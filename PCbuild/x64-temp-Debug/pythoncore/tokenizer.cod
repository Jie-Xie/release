; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@		; `string'
PUBLIC	??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@	; `string'
PUBLIC	??_C@_02MBMDLBEE@OP?$AA@			; `string'
PUBLIC	??_C@_08FHELOJEN@ELLIPSIS?$AA@			; `string'
PUBLIC	??_C@_06LPDGFLDK@RARROW?$AA@			; `string'
PUBLIC	??_C@_02KPDBFJEK@AT?$AA@			; `string'
PUBLIC	??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@	; `string'
PUBLIC	??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@		; `string'
PUBLIC	??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@		; `string'
PUBLIC	??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@		; `string'
PUBLIC	??_C@_09ICMHBFCA@VBAREQUAL?$AA@			; `string'
PUBLIC	??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@		; `string'
PUBLIC	??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@		; `string'
PUBLIC	??_C@_09LLDEOFJP@STAREQUAL?$AA@			; `string'
PUBLIC	??_C@_08JPGMLNCJ@MINEQUAL?$AA@			; `string'
PUBLIC	??_C@_09BJJNIKJA@PLUSEQUAL?$AA@			; `string'
PUBLIC	??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@		; `string'
PUBLIC	??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@		; `string'
PUBLIC	??_C@_09JKNLCHGF@LEFTSHIFT?$AA@			; `string'
PUBLIC	??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@		; `string'
PUBLIC	??_C@_05KHJOFHFM@TILDE?$AA@			; `string'
PUBLIC	??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@		; `string'
PUBLIC	??_C@_09EOMDFECK@LESSEQUAL?$AA@			; `string'
PUBLIC	??_C@_08KDCAELOL@NOTEQUAL?$AA@			; `string'
PUBLIC	??_C@_07PFKDGLNG@EQEQUAL?$AA@			; `string'
PUBLIC	??_C@_06KOAFIFC@RBRACE?$AA@			; `string'
PUBLIC	??_C@_06DNABLPMB@LBRACE?$AA@			; `string'
PUBLIC	??_C@_07IPMEJCHO@PERCENT?$AA@			; `string'
PUBLIC	??_C@_03GPNMLNCE@DOT?$AA@			; `string'
PUBLIC	??_C@_05MFJMDLJG@EQUAL?$AA@			; `string'
PUBLIC	??_C@_07INHKBBNC@GREATER?$AA@			; `string'
PUBLIC	??_C@_04PHHIILNL@LESS?$AA@			; `string'
PUBLIC	??_C@_05BPILGEDC@AMPER?$AA@			; `string'
PUBLIC	??_C@_04EGEGHKBO@VBAR?$AA@			; `string'
PUBLIC	??_C@_05CMNGPLPB@SLASH?$AA@			; `string'
PUBLIC	??_C@_04PLNEPNCN@STAR?$AA@			; `string'
PUBLIC	??_C@_05CIDCLABE@MINUS?$AA@			; `string'
PUBLIC	??_C@_04CLONMCGA@PLUS?$AA@			; `string'
PUBLIC	??_C@_04LDFNPPCJ@SEMI?$AA@			; `string'
PUBLIC	??_C@_05OFAMAJDB@COMMA?$AA@			; `string'
PUBLIC	??_C@_05NJKMKGPF@COLON?$AA@			; `string'
PUBLIC	??_C@_04NIHFNAF@RSQB?$AA@			; `string'
PUBLIC	??_C@_04NCFHHEOG@LSQB?$AA@			; `string'
PUBLIC	??_C@_04EJNGEDMK@RPAR?$AA@			; `string'
PUBLIC	??_C@_04JGAGGKCJ@LPAR?$AA@			; `string'
PUBLIC	??_C@_06CICIIECI@DEDENT?$AA@			; `string'
PUBLIC	??_C@_06CDDIBFCL@INDENT?$AA@			; `string'
PUBLIC	??_C@_07CNGHCLKN@NEWLINE?$AA@			; `string'
PUBLIC	??_C@_06IGECGLFO@STRING?$AA@			; `string'
PUBLIC	??_C@_06EFEGMLFC@NUMBER?$AA@			; `string'
PUBLIC	??_C@_04IPKHEEB@NAME?$AA@			; `string'
PUBLIC	??_C@_09MOKDLBPF@ENDMARKER?$AA@			; `string'
PUBLIC	_PyParser_TokenNames
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_readline@?1??fp_setreadl@@9@9 DQ 0000000000000000H ; `fp_setreadl'::`2'::PyId_readline
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	0000000000000000H
?PyId_open@?1??fp_setreadl@@9@9 DQ 0000000000000000H	; `fp_setreadl'::`2'::PyId_open
	DQ	FLAT:??_C@_04PMOCAHAA@open?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_PyParser_TokenNames DQ FLAT:??_C@_09MOKDLBPF@ENDMARKER?$AA@
	DQ	FLAT:??_C@_04IPKHEEB@NAME?$AA@
	DQ	FLAT:??_C@_06EFEGMLFC@NUMBER?$AA@
	DQ	FLAT:??_C@_06IGECGLFO@STRING?$AA@
	DQ	FLAT:??_C@_07CNGHCLKN@NEWLINE?$AA@
	DQ	FLAT:??_C@_06CDDIBFCL@INDENT?$AA@
	DQ	FLAT:??_C@_06CICIIECI@DEDENT?$AA@
	DQ	FLAT:??_C@_04JGAGGKCJ@LPAR?$AA@
	DQ	FLAT:??_C@_04EJNGEDMK@RPAR?$AA@
	DQ	FLAT:??_C@_04NCFHHEOG@LSQB?$AA@
	DQ	FLAT:??_C@_04NIHFNAF@RSQB?$AA@
	DQ	FLAT:??_C@_05NJKMKGPF@COLON?$AA@
	DQ	FLAT:??_C@_05OFAMAJDB@COMMA?$AA@
	DQ	FLAT:??_C@_04LDFNPPCJ@SEMI?$AA@
	DQ	FLAT:??_C@_04CLONMCGA@PLUS?$AA@
	DQ	FLAT:??_C@_05CIDCLABE@MINUS?$AA@
	DQ	FLAT:??_C@_04PLNEPNCN@STAR?$AA@
	DQ	FLAT:??_C@_05CMNGPLPB@SLASH?$AA@
	DQ	FLAT:??_C@_04EGEGHKBO@VBAR?$AA@
	DQ	FLAT:??_C@_05BPILGEDC@AMPER?$AA@
	DQ	FLAT:??_C@_04PHHIILNL@LESS?$AA@
	DQ	FLAT:??_C@_07INHKBBNC@GREATER?$AA@
	DQ	FLAT:??_C@_05MFJMDLJG@EQUAL?$AA@
	DQ	FLAT:??_C@_03GPNMLNCE@DOT?$AA@
	DQ	FLAT:??_C@_07IPMEJCHO@PERCENT?$AA@
	DQ	FLAT:??_C@_06DNABLPMB@LBRACE?$AA@
	DQ	FLAT:??_C@_06KOAFIFC@RBRACE?$AA@
	DQ	FLAT:??_C@_07PFKDGLNG@EQEQUAL?$AA@
	DQ	FLAT:??_C@_08KDCAELOL@NOTEQUAL?$AA@
	DQ	FLAT:??_C@_09EOMDFECK@LESSEQUAL?$AA@
	DQ	FLAT:??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@
	DQ	FLAT:??_C@_05KHJOFHFM@TILDE?$AA@
	DQ	FLAT:??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@
	DQ	FLAT:??_C@_09JKNLCHGF@LEFTSHIFT?$AA@
	DQ	FLAT:??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@
	DQ	FLAT:??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@
	DQ	FLAT:??_C@_09BJJNIKJA@PLUSEQUAL?$AA@
	DQ	FLAT:??_C@_08JPGMLNCJ@MINEQUAL?$AA@
	DQ	FLAT:??_C@_09LLDEOFJP@STAREQUAL?$AA@
	DQ	FLAT:??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@
	DQ	FLAT:??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@
	DQ	FLAT:??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@
	DQ	FLAT:??_C@_09ICMHBFCA@VBAREQUAL?$AA@
	DQ	FLAT:??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@
	DQ	FLAT:??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@
	DQ	FLAT:??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@
	DQ	FLAT:??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@
	DQ	FLAT:??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@
	DQ	FLAT:??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@
	DQ	FLAT:??_C@_02KPDBFJEK@AT?$AA@
	DQ	FLAT:??_C@_06LPDGFLDK@RARROW?$AA@
	DQ	FLAT:??_C@_08FHELOJEN@ELLIPSIS?$AA@
	DQ	FLAT:??_C@_02MBMDLBEE@OP?$AA@
	DQ	FLAT:??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@
	DQ	FLAT:??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@
CONST	SEGMENT
??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@ DB '<N_TOKENS>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@
CONST	SEGMENT
??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@ DB '<ERRORTOKEN>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBMDLBEE@OP?$AA@
CONST	SEGMENT
??_C@_02MBMDLBEE@OP?$AA@ DB 'OP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHELOJEN@ELLIPSIS?$AA@
CONST	SEGMENT
??_C@_08FHELOJEN@ELLIPSIS?$AA@ DB 'ELLIPSIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPDGFLDK@RARROW?$AA@
CONST	SEGMENT
??_C@_06LPDGFLDK@RARROW?$AA@ DB 'RARROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPDBFJEK@AT?$AA@
CONST	SEGMENT
??_C@_02KPDBFJEK@AT?$AA@ DB 'AT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@
CONST	SEGMENT
??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@ DB 'DOUBLESLASHEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@
CONST	SEGMENT
??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@ DB 'DOUBLESLASH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@ DB 'DOUBLESTAREQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@ DB 'RIGHTSHIFTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@
CONST	SEGMENT
??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@ DB 'LEFTSHIFTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@ DB 'CIRCUMFLEXEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICMHBFCA@VBAREQUAL?$AA@
CONST	SEGMENT
??_C@_09ICMHBFCA@VBAREQUAL?$AA@ DB 'VBAREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@
CONST	SEGMENT
??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@ DB 'AMPEREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@
CONST	SEGMENT
??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@ DB 'PERCENTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@
CONST	SEGMENT
??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@ DB 'SLASHEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLDEOFJP@STAREQUAL?$AA@
CONST	SEGMENT
??_C@_09LLDEOFJP@STAREQUAL?$AA@ DB 'STAREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPGMLNCJ@MINEQUAL?$AA@
CONST	SEGMENT
??_C@_08JPGMLNCJ@MINEQUAL?$AA@ DB 'MINEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BJJNIKJA@PLUSEQUAL?$AA@
CONST	SEGMENT
??_C@_09BJJNIKJA@PLUSEQUAL?$AA@ DB 'PLUSEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@
CONST	SEGMENT
??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@ DB 'DOUBLESTAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@
CONST	SEGMENT
??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@ DB 'RIGHTSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKNLCHGF@LEFTSHIFT?$AA@
CONST	SEGMENT
??_C@_09JKNLCHGF@LEFTSHIFT?$AA@ DB 'LEFTSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@
CONST	SEGMENT
??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@ DB 'CIRCUMFLEX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KHJOFHFM@TILDE?$AA@
CONST	SEGMENT
??_C@_05KHJOFHFM@TILDE?$AA@ DB 'TILDE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@
CONST	SEGMENT
??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@ DB 'GREATEREQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOMDFECK@LESSEQUAL?$AA@
CONST	SEGMENT
??_C@_09EOMDFECK@LESSEQUAL?$AA@ DB 'LESSEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDCAELOL@NOTEQUAL?$AA@
CONST	SEGMENT
??_C@_08KDCAELOL@NOTEQUAL?$AA@ DB 'NOTEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFKDGLNG@EQEQUAL?$AA@
CONST	SEGMENT
??_C@_07PFKDGLNG@EQEQUAL?$AA@ DB 'EQEQUAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOAFIFC@RBRACE?$AA@
CONST	SEGMENT
??_C@_06KOAFIFC@RBRACE?$AA@ DB 'RBRACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNABLPMB@LBRACE?$AA@
CONST	SEGMENT
??_C@_06DNABLPMB@LBRACE?$AA@ DB 'LBRACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPMEJCHO@PERCENT?$AA@
CONST	SEGMENT
??_C@_07IPMEJCHO@PERCENT?$AA@ DB 'PERCENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GPNMLNCE@DOT?$AA@
CONST	SEGMENT
??_C@_03GPNMLNCE@DOT?$AA@ DB 'DOT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFJMDLJG@EQUAL?$AA@
CONST	SEGMENT
??_C@_05MFJMDLJG@EQUAL?$AA@ DB 'EQUAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07INHKBBNC@GREATER?$AA@
CONST	SEGMENT
??_C@_07INHKBBNC@GREATER?$AA@ DB 'GREATER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHIILNL@LESS?$AA@
CONST	SEGMENT
??_C@_04PHHIILNL@LESS?$AA@ DB 'LESS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BPILGEDC@AMPER?$AA@
CONST	SEGMENT
??_C@_05BPILGEDC@AMPER?$AA@ DB 'AMPER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGEGHKBO@VBAR?$AA@
CONST	SEGMENT
??_C@_04EGEGHKBO@VBAR?$AA@ DB 'VBAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMNGPLPB@SLASH?$AA@
CONST	SEGMENT
??_C@_05CMNGPLPB@SLASH?$AA@ DB 'SLASH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLNEPNCN@STAR?$AA@
CONST	SEGMENT
??_C@_04PLNEPNCN@STAR?$AA@ DB 'STAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CIDCLABE@MINUS?$AA@
CONST	SEGMENT
??_C@_05CIDCLABE@MINUS?$AA@ DB 'MINUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLONMCGA@PLUS?$AA@
CONST	SEGMENT
??_C@_04CLONMCGA@PLUS?$AA@ DB 'PLUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDFNPPCJ@SEMI?$AA@
CONST	SEGMENT
??_C@_04LDFNPPCJ@SEMI?$AA@ DB 'SEMI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFAMAJDB@COMMA?$AA@
CONST	SEGMENT
??_C@_05OFAMAJDB@COMMA?$AA@ DB 'COMMA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJKMKGPF@COLON?$AA@
CONST	SEGMENT
??_C@_05NJKMKGPF@COLON?$AA@ DB 'COLON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIHFNAF@RSQB?$AA@
CONST	SEGMENT
??_C@_04NIHFNAF@RSQB?$AA@ DB 'RSQB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCFHHEOG@LSQB?$AA@
CONST	SEGMENT
??_C@_04NCFHHEOG@LSQB?$AA@ DB 'LSQB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EJNGEDMK@RPAR?$AA@
CONST	SEGMENT
??_C@_04EJNGEDMK@RPAR?$AA@ DB 'RPAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JGAGGKCJ@LPAR?$AA@
CONST	SEGMENT
??_C@_04JGAGGKCJ@LPAR?$AA@ DB 'LPAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CICIIECI@DEDENT?$AA@
CONST	SEGMENT
??_C@_06CICIIECI@DEDENT?$AA@ DB 'DEDENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDDIBFCL@INDENT?$AA@
CONST	SEGMENT
??_C@_06CDDIBFCL@INDENT?$AA@ DB 'INDENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNGHCLKN@NEWLINE?$AA@
CONST	SEGMENT
??_C@_07CNGHCLKN@NEWLINE?$AA@ DB 'NEWLINE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGECGLFO@STRING?$AA@
CONST	SEGMENT
??_C@_06IGECGLFO@STRING?$AA@ DB 'STRING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFEGMLFC@NUMBER?$AA@
CONST	SEGMENT
??_C@_06EFEGMLFC@NUMBER?$AA@ DB 'NUMBER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME?$AA@
CONST	SEGMENT
??_C@_04IPKHEEB@NAME?$AA@ DB 'NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOKDLBPF@ENDMARKER?$AA@
CONST	SEGMENT
??_C@_09MOKDLBPF@ENDMARKER?$AA@ DB 'ENDMARKER', 00H	; `string'
CONST	ENDS
PUBLIC	PyTokenizer_Free
PUBLIC	PyTokenizer_FromString
;	COMDAT pdata
; File c:\src\pyparallel\parser\tokenizer.c
pdata	SEGMENT
$pdata$PyTokenizer_FromString DD imagerel $LN5
	DD	imagerel $LN5+146
	DD	imagerel $unwind$PyTokenizer_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromString DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_FromString
_TEXT	SEGMENT
tok$ = 32
str$ = 64
exec_input$ = 72
PyTokenizer_FromString PROC				; COMDAT

; 798  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 799  :     struct tok_state *tok = tok_new();

  0000d	e8 00 00 00 00	 call	 tok_new
  00012	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 800  :     if (tok == NULL)

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0001d	75 04		 jne	 SHORT $LN2@PyTokenize

; 801  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 6a		 jmp	 SHORT $LN3@PyTokenize
$LN2@PyTokenize:

; 802  :     str = (char *)decode_str(str, exec_input, tok);

  00023	4c 8b 44 24 20	 mov	 r8, QWORD PTR tok$[rsp]
  00028	8b 54 24 48	 mov	 edx, DWORD PTR exec_input$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00031	e8 00 00 00 00	 call	 decode_str
  00036	48 89 44 24 40	 mov	 QWORD PTR str$[rsp], rax

; 803  :     if (str == NULL) {

  0003b	48 83 7c 24 40
	00		 cmp	 QWORD PTR str$[rsp], 0
  00041	75 0e		 jne	 SHORT $LN1@PyTokenize

; 804  :         PyTokenizer_Free(tok);

  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  00048	e8 00 00 00 00	 call	 PyTokenizer_Free

; 805  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 3c		 jmp	 SHORT $LN3@PyTokenize
$LN1@PyTokenize:

; 806  :     }
; 807  : 
; 808  :     /* XXX: constify members. */
; 809  :     tok->buf = tok->cur = tok->end = tok->inp = (char*)str;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  0005b	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00069	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00077	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00085	48 89 08	 mov	 QWORD PTR [rax], rcx

; 810  :     return tok;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
$LN3@PyTokenize:

; 811  : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
PyTokenizer_FromString ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_new DD imagerel tok_new
	DD	imagerel tok_new+513
	DD	imagerel $unwind$tok_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_new DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tok_new
_TEXT	SEGMENT
tok$ = 32
tv70 = 40
tok_new	PROC						; COMDAT

; 114  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 115  :     struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(
; 116  :                                             sizeof(struct tok_state));

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 11		 je	 SHORT $LN4@tok_new
  0000d	b9 e0 03 00 00	 mov	 ecx, 992		; 000003e0H
  00012	e8 00 00 00 00	 call	 _PxMem_Malloc
  00017	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  0001c	eb 0f		 jmp	 SHORT $LN5@tok_new
$LN4@tok_new:
  0001e	b9 e0 03 00 00	 mov	 ecx, 992		; 000003e0H
  00023	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00028	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@tok_new:
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00032	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 117  :     if (tok == NULL)

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0003d	75 07		 jne	 SHORT $LN1@tok_new

; 118  :         return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 b6 01 00 00	 jmp	 $LN2@tok_new
$LN1@tok_new:

; 119  :     tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0004b	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00058	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00065	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00072	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0007a	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0007f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 120  :     tok->done = E_OK;

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0008b	c7 40 28 0a 00
	00 00		 mov	 DWORD PTR [rax+40], 10

; 121  :     tok->fp = NULL;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00097	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 122  :     tok->input = NULL;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000a4	48 c7 80 d8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+984], 0

; 123  :     tok->tabsize = TABSIZE;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000b4	c7 40 38 08 00
	00 00		 mov	 DWORD PTR [rax+56], 8

; 124  :     tok->indent = 0;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000c0	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0

; 125  :     tok->indstack[0] = 0;

  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000cc	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 126  :     tok->atbol = 1;

  000d3	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000d8	c7 80 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+464], 1

; 127  :     tok->pendin = 0;

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000e7	c7 80 d4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+468], 0

; 128  :     tok->prompt = tok->nextprompt = NULL;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000f6	48 c7 80 e0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+480], 0
  00101	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00106	48 c7 80 d8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+472], 0

; 129  :     tok->lineno = 0;

  00111	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00116	c7 80 e8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+488], 0

; 130  :     tok->level = 0;

  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00125	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 131  :     tok->altwarning = 1;

  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00134	c7 80 f8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+504], 1

; 132  :     tok->alterror = 1;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00143	c7 80 fc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+508], 1

; 133  :     tok->alttabsize = 1;

  0014d	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00152	c7 80 00 02 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+512], 1

; 134  :     tok->altindstack[0] = 0;

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00161	c7 80 04 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+516], 0

; 135  :     tok->decoding_state = STATE_INIT;

  0016b	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00170	c7 80 94 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+916], 0

; 136  :     tok->decoding_erred = 0;

  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0017f	c7 80 98 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+920], 0

; 137  :     tok->read_coding_spec = 0;

  00189	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0018e	c7 80 9c 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+924], 0

; 138  :     tok->enc = NULL;

  00198	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0019d	48 c7 80 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+968], 0

; 139  :     tok->encoding = NULL;

  001a8	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001ad	48 c7 80 a0 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+928], 0

; 140  :     tok->cont_line = 0;

  001b8	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001bd	c7 80 a8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+936], 0

; 141  : #ifndef PGEN
; 142  :     tok->filename = NULL;

  001c7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001cc	48 c7 80 f0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+496], 0

; 143  :     tok->decoding_readline = NULL;

  001d7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001dc	48 c7 80 b8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+952], 0

; 144  :     tok->decoding_buffer = NULL;

  001e7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001ec	48 c7 80 c0 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+960], 0

; 145  : #endif
; 146  :     return tok;

  001f7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
$LN2@tok_new:

; 147  : }

  001fc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00200	c3		 ret	 0
tok_new	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DK@JEOCILEP@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@CFDMCMDN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAt?$AAf?$AA8?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@HAIFGJGF@?$AAu?$AAt?$AAf?$AA8?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@EHJCIEJE@?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_17OJIHJBCF@?$AAs?$AAt?$AAr?$AA?$AA@	; `string'
PUBLIC	??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_str DD imagerel decode_str
	DD	imagerel decode_str+879
	DD	imagerel $unwind$decode_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_str DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT ??_C@_1DK@JEOCILEP@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@JEOCILEP@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, '-', 00H, '>', 00H, 'd', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@CFDMCMDN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAt?$AAf?$AA8?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@CFDMCMDN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAt?$AAf?$AA8?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'u', 00H, 't', 00H, 'f', 00H, '8', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@HAIFGJGF@?$AAu?$AAt?$AAf?$AA8?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@HAIFGJGF@?$AAu?$AAt?$AAf?$AA8?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'u'
	DB	00H, 't', 00H, 'f', 00H, '8', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@EHJCIEJE@?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@EHJCIEJE@?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AA2?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 'n', 00H, 'e', 00H, 'n', 00H, 'o', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '2', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_17OJIHJBCF@?$AAs?$AAt?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_17OJIHJBCF@?$AAs?$AAt?$AAr?$AA?$AA@ DB 's', 00H, 't', 00H, 'r', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 't', 00H, 'o', 00H, 'k', 00H, 'e'
	DB	00H, 'n', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'r', 00H, '.', 00H
	DB	'c', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT decode_str
_TEXT	SEGMENT
lineno$ = 32
newl$ = 40
s$ = 56
utf8$ = 64
str$ = 72
input$ = 96
single$ = 104
tok$ = 112
decode_str PROC						; COMDAT

; 738  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 739  :     PyObject* utf8 = NULL;

  00012	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR utf8$[rsp], 0

; 740  :     const char *str;
; 741  :     const char *s;
; 742  :     const char *newl[2] = {NULL, NULL};

  0001b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR newl$[rsp], 0
  00024	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR newl$[rsp+8], 0

; 743  :     int lineno = 0;

  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR lineno$[rsp], 0

; 744  :     tok->input = str = translate_newlines(input, single, tok);

  00035	4c 8b 44 24 70	 mov	 r8, QWORD PTR tok$[rsp]
  0003a	8b 54 24 68	 mov	 edx, DWORD PTR single$[rsp]
  0003e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR input$[rsp]
  00043	e8 00 00 00 00	 call	 translate_newlines
  00048	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax
  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00052	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00057	48 89 88 d8 03
	00 00		 mov	 QWORD PTR [rax+984], rcx

; 745  :     if (str == NULL)

  0005e	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  00064	75 07		 jne	 SHORT $LN17@decode_str

; 746  :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 fd 02 00 00	 jmp	 $LN18@decode_str
$LN17@decode_str:

; 747  :     tok->enc = NULL;

  0006d	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00072	48 c7 80 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+968], 0

; 748  :     tok->str = str;

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00087	48 89 88 d0 03
	00 00		 mov	 QWORD PTR [rax+976], rcx

; 749  :     if (!check_bom(buf_getc, buf_ungetc, buf_setreadl, tok))

  0008e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tok$[rsp]
  00093	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:buf_setreadl
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf_ungetc
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf_getc
  000a8	e8 00 00 00 00	 call	 check_bom
  000ad	85 c0		 test	 eax, eax
  000af	75 0f		 jne	 SHORT $LN16@decode_str

; 750  :         return error_ret(tok);

  000b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  000b6	e8 00 00 00 00	 call	 error_ret
  000bb	e9 aa 02 00 00	 jmp	 $LN18@decode_str
$LN16@decode_str:

; 751  :     str = tok->str;             /* string after BOM if any */

  000c0	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  000c5	48 8b 80 d0 03
	00 00		 mov	 rax, QWORD PTR [rax+976]
  000cc	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax

; 752  :     assert(str);

  000d1	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$[rsp], 0
  000d7	75 1c		 jne	 SHORT $LN20@decode_str
  000d9	41 b8 f0 02 00
	00		 mov	 r8d, 752		; 000002f0H
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_17OJIHJBCF@?$AAs?$AAt?$AAr?$AA?$AA@
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f3	33 c0		 xor	 eax, eax
$LN20@decode_str:

; 753  :     if (tok->enc != NULL) {

  000f5	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  000fa	48 83 b8 c8 03
	00 00 00	 cmp	 QWORD PTR [rax+968], 0
  00102	74 41		 je	 SHORT $LN15@decode_str

; 754  :         utf8 = translate_into_utf8(str, tok->enc);

  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00109	48 8b 90 c8 03
	00 00		 mov	 rdx, QWORD PTR [rax+968]
  00110	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00115	e8 00 00 00 00	 call	 translate_into_utf8
  0011a	48 89 44 24 40	 mov	 QWORD PTR utf8$[rsp], rax

; 755  :         if (utf8 == NULL)

  0011f	48 83 7c 24 40
	00		 cmp	 QWORD PTR utf8$[rsp], 0
  00125	75 0f		 jne	 SHORT $LN14@decode_str

; 756  :             return error_ret(tok);

  00127	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  0012c	e8 00 00 00 00	 call	 error_ret
  00131	e9 34 02 00 00	 jmp	 $LN18@decode_str
$LN14@decode_str:

; 757  :         str = PyBytes_AsString(utf8);

  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR utf8$[rsp]
  0013b	e8 00 00 00 00	 call	 PyBytes_AsString
  00140	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax
$LN15@decode_str:

; 758  :     }
; 759  :     for (s = str;; s++) {

  00145	48 8b 44 24 48	 mov	 rax, QWORD PTR str$[rsp]
  0014a	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
  0014f	eb 0d		 jmp	 SHORT $LN13@decode_str
$LN12@decode_str:
  00151	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00156	48 ff c0	 inc	 rax
  00159	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
$LN13@decode_str:

; 760  :         if (*s == '\0') break;

  0015e	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00163	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00166	85 c0		 test	 eax, eax
  00168	75 04		 jne	 SHORT $LN10@decode_str
  0016a	eb 56		 jmp	 SHORT $LN11@decode_str
  0016c	eb 52		 jmp	 SHORT $LN9@decode_str
$LN10@decode_str:

; 761  :         else if (*s == '\n') {

  0016e	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00173	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00176	83 f8 0a	 cmp	 eax, 10
  00179	75 45		 jne	 SHORT $LN8@decode_str

; 762  :             assert(lineno < 2);

  0017b	83 7c 24 20 02	 cmp	 DWORD PTR lineno$[rsp], 2
  00180	7c 1c		 jl	 SHORT $LN21@decode_str
  00182	41 b8 fa 02 00
	00		 mov	 r8d, 762		; 000002faH
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@EHJCIEJE@?$AAl?$AAi?$AAn?$AAe?$AAn?$AAo?$AA?5?$AA?$DM?$AA?5?$AA2?$AA?$AA@
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019c	33 c0		 xor	 eax, eax
$LN21@decode_str:

; 763  :             newl[lineno] = s;

  0019e	48 63 44 24 20	 movsxd	 rax, DWORD PTR lineno$[rsp]
  001a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  001a8	48 89 4c c4 28	 mov	 QWORD PTR newl$[rsp+rax*8], rcx

; 764  :             lineno++;

  001ad	8b 44 24 20	 mov	 eax, DWORD PTR lineno$[rsp]
  001b1	ff c0		 inc	 eax
  001b3	89 44 24 20	 mov	 DWORD PTR lineno$[rsp], eax

; 765  :             if (lineno == 2) break;

  001b7	83 7c 24 20 02	 cmp	 DWORD PTR lineno$[rsp], 2
  001bc	75 02		 jne	 SHORT $LN7@decode_str
  001be	eb 02		 jmp	 SHORT $LN11@decode_str
$LN7@decode_str:
$LN8@decode_str:
$LN9@decode_str:

; 766  :         }
; 767  :     }

  001c0	eb 8f		 jmp	 SHORT $LN12@decode_str
$LN11@decode_str:

; 768  :     tok->enc = NULL;

  001c2	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001c7	48 c7 80 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+968], 0

; 769  :     /* need to check line 1 and 2 separately since check_coding_spec
; 770  :        assumes a single line as input */
; 771  :     if (newl[0]) {

  001d2	48 83 7c 24 28
	00		 cmp	 QWORD PTR newl$[rsp], 0
  001d8	0f 84 a0 00 00
	00		 je	 $LN6@decode_str

; 772  :         if (!check_coding_spec(str, newl[0] - str, tok, buf_setreadl))

  001de	48 8b 44 24 48	 mov	 rax, QWORD PTR str$[rsp]
  001e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newl$[rsp]
  001e8	48 2b c8	 sub	 rcx, rax
  001eb	48 8b c1	 mov	 rax, rcx
  001ee	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:buf_setreadl
  001f5	4c 8b 44 24 70	 mov	 r8, QWORD PTR tok$[rsp]
  001fa	48 8b d0	 mov	 rdx, rax
  001fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  00202	e8 00 00 00 00	 call	 check_coding_spec
  00207	85 c0		 test	 eax, eax
  00209	75 0f		 jne	 SHORT $LN5@decode_str

; 773  :             return error_ret(tok);

  0020b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  00210	e8 00 00 00 00	 call	 error_ret
  00215	e9 50 01 00 00	 jmp	 $LN18@decode_str
$LN5@decode_str:

; 774  :         if (tok->enc == NULL && !tok->read_coding_spec && newl[1]) {

  0021a	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  0021f	48 83 b8 c8 03
	00 00 00	 cmp	 QWORD PTR [rax+968], 0
  00227	75 55		 jne	 SHORT $LN4@decode_str
  00229	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  0022e	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  00235	75 47		 jne	 SHORT $LN4@decode_str
  00237	48 83 7c 24 30
	00		 cmp	 QWORD PTR newl$[rsp+8], 0
  0023d	74 3f		 je	 SHORT $LN4@decode_str

; 775  :             if (!check_coding_spec(newl[0]+1, newl[1] - newl[0],
; 776  :                                    tok, buf_setreadl))

  0023f	48 8b 44 24 28	 mov	 rax, QWORD PTR newl$[rsp]
  00244	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newl$[rsp+8]
  00249	48 2b c8	 sub	 rcx, rax
  0024c	48 8b c1	 mov	 rax, rcx
  0024f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newl$[rsp]
  00254	48 ff c1	 inc	 rcx
  00257	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:buf_setreadl
  0025e	4c 8b 44 24 70	 mov	 r8, QWORD PTR tok$[rsp]
  00263	48 8b d0	 mov	 rdx, rax
  00266	e8 00 00 00 00	 call	 check_coding_spec
  0026b	85 c0		 test	 eax, eax
  0026d	75 0f		 jne	 SHORT $LN3@decode_str

; 777  :                 return error_ret(tok);

  0026f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  00274	e8 00 00 00 00	 call	 error_ret
  00279	e9 ec 00 00 00	 jmp	 $LN18@decode_str
$LN3@decode_str:
$LN4@decode_str:
$LN6@decode_str:

; 778  :         }
; 779  :     }
; 780  :     if (tok->enc != NULL) {

  0027e	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00283	48 83 b8 c8 03
	00 00 00	 cmp	 QWORD PTR [rax+968], 0
  0028b	0f 84 98 00 00
	00		 je	 $LN2@decode_str

; 781  :         assert(utf8 == NULL);

  00291	48 83 7c 24 40
	00		 cmp	 QWORD PTR utf8$[rsp], 0
  00297	74 1c		 je	 SHORT $LN22@decode_str
  00299	41 b8 0d 03 00
	00		 mov	 r8d, 781		; 0000030dH
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@HAIFGJGF@?$AAu?$AAt?$AAf?$AA8?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b3	33 c0		 xor	 eax, eax
$LN22@decode_str:

; 782  :         utf8 = translate_into_utf8(str, tok->enc);

  002b5	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  002ba	48 8b 90 c8 03
	00 00		 mov	 rdx, QWORD PTR [rax+968]
  002c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$[rsp]
  002c6	e8 00 00 00 00	 call	 translate_into_utf8
  002cb	48 89 44 24 40	 mov	 QWORD PTR utf8$[rsp], rax

; 783  :         if (utf8 == NULL)

  002d0	48 83 7c 24 40
	00		 cmp	 QWORD PTR utf8$[rsp], 0
  002d6	75 0f		 jne	 SHORT $LN1@decode_str

; 784  :             return error_ret(tok);

  002d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  002dd	e8 00 00 00 00	 call	 error_ret
  002e2	e9 83 00 00 00	 jmp	 $LN18@decode_str
$LN1@decode_str:

; 785  :         str = PyBytes_AS_STRING(utf8);

  002e7	48 8b 44 24 40	 mov	 rax, QWORD PTR utf8$[rsp]
  002ec	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002f0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002f6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002fb	85 c0		 test	 eax, eax
  002fd	75 1c		 jne	 SHORT $LN23@decode_str
  002ff	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  00305	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@CFDMCMDN@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAt?$AAf?$AA8?$AA?$CJ?$AA?$AA@
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00319	33 c0		 xor	 eax, eax
$LN23@decode_str:
  0031b	48 8b 44 24 40	 mov	 rax, QWORD PTR utf8$[rsp]
  00320	48 83 c0 78	 add	 rax, 120		; 00000078H
  00324	48 89 44 24 48	 mov	 QWORD PTR str$[rsp], rax
$LN2@decode_str:

; 786  :     }
; 787  :     assert(tok->decoding_buffer == NULL);

  00329	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  0032e	48 83 b8 c0 03
	00 00 00	 cmp	 QWORD PTR [rax+960], 0
  00336	74 1c		 je	 SHORT $LN24@decode_str
  00338	41 b8 13 03 00
	00		 mov	 r8d, 787		; 00000313H
  0033e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@JEOCILEP@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00352	33 c0		 xor	 eax, eax
$LN24@decode_str:

; 788  :     tok->decoding_buffer = utf8; /* CAUTION */

  00354	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00359	48 8b 4c 24 40	 mov	 rcx, QWORD PTR utf8$[rsp]
  0035e	48 89 88 c0 03
	00 00		 mov	 QWORD PTR [rax+960], rcx

; 789  :     return str;

  00365	48 8b 44 24 48	 mov	 rax, QWORD PTR str$[rsp]
$LN18@decode_str:

; 790  : }

  0036a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0036e	c3		 ret	 0
decode_str ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$error_ret DD imagerel error_ret
	DD	imagerel error_ret+119
	DD	imagerel $unwind$error_ret
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$error_ret DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT error_ret
_TEXT	SEGMENT
tv72 = 32
tok$ = 64
error_ret PROC						; COMDAT

; 186  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 187  :     tok->decoding_erred = 1;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	c7 80 98 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+920], 1

; 188  :     if (tok->fp != NULL && tok->buf != NULL) /* see PyTokenizer_Free */

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0001d	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00022	74 40		 je	 SHORT $LN1@error_ret
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00029	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002d	74 35		 je	 SHORT $LN1@error_ret

; 189  :         PyMem_FREE(tok->buf);

  0002f	e8 00 00 00 00	 call	 _Py_PXCTX
  00034	85 c0		 test	 eax, eax
  00036	74 17		 je	 SHORT $LN4@error_ret
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0003d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00040	e8 00 00 00 00	 call	 _PxMem_Free
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  0004d	eb 15		 jmp	 SHORT $LN5@error_ret
$LN4@error_ret:
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00057	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0005c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN5@error_ret:
$LN1@error_ret:

; 190  :     tok->buf = NULL;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00069	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 191  :     return NULL;                /* as if it were EOF */

  00070	33 c0		 xor	 eax, eax

; 192  : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
error_ret ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@ ; `string'
PUBLIC	??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_1EC@FKAMIMJ@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAR?$AAA?$AAW@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	strcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_coding_spec DD imagerel check_coding_spec
	DD	imagerel check_coding_spec+730
	DD	imagerel $unwind$check_coding_spec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_coding_spec DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@
CONST	SEGMENT
??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@ DB 'encodin'
	DB	'g problem: %s with BOM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@ DB 'encoding problem: '
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@FKAMIMJ@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAR?$AAA?$AAW@
CONST	SEGMENT
??_C@_1EC@FKAMIMJ@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAR?$AAA?$AAW@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, '-', 00H, '>', 00H, 'd', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T'
	DB	00H, 'E', 00H, '_', 00H, 'R', 00H, 'A', 00H, 'W', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_coding_spec
_TEXT	SEGMENT
cs$ = 32
r$ = 40
i$20675 = 48
tv154 = 56
tv160 = 60
tv169 = 64
line$ = 96
size$ = 104
tok$ = 112
set_readline$ = 120
check_coding_spec PROC					; COMDAT

; 282  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 283  :     char *cs;
; 284  :     int r = 1;

  00018	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR r$[rsp], 1

; 285  : 
; 286  :     if (tok->cont_line) {

  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00025	83 b8 a8 03 00
	00 00		 cmp	 DWORD PTR [rax+936], 0
  0002c	74 19		 je	 SHORT $LN16@check_codi

; 287  :         /* It's a continuation line, so it can't be a coding spec. */
; 288  :         tok->read_coding_spec = 1;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00033	c7 80 9c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+924], 1

; 289  :         return 1;

  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	e9 8e 02 00 00	 jmp	 $LN17@check_codi
$LN16@check_codi:

; 290  :     }
; 291  :     if (!get_coding_spec(line, &cs, size, tok))

  00047	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tok$[rsp]
  0004c	4c 8b 44 24 68	 mov	 r8, QWORD PTR size$[rsp]
  00051	48 8d 54 24 20	 lea	 rdx, QWORD PTR cs$[rsp]
  00056	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  0005b	e8 00 00 00 00	 call	 get_coding_spec
  00060	85 c0		 test	 eax, eax
  00062	75 07		 jne	 SHORT $LN15@check_codi

; 292  :         return 0;

  00064	33 c0		 xor	 eax, eax
  00066	e9 6a 02 00 00	 jmp	 $LN17@check_codi
$LN15@check_codi:

; 293  :     if (!cs) {

  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR cs$[rsp], 0
  00071	0f 85 da 00 00
	00		 jne	 $LN14@check_codi

; 294  :         Py_ssize_t i;
; 295  :         for (i = 0; i < size; i++) {

  00077	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$20675[rsp], 0
  00080	eb 0d		 jmp	 SHORT $LN13@check_codi
$LN12@check_codi:
  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  00087	48 ff c0	 inc	 rax
  0008a	48 89 44 24 30	 mov	 QWORD PTR i$20675[rsp], rax
$LN13@check_codi:
  0008f	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  00094	48 39 44 24 30	 cmp	 QWORD PTR i$20675[rsp], rax
  00099	0f 8d a8 00 00
	00		 jge	 $LN11@check_codi

; 296  :             if (line[i] == '#' || line[i] == '\n' || line[i] == '\r')

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  000a9	48 03 c8	 add	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b2	83 f8 23	 cmp	 eax, 35			; 00000023H
  000b5	74 30		 je	 SHORT $LN9@check_codi
  000b7	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  000bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  000c1	48 03 c8	 add	 rcx, rax
  000c4	48 8b c1	 mov	 rax, rcx
  000c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ca	83 f8 0a	 cmp	 eax, 10
  000cd	74 18		 je	 SHORT $LN9@check_codi
  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  000d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  000d9	48 03 c8	 add	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000e2	83 f8 0d	 cmp	 eax, 13
  000e5	75 02		 jne	 SHORT $LN10@check_codi
$LN9@check_codi:

; 297  :                 break;

  000e7	eb 5e		 jmp	 SHORT $LN11@check_codi
$LN10@check_codi:

; 298  :             if (line[i] != ' ' && line[i] != '\t' && line[i] != '\014') {

  000e9	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  000f3	48 03 c8	 add	 rcx, rax
  000f6	48 8b c1	 mov	 rax, rcx
  000f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fc	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ff	74 41		 je	 SHORT $LN8@check_codi
  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  0010b	48 03 c8	 add	 rcx, rax
  0010e	48 8b c1	 mov	 rax, rcx
  00111	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00114	83 f8 09	 cmp	 eax, 9
  00117	74 29		 je	 SHORT $LN8@check_codi
  00119	48 8b 44 24 30	 mov	 rax, QWORD PTR i$20675[rsp]
  0011e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR line$[rsp]
  00123	48 03 c8	 add	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012c	83 f8 0c	 cmp	 eax, 12
  0012f	74 11		 je	 SHORT $LN8@check_codi

; 299  :                 /* Stop checking coding spec after a line containing
; 300  :                  * anything except a comment. */
; 301  :                 tok->read_coding_spec = 1;

  00131	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00136	c7 80 9c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+924], 1

; 302  :                 break;

  00140	eb 05		 jmp	 SHORT $LN11@check_codi
$LN8@check_codi:

; 303  :             }
; 304  :         }

  00142	e9 3b ff ff ff	 jmp	 $LN12@check_codi
$LN11@check_codi:

; 305  :         return 1;

  00147	b8 01 00 00 00	 mov	 eax, 1
  0014c	e9 84 01 00 00	 jmp	 $LN17@check_codi
$LN14@check_codi:

; 306  :     }
; 307  :     tok->read_coding_spec = 1;

  00151	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00156	c7 80 9c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+924], 1

; 308  :     if (tok->encoding == NULL) {

  00160	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00165	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  0016d	0f 85 dc 00 00
	00		 jne	 $LN7@check_codi

; 309  :         assert(tok->decoding_state == STATE_RAW);

  00173	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00178	83 b8 94 03 00
	00 01		 cmp	 DWORD PTR [rax+916], 1
  0017f	74 1c		 je	 SHORT $LN19@check_codi
  00181	41 b8 35 01 00
	00		 mov	 r8d, 309		; 00000135H
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@FKAMIMJ@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAR?$AAA?$AAW@
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0019b	33 c0		 xor	 eax, eax
$LN19@check_codi:

; 310  :         if (strcmp(cs, "utf-8") == 0) {

  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  001a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  001a9	e8 00 00 00 00	 call	 strcmp
  001ae	85 c0		 test	 eax, eax
  001b0	75 16		 jne	 SHORT $LN6@check_codi

; 311  :             tok->encoding = cs;

  001b2	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  001bc	48 89 88 a0 03
	00 00		 mov	 QWORD PTR [rax+928], rcx

; 312  :         } else {

  001c3	e9 82 00 00 00	 jmp	 $LN5@check_codi
$LN6@check_codi:

; 313  :             r = set_readline(tok, cs);

  001c8	48 8b 54 24 20	 mov	 rdx, QWORD PTR cs$[rsp]
  001cd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  001d2	ff 54 24 78	 call	 QWORD PTR set_readline$[rsp]
  001d6	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 314  :             if (r) {

  001da	83 7c 24 28 00	 cmp	 DWORD PTR r$[rsp], 0
  001df	74 22		 je	 SHORT $LN4@check_codi

; 315  :                 tok->encoding = cs;

  001e1	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  001eb	48 89 88 a0 03
	00 00		 mov	 QWORD PTR [rax+928], rcx

; 316  :                 tok->decoding_state = STATE_NORMAL;

  001f2	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001f7	c7 80 94 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+916], 2

; 317  :             }
; 318  :             else {

  00201	eb 47		 jmp	 SHORT $LN3@check_codi
$LN4@check_codi:

; 319  :                 PyErr_Format(PyExc_SyntaxError,
; 320  :                              "encoding problem: %s", cs);

  00203	4c 8b 44 24 20	 mov	 r8, QWORD PTR cs$[rsp]
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@
  0020f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00216	e8 00 00 00 00	 call	 PyErr_Format

; 321  :                 PyMem_FREE(cs);

  0021b	e8 00 00 00 00	 call	 _Py_PXCTX
  00220	85 c0		 test	 eax, eax
  00222	74 14		 je	 SHORT $LN20@check_codi
  00224	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  00229	e8 00 00 00 00	 call	 _PxMem_Free
  0022e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
  00236	eb 12		 jmp	 SHORT $LN21@check_codi
$LN20@check_codi:
  00238	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  0023d	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00242	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN21@check_codi:
$LN3@check_codi:
$LN5@check_codi:

; 322  :             }
; 323  :         }
; 324  :     } else {                /* then, compare cs with BOM */

  0024a	e9 82 00 00 00	 jmp	 $LN2@check_codi
$LN7@check_codi:

; 325  :         r = (strcmp(tok->encoding, cs) == 0);

  0024f	48 8b 54 24 20	 mov	 rdx, QWORD PTR cs$[rsp]
  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00259	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00260	e8 00 00 00 00	 call	 strcmp
  00265	85 c0		 test	 eax, eax
  00267	75 0a		 jne	 SHORT $LN22@check_codi
  00269	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00271	eb 08		 jmp	 SHORT $LN23@check_codi
$LN22@check_codi:
  00273	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN23@check_codi:
  0027b	8b 44 24 3c	 mov	 eax, DWORD PTR tv160[rsp]
  0027f	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 326  :         if (!r)

  00283	83 7c 24 28 00	 cmp	 DWORD PTR r$[rsp], 0
  00288	75 18		 jne	 SHORT $LN1@check_codi

; 327  :             PyErr_Format(PyExc_SyntaxError,
; 328  :                          "encoding problem: %s with BOM", cs);

  0028a	4c 8b 44 24 20	 mov	 r8, QWORD PTR cs$[rsp]
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@
  00296	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  0029d	e8 00 00 00 00	 call	 PyErr_Format
$LN1@check_codi:

; 329  :         PyMem_FREE(cs);

  002a2	e8 00 00 00 00	 call	 _Py_PXCTX
  002a7	85 c0		 test	 eax, eax
  002a9	74 14		 je	 SHORT $LN24@check_codi
  002ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  002b0	e8 00 00 00 00	 call	 _PxMem_Free
  002b5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
  002bd	eb 12		 jmp	 SHORT $LN25@check_codi
$LN24@check_codi:
  002bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cs$[rsp]
  002c4	e8 00 00 00 00	 call	 _PyMem_DebugFree
  002c9	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN25@check_codi:
$LN2@check_codi:

; 330  :     }
; 331  :     return r;

  002d1	8b 44 24 28	 mov	 eax, DWORD PTR r$[rsp]
$LN17@check_codi:

; 332  : }

  002d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002d9	c3		 ret	 0
check_coding_spec ENDP
_TEXT	ENDS
PUBLIC	??_C@_06GDAGLJDI@coding?$AA@			; `string'
EXTRN	strlen:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	__imp_strncmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_coding_spec DD imagerel get_coding_spec
	DD	imagerel get_coding_spec+684
	DD	imagerel $unwind$get_coding_spec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_coding_spec DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_06GDAGLJDI@coding?$AA@
CONST	SEGMENT
??_C@_06GDAGLJDI@coding?$AA@ DB 'coding', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_coding_spec
_TEXT	SEGMENT
i$ = 32
t$20638 = 40
begin$20641 = 48
q$20654 = 56
r$20653 = 64
tv159 = 72
s$ = 96
spec$ = 104
size$ = 112
tok$ = 120
get_coding_spec PROC					; COMDAT

; 228  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 229  :     Py_ssize_t i;
; 230  :     *spec = NULL;

  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR spec$[rsp]
  0001d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 231  :     /* Coding spec must be in a comment, and that comment must be
; 232  :      * the only statement on the source code line. */
; 233  :     for (i = 0; i < size - 6; i++) {

  00024	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0002d	eb 0d		 jmp	 SHORT $LN20@get_coding
$LN19@get_coding:
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00034	48 ff c0	 inc	 rax
  00037	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN20@get_coding:
  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR size$[rsp]
  00041	48 83 e8 06	 sub	 rax, 6
  00045	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0004a	7d 71		 jge	 SHORT $LN18@get_coding

; 234  :         if (s[i] == '#')

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005f	83 f8 23	 cmp	 eax, 35			; 00000023H
  00062	75 02		 jne	 SHORT $LN17@get_coding

; 235  :             break;

  00064	eb 57		 jmp	 SHORT $LN18@get_coding
$LN17@get_coding:

; 236  :         if (s[i] != ' ' && s[i] != '\t' && s[i] != '\014')

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0006b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00079	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007c	74 3a		 je	 SHORT $LN16@get_coding
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00091	83 f8 09	 cmp	 eax, 9
  00094	74 22		 je	 SHORT $LN16@get_coding
  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000a0	48 03 c8	 add	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a9	83 f8 0c	 cmp	 eax, 12
  000ac	74 0a		 je	 SHORT $LN16@get_coding

; 237  :             return 1;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	e9 ef 01 00 00	 jmp	 $LN21@get_coding
$LN16@get_coding:

; 238  :     }

  000b8	e9 72 ff ff ff	 jmp	 $LN19@get_coding
$LN18@get_coding:

; 239  :     for (; i < size - 6; i++) { /* XXX inefficient search */

  000bd	eb 0d		 jmp	 SHORT $LN15@get_coding
$LN14@get_coding:
  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000c4	48 ff c0	 inc	 rax
  000c7	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN15@get_coding:
  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR size$[rsp]
  000d1	48 83 e8 06	 sub	 rax, 6
  000d5	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  000da	0f 8d c2 01 00
	00		 jge	 $LN13@get_coding

; 240  :         const char* t = s + i;

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  000e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ea	48 03 c8	 add	 rcx, rax
  000ed	48 8b c1	 mov	 rax, rcx
  000f0	48 89 44 24 28	 mov	 QWORD PTR t$20638[rsp], rax

; 241  :         if (strncmp(t, "coding", 6) == 0) {

  000f5	41 b8 06 00 00
	00		 mov	 r8d, 6
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GDAGLJDI@coding?$AA@
  00102	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$20638[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 88 01 00
	00		 jne	 $LN12@get_coding

; 242  :             const char* begin = NULL;

  00115	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR begin$20641[rsp], 0

; 243  :             t += 6;

  0011e	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  00123	48 83 c0 06	 add	 rax, 6
  00127	48 89 44 24 28	 mov	 QWORD PTR t$20638[rsp], rax

; 244  :             if (t[0] != ':' && t[0] != '=')

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  00131	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00134	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00137	74 12		 je	 SHORT $LN11@get_coding
  00139	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  0013e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00141	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00144	74 05		 je	 SHORT $LN11@get_coding

; 245  :                 continue;

  00146	e9 74 ff ff ff	 jmp	 $LN14@get_coding
$LN11@get_coding:
$LN25@get_coding:
$LN10@get_coding:

; 246  :             do {
; 247  :                 t++;

  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  00150	48 ff c0	 inc	 rax
  00153	48 89 44 24 28	 mov	 QWORD PTR t$20638[rsp], rax

; 248  :             } while (t[0] == '\x20' || t[0] == '\t');

  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  0015d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00160	83 f8 20	 cmp	 eax, 32			; 00000020H
  00163	74 e6		 je	 SHORT $LN10@get_coding
  00165	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  0016a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0016d	83 f8 09	 cmp	 eax, 9
  00170	74 d9		 je	 SHORT $LN25@get_coding

; 249  : 
; 250  :             begin = t;

  00172	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  00177	48 89 44 24 30	 mov	 QWORD PTR begin$20641[rsp], rax
$LN7@get_coding:

; 251  :             while (Py_ISALNUM(t[0]) ||
; 252  :                    t[0] == '-' || t[0] == '_' || t[0] == '.')

  0017c	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  00181	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00184	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00189	0f b6 c0	 movzx	 eax, al
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00193	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00196	83 e0 07	 and	 eax, 7
  00199	85 c0		 test	 eax, eax
  0019b	75 27		 jne	 SHORT $LN5@get_coding
  0019d	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  001a2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a5	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001a8	74 1a		 je	 SHORT $LN5@get_coding
  001aa	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  001af	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001b2	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  001b5	74 0d		 je	 SHORT $LN5@get_coding
  001b7	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  001bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001bf	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001c2	75 0f		 jne	 SHORT $LN6@get_coding
$LN5@get_coding:

; 253  :                 t++;

  001c4	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  001c9	48 ff c0	 inc	 rax
  001cc	48 89 44 24 28	 mov	 QWORD PTR t$20638[rsp], rax
  001d1	eb a9		 jmp	 SHORT $LN7@get_coding
$LN6@get_coding:

; 254  : 
; 255  :             if (begin < t) {

  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR t$20638[rsp]
  001d8	48 39 44 24 30	 cmp	 QWORD PTR begin$20641[rsp], rax
  001dd	0f 83 ba 00 00
	00		 jae	 $LN4@get_coding

; 256  :                 char* r = new_string(begin, t - begin, tok);

  001e3	48 8b 44 24 30	 mov	 rax, QWORD PTR begin$20641[rsp]
  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$20638[rsp]
  001ed	48 2b c8	 sub	 rcx, rax
  001f0	48 8b c1	 mov	 rax, rcx
  001f3	4c 8b 44 24 78	 mov	 r8, QWORD PTR tok$[rsp]
  001f8	48 8b d0	 mov	 rdx, rax
  001fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR begin$20641[rsp]
  00200	e8 00 00 00 00	 call	 new_string
  00205	48 89 44 24 40	 mov	 QWORD PTR r$20653[rsp], rax

; 257  :                 char* q;
; 258  :                 if (!r)

  0020a	48 83 7c 24 40
	00		 cmp	 QWORD PTR r$20653[rsp], 0
  00210	75 07		 jne	 SHORT $LN3@get_coding

; 259  :                     return 0;

  00212	33 c0		 xor	 eax, eax
  00214	e9 8e 00 00 00	 jmp	 $LN21@get_coding
$LN3@get_coding:

; 260  :                 q = get_normal_name(r);

  00219	48 8b 4c 24 40	 mov	 rcx, QWORD PTR r$20653[rsp]
  0021e	e8 00 00 00 00	 call	 get_normal_name
  00223	48 89 44 24 38	 mov	 QWORD PTR q$20654[rsp], rax

; 261  :                 if (r != q) {

  00228	48 8b 44 24 38	 mov	 rax, QWORD PTR q$20654[rsp]
  0022d	48 39 44 24 40	 cmp	 QWORD PTR r$20653[rsp], rax
  00232	74 5c		 je	 SHORT $LN2@get_coding

; 262  :                     PyMem_FREE(r);

  00234	e8 00 00 00 00	 call	 _Py_PXCTX
  00239	85 c0		 test	 eax, eax
  0023b	74 14		 je	 SHORT $LN23@get_coding
  0023d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR r$20653[rsp]
  00242	e8 00 00 00 00	 call	 _PxMem_Free
  00247	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  0024f	eb 12		 jmp	 SHORT $LN24@get_coding
$LN23@get_coding:
  00251	48 8b 4c 24 40	 mov	 rcx, QWORD PTR r$20653[rsp]
  00256	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0025b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN24@get_coding:

; 263  :                     r = new_string(q, strlen(q), tok);

  00263	48 8b 4c 24 38	 mov	 rcx, QWORD PTR q$20654[rsp]
  00268	e8 00 00 00 00	 call	 strlen
  0026d	4c 8b 44 24 78	 mov	 r8, QWORD PTR tok$[rsp]
  00272	48 8b d0	 mov	 rdx, rax
  00275	48 8b 4c 24 38	 mov	 rcx, QWORD PTR q$20654[rsp]
  0027a	e8 00 00 00 00	 call	 new_string
  0027f	48 89 44 24 40	 mov	 QWORD PTR r$20653[rsp], rax

; 264  :                     if (!r)

  00284	48 83 7c 24 40
	00		 cmp	 QWORD PTR r$20653[rsp], 0
  0028a	75 04		 jne	 SHORT $LN1@get_coding

; 265  :                         return 0;

  0028c	33 c0		 xor	 eax, eax
  0028e	eb 17		 jmp	 SHORT $LN21@get_coding
$LN1@get_coding:
$LN2@get_coding:

; 266  :                 }
; 267  :                 *spec = r;

  00290	48 8b 44 24 68	 mov	 rax, QWORD PTR spec$[rsp]
  00295	48 8b 4c 24 40	 mov	 rcx, QWORD PTR r$20653[rsp]
  0029a	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@get_coding:
$LN12@get_coding:

; 268  :             }
; 269  :         }
; 270  :     }

  0029d	e9 1d fe ff ff	 jmp	 $LN14@get_coding
$LN13@get_coding:

; 271  :     return 1;

  002a2	b8 01 00 00 00	 mov	 eax, 1
$LN21@get_coding:

; 272  : }

  002a7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002ab	c3		 ret	 0
get_coding_spec ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_string DD imagerel new_string
	DD	imagerel new_string+155
	DD	imagerel $unwind$new_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_string DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT new_string
_TEXT	SEGMENT
result$ = 32
tv72 = 40
s$ = 64
len$ = 72
tok$ = 80
new_string PROC						; COMDAT

; 151  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 152  :     char* result = (char *)PyMem_MALLOC(len + 1);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 17		 je	 SHORT $LN4@new_string
  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00021	48 ff c0	 inc	 rax
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 _PxMem_Malloc
  0002c	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00031	eb 15		 jmp	 SHORT $LN5@new_string
$LN4@new_string:
  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00038	48 ff c0	 inc	 rax
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00043	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
$LN5@new_string:
  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR tv72[rsp]
  0004d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 153  :     if (!result) {

  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00058	75 10		 jne	 SHORT $LN1@new_string

; 154  :         tok->done = E_NOMEM;

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR tok$[rsp]
  0005f	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [rax+40], 15

; 155  :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	eb 2c		 jmp	 SHORT $LN2@new_string
$LN1@new_string:

; 156  :     }
; 157  :     memcpy(result, s, len);

  0006a	4c 8b 44 24 48	 mov	 r8, QWORD PTR len$[rsp]
  0006f	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00079	e8 00 00 00 00	 call	 memcpy

; 158  :     result[len] = '\0';

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 159  :     return result;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN2@new_string:

; 160  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
new_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@		; `string'
PUBLIC	??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@		; `string'
PUBLIC	??_C@_08PJOFPIOJ@latin?91?9?$AA@		; `string'
PUBLIC	??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@		; `string'
PUBLIC	??_C@_0L@CCLJNNOO@iso?98859?91?$AA@		; `string'
PUBLIC	??_C@_07BJPINKOJ@latin?91?$AA@			; `string'
PUBLIC	??_C@_06CAIILBD@utf?98?9?$AA@			; `string'
EXTRN	__imp_tolower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_normal_name DD imagerel get_normal_name
	DD	imagerel get_normal_name+349
	DD	imagerel $unwind$get_normal_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_normal_name DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@
CONST	SEGMENT
??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@ DB 'iso-latin-1-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@
CONST	SEGMENT
??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@ DB 'iso-8859-1-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJOFPIOJ@latin?91?9?$AA@
CONST	SEGMENT
??_C@_08PJOFPIOJ@latin?91?9?$AA@ DB 'latin-1-', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@
CONST	SEGMENT
??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@ DB 'iso-latin-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
CONST	SEGMENT
??_C@_0L@CCLJNNOO@iso?98859?91?$AA@ DB 'iso-8859-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJPINKOJ@latin?91?$AA@
CONST	SEGMENT
??_C@_07BJPINKOJ@latin?91?$AA@ DB 'latin-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAIILBD@utf?98?9?$AA@
CONST	SEGMENT
??_C@_06CAIILBD@utf?98?9?$AA@ DB 'utf-8-', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_normal_name
_TEXT	SEGMENT
i$ = 32
buf$ = 40
c$20599 = 56
s$ = 80
get_normal_name PROC					; COMDAT

; 197  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 198  :     char buf[13];
; 199  :     int i;
; 200  :     for (i = 0; i < 12; i++) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN13@get_normal
$LN12@get_normal:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@get_normal:
  0001d	83 7c 24 20 0c	 cmp	 DWORD PTR i$[rsp], 12
  00022	7d 45		 jge	 SHORT $LN11@get_normal

; 201  :         int c = s[i];

  00024	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0002e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00032	89 44 24 38	 mov	 DWORD PTR c$20599[rsp], eax

; 202  :         if (c == '\0')

  00036	83 7c 24 38 00	 cmp	 DWORD PTR c$20599[rsp], 0
  0003b	75 04		 jne	 SHORT $LN10@get_normal

; 203  :             break;

  0003d	eb 2a		 jmp	 SHORT $LN11@get_normal
  0003f	eb 26		 jmp	 SHORT $LN9@get_normal
$LN10@get_normal:

; 204  :         else if (c == '_')

  00041	83 7c 24 38 5f	 cmp	 DWORD PTR c$20599[rsp], 95 ; 0000005fH
  00046	75 0c		 jne	 SHORT $LN8@get_normal

; 205  :             buf[i] = '-';

  00048	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	c6 44 04 28 2d	 mov	 BYTE PTR buf$[rsp+rax], 45 ; 0000002dH

; 206  :         else

  00052	eb 13		 jmp	 SHORT $LN7@get_normal
$LN8@get_normal:

; 207  :             buf[i] = tolower(c);

  00054	8b 4c 24 38	 mov	 ecx, DWORD PTR c$20599[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  0005e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00063	88 44 0c 28	 mov	 BYTE PTR buf$[rsp+rcx], al
$LN7@get_normal:
$LN9@get_normal:

; 208  :     }

  00067	eb aa		 jmp	 SHORT $LN12@get_normal
$LN11@get_normal:

; 209  :     buf[i] = '\0';

  00069	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006e	c6 44 04 28 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 210  :     if (strcmp(buf, "utf-8") == 0 ||
; 211  :         strncmp(buf, "utf-8-", 6) == 0)

  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0007a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0007f	e8 00 00 00 00	 call	 strcmp
  00084	85 c0		 test	 eax, eax
  00086	74 1c		 je	 SHORT $LN5@get_normal
  00088	41 b8 06 00 00
	00		 mov	 r8d, 6
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CAIILBD@utf?98?9?$AA@
  00095	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000a0	85 c0		 test	 eax, eax
  000a2	75 11		 jne	 SHORT $LN6@get_normal
$LN5@get_normal:

; 212  :         return "utf-8";

  000a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  000ab	e9 a8 00 00 00	 jmp	 $LN14@get_normal

; 213  :     else if (strcmp(buf, "latin-1") == 0 ||

  000b0	e9 a3 00 00 00	 jmp	 $LN4@get_normal
$LN6@get_normal:

; 214  :              strcmp(buf, "iso-8859-1") == 0 ||
; 215  :              strcmp(buf, "iso-latin-1") == 0 ||
; 216  :              strncmp(buf, "latin-1-", 8) == 0 ||
; 217  :              strncmp(buf, "iso-8859-1-", 11) == 0 ||
; 218  :              strncmp(buf, "iso-latin-1-", 12) == 0)

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  000bc	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  000c1	e8 00 00 00 00	 call	 strcmp
  000c6	85 c0		 test	 eax, eax
  000c8	74 7e		 je	 SHORT $LN2@get_normal
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  000d1	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  000d6	e8 00 00 00 00	 call	 strcmp
  000db	85 c0		 test	 eax, eax
  000dd	74 69		 je	 SHORT $LN2@get_normal
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@
  000e6	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  000eb	e8 00 00 00 00	 call	 strcmp
  000f0	85 c0		 test	 eax, eax
  000f2	74 54		 je	 SHORT $LN2@get_normal
  000f4	41 b8 08 00 00
	00		 mov	 r8d, 8
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PJOFPIOJ@latin?91?9?$AA@
  00101	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0010c	85 c0		 test	 eax, eax
  0010e	74 38		 je	 SHORT $LN2@get_normal
  00110	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@
  0011d	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00128	85 c0		 test	 eax, eax
  0012a	74 1c		 je	 SHORT $LN2@get_normal
  0012c	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@
  00139	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00144	85 c0		 test	 eax, eax
  00146	75 0b		 jne	 SHORT $LN3@get_normal
$LN2@get_normal:

; 219  :         return "iso-8859-1";

  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  0014f	eb 07		 jmp	 SHORT $LN14@get_normal

; 220  :     else

  00151	eb 05		 jmp	 SHORT $LN1@get_normal
$LN3@get_normal:

; 221  :         return s;

  00153	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
$LN1@get_normal:
$LN4@get_normal:
$LN14@get_normal:

; 222  : }

  00158	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015c	c3		 ret	 0
get_normal_name ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_bom DD imagerel check_bom
	DD	imagerel check_bom+383
	DD	imagerel $unwind$check_bom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_bom DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT check_bom
_TEXT	SEGMENT
ch1$ = 32
ch2$ = 36
ch3$ = 40
tv95 = 44
get_char$ = 64
unget_char$ = 72
set_readline$ = 80
tok$ = 88
check_bom PROC						; COMDAT

; 343  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 344  :     int ch1, ch2, ch3;
; 345  :     ch1 = get_char(tok);

  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  0001d	ff 54 24 40	 call	 QWORD PTR get_char$[rsp]
  00021	89 44 24 20	 mov	 DWORD PTR ch1$[rsp], eax

; 346  :     tok->decoding_state = STATE_RAW;

  00025	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  0002a	c7 80 94 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+916], 1

; 347  :     if (ch1 == EOF) {

  00034	83 7c 24 20 ff	 cmp	 DWORD PTR ch1$[rsp], -1
  00039	75 0f		 jne	 SHORT $LN8@check_bom

; 348  :         return 1;

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	e9 35 01 00 00	 jmp	 $LN9@check_bom
  00045	e9 aa 00 00 00	 jmp	 $LN7@check_bom
$LN8@check_bom:

; 349  :     } else if (ch1 == 0xEF) {

  0004a	81 7c 24 20 ef
	00 00 00	 cmp	 DWORD PTR ch1$[rsp], 239 ; 000000efH
  00052	0f 85 85 00 00
	00		 jne	 $LN6@check_bom

; 350  :         ch2 = get_char(tok);

  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  0005d	ff 54 24 40	 call	 QWORD PTR get_char$[rsp]
  00061	89 44 24 24	 mov	 DWORD PTR ch2$[rsp], eax

; 351  :         if (ch2 != 0xBB) {

  00065	81 7c 24 24 bb
	00 00 00	 cmp	 DWORD PTR ch2$[rsp], 187 ; 000000bbH
  0006d	74 24		 je	 SHORT $LN5@check_bom

; 352  :             unget_char(ch2, tok);

  0006f	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  00074	8b 4c 24 24	 mov	 ecx, DWORD PTR ch2$[rsp]
  00078	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 353  :             unget_char(ch1, tok);

  0007c	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR ch1$[rsp]
  00085	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 354  :             return 1;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	e9 e7 00 00 00	 jmp	 $LN9@check_bom
$LN5@check_bom:

; 355  :         }
; 356  :         ch3 = get_char(tok);

  00093	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  00098	ff 54 24 40	 call	 QWORD PTR get_char$[rsp]
  0009c	89 44 24 28	 mov	 DWORD PTR ch3$[rsp], eax

; 357  :         if (ch3 != 0xBF) {

  000a0	81 7c 24 28 bf
	00 00 00	 cmp	 DWORD PTR ch3$[rsp], 191 ; 000000bfH
  000a8	74 31		 je	 SHORT $LN4@check_bom

; 358  :             unget_char(ch3, tok);

  000aa	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  000af	8b 4c 24 28	 mov	 ecx, DWORD PTR ch3$[rsp]
  000b3	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 359  :             unget_char(ch2, tok);

  000b7	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  000bc	8b 4c 24 24	 mov	 ecx, DWORD PTR ch2$[rsp]
  000c0	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 360  :             unget_char(ch1, tok);

  000c4	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  000c9	8b 4c 24 20	 mov	 ecx, DWORD PTR ch1$[rsp]
  000cd	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 361  :             return 1;

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	e9 9f 00 00 00	 jmp	 $LN9@check_bom
$LN4@check_bom:

; 362  :         }
; 363  : #if 0
; 364  :     /* Disable support for UTF-16 BOMs until a decision
; 365  :        is made whether this needs to be supported.  */
; 366  :     } else if (ch1 == 0xFE) {
; 367  :         ch2 = get_char(tok);
; 368  :         if (ch2 != 0xFF) {
; 369  :             unget_char(ch2, tok);
; 370  :             unget_char(ch1, tok);
; 371  :             return 1;
; 372  :         }
; 373  :         if (!set_readline(tok, "utf-16-be"))
; 374  :             return 0;
; 375  :         tok->decoding_state = STATE_NORMAL;
; 376  :     } else if (ch1 == 0xFF) {
; 377  :         ch2 = get_char(tok);
; 378  :         if (ch2 != 0xFE) {
; 379  :             unget_char(ch2, tok);
; 380  :             unget_char(ch1, tok);
; 381  :             return 1;
; 382  :         }
; 383  :         if (!set_readline(tok, "utf-16-le"))
; 384  :             return 0;
; 385  :         tok->decoding_state = STATE_NORMAL;
; 386  : #endif
; 387  :     } else {

  000db	eb 17		 jmp	 SHORT $LN3@check_bom
$LN6@check_bom:

; 388  :         unget_char(ch1, tok);

  000dd	48 8b 54 24 58	 mov	 rdx, QWORD PTR tok$[rsp]
  000e2	8b 4c 24 20	 mov	 ecx, DWORD PTR ch1$[rsp]
  000e6	ff 54 24 48	 call	 QWORD PTR unget_char$[rsp]

; 389  :         return 1;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	e9 86 00 00 00	 jmp	 $LN9@check_bom
$LN3@check_bom:
$LN7@check_bom:

; 390  :     }
; 391  :     if (tok->encoding != NULL)

  000f4	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  000f9	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  00101	74 3d		 je	 SHORT $LN2@check_bom

; 392  :         PyMem_FREE(tok->encoding);

  00103	e8 00 00 00 00	 call	 _Py_PXCTX
  00108	85 c0		 test	 eax, eax
  0010a	74 1b		 je	 SHORT $LN11@check_bom
  0010c	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  00111	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00118	e8 00 00 00 00	 call	 _PxMem_Free
  0011d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
  00125	eb 19		 jmp	 SHORT $LN12@check_bom
$LN11@check_bom:
  00127	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  0012c	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00133	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00138	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN12@check_bom:
$LN2@check_bom:

; 393  :     tok->encoding = new_string("utf-8", 5, tok);

  00140	4c 8b 44 24 58	 mov	 r8, QWORD PTR tok$[rsp]
  00145	ba 05 00 00 00	 mov	 edx, 5
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00151	e8 00 00 00 00	 call	 new_string
  00156	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  0015b	48 89 81 a0 03
	00 00		 mov	 QWORD PTR [rcx+928], rax

; 394  :     if (!tok->encoding)

  00162	48 8b 44 24 58	 mov	 rax, QWORD PTR tok$[rsp]
  00167	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  0016f	75 04		 jne	 SHORT $LN1@check_bom

; 395  :         return 0;

  00171	33 c0		 xor	 eax, eax
  00173	eb 05		 jmp	 SHORT $LN9@check_bom
$LN1@check_bom:

; 396  :     /* No need to set_readline: input is already utf-8 */
; 397  :     return 1;

  00175	b8 01 00 00 00	 mov	 eax, 1
$LN9@check_bom:

; 398  : }

  0017a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017e	c3		 ret	 0
check_bom ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$buf_getc DD imagerel buf_getc
	DD	imagerel buf_getc+68
	DD	imagerel $unwind$buf_getc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$buf_getc DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT buf_getc
_TEXT	SEGMENT
tv72 = 0
tok$ = 32
buf_getc PROC						; COMDAT

; 656  : buf_getc(struct tok_state *tok) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 657  :     return Py_CHARMASK(*tok->str++);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	48 8b 80 d0 03
	00 00		 mov	 rax, QWORD PTR [rax+976]
  00015	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00018	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0001d	88 04 24	 mov	 BYTE PTR tv72[rsp], al
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00025	48 8b 80 d0 03
	00 00		 mov	 rax, QWORD PTR [rax+976]
  0002c	48 ff c0	 inc	 rax
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  00034	48 89 81 d0 03
	00 00		 mov	 QWORD PTR [rcx+976], rax
  0003b	0f b6 04 24	 movzx	 eax, BYTE PTR tv72[rsp]

; 658  : }

  0003f	48 83 c4 18	 add	 rsp, 24
  00043	c3		 ret	 0
buf_getc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@BBJDDKJC@?$AAP?$AAy?$AA_?$AAC?$AAH?$AAA?$AAR?$AAM?$AAA?$AAS?$AAK?$AA?$CI?$AA?$CK?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$buf_ungetc DD imagerel buf_ungetc
	DD	imagerel buf_ungetc+102
	DD	imagerel $unwind$buf_ungetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$buf_ungetc DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT ??_C@_1DI@BBJDDKJC@?$AAP?$AAy?$AA_?$AAC?$AAH?$AAA?$AAR?$AAM?$AAA?$AAS?$AAK?$AA?$CI?$AA?$CK?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@BBJDDKJC@?$AAP?$AAy?$AA_?$AAC?$AAH?$AAA?$AAR?$AAM?$AAA?$AAS?$AAK?$AA?$CI?$AA?$CK?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'C', 00H, 'H', 00H, 'A', 00H, 'R', 00H
	DB	'M', 00H, 'A', 00H, 'S', 00H, 'K', 00H, '(', 00H, '*', 00H, 't'
	DB	00H, 'o', 00H, 'k', 00H, '-', 00H, '>', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'c'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT buf_ungetc
_TEXT	SEGMENT
c$ = 48
tok$ = 56
buf_ungetc PROC						; COMDAT

; 663  : buf_ungetc(int c, struct tok_state *tok) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 664  :     tok->str--;

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR tok$[rsp]
  00012	48 8b 80 d0 03
	00 00		 mov	 rax, QWORD PTR [rax+976]
  00019	48 ff c8	 dec	 rax
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tok$[rsp]
  00021	48 89 81 d0 03
	00 00		 mov	 QWORD PTR [rcx+976], rax

; 665  :     assert(Py_CHARMASK(*tok->str) == c);        /* tok->cur may point to read-only segment */

  00028	48 8b 44 24 38	 mov	 rax, QWORD PTR tok$[rsp]
  0002d	48 8b 80 d0 03
	00 00		 mov	 rax, QWORD PTR [rax+976]
  00034	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00037	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	3b 44 24 30	 cmp	 eax, DWORD PTR c$[rsp]
  00043	74 1c		 je	 SHORT $LN3@buf_ungetc
  00045	41 b8 99 02 00
	00		 mov	 r8d, 665		; 00000299H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@BBJDDKJC@?$AAP?$AAy?$AA_?$AAC?$AAH?$AAA?$AAR?$AAM?$AAA?$AAS?$AAK?$AA?$CI?$AA?$CK?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAs?$AAt?$AAr?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AA?$AA@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN3@buf_ungetc:

; 666  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
buf_ungetc ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT buf_setreadl
_TEXT	SEGMENT
tok$ = 8
enc$ = 16
buf_setreadl PROC					; COMDAT

; 672  : buf_setreadl(struct tok_state *tok, const char* enc) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 673  :     tok->enc = enc;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR tok$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR enc$[rsp]
  00014	48 89 88 c8 03
	00 00		 mov	 QWORD PTR [rax+968], rcx

; 674  :     return 1;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 675  : }

  00020	c3		 ret	 0
buf_setreadl ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	PyUnicode_AsUTF8String:PROC
EXTRN	PyUnicode_Decode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$translate_into_utf8 DD imagerel translate_into_utf8
	DD	imagerel translate_into_utf8+97
	DD	imagerel $unwind$translate_into_utf8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translate_into_utf8 DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT translate_into_utf8
_TEXT	SEGMENT
buf$ = 32
utf8$ = 40
str$ = 64
enc$ = 72
translate_into_utf8 PROC				; COMDAT

; 681  : translate_into_utf8(const char* str, const char* enc) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 682  :     PyObject *utf8;
; 683  :     PyObject* buf = PyUnicode_Decode(str, strlen(str), enc, NULL);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	45 33 c9	 xor	 r9d, r9d
  0001b	4c 8b 44 24 48	 mov	 r8, QWORD PTR enc$[rsp]
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00028	e8 00 00 00 00	 call	 PyUnicode_Decode
  0002d	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 684  :     if (buf == NULL)

  00032	48 83 7c 24 20
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00038	75 04		 jne	 SHORT $LN1@translate_

; 685  :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 1e		 jmp	 SHORT $LN2@translate_
$LN1@translate_:

; 686  :     utf8 = PyUnicode_AsUTF8String(buf);

  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00043	e8 00 00 00 00	 call	 PyUnicode_AsUTF8String
  00048	48 89 44 24 28	 mov	 QWORD PTR utf8$[rsp], rax

; 687  :     Py_DECREF(buf);

  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00052	e8 00 00 00 00	 call	 _Py_DecRef

; 688  :     return utf8;

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR utf8$[rsp]
$LN2@translate_:

; 689  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
translate_into_utf8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\tokenizer.c
pdata	SEGMENT
$pdata$translate_newlines DD imagerel translate_newlines
	DD	imagerel translate_newlines+462
	DD	imagerel $unwind$translate_newlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translate_newlines DD 011201H
	DD	0c212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT translate_newlines
_TEXT	SEGMENT
current$ = 32
needed_length$ = 40
buf$ = 48
c$ = 56
skip_next_lf$ = 60
final_length$ = 64
tv76 = 72
tv142 = 80
s$ = 112
exec_input$ = 120
tok$ = 128
translate_newlines PROC					; COMDAT

; 693  : translate_newlines(const char *s, int exec_input, struct tok_state *tok) {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 694  :     int skip_next_lf = 0, needed_length = strlen(s) + 2, final_length;

  00012	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR skip_next_lf$[rsp], 0
  0001a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 strlen
  00024	48 83 c0 02	 add	 rax, 2
  00028	89 44 24 28	 mov	 DWORD PTR needed_length$[rsp], eax

; 695  :     char *buf, *current;
; 696  :     char c = '\0';

  0002c	c6 44 24 38 00	 mov	 BYTE PTR c$[rsp], 0

; 697  :     buf = PyMem_MALLOC(needed_length);

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	74 14		 je	 SHORT $LN13@translate_@2
  0003a	48 63 44 24 28	 movsxd	 rax, DWORD PTR needed_length$[rsp]
  0003f	48 8b c8	 mov	 rcx, rax
  00042	e8 00 00 00 00	 call	 _PxMem_Malloc
  00047	48 89 44 24 48	 mov	 QWORD PTR tv76[rsp], rax
  0004c	eb 12		 jmp	 SHORT $LN14@translate_@2
$LN13@translate_@2:
  0004e	48 63 44 24 28	 movsxd	 rax, DWORD PTR needed_length$[rsp]
  00053	48 8b c8	 mov	 rcx, rax
  00056	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0005b	48 89 44 24 48	 mov	 QWORD PTR tv76[rsp], rax
$LN14@translate_@2:
  00060	48 8b 44 24 48	 mov	 rax, QWORD PTR tv76[rsp]
  00065	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 698  :     if (buf == NULL) {

  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00070	75 16		 jne	 SHORT $LN10@translate_@2

; 699  :         tok->done = E_NOMEM;

  00072	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0007a	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [rax+40], 15

; 700  :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 41 01 00 00	 jmp	 $LN11@translate_@2
$LN10@translate_@2:

; 701  :     }
; 702  :     for (current = buf; *s; s++, current++) {

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$[rsp]
  0008d	48 89 44 24 20	 mov	 QWORD PTR current$[rsp], rax
  00092	eb 1a		 jmp	 SHORT $LN9@translate_@2
$LN8@translate_@2:
  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00099	48 ff c0	 inc	 rax
  0009c	48 89 44 24 70	 mov	 QWORD PTR s$[rsp], rax
  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR current$[rsp]
  000a6	48 ff c0	 inc	 rax
  000a9	48 89 44 24 20	 mov	 QWORD PTR current$[rsp], rax
$LN9@translate_@2:
  000ae	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b6	85 c0		 test	 eax, eax
  000b8	74 71		 je	 SHORT $LN7@translate_@2

; 703  :         c = *s;

  000ba	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000c2	88 44 24 38	 mov	 BYTE PTR c$[rsp], al

; 704  :         if (skip_next_lf) {

  000c6	83 7c 24 3c 00	 cmp	 DWORD PTR skip_next_lf$[rsp], 0
  000cb	74 36		 je	 SHORT $LN6@translate_@2

; 705  :             skip_next_lf = 0;

  000cd	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR skip_next_lf$[rsp], 0

; 706  :             if (c == '\n') {

  000d5	0f be 44 24 38	 movsx	 eax, BYTE PTR c$[rsp]
  000da	83 f8 0a	 cmp	 eax, 10
  000dd	75 24		 jne	 SHORT $LN5@translate_@2

; 707  :                 c = *++s;

  000df	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000e4	48 ff c0	 inc	 rax
  000e7	48 89 44 24 70	 mov	 QWORD PTR s$[rsp], rax
  000ec	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f4	88 44 24 38	 mov	 BYTE PTR c$[rsp], al

; 708  :                 if (!c)

  000f8	0f be 44 24 38	 movsx	 eax, BYTE PTR c$[rsp]
  000fd	85 c0		 test	 eax, eax
  000ff	75 02		 jne	 SHORT $LN4@translate_@2

; 709  :                     break;

  00101	eb 28		 jmp	 SHORT $LN7@translate_@2
$LN4@translate_@2:
$LN5@translate_@2:
$LN6@translate_@2:

; 710  :             }
; 711  :         }
; 712  :         if (c == '\r') {

  00103	0f be 44 24 38	 movsx	 eax, BYTE PTR c$[rsp]
  00108	83 f8 0d	 cmp	 eax, 13
  0010b	75 0d		 jne	 SHORT $LN3@translate_@2

; 713  :             skip_next_lf = 1;

  0010d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR skip_next_lf$[rsp], 1

; 714  :             c = '\n';

  00115	c6 44 24 38 0a	 mov	 BYTE PTR c$[rsp], 10
$LN3@translate_@2:

; 715  :         }
; 716  :         *current = c;

  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR current$[rsp]
  0011f	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR c$[rsp]
  00124	88 08		 mov	 BYTE PTR [rax], cl

; 717  :     }

  00126	e9 69 ff ff ff	 jmp	 $LN8@translate_@2
$LN7@translate_@2:

; 718  :     /* If this is exec input, add a newline to the end of the string if
; 719  :        there isn't one already. */
; 720  :     if (exec_input && c != '\n') {

  0012b	83 7c 24 78 00	 cmp	 DWORD PTR exec_input$[rsp], 0
  00130	74 1f		 je	 SHORT $LN2@translate_@2
  00132	0f be 44 24 38	 movsx	 eax, BYTE PTR c$[rsp]
  00137	83 f8 0a	 cmp	 eax, 10
  0013a	74 15		 je	 SHORT $LN2@translate_@2

; 721  :         *current = '\n';

  0013c	48 8b 44 24 20	 mov	 rax, QWORD PTR current$[rsp]
  00141	c6 00 0a	 mov	 BYTE PTR [rax], 10

; 722  :         current++;

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR current$[rsp]
  00149	48 ff c0	 inc	 rax
  0014c	48 89 44 24 20	 mov	 QWORD PTR current$[rsp], rax
$LN2@translate_@2:

; 723  :     }
; 724  :     *current = '\0';

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR current$[rsp]
  00156	c6 00 00	 mov	 BYTE PTR [rax], 0

; 725  :     final_length = current - buf + 1;

  00159	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$[rsp]
  0015e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR current$[rsp]
  00163	48 2b c8	 sub	 rcx, rax
  00166	48 8b c1	 mov	 rax, rcx
  00169	48 ff c0	 inc	 rax
  0016c	89 44 24 40	 mov	 DWORD PTR final_length$[rsp], eax

; 726  :     if (final_length < needed_length && final_length)

  00170	8b 44 24 28	 mov	 eax, DWORD PTR needed_length$[rsp]
  00174	39 44 24 40	 cmp	 DWORD PTR final_length$[rsp], eax
  00178	7d 4a		 jge	 SHORT $LN1@translate_@2
  0017a	83 7c 24 40 00	 cmp	 DWORD PTR final_length$[rsp], 0
  0017f	74 43		 je	 SHORT $LN1@translate_@2

; 727  :         /* should never fail */
; 728  :         buf = PyMem_REALLOC(buf, final_length);

  00181	e8 00 00 00 00	 call	 _Py_PXCTX
  00186	85 c0		 test	 eax, eax
  00188	74 19		 je	 SHORT $LN15@translate_@2
  0018a	48 63 44 24 40	 movsxd	 rax, DWORD PTR final_length$[rsp]
  0018f	48 8b d0	 mov	 rdx, rax
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00197	e8 00 00 00 00	 call	 _PxMem_Realloc
  0019c	48 89 44 24 50	 mov	 QWORD PTR tv142[rsp], rax
  001a1	eb 17		 jmp	 SHORT $LN16@translate_@2
$LN15@translate_@2:
  001a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR final_length$[rsp]
  001a8	48 8b d0	 mov	 rdx, rax
  001ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  001b0	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  001b5	48 89 44 24 50	 mov	 QWORD PTR tv142[rsp], rax
$LN16@translate_@2:
  001ba	48 8b 44 24 50	 mov	 rax, QWORD PTR tv142[rsp]
  001bf	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax
$LN1@translate_@2:

; 729  :     return buf;

  001c4	48 8b 44 24 30	 mov	 rax, QWORD PTR buf$[rsp]
$LN11@translate_@2:

; 730  : }

  001c9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cd	c3		 ret	 0
translate_newlines ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FromUTF8
EXTRN	strcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FromUTF8 DD imagerel $LN8
	DD	imagerel $LN8+343
	DD	imagerel $unwind$PyTokenizer_FromUTF8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromUTF8 DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_FromUTF8
_TEXT	SEGMENT
tok$ = 32
tv84 = 40
str$ = 64
exec_input$ = 72
PyTokenizer_FromUTF8 PROC				; COMDAT

; 815  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 816  :     struct tok_state *tok = tok_new();

  0000d	e8 00 00 00 00	 call	 tok_new
  00012	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 817  :     if (tok == NULL)

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN3@PyTokenize@2

; 818  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 2c 01 00 00	 jmp	 $LN4@PyTokenize@2
$LN3@PyTokenize@2:

; 819  : #ifndef PGEN
; 820  :     tok->input = str = translate_newlines(str, exec_input, tok);

  00026	4c 8b 44 24 20	 mov	 r8, QWORD PTR tok$[rsp]
  0002b	8b 54 24 48	 mov	 edx, DWORD PTR exec_input$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00034	e8 00 00 00 00	 call	 translate_newlines
  00039	48 89 44 24 40	 mov	 QWORD PTR str$[rsp], rax
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00048	48 89 88 d8 03
	00 00		 mov	 QWORD PTR [rax+984], rcx

; 821  : #endif
; 822  :     if (str == NULL) {

  0004f	48 83 7c 24 40
	00		 cmp	 QWORD PTR str$[rsp], 0
  00055	75 11		 jne	 SHORT $LN2@PyTokenize@2

; 823  :         PyTokenizer_Free(tok);

  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0005c	e8 00 00 00 00	 call	 PyTokenizer_Free

; 824  :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	e9 ea 00 00 00	 jmp	 $LN4@PyTokenize@2
$LN2@PyTokenize@2:

; 825  :     }
; 826  :     tok->decoding_state = STATE_RAW;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0006d	c7 80 94 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+916], 1

; 827  :     tok->read_coding_spec = 1;

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0007c	c7 80 9c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+924], 1

; 828  :     tok->enc = NULL;

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0008b	48 c7 80 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+968], 0

; 829  :     tok->str = str;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  000a0	48 89 88 d0 03
	00 00		 mov	 QWORD PTR [rax+976], rcx

; 830  :     tok->encoding = (char *)PyMem_MALLOC(6);

  000a7	e8 00 00 00 00	 call	 _Py_PXCTX
  000ac	85 c0		 test	 eax, eax
  000ae	74 11		 je	 SHORT $LN6@PyTokenize@2
  000b0	b9 06 00 00 00	 mov	 ecx, 6
  000b5	e8 00 00 00 00	 call	 _PxMem_Malloc
  000ba	48 89 44 24 28	 mov	 QWORD PTR tv84[rsp], rax
  000bf	eb 0f		 jmp	 SHORT $LN7@PyTokenize@2
$LN6@PyTokenize@2:
  000c1	b9 06 00 00 00	 mov	 ecx, 6
  000c6	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  000cb	48 89 44 24 28	 mov	 QWORD PTR tv84[rsp], rax
$LN7@PyTokenize@2:
  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv84[rsp]
  000da	48 89 88 a0 03
	00 00		 mov	 QWORD PTR [rax+928], rcx

; 831  :     if (!tok->encoding) {

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000e6	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  000ee	75 0e		 jne	 SHORT $LN1@PyTokenize@2

; 832  :         PyTokenizer_Free(tok);

  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  000f5	e8 00 00 00 00	 call	 PyTokenizer_Free

; 833  :         return NULL;

  000fa	33 c0		 xor	 eax, eax
  000fc	eb 54		 jmp	 SHORT $LN4@PyTokenize@2
$LN1@PyTokenize@2:

; 834  :     }
; 835  :     strcpy(tok->encoding, "utf-8");

  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0010a	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00111	e8 00 00 00 00	 call	 strcpy

; 836  : 
; 837  :     /* XXX: constify members. */
; 838  :     tok->buf = tok->cur = tok->end = tok->inp = (char*)str;

  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00120	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  0012e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  00132	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00137	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  0013c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00140	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  0014a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 839  :     return tok;

  0014d	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
$LN4@PyTokenize@2:

; 840  : }

  00152	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00156	c3		 ret	 0
PyTokenizer_FromUTF8 ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FromFile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FromFile DD imagerel $LN11
	DD	imagerel $LN11+402
	DD	imagerel $unwind$PyTokenizer_FromFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromFile DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_FromFile
_TEXT	SEGMENT
tok$ = 32
tv72 = 40
tv129 = 48
fp$ = 80
enc$ = 88
ps1$ = 96
ps2$ = 104
PyTokenizer_FromFile PROC				; COMDAT

; 846  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 847  :     struct tok_state *tok = tok_new();

  00018	e8 00 00 00 00	 call	 tok_new
  0001d	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 848  :     if (tok == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00028	75 07		 jne	 SHORT $LN4@PyTokenize@3

; 849  :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 5c 01 00 00	 jmp	 $LN5@PyTokenize@3
$LN4@PyTokenize@3:

; 850  :     if ((tok->buf = (char *)PyMem_MALLOC(BUFSIZ)) == NULL) {

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	74 11		 je	 SHORT $LN7@PyTokenize@3
  0003a	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0003f	e8 00 00 00 00	 call	 _PxMem_Malloc
  00044	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
  00049	eb 0f		 jmp	 SHORT $LN8@PyTokenize@3
$LN7@PyTokenize@3:
  0004b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00050	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00055	48 89 44 24 28	 mov	 QWORD PTR tv72[rsp], rax
$LN8@PyTokenize@3:
  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv72[rsp]
  00064	48 89 08	 mov	 QWORD PTR [rax], rcx
  00067	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv72[rsp], 0
  0006d	75 11		 jne	 SHORT $LN3@PyTokenize@3

; 851  :         PyTokenizer_Free(tok);

  0006f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  00074	e8 00 00 00 00	 call	 PyTokenizer_Free

; 852  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 0d 01 00 00	 jmp	 $LN5@PyTokenize@3
$LN3@PyTokenize@3:

; 853  :     }
; 854  :     tok->cur = tok->inp = tok->buf;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0008a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0008d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0009b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0009f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 855  :     tok->end = tok->buf + BUFSIZ;

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  000b6	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 856  :     tok->fp = fp;

  000ba	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fp$[rsp]
  000c4	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 857  :     tok->prompt = ps1;

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ps1$[rsp]
  000d2	48 89 88 d8 01
	00 00		 mov	 QWORD PTR [rax+472], rcx

; 858  :     tok->nextprompt = ps2;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ps2$[rsp]
  000e3	48 89 88 e0 01
	00 00		 mov	 QWORD PTR [rax+480], rcx

; 859  :     if (enc != NULL) {

  000ea	48 83 7c 24 58
	00		 cmp	 QWORD PTR enc$[rsp], 0
  000f0	0f 84 92 00 00
	00		 je	 $LN2@PyTokenize@3

; 860  :         /* Must copy encoding declaration since it
; 861  :            gets copied into the parse tree. */
; 862  :         tok->encoding = PyMem_MALLOC(strlen(enc)+1);

  000f6	e8 00 00 00 00	 call	 _Py_PXCTX
  000fb	85 c0		 test	 eax, eax
  000fd	74 1c		 je	 SHORT $LN9@PyTokenize@3
  000ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR enc$[rsp]
  00104	e8 00 00 00 00	 call	 strlen
  00109	48 ff c0	 inc	 rax
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 _PxMem_Malloc
  00114	48 89 44 24 30	 mov	 QWORD PTR tv129[rsp], rax
  00119	eb 1a		 jmp	 SHORT $LN10@PyTokenize@3
$LN9@PyTokenize@3:
  0011b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR enc$[rsp]
  00120	e8 00 00 00 00	 call	 strlen
  00125	48 ff c0	 inc	 rax
  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00130	48 89 44 24 30	 mov	 QWORD PTR tv129[rsp], rax
$LN10@PyTokenize@3:
  00135	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv129[rsp]
  0013f	48 89 88 a0 03
	00 00		 mov	 QWORD PTR [rax+928], rcx

; 863  :         if (!tok->encoding) {

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0014b	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  00153	75 0e		 jne	 SHORT $LN1@PyTokenize@3

; 864  :             PyTokenizer_Free(tok);

  00155	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0015a	e8 00 00 00 00	 call	 PyTokenizer_Free

; 865  :             return NULL;

  0015f	33 c0		 xor	 eax, eax
  00161	eb 2a		 jmp	 SHORT $LN5@PyTokenize@3
$LN1@PyTokenize@3:

; 866  :         }
; 867  :         strcpy(tok->encoding, enc);

  00163	48 8b 54 24 58	 mov	 rdx, QWORD PTR enc$[rsp]
  00168	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0016d	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00174	e8 00 00 00 00	 call	 strcpy

; 868  :         tok->decoding_state = STATE_NORMAL;

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0017e	c7 80 94 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+916], 2
$LN2@PyTokenize@3:

; 869  :     }
; 870  :     return tok;

  00188	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
$LN5@PyTokenize@3:

; 871  : }

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
PyTokenizer_FromFile ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_Free DD imagerel $LN26
	DD	imagerel $LN26+403
	DD	imagerel $unwind$PyTokenizer_Free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_Free DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_Free
_TEXT	SEGMENT
tv72 = 32
tv95 = 36
tv136 = 40
tv141 = 44
tok$ = 64
PyTokenizer_Free PROC					; COMDAT

; 878  : {

$LN26:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 879  :     if (tok->encoding != NULL)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  00016	74 3d		 je	 SHORT $LN15@PyTokenize@4

; 880  :         PyMem_FREE(tok->encoding);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN18@PyTokenize@4
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00026	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  0002d	e8 00 00 00 00	 call	 _PxMem_Free
  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  0003a	eb 19		 jmp	 SHORT $LN19@PyTokenize@4
$LN18@PyTokenize@4:
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00041	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00048	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0004d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN19@PyTokenize@4:
$LN15@PyTokenize@4:
$LN14@PyTokenize@4:

; 881  : #ifndef PGEN
; 882  :     Py_XDECREF(tok->decoding_readline);

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0005a	48 83 b8 b8 03
	00 00 00	 cmp	 QWORD PTR [rax+952], 0
  00062	74 11		 je	 SHORT $LN11@PyTokenize@4
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00069	48 8b 88 b8 03
	00 00		 mov	 rcx, QWORD PTR [rax+952]
  00070	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyTokenize@4:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 da		 jne	 SHORT $LN14@PyTokenize@4
$LN10@PyTokenize@4:

; 883  :     Py_XDECREF(tok->decoding_buffer);

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00080	48 83 b8 c0 03
	00 00 00	 cmp	 QWORD PTR [rax+960], 0
  00088	74 11		 je	 SHORT $LN7@PyTokenize@4
  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0008f	48 8b 88 c0 03
	00 00		 mov	 rcx, QWORD PTR [rax+960]
  00096	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyTokenize@4:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 da		 jne	 SHORT $LN10@PyTokenize@4
$LN6@PyTokenize@4:

; 884  :     Py_XDECREF(tok->filename);

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000a6	48 83 b8 f0 01
	00 00 00	 cmp	 QWORD PTR [rax+496], 0
  000ae	74 11		 je	 SHORT $LN3@PyTokenize@4
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000b5	48 8b 88 f0 01
	00 00		 mov	 rcx, QWORD PTR [rax+496]
  000bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyTokenize@4:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 da		 jne	 SHORT $LN6@PyTokenize@4

; 885  : #endif
; 886  :     if (tok->fp != NULL && tok->buf != NULL)

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000cc	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000d1	74 40		 je	 SHORT $LN2@PyTokenize@4
  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000d8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000dc	74 35		 je	 SHORT $LN2@PyTokenize@4

; 887  :         PyMem_FREE(tok->buf);

  000de	e8 00 00 00 00	 call	 _Py_PXCTX
  000e3	85 c0		 test	 eax, eax
  000e5	74 17		 je	 SHORT $LN20@PyTokenize@4
  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000ec	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ef	e8 00 00 00 00	 call	 _PxMem_Free
  000f4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
  000fc	eb 15		 jmp	 SHORT $LN21@PyTokenize@4
$LN20@PyTokenize@4:
  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00103	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00106	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0010b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN21@PyTokenize@4:
$LN2@PyTokenize@4:

; 888  :     if (tok->input)

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00118	48 83 b8 d8 03
	00 00 00	 cmp	 QWORD PTR [rax+984], 0
  00120	74 3d		 je	 SHORT $LN1@PyTokenize@4

; 889  :         PyMem_FREE((char *)tok->input);

  00122	e8 00 00 00 00	 call	 _Py_PXCTX
  00127	85 c0		 test	 eax, eax
  00129	74 1b		 je	 SHORT $LN22@PyTokenize@4
  0012b	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00130	48 8b 88 d8 03
	00 00		 mov	 rcx, QWORD PTR [rax+984]
  00137	e8 00 00 00 00	 call	 _PxMem_Free
  0013c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
  00144	eb 19		 jmp	 SHORT $LN23@PyTokenize@4
$LN22@PyTokenize@4:
  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0014b	48 8b 88 d8 03
	00 00		 mov	 rcx, QWORD PTR [rax+984]
  00152	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00157	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN23@PyTokenize@4:
$LN1@PyTokenize@4:

; 890  :     PyMem_FREE(tok);

  0015f	e8 00 00 00 00	 call	 _Py_PXCTX
  00164	85 c0		 test	 eax, eax
  00166	74 14		 je	 SHORT $LN24@PyTokenize@4
  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tok$[rsp]
  0016d	e8 00 00 00 00	 call	 _PxMem_Free
  00172	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
  0017a	eb 12		 jmp	 SHORT $LN25@PyTokenize@4
$LN24@PyTokenize@4:
  0017c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tok$[rsp]
  00181	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00186	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN25@PyTokenize@4:

; 891  : }

  0018e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00192	c3		 ret	 0
PyTokenizer_Free ENDP
_TEXT	ENDS
PUBLIC	PyToken_OneChar
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyToken_OneChar DD imagerel $LN31
	DD	imagerel $LN31+438
	DD	imagerel $unwind$PyToken_OneChar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyToken_OneChar DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyToken_OneChar
_TEXT	SEGMENT
tv64 = 0
c$ = 32
PyToken_OneChar PROC					; COMDAT

; 1108 : {

$LN31:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1109 :     switch (c) {

  00008	8b 44 24 20	 mov	 eax, DWORD PTR c$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0000f	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00012	83 e8 25	 sub	 eax, 37			; 00000025H
  00015	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00018	83 3c 24 59	 cmp	 DWORD PTR tv64[rsp], 89	; 00000059H
  0001c	0f 87 cf 00 00
	00		 ja	 $LN1@PyToken_On
  00022	48 63 04 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN29@PyToken_On[rcx+rax]
  00035	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN30@PyToken_On[rcx+rax*4]
  0003c	48 03 c1	 add	 rax, rcx
  0003f	ff e0		 jmp	 rax
$LN24@PyToken_On:

; 1110 :     case '(':           return LPAR;

  00041	b8 07 00 00 00	 mov	 eax, 7
  00046	e9 ab 00 00 00	 jmp	 $LN27@PyToken_On
$LN23@PyToken_On:

; 1111 :     case ')':           return RPAR;

  0004b	b8 08 00 00 00	 mov	 eax, 8
  00050	e9 a1 00 00 00	 jmp	 $LN27@PyToken_On
$LN22@PyToken_On:

; 1112 :     case '[':           return LSQB;

  00055	b8 09 00 00 00	 mov	 eax, 9
  0005a	e9 97 00 00 00	 jmp	 $LN27@PyToken_On
$LN21@PyToken_On:

; 1113 :     case ']':           return RSQB;

  0005f	b8 0a 00 00 00	 mov	 eax, 10
  00064	e9 8d 00 00 00	 jmp	 $LN27@PyToken_On
$LN20@PyToken_On:

; 1114 :     case ':':           return COLON;

  00069	b8 0b 00 00 00	 mov	 eax, 11
  0006e	e9 83 00 00 00	 jmp	 $LN27@PyToken_On
$LN19@PyToken_On:

; 1115 :     case ',':           return COMMA;

  00073	b8 0c 00 00 00	 mov	 eax, 12
  00078	eb 7c		 jmp	 SHORT $LN27@PyToken_On
$LN18@PyToken_On:

; 1116 :     case ';':           return SEMI;

  0007a	b8 0d 00 00 00	 mov	 eax, 13
  0007f	eb 75		 jmp	 SHORT $LN27@PyToken_On
$LN17@PyToken_On:

; 1117 :     case '+':           return PLUS;

  00081	b8 0e 00 00 00	 mov	 eax, 14
  00086	eb 6e		 jmp	 SHORT $LN27@PyToken_On
$LN16@PyToken_On:

; 1118 :     case '-':           return MINUS;

  00088	b8 0f 00 00 00	 mov	 eax, 15
  0008d	eb 67		 jmp	 SHORT $LN27@PyToken_On
$LN15@PyToken_On:

; 1119 :     case '*':           return STAR;

  0008f	b8 10 00 00 00	 mov	 eax, 16
  00094	eb 60		 jmp	 SHORT $LN27@PyToken_On
$LN14@PyToken_On:

; 1120 :     case '/':           return SLASH;

  00096	b8 11 00 00 00	 mov	 eax, 17
  0009b	eb 59		 jmp	 SHORT $LN27@PyToken_On
$LN13@PyToken_On:

; 1121 :     case '|':           return VBAR;

  0009d	b8 12 00 00 00	 mov	 eax, 18
  000a2	eb 52		 jmp	 SHORT $LN27@PyToken_On
$LN12@PyToken_On:

; 1122 :     case '&':           return AMPER;

  000a4	b8 13 00 00 00	 mov	 eax, 19
  000a9	eb 4b		 jmp	 SHORT $LN27@PyToken_On
$LN11@PyToken_On:

; 1123 :     case '<':           return LESS;

  000ab	b8 14 00 00 00	 mov	 eax, 20
  000b0	eb 44		 jmp	 SHORT $LN27@PyToken_On
$LN10@PyToken_On:

; 1124 :     case '>':           return GREATER;

  000b2	b8 15 00 00 00	 mov	 eax, 21
  000b7	eb 3d		 jmp	 SHORT $LN27@PyToken_On
$LN9@PyToken_On:

; 1125 :     case '=':           return EQUAL;

  000b9	b8 16 00 00 00	 mov	 eax, 22
  000be	eb 36		 jmp	 SHORT $LN27@PyToken_On
$LN8@PyToken_On:

; 1126 :     case '.':           return DOT;

  000c0	b8 17 00 00 00	 mov	 eax, 23
  000c5	eb 2f		 jmp	 SHORT $LN27@PyToken_On
$LN7@PyToken_On:

; 1127 :     case '%':           return PERCENT;

  000c7	b8 18 00 00 00	 mov	 eax, 24
  000cc	eb 28		 jmp	 SHORT $LN27@PyToken_On
$LN6@PyToken_On:

; 1128 :     case '{':           return LBRACE;

  000ce	b8 19 00 00 00	 mov	 eax, 25
  000d3	eb 21		 jmp	 SHORT $LN27@PyToken_On
$LN5@PyToken_On:

; 1129 :     case '}':           return RBRACE;

  000d5	b8 1a 00 00 00	 mov	 eax, 26
  000da	eb 1a		 jmp	 SHORT $LN27@PyToken_On
$LN4@PyToken_On:

; 1130 :     case '^':           return CIRCUMFLEX;

  000dc	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000e1	eb 13		 jmp	 SHORT $LN27@PyToken_On
$LN3@PyToken_On:

; 1131 :     case '~':           return TILDE;

  000e3	b8 1f 00 00 00	 mov	 eax, 31
  000e8	eb 0c		 jmp	 SHORT $LN27@PyToken_On
$LN2@PyToken_On:

; 1132 :     case '@':       return AT;

  000ea	b8 31 00 00 00	 mov	 eax, 49			; 00000031H
  000ef	eb 05		 jmp	 SHORT $LN27@PyToken_On
$LN1@PyToken_On:

; 1133 :     default:            return OP;

  000f1	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN27@PyToken_On:

; 1134 :     }
; 1135 : }

  000f6	48 83 c4 18	 add	 rsp, 24
  000fa	c3		 ret	 0
  000fb	90		 npad	 1
$LN30@PyToken_On:
  000fc	00 00 00 00	 DD	 $LN7@PyToken_On
  00100	00 00 00 00	 DD	 $LN12@PyToken_On
  00104	00 00 00 00	 DD	 $LN24@PyToken_On
  00108	00 00 00 00	 DD	 $LN23@PyToken_On
  0010c	00 00 00 00	 DD	 $LN15@PyToken_On
  00110	00 00 00 00	 DD	 $LN17@PyToken_On
  00114	00 00 00 00	 DD	 $LN19@PyToken_On
  00118	00 00 00 00	 DD	 $LN16@PyToken_On
  0011c	00 00 00 00	 DD	 $LN8@PyToken_On
  00120	00 00 00 00	 DD	 $LN14@PyToken_On
  00124	00 00 00 00	 DD	 $LN20@PyToken_On
  00128	00 00 00 00	 DD	 $LN18@PyToken_On
  0012c	00 00 00 00	 DD	 $LN11@PyToken_On
  00130	00 00 00 00	 DD	 $LN9@PyToken_On
  00134	00 00 00 00	 DD	 $LN10@PyToken_On
  00138	00 00 00 00	 DD	 $LN2@PyToken_On
  0013c	00 00 00 00	 DD	 $LN22@PyToken_On
  00140	00 00 00 00	 DD	 $LN21@PyToken_On
  00144	00 00 00 00	 DD	 $LN4@PyToken_On
  00148	00 00 00 00	 DD	 $LN6@PyToken_On
  0014c	00 00 00 00	 DD	 $LN13@PyToken_On
  00150	00 00 00 00	 DD	 $LN5@PyToken_On
  00154	00 00 00 00	 DD	 $LN3@PyToken_On
  00158	00 00 00 00	 DD	 $LN1@PyToken_On
$LN29@PyToken_On:
  0015c	00		 DB	 0
  0015d	01		 DB	 1
  0015e	17		 DB	 23
  0015f	02		 DB	 2
  00160	03		 DB	 3
  00161	04		 DB	 4
  00162	05		 DB	 5
  00163	06		 DB	 6
  00164	07		 DB	 7
  00165	08		 DB	 8
  00166	09		 DB	 9
  00167	17		 DB	 23
  00168	17		 DB	 23
  00169	17		 DB	 23
  0016a	17		 DB	 23
  0016b	17		 DB	 23
  0016c	17		 DB	 23
  0016d	17		 DB	 23
  0016e	17		 DB	 23
  0016f	17		 DB	 23
  00170	17		 DB	 23
  00171	0a		 DB	 10
  00172	0b		 DB	 11
  00173	0c		 DB	 12
  00174	0d		 DB	 13
  00175	0e		 DB	 14
  00176	17		 DB	 23
  00177	0f		 DB	 15
  00178	17		 DB	 23
  00179	17		 DB	 23
  0017a	17		 DB	 23
  0017b	17		 DB	 23
  0017c	17		 DB	 23
  0017d	17		 DB	 23
  0017e	17		 DB	 23
  0017f	17		 DB	 23
  00180	17		 DB	 23
  00181	17		 DB	 23
  00182	17		 DB	 23
  00183	17		 DB	 23
  00184	17		 DB	 23
  00185	17		 DB	 23
  00186	17		 DB	 23
  00187	17		 DB	 23
  00188	17		 DB	 23
  00189	17		 DB	 23
  0018a	17		 DB	 23
  0018b	17		 DB	 23
  0018c	17		 DB	 23
  0018d	17		 DB	 23
  0018e	17		 DB	 23
  0018f	17		 DB	 23
  00190	17		 DB	 23
  00191	17		 DB	 23
  00192	10		 DB	 16
  00193	17		 DB	 23
  00194	11		 DB	 17
  00195	12		 DB	 18
  00196	17		 DB	 23
  00197	17		 DB	 23
  00198	17		 DB	 23
  00199	17		 DB	 23
  0019a	17		 DB	 23
  0019b	17		 DB	 23
  0019c	17		 DB	 23
  0019d	17		 DB	 23
  0019e	17		 DB	 23
  0019f	17		 DB	 23
  001a0	17		 DB	 23
  001a1	17		 DB	 23
  001a2	17		 DB	 23
  001a3	17		 DB	 23
  001a4	17		 DB	 23
  001a5	17		 DB	 23
  001a6	17		 DB	 23
  001a7	17		 DB	 23
  001a8	17		 DB	 23
  001a9	17		 DB	 23
  001aa	17		 DB	 23
  001ab	17		 DB	 23
  001ac	17		 DB	 23
  001ad	17		 DB	 23
  001ae	17		 DB	 23
  001af	17		 DB	 23
  001b0	17		 DB	 23
  001b1	17		 DB	 23
  001b2	13		 DB	 19
  001b3	14		 DB	 20
  001b4	15		 DB	 21
  001b5	16		 DB	 22
PyToken_OneChar ENDP
_TEXT	ENDS
PUBLIC	PyToken_TwoChars
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyToken_TwoChars DD imagerel $LN61
	DD	imagerel $LN61+676
	DD	imagerel $unwind$PyToken_TwoChars
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyToken_TwoChars DD 010c01H
	DD	0820cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyToken_TwoChars
_TEXT	SEGMENT
tv64 = 0
tv65 = 4
tv67 = 8
tv69 = 12
tv73 = 16
tv76 = 20
tv78 = 24
tv81 = 28
tv84 = 32
tv87 = 36
tv89 = 40
tv91 = 44
tv93 = 48
c1$ = 80
c2$ = 88
PyToken_TwoChars PROC					; COMDAT

; 1140 : {

$LN61:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1141 :     switch (c1) {

  0000c	8b 44 24 50	 mov	 eax, DWORD PTR c1$[rsp]
  00010	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00013	8b 04 24	 mov	 eax, DWORD PTR tv64[rsp]
  00016	83 e8 21	 sub	 eax, 33			; 00000021H
  00019	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  0001c	83 3c 24 5b	 cmp	 DWORD PTR tv64[rsp], 91	; 0000005bH
  00020	0f 87 e2 01 00
	00		 ja	 $LN55@PyToken_Tw
  00026	48 63 04 24	 movsxd	 rax, DWORD PTR tv64[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00031	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN59@PyToken_Tw[rcx+rax]
  00039	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN60@PyToken_Tw[rcx+rax*4]
  00040	48 03 c1	 add	 rax, rcx
  00043	ff e0		 jmp	 rax
$LN54@PyToken_Tw:

; 1142 :     case '=':
; 1143 :         switch (c2) {

  00045	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  00049	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  0004d	83 7c 24 04 3d	 cmp	 DWORD PTR tv65[rsp], 61	; 0000003dH
  00052	74 02		 je	 SHORT $LN51@PyToken_Tw
  00054	eb 0a		 jmp	 SHORT $LN52@PyToken_Tw
$LN51@PyToken_Tw:

; 1144 :         case '=':               return EQEQUAL;

  00056	b8 1b 00 00 00	 mov	 eax, 27
  0005b	e9 ad 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN52@PyToken_Tw:

; 1145 :         }
; 1146 :         break;

  00060	e9 a3 01 00 00	 jmp	 $LN55@PyToken_Tw
$LN50@PyToken_Tw:

; 1147 :     case '!':
; 1148 :         switch (c2) {

  00065	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  00069	89 44 24 08	 mov	 DWORD PTR tv67[rsp], eax
  0006d	83 7c 24 08 3d	 cmp	 DWORD PTR tv67[rsp], 61	; 0000003dH
  00072	74 02		 je	 SHORT $LN47@PyToken_Tw
  00074	eb 0a		 jmp	 SHORT $LN48@PyToken_Tw
$LN47@PyToken_Tw:

; 1149 :         case '=':               return NOTEQUAL;

  00076	b8 1c 00 00 00	 mov	 eax, 28
  0007b	e9 8d 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN48@PyToken_Tw:

; 1150 :         }
; 1151 :         break;

  00080	e9 83 01 00 00	 jmp	 $LN55@PyToken_Tw
$LN46@PyToken_Tw:

; 1152 :     case '<':
; 1153 :         switch (c2) {

  00085	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  00089	89 44 24 0c	 mov	 DWORD PTR tv69[rsp], eax
  0008d	83 7c 24 0c 3c	 cmp	 DWORD PTR tv69[rsp], 60	; 0000003cH
  00092	74 24		 je	 SHORT $LN41@PyToken_Tw
  00094	83 7c 24 0c 3d	 cmp	 DWORD PTR tv69[rsp], 61	; 0000003dH
  00099	74 13		 je	 SHORT $LN42@PyToken_Tw
  0009b	83 7c 24 0c 3e	 cmp	 DWORD PTR tv69[rsp], 62	; 0000003eH
  000a0	74 02		 je	 SHORT $LN43@PyToken_Tw
  000a2	eb 1e		 jmp	 SHORT $LN44@PyToken_Tw
$LN43@PyToken_Tw:

; 1154 :         case '>':               return NOTEQUAL;

  000a4	b8 1c 00 00 00	 mov	 eax, 28
  000a9	e9 5f 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN42@PyToken_Tw:

; 1155 :         case '=':               return LESSEQUAL;

  000ae	b8 1d 00 00 00	 mov	 eax, 29
  000b3	e9 55 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN41@PyToken_Tw:

; 1156 :         case '<':               return LEFTSHIFT;

  000b8	b8 21 00 00 00	 mov	 eax, 33			; 00000021H
  000bd	e9 4b 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN44@PyToken_Tw:

; 1157 :         }
; 1158 :         break;

  000c2	e9 41 01 00 00	 jmp	 $LN55@PyToken_Tw
$LN40@PyToken_Tw:

; 1159 :     case '>':
; 1160 :         switch (c2) {

  000c7	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  000cb	89 44 24 10	 mov	 DWORD PTR tv73[rsp], eax
  000cf	83 7c 24 10 3d	 cmp	 DWORD PTR tv73[rsp], 61	; 0000003dH
  000d4	74 09		 je	 SHORT $LN37@PyToken_Tw
  000d6	83 7c 24 10 3e	 cmp	 DWORD PTR tv73[rsp], 62	; 0000003eH
  000db	74 0c		 je	 SHORT $LN36@PyToken_Tw
  000dd	eb 14		 jmp	 SHORT $LN38@PyToken_Tw
$LN37@PyToken_Tw:

; 1161 :         case '=':               return GREATEREQUAL;

  000df	b8 1e 00 00 00	 mov	 eax, 30
  000e4	e9 24 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN36@PyToken_Tw:

; 1162 :         case '>':               return RIGHTSHIFT;

  000e9	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000ee	e9 1a 01 00 00	 jmp	 $LN57@PyToken_Tw
$LN38@PyToken_Tw:

; 1163 :         }
; 1164 :         break;

  000f3	e9 10 01 00 00	 jmp	 $LN55@PyToken_Tw
$LN35@PyToken_Tw:

; 1165 :     case '+':
; 1166 :         switch (c2) {

  000f8	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  000fc	89 44 24 14	 mov	 DWORD PTR tv76[rsp], eax
  00100	83 7c 24 14 3d	 cmp	 DWORD PTR tv76[rsp], 61	; 0000003dH
  00105	74 02		 je	 SHORT $LN32@PyToken_Tw
  00107	eb 0a		 jmp	 SHORT $LN33@PyToken_Tw
$LN32@PyToken_Tw:

; 1167 :         case '=':               return PLUSEQUAL;

  00109	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0010e	e9 fa 00 00 00	 jmp	 $LN57@PyToken_Tw
$LN33@PyToken_Tw:

; 1168 :         }
; 1169 :         break;

  00113	e9 f0 00 00 00	 jmp	 $LN55@PyToken_Tw
$LN31@PyToken_Tw:

; 1170 :     case '-':
; 1171 :         switch (c2) {

  00118	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  0011c	89 44 24 18	 mov	 DWORD PTR tv78[rsp], eax
  00120	83 7c 24 18 3d	 cmp	 DWORD PTR tv78[rsp], 61	; 0000003dH
  00125	74 09		 je	 SHORT $LN28@PyToken_Tw
  00127	83 7c 24 18 3e	 cmp	 DWORD PTR tv78[rsp], 62	; 0000003eH
  0012c	74 0c		 je	 SHORT $LN27@PyToken_Tw
  0012e	eb 14		 jmp	 SHORT $LN29@PyToken_Tw
$LN28@PyToken_Tw:

; 1172 :         case '=':               return MINEQUAL;

  00130	b8 25 00 00 00	 mov	 eax, 37			; 00000025H
  00135	e9 d3 00 00 00	 jmp	 $LN57@PyToken_Tw
$LN27@PyToken_Tw:

; 1173 :         case '>':               return RARROW;

  0013a	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  0013f	e9 c9 00 00 00	 jmp	 $LN57@PyToken_Tw
$LN29@PyToken_Tw:

; 1174 :         }
; 1175 :         break;

  00144	e9 bf 00 00 00	 jmp	 $LN55@PyToken_Tw
$LN26@PyToken_Tw:

; 1176 :     case '*':
; 1177 :         switch (c2) {

  00149	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  0014d	89 44 24 1c	 mov	 DWORD PTR tv81[rsp], eax
  00151	83 7c 24 1c 2a	 cmp	 DWORD PTR tv81[rsp], 42	; 0000002aH
  00156	74 09		 je	 SHORT $LN23@PyToken_Tw
  00158	83 7c 24 1c 3d	 cmp	 DWORD PTR tv81[rsp], 61	; 0000003dH
  0015d	74 0c		 je	 SHORT $LN22@PyToken_Tw
  0015f	eb 14		 jmp	 SHORT $LN24@PyToken_Tw
$LN23@PyToken_Tw:

; 1178 :         case '*':               return DOUBLESTAR;

  00161	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00166	e9 a2 00 00 00	 jmp	 $LN57@PyToken_Tw
$LN22@PyToken_Tw:

; 1179 :         case '=':               return STAREQUAL;

  0016b	b8 26 00 00 00	 mov	 eax, 38			; 00000026H
  00170	e9 98 00 00 00	 jmp	 $LN57@PyToken_Tw
$LN24@PyToken_Tw:

; 1180 :         }
; 1181 :         break;

  00175	e9 8e 00 00 00	 jmp	 $LN55@PyToken_Tw
$LN21@PyToken_Tw:

; 1182 :     case '/':
; 1183 :         switch (c2) {

  0017a	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  0017e	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  00182	83 7c 24 20 2f	 cmp	 DWORD PTR tv84[rsp], 47	; 0000002fH
  00187	74 09		 je	 SHORT $LN18@PyToken_Tw
  00189	83 7c 24 20 3d	 cmp	 DWORD PTR tv84[rsp], 61	; 0000003dH
  0018e	74 09		 je	 SHORT $LN17@PyToken_Tw
  00190	eb 0e		 jmp	 SHORT $LN19@PyToken_Tw
$LN18@PyToken_Tw:

; 1184 :         case '/':               return DOUBLESLASH;

  00192	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  00197	eb 74		 jmp	 SHORT $LN57@PyToken_Tw
$LN17@PyToken_Tw:

; 1185 :         case '=':               return SLASHEQUAL;

  00199	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0019e	eb 6d		 jmp	 SHORT $LN57@PyToken_Tw
$LN19@PyToken_Tw:

; 1186 :         }
; 1187 :         break;

  001a0	eb 66		 jmp	 SHORT $LN55@PyToken_Tw
$LN16@PyToken_Tw:

; 1188 :     case '|':
; 1189 :         switch (c2) {

  001a2	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  001a6	89 44 24 24	 mov	 DWORD PTR tv87[rsp], eax
  001aa	83 7c 24 24 3d	 cmp	 DWORD PTR tv87[rsp], 61	; 0000003dH
  001af	74 02		 je	 SHORT $LN13@PyToken_Tw
  001b1	eb 07		 jmp	 SHORT $LN14@PyToken_Tw
$LN13@PyToken_Tw:

; 1190 :         case '=':               return VBAREQUAL;

  001b3	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  001b8	eb 53		 jmp	 SHORT $LN57@PyToken_Tw
$LN14@PyToken_Tw:

; 1191 :         }
; 1192 :         break;

  001ba	eb 4c		 jmp	 SHORT $LN55@PyToken_Tw
$LN12@PyToken_Tw:

; 1193 :     case '%':
; 1194 :         switch (c2) {

  001bc	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  001c0	89 44 24 28	 mov	 DWORD PTR tv89[rsp], eax
  001c4	83 7c 24 28 3d	 cmp	 DWORD PTR tv89[rsp], 61	; 0000003dH
  001c9	74 02		 je	 SHORT $LN9@PyToken_Tw
  001cb	eb 07		 jmp	 SHORT $LN10@PyToken_Tw
$LN9@PyToken_Tw:

; 1195 :         case '=':               return PERCENTEQUAL;

  001cd	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  001d2	eb 39		 jmp	 SHORT $LN57@PyToken_Tw
$LN10@PyToken_Tw:

; 1196 :         }
; 1197 :         break;

  001d4	eb 32		 jmp	 SHORT $LN55@PyToken_Tw
$LN8@PyToken_Tw:

; 1198 :     case '&':
; 1199 :         switch (c2) {

  001d6	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  001da	89 44 24 2c	 mov	 DWORD PTR tv91[rsp], eax
  001de	83 7c 24 2c 3d	 cmp	 DWORD PTR tv91[rsp], 61	; 0000003dH
  001e3	74 02		 je	 SHORT $LN5@PyToken_Tw
  001e5	eb 07		 jmp	 SHORT $LN6@PyToken_Tw
$LN5@PyToken_Tw:

; 1200 :         case '=':               return AMPEREQUAL;

  001e7	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  001ec	eb 1f		 jmp	 SHORT $LN57@PyToken_Tw
$LN6@PyToken_Tw:

; 1201 :         }
; 1202 :         break;

  001ee	eb 18		 jmp	 SHORT $LN55@PyToken_Tw
$LN4@PyToken_Tw:

; 1203 :     case '^':
; 1204 :         switch (c2) {

  001f0	8b 44 24 58	 mov	 eax, DWORD PTR c2$[rsp]
  001f4	89 44 24 30	 mov	 DWORD PTR tv93[rsp], eax
  001f8	83 7c 24 30 3d	 cmp	 DWORD PTR tv93[rsp], 61	; 0000003dH
  001fd	74 02		 je	 SHORT $LN1@PyToken_Tw
  001ff	eb 07		 jmp	 SHORT $LN2@PyToken_Tw
$LN1@PyToken_Tw:

; 1205 :         case '=':               return CIRCUMFLEXEQUAL;

  00201	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  00206	eb 05		 jmp	 SHORT $LN57@PyToken_Tw
$LN2@PyToken_Tw:
$LN55@PyToken_Tw:

; 1206 :         }
; 1207 :         break;
; 1208 :     }
; 1209 :     return OP;

  00208	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN57@PyToken_Tw:

; 1210 : }

  0020d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00211	c3		 ret	 0
  00212	66 90		 npad	 2
$LN60@PyToken_Tw:
  00214	00 00 00 00	 DD	 $LN50@PyToken_Tw
  00218	00 00 00 00	 DD	 $LN12@PyToken_Tw
  0021c	00 00 00 00	 DD	 $LN8@PyToken_Tw
  00220	00 00 00 00	 DD	 $LN26@PyToken_Tw
  00224	00 00 00 00	 DD	 $LN35@PyToken_Tw
  00228	00 00 00 00	 DD	 $LN31@PyToken_Tw
  0022c	00 00 00 00	 DD	 $LN21@PyToken_Tw
  00230	00 00 00 00	 DD	 $LN46@PyToken_Tw
  00234	00 00 00 00	 DD	 $LN54@PyToken_Tw
  00238	00 00 00 00	 DD	 $LN40@PyToken_Tw
  0023c	00 00 00 00	 DD	 $LN4@PyToken_Tw
  00240	00 00 00 00	 DD	 $LN16@PyToken_Tw
  00244	00 00 00 00	 DD	 $LN55@PyToken_Tw
$LN59@PyToken_Tw:
  00248	00		 DB	 0
  00249	0c		 DB	 12
  0024a	0c		 DB	 12
  0024b	0c		 DB	 12
  0024c	01		 DB	 1
  0024d	02		 DB	 2
  0024e	0c		 DB	 12
  0024f	0c		 DB	 12
  00250	0c		 DB	 12
  00251	03		 DB	 3
  00252	04		 DB	 4
  00253	0c		 DB	 12
  00254	05		 DB	 5
  00255	0c		 DB	 12
  00256	06		 DB	 6
  00257	0c		 DB	 12
  00258	0c		 DB	 12
  00259	0c		 DB	 12
  0025a	0c		 DB	 12
  0025b	0c		 DB	 12
  0025c	0c		 DB	 12
  0025d	0c		 DB	 12
  0025e	0c		 DB	 12
  0025f	0c		 DB	 12
  00260	0c		 DB	 12
  00261	0c		 DB	 12
  00262	0c		 DB	 12
  00263	07		 DB	 7
  00264	08		 DB	 8
  00265	09		 DB	 9
  00266	0c		 DB	 12
  00267	0c		 DB	 12
  00268	0c		 DB	 12
  00269	0c		 DB	 12
  0026a	0c		 DB	 12
  0026b	0c		 DB	 12
  0026c	0c		 DB	 12
  0026d	0c		 DB	 12
  0026e	0c		 DB	 12
  0026f	0c		 DB	 12
  00270	0c		 DB	 12
  00271	0c		 DB	 12
  00272	0c		 DB	 12
  00273	0c		 DB	 12
  00274	0c		 DB	 12
  00275	0c		 DB	 12
  00276	0c		 DB	 12
  00277	0c		 DB	 12
  00278	0c		 DB	 12
  00279	0c		 DB	 12
  0027a	0c		 DB	 12
  0027b	0c		 DB	 12
  0027c	0c		 DB	 12
  0027d	0c		 DB	 12
  0027e	0c		 DB	 12
  0027f	0c		 DB	 12
  00280	0c		 DB	 12
  00281	0c		 DB	 12
  00282	0c		 DB	 12
  00283	0c		 DB	 12
  00284	0c		 DB	 12
  00285	0a		 DB	 10
  00286	0c		 DB	 12
  00287	0c		 DB	 12
  00288	0c		 DB	 12
  00289	0c		 DB	 12
  0028a	0c		 DB	 12
  0028b	0c		 DB	 12
  0028c	0c		 DB	 12
  0028d	0c		 DB	 12
  0028e	0c		 DB	 12
  0028f	0c		 DB	 12
  00290	0c		 DB	 12
  00291	0c		 DB	 12
  00292	0c		 DB	 12
  00293	0c		 DB	 12
  00294	0c		 DB	 12
  00295	0c		 DB	 12
  00296	0c		 DB	 12
  00297	0c		 DB	 12
  00298	0c		 DB	 12
  00299	0c		 DB	 12
  0029a	0c		 DB	 12
  0029b	0c		 DB	 12
  0029c	0c		 DB	 12
  0029d	0c		 DB	 12
  0029e	0c		 DB	 12
  0029f	0c		 DB	 12
  002a0	0c		 DB	 12
  002a1	0c		 DB	 12
  002a2	0c		 DB	 12
  002a3	0b		 DB	 11
PyToken_TwoChars ENDP
_TEXT	ENDS
PUBLIC	PyToken_ThreeChars
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyToken_ThreeChars DD imagerel $LN40
	DD	imagerel $LN40+303
	DD	imagerel $unwind$PyToken_ThreeChars
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyToken_ThreeChars DD 011101H
	DD	06211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyToken_ThreeChars
_TEXT	SEGMENT
tv64 = 0
tv65 = 4
tv66 = 8
tv69 = 12
tv70 = 16
tv73 = 20
tv74 = 24
tv77 = 28
tv78 = 32
tv81 = 36
tv82 = 40
c1$ = 64
c2$ = 72
c3$ = 80
PyToken_ThreeChars PROC					; COMDAT

; 1214 : {

$LN40:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1215 :     switch (c1) {

  00011	8b 44 24 40	 mov	 eax, DWORD PTR c1$[rsp]
  00015	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00018	83 3c 24 2a	 cmp	 DWORD PTR tv64[rsp], 42	; 0000002aH
  0001c	0f 84 84 00 00
	00		 je	 $LN21@PyToken_Th
  00022	83 3c 24 2e	 cmp	 DWORD PTR tv64[rsp], 46	; 0000002eH
  00026	0f 84 d0 00 00
	00		 je	 $LN7@PyToken_Th
  0002c	83 3c 24 2f	 cmp	 DWORD PTR tv64[rsp], 47	; 0000002fH
  00030	0f 84 9b 00 00
	00		 je	 $LN14@PyToken_Th
  00036	83 3c 24 3c	 cmp	 DWORD PTR tv64[rsp], 60	; 0000003cH
  0003a	74 0b		 je	 SHORT $LN35@PyToken_Th
  0003c	83 3c 24 3e	 cmp	 DWORD PTR tv64[rsp], 62	; 0000003eH
  00040	74 36		 je	 SHORT $LN28@PyToken_Th
  00042	e9 de 00 00 00	 jmp	 $LN36@PyToken_Th
$LN35@PyToken_Th:

; 1216 :     case '<':
; 1217 :         switch (c2) {

  00047	8b 44 24 48	 mov	 eax, DWORD PTR c2$[rsp]
  0004b	89 44 24 04	 mov	 DWORD PTR tv65[rsp], eax
  0004f	83 7c 24 04 3c	 cmp	 DWORD PTR tv65[rsp], 60	; 0000003cH
  00054	74 02		 je	 SHORT $LN32@PyToken_Th
  00056	eb 1b		 jmp	 SHORT $LN33@PyToken_Th
$LN32@PyToken_Th:

; 1218 :         case '<':
; 1219 :             switch (c3) {

  00058	8b 44 24 50	 mov	 eax, DWORD PTR c3$[rsp]
  0005c	89 44 24 08	 mov	 DWORD PTR tv66[rsp], eax
  00060	83 7c 24 08 3d	 cmp	 DWORD PTR tv66[rsp], 61	; 0000003dH
  00065	74 02		 je	 SHORT $LN29@PyToken_Th
  00067	eb 0a		 jmp	 SHORT $LN30@PyToken_Th
$LN29@PyToken_Th:

; 1220 :             case '=':
; 1221 :                 return LEFTSHIFTEQUAL;

  00069	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  0006e	e9 b7 00 00 00	 jmp	 $LN38@PyToken_Th
$LN30@PyToken_Th:
$LN33@PyToken_Th:

; 1222 :             }
; 1223 :             break;
; 1224 :         }
; 1225 :         break;

  00073	e9 ad 00 00 00	 jmp	 $LN36@PyToken_Th
$LN28@PyToken_Th:

; 1226 :     case '>':
; 1227 :         switch (c2) {

  00078	8b 44 24 48	 mov	 eax, DWORD PTR c2$[rsp]
  0007c	89 44 24 0c	 mov	 DWORD PTR tv69[rsp], eax
  00080	83 7c 24 0c 3e	 cmp	 DWORD PTR tv69[rsp], 62	; 0000003eH
  00085	74 02		 je	 SHORT $LN25@PyToken_Th
  00087	eb 1b		 jmp	 SHORT $LN26@PyToken_Th
$LN25@PyToken_Th:

; 1228 :         case '>':
; 1229 :             switch (c3) {

  00089	8b 44 24 50	 mov	 eax, DWORD PTR c3$[rsp]
  0008d	89 44 24 10	 mov	 DWORD PTR tv70[rsp], eax
  00091	83 7c 24 10 3d	 cmp	 DWORD PTR tv70[rsp], 61	; 0000003dH
  00096	74 02		 je	 SHORT $LN22@PyToken_Th
  00098	eb 0a		 jmp	 SHORT $LN23@PyToken_Th
$LN22@PyToken_Th:

; 1230 :             case '=':
; 1231 :                 return RIGHTSHIFTEQUAL;

  0009a	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0009f	e9 86 00 00 00	 jmp	 $LN38@PyToken_Th
$LN23@PyToken_Th:
$LN26@PyToken_Th:

; 1232 :             }
; 1233 :             break;
; 1234 :         }
; 1235 :         break;

  000a4	eb 7f		 jmp	 SHORT $LN36@PyToken_Th
$LN21@PyToken_Th:

; 1236 :     case '*':
; 1237 :         switch (c2) {

  000a6	8b 44 24 48	 mov	 eax, DWORD PTR c2$[rsp]
  000aa	89 44 24 14	 mov	 DWORD PTR tv73[rsp], eax
  000ae	83 7c 24 14 2a	 cmp	 DWORD PTR tv73[rsp], 42	; 0000002aH
  000b3	74 02		 je	 SHORT $LN18@PyToken_Th
  000b5	eb 18		 jmp	 SHORT $LN19@PyToken_Th
$LN18@PyToken_Th:

; 1238 :         case '*':
; 1239 :             switch (c3) {

  000b7	8b 44 24 50	 mov	 eax, DWORD PTR c3$[rsp]
  000bb	89 44 24 18	 mov	 DWORD PTR tv74[rsp], eax
  000bf	83 7c 24 18 3d	 cmp	 DWORD PTR tv74[rsp], 61	; 0000003dH
  000c4	74 02		 je	 SHORT $LN15@PyToken_Th
  000c6	eb 07		 jmp	 SHORT $LN16@PyToken_Th
$LN15@PyToken_Th:

; 1240 :             case '=':
; 1241 :                 return DOUBLESTAREQUAL;

  000c8	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000cd	eb 5b		 jmp	 SHORT $LN38@PyToken_Th
$LN16@PyToken_Th:
$LN19@PyToken_Th:

; 1242 :             }
; 1243 :             break;
; 1244 :         }
; 1245 :         break;

  000cf	eb 54		 jmp	 SHORT $LN36@PyToken_Th
$LN14@PyToken_Th:

; 1246 :     case '/':
; 1247 :         switch (c2) {

  000d1	8b 44 24 48	 mov	 eax, DWORD PTR c2$[rsp]
  000d5	89 44 24 1c	 mov	 DWORD PTR tv77[rsp], eax
  000d9	83 7c 24 1c 2f	 cmp	 DWORD PTR tv77[rsp], 47	; 0000002fH
  000de	74 02		 je	 SHORT $LN11@PyToken_Th
  000e0	eb 18		 jmp	 SHORT $LN12@PyToken_Th
$LN11@PyToken_Th:

; 1248 :         case '/':
; 1249 :             switch (c3) {

  000e2	8b 44 24 50	 mov	 eax, DWORD PTR c3$[rsp]
  000e6	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  000ea	83 7c 24 20 3d	 cmp	 DWORD PTR tv78[rsp], 61	; 0000003dH
  000ef	74 02		 je	 SHORT $LN8@PyToken_Th
  000f1	eb 07		 jmp	 SHORT $LN9@PyToken_Th
$LN8@PyToken_Th:

; 1250 :             case '=':
; 1251 :                 return DOUBLESLASHEQUAL;

  000f3	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  000f8	eb 30		 jmp	 SHORT $LN38@PyToken_Th
$LN9@PyToken_Th:
$LN12@PyToken_Th:

; 1252 :             }
; 1253 :             break;
; 1254 :         }
; 1255 :         break;

  000fa	eb 29		 jmp	 SHORT $LN36@PyToken_Th
$LN7@PyToken_Th:

; 1256 :     case '.':
; 1257 :         switch (c2) {

  000fc	8b 44 24 48	 mov	 eax, DWORD PTR c2$[rsp]
  00100	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
  00104	83 7c 24 24 2e	 cmp	 DWORD PTR tv81[rsp], 46	; 0000002eH
  00109	74 02		 je	 SHORT $LN4@PyToken_Th
  0010b	eb 18		 jmp	 SHORT $LN5@PyToken_Th
$LN4@PyToken_Th:

; 1258 :         case '.':
; 1259 :             switch (c3) {

  0010d	8b 44 24 50	 mov	 eax, DWORD PTR c3$[rsp]
  00111	89 44 24 28	 mov	 DWORD PTR tv82[rsp], eax
  00115	83 7c 24 28 2e	 cmp	 DWORD PTR tv82[rsp], 46	; 0000002eH
  0011a	74 02		 je	 SHORT $LN1@PyToken_Th
  0011c	eb 07		 jmp	 SHORT $LN2@PyToken_Th
$LN1@PyToken_Th:

; 1260 :             case '.':
; 1261 :                 return ELLIPSIS;

  0011e	b8 33 00 00 00	 mov	 eax, 51			; 00000033H
  00123	eb 05		 jmp	 SHORT $LN38@PyToken_Th
$LN2@PyToken_Th:
$LN5@PyToken_Th:
$LN36@PyToken_Th:

; 1262 :             }
; 1263 :             break;
; 1264 :         }
; 1265 :         break;
; 1266 :     }
; 1267 :     return OP;

  00125	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN38@PyToken_Th:

; 1268 : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
PyToken_ThreeChars ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_Get
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_Get DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$PyTokenizer_Get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_Get DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_Get
_TEXT	SEGMENT
result$ = 32
tok$ = 64
p_start$ = 72
p_end$ = 80
PyTokenizer_Get PROC					; COMDAT

; 1726 : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1727 :     int result = tok_get(tok, p_start, p_end);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR p_end$[rsp]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR p_start$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tok$[rsp]
  00022	e8 00 00 00 00	 call	 tok_get
  00027	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1728 :     if (tok->decoding_erred) {

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00030	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00037	74 14		 je	 SHORT $LN1@PyTokenize@5

; 1729 :         result = ERRORTOKEN;

  00039	c7 44 24 20 35
	00 00 00	 mov	 DWORD PTR result$[rsp], 53 ; 00000035H

; 1730 :         tok->done = E_DECODE;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00046	c7 40 28 16 00
	00 00		 mov	 DWORD PTR [rax+40], 22
$LN1@PyTokenize@5:

; 1731 :     }
; 1732 :     return result;

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 1733 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
PyTokenizer_Get ENDP
_TEXT	ENDS
EXTRN	__imp_isxdigit:PROC
EXTRN	__imp_isdigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_get DD imagerel tok_get
	DD	imagerel tok_get+4142
	DD	imagerel $unwind$tok_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_get DD 011301H
	DD	0e213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tok_get
_TEXT	SEGMENT
blankline$ = 32
nonascii$ = 36
c$ = 40
col$21446 = 44
altcol$21447 = 48
saw_r$21496 = 52
saw_u$21497 = 56
saw_b$21495 = 60
nonzero$21562 = 64
quote$21599 = 68
quote_size$21600 = 72
end_quote_size$21601 = 76
token$21619 = 80
c2$21618 = 84
c3$21621 = 88
token3$21622 = 92
tv171 = 96
tv245 = 100
tv483 = 104
tok$ = 128
p_start$ = 136
p_end$ = 144
tok_get	PROC						; COMDAT

; 1324 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1325 :     register int c;
; 1326 :     int blankline, nonascii;
; 1327 : 
; 1328 :     *p_start = *p_end = NULL;

  00013	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  0001b	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00022	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  0002a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$nextline$21443:

; 1329 :   nextline:
; 1330 :     tok->start = NULL;

  00031	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00039	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 1331 :     blankline = 0;

  00041	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR blankline$[rsp], 0

; 1332 : 
; 1333 :     /* Get indentation level */
; 1334 :     if (tok->atbol) {

  00049	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00051	83 b8 d0 01 00
	00 00		 cmp	 DWORD PTR [rax+464], 0
  00058	0f 84 9a 03 00
	00		 je	 $LN156@tok_get

; 1335 :         register int col = 0;

  0005e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR col$21446[rsp], 0

; 1336 :         register int altcol = 0;

  00066	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR altcol$21447[rsp], 0

; 1337 :         tok->atbol = 0;

  0006e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00076	c7 80 d0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+464], 0
$LN155@tok_get:

; 1338 :         for (;;) {
; 1339 :             c = tok_nextc(tok);

  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00088	e8 00 00 00 00	 call	 tok_nextc
  0008d	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1340 :             if (c == ' ')

  00091	83 7c 24 28 20	 cmp	 DWORD PTR c$[rsp], 32	; 00000020H
  00096	75 16		 jne	 SHORT $LN153@tok_get

; 1341 :                 col++, altcol++;

  00098	8b 44 24 2c	 mov	 eax, DWORD PTR col$21446[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 44 24 2c	 mov	 DWORD PTR col$21446[rsp], eax
  000a2	8b 44 24 30	 mov	 eax, DWORD PTR altcol$21447[rsp]
  000a6	ff c0		 inc	 eax
  000a8	89 44 24 30	 mov	 DWORD PTR altcol$21447[rsp], eax
  000ac	eb 6e		 jmp	 SHORT $LN152@tok_get
$LN153@tok_get:

; 1342 :             else if (c == '\t') {

  000ae	83 7c 24 28 09	 cmp	 DWORD PTR c$[rsp], 9
  000b3	75 4c		 jne	 SHORT $LN151@tok_get

; 1343 :                 col = (col/tok->tabsize + 1) * tok->tabsize;

  000b5	8b 44 24 2c	 mov	 eax, DWORD PTR col$21446[rsp]
  000b9	99		 cdq
  000ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000c2	f7 79 38	 idiv	 DWORD PTR [rcx+56]
  000c5	ff c0		 inc	 eax
  000c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000cf	0f af 41 38	 imul	 eax, DWORD PTR [rcx+56]
  000d3	89 44 24 2c	 mov	 DWORD PTR col$21446[rsp], eax

; 1344 :                 altcol = (altcol/tok->alttabsize + 1)
; 1345 :                     * tok->alttabsize;

  000d7	8b 44 24 30	 mov	 eax, DWORD PTR altcol$21447[rsp]
  000db	99		 cdq
  000dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000e4	f7 b9 00 02 00
	00		 idiv	 DWORD PTR [rcx+512]
  000ea	ff c0		 inc	 eax
  000ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000f4	0f af 81 00 02
	00 00		 imul	 eax, DWORD PTR [rcx+512]
  000fb	89 44 24 30	 mov	 DWORD PTR altcol$21447[rsp], eax
  000ff	eb 1b		 jmp	 SHORT $LN150@tok_get
$LN151@tok_get:

; 1346 :             }
; 1347 :             else if (c == '\014') /* Control-L (formfeed) */

  00101	83 7c 24 28 0c	 cmp	 DWORD PTR c$[rsp], 12
  00106	75 12		 jne	 SHORT $LN149@tok_get

; 1348 :                 col = altcol = 0; /* For Emacs users */

  00108	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR altcol$21447[rsp], 0
  00110	8b 44 24 30	 mov	 eax, DWORD PTR altcol$21447[rsp]
  00114	89 44 24 2c	 mov	 DWORD PTR col$21446[rsp], eax

; 1349 :             else

  00118	eb 02		 jmp	 SHORT $LN148@tok_get
$LN149@tok_get:

; 1350 :                 break;

  0011a	eb 05		 jmp	 SHORT $LN154@tok_get
$LN148@tok_get:
$LN150@tok_get:
$LN152@tok_get:

; 1351 :         }

  0011c	e9 5f ff ff ff	 jmp	 $LN155@tok_get
$LN154@tok_get:

; 1352 :         tok_backup(tok, c);

  00121	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00125	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0012d	e8 00 00 00 00	 call	 tok_backup

; 1353 :         if (c == '#' || c == '\n') {

  00132	83 7c 24 28 23	 cmp	 DWORD PTR c$[rsp], 35	; 00000023H
  00137	74 07		 je	 SHORT $LN146@tok_get
  00139	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  0013e	75 32		 jne	 SHORT $LN147@tok_get
$LN146@tok_get:

; 1354 :             /* Lines with only whitespace and/or comments
; 1355 :                shouldn't affect the indentation and are
; 1356 :                not passed to the parser as NEWLINE tokens,
; 1357 :                except *totally* empty lines in interactive
; 1358 :                mode, which signal the end of a command group. */
; 1359 :             if (col == 0 && c == '\n' && tok->prompt != NULL)

  00140	83 7c 24 2c 00	 cmp	 DWORD PTR col$21446[rsp], 0
  00145	75 23		 jne	 SHORT $LN145@tok_get
  00147	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  0014c	75 1c		 jne	 SHORT $LN145@tok_get
  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00156	48 83 b8 d8 01
	00 00 00	 cmp	 QWORD PTR [rax+472], 0
  0015e	74 0a		 je	 SHORT $LN145@tok_get

; 1360 :                 blankline = 0; /* Let it through */

  00160	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR blankline$[rsp], 0

; 1361 :             else

  00168	eb 08		 jmp	 SHORT $LN144@tok_get
$LN145@tok_get:

; 1362 :                 blankline = 1; /* Ignore completely */

  0016a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR blankline$[rsp], 1
$LN144@tok_get:
$LN147@tok_get:

; 1363 :             /* We can't jump back right here since we still
; 1364 :                may need to skip to the end of a comment */
; 1365 :         }
; 1366 :         if (!blankline && tok->level == 0) {

  00172	83 7c 24 20 00	 cmp	 DWORD PTR blankline$[rsp], 0
  00177	0f 85 7b 02 00
	00		 jne	 $LN143@tok_get
  0017d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00185	83 b8 ec 01 00
	00 00		 cmp	 DWORD PTR [rax+492], 0
  0018c	0f 85 66 02 00
	00		 jne	 $LN143@tok_get

; 1367 :             if (col == tok->indstack[tok->indent]) {

  00192	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0019a	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0019e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  001a6	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  001aa	39 44 24 2c	 cmp	 DWORD PTR col$21446[rsp], eax
  001ae	75 41		 jne	 SHORT $LN142@tok_get

; 1368 :                 /* No change */
; 1369 :                 if (altcol != tok->altindstack[tok->indent]) {

  001b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  001b8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  001bc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  001c4	8b 84 81 04 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+516]
  001cb	39 44 24 30	 cmp	 DWORD PTR altcol$21447[rsp], eax
  001cf	74 1b		 je	 SHORT $LN141@tok_get

; 1370 :                     if (indenterror(tok))

  001d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  001d9	e8 00 00 00 00	 call	 indenterror
  001de	85 c0		 test	 eax, eax
  001e0	74 0a		 je	 SHORT $LN140@tok_get

; 1371 :                         return ERRORTOKEN;

  001e2	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  001e7	e9 d8 0d 00 00	 jmp	 $LN157@tok_get
$LN140@tok_get:
$LN141@tok_get:

; 1372 :                 }

  001ec	e9 07 02 00 00	 jmp	 $LN139@tok_get
$LN142@tok_get:

; 1373 :             }
; 1374 :             else if (col > tok->indstack[tok->indent]) {

  001f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  001f9	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  001fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00205	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  00209	39 44 24 2c	 cmp	 DWORD PTR col$21446[rsp], eax
  0020d	0f 8e f6 00 00
	00		 jle	 $LN138@tok_get

; 1375 :                 /* Indent -- always one */
; 1376 :                 if (tok->indent+1 >= MAXINDENT) {

  00213	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0021b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0021e	ff c0		 inc	 eax
  00220	83 f8 64	 cmp	 eax, 100		; 00000064H
  00223	7c 31		 jl	 SHORT $LN137@tok_get

; 1377 :                     tok->done = E_TOODEEP;

  00225	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0022d	c7 40 28 14 00
	00 00		 mov	 DWORD PTR [rax+40], 20

; 1378 :                     tok->cur = tok->inp;

  00234	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0023c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00244	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00248	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1379 :                     return ERRORTOKEN;

  0024c	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00251	e9 6e 0d 00 00	 jmp	 $LN157@tok_get
$LN137@tok_get:

; 1380 :                 }
; 1381 :                 if (altcol <= tok->altindstack[tok->indent]) {

  00256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0025e	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00262	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0026a	8b 84 81 04 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+516]
  00271	39 44 24 30	 cmp	 DWORD PTR altcol$21447[rsp], eax
  00275	7f 1b		 jg	 SHORT $LN136@tok_get

; 1382 :                     if (indenterror(tok))

  00277	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0027f	e8 00 00 00 00	 call	 indenterror
  00284	85 c0		 test	 eax, eax
  00286	74 0a		 je	 SHORT $LN135@tok_get

; 1383 :                         return ERRORTOKEN;

  00288	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  0028d	e9 32 0d 00 00	 jmp	 $LN157@tok_get
$LN135@tok_get:
$LN136@tok_get:

; 1384 :                 }
; 1385 :                 tok->pendin++;

  00292	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0029a	8b 80 d4 01 00
	00		 mov	 eax, DWORD PTR [rax+468]
  002a0	ff c0		 inc	 eax
  002a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  002aa	89 81 d4 01 00
	00		 mov	 DWORD PTR [rcx+468], eax

; 1386 :                 tok->indstack[++tok->indent] = col;

  002b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002b8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  002bb	ff c0		 inc	 eax
  002bd	89 44 24 60	 mov	 DWORD PTR tv171[rsp], eax
  002c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002c9	8b 4c 24 60	 mov	 ecx, DWORD PTR tv171[rsp]
  002cd	89 48 3c	 mov	 DWORD PTR [rax+60], ecx
  002d0	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv171[rsp]
  002d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  002dd	8b 54 24 2c	 mov	 edx, DWORD PTR col$21446[rsp]
  002e1	89 54 81 40	 mov	 DWORD PTR [rcx+rax*4+64], edx

; 1387 :                 tok->altindstack[tok->indent] = altcol;

  002e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002ed	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  002f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  002f9	8b 54 24 30	 mov	 edx, DWORD PTR altcol$21447[rsp]
  002fd	89 94 81 04 02
	00 00		 mov	 DWORD PTR [rcx+rax*4+516], edx

; 1388 :             }
; 1389 :             else /* col < tok->indstack[tok->indent] */ {

  00304	e9 ef 00 00 00	 jmp	 $LN134@tok_get
$LN138@tok_get:
$LN133@tok_get:

; 1390 :                 /* Dedent -- any number, must be consistent */
; 1391 :                 while (tok->indent > 0 &&
; 1392 :                     col < tok->indstack[tok->indent]) {

  00309	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00311	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00315	7e 56		 jle	 SHORT $LN132@tok_get
  00317	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0031f	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00323	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0032b	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  0032f	39 44 24 2c	 cmp	 DWORD PTR col$21446[rsp], eax
  00333	7d 38		 jge	 SHORT $LN132@tok_get

; 1393 :                     tok->pendin--;

  00335	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0033d	8b 80 d4 01 00
	00		 mov	 eax, DWORD PTR [rax+468]
  00343	ff c8		 dec	 eax
  00345	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0034d	89 81 d4 01 00
	00		 mov	 DWORD PTR [rcx+468], eax

; 1394 :                     tok->indent--;

  00353	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0035b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0035e	ff c8		 dec	 eax
  00360	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00368	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 1395 :                 }

  0036b	eb 9c		 jmp	 SHORT $LN133@tok_get
$LN132@tok_get:

; 1396 :                 if (col != tok->indstack[tok->indent]) {

  0036d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00375	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00379	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00381	8b 44 81 40	 mov	 eax, DWORD PTR [rcx+rax*4+64]
  00385	39 44 24 2c	 cmp	 DWORD PTR col$21446[rsp], eax
  00389	74 31		 je	 SHORT $LN131@tok_get

; 1397 :                     tok->done = E_DEDENT;

  0038b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00393	c7 40 28 15 00
	00 00		 mov	 DWORD PTR [rax+40], 21

; 1398 :                     tok->cur = tok->inp;

  0039a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  003a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  003aa	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003ae	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1399 :                     return ERRORTOKEN;

  003b2	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  003b7	e9 08 0c 00 00	 jmp	 $LN157@tok_get
$LN131@tok_get:

; 1400 :                 }
; 1401 :                 if (altcol != tok->altindstack[tok->indent]) {

  003bc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  003c4	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  003c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  003d0	8b 84 81 04 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+516]
  003d7	39 44 24 30	 cmp	 DWORD PTR altcol$21447[rsp], eax
  003db	74 1b		 je	 SHORT $LN130@tok_get

; 1402 :                     if (indenterror(tok))

  003dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  003e5	e8 00 00 00 00	 call	 indenterror
  003ea	85 c0		 test	 eax, eax
  003ec	74 0a		 je	 SHORT $LN129@tok_get

; 1403 :                         return ERRORTOKEN;

  003ee	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  003f3	e9 cc 0b 00 00	 jmp	 $LN157@tok_get
$LN129@tok_get:
$LN130@tok_get:
$LN134@tok_get:
$LN139@tok_get:
$LN143@tok_get:
$LN156@tok_get:

; 1404 :                 }
; 1405 :             }
; 1406 :         }
; 1407 :     }
; 1408 : 
; 1409 :     tok->start = tok->cur;

  003f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00400	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00408	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0040c	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1410 : 
; 1411 :     /* Return pending indents/dedents */
; 1412 :     if (tok->pendin != 0) {

  00410	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00418	83 b8 d4 01 00
	00 00		 cmp	 DWORD PTR [rax+468], 0
  0041f	74 63		 je	 SHORT $LN128@tok_get

; 1413 :         if (tok->pendin < 0) {

  00421	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00429	83 b8 d4 01 00
	00 00		 cmp	 DWORD PTR [rax+468], 0
  00430	7d 2a		 jge	 SHORT $LN127@tok_get

; 1414 :             tok->pendin++;

  00432	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0043a	8b 80 d4 01 00
	00		 mov	 eax, DWORD PTR [rax+468]
  00440	ff c0		 inc	 eax
  00442	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0044a	89 81 d4 01 00
	00		 mov	 DWORD PTR [rcx+468], eax

; 1415 :             return DEDENT;

  00450	b8 06 00 00 00	 mov	 eax, 6
  00455	e9 6a 0b 00 00	 jmp	 $LN157@tok_get

; 1416 :         }
; 1417 :         else {

  0045a	eb 28		 jmp	 SHORT $LN126@tok_get
$LN127@tok_get:

; 1418 :             tok->pendin--;

  0045c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00464	8b 80 d4 01 00
	00		 mov	 eax, DWORD PTR [rax+468]
  0046a	ff c8		 dec	 eax
  0046c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00474	89 81 d4 01 00
	00		 mov	 DWORD PTR [rcx+468], eax

; 1419 :             return INDENT;

  0047a	b8 05 00 00 00	 mov	 eax, 5
  0047f	e9 40 0b 00 00	 jmp	 $LN157@tok_get
$LN126@tok_get:
$LN128@tok_get:
$again$21481:

; 1420 :         }
; 1421 :     }
; 1422 : 
; 1423 :  again:
; 1424 :     tok->start = NULL;

  00484	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0048c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN162@tok_get:
$LN161@tok_get:
$LN125@tok_get:

; 1425 :     /* Skip spaces */
; 1426 :     do {
; 1427 :         c = tok_nextc(tok);

  00494	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0049c	e8 00 00 00 00	 call	 tok_nextc
  004a1	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1428 :     } while (c == ' ' || c == '\t' || c == '\014');

  004a5	83 7c 24 28 20	 cmp	 DWORD PTR c$[rsp], 32	; 00000020H
  004aa	74 e8		 je	 SHORT $LN125@tok_get
  004ac	83 7c 24 28 09	 cmp	 DWORD PTR c$[rsp], 9
  004b1	74 e1		 je	 SHORT $LN161@tok_get
  004b3	83 7c 24 28 0c	 cmp	 DWORD PTR c$[rsp], 12
  004b8	74 da		 je	 SHORT $LN162@tok_get

; 1429 : 
; 1430 :     /* Set start of current token */
; 1431 :     tok->start = tok->cur - 1;

  004ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004c2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004c6	48 ff c8	 dec	 rax
  004c9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  004d1	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1432 : 
; 1433 :     /* Skip comment */
; 1434 :     if (c == '#')

  004d5	83 7c 24 28 23	 cmp	 DWORD PTR c$[rsp], 35	; 00000023H
  004da	75 21		 jne	 SHORT $LN122@tok_get
$LN121@tok_get:

; 1435 :         while (c != EOF && c != '\n')

  004dc	83 7c 24 28 ff	 cmp	 DWORD PTR c$[rsp], -1
  004e1	74 1a		 je	 SHORT $LN120@tok_get
  004e3	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  004e8	74 13		 je	 SHORT $LN120@tok_get

; 1436 :             c = tok_nextc(tok);

  004ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  004f2	e8 00 00 00 00	 call	 tok_nextc
  004f7	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax
  004fb	eb df		 jmp	 SHORT $LN121@tok_get
$LN120@tok_get:
$LN122@tok_get:

; 1437 : 
; 1438 :     /* Check for EOF and errors now */
; 1439 :     if (c == EOF) {

  004fd	83 7c 24 28 ff	 cmp	 DWORD PTR c$[rsp], -1
  00502	75 29		 jne	 SHORT $LN119@tok_get

; 1440 :         return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;

  00504	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0050c	83 78 28 0b	 cmp	 DWORD PTR [rax+40], 11
  00510	75 0a		 jne	 SHORT $LN159@tok_get
  00512	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv245[rsp], 0
  0051a	eb 08		 jmp	 SHORT $LN160@tok_get
$LN159@tok_get:
  0051c	c7 44 24 64 35
	00 00 00	 mov	 DWORD PTR tv245[rsp], 53 ; 00000035H
$LN160@tok_get:
  00524	8b 44 24 64	 mov	 eax, DWORD PTR tv245[rsp]
  00528	e9 97 0a 00 00	 jmp	 $LN157@tok_get
$LN119@tok_get:

; 1441 :     }
; 1442 : 
; 1443 :     /* Identifier (most frequent token!) */
; 1444 :     nonascii = 0;

  0052d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR nonascii$[rsp], 0

; 1445 :     if (is_potential_identifier_start(c)) {

  00535	83 7c 24 28 61	 cmp	 DWORD PTR c$[rsp], 97	; 00000061H
  0053a	7c 07		 jl	 SHORT $LN116@tok_get
  0053c	83 7c 24 28 7a	 cmp	 DWORD PTR c$[rsp], 122	; 0000007aH
  00541	7e 23		 jle	 SHORT $LN117@tok_get
$LN116@tok_get:
  00543	83 7c 24 28 41	 cmp	 DWORD PTR c$[rsp], 65	; 00000041H
  00548	7c 07		 jl	 SHORT $LN115@tok_get
  0054a	83 7c 24 28 5a	 cmp	 DWORD PTR c$[rsp], 90	; 0000005aH
  0054f	7e 15		 jle	 SHORT $LN117@tok_get
$LN115@tok_get:
  00551	83 7c 24 28 5f	 cmp	 DWORD PTR c$[rsp], 95	; 0000005fH
  00556	74 0e		 je	 SHORT $LN117@tok_get
  00558	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR c$[rsp], 128	; 00000080H
  00560	0f 8c a1 01 00
	00		 jl	 $LN118@tok_get
$LN117@tok_get:

; 1446 :         /* Process b"", r"", u"", br"" and rb"" */
; 1447 :         int saw_b = 0, saw_r = 0, saw_u = 0;

  00566	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR saw_b$21495[rsp], 0
  0056e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR saw_r$21496[rsp], 0
  00576	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR saw_u$21497[rsp], 0
$LN114@tok_get:

; 1448 :         while (1) {

  0057e	33 c0		 xor	 eax, eax
  00580	83 f8 01	 cmp	 eax, 1
  00583	0f 84 a4 00 00
	00		 je	 $LN113@tok_get

; 1449 :             if (!(saw_b || saw_u) && (c == 'b' || c == 'B'))

  00589	83 7c 24 3c 00	 cmp	 DWORD PTR saw_b$21495[rsp], 0
  0058e	75 1f		 jne	 SHORT $LN112@tok_get
  00590	83 7c 24 38 00	 cmp	 DWORD PTR saw_u$21497[rsp], 0
  00595	75 18		 jne	 SHORT $LN112@tok_get
  00597	83 7c 24 28 62	 cmp	 DWORD PTR c$[rsp], 98	; 00000062H
  0059c	74 07		 je	 SHORT $LN111@tok_get
  0059e	83 7c 24 28 42	 cmp	 DWORD PTR c$[rsp], 66	; 00000042H
  005a3	75 0a		 jne	 SHORT $LN112@tok_get
$LN111@tok_get:

; 1450 :                 saw_b = 1;

  005a5	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR saw_b$21495[rsp], 1
  005ad	eb 55		 jmp	 SHORT $LN110@tok_get
$LN112@tok_get:

; 1451 :             /* Since this is a backwards compatibility support literal we don't
; 1452 :                want to support it in arbitrary order like byte literals. */
; 1453 :             else if (!(saw_b || saw_u || saw_r) && (c == 'u' || c == 'U'))

  005af	83 7c 24 3c 00	 cmp	 DWORD PTR saw_b$21495[rsp], 0
  005b4	75 26		 jne	 SHORT $LN109@tok_get
  005b6	83 7c 24 38 00	 cmp	 DWORD PTR saw_u$21497[rsp], 0
  005bb	75 1f		 jne	 SHORT $LN109@tok_get
  005bd	83 7c 24 34 00	 cmp	 DWORD PTR saw_r$21496[rsp], 0
  005c2	75 18		 jne	 SHORT $LN109@tok_get
  005c4	83 7c 24 28 75	 cmp	 DWORD PTR c$[rsp], 117	; 00000075H
  005c9	74 07		 je	 SHORT $LN108@tok_get
  005cb	83 7c 24 28 55	 cmp	 DWORD PTR c$[rsp], 85	; 00000055H
  005d0	75 0a		 jne	 SHORT $LN109@tok_get
$LN108@tok_get:

; 1454 :                 saw_u = 1;

  005d2	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR saw_u$21497[rsp], 1
  005da	eb 28		 jmp	 SHORT $LN107@tok_get
$LN109@tok_get:

; 1455 :             /* ur"" and ru"" are not supported */
; 1456 :             else if (!(saw_r || saw_u) && (c == 'r' || c == 'R'))

  005dc	83 7c 24 34 00	 cmp	 DWORD PTR saw_r$21496[rsp], 0
  005e1	75 1f		 jne	 SHORT $LN106@tok_get
  005e3	83 7c 24 38 00	 cmp	 DWORD PTR saw_u$21497[rsp], 0
  005e8	75 18		 jne	 SHORT $LN106@tok_get
  005ea	83 7c 24 28 72	 cmp	 DWORD PTR c$[rsp], 114	; 00000072H
  005ef	74 07		 je	 SHORT $LN105@tok_get
  005f1	83 7c 24 28 52	 cmp	 DWORD PTR c$[rsp], 82	; 00000052H
  005f6	75 0a		 jne	 SHORT $LN106@tok_get
$LN105@tok_get:

; 1457 :                 saw_r = 1;

  005f8	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR saw_r$21496[rsp], 1

; 1458 :             else

  00600	eb 02		 jmp	 SHORT $LN104@tok_get
$LN106@tok_get:

; 1459 :                 break;

  00602	eb 29		 jmp	 SHORT $LN113@tok_get
$LN104@tok_get:
$LN107@tok_get:
$LN110@tok_get:

; 1460 :             c = tok_nextc(tok);

  00604	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0060c	e8 00 00 00 00	 call	 tok_nextc
  00611	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1461 :             if (c == '"' || c == '\'')

  00615	83 7c 24 28 22	 cmp	 DWORD PTR c$[rsp], 34	; 00000022H
  0061a	74 07		 je	 SHORT $LN102@tok_get
  0061c	83 7c 24 28 27	 cmp	 DWORD PTR c$[rsp], 39	; 00000027H
  00621	75 05		 jne	 SHORT $LN103@tok_get
$LN102@tok_get:

; 1462 :                 goto letter_quote;

  00623	e9 1a 06 00 00	 jmp	 $letter_quote$21512
$LN103@tok_get:

; 1463 :         }

  00628	e9 51 ff ff ff	 jmp	 $LN114@tok_get
$LN113@tok_get:
$LN101@tok_get:

; 1464 :         while (is_potential_identifier_char(c)) {

  0062d	83 7c 24 28 61	 cmp	 DWORD PTR c$[rsp], 97	; 00000061H
  00632	7c 07		 jl	 SHORT $LN98@tok_get
  00634	83 7c 24 28 7a	 cmp	 DWORD PTR c$[rsp], 122	; 0000007aH
  00639	7e 2d		 jle	 SHORT $LN99@tok_get
$LN98@tok_get:
  0063b	83 7c 24 28 41	 cmp	 DWORD PTR c$[rsp], 65	; 00000041H
  00640	7c 07		 jl	 SHORT $LN97@tok_get
  00642	83 7c 24 28 5a	 cmp	 DWORD PTR c$[rsp], 90	; 0000005aH
  00647	7e 1f		 jle	 SHORT $LN99@tok_get
$LN97@tok_get:
  00649	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  0064e	7c 07		 jl	 SHORT $LN96@tok_get
  00650	83 7c 24 28 39	 cmp	 DWORD PTR c$[rsp], 57	; 00000039H
  00655	7e 11		 jle	 SHORT $LN99@tok_get
$LN96@tok_get:
  00657	83 7c 24 28 5f	 cmp	 DWORD PTR c$[rsp], 95	; 0000005fH
  0065c	74 0a		 je	 SHORT $LN99@tok_get
  0065e	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR c$[rsp], 128	; 00000080H
  00666	7c 25		 jl	 SHORT $LN100@tok_get
$LN99@tok_get:

; 1465 :             if (c >= 128)

  00668	81 7c 24 28 80
	00 00 00	 cmp	 DWORD PTR c$[rsp], 128	; 00000080H
  00670	7c 08		 jl	 SHORT $LN95@tok_get

; 1466 :                 nonascii = 1;

  00672	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR nonascii$[rsp], 1
$LN95@tok_get:

; 1467 :             c = tok_nextc(tok);

  0067a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00682	e8 00 00 00 00	 call	 tok_nextc
  00687	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1468 :         }

  0068b	eb a0		 jmp	 SHORT $LN101@tok_get
$LN100@tok_get:

; 1469 :         tok_backup(tok, c);

  0068d	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00691	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00699	e8 00 00 00 00	 call	 tok_backup

; 1470 :         if (nonascii &&
; 1471 :             !verify_identifier(tok)) {

  0069e	83 7c 24 24 00	 cmp	 DWORD PTR nonascii$[rsp], 0
  006a3	74 2a		 je	 SHORT $LN94@tok_get
  006a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  006ad	e8 00 00 00 00	 call	 verify_identifier
  006b2	85 c0		 test	 eax, eax
  006b4	75 19		 jne	 SHORT $LN94@tok_get

; 1472 :             tok->done = E_IDENTIFIER;

  006b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006be	c7 40 28 1a 00
	00 00		 mov	 DWORD PTR [rax+40], 26

; 1473 :             return ERRORTOKEN;

  006c5	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  006ca	e9 f5 08 00 00	 jmp	 $LN157@tok_get
$LN94@tok_get:

; 1474 :         }
; 1475 :         *p_start = tok->start;

  006cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  006d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  006df	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  006e3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1476 :         *p_end = tok->cur;

  006e6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  006ee	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  006f6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  006fa	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1477 :         return NAME;

  006fd	b8 01 00 00 00	 mov	 eax, 1
  00702	e9 bd 08 00 00	 jmp	 $LN157@tok_get
$LN118@tok_get:

; 1478 :     }
; 1479 : 
; 1480 :     /* Newline */
; 1481 :     if (c == '\n') {

  00707	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  0070c	75 7c		 jne	 SHORT $LN93@tok_get

; 1482 :         tok->atbol = 1;

  0070e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00716	c7 80 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+464], 1

; 1483 :         if (blankline || tok->level > 0)

  00720	83 7c 24 20 00	 cmp	 DWORD PTR blankline$[rsp], 0
  00725	75 11		 jne	 SHORT $LN91@tok_get
  00727	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0072f	83 b8 ec 01 00
	00 00		 cmp	 DWORD PTR [rax+492], 0
  00736	7e 05		 jle	 SHORT $LN92@tok_get
$LN91@tok_get:

; 1484 :             goto nextline;

  00738	e9 f4 f8 ff ff	 jmp	 $nextline$21443
$LN92@tok_get:

; 1485 :         *p_start = tok->start;

  0073d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00745	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0074d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00751	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1486 :         *p_end = tok->cur - 1; /* Leave '\n' out of the string */

  00754	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0075c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00760	48 ff c8	 dec	 rax
  00763	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR p_end$[rsp]
  0076b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1487 :         tok->cont_line = 0;

  0076e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00776	c7 80 a8 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+936], 0

; 1488 :         return NEWLINE;

  00780	b8 04 00 00 00	 mov	 eax, 4
  00785	e9 3a 08 00 00	 jmp	 $LN157@tok_get
$LN93@tok_get:

; 1489 :     }
; 1490 : 
; 1491 :     /* Period or number starting with period? */
; 1492 :     if (c == '.') {

  0078a	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  0078f	0f 85 f0 00 00
	00		 jne	 $LN90@tok_get

; 1493 :         c = tok_nextc(tok);

  00795	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0079d	e8 00 00 00 00	 call	 tok_nextc
  007a2	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1494 :         if (isdigit(c)) {

  007a6	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  007aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  007b0	85 c0		 test	 eax, eax
  007b2	74 0a		 je	 SHORT $LN89@tok_get

; 1495 :             goto fraction;

  007b4	e9 69 03 00 00	 jmp	 $fraction$21527
  007b9	e9 8f 00 00 00	 jmp	 $LN88@tok_get
$LN89@tok_get:

; 1496 :         } else if (c == '.') {

  007be	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  007c3	75 77		 jne	 SHORT $LN87@tok_get

; 1497 :             c = tok_nextc(tok);

  007c5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  007cd	e8 00 00 00 00	 call	 tok_nextc
  007d2	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1498 :             if (c == '.') {

  007d6	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  007db	75 3a		 jne	 SHORT $LN86@tok_get

; 1499 :                 *p_start = tok->start;

  007dd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  007e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  007ed	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  007f1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1500 :                 *p_end = tok->cur;

  007f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  007fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00804	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00808	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1501 :                 return ELLIPSIS;

  0080b	b8 33 00 00 00	 mov	 eax, 51			; 00000033H
  00810	e9 af 07 00 00	 jmp	 $LN157@tok_get

; 1502 :             } else {

  00815	eb 11		 jmp	 SHORT $LN85@tok_get
$LN86@tok_get:

; 1503 :                 tok_backup(tok, c);

  00817	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  0081b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00823	e8 00 00 00 00	 call	 tok_backup
$LN85@tok_get:

; 1504 :             }
; 1505 :             tok_backup(tok, '.');

  00828	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0082d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00835	e8 00 00 00 00	 call	 tok_backup

; 1506 :         } else {

  0083a	eb 11		 jmp	 SHORT $LN84@tok_get
$LN87@tok_get:

; 1507 :             tok_backup(tok, c);

  0083c	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00840	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00848	e8 00 00 00 00	 call	 tok_backup
$LN84@tok_get:
$LN88@tok_get:

; 1508 :         }
; 1509 :         *p_start = tok->start;

  0084d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00855	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0085d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00861	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1510 :         *p_end = tok->cur;

  00864	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  0086c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00874	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00878	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1511 :         return DOT;

  0087b	b8 17 00 00 00	 mov	 eax, 23
  00880	e9 3f 07 00 00	 jmp	 $LN157@tok_get
$LN90@tok_get:

; 1512 :     }
; 1513 : 
; 1514 :     /* Number */
; 1515 :     if (isdigit(c)) {

  00885	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  0088f	85 c0		 test	 eax, eax
  00891	0f 84 ab 03 00
	00		 je	 $LN83@tok_get

; 1516 :         if (c == '0') {

  00897	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  0089c	0f 85 5a 02 00
	00		 jne	 $LN82@tok_get

; 1517 :             /* Hex, octal or binary -- maybe. */
; 1518 :             c = tok_nextc(tok);

  008a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  008aa	e8 00 00 00 00	 call	 tok_nextc
  008af	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1519 :             if (c == '.')

  008b3	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  008b8	75 05		 jne	 SHORT $LN81@tok_get

; 1520 :                 goto fraction;

  008ba	e9 63 02 00 00	 jmp	 $fraction$21527
$LN81@tok_get:

; 1521 :             if (c == 'j' || c == 'J')

  008bf	83 7c 24 28 6a	 cmp	 DWORD PTR c$[rsp], 106	; 0000006aH
  008c4	74 07		 je	 SHORT $LN79@tok_get
  008c6	83 7c 24 28 4a	 cmp	 DWORD PTR c$[rsp], 74	; 0000004aH
  008cb	75 05		 jne	 SHORT $LN80@tok_get
$LN79@tok_get:

; 1522 :                 goto imaginary;

  008cd	e9 16 03 00 00	 jmp	 $imaginary$21538
$LN80@tok_get:

; 1523 :             if (c == 'x' || c == 'X') {

  008d2	83 7c 24 28 78	 cmp	 DWORD PTR c$[rsp], 120	; 00000078H
  008d7	74 07		 je	 SHORT $LN77@tok_get
  008d9	83 7c 24 28 58	 cmp	 DWORD PTR c$[rsp], 88	; 00000058H
  008de	75 6d		 jne	 SHORT $LN78@tok_get
$LN77@tok_get:

; 1524 : 
; 1525 :                 /* Hex */
; 1526 :                 c = tok_nextc(tok);

  008e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  008e8	e8 00 00 00 00	 call	 tok_nextc
  008ed	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1527 :                 if (!isxdigit(c)) {

  008f1	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  008f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  008fb	85 c0		 test	 eax, eax
  008fd	75 2a		 jne	 SHORT $LN76@tok_get

; 1528 :                     tok->done = E_TOKEN;

  008ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00907	c7 40 28 0d 00
	00 00		 mov	 DWORD PTR [rax+40], 13

; 1529 :                     tok_backup(tok, c);

  0090e	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00912	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0091a	e8 00 00 00 00	 call	 tok_backup

; 1530 :                     return ERRORTOKEN;

  0091f	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00924	e9 9b 06 00 00	 jmp	 $LN157@tok_get
$LN76@tok_get:
$LN75@tok_get:

; 1531 :                 }
; 1532 :                 do {
; 1533 :                     c = tok_nextc(tok);

  00929	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00931	e8 00 00 00 00	 call	 tok_nextc
  00936	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1534 :                 } while (isxdigit(c));

  0093a	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  0093e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  00944	85 c0		 test	 eax, eax
  00946	75 e1		 jne	 SHORT $LN75@tok_get

; 1535 :             }
; 1536 :             else if (c == 'o' || c == 'O') {

  00948	e9 aa 01 00 00	 jmp	 $LN72@tok_get
$LN78@tok_get:
  0094d	83 7c 24 28 6f	 cmp	 DWORD PTR c$[rsp], 111	; 0000006fH
  00952	74 07		 je	 SHORT $LN70@tok_get
  00954	83 7c 24 28 4f	 cmp	 DWORD PTR c$[rsp], 79	; 0000004fH
  00959	75 6d		 jne	 SHORT $LN71@tok_get
$LN70@tok_get:

; 1537 :                 /* Octal */
; 1538 :                 c = tok_nextc(tok);

  0095b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00963	e8 00 00 00 00	 call	 tok_nextc
  00968	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1539 :                 if (c < '0' || c >= '8') {

  0096c	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  00971	7c 07		 jl	 SHORT $LN68@tok_get
  00973	83 7c 24 28 38	 cmp	 DWORD PTR c$[rsp], 56	; 00000038H
  00978	7c 2a		 jl	 SHORT $LN69@tok_get
$LN68@tok_get:

; 1540 :                     tok->done = E_TOKEN;

  0097a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00982	c7 40 28 0d 00
	00 00		 mov	 DWORD PTR [rax+40], 13

; 1541 :                     tok_backup(tok, c);

  00989	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  0098d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00995	e8 00 00 00 00	 call	 tok_backup

; 1542 :                     return ERRORTOKEN;

  0099a	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  0099f	e9 20 06 00 00	 jmp	 $LN157@tok_get
$LN69@tok_get:
$LN67@tok_get:

; 1543 :                 }
; 1544 :                 do {
; 1545 :                     c = tok_nextc(tok);

  009a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  009ac	e8 00 00 00 00	 call	 tok_nextc
  009b1	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1546 :                 } while ('0' <= c && c < '8');

  009b5	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  009ba	7c 07		 jl	 SHORT $LN64@tok_get
  009bc	83 7c 24 28 38	 cmp	 DWORD PTR c$[rsp], 56	; 00000038H
  009c1	7c e1		 jl	 SHORT $LN67@tok_get
$LN64@tok_get:

; 1547 :             }
; 1548 :             else if (c == 'b' || c == 'B') {

  009c3	e9 2f 01 00 00	 jmp	 $LN63@tok_get
$LN71@tok_get:
  009c8	83 7c 24 28 62	 cmp	 DWORD PTR c$[rsp], 98	; 00000062H
  009cd	74 07		 je	 SHORT $LN61@tok_get
  009cf	83 7c 24 28 42	 cmp	 DWORD PTR c$[rsp], 66	; 00000042H
  009d4	75 6d		 jne	 SHORT $LN62@tok_get
$LN61@tok_get:

; 1549 :                 /* Binary */
; 1550 :                 c = tok_nextc(tok);

  009d6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  009de	e8 00 00 00 00	 call	 tok_nextc
  009e3	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1551 :                 if (c != '0' && c != '1') {

  009e7	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  009ec	74 31		 je	 SHORT $LN60@tok_get
  009ee	83 7c 24 28 31	 cmp	 DWORD PTR c$[rsp], 49	; 00000031H
  009f3	74 2a		 je	 SHORT $LN60@tok_get

; 1552 :                     tok->done = E_TOKEN;

  009f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  009fd	c7 40 28 0d 00
	00 00		 mov	 DWORD PTR [rax+40], 13

; 1553 :                     tok_backup(tok, c);

  00a04	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00a08	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a10	e8 00 00 00 00	 call	 tok_backup

; 1554 :                     return ERRORTOKEN;

  00a15	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00a1a	e9 a5 05 00 00	 jmp	 $LN157@tok_get
$LN60@tok_get:
$LN163@tok_get:
$LN59@tok_get:

; 1555 :                 }
; 1556 :                 do {
; 1557 :                     c = tok_nextc(tok);

  00a1f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a27	e8 00 00 00 00	 call	 tok_nextc
  00a2c	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1558 :                 } while (c == '0' || c == '1');

  00a30	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  00a35	74 e8		 je	 SHORT $LN59@tok_get
  00a37	83 7c 24 28 31	 cmp	 DWORD PTR c$[rsp], 49	; 00000031H
  00a3c	74 e1		 je	 SHORT $LN163@tok_get

; 1559 :             }
; 1560 :             else {

  00a3e	e9 b4 00 00 00	 jmp	 $LN56@tok_get
$LN62@tok_get:

; 1561 :                 int nonzero = 0;

  00a43	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR nonzero$21562[rsp], 0
$LN55@tok_get:

; 1562 :                 /* maybe old-style octal; c is first char of it */
; 1563 :                 /* in any case, allow '0' as a literal */
; 1564 :                 while (c == '0')

  00a4b	83 7c 24 28 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  00a50	75 13		 jne	 SHORT $LN54@tok_get

; 1565 :                     c = tok_nextc(tok);

  00a52	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a5a	e8 00 00 00 00	 call	 tok_nextc
  00a5f	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax
  00a63	eb e6		 jmp	 SHORT $LN55@tok_get
$LN54@tok_get:
$LN53@tok_get:

; 1566 :                 while (isdigit(c)) {

  00a65	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00a69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00a6f	85 c0		 test	 eax, eax
  00a71	74 1b		 je	 SHORT $LN52@tok_get

; 1567 :                     nonzero = 1;

  00a73	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR nonzero$21562[rsp], 1

; 1568 :                     c = tok_nextc(tok);

  00a7b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a83	e8 00 00 00 00	 call	 tok_nextc
  00a88	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1569 :                 }

  00a8c	eb d7		 jmp	 SHORT $LN53@tok_get
$LN52@tok_get:

; 1570 :                 if (c == '.')

  00a8e	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  00a93	75 07		 jne	 SHORT $LN51@tok_get

; 1571 :                     goto fraction;

  00a95	e9 88 00 00 00	 jmp	 $fraction$21527
  00a9a	eb 5b		 jmp	 SHORT $LN50@tok_get
$LN51@tok_get:

; 1572 :                 else if (c == 'e' || c == 'E')

  00a9c	83 7c 24 28 65	 cmp	 DWORD PTR c$[rsp], 101	; 00000065H
  00aa1	74 07		 je	 SHORT $LN48@tok_get
  00aa3	83 7c 24 28 45	 cmp	 DWORD PTR c$[rsp], 69	; 00000045H
  00aa8	75 07		 jne	 SHORT $LN49@tok_get
$LN48@tok_get:

; 1573 :                     goto exponent;

  00aaa	e9 a4 00 00 00	 jmp	 $exponent$21573
  00aaf	eb 46		 jmp	 SHORT $LN47@tok_get
$LN49@tok_get:

; 1574 :                 else if (c == 'j' || c == 'J')

  00ab1	83 7c 24 28 6a	 cmp	 DWORD PTR c$[rsp], 106	; 0000006aH
  00ab6	74 07		 je	 SHORT $LN45@tok_get
  00ab8	83 7c 24 28 4a	 cmp	 DWORD PTR c$[rsp], 74	; 0000004aH
  00abd	75 07		 jne	 SHORT $LN46@tok_get
$LN45@tok_get:

; 1575 :                     goto imaginary;

  00abf	e9 24 01 00 00	 jmp	 $imaginary$21538
  00ac4	eb 31		 jmp	 SHORT $LN44@tok_get
$LN46@tok_get:

; 1576 :                 else if (nonzero) {

  00ac6	83 7c 24 40 00	 cmp	 DWORD PTR nonzero$21562[rsp], 0
  00acb	74 2a		 je	 SHORT $LN43@tok_get

; 1577 :                     tok->done = E_TOKEN;

  00acd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00ad5	c7 40 28 0d 00
	00 00		 mov	 DWORD PTR [rax+40], 13

; 1578 :                     tok_backup(tok, c);

  00adc	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00ae0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00ae8	e8 00 00 00 00	 call	 tok_backup

; 1579 :                     return ERRORTOKEN;

  00aed	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00af2	e9 cd 04 00 00	 jmp	 $LN157@tok_get
$LN43@tok_get:
$LN44@tok_get:
$LN47@tok_get:
$LN50@tok_get:
$LN56@tok_get:
$LN63@tok_get:
$LN72@tok_get:

; 1580 :                 }
; 1581 :             }
; 1582 :         }
; 1583 :         else {

  00af7	e9 fd 00 00 00	 jmp	 $LN42@tok_get
$LN82@tok_get:
$LN41@tok_get:

; 1584 :             /* Decimal */
; 1585 :             do {
; 1586 :                 c = tok_nextc(tok);

  00afc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00b04	e8 00 00 00 00	 call	 tok_nextc
  00b09	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1587 :             } while (isdigit(c));

  00b0d	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00b11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00b17	85 c0		 test	 eax, eax
  00b19	75 e1		 jne	 SHORT $LN41@tok_get

; 1588 :             {
; 1589 :                 /* Accept floating point numbers. */
; 1590 :                 if (c == '.') {

  00b1b	83 7c 24 28 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  00b20	75 1f		 jne	 SHORT $LN38@tok_get
$fraction$21527:
$LN37@tok_get:

; 1591 :         fraction:
; 1592 :                     /* Fraction */
; 1593 :                     do {
; 1594 :                         c = tok_nextc(tok);

  00b22	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00b2a	e8 00 00 00 00	 call	 tok_nextc
  00b2f	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1595 :                     } while (isdigit(c));

  00b33	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00b37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00b3d	85 c0		 test	 eax, eax
  00b3f	75 e1		 jne	 SHORT $LN37@tok_get
$LN38@tok_get:

; 1596 :                 }
; 1597 :                 if (c == 'e' || c == 'E') {

  00b41	83 7c 24 28 65	 cmp	 DWORD PTR c$[rsp], 101	; 00000065H
  00b46	74 0b		 je	 SHORT $LN33@tok_get
  00b48	83 7c 24 28 45	 cmp	 DWORD PTR c$[rsp], 69	; 00000045H
  00b4d	0f 85 87 00 00
	00		 jne	 $LN34@tok_get
$LN33@tok_get:
$exponent$21573:

; 1598 :         exponent:
; 1599 :                     /* Exponent part */
; 1600 :                     c = tok_nextc(tok);

  00b53	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00b5b	e8 00 00 00 00	 call	 tok_nextc
  00b60	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1601 :                     if (c == '+' || c == '-')

  00b64	83 7c 24 28 2b	 cmp	 DWORD PTR c$[rsp], 43	; 0000002bH
  00b69	74 07		 je	 SHORT $LN31@tok_get
  00b6b	83 7c 24 28 2d	 cmp	 DWORD PTR c$[rsp], 45	; 0000002dH
  00b70	75 11		 jne	 SHORT $LN32@tok_get
$LN31@tok_get:

; 1602 :                         c = tok_nextc(tok);

  00b72	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00b7a	e8 00 00 00 00	 call	 tok_nextc
  00b7f	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax
$LN32@tok_get:

; 1603 :                     if (!isdigit(c)) {

  00b83	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00b87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00b8d	85 c0		 test	 eax, eax
  00b8f	75 2a		 jne	 SHORT $LN30@tok_get

; 1604 :                         tok->done = E_TOKEN;

  00b91	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00b99	c7 40 28 0d 00
	00 00		 mov	 DWORD PTR [rax+40], 13

; 1605 :                         tok_backup(tok, c);

  00ba0	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00ba4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00bac	e8 00 00 00 00	 call	 tok_backup

; 1606 :                         return ERRORTOKEN;

  00bb1	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00bb6	e9 09 04 00 00	 jmp	 $LN157@tok_get
$LN30@tok_get:
$LN29@tok_get:

; 1607 :                     }
; 1608 :                     do {
; 1609 :                         c = tok_nextc(tok);

  00bbb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00bc3	e8 00 00 00 00	 call	 tok_nextc
  00bc8	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1610 :                     } while (isdigit(c));

  00bcc	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00bd0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00bd6	85 c0		 test	 eax, eax
  00bd8	75 e1		 jne	 SHORT $LN29@tok_get
$LN34@tok_get:

; 1611 :                 }
; 1612 :                 if (c == 'j' || c == 'J')

  00bda	83 7c 24 28 6a	 cmp	 DWORD PTR c$[rsp], 106	; 0000006aH
  00bdf	74 07		 je	 SHORT $LN25@tok_get
  00be1	83 7c 24 28 4a	 cmp	 DWORD PTR c$[rsp], 74	; 0000004aH
  00be6	75 11		 jne	 SHORT $LN26@tok_get
$LN25@tok_get:
$imaginary$21538:

; 1613 :                     /* Imaginary part */
; 1614 :         imaginary:
; 1615 :                     c = tok_nextc(tok);

  00be8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00bf0	e8 00 00 00 00	 call	 tok_nextc
  00bf5	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax
$LN26@tok_get:
$LN42@tok_get:

; 1616 :             }
; 1617 :         }
; 1618 :         tok_backup(tok, c);

  00bf9	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00bfd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c05	e8 00 00 00 00	 call	 tok_backup

; 1619 :         *p_start = tok->start;

  00c0a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00c12	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c1a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00c1e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1620 :         *p_end = tok->cur;

  00c21	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  00c29	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c31	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00c35	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1621 :         return NUMBER;

  00c38	b8 02 00 00 00	 mov	 eax, 2
  00c3d	e9 82 03 00 00	 jmp	 $LN157@tok_get
$LN83@tok_get:
$letter_quote$21512:

; 1622 :     }
; 1623 : 
; 1624 :   letter_quote:
; 1625 :     /* String */
; 1626 :     if (c == '\'' || c == '"') {

  00c42	83 7c 24 28 27	 cmp	 DWORD PTR c$[rsp], 39	; 00000027H
  00c47	74 0b		 je	 SHORT $LN23@tok_get
  00c49	83 7c 24 28 22	 cmp	 DWORD PTR c$[rsp], 34	; 00000022H
  00c4e	0f 85 9c 01 00
	00		 jne	 $LN24@tok_get
$LN23@tok_get:

; 1627 :         int quote = c;

  00c54	8b 44 24 28	 mov	 eax, DWORD PTR c$[rsp]
  00c58	89 44 24 44	 mov	 DWORD PTR quote$21599[rsp], eax

; 1628 :         int quote_size = 1;             /* 1 or 3 */

  00c5c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR quote_size$21600[rsp], 1

; 1629 :         int end_quote_size = 0;

  00c64	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR end_quote_size$21601[rsp], 0

; 1630 : 
; 1631 :         /* Find the quote size and start of string */
; 1632 :         c = tok_nextc(tok);

  00c6c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c74	e8 00 00 00 00	 call	 tok_nextc
  00c79	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1633 :         if (c == quote) {

  00c7d	8b 44 24 44	 mov	 eax, DWORD PTR quote$21599[rsp]
  00c81	39 44 24 28	 cmp	 DWORD PTR c$[rsp], eax
  00c85	75 2d		 jne	 SHORT $LN22@tok_get

; 1634 :             c = tok_nextc(tok);

  00c87	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c8f	e8 00 00 00 00	 call	 tok_nextc
  00c94	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1635 :             if (c == quote)

  00c98	8b 44 24 44	 mov	 eax, DWORD PTR quote$21599[rsp]
  00c9c	39 44 24 28	 cmp	 DWORD PTR c$[rsp], eax
  00ca0	75 0a		 jne	 SHORT $LN21@tok_get

; 1636 :                 quote_size = 3;

  00ca2	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR quote_size$21600[rsp], 3

; 1637 :             else

  00caa	eb 08		 jmp	 SHORT $LN20@tok_get
$LN21@tok_get:

; 1638 :                 end_quote_size = 1;     /* empty string found */

  00cac	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR end_quote_size$21601[rsp], 1
$LN20@tok_get:
$LN22@tok_get:

; 1639 :         }
; 1640 :         if (c != quote)

  00cb4	8b 44 24 44	 mov	 eax, DWORD PTR quote$21599[rsp]
  00cb8	39 44 24 28	 cmp	 DWORD PTR c$[rsp], eax
  00cbc	74 11		 je	 SHORT $LN19@tok_get

; 1641 :             tok_backup(tok, c);

  00cbe	8b 54 24 28	 mov	 edx, DWORD PTR c$[rsp]
  00cc2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00cca	e8 00 00 00 00	 call	 tok_backup
$LN19@tok_get:
$LN18@tok_get:

; 1642 : 
; 1643 :         /* Get rest of string */
; 1644 :         while (end_quote_size != quote_size) {

  00ccf	8b 44 24 48	 mov	 eax, DWORD PTR quote_size$21600[rsp]
  00cd3	39 44 24 4c	 cmp	 DWORD PTR end_quote_size$21601[rsp], eax
  00cd7	0f 84 db 00 00
	00		 je	 $LN17@tok_get

; 1645 :             c = tok_nextc(tok);

  00cdd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00ce5	e8 00 00 00 00	 call	 tok_nextc
  00cea	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1646 :             if (c == EOF) {

  00cee	83 7c 24 28 ff	 cmp	 DWORD PTR c$[rsp], -1
  00cf3	75 49		 jne	 SHORT $LN16@tok_get

; 1647 :                 if (quote_size == 3)

  00cf5	83 7c 24 48 03	 cmp	 DWORD PTR quote_size$21600[rsp], 3
  00cfa	75 11		 jne	 SHORT $LN15@tok_get

; 1648 :                     tok->done = E_EOFS;

  00cfc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d04	c7 40 28 17 00
	00 00		 mov	 DWORD PTR [rax+40], 23

; 1649 :                 else

  00d0b	eb 0f		 jmp	 SHORT $LN14@tok_get
$LN15@tok_get:

; 1650 :                     tok->done = E_EOLS;

  00d0d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d15	c7 40 28 18 00
	00 00		 mov	 DWORD PTR [rax+40], 24
$LN14@tok_get:

; 1651 :                 tok->cur = tok->inp;

  00d1c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d24	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00d2c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00d30	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1652 :                 return ERRORTOKEN;

  00d34	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00d39	e9 86 02 00 00	 jmp	 $LN157@tok_get
$LN16@tok_get:

; 1653 :             }
; 1654 :             if (quote_size == 1 && c == '\n') {

  00d3e	83 7c 24 48 01	 cmp	 DWORD PTR quote_size$21600[rsp], 1
  00d43	75 38		 jne	 SHORT $LN13@tok_get
  00d45	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  00d4a	75 31		 jne	 SHORT $LN13@tok_get

; 1655 :                 tok->done = E_EOLS;

  00d4c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d54	c7 40 28 18 00
	00 00		 mov	 DWORD PTR [rax+40], 24

; 1656 :                 tok->cur = tok->inp;

  00d5b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d63	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00d6b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00d6f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1657 :                 return ERRORTOKEN;

  00d73	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00d78	e9 47 02 00 00	 jmp	 $LN157@tok_get
$LN13@tok_get:

; 1658 :             }
; 1659 :             if (c == quote)

  00d7d	8b 44 24 44	 mov	 eax, DWORD PTR quote$21599[rsp]
  00d81	39 44 24 28	 cmp	 DWORD PTR c$[rsp], eax
  00d85	75 0c		 jne	 SHORT $LN12@tok_get

; 1660 :                 end_quote_size += 1;

  00d87	8b 44 24 4c	 mov	 eax, DWORD PTR end_quote_size$21601[rsp]
  00d8b	ff c0		 inc	 eax
  00d8d	89 44 24 4c	 mov	 DWORD PTR end_quote_size$21601[rsp], eax

; 1661 :             else {

  00d91	eb 20		 jmp	 SHORT $LN11@tok_get
$LN12@tok_get:

; 1662 :                 end_quote_size = 0;

  00d93	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR end_quote_size$21601[rsp], 0

; 1663 :                 if (c == '\\')

  00d9b	83 7c 24 28 5c	 cmp	 DWORD PTR c$[rsp], 92	; 0000005cH
  00da0	75 11		 jne	 SHORT $LN10@tok_get

; 1664 :                 c = tok_nextc(tok);  /* skip escaped char */

  00da2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00daa	e8 00 00 00 00	 call	 tok_nextc
  00daf	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax
$LN10@tok_get:
$LN11@tok_get:

; 1665 :             }
; 1666 :         }

  00db3	e9 17 ff ff ff	 jmp	 $LN18@tok_get
$LN17@tok_get:

; 1667 : 
; 1668 :         *p_start = tok->start;

  00db8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00dc0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00dc8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00dcc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1669 :         *p_end = tok->cur;

  00dcf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  00dd7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00ddf	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00de3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1670 :         return STRING;

  00de6	b8 03 00 00 00	 mov	 eax, 3
  00deb	e9 d4 01 00 00	 jmp	 $LN157@tok_get
$LN24@tok_get:

; 1671 :     }
; 1672 : 
; 1673 :     /* Line continuation */
; 1674 :     if (c == '\\') {

  00df0	83 7c 24 28 5c	 cmp	 DWORD PTR c$[rsp], 92	; 0000005cH
  00df5	75 60		 jne	 SHORT $LN9@tok_get

; 1675 :         c = tok_nextc(tok);

  00df7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00dff	e8 00 00 00 00	 call	 tok_nextc
  00e04	89 44 24 28	 mov	 DWORD PTR c$[rsp], eax

; 1676 :         if (c != '\n') {

  00e08	83 7c 24 28 0a	 cmp	 DWORD PTR c$[rsp], 10
  00e0d	74 31		 je	 SHORT $LN8@tok_get

; 1677 :             tok->done = E_LINECONT;

  00e0f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00e17	c7 40 28 19 00
	00 00		 mov	 DWORD PTR [rax+40], 25

; 1678 :             tok->cur = tok->inp;

  00e1e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00e26	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00e2e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00e32	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1679 :             return ERRORTOKEN;

  00e36	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00e3b	e9 84 01 00 00	 jmp	 $LN157@tok_get
$LN8@tok_get:

; 1680 :         }
; 1681 :         tok->cont_line = 1;

  00e40	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00e48	c7 80 a8 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+936], 1

; 1682 :         goto again; /* Read next line */

  00e52	e9 2d f6 ff ff	 jmp	 $again$21481
$LN9@tok_get:

; 1683 :     }
; 1684 : 
; 1685 :     /* Check for two-character token */
; 1686 :     {
; 1687 :         int c2 = tok_nextc(tok);

  00e57	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00e5f	e8 00 00 00 00	 call	 tok_nextc
  00e64	89 44 24 54	 mov	 DWORD PTR c2$21618[rsp], eax

; 1688 :         int token = PyToken_TwoChars(c, c2);

  00e68	8b 54 24 54	 mov	 edx, DWORD PTR c2$21618[rsp]
  00e6c	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00e70	e8 00 00 00 00	 call	 PyToken_TwoChars
  00e75	89 44 24 50	 mov	 DWORD PTR token$21619[rsp], eax

; 1689 :         if (token != OP) {

  00e79	83 7c 24 50 34	 cmp	 DWORD PTR token$21619[rsp], 52 ; 00000034H
  00e7e	0f 84 80 00 00
	00		 je	 $LN7@tok_get

; 1690 :             int c3 = tok_nextc(tok);

  00e84	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00e8c	e8 00 00 00 00	 call	 tok_nextc
  00e91	89 44 24 58	 mov	 DWORD PTR c3$21621[rsp], eax

; 1691 :             int token3 = PyToken_ThreeChars(c, c2, c3);

  00e95	44 8b 44 24 58	 mov	 r8d, DWORD PTR c3$21621[rsp]
  00e9a	8b 54 24 54	 mov	 edx, DWORD PTR c2$21618[rsp]
  00e9e	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00ea2	e8 00 00 00 00	 call	 PyToken_ThreeChars
  00ea7	89 44 24 5c	 mov	 DWORD PTR token3$21622[rsp], eax

; 1692 :             if (token3 != OP) {

  00eab	83 7c 24 5c 34	 cmp	 DWORD PTR token3$21622[rsp], 52 ; 00000034H
  00eb0	74 0a		 je	 SHORT $LN6@tok_get

; 1693 :                 token = token3;

  00eb2	8b 44 24 5c	 mov	 eax, DWORD PTR token3$21622[rsp]
  00eb6	89 44 24 50	 mov	 DWORD PTR token$21619[rsp], eax

; 1694 :             } else {

  00eba	eb 11		 jmp	 SHORT $LN5@tok_get
$LN6@tok_get:

; 1695 :                 tok_backup(tok, c3);

  00ebc	8b 54 24 58	 mov	 edx, DWORD PTR c3$21621[rsp]
  00ec0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00ec8	e8 00 00 00 00	 call	 tok_backup
$LN5@tok_get:

; 1696 :             }
; 1697 :             *p_start = tok->start;

  00ecd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00ed5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00edd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00ee1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1698 :             *p_end = tok->cur;

  00ee4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  00eec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00ef4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00ef8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1699 :             return token;

  00efb	8b 44 24 50	 mov	 eax, DWORD PTR token$21619[rsp]
  00eff	e9 c0 00 00 00	 jmp	 $LN157@tok_get
$LN7@tok_get:

; 1700 :         }
; 1701 :         tok_backup(tok, c2);

  00f04	8b 54 24 54	 mov	 edx, DWORD PTR c2$21618[rsp]
  00f08	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00f10	e8 00 00 00 00	 call	 tok_backup

; 1702 :     }
; 1703 : 
; 1704 :     /* Keep track of parentheses nesting level */
; 1705 :     switch (c) {

  00f15	8b 44 24 28	 mov	 eax, DWORD PTR c$[rsp]
  00f19	89 44 24 68	 mov	 DWORD PTR tv483[rsp], eax
  00f1d	8b 44 24 68	 mov	 eax, DWORD PTR tv483[rsp]
  00f21	83 e8 28	 sub	 eax, 40			; 00000028H
  00f24	89 44 24 68	 mov	 DWORD PTR tv483[rsp], eax
  00f28	83 7c 24 68 55	 cmp	 DWORD PTR tv483[rsp], 85 ; 00000055H
  00f2d	77 5e		 ja	 SHORT $LN3@tok_get
  00f2f	48 63 44 24 68	 movsxd	 rax, DWORD PTR tv483[rsp]
  00f34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00f3b	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN164@tok_get[rcx+rax]
  00f43	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN165@tok_get[rcx+rax*4]
  00f4a	48 03 c1	 add	 rax, rcx
  00f4d	ff e0		 jmp	 rax
$LN2@tok_get:

; 1706 :     case '(':
; 1707 :     case '[':
; 1708 :     case '{':
; 1709 :         tok->level++;

  00f4f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00f57	8b 80 ec 01 00
	00		 mov	 eax, DWORD PTR [rax+492]
  00f5d	ff c0		 inc	 eax
  00f5f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00f67	89 81 ec 01 00
	00		 mov	 DWORD PTR [rcx+492], eax

; 1710 :         break;

  00f6d	eb 1e		 jmp	 SHORT $LN3@tok_get
$LN1@tok_get:

; 1711 :     case ')':
; 1712 :     case ']':
; 1713 :     case '}':
; 1714 :         tok->level--;

  00f6f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00f77	8b 80 ec 01 00
	00		 mov	 eax, DWORD PTR [rax+492]
  00f7d	ff c8		 dec	 eax
  00f7f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00f87	89 81 ec 01 00
	00		 mov	 DWORD PTR [rcx+492], eax
$LN3@tok_get:

; 1715 :         break;
; 1716 :     }
; 1717 : 
; 1718 :     /* Punctuation character */
; 1719 :     *p_start = tok->start;

  00f8d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_start$[rsp]
  00f95	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00f9d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00fa1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1720 :     *p_end = tok->cur;

  00fa4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_end$[rsp]
  00fac	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00fb4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00fb8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1721 :     return PyToken_OneChar(c);

  00fbb	8b 4c 24 28	 mov	 ecx, DWORD PTR c$[rsp]
  00fbf	e8 00 00 00 00	 call	 PyToken_OneChar
$LN157@tok_get:

; 1722 : }

  00fc4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00fc8	c3		 ret	 0
  00fc9	0f 1f 00	 npad	 3
$LN165@tok_get:
  00fcc	00 00 00 00	 DD	 $LN2@tok_get
  00fd0	00 00 00 00	 DD	 $LN1@tok_get
  00fd4	00 00 00 00	 DD	 $LN3@tok_get
$LN164@tok_get:
  00fd8	00		 DB	 0
  00fd9	01		 DB	 1
  00fda	02		 DB	 2
  00fdb	02		 DB	 2
  00fdc	02		 DB	 2
  00fdd	02		 DB	 2
  00fde	02		 DB	 2
  00fdf	02		 DB	 2
  00fe0	02		 DB	 2
  00fe1	02		 DB	 2
  00fe2	02		 DB	 2
  00fe3	02		 DB	 2
  00fe4	02		 DB	 2
  00fe5	02		 DB	 2
  00fe6	02		 DB	 2
  00fe7	02		 DB	 2
  00fe8	02		 DB	 2
  00fe9	02		 DB	 2
  00fea	02		 DB	 2
  00feb	02		 DB	 2
  00fec	02		 DB	 2
  00fed	02		 DB	 2
  00fee	02		 DB	 2
  00fef	02		 DB	 2
  00ff0	02		 DB	 2
  00ff1	02		 DB	 2
  00ff2	02		 DB	 2
  00ff3	02		 DB	 2
  00ff4	02		 DB	 2
  00ff5	02		 DB	 2
  00ff6	02		 DB	 2
  00ff7	02		 DB	 2
  00ff8	02		 DB	 2
  00ff9	02		 DB	 2
  00ffa	02		 DB	 2
  00ffb	02		 DB	 2
  00ffc	02		 DB	 2
  00ffd	02		 DB	 2
  00ffe	02		 DB	 2
  00fff	02		 DB	 2
  01000	02		 DB	 2
  01001	02		 DB	 2
  01002	02		 DB	 2
  01003	02		 DB	 2
  01004	02		 DB	 2
  01005	02		 DB	 2
  01006	02		 DB	 2
  01007	02		 DB	 2
  01008	02		 DB	 2
  01009	02		 DB	 2
  0100a	02		 DB	 2
  0100b	00		 DB	 0
  0100c	02		 DB	 2
  0100d	01		 DB	 1
  0100e	02		 DB	 2
  0100f	02		 DB	 2
  01010	02		 DB	 2
  01011	02		 DB	 2
  01012	02		 DB	 2
  01013	02		 DB	 2
  01014	02		 DB	 2
  01015	02		 DB	 2
  01016	02		 DB	 2
  01017	02		 DB	 2
  01018	02		 DB	 2
  01019	02		 DB	 2
  0101a	02		 DB	 2
  0101b	02		 DB	 2
  0101c	02		 DB	 2
  0101d	02		 DB	 2
  0101e	02		 DB	 2
  0101f	02		 DB	 2
  01020	02		 DB	 2
  01021	02		 DB	 2
  01022	02		 DB	 2
  01023	02		 DB	 2
  01024	02		 DB	 2
  01025	02		 DB	 2
  01026	02		 DB	 2
  01027	02		 DB	 2
  01028	02		 DB	 2
  01029	02		 DB	 2
  0102a	02		 DB	 2
  0102b	00		 DB	 0
  0102c	02		 DB	 2
  0102d	01		 DB	 1
tok_get	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PySys_WriteStderr:PROC
EXTRN	PyOS_Readline:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_strchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_nextc DD imagerel tok_nextc
	DD	imagerel tok_nextc+3589
	DD	imagerel $unwind$tok_nextc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_nextc DD 020c01H
	DD	025010cH
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'u', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tok_nextc
_TEXT	SEGMENT
end$21116 = 32
newtok$21126 = 40
translated$21129 = 48
buflen$21133 = 56
u$21135 = 64
buf$21134 = 72
oldlen$21159 = 80
newlen$21160 = 88
start$21158 = 96
buf$21161 = 104
pt$21172 = 112
cur$21171 = 120
done$21170 = 128
curstart$21192 = 136
newsize$21195 = 144
curvalid$21194 = 152
newbuf$21196 = 160
tv75 = 168
tv144 = 169
tv152 = 176
tv165 = 184
tv180 = 188
tv212 = 192
tv228 = 200
tv249 = 208
tv259 = 216
tv264 = 220
tv277 = 224
tv294 = 228
tv314 = 232
tv337 = 240
tv354 = 248
tv366 = 256
tv378 = 264
tv403 = 272
tok$ = 304
tok_nextc PROC						; COMDAT

; 897  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
$LN42@tok_nextc:

; 898  :     for (;;) {
; 899  :         if (tok->cur != tok->inp) {

  0000c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00014	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0001c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00020	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx
  00024	74 43		 je	 SHORT $LN40@tok_nextc

; 900  :             return Py_CHARMASK(*tok->cur++); /* Fast path */

  00026	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0002e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00032	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00035	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003a	88 84 24 a8 00
	00 00		 mov	 BYTE PTR tv75[rsp], al
  00041	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 ff c0	 inc	 rax
  00050	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00058	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0005c	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv75[rsp]
  00064	e9 94 0d 00 00	 jmp	 $LN43@tok_nextc
$LN40@tok_nextc:

; 901  :         }
; 902  :         if (tok->done != E_OK)

  00069	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00071	83 78 28 0a	 cmp	 DWORD PTR [rax+40], 10
  00075	74 0a		 je	 SHORT $LN39@tok_nextc

; 903  :             return EOF;

  00077	b8 ff ff ff ff	 mov	 eax, -1
  0007c	e9 7c 0d 00 00	 jmp	 $LN43@tok_nextc
$LN39@tok_nextc:

; 904  :         if (tok->fp == NULL) {

  00081	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00089	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0008e	0f 85 2b 01 00
	00		 jne	 $LN38@tok_nextc

; 905  :             char *end = strchr(tok->inp, '\n');

  00094	ba 0a 00 00 00	 mov	 edx, 10
  00099	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  000a1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  000ab	48 89 44 24 20	 mov	 QWORD PTR end$21116[rsp], rax

; 906  :             if (end != NULL)

  000b0	48 83 7c 24 20
	00		 cmp	 QWORD PTR end$21116[rsp], 0
  000b6	74 0f		 je	 SHORT $LN37@tok_nextc

; 907  :                 end++;

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR end$21116[rsp]
  000bd	48 ff c0	 inc	 rax
  000c0	48 89 44 24 20	 mov	 QWORD PTR end$21116[rsp], rax

; 908  :             else {

  000c5	eb 45		 jmp	 SHORT $LN36@tok_nextc
$LN37@tok_nextc:

; 909  :                 end = strchr(tok->inp, '\0');

  000c7	33 d2		 xor	 edx, edx
  000c9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  000d1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  000db	48 89 44 24 20	 mov	 QWORD PTR end$21116[rsp], rax

; 910  :                 if (end == tok->inp) {

  000e0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  000e8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000ec	48 39 44 24 20	 cmp	 QWORD PTR end$21116[rsp], rax
  000f1	75 19		 jne	 SHORT $LN35@tok_nextc

; 911  :                     tok->done = E_EOF;

  000f3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  000fb	c7 40 28 0b 00
	00 00		 mov	 DWORD PTR [rax+40], 11

; 912  :                     return EOF;

  00102	b8 ff ff ff ff	 mov	 eax, -1
  00107	e9 f1 0c 00 00	 jmp	 $LN43@tok_nextc
$LN35@tok_nextc:
$LN36@tok_nextc:

; 913  :                 }
; 914  :             }
; 915  :             if (tok->start == NULL)

  0010c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00114	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00119	75 17		 jne	 SHORT $LN34@tok_nextc

; 916  :                 tok->buf = tok->cur;

  0011b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00123	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0012b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0012f	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN34@tok_nextc:

; 917  :             tok->line_start = tok->cur;

  00132	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0013a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00142	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00146	48 89 88 b0 03
	00 00		 mov	 QWORD PTR [rax+944], rcx

; 918  :             tok->lineno++;

  0014d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00155	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  0015b	ff c0		 inc	 eax
  0015d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00165	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 919  :             tok->inp = end;

  0016b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00173	48 8b 4c 24 20	 mov	 rcx, QWORD PTR end$21116[rsp]
  00178	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 920  :             return Py_CHARMASK(*tok->cur++);

  0017c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00184	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00188	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0018b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00190	88 84 24 a9 00
	00 00		 mov	 BYTE PTR tv144[rsp], al
  00197	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0019f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001a3	48 ff c0	 inc	 rax
  001a6	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  001ae	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  001b2	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR tv144[rsp]
  001ba	e9 3e 0c 00 00	 jmp	 $LN43@tok_nextc
$LN38@tok_nextc:

; 921  :         }
; 922  :         if (tok->prompt != NULL) {

  001bf	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  001c7	48 83 b8 d8 01
	00 00 00	 cmp	 QWORD PTR [rax+472], 0
  001cf	0f 84 95 06 00
	00		 je	 $LN33@tok_nextc

; 923  :             char *newtok = PyOS_Readline(stdin, stdout, tok->prompt);

  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  001db	48 83 c0 30	 add	 rax, 48			; 00000030H
  001df	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  001ed	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  001f5	4c 8b 81 d8 01
	00 00		 mov	 r8, QWORD PTR [rcx+472]
  001fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  00204	48 8b d1	 mov	 rdx, rcx
  00207	48 8b c8	 mov	 rcx, rax
  0020a	e8 00 00 00 00	 call	 PyOS_Readline
  0020f	48 89 44 24 28	 mov	 QWORD PTR newtok$21126[rsp], rax

; 924  : #ifndef PGEN
; 925  :             if (newtok != NULL) {

  00214	48 83 7c 24 28
	00		 cmp	 QWORD PTR newtok$21126[rsp], 0
  0021a	74 6a		 je	 SHORT $LN32@tok_nextc

; 926  :                 char *translated = translate_newlines(newtok, 0, tok);

  0021c	4c 8b 84 24 30
	01 00 00	 mov	 r8, QWORD PTR tok$[rsp]
  00224	33 d2		 xor	 edx, edx
  00226	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  0022b	e8 00 00 00 00	 call	 translate_newlines
  00230	48 89 44 24 30	 mov	 QWORD PTR translated$21129[rsp], rax

; 927  :                 PyMem_FREE(newtok);

  00235	e8 00 00 00 00	 call	 _Py_PXCTX
  0023a	85 c0		 test	 eax, eax
  0023c	74 17		 je	 SHORT $LN45@tok_nextc
  0023e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  00243	e8 00 00 00 00	 call	 _PxMem_Free
  00248	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv165[rsp], 0
  00253	eb 15		 jmp	 SHORT $LN46@tok_nextc
$LN45@tok_nextc:
  00255	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  0025a	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0025f	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv165[rsp], 0
$LN46@tok_nextc:

; 928  :                 if (translated == NULL)

  0026a	48 83 7c 24 30
	00		 cmp	 QWORD PTR translated$21129[rsp], 0
  00270	75 0a		 jne	 SHORT $LN31@tok_nextc

; 929  :                     return EOF;

  00272	b8 ff ff ff ff	 mov	 eax, -1
  00277	e9 81 0b 00 00	 jmp	 $LN43@tok_nextc
$LN31@tok_nextc:

; 930  :                 newtok = translated;

  0027c	48 8b 44 24 30	 mov	 rax, QWORD PTR translated$21129[rsp]
  00281	48 89 44 24 28	 mov	 QWORD PTR newtok$21126[rsp], rax
$LN32@tok_nextc:

; 931  :             }
; 932  :             if (tok->encoding && newtok && *newtok) {

  00286	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0028e	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  00296	0f 84 a0 01 00
	00		 je	 $LN30@tok_nextc
  0029c	48 83 7c 24 28
	00		 cmp	 QWORD PTR newtok$21126[rsp], 0
  002a2	0f 84 94 01 00
	00		 je	 $LN30@tok_nextc
  002a8	48 8b 44 24 28	 mov	 rax, QWORD PTR newtok$21126[rsp]
  002ad	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002b0	85 c0		 test	 eax, eax
  002b2	0f 84 84 01 00
	00		 je	 $LN30@tok_nextc

; 933  :                 /* Recode to UTF-8 */
; 934  :                 Py_ssize_t buflen;
; 935  :                 const char* buf;
; 936  :                 PyObject *u = translate_into_utf8(newtok, tok->encoding);

  002b8	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002c0	48 8b 90 a0 03
	00 00		 mov	 rdx, QWORD PTR [rax+928]
  002c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  002cc	e8 00 00 00 00	 call	 translate_into_utf8
  002d1	48 89 44 24 40	 mov	 QWORD PTR u$21135[rsp], rax

; 937  :                 PyMem_FREE(newtok);

  002d6	e8 00 00 00 00	 call	 _Py_PXCTX
  002db	85 c0		 test	 eax, eax
  002dd	74 17		 je	 SHORT $LN47@tok_nextc
  002df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  002e4	e8 00 00 00 00	 call	 _PxMem_Free
  002e9	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
  002f4	eb 15		 jmp	 SHORT $LN48@tok_nextc
$LN47@tok_nextc:
  002f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  002fb	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00300	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
$LN48@tok_nextc:

; 938  :                 if (!u) {

  0030b	48 83 7c 24 40
	00		 cmp	 QWORD PTR u$21135[rsp], 0
  00311	75 19		 jne	 SHORT $LN29@tok_nextc

; 939  :                     tok->done = E_DECODE;

  00313	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0031b	c7 40 28 16 00
	00 00		 mov	 DWORD PTR [rax+40], 22

; 940  :                     return EOF;

  00322	b8 ff ff ff ff	 mov	 eax, -1
  00327	e9 d1 0a 00 00	 jmp	 $LN43@tok_nextc
$LN29@tok_nextc:

; 941  :                 }
; 942  :                 buflen = PyBytes_GET_SIZE(u);

  0032c	48 8b 44 24 40	 mov	 rax, QWORD PTR u$21135[rsp]
  00331	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00335	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0033b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00340	85 c0		 test	 eax, eax
  00342	75 1c		 jne	 SHORT $LN49@tok_nextc
  00344	41 b8 ae 03 00
	00		 mov	 r8d, 942		; 000003aeH
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00351	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  00358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0035e	33 c0		 xor	 eax, eax
$LN49@tok_nextc:
  00360	48 8b 44 24 40	 mov	 rax, QWORD PTR u$21135[rsp]
  00365	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00369	48 89 44 24 38	 mov	 QWORD PTR buflen$21133[rsp], rax

; 943  :                 buf = PyBytes_AS_STRING(u);

  0036e	48 8b 44 24 40	 mov	 rax, QWORD PTR u$21135[rsp]
  00373	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00377	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0037d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00382	85 c0		 test	 eax, eax
  00384	75 1c		 jne	 SHORT $LN50@tok_nextc
  00386	41 b8 af 03 00
	00		 mov	 r8d, 943		; 000003afH
  0038c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CJJABHEH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003a0	33 c0		 xor	 eax, eax
$LN50@tok_nextc:
  003a2	48 8b 44 24 40	 mov	 rax, QWORD PTR u$21135[rsp]
  003a7	48 83 c0 78	 add	 rax, 120		; 00000078H
  003ab	48 89 44 24 48	 mov	 QWORD PTR buf$21134[rsp], rax

; 944  :                 if (!buf) {

  003b0	48 83 7c 24 48
	00		 cmp	 QWORD PTR buf$21134[rsp], 0
  003b6	75 23		 jne	 SHORT $LN28@tok_nextc

; 945  :                     Py_DECREF(u);

  003b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR u$21135[rsp]
  003bd	e8 00 00 00 00	 call	 _Py_DecRef

; 946  :                     tok->done = E_DECODE;

  003c2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  003ca	c7 40 28 16 00
	00 00		 mov	 DWORD PTR [rax+40], 22

; 947  :                     return EOF;

  003d1	b8 ff ff ff ff	 mov	 eax, -1
  003d6	e9 22 0a 00 00	 jmp	 $LN43@tok_nextc
$LN28@tok_nextc:

; 948  :                 }
; 949  :                 newtok = PyMem_MALLOC(buflen+1);

  003db	e8 00 00 00 00	 call	 _Py_PXCTX
  003e0	85 c0		 test	 eax, eax
  003e2	74 1a		 je	 SHORT $LN51@tok_nextc
  003e4	48 8b 44 24 38	 mov	 rax, QWORD PTR buflen$21133[rsp]
  003e9	48 ff c0	 inc	 rax
  003ec	48 8b c8	 mov	 rcx, rax
  003ef	e8 00 00 00 00	 call	 _PxMem_Malloc
  003f4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  003fc	eb 18		 jmp	 SHORT $LN52@tok_nextc
$LN51@tok_nextc:
  003fe	48 8b 44 24 38	 mov	 rax, QWORD PTR buflen$21133[rsp]
  00403	48 ff c0	 inc	 rax
  00406	48 8b c8	 mov	 rcx, rax
  00409	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0040e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
$LN52@tok_nextc:
  00416	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv212[rsp]
  0041e	48 89 44 24 28	 mov	 QWORD PTR newtok$21126[rsp], rax

; 950  :                 strcpy(newtok, buf);

  00423	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$21134[rsp]
  00428	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  0042d	e8 00 00 00 00	 call	 strcpy

; 951  :                 Py_DECREF(u);

  00432	48 8b 4c 24 40	 mov	 rcx, QWORD PTR u$21135[rsp]
  00437	e8 00 00 00 00	 call	 _Py_DecRef
$LN30@tok_nextc:

; 952  :             }
; 953  : #endif
; 954  :             if (tok->nextprompt != NULL)

  0043c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00444	48 83 b8 e0 01
	00 00 00	 cmp	 QWORD PTR [rax+480], 0
  0044c	74 1e		 je	 SHORT $LN27@tok_nextc

; 955  :                 tok->prompt = tok->nextprompt;

  0044e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00456	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0045e	48 8b 89 e0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+480]
  00465	48 89 88 d8 01
	00 00		 mov	 QWORD PTR [rax+472], rcx
$LN27@tok_nextc:

; 956  :             if (newtok == NULL)

  0046c	48 83 7c 24 28
	00		 cmp	 QWORD PTR newtok$21126[rsp], 0
  00472	75 14		 jne	 SHORT $LN26@tok_nextc

; 957  :                 tok->done = E_INTR;

  00474	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0047c	c7 40 28 0c 00
	00 00		 mov	 DWORD PTR [rax+40], 12
  00483	e9 dd 03 00 00	 jmp	 $LN25@tok_nextc
$LN26@tok_nextc:

; 958  :             else if (*newtok == '\0') {

  00488	48 8b 44 24 28	 mov	 rax, QWORD PTR newtok$21126[rsp]
  0048d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00490	85 c0		 test	 eax, eax
  00492	75 49		 jne	 SHORT $LN24@tok_nextc

; 959  :                 PyMem_FREE(newtok);

  00494	e8 00 00 00 00	 call	 _Py_PXCTX
  00499	85 c0		 test	 eax, eax
  0049b	74 17		 je	 SHORT $LN53@tok_nextc
  0049d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  004a2	e8 00 00 00 00	 call	 _PxMem_Free
  004a7	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
  004b2	eb 15		 jmp	 SHORT $LN54@tok_nextc
$LN53@tok_nextc:
  004b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  004b9	e8 00 00 00 00	 call	 _PyMem_DebugFree
  004be	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
$LN54@tok_nextc:

; 960  :                 tok->done = E_EOF;

  004c9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004d1	c7 40 28 0b 00
	00 00		 mov	 DWORD PTR [rax+40], 11
  004d8	e9 88 03 00 00	 jmp	 $LN23@tok_nextc
$LN24@tok_nextc:

; 961  :             }
; 962  :             else if (tok->start != NULL) {

  004dd	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004e5	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  004ea	0f 84 73 02 00
	00		 je	 $LN22@tok_nextc

; 963  :                 size_t start = tok->start - tok->buf;

  004f0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004f8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00500	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00503	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00507	48 2b c1	 sub	 rax, rcx
  0050a	48 89 44 24 60	 mov	 QWORD PTR start$21158[rsp], rax

; 964  :                 size_t oldlen = tok->cur - tok->buf;

  0050f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00517	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0051f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00522	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00526	48 2b c1	 sub	 rax, rcx
  00529	48 89 44 24 50	 mov	 QWORD PTR oldlen$21159[rsp], rax

; 965  :                 size_t newlen = oldlen + strlen(newtok);

  0052e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  00533	e8 00 00 00 00	 call	 strlen
  00538	48 8b 4c 24 50	 mov	 rcx, QWORD PTR oldlen$21159[rsp]
  0053d	48 03 c8	 add	 rcx, rax
  00540	48 8b c1	 mov	 rax, rcx
  00543	48 89 44 24 58	 mov	 QWORD PTR newlen$21160[rsp], rax

; 966  :                 char *buf = tok->buf;

  00548	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00550	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00553	48 89 44 24 68	 mov	 QWORD PTR buf$21161[rsp], rax

; 967  :                 buf = (char *)PyMem_REALLOC(buf, newlen+1);

  00558	e8 00 00 00 00	 call	 _Py_PXCTX
  0055d	85 c0		 test	 eax, eax
  0055f	74 1f		 je	 SHORT $LN55@tok_nextc
  00561	48 8b 44 24 58	 mov	 rax, QWORD PTR newlen$21160[rsp]
  00566	48 ff c0	 inc	 rax
  00569	48 8b d0	 mov	 rdx, rax
  0056c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$21161[rsp]
  00571	e8 00 00 00 00	 call	 _PxMem_Realloc
  00576	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  0057e	eb 1d		 jmp	 SHORT $LN56@tok_nextc
$LN55@tok_nextc:
  00580	48 8b 44 24 58	 mov	 rax, QWORD PTR newlen$21160[rsp]
  00585	48 ff c0	 inc	 rax
  00588	48 8b d0	 mov	 rdx, rax
  0058b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$21161[rsp]
  00590	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  00595	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
$LN56@tok_nextc:
  0059d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv249[rsp]
  005a5	48 89 44 24 68	 mov	 QWORD PTR buf$21161[rsp], rax

; 968  :                 tok->lineno++;

  005aa	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  005b2	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  005b8	ff c0		 inc	 eax
  005ba	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  005c2	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 969  :                 if (buf == NULL) {

  005c8	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$21161[rsp], 0
  005ce	0f 85 9e 00 00
	00		 jne	 $LN21@tok_nextc

; 970  :                     PyMem_FREE(tok->buf);

  005d4	e8 00 00 00 00	 call	 _Py_PXCTX
  005d9	85 c0		 test	 eax, eax
  005db	74 1d		 je	 SHORT $LN57@tok_nextc
  005dd	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  005e5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005e8	e8 00 00 00 00	 call	 _PxMem_Free
  005ed	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
  005f8	eb 1b		 jmp	 SHORT $LN58@tok_nextc
$LN57@tok_nextc:
  005fa	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00602	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00605	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0060a	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN58@tok_nextc:

; 971  :                     tok->buf = NULL;

  00615	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0061d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 972  :                     PyMem_FREE(newtok);

  00624	e8 00 00 00 00	 call	 _Py_PXCTX
  00629	85 c0		 test	 eax, eax
  0062b	74 17		 je	 SHORT $LN59@tok_nextc
  0062d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  00632	e8 00 00 00 00	 call	 _PxMem_Free
  00637	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
  00642	eb 15		 jmp	 SHORT $LN60@tok_nextc
$LN59@tok_nextc:
  00644	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  00649	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0064e	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN60@tok_nextc:

; 973  :                     tok->done = E_NOMEM;

  00659	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00661	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [rax+40], 15

; 974  :                     return EOF;

  00668	b8 ff ff ff ff	 mov	 eax, -1
  0066d	e9 8b 07 00 00	 jmp	 $LN43@tok_nextc
$LN21@tok_nextc:

; 975  :                 }
; 976  :                 tok->buf = buf;

  00672	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0067a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$21161[rsp]
  0067f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 977  :                 tok->cur = tok->buf + oldlen;

  00682	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0068a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0068d	48 03 44 24 50	 add	 rax, QWORD PTR oldlen$21159[rsp]
  00692	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0069a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 978  :                 tok->line_start = tok->cur;

  0069e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006a6	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  006ae	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  006b2	48 89 88 b0 03
	00 00		 mov	 QWORD PTR [rax+944], rcx

; 979  :                 strcpy(tok->buf + oldlen, newtok);

  006b9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006c4	48 03 44 24 50	 add	 rax, QWORD PTR oldlen$21159[rsp]
  006c9	48 8b 54 24 28	 mov	 rdx, QWORD PTR newtok$21126[rsp]
  006ce	48 8b c8	 mov	 rcx, rax
  006d1	e8 00 00 00 00	 call	 strcpy

; 980  :                 PyMem_FREE(newtok);

  006d6	e8 00 00 00 00	 call	 _Py_PXCTX
  006db	85 c0		 test	 eax, eax
  006dd	74 17		 je	 SHORT $LN61@tok_nextc
  006df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  006e4	e8 00 00 00 00	 call	 _PxMem_Free
  006e9	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv277[rsp], 0
  006f4	eb 15		 jmp	 SHORT $LN62@tok_nextc
$LN61@tok_nextc:
  006f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  006fb	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00700	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv277[rsp], 0
$LN62@tok_nextc:

; 981  :                 tok->inp = tok->buf + newlen;

  0070b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00713	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00716	48 03 44 24 58	 add	 rax, QWORD PTR newlen$21160[rsp]
  0071b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00723	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 982  :                 tok->end = tok->inp + 1;

  00727	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0072f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00733	48 ff c0	 inc	 rax
  00736	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0073e	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 983  :                 tok->start = tok->buf + start;

  00742	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0074a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0074d	48 03 44 24 60	 add	 rax, QWORD PTR start$21158[rsp]
  00752	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0075a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 984  :             }
; 985  :             else {

  0075e	e9 02 01 00 00	 jmp	 $LN20@tok_nextc
$LN22@tok_nextc:

; 986  :                 tok->lineno++;

  00763	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0076b	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  00771	ff c0		 inc	 eax
  00773	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0077b	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 987  :                 if (tok->buf != NULL)

  00781	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00789	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0078d	74 41		 je	 SHORT $LN19@tok_nextc

; 988  :                     PyMem_FREE(tok->buf);

  0078f	e8 00 00 00 00	 call	 _Py_PXCTX
  00794	85 c0		 test	 eax, eax
  00796	74 1d		 je	 SHORT $LN63@tok_nextc
  00798	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  007a0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007a3	e8 00 00 00 00	 call	 _PxMem_Free
  007a8	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
  007b3	eb 1b		 jmp	 SHORT $LN64@tok_nextc
$LN63@tok_nextc:
  007b5	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  007bd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007c0	e8 00 00 00 00	 call	 _PyMem_DebugFree
  007c5	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
$LN64@tok_nextc:
$LN19@tok_nextc:

; 989  :                 tok->buf = newtok;

  007d0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  007d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtok$21126[rsp]
  007dd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 990  :                 tok->line_start = tok->buf;

  007e0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  007e8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  007f0	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007f3	48 89 88 b0 03
	00 00		 mov	 QWORD PTR [rax+944], rcx

; 991  :                 tok->cur = tok->buf;

  007fa	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00802	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0080a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0080d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 992  :                 tok->line_start = tok->buf;

  00811	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00819	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00821	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00824	48 89 88 b0 03
	00 00		 mov	 QWORD PTR [rax+944], rcx

; 993  :                 tok->inp = strchr(tok->buf, '\0');

  0082b	33 d2		 xor	 edx, edx
  0082d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00835	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00838	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0083e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00846	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 994  :                 tok->end = tok->inp + 1;

  0084a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00852	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00856	48 ff c0	 inc	 rax
  00859	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00861	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN20@tok_nextc:
$LN23@tok_nextc:
$LN25@tok_nextc:

; 995  :             }
; 996  :         }
; 997  :         else {

  00865	e9 43 05 00 00	 jmp	 $LN18@tok_nextc
$LN33@tok_nextc:

; 998  :             int done = 0;

  0086a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR done$21170[rsp], 0

; 999  :             Py_ssize_t cur = 0;

  00875	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR cur$21171[rsp], 0

; 1000 :             char *pt;
; 1001 :             if (tok->start == NULL) {

  0087e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00886	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0088b	0f 85 58 01 00
	00		 jne	 $LN17@tok_nextc

; 1002 :                 if (tok->buf == NULL) {

  00891	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00899	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0089d	0f 85 86 00 00
	00		 jne	 $LN16@tok_nextc

; 1003 :                     tok->buf = (char *)
; 1004 :                         PyMem_MALLOC(BUFSIZ);

  008a3	e8 00 00 00 00	 call	 _Py_PXCTX
  008a8	85 c0		 test	 eax, eax
  008aa	74 14		 je	 SHORT $LN65@tok_nextc
  008ac	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  008b1	e8 00 00 00 00	 call	 _PxMem_Malloc
  008b6	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv314[rsp], rax
  008be	eb 12		 jmp	 SHORT $LN66@tok_nextc
$LN65@tok_nextc:
  008c0	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  008c5	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  008ca	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv314[rsp], rax
$LN66@tok_nextc:
  008d2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  008da	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv314[rsp]
  008e2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1005 :                     if (tok->buf == NULL) {

  008e5	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  008ed	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  008f1	75 19		 jne	 SHORT $LN15@tok_nextc

; 1006 :                         tok->done = E_NOMEM;

  008f3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  008fb	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [rax+40], 15

; 1007 :                         return EOF;

  00902	b8 ff ff ff ff	 mov	 eax, -1
  00907	e9 f1 04 00 00	 jmp	 $LN43@tok_nextc
$LN15@tok_nextc:

; 1008 :                     }
; 1009 :                     tok->end = tok->buf + BUFSIZ;

  0090c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00914	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00917	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  0091d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00925	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN16@tok_nextc:

; 1010 :                 }
; 1011 :                 if (decoding_fgets(tok->buf, (int)(tok->end - tok->buf),
; 1012 :                           tok) == NULL) {

  00929	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00931	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00939	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0093c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00940	48 2b c1	 sub	 rax, rcx
  00943	4c 8b 84 24 30
	01 00 00	 mov	 r8, QWORD PTR tok$[rsp]
  0094b	8b d0		 mov	 edx, eax
  0094d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00955	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00958	e8 00 00 00 00	 call	 decoding_fgets
  0095d	48 85 c0	 test	 rax, rax
  00960	75 1c		 jne	 SHORT $LN14@tok_nextc

; 1013 :                     tok->done = E_EOF;

  00962	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0096a	c7 40 28 0b 00
	00 00		 mov	 DWORD PTR [rax+40], 11

; 1014 :                     done = 1;

  00971	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR done$21170[rsp], 1

; 1015 :                 }
; 1016 :                 else {

  0097c	eb 69		 jmp	 SHORT $LN13@tok_nextc
$LN14@tok_nextc:

; 1017 :                     tok->done = E_OK;

  0097e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00986	c7 40 28 0a 00
	00 00		 mov	 DWORD PTR [rax+40], 10

; 1018 :                     tok->inp = strchr(tok->buf, '\0');

  0098d	33 d2		 xor	 edx, edx
  0098f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00997	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0099a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  009a0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  009a8	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1019 :                     done = tok->inp[-1] == '\n';

  009ac	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  009b4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  009b8	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  009bc	83 f8 0a	 cmp	 eax, 10
  009bf	75 0d		 jne	 SHORT $LN67@tok_nextc
  009c1	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv337[rsp], 1
  009cc	eb 0b		 jmp	 SHORT $LN68@tok_nextc
$LN67@tok_nextc:
  009ce	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv337[rsp], 0
$LN68@tok_nextc:
  009d9	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv337[rsp]
  009e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR done$21170[rsp], eax
$LN13@tok_nextc:

; 1020 :                 }
; 1021 :             }
; 1022 :             else {

  009e7	eb 5b		 jmp	 SHORT $LN12@tok_nextc
$LN17@tok_nextc:

; 1023 :                 cur = tok->cur - tok->buf;

  009e9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  009f1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  009f9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  009fc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00a00	48 2b c1	 sub	 rax, rcx
  00a03	48 89 44 24 78	 mov	 QWORD PTR cur$21171[rsp], rax

; 1024 :                 if (decoding_feof(tok)) {

  00a08	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a10	e8 00 00 00 00	 call	 decoding_feof
  00a15	85 c0		 test	 eax, eax
  00a17	74 1c		 je	 SHORT $LN11@tok_nextc

; 1025 :                     tok->done = E_EOF;

  00a19	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00a21	c7 40 28 0b 00
	00 00		 mov	 DWORD PTR [rax+40], 11

; 1026 :                     done = 1;

  00a28	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR done$21170[rsp], 1

; 1027 :                 }
; 1028 :                 else

  00a33	eb 0f		 jmp	 SHORT $LN10@tok_nextc
$LN11@tok_nextc:

; 1029 :                     tok->done = E_OK;

  00a35	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00a3d	c7 40 28 0a 00
	00 00		 mov	 DWORD PTR [rax+40], 10
$LN10@tok_nextc:
$LN12@tok_nextc:

; 1030 :             }
; 1031 :             tok->lineno++;

  00a44	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00a4c	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  00a52	ff c0		 inc	 eax
  00a54	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a5c	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax
$LN9@tok_nextc:

; 1032 :             /* Read until '\n' or EOF */
; 1033 :             while (!done) {

  00a62	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR done$21170[rsp], 0
  00a6a	0f 85 92 02 00
	00		 jne	 $LN8@tok_nextc

; 1034 :                 Py_ssize_t curstart = tok->start == NULL ? -1 :
; 1035 :                           tok->start - tok->buf;

  00a70	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00a78	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00a7d	75 0e		 jne	 SHORT $LN69@tok_nextc
  00a7f	48 c7 84 24 f8
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR tv354[rsp], -1
  00a8b	eb 22		 jmp	 SHORT $LN70@tok_nextc
$LN69@tok_nextc:
  00a8d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00a95	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00a9d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00aa0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00aa4	48 2b c1	 sub	 rax, rcx
  00aa7	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv354[rsp], rax
$LN70@tok_nextc:
  00aaf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv354[rsp]
  00ab7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR curstart$21192[rsp], rax

; 1036 :                 Py_ssize_t curvalid = tok->inp - tok->buf;

  00abf	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00ac7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00acf	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00ad2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00ad6	48 2b c1	 sub	 rax, rcx
  00ad9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR curvalid$21194[rsp], rax

; 1037 :                 Py_ssize_t newsize = curvalid + BUFSIZ;

  00ae1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR curvalid$21194[rsp]
  00ae9	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  00aef	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR newsize$21195[rsp], rax

; 1038 :                 char *newbuf = tok->buf;

  00af7	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00aff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b02	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR newbuf$21196[rsp], rax

; 1039 :                 newbuf = (char *)PyMem_REALLOC(newbuf,
; 1040 :                                                newsize);

  00b0a	e8 00 00 00 00	 call	 _Py_PXCTX
  00b0f	85 c0		 test	 eax, eax
  00b11	74 1f		 je	 SHORT $LN71@tok_nextc
  00b13	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR newsize$21195[rsp]
  00b1b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR newbuf$21196[rsp]
  00b23	e8 00 00 00 00	 call	 _PxMem_Realloc
  00b28	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv366[rsp], rax
  00b30	eb 1d		 jmp	 SHORT $LN72@tok_nextc
$LN71@tok_nextc:
  00b32	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR newsize$21195[rsp]
  00b3a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR newbuf$21196[rsp]
  00b42	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  00b47	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv366[rsp], rax
$LN72@tok_nextc:
  00b4f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv366[rsp]
  00b57	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR newbuf$21196[rsp], rax

; 1041 :                 if (newbuf == NULL) {

  00b5f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR newbuf$21196[rsp], 0
  00b68	75 31		 jne	 SHORT $LN7@tok_nextc

; 1042 :                     tok->done = E_NOMEM;

  00b6a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00b72	c7 40 28 0f 00
	00 00		 mov	 DWORD PTR [rax+40], 15

; 1043 :                     tok->cur = tok->inp;

  00b79	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00b81	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00b89	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00b8d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1044 :                     return EOF;

  00b91	b8 ff ff ff ff	 mov	 eax, -1
  00b96	e9 62 02 00 00	 jmp	 $LN43@tok_nextc
$LN7@tok_nextc:

; 1045 :                 }
; 1046 :                 tok->buf = newbuf;

  00b9b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00ba3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR newbuf$21196[rsp]
  00bab	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1047 :                 tok->inp = tok->buf + curvalid;

  00bae	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00bb6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bb9	48 03 84 24 98
	00 00 00	 add	 rax, QWORD PTR curvalid$21194[rsp]
  00bc1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00bc9	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1048 :                 tok->end = tok->buf + newsize;

  00bcd	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00bd5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bd8	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR newsize$21195[rsp]
  00be0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00be8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1049 :                 tok->start = curstart < 0 ? NULL :
; 1050 :                          tok->buf + curstart;

  00bec	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR curstart$21192[rsp], 0
  00bf5	7d 0e		 jge	 SHORT $LN73@tok_nextc
  00bf7	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv378[rsp], 0
  00c03	eb 1b		 jmp	 SHORT $LN74@tok_nextc
$LN73@tok_nextc:
  00c05	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c0d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c10	48 03 84 24 88
	00 00 00	 add	 rax, QWORD PTR curstart$21192[rsp]
  00c18	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv378[rsp], rax
$LN74@tok_nextc:
  00c20	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c28	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv378[rsp]
  00c30	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1051 :                 if (decoding_fgets(tok->inp,
; 1052 :                                (int)(tok->end - tok->inp),
; 1053 :                                tok) == NULL) {

  00c34	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c3c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00c44	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00c48	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00c4c	48 2b c1	 sub	 rax, rcx
  00c4f	4c 8b 84 24 30
	01 00 00	 mov	 r8, QWORD PTR tok$[rsp]
  00c57	8b d0		 mov	 edx, eax
  00c59	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c61	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00c65	e8 00 00 00 00	 call	 decoding_fgets
  00c6a	48 85 c0	 test	 rax, rax
  00c6d	75 33		 jne	 SHORT $LN6@tok_nextc

; 1054 :                     /* Break out early on decoding
; 1055 :                        errors, as tok->buf will be NULL
; 1056 :                      */
; 1057 :                     if (tok->decoding_erred)

  00c6f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c77	83 b8 98 03 00
	00 00		 cmp	 DWORD PTR [rax+920], 0
  00c7e	74 0a		 je	 SHORT $LN5@tok_nextc

; 1058 :                         return EOF;

  00c80	b8 ff ff ff ff	 mov	 eax, -1
  00c85	e9 73 01 00 00	 jmp	 $LN43@tok_nextc
$LN5@tok_nextc:

; 1059 :                     /* Last line does not end in \n,
; 1060 :                        fake one */
; 1061 :                     strcpy(tok->inp, "\n");

  00c8a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00c91	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00c99	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00c9d	e8 00 00 00 00	 call	 strcpy
$LN6@tok_nextc:

; 1062 :                 }
; 1063 :                 tok->inp = strchr(tok->inp, '\0');

  00ca2	33 d2		 xor	 edx, edx
  00ca4	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00cac	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00cb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00cb6	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00cbe	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1064 :                 done = tok->inp[-1] == '\n';

  00cc2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00cca	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00cce	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00cd2	83 f8 0a	 cmp	 eax, 10
  00cd5	75 0d		 jne	 SHORT $LN75@tok_nextc
  00cd7	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv403[rsp], 1
  00ce2	eb 0b		 jmp	 SHORT $LN76@tok_nextc
$LN75@tok_nextc:
  00ce4	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv403[rsp], 0
$LN76@tok_nextc:
  00cef	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv403[rsp]
  00cf6	89 84 24 80 00
	00 00		 mov	 DWORD PTR done$21170[rsp], eax

; 1065 :             }

  00cfd	e9 60 fd ff ff	 jmp	 $LN9@tok_nextc
$LN8@tok_nextc:

; 1066 :             if (tok->buf != NULL) {

  00d02	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d0a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00d0e	0f 84 99 00 00
	00		 je	 $LN4@tok_nextc

; 1067 :                 tok->cur = tok->buf + cur;

  00d14	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d1c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d1f	48 03 44 24 78	 add	 rax, QWORD PTR cur$21171[rsp]
  00d24	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00d2c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1068 :                 tok->line_start = tok->cur;

  00d30	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d38	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00d40	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00d44	48 89 88 b0 03
	00 00		 mov	 QWORD PTR [rax+944], rcx

; 1069 :                 /* replace "\r\n" with "\n" */
; 1070 :                 /* For Mac leave the \r, giving a syntax error */
; 1071 :                 pt = tok->inp - 2;

  00d4b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d53	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00d57	48 83 e8 02	 sub	 rax, 2
  00d5b	48 89 44 24 70	 mov	 QWORD PTR pt$21172[rsp], rax

; 1072 :                 if (pt >= tok->buf && *pt == '\r') {

  00d60	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00d68	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d6b	48 39 44 24 70	 cmp	 QWORD PTR pt$21172[rsp], rax
  00d70	72 3b		 jb	 SHORT $LN3@tok_nextc
  00d72	48 8b 44 24 70	 mov	 rax, QWORD PTR pt$21172[rsp]
  00d77	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00d7a	83 f8 0d	 cmp	 eax, 13
  00d7d	75 2e		 jne	 SHORT $LN3@tok_nextc

; 1073 :                     *pt++ = '\n';

  00d7f	48 8b 44 24 70	 mov	 rax, QWORD PTR pt$21172[rsp]
  00d84	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00d87	48 8b 44 24 70	 mov	 rax, QWORD PTR pt$21172[rsp]
  00d8c	48 ff c0	 inc	 rax
  00d8f	48 89 44 24 70	 mov	 QWORD PTR pt$21172[rsp], rax

; 1074 :                     *pt = '\0';

  00d94	48 8b 44 24 70	 mov	 rax, QWORD PTR pt$21172[rsp]
  00d99	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1075 :                     tok->inp = pt;

  00d9c	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00da4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pt$21172[rsp]
  00da9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN3@tok_nextc:
$LN4@tok_nextc:
$LN18@tok_nextc:

; 1076 :                 }
; 1077 :             }
; 1078 :         }
; 1079 :         if (tok->done != E_OK) {

  00dad	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00db5	83 78 28 0a	 cmp	 DWORD PTR [rax+40], 10
  00db9	74 3d		 je	 SHORT $LN2@tok_nextc

; 1080 :             if (tok->prompt != NULL)

  00dbb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00dc3	48 83 b8 d8 01
	00 00 00	 cmp	 QWORD PTR [rax+472], 0
  00dcb	74 0c		 je	 SHORT $LN1@tok_nextc

; 1081 :                 PySys_WriteStderr("\n");

  00dcd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00dd4	e8 00 00 00 00	 call	 PySys_WriteStderr
$LN1@tok_nextc:

; 1082 :             tok->cur = tok->inp;

  00dd9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00de1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00de9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ded	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1083 :             return EOF;

  00df1	b8 ff ff ff ff	 mov	 eax, -1
  00df6	eb 05		 jmp	 SHORT $LN43@tok_nextc
$LN2@tok_nextc:

; 1084 :         }
; 1085 :     }

  00df8	e9 0f f2 ff ff	 jmp	 $LN42@tok_nextc
$LN43@tok_nextc:

; 1086 :     /*NOTREACHED*/
; 1087 : }

  00dfd	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00e04	c3		 ret	 0
tok_nextc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@ ; `string'
PUBLIC	??_C@_1EE@OEHNHNME@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAI?$AAN?$AAI@ ; `string'
EXTRN	Py_UniversalNewlineFgets:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decoding_fgets DD imagerel decoding_fgets
	DD	imagerel decoding_fgets+506
	DD	imagerel $unwind$decoding_fgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decoding_fgets DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT ??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@
CONST	SEGMENT
??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@ DB 'Non-UTF-'
	DB	'8 code starting with ''\x%.2x'' in file %U on line %i, but no'
	DB	' encoding declared; see http://python.org/dev/peps/pep-0263/ '
	DB	'for details', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@OEHNHNME@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAI?$AAN?$AAI@
CONST	SEGMENT
??_C@_1EE@OEHNHNME@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAI?$AAN?$AAI@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, '-', 00H, '>', 00H, 'd', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'S', 00H, 'T', 00H, 'A', 00H, 'T'
	DB	00H, 'E', 00H, '_', 00H, 'I', 00H, 'N', 00H, 'I', 00H, 'T', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT decoding_fgets
_TEXT	SEGMENT
line$ = 48
badchar$ = 56
length$20883 = 60
c$20882 = 64
s$ = 96
size$ = 104
tok$ = 112
decoding_fgets PROC					; COMDAT

; 578  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 579  :     char *line = NULL;

  00012	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR line$[rsp], 0

; 580  :     int badchar = 0;

  0001b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR badchar$[rsp], 0
$LN15@decoding_f:

; 581  :     for (;;) {
; 582  :         if (tok->decoding_state == STATE_NORMAL) {

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00028	83 b8 94 03 00
	00 02		 cmp	 DWORD PTR [rax+916], 2
  0002f	75 22		 jne	 SHORT $LN13@decoding_f

; 583  :             /* We already have a codec associated with
; 584  :                this input. */
; 585  :             line = fp_readl(s, size, tok);

  00031	4c 8b 44 24 70	 mov	 r8, QWORD PTR tok$[rsp]
  00036	8b 54 24 68	 mov	 edx, DWORD PTR size$[rsp]
  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 fp_readl
  00044	48 89 44 24 30	 mov	 QWORD PTR line$[rsp], rax

; 586  :             break;

  00049	e9 97 00 00 00	 jmp	 $LN14@decoding_f
  0004e	e9 8d 00 00 00	 jmp	 $LN12@decoding_f
$LN13@decoding_f:

; 587  :         } else if (tok->decoding_state == STATE_RAW) {

  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00058	83 b8 94 03 00
	00 01		 cmp	 DWORD PTR [rax+916], 1
  0005f	75 23		 jne	 SHORT $LN11@decoding_f

; 588  :             /* We want a 'raw' read. */
; 589  :             line = Py_UniversalNewlineFgets(s, size,
; 590  :                                             tok->fp, NULL);

  00061	45 33 c9	 xor	 r9d, r9d
  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00069	4c 8b 40 30	 mov	 r8, QWORD PTR [rax+48]
  0006d	8b 54 24 68	 mov	 edx, DWORD PTR size$[rsp]
  00071	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00076	e8 00 00 00 00	 call	 Py_UniversalNewlineFgets
  0007b	48 89 44 24 30	 mov	 QWORD PTR line$[rsp], rax

; 591  :             break;

  00080	eb 63		 jmp	 SHORT $LN14@decoding_f

; 592  :         } else {

  00082	eb 5c		 jmp	 SHORT $LN10@decoding_f
$LN11@decoding_f:

; 593  :             /* We have not yet determined the encoding.
; 594  :                If an encoding is found, use the file-pointer
; 595  :                reader functions from now on. */
; 596  :             if (!check_bom(fp_getc, fp_ungetc, fp_setreadl, tok))

  00084	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tok$[rsp]
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:fp_setreadl
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fp_ungetc
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fp_getc
  0009e	e8 00 00 00 00	 call	 check_bom
  000a3	85 c0		 test	 eax, eax
  000a5	75 0f		 jne	 SHORT $LN9@decoding_f

; 597  :                 return error_ret(tok);

  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  000ac	e8 00 00 00 00	 call	 error_ret
  000b1	e9 3f 01 00 00	 jmp	 $LN16@decoding_f
$LN9@decoding_f:

; 598  :             assert(tok->decoding_state != STATE_INIT);

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  000bb	83 b8 94 03 00
	00 00		 cmp	 DWORD PTR [rax+916], 0
  000c2	75 1c		 jne	 SHORT $LN18@decoding_f
  000c4	41 b8 56 02 00
	00		 mov	 r8d, 598		; 00000256H
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OEHNHNME@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAd?$AAe?$AAc?$AAo?$AAd?$AAi?$AAn?$AAg?$AA_?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAS?$AAT?$AAA?$AAT?$AAE?$AA_?$AAI?$AAN?$AAI@
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000de	33 c0		 xor	 eax, eax
$LN18@decoding_f:
$LN10@decoding_f:
$LN12@decoding_f:

; 599  :         }
; 600  :     }

  000e0	e9 3e ff ff ff	 jmp	 $LN15@decoding_f
$LN14@decoding_f:

; 601  :     if (line != NULL && tok->lineno < 2 && !tok->read_coding_spec) {

  000e5	48 83 7c 24 30
	00		 cmp	 QWORD PTR line$[rsp], 0
  000eb	74 52		 je	 SHORT $LN8@decoding_f
  000ed	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  000f2	83 b8 e8 01 00
	00 02		 cmp	 DWORD PTR [rax+488], 2
  000f9	7d 44		 jge	 SHORT $LN8@decoding_f
  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  00100	83 b8 9c 03 00
	00 00		 cmp	 DWORD PTR [rax+924], 0
  00107	75 36		 jne	 SHORT $LN8@decoding_f

; 602  :         if (!check_coding_spec(line, strlen(line), tok, fp_setreadl)) {

  00109	48 8b 4c 24 30	 mov	 rcx, QWORD PTR line$[rsp]
  0010e	e8 00 00 00 00	 call	 strlen
  00113	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:fp_setreadl
  0011a	4c 8b 44 24 70	 mov	 r8, QWORD PTR tok$[rsp]
  0011f	48 8b d0	 mov	 rdx, rax
  00122	48 8b 4c 24 30	 mov	 rcx, QWORD PTR line$[rsp]
  00127	e8 00 00 00 00	 call	 check_coding_spec
  0012c	85 c0		 test	 eax, eax
  0012e	75 0f		 jne	 SHORT $LN7@decoding_f

; 603  :             return error_ret(tok);

  00130	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  00135	e8 00 00 00 00	 call	 error_ret
  0013a	e9 b6 00 00 00	 jmp	 $LN16@decoding_f
$LN7@decoding_f:
$LN8@decoding_f:

; 604  :         }
; 605  :     }
; 606  : #ifndef PGEN
; 607  :     /* The default encoding is UTF-8, so make sure we don't have any
; 608  :        non-UTF-8 sequences in it. */
; 609  :     if (line && !tok->encoding) {

  0013f	48 83 7c 24 30
	00		 cmp	 QWORD PTR line$[rsp], 0
  00145	74 61		 je	 SHORT $LN6@decoding_f
  00147	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  0014c	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  00154	75 52		 jne	 SHORT $LN6@decoding_f

; 610  :         unsigned char *c;
; 611  :         int length;
; 612  :         for (c = (unsigned char *)line; *c; c += length)

  00156	48 8b 44 24 30	 mov	 rax, QWORD PTR line$[rsp]
  0015b	48 89 44 24 40	 mov	 QWORD PTR c$20882[rsp], rax
  00160	eb 15		 jmp	 SHORT $LN5@decoding_f
$LN4@decoding_f:
  00162	48 63 44 24 3c	 movsxd	 rax, DWORD PTR length$20883[rsp]
  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$20882[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 89 44 24 40	 mov	 QWORD PTR c$20882[rsp], rax
$LN5@decoding_f:
  00177	48 8b 44 24 40	 mov	 rax, QWORD PTR c$20882[rsp]
  0017c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017f	85 c0		 test	 eax, eax
  00181	74 25		 je	 SHORT $LN3@decoding_f

; 613  :             if (!(length = valid_utf8(c))) {

  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$20882[rsp]
  00188	e8 00 00 00 00	 call	 valid_utf8
  0018d	89 44 24 3c	 mov	 DWORD PTR length$20883[rsp], eax
  00191	83 7c 24 3c 00	 cmp	 DWORD PTR length$20883[rsp], 0
  00196	75 0e		 jne	 SHORT $LN2@decoding_f

; 614  :                 badchar = *c;

  00198	48 8b 44 24 40	 mov	 rax, QWORD PTR c$20882[rsp]
  0019d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a0	89 44 24 38	 mov	 DWORD PTR badchar$[rsp], eax

; 615  :                 break;

  001a4	eb 02		 jmp	 SHORT $LN3@decoding_f
$LN2@decoding_f:

; 616  :             }
; 617  :     }

  001a6	eb ba		 jmp	 SHORT $LN4@decoding_f
$LN3@decoding_f:
$LN6@decoding_f:

; 618  :     if (badchar) {

  001a8	83 7c 24 38 00	 cmp	 DWORD PTR badchar$[rsp], 0
  001ad	74 41		 je	 SHORT $LN1@decoding_f

; 619  :         /* Need to add 1 to the line number, since this line
; 620  :            has not been counted, yet.  */
; 621  :         PyErr_Format(PyExc_SyntaxError,
; 622  :                 "Non-UTF-8 code starting with '\\x%.2x' "
; 623  :                 "in file %U on line %i, "
; 624  :                 "but no encoding declared; "
; 625  :                 "see http://python.org/dev/peps/pep-0263/ for details",
; 626  :                 badchar, tok->filename, tok->lineno + 1);

  001af	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001b4	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  001ba	ff c0		 inc	 eax
  001bc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001c0	48 8b 44 24 70	 mov	 rax, QWORD PTR tok$[rsp]
  001c5	4c 8b 88 f0 01
	00 00		 mov	 r9, QWORD PTR [rax+496]
  001cc	44 8b 44 24 38	 mov	 r8d, DWORD PTR badchar$[rsp]
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@
  001d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  001df	e8 00 00 00 00	 call	 PyErr_Format

; 627  :         return error_ret(tok);

  001e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tok$[rsp]
  001e9	e8 00 00 00 00	 call	 error_ret
  001ee	eb 05		 jmp	 SHORT $LN16@decoding_f
$LN1@decoding_f:

; 628  :     }
; 629  : #endif
; 630  :     return line;

  001f0	48 8b 44 24 30	 mov	 rax, QWORD PTR line$[rsp]
$LN16@decoding_f:

; 631  : }

  001f5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f9	c3		 ret	 0
decoding_fgets ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@IAGNAJBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	_Py_IncRef
PUBLIC	??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	PyByteArray_FromStringAndSize:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	PyByteArray_AsString:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fp_readl DD imagerel fp_readl
	DD	imagerel fp_readl+569
	DD	imagerel $unwind$fp_readl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_readl DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_1DE@IAGNAJBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@IAGNAJBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 'A', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'b', 00H, 'u', 00H
	DB	'f', 00H, 'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fp_readl
_TEXT	SEGMENT
buflen$ = 32
bufobj$ = 40
buf$ = 48
s$ = 80
size$ = 88
tok$ = 96
fp_readl PROC						; COMDAT

; 417  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 418  :     PyObject* bufobj;
; 419  :     const char *buf;
; 420  :     Py_ssize_t buflen;
; 421  : 
; 422  :     /* Ask for one less byte so we can terminate it */
; 423  :     assert(size > 0);

  00012	83 7c 24 58 00	 cmp	 DWORD PTR size$[rsp], 0
  00017	7f 1c		 jg	 SHORT $LN22@fp_readl
  00019	41 b8 a7 01 00
	00		 mov	 r8d, 423		; 000001a7H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN22@fp_readl:

; 424  :     size--;

  00035	8b 44 24 58	 mov	 eax, DWORD PTR size$[rsp]
  00039	ff c8		 dec	 eax
  0003b	89 44 24 58	 mov	 DWORD PTR size$[rsp], eax

; 425  : 
; 426  :     if (tok->decoding_buffer) {

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  00044	48 83 b8 c0 03
	00 00 00	 cmp	 QWORD PTR [rax+960], 0
  0004c	74 1d		 je	 SHORT $LN19@fp_readl

; 427  :         bufobj = tok->decoding_buffer;

  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  00053	48 8b 80 c0 03
	00 00		 mov	 rax, QWORD PTR [rax+960]
  0005a	48 89 44 24 28	 mov	 QWORD PTR bufobj$[rsp], rax

; 428  :         Py_INCREF(bufobj);

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  00064	e8 00 00 00 00	 call	 _Py_IncRef

; 429  :     }
; 430  :     else

  00069	eb 25		 jmp	 SHORT $LN18@fp_readl
$LN19@fp_readl:

; 431  :     {
; 432  :         bufobj = PyObject_CallObject(tok->decoding_readline, NULL);

  0006b	33 d2		 xor	 edx, edx
  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  00072	48 8b 88 b8 03
	00 00		 mov	 rcx, QWORD PTR [rax+952]
  00079	e8 00 00 00 00	 call	 PyObject_CallObject
  0007e	48 89 44 24 28	 mov	 QWORD PTR bufobj$[rsp], rax

; 433  :         if (bufobj == NULL)

  00083	48 83 7c 24 28
	00		 cmp	 QWORD PTR bufobj$[rsp], 0
  00089	75 05		 jne	 SHORT $LN17@fp_readl

; 434  :             goto error;

  0008b	e9 82 01 00 00	 jmp	 $error$20741
$LN17@fp_readl:
$LN18@fp_readl:

; 435  :     }
; 436  :     if (PyUnicode_CheckExact(bufobj))

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  0009c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000a0	75 23		 jne	 SHORT $LN16@fp_readl

; 437  :     {
; 438  :         buf = _PyUnicode_AsStringAndSize(bufobj, &buflen);

  000a2	48 8d 54 24 20	 lea	 rdx, QWORD PTR buflen$[rsp]
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  000ac	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  000b1	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 439  :         if (buf == NULL) {

  000b6	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000bc	75 05		 jne	 SHORT $LN15@fp_readl

; 440  :             goto error;

  000be	e9 4f 01 00 00	 jmp	 $error$20741
$LN15@fp_readl:

; 441  :         }
; 442  :     }
; 443  :     else

  000c3	eb 71		 jmp	 SHORT $LN14@fp_readl
$LN16@fp_readl:

; 444  :     {
; 445  :         buf = PyByteArray_AsString(bufobj);

  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  000ca	e8 00 00 00 00	 call	 PyByteArray_AsString
  000cf	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 446  :         if (buf == NULL) {

  000d4	48 83 7c 24 30
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000da	75 05		 jne	 SHORT $LN13@fp_readl

; 447  :             goto error;

  000dc	e9 31 01 00 00	 jmp	 $error$20741
$LN13@fp_readl:

; 448  :         }
; 449  :         buflen = PyByteArray_GET_SIZE(bufobj);

  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  000ed	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f1	74 35		 je	 SHORT $LN23@fp_readl
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000fa	48 8b 44 24 28	 mov	 rax, QWORD PTR bufobj$[rsp]
  000ff	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00103	e8 00 00 00 00	 call	 PyType_IsSubtype
  00108	85 c0		 test	 eax, eax
  0010a	75 1c		 jne	 SHORT $LN23@fp_readl
  0010c	41 b8 c1 01 00
	00		 mov	 r8d, 449		; 000001c1H
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@IAGNAJBJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAA?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00126	33 c0		 xor	 eax, eax
$LN23@fp_readl:
  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR bufobj$[rsp]
  0012d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00131	48 89 44 24 20	 mov	 QWORD PTR buflen$[rsp], rax
$LN14@fp_readl:
$LN12@fp_readl:

; 450  :     }
; 451  : 
; 452  :     Py_XDECREF(tok->decoding_buffer);

  00136	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  0013b	48 83 b8 c0 03
	00 00 00	 cmp	 QWORD PTR [rax+960], 0
  00143	74 11		 je	 SHORT $LN9@fp_readl
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  0014a	48 8b 88 c0 03
	00 00		 mov	 rcx, QWORD PTR [rax+960]
  00151	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@fp_readl:
  00156	33 c0		 xor	 eax, eax
  00158	85 c0		 test	 eax, eax
  0015a	75 da		 jne	 SHORT $LN12@fp_readl

; 453  :     if (buflen > size) {

  0015c	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  00161	48 39 44 24 20	 cmp	 QWORD PTR buflen$[rsp], rax
  00166	7e 51		 jle	 SHORT $LN8@fp_readl

; 454  :         /* Too many chars, the rest goes into tok->decoding_buffer */
; 455  :         tok->decoding_buffer = PyByteArray_FromStringAndSize(buf+size,
; 456  :                                                          buflen-size);

  00168	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  0016d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buflen$[rsp]
  00172	48 2b c8	 sub	 rcx, rax
  00175	48 8b c1	 mov	 rax, rcx
  00178	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR size$[rsp]
  0017d	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  00182	48 03 d1	 add	 rdx, rcx
  00185	48 8b ca	 mov	 rcx, rdx
  00188	48 8b d0	 mov	 rdx, rax
  0018b	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tok$[rsp]
  00195	48 89 81 c0 03
	00 00		 mov	 QWORD PTR [rcx+960], rax

; 457  :         if (tok->decoding_buffer == NULL)

  0019c	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  001a1	48 83 b8 c0 03
	00 00 00	 cmp	 QWORD PTR [rax+960], 0
  001a9	75 02		 jne	 SHORT $LN7@fp_readl

; 458  :             goto error;

  001ab	eb 65		 jmp	 SHORT $error$20741
$LN7@fp_readl:

; 459  :         buflen = size;

  001ad	48 63 44 24 58	 movsxd	 rax, DWORD PTR size$[rsp]
  001b2	48 89 44 24 20	 mov	 QWORD PTR buflen$[rsp], rax

; 460  :     }
; 461  :     else

  001b7	eb 10		 jmp	 SHORT $LN6@fp_readl
$LN8@fp_readl:

; 462  :         tok->decoding_buffer = NULL;

  001b9	48 8b 44 24 60	 mov	 rax, QWORD PTR tok$[rsp]
  001be	48 c7 80 c0 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+960], 0
$LN6@fp_readl:

; 463  : 
; 464  :     memcpy(s, buf, buflen);

  001c9	4c 8b 44 24 20	 mov	 r8, QWORD PTR buflen$[rsp]
  001ce	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001d8	e8 00 00 00 00	 call	 memcpy

; 465  :     s[buflen] = '\0';

  001dd	48 8b 44 24 20	 mov	 rax, QWORD PTR buflen$[rsp]
  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001e7	48 03 c8	 add	 rcx, rax
  001ea	48 8b c1	 mov	 rax, rcx
  001ed	c6 00 00	 mov	 BYTE PTR [rax], 0

; 466  :     if (buflen == 0) /* EOF */

  001f0	48 83 7c 24 20
	00		 cmp	 QWORD PTR buflen$[rsp], 0
  001f6	75 09		 jne	 SHORT $LN5@fp_readl

; 467  :         s = NULL;

  001f8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0
$LN5@fp_readl:

; 468  :     Py_DECREF(bufobj);

  00201	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  00206	e8 00 00 00 00	 call	 _Py_DecRef

; 469  :     return s;

  0020b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00210	eb 22		 jmp	 SHORT $LN20@fp_readl
$error$20741:
$LN4@fp_readl:

; 470  : 
; 471  : error:
; 472  :     Py_XDECREF(bufobj);

  00212	48 83 7c 24 28
	00		 cmp	 QWORD PTR bufobj$[rsp], 0
  00218	74 0a		 je	 SHORT $LN1@fp_readl
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufobj$[rsp]
  0021f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fp_readl:
  00224	33 c0		 xor	 eax, eax
  00226	85 c0		 test	 eax, eax
  00228	75 e8		 jne	 SHORT $LN4@fp_readl

; 473  :     return error_ret(tok);

  0022a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tok$[rsp]
  0022f	e8 00 00 00 00	 call	 error_ret
$LN20@fp_readl:

; 474  : }

  00234	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00238	c3		 ret	 0
fp_readl ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_07NGCAEEGB@isisOOO?$AA@			; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_02KFNNKBCK@io?$AA@			; `string'
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp_lseek:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_fileno:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\parser\tokenizer.c
pdata	SEGMENT
$pdata$fp_setreadl DD imagerel fp_setreadl
	DD	imagerel fp_setreadl+558
	DD	imagerel $unwind$fp_setreadl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_setreadl DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_07NGCAEEGB@isisOOO?$AA@
CONST	SEGMENT
??_C@_07NGCAEEGB@isisOOO?$AA@ DB 'isisOOO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFNNKBCK@io?$AA@
CONST	SEGMENT
??_C@_02KFNNKBCK@io?$AA@ DB 'io', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fp_setreadl
_TEXT	SEGMENT
io$ = 80
readline$ = 88
stream$ = 96
pos$ = 104
fd$ = 108
tv78 = 112
tv161 = 116
tok$ = 144
enc$ = 152
fp_setreadl PROC					; COMDAT

; 488  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 489  :     PyObject *readline = NULL, *stream = NULL, *io = NULL;

  00011	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR readline$[rsp], 0
  0001a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR stream$[rsp], 0
  00023	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR io$[rsp], 0

; 490  :     _Py_IDENTIFIER(open);
; 491  :     _Py_IDENTIFIER(readline);
; 492  :     int fd;
; 493  :     long pos;
; 494  : 
; 495  :     io = PyImport_ImportModuleNoBlock("io");

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KFNNKBCK@io?$AA@
  00033	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00038	48 89 44 24 50	 mov	 QWORD PTR io$[rsp], rax

; 496  :     if (io == NULL)

  0003d	48 83 7c 24 50
	00		 cmp	 QWORD PTR io$[rsp], 0
  00043	75 05		 jne	 SHORT $LN18@fp_setread

; 497  :         goto cleanup;

  00045	e9 8e 01 00 00	 jmp	 $cleanup$20795
$LN18@fp_setread:

; 498  : 
; 499  :     fd = fileno(tok->fp);

  0004a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00052	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0005c	89 44 24 6c	 mov	 DWORD PTR fd$[rsp], eax

; 500  :     /* Due to buffering the file offset for fd can be different from the file
; 501  :      * position of tok->fp.  If tok->fp was opened in text mode on Windows,
; 502  :      * its file position counts CRLF as one char and can't be directly mapped
; 503  :      * to the file offset for fd.  Instead we step back one byte and read to
; 504  :      * the end of line.*/
; 505  :     pos = ftell(tok->fp);

  00060	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00068	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00072	89 44 24 68	 mov	 DWORD PTR pos$[rsp], eax

; 506  :     if (pos == -1 ||
; 507  :         lseek(fd, (off_t)(pos > 0 ? pos - 1 : pos), SEEK_SET) == (off_t)-1) {

  00076	83 7c 24 68 ff	 cmp	 DWORD PTR pos$[rsp], -1
  0007b	74 31		 je	 SHORT $LN16@fp_setread
  0007d	83 7c 24 68 00	 cmp	 DWORD PTR pos$[rsp], 0
  00082	7e 0c		 jle	 SHORT $LN21@fp_setread
  00084	8b 44 24 68	 mov	 eax, DWORD PTR pos$[rsp]
  00088	ff c8		 dec	 eax
  0008a	89 44 24 70	 mov	 DWORD PTR tv78[rsp], eax
  0008e	eb 08		 jmp	 SHORT $LN22@fp_setread
$LN21@fp_setread:
  00090	8b 44 24 68	 mov	 eax, DWORD PTR pos$[rsp]
  00094	89 44 24 70	 mov	 DWORD PTR tv78[rsp], eax
$LN22@fp_setread:
  00098	45 33 c0	 xor	 r8d, r8d
  0009b	8b 54 24 70	 mov	 edx, DWORD PTR tv78[rsp]
  0009f	8b 4c 24 6c	 mov	 ecx, DWORD PTR fd$[rsp]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  000a9	83 f8 ff	 cmp	 eax, -1
  000ac	75 13		 jne	 SHORT $LN17@fp_setread
$LN16@fp_setread:

; 508  :         PyErr_SetFromErrnoWithFilename(PyExc_OSError, NULL);

  000ae	33 d2		 xor	 edx, edx
  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000b7	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename

; 509  :         goto cleanup;

  000bc	e9 17 01 00 00	 jmp	 $cleanup$20795
$LN17@fp_setread:

; 510  :     }
; 511  : 
; 512  :     stream = _PyObject_CallMethodId(io, &PyId_open, "isisOOO",
; 513  :                     fd, "r", -1, enc, Py_None, Py_None, Py_False);

  000c1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_open@?1??fp_setreadl@@9@9
  000c6	8b c0		 mov	 eax, eax
  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000ce	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000d7	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000e2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000ee	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR enc$[rsp]
  00107	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010c	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0011b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00120	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR fd$[rsp]
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07NGCAEEGB@isisOOO?$AA@
  0012c	48 8b d0	 mov	 rdx, rax
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR io$[rsp]
  00134	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00139	48 89 44 24 60	 mov	 QWORD PTR stream$[rsp], rax

; 514  :     if (stream == NULL)

  0013e	48 83 7c 24 60
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00144	75 05		 jne	 SHORT $LN15@fp_setread

; 515  :         goto cleanup;

  00146	e9 8d 00 00 00	 jmp	 $cleanup$20795
$LN15@fp_setread:
$LN14@fp_setread:

; 516  : 
; 517  :     Py_XDECREF(tok->decoding_readline);

  0014b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00153	48 83 b8 b8 03
	00 00 00	 cmp	 QWORD PTR [rax+952], 0
  0015b	74 14		 je	 SHORT $LN11@fp_setread
  0015d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00165	48 8b 88 b8 03
	00 00		 mov	 rcx, QWORD PTR [rax+952]
  0016c	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@fp_setread:
  00171	33 c0		 xor	 eax, eax
  00173	85 c0		 test	 eax, eax
  00175	75 d4		 jne	 SHORT $LN14@fp_setread

; 518  :     readline = _PyObject_GetAttrId(stream, &PyId_readline);

  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_readline@?1??fp_setreadl@@9@9
  0017c	8b c0		 mov	 eax, eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00184	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00191	48 8b d0	 mov	 rdx, rax
  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stream$[rsp]
  00199	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0019e	48 89 44 24 58	 mov	 QWORD PTR readline$[rsp], rax

; 519  :     tok->decoding_readline = readline;

  001a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  001ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR readline$[rsp]
  001b0	48 89 88 b8 03
	00 00		 mov	 QWORD PTR [rax+952], rcx

; 520  :     if (pos > 0) {

  001b7	83 7c 24 68 00	 cmp	 DWORD PTR pos$[rsp], 0
  001bc	7e 1a		 jle	 SHORT $LN10@fp_setread

; 521  :         if (PyObject_CallObject(readline, NULL) == NULL) {

  001be	33 d2		 xor	 edx, edx
  001c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR readline$[rsp]
  001c5	e8 00 00 00 00	 call	 PyObject_CallObject
  001ca	48 85 c0	 test	 rax, rax
  001cd	75 09		 jne	 SHORT $LN9@fp_setread

; 522  :             readline = NULL;

  001cf	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR readline$[rsp], 0
$LN9@fp_setread:
$LN10@fp_setread:
$cleanup$20795:
$LN8@fp_setread:

; 523  :             goto cleanup;
; 524  :         }
; 525  :     }
; 526  : 
; 527  :   cleanup:
; 528  :     Py_XDECREF(stream);

  001d8	48 83 7c 24 60
	00		 cmp	 QWORD PTR stream$[rsp], 0
  001de	74 0a		 je	 SHORT $LN5@fp_setread
  001e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stream$[rsp]
  001e5	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@fp_setread:
  001ea	33 c0		 xor	 eax, eax
  001ec	85 c0		 test	 eax, eax
  001ee	75 e8		 jne	 SHORT $LN8@fp_setread
$LN4@fp_setread:

; 529  :     Py_XDECREF(io);

  001f0	48 83 7c 24 50
	00		 cmp	 QWORD PTR io$[rsp], 0
  001f6	74 0a		 je	 SHORT $LN1@fp_setread
  001f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR io$[rsp]
  001fd	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fp_setread:
  00202	33 c0		 xor	 eax, eax
  00204	85 c0		 test	 eax, eax
  00206	75 e8		 jne	 SHORT $LN4@fp_setread

; 530  :     return readline != NULL;

  00208	48 83 7c 24 58
	00		 cmp	 QWORD PTR readline$[rsp], 0
  0020e	74 0a		 je	 SHORT $LN23@fp_setread
  00210	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  00218	eb 08		 jmp	 SHORT $LN24@fp_setread
$LN23@fp_setread:
  0021a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN24@fp_setread:
  00222	8b 44 24 74	 mov	 eax, DWORD PTR tv161[rsp]

; 531  : }

  00226	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0022d	c3		 ret	 0
fp_setreadl ENDP
_TEXT	ENDS
EXTRN	__imp_getc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fp_getc DD imagerel fp_getc
	DD	imagerel fp_getc+29
	DD	imagerel $unwind$fp_getc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_getc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fp_getc
_TEXT	SEGMENT
tok$ = 48
fp_getc	PROC						; COMDAT

; 535  : static int fp_getc(struct tok_state *tok) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 536  :     return getc(tok->fp);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc

; 537  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
fp_getc	ENDP
_TEXT	ENDS
EXTRN	__imp_ungetc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fp_ungetc DD imagerel fp_ungetc
	DD	imagerel fp_ungetc+37
	DD	imagerel $unwind$fp_ungetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_ungetc DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fp_ungetc
_TEXT	SEGMENT
c$ = 48
tok$ = 56
fp_ungetc PROC						; COMDAT

; 541  : static void fp_ungetc(int c, struct tok_state *tok) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 542  :     ungetc(c, tok->fp);

  0000d	48 8b 44 24 38	 mov	 rax, QWORD PTR tok$[rsp]
  00012	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  00016	8b 4c 24 30	 mov	 ecx, DWORD PTR c$[rsp]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 543  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
fp_ungetc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$valid_utf8 DD imagerel valid_utf8
	DD	imagerel valid_utf8+227
	DD	imagerel $unwind$valid_utf8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$valid_utf8 DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT valid_utf8
_TEXT	SEGMENT
length$ = 0
expected$ = 4
s$ = 32
valid_utf8 PROC						; COMDAT

; 549  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 550  :     int expected = 0;

  00009	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR expected$[rsp], 0

; 551  :     int length;
; 552  :     if (*s < 0x80)

  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00016	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00019	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0001e	7d 0a		 jge	 SHORT $LN13@valid_utf8

; 553  :         /* single-byte code */
; 554  :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	e9 b4 00 00 00	 jmp	 $LN14@valid_utf8
$LN13@valid_utf8:

; 555  :     if (*s < 0xc0)

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00037	7d 07		 jge	 SHORT $LN12@valid_utf8

; 556  :         /* following byte */
; 557  :         return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 9e 00 00 00	 jmp	 $LN14@valid_utf8
$LN12@valid_utf8:

; 558  :     if (*s < 0xE0)

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00045	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00048	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  0004d	7d 0a		 jge	 SHORT $LN11@valid_utf8

; 559  :         expected = 1;

  0004f	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR expected$[rsp], 1
  00057	eb 36		 jmp	 SHORT $LN10@valid_utf8
$LN11@valid_utf8:

; 560  :     else if (*s < 0xF0)

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0005e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00061	3d f0 00 00 00	 cmp	 eax, 240		; 000000f0H
  00066	7d 0a		 jge	 SHORT $LN9@valid_utf8

; 561  :         expected = 2;

  00068	c7 44 24 04 02
	00 00 00	 mov	 DWORD PTR expected$[rsp], 2
  00070	eb 1d		 jmp	 SHORT $LN8@valid_utf8
$LN9@valid_utf8:

; 562  :     else if (*s < 0xF8)

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00077	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007a	3d f8 00 00 00	 cmp	 eax, 248		; 000000f8H
  0007f	7d 0a		 jge	 SHORT $LN7@valid_utf8

; 563  :         expected = 3;

  00081	c7 44 24 04 03
	00 00 00	 mov	 DWORD PTR expected$[rsp], 3

; 564  :     else

  00089	eb 04		 jmp	 SHORT $LN6@valid_utf8
$LN7@valid_utf8:

; 565  :         return 0;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 4f		 jmp	 SHORT $LN14@valid_utf8
$LN6@valid_utf8:
$LN8@valid_utf8:
$LN10@valid_utf8:

; 566  :     length = expected + 1;

  0008f	8b 44 24 04	 mov	 eax, DWORD PTR expected$[rsp]
  00093	ff c0		 inc	 eax
  00095	89 04 24	 mov	 DWORD PTR length$[rsp], eax

; 567  :     for (; expected; expected--)

  00098	eb 0a		 jmp	 SHORT $LN5@valid_utf8
$LN4@valid_utf8:
  0009a	8b 44 24 04	 mov	 eax, DWORD PTR expected$[rsp]
  0009e	ff c8		 dec	 eax
  000a0	89 44 24 04	 mov	 DWORD PTR expected$[rsp], eax
$LN5@valid_utf8:
  000a4	83 7c 24 04 00	 cmp	 DWORD PTR expected$[rsp], 0
  000a9	74 30		 je	 SHORT $LN3@valid_utf8

; 568  :         if (s[expected] < 0x80 || s[expected] >= 0xC0)

  000ab	48 63 44 24 04	 movsxd	 rax, DWORD PTR expected$[rsp]
  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b9	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000be	7c 15		 jl	 SHORT $LN1@valid_utf8
  000c0	48 63 44 24 04	 movsxd	 rax, DWORD PTR expected$[rsp]
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ce	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000d3	7c 04		 jl	 SHORT $LN2@valid_utf8
$LN1@valid_utf8:

; 569  :             return 0;

  000d5	33 c0		 xor	 eax, eax
  000d7	eb 05		 jmp	 SHORT $LN14@valid_utf8
$LN2@valid_utf8:

; 570  :     return length;

  000d9	eb bf		 jmp	 SHORT $LN4@valid_utf8
$LN3@valid_utf8:
  000db	8b 04 24	 mov	 eax, DWORD PTR length$[rsp]
$LN14@valid_utf8:

; 571  : }

  000de	48 83 c4 18	 add	 rsp, 24
  000e2	c3		 ret	 0
valid_utf8 ENDP
_TEXT	ENDS
EXTRN	PyObject_Size:PROC
EXTRN	__imp_feof:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decoding_feof DD imagerel decoding_feof
	DD	imagerel decoding_feof+183
	DD	imagerel $unwind$decoding_feof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decoding_feof DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT decoding_feof
_TEXT	SEGMENT
buf$20897 = 32
tv81 = 40
tok$ = 64
decoding_feof PROC					; COMDAT

; 635  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 636  :     if (tok->decoding_state != STATE_NORMAL) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	83 b8 94 03 00
	00 02		 cmp	 DWORD PTR [rax+916], 2
  00015	74 19		 je	 SHORT $LN5@decoding_f@2

; 637  :         return feof(tok->fp);

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0001c	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00026	e9 87 00 00 00	 jmp	 $LN6@decoding_f@2

; 638  :     } else {

  0002b	e9 82 00 00 00	 jmp	 $LN4@decoding_f@2
$LN5@decoding_f@2:

; 639  :         PyObject* buf = tok->decoding_buffer;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00035	48 8b 80 c0 03
	00 00		 mov	 rax, QWORD PTR [rax+960]
  0003c	48 89 44 24 20	 mov	 QWORD PTR buf$20897[rsp], rax

; 640  :         if (buf == NULL) {

  00041	48 83 7c 24 20
	00		 cmp	 QWORD PTR buf$20897[rsp], 0
  00047	75 44		 jne	 SHORT $LN3@decoding_f@2

; 641  :             buf = PyObject_CallObject(tok->decoding_readline, NULL);

  00049	33 d2		 xor	 edx, edx
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00050	48 8b 88 b8 03
	00 00		 mov	 rcx, QWORD PTR [rax+952]
  00057	e8 00 00 00 00	 call	 PyObject_CallObject
  0005c	48 89 44 24 20	 mov	 QWORD PTR buf$20897[rsp], rax

; 642  :             if (buf == NULL) {

  00061	48 83 7c 24 20
	00		 cmp	 QWORD PTR buf$20897[rsp], 0
  00067	75 13		 jne	 SHORT $LN2@decoding_f@2

; 643  :                 error_ret(tok);

  00069	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tok$[rsp]
  0006e	e8 00 00 00 00	 call	 error_ret

; 644  :                 return 1;

  00073	b8 01 00 00 00	 mov	 eax, 1
  00078	eb 38		 jmp	 SHORT $LN6@decoding_f@2

; 645  :             } else {

  0007a	eb 11		 jmp	 SHORT $LN1@decoding_f@2
$LN2@decoding_f@2:

; 646  :                 tok->decoding_buffer = buf;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$20897[rsp]
  00086	48 89 88 c0 03
	00 00		 mov	 QWORD PTR [rax+960], rcx
$LN1@decoding_f@2:
$LN3@decoding_f@2:

; 647  :             }
; 648  :         }
; 649  :         return PyObject_Length(buf) == 0;

  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$20897[rsp]
  00092	e8 00 00 00 00	 call	 PyObject_Size
  00097	48 85 c0	 test	 rax, rax
  0009a	75 0a		 jne	 SHORT $LN8@decoding_f@2
  0009c	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN9@decoding_f@2
$LN8@decoding_f@2:
  000a6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN9@decoding_f@2:
  000ae	8b 44 24 28	 mov	 eax, DWORD PTR tv81[rsp]
$LN4@decoding_f@2:
$LN6@decoding_f@2:

; 650  :     }
; 651  : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
decoding_feof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_backup DD imagerel tok_backup
	DD	imagerel tok_backup+117
	DD	imagerel $unwind$tok_backup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_backup DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@
CONST	SEGMENT
??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@ DB 'tok_backu'
	DB	'p: beginning of buffer', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tok_backup
_TEXT	SEGMENT
tv67 = 32
tok$ = 64
c$ = 72
tok_backup PROC						; COMDAT

; 1094 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1095 :     if (c != EOF) {

  0000d	83 7c 24 48 ff	 cmp	 DWORD PTR c$[rsp], -1
  00012	74 5c		 je	 SHORT $LN3@tok_backup

; 1096 :         if (--tok->cur < tok->buf)

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00019	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001d	48 ff c8	 dec	 rax
  00020	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  0002f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	48 39 44 24 20	 cmp	 QWORD PTR tv67[rsp], rax
  00040	73 0c		 jae	 SHORT $LN2@tok_backup

; 1097 :             Py_FatalError("tok_backup: beginning of buffer");

  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@
  00049	e8 00 00 00 00	 call	 Py_FatalError
$LN2@tok_backup:

; 1098 :         if (*tok->cur != c)

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00053	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00057	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0005a	3b 44 24 48	 cmp	 eax, DWORD PTR c$[rsp]
  0005e	74 10		 je	 SHORT $LN1@tok_backup

; 1099 :             *tok->cur = c;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00065	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00069	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR c$[rsp]
  0006e	88 08		 mov	 BYTE PTR [rax], cl
$LN1@tok_backup:
$LN3@tok_backup:

; 1100 :     }
; 1101 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
tok_backup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@ ; `string'
EXTRN	PySys_FormatStderr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$indenterror DD imagerel indenterror
	DD	imagerel indenterror+120
	DD	imagerel $unwind$indenterror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$indenterror DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@
CONST	SEGMENT
??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@ DB '%U: inc'
	DB	'onsistent use of tabs and spaces in indentation', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT indenterror
_TEXT	SEGMENT
tok$ = 48
indenterror PROC					; COMDAT

; 1272 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1273 :     if (tok->alterror) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	83 b8 fc 01 00
	00 00		 cmp	 DWORD PTR [rax+508], 0
  00015	74 25		 je	 SHORT $LN2@indenterro

; 1274 :         tok->done = E_TABSPACE;

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0001c	c7 40 28 12 00
	00 00		 mov	 DWORD PTR [rax+40], 18

; 1275 :         tok->cur = tok->inp;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  0002d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00031	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1276 :         return 1;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	eb 37		 jmp	 SHORT $LN3@indenterro
$LN2@indenterro:

; 1277 :     }
; 1278 :     if (tok->altwarning) {

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  00041	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00048	74 27		 je	 SHORT $LN1@indenterro

; 1279 : #ifdef PGEN
; 1280 :         PySys_WriteStderr("inconsistent use of tabs and spaces "
; 1281 :                           "in indentation\n");
; 1282 : #else
; 1283 :         PySys_FormatStderr("%U: inconsistent use of tabs and spaces "
; 1284 :                           "in indentation\n", tok->filename);

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  0004f	48 8b 90 f0 01
	00 00		 mov	 rdx, QWORD PTR [rax+496]
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@
  0005d	e8 00 00 00 00	 call	 PySys_FormatStderr

; 1285 : #endif
; 1286 :         tok->altwarning = 0;

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  00067	c7 80 f8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+504], 0
$LN1@indenterro:

; 1287 :     }
; 1288 :     return 0;

  00071	33 c0		 xor	 eax, eax
$LN3@indenterro:

; 1289 : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
indenterror ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@MKPCHAGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_IsIdentifier:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeDecodeError:QWORD
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$verify_identifier DD imagerel verify_identifier
	DD	imagerel verify_identifier+267
	DD	imagerel $unwind$verify_identifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$verify_identifier DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CG@MKPCHAGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@MKPCHAGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT verify_identifier
_TEXT	SEGMENT
s$ = 32
result$ = 40
tv87 = 44
tok$ = 64
verify_identifier PROC					; COMDAT

; 1299 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1300 :     PyObject *s;
; 1301 :     int result;
; 1302 :     s = PyUnicode_DecodeUTF8(tok->start, tok->cur - tok->start, NULL);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tok$[rsp]
  00013	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00017	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	48 8b d0	 mov	 rdx, rax
  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  00029	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0002d	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00032	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 1303 :     if (s == NULL || PyUnicode_READY(s) == -1) {

  00037	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0003d	74 65		 je	 SHORT $LN4@verify_ide
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00044	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00048	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004e	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00053	85 c0		 test	 eax, eax
  00055	75 1c		 jne	 SHORT $LN8@verify_ide
  00057	41 b8 17 05 00
	00		 mov	 r8d, 1303		; 00000517H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@KAFCIJDO@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAt?$AAo?$AAk?$AAe?$AAn?$AAi?$AAz?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@MKPCHAGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN8@verify_ide:
  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00078	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007b	c1 e8 07	 shr	 eax, 7
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	74 0a		 je	 SHORT $LN9@verify_ide
  00085	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  0008d	eb 0e		 jmp	 SHORT $LN10@verify_ide
$LN9@verify_ide:
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00099	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN10@verify_ide:
  0009d	83 7c 24 2c ff	 cmp	 DWORD PTR tv87[rsp], -1
  000a2	75 33		 jne	 SHORT $LN5@verify_ide
$LN4@verify_ide:

; 1304 :         if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {

  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeDecodeError
  000ab	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000b0	85 c0		 test	 eax, eax
  000b2	74 13		 je	 SHORT $LN3@verify_ide

; 1305 :             PyErr_Clear();

  000b4	e8 00 00 00 00	 call	 PyErr_Clear

; 1306 :             tok->done = E_IDENTIFIER;

  000b9	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000be	c7 40 28 1a 00
	00 00		 mov	 DWORD PTR [rax+40], 26

; 1307 :         } else {

  000c5	eb 0c		 jmp	 SHORT $LN2@verify_ide
$LN3@verify_ide:

; 1308 :             tok->done = E_ERROR;

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000cc	c7 40 28 11 00
	00 00		 mov	 DWORD PTR [rax+40], 17
$LN2@verify_ide:

; 1309 :         }
; 1310 :         return 0;

  000d3	33 c0		 xor	 eax, eax
  000d5	eb 2f		 jmp	 SHORT $LN6@verify_ide
$LN5@verify_ide:

; 1311 :     }
; 1312 :     result = PyUnicode_IsIdentifier(s);

  000d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	e8 00 00 00 00	 call	 PyUnicode_IsIdentifier
  000e1	89 44 24 28	 mov	 DWORD PTR result$[rsp], eax

; 1313 :     Py_DECREF(s);

  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ea	e8 00 00 00 00	 call	 _Py_DecRef

; 1314 :     if (result == 0)

  000ef	83 7c 24 28 00	 cmp	 DWORD PTR result$[rsp], 0
  000f4	75 0c		 jne	 SHORT $LN1@verify_ide

; 1315 :         tok->done = E_IDENTIFIER;

  000f6	48 8b 44 24 40	 mov	 rax, QWORD PTR tok$[rsp]
  000fb	c7 40 28 1a 00
	00 00		 mov	 DWORD PTR [rax+40], 26
$LN1@verify_ide:

; 1316 :     return result;

  00102	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
$LN6@verify_ide:

; 1317 : }

  00106	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010a	c3		 ret	 0
verify_identifier ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@		; `string'
PUBLIC	PyTokenizer_FindEncodingFilename
EXTRN	PyUnicode_FromString:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fdopen:PROC
EXTRN	__imp_dup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FindEncodingFilename DD imagerel $LN15
	DD	imagerel $LN15+471
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FindEncodingFilename DD 010d01H
	DD	0a20dH
xdata	ENDS
;	COMDAT ??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
CONST	SEGMENT
??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@ DB '<string>', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyTokenizer_FindEncodingFilename
_TEXT	SEGMENT
tok$ = 32
fp$ = 40
p_end$ = 48
encoding$ = 56
p_start$ = 64
tv144 = 72
fd$ = 96
filename$ = 104
PyTokenizer_FindEncodingFilename PROC			; COMDAT

; 1747 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1748 :     struct tok_state *tok;
; 1749 :     FILE *fp;
; 1750 :     char *p_start =NULL , *p_end =NULL , *encoding = NULL;

  0000d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR p_start$[rsp], 0
  00016	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p_end$[rsp], 0
  0001f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR encoding$[rsp], 0

; 1751 : 
; 1752 :     fd = dup(fd);

  00028	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  00032	89 44 24 60	 mov	 DWORD PTR fd$[rsp], eax

; 1753 :     if (fd < 0) {

  00036	83 7c 24 60 00	 cmp	 DWORD PTR fd$[rsp], 0
  0003b	7d 07		 jge	 SHORT $LN10@PyTokenize@6

; 1754 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 8e 01 00 00	 jmp	 $LN11@PyTokenize@6
$LN10@PyTokenize@6:

; 1755 :     }
; 1756 :     fp = fdopen(fd, "r");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0004b	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fdopen
  00055	48 89 44 24 28	 mov	 QWORD PTR fp$[rsp], rax

; 1757 :     if (fp == NULL) {

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00060	75 07		 jne	 SHORT $LN9@PyTokenize@6

; 1758 :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 69 01 00 00	 jmp	 $LN11@PyTokenize@6
$LN9@PyTokenize@6:

; 1759 :     }
; 1760 :     tok = PyTokenizer_FromFile(fp, NULL, NULL, NULL);

  00069	45 33 c9	 xor	 r9d, r9d
  0006c	45 33 c0	 xor	 r8d, r8d
  0006f	33 d2		 xor	 edx, edx
  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$[rsp]
  00076	e8 00 00 00 00	 call	 PyTokenizer_FromFile
  0007b	48 89 44 24 20	 mov	 QWORD PTR tok$[rsp], rax

; 1761 :     if (tok == NULL) {

  00080	48 83 7c 24 20
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00086	75 12		 jne	 SHORT $LN8@PyTokenize@6

; 1762 :         fclose(fp);

  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1763 :         return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 38 01 00 00	 jmp	 $LN11@PyTokenize@6
$LN8@PyTokenize@6:

; 1764 :     }
; 1765 : #ifndef PGEN
; 1766 :     if (filename != NULL) {

  0009a	48 83 7c 24 68
	00		 cmp	 QWORD PTR filename$[rsp], 0
  000a0	74 1d		 je	 SHORT $LN7@PyTokenize@6

; 1767 :         Py_INCREF(filename);

  000a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filename$[rsp]
  000a7	e8 00 00 00 00	 call	 _Py_IncRef

; 1768 :         tok->filename = filename;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000b1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filename$[rsp]
  000b6	48 89 88 f0 01
	00 00		 mov	 QWORD PTR [rax+496], rcx

; 1769 :     }
; 1770 :     else {

  000bd	eb 46		 jmp	 SHORT $LN6@PyTokenize@6
$LN7@PyTokenize@6:

; 1771 :         tok->filename = PyUnicode_FromString("<string>");

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
  000c6	e8 00 00 00 00	 call	 PyUnicode_FromString
  000cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  000d0	48 89 81 f0 01
	00 00		 mov	 QWORD PTR [rcx+496], rax

; 1772 :         if (tok->filename == NULL) {

  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  000dc	48 83 b8 f0 01
	00 00 00	 cmp	 QWORD PTR [rax+496], 0
  000e4	75 1f		 jne	 SHORT $LN5@PyTokenize@6

; 1773 :             fclose(fp);

  000e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$[rsp]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1774 :             PyTokenizer_Free(tok);

  000f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  000f6	e8 00 00 00 00	 call	 PyTokenizer_Free

; 1775 :             return encoding;

  000fb	48 8b 44 24 38	 mov	 rax, QWORD PTR encoding$[rsp]
  00100	e9 cd 00 00 00	 jmp	 $LN11@PyTokenize@6
$LN5@PyTokenize@6:
$LN6@PyTokenize@6:
$LN4@PyTokenize@6:

; 1776 :         }
; 1777 :     }
; 1778 : #endif
; 1779 :     while (tok->lineno < 2 && tok->done == E_OK) {

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0010a	83 b8 e8 01 00
	00 02		 cmp	 DWORD PTR [rax+488], 2
  00111	7d 21		 jge	 SHORT $LN3@PyTokenize@6
  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00118	83 78 28 0a	 cmp	 DWORD PTR [rax+40], 10
  0011c	75 16		 jne	 SHORT $LN3@PyTokenize@6

; 1780 :         PyTokenizer_Get(tok, &p_start, &p_end);

  0011e	4c 8d 44 24 30	 lea	 r8, QWORD PTR p_end$[rsp]
  00123	48 8d 54 24 40	 lea	 rdx, QWORD PTR p_start$[rsp]
  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  0012d	e8 00 00 00 00	 call	 PyTokenizer_Get

; 1781 :     }

  00132	eb d1		 jmp	 SHORT $LN4@PyTokenize@6
$LN3@PyTokenize@6:

; 1782 :     fclose(fp);

  00134	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fp$[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1783 :     if (tok->encoding) {

  0013f	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  00144	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  0014c	74 75		 je	 SHORT $LN2@PyTokenize@6

; 1784 :         encoding = (char *)PyMem_MALLOC(strlen(tok->encoding) + 1);

  0014e	e8 00 00 00 00	 call	 _Py_PXCTX
  00153	85 c0		 test	 eax, eax
  00155	74 23		 je	 SHORT $LN13@PyTokenize@6
  00157	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0015c	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00163	e8 00 00 00 00	 call	 strlen
  00168	48 ff c0	 inc	 rax
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 _PxMem_Malloc
  00173	48 89 44 24 48	 mov	 QWORD PTR tv144[rsp], rax
  00178	eb 21		 jmp	 SHORT $LN14@PyTokenize@6
$LN13@PyTokenize@6:
  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  0017f	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00186	e8 00 00 00 00	 call	 strlen
  0018b	48 ff c0	 inc	 rax
  0018e	48 8b c8	 mov	 rcx, rax
  00191	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00196	48 89 44 24 48	 mov	 QWORD PTR tv144[rsp], rax
$LN14@PyTokenize@6:
  0019b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv144[rsp]
  001a0	48 89 44 24 38	 mov	 QWORD PTR encoding$[rsp], rax

; 1785 :         if (encoding)

  001a5	48 83 7c 24 38
	00		 cmp	 QWORD PTR encoding$[rsp], 0
  001ab	74 16		 je	 SHORT $LN1@PyTokenize@6

; 1786 :         strcpy(encoding, tok->encoding);

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR tok$[rsp]
  001b2	48 8b 90 a0 03
	00 00		 mov	 rdx, QWORD PTR [rax+928]
  001b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR encoding$[rsp]
  001be	e8 00 00 00 00	 call	 strcpy
$LN1@PyTokenize@6:
$LN2@PyTokenize@6:

; 1787 :     }
; 1788 :     PyTokenizer_Free(tok);

  001c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tok$[rsp]
  001c8	e8 00 00 00 00	 call	 PyTokenizer_Free

; 1789 :     return encoding;

  001cd	48 8b 44 24 38	 mov	 rax, QWORD PTR encoding$[rsp]
$LN11@PyTokenize@6:

; 1790 : }

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
PyTokenizer_FindEncodingFilename ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FindEncoding
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FindEncoding DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PyTokenizer_FindEncoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FindEncoding DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyTokenizer_FindEncoding
_TEXT	SEGMENT
fd$ = 48
PyTokenizer_FindEncoding PROC				; COMDAT

; 1794 : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1795 :     return PyTokenizer_FindEncodingFilename(fd, NULL);

  00008	33 d2		 xor	 edx, edx
  0000a	8b 4c 24 30	 mov	 ecx, DWORD PTR fd$[rsp]
  0000e	e8 00 00 00 00	 call	 PyTokenizer_FindEncodingFilename

; 1796 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyTokenizer_FindEncoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_06GKCPFECC@?$CI?$CF?4?$CKs?$CJ?$AA@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	_Py_tok_dump
EXTRN	__imp_printf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_tok_dump DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$_Py_tok_dump
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_tok_dump DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT ??_C@_06GKCPFECC@?$CI?$CF?4?$CKs?$CJ?$AA@
CONST	SEGMENT
??_C@_06GKCPFECC@?$CI?$CF?4?$CKs?$CJ?$AA@ DB '(%.*s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_tok_dump
_TEXT	SEGMENT
type$ = 48
start$ = 56
end$ = 64
_Py_tok_dump PROC					; COMDAT

; 1802 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1803 :     printf("%s", _PyParser_TokenNames[type]);

  00012	48 63 44 24 30	 movsxd	 rax, DWORD PTR type$[rsp]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  0001e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1804 :     if (type == NAME || type == NUMBER || type == STRING || type == OP)

  0002f	83 7c 24 30 01	 cmp	 DWORD PTR type$[rsp], 1
  00034	74 15		 je	 SHORT $LN1@Py_tok_dum
  00036	83 7c 24 30 02	 cmp	 DWORD PTR type$[rsp], 2
  0003b	74 0e		 je	 SHORT $LN1@Py_tok_dum
  0003d	83 7c 24 30 03	 cmp	 DWORD PTR type$[rsp], 3
  00042	74 07		 je	 SHORT $LN1@Py_tok_dum
  00044	83 7c 24 30 34	 cmp	 DWORD PTR type$[rsp], 52 ; 00000034H
  00049	75 24		 jne	 SHORT $LN2@Py_tok_dum
$LN1@Py_tok_dum:

; 1805 :         printf("(%.*s)", (int)(end - start), start);

  0004b	48 8b 44 24 38	 mov	 rax, QWORD PTR start$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  00055	48 2b c8	 sub	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	4c 8b 44 24 38	 mov	 r8, QWORD PTR start$[rsp]
  00060	8b d0		 mov	 edx, eax
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GKCPFECC@?$CI?$CF?4?$CKs?$CJ?$AA@
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN2@Py_tok_dum:

; 1806 : }

  0006f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00073	c3		 ret	 0
_Py_tok_dump ENDP
_TEXT	ENDS
END
