; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@	; `string'
PUBLIC	??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@	; `string'
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	??_C@_09LJKDIEEK@__bases__?$AA@			; `string'
PUBLIC	??_C@_06GEKOPAHD@values?$AA@			; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04IEPFDAGF@keys?$AA@			; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
;	COMDAT ??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
CONST	SEGMENT
??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@ DB '__subclasscheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
CONST	SEGMENT
??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@ DB '__instancecheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJKDIEEK@__bases__?$AA@
CONST	SEGMENT
??_C@_09LJKDIEEK@__bases__?$AA@ DB '__bases__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GEKOPAHD@values?$AA@
CONST	SEGMENT
??_C@_06GEKOPAHD@values?$AA@ DB 'values', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEPFDAGF@keys?$AA@
CONST	SEGMENT
??_C@_04IEPFDAGF@keys?$AA@ DB 'keys', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___class__@?1??recursive_isinstance@@9@9 DQ 0000000000000000H ; `recursive_isinstance'::`2'::PyId___class__
	DQ	FLAT:??_C@_09LFGACEKG@__class__?$AA@
	DQ	0000000000000000H
?PyId___subclasscheck__@?1??PyObject_IsSubclass@@9@9 DQ 0000000000000000H ; `PyObject_IsSubclass'::`2'::PyId___subclasscheck__
	DQ	FLAT:??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
	DQ	0000000000000000H
?PyId___instancecheck__@?1??PyObject_IsInstance@@9@9 DQ 0000000000000000H ; `PyObject_IsInstance'::`2'::PyId___instancecheck__
	DQ	FLAT:??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
	DQ	0000000000000000H
?PyId___bases__@?1??abstract_get_bases@@9@9 DQ 0000000000000000H ; `abstract_get_bases'::`2'::PyId___bases__
	DQ	FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
	DQ	0000000000000000H
?PyId_values@?1??PyMapping_Values@@9@9 DQ 0000000000000000H ; `PyMapping_Values'::`2'::PyId_values
	DQ	FLAT:??_C@_06GEKOPAHD@values?$AA@
	DQ	0000000000000000H
?PyId_items@?1??PyMapping_Items@@9@9 DQ 0000000000000000H ; `PyMapping_Items'::`2'::PyId_items
	DQ	FLAT:??_C@_05CFHBDDLG@items?$AA@
	DQ	0000000000000000H
?PyId_keys@?1??PyMapping_Keys@@9@9 DQ 0000000000000000H	; `PyMapping_Keys'::`2'::PyId_keys
	DQ	FLAT:??_C@_04IEPFDAGF@keys?$AA@
	DQ	0000000000000000H
?PyId___trunc__@?1??PyNumber_Long@@9@9 DQ 0000000000000000H ; `PyNumber_Long'::`2'::PyId___trunc__
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	0000000000000000H
?PyId___format__@?1??PyObject_Format@@9@9 DQ 0000000000000000H ; `PyObject_Format'::`2'::PyId___format__
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	0000000000000000H
?PyId___length_hint__@?1??_PyObject_LengthHint@@9@9 DQ 0000000000000000H ; `_PyObject_LengthHint'::`2'::PyId___length_hint__
	DQ	FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\abstract.c
pdata	SEGMENT
$pdata$type_error DD imagerel type_error
	DD	imagerel type_error+34
	DD	imagerel $unwind$type_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_error DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT type_error
_TEXT	SEGMENT
msg$ = 48
obj$ = 56
type_error PROC						; COMDAT

; 14   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 15   :     PyErr_Format(PyExc_TypeError, msg, obj->ob_type->tp_name);

  00004	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00008	48 8b d1	 mov	 rdx, rcx
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00012	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00016	e8 00 00 00 00	 call	 PyErr_Format

; 16   :     return NULL;

  0001b	33 c0		 xor	 eax, eax

; 17   : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
type_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$null_error DD imagerel null_error
	DD	imagerel null_error+40
	DD	imagerel $unwind$null_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$null_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@
CONST	SEGMENT
??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@ DB 'null argumen'
	DB	't to internal routine', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT null_error
_TEXT	SEGMENT
null_error PROC						; COMDAT

; 21   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 22   :     if (!PyErr_Occurred())

  00004	e8 00 00 00 00	 call	 PyErr_Occurred
  00009	48 85 c0	 test	 rax, rax
  0000c	75 13		 jne	 SHORT $LN4@null_error

; 23   :         PyErr_SetString(PyExc_SystemError,
; 24   :                         "null argument to internal routine");

  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@
  0001c	e8 00 00 00 00	 call	 PyErr_SetString
$LN4@null_error:

; 25   :     return NULL;

  00021	33 c0		 xor	 eax, eax

; 26   : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
null_error ENDP
_TEXT	ENDS
PUBLIC	PyObject_Type
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyObject_Type DD imagerel $LN8
	DD	imagerel $LN8+99
	DD	imagerel $unwind$PyObject_Type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Type DD 031701H
	DD	063417H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT PyObject_Type
_TEXT	SEGMENT
o$ = 64
PyObject_Type PROC					; COMDAT

; 32   : {

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 33   :     PyObject *v;
; 34   : 
; 35   :     if (o == NULL)

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 09		 jne	 SHORT $LN1@PyObject_T

; 40   : }

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	e9 00 00 00 00	 jmp	 null_error
$LN1@PyObject_T:
  00012	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 36   :         return null_error();
; 37   :     v = (PyObject *)o->ob_type;

  00017	48 8b 59 58	 mov	 rbx, QWORD PTR [rcx+88]

; 38   :     Py_INCREF(v);

  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	75 32		 jne	 SHORT $LN5@PyObject_T
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00032	4c 8b cb	 mov	 r9, rbx
  00035	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00043	e8 00 00 00 00	 call	 _PyParallel_Guard
  00048	85 c0		 test	 eax, eax
  0004a	75 06		 jne	 SHORT $LN4@PyObject_T
  0004c	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00050	74 04		 je	 SHORT $LN5@PyObject_T
$LN4@PyObject_T:
  00052	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@PyObject_T:

; 39   :     return v;

  00056	48 8b c3	 mov	 rax, rbx
  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 40   : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
PyObject_Type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@ ; `string'
PUBLIC	PyObject_AsCharBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsCharBuffer DD imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsCharBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_AsCharBuffer DD imagerel $LN15+56
	DD	imagerel $LN15+172
	DD	imagerel $chain$0$PyObject_AsCharBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_AsCharBuffer DD imagerel $LN15+172
	DD	imagerel $LN15+196
	DD	imagerel $chain$2$PyObject_AsCharBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_AsCharBuffer DD imagerel $LN15+196
	DD	imagerel $LN15+222
	DD	imagerel $chain$3$PyObject_AsCharBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_AsCharBuffer DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsCharBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_AsCharBuffer DD 020021H
	DD	0107400H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsCharBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_AsCharBuffer DD 020421H
	DD	0107404H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsCharBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsCharBuffer DD 061001H
	DD	0125410H
	DD	0113410H
	DD	0600cd210H
xdata	ENDS
;	COMDAT ??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@
CONST	SEGMENT
??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@ DB 'expected by'
	DB	'tes, bytearray or buffer compatible object', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_AsCharBuffer
_TEXT	SEGMENT
view$ = 32
obj$ = 128
buffer$ = 136
buffer_len$ = 144
PyObject_AsCharBuffer PROC				; COMDAT

; 241  : {

$LN15:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	56		 push	 rsi
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00010	49 8b f0	 mov	 rsi, r8
  00013	48 8b ea	 mov	 rbp, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 242  :     PyBufferProcs *pb;
; 243  :     Py_buffer view;
; 244  : 
; 245  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	0f 84 a2 00 00
	00		 je	 $LN9@PyObject_A
  00022	48 85 d2	 test	 rdx, rdx
  00025	0f 84 99 00 00
	00		 je	 $LN9@PyObject_A
  0002b	4d 85 c0	 test	 r8, r8
  0002e	0f 84 90 00 00
	00		 je	 $LN9@PyObject_A

; 247  :         return -1;
; 248  :     }
; 249  : 
; 250  :     pb = obj->ob_type->tp_as_buffer;

  00034	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00038	49 89 7b 08	 mov	 QWORD PTR [r11+8], rdi
  0003c	48 8b b8 f8 00
	00 00		 mov	 rdi, QWORD PTR [rax+248]

; 251  :     if (pb == NULL || pb->bf_getbuffer == NULL) {

  00043	48 85 ff	 test	 rdi, rdi
  00046	74 64		 je	 SHORT $LN7@PyObject_A
  00048	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 5c		 je	 SHORT $LN7@PyObject_A

; 256  :     }
; 257  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE)) return -1;

  00050	49 8d 53 a8	 lea	 rdx, QWORD PTR [r11-88]
  00054	45 33 c0	 xor	 r8d, r8d
  00057	ff d0		 call	 rax
  00059	85 c0		 test	 eax, eax
  0005b	75 62		 jne	 SHORT $LN14@PyObject_A

; 258  : 
; 259  :     *buffer = view.buf;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00062	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 260  :     *buffer_len = view.len;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp+16]
  0006b	48 89 06	 mov	 QWORD PTR [rsi], rax

; 261  :     if (pb->bf_releasebuffer != NULL)

  0006e	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00072	48 85 c0	 test	 rax, rax
  00075	74 0a		 je	 SHORT $LN4@PyObject_A

; 262  :         (*pb->bf_releasebuffer)(obj, &view);

  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	ff d0		 call	 rax
$LN4@PyObject_A:

; 263  :     Py_XDECREF(view.obj);

  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  00086	48 85 c9	 test	 rcx, rcx
  00089	74 05		 je	 SHORT $LN3@PyObject_A
  0008b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_A:

; 264  :     return 0;

  00090	33 c0		 xor	 eax, eax
$LN13@PyObject_A:
  00092	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 265  : }

  0009a	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  0009f	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000a3	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000a7	49 8b e3	 mov	 rsp, r11
  000aa	5e		 pop	 rsi
  000ab	c3		 ret	 0
$LN7@PyObject_A:

; 252  :         PyErr_SetString(PyExc_TypeError,
; 253  :                         "expected bytes, bytearray "
; 254  :                         "or buffer compatible object");

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@
  000ba	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@PyObject_A:

; 255  :         return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	eb ce		 jmp	 SHORT $LN13@PyObject_A
$LN9@PyObject_A:

; 246  :         null_error();

  000c4	e8 00 00 00 00	 call	 null_error

; 265  : }

  000c9	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000ce	83 c8 ff	 or	 eax, -1
  000d1	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000d5	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000d9	49 8b e3	 mov	 rsp, r11
  000dc	5e		 pop	 rsi
  000dd	c3		 ret	 0
PyObject_AsCharBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@ ; `string'
PUBLIC	PyObject_AsReadBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsReadBuffer DD imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsReadBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_AsReadBuffer DD imagerel $LN15+56
	DD	imagerel $LN15+172
	DD	imagerel $chain$0$PyObject_AsReadBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_AsReadBuffer DD imagerel $LN15+172
	DD	imagerel $LN15+196
	DD	imagerel $chain$2$PyObject_AsReadBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_AsReadBuffer DD imagerel $LN15+196
	DD	imagerel $LN15+222
	DD	imagerel $chain$3$PyObject_AsReadBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_AsReadBuffer DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsReadBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_AsReadBuffer DD 020021H
	DD	0107400H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsReadBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_AsReadBuffer DD 020421H
	DD	0107404H
	DD	imagerel $LN15
	DD	imagerel $LN15+56
	DD	imagerel $unwind$PyObject_AsReadBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsReadBuffer DD 061001H
	DD	0125410H
	DD	0113410H
	DD	0600cd210H
xdata	ENDS
;	COMDAT ??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@
CONST	SEGMENT
??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@ DB 'expected an'
	DB	' object with a buffer interface', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_AsReadBuffer
_TEXT	SEGMENT
view$ = 32
obj$ = 128
buffer$ = 136
buffer_len$ = 144
PyObject_AsReadBuffer PROC				; COMDAT

; 288  : {

$LN15:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	56		 push	 rsi
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00010	49 8b f0	 mov	 rsi, r8
  00013	48 8b ea	 mov	 rbp, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 289  :     PyBufferProcs *pb;
; 290  :     Py_buffer view;
; 291  : 
; 292  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	0f 84 a2 00 00
	00		 je	 $LN9@PyObject_A@2
  00022	48 85 d2	 test	 rdx, rdx
  00025	0f 84 99 00 00
	00		 je	 $LN9@PyObject_A@2
  0002b	4d 85 c0	 test	 r8, r8
  0002e	0f 84 90 00 00
	00		 je	 $LN9@PyObject_A@2

; 294  :         return -1;
; 295  :     }
; 296  : 
; 297  :     pb = obj->ob_type->tp_as_buffer;

  00034	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00038	49 89 7b 08	 mov	 QWORD PTR [r11+8], rdi
  0003c	48 8b b8 f8 00
	00 00		 mov	 rdi, QWORD PTR [rax+248]

; 298  :     if (pb == NULL ||
; 299  :         pb->bf_getbuffer == NULL) {

  00043	48 85 ff	 test	 rdi, rdi
  00046	74 64		 je	 SHORT $LN7@PyObject_A@2
  00048	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 5c		 je	 SHORT $LN7@PyObject_A@2

; 303  :     }
; 304  : 
; 305  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE)) return -1;

  00050	49 8d 53 a8	 lea	 rdx, QWORD PTR [r11-88]
  00054	45 33 c0	 xor	 r8d, r8d
  00057	ff d0		 call	 rax
  00059	85 c0		 test	 eax, eax
  0005b	75 62		 jne	 SHORT $LN14@PyObject_A@2

; 306  : 
; 307  :     *buffer = view.buf;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00062	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 308  :     *buffer_len = view.len;

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp+16]
  0006b	48 89 06	 mov	 QWORD PTR [rsi], rax

; 309  :     if (pb->bf_releasebuffer != NULL)

  0006e	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00072	48 85 c0	 test	 rax, rax
  00075	74 0a		 je	 SHORT $LN4@PyObject_A@2

; 310  :         (*pb->bf_releasebuffer)(obj, &view);

  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	ff d0		 call	 rax
$LN4@PyObject_A@2:

; 311  :     Py_XDECREF(view.obj);

  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  00086	48 85 c9	 test	 rcx, rcx
  00089	74 05		 je	 SHORT $LN3@PyObject_A@2
  0008b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_A@2:

; 312  :     return 0;

  00090	33 c0		 xor	 eax, eax
$LN13@PyObject_A@2:
  00092	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 313  : }

  0009a	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  0009f	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000a3	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000a7	49 8b e3	 mov	 rsp, r11
  000aa	5e		 pop	 rsi
  000ab	c3		 ret	 0
$LN7@PyObject_A@2:

; 300  :         PyErr_SetString(PyExc_TypeError,
; 301  :                         "expected an object with a buffer interface");

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@
  000ba	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@PyObject_A@2:

; 302  :         return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	eb ce		 jmp	 SHORT $LN13@PyObject_A@2
$LN9@PyObject_A@2:

; 293  :         null_error();

  000c4	e8 00 00 00 00	 call	 null_error

; 313  : }

  000c9	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000ce	83 c8 ff	 or	 eax, -1
  000d1	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000d5	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000d9	49 8b e3	 mov	 rsp, r11
  000dc	5e		 pop	 rsi
  000dd	c3		 ret	 0
PyObject_AsReadBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@ ; `string'
PUBLIC	PyObject_AsWriteBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsWriteBuffer DD imagerel $LN13
	DD	imagerel $LN13+56
	DD	imagerel $unwind$PyObject_AsWriteBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_AsWriteBuffer DD imagerel $LN13+56
	DD	imagerel $LN13+175
	DD	imagerel $chain$0$PyObject_AsWriteBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_AsWriteBuffer DD imagerel $LN13+175
	DD	imagerel $LN13+199
	DD	imagerel $chain$2$PyObject_AsWriteBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_AsWriteBuffer DD imagerel $LN13+199
	DD	imagerel $LN13+225
	DD	imagerel $chain$3$PyObject_AsWriteBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_AsWriteBuffer DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+56
	DD	imagerel $unwind$PyObject_AsWriteBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_AsWriteBuffer DD 020021H
	DD	0107400H
	DD	imagerel $LN13
	DD	imagerel $LN13+56
	DD	imagerel $unwind$PyObject_AsWriteBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_AsWriteBuffer DD 020421H
	DD	0107404H
	DD	imagerel $LN13
	DD	imagerel $LN13+56
	DD	imagerel $unwind$PyObject_AsWriteBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsWriteBuffer DD 061001H
	DD	0125410H
	DD	0113410H
	DD	0600cd210H
xdata	ENDS
;	COMDAT ??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@
CONST	SEGMENT
??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@ DB 'expected an'
	DB	' object with a writable buffer interface', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_AsWriteBuffer
_TEXT	SEGMENT
view$ = 32
obj$ = 128
buffer$ = 136
buffer_len$ = 144
PyObject_AsWriteBuffer PROC				; COMDAT

; 318  : {

$LN13:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 6b 18	 mov	 QWORD PTR [r11+24], rbp
  0000b	56		 push	 rsi
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00010	49 8b f0	 mov	 rsi, r8
  00013	48 8b ea	 mov	 rbp, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 319  :     PyBufferProcs *pb;
; 320  :     Py_buffer view;
; 321  : 
; 322  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	0f 84 a5 00 00
	00		 je	 $LN8@PyObject_A@3
  00022	48 85 d2	 test	 rdx, rdx
  00025	0f 84 9c 00 00
	00		 je	 $LN8@PyObject_A@3
  0002b	4d 85 c0	 test	 r8, r8
  0002e	0f 84 93 00 00
	00		 je	 $LN8@PyObject_A@3

; 324  :         return -1;
; 325  :     }
; 326  : 
; 327  :     pb = obj->ob_type->tp_as_buffer;

  00034	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00038	49 89 7b 08	 mov	 QWORD PTR [r11+8], rdi
  0003c	48 8b b8 f8 00
	00 00		 mov	 rdi, QWORD PTR [rax+248]

; 328  :     if (pb == NULL ||
; 329  :         pb->bf_getbuffer == NULL ||
; 330  :         ((*pb->bf_getbuffer)(obj, &view, PyBUF_WRITABLE) != 0)) {

  00043	48 85 ff	 test	 rdi, rdi
  00046	74 67		 je	 SHORT $LN6@PyObject_A@3
  00048	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 5f		 je	 SHORT $LN6@PyObject_A@3
  00050	49 8d 53 a8	 lea	 rdx, QWORD PTR [r11-88]
  00054	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005a	ff d0		 call	 rax
  0005c	85 c0		 test	 eax, eax
  0005e	75 4f		 jne	 SHORT $LN6@PyObject_A@3

; 334  :     }
; 335  : 
; 336  :     *buffer = view.buf;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00065	48 89 45 00	 mov	 QWORD PTR [rbp], rax

; 337  :     *buffer_len = view.len;

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp+16]
  0006e	48 89 06	 mov	 QWORD PTR [rsi], rax

; 338  :     if (pb->bf_releasebuffer != NULL)

  00071	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00075	48 85 c0	 test	 rax, rax
  00078	74 0a		 je	 SHORT $LN4@PyObject_A@3

; 339  :         (*pb->bf_releasebuffer)(obj, &view);

  0007a	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff d0		 call	 rax
$LN4@PyObject_A@3:

; 340  :     Py_XDECREF(view.obj);

  00084	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  00089	48 85 c9	 test	 rcx, rcx
  0008c	74 05		 je	 SHORT $LN3@PyObject_A@3
  0008e	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_A@3:

; 341  :     return 0;

  00093	33 c0		 xor	 eax, eax
$LN12@PyObject_A@3:
  00095	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 342  : }

  0009d	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000a2	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000a6	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000aa	49 8b e3	 mov	 rsp, r11
  000ad	5e		 pop	 rsi
  000ae	c3		 ret	 0
$LN6@PyObject_A@3:

; 331  :         PyErr_SetString(PyExc_TypeError,
; 332  :                         "expected an object with a writable buffer interface");

  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@
  000bd	e8 00 00 00 00	 call	 PyErr_SetString

; 333  :         return -1;

  000c2	83 c8 ff	 or	 eax, -1
  000c5	eb ce		 jmp	 SHORT $LN12@PyObject_A@3
$LN8@PyObject_A@3:

; 323  :         null_error();

  000c7	e8 00 00 00 00	 call	 null_error

; 342  : }

  000cc	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000d1	83 c8 ff	 or	 eax, -1
  000d4	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  000d8	49 8b 6b 20	 mov	 rbp, QWORD PTR [r11+32]
  000dc	49 8b e3	 mov	 rsp, r11
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
PyObject_AsWriteBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@ ; `string'
PUBLIC	PyObject_GetBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_GetBuffer DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$PyObject_GetBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetBuffer DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@
CONST	SEGMENT
??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@ DB '''%.1'
	DB	'00s'' does not support the buffer interface', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_GetBuffer
_TEXT	SEGMENT
obj$ = 48
view$ = 56
flags$ = 64
PyObject_GetBuffer PROC					; COMDAT

; 348  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b c8	 mov	 r9d, r8d

; 349  :     if (!PyObject_CheckBuffer(obj)) {

  00007	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000b	49 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [r8+248]
  00012	48 85 c0	 test	 rax, rax
  00015	74 10		 je	 SHORT $LN1@PyObject_G
  00017	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0001b	74 0a		 je	 SHORT $LN1@PyObject_G

; 354  :     }
; 355  :     return (*(obj->ob_type->tp_as_buffer->bf_getbuffer))(obj, view, flags);

  0001d	45 8b c1	 mov	 r8d, r9d

; 356  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	48 ff 20	 rex_jmp QWORD PTR [rax]
$LN1@PyObject_G:

; 350  :         PyErr_Format(PyExc_TypeError,
; 351  :                      "'%.100s' does not support the buffer interface",
; 352  :                      Py_TYPE(obj)->tp_name);

  00027	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@
  00039	e8 00 00 00 00	 call	 PyErr_Format

; 353  :         return -1;

  0003e	83 c8 ff	 or	 eax, -1

; 356  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
PyObject_GetBuffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _IsFortranContiguous
_TEXT	SEGMENT
view$ = 8
_IsFortranContiguous PROC				; COMDAT

; 361  :     Py_ssize_t sd, dim;
; 362  :     int i;
; 363  : 
; 364  :     if (view->ndim == 0) return 1;

  00000	44 8b 49 24	 mov	 r9d, DWORD PTR [rcx+36]
  00004	4c 8b c1	 mov	 r8, rcx
  00007	45 85 c9	 test	 r9d, r9d
  0000a	74 61		 je	 SHORT $LN3@IsFortranC

; 365  :     if (view->strides == NULL) return (view->ndim == 1);

  0000c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00010	48 85 c9	 test	 rcx, rcx
  00013	75 0a		 jne	 SHORT $LN7@IsFortranC
  00015	33 c0		 xor	 eax, eax
  00017	41 83 f9 01	 cmp	 r9d, 1
  0001b	0f 94 c0	 sete	 al

; 377  : }

  0001e	c3		 ret	 0
$LN7@IsFortranC:

; 366  : 
; 367  :     sd = view->itemsize;

  0001f	49 8b 50 18	 mov	 rdx, QWORD PTR [r8+24]

; 368  :     if (view->ndim == 1) return (view->shape[0] == 1 ||

  00023	41 83 f9 01	 cmp	 r9d, 1
  00027	75 12		 jne	 SHORT $LN6@IsFortranC

; 369  :                                sd == view->strides[0]);

  00029	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  0002d	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00031	74 3a		 je	 SHORT $LN3@IsFortranC
  00033	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00036	74 35		 je	 SHORT $LN3@IsFortranC
$LN15@IsFortranC:
  00038	33 c0		 xor	 eax, eax

; 377  : }

  0003a	c3		 ret	 0
$LN6@IsFortranC:

; 370  :     for (i=0; i<view->ndim; i++) {

  0003b	33 c0		 xor	 eax, eax
  0003d	45 85 c9	 test	 r9d, r9d
  00040	7e 2b		 jle	 SHORT $LN3@IsFortranC
  00042	4d 8b 50 30	 mov	 r10, QWORD PTR [r8+48]
  00046	4c 2b d1	 sub	 r10, rcx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@IsFortranC:

; 371  :         dim = view->shape[i];

  00050	4d 8b 04 0a	 mov	 r8, QWORD PTR [r10+rcx]

; 372  :         if (dim == 0) return 1;

  00054	4d 85 c0	 test	 r8, r8
  00057	74 14		 je	 SHORT $LN3@IsFortranC

; 373  :         if (view->strides[i] != sd) return 0;

  00059	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  0005c	75 da		 jne	 SHORT $LN15@IsFortranC

; 374  :         sd *= dim;

  0005e	ff c0		 inc	 eax
  00060	49 0f af d0	 imul	 rdx, r8
  00064	48 83 c1 08	 add	 rcx, 8
  00068	41 3b c1	 cmp	 eax, r9d
  0006b	7c e3		 jl	 SHORT $LL5@IsFortranC
$LN3@IsFortranC:

; 375  :     }
; 376  :     return 1;

  0006d	b8 01 00 00 00	 mov	 eax, 1

; 377  : }

  00072	c3		 ret	 0
_IsFortranContiguous ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _IsCContiguous
_TEXT	SEGMENT
view$ = 8
_IsCContiguous PROC					; COMDAT

; 382  :     Py_ssize_t sd, dim;
; 383  :     int i;
; 384  : 
; 385  :     if (view->ndim == 0) return 1;

  00000	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  00003	4c 8b c1	 mov	 r8, rcx
  00006	85 c0		 test	 eax, eax
  00008	74 51		 je	 SHORT $LN3@IsCContigu

; 386  :     if (view->strides == NULL) return 1;

  0000a	4c 8b 49 38	 mov	 r9, QWORD PTR [rcx+56]
  0000e	4d 85 c9	 test	 r9, r9
  00011	74 48		 je	 SHORT $LN3@IsCContigu

; 387  : 
; 388  :     sd = view->itemsize;

  00013	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]

; 389  :     if (view->ndim == 1) return (view->shape[0] == 1 ||

  00017	83 f8 01	 cmp	 eax, 1
  0001a	75 12		 jne	 SHORT $LN6@IsCContigu

; 390  :                                sd == view->strides[0]);

  0001c	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  00020	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00024	74 35		 je	 SHORT $LN3@IsCContigu
  00026	49 3b 09	 cmp	 rcx, QWORD PTR [r9]
  00029	74 30		 je	 SHORT $LN3@IsCContigu
$LN15@IsCContigu:
  0002b	33 c0		 xor	 eax, eax

; 398  : }

  0002d	c3		 ret	 0
$LN6@IsCContigu:

; 391  :     for (i=view->ndim-1; i>=0; i--) {

  0002e	ff c8		 dec	 eax
  00030	48 63 d0	 movsxd	 rdx, eax
  00033	78 26		 js	 SHORT $LN3@IsCContigu
  00035	4d 8b 50 30	 mov	 r10, QWORD PTR [r8+48]
  00039	49 8d 04 d1	 lea	 rax, QWORD PTR [r9+rdx*8]
  0003d	4d 2b d1	 sub	 r10, r9
$LL5@IsCContigu:

; 392  :         dim = view->shape[i];

  00040	4d 8b 04 02	 mov	 r8, QWORD PTR [r10+rax]

; 393  :         if (dim == 0) return 1;

  00044	4d 85 c0	 test	 r8, r8
  00047	74 12		 je	 SHORT $LN3@IsCContigu

; 394  :         if (view->strides[i] != sd) return 0;

  00049	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0004c	75 dd		 jne	 SHORT $LN15@IsCContigu

; 395  :         sd *= dim;

  0004e	49 0f af c8	 imul	 rcx, r8
  00052	48 83 e8 08	 sub	 rax, 8
  00056	48 ff ca	 dec	 rdx
  00059	79 e5		 jns	 SHORT $LL5@IsCContigu
$LN3@IsCContigu:

; 396  :     }
; 397  :     return 1;

  0005b	b8 01 00 00 00	 mov	 eax, 1

; 398  : }

  00060	c3		 ret	 0
_IsCContiguous ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_IsContiguous
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_IsContiguous DD imagerel $LN11
	DD	imagerel $LN11+85
	DD	imagerel $unwind$PyBuffer_IsContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_IsContiguous DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyBuffer_IsContiguous
_TEXT	SEGMENT
view$ = 48
order$ = 56
PyBuffer_IsContiguous PROC				; COMDAT

; 402  : {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 403  : 
; 404  :     if (view->suboffsets != NULL) return 0;

  00004	48 83 79 40 00	 cmp	 QWORD PTR [rcx+64], 0
  00009	4c 8b d9	 mov	 r11, rcx
  0000c	75 40		 jne	 SHORT $LN1@PyBuffer_I

; 405  : 
; 406  :     if (order == 'C')

  0000e	80 fa 43	 cmp	 dl, 67			; 00000043H
  00011	75 09		 jne	 SHORT $LN5@PyBuffer_I

; 413  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	e9 00 00 00 00	 jmp	 _IsCContiguous
$LN5@PyBuffer_I:

; 407  :         return _IsCContiguous(view);
; 408  :     else if (order == 'F')

  0001c	80 fa 46	 cmp	 dl, 70			; 00000046H
  0001f	75 09		 jne	 SHORT $LN3@PyBuffer_I

; 413  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	e9 00 00 00 00	 jmp	 _IsFortranContiguous
$LN3@PyBuffer_I:

; 409  :         return _IsFortranContiguous(view);
; 410  :     else if (order == 'A')

  0002a	80 fa 41	 cmp	 dl, 65			; 00000041H
  0002d	75 1f		 jne	 SHORT $LN1@PyBuffer_I

; 411  :         return (_IsCContiguous(view) || _IsFortranContiguous(view));

  0002f	e8 00 00 00 00	 call	 _IsCContiguous
  00034	85 c0		 test	 eax, eax
  00036	75 0c		 jne	 SHORT $LN9@PyBuffer_I
  00038	49 8b cb	 mov	 rcx, r11
  0003b	e8 00 00 00 00	 call	 _IsFortranContiguous
  00040	85 c0		 test	 eax, eax
  00042	74 0a		 je	 SHORT $LN1@PyBuffer_I
$LN9@PyBuffer_I:
  00044	b8 01 00 00 00	 mov	 eax, 1

; 413  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
$LN1@PyBuffer_I:

; 412  :     return 0;

  0004e	33 c0		 xor	 eax, eax

; 413  : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
PyBuffer_IsContiguous ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_GetPointer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_GetPointer DD imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$PyBuffer_GetPointer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyBuffer_GetPointer DD imagerel $LN10+21
	DD	imagerel $LN10+93
	DD	imagerel $chain$0$PyBuffer_GetPointer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyBuffer_GetPointer DD imagerel $LN10+93
	DD	imagerel $LN10+101
	DD	imagerel $chain$1$PyBuffer_GetPointer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyBuffer_GetPointer DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$PyBuffer_GetPointer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyBuffer_GetPointer DD 020421H
	DD	03404H
	DD	imagerel $LN10
	DD	imagerel $LN10+21
	DD	imagerel $unwind$PyBuffer_GetPointer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_GetPointer DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyBuffer_GetPointer
_TEXT	SEGMENT
view$ = 16
indices$ = 24
PyBuffer_GetPointer PROC				; COMDAT

; 418  : {

$LN10:
  00000	48 83 ec 08	 sub	 rsp, 8

; 419  :     char* pointer;
; 420  :     int i;
; 421  :     pointer = (char *)view->buf;
; 422  :     for (i = 0; i < view->ndim; i++) {

  00004	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  00007	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0000a	4c 8b d2	 mov	 r10, rdx
  0000d	85 c0		 test	 eax, eax
  0000f	7e 4c		 jle	 SHORT $LN9@PyBuffer_G
  00011	4c 8b 59 40	 mov	 r11, QWORD PTR [rcx+64]
  00015	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  00019	48 8b 59 38	 mov	 rbx, QWORD PTR [rcx+56]
  0001d	48 2b da	 sub	 rbx, rdx
  00020	4d 8b cb	 mov	 r9, r11
  00023	4d 2b d3	 sub	 r10, r11
  00026	8b d0		 mov	 edx, eax
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@PyBuffer_G:

; 423  :         pointer += view->strides[i]*indices[i];

  00030	4b 8d 04 0a	 lea	 rax, QWORD PTR [r10+r9]
  00034	48 8b 0c 18	 mov	 rcx, QWORD PTR [rax+rbx]
  00038	48 0f af 08	 imul	 rcx, QWORD PTR [rax]
  0003c	4c 03 c1	 add	 r8, rcx

; 424  :         if ((view->suboffsets != NULL) && (view->suboffsets[i] >= 0)) {

  0003f	4d 85 db	 test	 r11, r11
  00042	74 0c		 je	 SHORT $LN3@PyBuffer_G
  00044	49 83 39 00	 cmp	 QWORD PTR [r9], 0
  00048	7c 06		 jl	 SHORT $LN3@PyBuffer_G

; 425  :             pointer = *((char**)pointer) + view->suboffsets[i];

  0004a	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0004d	4d 03 01	 add	 r8, QWORD PTR [r9]
$LN3@PyBuffer_G:

; 419  :     char* pointer;
; 420  :     int i;
; 421  :     pointer = (char *)view->buf;
; 422  :     for (i = 0; i < view->ndim; i++) {

  00050	49 83 c1 08	 add	 r9, 8
  00054	48 ff ca	 dec	 rdx
  00057	75 d7		 jne	 SHORT $LL4@PyBuffer_G
  00059	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN9@PyBuffer_G:

; 426  :         }
; 427  :     }
; 428  :     return (void*)pointer;

  0005d	49 8b c0	 mov	 rax, r8

; 429  : }

  00060	48 83 c4 08	 add	 rsp, 8
  00064	c3		 ret	 0
PyBuffer_GetPointer ENDP
_TEXT	ENDS
PUBLIC	_Py_add_one_to_index_F
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_add_one_to_index_F DD imagerel $LN11
	DD	imagerel $LN11+81
	DD	imagerel $unwind$_Py_add_one_to_index_F
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_add_one_to_index_F DD 020501H
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_add_one_to_index_F
_TEXT	SEGMENT
nd$ = 8
index$ = 16
shape$ = 24
_Py_add_one_to_index_F PROC				; COMDAT

; 434  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 435  :     int k;
; 436  : 
; 437  :     for (k=0; k<nd; k++) {

  00005	33 db		 xor	 ebx, ebx
  00007	4c 63 d9	 movsxd	 r11, ecx
  0000a	44 8b d3	 mov	 r10d, ebx
  0000d	44 8b cb	 mov	 r9d, ebx
  00010	85 c9		 test	 ecx, ecx
  00012	7e 37		 jle	 SHORT $LN3@Py_add_one
  00014	48 8b ca	 mov	 rcx, rdx
  00017	4c 2b c2	 sub	 r8, rdx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL5@Py_add_one:

; 438  :         if (index[k] < shape[k]-1) {

  00020	49 8b 04 08	 mov	 rax, QWORD PTR [r8+rcx]
  00024	48 ff c8	 dec	 rax
  00027	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0002a	7c 18		 jl	 SHORT $LN9@Py_add_one

; 440  :             break;
; 441  :         }
; 442  :         else {
; 443  :             index[k] = 0;

  0002c	49 ff c1	 inc	 r9
  0002f	48 89 19	 mov	 QWORD PTR [rcx], rbx
  00032	41 ff c2	 inc	 r10d
  00035	48 83 c1 08	 add	 rcx, 8
  00039	4d 3b cb	 cmp	 r9, r11
  0003c	7c e2		 jl	 SHORT $LL5@Py_add_one

; 444  :         }
; 445  :     }
; 446  : }

  0003e	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00043	c3		 ret	 0
$LN9@Py_add_one:

; 439  :             index[k]++;

  00044	49 63 c2	 movsxd	 rax, r10d
  00047	48 ff 04 c2	 inc	 QWORD PTR [rdx+rax*8]
$LN3@Py_add_one:

; 444  :         }
; 445  :     }
; 446  : }

  0004b	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00050	c3		 ret	 0
_Py_add_one_to_index_F ENDP
_TEXT	ENDS
PUBLIC	_Py_add_one_to_index_C
; Function compile flags: /Ogtpy
;	COMDAT _Py_add_one_to_index_C
_TEXT	SEGMENT
nd$ = 8
index$ = 16
shape$ = 24
_Py_add_one_to_index_C PROC				; COMDAT

; 451  :     int k;
; 452  : 
; 453  :     for (k=nd-1; k>=0; k--) {

  00000	44 8d 51 ff	 lea	 r10d, DWORD PTR [rcx-1]
  00004	4d 63 ca	 movsxd	 r9, r10d
  00007	45 85 d2	 test	 r10d, r10d
  0000a	78 38		 js	 SHORT $LN3@Py_add_one@2
  0000c	4c 2b c2	 sub	 r8, rdx
  0000f	4a 8d 0c ca	 lea	 rcx, QWORD PTR [rdx+r9*8]
  00013	45 33 db	 xor	 r11d, r11d
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@Py_add_one@2:

; 454  :         if (index[k] < shape[k]-1) {

  00020	49 8b 04 08	 mov	 rax, QWORD PTR [r8+rcx]
  00024	48 ff c8	 dec	 rax
  00027	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0002a	7c 11		 jl	 SHORT $LN9@Py_add_one@2

; 456  :             break;
; 457  :         }
; 458  :         else {
; 459  :             index[k] = 0;

  0002c	4c 89 19	 mov	 QWORD PTR [rcx], r11
  0002f	48 83 e9 08	 sub	 rcx, 8
  00033	41 ff ca	 dec	 r10d
  00036	49 ff c9	 dec	 r9
  00039	79 e5		 jns	 SHORT $LL5@Py_add_one@2

; 460  :         }
; 461  :     }
; 462  : }

  0003b	f3 c3		 fatret	 0
$LN9@Py_add_one@2:

; 455  :             index[k]++;

  0003d	49 63 c2	 movsxd	 rax, r10d
  00040	48 ff 04 c2	 inc	 QWORD PTR [rdx+rax*8]
$LN3@Py_add_one@2:

; 460  :         }
; 461  :     }
; 462  : }

  00044	f3 c3		 fatret	 0
_Py_add_one_to_index_C ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_FromContiguous
EXTRN	PyMem_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_FromContiguous DD imagerel $LN19
	DD	imagerel $LN19+121
	DD	imagerel $unwind$PyBuffer_FromContiguous
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyBuffer_FromContiguous DD imagerel $LN19+121
	DD	imagerel $LN19+271
	DD	imagerel $chain$1$PyBuffer_FromContiguous
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyBuffer_FromContiguous DD imagerel $LN19+271
	DD	imagerel $LN19+290
	DD	imagerel $chain$2$PyBuffer_FromContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyBuffer_FromContiguous DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+121
	DD	imagerel $unwind$PyBuffer_FromContiguous
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyBuffer_FromContiguous DD 020521H
	DD	09c405H
	DD	imagerel $LN19
	DD	imagerel $LN19+121
	DD	imagerel $unwind$PyBuffer_FromContiguous
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_FromContiguous DD 085901H
	DD	087459H
	DD	0a340dH
	DD	0d009320dH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyBuffer_FromContiguous
_TEXT	SEGMENT
view$ = 64
buf$ = 72
len$ = 80
fort$ = 88
PyBuffer_FromContiguous PROC				; COMDAT

; 466  : {

$LN19:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 55		 push	 r13
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 467  :     int k;
; 468  :     void (*addone)(int, Py_ssize_t *, const Py_ssize_t *);
; 469  :     Py_ssize_t *indices, elements;
; 470  :     char *src, *ptr;
; 471  : 
; 472  :     if (len > view->len) {

  0000d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00011	49 8b f0	 mov	 rsi, r8
  00014	48 8b ea	 mov	 rbp, rdx
  00017	4c 3b c0	 cmp	 r8, rax

; 473  :         len = view->len;
; 474  :     }
; 475  : 
; 476  :     if (PyBuffer_IsContiguous(view, fort)) {

  0001a	41 0f b6 d1	 movzx	 edx, r9b
  0001e	45 0f b6 e9	 movzx	 r13d, r9b
  00022	48 0f 4f f0	 cmovg	 rsi, rax
  00026	48 8b d9	 mov	 rbx, rcx
  00029	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0002e	85 c0		 test	 eax, eax
  00030	74 1e		 je	 SHORT $LN9@PyBuffer_F

; 477  :         /* simplest copy is all that is needed */
; 478  :         memcpy(view->buf, buf, len);

  00032	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00035	4c 8b c6	 mov	 r8, rsi
  00038	48 8b d5	 mov	 rdx, rbp
  0003b	e8 00 00 00 00	 call	 memcpy

; 479  :         return 0;

  00040	33 c0		 xor	 eax, eax

; 514  : }

  00042	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	41 5d		 pop	 r13
  0004d	5e		 pop	 rsi
  0004e	5d		 pop	 rbp
  0004f	c3		 ret	 0
$LN9@PyBuffer_F:

; 480  :     }
; 481  : 
; 482  :     /* Otherwise a more elaborate scheme is needed */
; 483  : 
; 484  :     /* XXX(nnorwitz): need to check for overflow! */
; 485  :     indices = (Py_ssize_t *)PyMem_Malloc(sizeof(Py_ssize_t)*(view->ndim));

  00050	48 63 4b 24	 movsxd	 rcx, DWORD PTR [rbx+36]
  00054	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00059	48 c1 e1 03	 shl	 rcx, 3
  0005d	e8 00 00 00 00	 call	 PyMem_Malloc
  00062	48 8b f8	 mov	 rdi, rax

; 486  :     if (indices == NULL) {

  00065	48 85 c0	 test	 rax, rax
  00068	75 0d		 jne	 SHORT $LN8@PyBuffer_F

; 487  :         PyErr_NoMemory();

  0006a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 488  :         return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	e9 98 00 00 00	 jmp	 $LN18@PyBuffer_F
$LN8@PyBuffer_F:

; 489  :     }
; 490  :     for (k=0; k<view->ndim;k++) {

  00077	33 d2		 xor	 edx, edx
  00079	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  0007e	8b ca		 mov	 ecx, edx
  00080	39 53 24	 cmp	 DWORD PTR [rbx+36], edx
  00083	7e 19		 jle	 SHORT $LN5@PyBuffer_F
  00085	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@PyBuffer_F:

; 491  :         indices[k] = 0;

  00090	48 89 10	 mov	 QWORD PTR [rax], rdx
  00093	ff c1		 inc	 ecx
  00095	48 83 c0 08	 add	 rax, 8
  00099	3b 4b 24	 cmp	 ecx, DWORD PTR [rbx+36]
  0009c	7c f2		 jl	 SHORT $LL7@PyBuffer_F
$LN5@PyBuffer_F:

; 492  :     }
; 493  : 
; 494  :     if (fort == 'F') {

  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_add_one_to_index_F
  000a5	41 80 fd 46	 cmp	 r13b, 70		; 00000046H
  000a9	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_add_one_to_index_C
  000b0	4c 0f 44 e0	 cmove	 r12, rax

; 495  :         addone = _Py_add_one_to_index_F;
; 496  :     }
; 497  :     else {
; 498  :         addone = _Py_add_one_to_index_C;
; 499  :     }
; 500  :     src = buf;
; 501  :     /* XXX : This is not going to be the fastest code in the world
; 502  :              several optimizations are possible.
; 503  :      */
; 504  :     elements = len / view->itemsize;

  000b4	48 8b c6	 mov	 rax, rsi
  000b7	48 99		 cdq
  000b9	48 f7 7b 18	 idiv	 QWORD PTR [rbx+24]
  000bd	48 8b f0	 mov	 rsi, rax

; 505  :     while (elements--) {

  000c0	48 85 c0	 test	 rax, rax
  000c3	74 3b		 je	 SHORT $LN16@PyBuffer_F
  000c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@PyBuffer_F:

; 506  :         addone(view->ndim, indices, view->shape);

  000d0	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  000d4	8b 4b 24	 mov	 ecx, DWORD PTR [rbx+36]
  000d7	48 8b d7	 mov	 rdx, rdi
  000da	41 ff d4	 call	 r12

; 507  :         ptr = PyBuffer_GetPointer(view, indices);

  000dd	48 8b d7	 mov	 rdx, rdi
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	e8 00 00 00 00	 call	 PyBuffer_GetPointer

; 508  :         memcpy(ptr, src, view->itemsize);

  000e8	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  000ec	48 8b d5	 mov	 rdx, rbp
  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 memcpy

; 509  :         src += view->itemsize;

  000f7	48 03 6b 18	 add	 rbp, QWORD PTR [rbx+24]
  000fb	48 ff ce	 dec	 rsi
  000fe	75 d0		 jne	 SHORT $LL2@PyBuffer_F
$LN16@PyBuffer_F:

; 510  :     }
; 511  : 
; 512  :     PyMem_Free(indices);

  00100	48 8b cf	 mov	 rcx, rdi
  00103	e8 00 00 00 00	 call	 PyMem_Free
  00108	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]

; 513  :     return 0;

  0010d	33 c0		 xor	 eax, eax
$LN18@PyBuffer_F:
  0010f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 514  : }

  00114	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00119	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011d	41 5d		 pop	 r13
  0011f	5e		 pop	 rsi
  00120	5d		 pop	 rbp
  00121	c3		 ret	 0
PyBuffer_FromContiguous ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_FillContiguousStrides
; Function compile flags: /Ogtpy
;	COMDAT PyBuffer_FillContiguousStrides
_TEXT	SEGMENT
nd$ = 8
shape$ = 16
strides$ = 24
itemsize$ = 32
fort$ = 40
PyBuffer_FillContiguousStrides PROC			; COMDAT

; 591  :     int k;
; 592  :     Py_ssize_t sd;
; 593  : 
; 594  :     sd = itemsize;
; 595  :     if (fort == 'F') {

  00000	80 7c 24 28 46	 cmp	 BYTE PTR fort$[rsp], 70	; 00000046H
  00005	4d 63 d1	 movsxd	 r10, r9d
  00008	75 29		 jne	 SHORT $LN8@PyBuffer_F@2

; 596  :         for (k=0; k<nd; k++) {

  0000a	48 63 c1	 movsxd	 rax, ecx
  0000d	85 c9		 test	 ecx, ecx
  0000f	7e 50		 jle	 SHORT $LN1@PyBuffer_F@2
  00011	4c 2b c2	 sub	 r8, rdx
  00014	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL7@PyBuffer_F@2:

; 597  :             strides[k] = sd;

  00020	4d 89 14 10	 mov	 QWORD PTR [r8+rdx], r10

; 598  :             sd *= shape[k];

  00024	4c 0f af 12	 imul	 r10, QWORD PTR [rdx]
  00028	48 83 c2 08	 add	 rdx, 8
  0002c	48 ff c8	 dec	 rax
  0002f	75 ef		 jne	 SHORT $LL7@PyBuffer_F@2

; 605  :         }
; 606  :     }
; 607  :     return;
; 608  : }

  00031	f3 c3		 fatret	 0
$LN8@PyBuffer_F@2:

; 599  :         }
; 600  :     }
; 601  :     else {
; 602  :         for (k=nd-1; k>=0; k--) {

  00033	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00036	48 63 c8	 movsxd	 rcx, eax
  00039	85 c0		 test	 eax, eax
  0003b	78 24		 js	 SHORT $LN1@PyBuffer_F@2
  0003d	48 8d 04 ca	 lea	 rax, QWORD PTR [rdx+rcx*8]
  00041	4c 2b c2	 sub	 r8, rdx
  00044	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@PyBuffer_F@2:

; 603  :             strides[k] = sd;

  00050	4e 89 14 00	 mov	 QWORD PTR [rax+r8], r10

; 604  :             sd *= shape[k];

  00054	4c 0f af 10	 imul	 r10, QWORD PTR [rax]
  00058	48 83 e8 08	 sub	 rax, 8
  0005c	48 ff c9	 dec	 rcx
  0005f	79 ef		 jns	 SHORT $LL3@PyBuffer_F@2
$LN1@PyBuffer_F@2:

; 605  :         }
; 606  :     }
; 607  :     return;
; 608  : }

  00061	f3 c3		 fatret	 0
PyBuffer_FillContiguousStrides ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@ ; `string'
PUBLIC	PyBuffer_FillInfo
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_FillInfo DD imagerel $LN11
	DD	imagerel $LN11+244
	DD	imagerel $unwind$PyBuffer_FillInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_FillInfo DD 0a3f01H
	DD	07743fH
	DD	066436H
	DD	095410H
	DD	083410H
	DD	0c00c3210H
xdata	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@
CONST	SEGMENT
??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@ DB 'Object is not wri'
	DB	'table.', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyBuffer_FillInfo
_TEXT	SEGMENT
view$ = 48
obj$ = 56
buf$ = 64
len$ = 72
readonly$ = 80
flags$ = 88
PyBuffer_FillInfo PROC					; COMDAT

; 613  : {

$LN11:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	49 8b e9	 mov	 rbp, r9
  00013	4d 8b e0	 mov	 r12, r8
  00016	48 8b d9	 mov	 rbx, rcx

; 614  :     if (view == NULL) return 0; /* XXX why not -1? */

  00019	48 85 c9	 test	 rcx, rcx
  0001c	75 13		 jne	 SHORT $LN6@PyBuffer_F@3
  0001e	33 c0		 xor	 eax, eax

; 642  : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	41 5c		 pop	 r12
  00030	c3		 ret	 0
$LN6@PyBuffer_F@3:
  00031	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 615  :     if (((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE) &&
; 616  :         (readonly == 1)) {

  00036	8b 74 24 50	 mov	 esi, DWORD PTR readonly$[rsp]
  0003a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003f	8b 7c 24 58	 mov	 edi, DWORD PTR flags$[rsp]
  00043	40 f6 c7 01	 test	 dil, 1
  00047	74 1d		 je	 SHORT $LN5@PyBuffer_F@3
  00049	83 fe 01	 cmp	 esi, 1
  0004c	75 18		 jne	 SHORT $LN5@PyBuffer_F@3

; 617  :         PyErr_SetString(PyExc_BufferError,
; 618  :                         "Object is not writable.");

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 619  :         return -1;

  00061	83 c8 ff	 or	 eax, -1
  00064	eb 73		 jmp	 SHORT $LN10@PyBuffer_F@3
$LN5@PyBuffer_F@3:

; 620  :     }
; 621  : 
; 622  :     view->obj = obj;

  00066	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 623  :     if (obj)

  0006a	48 85 d2	 test	 rdx, rdx
  0006d	74 08		 je	 SHORT $LN4@PyBuffer_F@3

; 624  :         Py_INCREF(obj);

  0006f	48 8b ca	 mov	 rcx, rdx
  00072	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@PyBuffer_F@3:

; 625  :     view->buf = buf;
; 626  :     view->len = len;
; 627  :     view->readonly = readonly;
; 628  :     view->itemsize = 1;
; 629  :     view->format = NULL;

  00077	45 33 c9	 xor	 r9d, r9d

; 630  :     if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)

  0007a	40 0f b6 c7	 movzx	 eax, dil
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  00085	24 04		 and	 al, 4
  00087	4c 8d 43 10	 lea	 r8, QWORD PTR [rbx+16]
  0008b	48 8d 53 18	 lea	 rdx, QWORD PTR [rbx+24]
  0008f	3c 04		 cmp	 al, 4
  00091	4c 89 23	 mov	 QWORD PTR [rbx], r12
  00094	89 73 20	 mov	 DWORD PTR [rbx+32], esi
  00097	49 0f 45 c9	 cmovne	 rcx, r9
  0009b	49 89 28	 mov	 QWORD PTR [r8], rbp
  0009e	48 c7 02 01 00
	00 00		 mov	 QWORD PTR [rdx], 1

; 631  :         view->format = "B";
; 632  :     view->ndim = 1;

  000a5	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1

; 633  :     view->shape = NULL;

  000ac	4c 89 4b 30	 mov	 QWORD PTR [rbx+48], r9
  000b0	48 89 4b 28	 mov	 QWORD PTR [rbx+40], rcx

; 634  :     if ((flags & PyBUF_ND) == PyBUF_ND)

  000b4	40 f6 c7 08	 test	 dil, 8
  000b8	74 04		 je	 SHORT $LN2@PyBuffer_F@3

; 635  :         view->shape = &(view->len);

  000ba	4c 89 43 30	 mov	 QWORD PTR [rbx+48], r8
$LN2@PyBuffer_F@3:

; 636  :     view->strides = NULL;
; 637  :     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES)

  000be	83 e7 18	 and	 edi, 24
  000c1	4c 89 4b 38	 mov	 QWORD PTR [rbx+56], r9
  000c5	40 80 ff 18	 cmp	 dil, 24
  000c9	75 04		 jne	 SHORT $LN1@PyBuffer_F@3

; 638  :         view->strides = &(view->itemsize);

  000cb	48 89 53 38	 mov	 QWORD PTR [rbx+56], rdx
$LN1@PyBuffer_F@3:

; 639  :     view->suboffsets = NULL;

  000cf	4c 89 4b 40	 mov	 QWORD PTR [rbx+64], r9

; 640  :     view->internal = NULL;

  000d3	4c 89 4b 48	 mov	 QWORD PTR [rbx+72], r9

; 641  :     return 0;

  000d7	33 c0		 xor	 eax, eax
$LN10@PyBuffer_F@3:

; 642  : }

  000d9	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000de	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000e3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e8	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ed	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f1	41 5c		 pop	 r12
  000f3	c3		 ret	 0
PyBuffer_FillInfo ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_Release
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyBuffer_Release DD imagerel $LN23
	DD	imagerel $LN23+232
	DD	imagerel $unwind$PyBuffer_Release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_Release DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT PyBuffer_Release
_TEXT	SEGMENT
view$ = 64
PyBuffer_Release PROC					; COMDAT

; 646  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 647  :     PyObject *obj = view->obj;

  0000a	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  0000e	48 8b d9	 mov	 rbx, rcx

; 648  :     if (obj && Py_TYPE(obj)->tp_as_buffer && Py_TYPE(obj)->tp_as_buffer->bf_releasebuffer)

  00011	48 85 ff	 test	 rdi, rdi
  00014	0f 84 bb 00 00
	00		 je	 $LN22@PyBuffer_R
  0001a	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0001e	48 8b 88 f8 00
	00 00		 mov	 rcx, QWORD PTR [rax+248]
  00025	48 85 c9	 test	 rcx, rcx
  00028	74 11		 je	 SHORT $LN4@PyBuffer_R
  0002a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0002e	48 85 c0	 test	 rax, rax
  00031	74 08		 je	 SHORT $LN4@PyBuffer_R

; 649  :         Py_TYPE(obj)->tp_as_buffer->bf_releasebuffer(obj, view);

  00033	48 8b d3	 mov	 rdx, rbx
  00036	48 8b cf	 mov	 rcx, rdi
  00039	ff d0		 call	 rax
$LN4@PyBuffer_R:

; 650  :     Py_XDECREF(obj);

  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	85 c0		 test	 eax, eax
  00042	75 46		 jne	 SHORT $LN19@PyBuffer_R
  00044	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00048	a8 20		 test	 al, 32			; 00000020H
  0004a	75 6e		 jne	 SHORT $LN12@PyBuffer_R
  0004c	84 c0		 test	 al, al
  0004e	78 6a		 js	 SHORT $LN12@PyBuffer_R
  00050	a8 02		 test	 al, 2
  00052	75 36		 jne	 SHORT $LN19@PyBuffer_R
  00054	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00058	75 30		 jne	 SHORT $LN19@PyBuffer_R
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00068	4c 8b cf	 mov	 r9, rdi
  0006b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00071	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00079	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007e	48 8b cf	 mov	 rcx, rdi
  00081	85 c0		 test	 eax, eax
  00083	74 18		 je	 SHORT $LN17@PyBuffer_R
  00085	e8 00 00 00 00	 call	 _Px_Dealloc
$LN19@PyBuffer_R:

; 651  :     view->obj = NULL;

  0008a	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 652  : }

  00092	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00097	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0

; 650  :     Py_XDECREF(obj);

$LN17@PyBuffer_R:
  0009d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000a1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 651  :     view->obj = NULL;

  000a7	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 652  : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0

; 650  :     Py_XDECREF(obj);

$LN12@PyBuffer_R:
  000ba	48 8b cf	 mov	 rcx, rdi
  000bd	e8 00 00 00 00	 call	 Px_DecRef

; 651  :     view->obj = NULL;

  000c2	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 652  : }

  000ca	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
$LN22@PyBuffer_R:

; 651  :     view->obj = NULL;

  000d5	48 c7 41 08 00
	00 00 00	 mov	 QWORD PTR [rcx+8], 0

; 652  : }

  000dd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
PyBuffer_Release ENDP
_TEXT	ENDS
PUBLIC	PyNumber_Check
; Function compile flags: /Ogtpy
;	COMDAT PyNumber_Check
_TEXT	SEGMENT
o$ = 8
PyNumber_Check PROC					; COMDAT

; 699  :     return o && o->ob_type->tp_as_number &&
; 700  :            (o->ob_type->tp_as_number->nb_int ||
; 701  :         o->ob_type->tp_as_number->nb_float);

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2a		 je	 SHORT $LN3@PyNumber_C
  00005	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00009	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 1a		 je	 SHORT $LN3@PyNumber_C
  00015	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0001d	75 0a		 jne	 SHORT $LN4@PyNumber_C
  0001f	48 83 b9 90 00
	00 00 00	 cmp	 QWORD PTR [rcx+144], 0
  00027	74 06		 je	 SHORT $LN3@PyNumber_C
$LN4@PyNumber_C:
  00029	b8 01 00 00 00	 mov	 eax, 1

; 702  : }

  0002e	c3		 ret	 0
$LN3@PyNumber_C:

; 699  :     return o && o->ob_type->tp_as_number &&
; 700  :            (o->ob_type->tp_as_number->nb_int ||
; 701  :         o->ob_type->tp_as_number->nb_float);

  0002f	33 c0		 xor	 eax, eax

; 702  : }

  00031	c3		 ret	 0
PyNumber_Check ENDP
_TEXT	ENDS
EXTRN	PyType_IsSubtype:PROC
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$binary_op1 DD imagerel binary_op1
	DD	imagerel binary_op1+290
	DD	imagerel $unwind$binary_op1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_op1 DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT binary_op1
_TEXT	SEGMENT
v$ = 80
w$ = 88
op_slot$ = 96
binary_op1 PROC						; COMDAT

; 724  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 725  :     PyObject *x;
; 726  :     binaryfunc slotv = NULL;
; 727  :     binaryfunc slotw = NULL;
; 728  : 
; 729  :     if (v->ob_type->tp_as_number != NULL)

  00018	4c 8b 49 58	 mov	 r9, QWORD PTR [rcx+88]
  0001c	45 33 ed	 xor	 r13d, r13d
  0001f	48 8b f2	 mov	 rsi, rdx
  00022	49 8b 91 b8 00
	00 00		 mov	 rdx, QWORD PTR [r9+184]
  00029	48 8b e9	 mov	 rbp, rcx
  0002c	41 8b fd	 mov	 edi, r13d
  0002f	41 8b dd	 mov	 ebx, r13d
  00032	48 85 d2	 test	 rdx, rdx
  00035	74 07		 je	 SHORT $LN9@binary_op1

; 730  :         slotv = NB_BINOP(v->ob_type->tp_as_number, op_slot);

  00037	49 63 c0	 movsxd	 rax, r8d
  0003a	48 8b 3c 10	 mov	 rdi, QWORD PTR [rax+rdx]
$LN9@binary_op1:

; 731  :     if (w->ob_type != v->ob_type &&
; 732  :         w->ob_type->tp_as_number != NULL) {

  0003e	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00042	49 3b c9	 cmp	 rcx, r9
  00045	74 1a		 je	 SHORT $LN7@binary_op1
  00047	48 8b 91 b8 00
	00 00		 mov	 rdx, QWORD PTR [rcx+184]
  0004e	48 85 d2	 test	 rdx, rdx
  00051	74 0e		 je	 SHORT $LN7@binary_op1

; 733  :         slotw = NB_BINOP(w->ob_type->tp_as_number, op_slot);

  00053	49 63 c0	 movsxd	 rax, r8d
  00056	48 8b 1c 10	 mov	 rbx, QWORD PTR [rax+rdx]

; 734  :         if (slotw == slotv)

  0005a	48 3b df	 cmp	 rbx, rdi
  0005d	49 0f 44 dd	 cmove	 rbx, r13
$LN7@binary_op1:

; 735  :             slotw = NULL;
; 736  :     }
; 737  :     if (slotv) {

  00061	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NotImplementedStruct
  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 3e		 je	 SHORT $LN6@binary_op1

; 738  :         if (slotw && PyType_IsSubtype(w->ob_type, v->ob_type)) {

  0006d	48 85 db	 test	 rbx, rbx
  00070	74 24		 je	 SHORT $LN5@binary_op1
  00072	49 8b d1	 mov	 rdx, r9
  00075	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007a	85 c0		 test	 eax, eax
  0007c	74 18		 je	 SHORT $LN5@binary_op1

; 739  :             x = slotw(v, w);

  0007e	48 8b d6	 mov	 rdx, rsi
  00081	48 8b cd	 mov	 rcx, rbp
  00084	ff d3		 call	 rbx

; 740  :             if (x != Py_NotImplemented)

  00086	49 3b c4	 cmp	 rax, r12

; 741  :                 return x;

  00089	75 7e		 jne	 SHORT $LN10@binary_op1

; 742  :             Py_DECREF(x); /* can't do it */

  0008b	48 8b c8	 mov	 rcx, rax
  0008e	e8 00 00 00 00	 call	 _Py_DecRef

; 743  :             slotw = NULL;

  00093	49 8b dd	 mov	 rbx, r13
$LN5@binary_op1:

; 744  :         }
; 745  :         x = slotv(v, w);

  00096	48 8b d6	 mov	 rdx, rsi
  00099	48 8b cd	 mov	 rcx, rbp
  0009c	ff d7		 call	 rdi

; 746  :         if (x != Py_NotImplemented)

  0009e	49 3b c4	 cmp	 rax, r12

; 747  :             return x;

  000a1	75 66		 jne	 SHORT $LN10@binary_op1

; 748  :         Py_DECREF(x); /* can't do it */

  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@binary_op1:

; 749  :     }
; 750  :     if (slotw) {

  000ab	48 85 db	 test	 rbx, rbx
  000ae	74 15		 je	 SHORT $LN2@binary_op1

; 751  :         x = slotw(v, w);

  000b0	48 8b d6	 mov	 rdx, rsi
  000b3	48 8b cd	 mov	 rcx, rbp
  000b6	ff d3		 call	 rbx

; 752  :         if (x != Py_NotImplemented)

  000b8	49 3b c4	 cmp	 rax, r12

; 753  :             return x;

  000bb	75 4c		 jne	 SHORT $LN10@binary_op1

; 754  :         Py_DECREF(x); /* can't do it */

  000bd	48 8b c8	 mov	 rcx, rax
  000c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@binary_op1:

; 755  :     }
; 756  :     Py_RETURN_NOTIMPLEMENTED;

  000c5	e8 00 00 00 00	 call	 _Py_PXCTX
  000ca	85 c0		 test	 eax, eax
  000cc	75 38		 jne	 SHORT $LN13@binary_op1
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000dc	4d 8b cc	 mov	 r9, r12
  000df	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000e5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ed	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f2	85 c0		 test	 eax, eax
  000f4	75 09		 jne	 SHORT $LN12@binary_op1
  000f6	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000fd	74 07		 je	 SHORT $LN13@binary_op1
$LN12@binary_op1:
  000ff	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN13@binary_op1:
  00106	49 8b c4	 mov	 rax, r12
$LN10@binary_op1:

; 757  : }

  00109	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0010e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00113	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
binary_op1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binop_type_error DD imagerel binop_type_error
	DD	imagerel binop_type_error+51
	DD	imagerel $unwind$binop_type_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binop_type_error DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for %.100s: ''%.100s'' and ''%.100s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binop_type_error
_TEXT	SEGMENT
v$ = 64
w$ = 72
op_name$ = 80
binop_type_error PROC					; COMDAT

; 761  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 762  :     PyErr_Format(PyExc_TypeError,
; 763  :                  "unsupported operand type(s) for %.100s: "
; 764  :                  "'%.100s' and '%.100s'",
; 765  :                  op_name,
; 766  :                  v->ob_type->tp_name,
; 767  :                  w->ob_type->tp_name);

  00004	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00008	4c 8b 49 58	 mov	 r9, QWORD PTR [rcx+88]
  0000c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	e8 00 00 00 00	 call	 PyErr_Format

; 768  :     return NULL;

  0002c	33 c0		 xor	 eax, eax

; 769  : }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
binop_type_error ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_op DD imagerel binary_op
	DD	imagerel binary_op+79
	DD	imagerel $unwind$binary_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_op DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT binary_op
_TEXT	SEGMENT
v$ = 48
w$ = 56
op_slot$ = 64
op_name$ = 72
binary_op PROC						; COMDAT

; 773  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f1	 mov	 rsi, r9
  00012	48 8b da	 mov	 rbx, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 774  :     PyObject *result = binary_op1(v, w, op_slot);

  00018	e8 00 00 00 00	 call	 binary_op1

; 775  :     if (result == Py_NotImplemented) {

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00024	48 3b c1	 cmp	 rax, rcx
  00027	75 16		 jne	 SHORT $LN1@binary_op

; 776  :         Py_DECREF(result);

  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 _Py_DecRef

; 777  :         return binop_type_error(v, w, op_name);

  00031	4c 8b c6	 mov	 r8, rsi
  00034	48 8b d3	 mov	 rdx, rbx
  00037	48 8b cf	 mov	 rcx, rdi
  0003a	e8 00 00 00 00	 call	 binop_type_error
$LN1@binary_op:

; 778  :     }
; 779  :     return result;
; 780  : }

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
binary_op ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
PUBLIC	??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$ternary_op DD imagerel ternary_op
	DD	imagerel ternary_op+394
	DD	imagerel $unwind$ternary_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ternary_op DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for pow(): ''%.100s'', ''%.100s'', ''%.'
	DB	'100s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for ** or pow(): ''%.100s'' and ''%.100'
	DB	's''', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ternary_op
_TEXT	SEGMENT
v$ = 96
w$ = 104
z$ = 112
op_slot$ = 120
ternary_op PROC						; COMDAT

; 796  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 797  :     PyNumberMethods *mv, *mw, *mz;
; 798  :     PyObject *x = NULL;
; 799  :     ternaryfunc slotv = NULL;
; 800  :     ternaryfunc slotw = NULL;
; 801  :     ternaryfunc slotz = NULL;
; 802  : 
; 803  :     mv = v->ob_type->tp_as_number;
; 804  :     mw = w->ob_type->tp_as_number;

  0001c	4c 8b 52 58	 mov	 r10, QWORD PTR [rdx+88]
  00020	45 33 ff	 xor	 r15d, r15d
  00023	49 8b f8	 mov	 rdi, r8
  00026	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0002a	48 8b e9	 mov	 rbp, rcx
  0002d	48 8b f2	 mov	 rsi, rdx
  00030	49 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [r8+184]
  00037	49 8b 92 b8 00
	00 00		 mov	 rdx, QWORD PTR [r10+184]
  0003e	4d 63 e9	 movsxd	 r13, r9d
  00041	45 8b e7	 mov	 r12d, r15d
  00044	41 8b df	 mov	 ebx, r15d

; 805  :     if (mv != NULL)

  00047	48 85 c9	 test	 rcx, rcx
  0004a	74 05		 je	 SHORT $LN16@ternary_op

; 806  :         slotv = NB_TERNOP(mv, op_slot);

  0004c	4d 8b 64 0d 00	 mov	 r12, QWORD PTR [r13+rcx]
$LN16@ternary_op:

; 807  :     if (w->ob_type != v->ob_type &&
; 808  :         mw != NULL) {

  00051	4d 3b d0	 cmp	 r10, r8
  00054	74 11		 je	 SHORT $LN14@ternary_op
  00056	48 85 d2	 test	 rdx, rdx
  00059	74 0c		 je	 SHORT $LN14@ternary_op

; 809  :         slotw = NB_TERNOP(mw, op_slot);

  0005b	49 8b 5c 15 00	 mov	 rbx, QWORD PTR [r13+rdx]

; 810  :         if (slotw == slotv)

  00060	49 3b dc	 cmp	 rbx, r12
  00063	49 0f 44 df	 cmove	 rbx, r15
$LN14@ternary_op:

; 811  :             slotw = NULL;
; 812  :     }
; 813  :     if (slotv) {

  00067	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NotImplementedStruct
  0006e	4d 85 e4	 test	 r12, r12
  00071	74 50		 je	 SHORT $LN13@ternary_op

; 814  :         if (slotw && PyType_IsSubtype(w->ob_type, v->ob_type)) {

  00073	48 85 db	 test	 rbx, rbx
  00076	74 2e		 je	 SHORT $LN12@ternary_op
  00078	49 8b d0	 mov	 rdx, r8
  0007b	49 8b ca	 mov	 rcx, r10
  0007e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00083	85 c0		 test	 eax, eax
  00085	74 1f		 je	 SHORT $LN12@ternary_op

; 815  :             x = slotw(v, w, z);

  00087	4c 8b c7	 mov	 r8, rdi
  0008a	48 8b d6	 mov	 rdx, rsi
  0008d	48 8b cd	 mov	 rcx, rbp
  00090	ff d3		 call	 rbx

; 816  :             if (x != Py_NotImplemented)

  00092	49 3b c6	 cmp	 rax, r14

; 817  :                 return x;

  00095	0f 85 d2 00 00
	00		 jne	 $LN17@ternary_op

; 818  :             Py_DECREF(x); /* can't do it */

  0009b	48 8b c8	 mov	 rcx, rax
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 819  :             slotw = NULL;

  000a3	49 8b df	 mov	 rbx, r15
$LN12@ternary_op:

; 820  :         }
; 821  :         x = slotv(v, w, z);

  000a6	4c 8b c7	 mov	 r8, rdi
  000a9	48 8b d6	 mov	 rdx, rsi
  000ac	48 8b cd	 mov	 rcx, rbp
  000af	41 ff d4	 call	 r12

; 822  :         if (x != Py_NotImplemented)

  000b2	49 3b c6	 cmp	 rax, r14

; 823  :             return x;

  000b5	0f 85 b2 00 00
	00		 jne	 $LN17@ternary_op

; 824  :         Py_DECREF(x); /* can't do it */

  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@ternary_op:

; 825  :     }
; 826  :     if (slotw) {

  000c3	48 85 db	 test	 rbx, rbx
  000c6	74 1c		 je	 SHORT $LN9@ternary_op

; 827  :         x = slotw(v, w, z);

  000c8	4c 8b c7	 mov	 r8, rdi
  000cb	48 8b d6	 mov	 rdx, rsi
  000ce	48 8b cd	 mov	 rcx, rbp
  000d1	ff d3		 call	 rbx

; 828  :         if (x != Py_NotImplemented)

  000d3	49 3b c6	 cmp	 rax, r14

; 829  :             return x;

  000d6	0f 85 91 00 00
	00		 jne	 $LN17@ternary_op

; 830  :         Py_DECREF(x); /* can't do it */

  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ternary_op:

; 831  :     }
; 832  :     mz = z->ob_type->tp_as_number;

  000e4	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000e8	4c 8b 88 b8 00
	00 00		 mov	 r9, QWORD PTR [rax+184]

; 833  :     if (mz != NULL) {

  000ef	4d 85 c9	 test	 r9, r9
  000f2	74 2d		 je	 SHORT $LN4@ternary_op

; 834  :         slotz = NB_TERNOP(mz, op_slot);

  000f4	4f 8b 4c 0d 00	 mov	 r9, QWORD PTR [r13+r9]

; 835  :         if (slotz == slotv || slotz == slotw)

  000f9	4d 3b cc	 cmp	 r9, r12
  000fc	74 23		 je	 SHORT $LN4@ternary_op
  000fe	4c 3b cb	 cmp	 r9, rbx

; 836  :             slotz = NULL;
; 837  :         if (slotz) {

  00101	74 1e		 je	 SHORT $LN4@ternary_op
  00103	4d 85 c9	 test	 r9, r9
  00106	74 19		 je	 SHORT $LN4@ternary_op

; 838  :             x = slotz(v, w, z);

  00108	4c 8b c7	 mov	 r8, rdi
  0010b	48 8b d6	 mov	 rdx, rsi
  0010e	48 8b cd	 mov	 rcx, rbp
  00111	41 ff d1	 call	 r9

; 839  :             if (x != Py_NotImplemented)

  00114	49 3b c6	 cmp	 rax, r14

; 840  :                 return x;

  00117	75 54		 jne	 SHORT $LN17@ternary_op

; 841  :             Py_DECREF(x); /* can't do it */

  00119	48 8b c8	 mov	 rcx, rax
  0011c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@ternary_op:

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     if (z == Py_None)
; 846  :         PyErr_Format(
; 847  :             PyExc_TypeError,
; 848  :             "unsupported operand type(s) for ** or pow(): "
; 849  :             "'%.100s' and '%.100s'",
; 850  :             v->ob_type->tp_name,
; 851  :             w->ob_type->tp_name);

  00121	4c 8b 4e 58	 mov	 r9, QWORD PTR [rsi+88]
  00125	4c 8b 45 58	 mov	 r8, QWORD PTR [rbp+88]
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00130	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00134	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0013f	48 3b f8	 cmp	 rdi, rax
  00142	75 0e		 jne	 SHORT $LN2@ternary_op
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  0014b	e8 00 00 00 00	 call	 PyErr_Format

; 852  :     else

  00150	eb 19		 jmp	 SHORT $LN1@ternary_op
$LN2@ternary_op:

; 853  :         PyErr_Format(
; 854  :             PyExc_TypeError,
; 855  :             "unsupported operand type(s) for pow(): "
; 856  :             "'%.100s', '%.100s', '%.100s'",
; 857  :             v->ob_type->tp_name,
; 858  :             w->ob_type->tp_name,
; 859  :             z->ob_type->tp_name);

  00152	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  0015d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00161	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00166	e8 00 00 00 00	 call	 PyErr_Format
$LN1@ternary_op:

; 860  :     return NULL;

  0016b	33 c0		 xor	 eax, eax
$LN17@ternary_op:

; 861  : }

  0016d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00172	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00177	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0017c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00180	41 5f		 pop	 r15
  00182	41 5e		 pop	 r14
  00184	41 5d		 pop	 r13
  00186	41 5c		 pop	 r12
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
ternary_op ENDP
_TEXT	ENDS
PUBLIC	??_C@_01DNKMNLPK@?$HM?$AA@			; `string'
PUBLIC	PyNumber_Or
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM?$AA@ DB '|', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Or
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Or PROC					; COMDAT

; 869  : BINARY_FUNC(PyNumber_Or, nb_or, "|")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01DNKMNLPK@?$HM?$AA@
  00007	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Or ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JKBOJNNK@?$FO?$AA@			; `string'
PUBLIC	PyNumber_Xor
;	COMDAT ??_C@_01JKBOJNNK@?$FO?$AA@
CONST	SEGMENT
??_C@_01JKBOJNNK@?$FO?$AA@ DB '^', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Xor
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Xor PROC					; COMDAT

; 870  : BINARY_FUNC(PyNumber_Xor, nb_xor, "^")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01JKBOJNNK@?$FO?$AA@
  00007	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Xor ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HNPIGOCE@?$CG?$AA@			; `string'
PUBLIC	PyNumber_And
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG?$AA@ DB '&', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_And
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_And PROC					; COMDAT

; 871  : BINARY_FUNC(PyNumber_And, nb_and, "&")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01HNPIGOCE@?$CG?$AA@
  00007	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_And ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FODMEDOG@?$DM?$DM?$AA@			; `string'
PUBLIC	PyNumber_Lshift
;	COMDAT ??_C@_02FODMEDOG@?$DM?$DM?$AA@
CONST	SEGMENT
??_C@_02FODMEDOG@?$DM?$DM?$AA@ DB '<<', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Lshift
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Lshift PROC					; COMDAT

; 872  : BINARY_FUNC(PyNumber_Lshift, nb_lshift, "<<")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02FODMEDOG@?$DM?$DM?$AA@
  00007	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Lshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GPIOPFAK@?$DO?$DO?$AA@			; `string'
PUBLIC	PyNumber_Rshift
;	COMDAT ??_C@_02GPIOPFAK@?$DO?$DO?$AA@
CONST	SEGMENT
??_C@_02GPIOPFAK@?$DO?$DO?$AA@ DB '>>', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Rshift
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Rshift PROC					; COMDAT

; 873  : BINARY_FUNC(PyNumber_Rshift, nb_rshift, ">>")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02GPIOPFAK@?$DO?$DO?$AA@
  00007	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Rshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	PyNumber_Subtract
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Subtract
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Subtract PROC					; COMDAT

; 874  : BINARY_FUNC(PyNumber_Subtract, nb_subtract, "-")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01JOAMLHOP@?9?$AA@
  00007	41 b8 08 00 00
	00		 mov	 r8d, 8
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Subtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@		; `string'
PUBLIC	PyNumber_Divmod
;	COMDAT ??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@ DB 'divmod()', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Divmod
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Divmod PROC					; COMDAT

; 875  : BINARY_FUNC(PyNumber_Divmod, nb_divmod, "divmod()")

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@
  00007	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	PyNumber_Add
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Add DD imagerel $LN5
	DD	imagerel $LN5+132
	DD	imagerel $unwind$PyNumber_Add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Add DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Add
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Add PROC					; COMDAT

; 879  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 880  :     PyObject *result = binary_op1(v, w, NB_SLOT(nb_add));

  0000f	45 33 c0	 xor	 r8d, r8d
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	e8 00 00 00 00	 call	 binary_op1

; 881  :     if (result == Py_NotImplemented) {

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00024	48 3b c1	 cmp	 rax, rcx
  00027	75 4b		 jne	 SHORT $LN2@PyNumber_A

; 882  :         PySequenceMethods *m = v->ob_type->tp_as_sequence;

  00029	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]

; 883  :         Py_DECREF(result);

  0002d	48 8b c8	 mov	 rcx, rax
  00030	49 8b 98 c0 00
	00 00		 mov	 rbx, QWORD PTR [r8+192]
  00037	e8 00 00 00 00	 call	 _Py_DecRef

; 884  :         if (m && m->sq_concat) {

  0003c	48 85 db	 test	 rbx, rbx
  0003f	74 21		 je	 SHORT $LN1@PyNumber_A
  00041	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00045	48 85 c0	 test	 rax, rax
  00048	74 18		 je	 SHORT $LN1@PyNumber_A

; 885  :             return (*m->sq_concat)(v, w);

  0004a	48 8b d6	 mov	 rdx, rsi
  0004d	48 8b cf	 mov	 rcx, rdi

; 888  :     }
; 889  :     return result;
; 890  : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	48 ff e0	 rex_jmp rax
$LN1@PyNumber_A:

; 886  :         }
; 887  :         result = binop_type_error(v, w, "+");

  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MIFGBAGJ@?$CL?$AA@
  00069	48 8b d6	 mov	 rdx, rsi
  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	e8 00 00 00 00	 call	 binop_type_error
$LN2@PyNumber_A:

; 888  :     }
; 889  :     return result;
; 890  : }

  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
PyNumber_Add ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	PyNumber_FloorDivide
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_FloorDivide
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_FloorDivide PROC				; COMDAT

; 930  :     return binary_op(v, w, NB_SLOT(nb_floor_divide), "//");

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02CBLDBPFN@?1?1?$AA@
  00007	41 b8 e8 00 00
	00		 mov	 r8d, 232		; 000000e8H

; 931  : }

  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_FloorDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	PyNumber_TrueDivide
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_TrueDivide
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_TrueDivide PROC				; COMDAT

; 936  :     return binary_op(v, w, NB_SLOT(nb_true_divide), "/");

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01KMDKNFGN@?1?$AA@
  00007	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H

; 937  : }

  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_TrueDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
PUBLIC	PyNumber_Remainder
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Remainder
_TEXT	SEGMENT
v$ = 8
w$ = 16
PyNumber_Remainder PROC					; COMDAT

; 942  :     return binary_op(v, w, NB_SLOT(nb_remainder), "%");

  00000	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01FGNFDNOH@?$CF?$AA@
  00007	41 b8 18 00 00
	00		 mov	 r8d, 24

; 943  : }

  0000d	e9 00 00 00 00	 jmp	 binary_op
PyNumber_Remainder ENDP
_TEXT	ENDS
PUBLIC	PyNumber_Power
; Function compile flags: /Ogtpy
;	COMDAT PyNumber_Power
_TEXT	SEGMENT
v$ = 8
w$ = 16
z$ = 24
PyNumber_Power PROC					; COMDAT

; 948  :     return ternary_op(v, w, z, NB_SLOT(nb_power), "** or pow()");

  00000	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H

; 949  : }

  00006	e9 00 00 00 00	 jmp	 ternary_op
PyNumber_Power ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_iop1 DD imagerel binary_iop1
	DD	imagerel binary_iop1+105
	DD	imagerel $unwind$binary_iop1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_iop1 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT binary_iop1
_TEXT	SEGMENT
v$ = 48
w$ = 56
iop_slot$ = 64
op_slot$ = 72
binary_iop1 PROC					; COMDAT

; 969  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 970  :     PyNumberMethods *mv = v->ob_type->tp_as_number;

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00013	4d 63 d0	 movsxd	 r10, r8d
  00016	41 8b f1	 mov	 esi, r9d
  00019	4c 8b 80 b8 00
	00 00		 mov	 r8, QWORD PTR [rax+184]
  00020	48 8b fa	 mov	 rdi, rdx
  00023	48 8b d9	 mov	 rbx, rcx

; 971  :     if (mv != NULL) {

  00026	4d 85 c0	 test	 r8, r8
  00029	74 20		 je	 SHORT $LN2@binary_iop

; 972  :         binaryfunc slot = NB_BINOP(mv, iop_slot);

  0002b	4f 8b 04 02	 mov	 r8, QWORD PTR [r10+r8]

; 973  :         if (slot) {

  0002f	4d 85 c0	 test	 r8, r8
  00032	74 17		 je	 SHORT $LN2@binary_iop

; 974  :             PyObject *x = (slot)(v, w);

  00034	41 ff d0	 call	 r8

; 975  :             if (x != Py_NotImplemented) {

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0003e	48 3b c1	 cmp	 rax, rcx

; 976  :                 return x;

  00041	75 16		 jne	 SHORT $LN4@binary_iop

; 977  :             }
; 978  :             Py_DECREF(x);

  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@binary_iop:

; 979  :         }
; 980  :     }
; 981  :     return binary_op1(v, w, op_slot);

  0004b	44 8b c6	 mov	 r8d, esi
  0004e	48 8b d7	 mov	 rdx, rdi
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 binary_op1
$LN4@binary_iop:

; 982  : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
binary_iop1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_iop DD imagerel binary_iop
	DD	imagerel binary_iop+68
	DD	imagerel $unwind$binary_iop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_iop DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT binary_iop
_TEXT	SEGMENT
v$ = 48
w$ = 56
iop_slot$ = 64
op_slot$ = 72
op_name$ = 80
binary_iop PROC						; COMDAT

; 987  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 988  :     PyObject *result = binary_iop1(v, w, iop_slot, op_slot);

  00010	e8 00 00 00 00	 call	 binary_iop1

; 989  :     if (result == Py_NotImplemented) {

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0001c	48 3b c1	 cmp	 rax, rcx
  0001f	75 18		 jne	 SHORT $LN1@binary_iop@2

; 990  :         Py_DECREF(result);

  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 _Py_DecRef

; 991  :         return binop_type_error(v, w, op_name);

  00029	4c 8b 44 24 50	 mov	 r8, QWORD PTR op_name$[rsp]
  0002e	48 8b d3	 mov	 rdx, rbx
  00031	48 8b cf	 mov	 rcx, rdi
  00034	e8 00 00 00 00	 call	 binop_type_error
$LN1@binary_iop@2:

; 992  :     }
; 993  :     return result;
; 994  : }

  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
binary_iop ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DHLNPPGH@?$HM?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceOr
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceOr DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceOr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceOr DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02DHLNPPGH@?$HM?$DN?$AA@
CONST	SEGMENT
??_C@_02DHLNPPGH@?$HM?$DN?$AA@ DB '|=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceOr
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceOr PROC					; COMDAT

; 1002 : INPLACE_BINOP(PyNumber_InPlaceOr, nb_inplace_or, nb_or, "|=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	41 b9 78 00 00
	00		 mov	 r9d, 120		; 00000078H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DHLNPPGH@?$HM?$DN?$AA@
  00011	45 8d 41 68	 lea	 r8d, QWORD PTR [r9+104]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop
  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceOr ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MHEGNOJ@?$FO?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceXor
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceXor DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceXor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceXor DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02MHEGNOJ@?$FO?$DN?$AA@
CONST	SEGMENT
??_C@_02MHEGNOJ@?$FO?$DN?$AA@ DB '^=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceXor
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceXor PROC				; COMDAT

; 1003 : INPLACE_BINOP(PyNumber_InPlaceXor, nb_inplace_xor, nb_xor, "^=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	41 b9 70 00 00
	00		 mov	 r9d, 112		; 00000070H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02MHEGNOJ@?$FO?$DN?$AA@
  00011	45 8d 41 68	 lea	 r8d, QWORD PTR [r9+104]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop
  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceXor ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FGJGFEAB@?$CG?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceAnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceAnd DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceAnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceAnd DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02FGJGFEAB@?$CG?$DN?$AA@
CONST	SEGMENT
??_C@_02FGJGFEAB@?$CG?$DN?$AA@ DB '&=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceAnd
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceAnd PROC				; COMDAT

; 1004 : INPLACE_BINOP(PyNumber_InPlaceAnd, nb_inplace_and, nb_and, "&=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	41 b9 68 00 00
	00		 mov	 r9d, 104		; 00000068H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FGJGFEAB@?$CG?$DN?$AA@
  00011	45 8d 41 68	 lea	 r8d, QWORD PTR [r9+104]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop
  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceAnd ENDP
_TEXT	ENDS
PUBLIC	??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@		; `string'
PUBLIC	PyNumber_InPlaceLshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceLshift DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceLshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceLshift DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@
CONST	SEGMENT
??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@ DB '<<=', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceLshift
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceLshift PROC				; COMDAT

; 1005 : INPLACE_BINOP(PyNumber_InPlaceLshift, nb_inplace_lshift, nb_lshift, "<<=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@
  00011	45 8d 41 68	 lea	 r8d, QWORD PTR [r9+104]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop
  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceLshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@		; `string'
PUBLIC	PyNumber_InPlaceRshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceRshift DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceRshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceRshift DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@
CONST	SEGMENT
??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@ DB '>>=', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceRshift
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceRshift PROC				; COMDAT

; 1006 : INPLACE_BINOP(PyNumber_InPlaceRshift, nb_inplace_rshift, nb_rshift, ">>=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	41 b9 60 00 00
	00		 mov	 r9d, 96			; 00000060H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@
  00011	45 8d 41 68	 lea	 r8d, QWORD PTR [r9+104]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop
  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceRshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FKMDLLOA@?9?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceSubtract
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceSubtract DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$PyNumber_InPlaceSubtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceSubtract DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02FKMDLLOA@?9?$DN?$AA@
CONST	SEGMENT
??_C@_02FKMDLLOA@?9?$DN?$AA@ DB '-=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceSubtract
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceSubtract PROC				; COMDAT

; 1007 : INPLACE_BINOP(PyNumber_InPlaceSubtract, nb_inplace_subtract, nb_subtract, "-=")

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FKMDLLOA@?9?$DN?$AA@
  0000b	41 b9 08 00 00
	00		 mov	 r9d, 8
  00011	41 b8 a0 00 00
	00		 mov	 r8d, 160		; 000000a0H
  00017	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001c	e8 00 00 00 00	 call	 binary_iop
  00021	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00025	c3		 ret	 0
PyNumber_InPlaceSubtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_03HPBDNGOI@?1?1?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceFloorDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceFloorDivide DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceFloorDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceFloorDivide DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_03HPBDNGOI@?1?1?$DN?$AA@
CONST	SEGMENT
??_C@_03HPBDNGOI@?1?1?$DN?$AA@ DB '//=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceFloorDivide
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceFloorDivide PROC			; COMDAT

; 1011 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1012 :     return binary_iop(v, w, NB_SLOT(nb_inplace_floor_divide),
; 1013 :                       NB_SLOT(nb_floor_divide), "//=");

  00004	41 b9 e8 00 00
	00		 mov	 r9d, 232		; 000000e8H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03HPBDNGOI@?1?1?$DN?$AA@
  00011	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop

; 1014 : }

  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceFloorDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FJEHGPIO@?1?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceTrueDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceTrueDivide DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$PyNumber_InPlaceTrueDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceTrueDivide DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02FJEHGPIO@?1?$DN?$AA@
CONST	SEGMENT
??_C@_02FJEHGPIO@?1?$DN?$AA@ DB '/=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceTrueDivide
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceTrueDivide PROC				; COMDAT

; 1018 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1019 :     return binary_iop(v, w, NB_SLOT(nb_inplace_true_divide),
; 1020 :                       NB_SLOT(nb_true_divide), "/=");

  00004	41 b9 f0 00 00
	00		 mov	 r9d, 240		; 000000f0H
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FJEHGPIO@?1?$DN?$AA@
  00011	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	e8 00 00 00 00	 call	 binary_iop

; 1021 : }

  0001f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00023	c3		 ret	 0
PyNumber_InPlaceTrueDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FOEOMHFC@?$CL?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceAdd
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceAdd DD imagerel $LN8
	DD	imagerel $LN8+147
	DD	imagerel $unwind$PyNumber_InPlaceAdd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceAdd DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_02FOEOMHFC@?$CL?$DN?$AA@
CONST	SEGMENT
??_C@_02FOEOMHFC@?$CL?$DN?$AA@ DB '+=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceAdd
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_InPlaceAdd PROC				; COMDAT

; 1025 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1026 :     PyObject *result = binary_iop1(v, w, NB_SLOT(nb_inplace_add),
; 1027 :                                    NB_SLOT(nb_add));

  0000f	45 33 c9	 xor	 r9d, r9d
  00012	41 b8 98 00 00
	00		 mov	 r8d, 152		; 00000098H
  00018	48 8b f2	 mov	 rsi, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	e8 00 00 00 00	 call	 binary_iop1

; 1028 :     if (result == Py_NotImplemented) {

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	75 54		 jne	 SHORT $LN4@PyNumber_I

; 1029 :         PySequenceMethods *m = v->ob_type->tp_as_sequence;

  0002f	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]

; 1030 :         Py_DECREF(result);

  00033	48 8b c8	 mov	 rcx, rax
  00036	49 8b 98 c0 00
	00 00		 mov	 rbx, QWORD PTR [r8+192]
  0003d	e8 00 00 00 00	 call	 _Py_DecRef

; 1031 :         if (m != NULL) {

  00042	48 85 db	 test	 rbx, rbx
  00045	74 2a		 je	 SHORT $LN1@PyNumber_I

; 1032 :             binaryfunc f = NULL;
; 1033 :             f = m->sq_inplace_concat;

  00047	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]

; 1034 :             if (f == NULL)

  0004b	48 85 c0	 test	 rax, rax
  0004e	75 09		 jne	 SHORT $LN7@PyNumber_I

; 1035 :                 f = m->sq_concat;

  00050	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 1036 :             if (f != NULL)

  00054	48 85 c0	 test	 rax, rax
  00057	74 18		 je	 SHORT $LN1@PyNumber_I
$LN7@PyNumber_I:

; 1037 :                 return (*f)(v, w);

  00059	48 8b d6	 mov	 rdx, rsi
  0005c	48 8b cf	 mov	 rcx, rdi

; 1040 :     }
; 1041 :     return result;
; 1042 : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	48 ff e0	 rex_jmp rax
$LN1@PyNumber_I:

; 1038 :         }
; 1039 :         result = binop_type_error(v, w, "+=");

  00071	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FOEOMHFC@?$CL?$DN?$AA@
  00078	48 8b d6	 mov	 rdx, rsi
  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	e8 00 00 00 00	 call	 binop_type_error
$LN4@PyNumber_I:

; 1040 :     }
; 1041 :     return result;
; 1042 : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
PyNumber_InPlaceAdd ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FENAOKFI@?$CF?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceRemainder
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceRemainder DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$PyNumber_InPlaceRemainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceRemainder DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02FENAOKFI@?$CF?$DN?$AA@
CONST	SEGMENT
??_C@_02FENAOKFI@?$CF?$DN?$AA@ DB '%=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceRemainder
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceRemainder PROC				; COMDAT

; 1075 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1076 :     return binary_iop(v, w, NB_SLOT(nb_inplace_remainder),
; 1077 :                             NB_SLOT(nb_remainder), "%=");

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FENAOKFI@?$CF?$DN?$AA@
  0000b	41 b9 18 00 00
	00		 mov	 r9d, 24
  00011	41 b8 b0 00 00
	00		 mov	 r8d, 176		; 000000b0H
  00017	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001c	e8 00 00 00 00	 call	 binary_iop

; 1078 : }

  00021	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00025	c3		 ret	 0
PyNumber_InPlaceRemainder ENDP
_TEXT	ENDS
PUBLIC	PyNumber_InPlacePower
; Function compile flags: /Ogtpy
;	COMDAT PyNumber_InPlacePower
_TEXT	SEGMENT
v$ = 8
w$ = 16
z$ = 24
PyNumber_InPlacePower PROC				; COMDAT

; 1083 :     if (v->ob_type->tp_as_number &&
; 1084 :         v->ob_type->tp_as_number->nb_inplace_power != NULL) {

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	4c 8b 88 b8 00
	00 00		 mov	 r9, QWORD PTR [rax+184]
  0000b	4d 85 c9	 test	 r9, r9
  0000e	74 10		 je	 SHORT $LN2@PyNumber_I@2
  00010	49 83 b9 b8 00
	00 00 00	 cmp	 QWORD PTR [r9+184], 0

; 1085 :         return ternary_op(v, w, z, NB_SLOT(nb_inplace_power), "**=");

  00018	41 b9 b8 00 00
	00		 mov	 r9d, 184		; 000000b8H
  0001e	75 06		 jne	 SHORT $LN5@PyNumber_I@2
$LN2@PyNumber_I@2:

; 1086 :     }
; 1087 :     else {
; 1088 :         return ternary_op(v, w, z, NB_SLOT(nb_power), "**=");

  00020	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
$LN5@PyNumber_I@2:

; 1089 :     }
; 1090 : }

  00026	e9 00 00 00 00	 jmp	 ternary_op
PyNumber_InPlacePower ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Negative
;	COMDAT ??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@ DB 'bad '
	DB	'operand type for unary -: ''%.200s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Negative
_TEXT	SEGMENT
o$ = 8
PyNumber_Negative PROC					; COMDAT

; 1098 :     PyNumberMethods *m;
; 1099 : 
; 1100 :     if (o == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@PyNumber_N

; 1107 : }

  00005	e9 00 00 00 00	 jmp	 null_error
$LN2@PyNumber_N:

; 1101 :         return null_error();
; 1102 :     m = o->ob_type->tp_as_number;

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]

; 1103 :     if (m && m->nb_negative)

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 0c		 je	 SHORT $LN1@PyNumber_N
  0001a	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  0001e	48 85 c0	 test	 rax, rax
  00021	74 03		 je	 SHORT $LN1@PyNumber_N

; 1107 : }

  00023	48 ff e0	 rex_jmp rax
$LN1@PyNumber_N:

; 1104 :         return (*m->nb_negative)(o);
; 1105 : 
; 1106 :     return type_error("bad operand type for unary -: '%.200s'", o);

  00026	48 8b d1	 mov	 rdx, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@

; 1107 : }

  00030	e9 00 00 00 00	 jmp	 type_error
PyNumber_Negative ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Positive
;	COMDAT ??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@ DB 'ba'
	DB	'd operand type for unary +: ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Positive
_TEXT	SEGMENT
o$ = 8
PyNumber_Positive PROC					; COMDAT

; 1112 :     PyNumberMethods *m;
; 1113 : 
; 1114 :     if (o == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@PyNumber_P

; 1121 : }

  00005	e9 00 00 00 00	 jmp	 null_error
$LN2@PyNumber_P:

; 1115 :         return null_error();
; 1116 :     m = o->ob_type->tp_as_number;

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]

; 1117 :     if (m && m->nb_positive)

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 0c		 je	 SHORT $LN1@PyNumber_P
  0001a	48 8b 42 38	 mov	 rax, QWORD PTR [rdx+56]
  0001e	48 85 c0	 test	 rax, rax
  00021	74 03		 je	 SHORT $LN1@PyNumber_P

; 1121 : }

  00023	48 ff e0	 rex_jmp rax
$LN1@PyNumber_P:

; 1118 :         return (*m->nb_positive)(o);
; 1119 : 
; 1120 :     return type_error("bad operand type for unary +: '%.200s'", o);

  00026	48 8b d1	 mov	 rdx, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@

; 1121 : }

  00030	e9 00 00 00 00	 jmp	 type_error
PyNumber_Positive ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Invert
;	COMDAT ??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@ DB 'ba'
	DB	'd operand type for unary ~: ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Invert
_TEXT	SEGMENT
o$ = 8
PyNumber_Invert PROC					; COMDAT

; 1126 :     PyNumberMethods *m;
; 1127 : 
; 1128 :     if (o == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@PyNumber_I@3

; 1135 : }

  00005	e9 00 00 00 00	 jmp	 null_error
$LN2@PyNumber_I@3:

; 1129 :         return null_error();
; 1130 :     m = o->ob_type->tp_as_number;

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]

; 1131 :     if (m && m->nb_invert)

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 0c		 je	 SHORT $LN1@PyNumber_I@3
  0001a	48 8b 42 50	 mov	 rax, QWORD PTR [rdx+80]
  0001e	48 85 c0	 test	 rax, rax
  00021	74 03		 je	 SHORT $LN1@PyNumber_I@3

; 1135 : }

  00023	48 ff e0	 rex_jmp rax
$LN1@PyNumber_I@3:

; 1132 :         return (*m->nb_invert)(o);
; 1133 : 
; 1134 :     return type_error("bad operand type for unary ~: '%.200s'", o);

  00026	48 8b d1	 mov	 rdx, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@

; 1135 : }

  00030	e9 00 00 00 00	 jmp	 type_error
PyNumber_Invert ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@ ; `string'
PUBLIC	PyNumber_Absolute
;	COMDAT ??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@
CONST	SEGMENT
??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@ DB 'b'
	DB	'ad operand type for abs(): ''%.200s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Absolute
_TEXT	SEGMENT
o$ = 8
PyNumber_Absolute PROC					; COMDAT

; 1140 :     PyNumberMethods *m;
; 1141 : 
; 1142 :     if (o == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 05		 jne	 SHORT $LN2@PyNumber_A@2

; 1149 : }

  00005	e9 00 00 00 00	 jmp	 null_error
$LN2@PyNumber_A@2:

; 1143 :         return null_error();
; 1144 :     m = o->ob_type->tp_as_number;

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]

; 1145 :     if (m && m->nb_absolute)

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 0c		 je	 SHORT $LN1@PyNumber_A@2
  0001a	48 8b 42 40	 mov	 rax, QWORD PTR [rdx+64]
  0001e	48 85 c0	 test	 rax, rax
  00021	74 03		 je	 SHORT $LN1@PyNumber_A@2

; 1149 : }

  00023	48 ff e0	 rex_jmp rax
$LN1@PyNumber_A@2:

; 1146 :         return m->nb_absolute(o);
; 1147 : 
; 1148 :     return type_error("bad operand type for abs(): '%.200s'", o);

  00026	48 8b d1	 mov	 rdx, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@

; 1149 : }

  00030	e9 00 00 00 00	 jmp	 type_error
PyNumber_Absolute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@ ; `string'
PUBLIC	??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@ ; `string'
PUBLIC	PyNumber_Index
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyNumber_Index DD imagerel $LN15
	DD	imagerel $LN15+242
	DD	imagerel $unwind$PyNumber_Index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Index DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@
CONST	SEGMENT
??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@ DB '''%.20'
	DB	'0s'' object cannot be interpreted as an integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@
CONST	SEGMENT
??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@ DB '__index__'
	DB	' returned non-int (type %.200s)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
CONST	ENDS
;	COMDAT PyNumber_Index
_TEXT	SEGMENT
item$ = 64
PyNumber_Index PROC					; COMDAT

; 1157 : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1158 :     PyObject *result = NULL;
; 1159 :     if (item == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN7@PyNumber_I@4

; 1179 :         return NULL;
; 1180 :     }
; 1181 :     return result;
; 1182 : }

  0000e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN7@PyNumber_I@4:

; 1160 :         return null_error();
; 1161 :     if (PyLong_Check(item)) {

  00018	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0001c	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  00027	74 44		 je	 SHORT $LN6@PyNumber_I@4

; 1162 :         Py_INCREF(item);

  00029	e8 00 00 00 00	 call	 _Py_PXCTX
  0002e	85 c0		 test	 eax, eax
  00030	75 32		 jne	 SHORT $LN11@PyNumber_I@4
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00040	4c 8b cb	 mov	 r9, rbx
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 06		 jne	 SHORT $LN10@PyNumber_I@4
  0005a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005e	74 04		 je	 SHORT $LN11@PyNumber_I@4
$LN10@PyNumber_I@4:
  00060	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@PyNumber_I@4:

; 1163 :         return item;

  00064	48 8b c3	 mov	 rax, rbx

; 1179 :         return NULL;
; 1180 :     }
; 1181 :     return result;
; 1182 : }

  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
$LN6@PyNumber_I@4:

; 1164 :     }
; 1165 :     if (!PyIndex_Check(item)) {

  0006d	49 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [r8+184]
  00074	48 85 c0	 test	 rax, rax
  00077	74 5a		 je	 SHORT $LN4@PyNumber_I@4
  00079	48 8b 90 08 01
	00 00		 mov	 rdx, QWORD PTR [rax+264]
  00080	48 85 d2	 test	 rdx, rdx
  00083	74 4e		 je	 SHORT $LN4@PyNumber_I@4

; 1170 :     }
; 1171 :     result = item->ob_type->tp_as_number->nb_index(item);

  00085	ff d2		 call	 rdx
  00087	48 8b d8	 mov	 rbx, rax

; 1172 :     if (!result || PyLong_CheckExact(result))

  0008a	48 85 c0	 test	 rax, rax
  0008d	74 d5		 je	 SHORT $LN11@PyNumber_I@4
  0008f	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  0009a	4c 3b c0	 cmp	 r8, rax
  0009d	74 c5		 je	 SHORT $LN11@PyNumber_I@4

; 1173 :         return result;
; 1174 :     if (!PyLong_Check(result)) {

  0009f	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  000aa	75 b8		 jne	 SHORT $LN11@PyNumber_I@4

; 1175 :         PyErr_Format(PyExc_TypeError,
; 1176 :                      "__index__ returned non-int (type %.200s)",
; 1177 :                      result->ob_type->tp_name);

  000ac	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@
  000be	e8 00 00 00 00	 call	 PyErr_Format

; 1178 :         Py_DECREF(result);

  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 _Py_DecRef
  000cb	33 c0		 xor	 eax, eax

; 1179 :         return NULL;
; 1180 :     }
; 1181 :     return result;
; 1182 : }

  000cd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d1	5b		 pop	 rbx
  000d2	c3		 ret	 0
$LN4@PyNumber_I@4:

; 1166 :         PyErr_Format(PyExc_TypeError,
; 1167 :                      "'%.200s' object cannot be interpreted "
; 1168 :                      "as an integer", item->ob_type->tp_name);

  000d3	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@
  000e5	e8 00 00 00 00	 call	 PyErr_Format

; 1169 :         return NULL;

  000ea	33 c0		 xor	 eax, eax

; 1179 :         return NULL;
; 1180 :     }
; 1181 :     return result;
; 1182 : }

  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5b		 pop	 rbx
  000f1	c3		 ret	 0
PyNumber_Index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@ ; `string'
PUBLIC	PyNumber_AsSsize_t
EXTRN	_PyLong_Sign:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_GivenExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_AsSsize_t DD imagerel $LN11
	DD	imagerel $LN11+200
	DD	imagerel $unwind$PyNumber_AsSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_AsSsize_t DD 083e01H
	DD	06343eH
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@
CONST	SEGMENT
??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@ DB 'canno'
	DB	't fit ''%.200s'' into an index-sized integer', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_AsSsize_t
_TEXT	SEGMENT
item$ = 48
err$ = 56
PyNumber_AsSsize_t PROC					; COMDAT

; 1188 : {

$LN11:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	48 8b e9	 mov	 rbp, rcx

; 1189 :     Py_ssize_t result;
; 1190 :     PyObject *runerr;
; 1191 :     PyObject *value = PyNumber_Index(item);

  00015	e8 00 00 00 00	 call	 PyNumber_Index
  0001a	48 8b f8	 mov	 rdi, rax

; 1192 :     if (value == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 14		 jne	 SHORT $LN8@PyNumber_A@3

; 1193 :         return -1;

  00022	48 83 c8 ff	 or	 rax, -1

; 1227 :     return result;
; 1228 : }

  00026	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0002b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN8@PyNumber_A@3:

; 1194 : 
; 1195 :     /* We're done if PyLong_AsSsize_t() returns without error. */
; 1196 :     result = PyLong_AsSsize_t(value);

  00036	48 8b c8	 mov	 rcx, rax
  00039	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00043	48 8b d8	 mov	 rbx, rax

; 1197 :     if (result != -1 || !(runerr = PyErr_Occurred()))

  00046	48 83 f8 ff	 cmp	 rax, -1
  0004a	75 5c		 jne	 SHORT $finish$21263
  0004c	e8 00 00 00 00	 call	 PyErr_Occurred
  00051	48 85 c0	 test	 rax, rax
  00054	74 52		 je	 SHORT $finish$21263

; 1198 :         goto finish;
; 1199 : 
; 1200 :     /* Error handling code -- only manage OverflowError differently */
; 1201 :     if (!PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError))

  00056	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  00065	85 c0		 test	 eax, eax
  00067	74 3f		 je	 SHORT $finish$21263

; 1202 :         goto finish;
; 1203 : 
; 1204 :     PyErr_Clear();

  00069	e8 00 00 00 00	 call	 PyErr_Clear

; 1205 :     /* If no error-handling desired then the default clipping
; 1206 :        is sufficient.
; 1207 :      */
; 1208 :     if (!err) {

  0006e	48 85 f6	 test	 rsi, rsi
  00071	75 1e		 jne	 SHORT $LN4@PyNumber_A@3

; 1209 :         assert(PyLong_Check(value));
; 1210 :         /* Whether or not it is less than or equal to
; 1211 :            zero is determined by the sign of ob_size
; 1212 :         */
; 1213 :         if (_PyLong_Sign(value) < 0)

  00073	48 8b cf	 mov	 rcx, rdi
  00076	e8 00 00 00 00	 call	 _PyLong_Sign
  0007b	33 db		 xor	 ebx, ebx
  0007d	85 c0		 test	 eax, eax
  0007f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00089	0f 98 c3	 sets	 bl
  0008c	48 03 d8	 add	 rbx, rax

; 1214 :             result = PY_SSIZE_T_MIN;
; 1215 :         else
; 1216 :             result = PY_SSIZE_T_MAX;
; 1217 :     }
; 1218 :     else {

  0008f	eb 17		 jmp	 SHORT $finish$21263
$LN4@PyNumber_A@3:

; 1219 :         /* Otherwise replace the error with caller's error object. */
; 1220 :         PyErr_Format(err,
; 1221 :                      "cannot fit '%.200s' into an index-sized integer",
; 1222 :                      item->ob_type->tp_name);

  00091	4c 8b 45 58	 mov	 r8, QWORD PTR [rbp+88]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@
  0009c	48 8b ce	 mov	 rcx, rsi
  0009f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000a3	e8 00 00 00 00	 call	 PyErr_Format
$finish$21263:

; 1223 :     }
; 1224 : 
; 1225 :  finish:
; 1226 :     Py_DECREF(value);

  000a8	48 8b cf	 mov	 rcx, rdi
  000ab	e8 00 00 00 00	 call	 _Py_DecRef

; 1227 :     return result;
; 1228 : }

  000b0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ba	48 8b c3	 mov	 rax, rbx
  000bd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
PyNumber_AsSsize_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@ ; `string'
PUBLIC	??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@ ; `string'
PUBLIC	PyNumber_Long
EXTRN	PyLong_FromUnicodeObject:PROC
EXTRN	_PyLong_FromBytes:PROC
EXTRN	PyEval_CallObjectWithKeywords:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	_PyLong_FromNbInt:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyNumber_Long DD imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyNumber_Long DD imagerel $LN21+170
	DD	imagerel $LN21+303
	DD	imagerel $chain$1$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyNumber_Long DD imagerel $LN21+303
	DD	imagerel $LN21+352
	DD	imagerel $chain$3$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyNumber_Long DD imagerel $LN21+352
	DD	imagerel $LN21+371
	DD	imagerel $chain$5$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyNumber_Long DD imagerel $LN21+371
	DD	imagerel $LN21+394
	DD	imagerel $chain$7$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$PyNumber_Long DD imagerel $LN21+394
	DD	imagerel $LN21+439
	DD	imagerel $chain$9$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$PyNumber_Long DD imagerel $LN21+439
	DD	imagerel $LN21+468
	DD	imagerel $chain$11$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$PyNumber_Long DD imagerel $LN21+468
	DD	imagerel $LN21+516
	DD	imagerel $chain$13$PyNumber_Long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$PyNumber_Long DD imagerel $LN21+516
	DD	imagerel $LN21+541
	DD	imagerel $chain$15$PyNumber_Long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$PyNumber_Long DD 020021H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$PyNumber_Long DD 020021H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$PyNumber_Long DD 020021H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$PyNumber_Long DD 020021H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyNumber_Long DD 020021H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyNumber_Long DD 040021H
	DD	0b7400H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyNumber_Long DD 040021H
	DD	0b7400H
	DD	0a6400H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyNumber_Long DD 042321H
	DD	0b7423H
	DD	0a6405H
	DD	imagerel $LN21
	DD	imagerel $LN21+170
	DD	imagerel $unwind$PyNumber_Long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Long DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@
CONST	SEGMENT
??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@ DB 'int('
	DB	') argument must be a string or a number, not ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@
CONST	SEGMENT
??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@ DB '__trunc__ re'
	DB	'turned non-Integral (type %.200s)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
CONST	ENDS
;	COMDAT PyNumber_Long
_TEXT	SEGMENT
buffer_len$ = 64
o$ = 64
buffer$ = 72
PyNumber_Long PROC					; COMDAT

; 1233 : {

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1234 :     PyNumberMethods *m;
; 1235 :     PyObject *trunc_func;
; 1236 :     const char *buffer;
; 1237 :     Py_ssize_t buffer_len;
; 1238 :     _Py_IDENTIFIER(__trunc__);
; 1239 : 
; 1240 :     if (o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN12@PyNumber_L

; 1290 : }

  0000e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN12@PyNumber_L:

; 1241 :         return null_error();
; 1242 :     if (PyLong_CheckExact(o)) {

  00018	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyLong_Type
  00023	48 3b c1	 cmp	 rax, rcx
  00026	75 44		 jne	 SHORT $LN11@PyNumber_L

; 1243 :         Py_INCREF(o);

  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 32		 jne	 SHORT $LN16@PyNumber_L
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003f	4c 8b cb	 mov	 r9, rbx
  00042	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00048	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 06		 jne	 SHORT $LN15@PyNumber_L
  00059	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005d	74 04		 je	 SHORT $LN16@PyNumber_L
$LN15@PyNumber_L:
  0005f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN16@PyNumber_L:

; 1244 :         return o;

  00063	48 8b c3	 mov	 rax, rbx

; 1290 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN11@PyNumber_L:

; 1245 :     }
; 1246 :     m = o->ob_type->tp_as_number;

  0006c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]

; 1247 :     if (m && m->nb_int) { /* This should include subclasses of int */

  00073	48 85 c0	 test	 rax, rax
  00076	74 17		 je	 SHORT $LN10@PyNumber_L
  00078	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00080	74 0d		 je	 SHORT $LN10@PyNumber_L

; 1248 :         return (PyObject *)_PyLong_FromNbInt(o);

  00082	48 8b cb	 mov	 rcx, rbx

; 1290 : }

  00085	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00089	5b		 pop	 rbx
  0008a	e9 00 00 00 00	 jmp	 _PyLong_FromNbInt
$LN10@PyNumber_L:

; 1249 :     }
; 1250 :     trunc_func = _PyObject_LookupSpecial(o, &PyId___trunc__);

  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00095	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0009e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___trunc__@?1??PyNumber_Long@@9@9
  000a3	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  000af	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  000b4	48 8b f0	 mov	 rsi, rax

; 1251 :     if (trunc_func) {

  000b7	48 85 c0	 test	 rax, rax
  000ba	0f 84 b3 00 00
	00		 je	 $LN9@PyNumber_L

; 1252 :         PyObject *truncated = PyEval_CallObject(trunc_func, NULL);

  000c0	45 33 c0	 xor	 r8d, r8d
  000c3	33 d2		 xor	 edx, edx
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  000cd	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 1253 :         PyObject *int_instance;
; 1254 :         Py_DECREF(trunc_func);

  000d2	48 8b ce	 mov	 rcx, rsi
  000d5	48 8b f8	 mov	 rdi, rax
  000d8	e8 00 00 00 00	 call	 _Py_DecRef

; 1255 :         if (truncated == NULL || PyLong_Check(truncated))

  000dd	48 85 ff	 test	 rdi, rdi
  000e0	74 7e		 je	 SHORT $LN7@PyNumber_L
  000e2	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  000e6	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  000f1	75 6d		 jne	 SHORT $LN7@PyNumber_L

; 1257 :         /* __trunc__ is specified to return an Integral type,
; 1258 :            but int() needs to return a int. */
; 1259 :         m = truncated->ob_type->tp_as_number;

  000f3	49 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [r8+184]

; 1260 :         if (m == NULL || m->nb_int == NULL) {

  000fa	48 85 c0	 test	 rax, rax
  000fd	74 30		 je	 SHORT $LN5@PyNumber_L
  000ff	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00107	74 26		 je	 SHORT $LN5@PyNumber_L

; 1267 :         }
; 1268 :         int_instance = (PyObject *)_PyLong_FromNbInt(truncated);

  00109	48 8b cf	 mov	 rcx, rdi
  0010c	e8 00 00 00 00	 call	 _PyLong_FromNbInt

; 1269 :         Py_DECREF(truncated);

  00111	48 8b cf	 mov	 rcx, rdi
  00114	48 8b d8	 mov	 rbx, rax
  00117	e8 00 00 00 00	 call	 _Py_DecRef
  0011c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00121	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1270 :         return int_instance;

  00126	48 8b c3	 mov	 rax, rbx

; 1290 : }

  00129	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012d	5b		 pop	 rbx
  0012e	c3		 ret	 0
$LN5@PyNumber_L:

; 1261 :             PyErr_Format(
; 1262 :                 PyExc_TypeError,
; 1263 :                 "__trunc__ returned non-Integral (type %.200s)",
; 1264 :                 truncated->ob_type->tp_name);

  0012f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@
  00141	e8 00 00 00 00	 call	 PyErr_Format

; 1265 :             Py_DECREF(truncated);

  00146	48 8b cf	 mov	 rcx, rdi
  00149	e8 00 00 00 00	 call	 _Py_DecRef
  0014e	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00153	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1266 :             return NULL;

  00158	33 c0		 xor	 eax, eax

; 1290 : }

  0015a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015e	5b		 pop	 rbx
  0015f	c3		 ret	 0
$LN7@PyNumber_L:
  00160	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1256 :             return truncated;

  00165	48 8b c7	 mov	 rax, rdi
  00168	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 1290 : }

  0016d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00171	5b		 pop	 rbx
  00172	c3		 ret	 0
$LN9@PyNumber_L:

; 1271 :     }
; 1272 :     if (PyErr_Occurred())

  00173	e8 00 00 00 00	 call	 PyErr_Occurred
  00178	48 85 c0	 test	 rax, rax
  0017b	74 0d		 je	 SHORT $LN4@PyNumber_L

; 1273 :         return NULL;

  0017d	33 c0		 xor	 eax, eax
  0017f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1290 : }

  00184	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00188	5b		 pop	 rbx
  00189	c3		 ret	 0
$LN4@PyNumber_L:

; 1274 : 
; 1275 :     if (PyBytes_Check(o))

  0018a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018e	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00194	0f ba e1 1b	 bt	 ecx, 27
  00198	73 1d		 jae	 SHORT $LN3@PyNumber_L

; 1276 :         /* need to do extra error checking that PyLong_FromString()
; 1277 :          * doesn't do.  In particular int('9\x005') must raise an
; 1278 :          * exception, not truncate at the null.
; 1279 :          */
; 1280 :         return _PyLong_FromBytes(PyBytes_AS_STRING(o),
; 1281 :                                  PyBytes_GET_SIZE(o), 10);

  0019a	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0019e	48 8d 4b 78	 lea	 rcx, QWORD PTR [rbx+120]
  001a2	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001a8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1290 : }

  001ad	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b1	5b		 pop	 rbx
  001b2	e9 00 00 00 00	 jmp	 _PyLong_FromBytes
$LN3@PyNumber_L:

; 1282 :     if (PyUnicode_Check(o))

  001b7	0f ba e1 1c	 bt	 ecx, 28

; 1283 :         /* The above check is done in PyLong_FromUnicode(). */
; 1284 :         return PyLong_FromUnicodeObject(o, 10);

  001bb	48 8b cb	 mov	 rcx, rbx
  001be	73 14		 jae	 SHORT $LN2@PyNumber_L
  001c0	ba 0a 00 00 00	 mov	 edx, 10
  001c5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1290 : }

  001ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ce	5b		 pop	 rbx
  001cf	e9 00 00 00 00	 jmp	 PyLong_FromUnicodeObject
$LN2@PyNumber_L:

; 1285 :     if (!PyObject_AsCharBuffer(o, &buffer, &buffer_len))

  001d4	4c 8d 44 24 40	 lea	 r8, QWORD PTR buffer_len$[rsp]
  001d9	48 8d 54 24 48	 lea	 rdx, QWORD PTR buffer$[rsp]
  001de	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  001e3	85 c0		 test	 eax, eax
  001e5	75 1d		 jne	 SHORT $LN1@PyNumber_L

; 1286 :         return _PyLong_FromBytes(buffer, buffer_len, 10);

  001e7	48 8b 54 24 40	 mov	 rdx, QWORD PTR buffer_len$[rsp]
  001ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  001f1	44 8d 40 0a	 lea	 r8d, QWORD PTR [rax+10]
  001f5	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1290 : }

  001fa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fe	5b		 pop	 rbx
  001ff	e9 00 00 00 00	 jmp	 _PyLong_FromBytes
$LN1@PyNumber_L:

; 1287 : 
; 1288 :     return type_error("int() argument must be a string or a "
; 1289 :                       "number, not '%.200s'", o);

  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@
  0020b	48 8b d3	 mov	 rdx, rbx
  0020e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1290 : }

  00213	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00217	5b		 pop	 rbx
  00218	e9 00 00 00 00	 jmp	 type_error
PyNumber_Long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@ ; `string'
PUBLIC	PyNumber_Float
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyFloat_FromString:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Float DD imagerel $LN8
	DD	imagerel $LN8+191
	DD	imagerel $unwind$PyNumber_Float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Float DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@
CONST	SEGMENT
??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@ DB '__float__'
	DB	' returned non-float (type %.200s)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Float
_TEXT	SEGMENT
o$ = 48
PyNumber_Float PROC					; COMDAT

; 1294 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1295 :     PyNumberMethods *m;
; 1296 : 
; 1297 :     if (o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN5@PyNumber_F

; 1316 : }

  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN5@PyNumber_F:

; 1298 :         return null_error();
; 1299 :     m = o->ob_type->tp_as_number;

  00018	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001c	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 1300 :     if (m && m->nb_float) { /* This should include subclasses of float */

  00023	48 85 c0	 test	 rax, rax
  00026	74 66		 je	 SHORT $LN4@PyNumber_F
  00028	48 8b 90 90 00
	00 00		 mov	 rdx, QWORD PTR [rax+144]
  0002f	48 85 d2	 test	 rdx, rdx
  00032	74 5a		 je	 SHORT $LN4@PyNumber_F

; 1301 :         PyObject *res = m->nb_float(o);

  00034	48 8b cb	 mov	 rcx, rbx
  00037	ff d2		 call	 rdx
  00039	48 8b d8	 mov	 rbx, rax

; 1302 :         if (res && !PyFloat_Check(res)) {

  0003c	48 85 c0	 test	 rax, rax
  0003f	74 44		 je	 SHORT $LN3@PyNumber_F
  00041	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0004c	48 3b ca	 cmp	 rcx, rdx
  0004f	74 34		 je	 SHORT $LN3@PyNumber_F
  00051	e8 00 00 00 00	 call	 PyType_IsSubtype
  00056	85 c0		 test	 eax, eax
  00058	75 2b		 jne	 SHORT $LN3@PyNumber_F

; 1303 :             PyErr_Format(PyExc_TypeError,
; 1304 :               "__float__ returned non-float (type %.200s)",
; 1305 :               res->ob_type->tp_name);

  0005a	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@
  0006c	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00070	e8 00 00 00 00	 call	 PyErr_Format

; 1306 :             Py_DECREF(res);

  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 1307 :             return NULL;

  0007d	33 c0		 xor	 eax, eax

; 1316 : }

  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
$LN3@PyNumber_F:

; 1308 :         }
; 1309 :         return res;

  00085	48 8b c3	 mov	 rax, rbx

; 1316 : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5b		 pop	 rbx
  0008d	c3		 ret	 0
$LN4@PyNumber_F:

; 1310 :     }
; 1311 :     if (PyFloat_Check(o)) { /* A float subclass with nb_float == NULL */

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00095	48 3b ca	 cmp	 rcx, rdx
  00098	74 16		 je	 SHORT $LN1@PyNumber_F
  0009a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009f	85 c0		 test	 eax, eax
  000a1	75 0d		 jne	 SHORT $LN1@PyNumber_F

; 1314 :     }
; 1315 :     return PyFloat_FromString(o);

  000a3	48 8b cb	 mov	 rcx, rbx

; 1316 : }

  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5b		 pop	 rbx
  000ab	e9 00 00 00 00	 jmp	 PyFloat_FromString
$LN1@PyNumber_F:

; 1312 :         PyFloatObject *po = (PyFloatObject *)o;
; 1313 :         return PyFloat_FromDouble(po->ob_fval);

  000b0	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]

; 1316 : }

  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	5b		 pop	 rbx
  000ba	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
PyNumber_Float ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@ ; `string'
PUBLIC	PyNumber_ToBase
EXTRN	PyExc_ValueError:QWORD
EXTRN	_PyLong_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_ToBase DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$PyNumber_ToBase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_ToBase DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@
CONST	SEGMENT
??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@ DB 'PyNumber_T'
	DB	'oBase: index not int', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_ToBase
_TEXT	SEGMENT
n$ = 48
base$ = 56
PyNumber_ToBase PROC					; COMDAT

; 1321 : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b f2		 mov	 esi, edx

; 1322 :     PyObject *res = NULL;

  00011	33 ff		 xor	 edi, edi

; 1323 :     PyObject *index = PyNumber_Index(n);

  00013	e8 00 00 00 00	 call	 PyNumber_Index
  00018	48 8b d8	 mov	 rbx, rax

; 1324 : 
; 1325 :     if (!index)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 10		 jne	 SHORT $LN3@PyNumber_T

; 1335 :     return res;
; 1336 : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN3@PyNumber_T:

; 1326 :         return NULL;
; 1327 :     if (PyLong_Check(index))

  00030	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00034	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0003e	74 0f		 je	 SHORT $LN2@PyNumber_T

; 1328 :         res = _PyLong_Format(index, base);

  00040	8b d6		 mov	 edx, esi
  00042	48 8b cb	 mov	 rcx, rbx
  00045	e8 00 00 00 00	 call	 _PyLong_Format
  0004a	48 8b f8	 mov	 rdi, rax

; 1329 :     else

  0004d	eb 13		 jmp	 SHORT $LN1@PyNumber_T
$LN2@PyNumber_T:

; 1330 :         /* It should not be possible to get here, as
; 1331 :            PyNumber_Index already has a check for the same
; 1332 :            condition */
; 1333 :         PyErr_SetString(PyExc_ValueError, "PyNumber_ToBase: index not int");

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@
  0005d	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyNumber_T:

; 1334 :     Py_DECREF(index);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 _Py_DecRef

; 1335 :     return res;
; 1336 : }

  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00074	48 8b c7	 mov	 rax, rdi
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
PyNumber_ToBase ENDP
_TEXT	ENDS
PUBLIC	PySequence_Check
; Function compile flags: /Ogtpy
;	COMDAT PySequence_Check
_TEXT	SEGMENT
s$ = 8
PySequence_Check PROC					; COMDAT

; 1344 :     if (PyDict_Check(s))

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H

; 1345 :         return 0;

  0000e	75 19		 jne	 SHORT $LN4@PySequence

; 1346 :     return s != NULL && s->ob_type->tp_as_sequence &&
; 1347 :         s->ob_type->tp_as_sequence->sq_item != NULL;

  00010	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00017	48 85 c0	 test	 rax, rax
  0001a	74 0d		 je	 SHORT $LN4@PySequence
  0001c	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00021	74 06		 je	 SHORT $LN4@PySequence
  00023	b8 01 00 00 00	 mov	 eax, 1

; 1348 : }

  00028	c3		 ret	 0
$LN4@PySequence:

; 1346 :     return s != NULL && s->ob_type->tp_as_sequence &&
; 1347 :         s->ob_type->tp_as_sequence->sq_item != NULL;

  00029	33 c0		 xor	 eax, eax

; 1348 : }

  0002b	c3		 ret	 0
PySequence_Check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@ ; `string'
PUBLIC	PySequence_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Size DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$PySequence_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Size DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
CONST	SEGMENT
??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@ DB 'obje'
	DB	'ct of type ''%.200s'' has no len()', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_Size
_TEXT	SEGMENT
s$ = 48
PySequence_Size PROC					; COMDAT

; 1352 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1353 :     PySequenceMethods *m;
; 1354 : 
; 1355 :     if (s == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 0e		 jne	 SHORT $LN2@PySequence@2

; 1356 :         null_error();

  00009	e8 00 00 00 00	 call	 null_error

; 1365 :     return -1;

  0000e	48 83 c8 ff	 or	 rax, -1

; 1366 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@PySequence@2:

; 1357 :         return -1;
; 1358 :     }
; 1359 : 
; 1360 :     m = s->ob_type->tp_as_sequence;

  00017	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001b	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]

; 1361 :     if (m && m->sq_length)

  00022	48 85 d2	 test	 rdx, rdx
  00025	74 0f		 je	 SHORT $LN1@PySequence@2
  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 07		 je	 SHORT $LN1@PySequence@2

; 1366 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	48 ff e0	 rex_jmp rax
$LN1@PySequence@2:

; 1362 :         return m->sq_length(s);
; 1363 : 
; 1364 :     type_error("object of type '%.200s' has no len()", s);

  00036	48 8b d1	 mov	 rdx, rcx
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
  00040	e8 00 00 00 00	 call	 type_error

; 1365 :     return -1;

  00045	48 83 c8 ff	 or	 rax, -1

; 1366 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
PySequence_Size ENDP
_TEXT	ENDS
PUBLIC	PySequence_Length
; Function compile flags: /Ogtpy
;	COMDAT PySequence_Length
_TEXT	SEGMENT
s$ = 8
PySequence_Length PROC					; COMDAT

; 1372 :     return PySequence_Size(s);
; 1373 : }

  00000	e9 00 00 00 00	 jmp	 PySequence_Size
PySequence_Length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@ ; `string'
PUBLIC	PySequence_Concat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Concat DD imagerel $LN8
	DD	imagerel $LN8+141
	DD	imagerel $unwind$PySequence_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Concat DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
CONST	SEGMENT
??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@ DB '''%.2'
	DB	'00s'' object can''t be concatenated', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_Concat
_TEXT	SEGMENT
s$ = 48
o$ = 56
PySequence_Concat PROC					; COMDAT

; 1378 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1379 :     PySequenceMethods *m;
; 1380 : 
; 1381 :     if (s == NULL || o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 74		 je	 SHORT $LN4@PySequence@3
  0000e	48 85 d2	 test	 rdx, rdx
  00011	74 6f		 je	 SHORT $LN4@PySequence@3

; 1383 : 
; 1384 :     m = s->ob_type->tp_as_sequence;

  00013	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00017	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 1385 :     if (m && m->sq_concat)

  0001e	48 85 c9	 test	 rcx, rcx
  00021	74 14		 je	 SHORT $LN3@PySequence@3
  00023	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00027	48 85 c0	 test	 rax, rax
  0002a	74 0b		 je	 SHORT $LN3@PySequence@3

; 1386 :         return m->sq_concat(s, o);

  0002c	48 8b cb	 mov	 rcx, rbx

; 1398 : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	48 ff e0	 rex_jmp rax
$LN3@PySequence@3:

; 1387 : 
; 1388 :     /* Instances of user classes defining an __add__() method only
; 1389 :        have an nb_add slot, not an sq_concat slot.      So we fall back
; 1390 :        to nb_add if both arguments appear to be sequences. */
; 1391 :     if (PySequence_Check(s) && PySequence_Check(o)) {

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 PySequence_Check
  0003f	85 c0		 test	 eax, eax
  00041	74 2b		 je	 SHORT $LN2@PySequence@3
  00043	48 8b ca	 mov	 rcx, rdx
  00046	e8 00 00 00 00	 call	 PySequence_Check
  0004b	85 c0		 test	 eax, eax
  0004d	74 1f		 je	 SHORT $LN2@PySequence@3

; 1392 :         PyObject *result = binary_op1(s, o, NB_SLOT(nb_add));

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 binary_op1

; 1393 :         if (result != Py_NotImplemented)

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00061	48 3b c1	 cmp	 rax, rcx

; 1394 :             return result;

  00064	75 21		 jne	 SHORT $LN6@PySequence@3

; 1395 :         Py_DECREF(result);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PySequence@3:

; 1396 :     }
; 1397 :     return type_error("'%.200s' object can't be concatenated", s);

  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
  00075	48 8b d3	 mov	 rdx, rbx

; 1398 : }

  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	e9 00 00 00 00	 jmp	 type_error
$LN4@PySequence@3:

; 1382 :         return null_error();

  00082	e8 00 00 00 00	 call	 null_error
$LN6@PySequence@3:

; 1398 : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
PySequence_Concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@ ; `string'
PUBLIC	PySequence_Repeat
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Repeat DD imagerel $LN10
	DD	imagerel $LN10+63
	DD	imagerel $unwind$PySequence_Repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySequence_Repeat DD imagerel $LN10+63
	DD	imagerel $LN10+114
	DD	imagerel $chain$1$PySequence_Repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_Repeat DD imagerel $LN10+114
	DD	imagerel $LN10+173
	DD	imagerel $chain$3$PySequence_Repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PySequence_Repeat DD imagerel $LN10+173
	DD	imagerel $LN10+211
	DD	imagerel $chain$5$PySequence_Repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PySequence_Repeat DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN10
	DD	imagerel $LN10+63
	DD	imagerel $unwind$PySequence_Repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_Repeat DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN10
	DD	imagerel $LN10+63
	DD	imagerel $unwind$PySequence_Repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySequence_Repeat DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel $LN10
	DD	imagerel $LN10+63
	DD	imagerel $unwind$PySequence_Repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Repeat DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
CONST	SEGMENT
??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@ DB '''%.2'
	DB	'00s'' object can''t be repeated', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_Repeat
_TEXT	SEGMENT
o$ = 48
count$ = 56
PySequence_Repeat PROC					; COMDAT

; 1402 : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1403 :     PySequenceMethods *m;
; 1404 : 
; 1405 :     if (o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN5@PySequence@4

; 1427 : }

  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN5@PySequence@4:

; 1406 :         return null_error();
; 1407 : 
; 1408 :     m = o->ob_type->tp_as_sequence;

  00018	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001c	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 1409 :     if (m && m->sq_repeat)

  00023	48 85 c9	 test	 rcx, rcx
  00026	74 14		 je	 SHORT $LN4@PySequence@4
  00028	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 0b		 je	 SHORT $LN4@PySequence@4

; 1410 :         return m->sq_repeat(o, count);

  00031	48 8b cb	 mov	 rcx, rbx

; 1427 : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	48 ff e0	 rex_jmp rax
$LN4@PySequence@4:

; 1411 : 
; 1412 :     /* Instances of user classes defining a __mul__() method only
; 1413 :        have an nb_multiply slot, not an sq_repeat slot. so we fall back
; 1414 :        to nb_multiply if o appears to be a sequence. */
; 1415 :     if (PySequence_Check(o)) {

  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00044	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00049	e8 00 00 00 00	 call	 PySequence_Check
  0004e	85 c0		 test	 eax, eax
  00050	74 63		 je	 SHORT $LN3@PySequence@4

; 1416 :         PyObject *n, *result;
; 1417 :         n = PyLong_FromSsize_t(count);

  00052	48 8b ca	 mov	 rcx, rdx
  00055	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0005a	48 8b f0	 mov	 rsi, rax

; 1418 :         if (n == NULL)

  0005d	48 85 c0	 test	 rax, rax
  00060	75 10		 jne	 SHORT $LN2@PySequence@4
  00062	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00067	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1427 : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
$LN2@PySequence@4:

; 1419 :             return NULL;
; 1420 :         result = binary_op1(o, n, NB_SLOT(nb_multiply));

  00072	41 b8 10 00 00
	00		 mov	 r8d, 16
  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 binary_op1

; 1421 :         Py_DECREF(n);

  00083	48 8b ce	 mov	 rcx, rsi
  00086	48 8b f8	 mov	 rdi, rax
  00089	e8 00 00 00 00	 call	 _Py_DecRef

; 1422 :         if (result != Py_NotImplemented)

  0008e	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_NotImplementedStruct
  00095	49 3b fb	 cmp	 rdi, r11
  00098	74 13		 je	 SHORT $LN1@PySequence@4

; 1423 :             return result;

  0009a	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0009f	48 8b c7	 mov	 rax, rdi
  000a2	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1427 : }

  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5b		 pop	 rbx
  000ac	c3		 ret	 0
$LN1@PySequence@4:

; 1424 :         Py_DECREF(result);

  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PySequence@4:

; 1425 :     }
; 1426 :     return type_error("'%.200s' object can't be repeated", o);

  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
  000bc	48 8b d3	 mov	 rdx, rbx
  000bf	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000c4	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1427 : }

  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5b		 pop	 rbx
  000ce	e9 00 00 00 00	 jmp	 type_error
PySequence_Repeat ENDP
_TEXT	ENDS
PUBLIC	PySequence_InPlaceConcat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_InPlaceConcat DD imagerel $LN10
	DD	imagerel $LN10+160
	DD	imagerel $unwind$PySequence_InPlaceConcat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_InPlaceConcat DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySequence_InPlaceConcat
_TEXT	SEGMENT
s$ = 48
o$ = 56
PySequence_InPlaceConcat PROC				; COMDAT

; 1431 : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1432 :     PySequenceMethods *m;
; 1433 : 
; 1434 :     if (s == NULL || o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 83 00 00
	00		 je	 $LN5@PySequence@5
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 7e		 je	 SHORT $LN5@PySequence@5

; 1436 : 
; 1437 :     m = s->ob_type->tp_as_sequence;

  00017	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001b	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 1438 :     if (m && m->sq_inplace_concat)

  00022	48 85 c9	 test	 rcx, rcx
  00025	74 1d		 je	 SHORT $LN3@PySequence@5
  00027	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 0b		 je	 SHORT $LN4@PySequence@5
$LN9@PySequence@5:

; 1439 :         return m->sq_inplace_concat(s, o);

  00030	48 8b cb	 mov	 rcx, rbx

; 1451 : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	48 ff e0	 rex_jmp rax
$LN4@PySequence@5:

; 1440 :     if (m && m->sq_concat)

  0003b	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0003f	48 85 c0	 test	 rax, rax

; 1441 :         return m->sq_concat(s, o);

  00042	75 ec		 jne	 SHORT $LN9@PySequence@5
$LN3@PySequence@5:

; 1442 : 
; 1443 :     if (PySequence_Check(s) && PySequence_Check(o)) {

  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 PySequence_Check
  0004c	85 c0		 test	 eax, eax
  0004e	74 31		 je	 SHORT $LN2@PySequence@5
  00050	48 8b ca	 mov	 rcx, rdx
  00053	e8 00 00 00 00	 call	 PySequence_Check
  00058	85 c0		 test	 eax, eax
  0005a	74 25		 je	 SHORT $LN2@PySequence@5

; 1444 :         PyObject *result = binary_iop1(s, o, NB_SLOT(nb_inplace_add),
; 1445 :                                        NB_SLOT(nb_add));

  0005c	45 33 c9	 xor	 r9d, r9d
  0005f	41 b8 98 00 00
	00		 mov	 r8d, 152		; 00000098H
  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 binary_iop1

; 1446 :         if (result != Py_NotImplemented)

  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00074	48 3b c1	 cmp	 rax, rcx

; 1447 :             return result;

  00077	75 21		 jne	 SHORT $LN7@PySequence@5

; 1448 :         Py_DECREF(result);

  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PySequence@5:

; 1449 :     }
; 1450 :     return type_error("'%.200s' object can't be concatenated", s);

  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
  00088	48 8b d3	 mov	 rdx, rbx

; 1451 : }

  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5b		 pop	 rbx
  00090	e9 00 00 00 00	 jmp	 type_error
$LN5@PySequence@5:

; 1435 :         return null_error();

  00095	e8 00 00 00 00	 call	 null_error
$LN7@PySequence@5:

; 1451 : }

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
PySequence_InPlaceConcat ENDP
_TEXT	ENDS
PUBLIC	PySequence_InPlaceRepeat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_InPlaceRepeat DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$PySequence_InPlaceRepeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySequence_InPlaceRepeat DD imagerel $LN12+72
	DD	imagerel $LN12+123
	DD	imagerel $chain$1$PySequence_InPlaceRepeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_InPlaceRepeat DD imagerel $LN12+123
	DD	imagerel $LN12+188
	DD	imagerel $chain$3$PySequence_InPlaceRepeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PySequence_InPlaceRepeat DD imagerel $LN12+188
	DD	imagerel $LN12+226
	DD	imagerel $chain$5$PySequence_InPlaceRepeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PySequence_InPlaceRepeat DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$PySequence_InPlaceRepeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_InPlaceRepeat DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$PySequence_InPlaceRepeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySequence_InPlaceRepeat DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$PySequence_InPlaceRepeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_InPlaceRepeat DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySequence_InPlaceRepeat
_TEXT	SEGMENT
o$ = 48
count$ = 56
PySequence_InPlaceRepeat PROC				; COMDAT

; 1455 : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1456 :     PySequenceMethods *m;
; 1457 : 
; 1458 :     if (o == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN6@PySequence@6

; 1480 : }

  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN6@PySequence@6:

; 1459 :         return null_error();
; 1460 : 
; 1461 :     m = o->ob_type->tp_as_sequence;

  00018	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001c	48 8b 88 c0 00
	00 00		 mov	 rcx, QWORD PTR [rax+192]

; 1462 :     if (m && m->sq_inplace_repeat)

  00023	48 85 c9	 test	 rcx, rcx
  00026	74 1d		 je	 SHORT $LN4@PySequence@6
  00028	48 8b 41 48	 mov	 rax, QWORD PTR [rcx+72]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 0b		 je	 SHORT $LN5@PySequence@6
$LN11@PySequence@6:

; 1463 :         return m->sq_inplace_repeat(o, count);

  00031	48 8b cb	 mov	 rcx, rbx

; 1480 : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	48 ff e0	 rex_jmp rax
$LN5@PySequence@6:

; 1464 :     if (m && m->sq_repeat)

  0003c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00040	48 85 c0	 test	 rax, rax

; 1465 :         return m->sq_repeat(o, count);

  00043	75 ec		 jne	 SHORT $LN11@PySequence@6
$LN4@PySequence@6:

; 1466 : 
; 1467 :     if (PySequence_Check(o)) {

  00045	48 8b cb	 mov	 rcx, rbx
  00048	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0004d	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00052	e8 00 00 00 00	 call	 PySequence_Check
  00057	85 c0		 test	 eax, eax
  00059	74 69		 je	 SHORT $LN3@PySequence@6

; 1468 :         PyObject *n, *result;
; 1469 :         n = PyLong_FromSsize_t(count);

  0005b	48 8b ca	 mov	 rcx, rdx
  0005e	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00063	48 8b f0	 mov	 rsi, rax

; 1470 :         if (n == NULL)

  00066	48 85 c0	 test	 rax, rax
  00069	75 10		 jne	 SHORT $LN2@PySequence@6
  0006b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00070	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1480 : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
$LN2@PySequence@6:

; 1471 :             return NULL;
; 1472 :         result = binary_iop1(o, n, NB_SLOT(nb_inplace_multiply),
; 1473 :                              NB_SLOT(nb_multiply));

  0007b	41 b9 10 00 00
	00		 mov	 r9d, 16
  00081	41 b8 a8 00 00
	00		 mov	 r8d, 168		; 000000a8H
  00087	48 8b d0	 mov	 rdx, rax
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 binary_iop1

; 1474 :         Py_DECREF(n);

  00092	48 8b ce	 mov	 rcx, rsi
  00095	48 8b f8	 mov	 rdi, rax
  00098	e8 00 00 00 00	 call	 _Py_DecRef

; 1475 :         if (result != Py_NotImplemented)

  0009d	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_NotImplementedStruct
  000a4	49 3b fb	 cmp	 rdi, r11
  000a7	74 13		 je	 SHORT $LN1@PySequence@6

; 1476 :             return result;

  000a9	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000ae	48 8b c7	 mov	 rax, rdi
  000b1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1480 : }

  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5b		 pop	 rbx
  000bb	c3		 ret	 0
$LN1@PySequence@6:

; 1477 :         Py_DECREF(result);

  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PySequence@6:

; 1478 :     }
; 1479 :     return type_error("'%.200s' object can't be repeated", o);

  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
  000cb	48 8b d3	 mov	 rdx, rbx
  000ce	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000d3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1480 : }

  000d8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dc	5b		 pop	 rbx
  000dd	e9 00 00 00 00	 jmp	 type_error
PySequence_InPlaceRepeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
PUBLIC	PySequence_GetItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_GetItem DD imagerel $LN9
	DD	imagerel $LN9+40
	DD	imagerel $unwind$PySequence_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySequence_GetItem DD imagerel $LN9+40
	DD	imagerel $LN9+102
	DD	imagerel $chain$0$PySequence_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PySequence_GetItem DD imagerel $LN9+102
	DD	imagerel $LN9+133
	DD	imagerel $chain$2$PySequence_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PySequence_GetItem DD imagerel $LN9+133
	DD	imagerel $LN9+163
	DD	imagerel $chain$4$PySequence_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PySequence_GetItem DD 020021H
	DD	066400H
	DD	imagerel $LN9
	DD	imagerel $LN9+40
	DD	imagerel $unwind$PySequence_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PySequence_GetItem DD 020021H
	DD	066400H
	DD	imagerel $LN9
	DD	imagerel $LN9+40
	DD	imagerel $unwind$PySequence_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySequence_GetItem DD 020521H
	DD	066405H
	DD	imagerel $LN9
	DD	imagerel $LN9+40
	DD	imagerel $unwind$PySequence_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_GetItem DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support indexing', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_GetItem
_TEXT	SEGMENT
s$ = 48
i$ = 56
PySequence_GetItem PROC					; COMDAT

; 1484 : {

$LN9:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1485 :     PySequenceMethods *m;
; 1486 : 
; 1487 :     if (s == NULL)

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 0f		 jne	 SHORT $LN5@PySequence@7

; 1504 : }

  00015	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5f		 pop	 rdi
  0001f	e9 00 00 00 00	 jmp	 null_error
$LN5@PySequence@7:

; 1488 :         return null_error();
; 1489 : 
; 1490 :     m = s->ob_type->tp_as_sequence;

  00024	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00028	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002d	48 8b b0 c0 00
	00 00		 mov	 rsi, QWORD PTR [rax+192]

; 1491 :     if (m && m->sq_item) {

  00034	48 85 f6	 test	 rsi, rsi
  00037	74 4c		 je	 SHORT $LN4@PySequence@7
  00039	48 83 7e 18 00	 cmp	 QWORD PTR [rsi+24], 0
  0003e	74 45		 je	 SHORT $LN4@PySequence@7

; 1492 :         if (i < 0) {

  00040	48 85 d2	 test	 rdx, rdx
  00043	79 24		 jns	 SHORT $LN2@PySequence@7

; 1493 :             if (m->sq_length) {

  00045	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00048	48 85 c0	 test	 rax, rax
  0004b	74 1c		 je	 SHORT $LN2@PySequence@7

; 1494 :                 Py_ssize_t l = (*m->sq_length)(s);

  0004d	ff d0		 call	 rax

; 1495 :                 if (l < 0)

  0004f	48 85 c0	 test	 rax, rax
  00052	79 12		 jns	 SHORT $LN1@PySequence@7

; 1496 :                     return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1504 : }

  0005b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN1@PySequence@7:

; 1497 :                 i += l;

  00066	48 03 f8	 add	 rdi, rax
$LN2@PySequence@7:

; 1498 :             }
; 1499 :         }
; 1500 :         return m->sq_item(s, i);

  00069	48 8b d7	 mov	 rdx, rdi
  0006c	48 8b cb	 mov	 rcx, rbx

; 1504 : }

  0006f	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 1498 :             }
; 1499 :         }
; 1500 :         return m->sq_item(s, i);

  00073	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1504 : }

  00078	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	48 ff e0	 rex_jmp rax
$LN4@PySequence@7:

; 1501 :     }
; 1502 : 
; 1503 :     return type_error("'%.200s' object does not support indexing", s);

  00085	48 8b d1	 mov	 rdx, rcx
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@
  0008f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1504 : }

  00094	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5f		 pop	 rdi
  0009e	e9 00 00 00 00	 jmp	 type_error
PySequence_GetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@ ; `string'
PUBLIC	PySequence_GetSlice
EXTRN	_PySlice_FromIndices:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_GetSlice DD imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$PySequence_GetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySequence_GetSlice DD imagerel $LN8+31
	DD	imagerel $LN8+95
	DD	imagerel $chain$1$PySequence_GetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_GetSlice DD imagerel $LN8+95
	DD	imagerel $LN8+134
	DD	imagerel $chain$3$PySequence_GetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PySequence_GetSlice DD imagerel $LN8+134
	DD	imagerel $LN8+159
	DD	imagerel $chain$5$PySequence_GetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PySequence_GetSlice DD 020021H
	DD	077400H
	DD	imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$PySequence_GetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_GetSlice DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$PySequence_GetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySequence_GetSlice DD 042321H
	DD	066423H
	DD	077405H
	DD	imagerel $LN8
	DD	imagerel $LN8+31
	DD	imagerel $unwind$PySequence_GetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_GetSlice DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@
CONST	SEGMENT
??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@ DB '''%.2'
	DB	'00s'' object is unsliceable', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_GetSlice
_TEXT	SEGMENT
s$ = 48
i1$ = 56
i2$ = 64
PySequence_GetSlice PROC				; COMDAT

; 1508 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b ca	 mov	 r9, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1509 :     PyMappingMethods *mp;
; 1510 : 
; 1511 :     if (!s) return null_error();

  0000c	48 85 c9	 test	 rcx, rcx
  0000f	75 0a		 jne	 SHORT $LN3@PySequence@8

; 1525 : }

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	e9 00 00 00 00	 jmp	 null_error
$LN3@PySequence@8:

; 1512 : 
; 1513 :     mp = s->ob_type->tp_as_mapping;

  0001b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00024	48 8b b8 c8 00
	00 00		 mov	 rdi, QWORD PTR [rax+200]

; 1514 :     if (mp && mp->mp_subscript) {

  0002b	48 85 ff	 test	 rdi, rdi
  0002e	74 56		 je	 SHORT $LN2@PySequence@8
  00030	48 83 7f 08 00	 cmp	 QWORD PTR [rdi+8], 0
  00035	74 4f		 je	 SHORT $LN2@PySequence@8

; 1515 :         PyObject *res;
; 1516 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  00037	49 8b d0	 mov	 rdx, r8
  0003a	49 8b c9	 mov	 rcx, r9
  0003d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00042	e8 00 00 00 00	 call	 _PySlice_FromIndices
  00047	48 8b f0	 mov	 rsi, rax

; 1517 :         if (!slice)

  0004a	48 85 c0	 test	 rax, rax
  0004d	75 10		 jne	 SHORT $LN1@PySequence@8
  0004f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00054	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1525 : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
$LN1@PySequence@8:

; 1518 :             return NULL;
; 1519 :         res = mp->mp_subscript(s, slice);

  0005f	48 8b d0	 mov	 rdx, rax
  00062	48 8b cb	 mov	 rcx, rbx
  00065	ff 57 08	 call	 QWORD PTR [rdi+8]

; 1520 :         Py_DECREF(slice);

  00068	48 8b ce	 mov	 rcx, rsi
  0006b	48 8b d8	 mov	 rbx, rax
  0006e	e8 00 00 00 00	 call	 _Py_DecRef
  00073	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00078	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1521 :         return res;

  0007d	48 8b c3	 mov	 rax, rbx

; 1525 : }

  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
$LN2@PySequence@8:

; 1522 :     }
; 1523 : 
; 1524 :     return type_error("'%.200s' object is unsliceable", s);

  00086	48 8b d1	 mov	 rdx, rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@
  00090	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1525 : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5b		 pop	 rbx
  0009a	e9 00 00 00 00	 jmp	 type_error
PySequence_GetSlice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
PUBLIC	PySequence_SetItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_SetItem DD imagerel $LN10
	DD	imagerel $LN10+157
	DD	imagerel $unwind$PySequence_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_SetItem DD 083e01H
	DD	06743eH
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT ??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support item assignment', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_SetItem
_TEXT	SEGMENT
s$ = 48
i$ = 56
o$ = 64
PySequence_SetItem PROC					; COMDAT

; 1529 : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1530 :     PySequenceMethods *m;
; 1531 : 
; 1532 :     if (s == NULL) {

  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 18		 jne	 SHORT $LN5@PySequence@9

; 1533 :         null_error();

  0001d	e8 00 00 00 00	 call	 null_error

; 1534 :         return -1;

  00022	83 c8 ff	 or	 eax, -1

; 1557 : }

  00025	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5e		 pop	 rsi
  00034	c3		 ret	 0
$LN5@PySequence@9:

; 1535 :     }
; 1536 : 
; 1537 :     /*
; 1538 :     if (Px_CHECK_PROTECTION(s, NULL, o))
; 1539 :         return -1;
; 1540 :     */
; 1541 : 
; 1542 :     m = s->ob_type->tp_as_sequence;

  00035	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00039	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0003e	48 8b b8 c0 00
	00 00		 mov	 rdi, QWORD PTR [rax+192]

; 1543 :     if (m && m->sq_ass_item) {

  00045	48 85 ff	 test	 rdi, rdi
  00048	74 2c		 je	 SHORT $LN4@PySequence@9
  0004a	48 83 7f 28 00	 cmp	 QWORD PTR [rdi+40], 0
  0004f	74 25		 je	 SHORT $LN4@PySequence@9

; 1544 :         if (i < 0) {

  00051	48 85 d2	 test	 rdx, rdx
  00054	79 12		 jns	 SHORT $LN2@PySequence@9

; 1545 :             if (m->sq_length) {

  00056	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00059	48 85 c0	 test	 rax, rax
  0005c	74 0a		 je	 SHORT $LN2@PySequence@9

; 1546 :                 Py_ssize_t l = (*m->sq_length)(s);

  0005e	ff d0		 call	 rax

; 1547 :                 if (l < 0)

  00060	48 85 c0	 test	 rax, rax

; 1548 :                     return -1;

  00063	78 20		 js	 SHORT $LN9@PySequence@9

; 1549 :                 i += l;

  00065	48 03 f0	 add	 rsi, rax
$LN2@PySequence@9:

; 1550 :             }
; 1551 :         }
; 1552 :         return m->sq_ass_item(s, i, o);

  00068	4c 8b c5	 mov	 r8, rbp
  0006b	48 8b d6	 mov	 rdx, rsi
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	ff 57 28	 call	 QWORD PTR [rdi+40]
  00074	eb 12		 jmp	 SHORT $LN8@PySequence@9
$LN4@PySequence@9:

; 1553 :     }
; 1554 : 
; 1555 :     type_error("'%.200s' object does not support item assignment", s);

  00076	48 8b d1	 mov	 rdx, rcx
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
  00080	e8 00 00 00 00	 call	 type_error
$LN9@PySequence@9:

; 1556 :     return -1;

  00085	83 c8 ff	 or	 eax, -1
$LN8@PySequence@9:
  00088	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1557 : }

  0008d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00092	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5e		 pop	 rsi
  0009c	c3		 ret	 0
PySequence_SetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
PUBLIC	PySequence_DelItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_DelItem DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$PySequence_DelItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySequence_DelItem DD imagerel $LN10+44
	DD	imagerel $LN10+122
	DD	imagerel $chain$0$PySequence_DelItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PySequence_DelItem DD imagerel $LN10+122
	DD	imagerel $LN10+156
	DD	imagerel $chain$2$PySequence_DelItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PySequence_DelItem DD 020021H
	DD	066400H
	DD	imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$PySequence_DelItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySequence_DelItem DD 020521H
	DD	066405H
	DD	imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$PySequence_DelItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_DelItem DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support item deletion', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_DelItem
_TEXT	SEGMENT
s$ = 48
i$ = 56
PySequence_DelItem PROC					; COMDAT

; 1561 : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1562 :     PySequenceMethods *m;
; 1563 : 
; 1564 :     if (s == NULL) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 13		 jne	 SHORT $LN5@PySequence@10

; 1565 :         null_error();

  00015	e8 00 00 00 00	 call	 null_error

; 1566 :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1588 :     return -1;
; 1589 : }

  0001d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN5@PySequence@10:

; 1567 :     }
; 1568 : 
; 1569 :     /*
; 1570 :     if (Px_CHECK_PROTECTION(s, NULL, NULL))
; 1571 :         return -1;
; 1572 :     */
; 1573 : 
; 1574 :     m = s->ob_type->tp_as_sequence;

  00028	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00031	48 8b b0 c0 00
	00 00		 mov	 rsi, QWORD PTR [rax+192]

; 1575 :     if (m && m->sq_ass_item) {

  00038	48 85 f6	 test	 rsi, rsi
  0003b	74 3d		 je	 SHORT $LN4@PySequence@10
  0003d	48 83 7e 28 00	 cmp	 QWORD PTR [rsi+40], 0
  00042	74 36		 je	 SHORT $LN4@PySequence@10

; 1576 :         if (i < 0) {

  00044	48 85 d2	 test	 rdx, rdx
  00047	79 12		 jns	 SHORT $LN2@PySequence@10

; 1577 :             if (m->sq_length) {

  00049	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0004c	48 85 c0	 test	 rax, rax
  0004f	74 0a		 je	 SHORT $LN2@PySequence@10

; 1578 :                 Py_ssize_t l = (*m->sq_length)(s);

  00051	ff d0		 call	 rax

; 1579 :                 if (l < 0)

  00053	48 85 c0	 test	 rax, rax

; 1580 :                     return -1;

  00056	78 31		 js	 SHORT $LN9@PySequence@10

; 1581 :                 i += l;

  00058	48 03 f8	 add	 rdi, rax
$LN2@PySequence@10:

; 1582 :             }
; 1583 :         }
; 1584 :         return m->sq_ass_item(s, i, (PyObject *)NULL);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	48 8b d7	 mov	 rdx, rdi
  00061	48 8b cb	 mov	 rcx, rbx
  00064	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  00068	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1588 :     return -1;
; 1589 : }

  0006d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	48 ff e0	 rex_jmp rax
$LN4@PySequence@10:

; 1585 :     }
; 1586 : 
; 1587 :     type_error("'%.200s' object doesn't support item deletion", s);

  0007a	48 8b d1	 mov	 rdx, rcx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  00084	e8 00 00 00 00	 call	 type_error
$LN9@PySequence@10:

; 1588 :     return -1;
; 1589 : }

  00089	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0008e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00093	83 c8 ff	 or	 eax, -1
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
PySequence_DelItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
PUBLIC	PySequence_SetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_SetSlice DD imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$PySequence_SetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySequence_SetSlice DD imagerel $LN8+47
	DD	imagerel $LN8+119
	DD	imagerel $chain$1$PySequence_SetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_SetSlice DD imagerel $LN8+119
	DD	imagerel $LN8+145
	DD	imagerel $chain$3$PySequence_SetSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PySequence_SetSlice DD imagerel $LN8+145
	DD	imagerel $LN8+179
	DD	imagerel $chain$4$PySequence_SetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PySequence_SetSlice DD 020021H
	DD	077400H
	DD	imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$PySequence_SetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_SetSlice DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$PySequence_SetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySequence_SetSlice DD 042321H
	DD	066423H
	DD	077405H
	DD	imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$PySequence_SetSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_SetSlice DD 040a01H
	DD	08340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT ??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support slice assignment', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_SetSlice
_TEXT	SEGMENT
s$ = 48
i1$ = 56
i2$ = 64
o$ = 72
PySequence_SetSlice PROC				; COMDAT

; 1593 : {

$LN8:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b e9	 mov	 rbp, r9
  0000d	4c 8b d2	 mov	 r10, rdx
  00010	48 8b d9	 mov	 rbx, rcx

; 1594 :     PyMappingMethods *mp;
; 1595 : 
; 1596 :     if (s == NULL) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	75 13		 jne	 SHORT $LN3@PySequence@11

; 1597 :         null_error();

  00018	e8 00 00 00 00	 call	 null_error

; 1598 :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 1618 :     return -1;
; 1619 : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
$LN3@PySequence@11:

; 1599 :     }
; 1600 : 
; 1601 :     /*
; 1602 :     if (Px_CHECK_PROTECTION(s, NULL, o))
; 1603 :         return -1;
; 1604 :     */
; 1605 : 
; 1606 :     mp = s->ob_type->tp_as_mapping;

  0002b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00034	48 8b b8 c8 00
	00 00		 mov	 rdi, QWORD PTR [rax+200]

; 1607 :     if (mp && mp->mp_ass_subscript) {

  0003b	48 85 ff	 test	 rdi, rdi
  0003e	74 51		 je	 SHORT $LN2@PySequence@11
  00040	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  00045	74 4a		 je	 SHORT $LN2@PySequence@11

; 1608 :         int res;
; 1609 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  00047	49 8b d0	 mov	 rdx, r8
  0004a	49 8b ca	 mov	 rcx, r10
  0004d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00052	e8 00 00 00 00	 call	 _PySlice_FromIndices
  00057	48 8b f0	 mov	 rsi, rax

; 1610 :         if (!slice)

  0005a	48 85 c0	 test	 rax, rax
  0005d	75 18		 jne	 SHORT $LN1@PySequence@11

; 1611 :             return -1;

  0005f	83 c8 ff	 or	 eax, -1
$LN7@PySequence@11:
  00062	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00067	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1618 :     return -1;
; 1619 : }

  0006c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5d		 pop	 rbp
  00076	c3		 ret	 0
$LN1@PySequence@11:

; 1612 :         res = mp->mp_ass_subscript(s, slice, o);

  00077	4c 8b c5	 mov	 r8, rbp
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	ff 57 10	 call	 QWORD PTR [rdi+16]

; 1613 :         Py_DECREF(slice);

  00083	48 8b ce	 mov	 rcx, rsi
  00086	8b d8		 mov	 ebx, eax
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 1614 :         return res;

  0008d	8b c3		 mov	 eax, ebx
  0008f	eb d1		 jmp	 SHORT $LN7@PySequence@11
$LN2@PySequence@11:

; 1615 :     }
; 1616 : 
; 1617 :     type_error("'%.200s' object doesn't support slice assignment", s);

  00091	48 8b d1	 mov	 rdx, rcx
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  0009b	e8 00 00 00 00	 call	 type_error
  000a0	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1618 :     return -1;
; 1619 : }

  000a5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000aa	83 c8 ff	 or	 eax, -1
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5d		 pop	 rbp
  000b2	c3		 ret	 0
PySequence_SetSlice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
PUBLIC	PySequence_DelSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_DelSlice DD imagerel $LN8
	DD	imagerel $LN8+35
	DD	imagerel $unwind$PySequence_DelSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PySequence_DelSlice DD imagerel $LN8+35
	DD	imagerel $LN8+102
	DD	imagerel $chain$1$PySequence_DelSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_DelSlice DD imagerel $LN8+102
	DD	imagerel $LN8+142
	DD	imagerel $chain$3$PySequence_DelSlice
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PySequence_DelSlice DD imagerel $LN8+142
	DD	imagerel $LN8+171
	DD	imagerel $chain$5$PySequence_DelSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PySequence_DelSlice DD 020021H
	DD	077400H
	DD	imagerel $LN8
	DD	imagerel $LN8+35
	DD	imagerel $unwind$PySequence_DelSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_DelSlice DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN8
	DD	imagerel $LN8+35
	DD	imagerel $unwind$PySequence_DelSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PySequence_DelSlice DD 042321H
	DD	066423H
	DD	077405H
	DD	imagerel $LN8
	DD	imagerel $LN8+35
	DD	imagerel $unwind$PySequence_DelSlice
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_DelSlice DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support slice deletion', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PySequence_DelSlice
_TEXT	SEGMENT
s$ = 48
i1$ = 56
i2$ = 64
PySequence_DelSlice PROC				; COMDAT

; 1623 : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b ca	 mov	 r9, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1624 :     PyMappingMethods *mp;
; 1625 : 
; 1626 :     if (s == NULL) {

  0000c	48 85 c9	 test	 rcx, rcx
  0000f	75 0e		 jne	 SHORT $LN3@PySequence@12

; 1627 :         null_error();

  00011	e8 00 00 00 00	 call	 null_error

; 1628 :         return -1;

  00016	83 c8 ff	 or	 eax, -1

; 1643 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN3@PySequence@12:

; 1629 :     }
; 1630 : 
; 1631 :     mp = s->ob_type->tp_as_mapping;

  0001f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00023	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00028	48 8b b8 c8 00
	00 00		 mov	 rdi, QWORD PTR [rax+200]

; 1632 :     if (mp && mp->mp_ass_subscript) {

  0002f	48 85 ff	 test	 rdi, rdi
  00032	74 5a		 je	 SHORT $LN2@PySequence@12
  00034	48 83 7f 10 00	 cmp	 QWORD PTR [rdi+16], 0
  00039	74 53		 je	 SHORT $LN2@PySequence@12

; 1633 :         int res;
; 1634 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  0003b	49 8b d0	 mov	 rdx, r8
  0003e	49 8b c9	 mov	 rcx, r9
  00041	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00046	e8 00 00 00 00	 call	 _PySlice_FromIndices
  0004b	48 8b f0	 mov	 rsi, rax

; 1635 :         if (!slice)

  0004e	48 85 c0	 test	 rax, rax
  00051	75 13		 jne	 SHORT $LN1@PySequence@12

; 1636 :             return -1;

  00053	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00058	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0005d	83 c8 ff	 or	 eax, -1

; 1643 : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
$LN1@PySequence@12:

; 1637 :         res = mp->mp_ass_subscript(s, slice, NULL);

  00066	45 33 c0	 xor	 r8d, r8d
  00069	48 8b d0	 mov	 rdx, rax
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff 57 10	 call	 QWORD PTR [rdi+16]

; 1638 :         Py_DECREF(slice);

  00072	48 8b ce	 mov	 rcx, rsi
  00075	8b d8		 mov	 ebx, eax
  00077	e8 00 00 00 00	 call	 _Py_DecRef
  0007c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00081	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1639 :         return res;

  00086	8b c3		 mov	 eax, ebx

; 1643 : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5b		 pop	 rbx
  0008d	c3		 ret	 0
$LN2@PySequence@12:

; 1640 :     }
; 1641 :     type_error("'%.200s' object doesn't support slice deletion", s);

  0008e	48 8b d1	 mov	 rdx, rcx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  00098	e8 00 00 00 00	 call	 type_error
  0009d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1642 :     return -1;

  000a2	83 c8 ff	 or	 eax, -1

; 1643 : }

  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5b		 pop	 rbx
  000aa	c3		 ret	 0
PySequence_DelSlice ENDP
_TEXT	ENDS
PUBLIC	PySequence_List
EXTRN	_PyList_Extend:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_List DD imagerel $LN8
	DD	imagerel $LN8+26
	DD	imagerel $unwind$PySequence_List
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySequence_List DD imagerel $LN8+26
	DD	imagerel $LN8+81
	DD	imagerel $chain$0$PySequence_List
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PySequence_List DD imagerel $LN8+81
	DD	imagerel $LN8+103
	DD	imagerel $chain$2$PySequence_List
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PySequence_List DD 020021H
	DD	063400H
	DD	imagerel $LN8
	DD	imagerel $LN8+26
	DD	imagerel $unwind$PySequence_List
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySequence_List DD 020521H
	DD	063405H
	DD	imagerel $LN8
	DD	imagerel $LN8+26
	DD	imagerel $unwind$PySequence_List
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_List DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PySequence_List
_TEXT	SEGMENT
v$ = 48
PySequence_List PROC					; COMDAT

; 1729 : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 1730 :     PyObject *result;  /* result list */
; 1731 :     PyObject *rv;          /* return value from PyList_Extend */
; 1732 : 
; 1733 :     if (v == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0a		 jne	 SHORT $LN3@PySequence@13

; 1747 : }

  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5f		 pop	 rdi
  00013	e9 00 00 00 00	 jmp	 null_error
$LN3@PySequence@13:

; 1734 :         return null_error();
; 1735 : 
; 1736 :     result = PyList_New(0);

  00018	33 c9		 xor	 ecx, ecx
  0001a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001f	e8 00 00 00 00	 call	 PyList_New
  00024	48 8b d8	 mov	 rbx, rax

; 1737 :     if (result == NULL)

  00027	48 85 c0	 test	 rax, rax

; 1738 :         return NULL;

  0002a	74 18		 je	 SHORT $LN7@PySequence@13

; 1739 : 
; 1740 :     rv = _PyList_Extend((PyListObject *)result, v);

  0002c	48 8b d7	 mov	 rdx, rdi
  0002f	48 8b c8	 mov	 rcx, rax
  00032	e8 00 00 00 00	 call	 _PyList_Extend

; 1741 :     if (rv == NULL) {

  00037	48 85 c0	 test	 rax, rax
  0003a	75 15		 jne	 SHORT $LN1@PySequence@13

; 1742 :         Py_DECREF(result);

  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PySequence@13:

; 1743 :         return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1747 : }

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN1@PySequence@13:

; 1744 :     }
; 1745 :     Py_DECREF(rv);

  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 _Py_DecRef

; 1746 :     return result;

  00059	48 8b c3	 mov	 rax, rbx
  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1747 : }

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
PySequence_List ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Check
; Function compile flags: /Ogtpy
;	COMDAT PyMapping_Check
_TEXT	SEGMENT
o$ = 8
PyMapping_Check PROC					; COMDAT

; 1904 :     return o && o->ob_type->tp_as_mapping &&
; 1905 :         o->ob_type->tp_as_mapping->mp_subscript;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN3@PyMapping_
  00005	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00009	48 8b 88 c8 00
	00 00		 mov	 rcx, QWORD PTR [rax+200]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 0d		 je	 SHORT $LN3@PyMapping_
  00015	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  0001a	74 06		 je	 SHORT $LN3@PyMapping_
  0001c	b8 01 00 00 00	 mov	 eax, 1

; 1906 : }

  00021	c3		 ret	 0
$LN3@PyMapping_:

; 1904 :     return o && o->ob_type->tp_as_mapping &&
; 1905 :         o->ob_type->tp_as_mapping->mp_subscript;

  00022	33 c0		 xor	 eax, eax

; 1906 : }

  00024	c3		 ret	 0
PyMapping_Check ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Size DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$PyMapping_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Size DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMapping_Size
_TEXT	SEGMENT
o$ = 48
PyMapping_Size PROC					; COMDAT

; 1910 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1911 :     PyMappingMethods *m;
; 1912 : 
; 1913 :     if (o == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 0e		 jne	 SHORT $LN2@PyMapping_@2

; 1914 :         null_error();

  00009	e8 00 00 00 00	 call	 null_error

; 1923 :     return -1;

  0000e	48 83 c8 ff	 or	 rax, -1

; 1924 : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@PyMapping_@2:

; 1915 :         return -1;
; 1916 :     }
; 1917 : 
; 1918 :     m = o->ob_type->tp_as_mapping;

  00017	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001b	48 8b 90 c8 00
	00 00		 mov	 rdx, QWORD PTR [rax+200]

; 1919 :     if (m && m->mp_length)

  00022	48 85 d2	 test	 rdx, rdx
  00025	74 0f		 je	 SHORT $LN1@PyMapping_@2
  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 07		 je	 SHORT $LN1@PyMapping_@2

; 1924 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	48 ff e0	 rex_jmp rax
$LN1@PyMapping_@2:

; 1920 :         return m->mp_length(o);
; 1921 : 
; 1922 :     type_error("object of type '%.200s' has no len()", o);

  00036	48 8b d1	 mov	 rdx, rcx
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
  00040	e8 00 00 00 00	 call	 type_error

; 1923 :     return -1;

  00045	48 83 c8 ff	 or	 rax, -1

; 1924 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
PyMapping_Size ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Length
; Function compile flags: /Ogtpy
;	COMDAT PyMapping_Length
_TEXT	SEGMENT
o$ = 8
PyMapping_Length PROC					; COMDAT

; 1930 :     return PyMapping_Size(o);
; 1931 : }

  00000	e9 00 00 00 00	 jmp	 PyMapping_Size
PyMapping_Length ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallObject
; Function compile flags: /Ogtpy
;	COMDAT PyObject_CallObject
_TEXT	SEGMENT
o$ = 8
a$ = 16
PyObject_CallObject PROC				; COMDAT

; 2061 :     return PyEval_CallObjectWithKeywords(o, a, NULL);

  00000	45 33 c0	 xor	 r8d, r8d

; 2062 : }

  00003	e9 00 00 00 00	 jmp	 PyEval_CallObjectWithKeywords
PyObject_CallObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@ ; `string'
PUBLIC	??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@ ; `string'
PUBLIC	??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@ ; `string'
PUBLIC	PyObject_Call
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Call DD imagerel $LN19
	DD	imagerel $LN19+290
	DD	imagerel $unwind$PyObject_Call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Call DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@
CONST	SEGMENT
??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@ DB '''%'
	DB	'.200s'' object is not callable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@
CONST	SEGMENT
??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@ DB 'NULL result'
	DB	' without error in PyObject_Call', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@
CONST	SEGMENT
??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@ DB ' while ca'
	DB	'lling a Python object', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_Call
_TEXT	SEGMENT
func$ = 48
arg$ = 56
kw$ = 64
PyObject_Call PROC					; COMDAT

; 2066 : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8

; 2067 :     ternaryfunc call;
; 2068 : 
; 2069 :     if ((call = func->ob_type->tp_call) != NULL) {

  00017	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	49 8b b8 d8 00
	00 00		 mov	 rdi, QWORD PTR [r8+216]
  00025	48 8b d9	 mov	 rbx, rcx
  00028	48 85 ff	 test	 rdi, rdi
  0002b	0f 84 c3 00 00
	00		 je	 $LN7@PyObject_C

; 2070 :         PyObject *result;
; 2071 :         if (Py_EnterRecursiveCall(" while calling a Python object"))

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	74 07		 je	 SHORT $LN10@PyObject_C
  0003a	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0003f	eb 07		 jmp	 SHORT $LN11@PyObject_C
$LN10@PyObject_C:
  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN11@PyObject_C:
  00048	ff 40 18	 inc	 DWORD PTR [rax+24]
  0004b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0004e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00054	7e 14		 jle	 SHORT $LN6@PyObject_C
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@
  0005d	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00062	85 c0		 test	 eax, eax

; 2072 :             return NULL;

  00064	0f 85 a1 00 00
	00		 jne	 $LN18@PyObject_C
$LN6@PyObject_C:

; 2073 :         result = (*call)(func, arg, kw);

  0006a	4c 8b c6	 mov	 r8, rsi
  0006d	48 8b d5	 mov	 rdx, rbp
  00070	48 8b cb	 mov	 rcx, rbx
  00073	ff d7		 call	 rdi
  00075	48 8b d8	 mov	 rbx, rax

; 2074 :         Py_LeaveRecursiveCall();

  00078	e8 00 00 00 00	 call	 _Py_PXCTX
  0007d	85 c0		 test	 eax, eax
  0007f	74 0a		 je	 SHORT $LN12@PyObject_C
  00081	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00086	4c 8b d8	 mov	 r11, rax
  00089	eb 07		 jmp	 SHORT $LN13@PyObject_C
$LN12@PyObject_C:
  0008b	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN13@PyObject_C:
  00092	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00098	83 f8 64	 cmp	 eax, 100		; 00000064H
  0009b	7e 05		 jle	 SHORT $LN14@PyObject_C
  0009d	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  000a0	eb 06		 jmp	 SHORT $LN15@PyObject_C
$LN14@PyObject_C:
  000a2	c1 f8 02	 sar	 eax, 2
  000a5	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN15@PyObject_C:
  000a8	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  000ac	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  000b0	7d 1b		 jge	 SHORT $LN4@PyObject_C
  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	85 c0		 test	 eax, eax
  000b9	74 07		 je	 SHORT $LN16@PyObject_C
  000bb	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000c0	eb 07		 jmp	 SHORT $LN17@PyObject_C
$LN16@PyObject_C:
  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN17@PyObject_C:
  000c9	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN4@PyObject_C:

; 2075 :         if (result == NULL && !PyErr_Occurred())

  000cd	48 85 db	 test	 rbx, rbx
  000d0	75 1d		 jne	 SHORT $LN1@PyObject_C
  000d2	e8 00 00 00 00	 call	 PyErr_Occurred
  000d7	48 85 c0	 test	 rax, rax
  000da	75 13		 jne	 SHORT $LN1@PyObject_C

; 2076 :             PyErr_SetString(
; 2077 :                 PyExc_SystemError,
; 2078 :                 "NULL result without error in PyObject_Call");

  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@
  000ea	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyObject_C:

; 2079 :         return result;

  000ef	48 8b c3	 mov	 rax, rbx
  000f2	eb 19		 jmp	 SHORT $LN8@PyObject_C
$LN7@PyObject_C:

; 2080 :     }
; 2081 :     PyErr_Format(PyExc_TypeError, "'%.200s' object is not callable",
; 2082 :                  func->ob_type->tp_name);

  000f4	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@
  00106	e8 00 00 00 00	 call	 PyErr_Format
$LN18@PyObject_C:

; 2083 :     return NULL;

  0010b	33 c0		 xor	 eax, eax
$LN8@PyObject_C:

; 2084 : }

  0010d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00112	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00117	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0011c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
PyObject_Call ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_function_tail DD imagerel call_function_tail
	DD	imagerel call_function_tail+119
	DD	imagerel $unwind$call_function_tail
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_function_tail DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT call_function_tail
_TEXT	SEGMENT
callable$ = 48
args$ = 56
call_function_tail PROC					; COMDAT

; 2088 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2089 :     PyObject *retval;
; 2090 : 
; 2091 :     if (args == NULL)

  00010	48 85 d2	 test	 rdx, rdx

; 2092 :         return NULL;

  00013	74 27		 je	 SHORT $LN6@call_funct

; 2093 : 
; 2094 :     if (!PyTuple_Check(args)) {

  00015	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00019	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00023	75 2b		 jne	 SHORT $LN2@call_funct

; 2095 :         PyObject *a;
; 2096 : 
; 2097 :         a = PyTuple_New(1);

  00025	b9 01 00 00 00	 mov	 ecx, 1
  0002a	e8 00 00 00 00	 call	 PyTuple_New

; 2098 :         if (a == NULL) {

  0002f	48 85 c0	 test	 rax, rax
  00032	75 15		 jne	 SHORT $LN1@call_funct

; 2099 :             Py_DECREF(args);

  00034	48 8b cf	 mov	 rcx, rdi
  00037	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@call_funct:

; 2100 :             return NULL;

  0003c	33 c0		 xor	 eax, eax

; 2110 : }

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN1@call_funct:

; 2101 :         }
; 2102 :         PyTuple_SET_ITEM(a, 0, args);

  00049	48 89 78 70	 mov	 QWORD PTR [rax+112], rdi

; 2103 :         args = a;

  0004d	48 8b f8	 mov	 rdi, rax
$LN2@call_funct:

; 2104 :     }
; 2105 :     retval = PyObject_Call(callable, args, NULL);

  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8b d7	 mov	 rdx, rdi
  00056	48 8b cb	 mov	 rcx, rbx
  00059	e8 00 00 00 00	 call	 PyObject_Call

; 2106 : 
; 2107 :     Py_DECREF(args);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	48 8b d8	 mov	 rbx, rax
  00064	e8 00 00 00 00	 call	 _Py_DecRef

; 2108 : 
; 2109 :     return retval;

  00069	48 8b c3	 mov	 rax, rbx

; 2110 : }

  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
call_function_tail ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallFunction
EXTRN	Py_VaBuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallFunction DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$PyObject_CallFunction
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallFunction DD 021401H
	DD	030103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_CallFunction
_TEXT	SEGMENT
callable$ = 48
format$ = 56
PyObject_CallFunction PROC				; COMDAT

; 2114 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	53		 push	 rbx
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b c2	 mov	 rax, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 2115 :     va_list va;
; 2116 :     PyObject *args;
; 2117 : 
; 2118 :     if (callable == NULL)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	75 0b		 jne	 SHORT $LN3@PyObject_C@2

; 2119 :         return null_error();

  0001f	e8 00 00 00 00	 call	 null_error

; 2130 : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$LN3@PyObject_C@2:

; 2120 : 
; 2121 :     if (format && *format) {

  0002a	48 85 d2	 test	 rdx, rdx
  0002d	74 23		 je	 SHORT $LN2@PyObject_C@2
  0002f	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00032	74 1e		 je	 SHORT $LN2@PyObject_C@2

; 2122 :         va_start(va, format);

  00034	48 8d 54 24 40	 lea	 rdx, QWORD PTR format$[rsp+8]

; 2123 :         args = Py_VaBuildValue(format, va);

  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 Py_VaBuildValue

; 2128 : 
; 2129 :     return call_function_tail(callable, args);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	48 8b d0	 mov	 rdx, rax
  00047	e8 00 00 00 00	 call	 call_function_tail

; 2130 : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN2@PyObject_C@2:

; 2124 :         va_end(va);
; 2125 :     }
; 2126 :     else
; 2127 :         args = PyTuple_New(0);

  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 PyTuple_New

; 2128 : 
; 2129 :     return call_function_tail(callable, args);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	e8 00 00 00 00	 call	 call_function_tail

; 2130 : }

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
PyObject_CallFunction ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallFunction_SizeT
EXTRN	_Py_VaBuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallFunction_SizeT DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$_PyObject_CallFunction_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallFunction_SizeT DD 021401H
	DD	030103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_CallFunction_SizeT
_TEXT	SEGMENT
callable$ = 48
format$ = 56
_PyObject_CallFunction_SizeT PROC			; COMDAT

; 2134 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	53		 push	 rbx
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b c2	 mov	 rax, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 2135 :     va_list va;
; 2136 :     PyObject *args;
; 2137 : 
; 2138 :     if (callable == NULL)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	75 0b		 jne	 SHORT $LN3@PyObject_C@3

; 2139 :         return null_error();

  0001f	e8 00 00 00 00	 call	 null_error

; 2150 : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$LN3@PyObject_C@3:

; 2140 : 
; 2141 :     if (format && *format) {

  0002a	48 85 d2	 test	 rdx, rdx
  0002d	74 23		 je	 SHORT $LN2@PyObject_C@3
  0002f	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00032	74 1e		 je	 SHORT $LN2@PyObject_C@3

; 2142 :         va_start(va, format);

  00034	48 8d 54 24 40	 lea	 rdx, QWORD PTR format$[rsp+8]

; 2143 :         args = _Py_VaBuildValue_SizeT(format, va);

  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 _Py_VaBuildValue_SizeT

; 2148 : 
; 2149 :     return call_function_tail(callable, args);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	48 8b d0	 mov	 rdx, rax
  00047	e8 00 00 00 00	 call	 call_function_tail

; 2150 : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN2@PyObject_C@3:

; 2144 :         va_end(va);
; 2145 :     }
; 2146 :     else
; 2147 :         args = PyTuple_New(0);

  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 PyTuple_New

; 2148 : 
; 2149 :     return call_function_tail(callable, args);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	e8 00 00 00 00	 call	 call_function_tail

; 2150 : }

  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
_PyObject_CallFunction_SizeT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@ ; `string'
EXTRN	PyCallable_Check:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$callmethod DD imagerel callmethod
	DD	imagerel callmethod+258
	DD	imagerel $unwind$callmethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$callmethod DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@
CONST	SEGMENT
??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@ DB 'attri'
	DB	'bute of type ''%.200s'' is not callable', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
CONST	ENDS
;	COMDAT callmethod
_TEXT	SEGMENT
func$ = 64
format$ = 72
va$ = 80
is_size_t$ = 88
callmethod PROC						; COMDAT

; 2154 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	45 8b e1	 mov	 r12d, r9d
  0001d	49 8b e8	 mov	 rbp, r8
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 8b d9	 mov	 rbx, rcx

; 2155 :     PyObject *retval = NULL;

  00026	33 ff		 xor	 edi, edi

; 2156 :     PyObject *args;
; 2157 : 
; 2158 :     if (!PyCallable_Check(func)) {

  00028	e8 00 00 00 00	 call	 PyCallable_Check
  0002d	85 c0		 test	 eax, eax
  0002f	75 11		 jne	 SHORT $LN9@callmethod

; 2159 :         type_error("attribute of type '%.200s' is not callable", func);

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@
  00038	48 8b d3	 mov	 rdx, rbx
  0003b	e8 00 00 00 00	 call	 type_error

; 2160 :         goto exit;

  00040	eb 38		 jmp	 SHORT $exit$21925
$LN9@callmethod:

; 2161 :     }
; 2162 : 
; 2163 :     if (format && *format) {

  00042	48 85 f6	 test	 rsi, rsi
  00045	74 1e		 je	 SHORT $LN8@callmethod
  00047	40 38 3e	 cmp	 BYTE PTR [rsi], dil
  0004a	74 19		 je	 SHORT $LN8@callmethod

; 2164 :         if (is_size_t)
; 2165 :             args = _Py_VaBuildValue_SizeT(format, va);

  0004c	48 8b d5	 mov	 rdx, rbp
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	45 85 e4	 test	 r12d, r12d
  00055	74 07		 je	 SHORT $LN7@callmethod
  00057	e8 00 00 00 00	 call	 _Py_VaBuildValue_SizeT

; 2166 :         else

  0005c	eb 0e		 jmp	 SHORT $LN5@callmethod
$LN7@callmethod:

; 2167 :             args = Py_VaBuildValue(format, va);

  0005e	e8 00 00 00 00	 call	 Py_VaBuildValue

; 2168 :     }
; 2169 :     else

  00063	eb 07		 jmp	 SHORT $LN5@callmethod
$LN8@callmethod:

; 2170 :         args = PyTuple_New(0);

  00065	33 c9		 xor	 ecx, ecx
  00067	e8 00 00 00 00	 call	 PyTuple_New
$LN5@callmethod:

; 2171 : 
; 2172 :     retval = call_function_tail(func, args);

  0006c	48 8b d0	 mov	 rdx, rax
  0006f	48 8b cb	 mov	 rcx, rbx
  00072	e8 00 00 00 00	 call	 call_function_tail
  00077	48 8b f8	 mov	 rdi, rax
$exit$21925:

; 2173 : 
; 2174 :   exit:
; 2175 :     /* args gets consumed in call_function_tail */
; 2176 :     Py_XDECREF(func);

  0007a	48 85 db	 test	 rbx, rbx
  0007d	74 65		 je	 SHORT $LN25@callmethod
  0007f	e8 00 00 00 00	 call	 _Py_PXCTX
  00084	85 c0		 test	 eax, eax
  00086	75 5c		 jne	 SHORT $LN25@callmethod
  00088	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0008c	a8 20		 test	 al, 32			; 00000020H
  0008e	75 4c		 jne	 SHORT $LN16@callmethod
  00090	84 c0		 test	 al, al
  00092	78 48		 js	 SHORT $LN16@callmethod
  00094	a8 02		 test	 al, 2
  00096	75 4c		 jne	 SHORT $LN25@callmethod
  00098	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0009c	75 46		 jne	 SHORT $LN25@callmethod
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ac	4c 8b cb	 mov	 r9, rbx
  000af	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c2	48 8b cb	 mov	 rcx, rbx
  000c5	85 c0		 test	 eax, eax
  000c7	74 07		 je	 SHORT $LN21@callmethod
  000c9	e8 00 00 00 00	 call	 _Px_Dealloc
  000ce	eb 14		 jmp	 SHORT $LN25@callmethod
$LN21@callmethod:
  000d0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000da	eb 08		 jmp	 SHORT $LN25@callmethod
$LN16@callmethod:
  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 Px_DecRef
$LN25@callmethod:

; 2177 : 
; 2178 :     return retval;
; 2179 : }

  000e4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ee	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000f3	48 8b c7	 mov	 rax, rdi
  000f6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000fb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ff	41 5c		 pop	 r12
  00101	c3		 ret	 0
callmethod ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallMethod
EXTRN	PyObject_GetAttrString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallMethod DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$PyObject_CallMethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallMethod DD 010e01H
	DD	0420eH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_CallMethod
_TEXT	SEGMENT
o$ = 48
name$ = 56
format$ = 64
PyObject_CallMethod PROC				; COMDAT

; 2183 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2184 :     va_list va;
; 2185 :     PyObject *func = NULL;
; 2186 :     PyObject *retval = NULL;
; 2187 : 
; 2188 :     if (o == NULL || name == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	74 2e		 je	 SHORT $LN2@PyObject_C@4
  00013	48 85 d2	 test	 rdx, rdx
  00016	74 29		 je	 SHORT $LN2@PyObject_C@4

; 2190 : 
; 2191 :     func = PyObject_GetAttrString(o, name);

  00018	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 2192 :     if (func == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 05		 jne	 SHORT $LN1@PyObject_C@4

; 2198 :     va_end(va);
; 2199 :     return retval;
; 2200 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN1@PyObject_C@4:

; 2193 :         return 0;
; 2194 :     }
; 2195 : 
; 2196 :     va_start(va, format);
; 2197 :     retval = callmethod(func, format, va, 0);

  00027	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  0002c	4c 8d 44 24 48	 lea	 r8, QWORD PTR format$[rsp+8]
  00031	45 33 c9	 xor	 r9d, r9d
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 callmethod

; 2198 :     va_end(va);
; 2199 :     return retval;
; 2200 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN2@PyObject_C@4:

; 2189 :         return null_error();

  00041	e8 00 00 00 00	 call	 null_error

; 2198 :     va_end(va);
; 2199 :     return retval;
; 2200 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
PyObject_CallMethod ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethodId
EXTRN	_PyObject_GetAttrId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodId DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$_PyObject_CallMethodId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodId DD 010e01H
	DD	0420eH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_CallMethodId
_TEXT	SEGMENT
o$ = 48
name$ = 56
format$ = 64
_PyObject_CallMethodId PROC				; COMDAT

; 2204 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2205 :     va_list va;
; 2206 :     PyObject *func = NULL;
; 2207 :     PyObject *retval = NULL;
; 2208 : 
; 2209 :     if (o == NULL || name == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	74 2e		 je	 SHORT $LN2@PyObject_C@5
  00013	48 85 d2	 test	 rdx, rdx
  00016	74 29		 je	 SHORT $LN2@PyObject_C@5

; 2211 : 
; 2212 :     func = _PyObject_GetAttrId(o, name);

  00018	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 2213 :     if (func == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 05		 jne	 SHORT $LN1@PyObject_C@5

; 2219 :     va_end(va);
; 2220 :     return retval;
; 2221 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN1@PyObject_C@5:

; 2214 :         return 0;
; 2215 :     }
; 2216 : 
; 2217 :     va_start(va, format);
; 2218 :     retval = callmethod(func, format, va, 0);

  00027	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  0002c	4c 8d 44 24 48	 lea	 r8, QWORD PTR format$[rsp+8]
  00031	45 33 c9	 xor	 r9d, r9d
  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 callmethod

; 2219 :     va_end(va);
; 2220 :     return retval;
; 2221 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN2@PyObject_C@5:

; 2210 :         return null_error();

  00041	e8 00 00 00 00	 call	 null_error

; 2219 :     va_end(va);
; 2220 :     return retval;
; 2221 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
_PyObject_CallMethodId ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethod_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethod_SizeT DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$_PyObject_CallMethod_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethod_SizeT DD 010e01H
	DD	0420eH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_CallMethod_SizeT
_TEXT	SEGMENT
o$ = 48
name$ = 56
format$ = 64
_PyObject_CallMethod_SizeT PROC				; COMDAT

; 2225 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2226 :     va_list va;
; 2227 :     PyObject *func = NULL;
; 2228 :     PyObject *retval;
; 2229 : 
; 2230 :     if (o == NULL || name == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	74 31		 je	 SHORT $LN2@PyObject_C@6
  00013	48 85 d2	 test	 rdx, rdx
  00016	74 2c		 je	 SHORT $LN2@PyObject_C@6

; 2232 : 
; 2233 :     func = PyObject_GetAttrString(o, name);

  00018	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 2234 :     if (func == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 05		 jne	 SHORT $LN1@PyObject_C@6

; 2239 :     va_end(va);
; 2240 :     return retval;
; 2241 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN1@PyObject_C@6:

; 2235 :         return 0;
; 2236 :     }
; 2237 :     va_start(va, format);
; 2238 :     retval = callmethod(func, format, va, 1);

  00027	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  0002c	4c 8d 44 24 48	 lea	 r8, QWORD PTR format$[rsp+8]
  00031	41 b9 01 00 00
	00		 mov	 r9d, 1
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 callmethod

; 2239 :     va_end(va);
; 2240 :     return retval;
; 2241 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN2@PyObject_C@6:

; 2231 :         return null_error();

  00044	e8 00 00 00 00	 call	 null_error

; 2239 :     va_end(va);
; 2240 :     return retval;
; 2241 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
_PyObject_CallMethod_SizeT ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethodId_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodId_SizeT DD imagerel $LN6
	DD	imagerel $LN6+78
	DD	imagerel $unwind$_PyObject_CallMethodId_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodId_SizeT DD 010e01H
	DD	0420eH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_CallMethodId_SizeT
_TEXT	SEGMENT
o$ = 48
name$ = 56
format$ = 64
_PyObject_CallMethodId_SizeT PROC			; COMDAT

; 2245 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2246 :     va_list va;
; 2247 :     PyObject *func = NULL;
; 2248 :     PyObject *retval;
; 2249 : 
; 2250 :     if (o == NULL || name == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	74 31		 je	 SHORT $LN2@PyObject_C@7
  00013	48 85 d2	 test	 rdx, rdx
  00016	74 2c		 je	 SHORT $LN2@PyObject_C@7

; 2252 : 
; 2253 :     func = _PyObject_GetAttrId(o, name);

  00018	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 2254 :     if (func == NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	75 05		 jne	 SHORT $LN1@PyObject_C@7

; 2259 :     va_end(va);
; 2260 :     return retval;
; 2261 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN1@PyObject_C@7:

; 2255 :         return NULL;
; 2256 :     }
; 2257 :     va_start(va, format);
; 2258 :     retval = callmethod(func, format, va, 1);

  00027	48 8b 54 24 40	 mov	 rdx, QWORD PTR format$[rsp]
  0002c	4c 8d 44 24 48	 lea	 r8, QWORD PTR format$[rsp+8]
  00031	41 b9 01 00 00
	00		 mov	 r9d, 1
  00037	48 8b c8	 mov	 rcx, rax
  0003a	e8 00 00 00 00	 call	 callmethod

; 2259 :     va_end(va);
; 2260 :     return retval;
; 2261 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN2@PyObject_C@7:

; 2251 :         return null_error();

  00044	e8 00 00 00 00	 call	 null_error

; 2259 :     va_end(va);
; 2260 :     return retval;
; 2261 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
_PyObject_CallMethodId_SizeT ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$objargs_mktuple DD imagerel objargs_mktuple
	DD	imagerel objargs_mktuple+69
	DD	imagerel $unwind$objargs_mktuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$objargs_mktuple DD imagerel objargs_mktuple+69
	DD	imagerel objargs_mktuple+170
	DD	imagerel $chain$0$objargs_mktuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$objargs_mktuple DD imagerel objargs_mktuple+170
	DD	imagerel objargs_mktuple+192
	DD	imagerel $chain$1$objargs_mktuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$objargs_mktuple DD 021H
	DD	imagerel objargs_mktuple
	DD	imagerel objargs_mktuple+69
	DD	imagerel $unwind$objargs_mktuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$objargs_mktuple DD 020521H
	DD	087405H
	DD	imagerel objargs_mktuple
	DD	imagerel objargs_mktuple+69
	DD	imagerel $unwind$objargs_mktuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$objargs_mktuple DD 081501H
	DD	0b6415H
	DD	0a5415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT objargs_mktuple
_TEXT	SEGMENT
va$ = 64
objargs_mktuple PROC					; COMDAT

; 2265 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2266 :     int i, n = 0;

  00015	33 db		 xor	 ebx, ebx
  00017	4c 8b e1	 mov	 r12, rcx

; 2267 :     va_list countva;
; 2268 :     PyObject *result, *tmp;
; 2269 : 
; 2270 :         Py_VA_COPY(countva, va);
; 2271 : 
; 2272 :     while (((PyObject *)va_arg(countva, PyObject *)) != NULL)

  0001a	48 8b c1	 mov	 rax, rcx
  0001d	48 39 19	 cmp	 QWORD PTR [rcx], rbx
  00020	74 0c		 je	 SHORT $LN5@objargs_mk
$LL6@objargs_mk:
  00022	48 83 c0 08	 add	 rax, 8

; 2273 :         ++n;

  00026	ff c3		 inc	 ebx
  00028	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002c	75 f4		 jne	 SHORT $LL6@objargs_mk
$LN5@objargs_mk:

; 2274 :     result = PyTuple_New(n);

  0002e	48 63 f3	 movsxd	 rsi, ebx
  00031	48 8b ce	 mov	 rcx, rsi
  00034	e8 00 00 00 00	 call	 PyTuple_New
  00039	48 8b e8	 mov	 rbp, rax

; 2275 :     if (result != NULL && n > 0) {

  0003c	48 85 c0	 test	 rax, rax
  0003f	74 69		 je	 SHORT $LN1@objargs_mk
  00041	85 db		 test	 ebx, ebx
  00043	7e 65		 jle	 SHORT $LN1@objargs_mk

; 2276 :         for (i = 0; i < n; ++i) {

  00045	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004a	49 83 c4 f8	 add	 r12, -8

; 2278 :             PyTuple_SET_ITEM(result, i, tmp);

  0004e	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
$LL3@objargs_mk:

; 2277 :             tmp = (PyObject *)va_arg(va, PyObject *);

  00052	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]
  00057	49 83 c4 08	 add	 r12, 8

; 2278 :             PyTuple_SET_ITEM(result, i, tmp);

  0005b	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 2279 :             Py_INCREF(tmp);

  0005e	e8 00 00 00 00	 call	 _Py_PXCTX
  00063	85 c0		 test	 eax, eax
  00065	75 32		 jne	 SHORT $LN2@objargs_mk
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00075	4c 8b cb	 mov	 r9, rbx
  00078	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00086	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008b	85 c0		 test	 eax, eax
  0008d	75 06		 jne	 SHORT $LN9@objargs_mk
  0008f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00093	74 04		 je	 SHORT $LN2@objargs_mk
$LN9@objargs_mk:
  00095	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@objargs_mk:

; 2276 :         for (i = 0; i < n; ++i) {

  00099	48 83 c7 08	 add	 rdi, 8
  0009d	48 ff ce	 dec	 rsi
  000a0	75 b0		 jne	 SHORT $LL3@objargs_mk

; 2280 :         }
; 2281 :     }
; 2282 :     return result;

  000a2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000a7	48 8b c5	 mov	 rax, rbp
$LN1@objargs_mk:

; 2283 : }

  000aa	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000af	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000b4	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	41 5c		 pop	 r12
  000bf	c3		 ret	 0
objargs_mktuple ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallMethodObjArgs
EXTRN	PyObject_GetAttr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallMethodObjArgs DD imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_CallMethodObjArgs DD imagerel $LN9+37
	DD	imagerel $LN9+65
	DD	imagerel $chain$0$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_CallMethodObjArgs DD imagerel $LN9+65
	DD	imagerel $LN9+113
	DD	imagerel $chain$3$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyObject_CallMethodObjArgs DD imagerel $LN9+113
	DD	imagerel $LN9+171
	DD	imagerel $chain$6$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyObject_CallMethodObjArgs DD imagerel $LN9+171
	DD	imagerel $LN9+181
	DD	imagerel $chain$7$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyObject_CallMethodObjArgs DD 021H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyObject_CallMethodObjArgs DD 060b21H
	DD	06340bH
	DD	047400H
	DD	056400H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_CallMethodObjArgs DD 040a21H
	DD	05640aH
	DD	047400H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_CallMethodObjArgs DD 020521H
	DD	047405H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallMethodObjArgs DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_CallMethodObjArgs
_TEXT	SEGMENT
callable$ = 64
name$ = 72
PyObject_CallMethodObjArgs PROC				; COMDAT

; 2287 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2288 :     PyObject *args, *tmp;
; 2289 :     va_list vargs;
; 2290 : 
; 2291 :     if (callable == NULL || name == NULL)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 8f 00 00
	00		 je	 $LN3@PyObject_C@8
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 86 00 00
	00		 je	 $LN3@PyObject_C@8

; 2293 : 
; 2294 :     callable = PyObject_GetAttr(callable, name);

  00025	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0002a	e8 00 00 00 00	 call	 PyObject_GetAttr
  0002f	48 8b f8	 mov	 rdi, rax

; 2295 :     if (callable == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0a		 jne	 SHORT $LN2@PyObject_C@8
  00037	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2311 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
$LN2@PyObject_C@8:

; 2296 :         return NULL;
; 2297 : 
; 2298 :     /* count the args */
; 2299 :     va_start(vargs, name);

  00041	48 8d 4c 24 50	 lea	 rcx, QWORD PTR name$[rsp+8]
  00046	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi

; 2300 :     args = objargs_mktuple(vargs);

  0004b	e8 00 00 00 00	 call	 objargs_mktuple

; 2301 :     va_end(vargs);
; 2302 :     if (args == NULL) {
; 2303 :         Py_DECREF(callable);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	48 8b f0	 mov	 rsi, rax
  00056	48 85 c0	 test	 rax, rax
  00059	75 16		 jne	 SHORT $LN1@PyObject_C@8
  0005b	e8 00 00 00 00	 call	 _Py_DecRef
  00060	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00065	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2304 :         return NULL;

  0006a	33 c0		 xor	 eax, eax

; 2311 : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
$LN1@PyObject_C@8:

; 2305 :     }
; 2306 :     tmp = PyObject_Call(callable, args, NULL);

  00071	45 33 c0	 xor	 r8d, r8d
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0007c	e8 00 00 00 00	 call	 PyObject_Call

; 2307 :     Py_DECREF(args);

  00081	48 8b ce	 mov	 rcx, rsi
  00084	48 8b d8	 mov	 rbx, rax
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 2308 :     Py_DECREF(callable);

  0008c	48 8b cf	 mov	 rcx, rdi
  0008f	e8 00 00 00 00	 call	 _Py_DecRef
  00094	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00099	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2309 : 
; 2310 :     return tmp;

  0009e	48 8b c3	 mov	 rax, rbx
  000a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2311 : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
$LN3@PyObject_C@8:

; 2292 :         return null_error();

  000ab	e8 00 00 00 00	 call	 null_error

; 2311 : }

  000b0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b4	c3		 ret	 0
PyObject_CallMethodObjArgs ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethodObjIdArgs
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodObjIdArgs DD imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyObject_CallMethodObjIdArgs DD imagerel $LN9+37
	DD	imagerel $LN9+65
	DD	imagerel $chain$0$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyObject_CallMethodObjIdArgs DD imagerel $LN9+65
	DD	imagerel $LN9+113
	DD	imagerel $chain$3$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyObject_CallMethodObjIdArgs DD imagerel $LN9+113
	DD	imagerel $LN9+171
	DD	imagerel $chain$6$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_PyObject_CallMethodObjIdArgs DD imagerel $LN9+171
	DD	imagerel $LN9+181
	DD	imagerel $chain$7$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_PyObject_CallMethodObjIdArgs DD 021H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyObject_CallMethodObjIdArgs DD 060b21H
	DD	06340bH
	DD	047400H
	DD	056400H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyObject_CallMethodObjIdArgs DD 040a21H
	DD	05640aH
	DD	047400H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyObject_CallMethodObjIdArgs DD 020521H
	DD	047405H
	DD	imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodObjIdArgs DD 011301H
	DD	06213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_CallMethodObjIdArgs
_TEXT	SEGMENT
callable$ = 64
name$ = 72
_PyObject_CallMethodObjIdArgs PROC			; COMDAT

; 2316 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2317 :     PyObject *args, *tmp;
; 2318 :     va_list vargs;
; 2319 : 
; 2320 :     if (callable == NULL || name == NULL)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 8f 00 00
	00		 je	 $LN3@PyObject_C@9
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 86 00 00
	00		 je	 $LN3@PyObject_C@9

; 2322 : 
; 2323 :     callable = _PyObject_GetAttrId(callable, name);

  00025	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0002a	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0002f	48 8b f8	 mov	 rdi, rax

; 2324 :     if (callable == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0a		 jne	 SHORT $LN2@PyObject_C@9
  00037	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2340 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
$LN2@PyObject_C@9:

; 2325 :         return NULL;
; 2326 : 
; 2327 :     /* count the args */
; 2328 :     va_start(vargs, name);

  00041	48 8d 4c 24 50	 lea	 rcx, QWORD PTR name$[rsp+8]
  00046	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi

; 2329 :     args = objargs_mktuple(vargs);

  0004b	e8 00 00 00 00	 call	 objargs_mktuple

; 2330 :     va_end(vargs);
; 2331 :     if (args == NULL) {
; 2332 :         Py_DECREF(callable);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	48 8b f0	 mov	 rsi, rax
  00056	48 85 c0	 test	 rax, rax
  00059	75 16		 jne	 SHORT $LN1@PyObject_C@9
  0005b	e8 00 00 00 00	 call	 _Py_DecRef
  00060	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00065	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2333 :         return NULL;

  0006a	33 c0		 xor	 eax, eax

; 2340 : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
$LN1@PyObject_C@9:

; 2334 :     }
; 2335 :     tmp = PyObject_Call(callable, args, NULL);

  00071	45 33 c0	 xor	 r8d, r8d
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0007c	e8 00 00 00 00	 call	 PyObject_Call

; 2336 :     Py_DECREF(args);

  00081	48 8b ce	 mov	 rcx, rsi
  00084	48 8b d8	 mov	 rbx, rax
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 2337 :     Py_DECREF(callable);

  0008c	48 8b cf	 mov	 rcx, rdi
  0008f	e8 00 00 00 00	 call	 _Py_DecRef
  00094	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00099	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2338 : 
; 2339 :     return tmp;

  0009e	48 8b c3	 mov	 rax, rbx
  000a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2340 : }

  000a6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000aa	c3		 ret	 0
$LN3@PyObject_C@9:

; 2321 :         return null_error();

  000ab	e8 00 00 00 00	 call	 null_error

; 2340 : }

  000b0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b4	c3		 ret	 0
_PyObject_CallMethodObjIdArgs ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallFunctionObjArgs
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallFunctionObjArgs DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$PyObject_CallFunctionObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_CallFunctionObjArgs DD imagerel $LN6+44
	DD	imagerel $LN6+72
	DD	imagerel $chain$0$PyObject_CallFunctionObjArgs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_CallFunctionObjArgs DD imagerel $LN6+72
	DD	imagerel $LN6+122
	DD	imagerel $chain$3$PyObject_CallFunctionObjArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_CallFunctionObjArgs DD 041021H
	DD	063410H
	DD	057400H
	DD	imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$PyObject_CallFunctionObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_CallFunctionObjArgs DD 020521H
	DD	057405H
	DD	imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$PyObject_CallFunctionObjArgs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallFunctionObjArgs DD 011801H
	DD	06218H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_CallFunctionObjArgs
_TEXT	SEGMENT
callable$ = 64
PyObject_CallFunctionObjArgs PROC			; COMDAT

; 2344 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2345 :     PyObject *args, *tmp;
; 2346 :     va_list vargs;
; 2347 : 
; 2348 :     if (callable == NULL)

  00018	48 85 c9	 test	 rcx, rcx
  0001b	75 0a		 jne	 SHORT $LN2@PyObject_C@10

; 2349 :         return null_error();

  0001d	e8 00 00 00 00	 call	 null_error

; 2361 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
$LN2@PyObject_C@10:

; 2350 : 
; 2351 :     /* count the args */
; 2352 :     va_start(vargs, callable);

  00027	48 8d 4c 24 48	 lea	 rcx, QWORD PTR callable$[rsp+8]
  0002c	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi

; 2353 :     args = objargs_mktuple(vargs);

  00031	e8 00 00 00 00	 call	 objargs_mktuple
  00036	48 8b f8	 mov	 rdi, rax

; 2354 :     va_end(vargs);
; 2355 :     if (args == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	75 0a		 jne	 SHORT $LN1@PyObject_C@10
  0003e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 2361 : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
$LN1@PyObject_C@10:

; 2356 :         return NULL;
; 2357 :     tmp = PyObject_Call(callable, args, NULL);

  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR callable$[rsp]
  0004d	45 33 c0	 xor	 r8d, r8d
  00050	48 8b d0	 mov	 rdx, rax
  00053	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00058	e8 00 00 00 00	 call	 PyObject_Call

; 2358 :     Py_DECREF(args);

  0005d	48 8b cf	 mov	 rcx, rdi
  00060	48 8b d8	 mov	 rbx, rax
  00063	e8 00 00 00 00	 call	 _Py_DecRef
  00068	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 2359 : 
; 2360 :     return tmp;

  0006d	48 8b c3	 mov	 rax, rbx
  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2361 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
PyObject_CallFunctionObjArgs ENDP
_TEXT	ENDS
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$abstract_get_bases DD imagerel abstract_get_bases
	DD	imagerel abstract_get_bases+219
	DD	imagerel $unwind$abstract_get_bases
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$abstract_get_bases DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT abstract_get_bases
_TEXT	SEGMENT
cls$ = 48
abstract_get_bases PROC					; COMDAT

; 2392 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2393 :     _Py_IDENTIFIER(__bases__);
; 2394 :     PyObject *bases;
; 2395 : 
; 2396 :     Py_ALLOW_RECURSION

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN9@abstract_g
  00016	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0001b	eb 07		 jmp	 SHORT $LN10@abstract_g
$LN9@abstract_g:
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN10@abstract_g:
  00024	0f b6 78 1d	 movzx	 edi, BYTE PTR [rax+29]
  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN11@abstract_g
  00031	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00036	eb 07		 jmp	 SHORT $LN12@abstract_g
$LN11@abstract_g:
  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN12@abstract_g:

; 2397 :     bases = _PyObject_GetAttrId(cls, &PyId___bases__);

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00045	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1
  00049	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00052	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___bases__@?1??abstract_get_bases@@9@9
  00057	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00063	48 8b d8	 mov	 rbx, rax

; 2398 :     Py_END_ALLOW_RECURSION

  00066	e8 00 00 00 00	 call	 _Py_PXCTX
  0006b	85 c0		 test	 eax, eax
  0006d	74 07		 je	 SHORT $LN13@abstract_g
  0006f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00074	eb 07		 jmp	 SHORT $LN14@abstract_g
$LN13@abstract_g:
  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN14@abstract_g:
  0007d	40 88 78 1d	 mov	 BYTE PTR [rax+29], dil

; 2399 :     if (bases == NULL) {

  00081	48 85 db	 test	 rbx, rbx
  00084	75 22		 jne	 SHORT $LN3@abstract_g

; 2400 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00086	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0008d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00092	85 c0		 test	 eax, eax
  00094	74 05		 je	 SHORT $LN2@abstract_g

; 2401 :             PyErr_Clear();

  00096	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@abstract_g:

; 2402 :         return NULL;

  0009b	33 c0		 xor	 eax, eax

; 2409 : }

  0009d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
$LN3@abstract_g:

; 2403 :     }
; 2404 :     if (!PyTuple_Check(bases)) {

  000a8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000ac	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  000b6	75 15		 jne	 SHORT $LN1@abstract_g

; 2405 :         Py_DECREF(bases);

  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 _Py_DecRef

; 2406 :         return NULL;

  000c0	33 c0		 xor	 eax, eax

; 2409 : }

  000c2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cb	5f		 pop	 rdi
  000cc	c3		 ret	 0
$LN1@abstract_g:

; 2407 :     }
; 2408 :     return bases;

  000cd	48 8b c3	 mov	 rax, rbx

; 2409 : }

  000d0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
abstract_get_bases ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$abstract_issubclass DD imagerel abstract_issubclass
	DD	imagerel abstract_issubclass+240
	DD	imagerel $unwind$abstract_issubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$abstract_issubclass DD 061101H
	DD	0a3411H
	DD	0700d3211H
	DD	0500b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT abstract_issubclass
_TEXT	SEGMENT
bases$1$ = 64
derived$ = 64
tv188 = 72
cls$ = 72
abstract_issubclass PROC				; COMDAT

; 2414 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2415 :     PyObject *bases = NULL;
; 2416 :     Py_ssize_t i, n;
; 2417 :     int r = 0;

  00011	33 ed		 xor	 ebp, ebp
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b f9	 mov	 rdi, rcx

; 2418 : 
; 2419 :     while (1) {
; 2420 :         if (derived == cls)

  00019	48 3b ca	 cmp	 rcx, rdx
  0001c	74 3f		 je	 SHORT $LN16@abstract_i
  0001e	66 90		 npad	 2
$LL11@abstract_i:

; 2422 :         bases = abstract_get_bases(derived);

  00020	48 8b cf	 mov	 rcx, rdi
  00023	e8 00 00 00 00	 call	 abstract_get_bases
  00028	48 8b d8	 mov	 rbx, rax
  0002b	48 89 44 24 40	 mov	 QWORD PTR bases$1$[rsp], rax

; 2423 :         if (bases == NULL) {

  00030	48 85 c0	 test	 rax, rax
  00033	0f 84 a0 00 00
	00		 je	 $LN17@abstract_i

; 2425 :                 return -1;
; 2426 :             return 0;
; 2427 :         }
; 2428 :         n = PyTuple_GET_SIZE(bases);

  00039	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 2429 :         if (n == 0) {

  0003d	48 85 ff	 test	 rdi, rdi
  00040	0f 84 7c 00 00
	00		 je	 $LN18@abstract_i

; 2432 :         }
; 2433 :         /* Avoid recursivity in the single inheritance case */
; 2434 :         if (n == 1) {

  00046	48 83 ff 01	 cmp	 rdi, 1
  0004a	75 23		 jne	 SHORT $LN5@abstract_i

; 2435 :             derived = PyTuple_GET_ITEM(bases, 0);

  0004c	48 8b 78 70	 mov	 rdi, QWORD PTR [rax+112]

; 2436 :             Py_DECREF(bases);

  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 _Py_DecRef
  00058	48 3b fe	 cmp	 rdi, rsi
  0005b	75 c3		 jne	 SHORT $LL11@abstract_i
$LN16@abstract_i:

; 2421 :             return 1;

  0005d	b8 01 00 00 00	 mov	 eax, 1

; 2446 :     }
; 2447 : }

  00062	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	5e		 pop	 rsi
  0006d	5d		 pop	 rbp
  0006e	c3		 ret	 0
$LN5@abstract_i:

; 2437 :             continue;
; 2438 :         }
; 2439 :         for (i = 0; i < n; i++) {

  0006f	48 8b f5	 mov	 rsi, rbp
  00072	48 85 ff	 test	 rdi, rdi
  00075	7e 34		 jle	 SHORT $LN19@abstract_i
  00077	48 8b 5c 24 48	 mov	 rbx, QWORD PTR cls$[rsp]
  0007c	48 8d 68 70	 lea	 rbp, QWORD PTR [rax+112]
$LL4@abstract_i:

; 2440 :             r = abstract_issubclass(PyTuple_GET_ITEM(bases, i), cls);

  00080	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00084	48 8b d3	 mov	 rdx, rbx
  00087	e8 00 00 00 00	 call	 abstract_issubclass
  0008c	48 89 44 24 48	 mov	 QWORD PTR tv188[rsp], rax

; 2441 :             if (r != 0)

  00091	85 c0		 test	 eax, eax
  00093	75 0c		 jne	 SHORT $LN22@abstract_i

; 2437 :             continue;
; 2438 :         }
; 2439 :         for (i = 0; i < n; i++) {

  00095	48 ff c6	 inc	 rsi
  00098	48 83 c5 08	 add	 rbp, 8
  0009c	48 3b f7	 cmp	 rsi, rdi
  0009f	7c df		 jl	 SHORT $LL4@abstract_i
$LN22@abstract_i:
  000a1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR bases$1$[rsp]
  000a6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR tv188[rsp]
$LN19@abstract_i:

; 2442 :                 break;
; 2443 :         }
; 2444 :         Py_DECREF(bases);

  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 2445 :         return r;

  000b3	8b c5		 mov	 eax, ebp

; 2446 :     }
; 2447 : }

  000b5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	5e		 pop	 rsi
  000c0	5d		 pop	 rbp
  000c1	c3		 ret	 0
$LN18@abstract_i:

; 2430 :             Py_DECREF(bases);

  000c2	48 8b c8	 mov	 rcx, rax
  000c5	e8 00 00 00 00	 call	 _Py_DecRef

; 2431 :             return 0;

  000ca	33 c0		 xor	 eax, eax

; 2446 :     }
; 2447 : }

  000cc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5f		 pop	 rdi
  000d6	5e		 pop	 rsi
  000d7	5d		 pop	 rbp
  000d8	c3		 ret	 0
$LN17@abstract_i:

; 2424 :             if (PyErr_Occurred())

  000d9	e8 00 00 00 00	 call	 PyErr_Occurred

; 2446 :     }
; 2447 : }

  000de	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000e3	48 f7 d8	 neg	 rax
  000e6	1b c0		 sbb	 eax, eax
  000e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ec	5f		 pop	 rdi
  000ed	5e		 pop	 rsi
  000ee	5d		 pop	 rbp
  000ef	c3		 ret	 0
abstract_issubclass ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_class DD imagerel check_class
	DD	imagerel check_class+69
	DD	imagerel $unwind$check_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_class DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT check_class
_TEXT	SEGMENT
cls$ = 48
error$ = 56
check_class PROC					; COMDAT

; 2451 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 2452 :     PyObject *bases = abstract_get_bases(cls);

  00009	e8 00 00 00 00	 call	 abstract_get_bases

; 2453 :     if (bases == NULL) {

  0000e	48 85 c0	 test	 rax, rax
  00011	75 21		 jne	 SHORT $LN2@check_clas

; 2454 :         /* Do not mask errors. */
; 2455 :         if (!PyErr_Occurred())

  00013	e8 00 00 00 00	 call	 PyErr_Occurred
  00018	48 85 c0	 test	 rax, rax
  0001b	75 0f		 jne	 SHORT $LN1@check_clas

; 2456 :             PyErr_SetString(PyExc_TypeError, error);

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00024	48 8b d3	 mov	 rdx, rbx
  00027	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@check_clas:

; 2457 :         return 0;

  0002c	33 c0		 xor	 eax, eax

; 2461 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
$LN2@check_clas:

; 2458 :     }
; 2459 :     Py_DECREF(bases);

  00034	48 8b c8	 mov	 rcx, rax
  00037	e8 00 00 00 00	 call	 _Py_DecRef

; 2460 :     return -1;

  0003c	83 c8 ff	 or	 eax, -1

; 2461 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
check_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$recursive_isinstance DD imagerel recursive_isinstance
	DD	imagerel recursive_isinstance+284
	DD	imagerel $unwind$recursive_isinstance
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recursive_isinstance DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@
CONST	SEGMENT
??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@ DB 'isin'
	DB	'stance() arg 2 must be a type or tuple of types', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT recursive_isinstance
_TEXT	SEGMENT
inst$ = 48
cls$ = 56
recursive_isinstance PROC				; COMDAT

; 2465 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2466 :     PyObject *icls;
; 2467 :     int retval = 0;
; 2468 :     _Py_IDENTIFIER(__class__);
; 2469 : 
; 2470 :     if (PyType_Check(cls)) {

  00014	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00018	33 db		 xor	 ebx, ebx
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  00027	48 8b e9	 mov	 rbp, rcx
  0002a	74 68		 je	 SHORT $LN13@recursive_

; 2471 :         retval = PyObject_TypeCheck(inst, (PyTypeObject *)cls);

  0002c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00030	48 3b ca	 cmp	 rcx, rdx
  00033	74 58		 je	 SHORT $LN16@recursive_
  00035	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003a	85 c0		 test	 eax, eax
  0003c	75 4f		 jne	 SHORT $LN16@recursive_

; 2473 :             PyObject *c = _PyObject_GetAttrId(inst, &PyId___class__);

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00044	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0004d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___class__@?1??recursive_isinstance@@9@9
  00052	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00056	48 8b cd	 mov	 rcx, rbp
  00059	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0005e	48 8b f0	 mov	 rsi, rax

; 2474 :             if (c == NULL) {

  00061	48 85 c0	 test	 rax, rax

; 2475 :                 if (PyErr_ExceptionMatches(PyExc_AttributeError))
; 2476 :                     PyErr_Clear();
; 2477 :                 else

  00064	74 6e		 je	 SHORT $LN20@recursive_

; 2478 :                     retval = -1;
; 2479 :             }
; 2480 :             else {
; 2481 :                 if (c != (PyObject *)(inst->ob_type) &&
; 2482 :                     PyType_Check(c))

  00066	48 3b 45 58	 cmp	 rax, QWORD PTR [rbp+88]
  0006a	0f 84 8d 00 00
	00		 je	 $LN7@recursive_
  00070	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00074	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  0007e	74 7d		 je	 SHORT $LN7@recursive_

; 2483 :                     retval = PyType_IsSubtype(
; 2484 :                         (PyTypeObject *)c,
; 2485 :                         (PyTypeObject *)cls);

  00080	48 8b d7	 mov	 rdx, rdi
  00083	48 8b ce	 mov	 rcx, rsi
  00086	e8 00 00 00 00	 call	 PyType_IsSubtype

; 2486 :                 Py_DECREF(c);
; 2487 :             }
; 2488 :         }
; 2489 :     }
; 2490 :     else {

  0008b	eb 6e		 jmp	 SHORT $LN19@recursive_
$LN16@recursive_:

; 2471 :         retval = PyObject_TypeCheck(inst, (PyTypeObject *)cls);

  0008d	bb 01 00 00 00	 mov	 ebx, 1

; 2472 :         if (retval == 0) {

  00092	eb 71		 jmp	 SHORT $LN1@recursive_
$LN13@recursive_:

; 2491 :         if (!check_class(cls,
; 2492 :             "isinstance() arg 2 must be a type or tuple of types"))

  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@
  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 check_class
  000a3	85 c0		 test	 eax, eax
  000a5	75 05		 jne	 SHORT $LN5@recursive_

; 2493 :             return -1;

  000a7	83 c8 ff	 or	 eax, -1
  000aa	eb 5b		 jmp	 SHORT $LN14@recursive_
$LN5@recursive_:

; 2494 :         icls = _PyObject_GetAttrId(inst, &PyId___class__);

  000ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b2	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000bb	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___class__@?1??recursive_isinstance@@9@9
  000c0	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000c4	48 8b cd	 mov	 rcx, rbp
  000c7	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000cc	48 8b f0	 mov	 rsi, rax

; 2495 :         if (icls == NULL) {

  000cf	48 85 c0	 test	 rax, rax
  000d2	75 1c		 jne	 SHORT $LN4@recursive_
$LN20@recursive_:

; 2496 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000db	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000e0	85 c0		 test	 eax, eax
  000e2	74 07		 je	 SHORT $LN3@recursive_

; 2497 :                 PyErr_Clear();

  000e4	e8 00 00 00 00	 call	 PyErr_Clear

; 2498 :             else

  000e9	eb 1a		 jmp	 SHORT $LN1@recursive_
$LN3@recursive_:

; 2499 :                 retval = -1;

  000eb	83 cb ff	 or	 ebx, -1

; 2500 :         }
; 2501 :         else {

  000ee	eb 15		 jmp	 SHORT $LN1@recursive_
$LN4@recursive_:

; 2502 :             retval = abstract_issubclass(icls, cls);

  000f0	48 8b d7	 mov	 rdx, rdi
  000f3	48 8b c8	 mov	 rcx, rax
  000f6	e8 00 00 00 00	 call	 abstract_issubclass
$LN19@recursive_:
  000fb	8b d8		 mov	 ebx, eax
$LN7@recursive_:

; 2503 :             Py_DECREF(icls);

  000fd	48 8b ce	 mov	 rcx, rsi
  00100	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@recursive_:

; 2504 :         }
; 2505 :     }
; 2506 : 
; 2507 :     return retval;

  00105	8b c3		 mov	 eax, ebx
$LN14@recursive_:

; 2508 : }

  00107	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00111	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00116	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011a	5f		 pop	 rdi
  0011b	c3		 ret	 0
recursive_isinstance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@	; `string'
PUBLIC	PyObject_IsInstance
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_IsInstance DD imagerel $LN46
	DD	imagerel $LN46+591
	DD	imagerel $unwind$PyObject_IsInstance
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_IsInstance DD 083901H
	DD	085439H
	DD	073434H
	DD	09640fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
CONST	SEGMENT
??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@ DB ' in __instancecheck__'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_IsInstance
_TEXT	SEGMENT
inst$ = 48
cls$ = 56
PyObject_IsInstance PROC				; COMDAT

; 2512 : {

$LN46:
  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 2513 :     _Py_IDENTIFIER(__instancecheck__);
; 2514 :     PyObject *checker;
; 2515 : 
; 2516 :     /* Quick test for an exact match */
; 2517 :     if (Py_TYPE(inst) == (PyTypeObject *)cls)

  00015	48 39 51 58	 cmp	 QWORD PTR [rcx+88], rdx
  00019	75 10		 jne	 SHORT $LN20@PyObject_I

; 2518 :         return 1;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 2559 : }

  00020	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN20@PyObject_I:

; 2519 : 
; 2520 :     if (PyTuple_Check(cls)) {

  0002b	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0002f	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00034	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00039	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00043	0f 84 db 00 00
	00		 je	 $LN19@PyObject_I

; 2521 :         Py_ssize_t i;
; 2522 :         Py_ssize_t n;
; 2523 :         int r = 0;

  00049	33 ed		 xor	 ebp, ebp

; 2524 : 
; 2525 :         if (Py_EnterRecursiveCall(" in __instancecheck__"))

  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	74 07		 je	 SHORT $LN23@PyObject_I
  00054	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00059	eb 07		 jmp	 SHORT $LN24@PyObject_I
$LN23@PyObject_I:
  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN24@PyObject_I:
  00062	ff 40 18	 inc	 DWORD PTR [rax+24]
  00065	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00068	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  0006e	7e 14		 jle	 SHORT $LN18@PyObject_I
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
  00077	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0007c	85 c0		 test	 eax, eax

; 2526 :             return -1;

  0007e	0f 85 a6 01 00
	00		 jne	 $LN45@PyObject_I
$LN18@PyObject_I:

; 2527 :         n = PyTuple_GET_SIZE(cls);

  00084	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 2528 :         for (i = 0; i < n; ++i) {

  00088	48 8b dd	 mov	 rbx, rbp
  0008b	48 85 f6	 test	 rsi, rsi
  0008e	7e 2f		 jle	 SHORT $LN13@PyObject_I

; 2527 :         n = PyTuple_GET_SIZE(cls);

  00090	48 83 c7 70	 add	 rdi, 112		; 00000070H
  00094	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL17@PyObject_I:

; 2529 :             PyObject *item = PyTuple_GET_ITEM(cls, i);
; 2530 :             r = PyObject_IsInstance(inst, item);

  000a0	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	e8 00 00 00 00	 call	 PyObject_IsInstance
  000ad	8b e8		 mov	 ebp, eax

; 2531 :             if (r != 0)

  000af	85 c0		 test	 eax, eax
  000b1	75 0c		 jne	 SHORT $LN13@PyObject_I

; 2528 :         for (i = 0; i < n; ++i) {

  000b3	48 ff c3	 inc	 rbx
  000b6	48 83 c7 08	 add	 rdi, 8
  000ba	48 3b de	 cmp	 rbx, rsi
  000bd	7c e1		 jl	 SHORT $LL17@PyObject_I
$LN13@PyObject_I:

; 2532 :                 /* either found it, or got an error */
; 2533 :                 break;
; 2534 :         }
; 2535 :         Py_LeaveRecursiveCall();

  000bf	e8 00 00 00 00	 call	 _Py_PXCTX
  000c4	85 c0		 test	 eax, eax
  000c6	74 0a		 je	 SHORT $LN25@PyObject_I
  000c8	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000cd	4c 8b d8	 mov	 r11, rax
  000d0	eb 07		 jmp	 SHORT $LN26@PyObject_I
$LN25@PyObject_I:
  000d2	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN26@PyObject_I:
  000d9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  000df	83 f8 64	 cmp	 eax, 100		; 00000064H
  000e2	7e 05		 jle	 SHORT $LN27@PyObject_I
  000e4	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  000e7	eb 06		 jmp	 SHORT $LN28@PyObject_I
$LN27@PyObject_I:
  000e9	c1 f8 02	 sar	 eax, 2
  000ec	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN28@PyObject_I:
  000ef	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  000f3	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  000f7	7d 24		 jge	 SHORT $LN12@PyObject_I
  000f9	e8 00 00 00 00	 call	 _Py_PXCTX
  000fe	85 c0		 test	 eax, eax
  00100	74 10		 je	 SHORT $LN29@PyObject_I
  00102	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00107	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2536 :         return r;

  0010b	8b c5		 mov	 eax, ebp
  0010d	e9 28 01 00 00	 jmp	 $LN44@PyObject_I
$LN29@PyObject_I:

; 2532 :                 /* either found it, or got an error */
; 2533 :                 break;
; 2534 :         }
; 2535 :         Py_LeaveRecursiveCall();

  00112	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00119	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN12@PyObject_I:

; 2536 :         return r;

  0011d	8b c5		 mov	 eax, ebp
  0011f	e9 16 01 00 00	 jmp	 $LN44@PyObject_I
$LN19@PyObject_I:

; 2537 :     }
; 2538 : 
; 2539 :     checker = _PyObject_LookupSpecial(cls, &PyId___instancecheck__);

  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0012a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00133	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___instancecheck__@?1??PyObject_IsInstance@@9@9
  00138	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0013c	48 8b cf	 mov	 rcx, rdi
  0013f	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00144	48 8b e8	 mov	 rbp, rax

; 2540 :     if (checker != NULL) {

  00147	48 85 c0	 test	 rax, rax
  0014a	0f 84 d0 00 00
	00		 je	 $LN9@PyObject_I

; 2541 :         PyObject *res;
; 2542 :         int ok = -1;

  00150	83 cb ff	 or	 ebx, -1

; 2543 :         if (Py_EnterRecursiveCall(" in __instancecheck__")) {

  00153	e8 00 00 00 00	 call	 _Py_PXCTX
  00158	85 c0		 test	 eax, eax
  0015a	74 07		 je	 SHORT $LN31@PyObject_I
  0015c	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00161	eb 07		 jmp	 SHORT $LN32@PyObject_I
$LN31@PyObject_I:
  00163	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN32@PyObject_I:
  0016a	ff 40 18	 inc	 DWORD PTR [rax+24]
  0016d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00170	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00176	7e 1f		 jle	 SHORT $LN8@PyObject_I
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
  0017f	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00184	85 c0		 test	 eax, eax
  00186	74 0f		 je	 SHORT $LN8@PyObject_I

; 2544 :             Py_DECREF(checker);

  00188	48 8b cd	 mov	 rcx, rbp
  0018b	e8 00 00 00 00	 call	 _Py_DecRef

; 2545 :             return ok;

  00190	8b c3		 mov	 eax, ebx
  00192	e9 a3 00 00 00	 jmp	 $LN44@PyObject_I
$LN8@PyObject_I:

; 2546 :         }
; 2547 :         res = PyObject_CallFunctionObjArgs(checker, inst, NULL);

  00197	45 33 c0	 xor	 r8d, r8d
  0019a	48 8b d6	 mov	 rdx, rsi
  0019d	48 8b cd	 mov	 rcx, rbp
  001a0	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  001a5	48 8b f8	 mov	 rdi, rax

; 2548 :         Py_LeaveRecursiveCall();

  001a8	e8 00 00 00 00	 call	 _Py_PXCTX
  001ad	85 c0		 test	 eax, eax
  001af	74 0a		 je	 SHORT $LN33@PyObject_I
  001b1	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001b6	4c 8b d8	 mov	 r11, rax
  001b9	eb 07		 jmp	 SHORT $LN34@PyObject_I
$LN33@PyObject_I:
  001bb	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN34@PyObject_I:
  001c2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  001c8	83 f8 64	 cmp	 eax, 100		; 00000064H
  001cb	7e 05		 jle	 SHORT $LN35@PyObject_I
  001cd	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  001d0	eb 06		 jmp	 SHORT $LN36@PyObject_I
$LN35@PyObject_I:
  001d2	c1 f8 02	 sar	 eax, 2
  001d5	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN36@PyObject_I:
  001d8	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  001dc	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  001e0	7d 1b		 jge	 SHORT $LN6@PyObject_I
  001e2	e8 00 00 00 00	 call	 _Py_PXCTX
  001e7	85 c0		 test	 eax, eax
  001e9	74 07		 je	 SHORT $LN37@PyObject_I
  001eb	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001f0	eb 07		 jmp	 SHORT $LN38@PyObject_I
$LN37@PyObject_I:
  001f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN38@PyObject_I:
  001f9	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN6@PyObject_I:

; 2549 :         Py_DECREF(checker);

  001fd	48 8b cd	 mov	 rcx, rbp
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 2550 :         if (res != NULL) {

  00205	48 85 ff	 test	 rdi, rdi
  00208	74 12		 je	 SHORT $LN3@PyObject_I

; 2551 :             ok = PyObject_IsTrue(res);

  0020a	48 8b cf	 mov	 rcx, rdi
  0020d	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2552 :             Py_DECREF(res);

  00212	48 8b cf	 mov	 rcx, rdi
  00215	8b d8		 mov	 ebx, eax
  00217	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_I:

; 2553 :         }
; 2554 :         return ok;

  0021c	8b c3		 mov	 eax, ebx
  0021e	eb 1a		 jmp	 SHORT $LN44@PyObject_I
$LN9@PyObject_I:

; 2555 :     }
; 2556 :     else if (PyErr_Occurred())

  00220	e8 00 00 00 00	 call	 PyErr_Occurred
  00225	48 85 c0	 test	 rax, rax
  00228	74 05		 je	 SHORT $LN1@PyObject_I
$LN45@PyObject_I:

; 2557 :         return -1;

  0022a	83 c8 ff	 or	 eax, -1
  0022d	eb 0b		 jmp	 SHORT $LN44@PyObject_I
$LN1@PyObject_I:

; 2558 :     return recursive_isinstance(inst, cls);

  0022f	48 8b d7	 mov	 rdx, rdi
  00232	48 8b ce	 mov	 rcx, rsi
  00235	e8 00 00 00 00	 call	 recursive_isinstance
$LN44@PyObject_I:

; 2559 : }

  0023a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0023f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00244	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00249	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0024d	5f		 pop	 rdi
  0024e	c3		 ret	 0
PyObject_IsInstance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@ ; `string'
PUBLIC	??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$recursive_issubclass DD imagerel recursive_issubclass
	DD	imagerel recursive_issubclass+133
	DD	imagerel $unwind$recursive_issubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recursive_issubclass DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@
CONST	SEGMENT
??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@ DB 'issu'
	DB	'bclass() arg 2 must be a class or tuple of classes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@
CONST	SEGMENT
??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@ DB 'issu'
	DB	'bclass() arg 1 must be a class', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT recursive_issubclass
_TEXT	SEGMENT
derived$ = 48
cls$ = 56
recursive_issubclass PROC				; COMDAT

; 2563 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2564 :     if (PyType_Check(cls) && PyType_Check(derived)) {

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  0001e	74 1f		 je	 SHORT $LN3@recursive_@2
  00020	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00024	f7 80 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rax+256], -2147483648 ; ffffffff80000000H
  0002e	74 0f		 je	 SHORT $LN3@recursive_@2

; 2577 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	e9 00 00 00 00	 jmp	 PyType_IsSubtype
$LN3@recursive_@2:

; 2565 :         /* Fast path (non-recursive) */
; 2566 :         return PyType_IsSubtype((PyTypeObject *)derived, (PyTypeObject *)cls);
; 2567 :     }
; 2568 :     if (!check_class(derived,
; 2569 :                      "issubclass() arg 1 must be a class"))

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@
  00046	e8 00 00 00 00	 call	 check_class
  0004b	85 c0		 test	 eax, eax
  0004d	75 0e		 jne	 SHORT $LN2@recursive_@2
$LN6@recursive_@2:

; 2570 :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 2577 : }

  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN2@recursive_@2:

; 2571 :     if (!check_class(cls,
; 2572 :                     "issubclass() arg 2 must be a class"
; 2573 :                     " or tuple of classes"))

  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@
  00064	48 8b cf	 mov	 rcx, rdi
  00067	e8 00 00 00 00	 call	 check_class
  0006c	85 c0		 test	 eax, eax

; 2574 :         return -1;

  0006e	74 df		 je	 SHORT $LN6@recursive_@2

; 2575 : 
; 2576 :     return abstract_issubclass(derived, cls);

  00070	48 8b d7	 mov	 rdx, rdi
  00073	48 8b cb	 mov	 rcx, rbx

; 2577 : }

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	e9 00 00 00 00	 jmp	 abstract_issubclass
recursive_issubclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@	; `string'
PUBLIC	PyObject_IsSubclass
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_IsSubclass DD imagerel $LN43
	DD	imagerel $LN43+560
	DD	imagerel $unwind$PyObject_IsSubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_IsSubclass DD 081901H
	DD	096419H
	DD	085419H
	DD	073419H
	DD	070153219H
xdata	ENDS
;	COMDAT ??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
CONST	SEGMENT
??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@ DB ' in __subclasscheck__'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_IsSubclass
_TEXT	SEGMENT
derived$ = 48
cls$ = 56
PyObject_IsSubclass PROC				; COMDAT

; 2581 : {

$LN43:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2582 :     _Py_IDENTIFIER(__subclasscheck__);
; 2583 :     PyObject *checker;
; 2584 : 
; 2585 :     if (PyTuple_Check(cls)) {

  00019	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	48 8b e9	 mov	 rbp, rcx
  00023	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0002d	0f 84 d3 00 00
	00		 je	 $LN19@PyObject_I@2

; 2586 :         Py_ssize_t i;
; 2587 :         Py_ssize_t n;
; 2588 :         int r = 0;

  00033	33 ed		 xor	 ebp, ebp

; 2589 : 
; 2590 :         if (Py_EnterRecursiveCall(" in __subclasscheck__"))

  00035	e8 00 00 00 00	 call	 _Py_PXCTX
  0003a	85 c0		 test	 eax, eax
  0003c	74 07		 je	 SHORT $LN22@PyObject_I@2
  0003e	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00043	eb 07		 jmp	 SHORT $LN23@PyObject_I@2
$LN22@PyObject_I@2:
  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN23@PyObject_I@2:
  0004c	ff 40 18	 inc	 DWORD PTR [rax+24]
  0004f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00052	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00058	7e 18		 jle	 SHORT $LN18@PyObject_I@2
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
  00061	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00066	85 c0		 test	 eax, eax
  00068	74 08		 je	 SHORT $LN18@PyObject_I@2
$LN42@PyObject_I@2:

; 2591 :             return -1;

  0006a	83 c8 ff	 or	 eax, -1
  0006d	e9 a9 01 00 00	 jmp	 $LN20@PyObject_I@2
$LN18@PyObject_I@2:

; 2592 :         n = PyTuple_GET_SIZE(cls);

  00072	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 2593 :         for (i = 0; i < n; ++i) {

  00076	48 8b dd	 mov	 rbx, rbp
  00079	48 85 f6	 test	 rsi, rsi
  0007c	7e 23		 jle	 SHORT $LN13@PyObject_I@2

; 2592 :         n = PyTuple_GET_SIZE(cls);

  0007e	48 83 c7 70	 add	 rdi, 112		; 00000070H
$LL17@PyObject_I@2:

; 2594 :             PyObject *item = PyTuple_GET_ITEM(cls, i);
; 2595 :             r = PyObject_IsSubclass(derived, item);

  00082	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR derived$[rsp]
  0008a	e8 00 00 00 00	 call	 PyObject_IsSubclass
  0008f	8b e8		 mov	 ebp, eax

; 2596 :             if (r != 0)

  00091	85 c0		 test	 eax, eax
  00093	75 0c		 jne	 SHORT $LN13@PyObject_I@2

; 2593 :         for (i = 0; i < n; ++i) {

  00095	48 ff c3	 inc	 rbx
  00098	48 83 c7 08	 add	 rdi, 8
  0009c	48 3b de	 cmp	 rbx, rsi
  0009f	7c e1		 jl	 SHORT $LL17@PyObject_I@2
$LN13@PyObject_I@2:

; 2597 :                 /* either found it, or got an error */
; 2598 :                 break;
; 2599 :         }
; 2600 :         Py_LeaveRecursiveCall();

  000a1	e8 00 00 00 00	 call	 _Py_PXCTX
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN24@PyObject_I@2
  000aa	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000af	4c 8b d8	 mov	 r11, rax
  000b2	eb 07		 jmp	 SHORT $LN25@PyObject_I@2
$LN24@PyObject_I@2:
  000b4	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN25@PyObject_I@2:
  000bb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  000c1	83 f8 64	 cmp	 eax, 100		; 00000064H
  000c4	7e 05		 jle	 SHORT $LN26@PyObject_I@2
  000c6	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  000c9	eb 06		 jmp	 SHORT $LN27@PyObject_I@2
$LN26@PyObject_I@2:
  000cb	c1 f8 02	 sar	 eax, 2
  000ce	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN27@PyObject_I@2:
  000d1	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  000d5	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  000d9	7d 24		 jge	 SHORT $LN12@PyObject_I@2
  000db	e8 00 00 00 00	 call	 _Py_PXCTX
  000e0	85 c0		 test	 eax, eax
  000e2	74 10		 je	 SHORT $LN28@PyObject_I@2
  000e4	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  000e9	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 2601 :         return r;

  000ed	8b c5		 mov	 eax, ebp
  000ef	e9 27 01 00 00	 jmp	 $LN20@PyObject_I@2
$LN28@PyObject_I@2:

; 2597 :                 /* either found it, or got an error */
; 2598 :                 break;
; 2599 :         }
; 2600 :         Py_LeaveRecursiveCall();

  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  000fb	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN12@PyObject_I@2:

; 2601 :         return r;

  000ff	8b c5		 mov	 eax, ebp
  00101	e9 15 01 00 00	 jmp	 $LN20@PyObject_I@2
$LN19@PyObject_I@2:

; 2602 :     }
; 2603 : 
; 2604 :     checker = _PyObject_LookupSpecial(cls, &PyId___subclasscheck__);

  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0010c	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00115	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___subclasscheck__@?1??PyObject_IsSubclass@@9@9
  0011a	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00126	48 8b f0	 mov	 rsi, rax

; 2605 :     if (checker != NULL) {

  00129	48 85 c0	 test	 rax, rax
  0012c	0f 84 d0 00 00
	00		 je	 $LN9@PyObject_I@2

; 2606 :         PyObject *res;
; 2607 :         int ok = -1;

  00132	83 cb ff	 or	 ebx, -1

; 2608 :         if (Py_EnterRecursiveCall(" in __subclasscheck__")) {

  00135	e8 00 00 00 00	 call	 _Py_PXCTX
  0013a	85 c0		 test	 eax, eax
  0013c	74 07		 je	 SHORT $LN30@PyObject_I@2
  0013e	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00143	eb 07		 jmp	 SHORT $LN31@PyObject_I@2
$LN30@PyObject_I@2:
  00145	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN31@PyObject_I@2:
  0014c	ff 40 18	 inc	 DWORD PTR [rax+24]
  0014f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00152	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00158	7e 1f		 jle	 SHORT $LN8@PyObject_I@2
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
  00161	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00166	85 c0		 test	 eax, eax
  00168	74 0f		 je	 SHORT $LN8@PyObject_I@2

; 2609 :             Py_DECREF(checker);

  0016a	48 8b ce	 mov	 rcx, rsi
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 2610 :             return ok;

  00172	8b c3		 mov	 eax, ebx
  00174	e9 a2 00 00 00	 jmp	 $LN20@PyObject_I@2
$LN8@PyObject_I@2:

; 2611 :         }
; 2612 :         res = PyObject_CallFunctionObjArgs(checker, derived, NULL);

  00179	45 33 c0	 xor	 r8d, r8d
  0017c	48 8b d5	 mov	 rdx, rbp
  0017f	48 8b ce	 mov	 rcx, rsi
  00182	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00187	48 8b f8	 mov	 rdi, rax

; 2613 :         Py_LeaveRecursiveCall();

  0018a	e8 00 00 00 00	 call	 _Py_PXCTX
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN32@PyObject_I@2
  00193	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00198	4c 8b d8	 mov	 r11, rax
  0019b	eb 07		 jmp	 SHORT $LN33@PyObject_I@2
$LN32@PyObject_I@2:
  0019d	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN33@PyObject_I@2:
  001a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  001aa	83 f8 64	 cmp	 eax, 100		; 00000064H
  001ad	7e 05		 jle	 SHORT $LN34@PyObject_I@2
  001af	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  001b2	eb 06		 jmp	 SHORT $LN35@PyObject_I@2
$LN34@PyObject_I@2:
  001b4	c1 f8 02	 sar	 eax, 2
  001b7	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN35@PyObject_I@2:
  001ba	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  001be	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  001c2	7d 1b		 jge	 SHORT $LN6@PyObject_I@2
  001c4	e8 00 00 00 00	 call	 _Py_PXCTX
  001c9	85 c0		 test	 eax, eax
  001cb	74 07		 je	 SHORT $LN36@PyObject_I@2
  001cd	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001d2	eb 07		 jmp	 SHORT $LN37@PyObject_I@2
$LN36@PyObject_I@2:
  001d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN37@PyObject_I@2:
  001db	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN6@PyObject_I@2:

; 2614 :         Py_DECREF(checker);

  001df	48 8b ce	 mov	 rcx, rsi
  001e2	e8 00 00 00 00	 call	 _Py_DecRef

; 2615 :         if (res != NULL) {

  001e7	48 85 ff	 test	 rdi, rdi
  001ea	74 12		 je	 SHORT $LN3@PyObject_I@2

; 2616 :             ok = PyObject_IsTrue(res);

  001ec	48 8b cf	 mov	 rcx, rdi
  001ef	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2617 :             Py_DECREF(res);

  001f4	48 8b cf	 mov	 rcx, rdi
  001f7	8b d8		 mov	 ebx, eax
  001f9	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_I@2:

; 2618 :         }
; 2619 :         return ok;

  001fe	8b c3		 mov	 eax, ebx
  00200	eb 19		 jmp	 SHORT $LN20@PyObject_I@2
$LN9@PyObject_I@2:

; 2620 :     }
; 2621 :     else if (PyErr_Occurred())

  00202	e8 00 00 00 00	 call	 PyErr_Occurred
  00207	48 85 c0	 test	 rax, rax

; 2622 :         return -1;

  0020a	0f 85 5a fe ff
	ff		 jne	 $LN42@PyObject_I@2

; 2623 :     return recursive_issubclass(derived, cls);

  00210	48 8b d7	 mov	 rdx, rdi
  00213	48 8b cd	 mov	 rcx, rbp
  00216	e8 00 00 00 00	 call	 recursive_issubclass
$LN20@PyObject_I@2:

; 2624 : }

  0021b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00220	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00225	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0022a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0022e	5f		 pop	 rdi
  0022f	c3		 ret	 0
PyObject_IsSubclass ENDP
_TEXT	ENDS
PUBLIC	_PyObject_RealIsInstance
; Function compile flags: /Ogtpy
;	COMDAT _PyObject_RealIsInstance
_TEXT	SEGMENT
inst$ = 8
cls$ = 16
_PyObject_RealIsInstance PROC				; COMDAT

; 2629 :     return recursive_isinstance(inst, cls);
; 2630 : }

  00000	e9 00 00 00 00	 jmp	 recursive_isinstance
_PyObject_RealIsInstance ENDP
_TEXT	ENDS
PUBLIC	_PyObject_RealIsSubclass
; Function compile flags: /Ogtpy
;	COMDAT _PyObject_RealIsSubclass
_TEXT	SEGMENT
derived$ = 8
cls$ = 16
_PyObject_RealIsSubclass PROC				; COMDAT

; 2635 :     return recursive_issubclass(derived, cls);
; 2636 : }

  00000	e9 00 00 00 00	 jmp	 recursive_issubclass
_PyObject_RealIsSubclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@ ; `string'
PUBLIC	??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ ; `string'
PUBLIC	PyObject_GetIter
EXTRN	_PyObject_NextNotImplemented:PROC
EXTRN	PySeqIter_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_GetIter DD imagerel $LN8
	DD	imagerel $LN8+146
	DD	imagerel $unwind$PyObject_GetIter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetIter DD 033e01H
	DD	04343eH
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@
CONST	SEGMENT
??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@ DB 'iter('
	DB	') returned non-iterator of type ''%.100s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ DB '''%'
	DB	'.200s'' object is not iterable', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_GetIter
_TEXT	SEGMENT
o$ = 48
PyObject_GetIter PROC					; COMDAT

; 2641 : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2642 :     PyTypeObject *t = o->ob_type;
; 2643 :     getiterfunc f = NULL;
; 2644 : 
; 2645 :     f = t->tp_iter;

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	48 8b 90 30 01
	00 00		 mov	 rdx, QWORD PTR [rax+304]

; 2646 :     if (f == NULL) {

  0000f	48 85 d2	 test	 rdx, rdx
  00012	75 25		 jne	 SHORT $LN5@PyObject_G@2

; 2647 :         if (PySequence_Check(o))

  00014	e8 00 00 00 00	 call	 PySequence_Check
  00019	85 c0		 test	 eax, eax
  0001b	74 09		 je	 SHORT $LN4@PyObject_G@2

; 2662 :     }
; 2663 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 PySeqIter_New
$LN4@PyObject_G@2:

; 2648 :             return PySeqIter_New(o);
; 2649 :         return type_error("'%.200s' object is not iterable", o);

  00026	48 8b d1	 mov	 rdx, rcx
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@

; 2662 :     }
; 2663 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	e9 00 00 00 00	 jmp	 type_error
$LN5@PyObject_G@2:
  00039	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx

; 2650 :     }
; 2651 :     else {
; 2652 :         PyObject *res = (*f)(o);

  0003e	ff d2		 call	 rdx
  00040	48 8b d8	 mov	 rbx, rax

; 2653 :         if (res != NULL && !PyIter_Check(res)) {

  00043	48 85 c0	 test	 rax, rax
  00046	74 3d		 je	 SHORT $LN2@PyObject_G@2
  00048	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0004c	49 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [r8+312]
  00053	48 85 c0	 test	 rax, rax
  00056	74 0c		 je	 SHORT $LN1@PyObject_G@2
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyObject_NextNotImplemented
  0005f	48 3b c1	 cmp	 rax, rcx
  00062	75 21		 jne	 SHORT $LN2@PyObject_G@2
$LN1@PyObject_G@2:

; 2654 :             PyErr_Format(PyExc_TypeError,
; 2655 :                          "iter() returned non-iterator "
; 2656 :                          "of type '%.100s'",
; 2657 :                          res->ob_type->tp_name);

  00064	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@
  00076	e8 00 00 00 00	 call	 PyErr_Format

; 2658 :             Py_DECREF(res);

  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 2659 :             res = NULL;

  00083	33 db		 xor	 ebx, ebx
$LN2@PyObject_G@2:

; 2660 :         }
; 2661 :         return res;

  00085	48 8b c3	 mov	 rax, rbx
  00088	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2662 :     }
; 2663 : }

  0008d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00091	c3		 ret	 0
PyObject_GetIter ENDP
_TEXT	ENDS
PUBLIC	PyIter_Next
EXTRN	PyExc_StopIteration:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyIter_Next DD imagerel $LN7
	DD	imagerel $LN7+64
	DD	imagerel $unwind$PyIter_Next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyIter_Next DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyIter_Next
_TEXT	SEGMENT
iter$ = 48
PyIter_Next PROC					; COMDAT

; 2674 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2675 :     PyObject *result;
; 2676 : 
; 2677 :     result = (*iter->ob_type->tp_iternext)(iter);

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  00010	48 8b d8	 mov	 rbx, rax

; 2678 :     if (result == NULL &&
; 2679 :         PyErr_Occurred() &&
; 2680 :         PyErr_ExceptionMatches(PyExc_StopIteration))

  00013	48 85 c0	 test	 rax, rax
  00016	75 22		 jne	 SHORT $LN1@PyIter_Nex
  00018	e8 00 00 00 00	 call	 PyErr_Occurred
  0001d	48 85 c0	 test	 rax, rax
  00020	74 15		 je	 SHORT $LN5@PyIter_Nex
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00029	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0002e	85 c0		 test	 eax, eax
  00030	74 05		 je	 SHORT $LN5@PyIter_Nex

; 2681 :         PyErr_Clear();

  00032	e8 00 00 00 00	 call	 PyErr_Clear
$LN5@PyIter_Nex:

; 2682 :     return result;

  00037	48 8b c3	 mov	 rax, rbx
$LN1@PyIter_Nex:

; 2683 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
PyIter_Next ENDP
_TEXT	ENDS
PUBLIC	_Py_FreeCharPArray
EXTRN	__imp_free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_FreeCharPArray DD imagerel $LN8
	DD	imagerel $LN8+65
	DD	imagerel $unwind$_Py_FreeCharPArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_FreeCharPArray DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _Py_FreeCharPArray
_TEXT	SEGMENT
array$ = 48
_Py_FreeCharPArray PROC					; COMDAT

; 2752 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2753 :     Py_ssize_t i;
; 2754 :     for (i = 0; array[i] != NULL; ++i) {

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	33 db		 xor	 ebx, ebx
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	48 85 c0	 test	 rax, rax
  00015	74 16		 je	 SHORT $LN1@Py_FreeCha
$LL3@Py_FreeCha:

; 2755 :         free(array[i]);

  00017	48 8b c8	 mov	 rcx, rax
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00020	48 8b 44 df 08	 mov	 rax, QWORD PTR [rdi+rbx*8+8]
  00025	48 ff c3	 inc	 rbx
  00028	48 85 c0	 test	 rax, rax
  0002b	75 ea		 jne	 SHORT $LL3@Py_FreeCha
$LN1@Py_FreeCha:

; 2756 :     }
; 2757 :     free((void*)array);

  0002d	48 8b cf	 mov	 rcx, rdi

; 2758 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
_Py_FreeCharPArray ENDP
_TEXT	ENDS
PUBLIC	PyObject_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Size DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$PyObject_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Size DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_Size
_TEXT	SEGMENT
o$ = 48
PyObject_Size PROC					; COMDAT

; 44   : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 45   :     PySequenceMethods *m;
; 46   : 
; 47   :     if (o == NULL) {

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 0e		 jne	 SHORT $LN2@PyObject_S

; 48   :         null_error();

  00009	e8 00 00 00 00	 call	 null_error

; 49   :         return -1;

  0000e	48 83 c8 ff	 or	 rax, -1

; 54   :         return m->sq_length(o);
; 55   : 
; 56   :     return PyMapping_Size(o);
; 57   : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
$LN2@PyObject_S:

; 50   :     }
; 51   : 
; 52   :     m = o->ob_type->tp_as_sequence;

  00017	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001b	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]

; 53   :     if (m && m->sq_length)

  00022	48 85 d2	 test	 rdx, rdx
  00025	74 0f		 je	 SHORT $LN1@PyObject_S
  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 07		 je	 SHORT $LN1@PyObject_S

; 54   :         return m->sq_length(o);
; 55   : 
; 56   :     return PyMapping_Size(o);
; 57   : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	48 ff e0	 rex_jmp rax
$LN1@PyObject_S:
  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	e9 00 00 00 00	 jmp	 PyMapping_Size
PyObject_Size ENDP
_TEXT	ENDS
PUBLIC	PyObject_Length
; Function compile flags: /Ogtpy
;	COMDAT PyObject_Length
_TEXT	SEGMENT
o$ = 8
PyObject_Length PROC					; COMDAT

; 63   :     return PyObject_Size(o);
; 64   : }

  00000	e9 00 00 00 00	 jmp	 PyObject_Size
PyObject_Length ENDP
_TEXT	ENDS
PUBLIC	_PyObject_LengthHint
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_LengthHint DD imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyObject_LengthHint DD imagerel $LN15+103
	DD	imagerel $LN15+156
	DD	imagerel $chain$0$_PyObject_LengthHint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyObject_LengthHint DD imagerel $LN15+156
	DD	imagerel $LN15+218
	DD	imagerel $chain$2$_PyObject_LengthHint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyObject_LengthHint DD imagerel $LN15+218
	DD	imagerel $LN15+242
	DD	imagerel $chain$4$_PyObject_LengthHint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyObject_LengthHint DD imagerel $LN15+242
	DD	imagerel $LN15+285
	DD	imagerel $chain$6$_PyObject_LengthHint
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_PyObject_LengthHint DD imagerel $LN15+285
	DD	imagerel $LN15+296
	DD	imagerel $chain$7$_PyObject_LengthHint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_PyObject_LengthHint DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyObject_LengthHint DD 020021H
	DD	066400H
	DD	imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyObject_LengthHint DD 020021H
	DD	066400H
	DD	imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyObject_LengthHint DD 020021H
	DD	066400H
	DD	imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyObject_LengthHint DD 020521H
	DD	066405H
	DD	imagerel $LN15
	DD	imagerel $LN15+103
	DD	imagerel $unwind$_PyObject_LengthHint
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_LengthHint DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyObject_LengthHint
_TEXT	SEGMENT
o$ = 48
defaultvalue$ = 56
_PyObject_LengthHint PROC				; COMDAT

; 76   : {

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 77   :     _Py_IDENTIFIER(__length_hint__);
; 78   :     PyObject *ro, *hintmeth;
; 79   :     Py_ssize_t rv;
; 80   : 
; 81   :     /* try o.__len__() */
; 82   :     rv = PyObject_Size(o);

  00010	e8 00 00 00 00	 call	 PyObject_Size

; 83   :     if (rv >= 0)

  00015	48 85 c0	 test	 rax, rax

; 84   :         return rv;

  00018	0f 89 ff 00 00
	00		 jns	 $LN9@PyObject_L

; 85   :     if (PyErr_Occurred()) {

  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 24		 je	 SHORT $LN7@PyObject_L

; 86   :         if (!PyErr_ExceptionMatches(PyExc_TypeError))

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002f	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00034	85 c0		 test	 eax, eax
  00036	75 0f		 jne	 SHORT $LN6@PyObject_L

; 87   :             return -1;

  00038	48 83 c8 ff	 or	 rax, -1

; 110  : }

  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN6@PyObject_L:

; 88   :         PyErr_Clear();

  00047	e8 00 00 00 00	 call	 PyErr_Clear
$LN7@PyObject_L:

; 89   :     }
; 90   : 
; 91   :     /* try o.__length_hint__() */
; 92   :     hintmeth = _PyObject_LookupSpecial(o, &PyId___length_hint__);

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00052	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0005b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___length_hint__@?1??_PyObject_LengthHint@@9@9
  00060	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00064	48 8b cf	 mov	 rcx, rdi
  00067	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0006c	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00071	48 8b f0	 mov	 rsi, rax

; 93   :     if (hintmeth == NULL) {

  00074	48 85 c0	 test	 rax, rax
  00077	75 23		 jne	 SHORT $LN3@PyObject_L

; 94   :         if (PyErr_Occurred())

  00079	e8 00 00 00 00	 call	 PyErr_Occurred
  0007e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00083	48 83 c9 ff	 or	 rcx, -1
  00087	48 85 c0	 test	 rax, rax
  0008a	48 0f 45 d9	 cmovne	 rbx, rcx

; 109  :     return rv;

  0008e	48 8b c3	 mov	 rax, rbx

; 110  : }

  00091	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
$LN3@PyObject_L:

; 95   :             return -1;
; 96   :         else
; 97   :             return defaultvalue;
; 98   :     }
; 99   :     ro = PyObject_CallFunctionObjArgs(hintmeth, NULL);

  0009c	33 d2		 xor	 edx, edx
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 100  :     Py_DECREF(hintmeth);

  000a6	48 8b ce	 mov	 rcx, rsi
  000a9	48 8b f8	 mov	 rdi, rax
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :     if (ro == NULL) {

  000b1	48 85 ff	 test	 rdi, rdi
  000b4	75 3c		 jne	 SHORT $LN2@PyObject_L

; 102  :         if (!PyErr_ExceptionMatches(PyExc_TypeError))

  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bd	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000c2	85 c0		 test	 eax, eax
  000c4	75 14		 jne	 SHORT $LN1@PyObject_L

; 103  :             return -1;

  000c6	48 83 c8 ff	 or	 rax, -1
  000ca	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 110  : }

  000cf	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
$LN1@PyObject_L:

; 104  :         PyErr_Clear();

  000da	e8 00 00 00 00	 call	 PyErr_Clear
  000df	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 109  :     return rv;

  000e4	48 8b c3	 mov	 rax, rbx

; 110  : }

  000e7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ec	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
$LN2@PyObject_L:

; 105  :         return defaultvalue;
; 106  :     }
; 107  :     rv = PyLong_Check(ro) ? PyLong_AsSsize_t(ro) : defaultvalue;

  000f2	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000f6	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00100	74 0b		 je	 SHORT $LN11@PyObject_L
  00102	48 8b cf	 mov	 rcx, rdi
  00105	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0010a	48 8b d8	 mov	 rbx, rax
$LN11@PyObject_L:

; 108  :     Py_DECREF(ro);

  0010d	48 8b cf	 mov	 rcx, rdi
  00110	e8 00 00 00 00	 call	 _Py_DecRef
  00115	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 109  :     return rv;

  0011a	48 8b c3	 mov	 rax, rbx
$LN9@PyObject_L:

; 110  : }

  0011d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00122	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00126	5f		 pop	 rdi
  00127	c3		 ret	 0
_PyObject_LengthHint ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@ ; `string'
PUBLIC	??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@ ; `string'
PUBLIC	PyObject_GetItem
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_GetItem DD imagerel $LN12
	DD	imagerel $LN12+114
	DD	imagerel $unwind$PyObject_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_GetItem DD imagerel $LN12+114
	DD	imagerel $LN12+156
	DD	imagerel $chain$0$PyObject_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_GetItem DD imagerel $LN12+156
	DD	imagerel $LN12+177
	DD	imagerel $chain$2$PyObject_GetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_GetItem DD imagerel $LN12+177
	DD	imagerel $LN12+234
	DD	imagerel $chain$3$PyObject_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_GetItem DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+114
	DD	imagerel $unwind$PyObject_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_GetItem DD 020021H
	DD	067400H
	DD	imagerel $LN12
	DD	imagerel $LN12+114
	DD	imagerel $unwind$PyObject_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_GetItem DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+114
	DD	imagerel $unwind$PyObject_GetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetItem DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@
CONST	SEGMENT
??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@ DB '''%.20'
	DB	'0s'' object is not subscriptable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
CONST	SEGMENT
??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@ DB 'sequence i'
	DB	'ndex must be integer, not ''%.200s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_GetItem
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyObject_GetItem PROC					; COMDAT

; 114  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c2	 mov	 r8, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 115  :     PyMappingMethods *m;
; 116  : 
; 117  :     if (o == NULL || key == NULL)

  0000c	48 85 c9	 test	 rcx, rcx
  0000f	0f 84 cb 00 00
	00		 je	 $LN7@PyObject_G@3
  00015	48 85 d2	 test	 rdx, rdx
  00018	0f 84 c2 00 00
	00		 je	 $LN7@PyObject_G@3

; 118  :         return null_error();
; 119  : 
; 120  :     m = o->ob_type->tp_as_mapping;

  0001e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00022	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]

; 121  :     if (m && m->mp_subscript)

  00029	48 85 c0	 test	 rax, rax
  0002c	74 14		 je	 SHORT $LN6@PyObject_G@3
  0002e	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00032	4d 85 c9	 test	 r9, r9
  00035	74 0b		 je	 SHORT $LN6@PyObject_G@3

; 122  :         return m->mp_subscript(o, key);

  00037	48 8b cb	 mov	 rcx, rbx

; 138  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	49 ff e1	 rex_jmp r9
$LN6@PyObject_G@3:

; 123  : 
; 124  :     if (o->ob_type->tp_as_sequence) {

  00042	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00049	48 85 c9	 test	 rcx, rcx
  0004c	74 7e		 je	 SHORT $LN1@PyObject_G@3

; 125  :         if (PyIndex_Check(key)) {

  0004e	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00052	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]
  00059	48 85 d2	 test	 rdx, rdx
  0005c	74 53		 je	 SHORT $LN4@PyObject_G@3
  0005e	48 83 ba 08 01
	00 00 00	 cmp	 QWORD PTR [rdx+264], 0
  00066	74 49		 je	 SHORT $LN4@PyObject_G@3

; 126  :             Py_ssize_t key_value;
; 127  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  00068	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0006f	49 8b c8	 mov	 rcx, r8
  00072	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00077	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0007c	48 8b f8	 mov	 rdi, rax

; 128  :             if (key_value == -1 && PyErr_Occurred())

  0007f	48 83 f8 ff	 cmp	 rax, -1
  00083	75 17		 jne	 SHORT $LN3@PyObject_G@3
  00085	e8 00 00 00 00	 call	 PyErr_Occurred
  0008a	48 85 c0	 test	 rax, rax
  0008d	74 0d		 je	 SHORT $LN3@PyObject_G@3

; 129  :                 return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 138  : }

  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
$LN3@PyObject_G@3:

; 130  :             return PySequence_GetItem(o, key_value);

  0009c	48 8b d7	 mov	 rdx, rdi
  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 138  : }

  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5b		 pop	 rbx
  000ac	e9 00 00 00 00	 jmp	 PySequence_GetItem
$LN4@PyObject_G@3:

; 131  :         }
; 132  :         else if (o->ob_type->tp_as_sequence->sq_item)

  000b1	48 83 79 18 00	 cmp	 QWORD PTR [rcx+24], 0
  000b6	74 14		 je	 SHORT $LN1@PyObject_G@3

; 133  :             return type_error("sequence index must "
; 134  :                               "be integer, not '%.200s'", key);

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  000bf	49 8b d0	 mov	 rdx, r8

; 138  : }

  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5b		 pop	 rbx
  000c7	e9 00 00 00 00	 jmp	 type_error
$LN1@PyObject_G@3:

; 135  :     }
; 136  : 
; 137  :     return type_error("'%.200s' object is not subscriptable", o);

  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@
  000d3	48 8b d3	 mov	 rdx, rbx

; 138  : }

  000d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000da	5b		 pop	 rbx
  000db	e9 00 00 00 00	 jmp	 type_error
$LN7@PyObject_G@3:
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5b		 pop	 rbx
  000e5	e9 00 00 00 00	 jmp	 null_error
PyObject_GetItem ENDP
_TEXT	ENDS
PUBLIC	PyObject_SetItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_SetItem DD imagerel $LN12
	DD	imagerel $LN12+139
	DD	imagerel $unwind$PyObject_SetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_SetItem DD imagerel $LN12+139
	DD	imagerel $LN12+186
	DD	imagerel $chain$0$PyObject_SetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_SetItem DD imagerel $LN12+186
	DD	imagerel $LN12+215
	DD	imagerel $chain$2$PyObject_SetItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_SetItem DD imagerel $LN12+215
	DD	imagerel $LN12+299
	DD	imagerel $chain$3$PyObject_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_SetItem DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+139
	DD	imagerel $unwind$PyObject_SetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_SetItem DD 020021H
	DD	066400H
	DD	imagerel $LN12
	DD	imagerel $LN12+139
	DD	imagerel $unwind$PyObject_SetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_SetItem DD 020521H
	DD	066405H
	DD	imagerel $LN12
	DD	imagerel $LN12+139
	DD	imagerel $unwind$PyObject_SetItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_SetItem DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_SetItem
_TEXT	SEGMENT
o$ = 48
key$ = 56
value$ = 64
PyObject_SetItem PROC					; COMDAT

; 142  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	48 8b d9	 mov	 rbx, rcx

; 143  :     PyMappingMethods *m;
; 144  : 
; 145  :     if (o == NULL || key == NULL || value == NULL) {

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 fc 00 00
	00		 je	 $LN7@PyObject_S@2
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 f3 00 00
	00		 je	 $LN7@PyObject_S@2
  00025	4d 85 c0	 test	 r8, r8
  00028	0f 84 ea 00 00
	00		 je	 $LN7@PyObject_S@2

; 147  :         return -1;
; 148  :     }
; 149  : 
; 150  :     /*
; 151  :     if (Px_CHECK_PROTECTION(o, key, value))
; 152  :         return -1;
; 153  :     */
; 154  : 
; 155  :     m = o->ob_type->tp_as_mapping;

  0002e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00032	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]

; 156  :     if (m && m->mp_ass_subscript)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 19		 je	 SHORT $LN6@PyObject_S@2
  0003e	4c 8b 50 10	 mov	 r10, QWORD PTR [rax+16]
  00042	4d 85 d2	 test	 r10, r10
  00045	74 10		 je	 SHORT $LN6@PyObject_S@2

; 157  :         return m->mp_ass_subscript(o, key, value);

  00047	48 8b cb	 mov	 rcx, rbx

; 176  : }

  0004a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5f		 pop	 rdi
  00054	49 ff e2	 rex_jmp r10
$LN6@PyObject_S@2:

; 158  : 
; 159  :     if (o->ob_type->tp_as_sequence) {

  00057	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  0005e	48 85 c9	 test	 rcx, rcx
  00061	0f 84 94 00 00
	00		 je	 $LN1@PyObject_S@2

; 160  :         if (PyIndex_Check(key)) {

  00067	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0006b	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]
  00072	48 85 d2	 test	 rdx, rdx
  00075	74 60		 je	 SHORT $LN4@PyObject_S@2
  00077	48 83 ba 08 01
	00 00 00	 cmp	 QWORD PTR [rdx+264], 0
  0007f	74 56		 je	 SHORT $LN4@PyObject_S@2

; 161  :             Py_ssize_t key_value;
; 162  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  00081	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00088	49 8b c9	 mov	 rcx, r9
  0008b	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00090	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00095	48 8b f0	 mov	 rsi, rax

; 163  :             if (key_value == -1 && PyErr_Occurred())

  00098	48 83 f8 ff	 cmp	 rax, -1
  0009c	75 1c		 jne	 SHORT $LN3@PyObject_S@2
  0009e	e8 00 00 00 00	 call	 PyErr_Occurred
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 12		 je	 SHORT $LN3@PyObject_S@2

; 164  :                 return -1;

  000a8	0b c6		 or	 eax, esi
  000aa	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 176  : }

  000af	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN3@PyObject_S@2:

; 165  :             return PySequence_SetItem(o, key_value, value);

  000ba	4c 8b c7	 mov	 r8, rdi
  000bd	48 8b d6	 mov	 rdx, rsi
  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 176  : }

  000c8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	5f		 pop	 rdi
  000d2	e9 00 00 00 00	 jmp	 PySequence_SetItem
$LN4@PyObject_S@2:

; 166  :         }
; 167  :         else if (o->ob_type->tp_as_sequence->sq_ass_item) {

  000d7	48 83 79 28 00	 cmp	 QWORD PTR [rcx+40], 0
  000dc	74 1d		 je	 SHORT $LN1@PyObject_S@2

; 168  :             type_error("sequence index must be "
; 169  :                        "integer, not '%.200s'", key);

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  000e5	49 8b d1	 mov	 rdx, r9
  000e8	e8 00 00 00 00	 call	 type_error

; 170  :             return -1;

  000ed	83 c8 ff	 or	 eax, -1

; 176  : }

  000f0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
$LN1@PyObject_S@2:

; 171  :         }
; 172  :     }
; 173  : 
; 174  :     type_error("'%.200s' object does not support item assignment", o);

  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
  00102	48 8b d3	 mov	 rdx, rbx
  00105	e8 00 00 00 00	 call	 type_error

; 175  :     return -1;

  0010a	83 c8 ff	 or	 eax, -1

; 176  : }

  0010d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00112	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
$LN7@PyObject_S@2:

; 146  :         null_error();

  00118	e8 00 00 00 00	 call	 null_error

; 176  : }

  0011d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00122	83 c8 ff	 or	 eax, -1
  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	5f		 pop	 rdi
  0012a	c3		 ret	 0
PyObject_SetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
PUBLIC	PyObject_DelItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_DelItem DD imagerel $LN12
	DD	imagerel $LN12+121
	DD	imagerel $unwind$PyObject_DelItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_DelItem DD imagerel $LN12+121
	DD	imagerel $LN12+163
	DD	imagerel $chain$0$PyObject_DelItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_DelItem DD imagerel $LN12+163
	DD	imagerel $LN12+184
	DD	imagerel $chain$2$PyObject_DelItem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_DelItem DD imagerel $LN12+184
	DD	imagerel $LN12+253
	DD	imagerel $chain$3$PyObject_DelItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_DelItem DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+121
	DD	imagerel $unwind$PyObject_DelItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_DelItem DD 020021H
	DD	067400H
	DD	imagerel $LN12
	DD	imagerel $LN12+121
	DD	imagerel $unwind$PyObject_DelItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_DelItem DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+121
	DD	imagerel $unwind$PyObject_DelItem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_DelItem DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support item deletion', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_DelItem
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyObject_DelItem PROC					; COMDAT

; 180  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b ca	 mov	 r9, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 181  :     PyMappingMethods *m;
; 182  : 
; 183  :     if (o == NULL || key == NULL) {

  0000c	48 85 c9	 test	 rcx, rcx
  0000f	0f 84 da 00 00
	00		 je	 $LN7@PyObject_D
  00015	48 85 d2	 test	 rdx, rdx
  00018	0f 84 d1 00 00
	00		 je	 $LN7@PyObject_D

; 186  :     }
; 187  : 
; 188  :     /*
; 189  :     if (Px_CHECK_PROTECTION(o, NULL, NULL))
; 190  :         return -1;
; 191  :     */
; 192  : 
; 193  :     m = o->ob_type->tp_as_mapping;

  0001e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00022	48 8b 81 c8 00
	00 00		 mov	 rax, QWORD PTR [rcx+200]

; 194  :     if (m && m->mp_ass_subscript)

  00029	48 85 c0	 test	 rax, rax
  0002c	74 17		 je	 SHORT $LN6@PyObject_D
  0002e	4c 8b 50 10	 mov	 r10, QWORD PTR [rax+16]
  00032	4d 85 d2	 test	 r10, r10
  00035	74 0e		 je	 SHORT $LN6@PyObject_D

; 195  :         return m->mp_ass_subscript(o, key, (PyObject*)NULL);

  00037	45 33 c0	 xor	 r8d, r8d
  0003a	48 8b cb	 mov	 rcx, rbx

; 214  : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	49 ff e2	 rex_jmp r10
$LN6@PyObject_D:

; 196  : 
; 197  :     if (o->ob_type->tp_as_sequence) {

  00045	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  0004c	48 85 c9	 test	 rcx, rcx
  0004f	0f 84 82 00 00
	00		 je	 $LN1@PyObject_D

; 198  :         if (PyIndex_Check(key)) {

  00055	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00059	48 8b 90 b8 00
	00 00		 mov	 rdx, QWORD PTR [rax+184]
  00060	48 85 d2	 test	 rdx, rdx
  00063	74 53		 je	 SHORT $LN4@PyObject_D
  00065	48 83 ba 08 01
	00 00 00	 cmp	 QWORD PTR [rdx+264], 0
  0006d	74 49		 je	 SHORT $LN4@PyObject_D

; 199  :             Py_ssize_t key_value;
; 200  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  0006f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00076	49 8b c9	 mov	 rcx, r9
  00079	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0007e	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00083	48 8b f8	 mov	 rdi, rax

; 201  :             if (key_value == -1 && PyErr_Occurred())

  00086	48 83 f8 ff	 cmp	 rax, -1
  0008a	75 17		 jne	 SHORT $LN3@PyObject_D
  0008c	e8 00 00 00 00	 call	 PyErr_Occurred
  00091	48 85 c0	 test	 rax, rax
  00094	74 0d		 je	 SHORT $LN3@PyObject_D

; 202  :                 return -1;

  00096	0b c7		 or	 eax, edi
  00098	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 214  : }

  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
$LN3@PyObject_D:

; 203  :             return PySequence_DelItem(o, key_value);

  000a3	48 8b d7	 mov	 rdx, rdi
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 214  : }

  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5b		 pop	 rbx
  000b3	e9 00 00 00 00	 jmp	 PySequence_DelItem
$LN4@PyObject_D:

; 204  :         }
; 205  :         else if (o->ob_type->tp_as_sequence->sq_ass_item) {

  000b8	48 83 79 28 00	 cmp	 QWORD PTR [rcx+40], 0
  000bd	74 18		 je	 SHORT $LN1@PyObject_D

; 206  :             type_error("sequence index must be "
; 207  :                        "integer, not '%.200s'", key);

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  000c6	49 8b d1	 mov	 rdx, r9
  000c9	e8 00 00 00 00	 call	 type_error

; 208  :             return -1;

  000ce	83 c8 ff	 or	 eax, -1

; 214  : }

  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
$LN1@PyObject_D:

; 209  :         }
; 210  :     }
; 211  : 
; 212  :     type_error("'%.200s' object does not support item deletion", o);

  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@
  000de	48 8b d3	 mov	 rdx, rbx
  000e1	e8 00 00 00 00	 call	 type_error

; 213  :     return -1;

  000e6	83 c8 ff	 or	 eax, -1

; 214  : }

  000e9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ed	5b		 pop	 rbx
  000ee	c3		 ret	 0
$LN7@PyObject_D:

; 184  :         null_error();

  000ef	e8 00 00 00 00	 call	 null_error

; 185  :         return -1;

  000f4	83 c8 ff	 or	 eax, -1

; 214  : }

  000f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fb	5b		 pop	 rbx
  000fc	c3		 ret	 0
PyObject_DelItem ENDP
_TEXT	ENDS
PUBLIC	PyObject_DelItemString
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_DelItemString DD imagerel $LN7
	DD	imagerel $LN7+22
	DD	imagerel $unwind$PyObject_DelItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_DelItemString DD imagerel $LN7+22
	DD	imagerel $LN7+54
	DD	imagerel $chain$0$PyObject_DelItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_DelItemString DD imagerel $LN7+54
	DD	imagerel $LN7+88
	DD	imagerel $chain$2$PyObject_DelItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_DelItemString DD imagerel $LN7+88
	DD	imagerel $LN7+102
	DD	imagerel $chain$3$PyObject_DelItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_DelItemString DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+22
	DD	imagerel $unwind$PyObject_DelItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_DelItemString DD 020021H
	DD	067400H
	DD	imagerel $LN7
	DD	imagerel $LN7+22
	DD	imagerel $unwind$PyObject_DelItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_DelItemString DD 020521H
	DD	067405H
	DD	imagerel $LN7
	DD	imagerel $LN7+22
	DD	imagerel $unwind$PyObject_DelItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_DelItemString DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_DelItemString
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyObject_DelItemString PROC				; COMDAT

; 218  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 219  :     PyObject *okey;
; 220  :     int ret;
; 221  : 
; 222  :     if (o == NULL || key == NULL) {

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 4a		 je	 SHORT $LN2@PyObject_D@2
  0000e	48 85 d2	 test	 rdx, rdx
  00011	74 45		 je	 SHORT $LN2@PyObject_D@2

; 225  :     }
; 226  :     okey = PyUnicode_FromString(key);

  00013	48 8b ca	 mov	 rcx, rdx
  00016	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001b	e8 00 00 00 00	 call	 PyUnicode_FromString
  00020	48 8b f8	 mov	 rdi, rax

; 227  :     if (okey == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 0e		 jne	 SHORT $LN1@PyObject_D@2

; 228  :         return -1;

  00028	83 c8 ff	 or	 eax, -1
  0002b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 232  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN1@PyObject_D@2:

; 229  :     ret = PyObject_DelItem(o, okey);

  00036	48 8b d0	 mov	 rdx, rax
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 PyObject_DelItem

; 230  :     Py_DECREF(okey);

  00041	48 8b cf	 mov	 rcx, rdi
  00044	8b d8		 mov	 ebx, eax
  00046	e8 00 00 00 00	 call	 _Py_DecRef
  0004b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 231  :     return ret;

  00050	8b c3		 mov	 eax, ebx

; 232  : }

  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN2@PyObject_D@2:

; 223  :         null_error();

  00058	e8 00 00 00 00	 call	 null_error

; 224  :         return -1;

  0005d	83 c8 ff	 or	 eax, -1

; 232  : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
PyObject_DelItemString ENDP
_TEXT	ENDS
PUBLIC	PyObject_CheckReadBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CheckReadBuffer DD imagerel $LN6
	DD	imagerel $LN6+75
	DD	imagerel $unwind$PyObject_CheckReadBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CheckReadBuffer DD 010401H
	DD	0e204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyObject_CheckReadBuffer
_TEXT	SEGMENT
view$ = 32
obj$ = 128
PyObject_CheckReadBuffer PROC				; COMDAT

; 269  : {

$LN6:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 270  :     PyBufferProcs *pb = obj->ob_type->tp_as_buffer;

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	48 8b 90 f8 00
	00 00		 mov	 rdx, QWORD PTR [rax+248]

; 271  :     Py_buffer view;
; 272  : 
; 273  :     if (pb == NULL ||
; 274  :         pb->bf_getbuffer == NULL)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	74 1c		 je	 SHORT $LN2@PyObject_C@11
  00014	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00017	48 85 c0	 test	 rax, rax
  0001a	74 14		 je	 SHORT $LN2@PyObject_C@11

; 276  : 
; 277  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE) == -1) {

  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  00021	45 33 c0	 xor	 r8d, r8d
  00024	ff d0		 call	 rax
  00026	83 f8 ff	 cmp	 eax, -1
  00029	75 0c		 jne	 SHORT $LN1@PyObject_C@11

; 278  :         PyErr_Clear();

  0002b	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@PyObject_C@11:

; 275  :         return 0;

  00030	33 c0		 xor	 eax, eax

; 283  : }

  00032	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00036	c3		 ret	 0
$LN1@PyObject_C@11:

; 279  :         return 0;
; 280  :     }
; 281  :     PyBuffer_Release(&view);

  00037	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view$[rsp]
  0003c	e8 00 00 00 00	 call	 PyBuffer_Release

; 282  :     return 1;

  00041	b8 01 00 00 00	 mov	 eax, 1

; 283  : }

  00046	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0004a	c3		 ret	 0
PyObject_CheckReadBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@ ; `string'
PUBLIC	??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@ ; `string'
PUBLIC	PyObject_CopyData
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CopyData DD imagerel $LN38
	DD	imagerel $LN38+335
	DD	imagerel $unwind$PyObject_CopyData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyObject_CopyData DD imagerel $LN38+335
	DD	imagerel $LN38+411
	DD	imagerel $chain$0$PyObject_CopyData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyObject_CopyData DD imagerel $LN38+411
	DD	imagerel $LN38+417
	DD	imagerel $chain$2$PyObject_CopyData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyObject_CopyData DD imagerel $LN38+417
	DD	imagerel $LN38+586
	DD	imagerel $chain$3$PyObject_CopyData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyObject_CopyData DD imagerel $LN38+586
	DD	imagerel $LN38+625
	DD	imagerel $chain$5$PyObject_CopyData
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyObject_CopyData DD 021H
	DD	imagerel $LN38
	DD	imagerel $LN38+335
	DD	imagerel $unwind$PyObject_CopyData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyObject_CopyData DD 020821H
	DD	01b7408H
	DD	imagerel $LN38+411
	DD	imagerel $LN38+417
	DD	imagerel $chain$2$PyObject_CopyData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyObject_CopyData DD 020021H
	DD	01a6400H
	DD	imagerel $LN38
	DD	imagerel $LN38+335
	DD	imagerel $unwind$PyObject_CopyData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyObject_CopyData DD 020821H
	DD	01a6408H
	DD	imagerel $LN38
	DD	imagerel $LN38+335
	DD	imagerel $unwind$PyObject_CopyData
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CopyData DD 051201H
	DD	01c3412H
	DD	0180112H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@
CONST	SEGMENT
??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@ DB 'both destina'
	DB	'tion and source must have the buffer interface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@
CONST	SEGMENT
??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@ DB 'destination'
	DB	' is too small to receive data from source', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_CopyData
_TEXT	SEGMENT
view_src$ = 32
view_dest$ = 112
dest$ = 208
src$ = 216
PyObject_CopyData PROC					; COMDAT

; 517  : {

$LN38:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 518  :     Py_buffer view_dest, view_src;
; 519  :     int k;
; 520  :     Py_ssize_t *indices, elements;
; 521  :     char *dptr, *sptr;
; 522  : 
; 523  :     if (!PyObject_CheckBuffer(dest) ||
; 524  :         !PyObject_CheckBuffer(src)) {

  00012	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00016	48 8b da	 mov	 rbx, rdx
  00019	4c 8b 80 f8 00
	00 00		 mov	 r8, QWORD PTR [rax+248]
  00020	4d 85 c0	 test	 r8, r8
  00023	0f 84 21 02 00
	00		 je	 $LN16@PyObject_C@12
  00029	49 83 38 00	 cmp	 QWORD PTR [r8], 0
  0002d	0f 84 17 02 00
	00		 je	 $LN16@PyObject_C@12
  00033	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00037	4c 8b 80 f8 00
	00 00		 mov	 r8, QWORD PTR [rax+248]
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 03 02 00
	00		 je	 $LN16@PyObject_C@12
  00047	49 83 38 00	 cmp	 QWORD PTR [r8], 0
  0004b	0f 84 f9 01 00
	00		 je	 $LN16@PyObject_C@12

; 528  :         return -1;
; 529  :     }
; 530  : 
; 531  :     if (PyObject_GetBuffer(dest, &view_dest, PyBUF_FULL) != 0) return -1;

  00051	48 8d 55 07	 lea	 rdx, QWORD PTR view_dest$[rbp-105]
  00055	41 b8 1d 01 00
	00		 mov	 r8d, 285		; 0000011dH
  0005b	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00060	85 c0		 test	 eax, eax
  00062	75 1f		 jne	 SHORT $LN37@PyObject_C@12

; 532  :     if (PyObject_GetBuffer(src, &view_src, PyBUF_FULL_RO) != 0) {

  00064	48 8d 55 b7	 lea	 rdx, QWORD PTR view_src$[rbp-105]
  00068	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00076	85 c0		 test	 eax, eax
  00078	74 1d		 je	 SHORT $LN14@PyObject_C@12

; 533  :         PyBuffer_Release(&view_dest);

  0007a	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  0007e	e8 00 00 00 00	 call	 PyBuffer_Release
$LN37@PyObject_C@12:

; 534  :         return -1;

  00083	83 c8 ff	 or	 eax, -1

; 584  : }

  00086	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
  0008e	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00095	5d		 pop	 rbp
  00096	c3		 ret	 0
$LN14@PyObject_C@12:

; 535  :     }
; 536  : 
; 537  :     if (view_dest.len < view_src.len) {

  00097	48 8b 5d c7	 mov	 rbx, QWORD PTR view_src$[rbp-89]
  0009b	48 39 5d 17	 cmp	 QWORD PTR view_dest$[rbp-89], rbx
  0009f	7d 39		 jge	 SHORT $LN13@PyObject_C@12

; 538  :         PyErr_SetString(PyExc_BufferError,
; 539  :                         "destination is too small to receive data from source");

  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@
  000af	e8 00 00 00 00	 call	 PyErr_SetString

; 540  :         PyBuffer_Release(&view_dest);

  000b4	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  000b8	e8 00 00 00 00	 call	 PyBuffer_Release

; 541  :         PyBuffer_Release(&view_src);

  000bd	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  000c1	e8 00 00 00 00	 call	 PyBuffer_Release

; 542  :         return -1;

  000c6	83 c8 ff	 or	 eax, -1

; 584  : }

  000c9	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
  000d1	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  000d8	5d		 pop	 rbp
  000d9	c3		 ret	 0
$LN13@PyObject_C@12:

; 543  :     }
; 544  : 
; 545  :     if ((PyBuffer_IsContiguous(&view_dest, 'C') &&
; 546  :          PyBuffer_IsContiguous(&view_src, 'C')) ||
; 547  :         (PyBuffer_IsContiguous(&view_dest, 'F') &&
; 548  :          PyBuffer_IsContiguous(&view_src, 'F'))) {

  000da	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  000de	b2 43		 mov	 dl, 67			; 00000043H
  000e0	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  000e5	85 c0		 test	 eax, eax
  000e7	74 0f		 je	 SHORT $LN10@PyObject_C@12
  000e9	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  000ed	b2 43		 mov	 dl, 67			; 00000043H
  000ef	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  000f4	85 c0		 test	 eax, eax
  000f6	75 1e		 jne	 SHORT $LN11@PyObject_C@12
$LN10@PyObject_C@12:
  000f8	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  000fc	b2 46		 mov	 dl, 70			; 00000046H
  000fe	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00103	85 c0		 test	 eax, eax
  00105	74 44		 je	 SHORT $LN12@PyObject_C@12
  00107	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  0010b	b2 46		 mov	 dl, 70			; 00000046H
  0010d	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00112	85 c0		 test	 eax, eax
  00114	74 35		 je	 SHORT $LN12@PyObject_C@12
$LN11@PyObject_C@12:

; 549  :         /* simplest copy is all that is needed */
; 550  :         memcpy(view_dest.buf, view_src.buf, view_src.len);

  00116	48 8b 55 b7	 mov	 rdx, QWORD PTR view_src$[rbp-105]
  0011a	48 8b 4d 07	 mov	 rcx, QWORD PTR view_dest$[rbp-105]
  0011e	4c 8b c3	 mov	 r8, rbx
  00121	e8 00 00 00 00	 call	 memcpy

; 551  :         PyBuffer_Release(&view_dest);

  00126	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  0012a	e8 00 00 00 00	 call	 PyBuffer_Release

; 552  :         PyBuffer_Release(&view_src);

  0012f	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  00133	e8 00 00 00 00	 call	 PyBuffer_Release

; 553  :         return 0;

  00138	33 c0		 xor	 eax, eax

; 584  : }

  0013a	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
  00142	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00149	5d		 pop	 rbp
  0014a	c3		 ret	 0
$LN12@PyObject_C@12:

; 554  :     }
; 555  : 
; 556  :     /* Otherwise a more elaborate copy scheme is needed */
; 557  : 
; 558  :     /* XXX(nnorwitz): need to check for overflow! */
; 559  :     indices = (Py_ssize_t *)PyMem_Malloc(sizeof(Py_ssize_t)*view_src.ndim);

  0014b	48 63 4d db	 movsxd	 rcx, DWORD PTR view_src$[rbp-69]
  0014f	48 89 b4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rsi
  00157	48 c1 e1 03	 shl	 rcx, 3
  0015b	e8 00 00 00 00	 call	 PyMem_Malloc
  00160	48 8b f0	 mov	 rsi, rax

; 560  :     if (indices == NULL) {

  00163	48 85 c0	 test	 rax, rax
  00166	75 33		 jne	 SHORT $LN9@PyObject_C@12

; 561  :         PyErr_NoMemory();

  00168	e8 00 00 00 00	 call	 PyErr_NoMemory

; 562  :         PyBuffer_Release(&view_dest);

  0016d	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  00171	e8 00 00 00 00	 call	 PyBuffer_Release

; 563  :         PyBuffer_Release(&view_src);

  00176	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  0017a	e8 00 00 00 00	 call	 PyBuffer_Release

; 564  :         return -1;

  0017f	83 c8 ff	 or	 eax, -1
$LN36@PyObject_C@12:
  00182	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+208]

; 584  : }

  0018a	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
  00192	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00199	5d		 pop	 rbp
  0019a	c3		 ret	 0
$LN9@PyObject_C@12:

; 565  :     }
; 566  :     for (k=0; k<view_src.ndim;k++) {

  0019b	8b 4d db	 mov	 ecx, DWORD PTR view_src$[rbp-69]
  0019e	45 33 c0	 xor	 r8d, r8d
  001a1	48 89 bc 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rdi
  001a9	41 8b d0	 mov	 edx, r8d
  001ac	85 c9		 test	 ecx, ecx
  001ae	7e 10		 jle	 SHORT $LN6@PyObject_C@12
$LL8@PyObject_C@12:

; 567  :         indices[k] = 0;

  001b0	4c 89 00	 mov	 QWORD PTR [rax], r8
  001b3	8b 4d db	 mov	 ecx, DWORD PTR view_src$[rbp-69]
  001b6	ff c2		 inc	 edx
  001b8	48 83 c0 08	 add	 rax, 8
  001bc	3b d1		 cmp	 edx, ecx
  001be	7c f0		 jl	 SHORT $LL8@PyObject_C@12
$LN6@PyObject_C@12:

; 570  :     for (k=0; k<view_src.ndim; k++) {

  001c0	4c 8b 45 e7	 mov	 r8, QWORD PTR view_src$[rbp-57]
  001c4	bf 01 00 00 00	 mov	 edi, 1
  001c9	85 c9		 test	 ecx, ecx
  001cb	7e 17		 jle	 SHORT $LL2@PyObject_C@12

; 568  :     }
; 569  :     elements = 1;

  001cd	49 8b c0	 mov	 rax, r8
  001d0	8b d1		 mov	 edx, ecx
$LL5@PyObject_C@12:

; 571  :         /* XXX(nnorwitz): can this overflow? */
; 572  :         elements *= view_src.shape[k];

  001d2	48 0f af 38	 imul	 rdi, QWORD PTR [rax]
  001d6	48 83 c0 08	 add	 rax, 8
  001da	48 ff ca	 dec	 rdx
  001dd	75 f3		 jne	 SHORT $LL5@PyObject_C@12

; 573  :     }
; 574  :     while (elements--) {

  001df	48 85 ff	 test	 rdi, rdi
  001e2	74 3d		 je	 SHORT $LN34@PyObject_C@12
$LL2@PyObject_C@12:

; 575  :         _Py_add_one_to_index_C(view_src.ndim, indices, view_src.shape);

  001e4	48 8b d6	 mov	 rdx, rsi
  001e7	e8 00 00 00 00	 call	 _Py_add_one_to_index_C

; 576  :         dptr = PyBuffer_GetPointer(&view_dest, indices);
; 577  :         sptr = PyBuffer_GetPointer(&view_src, indices);

  001ec	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  001f0	e8 00 00 00 00	 call	 PyBuffer_GetPointer
  001f5	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  001f9	48 8b d6	 mov	 rdx, rsi
  001fc	48 8b d8	 mov	 rbx, rax
  001ff	e8 00 00 00 00	 call	 PyBuffer_GetPointer

; 578  :         memcpy(dptr, sptr, view_src.itemsize);

  00204	4c 8b 45 cf	 mov	 r8, QWORD PTR view_src$[rbp-81]
  00208	48 8b c8	 mov	 rcx, rax
  0020b	48 8b d3	 mov	 rdx, rbx
  0020e	e8 00 00 00 00	 call	 memcpy
  00213	48 ff cf	 dec	 rdi
  00216	74 09		 je	 SHORT $LN34@PyObject_C@12

; 573  :     }
; 574  :     while (elements--) {

  00218	4c 8b 45 e7	 mov	 r8, QWORD PTR view_src$[rbp-57]
  0021c	8b 4d db	 mov	 ecx, DWORD PTR view_src$[rbp-69]
  0021f	eb c3		 jmp	 SHORT $LL2@PyObject_C@12
$LN34@PyObject_C@12:

; 579  :     }
; 580  :     PyMem_Free(indices);

  00221	48 8b ce	 mov	 rcx, rsi
  00224	e8 00 00 00 00	 call	 PyMem_Free

; 581  :     PyBuffer_Release(&view_dest);

  00229	48 8d 4d 07	 lea	 rcx, QWORD PTR view_dest$[rbp-105]
  0022d	e8 00 00 00 00	 call	 PyBuffer_Release

; 582  :     PyBuffer_Release(&view_src);

  00232	48 8d 4d b7	 lea	 rcx, QWORD PTR view_src$[rbp-105]
  00236	e8 00 00 00 00	 call	 PyBuffer_Release
  0023b	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+216]

; 583  :     return 0;

  00243	33 c0		 xor	 eax, eax
  00245	e9 38 ff ff ff	 jmp	 $LN36@PyObject_C@12
$LN16@PyObject_C@12:

; 525  :         PyErr_SetString(PyExc_TypeError,
; 526  :                         "both destination and source must have the "\
; 527  :                         "buffer interface");

  0024a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00251	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@
  00258	e8 00 00 00 00	 call	 PyErr_SetString

; 584  : }

  0025d	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
  00265	83 c8 ff	 or	 eax, -1
  00268	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0026f	5d		 pop	 rbp
  00270	c3		 ret	 0
PyObject_CopyData ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@ ; `string'
PUBLIC	??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@ ; `string'
PUBLIC	PyObject_Format
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyObject_Format DD imagerel $LN26
	DD	imagerel $LN26+345
	DD	imagerel $unwind$PyObject_Format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Format DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@
CONST	SEGMENT
??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@ DB '__format__ m'
	DB	'ethod did not return string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@
CONST	SEGMENT
??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@ DB 'Type %.'
	DB	'100s doesn''t define __format__', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
CONST	ENDS
;	COMDAT PyObject_Format
_TEXT	SEGMENT
obj$ = 64
format_spec$ = 72
PyObject_Format PROC					; COMDAT

; 656  : {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 657  :     PyObject *meth;
; 658  :     PyObject *empty = NULL;

  0001a	33 ff		 xor	 edi, edi

; 659  :     PyObject *result = NULL;

  0001c	33 db		 xor	 ebx, ebx
  0001e	48 8b f2	 mov	 rsi, rdx
  00021	48 8b e9	 mov	 rbp, rcx

; 660  :     _Py_IDENTIFIER(__format__);
; 661  : 
; 662  :     /* If no format_spec is provided, use an empty string */
; 663  :     if (format_spec == NULL) {

  00024	48 85 d2	 test	 rdx, rdx
  00027	75 0d		 jne	 SHORT $LN8@PyObject_F

; 664  :         empty = PyUnicode_New(0, 0);

  00029	33 c9		 xor	 ecx, ecx
  0002b	e8 00 00 00 00	 call	 PyUnicode_New
  00030	48 8b f8	 mov	 rdi, rax

; 665  :         format_spec = empty;

  00033	48 8b f0	 mov	 rsi, rax
$LN8@PyObject_F:

; 666  :     }
; 667  : 
; 668  :     /* Find the (unbound!) __format__ method (a borrowed reference) */
; 669  :     meth = _PyObject_LookupSpecial(obj, &PyId___format__);

  00036	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0003d	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00046	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___format__@?1??PyObject_Format@@9@9
  0004b	4a 03 14 c1	 add	 rdx, QWORD PTR [rcx+r8*8]
  0004f	48 8b cd	 mov	 rcx, rbp
  00052	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00057	4c 8b e0	 mov	 r12, rax

; 670  :     if (meth == NULL) {

  0005a	48 85 c0	 test	 rax, rax
  0005d	75 27		 jne	 SHORT $LN7@PyObject_F

; 671  :         if (!PyErr_Occurred())

  0005f	e8 00 00 00 00	 call	 PyErr_Occurred
  00064	48 85 c0	 test	 rax, rax
  00067	75 68		 jne	 SHORT $done$20698

; 672  :             PyErr_Format(PyExc_TypeError,
; 673  :                          "Type %.100s doesn't define __format__",
; 674  :                          Py_TYPE(obj)->tp_name);

  00069	4c 8b 45 58	 mov	 r8, QWORD PTR [rbp+88]
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@
  0007b	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0007f	e8 00 00 00 00	 call	 PyErr_Format

; 675  :         goto done;

  00084	eb 4b		 jmp	 SHORT $done$20698
$LN7@PyObject_F:

; 676  :     }
; 677  : 
; 678  :     /* And call it. */
; 679  :     result = PyObject_CallFunctionObjArgs(meth, format_spec, NULL);

  00086	45 33 c0	 xor	 r8d, r8d
  00089	48 8b d6	 mov	 rdx, rsi
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 680  :     Py_DECREF(meth);

  00094	49 8b cc	 mov	 rcx, r12
  00097	48 8b d8	 mov	 rbx, rax
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 681  : 
; 682  :     if (result && !PyUnicode_Check(result)) {

  0009f	48 85 db	 test	 rbx, rbx
  000a2	74 2d		 je	 SHORT $done$20698
  000a4	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  000a8	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  000b2	75 1d		 jne	 SHORT $done$20698

; 683  :         PyErr_SetString(PyExc_TypeError,
; 684  :                         "__format__ method did not return string");

  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@
  000c2	e8 00 00 00 00	 call	 PyErr_SetString

; 685  :         Py_DECREF(result);

  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	e8 00 00 00 00	 call	 _Py_DecRef

; 686  :         result = NULL;

  000cf	33 db		 xor	 ebx, ebx
$done$20698:

; 687  :         goto done;
; 688  :     }
; 689  : 
; 690  : done:
; 691  :     Py_XDECREF(empty);

  000d1	48 85 ff	 test	 rdi, rdi
  000d4	74 65		 je	 SHORT $LN24@PyObject_F
  000d6	e8 00 00 00 00	 call	 _Py_PXCTX
  000db	85 c0		 test	 eax, eax
  000dd	75 5c		 jne	 SHORT $LN24@PyObject_F
  000df	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000e3	a8 20		 test	 al, 32			; 00000020H
  000e5	75 4c		 jne	 SHORT $LN15@PyObject_F
  000e7	84 c0		 test	 al, al
  000e9	78 48		 js	 SHORT $LN15@PyObject_F
  000eb	a8 02		 test	 al, 2
  000ed	75 4c		 jne	 SHORT $LN24@PyObject_F
  000ef	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000f3	75 46		 jne	 SHORT $LN24@PyObject_F
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00103	4c 8b cf	 mov	 r9, rdi
  00106	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0010c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00114	e8 00 00 00 00	 call	 _PyParallel_Guard
  00119	48 8b cf	 mov	 rcx, rdi
  0011c	85 c0		 test	 eax, eax
  0011e	74 07		 je	 SHORT $LN20@PyObject_F
  00120	e8 00 00 00 00	 call	 _Px_Dealloc
  00125	eb 14		 jmp	 SHORT $LN24@PyObject_F
$LN20@PyObject_F:
  00127	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0012b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00131	eb 08		 jmp	 SHORT $LN24@PyObject_F
$LN15@PyObject_F:
  00133	48 8b cf	 mov	 rcx, rdi
  00136	e8 00 00 00 00	 call	 Px_DecRef
$LN24@PyObject_F:

; 692  :     return result;
; 693  : }

  0013b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00140	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00145	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0014a	48 8b c3	 mov	 rax, rbx
  0014d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	41 5c		 pop	 r12
  00158	c3		 ret	 0
PyObject_Format ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$sequence_repeat DD imagerel sequence_repeat
	DD	imagerel sequence_repeat+52
	DD	imagerel $unwind$sequence_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$sequence_repeat DD imagerel sequence_repeat+52
	DD	imagerel sequence_repeat+99
	DD	imagerel $chain$0$sequence_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$sequence_repeat DD imagerel sequence_repeat+99
	DD	imagerel sequence_repeat+126
	DD	imagerel $chain$2$sequence_repeat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$sequence_repeat DD imagerel sequence_repeat+126
	DD	imagerel sequence_repeat+151
	DD	imagerel $chain$3$sequence_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$sequence_repeat DD 021H
	DD	imagerel sequence_repeat
	DD	imagerel sequence_repeat+52
	DD	imagerel $unwind$sequence_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$sequence_repeat DD 020021H
	DD	063400H
	DD	imagerel sequence_repeat
	DD	imagerel sequence_repeat+52
	DD	imagerel $unwind$sequence_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$sequence_repeat DD 020521H
	DD	063405H
	DD	imagerel sequence_repeat
	DD	imagerel sequence_repeat+52
	DD	imagerel $unwind$sequence_repeat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sequence_repeat DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@
CONST	SEGMENT
??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@ DB 'can''t mul'
	DB	'tiply sequence by non-int of type ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT sequence_repeat
_TEXT	SEGMENT
repeatfunc$ = 48
seq$ = 56
n$ = 64
sequence_repeat PROC					; COMDAT

; 894  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 895  :     Py_ssize_t count;
; 896  :     if (PyIndex_Check(n)) {

  0000a	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b f1	 mov	 rsi, rcx
  00014	4c 8b 88 b8 00
	00 00		 mov	 r9, QWORD PTR [rax+184]
  0001b	4d 85 c9	 test	 r9, r9
  0001e	74 5e		 je	 SHORT $LN3@sequence_r
  00020	49 83 b9 08 01
	00 00 00	 cmp	 QWORD PTR [r9+264], 0
  00028	74 54		 je	 SHORT $LN3@sequence_r

; 897  :         count = PyNumber_AsSsize_t(n, PyExc_OverflowError);

  0002a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00031	49 8b c8	 mov	 rcx, r8
  00034	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00039	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0003e	48 8b d8	 mov	 rbx, rax

; 898  :         if (count == -1 && PyErr_Occurred())

  00041	48 83 f8 ff	 cmp	 rax, -1
  00045	75 1c		 jne	 SHORT $LN2@sequence_r
  00047	e8 00 00 00 00	 call	 PyErr_Occurred
  0004c	48 85 c0	 test	 rax, rax
  0004f	74 12		 je	 SHORT $LN2@sequence_r

; 899  :             return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 906  : }

  00058	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN2@sequence_r:

; 904  :     }
; 905  :     return (*repeatfunc)(seq, count);

  00063	48 8b d3	 mov	 rdx, rbx
  00066	48 8b cf	 mov	 rcx, rdi
  00069	48 8b c6	 mov	 rax, rsi
  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 906  : }

  00071	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	48 ff e0	 rex_jmp rax
$LN3@sequence_r:

; 900  :     }
; 901  :     else {
; 902  :         return type_error("can't multiply sequence by "
; 903  :                           "non-int of type '%.200s'", n);

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@
  00085	49 8b d0	 mov	 rdx, r8

; 906  : }

  00088	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	e9 00 00 00 00	 jmp	 type_error
sequence_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	PyNumber_Multiply
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Multiply DD imagerel $LN7
	DD	imagerel $LN7+172
	DD	imagerel $unwind$PyNumber_Multiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Multiply DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_Multiply
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Multiply PROC					; COMDAT

; 910  : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 911  :     PyObject *result = binary_op1(v, w, NB_SLOT(nb_multiply));

  00014	41 b8 10 00 00
	00		 mov	 r8d, 16
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	e8 00 00 00 00	 call	 binary_op1

; 912  :     if (result == Py_NotImplemented) {

  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0002c	48 3b c1	 cmp	 rax, rcx
  0002f	75 66		 jne	 SHORT $LN4@PyNumber_M

; 913  :         PySequenceMethods *mv = v->ob_type->tp_as_sequence;

  00031	4c 8b 46 58	 mov	 r8, QWORD PTR [rsi+88]

; 914  :         PySequenceMethods *mw = w->ob_type->tp_as_sequence;
; 915  :         Py_DECREF(result);

  00035	48 8b c8	 mov	 rcx, rax
  00038	49 8b a8 c0 00
	00 00		 mov	 rbp, QWORD PTR [r8+192]
  0003f	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  00043	49 8b 98 c0 00
	00 00		 mov	 rbx, QWORD PTR [r8+192]
  0004a	e8 00 00 00 00	 call	 _Py_DecRef

; 916  :         if  (mv && mv->sq_repeat) {

  0004f	48 85 ed	 test	 rbp, rbp
  00052	74 16		 je	 SHORT $LN3@PyNumber_M
  00054	48 8b 4d 10	 mov	 rcx, QWORD PTR [rbp+16]
  00058	48 85 c9	 test	 rcx, rcx
  0005b	74 0d		 je	 SHORT $LN3@PyNumber_M

; 917  :             return sequence_repeat(mv->sq_repeat, v, w);

  0005d	4c 8b c7	 mov	 r8, rdi
  00060	48 8b d6	 mov	 rdx, rsi
  00063	e8 00 00 00 00	 call	 sequence_repeat
  00068	eb 2d		 jmp	 SHORT $LN4@PyNumber_M
$LN3@PyNumber_M:

; 918  :         }
; 919  :         else if (mw && mw->sq_repeat) {

  0006a	48 85 db	 test	 rbx, rbx
  0006d	74 16		 je	 SHORT $LN1@PyNumber_M
  0006f	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00073	48 85 c9	 test	 rcx, rcx
  00076	74 0d		 je	 SHORT $LN1@PyNumber_M

; 920  :             return sequence_repeat(mw->sq_repeat, w, v);

  00078	4c 8b c6	 mov	 r8, rsi
  0007b	48 8b d7	 mov	 rdx, rdi
  0007e	e8 00 00 00 00	 call	 sequence_repeat
  00083	eb 12		 jmp	 SHORT $LN4@PyNumber_M
$LN1@PyNumber_M:

; 921  :         }
; 922  :         result = binop_type_error(v, w, "*");

  00085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NBENCBCI@?$CK?$AA@
  0008c	48 8b d7	 mov	 rdx, rdi
  0008f	48 8b ce	 mov	 rcx, rsi
  00092	e8 00 00 00 00	 call	 binop_type_error
$LN4@PyNumber_M:

; 923  :     }
; 924  :     return result;
; 925  : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
PyNumber_Multiply ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FPIMKNGF@?$CK?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceMultiply
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceMultiply DD imagerel $LN11
	DD	imagerel $LN11+187
	DD	imagerel $unwind$PyNumber_InPlaceMultiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceMultiply DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_02FPIMKNGF@?$CK?$DN?$AA@
CONST	SEGMENT
??_C@_02FPIMKNGF@?$CK?$DN?$AA@ DB '*=', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyNumber_InPlaceMultiply
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_InPlaceMultiply PROC				; COMDAT

; 1046 : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1047 :     PyObject *result = binary_iop1(v, w, NB_SLOT(nb_inplace_multiply),
; 1048 :                                    NB_SLOT(nb_multiply));

  00014	41 b9 10 00 00
	00		 mov	 r9d, 16
  0001a	41 b8 a8 00 00
	00		 mov	 r8d, 168		; 000000a8H
  00020	48 8b f2	 mov	 rsi, rdx
  00023	48 8b e9	 mov	 rbp, rcx
  00026	e8 00 00 00 00	 call	 binary_iop1

; 1049 :     if (result == Py_NotImplemented) {

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00032	48 3b c1	 cmp	 rax, rcx
  00035	75 6f		 jne	 SHORT $LN7@PyNumber_I@5

; 1050 :         ssizeargfunc f = NULL;
; 1051 :         PySequenceMethods *mv = v->ob_type->tp_as_sequence;

  00037	4c 8b 45 58	 mov	 r8, QWORD PTR [rbp+88]

; 1052 :         PySequenceMethods *mw = w->ob_type->tp_as_sequence;

  0003b	48 8b 56 58	 mov	 rdx, QWORD PTR [rsi+88]

; 1053 :         Py_DECREF(result);

  0003f	48 8b c8	 mov	 rcx, rax
  00042	49 8b 98 c0 00
	00 00		 mov	 rbx, QWORD PTR [r8+192]
  00049	48 8b ba c0 00
	00 00		 mov	 rdi, QWORD PTR [rdx+192]
  00050	e8 00 00 00 00	 call	 _Py_DecRef

; 1054 :         if (mv != NULL) {

  00055	48 85 db	 test	 rbx, rbx
  00058	74 1f		 je	 SHORT $LN6@PyNumber_I@5

; 1055 :             f = mv->sq_inplace_repeat;

  0005a	48 8b 4b 48	 mov	 rcx, QWORD PTR [rbx+72]

; 1056 :             if (f == NULL)

  0005e	48 85 c9	 test	 rcx, rcx
  00061	75 09		 jne	 SHORT $LN10@PyNumber_I@5

; 1057 :                 f = mv->sq_repeat;

  00063	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 1058 :             if (f != NULL)

  00067	48 85 c9	 test	 rcx, rcx
  0006a	74 28		 je	 SHORT $LN1@PyNumber_I@5
$LN10@PyNumber_I@5:

; 1059 :                 return sequence_repeat(f, v, w);

  0006c	4c 8b c6	 mov	 r8, rsi
  0006f	48 8b d5	 mov	 rdx, rbp
  00072	e8 00 00 00 00	 call	 sequence_repeat
  00077	eb 2d		 jmp	 SHORT $LN7@PyNumber_I@5
$LN6@PyNumber_I@5:

; 1060 :         }
; 1061 :         else if (mw != NULL) {

  00079	48 85 ff	 test	 rdi, rdi
  0007c	74 16		 je	 SHORT $LN1@PyNumber_I@5

; 1062 :             /* Note that the right hand operand should not be
; 1063 :              * mutated in this case so sq_inplace_repeat is not
; 1064 :              * used. */
; 1065 :             if (mw->sq_repeat)

  0007e	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00082	48 85 c9	 test	 rcx, rcx
  00085	74 0d		 je	 SHORT $LN1@PyNumber_I@5

; 1066 :                 return sequence_repeat(mw->sq_repeat, w, v);

  00087	4c 8b c5	 mov	 r8, rbp
  0008a	48 8b d6	 mov	 rdx, rsi
  0008d	e8 00 00 00 00	 call	 sequence_repeat
  00092	eb 12		 jmp	 SHORT $LN7@PyNumber_I@5
$LN1@PyNumber_I@5:

; 1067 :         }
; 1068 :         result = binop_type_error(v, w, "*=");

  00094	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FPIMKNGF@?$CK?$DN?$AA@
  0009b	48 8b d6	 mov	 rdx, rsi
  0009e	48 8b cd	 mov	 rcx, rbp
  000a1	e8 00 00 00 00	 call	 binop_type_error
$LN7@PyNumber_I@5:

; 1069 :     }
; 1070 :     return result;
; 1071 : }

  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ab	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
PyNumber_InPlaceMultiply ENDP
_TEXT	ENDS
PUBLIC	PySequence_Tuple
EXTRN	_PyTuple_Resize:PROC
EXTRN	PyList_AsTuple:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PySequence_Tuple DD imagerel $LN35
	DD	imagerel $LN35+146
	DD	imagerel $unwind$PySequence_Tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySequence_Tuple DD imagerel $LN35+146
	DD	imagerel $LN35+176
	DD	imagerel $chain$0$PySequence_Tuple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PySequence_Tuple DD imagerel $LN35+176
	DD	imagerel $LN35+440
	DD	imagerel $chain$4$PySequence_Tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PySequence_Tuple DD 061221H
	DD	06c412H
	DD	0b540dH
	DD	0c6400H
	DD	imagerel $LN35
	DD	imagerel $LN35+146
	DD	imagerel $unwind$PySequence_Tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySequence_Tuple DD 020521H
	DD	0c6405H
	DD	imagerel $LN35
	DD	imagerel $LN35+146
	DD	imagerel $unwind$PySequence_Tuple
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Tuple DD 030701H
	DD	070036207H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT PySequence_Tuple
_TEXT	SEGMENT
result$ = 80
v$ = 80
PySequence_Tuple PROC					; COMDAT

; 1647 : {

$LN35:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1648 :     PyObject *it;  /* iter(v) */
; 1649 :     Py_ssize_t n;             /* guess for result tuple size */
; 1650 :     PyObject *result = NULL;

  00007	33 ff		 xor	 edi, edi
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 89 7c 24 50	 mov	 QWORD PTR result$[rsp], rdi

; 1651 :     Py_ssize_t j;
; 1652 : 
; 1653 :     if (v == NULL)

  00011	48 85 c9	 test	 rcx, rcx
  00014	75 0c		 jne	 SHORT $LN19@PySequence@14

; 1654 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error

; 1725 : }

  0001b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001f	5f		 pop	 rdi
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN19@PySequence@14:

; 1655 : 
; 1656 :     /* Special-case the common tuple and list cases, for efficiency. */
; 1657 :     if (PyTuple_CheckExact(v)) {

  00022	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTuple_Type
  0002d	48 3b c1	 cmp	 rax, rcx
  00030	75 45		 jne	 SHORT $LN18@PySequence@14

; 1658 :         /* Note that we can't know whether it's safe to return
; 1659 :            a tuple *subclass* instance as-is, hence the restriction
; 1660 :            to exact tuples here.  In contrast, lists always make
; 1661 :            a copy, so there's no need for exactness below. */
; 1662 :         Py_INCREF(v);

  00032	e8 00 00 00 00	 call	 _Py_PXCTX
  00037	85 c0		 test	 eax, eax
  00039	75 32		 jne	 SHORT $LN23@PySequence@14
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00049	4c 8b cb	 mov	 r9, rbx
  0004c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00052	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005f	85 c0		 test	 eax, eax
  00061	75 06		 jne	 SHORT $LN22@PySequence@14
  00063	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00067	74 04		 je	 SHORT $LN23@PySequence@14
$LN22@PySequence@14:
  00069	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN23@PySequence@14:

; 1663 :         return v;

  0006d	48 8b c3	 mov	 rax, rbx

; 1725 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	5f		 pop	 rdi
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
$LN18@PySequence@14:

; 1664 :     }
; 1665 :     if (PyList_Check(v))

  00077	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H

; 1666 :         return PyList_AsTuple(v);

  00081	48 8b cb	 mov	 rcx, rbx
  00084	74 0c		 je	 SHORT $LN17@PySequence@14
  00086	e8 00 00 00 00	 call	 PyList_AsTuple

; 1725 : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	5f		 pop	 rdi
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
$LN17@PySequence@14:
  00092	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi

; 1667 : 
; 1668 :     /* Get iterator. */
; 1669 :     it = PyObject_GetIter(v);

  00097	e8 00 00 00 00	 call	 PyObject_GetIter
  0009c	48 8b f0	 mov	 rsi, rax

; 1670 :     if (it == NULL)

  0009f	48 85 c0	 test	 rax, rax
  000a2	75 0c		 jne	 SHORT $LN16@PySequence@14
  000a4	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 1725 : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	5f		 pop	 rdi
  000ae	5b		 pop	 rbx
  000af	c3		 ret	 0
$LN16@PySequence@14:

; 1671 :         return NULL;
; 1672 : 
; 1673 :     /* Guess result size and allocate space. */
; 1674 :     n = _PyObject_LengthHint(v, 10);

  000b0	ba 0a 00 00 00	 mov	 edx, 10
  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  000bd	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  000c2	e8 00 00 00 00	 call	 _PyObject_LengthHint
  000c7	48 8b d8	 mov	 rbx, rax

; 1675 :     if (n == -1)

  000ca	48 83 f8 ff	 cmp	 rax, -1
  000ce	0f 84 b5 00 00
	00		 je	 $Fail$21583

; 1676 :         goto Fail;
; 1677 :     result = PyTuple_New(n);

  000d4	48 8b c8	 mov	 rcx, rax
  000d7	e8 00 00 00 00	 call	 PyTuple_New
  000dc	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1678 :     if (result == NULL)

  000e1	48 85 c0	 test	 rax, rax
  000e4	0f 84 ae 00 00
	00		 je	 $LN3@PySequence@14

; 1683 :         PyObject *item = PyIter_Next(it);

  000ea	48 8b ce	 mov	 rcx, rsi
  000ed	e8 00 00 00 00	 call	 PyIter_Next
  000f2	48 8b e8	 mov	 rbp, rax

; 1684 :         if (item == NULL) {

  000f5	48 85 c0	 test	 rax, rax
  000f8	74 53		 je	 SHORT $LN28@PySequence@14

; 1679 :         goto Fail;
; 1680 : 
; 1681 :     /* Fill the tuple. */
; 1682 :     for (j = 0; ; ++j) {

  000fa	41 bc 70 00 00
	00		 mov	 r12d, 112		; 00000070H
$LL13@PySequence@14:

; 1686 :                 goto Fail;
; 1687 :             break;
; 1688 :         }
; 1689 :         if (j >= n) {

  00100	48 3b fb	 cmp	 rdi, rbx
  00103	7c 27		 jl	 SHORT $LN6@PySequence@14

; 1690 :             Py_ssize_t oldn = n;

  00105	48 8b d3	 mov	 rdx, rbx

; 1691 :             /* The over-allocation strategy can grow a bit faster
; 1692 :                than for lists because unlike lists the
; 1693 :                over-allocation isn't permanent -- we reclaim
; 1694 :                the excess before the end of this routine.
; 1695 :                So, grow by ten and then add 25%.
; 1696 :             */
; 1697 :             n += 10;

  00108	48 83 c3 0a	 add	 rbx, 10

; 1698 :             n += n >> 2;

  0010c	48 8b cb	 mov	 rcx, rbx
  0010f	48 c1 f9 02	 sar	 rcx, 2
  00113	48 03 d9	 add	 rbx, rcx

; 1699 :             if (n < oldn) {

  00116	48 3b da	 cmp	 rbx, rdx
  00119	7c 61		 jl	 SHORT $LN29@PySequence@14

; 1703 :                 goto Fail;
; 1704 :             }
; 1705 :             if (_PyTuple_Resize(&result, n) != 0) {

  0011b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00120	48 8b d3	 mov	 rdx, rbx
  00123	e8 00 00 00 00	 call	 _PyTuple_Resize
  00128	85 c0		 test	 eax, eax
  0012a	75 55		 jne	 SHORT $LN30@PySequence@14
$LN6@PySequence@14:

; 1706 :                 Py_DECREF(item);
; 1707 :                 goto Fail;
; 1708 :             }
; 1709 :         }
; 1710 :         PyTuple_SET_ITEM(result, j, item);

  0012c	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  00131	48 8b ce	 mov	 rcx, rsi
  00134	49 83 c4 08	 add	 r12, 8
  00138	49 89 6c 04 f8	 mov	 QWORD PTR [r12+rax-8], rbp
  0013d	48 ff c7	 inc	 rdi
  00140	e8 00 00 00 00	 call	 PyIter_Next
  00145	48 8b e8	 mov	 rbp, rax
  00148	48 85 c0	 test	 rax, rax
  0014b	75 b3		 jne	 SHORT $LL13@PySequence@14
$LN28@PySequence@14:

; 1685 :             if (PyErr_Occurred())

  0014d	e8 00 00 00 00	 call	 PyErr_Occurred
  00152	48 85 c0	 test	 rax, rax
  00155	75 32		 jne	 SHORT $Fail$21583

; 1711 :     }
; 1712 : 
; 1713 :     /* Cut tuple back if guess was too large. */
; 1714 :     if (j < n &&
; 1715 :         _PyTuple_Resize(&result, j) != 0)

  00157	48 3b fb	 cmp	 rdi, rbx
  0015a	7d 11		 jge	 SHORT $LN5@PySequence@14
  0015c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  00161	48 8b d7	 mov	 rdx, rdi
  00164	e8 00 00 00 00	 call	 _PyTuple_Resize
  00169	85 c0		 test	 eax, eax
  0016b	75 1c		 jne	 SHORT $Fail$21583
$LN5@PySequence@14:

; 1716 :         goto Fail;
; 1717 : 
; 1718 :     Py_DECREF(it);

  0016d	48 8b ce	 mov	 rcx, rsi
  00170	e8 00 00 00 00	 call	 _Py_DecRef

; 1719 :     return result;

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  0017a	eb 26		 jmp	 SHORT $LN34@PySequence@14
$LN29@PySequence@14:

; 1700 :                 /* Check for overflow */
; 1701 :                 PyErr_NoMemory();

  0017c	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN30@PySequence@14:

; 1702 :                 Py_DECREF(item);

  00181	48 8b cd	 mov	 rcx, rbp
  00184	e8 00 00 00 00	 call	 _Py_DecRef
$Fail$21583:

; 1720 : 
; 1721 : Fail:
; 1722 :     Py_XDECREF(result);

  00189	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0018e	48 85 c9	 test	 rcx, rcx
  00191	74 05		 je	 SHORT $LN3@PySequence@14
  00193	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PySequence@14:

; 1723 :     Py_DECREF(it);

  00198	48 8b ce	 mov	 rcx, rsi
  0019b	e8 00 00 00 00	 call	 _Py_DecRef

; 1724 :     return NULL;

  001a0	33 c0		 xor	 eax, eax
$LN34@PySequence@14:
  001a2	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001a7	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  001ac	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 1725 : }

  001b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001b5	5f		 pop	 rdi
  001b6	5b		 pop	 rbx
  001b7	c3		 ret	 0
PySequence_Tuple ENDP
_TEXT	ENDS
PUBLIC	PySequence_Fast
EXTRN	PyList_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PySequence_Fast DD imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$PySequence_Fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PySequence_Fast DD imagerel $LN13+67
	DD	imagerel $LN13+134
	DD	imagerel $chain$0$PySequence_Fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PySequence_Fast DD imagerel $LN13+134
	DD	imagerel $LN13+172
	DD	imagerel $chain$2$PySequence_Fast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PySequence_Fast DD imagerel $LN13+172
	DD	imagerel $LN13+245
	DD	imagerel $chain$3$PySequence_Fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PySequence_Fast DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$PySequence_Fast
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PySequence_Fast DD 020021H
	DD	087400H
	DD	imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$PySequence_Fast
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PySequence_Fast DD 020521H
	DD	087405H
	DD	imagerel $LN13
	DD	imagerel $LN13+67
	DD	imagerel $unwind$PySequence_Fast
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Fast DD 040a01H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT PySequence_Fast
_TEXT	SEGMENT
v$ = 64
m$ = 72
PySequence_Fast PROC					; COMDAT

; 1751 : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1752 :     PyObject *it;
; 1753 : 
; 1754 :     if (v == NULL)

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 0f		 jne	 SHORT $LN5@PySequence@15

; 1773 : }

  00015	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0001a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001e	5e		 pop	 rsi
  0001f	e9 00 00 00 00	 jmp	 null_error
$LN5@PySequence@15:

; 1755 :         return null_error();
; 1756 : 
; 1757 :     if (PyList_CheckExact(v) || PyTuple_CheckExact(v)) {

  00024	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  0002f	48 3b c1	 cmp	 rax, rcx
  00032	74 78		 je	 SHORT $LN3@PySequence@15
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTuple_Type
  0003b	48 3b c1	 cmp	 rax, rcx
  0003e	74 6c		 je	 SHORT $LN3@PySequence@15

; 1760 :     }
; 1761 : 
; 1762 :     it = PyObject_GetIter(v);

  00040	48 8b cb	 mov	 rcx, rbx
  00043	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00048	e8 00 00 00 00	 call	 PyObject_GetIter
  0004d	48 8b f8	 mov	 rdi, rax

; 1763 :     if (it == NULL) {

  00050	48 85 c0	 test	 rax, rax
  00053	75 31		 jne	 SHORT $LN2@PySequence@15

; 1764 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00061	85 c0		 test	 eax, eax
  00063	74 0f		 je	 SHORT $LN1@PySequence@15

; 1765 :             PyErr_SetString(PyExc_TypeError, m);

  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006c	48 8b d6	 mov	 rdx, rsi
  0006f	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PySequence@15:

; 1766 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1773 : }

  0007b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5e		 pop	 rsi
  00085	c3		 ret	 0
$LN2@PySequence@15:

; 1767 :     }
; 1768 : 
; 1769 :     v = PySequence_List(it);

  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 PySequence_List

; 1770 :     Py_DECREF(it);

  0008e	48 8b cf	 mov	 rcx, rdi
  00091	48 8b d8	 mov	 rbx, rax
  00094	e8 00 00 00 00	 call	 _Py_DecRef
  00099	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1771 : 
; 1772 :     return v;

  0009e	48 8b c3	 mov	 rax, rbx

; 1773 : }

  000a1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5e		 pop	 rsi
  000ab	c3		 ret	 0
$LN3@PySequence@15:

; 1758 :         Py_INCREF(v);

  000ac	e8 00 00 00 00	 call	 _Py_PXCTX
  000b1	85 c0		 test	 eax, eax
  000b3	75 32		 jne	 SHORT $LN9@PySequence@15
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c3	4c 8b cb	 mov	 r9, rbx
  000c6	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000cc	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d9	85 c0		 test	 eax, eax
  000db	75 06		 jne	 SHORT $LN8@PySequence@15
  000dd	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000e1	74 04		 je	 SHORT $LN9@PySequence@15
$LN8@PySequence@15:
  000e3	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@PySequence@15:

; 1759 :         return v;

  000e7	48 8b c3	 mov	 rax, rbx

; 1773 : }

  000ea	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ef	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f3	5e		 pop	 rsi
  000f4	c3		 ret	 0
PySequence_Fast ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@ ; `string'
PUBLIC	??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@ ; `string'
PUBLIC	??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@ ; `string'
PUBLIC	??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@ ; `string'
PUBLIC	_PySequence_IterSearch
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySequence_IterSearch DD imagerel $LN30
	DD	imagerel $LN30+36
	DD	imagerel $unwind$_PySequence_IterSearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PySequence_IterSearch DD imagerel $LN30+36
	DD	imagerel $LN30+87
	DD	imagerel $chain$0$_PySequence_IterSearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PySequence_IterSearch DD imagerel $LN30+87
	DD	imagerel $LN30+323
	DD	imagerel $chain$6$_PySequence_IterSearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_PySequence_IterSearch DD imagerel $LN30+323
	DD	imagerel $LN30+371
	DD	imagerel $chain$8$_PySequence_IterSearch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$_PySequence_IterSearch DD imagerel $LN30+371
	DD	imagerel $LN30+389
	DD	imagerel $chain$9$_PySequence_IterSearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$_PySequence_IterSearch DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+36
	DD	imagerel $unwind$_PySequence_IterSearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_PySequence_IterSearch DD 0a0021H
	DD	04f400H
	DD	05d400H
	DD	0cc400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel $LN30
	DD	imagerel $LN30+36
	DD	imagerel $unwind$_PySequence_IterSearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PySequence_IterSearch DD 0a1b21H
	DD	04f41bH
	DD	0cc414H
	DD	0b640aH
	DD	0a5405H
	DD	05d400H
	DD	imagerel $LN30
	DD	imagerel $LN30+36
	DD	imagerel $unwind$_PySequence_IterSearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PySequence_IterSearch DD 020521H
	DD	05d405H
	DD	imagerel $LN30
	DD	imagerel $LN30+36
	DD	imagerel $unwind$_PySequence_IterSearch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySequence_IterSearch DD 040901H
	DD	0e0055209H
	DD	030027003H
xdata	ENDS
;	COMDAT ??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@
CONST	SEGMENT
??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@ DB 'index exceed'
	DB	's C integer size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@
CONST	SEGMENT
??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@ DB 'count exceed'
	DB	's C integer size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@
CONST	SEGMENT
??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@ DB 'sequ'
	DB	'ence.index(x): x not in sequence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@
CONST	SEGMENT
??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@ DB 'argum'
	DB	'ent of type ''%.200s'' is not iterable', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PySequence_IterSearch
_TEXT	SEGMENT
seq$ = 80
obj$ = 88
operation$ = 96
_PySequence_IterSearch PROC				; COMDAT

; 1783 : {

$LN30:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	41 8b f8	 mov	 edi, r8d
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b d9	 mov	 rbx, rcx

; 1784 :     Py_ssize_t n;
; 1785 :     int wrapped;  /* for PY_ITERSEARCH_INDEX, true iff n wrapped around */
; 1786 :     PyObject *it;  /* iter(seq) */
; 1787 : 
; 1788 :     if (seq == NULL || obj == NULL) {

  00012	48 85 c9	 test	 rcx, rcx
  00015	0f 84 58 01 00
	00		 je	 $LN19@PySequence@16
  0001b	48 85 d2	 test	 rdx, rdx
  0001e	0f 84 4f 01 00
	00		 je	 $LN19@PySequence@16

; 1791 :     }
; 1792 : 
; 1793 :     it = PyObject_GetIter(seq);

  00024	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00029	e8 00 00 00 00	 call	 PyObject_GetIter
  0002e	4c 8b e8	 mov	 r13, rax

; 1794 :     if (it == NULL) {

  00031	48 85 c0	 test	 rax, rax
  00034	75 21		 jne	 SHORT $LN18@PySequence@16

; 1795 :         type_error("argument of type '%.200s' is not iterable", seq);

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@
  0003d	48 8b d3	 mov	 rdx, rbx
  00040	e8 00 00 00 00	 call	 type_error
  00045	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 1796 :         return -1;

  0004a	48 83 c8 ff	 or	 rax, -1

; 1860 : 
; 1861 : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	41 5e		 pop	 r14
  00054	5f		 pop	 rdi
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN18@PySequence@16:
  00057	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0005c	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 1797 :     }
; 1798 : 
; 1799 :     n = wrapped = 0;

  00061	33 ed		 xor	 ebp, ebp

; 1800 :     for (;;) {
; 1801 :         int cmp;
; 1802 :         PyObject *item = PyIter_Next(it);

  00063	48 8b c8	 mov	 rcx, rax
  00066	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  0006b	8b dd		 mov	 ebx, ebp
  0006d	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00072	e8 00 00 00 00	 call	 PyIter_Next
  00077	48 8b f0	 mov	 rsi, rax

; 1803 :         if (item == NULL) {

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 71		 je	 SHORT $LN24@PySequence@16
  0007f	49 bf ff ff ff
	ff ff ff ff 7f	 mov	 r15, 9223372036854775807 ; 7fffffffffffffffH
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@PySequence@16:

; 1805 :                 goto Fail;
; 1806 :             break;
; 1807 :         }
; 1808 : 
; 1809 :         cmp = PyObject_RichCompareBool(obj, item, Py_EQ);

  00090	41 b8 02 00 00
	00		 mov	 r8d, 2
  00096	48 8b d6	 mov	 rdx, rsi
  00099	49 8b ce	 mov	 rcx, r14
  0009c	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 1810 :         Py_DECREF(item);

  000a1	48 8b ce	 mov	 rcx, rsi
  000a4	44 8b e0	 mov	 r12d, eax
  000a7	e8 00 00 00 00	 call	 _Py_DecRef

; 1811 :         if (cmp < 0)

  000ac	45 85 e4	 test	 r12d, r12d
  000af	78 61		 js	 SHORT $Fail$21668

; 1812 :             goto Fail;
; 1813 :         if (cmp > 0) {

  000b1	7e 1a		 jle	 SHORT $LN4@PySequence@16

; 1814 :             switch (operation) {

  000b3	8b cf		 mov	 ecx, edi
  000b5	ff c9		 dec	 ecx
  000b7	0f 84 86 00 00
	00		 je	 $LN9@PySequence@16
  000bd	ff c9		 dec	 ecx
  000bf	0f 84 9a 00 00
	00		 je	 $LN7@PySequence@16
  000c5	ff c9		 dec	 ecx
  000c7	0f 84 8b 00 00
	00		 je	 $LN5@PySequence@16
$LN4@PySequence@16:

; 1835 : 
; 1836 :             default:
; 1837 :                 assert(!"unknown operation");
; 1838 :             }
; 1839 :         }
; 1840 : 
; 1841 :         if (operation == PY_ITERSEARCH_INDEX) {

  000cd	83 ff 02	 cmp	 edi, 2
  000d0	75 0e		 jne	 SHORT $LN3@PySequence@16

; 1842 :             if (n == PY_SSIZE_T_MAX)

  000d2	49 3b df	 cmp	 rbx, r15
  000d5	b8 01 00 00 00	 mov	 eax, 1
  000da	0f 44 e8	 cmove	 ebp, eax
$LN28@PySequence@16:

; 1843 :                 wrapped = 1;
; 1844 :             ++n;

  000dd	48 ff c3	 inc	 rbx
$LN3@PySequence@16:

; 1800 :     for (;;) {
; 1801 :         int cmp;
; 1802 :         PyObject *item = PyIter_Next(it);

  000e0	49 8b cd	 mov	 rcx, r13
  000e3	e8 00 00 00 00	 call	 PyIter_Next
  000e8	48 8b f0	 mov	 rsi, rax

; 1803 :         if (item == NULL) {

  000eb	48 85 c0	 test	 rax, rax
  000ee	75 a0		 jne	 SHORT $LL17@PySequence@16
$LN24@PySequence@16:

; 1804 :             if (PyErr_Occurred())

  000f0	e8 00 00 00 00	 call	 PyErr_Occurred
  000f5	48 85 c0	 test	 rax, rax
  000f8	75 18		 jne	 SHORT $Fail$21668

; 1845 :         }
; 1846 :     }
; 1847 : 
; 1848 :     if (operation != PY_ITERSEARCH_INDEX)

  000fa	83 ff 02	 cmp	 edi, 2
  000fd	75 17		 jne	 SHORT $Done$21684

; 1849 :         goto Done;
; 1850 : 
; 1851 :     PyErr_SetString(PyExc_ValueError,
; 1852 :                     "sequence.index(x): x not in sequence");

  000ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@
$LN29@PySequence@16:
  0010d	e8 00 00 00 00	 call	 PyErr_SetString
$Fail$21668:

; 1853 :     /* fall into failure code */
; 1854 : Fail:
; 1855 :     n = -1;

  00112	48 83 cb ff	 or	 rbx, -1
$Done$21684:

; 1856 :     /* fall through */
; 1857 : Done:
; 1858 :     Py_DECREF(it);

  00116	49 8b cd	 mov	 rcx, r13
  00119	e8 00 00 00 00	 call	 _Py_DecRef
  0011e	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00123	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00128	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0012d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00132	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]

; 1859 :     return n;

  00137	48 8b c3	 mov	 rax, rbx

; 1860 : 
; 1861 : }

  0013a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013e	41 5e		 pop	 r14
  00140	5f		 pop	 rdi
  00141	5b		 pop	 rbx
  00142	c3		 ret	 0
$LN9@PySequence@16:

; 1815 :             case PY_ITERSEARCH_COUNT:
; 1816 :                 if (n == PY_SSIZE_T_MAX) {

  00143	49 3b df	 cmp	 rbx, r15
  00146	75 95		 jne	 SHORT $LN28@PySequence@16

; 1817 :                     PyErr_SetString(PyExc_OverflowError,
; 1818 :                            "count exceeds C integer size");

  00148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@
  00156	eb b5		 jmp	 SHORT $LN29@PySequence@16
$LN5@PySequence@16:

; 1829 :                 }
; 1830 :                 goto Done;
; 1831 : 
; 1832 :             case PY_ITERSEARCH_CONTAINS:
; 1833 :                 n = 1;

  00158	bb 01 00 00 00	 mov	 ebx, 1

; 1834 :                 goto Done;

  0015d	eb b7		 jmp	 SHORT $Done$21684
$LN7@PySequence@16:

; 1819 :                     goto Fail;
; 1820 :                 }
; 1821 :                 ++n;
; 1822 :                 break;
; 1823 : 
; 1824 :             case PY_ITERSEARCH_INDEX:
; 1825 :                 if (wrapped) {

  0015f	85 ed		 test	 ebp, ebp
  00161	74 b3		 je	 SHORT $Done$21684

; 1826 :                     PyErr_SetString(PyExc_OverflowError,
; 1827 :                            "index exceeds C integer size");

  00163	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@

; 1828 :                     goto Fail;

  00171	eb 9a		 jmp	 SHORT $LN29@PySequence@16
$LN19@PySequence@16:

; 1789 :         null_error();

  00173	e8 00 00 00 00	 call	 null_error

; 1790 :         return -1;

  00178	48 83 c8 ff	 or	 rax, -1

; 1860 : 
; 1861 : }

  0017c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00180	41 5e		 pop	 r14
  00182	5f		 pop	 rdi
  00183	5b		 pop	 rbx
  00184	c3		 ret	 0
_PySequence_IterSearch ENDP
_TEXT	ENDS
PUBLIC	PySequence_Count
; Function compile flags: /Ogtpy
;	COMDAT PySequence_Count
_TEXT	SEGMENT
s$ = 8
o$ = 16
PySequence_Count PROC					; COMDAT

; 1867 :     return _PySequence_IterSearch(s, o, PY_ITERSEARCH_COUNT);

  00000	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1868 : }

  00006	e9 00 00 00 00	 jmp	 _PySequence_IterSearch
PySequence_Count ENDP
_TEXT	ENDS
PUBLIC	PySequence_Contains
; Function compile flags: /Ogtpy
;	COMDAT PySequence_Contains
_TEXT	SEGMENT
seq$ = 8
ob$ = 16
PySequence_Contains PROC				; COMDAT

; 1876 :     Py_ssize_t result;
; 1877 :     PySequenceMethods *sqm = seq->ob_type->tp_as_sequence;

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]

; 1878 : 
; 1879 :     if (sqm != NULL && sqm->sq_contains != NULL)

  0000b	48 85 c0	 test	 rax, rax
  0000e	74 0c		 je	 SHORT $LN1@PySequence@17
  00010	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00014	48 85 c0	 test	 rax, rax
  00017	74 03		 je	 SHORT $LN1@PySequence@17

; 1882 :     return Py_SAFE_DOWNCAST(result, Py_ssize_t, int);
; 1883 : }

  00019	48 ff e0	 rex_jmp rax
$LN1@PySequence@17:

; 1880 :         return (*sqm->sq_contains)(seq, ob);
; 1881 :     result = _PySequence_IterSearch(seq, ob, PY_ITERSEARCH_CONTAINS);

  0001c	41 b8 03 00 00
	00		 mov	 r8d, 3

; 1882 :     return Py_SAFE_DOWNCAST(result, Py_ssize_t, int);
; 1883 : }

  00022	e9 00 00 00 00	 jmp	 _PySequence_IterSearch
PySequence_Contains ENDP
_TEXT	ENDS
PUBLIC	PySequence_In
; Function compile flags: /Ogtpy
;	COMDAT PySequence_In
_TEXT	SEGMENT
w$ = 8
v$ = 16
PySequence_In PROC					; COMDAT

; 1890 :     return PySequence_Contains(w, v);
; 1891 : }

  00000	e9 00 00 00 00	 jmp	 PySequence_Contains
PySequence_In ENDP
_TEXT	ENDS
PUBLIC	PySequence_Index
; Function compile flags: /Ogtpy
;	COMDAT PySequence_Index
_TEXT	SEGMENT
s$ = 8
o$ = 16
PySequence_Index PROC					; COMDAT

; 1896 :     return _PySequence_IterSearch(s, o, PY_ITERSEARCH_INDEX);

  00000	41 b8 02 00 00
	00		 mov	 r8d, 2

; 1897 : }

  00006	e9 00 00 00 00	 jmp	 _PySequence_IterSearch
PySequence_Index ENDP
_TEXT	ENDS
PUBLIC	PyMapping_GetItemString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_GetItemString DD imagerel $LN6
	DD	imagerel $LN6+27
	DD	imagerel $unwind$PyMapping_GetItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMapping_GetItemString DD imagerel $LN6+27
	DD	imagerel $LN6+56
	DD	imagerel $chain$0$PyMapping_GetItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyMapping_GetItemString DD imagerel $LN6+56
	DD	imagerel $LN6+92
	DD	imagerel $chain$2$PyMapping_GetItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyMapping_GetItemString DD 020021H
	DD	067400H
	DD	imagerel $LN6
	DD	imagerel $LN6+27
	DD	imagerel $unwind$PyMapping_GetItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMapping_GetItemString DD 020521H
	DD	067405H
	DD	imagerel $LN6
	DD	imagerel $LN6+27
	DD	imagerel $unwind$PyMapping_GetItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_GetItemString DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMapping_GetItemString
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyMapping_GetItemString PROC				; COMDAT

; 1936 : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1937 :     PyObject *okey, *r;
; 1938 : 
; 1939 :     if (key == NULL)

  00009	48 85 d2	 test	 rdx, rdx
  0000c	75 0a		 jne	 SHORT $LN2@PyMapping_@3

; 1948 : }

  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5b		 pop	 rbx
  00013	e9 00 00 00 00	 jmp	 null_error
$LN2@PyMapping_@3:

; 1940 :         return null_error();
; 1941 : 
; 1942 :     okey = PyUnicode_FromString(key);

  00018	48 8b ca	 mov	 rcx, rdx
  0001b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00020	e8 00 00 00 00	 call	 PyUnicode_FromString
  00025	48 8b f8	 mov	 rdi, rax

; 1943 :     if (okey == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0b		 jne	 SHORT $LN1@PyMapping_@3
  0002d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1948 : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
$LN1@PyMapping_@3:

; 1944 :         return NULL;
; 1945 :     r = PyObject_GetItem(o, okey);

  00038	48 8b d0	 mov	 rdx, rax
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 PyObject_GetItem

; 1946 :     Py_DECREF(okey);

  00043	48 8b cf	 mov	 rcx, rdi
  00046	48 8b d8	 mov	 rbx, rax
  00049	e8 00 00 00 00	 call	 _Py_DecRef
  0004e	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1947 :     return r;

  00053	48 8b c3	 mov	 rax, rbx

; 1948 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
PyMapping_GetItemString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_SetItemString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_SetItemString DD imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$PyMapping_SetItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMapping_SetItemString DD imagerel $LN6+43
	DD	imagerel $LN6+80
	DD	imagerel $chain$0$PyMapping_SetItemString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyMapping_SetItemString DD imagerel $LN6+80
	DD	imagerel $LN6+122
	DD	imagerel $chain$2$PyMapping_SetItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyMapping_SetItemString DD 020021H
	DD	067400H
	DD	imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$PyMapping_SetItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMapping_SetItemString DD 020521H
	DD	067405H
	DD	imagerel $LN6
	DD	imagerel $LN6+43
	DD	imagerel $unwind$PyMapping_SetItemString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_SetItemString DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMapping_SetItemString
_TEXT	SEGMENT
o$ = 48
key$ = 56
value$ = 64
PyMapping_SetItemString PROC				; COMDAT

; 1952 : {

$LN6:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8
  0000d	48 8b f1	 mov	 rsi, rcx

; 1953 :     PyObject *okey;
; 1954 :     int r;
; 1955 : 
; 1956 :     if (key == NULL) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 13		 jne	 SHORT $LN2@PyMapping_@4

; 1957 :         null_error();

  00015	e8 00 00 00 00	 call	 null_error

; 1958 :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1973 : }

  0001d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5e		 pop	 rsi
  00027	c3		 ret	 0
$LN2@PyMapping_@4:

; 1959 :     }
; 1960 : 
; 1961 :     okey = PyUnicode_FromString(key);

  00028	48 8b ca	 mov	 rcx, rdx
  0002b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00030	e8 00 00 00 00	 call	 PyUnicode_FromString
  00035	48 8b f8	 mov	 rdi, rax

; 1962 :     if (okey == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	75 13		 jne	 SHORT $LN1@PyMapping_@4

; 1963 :         return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1973 : }

  00045	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN1@PyMapping_@4:

; 1964 : 
; 1965 :     /*
; 1966 :     if (Px_CHECK_PROTECTION(o, okey, value))
; 1967 :         return -1;
; 1968 :     */
; 1969 : 
; 1970 :     r = PyObject_SetItem(o, okey, value);

  00050	4c 8b c3	 mov	 r8, rbx
  00053	48 8b d0	 mov	 rdx, rax
  00056	48 8b ce	 mov	 rcx, rsi
  00059	e8 00 00 00 00	 call	 PyObject_SetItem

; 1971 :     Py_DECREF(okey);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	8b d8		 mov	 ebx, eax
  00063	e8 00 00 00 00	 call	 _Py_DecRef
  00068	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1972 :     return r;

  0006d	8b c3		 mov	 eax, ebx

; 1973 : }

  0006f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5e		 pop	 rsi
  00079	c3		 ret	 0
PyMapping_SetItemString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_HasKeyString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_HasKeyString DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$PyMapping_HasKeyString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_HasKeyString DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMapping_HasKeyString
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyMapping_HasKeyString PROC				; COMDAT

; 1977 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1978 :     PyObject *v;
; 1979 : 
; 1980 :     v = PyMapping_GetItemString(o, key);

  00004	e8 00 00 00 00	 call	 PyMapping_GetItemString

; 1981 :     if (v) {

  00009	48 85 c0	 test	 rax, rax
  0000c	74 12		 je	 SHORT $LN1@PyMapping_@5

; 1982 :         Py_DECREF(v);

  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 _Py_DecRef

; 1983 :         return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 1987 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN1@PyMapping_@5:

; 1984 :     }
; 1985 :     PyErr_Clear();

  00020	e8 00 00 00 00	 call	 PyErr_Clear

; 1986 :     return 0;

  00025	33 c0		 xor	 eax, eax

; 1987 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
PyMapping_HasKeyString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_HasKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_HasKey DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$PyMapping_HasKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_HasKey DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMapping_HasKey
_TEXT	SEGMENT
o$ = 48
key$ = 56
PyMapping_HasKey PROC					; COMDAT

; 1991 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1992 :     PyObject *v;
; 1993 : 
; 1994 :     v = PyObject_GetItem(o, key);

  00004	e8 00 00 00 00	 call	 PyObject_GetItem

; 1995 :     if (v) {

  00009	48 85 c0	 test	 rax, rax
  0000c	74 12		 je	 SHORT $LN1@PyMapping_@6

; 1996 :         Py_DECREF(v);

  0000e	48 8b c8	 mov	 rcx, rax
  00011	e8 00 00 00 00	 call	 _Py_DecRef

; 1997 :         return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 2001 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN1@PyMapping_@6:

; 1998 :     }
; 1999 :     PyErr_Clear();

  00020	e8 00 00 00 00	 call	 PyErr_Clear

; 2000 :     return 0;

  00025	33 c0		 xor	 eax, eax

; 2001 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
PyMapping_HasKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	PyMapping_Keys
EXTRN	PyDict_Keys:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Keys DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Keys
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMapping_Keys DD imagerel $LN7+51
	DD	imagerel $LN7+79
	DD	imagerel $chain$0$PyMapping_Keys
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyMapping_Keys DD imagerel $LN7+79
	DD	imagerel $LN7+128
	DD	imagerel $chain$3$PyMapping_Keys
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyMapping_Keys DD imagerel $LN7+128
	DD	imagerel $LN7+137
	DD	imagerel $chain$4$PyMapping_Keys
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyMapping_Keys DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Keys
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyMapping_Keys DD 040f21H
	DD	06340fH
	DD	047400H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Keys
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMapping_Keys DD 020521H
	DD	047405H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Keys
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Keys DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.keys() a'
	DB	're not iterable', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMapping_Keys
_TEXT	SEGMENT
o$ = 48
PyMapping_Keys PROC					; COMDAT

; 2005 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2006 :     PyObject *keys;
; 2007 :     PyObject *fast;
; 2008 :     _Py_IDENTIFIER(keys);
; 2009 : 
; 2010 :     if (PyDict_CheckExact(o))

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0000b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000f	74 6f		 je	 SHORT $LN2@PyMapping_@7
  00011	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00015	74 69		 je	 SHORT $LN2@PyMapping_@7

; 2011 :         return PyDict_Keys(o);
; 2012 :     keys = _PyObject_CallMethodId(o, &PyId_keys, NULL);

  00017	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00027	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_keys@?1??PyMapping_Keys@@9@9
  0002c	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00030	45 33 c0	 xor	 r8d, r8d
  00033	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00038	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0003d	48 8b f8	 mov	 rdi, rax

; 2013 :     if (keys == NULL)

  00040	48 85 c0	 test	 rax, rax
  00043	75 0a		 jne	 SHORT $LN1@PyMapping_@7
  00045	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2018 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN1@PyMapping_@7:

; 2014 :         return NULL;
; 2015 :     fast = PySequence_Fast(keys, "o.keys() are not iterable");

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005e	e8 00 00 00 00	 call	 PySequence_Fast

; 2016 :     Py_DECREF(keys);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	48 8b d8	 mov	 rbx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef
  0006e	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2017 :     return fast;

  00073	48 8b c3	 mov	 rax, rbx
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2018 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
$LN2@PyMapping_@7:
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	e9 00 00 00 00	 jmp	 PyDict_Keys
PyMapping_Keys ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	PyMapping_Items
EXTRN	PyDict_Items:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Items DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Items
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMapping_Items DD imagerel $LN7+51
	DD	imagerel $LN7+79
	DD	imagerel $chain$0$PyMapping_Items
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyMapping_Items DD imagerel $LN7+79
	DD	imagerel $LN7+128
	DD	imagerel $chain$3$PyMapping_Items
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyMapping_Items DD imagerel $LN7+128
	DD	imagerel $LN7+137
	DD	imagerel $chain$4$PyMapping_Items
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyMapping_Items DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Items
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyMapping_Items DD 040f21H
	DD	06340fH
	DD	047400H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Items
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMapping_Items DD 020521H
	DD	047405H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Items
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Items DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.items('
	DB	') are not iterable', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMapping_Items
_TEXT	SEGMENT
o$ = 48
PyMapping_Items PROC					; COMDAT

; 2022 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2023 :     PyObject *items;
; 2024 :     PyObject *fast;
; 2025 :     _Py_IDENTIFIER(items);
; 2026 : 
; 2027 :     if (PyDict_CheckExact(o))

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0000b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000f	74 6f		 je	 SHORT $LN2@PyMapping_@8
  00011	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00015	74 69		 je	 SHORT $LN2@PyMapping_@8

; 2028 :         return PyDict_Items(o);
; 2029 :     items = _PyObject_CallMethodId(o, &PyId_items, NULL);

  00017	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00027	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_items@?1??PyMapping_Items@@9@9
  0002c	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00030	45 33 c0	 xor	 r8d, r8d
  00033	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00038	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0003d	48 8b f8	 mov	 rdi, rax

; 2030 :     if (items == NULL)

  00040	48 85 c0	 test	 rax, rax
  00043	75 0a		 jne	 SHORT $LN1@PyMapping_@8
  00045	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2035 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN1@PyMapping_@8:

; 2031 :         return NULL;
; 2032 :     fast = PySequence_Fast(items, "o.items() are not iterable");

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005e	e8 00 00 00 00	 call	 PySequence_Fast

; 2033 :     Py_DECREF(items);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	48 8b d8	 mov	 rbx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef
  0006e	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2034 :     return fast;

  00073	48 8b c3	 mov	 rax, rbx
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2035 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
$LN2@PyMapping_@8:
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	e9 00 00 00 00	 jmp	 PyDict_Items
PyMapping_Items ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	PyMapping_Values
EXTRN	PyDict_Values:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Values DD imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMapping_Values DD imagerel $LN7+51
	DD	imagerel $LN7+79
	DD	imagerel $chain$0$PyMapping_Values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyMapping_Values DD imagerel $LN7+79
	DD	imagerel $LN7+128
	DD	imagerel $chain$3$PyMapping_Values
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyMapping_Values DD imagerel $LN7+128
	DD	imagerel $LN7+137
	DD	imagerel $chain$4$PyMapping_Values
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyMapping_Values DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyMapping_Values DD 040f21H
	DD	06340fH
	DD	047400H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMapping_Values DD 020521H
	DD	047405H
	DD	imagerel $LN7
	DD	imagerel $LN7+51
	DD	imagerel $unwind$PyMapping_Values
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Values DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.value'
	DB	's() are not iterable', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMapping_Values
_TEXT	SEGMENT
o$ = 48
PyMapping_Values PROC					; COMDAT

; 2039 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2040 :     PyObject *values;
; 2041 :     PyObject *fast;
; 2042 :     _Py_IDENTIFIER(values);
; 2043 : 
; 2044 :     if (PyDict_CheckExact(o))

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0000b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000f	74 6f		 je	 SHORT $LN2@PyMapping_@9
  00011	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00015	74 69		 je	 SHORT $LN2@PyMapping_@9

; 2045 :         return PyDict_Values(o);
; 2046 :     values = _PyObject_CallMethodId(o, &PyId_values, NULL);

  00017	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0001e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00027	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_values@?1??PyMapping_Values@@9@9
  0002c	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00030	45 33 c0	 xor	 r8d, r8d
  00033	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00038	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0003d	48 8b f8	 mov	 rdi, rax

; 2047 :     if (values == NULL)

  00040	48 85 c0	 test	 rax, rax
  00043	75 0a		 jne	 SHORT $LN1@PyMapping_@9
  00045	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2052 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
$LN1@PyMapping_@9:

; 2048 :         return NULL;
; 2049 :     fast = PySequence_Fast(values, "o.values() are not iterable");

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005e	e8 00 00 00 00	 call	 PySequence_Fast

; 2050 :     Py_DECREF(values);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	48 8b d8	 mov	 rbx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef
  0006e	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 2051 :     return fast;

  00073	48 8b c3	 mov	 rax, rbx
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2052 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
$LN2@PyMapping_@9:
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	e9 00 00 00 00	 jmp	 PyDict_Values
PyMapping_Values ENDP
_TEXT	ENDS
PUBLIC	_PySequence_BytesToCharpArray
EXTRN	__imp_strdup:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PySequence_BytesToCharpArray DD imagerel $LN36
	DD	imagerel $LN36+70
	DD	imagerel $unwind$_PySequence_BytesToCharpArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PySequence_BytesToCharpArray DD imagerel $LN36+70
	DD	imagerel $LN36+113
	DD	imagerel $chain$0$_PySequence_BytesToCharpArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PySequence_BytesToCharpArray DD imagerel $LN36+113
	DD	imagerel $LN36+240
	DD	imagerel $chain$4$_PySequence_BytesToCharpArray
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PySequence_BytesToCharpArray DD imagerel $LN36+240
	DD	imagerel $LN36+426
	DD	imagerel $chain$6$_PySequence_BytesToCharpArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PySequence_BytesToCharpArray DD 060021H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN36
	DD	imagerel $LN36+70
	DD	imagerel $unwind$_PySequence_BytesToCharpArray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PySequence_BytesToCharpArray DD 060a21H
	DD	0a740aH
	DD	083405H
	DD	095400H
	DD	imagerel $LN36
	DD	imagerel $LN36+70
	DD	imagerel $unwind$_PySequence_BytesToCharpArray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PySequence_BytesToCharpArray DD 020521H
	DD	095405H
	DD	imagerel $LN36
	DD	imagerel $LN36+70
	DD	imagerel $unwind$_PySequence_BytesToCharpArray
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySequence_BytesToCharpArray DD 040b01H
	DD	0b640bH
	DD	0c007520bH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\abstract.c
xdata	ENDS
;	COMDAT _PySequence_BytesToCharpArray
_TEXT	SEGMENT
self$ = 64
_PySequence_BytesToCharpArray PROC			; COMDAT

; 2696 : {

$LN36:
  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	41 54		 push	 r12
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000b	4c 8b e1	 mov	 r12, rcx

; 2697 :     char **array;
; 2698 :     Py_ssize_t i, argc;
; 2699 :     PyObject *item = NULL;
; 2700 : 
; 2701 :     argc = PySequence_Size(self);

  0000e	e8 00 00 00 00	 call	 PySequence_Size
  00013	48 8b f0	 mov	 rsi, rax

; 2702 :     if (argc == -1)

  00016	48 83 f8 ff	 cmp	 rax, -1

; 2703 :         return NULL;

  0001a	74 14		 je	 SHORT $LN35@PySequence@18

; 2704 : 
; 2705 :     assert(argc >= 0);
; 2706 : 
; 2707 :     if ((size_t)argc > (PY_SSIZE_T_MAX-sizeof(char *)) / sizeof(char *)) {

  0001c	48 b8 fe ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846974 ; 0ffffffffffffffeH
  00026	48 3b f0	 cmp	 rsi, rax
  00029	76 13		 jbe	 SHORT $LN12@PySequence@18

; 2708 :         PyErr_NoMemory();

  0002b	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN35@PySequence@18:

; 2709 :         return NULL;

  00030	33 c0		 xor	 eax, eax

; 2746 : }

  00032	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00037	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003b	41 5c		 pop	 r12
  0003d	c3		 ret	 0
$LN12@PySequence@18:

; 2710 :     }
; 2711 : 
; 2712 :     array = malloc((argc + 1) * sizeof(char *));

  0003e	48 8d 0c f5 08
	00 00 00	 lea	 rcx, QWORD PTR [rsi*8+8]
  00046	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00051	48 8b e8	 mov	 rbp, rax

; 2713 :     if (array == NULL) {

  00054	48 85 c0	 test	 rax, rax
  00057	75 18		 jne	 SHORT $LN11@PySequence@18

; 2714 :         PyErr_NoMemory();

  00059	e8 00 00 00 00	 call	 PyErr_NoMemory
  0005e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 2715 :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 2746 : }

  00065	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0006a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006e	41 5c		 pop	 r12
  00070	c3		 ret	 0
$LN11@PySequence@18:
  00071	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00076	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 2716 :     }
; 2717 :     for (i = 0; i < argc; ++i) {

  0007b	33 ff		 xor	 edi, edi
  0007d	48 85 f6	 test	 rsi, rsi
  00080	7e 47		 jle	 SHORT $LN8@PySequence@18
$LL10@PySequence@18:

; 2718 :         char *data;
; 2719 :         item = PySequence_GetItem(self, i);

  00082	48 8b d7	 mov	 rdx, rdi
  00085	49 8b cc	 mov	 rcx, r12
  00088	e8 00 00 00 00	 call	 PySequence_GetItem
  0008d	48 8b d8	 mov	 rbx, rax

; 2720 :         if (item == NULL) {

  00090	48 85 c0	 test	 rax, rax
  00093	0f 84 f9 00 00
	00		 je	 $LN28@PySequence@18

; 2723 :             goto fail;
; 2724 :         }
; 2725 :         data = PyBytes_AsString(item);

  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 PyBytes_AsString

; 2726 :         if (data == NULL) {

  000a1	48 85 c0	 test	 rax, rax
  000a4	74 51		 je	 SHORT $LN29@PySequence@18

; 2729 :             goto fail;
; 2730 :         }
; 2731 :         array[i] = strdup(data);

  000a6	48 8b c8	 mov	 rcx, rax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000af	48 89 44 fd 00	 mov	 QWORD PTR [rbp+rdi*8], rax

; 2732 :         if (!array[i]) {

  000b4	48 85 c0	 test	 rax, rax
  000b7	74 37		 je	 SHORT $LN30@PySequence@18

; 2734 :             goto fail;
; 2735 :         }
; 2736 :         Py_DECREF(item);

  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 _Py_DecRef
  000c1	48 ff c7	 inc	 rdi
  000c4	48 3b fe	 cmp	 rdi, rsi
  000c7	7c b9		 jl	 SHORT $LL10@PySequence@18
$LN8@PySequence@18:

; 2737 :     }
; 2738 :     array[argc] = NULL;

  000c9	48 c7 44 f5 00
	00 00 00 00	 mov	 QWORD PTR [rbp+rsi*8], 0

; 2739 : 
; 2740 :     return array;

  000d2	48 8b c5	 mov	 rax, rbp
$LN34@PySequence@18:

; 2746 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000df	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e4	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000e9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ed	41 5c		 pop	 r12
  000ef	c3		 ret	 0
$LN30@PySequence@18:

; 2733 :             PyErr_NoMemory();

  000f0	e8 00 00 00 00	 call	 PyErr_NoMemory
  000f5	eb 09		 jmp	 SHORT $fail$22404
$LN29@PySequence@18:

; 2727 :             /* NULL terminate before freeing. */
; 2728 :             array[i] = NULL;

  000f7	48 c7 44 fd 00
	00 00 00 00	 mov	 QWORD PTR [rbp+rdi*8], 0
$fail$22404:

; 2741 : 
; 2742 : fail:
; 2743 :     Py_XDECREF(item);

  00100	e8 00 00 00 00	 call	 _Py_PXCTX
  00105	85 c0		 test	 eax, eax
  00107	0f 85 8e 00 00
	00		 jne	 $LN3@PySequence@18
  0010d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00111	a8 20		 test	 al, 32			; 00000020H
  00113	75 66		 jne	 SHORT $LN20@PySequence@18
  00115	84 c0		 test	 al, al
  00117	78 62		 js	 SHORT $LN20@PySequence@18
  00119	a8 02		 test	 al, 2
  0011b	75 7e		 jne	 SHORT $LN3@PySequence@18
  0011d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00121	75 78		 jne	 SHORT $LN3@PySequence@18
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00131	4c 8b cb	 mov	 r9, rbx
  00134	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0013a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00142	e8 00 00 00 00	 call	 _PyParallel_Guard
  00147	48 8b cb	 mov	 rcx, rbx
  0014a	85 c0		 test	 eax, eax
  0014c	74 14		 je	 SHORT $LN25@PySequence@18
  0014e	e8 00 00 00 00	 call	 _Px_Dealloc

; 2744 :     _Py_FreeCharPArray(array);

  00153	48 8b cd	 mov	 rcx, rbp
  00156	e8 00 00 00 00	 call	 _Py_FreeCharPArray

; 2745 :     return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	e9 73 ff ff ff	 jmp	 $LN34@PySequence@18

; 2741 : 
; 2742 : fail:
; 2743 :     Py_XDECREF(item);

$LN25@PySequence@18:
  00162	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00166	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 2744 :     _Py_FreeCharPArray(array);

  0016c	48 8b cd	 mov	 rcx, rbp
  0016f	e8 00 00 00 00	 call	 _Py_FreeCharPArray

; 2745 :     return NULL;

  00174	33 c0		 xor	 eax, eax
  00176	e9 5a ff ff ff	 jmp	 $LN34@PySequence@18

; 2741 : 
; 2742 : fail:
; 2743 :     Py_XDECREF(item);

$LN20@PySequence@18:
  0017b	48 8b cb	 mov	 rcx, rbx
  0017e	e8 00 00 00 00	 call	 Px_DecRef

; 2744 :     _Py_FreeCharPArray(array);

  00183	48 8b cd	 mov	 rcx, rbp
  00186	e8 00 00 00 00	 call	 _Py_FreeCharPArray

; 2745 :     return NULL;

  0018b	33 c0		 xor	 eax, eax
  0018d	e9 43 ff ff ff	 jmp	 $LN34@PySequence@18
$LN28@PySequence@18:

; 2721 :             /* NULL terminate before freeing. */
; 2722 :             array[i] = NULL;

  00192	48 c7 44 fd 00
	00 00 00 00	 mov	 QWORD PTR [rbp+rdi*8], 0
$LN3@PySequence@18:

; 2744 :     _Py_FreeCharPArray(array);

  0019b	48 8b cd	 mov	 rcx, rbp
  0019e	e8 00 00 00 00	 call	 _Py_FreeCharPArray

; 2745 :     return NULL;

  001a3	33 c0		 xor	 eax, eax
  001a5	e9 2b ff ff ff	 jmp	 $LN34@PySequence@18
_PySequence_BytesToCharpArray ENDP
_TEXT	ENDS
END
