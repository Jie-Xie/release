; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04CFDJAKFL@math?$AA@			; `string'
PUBLIC	??_C@_05NOECMME@trunc?$AA@			; `string'
PUBLIC	??_C@_04FJHINJAO@tanh?$AA@			; `string'
PUBLIC	??_C@_03IIINPABG@tan?$AA@			; `string'
PUBLIC	??_C@_04EIAKFFMI@sqrt?$AA@			; `string'
PUBLIC	??_C@_04COOMCNPB@sinh?$AA@			; `string'
PUBLIC	??_C@_03BLEJJJBH@sin?$AA@			; `string'
PUBLIC	??_C@_07JLOPPFCD@radians?$AA@			; `string'
PUBLIC	??_C@_03JGHBODFD@pow?$AA@			; `string'
PUBLIC	??_C@_04EHEDPDJG@modf?$AA@			; `string'
PUBLIC	??_C@_04KGLCPMCP@log2?$AA@			; `string'
PUBLIC	??_C@_05HGHHAHAP@log10?$AA@			; `string'
PUBLIC	??_C@_05IGAOEIAK@log1p?$AA@			; `string'
PUBLIC	??_C@_03MGHMBJCF@log?$AA@			; `string'
PUBLIC	??_C@_06GKIDEKEE@lgamma?$AA@			; `string'
PUBLIC	??_C@_05CEJMAHNP@ldexp?$AA@			; `string'
PUBLIC	??_C@_05LGCGPNNP@isnan?$AA@			; `string'
PUBLIC	??_C@_05OIHEAIFD@isinf?$AA@			; `string'
PUBLIC	??_C@_08CHCKEDFL@isfinite?$AA@			; `string'
PUBLIC	??_C@_05DNLPMBKG@hypot?$AA@			; `string'
PUBLIC	??_C@_05KDLBCAI@gamma?$AA@			; `string'
PUBLIC	??_C@_04NEEMDKCM@fsum?$AA@			; `string'
PUBLIC	??_C@_05GKKHEGJL@frexp?$AA@			; `string'
PUBLIC	??_C@_04KEPJIHGP@fmod?$AA@			; `string'
PUBLIC	??_C@_05PBJFFIGL@floor?$AA@			; `string'
PUBLIC	??_C@_09HBBEBGCM@factorial?$AA@			; `string'
PUBLIC	??_C@_04ODHECPBC@fabs?$AA@			; `string'
PUBLIC	??_C@_05DCMLJEOG@expm1?$AA@			; `string'
PUBLIC	??_C@_03KHJOGHMM@exp?$AA@			; `string'
PUBLIC	??_C@_04KLLDBHDO@erfc?$AA@			; `string'
PUBLIC	??_C@_03LGJBFHMN@erf?$AA@			; `string'
PUBLIC	??_C@_07MHOHEFBH@degrees?$AA@			; `string'
PUBLIC	??_C@_04HPJJNFIM@cosh?$AA@			; `string'
PUBLIC	??_C@_03LALBNOCG@cos?$AA@			; `string'
PUBLIC	??_C@_08PLCMNBBP@copysign?$AA@			; `string'
PUBLIC	??_C@_04GFPJNGEK@ceil?$AA@			; `string'
PUBLIC	??_C@_05ONDAFDEP@atanh?$AA@			; `string'
PUBLIC	??_C@_05KNGEOGJB@atan2?$AA@			; `string'
PUBLIC	??_C@_04MLLJIGOK@atan?$AA@			; `string'
PUBLIC	??_C@_05JKKEKHLA@asinh?$AA@			; `string'
PUBLIC	??_C@_04FIHNOPOL@asin?$AA@			; `string'
PUBLIC	??_C@_05MLNBFPMN@acosh?$AA@			; `string'
PUBLIC	??_C@_04PDIFKINK@acos?$AA@			; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_09NKCGFGFE@__floor__?$AA@			; `string'
PUBLIC	??_C@_08GFGNDJJM@__ceil__?$AA@			; `string'
;	COMDAT ??_C@_04CFDJAKFL@math?$AA@
CONST	SEGMENT
??_C@_04CFDJAKFL@math?$AA@ DB 'math', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NOECMME@trunc?$AA@
CONST	SEGMENT
??_C@_05NOECMME@trunc?$AA@ DB 'trunc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJHINJAO@tanh?$AA@
CONST	SEGMENT
??_C@_04FJHINJAO@tanh?$AA@ DB 'tanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IIINPABG@tan?$AA@
CONST	SEGMENT
??_C@_03IIINPABG@tan?$AA@ DB 'tan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIAKFFMI@sqrt?$AA@
CONST	SEGMENT
??_C@_04EIAKFFMI@sqrt?$AA@ DB 'sqrt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COOMCNPB@sinh?$AA@
CONST	SEGMENT
??_C@_04COOMCNPB@sinh?$AA@ DB 'sinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLEJJJBH@sin?$AA@
CONST	SEGMENT
??_C@_03BLEJJJBH@sin?$AA@ DB 'sin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLOPPFCD@radians?$AA@
CONST	SEGMENT
??_C@_07JLOPPFCD@radians?$AA@ DB 'radians', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGHBODFD@pow?$AA@
CONST	SEGMENT
??_C@_03JGHBODFD@pow?$AA@ DB 'pow', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHEDPDJG@modf?$AA@
CONST	SEGMENT
??_C@_04EHEDPDJG@modf?$AA@ DB 'modf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KGLCPMCP@log2?$AA@
CONST	SEGMENT
??_C@_04KGLCPMCP@log2?$AA@ DB 'log2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGHHAHAP@log10?$AA@
CONST	SEGMENT
??_C@_05HGHHAHAP@log10?$AA@ DB 'log10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGAOEIAK@log1p?$AA@
CONST	SEGMENT
??_C@_05IGAOEIAK@log1p?$AA@ DB 'log1p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log?$AA@
CONST	SEGMENT
??_C@_03MGHMBJCF@log?$AA@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKIDEKEE@lgamma?$AA@
CONST	SEGMENT
??_C@_06GKIDEKEE@lgamma?$AA@ DB 'lgamma', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CEJMAHNP@ldexp?$AA@
CONST	SEGMENT
??_C@_05CEJMAHNP@ldexp?$AA@ DB 'ldexp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGCGPNNP@isnan?$AA@
CONST	SEGMENT
??_C@_05LGCGPNNP@isnan?$AA@ DB 'isnan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OIHEAIFD@isinf?$AA@
CONST	SEGMENT
??_C@_05OIHEAIFD@isinf?$AA@ DB 'isinf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHCKEDFL@isfinite?$AA@
CONST	SEGMENT
??_C@_08CHCKEDFL@isfinite?$AA@ DB 'isfinite', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNLPMBKG@hypot?$AA@
CONST	SEGMENT
??_C@_05DNLPMBKG@hypot?$AA@ DB 'hypot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDLBCAI@gamma?$AA@
CONST	SEGMENT
??_C@_05KDLBCAI@gamma?$AA@ DB 'gamma', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEEMDKCM@fsum?$AA@
CONST	SEGMENT
??_C@_04NEEMDKCM@fsum?$AA@ DB 'fsum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKKHEGJL@frexp?$AA@
CONST	SEGMENT
??_C@_05GKKHEGJL@frexp?$AA@ DB 'frexp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEPJIHGP@fmod?$AA@
CONST	SEGMENT
??_C@_04KEPJIHGP@fmod?$AA@ DB 'fmod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBJFFIGL@floor?$AA@
CONST	SEGMENT
??_C@_05PBJFFIGL@floor?$AA@ DB 'floor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBBEBGCM@factorial?$AA@
CONST	SEGMENT
??_C@_09HBBEBGCM@factorial?$AA@ DB 'factorial', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODHECPBC@fabs?$AA@
CONST	SEGMENT
??_C@_04ODHECPBC@fabs?$AA@ DB 'fabs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DCMLJEOG@expm1?$AA@
CONST	SEGMENT
??_C@_05DCMLJEOG@expm1?$AA@ DB 'expm1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHJOGHMM@exp?$AA@
CONST	SEGMENT
??_C@_03KHJOGHMM@exp?$AA@ DB 'exp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLLDBHDO@erfc?$AA@
CONST	SEGMENT
??_C@_04KLLDBHDO@erfc?$AA@ DB 'erfc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGJBFHMN@erf?$AA@
CONST	SEGMENT
??_C@_03LGJBFHMN@erf?$AA@ DB 'erf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHOHEFBH@degrees?$AA@
CONST	SEGMENT
??_C@_07MHOHEFBH@degrees?$AA@ DB 'degrees', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPJJNFIM@cosh?$AA@
CONST	SEGMENT
??_C@_04HPJJNFIM@cosh?$AA@ DB 'cosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LALBNOCG@cos?$AA@
CONST	SEGMENT
??_C@_03LALBNOCG@cos?$AA@ DB 'cos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PLCMNBBP@copysign?$AA@
CONST	SEGMENT
??_C@_08PLCMNBBP@copysign?$AA@ DB 'copysign', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFPJNGEK@ceil?$AA@
CONST	SEGMENT
??_C@_04GFPJNGEK@ceil?$AA@ DB 'ceil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONDAFDEP@atanh?$AA@
CONST	SEGMENT
??_C@_05ONDAFDEP@atanh?$AA@ DB 'atanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNGEOGJB@atan2?$AA@
CONST	SEGMENT
??_C@_05KNGEOGJB@atan2?$AA@ DB 'atan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLJIGOK@atan?$AA@
CONST	SEGMENT
??_C@_04MLLJIGOK@atan?$AA@ DB 'atan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKKEKHLA@asinh?$AA@
CONST	SEGMENT
??_C@_05JKKEKHLA@asinh?$AA@ DB 'asinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIHNOPOL@asin?$AA@
CONST	SEGMENT
??_C@_04FIHNOPOL@asin?$AA@ DB 'asin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLNBFPMN@acosh?$AA@
CONST	SEGMENT
??_C@_05MLNBFPMN@acosh?$AA@ DB 'acosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDIFKINK@acos?$AA@
CONST	SEGMENT
??_C@_04PDIFKINK@acos?$AA@ DB 'acos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKCGFGFE@__floor__?$AA@
CONST	SEGMENT
??_C@_09NKCGFGFE@__floor__?$AA@ DB '__floor__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___trunc__@?1??math_trunc@@9@9 DQ 0000000000000000H ; `math_trunc'::`2'::PyId___trunc__
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	0000000000000000H
?PyId___floor__@?1??math_floor@@9@9 DQ 0000000000000000H ; `math_floor'::`2'::PyId___floor__
	DQ	FLAT:??_C@_09NKCGFGFE@__floor__?$AA@
	DQ	0000000000000000H
?PyId___ceil__@?1??math_ceil@@9@9 DQ 0000000000000000H	; `math_ceil'::`2'::PyId___ceil__
	DQ	FLAT:??_C@_08GFGNDJJM@__ceil__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08GFGNDJJM@__ceil__?$AA@
CONST	SEGMENT
??_C@_08GFGNDJJM@__ceil__?$AA@ DB '__ceil__', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
math_acos_doc DB 'acos(x)', 0aH, 0aH, 'Return the arc cosine (measured in'
	DB	' radians) of x.', 00H
	ORG $+5
math_acosh_doc DB 'acosh(x)', 0aH, 0aH, 'Return the hyperbolic arc cosine'
	DB	' (measured in radians) of x.', 00H
	ORG $+1
math_asin_doc DB 'asin(x)', 0aH, 0aH, 'Return the arc sine (measured in r'
	DB	'adians) of x.', 00H
	ORG $+15
math_asinh_doc DB 'asinh(x)', 0aH, 0aH, 'Return the hyperbolic arc sine ('
	DB	'measured in radians) of x.', 00H
	ORG $+3
math_atan_doc DB 'atan(x)', 0aH, 0aH, 'Return the arc tangent (measured i'
	DB	'n radians) of x.', 00H
	ORG $+12
math_atan2_doc DB 'atan2(y, x)', 0aH, 0aH, 'Return the arc tangent (measu'
	DB	'red in radians) of y/x.', 0aH, 'Unlike atan(y/x), the signs o'
	DB	'f both x and y are considered.', 00H
	ORG $+2
math_atanh_doc DB 'atanh(x)', 0aH, 0aH, 'Return the hyperbolic arc tangen'
	DB	't (measured in radians) of x.', 00H
	ORG $+8
math_ceil_doc DB 'ceil(x)', 0aH, 0aH, 'Return the ceiling of x as an int.'
	DB	0aH, 'This is the smallest integral value >= x.', 00H
	ORG $+10
math_copysign_doc DB 'copysign(x, y)', 0aH, 0aH, 'Return a float with the'
	DB	' magnitude (absolute value) of x but the sign ', 0aH, 'of y. '
	DB	'On platforms that support signed zeros, copysign(1.0, -0.0) ', 0aH
	DB	'returns -1.0.', 0aH, 00H
math_cos_doc DB	'cos(x)', 0aH, 0aH, 'Return the cosine of x (measured in '
	DB	'radians).', 00H
	ORG $+2
math_cosh_doc DB 'cosh(x)', 0aH, 0aH, 'Return the hyperbolic cosine of x.'
	DB	00H
	ORG $+4
math_erf_doc DB	'erf(x)', 0aH, 0aH, 'Error function at x.', 00H
	ORG $+3
math_erfc_doc DB 'erfc(x)', 0aH, 0aH, 'Complementary error function at x.'
	DB	00H
	ORG $+4
math_exp_doc DB	'exp(x)', 0aH, 0aH, 'Return e raised to the power of x.', 00H
	ORG $+5
math_expm1_doc DB 'expm1(x)', 0aH, 0aH, 'Return exp(x)-1.', 0aH, 'This fu'
	DB	'nction avoids the loss of precision involved in the direct ev'
	DB	'aluation of exp(x)-1 for small x.', 00H
	ORG $+7
math_fabs_doc DB 'fabs(x)', 0aH, 0aH, 'Return the absolute value of the f'
	DB	'loat x.', 00H
	ORG $+5
math_floor_doc DB 'floor(x)', 0aH, 0aH, 'Return the floor of x as an int.'
	DB	0aH, 'This is the largest integral value <= x.', 00H
	ORG $+4
math_gamma_doc DB 'gamma(x)', 0aH, 0aH, 'Gamma function at x.', 00H
	ORG $+9
math_lgamma_doc DB 'lgamma(x)', 0aH, 0aH, 'Natural logarithm of absolute '
	DB	'value of Gamma function at x.', 00H
	ORG $+9
math_log1p_doc DB 'log1p(x)', 0aH, 0aH, 'Return the natural logarithm of '
	DB	'1+x (base e).', 0aH, 'The result is computed in a way which i'
	DB	's accurate for x near zero.', 00H
	ORG $+5
math_sin_doc DB	'sin(x)', 0aH, 0aH, 'Return the sine of x (measured in ra'
	DB	'dians).', 00H
	ORG $+4
math_sinh_doc DB 'sinh(x)', 0aH, 0aH, 'Return the hyperbolic sine of x.', 00H
	ORG $+6
math_sqrt_doc DB 'sqrt(x)', 0aH, 0aH, 'Return the square root of x.', 00H
	ORG $+2
math_tan_doc DB	'tan(x)', 0aH, 0aH, 'Return the tangent of x (measured in'
	DB	' radians).', 00H
	ORG $+1
math_tanh_doc DB 'tanh(x)', 0aH, 0aH, 'Return the hyperbolic tangent of x'
	DB	'.', 00H
	ORG $+11
math_fsum_doc DB 'fsum(iterable)', 0aH, 0aH, 'Return an accurate floating'
	DB	' point sum of values in the iterable.', 0aH, 'Assumes IEEE-75'
	DB	'4 floating point arithmetic.', 00H
	ORG $+3
math_factorial_doc DB 'factorial(x) -> Integral', 0aH, 0aH, 'Find x!. Rai'
	DB	'se a ValueError if x is negative or non-integral.', 00H
	ORG $+8
math_trunc_doc DB 'trunc(x:Real) -> Integral', 0aH, 0aH, 'Truncates x to '
	DB	'the nearest Integral toward 0. Uses the __trunc__ magic metho'
	DB	'd.', 00H
	ORG $+6
math_frexp_doc DB 'frexp(x)', 0aH, 0aH, 'Return the mantissa and exponent'
	DB	' of x, as pair (m, e).', 0aH, 'm is a float and e is an int, '
	DB	'such that x = m * 2.**e.', 0aH, 'If x is 0, m and e are both '
	DB	'0.  Else 0.5 <= abs(m) < 1.0.', 00H
	ORG $+6
math_ldexp_doc DB 'ldexp(x, i)', 0aH, 0aH, 'Return x * (2**i).', 00H
	ORG $+8
math_modf_doc DB 'modf(x)', 0aH, 0aH, 'Return the fractional and integer '
	DB	'parts of x.  Both results carry the sign', 0aH, 'of x and are'
	DB	' floats.', 00H
	ORG $+7
math_log_doc DB	'log(x[, base])', 0aH, 0aH, 'Return the logarithm of x to'
	DB	' the given base.', 0aH, 'If the base not specified, returns t'
	DB	'he natural logarithm (base e) of x.', 00H
	ORG $+3
math_log2_doc DB 'log2(x)', 0aH, 0aH, 'Return the base 2 logarithm of x.', 00H
	ORG $+5
math_log10_doc DB 'log10(x)', 0aH, 0aH, 'Return the base 10 logarithm of '
	DB	'x.', 00H
	ORG $+11
math_fmod_doc DB 'fmod(x, y)', 0aH, 0aH, 'Return fmod(x, y), according to'
	DB	' platform C.  x % y may differ.', 00H
	ORG $+5
math_hypot_doc DB 'hypot(x, y)', 0aH, 0aH, 'Return the Euclidean distance'
	DB	', sqrt(x*x + y*y).', 00H
	ORG $+3
math_pow_doc DB	'pow(x, y)', 0aH, 0aH, 'Return x**y (x to the power of y)'
	DB	'.', 00H
	ORG $+2
math_degrees_doc DB 'degrees(x)', 0aH, 0aH, 'Convert angle x from radians'
	DB	' to degrees.', 00H
	ORG $+3
math_radians_doc DB 'radians(x)', 0aH, 0aH, 'Convert angle x from degrees'
	DB	' to radians.', 00H
	ORG $+3
math_isfinite_doc DB 'isfinite(x) -> bool', 0aH, 0aH, 'Return True if x i'
	DB	's neither an infinity nor a NaN, and False otherwise.', 00H
	ORG $+3
math_isnan_doc DB 'isnan(x) -> bool', 0aH, 0aH, 'Return True if x is a Na'
	DB	'N (not a number), and False otherwise.', 00H
	ORG $+15
math_isinf_doc DB 'isinf(x) -> bool', 0aH, 0aH, 'Return True if x is a po'
	DB	'sitive or negative infinity, and False otherwise.', 00H
	ORG $+4
math_methods DQ	FLAT:??_C@_04PDIFKINK@acos?$AA@
	DQ	FLAT:math_acos
	DD	08H
	ORG $+4
	DQ	FLAT:math_acos_doc
	DQ	FLAT:??_C@_05MLNBFPMN@acosh?$AA@
	DQ	FLAT:math_acosh
	DD	08H
	ORG $+4
	DQ	FLAT:math_acosh_doc
	DQ	FLAT:??_C@_04FIHNOPOL@asin?$AA@
	DQ	FLAT:math_asin
	DD	08H
	ORG $+4
	DQ	FLAT:math_asin_doc
	DQ	FLAT:??_C@_05JKKEKHLA@asinh?$AA@
	DQ	FLAT:math_asinh
	DD	08H
	ORG $+4
	DQ	FLAT:math_asinh_doc
	DQ	FLAT:??_C@_04MLLJIGOK@atan?$AA@
	DQ	FLAT:math_atan
	DD	08H
	ORG $+4
	DQ	FLAT:math_atan_doc
	DQ	FLAT:??_C@_05KNGEOGJB@atan2?$AA@
	DQ	FLAT:math_atan2
	DD	01H
	ORG $+4
	DQ	FLAT:math_atan2_doc
	DQ	FLAT:??_C@_05ONDAFDEP@atanh?$AA@
	DQ	FLAT:math_atanh
	DD	08H
	ORG $+4
	DQ	FLAT:math_atanh_doc
	DQ	FLAT:??_C@_04GFPJNGEK@ceil?$AA@
	DQ	FLAT:math_ceil
	DD	08H
	ORG $+4
	DQ	FLAT:math_ceil_doc
	DQ	FLAT:??_C@_08PLCMNBBP@copysign?$AA@
	DQ	FLAT:math_copysign
	DD	01H
	ORG $+4
	DQ	FLAT:math_copysign_doc
	DQ	FLAT:??_C@_03LALBNOCG@cos?$AA@
	DQ	FLAT:math_cos
	DD	08H
	ORG $+4
	DQ	FLAT:math_cos_doc
	DQ	FLAT:??_C@_04HPJJNFIM@cosh?$AA@
	DQ	FLAT:math_cosh
	DD	08H
	ORG $+4
	DQ	FLAT:math_cosh_doc
	DQ	FLAT:??_C@_07MHOHEFBH@degrees?$AA@
	DQ	FLAT:math_degrees
	DD	08H
	ORG $+4
	DQ	FLAT:math_degrees_doc
	DQ	FLAT:??_C@_03LGJBFHMN@erf?$AA@
	DQ	FLAT:math_erf
	DD	08H
	ORG $+4
	DQ	FLAT:math_erf_doc
	DQ	FLAT:??_C@_04KLLDBHDO@erfc?$AA@
	DQ	FLAT:math_erfc
	DD	08H
	ORG $+4
	DQ	FLAT:math_erfc_doc
	DQ	FLAT:??_C@_03KHJOGHMM@exp?$AA@
	DQ	FLAT:math_exp
	DD	08H
	ORG $+4
	DQ	FLAT:math_exp_doc
	DQ	FLAT:??_C@_05DCMLJEOG@expm1?$AA@
	DQ	FLAT:math_expm1
	DD	08H
	ORG $+4
	DQ	FLAT:math_expm1_doc
	DQ	FLAT:??_C@_04ODHECPBC@fabs?$AA@
	DQ	FLAT:math_fabs
	DD	08H
	ORG $+4
	DQ	FLAT:math_fabs_doc
	DQ	FLAT:??_C@_09HBBEBGCM@factorial?$AA@
	DQ	FLAT:math_factorial
	DD	08H
	ORG $+4
	DQ	FLAT:math_factorial_doc
	DQ	FLAT:??_C@_05PBJFFIGL@floor?$AA@
	DQ	FLAT:math_floor
	DD	08H
	ORG $+4
	DQ	FLAT:math_floor_doc
	DQ	FLAT:??_C@_04KEPJIHGP@fmod?$AA@
	DQ	FLAT:math_fmod
	DD	01H
	ORG $+4
	DQ	FLAT:math_fmod_doc
	DQ	FLAT:??_C@_05GKKHEGJL@frexp?$AA@
	DQ	FLAT:math_frexp
	DD	08H
	ORG $+4
	DQ	FLAT:math_frexp_doc
	DQ	FLAT:??_C@_04NEEMDKCM@fsum?$AA@
	DQ	FLAT:math_fsum
	DD	08H
	ORG $+4
	DQ	FLAT:math_fsum_doc
	DQ	FLAT:??_C@_05KDLBCAI@gamma?$AA@
	DQ	FLAT:math_gamma
	DD	08H
	ORG $+4
	DQ	FLAT:math_gamma_doc
	DQ	FLAT:??_C@_05DNLPMBKG@hypot?$AA@
	DQ	FLAT:math_hypot
	DD	01H
	ORG $+4
	DQ	FLAT:math_hypot_doc
	DQ	FLAT:??_C@_08CHCKEDFL@isfinite?$AA@
	DQ	FLAT:math_isfinite
	DD	08H
	ORG $+4
	DQ	FLAT:math_isfinite_doc
	DQ	FLAT:??_C@_05OIHEAIFD@isinf?$AA@
	DQ	FLAT:math_isinf
	DD	08H
	ORG $+4
	DQ	FLAT:math_isinf_doc
	DQ	FLAT:??_C@_05LGCGPNNP@isnan?$AA@
	DQ	FLAT:math_isnan
	DD	08H
	ORG $+4
	DQ	FLAT:math_isnan_doc
	DQ	FLAT:??_C@_05CEJMAHNP@ldexp?$AA@
	DQ	FLAT:math_ldexp
	DD	01H
	ORG $+4
	DQ	FLAT:math_ldexp_doc
	DQ	FLAT:??_C@_06GKIDEKEE@lgamma?$AA@
	DQ	FLAT:math_lgamma
	DD	08H
	ORG $+4
	DQ	FLAT:math_lgamma_doc
	DQ	FLAT:??_C@_03MGHMBJCF@log?$AA@
	DQ	FLAT:math_log
	DD	01H
	ORG $+4
	DQ	FLAT:math_log_doc
	DQ	FLAT:??_C@_05IGAOEIAK@log1p?$AA@
	DQ	FLAT:math_log1p
	DD	08H
	ORG $+4
	DQ	FLAT:math_log1p_doc
	DQ	FLAT:??_C@_05HGHHAHAP@log10?$AA@
	DQ	FLAT:math_log10
	DD	08H
	ORG $+4
	DQ	FLAT:math_log10_doc
	DQ	FLAT:??_C@_04KGLCPMCP@log2?$AA@
	DQ	FLAT:math_log2
	DD	08H
	ORG $+4
	DQ	FLAT:math_log2_doc
	DQ	FLAT:??_C@_04EHEDPDJG@modf?$AA@
	DQ	FLAT:math_modf
	DD	08H
	ORG $+4
	DQ	FLAT:math_modf_doc
	DQ	FLAT:??_C@_03JGHBODFD@pow?$AA@
	DQ	FLAT:math_pow
	DD	01H
	ORG $+4
	DQ	FLAT:math_pow_doc
	DQ	FLAT:??_C@_07JLOPPFCD@radians?$AA@
	DQ	FLAT:math_radians
	DD	08H
	ORG $+4
	DQ	FLAT:math_radians_doc
	DQ	FLAT:??_C@_03BLEJJJBH@sin?$AA@
	DQ	FLAT:math_sin
	DD	08H
	ORG $+4
	DQ	FLAT:math_sin_doc
	DQ	FLAT:??_C@_04COOMCNPB@sinh?$AA@
	DQ	FLAT:math_sinh
	DD	08H
	ORG $+4
	DQ	FLAT:math_sinh_doc
	DQ	FLAT:??_C@_04EIAKFFMI@sqrt?$AA@
	DQ	FLAT:math_sqrt
	DD	08H
	ORG $+4
	DQ	FLAT:math_sqrt_doc
	DQ	FLAT:??_C@_03IIINPABG@tan?$AA@
	DQ	FLAT:math_tan
	DD	08H
	ORG $+4
	DQ	FLAT:math_tan_doc
	DQ	FLAT:??_C@_04FJHINJAO@tanh?$AA@
	DQ	FLAT:math_tanh
	DD	08H
	ORG $+4
	DQ	FLAT:math_tanh_doc
	DQ	FLAT:??_C@_05NOECMME@trunc?$AA@
	DQ	FLAT:math_trunc
	DD	08H
	ORG $+4
	DQ	FLAT:math_trunc_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'This module is always available.  It provides access to '
	DB	'the', 0aH, 'mathematical functions defined by the C standard.'
	DB	00H
	ORG $+2
mathmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04CFDJAKFL@math?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:math_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
pi	DQ	0400921fb54442d18r		; 3.14159
sqrtpi	DQ	03ffc5bf891b4ef6br		; 1.77245
logpi	DQ	03ff250d048e7a1bdr		; 1.14473
lanczos_g DQ	040181945b9800000r		; 6.02468
lanczos_g_minus_half DQ 040161945b9800000r	; 5.52468
SmallFactorials DD 01H
	DD	01H
	DD	02H
	DD	06H
	DD	018H
	DD	078H
	DD	02d0H
	DD	013b0H
	DD	09d80H
	DD	058980H
	DD	0375f00H
	DD	02611500H
	DD	01c8cfc00H
	ORG $+4
lanczos_num_coeffs DQ 04215ea5143c1a49er	; 2.35314e+010
	DQ	04223fc7075f54c57r		; 4.29198e+010
	DQ	04220a132818ab61ar		; 3.5712e+010
	DQ	04210b0b522e8261ar		; 1.7921e+010
	DQ	041f67fc1b3a5a1e8r		; 6.03954e+009
	DQ	041d57418f5d3f33fr		; 1.43972e+009
	DQ	041adab0c7bb95f2ar		; 2.48875e+008
	DQ	0417df876f95dcc98r		; 3.14264e+007
	DQ	04145f1e95080f44cr		; 2.87637e+006
	DQ	04106b6421f8787ebr		; 186056
	DQ	040bf87ac0858d804r		; 8071.67
	DQ	0406a5a607bbc3b52r		; 210.824
	DQ	040040d931ff62705r		; 2.50663
degToRad DQ	03f91df46a2529d39r		; 0.0174533
lanczos_den_coeffs DQ 00000000000000000r	; 0
	DQ	0418308a800000000r		; 3.99168e+007
	DQ	0419cbd6980000000r		; 1.20544e+008
	DQ	041a1fda6b0000000r		; 1.50918e+008
	DQ	04199187170000000r		; 1.05258e+008
	DQ	04185eeb690000000r		; 4.59957e+007
	DQ	041697171e0000000r		; 1.33395e+007
	DQ	041441f7b00000000r		; 2.63756e+006
	DQ	04115d0bc00000000r		; 357423
	DQ	040dfe78000000000r		; 32670
	DQ	0409e140000000000r		; 1925
	DQ	04050800000000000r		; 66
	DQ	03ff0000000000000r		; 1
radToDeg DQ	0404ca5dc1a63c1f8r		; 57.2958
gamma_integral DQ 03ff0000000000000r		; 1
	DQ	03ff0000000000000r		; 1
	DQ	04000000000000000r		; 2
	DQ	04018000000000000r		; 6
	DQ	04038000000000000r		; 24
	DQ	0405e000000000000r		; 120
	DQ	04086800000000000r		; 720
	DQ	040b3b00000000000r		; 5040
	DQ	040e3b00000000000r		; 40320
	DQ	04116260000000000r		; 362880
	DQ	0414baf8000000000r		; 3.6288e+006
	DQ	0418308a800000000r		; 3.99168e+007
	DQ	041bc8cfc00000000r		; 4.79002e+008
	DQ	041f7328cc0000000r		; 6.22702e+009
	DQ	042344c3b28000000r		; 8.71783e+010
	DQ	04273077775800000r		; 1.30767e+012
	DQ	042b3077775800000r		; 2.09228e+013
	DQ	042f437eeecd80000r		; 3.55687e+014
	DQ	04336beecca730000r		; 6.40237e+015
	DQ	0437b02b930689000r		; 1.21645e+017
	DQ	043c0e1b3be415a00r		; 2.4329e+018
	DQ	04406283be9b5c620r		; 5.10909e+019
	DQ	0444e77526159f06cr		; 1.124e+021
CONST	ENDS
EXTRN	__imp__hypot:PROC
EXTRN	_fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT hypot
_TEXT	SEGMENT
_X$ = 8
_Y$ = 16
hypot	PROC						; COMDAT

; 163  :     return _hypot(_X, _Y);
; 164  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__hypot
hypot	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__mask@@NegDouble@
PUBLIC	__real@3ff8000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@e979b5d96fe285c6
PUBLIC	__mask@@AbsDouble@
PUBLIC	__real@4000000000000000
EXTRN	__imp__copysign:PROC
EXTRN	round:PROC
EXTRN	fmod:PROC
EXTRN	cos:PROC
EXTRN	sin:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\mathmodule.c
pdata	SEGMENT
$pdata$sinpi DD	imagerel sinpi
	DD	imagerel sinpi+255
	DD	imagerel $unwind$sinpi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sinpi DD 051701H
	DD	029817H
	DD	036811H
	DD	08204H
xdata	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@e979b5d96fe285c6
CONST	SEGMENT
__real@e979b5d96fe285c6 DQ 0e979b5d96fe285c6r	; -1.23e+200
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT sinpi
_TEXT	SEGMENT
x$ = 80
sinpi	PROC						; COMDAT

; 71   : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 72   :     double y, r;
; 73   :     int n;
; 74   :     /* this function should only ever be called for finite arguments */
; 75   :     assert(Py_IS_FINITE(x));
; 76   :     y = fmod(fabs(x), 2.0);

  00004	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  0000c	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00011	44 0f 29 4c 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm9
  00017	66 44 0f 28 c8	 movapd	 xmm9, xmm0
  0001c	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  00024	e8 00 00 00 00	 call	 fmod
  00029	66 0f 28 f0	 movapd	 xmm6, xmm0

; 77   :     n = (int)round(2.0*y);

  0002d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00035	e8 00 00 00 00	 call	 round

; 78   :     assert(0 <= n && n <= 4);
; 79   :     switch (n) {

  0003a	f2 0f 2c c8	 cvttsd2si ecx, xmm0
  0003e	85 c9		 test	 ecx, ecx
  00040	74 26		 je	 SHORT $LN6@sinpi
  00042	ff c9		 dec	 ecx
  00044	0f 84 97 00 00
	00		 je	 $LN5@sinpi
  0004a	ff c9		 dec	 ecx
  0004c	74 7d		 je	 SHORT $LN4@sinpi
  0004e	ff c9		 dec	 ecx
  00050	74 52		 je	 SHORT $LN3@sinpi
  00052	ff c9		 dec	 ecx
  00054	74 0a		 je	 SHORT $LN2@sinpi

; 96   :         break;
; 97   :     default:
; 98   :         assert(0);  /* should never get here */
; 99   :         r = -1.23e200; /* silence gcc warning */

  00056	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@e979b5d96fe285c6
  0005e	eb 1d		 jmp	 SHORT $LN7@sinpi
$LN2@sinpi:

; 94   :     case 4:
; 95   :         r = sin(pi*(y-2.0));

  00060	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@4000000000000000
$LN6@sinpi:

; 80   :     case 0:
; 81   :         r = sin(pi*y);

  00068	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR pi
  00070	66 0f 28 c6	 movapd	 xmm0, xmm6
$LN11@sinpi:
  00074	e8 00 00 00 00	 call	 sin
$LN12@sinpi:
  00079	66 0f 28 f0	 movapd	 xmm6, xmm0
$LN7@sinpi:

; 100  :     }
; 101  :     return copysign(1.0, x)*r;

  0007d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00085	66 41 0f 28 c9	 movapd	 xmm1, xmm9
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign

; 102  : }

  00090	44 0f 28 4c 24
	20		 movaps	 xmm9, XMMWORD PTR [rsp+32]
  00096	f2 0f 59 c6	 mulsd	 xmm0, xmm6
  0009a	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0009f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a3	c3		 ret	 0
$LN3@sinpi:

; 91   :     case 3:
; 92   :         r = -cos(pi*(y-1.5));

  000a4	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3ff8000000000000
  000ac	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR pi
  000b4	66 0f 28 c6	 movapd	 xmm0, xmm6
  000b8	e8 00 00 00 00	 call	 cos
  000bd	66 0f 28 f0	 movapd	 xmm6, xmm0
  000c1	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@

; 93   :         break;

  000c9	eb b2		 jmp	 SHORT $LN7@sinpi
$LN4@sinpi:

; 86   :     case 2:
; 87   :         /* N.B. -sin(pi*(y-1.0)) is *not* equivalent: it would give
; 88   :            -0.0 instead of 0.0 when y == 1.0. */
; 89   :         r = sin(pi*(1.0-y));

  000cb	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000d3	f2 0f 5c c6	 subsd	 xmm0, xmm6
  000d7	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR pi

; 90   :         break;

  000df	eb 93		 jmp	 SHORT $LN11@sinpi
$LN5@sinpi:

; 82   :         break;
; 83   :     case 1:
; 84   :         r = cos(pi*(y-0.5));

  000e1	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3fe0000000000000
  000e9	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR pi
  000f1	66 0f 28 c6	 movapd	 xmm0, xmm6
  000f5	e8 00 00 00 00	 call	 cos

; 85   :         break;

  000fa	e9 7a ff ff ff	 jmp	 $LN12@sinpi
sinpi	ENDP
_TEXT	ENDS
PUBLIC	__real@4014000000000000
EXTRN	__ImageBase:BYTE
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT lanczos_sum
_TEXT	SEGMENT
x$ = 8
lanczos_sum PROC					; COMDAT

; 200  :     double num = 0.0, den = 0.0;
; 201  :     int i;
; 202  :     assert(x > 0.0);
; 203  :     /* evaluate the rational function lanczos_sum(x).  For large
; 204  :        x, the obvious algorithm risks overflow, so we instead
; 205  :        rescale the denominator and numerator of the rational
; 206  :        function by x**(1-LANCZOS_N) and treat this as a
; 207  :        rational function in 1/x.  This also reduces the error for
; 208  :        larger x values.  The choice of cutoff point (5.0 below) is
; 209  :        somewhat arbitrary; in tests, smaller cutoff values than
; 210  :        this resulted in lower accuracy. */
; 211  :     if (x < 5.0) {

  00000	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4014000000000000
  00008	66 0f 2f c8	 comisd	 xmm1, xmm0
  0000c	0f 86 fe 00 00
	00		 jbe	 $LL7@lanczos_su

; 212  :         for (i = LANCZOS_N; --i >= 0; ) {
; 213  :             num = num * x + lanczos_num_coeffs[i];

  00012	66 0f 28 d0	 movapd	 xmm2, xmm0
  00016	33 c0		 xor	 eax, eax
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0001f	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR lanczos_den_coeffs
  00027	66 0f 28 ca	 movapd	 xmm1, xmm2

; 214  :             den = den * x + lanczos_den_coeffs[i];

  0002b	f2 0f 58 15 00
	00 00 00	 addsd	 xmm2, QWORD PTR __real@3ff0000000000000
  00033	f2 0f 58 0d 60
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+96
  0003b	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  0003f	f2 0f 58 15 58
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+88
  00047	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0004b	f2 0f 58 0d 58
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+88
  00053	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00057	f2 0f 58 15 50
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+80
  0005f	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00063	f2 0f 58 0d 50
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+80
  0006b	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  0006f	f2 0f 58 15 48
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+72
  00077	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0007b	f2 0f 58 0d 48
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+72
  00083	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00087	f2 0f 58 15 40
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+64
  0008f	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00093	f2 0f 58 0d 40
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+64
  0009b	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  0009f	f2 0f 58 15 38
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+56
  000a7	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000ab	f2 0f 58 0d 38
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+56
  000b3	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  000b7	f2 0f 58 15 30
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+48
  000bf	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000c3	f2 0f 58 0d 30
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+48
  000cb	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  000cf	f2 0f 58 15 28
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+40
  000d7	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000db	f2 0f 58 0d 28
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+40
$LC6@lanczos_su:
  000e3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000e7	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  000eb	48 83 e8 08	 sub	 rax, 8
  000ef	f2 0f 58 8c 08
	28 00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs[rax+rcx+40]
  000f8	f2 0f 58 94 08
	28 00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs[rax+rcx+40]
  00101	48 83 f8 e0	 cmp	 rax, -32		; ffffffffffffffe0H
  00105	7d dc		 jge	 SHORT $LC6@lanczos_su

; 221  :         }
; 222  :     }
; 223  :     return num/den;

  00107	f2 0f 5e ca	 divsd	 xmm1, xmm2
  0010b	66 0f 28 c1	 movapd	 xmm0, xmm1

; 224  : }

  0010f	c3		 ret	 0
$LL7@lanczos_su:

; 215  :         }
; 216  :     }
; 217  :     else {
; 218  :         for (i = 0; i < LANCZOS_N; i++) {
; 219  :             num = num / x + lanczos_num_coeffs[i];

  00110	66 0f 57 d2	 xorpd	 xmm2, xmm2
  00114	33 c0		 xor	 eax, eax
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0011d	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00121	66 0f 28 ca	 movapd	 xmm1, xmm2

; 220  :             den = den / x + lanczos_den_coeffs[i];

  00125	f2 0f 58 15 00
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs
  0012d	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs
  00135	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00139	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0013d	f2 0f 58 15 08
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+8
  00145	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00149	f2 0f 58 0d 08
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+8
  00151	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00155	f2 0f 58 15 10
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+16
  0015d	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00161	f2 0f 58 0d 10
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+16
  00169	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0016d	f2 0f 58 15 18
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+24
  00175	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00179	f2 0f 58 0d 18
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+24
  00181	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00185	f2 0f 58 15 20
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+32
  0018d	f2 0f 5e d0	 divsd	 xmm2, xmm0
  00191	f2 0f 58 0d 20
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+32
  00199	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0019d	f2 0f 58 15 28
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+40
  001a5	f2 0f 5e d0	 divsd	 xmm2, xmm0
  001a9	f2 0f 58 0d 28
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+40
  001b1	f2 0f 5e c8	 divsd	 xmm1, xmm0
  001b5	f2 0f 58 15 30
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+48
  001bd	f2 0f 5e d0	 divsd	 xmm2, xmm0
  001c1	f2 0f 58 0d 30
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+48
  001c9	f2 0f 5e c8	 divsd	 xmm1, xmm0
  001cd	f2 0f 58 15 38
	00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs+56
  001d5	f2 0f 58 0d 38
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs+56
$LC3@lanczos_su:
  001dd	f2 0f 5e c8	 divsd	 xmm1, xmm0
  001e1	f2 0f 5e d0	 divsd	 xmm2, xmm0
  001e5	48 83 c0 08	 add	 rax, 8
  001e9	f2 0f 58 8c 08
	38 00 00 00	 addsd	 xmm1, QWORD PTR lanczos_num_coeffs[rax+rcx+56]
  001f2	f2 0f 58 94 08
	38 00 00 00	 addsd	 xmm2, QWORD PTR lanczos_den_coeffs[rax+rcx+56]
  001fb	48 83 f8 28	 cmp	 rax, 40			; 00000028H
  001ff	7c dc		 jl	 SHORT $LC3@lanczos_su

; 221  :         }
; 222  :     }
; 223  :     return num/den;

  00201	f2 0f 5e ca	 divsd	 xmm1, xmm2
  00205	66 0f 28 c1	 movapd	 xmm0, xmm1

; 224  : }

  00209	c3		 ret	 0
lanczos_sum ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@4061800000000000
PUBLIC	__real@c00921fb54442d18
PUBLIC	__real@4069000000000000
PUBLIC	__real@3bc79ca10c924223
PUBLIC	__real@4037000000000000
EXTRN	__imp__HUGE:QWORD
EXTRN	__imp__errno:PROC
EXTRN	__imp__isnan:PROC
EXTRN	__imp__finite:PROC
EXTRN	floor:PROC
EXTRN	exp:PROC
EXTRN	pow:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_tgamma DD imagerel m_tgamma
	DD	imagerel m_tgamma+431
	DD	imagerel $unwind$m_tgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$m_tgamma DD imagerel m_tgamma+431
	DD	imagerel m_tgamma+791
	DD	imagerel $chain$2$m_tgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$m_tgamma DD imagerel m_tgamma+791
	DD	imagerel m_tgamma+842
	DD	imagerel $chain$3$m_tgamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$m_tgamma DD 021H
	DD	imagerel m_tgamma
	DD	imagerel m_tgamma+431
	DD	imagerel $unwind$m_tgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$m_tgamma DD 040c21H
	DD	02a80cH
	DD	048806H
	DD	imagerel m_tgamma
	DD	imagerel m_tgamma+431
	DD	imagerel $unwind$m_tgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_tgamma DD 077701H
	DD	039877H
	DD	05780eH
	DD	066809H
	DD	0e204H
xdata	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@4061800000000000
CONST	SEGMENT
__real@4061800000000000 DQ 04061800000000000r	; 140
CONST	ENDS
;	COMDAT __real@c00921fb54442d18
CONST	SEGMENT
__real@c00921fb54442d18 DQ 0c00921fb54442d18r	; -3.14159
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3bc79ca10c924223
CONST	SEGMENT
__real@3bc79ca10c924223 DQ 03bc79ca10c924223r	; 1e-020
CONST	ENDS
;	COMDAT __real@4037000000000000
CONST	SEGMENT
__real@4037000000000000 DQ 04037000000000000r	; 23
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT m_tgamma
_TEXT	SEGMENT
x$ = 128
m_tgamma PROC						; COMDAT

; 228  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00004	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00009	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  0000e	66 0f 28 f8	 movapd	 xmm7, xmm0

; 229  :     double absx, r, y, z, sqrtpow;
; 230  : 
; 231  :     /* special cases */
; 232  :     if (!Py_IS_FINITE(x)) {

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00018	85 c0		 test	 eax, eax
  0001a	75 55		 jne	 SHORT $LN19@m_tgamma

; 233  :         if (Py_IS_NAN(x) || x > 0.0)

  0001c	66 0f 28 c7	 movapd	 xmm0, xmm7
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00026	85 c0		 test	 eax, eax
  00028	75 34		 jne	 SHORT $LN20@m_tgamma
  0002a	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0002e	66 0f 2f fe	 comisd	 xmm7, xmm6
  00032	77 2a		 ja	 SHORT $LN20@m_tgamma

; 235  :         else {
; 236  :             errno = EDOM;

  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003a	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 237  :             return Py_NAN;  /* tgamma(-inf) = nan, invalid */

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00047	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0004b	f2 0f 59 c6	 mulsd	 xmm0, xmm6

; 320  : }

  0004f	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00054	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00059	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0005d	c3		 ret	 0
$LN20@m_tgamma:

; 234  :             return x;  /* tgamma(nan) = nan, tgamma(inf) = inf */

  0005e	66 0f 28 c7	 movapd	 xmm0, xmm7

; 320  : }

  00062	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00067	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  0006c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00070	c3		 ret	 0
$LN19@m_tgamma:
  00071	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9

; 238  :         }
; 239  :     }
; 240  :     if (x == 0.0) {

  00077	66 45 0f 57 c9	 xorpd	 xmm9, xmm9
  0007c	66 41 0f 2e f9	 ucomisd xmm7, xmm9
  00081	7a 28		 jp	 SHORT $LN18@m_tgamma
  00083	75 26		 jne	 SHORT $LN18@m_tgamma

; 241  :         errno = EDOM;

  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 242  :         /* tgamma(+-0.0) = +-inf, divide-by-zero */
; 243  :         return copysign(Py_HUGE_VAL, x);

  0008b	66 0f 28 cf	 movapd	 xmm1, xmm7
  0008f	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0009c	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000a6	e9 8a 02 00 00	 jmp	 $LN25@m_tgamma
$LN18@m_tgamma:

; 244  :     }
; 245  : 
; 246  :     /* integer arguments */
; 247  :     if (x == floor(x)) {

  000ab	66 0f 28 c7	 movapd	 xmm0, xmm7
  000af	e8 00 00 00 00	 call	 floor
  000b4	66 0f 2e f8	 ucomisd xmm7, xmm0
  000b8	7a 51		 jp	 SHORT $LN15@m_tgamma
  000ba	75 4f		 jne	 SHORT $LN15@m_tgamma

; 248  :         if (x < 0.0) {

  000bc	66 44 0f 2f cf	 comisd	 xmm9, xmm7
  000c1	76 21		 jbe	 SHORT $LN16@m_tgamma

; 249  :             errno = EDOM;  /* tgamma(n) = nan, invalid for */

  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c9	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 250  :             return Py_NAN; /* negative integers n */

  000cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000d6	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000da	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  000df	e9 51 02 00 00	 jmp	 $LN25@m_tgamma
$LN16@m_tgamma:

; 251  :         }
; 252  :         if (x <= NGAMMA_INTEGRAL)

  000e4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4037000000000000
  000ec	66 0f 2f c7	 comisd	 xmm0, xmm7
  000f0	72 19		 jb	 SHORT $LN15@m_tgamma

; 253  :             return gamma_integral[(int)x - 1];

  000f2	f2 0f 2c c7	 cvttsd2si eax, xmm7
  000f6	48 63 c8	 movsxd	 rcx, eax
  000f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gamma_integral
  00100	f2 0f 10 44 c8
	f8		 movsdx	 xmm0, QWORD PTR [rax+rcx*8-8]
  00106	e9 2a 02 00 00	 jmp	 $LN25@m_tgamma
$LN15@m_tgamma:

; 254  :     }
; 255  :     absx = fabs(x);
; 256  : 
; 257  :     /* tiny arguments:  tgamma(x) ~ 1/x for x near 0 */
; 258  :     if (absx < 1e-20) {

  0010b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3bc79ca10c924223
  00113	66 0f 28 f7	 movapd	 xmm6, xmm7
  00117	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@
  0011f	66 0f 2f c6	 comisd	 xmm0, xmm6
  00123	76 3d		 jbe	 SHORT $LN14@m_tgamma

; 259  :         r = 1.0/x;

  00125	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000
  0012d	f2 0f 5e f7	 divsd	 xmm6, xmm7

; 260  :         if (Py_IS_INFINITY(r))

  00131	66 0f 28 c6	 movapd	 xmm0, xmm6
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0013b	85 c0		 test	 eax, eax
  0013d	75 1a		 jne	 SHORT $LN13@m_tgamma
  0013f	66 0f 28 c6	 movapd	 xmm0, xmm6
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00149	85 c0		 test	 eax, eax
  0014b	75 0c		 jne	 SHORT $LN13@m_tgamma

; 261  :             errno = ERANGE;

  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00153	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN13@m_tgamma:

; 262  :         return r;

  00159	66 0f 28 c6	 movapd	 xmm0, xmm6
  0015d	e9 d3 01 00 00	 jmp	 $LN25@m_tgamma
$LN14@m_tgamma:

; 263  :     }
; 264  : 
; 265  :     /* large arguments: assuming IEEE 754 doubles, tgamma(x) overflows for
; 266  :        x > 200, and underflows to +-0.0 for x < -200, not a negative
; 267  :        integer. */
; 268  :     if (absx > 200.0) {

  00162	66 0f 2f 35 00
	00 00 00	 comisd	 xmm6, QWORD PTR __real@4069000000000000
  0016a	76 3b		 jbe	 SHORT $LN10@m_tgamma

; 269  :         if (x < 0.0) {

  0016c	66 44 0f 2f cf	 comisd	 xmm9, xmm7
  00171	76 18		 jbe	 SHORT $LN11@m_tgamma

; 270  :             return 0.0/sinpi(x);

  00173	66 0f 28 c7	 movapd	 xmm0, xmm7
  00177	e8 00 00 00 00	 call	 sinpi
  0017c	f2 44 0f 5e c8	 divsd	 xmm9, xmm0
  00181	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00186	e9 aa 01 00 00	 jmp	 $LN25@m_tgamma
$LN11@m_tgamma:

; 271  :         }
; 272  :         else {
; 273  :             errno = ERANGE;

  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00191	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 274  :             return Py_HUGE_VAL;

  00197	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0019e	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  001a2	e9 8e 01 00 00	 jmp	 $LN25@m_tgamma
$LN10@m_tgamma:

; 275  :         }
; 276  :     }
; 277  : 
; 278  :     y = absx + lanczos_g_minus_half;

  001a7	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR lanczos_g_minus_half
  001af	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  001b5	44 0f 29 54 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm10

; 279  :     /* compute error in sum */
; 280  :     if (absx > lanczos_g_minus_half) {

  001bb	66 0f 2f f0	 comisd	 xmm6, xmm0
  001bf	66 44 0f 28 d6	 movapd	 xmm10, xmm6
  001c4	f2 44 0f 58 d0	 addsd	 xmm10, xmm0

; 281  :         /* note: the correction can be foiled by an optimizing
; 282  :            compiler that (incorrectly) thinks that an expression like
; 283  :            a + b - a - b can be optimized to 0.0.  This shouldn't
; 284  :            happen in a standards-conforming compiler. */
; 285  :         double q = y - absx;

  001c9	66 45 0f 28 c2	 movapd	 xmm8, xmm10
  001ce	76 0c		 jbe	 SHORT $LN9@m_tgamma
  001d0	f2 44 0f 5c c6	 subsd	 xmm8, xmm6

; 286  :         z = q - lanczos_g_minus_half;

  001d5	f2 44 0f 5c c0	 subsd	 xmm8, xmm0

; 287  :     }
; 288  :     else {

  001da	eb 0a		 jmp	 SHORT $LN8@m_tgamma
$LN9@m_tgamma:

; 289  :         double q = y - lanczos_g_minus_half;

  001dc	f2 44 0f 5c c0	 subsd	 xmm8, xmm0

; 290  :         z = q - absx;

  001e1	f2 44 0f 5c c6	 subsd	 xmm8, xmm6
$LN8@m_tgamma:

; 291  :     }
; 292  :     z = z * lanczos_g / y;
; 293  :     if (x < 0.0) {

  001e6	66 44 0f 2f cf	 comisd	 xmm9, xmm7
  001eb	f2 44 0f 59 05
	00 00 00 00	 mulsd	 xmm8, QWORD PTR lanczos_g

; 294  :         r = -pi / sinpi(absx) / absx * exp(y) / lanczos_sum(absx);

  001f4	66 0f 28 c6	 movapd	 xmm0, xmm6
  001f8	f2 45 0f 5e c2	 divsd	 xmm8, xmm10
  001fd	0f 86 8a 00 00
	00		 jbe	 $LN7@m_tgamma
  00203	e8 00 00 00 00	 call	 sinpi
  00208	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@c00921fb54442d18
  00210	f2 0f 5e f8	 divsd	 xmm7, xmm0
  00214	66 41 0f 28 c2	 movapd	 xmm0, xmm10
  00219	f2 0f 5e fe	 divsd	 xmm7, xmm6
  0021d	e8 00 00 00 00	 call	 exp
  00222	f2 0f 59 f8	 mulsd	 xmm7, xmm0
  00226	66 0f 28 c6	 movapd	 xmm0, xmm6
  0022a	e8 00 00 00 00	 call	 lanczos_sum

; 295  :         r -= z * r;
; 296  :         if (absx < 140.0) {

  0022f	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@4061800000000000
  00237	66 0f 2f d6	 comisd	 xmm2, xmm6
  0023b	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 297  :             r /= pow(y, absx - 0.5);

  0023f	66 41 0f 28 c2	 movapd	 xmm0, xmm10
  00244	f2 44 0f 59 c7	 mulsd	 xmm8, xmm7
  00249	f2 41 0f 5c f8	 subsd	 xmm7, xmm8
  0024e	76 1a		 jbe	 SHORT $LN6@m_tgamma
  00250	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3fe0000000000000
  00258	66 0f 28 ce	 movapd	 xmm1, xmm6
  0025c	e8 00 00 00 00	 call	 pow
  00261	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 298  :         }
; 299  :         else {

  00265	e9 93 00 00 00	 jmp	 $LN2@m_tgamma
$LN6@m_tgamma:

; 300  :             sqrtpow = pow(y, absx / 2.0 - 0.25);

  0026a	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@3fe0000000000000
  00272	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3fd0000000000000
  0027a	66 0f 28 ce	 movapd	 xmm1, xmm6
  0027e	e8 00 00 00 00	 call	 pow

; 301  :             r /= sqrtpow;

  00283	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 302  :             r /= sqrtpow;

  00287	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 303  :         }
; 304  :     }
; 305  :     else {

  0028b	eb 70		 jmp	 SHORT $LN2@m_tgamma
$LN7@m_tgamma:

; 306  :         r = lanczos_sum(absx) / exp(y);

  0028d	e8 00 00 00 00	 call	 lanczos_sum
  00292	66 0f 28 f8	 movapd	 xmm7, xmm0
  00296	66 41 0f 28 c2	 movapd	 xmm0, xmm10
  0029b	e8 00 00 00 00	 call	 exp
  002a0	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 307  :         r += z * r;
; 308  :         if (absx < 140.0) {

  002a4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4061800000000000
  002ac	66 0f 2f c6	 comisd	 xmm0, xmm6

; 309  :             r *= pow(y, absx - 0.5);

  002b0	66 41 0f 28 c2	 movapd	 xmm0, xmm10
  002b5	f2 44 0f 59 c7	 mulsd	 xmm8, xmm7
  002ba	f2 41 0f 58 f8	 addsd	 xmm7, xmm8
  002bf	76 13		 jbe	 SHORT $LN3@m_tgamma
  002c1	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3fe0000000000000
  002c9	66 0f 28 ce	 movapd	 xmm1, xmm6
  002cd	e8 00 00 00 00	 call	 pow

; 310  :         }
; 311  :         else {

  002d2	eb 25		 jmp	 SHORT $LN26@m_tgamma
$LN3@m_tgamma:

; 312  :             sqrtpow = pow(y, absx / 2.0 - 0.25);

  002d4	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@3fe0000000000000
  002dc	f2 0f 5c 35 00
	00 00 00	 subsd	 xmm6, QWORD PTR __real@3fd0000000000000
  002e4	66 0f 28 ce	 movapd	 xmm1, xmm6
  002e8	e8 00 00 00 00	 call	 pow

; 313  :             r *= sqrtpow;

  002ed	66 0f 28 c8	 movapd	 xmm1, xmm0
  002f1	f2 0f 59 cf	 mulsd	 xmm1, xmm7

; 314  :             r *= sqrtpow;

  002f5	66 0f 28 f9	 movapd	 xmm7, xmm1
$LN26@m_tgamma:
  002f9	f2 0f 59 f8	 mulsd	 xmm7, xmm0
$LN2@m_tgamma:

; 315  :         }
; 316  :     }
; 317  :     if (Py_IS_INFINITY(r))

  002fd	66 0f 28 c7	 movapd	 xmm0, xmm7
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00307	44 0f 28 54 24
	20		 movaps	 xmm10, XMMWORD PTR [rsp+32]
  0030d	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  00313	85 c0		 test	 eax, eax
  00315	75 1a		 jne	 SHORT $LN1@m_tgamma
  00317	66 0f 28 c7	 movapd	 xmm0, xmm7
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00321	85 c0		 test	 eax, eax
  00323	75 0c		 jne	 SHORT $LN1@m_tgamma

; 318  :         errno = ERANGE;

  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0032b	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN1@m_tgamma:

; 319  :     return r;

  00331	66 0f 28 c7	 movapd	 xmm0, xmm7
$LN25@m_tgamma:
  00335	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]

; 320  : }

  0033b	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00340	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00345	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00349	c3		 ret	 0
m_tgamma ENDP
_TEXT	ENDS
EXTRN	log:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_lgamma DD imagerel m_lgamma
	DD	imagerel m_lgamma+133
	DD	imagerel $unwind$m_lgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$m_lgamma DD imagerel m_lgamma+133
	DD	imagerel m_lgamma+194
	DD	imagerel $chain$1$m_lgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$m_lgamma DD imagerel m_lgamma+194
	DD	imagerel m_lgamma+371
	DD	imagerel $chain$3$m_lgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$m_lgamma DD imagerel m_lgamma+371
	DD	imagerel m_lgamma+409
	DD	imagerel $chain$4$m_lgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$m_lgamma DD imagerel m_lgamma+409
	DD	imagerel m_lgamma+421
	DD	imagerel $chain$5$m_lgamma
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$m_lgamma DD imagerel m_lgamma+421
	DD	imagerel m_lgamma+431
	DD	imagerel $chain$6$m_lgamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$m_lgamma DD 021H
	DD	imagerel m_lgamma
	DD	imagerel m_lgamma+133
	DD	imagerel $unwind$m_lgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$m_lgamma DD 021H
	DD	imagerel m_lgamma+133
	DD	imagerel m_lgamma+194
	DD	imagerel $chain$1$m_lgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$m_lgamma DD 020021H
	DD	039800H
	DD	imagerel m_lgamma+133
	DD	imagerel m_lgamma+194
	DD	imagerel $chain$1$m_lgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$m_lgamma DD 040b21H
	DD	03980bH
	DD	066805H
	DD	imagerel m_lgamma+133
	DD	imagerel m_lgamma+194
	DD	imagerel $chain$1$m_lgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$m_lgamma DD 040c21H
	DD	02a80cH
	DD	048806H
	DD	imagerel m_lgamma
	DD	imagerel m_lgamma+133
	DD	imagerel $unwind$m_lgamma
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_lgamma DD 030901H
	DD	057809H
	DD	0e204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_lgamma
_TEXT	SEGMENT
x$ = 128
m_lgamma PROC						; COMDAT

; 329  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00004	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00009	66 0f 28 f8	 movapd	 xmm7, xmm0

; 330  :     double r, absx;
; 331  : 
; 332  :     /* special cases */
; 333  :     if (!Py_IS_FINITE(x)) {

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite

; 334  :         if (Py_IS_NAN(x))

  00013	66 0f 28 c7	 movapd	 xmm0, xmm7
  00017	85 c0		 test	 eax, eax
  00019	75 18		 jne	 SHORT $LN7@m_lgamma
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00021	85 c0		 test	 eax, eax
  00023	74 43		 je	 SHORT $LN8@m_lgamma

; 335  :             return x;  /* lgamma(nan) = nan */

  00025	66 0f 28 c7	 movapd	 xmm0, xmm7

; 368  : }

  00029	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  0002e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00032	c3		 ret	 0
$LN7@m_lgamma:

; 336  :         else
; 337  :             return Py_HUGE_VAL; /* lgamma(+-inf) = +inf */
; 338  :     }
; 339  : 
; 340  :     /* integer arguments */
; 341  :     if (x == floor(x) && x <= 2.0) {

  00033	e8 00 00 00 00	 call	 floor
  00038	66 0f 2e f8	 ucomisd xmm7, xmm0
  0003c	7a 3f		 jp	 SHORT $LN4@m_lgamma
  0003e	75 3d		 jne	 SHORT $LN4@m_lgamma
  00040	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00048	66 0f 2f c7	 comisd	 xmm0, xmm7
  0004c	72 2f		 jb	 SHORT $LN4@m_lgamma

; 342  :         if (x <= 0.0) {

  0004e	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00052	66 0f 2f c7	 comisd	 xmm0, xmm7
  00056	0f 82 49 01 00
	00		 jb	 $LN10@m_lgamma

; 343  :             errno = EDOM;  /* lgamma(n) = inf, divide-by-zero for */

  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00062	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
$LN8@m_lgamma:

; 344  :             return Py_HUGE_VAL; /* integers n <= 0 */

  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0006f	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]

; 368  : }

  00073	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00078	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0007c	c3		 ret	 0
$LN4@m_lgamma:

; 345  :         }
; 346  :         else {
; 347  :             return 0.0; /* lgamma(1) = lgamma(2) = 0.0 */
; 348  :         }
; 349  :     }
; 350  : 
; 351  :     absx = fabs(x);
; 352  :     /* tiny arguments: lgamma(x) ~ -log(fabs(x)) for small x */
; 353  :     if (absx < 1e-20)

  0007d	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3bc79ca10c924223
  00085	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  0008b	44 0f 29 54 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm10
  00091	f2 44 0f 10 15
	00 00 00 00	 movsdx	 xmm10, QWORD PTR __mask@@AbsDouble@
  0009a	66 44 0f 28 c7	 movapd	 xmm8, xmm7
  0009f	66 45 0f 54 c2	 andpd	 xmm8, xmm10
  000a4	66 41 0f 2f c8	 comisd	 xmm1, xmm8

; 354  :         return -log(absx);

  000a9	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000ae	76 12		 jbe	 SHORT $LN3@m_lgamma
  000b0	e8 00 00 00 00	 call	 log
  000b5	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  000bd	e9 d7 00 00 00	 jmp	 $LN13@m_lgamma
$LN3@m_lgamma:
  000c2	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  000c7	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9

; 355  : 
; 356  :     /* Lanczos' formula.  We could save a fraction of a ulp in accuracy by
; 357  :        having a second set of numerator coefficients for lanczos_sum that
; 358  :        absorbed the exp(-lanczos_g) term, and throwing out the lanczos_g
; 359  :        subtraction below; it's probably not worth it. */
; 360  :     r = log(lanczos_sum(absx)) - lanczos_g;

  000cd	e8 00 00 00 00	 call	 lanczos_sum
  000d2	e8 00 00 00 00	 call	 log
  000d7	66 44 0f 28 c8	 movapd	 xmm9, xmm0

; 361  :     r += (absx - 0.5) * (log(absx + lanczos_g - 0.5) - 1);

  000dc	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000e1	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR lanczos_g
  000e9	f2 44 0f 5c 0d
	00 00 00 00	 subsd	 xmm9, QWORD PTR lanczos_g
  000f2	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  000fa	e8 00 00 00 00	 call	 log
  000ff	66 41 0f 28 c8	 movapd	 xmm1, xmm8
  00104	f2 0f 5c 0d 00
	00 00 00	 subsd	 xmm1, QWORD PTR __real@3fe0000000000000
  0010c	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00114	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00118	f2 44 0f 58 c8	 addsd	 xmm9, xmm0

; 362  :     if (x < 0.0)

  0011d	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00121	66 0f 2f c7	 comisd	 xmm0, xmm7
  00125	76 38		 jbe	 SHORT $LN2@m_lgamma

; 363  :         /* Use reflection formula to get value for negative x. */
; 364  :         r = logpi - log(fabs(sinpi(absx))) - log(absx) - r;

  00127	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0012c	e8 00 00 00 00	 call	 sinpi
  00131	66 41 0f 54 c2	 andpd	 xmm0, xmm10
  00136	e8 00 00 00 00	 call	 log
  0013b	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR logpi
  00143	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00147	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0014c	e8 00 00 00 00	 call	 log
  00151	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00155	f2 41 0f 5c f1	 subsd	 xmm6, xmm9
  0015a	66 44 0f 28 ce	 movapd	 xmm9, xmm6
$LN2@m_lgamma:

; 365  :     if (Py_IS_INFINITY(r))

  0015f	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0016a	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  0016f	85 c0		 test	 eax, eax
  00171	75 1b		 jne	 SHORT $LN1@m_lgamma
  00173	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0017e	85 c0		 test	 eax, eax
  00180	75 0c		 jne	 SHORT $LN1@m_lgamma

; 366  :         errno = ERANGE;

  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00188	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN1@m_lgamma:

; 367  :     return r;

  0018e	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00193	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
$LN13@m_lgamma:
  00199	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  0019f	44 0f 28 54 24
	20		 movaps	 xmm10, XMMWORD PTR [rsp+32]
$LN10@m_lgamma:

; 368  : }

  001a5	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  001aa	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001ae	c3		 ret	 0
m_lgamma ENDP
_TEXT	ENDS
PUBLIC	__real@4039800000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erf_series DD imagerel m_erf_series
	DD	imagerel m_erf_series+237
	DD	imagerel $unwind$m_erf_series
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erf_series DD 082601H
	DD	028826H
	DD	037820H
	DD	04681bH
	DD	030029206H
xdata	ENDS
;	COMDAT __real@4039800000000000
CONST	SEGMENT
__real@4039800000000000 DQ 04039800000000000r	; 25.5
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT m_erf_series
_TEXT	SEGMENT
x$ = 96
m_erf_series PROC					; COMDAT

; 422  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 423  :     double x2, acc, fk, result;
; 424  :     int i, saved_errno;
; 425  : 
; 426  :     x2 = x * x;
; 427  :     acc = 0.0;
; 428  :     fk = (double)ERF_SERIES_TERMS + 0.5;

  00006	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4039800000000000
  0000e	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3ff0000000000000
  00016	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  0001b	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  00020	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8
  00026	b8 05 00 00 00	 mov	 eax, 5
  0002b	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0002f	66 0f 28 f8	 movapd	 xmm7, xmm0
  00033	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  00038	f2 0f 59 f8	 mulsd	 xmm7, xmm0
  0003c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00044	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@m_erf_seri:

; 429  :     for (i = 0; i < ERF_SERIES_TERMS; i++) {

  00050	48 ff c8	 dec	 rax

; 430  :         acc = 2.0 + x2 * acc / fk;

  00053	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00057	f2 0f 5e f1	 divsd	 xmm6, xmm1

; 431  :         fk -= 1.0;

  0005b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0005f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00063	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00067	f2 0f 5e f1	 divsd	 xmm6, xmm1
  0006b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0006f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00073	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00077	f2 0f 5e f1	 divsd	 xmm6, xmm1
  0007b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0007f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00083	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00087	f2 0f 5e f1	 divsd	 xmm6, xmm1
  0008b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0008f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00093	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00097	f2 0f 5e f1	 divsd	 xmm6, xmm1
  0009b	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0009f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  000a3	75 ab		 jne	 SHORT $LL3@m_erf_seri

; 432  :     }
; 433  :     /* Make sure the exp call doesn't affect errno;
; 434  :        see m_erfc_contfrac for more. */
; 435  :     saved_errno = errno;

  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ab	8b 18		 mov	 ebx, DWORD PTR [rax]

; 436  :     result = acc * x * exp(-x2) / sqrtpi;
; 437  :     errno = saved_errno;

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b3	89 18		 mov	 DWORD PTR [rax], ebx
  000b5	66 0f 57 3d 00
	00 00 00	 xorpd	 xmm7, QWORD PTR __mask@@NegDouble@
  000bd	66 0f 28 c7	 movapd	 xmm0, xmm7
  000c1	e8 00 00 00 00	 call	 exp

; 438  :     return result;
; 439  : }

  000c6	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  000cb	f2 41 0f 59 f0	 mulsd	 xmm6, xmm8
  000d0	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]
  000d6	f2 0f 59 c6	 mulsd	 xmm0, xmm6
  000da	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000df	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR sqrtpi
  000e7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
m_erf_series ENDP
_TEXT	ENDS
PUBLIC	__real@403e000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erfc_contfrac DD imagerel m_erfc_contfrac
	DD	imagerel m_erfc_contfrac+779
	DD	imagerel $unwind$m_erfc_contfrac
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erfc_contfrac DD 0128301H
	DD	02c883H
	DD	03b87dH
	DD	04a860H
	DD	05985aH
	DD	077843H
	DD	08683eH
	DD	0123436H
	DD	068815H
	DD	0130107H
xdata	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT m_erfc_contfrac
_TEXT	SEGMENT
x$ = 160
m_erfc_contfrac PROC					; COMDAT

; 452  : {

  00000	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 453  :     double x2, a, da, p, p_last, q, q_last, b, result;
; 454  :     int i, saved_errno;
; 455  : 
; 456  :     if (x >= ERFC_CONTFRAC_CUTOFF)

  00007	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@403e000000000000
  0000f	44 0f 29 44 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm8
  00015	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  0001a	72 12		 jb	 SHORT $LN4@m_erfc_con

; 457  :         return 0.0;

  0001c	66 0f 57 c0	 xorpd	 xmm0, xmm0

; 477  :     return result;
; 478  : }

  00020	44 0f 28 44 24
	60		 movaps	 xmm8, XMMWORD PTR [rsp+96]
  00026	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0002d	c3		 ret	 0
$LN4@m_erfc_con:
  0002e	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00036	0f 29 b4 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm6
  0003e	0f 29 7c 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm7

; 458  : 
; 459  :     x2 = x*x;
; 460  :     a = 0.0;
; 461  :     da = 0.5;
; 462  :     p = 1.0; p_last = 0.0;

  00043	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@3ff0000000000000
  0004b	66 0f 28 f0	 movapd	 xmm6, xmm0
  0004f	b8 05 00 00 00	 mov	 eax, 5
  00054	44 0f 29 4c 24
	50		 movaps	 XMMWORD PTR [rsp+80], xmm9
  0005a	44 0f 29 54 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm10
  00060	66 45 0f 57 d2	 xorpd	 xmm10, xmm10
  00065	f2 0f 59 f0	 mulsd	 xmm6, xmm0

; 463  :     q = da + x2; q_last = 1.0;

  00069	66 44 0f 28 ce	 movapd	 xmm9, xmm6
  0006e	66 0f 28 d7	 movapd	 xmm2, xmm7
  00072	66 41 0f 28 ea	 movapd	 xmm5, xmm10
  00077	44 0f 29 5c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm11
  0007d	44 0f 29 64 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm12
  00083	f2 44 0f 10 1d
	00 00 00 00	 movsdx	 xmm11, QWORD PTR __real@3fe0000000000000
  0008c	f2 44 0f 10 25
	00 00 00 00	 movsdx	 xmm12, QWORD PTR __real@4000000000000000
  00095	f2 45 0f 58 cb	 addsd	 xmm9, xmm11
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL3@m_erfc_con:

; 464  :     for (i = 0; i < ERFC_CONTFRAC_TERMS; i++) {
; 465  :         double temp;
; 466  :         a += da;

  000a0	f2 45 0f 58 d3	 addsd	 xmm10, xmm11

; 467  :         da += 2.0;

  000a5	f2 45 0f 58 dc	 addsd	 xmm11, xmm12

; 468  :         b = da + x2;
; 469  :         temp = p; p = b*p - a*p_last; p_last = temp;

  000aa	f2 41 0f 59 ea	 mulsd	 xmm5, xmm10

; 470  :         temp = q; q = b*q - a*q_last; q_last = temp;

  000af	f2 41 0f 59 d2	 mulsd	 xmm2, xmm10
  000b4	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  000b9	66 41 0f 28 db	 movapd	 xmm3, xmm11
  000be	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  000c3	f2 0f 58 de	 addsd	 xmm3, xmm6
  000c7	66 41 0f 28 e3	 movapd	 xmm4, xmm11
  000cc	66 0f 28 c3	 movapd	 xmm0, xmm3
  000d0	f2 0f 58 e6	 addsd	 xmm4, xmm6
  000d4	f2 41 0f 59 d9	 mulsd	 xmm3, xmm9
  000d9	f2 45 0f 59 ca	 mulsd	 xmm9, xmm10
  000de	f2 0f 5c da	 subsd	 xmm3, xmm2
  000e2	66 0f 28 cc	 movapd	 xmm1, xmm4
  000e6	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  000ea	f2 41 0f 59 fa	 mulsd	 xmm7, xmm10
  000ef	f2 0f 5c c5	 subsd	 xmm0, xmm5
  000f3	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  000f8	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  000fd	f2 0f 59 e3	 mulsd	 xmm4, xmm3
  00101	f2 41 0f 59 da	 mulsd	 xmm3, xmm10
  00106	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0010a	f2 41 0f 59 c2	 mulsd	 xmm0, xmm10
  0010f	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  00114	f2 41 0f 5c e1	 subsd	 xmm4, xmm9
  00119	66 41 0f 28 eb	 movapd	 xmm5, xmm11
  0011e	f2 0f 58 ee	 addsd	 xmm5, xmm6
  00122	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  00127	f2 0f 5c cf	 subsd	 xmm1, xmm7
  0012b	66 0f 28 d5	 movapd	 xmm2, xmm5
  0012f	f2 0f 59 ec	 mulsd	 xmm5, xmm4
  00133	f2 41 0f 59 e2	 mulsd	 xmm4, xmm10
  00138	f2 0f 5c eb	 subsd	 xmm5, xmm3
  0013c	66 41 0f 28 db	 movapd	 xmm3, xmm11
  00141	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  00145	f2 41 0f 59 ca	 mulsd	 xmm1, xmm10
  0014a	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  0014f	f2 0f 58 de	 addsd	 xmm3, xmm6
  00153	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  00158	f2 0f 5c d0	 subsd	 xmm2, xmm0
  0015c	66 0f 28 c3	 movapd	 xmm0, xmm3
  00160	f2 0f 59 dd	 mulsd	 xmm3, xmm5
  00164	f2 41 0f 59 ea	 mulsd	 xmm5, xmm10
  00169	f2 0f 5c dc	 subsd	 xmm3, xmm4
  0016d	66 41 0f 28 e3	 movapd	 xmm4, xmm11
  00172	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00176	f2 41 0f 59 d2	 mulsd	 xmm2, xmm10
  0017b	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0017f	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  00184	f2 0f 58 e6	 addsd	 xmm4, xmm6
  00188	66 0f 28 cc	 movapd	 xmm1, xmm4
  0018c	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  00191	f2 0f 59 e3	 mulsd	 xmm4, xmm3
  00195	f2 41 0f 59 da	 mulsd	 xmm3, xmm10
  0019a	f2 0f 5c e5	 subsd	 xmm4, xmm5
  0019e	66 41 0f 28 eb	 movapd	 xmm5, xmm11
  001a3	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  001a7	f2 41 0f 59 c2	 mulsd	 xmm0, xmm10
  001ac	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  001b1	f2 0f 5c ca	 subsd	 xmm1, xmm2
  001b5	f2 0f 58 ee	 addsd	 xmm5, xmm6
  001b9	66 0f 28 d5	 movapd	 xmm2, xmm5
  001bd	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  001c2	f2 0f 59 ec	 mulsd	 xmm5, xmm4
  001c6	f2 41 0f 59 e2	 mulsd	 xmm4, xmm10
  001cb	f2 0f 5c eb	 subsd	 xmm5, xmm3
  001cf	66 41 0f 28 db	 movapd	 xmm3, xmm11
  001d4	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  001d8	f2 41 0f 59 ca	 mulsd	 xmm1, xmm10
  001dd	f2 0f 58 de	 addsd	 xmm3, xmm6
  001e1	f2 0f 5c d0	 subsd	 xmm2, xmm0
  001e5	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  001ea	66 0f 28 c3	 movapd	 xmm0, xmm3
  001ee	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  001f3	f2 0f 59 dd	 mulsd	 xmm3, xmm5
  001f7	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  001fb	f2 0f 5c dc	 subsd	 xmm3, xmm4
  001ff	66 41 0f 28 e3	 movapd	 xmm4, xmm11
  00204	f2 0f 58 e6	 addsd	 xmm4, xmm6
  00208	f2 0f 5c c1	 subsd	 xmm0, xmm1

; 468  :         b = da + x2;
; 469  :         temp = p; p = b*p - a*p_last; p_last = temp;

  0020c	48 ff c8	 dec	 rax
  0020f	f2 41 0f 59 d2	 mulsd	 xmm2, xmm10

; 470  :         temp = q; q = b*q - a*q_last; q_last = temp;

  00214	f2 41 0f 59 ea	 mulsd	 xmm5, xmm10
  00219	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  0021e	66 0f 28 cc	 movapd	 xmm1, xmm4
  00222	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  00227	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0022b	f2 0f 59 e3	 mulsd	 xmm4, xmm3
  0022f	f2 41 0f 59 c2	 mulsd	 xmm0, xmm10
  00234	f2 0f 5c ca	 subsd	 xmm1, xmm2
  00238	f2 0f 5c e5	 subsd	 xmm4, xmm5
  0023c	66 41 0f 28 d3	 movapd	 xmm2, xmm11
  00241	f2 41 0f 59 da	 mulsd	 xmm3, xmm10
  00246	f2 0f 58 d6	 addsd	 xmm2, xmm6
  0024a	f2 45 0f 58 d3	 addsd	 xmm10, xmm11
  0024f	f2 45 0f 58 dc	 addsd	 xmm11, xmm12
  00254	66 0f 28 ea	 movapd	 xmm5, xmm2
  00258	66 45 0f 28 cb	 movapd	 xmm9, xmm11
  0025d	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  00261	f2 41 0f 59 e2	 mulsd	 xmm4, xmm10
  00266	f2 44 0f 58 ce	 addsd	 xmm9, xmm6
  0026b	f2 0f 5c d3	 subsd	 xmm2, xmm3
  0026f	f2 0f 59 e9	 mulsd	 xmm5, xmm1
  00273	f2 41 0f 59 ca	 mulsd	 xmm1, xmm10
  00278	66 41 0f 28 f9	 movapd	 xmm7, xmm9
  0027d	f2 0f 5c e8	 subsd	 xmm5, xmm0
  00281	f2 44 0f 59 ca	 mulsd	 xmm9, xmm2
  00286	f2 0f 59 fd	 mulsd	 xmm7, xmm5
  0028a	f2 44 0f 5c cc	 subsd	 xmm9, xmm4
  0028f	f2 0f 5c f9	 subsd	 xmm7, xmm1
  00293	0f 85 07 fe ff
	ff		 jne	 $LL3@m_erfc_con

; 471  :     }
; 472  :     /* Issue #8986: On some platforms, exp sets errno on underflow to zero;
; 473  :        save the current errno value so that we can restore it later. */
; 474  :     saved_errno = errno;

  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0029f	8b 18		 mov	 ebx, DWORD PTR [rax]

; 475  :     result = p / q * x * exp(-x2) / sqrtpi;
; 476  :     errno = saved_errno;

  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a7	89 18		 mov	 DWORD PTR [rax], ebx
  002a9	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@
  002b1	66 0f 28 c6	 movapd	 xmm0, xmm6
  002b5	e8 00 00 00 00	 call	 exp
  002ba	44 0f 28 64 24
	20		 movaps	 xmm12, XMMWORD PTR [rsp+32]
  002c0	44 0f 28 5c 24
	30		 movaps	 xmm11, XMMWORD PTR [rsp+48]
  002c6	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  002ce	f2 41 0f 5e f9	 divsd	 xmm7, xmm9
  002d3	44 0f 28 54 24
	40		 movaps	 xmm10, XMMWORD PTR [rsp+64]
  002d9	44 0f 28 4c 24
	50		 movaps	 xmm9, XMMWORD PTR [rsp+80]
  002df	0f 28 b4 24 80
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+128]
  002e7	f2 41 0f 59 f8	 mulsd	 xmm7, xmm8

; 477  :     return result;
; 478  : }

  002ec	44 0f 28 44 24
	60		 movaps	 xmm8, XMMWORD PTR [rsp+96]
  002f2	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  002f6	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]
  002fb	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR sqrtpi
  00303	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0030a	c3		 ret	 0
m_erfc_contfrac ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erf DD	imagerel m_erf
	DD	imagerel m_erf+144
	DD	imagerel $unwind$m_erf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erf DD 030901H
	DD	026809H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_erf
_TEXT	SEGMENT
x$ = 64
m_erf	PROC						; COMDAT

; 484  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00009	66 0f 28 f0	 movapd	 xmm6, xmm0

; 485  :     double absx, cf;
; 486  : 
; 487  :     if (Py_IS_NAN(x))

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00013	85 c0		 test	 eax, eax
  00015	74 0e		 je	 SHORT $LN3@m_erf

; 488  :         return x;

  00017	66 0f 28 c6	 movapd	 xmm0, xmm6

; 495  :     }
; 496  : }

  0001b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
$LN3@m_erf:

; 489  :     absx = fabs(x);
; 490  :     if (absx < ERF_SERIES_CUTOFF)

  00025	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff8000000000000
  0002d	66 0f 28 ce	 movapd	 xmm1, xmm6
  00031	66 0f 54 0d 00
	00 00 00	 andpd	 xmm1, QWORD PTR __mask@@AbsDouble@
  00039	66 0f 2f c1	 comisd	 xmm0, xmm1
  0003d	76 12		 jbe	 SHORT $LN2@m_erf

; 491  :         return m_erf_series(x);

  0003f	66 0f 28 c6	 movapd	 xmm0, xmm6

; 495  :     }
; 496  : }

  00043	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	e9 00 00 00 00	 jmp	 m_erf_series
$LN2@m_erf:

; 492  :     else {
; 493  :         cf = m_erfc_contfrac(absx);

  00051	66 0f 28 c1	 movapd	 xmm0, xmm1
  00055	e8 00 00 00 00	 call	 m_erfc_contfrac

; 494  :         return x > 0.0 ? 1.0 - cf : cf - 1.0;

  0005a	66 0f 2f 35 00
	00 00 00	 comisd	 xmm6, QWORD PTR lanczos_den_coeffs
  00062	66 0f 28 e8	 movapd	 xmm5, xmm0
  00066	76 16		 jbe	 SHORT $LN6@m_erf
  00068	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00070	f2 0f 5c c5	 subsd	 xmm0, xmm5

; 495  :     }
; 496  : }

  00074	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
$LN6@m_erf:

; 494  :         return x > 0.0 ? 1.0 - cf : cf - 1.0;

  0007e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000

; 495  :     }
; 496  : }

  00086	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
m_erf	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erfc DD imagerel m_erfc
	DD	imagerel m_erfc+151
	DD	imagerel $unwind$m_erfc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erfc DD 030901H
	DD	026809H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_erfc
_TEXT	SEGMENT
x$ = 64
m_erfc	PROC						; COMDAT

; 502  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00009	66 0f 28 f0	 movapd	 xmm6, xmm0

; 503  :     double absx, cf;
; 504  : 
; 505  :     if (Py_IS_NAN(x))

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00013	85 c0		 test	 eax, eax
  00015	74 0e		 je	 SHORT $LN3@m_erfc

; 506  :         return x;

  00017	66 0f 28 c6	 movapd	 xmm0, xmm6

; 513  :     }
; 514  : }

  0001b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
$LN3@m_erfc:

; 507  :     absx = fabs(x);
; 508  :     if (absx < ERF_SERIES_CUTOFF)

  00025	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff8000000000000
  0002d	66 0f 28 ce	 movapd	 xmm1, xmm6
  00031	66 0f 54 0d 00
	00 00 00	 andpd	 xmm1, QWORD PTR __mask@@AbsDouble@
  00039	66 0f 2f c1	 comisd	 xmm0, xmm1
  0003d	76 23		 jbe	 SHORT $LN2@m_erfc

; 509  :         return 1.0 - m_erf_series(x);

  0003f	66 0f 28 c6	 movapd	 xmm0, xmm6
  00043	e8 00 00 00 00	 call	 m_erf_series
  00048	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3ff0000000000000
  00050	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00054	66 0f 28 c1	 movapd	 xmm0, xmm1

; 513  :     }
; 514  : }

  00058	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
$LN2@m_erfc:

; 510  :     else {
; 511  :         cf = m_erfc_contfrac(absx);

  00062	66 0f 28 c1	 movapd	 xmm0, xmm1
  00066	e8 00 00 00 00	 call	 m_erfc_contfrac

; 512  :         return x > 0.0 ? cf : 2.0 - cf;

  0006b	66 0f 2f 35 00
	00 00 00	 comisd	 xmm6, QWORD PTR lanczos_den_coeffs
  00073	66 0f 28 e8	 movapd	 xmm5, xmm0
  00077	77 10		 ja	 SHORT $LN7@m_erfc
  00079	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00081	f2 0f 5c c5	 subsd	 xmm0, xmm5
  00085	66 0f 28 e8	 movapd	 xmm5, xmm0
$LN7@m_erfc:
  00089	66 0f 28 c5	 movapd	 xmm0, xmm5

; 513  :     }
; 514  : }

  0008d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00092	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00096	c3		 ret	 0
m_erfc	ENDP
_TEXT	ENDS
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@4002d97c7f3321d2
PUBLIC	__real@3fe921fb54442d18
EXTRN	atan2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_atan2 DD imagerel m_atan2
	DD	imagerel m_atan2+255
	DD	imagerel $unwind$m_atan2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$m_atan2 DD imagerel m_atan2+255
	DD	imagerel m_atan2+365
	DD	imagerel $chain$0$m_atan2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$m_atan2 DD imagerel m_atan2+365
	DD	imagerel m_atan2+394
	DD	imagerel $chain$2$m_atan2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$m_atan2 DD imagerel m_atan2+394
	DD	imagerel m_atan2+428
	DD	imagerel $chain$3$m_atan2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$m_atan2 DD 021H
	DD	imagerel m_atan2
	DD	imagerel m_atan2+255
	DD	imagerel $unwind$m_atan2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$m_atan2 DD 020021H
	DD	028800H
	DD	imagerel m_atan2
	DD	imagerel m_atan2+255
	DD	imagerel $unwind$m_atan2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$m_atan2 DD 020621H
	DD	028806H
	DD	imagerel m_atan2
	DD	imagerel m_atan2+255
	DD	imagerel $unwind$m_atan2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_atan2 DD 050e01H
	DD	03780eH
	DD	046809H
	DD	0a204H
xdata	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@4002d97c7f3321d2
CONST	SEGMENT
__real@4002d97c7f3321d2 DQ 04002d97c7f3321d2r	; 2.35619
CONST	ENDS
;	COMDAT __real@3fe921fb54442d18
CONST	SEGMENT
__real@3fe921fb54442d18 DQ 03fe921fb54442d18r	; 0.785398
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT m_atan2
_TEXT	SEGMENT
y$ = 96
x$ = 104
m_atan2	PROC						; COMDAT

; 526  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00009	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  0000e	66 0f 28 f8	 movapd	 xmm7, xmm0

; 527  :     if (Py_IS_NAN(x) || Py_IS_NAN(y))

  00012	66 0f 28 c1	 movapd	 xmm0, xmm1
  00016	66 0f 28 f1	 movapd	 xmm6, xmm1
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00020	85 c0		 test	 eax, eax
  00022	0f 85 62 01 00
	00		 jne	 $LN10@m_atan2
  00028	66 0f 28 c7	 movapd	 xmm0, xmm7
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00032	85 c0		 test	 eax, eax
  00034	0f 85 50 01 00
	00		 jne	 $LN10@m_atan2

; 529  :     if (Py_IS_INFINITY(y)) {

  0003a	66 0f 28 c7	 movapd	 xmm0, xmm7
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00044	85 c0		 test	 eax, eax
  00046	0f 85 af 00 00
	00		 jne	 $LN9@m_atan2
  0004c	66 0f 28 c7	 movapd	 xmm0, xmm7
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00056	85 c0		 test	 eax, eax
  00058	0f 85 9d 00 00
	00		 jne	 $LN9@m_atan2

; 530  :         if (Py_IS_INFINITY(x)) {

  0005e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00068	85 c0		 test	 eax, eax
  0006a	75 6e		 jne	 SHORT $LN6@m_atan2
  0006c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00076	85 c0		 test	 eax, eax
  00078	75 60		 jne	 SHORT $LN6@m_atan2

; 531  :             if (copysign(1., x) == 1.)

  0007a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00082	66 0f 28 ce	 movapd	 xmm1, xmm6
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0008c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  00094	7a 23		 jp	 SHORT $LN7@m_atan2
  00096	75 21		 jne	 SHORT $LN7@m_atan2

; 532  :                 /* atan2(+-inf, +inf) == +-pi/4 */
; 533  :                 return copysign(0.25*Py_MATH_PI, y);

  00098	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe921fb54442d18
  000a0	66 0f 28 cf	 movapd	 xmm1, xmm7

; 550  : }

  000a4	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000a9	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  000ae	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b2	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__copysign
$LN7@m_atan2:

; 534  :             else
; 535  :                 /* atan2(+-inf, -inf) == +-pi*3/4 */
; 536  :                 return copysign(0.75*Py_MATH_PI, y);

  000b9	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4002d97c7f3321d2
  000c1	66 0f 28 cf	 movapd	 xmm1, xmm7

; 550  : }

  000c5	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000ca	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  000cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d3	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__copysign
$LN6@m_atan2:

; 537  :         }
; 538  :         /* atan2(+-inf, x) == +-pi/2 for finite x */
; 539  :         return copysign(0.5*Py_MATH_PI, y);

  000da	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff921fb54442d18
  000e2	66 0f 28 cf	 movapd	 xmm1, xmm7

; 550  : }

  000e6	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000eb	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  000f0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f4	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__copysign
$LN9@m_atan2:

; 540  :     }
; 541  :     if (Py_IS_INFINITY(x) || y == 0.) {

  000fb	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ff	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0010b	66 45 0f 57 c0	 xorpd	 xmm8, xmm8
  00110	85 c0		 test	 eax, eax
  00112	75 0e		 jne	 SHORT $LN3@m_atan2
  00114	66 0f 28 c6	 movapd	 xmm0, xmm6
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0011e	85 c0		 test	 eax, eax
  00120	74 09		 je	 SHORT $LN4@m_atan2
$LN3@m_atan2:
  00122	66 41 0f 2e f8	 ucomisd xmm7, xmm8
  00127	7a 52		 jp	 SHORT $LN1@m_atan2
  00129	75 50		 jne	 SHORT $LN1@m_atan2
$LN4@m_atan2:

; 542  :         if (copysign(1., x) == 1.)

  0012b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00133	66 0f 28 ce	 movapd	 xmm1, xmm6
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0013d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  00145	7a 26		 jp	 SHORT $LN2@m_atan2
  00147	75 24		 jne	 SHORT $LN2@m_atan2

; 543  :             /* atan2(+-y, +inf) = atan2(+-0, +x) = +-0. */
; 544  :             return copysign(0., y);

  00149	66 0f 28 cf	 movapd	 xmm1, xmm7
  0014d	66 41 0f 28 c0	 movapd	 xmm0, xmm8
$LN15@m_atan2:
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
$LN14@m_atan2:
  00158	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]

; 550  : }

  0015e	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00163	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  00168	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0016c	c3		 ret	 0
$LN2@m_atan2:

; 545  :         else
; 546  :             /* atan2(+-y, -inf) = atan2(+-0., -x) = +-pi. */
; 547  :             return copysign(Py_MATH_PI, y);

  0016d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR pi
  00175	66 0f 28 cf	 movapd	 xmm1, xmm7
  00179	eb d7		 jmp	 SHORT $LN15@m_atan2
$LN1@m_atan2:

; 548  :     }
; 549  :     return atan2(y, x);

  0017b	66 0f 28 ce	 movapd	 xmm1, xmm6
  0017f	66 0f 28 c7	 movapd	 xmm0, xmm7
  00183	e8 00 00 00 00	 call	 atan2
  00188	eb ce		 jmp	 SHORT $LN14@m_atan2
$LN10@m_atan2:

; 528  :         return Py_NAN;

  0018a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE

; 550  : }

  00191	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00196	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  0019b	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0019f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR lanczos_den_coeffs
  001a7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ab	c3		 ret	 0
m_atan2	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log DD	imagerel m_log
	DD	imagerel m_log+200
	DD	imagerel $unwind$m_log
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log DD 050e01H
	DD	02780eH
	DD	036809H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_log
_TEXT	SEGMENT
x$ = 80
m_log	PROC						; COMDAT

; 561  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00009	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  0000e	66 0f 28 f0	 movapd	 xmm6, xmm0

; 562  :     if (Py_IS_FINITE(x)) {

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00018	85 c0		 test	 eax, eax
  0001a	74 57		 je	 SHORT $LN9@m_log

; 563  :         if (x > 0.0)

  0001c	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00020	66 0f 2f f7	 comisd	 xmm6, xmm7
  00024	76 17		 jbe	 SHORT $LN8@m_log

; 564  :             return log(x);

  00026	66 0f 28 c6	 movapd	 xmm0, xmm6

; 578  :     }
; 579  : }

  0002a	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0002f	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00034	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00038	e9 00 00 00 00	 jmp	 log
$LN8@m_log:

; 565  :         errno = EDOM;

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 566  :         if (x == 0.0)

  00043	66 0f 2e f7	 ucomisd xmm6, xmm7
  00047	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  0004d	7a 5b		 jp	 SHORT $LN7@m_log
  0004f	75 59		 jne	 SHORT $LN7@m_log

; 567  :             return -Py_HUGE_VAL; /* log(0) = -inf */

  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00058	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0005c	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@

; 578  :     }
; 579  : }

  00064	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00069	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0006e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00072	c3		 ret	 0
$LN9@m_log:

; 568  :         else
; 569  :             return Py_NAN; /* log(-ve) = nan */
; 570  :     }
; 571  :     else if (Py_IS_NAN(x))

  00073	66 0f 28 c6	 movapd	 xmm0, xmm6
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0007d	85 c0		 test	 eax, eax
  0007f	74 13		 je	 SHORT $LN4@m_log
$LN12@m_log:

; 572  :         return x; /* log(nan) = nan */

  00081	66 0f 28 c6	 movapd	 xmm0, xmm6

; 578  :     }
; 579  : }

  00085	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0008a	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
$LN4@m_log:

; 573  :     else if (x > 0.0)

  00094	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00098	66 0f 2f f7	 comisd	 xmm6, xmm7

; 574  :         return x; /* log(inf) = inf */

  0009c	77 e3		 ja	 SHORT $LN12@m_log

; 575  :     else {
; 576  :         errno = EDOM;

  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a4	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
$LN7@m_log:

; 577  :         return Py_NAN; /* log(-inf) = nan */

  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE

; 578  :     }
; 579  : }

  000b1	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000b6	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000ba	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  000be	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
m_log	ENDP
_TEXT	ENDS
EXTRN	__imp_frexp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log2 DD imagerel m_log2
	DD	imagerel m_log2+332
	DD	imagerel $unwind$m_log2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log2 DD 050e01H
	DD	02780eH
	DD	036809H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_log2
_TEXT	SEGMENT
x$ = 80
e$20392 = 88
m_log2	PROC						; COMDAT

; 593  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00009	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  0000e	66 0f 28 f0	 movapd	 xmm6, xmm0

; 594  :     if (!Py_IS_FINITE(x)) {

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00018	85 c0		 test	 eax, eax
  0001a	75 2f		 jne	 SHORT $LN7@m_log2

; 595  :         if (Py_IS_NAN(x))

  0001c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00026	85 c0		 test	 eax, eax

; 596  :             return x; /* log2(nan) = nan */

  00028	75 0e		 jne	 SHORT $LN15@m_log2

; 597  :         else if (x > 0.0)

  0002a	66 0f 57 ff	 xorpd	 xmm7, xmm7
  0002e	66 0f 2f f7	 comisd	 xmm6, xmm7
  00032	0f 86 ea 00 00
	00		 jbe	 $LN2@m_log2
$LN15@m_log2:

; 598  :             return x; /* log2(+inf) = +inf */

  00038	66 0f 28 c6	 movapd	 xmm0, xmm6

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 633  :     }
; 634  : }

  0003c	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00041	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00046	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004a	c3		 ret	 0
$LN7@m_log2:

; 599  :         else {
; 600  :             errno = EDOM;
; 601  :             return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 602  :         }
; 603  :     }
; 604  : 
; 605  :     if (x > 0.0) {

  0004b	66 0f 57 ff	 xorpd	 xmm7, xmm7
  0004f	66 0f 2f f7	 comisd	 xmm6, xmm7
  00053	0f 86 93 00 00
	00		 jbe	 $LN6@m_log2

; 606  : #ifdef HAVE_LOG2
; 607  :         return log2(x);
; 608  : #else
; 609  :         double m;
; 610  :         int e;
; 611  :         m = frexp(x, &e);

  00059	48 8d 54 24 58	 lea	 rdx, QWORD PTR e$20392[rsp]
  0005e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 612  :         /* We want log2(m * 2**e) == log(m) / log(2) + e.  Care is needed when
; 613  :          * x is just greater than 1.0: in that case e is 1, log(m) is negative,
; 614  :          * and we get significant cancellation error from the addition of
; 615  :          * log(m) / log(2) to e.  The slight rewrite of the expression below
; 616  :          * avoids this problem.
; 617  :          */
; 618  :         if (x >= 1.0) {

  00068	66 0f 2f 35 00
	00 00 00	 comisd	 xmm6, QWORD PTR __real@3ff0000000000000
  00070	72 43		 jb	 SHORT $LN5@m_log2

; 619  :             return log(2.0 * m) / log(2.0) + (e - 1);

  00072	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  0007a	e8 00 00 00 00	 call	 log
  0007f	66 0f 28 f8	 movapd	 xmm7, xmm0
  00083	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  0008b	e8 00 00 00 00	 call	 log
  00090	8b 44 24 58	 mov	 eax, DWORD PTR e$20392[rsp]
  00094	ff c8		 dec	 eax
  00096	f2 0f 5e f8	 divsd	 xmm7, xmm0
  0009a	66 0f 6e c8	 movd	 xmm1, eax
  0009e	f3 0f e6 c1	 cvtdq2pd xmm0, xmm1
  000a2	f2 0f 58 c7	 addsd	 xmm0, xmm7

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 633  :     }
; 634  : }

  000a6	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000ab	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
$LN5@m_log2:

; 620  :         }
; 621  :         else {
; 622  :             return log(m) / log(2.0) + e;

  000b5	e8 00 00 00 00	 call	 log
  000ba	66 0f 28 f0	 movapd	 xmm6, xmm0
  000be	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  000c6	e8 00 00 00 00	 call	 log
  000cb	66 0f 6e 4c 24
	58		 movd	 xmm1, DWORD PTR e$20392[rsp]
  000d1	f2 0f 5e f0	 divsd	 xmm6, xmm0
  000d5	f3 0f e6 c1	 cvtdq2pd xmm0, xmm1
  000d9	f2 0f 58 c6	 addsd	 xmm0, xmm6

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 633  :     }
; 634  : }

  000dd	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000e2	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000e7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000eb	c3		 ret	 0
$LN6@m_log2:

; 623  :         }
; 624  : #endif
; 625  :     }
; 626  :     else if (x == 0.0) {

  000ec	66 0f 2e f7	 ucomisd xmm6, xmm7
  000f0	7a 30		 jp	 SHORT $LN2@m_log2
  000f2	75 2e		 jne	 SHORT $LN2@m_log2

; 627  :         errno = EDOM;

  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fa	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 628  :         return -Py_HUGE_VAL; /* log2(0) = -inf, divide-by-zero */

  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00107	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0010b	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 633  :     }
; 634  : }

  00113	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00118	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0011d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00121	c3		 ret	 0
$LN2@m_log2:

; 629  :     }
; 630  :     else {
; 631  :         errno = EDOM;

  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */
; 633  :     }
; 634  : }

  00128	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0012d	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  00133	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0013a	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0013e	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  00142	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00147	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014b	c3		 ret	 0
m_log2	ENDP
_TEXT	ENDS
EXTRN	log10:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log10 DD imagerel m_log10
	DD	imagerel m_log10+200
	DD	imagerel $unwind$m_log10
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log10 DD 050e01H
	DD	02780eH
	DD	036809H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT m_log10
_TEXT	SEGMENT
x$ = 80
m_log10	PROC						; COMDAT

; 638  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00009	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  0000e	66 0f 28 f0	 movapd	 xmm6, xmm0

; 639  :     if (Py_IS_FINITE(x)) {

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00018	85 c0		 test	 eax, eax
  0001a	74 57		 je	 SHORT $LN9@m_log10

; 640  :         if (x > 0.0)

  0001c	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00020	66 0f 2f f7	 comisd	 xmm6, xmm7
  00024	76 17		 jbe	 SHORT $LN8@m_log10

; 641  :             return log10(x);

  00026	66 0f 28 c6	 movapd	 xmm0, xmm6

; 655  :     }
; 656  : }

  0002a	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0002f	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00034	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00038	e9 00 00 00 00	 jmp	 log10
$LN8@m_log10:

; 642  :         errno = EDOM;

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 643  :         if (x == 0.0)

  00043	66 0f 2e f7	 ucomisd xmm6, xmm7
  00047	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  0004d	7a 5b		 jp	 SHORT $LN7@m_log10
  0004f	75 59		 jne	 SHORT $LN7@m_log10

; 644  :             return -Py_HUGE_VAL; /* log10(0) = -inf */

  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00058	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0005c	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@

; 655  :     }
; 656  : }

  00064	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00069	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0006e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00072	c3		 ret	 0
$LN9@m_log10:

; 645  :         else
; 646  :             return Py_NAN; /* log10(-ve) = nan */
; 647  :     }
; 648  :     else if (Py_IS_NAN(x))

  00073	66 0f 28 c6	 movapd	 xmm0, xmm6
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0007d	85 c0		 test	 eax, eax
  0007f	74 13		 je	 SHORT $LN4@m_log10
$LN12@m_log10:

; 649  :         return x; /* log10(nan) = nan */

  00081	66 0f 28 c6	 movapd	 xmm0, xmm6

; 655  :     }
; 656  : }

  00085	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0008a	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
$LN4@m_log10:

; 650  :     else if (x > 0.0)

  00094	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00098	66 0f 2f f7	 comisd	 xmm6, xmm7

; 651  :         return x; /* log10(inf) = inf */

  0009c	77 e3		 ja	 SHORT $LN12@m_log10

; 652  :     else {
; 653  :         errno = EDOM;

  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a4	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
$LN7@m_log10:

; 654  :         return Py_NAN; /* log10(-inf) = nan */

  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE

; 655  :     }
; 656  : }

  000b1	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000b6	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000ba	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  000be	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
m_log10	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@PNJGEICL@math?5range?5error?$AA@	; `string'
PUBLIC	??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@	; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_error DD imagerel is_error
	DD	imagerel is_error+164
	DD	imagerel $unwind$is_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_error DD 030901H
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BB@PNJGEICL@math?5range?5error?$AA@
CONST	SEGMENT
??_C@_0BB@PNJGEICL@math?5range?5error?$AA@ DB 'math range error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
CONST	SEGMENT
??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@ DB 'math domain error', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT is_error
_TEXT	SEGMENT
x$ = 64
is_error PROC						; COMDAT

; 665  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00009	66 0f 28 f0	 movapd	 xmm6, xmm0

; 666  :     int result = 1;     /* presumption of guilt */
; 667  :     assert(errno);      /* non-zero errno is a precondition for calling */
; 668  :     if (errno == EDOM)

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	83 38 21	 cmp	 DWORD PTR [rax], 33	; 00000021H
  00016	75 22		 jne	 SHORT $LN6@is_error

; 669  :         PyErr_SetString(PyExc_ValueError, "math domain error");

  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  00026	e8 00 00 00 00	 call	 PyErr_SetString

; 696  :     return result;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 697  : }

  00030	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
$LN6@is_error:

; 670  : 
; 671  :     else if (errno == ERANGE) {

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00043	75 44		 jne	 SHORT $LN4@is_error

; 672  :         /* ANSI C generally requires libm functions to set ERANGE
; 673  :          * on overflow, but also generally *allows* them to set
; 674  :          * ERANGE on underflow too.  There's no consistency about
; 675  :          * the latter across platforms.
; 676  :          * Alas, C99 never requires that errno be set.
; 677  :          * Here we suppress the underflow errors (libm functions
; 678  :          * should return a zero on underflow, and +- HUGE_VAL on
; 679  :          * overflow, so testing the result for zero suffices to
; 680  :          * distinguish the cases).
; 681  :          *
; 682  :          * On some platforms (Ubuntu/ia64) it seems that errno can be
; 683  :          * set to ERANGE for subnormal results that do *not* underflow
; 684  :          * to zero.  So to be safe, we'll ignore ERANGE whenever the
; 685  :          * function result is less than one in absolute value.
; 686  :          */
; 687  :         if (fabs(x) < 1.0)

  00045	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@
  0004d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00055	66 0f 2f c6	 comisd	 xmm0, xmm6
  00059	76 0c		 jbe	 SHORT $LN3@is_error

; 696  :     return result;

  0005b	33 c0		 xor	 eax, eax

; 697  : }

  0005d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
$LN3@is_error:

; 688  :             result = 0;
; 689  :         else
; 690  :             PyErr_SetString(PyExc_OverflowError,
; 691  :                             "math range error");

  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@PNJGEICL@math?5range?5error?$AA@
  00075	e8 00 00 00 00	 call	 PyErr_SetString

; 696  :     return result;

  0007a	b8 01 00 00 00	 mov	 eax, 1

; 697  : }

  0007f	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
$LN4@is_error:

; 692  :     }
; 693  :     else
; 694  :         /* Unexpected math error */
; 695  :         PyErr_SetFromErrno(PyExc_ValueError);

  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00090	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 696  :     return result;

  00095	b8 01 00 00 00	 mov	 eax, 1

; 697  : }

  0009a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0009f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a3	c3		 ret	 0
is_error ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
EXTRN	PyErr_Occurred:PROC
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_1_to_whatever DD imagerel math_1_to_whatever
	DD	imagerel math_1_to_whatever+67
	DD	imagerel $unwind$math_1_to_whatever
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$math_1_to_whatever DD imagerel math_1_to_whatever+67
	DD	imagerel math_1_to_whatever+259
	DD	imagerel $chain$0$math_1_to_whatever
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_1_to_whatever DD imagerel math_1_to_whatever+259
	DD	imagerel math_1_to_whatever+280
	DD	imagerel $chain$1$math_1_to_whatever
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_1_to_whatever DD 021H
	DD	imagerel math_1_to_whatever
	DD	imagerel math_1_to_whatever+67
	DD	imagerel $unwind$math_1_to_whatever
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$math_1_to_whatever DD 020521H
	DD	036805H
	DD	imagerel math_1_to_whatever
	DD	imagerel math_1_to_whatever+67
	DD	imagerel $unwind$math_1_to_whatever
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1_to_whatever DD 081401H
	DD	027814H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_1_to_whatever
_TEXT	SEGMENT
arg$ = 80
func$ = 88
from_double_func$ = 96
can_overflow$ = 104
math_1_to_whatever PROC					; COMDAT

; 733  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00014	41 8b d9	 mov	 ebx, r9d
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b f2	 mov	 rsi, rdx

; 734  :     double x, r;
; 735  :     x = PyFloat_AsDouble(arg);

  0001d	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 736  :     if (x == -1.0 && PyErr_Occurred())

  00022	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002a	66 0f 28 f8	 movapd	 xmm7, xmm0
  0002e	7a 13		 jp	 SHORT $LN6@math_1_to_
  00030	75 11		 jne	 SHORT $LN6@math_1_to_
  00032	e8 00 00 00 00	 call	 PyErr_Occurred
  00037	48 85 c0	 test	 rax, rax
  0003a	74 07		 je	 SHORT $LN6@math_1_to_

; 737  :         return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 c0 00 00 00	 jmp	 $LN7@math_1_to_
$LN6@math_1_to_:
  00043	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 738  :     errno = 0;

  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 739  :     PyFPE_START_PROTECT("in math_1", return 0);
; 740  :     r = (*func)(x);

  0004e	66 0f 28 c7	 movapd	 xmm0, xmm7
  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00058	ff d6		 call	 rsi
  0005a	66 0f 28 f0	 movapd	 xmm6, xmm0

; 741  :     PyFPE_END_PROTECT(r);
; 742  :     if (Py_IS_NAN(r) && !Py_IS_NAN(x)) {

  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00064	85 c0		 test	 eax, eax
  00066	74 0e		 je	 SHORT $LN5@math_1_to_
  00068	66 0f 28 c7	 movapd	 xmm0, xmm7
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00072	85 c0		 test	 eax, eax

; 743  :         PyErr_SetString(PyExc_ValueError,
; 744  :                         "math domain error"); /* invalid arg */
; 745  :         return NULL;

  00074	74 45		 je	 SHORT $LN3@math_1_to_
$LN5@math_1_to_:

; 746  :     }
; 747  :     if (Py_IS_INFINITY(r) && Py_IS_FINITE(x)) {

  00076	66 0f 28 c6	 movapd	 xmm0, xmm6
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00080	85 c0		 test	 eax, eax
  00082	75 4e		 jne	 SHORT $LN4@math_1_to_
  00084	66 0f 28 c6	 movapd	 xmm0, xmm6
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0008e	85 c0		 test	 eax, eax
  00090	75 40		 jne	 SHORT $LN4@math_1_to_
  00092	66 0f 28 c7	 movapd	 xmm0, xmm7
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0009c	85 c0		 test	 eax, eax
  0009e	74 32		 je	 SHORT $LN4@math_1_to_

; 748  :         if (can_overflow)

  000a0	85 db		 test	 ebx, ebx
  000a2	74 17		 je	 SHORT $LN3@math_1_to_

; 749  :             PyErr_SetString(PyExc_OverflowError,
; 750  :                             "math range error"); /* overflow */

  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@PNJGEICL@math?5range?5error?$AA@

; 751  :         else
; 752  :             PyErr_SetString(PyExc_ValueError,
; 753  :                             "math domain error"); /* singularity */

  000b2	e8 00 00 00 00	 call	 PyErr_SetString

; 754  :         return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	eb 43		 jmp	 SHORT $LN9@math_1_to_
$LN3@math_1_to_:

; 751  :         else
; 752  :             PyErr_SetString(PyExc_ValueError,
; 753  :                             "math domain error"); /* singularity */

  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  000c9	e8 00 00 00 00	 call	 PyErr_SetString
$LN11@math_1_to_:

; 754  :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 2c		 jmp	 SHORT $LN9@math_1_to_
$LN4@math_1_to_:

; 755  :     }
; 756  :     if (Py_IS_FINITE(r) && errno && is_error(r))

  000d2	66 0f 28 c6	 movapd	 xmm0, xmm6
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000dc	85 c0		 test	 eax, eax
  000de	74 18		 je	 SHORT $LN1@math_1_to_
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e6	83 38 00	 cmp	 DWORD PTR [rax], 0
  000e9	74 0d		 je	 SHORT $LN1@math_1_to_
  000eb	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ef	e8 00 00 00 00	 call	 is_error
  000f4	85 c0		 test	 eax, eax

; 757  :         /* this branch unnecessary on most platforms */
; 758  :         return NULL;

  000f6	75 d6		 jne	 SHORT $LN11@math_1_to_
$LN1@math_1_to_:

; 759  : 
; 760  :     return (*from_double_func)(r);

  000f8	66 0f 28 c6	 movapd	 xmm0, xmm6
  000fc	ff d7		 call	 rdi
$LN9@math_1_to_:
  000fe	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
$LN7@math_1_to_:

; 761  : }

  00103	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00108	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0010d	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  00112	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
math_1_to_whatever ENDP
_TEXT	ENDS
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_1a DD imagerel math_1a
	DD	imagerel math_1a+123
	DD	imagerel $unwind$math_1a
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1a DD 040b01H
	DD	02680bH
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_1a
_TEXT	SEGMENT
arg$ = 64
func$ = 72
math_1a	PROC						; COMDAT

; 769  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000b	48 8b da	 mov	 rbx, rdx

; 770  :     double x, r;
; 771  :     x = PyFloat_AsDouble(arg);

  0000e	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 772  :     if (x == -1.0 && PyErr_Occurred())

  00013	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0001b	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001f	7a 19		 jp	 SHORT $LN2@math_1a
  00021	75 17		 jne	 SHORT $LN2@math_1a
  00023	e8 00 00 00 00	 call	 PyErr_Occurred
  00028	48 85 c0	 test	 rax, rax
  0002b	74 0d		 je	 SHORT $LN2@math_1a
$LN5@math_1a:

; 773  :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 781  : }

  0002f	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@math_1a:

; 774  :     errno = 0;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 775  :     PyFPE_START_PROTECT("in math_1a", return 0);
; 776  :     r = (*func)(x);

  00040	66 0f 28 c6	 movapd	 xmm0, xmm6
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0004a	ff d3		 call	 rbx
  0004c	66 0f 28 f0	 movapd	 xmm6, xmm0

; 777  :     PyFPE_END_PROTECT(r);
; 778  :     if (errno && is_error(r))

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00056	83 38 00	 cmp	 DWORD PTR [rax], 0
  00059	74 0d		 je	 SHORT $LN1@math_1a
  0005b	66 0f 28 c6	 movapd	 xmm0, xmm6
  0005f	e8 00 00 00 00	 call	 is_error
  00064	85 c0		 test	 eax, eax

; 779  :         return NULL;

  00066	75 c5		 jne	 SHORT $LN5@math_1a
$LN1@math_1a:

; 780  :     return PyFloat_FromDouble(r);

  00068	66 0f 28 c6	 movapd	 xmm0, xmm6

; 781  : }

  0006c	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5b		 pop	 rbx
  00076	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
math_1a	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_1
_TEXT	SEGMENT
arg$ = 8
func$ = 16
can_overflow$ = 24
math_1	PROC						; COMDAT

; 813  :     return math_1_to_whatever(arg, func, PyFloat_FromDouble, can_overflow);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyFloat_FromDouble

; 814  : }

  0000a	e9 00 00 00 00	 jmp	 math_1_to_whatever
math_1	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromDouble:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_1_to_int
_TEXT	SEGMENT
arg$ = 8
func$ = 16
can_overflow$ = 24
math_1_to_int PROC					; COMDAT

; 819  :     return math_1_to_whatever(arg, func, PyLong_FromDouble, can_overflow);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyLong_FromDouble

; 820  : }

  0000a	e9 00 00 00 00	 jmp	 math_1_to_whatever
math_1_to_int ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_2 DD imagerel math_2
	DD	imagerel math_2+67
	DD	imagerel $unwind$math_2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_2 DD imagerel math_2+67
	DD	imagerel math_2+156
	DD	imagerel $chain$1$math_2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$math_2 DD imagerel math_2+156
	DD	imagerel math_2+383
	DD	imagerel $chain$4$math_2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$math_2 DD 060521H
	DD	066805H
	DD	048800H
	DD	057800H
	DD	imagerel math_2
	DD	imagerel math_2+67
	DD	imagerel $unwind$math_2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_2 DD 040b21H
	DD	04880bH
	DD	057805H
	DD	imagerel math_2
	DD	imagerel math_2+67
	DD	imagerel $unwind$math_2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_2 DD 020801H
	DD	03004d208H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_2
_TEXT	SEGMENT
oy$ = 48
args$ = 128
func$ = 136
funcname$ = 144
ox$ = 152
math_2	PROC						; COMDAT

; 824  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00008	48 8b da	 mov	 rbx, rdx

; 825  :     PyObject *ox, *oy;
; 826  :     double x, y, r;
; 827  :     if (! PyArg_UnpackTuple(args, funcname, 2, 2, &ox, &oy))

  0000b	49 8d 53 b8	 lea	 rdx, QWORD PTR [r11-72]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 53 b0	 mov	 QWORD PTR [r11-80], rdx
  00016	49 8d 53 20	 lea	 rdx, QWORD PTR [r11+32]
  0001a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00020	49 89 53 a8	 mov	 QWORD PTR [r11-88], rdx
  00024	48 8b d0	 mov	 rdx, rax
  00027	45 8b c1	 mov	 r8d, r9d
  0002a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0002f	85 c0		 test	 eax, eax
  00031	75 08		 jne	 SHORT $LN12@math_2

; 828  :         return NULL;

  00033	33 c0		 xor	 eax, eax

; 853  : }

  00035	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN12@math_2:

; 829  :     x = PyFloat_AsDouble(ox);

  0003b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ox$[rsp]
  00043	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00048	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  0004e	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 830  :     y = PyFloat_AsDouble(oy);

  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oy$[rsp]
  00058	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  0005d	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00062	66 0f 28 f8	 movapd	 xmm7, xmm0

; 831  :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  00066	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  0006e	66 44 0f 2e c0	 ucomisd xmm8, xmm0
  00073	7a 02		 jp	 SHORT $LN15@math_2
  00075	74 08		 je	 SHORT $LN10@math_2
$LN15@math_2:
  00077	66 0f 2e f8	 ucomisd xmm7, xmm0
  0007b	7a 1f		 jp	 SHORT $LN11@math_2
  0007d	75 1d		 jne	 SHORT $LN11@math_2
$LN10@math_2:
  0007f	e8 00 00 00 00	 call	 PyErr_Occurred
  00084	48 85 c0	 test	 rax, rax
  00087	74 13		 je	 SHORT $LN11@math_2

; 832  :         return NULL;

  00089	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  0008e	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  00094	33 c0		 xor	 eax, eax

; 853  : }

  00096	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
$LN11@math_2:
  0009c	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6

; 833  :     errno = 0;

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 834  :     PyFPE_START_PROTECT("in math_2", return 0);
; 835  :     r = (*func)(x, y);

  000a7	66 0f 28 cf	 movapd	 xmm1, xmm7
  000ab	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000b0	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000b6	ff d3		 call	 rbx
  000b8	66 0f 28 f0	 movapd	 xmm6, xmm0

; 836  :     PyFPE_END_PROTECT(r);
; 837  :     if (Py_IS_NAN(r)) {

  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000c2	85 c0		 test	 eax, eax
  000c4	74 2b		 je	 SHORT $LN9@math_2

; 838  :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  000c6	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000d1	85 c0		 test	 eax, eax
  000d3	75 63		 jne	 SHORT $LN4@math_2
  000d5	66 0f 28 c7	 movapd	 xmm0, xmm7
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000df	85 c0		 test	 eax, eax
  000e1	75 55		 jne	 SHORT $LN4@math_2

; 839  :             errno = EDOM;

  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e9	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 840  :         else
; 841  :             errno = 0;
; 842  :     }
; 843  :     else if (Py_IS_INFINITY(r)) {

  000ef	eb 53		 jmp	 SHORT $LN3@math_2
$LN9@math_2:
  000f1	66 0f 28 c6	 movapd	 xmm0, xmm6
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000fb	85 c0		 test	 eax, eax
  000fd	75 45		 jne	 SHORT $LN3@math_2
  000ff	66 0f 28 c6	 movapd	 xmm0, xmm6
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00109	85 c0		 test	 eax, eax
  0010b	75 37		 jne	 SHORT $LN3@math_2

; 844  :         if (Py_IS_FINITE(x) && Py_IS_FINITE(y))

  0010d	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00118	85 c0		 test	 eax, eax
  0011a	74 1c		 je	 SHORT $LN4@math_2
  0011c	66 0f 28 c7	 movapd	 xmm0, xmm7
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00126	85 c0		 test	 eax, eax
  00128	74 0e		 je	 SHORT $LN4@math_2

; 845  :             errno = ERANGE;

  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00130	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 846  :         else

  00136	eb 0c		 jmp	 SHORT $LN3@math_2
$LN4@math_2:

; 847  :             errno = 0;

  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_2:

; 848  :     }
; 849  :     if (errno && is_error(r))

  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0014d	74 11		 je	 SHORT $LN2@math_2
  0014f	66 0f 28 c6	 movapd	 xmm0, xmm6
  00153	e8 00 00 00 00	 call	 is_error
  00158	85 c0		 test	 eax, eax
  0015a	74 04		 je	 SHORT $LN2@math_2

; 850  :         return NULL;

  0015c	33 c0		 xor	 eax, eax
  0015e	eb 09		 jmp	 SHORT $LN18@math_2
$LN2@math_2:

; 851  :     else
; 852  :         return PyFloat_FromDouble(r);

  00160	66 0f 28 c6	 movapd	 xmm0, xmm6
  00164	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN18@math_2:
  00169	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  0016e	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00173	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]

; 853  : }

  00179	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0017d	5b		 pop	 rbx
  0017e	c3		 ret	 0
math_2	ENDP
_TEXT	ENDS
EXTRN	acos:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_acos
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_acos PROC						; COMDAT

; 874  :       "acos(x)\n\nReturn the arc cosine (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:acos
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_acos ENDP
_TEXT	ENDS
EXTRN	_Py_acosh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_acosh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_acosh PROC						; COMDAT

; 876  :       "acosh(x)\n\nReturn the hyperbolic arc cosine (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_acosh
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_acosh ENDP
_TEXT	ENDS
EXTRN	asin:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_asin
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_asin PROC						; COMDAT

; 878  :       "asin(x)\n\nReturn the arc sine (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:asin
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_asin ENDP
_TEXT	ENDS
EXTRN	_Py_asinh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_asinh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_asinh PROC						; COMDAT

; 880  :       "asinh(x)\n\nReturn the hyperbolic arc sine (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_asinh
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_asinh ENDP
_TEXT	ENDS
EXTRN	atan:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_atan
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_atan PROC						; COMDAT

; 882  :       "atan(x)\n\nReturn the arc tangent (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:atan
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_atan ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_atan2
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_atan2 PROC						; COMDAT

; 885  :       "Unlike atan(y/x), the signs of both x and y are considered.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05KNGEOGJB@atan2?$AA@
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_atan2
  00011	e9 00 00 00 00	 jmp	 math_2
math_atan2 ENDP
_TEXT	ENDS
EXTRN	_Py_atanh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_atanh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_atanh PROC						; COMDAT

; 887  :       "atanh(x)\n\nReturn the hyperbolic arc tangent (measured in radians) of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_atanh
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_atanh ENDP
_TEXT	ENDS
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	__imp_ceil:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_ceil DD imagerel math_ceil
	DD	imagerel math_ceil+139
	DD	imagerel $unwind$math_ceil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_ceil DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_ceil
_TEXT	SEGMENT
self$ = 48
number$ = 56
math_ceil PROC						; COMDAT

; 889  : static PyObject * math_ceil(PyObject *self, PyObject *number) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 890  :     _Py_IDENTIFIER(__ceil__);
; 891  :     PyObject *method, *result;
; 892  : 
; 893  :     method = _PyObject_LookupSpecial(number, &PyId___ceil__);

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00010	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00019	48 8b da	 mov	 rbx, rdx
  0001c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___ceil__@?1??math_ceil@@9@9
  00021	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  0002d	48 8b f8	 mov	 rdi, rax

; 894  :     if (method == NULL) {

  00030	48 85 c0	 test	 rax, rax
  00033	75 33		 jne	 SHORT $LN2@math_ceil

; 895  :         if (PyErr_Occurred())

  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 0d		 je	 SHORT $LN1@math_ceil

; 896  :             return NULL;

  0003f	33 c0		 xor	 eax, eax

; 902  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
$LN1@math_ceil:

; 897  :         return math_1_to_int(number, ceil, 0);

  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_ceil
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b cb	 mov	 rcx, rbx

; 902  : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	e9 00 00 00 00	 jmp	 math_1_to_int
$LN2@math_ceil:

; 898  :     }
; 899  :     result = PyObject_CallFunctionObjArgs(method, NULL);

  00068	33 d2		 xor	 edx, edx
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 900  :     Py_DECREF(method);

  00072	48 8b cf	 mov	 rcx, rdi
  00075	48 8b d8	 mov	 rbx, rax
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 901  :     return result;

  0007d	48 8b c3	 mov	 rax, rbx

; 902  : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
math_ceil ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_copysign
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_copysign PROC					; COMDAT

; 911  :       "copysign(1.0, -0.0) \nreturns -1.0.\n")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp__copysign
  0000a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08PLCMNBBP@copysign?$AA@
  00011	e9 00 00 00 00	 jmp	 math_2
math_copysign ENDP
_TEXT	ENDS
EXTRN	cos:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_cos
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_cos PROC						; COMDAT

; 913  :       "cos(x)\n\nReturn the cosine of x (measured in radians).")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cos
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_cos ENDP
_TEXT	ENDS
EXTRN	cosh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_cosh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_cosh PROC						; COMDAT

; 915  :       "cosh(x)\n\nReturn the hyperbolic cosine of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cosh
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	e9 00 00 00 00	 jmp	 math_1
math_cosh ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_erf
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_erf PROC						; COMDAT

; 917  :        "erf(x)\n\nError function at x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_erf
  0000a	e9 00 00 00 00	 jmp	 math_1a
math_erf ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_erfc
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_erfc PROC						; COMDAT

; 919  :        "erfc(x)\n\nComplementary error function at x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_erfc
  0000a	e9 00 00 00 00	 jmp	 math_1a
math_erfc ENDP
_TEXT	ENDS
EXTRN	exp:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_exp
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_exp PROC						; COMDAT

; 921  :       "exp(x)\n\nReturn e raised to the power of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exp
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	e9 00 00 00 00	 jmp	 math_1
math_exp ENDP
_TEXT	ENDS
EXTRN	_Py_expm1:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_expm1
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_expm1 PROC						; COMDAT

; 925  :       "evaluation of exp(x)-1 for small x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_expm1
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	e9 00 00 00 00	 jmp	 math_1
math_expm1 ENDP
_TEXT	ENDS
EXTRN	fabs:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_fabs
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_fabs PROC						; COMDAT

; 927  :       "fabs(x)\n\nReturn the absolute value of the float x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fabs
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_fabs ENDP
_TEXT	ENDS
EXTRN	__imp_floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_floor DD imagerel math_floor
	DD	imagerel math_floor+139
	DD	imagerel $unwind$math_floor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_floor DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_floor
_TEXT	SEGMENT
self$ = 48
number$ = 56
math_floor PROC						; COMDAT

; 929  : static PyObject * math_floor(PyObject *self, PyObject *number) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 930  :     _Py_IDENTIFIER(__floor__);
; 931  :     PyObject *method, *result;
; 932  : 
; 933  :     method = _PyObject_LookupSpecial(number, &PyId___floor__);

  0000a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00010	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00019	48 8b da	 mov	 rbx, rdx
  0001c	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___floor__@?1??math_floor@@9@9
  00021	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  0002d	48 8b f8	 mov	 rdi, rax

; 934  :     if (method == NULL) {

  00030	48 85 c0	 test	 rax, rax
  00033	75 33		 jne	 SHORT $LN2@math_floor

; 935  :         if (PyErr_Occurred())

  00035	e8 00 00 00 00	 call	 PyErr_Occurred
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 0d		 je	 SHORT $LN1@math_floor

; 936  :             return NULL;

  0003f	33 c0		 xor	 eax, eax

; 942  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
$LN1@math_floor:

; 937  :         return math_1_to_int(number, floor, 0);

  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_floor
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b cb	 mov	 rcx, rbx

; 942  : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	e9 00 00 00 00	 jmp	 math_1_to_int
$LN2@math_floor:

; 938  :     }
; 939  :     result = PyObject_CallFunctionObjArgs(method, NULL);

  00068	33 d2		 xor	 edx, edx
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 940  :     Py_DECREF(method);

  00072	48 8b cf	 mov	 rcx, rdi
  00075	48 8b d8	 mov	 rbx, rax
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 941  :     return result;

  0007d	48 8b c3	 mov	 rax, rbx

; 942  : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
math_floor ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_gamma
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_gamma PROC						; COMDAT

; 949  :       "gamma(x)\n\nGamma function at x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_tgamma
  0000a	e9 00 00 00 00	 jmp	 math_1a
math_gamma ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_lgamma
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_lgamma PROC					; COMDAT

; 951  :       "lgamma(x)\n\nNatural logarithm of absolute value of Gamma function at x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_lgamma
  0000a	e9 00 00 00 00	 jmp	 math_1a
math_lgamma ENDP
_TEXT	ENDS
EXTRN	_Py_log1p:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_log1p
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_log1p PROC						; COMDAT

; 954  :       "The result is computed in a way which is accurate for x near zero.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_log1p
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_log1p ENDP
_TEXT	ENDS
EXTRN	sin:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_sin
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_sin PROC						; COMDAT

; 956  :       "sin(x)\n\nReturn the sine of x (measured in radians).")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sin
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_sin ENDP
_TEXT	ENDS
EXTRN	sinh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_sinh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_sinh PROC						; COMDAT

; 958  :       "sinh(x)\n\nReturn the hyperbolic sine of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sinh
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	e9 00 00 00 00	 jmp	 math_1
math_sinh ENDP
_TEXT	ENDS
EXTRN	sqrt:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_sqrt
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_sqrt PROC						; COMDAT

; 960  :       "sqrt(x)\n\nReturn the square root of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sqrt
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_sqrt ENDP
_TEXT	ENDS
EXTRN	tan:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_tan
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_tan PROC						; COMDAT

; 962  :       "tan(x)\n\nReturn the tangent of x (measured in radians).")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tan
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_tan ENDP
_TEXT	ENDS
EXTRN	tanh:PROC
; Function compile flags: /Ogtpy
;	COMDAT math_tanh
_TEXT	SEGMENT
self$ = 8
args$ = 16
math_tanh PROC						; COMDAT

; 964  :       "tanh(x)\n\nReturn the hyperbolic tangent of x.")

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tanh
  0000a	45 33 c0	 xor	 r8d, r8d
  0000d	e9 00 00 00 00	 jmp	 math_1
math_tanh ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@	; `string'
EXTRN	PyExc_MemoryError:QWORD
EXTRN	PyMem_Realloc:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_fsum_realloc DD imagerel _fsum_realloc
	DD	imagerel _fsum_realloc+193
	DD	imagerel $unwind$_fsum_realloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_fsum_realloc DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@
CONST	SEGMENT
??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@ DB 'math.fsum partials', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _fsum_realloc
_TEXT	SEGMENT
p_ptr$ = 64
n$ = 72
ps$ = 80
m_ptr$ = 88
_fsum_realloc PROC					; COMDAT

; 1008 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1009 :     void *v = NULL;
; 1010 :     Py_ssize_t m = *m_ptr;
; 1011 : 
; 1012 :     m += m;  /* double */

  00018	49 8b 39	 mov	 rdi, QWORD PTR [r9]
  0001b	4d 8b e1	 mov	 r12, r9
  0001e	49 8b e8	 mov	 rbp, r8
  00021	48 03 ff	 add	 rdi, rdi
  00024	4c 8b ea	 mov	 r13, rdx
  00027	48 8b f1	 mov	 rsi, rcx

; 1013 :     if (n < m && m < (PY_SSIZE_T_MAX / sizeof(double))) {

  0002a	48 3b d7	 cmp	 rdx, rdi
  0002d	7d 61		 jge	 SHORT $LN8@fsum_reall
  0002f	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00039	48 3b f8	 cmp	 rdi, rax
  0003c	73 52		 jae	 SHORT $LN8@fsum_reall

; 1014 :         double *p = *p_ptr;

  0003e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1015 :         if (p == ps) {

  00041	49 3b c8	 cmp	 rcx, r8
  00044	75 2a		 jne	 SHORT $LN4@fsum_reall

; 1016 :             v = PyMem_Malloc(sizeof(double) * m);

  00046	48 8d 0c fd 00
	00 00 00	 lea	 rcx, QWORD PTR [rdi*8]
  0004e	e8 00 00 00 00	 call	 PyMem_Malloc
  00053	48 8b d8	 mov	 rbx, rax

; 1017 :             if (v != NULL)

  00056	48 85 c0	 test	 rax, rax
  00059	74 35		 je	 SHORT $LN8@fsum_reall

; 1018 :                 memcpy(v, ps, sizeof(double) * n);

  0005b	4e 8d 04 ed 00
	00 00 00	 lea	 r8, QWORD PTR [r13*8]
  00063	48 8b d5	 mov	 rdx, rbp
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 memcpy

; 1019 :         }
; 1020 :         else

  0006e	eb 10		 jmp	 SHORT $LN2@fsum_reall
$LN4@fsum_reall:

; 1021 :             v = PyMem_Realloc(p, sizeof(double) * m);

  00070	48 8d 14 fd 00
	00 00 00	 lea	 rdx, QWORD PTR [rdi*8]
  00078	e8 00 00 00 00	 call	 PyMem_Realloc
  0007d	48 8b d8	 mov	 rbx, rax
$LN2@fsum_reall:

; 1022 :     }
; 1023 :     if (v == NULL) {        /* size overflow or no memory */

  00080	48 85 db	 test	 rbx, rbx
  00083	74 0b		 je	 SHORT $LN8@fsum_reall

; 1026 :     }
; 1027 :     *p_ptr = (double*) v;

  00085	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 1028 :     *m_ptr = m;
; 1029 :     return 0;

  00088	33 c0		 xor	 eax, eax
  0008a	49 89 3c 24	 mov	 QWORD PTR [r12], rdi
  0008e	eb 18		 jmp	 SHORT $LN6@fsum_reall
$LN8@fsum_reall:

; 1024 :         PyErr_SetString(PyExc_MemoryError, "math.fsum partials");

  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@
  0009e	e8 00 00 00 00	 call	 PyErr_SetString

; 1025 :         return 1;

  000a3	b8 01 00 00 00	 mov	 eax, 1
$LN6@fsum_reall:

; 1030 : }

  000a8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ad	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000b2	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	41 5d		 pop	 r13
  000bd	41 5c		 pop	 r12
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
_fsum_realloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@ ; `string'
PUBLIC	??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@ ; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$math_fsum DD imagerel math_fsum
	DD	imagerel math_fsum+85
	DD	imagerel $unwind$math_fsum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$math_fsum DD imagerel math_fsum+85
	DD	imagerel math_fsum+1103
	DD	imagerel $chain$3$math_fsum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$math_fsum DD imagerel math_fsum+1103
	DD	imagerel math_fsum+1251
	DD	imagerel $chain$4$math_fsum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$math_fsum DD 021H
	DD	imagerel math_fsum
	DD	imagerel math_fsum+85
	DD	imagerel $unwind$math_fsum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$math_fsum DD 082421H
	DD	0169824H
	DD	018781bH
	DD	0196810H
	DD	0383408H
	DD	imagerel math_fsum
	DD	imagerel math_fsum+85
	DD	imagerel $unwind$math_fsum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_fsum DD 0b3b01H
	DD	014b83bH
	DD	015a81cH
	DD	0178812H
	DD	034010dH
	DD	060057006H
	DD	05004H
xdata	ENDS
;	COMDAT ??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@
CONST	SEGMENT
??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@ DB '-inf + inf in fsum'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@
CONST	SEGMENT
??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@ DB 'intermediate'
	DB	' overflow in fsum', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\mathmodule.c
CONST	ENDS
;	COMDAT math_fsum
_TEXT	SEGMENT
lo$ = 48
yr$ = 48
m$ = 56
ps$ = 64
self$ = 448
seq$ = 456
hi$ = 464
p$ = 472
math_fsum PROC						; COMDAT

; 1064 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  0000d	45 0f 29 43 b8	 movaps	 XMMWORD PTR [r11-72], xmm8

; 1065 :     PyObject *item, *iter, *sum = NULL;
; 1066 :     Py_ssize_t i, j, n = 0, m = NUM_PARTIALS;
; 1067 :     double x, y, t, ps[NUM_PARTIALS], *p = ps;
; 1068 :     double xsave, special_sum = 0.0, inf_sum = 0.0;

  00012	66 45 0f 57 c0	 xorpd	 xmm8, xmm8
  00017	45 0f 29 53 98	 movaps	 XMMWORD PTR [r11-104], xmm10
  0001c	48 8d 44 24 40	 lea	 rax, QWORD PTR ps$[rsp]
  00021	33 ed		 xor	 ebp, ebp

; 1069 :     volatile double hi, yr, lo;
; 1070 : 
; 1071 :     iter = PyObject_GetIter(seq);

  00023	48 8b ca	 mov	 rcx, rdx
  00026	48 c7 44 24 38
	20 00 00 00	 mov	 QWORD PTR m$[rsp], 32	; 00000020H
  0002f	66 45 0f 28 d0	 movapd	 xmm10, xmm8
  00034	8b fd		 mov	 edi, ebp
  00036	45 0f 29 5b 88	 movaps	 XMMWORD PTR [r11-120], xmm11
  0003b	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  0003f	66 45 0f 28 d8	 movapd	 xmm11, xmm8
  00044	e8 00 00 00 00	 call	 PyObject_GetIter
  00049	48 8b f0	 mov	 rsi, rax

; 1072 :     if (iter == NULL)

  0004c	48 85 c0	 test	 rax, rax
  0004f	0f 84 70 04 00
	00		 je	 $LN31@math_fsum
$LN56@math_fsum:
  00055	48 89 9c 24 c0
	01 00 00	 mov	 QWORD PTR [rsp+448], rbx
  0005d	0f 29 b4 24 90
	01 00 00	 movaps	 XMMWORD PTR [rsp+400], xmm6

; 1073 :         return NULL;
; 1074 : 
; 1075 :     PyFPE_START_PROTECT("fsum", Py_DECREF(iter); return NULL)
; 1076 : 
; 1077 :     for(;;) {           /* for x in iterable */
; 1078 :         assert(0 <= n && n <= m);
; 1079 :         assert((m == NUM_PARTIALS && p == ps) ||
; 1080 :                (m >  NUM_PARTIALS && p != NULL));
; 1081 : 
; 1082 :         item = PyIter_Next(iter);

  00065	48 8b c8	 mov	 rcx, rax
  00068	0f 29 bc 24 80
	01 00 00	 movaps	 XMMWORD PTR [rsp+384], xmm7
  00070	44 0f 29 8c 24
	60 01 00 00	 movaps	 XMMWORD PTR [rsp+352], xmm9
  00079	e8 00 00 00 00	 call	 PyIter_Next
  0007e	48 8b d8	 mov	 rbx, rax

; 1083 :         if (item == NULL) {

  00081	48 85 c0	 test	 rax, rax
  00084	0f 84 ef 01 00
	00		 je	 $LN59@math_fsum
  0008a	f2 44 0f 10 0d
	00 00 00 00	 movsdx	 xmm9, QWORD PTR __mask@@AbsDouble@
$LL29@math_fsum:

; 1085 :                 goto _fsum_error;
; 1086 :             break;
; 1087 :         }
; 1088 :         x = PyFloat_AsDouble(item);

  00093	48 8b cb	 mov	 rcx, rbx
  00096	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0009b	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1089 :         Py_DECREF(item);

  0009f	e8 00 00 00 00	 call	 _Py_PXCTX
  000a4	85 c0		 test	 eax, eax
  000a6	75 5c		 jne	 SHORT $LN43@math_fsum
  000a8	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ac	a8 20		 test	 al, 32			; 00000020H
  000ae	75 4c		 jne	 SHORT $LN37@math_fsum
  000b0	84 c0		 test	 al, al
  000b2	78 48		 js	 SHORT $LN37@math_fsum
  000b4	a8 02		 test	 al, 2
  000b6	75 4c		 jne	 SHORT $LN43@math_fsum
  000b8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000bc	75 46		 jne	 SHORT $LN43@math_fsum
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000cc	4c 8b cb	 mov	 r9, rbx
  000cf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000dd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e2	48 8b cb	 mov	 rcx, rbx
  000e5	85 c0		 test	 eax, eax
  000e7	74 07		 je	 SHORT $LN42@math_fsum
  000e9	e8 00 00 00 00	 call	 _Px_Dealloc
  000ee	eb 14		 jmp	 SHORT $LN43@math_fsum
$LN42@math_fsum:
  000f0	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000fa	eb 08		 jmp	 SHORT $LN43@math_fsum
$LN37@math_fsum:
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 Px_DecRef
$LN43@math_fsum:

; 1090 :         if (PyErr_Occurred())

  00104	e8 00 00 00 00	 call	 PyErr_Occurred
  00109	48 85 c0	 test	 rax, rax
  0010c	0f 85 13 03 00
	00		 jne	 $_fsum_error$20778

; 1091 :             goto _fsum_error;
; 1092 : 
; 1093 :         xsave = x;

  00112	66 0f 28 fe	 movapd	 xmm7, xmm6

; 1094 :         for (i = j = 0; j < n; j++) {       /* for y in partials */

  00116	48 8b cd	 mov	 rcx, rbp
  00119	48 8b dd	 mov	 rbx, rbp
  0011c	48 85 ff	 test	 rdi, rdi
  0011f	0f 8e ab 00 00
	00		 jle	 $LN72@math_fsum
  00125	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL24@math_fsum:

; 1095 :             y = p[j];

  00130	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]

; 1096 :             if (fabs(x) < fabs(y)) {

  00138	66 0f 28 ce	 movapd	 xmm1, xmm6
  0013c	66 41 0f 54 c9	 andpd	 xmm1, xmm9
  00141	f2 0f 10 14 c8	 movsdx	 xmm2, QWORD PTR [rax+rcx*8]
  00146	66 0f 28 c2	 movapd	 xmm0, xmm2
  0014a	66 41 0f 54 c1	 andpd	 xmm0, xmm9
  0014f	66 0f 2f c1	 comisd	 xmm0, xmm1
  00153	76 0c		 jbe	 SHORT $LN21@math_fsum

; 1097 :                 t = x; x = y; y = t;

  00155	66 0f 28 c6	 movapd	 xmm0, xmm6
  00159	66 0f 28 f2	 movapd	 xmm6, xmm2
  0015d	66 0f 28 d0	 movapd	 xmm2, xmm0
$LN21@math_fsum:

; 1098 :             }
; 1099 :             hi = x + y;

  00161	66 0f 28 c2	 movapd	 xmm0, xmm2
  00165	f2 0f 58 c6	 addsd	 xmm0, xmm6
  00169	f2 0f 11 84 24
	d0 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1100 :             yr = hi - x;

  00172	f2 0f 10 8c 24
	d0 01 00 00	 movsdx	 xmm1, QWORD PTR hi$[rsp]
  0017b	f2 0f 5c ce	 subsd	 xmm1, xmm6
  0017f	f2 0f 11 4c 24
	30		 movsdx	 QWORD PTR yr$[rsp], xmm1

; 1101 :             lo = y - yr;

  00185	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR yr$[rsp]
  0018b	f2 0f 5c d0	 subsd	 xmm2, xmm0
  0018f	f2 0f 11 54 24
	30		 movsdx	 QWORD PTR lo$[rsp], xmm2

; 1102 :             if (lo != 0.0)

  00195	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  0019b	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  001a0	7a 02		 jp	 SHORT $LN67@math_fsum
  001a2	74 17		 je	 SHORT $LN20@math_fsum
$LN67@math_fsum:

; 1103 :                 p[i++] = lo;

  001a4	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  001aa	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001b2	48 ff c3	 inc	 rbx
  001b5	f2 0f 11 44 d8
	f8		 movsdx	 QWORD PTR [rax+rbx*8-8], xmm0
$LN20@math_fsum:

; 1104 :             x = hi;

  001bb	f2 0f 10 b4 24
	d0 01 00 00	 movsdx	 xmm6, QWORD PTR hi$[rsp]
  001c4	48 ff c1	 inc	 rcx
  001c7	48 3b cf	 cmp	 rcx, rdi
  001ca	0f 8c 60 ff ff
	ff		 jl	 $LL24@math_fsum
$LN72@math_fsum:

; 1105 :         }
; 1106 : 
; 1107 :         n = i;                              /* ps[i:] = [x] */
; 1108 :         if (x != 0.0) {

  001d0	66 41 0f 2e f0	 ucomisd xmm6, xmm8
  001d5	48 8b fb	 mov	 rdi, rbx
  001d8	7a 06		 jp	 SHORT $LN66@math_fsum
  001da	0f 84 85 00 00
	00		 je	 $LN13@math_fsum
$LN66@math_fsum:

; 1109 :             if (! Py_IS_FINITE(x)) {

  001e0	66 0f 28 c6	 movapd	 xmm0, xmm6
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001ea	85 c0		 test	 eax, eax
  001ec	75 3d		 jne	 SHORT $LN18@math_fsum

; 1110 :                 /* a nonfinite x could arise either as
; 1111 :                    a result of intermediate overflow, or
; 1112 :                    as a result of a nan or inf in the
; 1113 :                    summands */
; 1114 :                 if (Py_IS_FINITE(xsave)) {

  001ee	66 0f 28 c7	 movapd	 xmm0, xmm7
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001f8	85 c0		 test	 eax, eax
  001fa	0f 85 3f 01 00
	00		 jne	 $LN61@math_fsum

; 1117 :                     goto _fsum_error;
; 1118 :                 }
; 1119 :                 if (Py_IS_INFINITY(xsave))

  00200	66 0f 28 c7	 movapd	 xmm0, xmm7
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0020a	85 c0		 test	 eax, eax
  0020c	75 13		 jne	 SHORT $LN16@math_fsum
  0020e	66 0f 28 c7	 movapd	 xmm0, xmm7
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00218	85 c0		 test	 eax, eax
  0021a	75 05		 jne	 SHORT $LN16@math_fsum

; 1120 :                     inf_sum += xsave;

  0021c	f2 44 0f 58 df	 addsd	 xmm11, xmm7
$LN16@math_fsum:

; 1121 :                 special_sum += xsave;

  00221	f2 44 0f 58 d7	 addsd	 xmm10, xmm7

; 1122 :                 /* reset partials */
; 1123 :                 n = 0;

  00226	48 8b fd	 mov	 rdi, rbp
  00229	eb 3a		 jmp	 SHORT $LN13@math_fsum
$LN18@math_fsum:

; 1124 :             }
; 1125 :             else if (n >= m && _fsum_realloc(&p, n, ps, &m))

  0022b	48 3b 5c 24 38	 cmp	 rbx, QWORD PTR m$[rsp]
  00230	7c 22		 jl	 SHORT $LN14@math_fsum
  00232	4c 8d 4c 24 38	 lea	 r9, QWORD PTR m$[rsp]
  00237	4c 8d 44 24 40	 lea	 r8, QWORD PTR ps$[rsp]
  0023c	48 8d 8c 24 d8
	01 00 00	 lea	 rcx, QWORD PTR p$[rsp]
  00244	48 8b d3	 mov	 rdx, rbx
  00247	e8 00 00 00 00	 call	 _fsum_realloc
  0024c	85 c0		 test	 eax, eax
  0024e	0f 85 d1 01 00
	00		 jne	 $_fsum_error$20778
$LN14@math_fsum:

; 1126 :                 goto _fsum_error;
; 1127 :             else
; 1128 :                 p[n++] = x;

  00254	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0025c	48 8d 7b 01	 lea	 rdi, QWORD PTR [rbx+1]
  00260	f2 0f 11 34 d8	 movsdx	 QWORD PTR [rax+rbx*8], xmm6
$LN13@math_fsum:

; 1073 :         return NULL;
; 1074 : 
; 1075 :     PyFPE_START_PROTECT("fsum", Py_DECREF(iter); return NULL)
; 1076 : 
; 1077 :     for(;;) {           /* for x in iterable */
; 1078 :         assert(0 <= n && n <= m);
; 1079 :         assert((m == NUM_PARTIALS && p == ps) ||
; 1080 :                (m >  NUM_PARTIALS && p != NULL));
; 1081 : 
; 1082 :         item = PyIter_Next(iter);

  00265	48 8b ce	 mov	 rcx, rsi
  00268	e8 00 00 00 00	 call	 PyIter_Next
  0026d	48 8b d8	 mov	 rbx, rax

; 1083 :         if (item == NULL) {

  00270	48 85 c0	 test	 rax, rax
  00273	0f 85 1a fe ff
	ff		 jne	 $LL29@math_fsum
$LN59@math_fsum:

; 1084 :             if (PyErr_Occurred())

  00279	e8 00 00 00 00	 call	 PyErr_Occurred
  0027e	48 85 c0	 test	 rax, rax
  00281	0f 85 9e 01 00
	00		 jne	 $_fsum_error$20778

; 1129 :         }
; 1130 :     }
; 1131 : 
; 1132 :     if (special_sum != 0.0) {

  00287	66 45 0f 2e d0	 ucomisd xmm10, xmm8
  0028c	0f 8a 62 01 00
	00		 jp	 $LN65@math_fsum
  00292	0f 85 5c 01 00
	00		 jne	 $LN65@math_fsum

; 1138 :         goto _fsum_error;
; 1139 :     }
; 1140 : 
; 1141 :     hi = 0.0;

  00298	f2 44 0f 11 84
	24 d0 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm8

; 1142 :     if (n > 0) {

  002a2	48 85 ff	 test	 rdi, rdi
  002a5	0f 8e 3e 01 00
	00		 jle	 $LN2@math_fsum

; 1143 :         hi = p[--n];

  002ab	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  002b3	48 ff cf	 dec	 rdi
  002b6	f2 0f 10 04 f8	 movsdx	 xmm0, QWORD PTR [rax+rdi*8]
  002bb	f2 0f 11 84 24
	d0 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1144 :         /* sum_exact(ps, hi) from the top, stop when the sum becomes
; 1145 :            inexact. */
; 1146 :         while (n > 0) {

  002c4	48 85 ff	 test	 rdi, rdi
  002c7	0f 8e 1c 01 00
	00		 jle	 $LN2@math_fsum
  002cd	0f 1f 00	 npad	 3
$LL8@math_fsum:

; 1147 :             x = hi;

  002d0	f2 0f 10 94 24
	d0 01 00 00	 movsdx	 xmm2, QWORD PTR hi$[rsp]

; 1148 :             y = p[--n];

  002d9	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  002e1	48 ff cf	 dec	 rdi
  002e4	f2 0f 10 1c f8	 movsdx	 xmm3, QWORD PTR [rax+rdi*8]

; 1149 :             assert(fabs(y) < fabs(x));
; 1150 :             hi = x + y;

  002e9	66 0f 28 c3	 movapd	 xmm0, xmm3
  002ed	f2 0f 58 c2	 addsd	 xmm0, xmm2
  002f1	f2 0f 11 84 24
	d0 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1151 :             yr = hi - x;

  002fa	f2 0f 10 8c 24
	d0 01 00 00	 movsdx	 xmm1, QWORD PTR hi$[rsp]
  00303	f2 0f 5c ca	 subsd	 xmm1, xmm2
  00307	f2 0f 11 4c 24
	30		 movsdx	 QWORD PTR yr$[rsp], xmm1

; 1152 :             lo = y - yr;

  0030d	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR yr$[rsp]
  00313	f2 0f 5c d8	 subsd	 xmm3, xmm0
  00317	f2 0f 11 5c 24
	30		 movsdx	 QWORD PTR lo$[rsp], xmm3

; 1153 :             if (lo != 0.0)

  0031d	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  00323	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  00328	7a 2d		 jp	 SHORT $LN63@math_fsum
  0032a	75 2b		 jne	 SHORT $LN63@math_fsum

; 1144 :         /* sum_exact(ps, hi) from the top, stop when the sum becomes
; 1145 :            inexact. */
; 1146 :         while (n > 0) {

  0032c	48 85 ff	 test	 rdi, rdi
  0032f	7f 9f		 jg	 SHORT $LL8@math_fsum

; 1168 :         }
; 1169 :     }
; 1170 :     sum = PyFloat_FromDouble(hi);

  00331	f2 0f 10 84 24
	d0 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  0033a	e9 de 00 00 00	 jmp	 $LN73@math_fsum
$LN61@math_fsum:

; 1115 :                     PyErr_SetString(PyExc_OverflowError,
; 1116 :                           "intermediate overflow in fsum");

  0033f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00346	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@
  0034d	e8 00 00 00 00	 call	 PyErr_SetString
  00352	e9 ce 00 00 00	 jmp	 $_fsum_error$20778
$LN63@math_fsum:

; 1154 :                 break;
; 1155 :         }
; 1156 :         /* Make half-even rounding work across multiple partials.
; 1157 :            Needed so that sum([1e-16, 1, 1e16]) will round-up the last
; 1158 :            digit to two instead of down to zero (the 1e-16 makes the 1
; 1159 :            slightly closer to two).  With a potential 1 ULP rounding
; 1160 :            error fixed-up, math.fsum() can guarantee commutativity. */
; 1161 :         if (n > 0 && ((lo < 0.0 && p[n-1] < 0.0) ||
; 1162 :                       (lo > 0.0 && p[n-1] > 0.0))) {

  00357	48 85 ff	 test	 rdi, rdi
  0035a	0f 8e 89 00 00
	00		 jle	 $LN2@math_fsum
  00360	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  00366	66 44 0f 2f c0	 comisd	 xmm8, xmm0
  0036b	76 11		 jbe	 SHORT $LN3@math_fsum
  0036d	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00375	66 44 0f 2f 44
	f8 f8		 comisd	 xmm8, QWORD PTR [rax+rdi*8-8]
  0037c	77 22		 ja	 SHORT $LN4@math_fsum
$LN3@math_fsum:
  0037e	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  00384	66 41 0f 2f c0	 comisd	 xmm0, xmm8
  00389	76 5e		 jbe	 SHORT $LN2@math_fsum
  0038b	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00393	f2 0f 10 44 f8
	f8		 movsdx	 xmm0, QWORD PTR [rax+rdi*8-8]
  00399	66 41 0f 2f c0	 comisd	 xmm0, xmm8
  0039e	76 49		 jbe	 SHORT $LN2@math_fsum
$LN4@math_fsum:

; 1163 :             y = lo * 2.0;

  003a0	f2 0f 10 54 24
	30		 movsdx	 xmm2, QWORD PTR lo$[rsp]
  003a6	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@4000000000000000

; 1164 :             x = hi + y;

  003ae	66 0f 28 da	 movapd	 xmm3, xmm2
  003b2	f2 0f 58 9c 24
	d0 01 00 00	 addsd	 xmm3, QWORD PTR hi$[rsp]

; 1165 :             yr = x - hi;

  003bb	f2 0f 10 84 24
	d0 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  003c4	66 0f 28 cb	 movapd	 xmm1, xmm3
  003c8	f2 0f 5c c8	 subsd	 xmm1, xmm0
  003cc	f2 0f 11 4c 24
	30		 movsdx	 QWORD PTR yr$[rsp], xmm1

; 1166 :             if (y == yr)

  003d2	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR yr$[rsp]
  003d8	66 0f 2e d0	 ucomisd xmm2, xmm0
  003dc	7a 0b		 jp	 SHORT $LN2@math_fsum
  003de	75 09		 jne	 SHORT $LN2@math_fsum

; 1167 :                 hi = x;

  003e0	f2 0f 11 9c 24
	d0 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm3
$LN2@math_fsum:

; 1168 :         }
; 1169 :     }
; 1170 :     sum = PyFloat_FromDouble(hi);

  003e9	f2 0f 10 84 24
	d0 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  003f2	eb 29		 jmp	 SHORT $LN73@math_fsum
$LN65@math_fsum:

; 1133 :         if (Py_IS_NAN(inf_sum))

  003f4	66 41 0f 28 c3	 movapd	 xmm0, xmm11
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  003ff	85 c0		 test	 eax, eax
  00401	74 15		 je	 SHORT $LN11@math_fsum

; 1134 :             PyErr_SetString(PyExc_ValueError,
; 1135 :                             "-inf + inf in fsum");

  00403	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0040a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@
  00411	e8 00 00 00 00	 call	 PyErr_SetString

; 1136 :         else

  00416	eb 0d		 jmp	 SHORT $_fsum_error$20778
$LN11@math_fsum:

; 1137 :             sum = PyFloat_FromDouble(special_sum);

  00418	66 41 0f 28 c2	 movapd	 xmm0, xmm10
$LN73@math_fsum:
  0041d	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00422	48 8b e8	 mov	 rbp, rax
$_fsum_error$20778:

; 1171 : 
; 1172 : _fsum_error:
; 1173 :     PyFPE_END_PROTECT(hi)
; 1174 :     Py_DECREF(iter);

  00425	e8 00 00 00 00	 call	 _Py_PXCTX
  0042a	44 0f 28 8c 24
	60 01 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+352]
  00433	0f 28 bc 24 80
	01 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+384]
  0043b	48 8b 9c 24 c0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+448]
  00443	0f 28 b4 24 90
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+400]
  0044b	85 c0		 test	 eax, eax
  0044d	75 5c		 jne	 SHORT $LN54@math_fsum
  0044f	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00453	a8 20		 test	 al, 32			; 00000020H
  00455	75 4c		 jne	 SHORT $LN48@math_fsum
  00457	84 c0		 test	 al, al
  00459	78 48		 js	 SHORT $LN48@math_fsum
  0045b	a8 02		 test	 al, 2
  0045d	75 4c		 jne	 SHORT $LN54@math_fsum
  0045f	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00463	75 46		 jne	 SHORT $LN54@math_fsum
  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0046c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00473	4c 8b ce	 mov	 r9, rsi
  00476	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0047c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00484	e8 00 00 00 00	 call	 _PyParallel_Guard
  00489	48 8b ce	 mov	 rcx, rsi
  0048c	85 c0		 test	 eax, eax
  0048e	74 07		 je	 SHORT $LN53@math_fsum
  00490	e8 00 00 00 00	 call	 _Px_Dealloc
  00495	eb 14		 jmp	 SHORT $LN54@math_fsum
$LN53@math_fsum:
  00497	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0049b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  004a1	eb 08		 jmp	 SHORT $LN54@math_fsum
$LN48@math_fsum:
  004a3	48 8b ce	 mov	 rcx, rsi
  004a6	e8 00 00 00 00	 call	 Px_DecRef
$LN54@math_fsum:

; 1175 :     if (p != ps)

  004ab	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  004b3	48 8d 44 24 40	 lea	 rax, QWORD PTR ps$[rsp]
  004b8	48 3b c8	 cmp	 rcx, rax
  004bb	74 05		 je	 SHORT $LN1@math_fsum

; 1176 :         PyMem_Free(p);

  004bd	e8 00 00 00 00	 call	 PyMem_Free
$LN1@math_fsum:

; 1177 :     return sum;

  004c2	48 8b c5	 mov	 rax, rbp
$LN31@math_fsum:

; 1178 : }

  004c5	4c 8d 9c 24 a0
	01 00 00	 lea	 r11, QWORD PTR [rsp+416]
  004cd	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  004d2	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  004d7	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  004dc	49 8b e3	 mov	 rsp, r11
  004df	5f		 pop	 rdi
  004e0	5e		 pop	 rsi
  004e1	5d		 pop	 rbp
  004e2	c3		 ret	 0
math_fsum ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bit_length
_TEXT	SEGMENT
n$ = 8
bit_length PROC						; COMDAT

; 1201 :     unsigned long len = 0;

  00000	33 c0		 xor	 eax, eax

; 1202 :     while (n != 0) {

  00002	85 c9		 test	 ecx, ecx
  00004	74 06		 je	 SHORT $LN7@bit_length
$LL2@bit_length:

; 1203 :         ++len;

  00006	ff c0		 inc	 eax

; 1204 :         n >>= 1;

  00008	d1 e9		 shr	 ecx, 1
  0000a	75 fa		 jne	 SHORT $LL2@bit_length
$LN7@bit_length:

; 1205 :     }
; 1206 :     return len;
; 1207 : }

  0000c	f3 c3		 fatret	 0
bit_length ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT count_set_bits
_TEXT	SEGMENT
n$ = 8
count_set_bits PROC					; COMDAT

; 1212 :     unsigned long count = 0;

  00000	33 c0		 xor	 eax, eax

; 1213 :     while (n != 0) {

  00002	85 c9		 test	 ecx, ecx
  00004	74 09		 je	 SHORT $LN7@count_set_
$LL2@count_set_:

; 1214 :         ++count;
; 1215 :         n &= n - 1; /* clear least significant bit */

  00006	8d 51 ff	 lea	 edx, DWORD PTR [rcx-1]
  00009	ff c0		 inc	 eax
  0000b	23 ca		 and	 ecx, edx
  0000d	75 f7		 jne	 SHORT $LL2@count_set_
$LN7@count_set_:

; 1216 :     }
; 1217 :     return count;
; 1218 : }

  0000f	f3 c3		 fatret	 0
count_set_bits ENDP
_TEXT	ENDS
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$factorial_partial_product DD imagerel factorial_partial_product
	DD	imagerel factorial_partial_product+414
	DD	imagerel $unwind$factorial_partial_product
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factorial_partial_product DD 086b01H
	DD	09746bH
	DD	085462H
	DD	0a340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\mathmodule.c
xdata	ENDS
;	COMDAT factorial_partial_product
_TEXT	SEGMENT
start$ = 64
stop$ = 72
max_bits$ = 80
result$1$ = 88
factorial_partial_product PROC				; COMDAT

; 1292 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	44 8b c9	 mov	 r9d, ecx

; 1293 :     unsigned long midpoint, num_operands;
; 1294 :     PyObject *left = NULL, *right = NULL, *result = NULL;
; 1295 : 
; 1296 :     /* If the return value will fit an unsigned long, then we can
; 1297 :      * multiply in a tight, fast loop where each multiply is O(1).
; 1298 :      * Compute an upper bound on the number of bits required to store
; 1299 :      * the answer.
; 1300 :      *
; 1301 :      * Storing some integer z requires floor(lg(z))+1 bits, which is
; 1302 :      * conveniently the value returned by bit_length(z).  The
; 1303 :      * product x*y will require at most
; 1304 :      * bit_length(x) + bit_length(y) bits to store, based
; 1305 :      * on the idea that lg product = lg x + lg y.
; 1306 :      *
; 1307 :      * We know that stop - 2 is the largest number to be multiplied.  From
; 1308 :      * there, we have: bit_length(answer) <= num_operands *
; 1309 :      * bit_length(stop - 2)
; 1310 :      */
; 1311 : 
; 1312 :     num_operands = (stop - start) / 2;

  0000d	8b ca		 mov	 ecx, edx
  0000f	41 8b f0	 mov	 esi, r8d
  00012	41 2b c9	 sub	 ecx, r9d
  00015	8b da		 mov	 ebx, edx
  00017	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR result$1$[rsp], 0
  00020	d1 e9		 shr	 ecx, 1

; 1313 :     /* The "num_operands <= 8 * SIZEOF_LONG" check guards against the
; 1314 :      * unlikely case of an overflow in num_operands * max_bits. */
; 1315 :     if (num_operands <= 8 * SIZEOF_LONG &&
; 1316 :         num_operands * max_bits <= 8 * SIZEOF_LONG) {

  00022	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00025	77 36		 ja	 SHORT $LN14@factorial_
  00027	8b c1		 mov	 eax, ecx
  00029	0f af c6	 imul	 eax, esi
  0002c	83 f8 20	 cmp	 eax, 32			; 00000020H
  0002f	77 2c		 ja	 SHORT $LN14@factorial_

; 1317 :         unsigned long j, total;
; 1318 :         for (total = start, j = start + 2; j < stop; j += 2)

  00031	41 8d 41 02	 lea	 eax, DWORD PTR [r9+2]
  00035	3b c2		 cmp	 eax, edx
  00037	73 12		 jae	 SHORT $LN11@factorial_
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@factorial_:

; 1319 :             total *= j;

  00040	44 0f af c8	 imul	 r9d, eax
  00044	83 c0 02	 add	 eax, 2
  00047	3b c2		 cmp	 eax, edx
  00049	72 f5		 jb	 SHORT $LL13@factorial_
$LN11@factorial_:

; 1320 :         return PyLong_FromUnsignedLong(total);

  0004b	41 8b c9	 mov	 ecx, r9d

; 1338 : }

  0004e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5e		 pop	 rsi
  00058	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
$LN14@factorial_:
  0005d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1321 :     }
; 1322 : 
; 1323 :     /* find midpoint of range(start, stop), rounded up to next odd number. */
; 1324 :     midpoint = (start + num_operands) | 1;

  00062	42 8d 2c 09	 lea	 ebp, DWORD PTR [rcx+r9]
  00066	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0006b	83 cd 01	 or	 ebp, 1

; 1325 :     left = factorial_partial_product(start, midpoint,
; 1326 :                                      bit_length(midpoint - 2));

  0006e	8d 4d fe	 lea	 ecx, DWORD PTR [rbp-2]
  00071	e8 00 00 00 00	 call	 bit_length
  00076	8b d5		 mov	 edx, ebp
  00078	41 8b c9	 mov	 ecx, r9d
  0007b	44 8b c0	 mov	 r8d, eax
  0007e	e8 00 00 00 00	 call	 factorial_partial_product
  00083	48 8b f8	 mov	 rdi, rax

; 1327 :     if (left == NULL)

  00086	48 85 c0	 test	 rax, rax
  00089	0f 84 f5 00 00
	00		 je	 $LN3@factorial_

; 1328 :         goto error;
; 1329 :     right = factorial_partial_product(midpoint, stop, max_bits);

  0008f	44 8b c6	 mov	 r8d, esi
  00092	8b d3		 mov	 edx, ebx
  00094	8b cd		 mov	 ecx, ebp
  00096	e8 00 00 00 00	 call	 factorial_partial_product
  0009b	48 8b d8	 mov	 rbx, rax

; 1330 :     if (right == NULL)

  0009e	48 85 c0	 test	 rax, rax
  000a1	74 10		 je	 SHORT $error$20851

; 1331 :         goto error;
; 1332 :     result = PyNumber_Multiply(left, right);

  000a3	48 8b d0	 mov	 rdx, rax
  000a6	48 8b cf	 mov	 rcx, rdi
  000a9	e8 00 00 00 00	 call	 PyNumber_Multiply
  000ae	48 89 44 24 58	 mov	 QWORD PTR result$1$[rsp], rax
$error$20851:

; 1333 : 
; 1334 :   error:
; 1335 :     Py_XDECREF(left);

  000b3	e8 00 00 00 00	 call	 _Py_PXCTX
  000b8	85 c0		 test	 eax, eax
  000ba	75 5e		 jne	 SHORT $LN7@factorial_
  000bc	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000c0	f6 c1 20	 test	 cl, 32			; 00000020H
  000c3	75 4d		 jne	 SHORT $LN21@factorial_
  000c5	84 c9		 test	 cl, cl
  000c7	78 49		 js	 SHORT $LN21@factorial_
  000c9	f6 c1 02	 test	 cl, 2
  000cc	75 4c		 jne	 SHORT $LN7@factorial_
  000ce	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000d2	75 46		 jne	 SHORT $LN7@factorial_
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000e2	4c 8b cf	 mov	 r9, rdi
  000e5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000eb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f8	48 8b cf	 mov	 rcx, rdi
  000fb	85 c0		 test	 eax, eax
  000fd	74 07		 je	 SHORT $LN26@factorial_
  000ff	e8 00 00 00 00	 call	 _Px_Dealloc
  00104	eb 14		 jmp	 SHORT $LN7@factorial_
$LN26@factorial_:
  00106	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0010a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00110	eb 08		 jmp	 SHORT $LN7@factorial_
$LN21@factorial_:
  00112	48 8b cf	 mov	 rcx, rdi
  00115	e8 00 00 00 00	 call	 Px_DecRef
$LN7@factorial_:

; 1336 :     Py_XDECREF(right);

  0011a	48 85 db	 test	 rbx, rbx
  0011d	74 65		 je	 SHORT $LN3@factorial_
  0011f	e8 00 00 00 00	 call	 _Py_PXCTX
  00124	85 c0		 test	 eax, eax
  00126	75 5c		 jne	 SHORT $LN3@factorial_
  00128	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0012c	a8 20		 test	 al, 32			; 00000020H
  0012e	75 4c		 jne	 SHORT $LN32@factorial_
  00130	84 c0		 test	 al, al
  00132	78 48		 js	 SHORT $LN32@factorial_
  00134	a8 02		 test	 al, 2
  00136	75 4c		 jne	 SHORT $LN3@factorial_
  00138	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0013c	75 46		 jne	 SHORT $LN3@factorial_
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014c	4c 8b cb	 mov	 r9, rbx
  0014f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00155	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00162	48 8b cb	 mov	 rcx, rbx
  00165	85 c0		 test	 eax, eax
  00167	74 07		 je	 SHORT $LN37@factorial_
  00169	e8 00 00 00 00	 call	 _Px_Dealloc
  0016e	eb 14		 jmp	 SHORT $LN3@factorial_
$LN37@factorial_:
  00170	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00174	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0017a	eb 08		 jmp	 SHORT $LN3@factorial_
$LN32@factorial_:
  0017c	48 8b cb	 mov	 rcx, rbx
  0017f	e8 00 00 00 00	 call	 Px_DecRef
$LN3@factorial_:

; 1337 :     return result;

  00184	48 8b 44 24 58	 mov	 rax, QWORD PTR result$1$[rsp]
  00189	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0018e	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1338 : }

  00193	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00198	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019c	5e		 pop	 rsi
  0019d	c3		 ret	 0
factorial_partial_product ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$factorial_odd_part DD imagerel factorial_odd_part
	DD	imagerel factorial_odd_part+455
	DD	imagerel $unwind$factorial_odd_part
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factorial_odd_part DD 0d8501H
	DD	0dc485H
	DD	0a547aH
	DD	06e434H
	DD	0c742fH
	DD	0b642aH
	DD	0d0046208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\mathmodule.c
xdata	ENDS
;	COMDAT factorial_odd_part
_TEXT	SEGMENT
n$ = 80
factorial_odd_part PROC					; COMDAT

; 1344 : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	44 8b e9	 mov	 r13d, ecx

; 1345 :     long i;
; 1346 :     unsigned long v, lower, upper;
; 1347 :     PyObject *partial, *tmp, *inner, *outer;
; 1348 : 
; 1349 :     inner = PyLong_FromLong(1);

  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	e8 00 00 00 00	 call	 PyLong_FromLong
  00015	48 8b d8	 mov	 rbx, rax

; 1350 :     if (inner == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 08		 jne	 SHORT $LN8@factorial_@2

; 1393 : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	41 5d		 pop	 r13
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN8@factorial_@2:
  00025	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0002a	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0002f	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14

; 1351 :         return NULL;
; 1352 :     outer = inner;

  00034	48 8b f0	 mov	 rsi, rax

; 1353 :     Py_INCREF(outer);

  00037	e8 00 00 00 00	 call	 _Py_PXCTX
  0003c	85 c0		 test	 eax, eax
  0003e	75 32		 jne	 SHORT $LN12@factorial_@2
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004e	4c 8b cb	 mov	 r9, rbx
  00051	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00057	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00064	85 c0		 test	 eax, eax
  00066	75 06		 jne	 SHORT $LN11@factorial_@2
  00068	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0006c	74 04		 je	 SHORT $LN12@factorial_@2
$LN11@factorial_@2:
  0006e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@factorial_@2:

; 1354 : 
; 1355 :     upper = 3;
; 1356 :     for (i = bit_length(n) - 2; i >= 0; i--) {

  00072	41 8b cd	 mov	 ecx, r13d
  00075	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0007a	41 be 03 00 00
	00		 mov	 r14d, 3
  00080	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00085	e8 00 00 00 00	 call	 bit_length
  0008a	8b f8		 mov	 edi, eax
  0008c	83 ef 02	 sub	 edi, 2
  0008f	0f 88 95 00 00
	00		 js	 $LN31@factorial_@2
  00095	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@factorial_@2:

; 1357 :         v = n >> i;

  000a0	41 8b d5	 mov	 edx, r13d
  000a3	8b cf		 mov	 ecx, edi
  000a5	d3 ea		 shr	 edx, cl

; 1358 :         if (v <= 2)

  000a7	83 fa 02	 cmp	 edx, 2
  000aa	76 76		 jbe	 SHORT $LN6@factorial_@2

; 1359 :             continue;
; 1360 :         lower = upper;

  000ac	45 8b ce	 mov	 r9d, r14d

; 1361 :         /* (v + 1) | 1 = least odd integer strictly larger than n / 2**i */
; 1362 :         upper = (v + 1) | 1;

  000af	44 8d 72 01	 lea	 r14d, DWORD PTR [rdx+1]
  000b3	41 83 ce 01	 or	 r14d, 1

; 1363 :         /* Here inner is the product of all odd integers j in the range (0,
; 1364 :            n/2**(i+1)].  The factorial_partial_product call below gives the
; 1365 :            product of all odd integers j in the range (n/2**(i+1), n/2**i]. */
; 1366 :         partial = factorial_partial_product(lower, upper, bit_length(upper-2));

  000b7	41 8d 4e fe	 lea	 ecx, DWORD PTR [r14-2]
  000bb	e8 00 00 00 00	 call	 bit_length
  000c0	41 8b d6	 mov	 edx, r14d
  000c3	41 8b c9	 mov	 ecx, r9d
  000c6	44 8b c0	 mov	 r8d, eax
  000c9	e8 00 00 00 00	 call	 factorial_partial_product
  000ce	4c 8b e0	 mov	 r12, rax

; 1367 :         /* inner *= partial */
; 1368 :         if (partial == NULL)

  000d1	48 85 c0	 test	 rax, rax
  000d4	0f 84 a1 00 00
	00		 je	 $error$20886

; 1369 :             goto error;
; 1370 :         tmp = PyNumber_Multiply(inner, partial);

  000da	48 8b d0	 mov	 rdx, rax
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1371 :         Py_DECREF(partial);

  000e5	49 8b cc	 mov	 rcx, r12
  000e8	48 8b e8	 mov	 rbp, rax
  000eb	e8 00 00 00 00	 call	 _Py_DecRef

; 1372 :         if (tmp == NULL)

  000f0	48 85 ed	 test	 rbp, rbp
  000f3	0f 84 82 00 00
	00		 je	 $error$20886

; 1373 :             goto error;
; 1374 :         Py_DECREF(inner);

  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 _Py_DecRef

; 1375 :         inner = tmp;
; 1376 :         /* Now inner is the product of all odd integers j in the range (0,
; 1377 :            n/2**i], giving the inner product in the formula above. */
; 1378 : 
; 1379 :         /* outer *= inner; */
; 1380 :         tmp = PyNumber_Multiply(outer, inner);

  00101	48 8b d5	 mov	 rdx, rbp
  00104	48 8b ce	 mov	 rcx, rsi
  00107	48 8b dd	 mov	 rbx, rbp
  0010a	e8 00 00 00 00	 call	 PyNumber_Multiply
  0010f	48 8b e8	 mov	 rbp, rax

; 1381 :         if (tmp == NULL)

  00112	48 85 c0	 test	 rax, rax
  00115	74 64		 je	 SHORT $error$20886

; 1382 :             goto error;
; 1383 :         Py_DECREF(outer);

  00117	48 8b ce	 mov	 rcx, rsi
  0011a	e8 00 00 00 00	 call	 _Py_DecRef

; 1384 :         outer = tmp;

  0011f	48 8b f5	 mov	 rsi, rbp
$LN6@factorial_@2:

; 1354 : 
; 1355 :     upper = 3;
; 1356 :     for (i = bit_length(n) - 2; i >= 0; i--) {

  00122	ff cf		 dec	 edi
  00124	0f 89 76 ff ff
	ff		 jns	 $LL7@factorial_@2
$LN31@factorial_@2:

; 1385 :     }
; 1386 :     Py_DECREF(inner);

  0012a	e8 00 00 00 00	 call	 _Py_PXCTX
  0012f	85 c0		 test	 eax, eax
  00131	75 70		 jne	 SHORT $LN25@factorial_@2
  00133	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00137	a8 20		 test	 al, 32			; 00000020H
  00139	75 60		 jne	 SHORT $LN19@factorial_@2
  0013b	84 c0		 test	 al, al
  0013d	78 5c		 js	 SHORT $LN19@factorial_@2
  0013f	a8 02		 test	 al, 2
  00141	75 60		 jne	 SHORT $LN25@factorial_@2
  00143	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00147	75 5a		 jne	 SHORT $LN25@factorial_@2
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00157	4c 8b cb	 mov	 r9, rbx
  0015a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00160	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00168	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016d	48 8b cb	 mov	 rcx, rbx
  00170	85 c0		 test	 eax, eax
  00172	74 1b		 je	 SHORT $LN24@factorial_@2
  00174	e8 00 00 00 00	 call	 _Px_Dealloc
  00179	eb 28		 jmp	 SHORT $LN25@factorial_@2
$error$20886:

; 1388 : 
; 1389 :   error:
; 1390 :     Py_DECREF(outer);

  0017b	48 8b ce	 mov	 rcx, rsi
  0017e	e8 00 00 00 00	 call	 _Py_DecRef

; 1391 :     Py_DECREF(inner);

  00183	48 8b cb	 mov	 rcx, rbx
  00186	e8 00 00 00 00	 call	 _Py_DecRef

; 1392 :     return NULL;

  0018b	33 c0		 xor	 eax, eax
  0018d	eb 17		 jmp	 SHORT $LN36@factorial_@2

; 1385 :     }
; 1386 :     Py_DECREF(inner);

$LN24@factorial_@2:
  0018f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00193	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00199	eb 08		 jmp	 SHORT $LN25@factorial_@2
$LN19@factorial_@2:
  0019b	48 8b cb	 mov	 rcx, rbx
  0019e	e8 00 00 00 00	 call	 Px_DecRef
$LN25@factorial_@2:

; 1387 :     return outer;

  001a3	48 8b c6	 mov	 rax, rsi
$LN36@factorial_@2:
  001a6	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  001ab	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001b0	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001b5	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  001ba	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 1393 : }

  001bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c3	41 5d		 pop	 r13
  001c5	5b		 pop	 rbx
  001c6	c3		 ret	 0
factorial_odd_part ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@ ; `string'
PUBLIC	??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@ ; `string'
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_factorial DD imagerel math_factorial
	DD	imagerel math_factorial+267
	DD	imagerel $unwind$math_factorial
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$math_factorial DD imagerel math_factorial+267
	DD	imagerel math_factorial+325
	DD	imagerel $chain$0$math_factorial
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$math_factorial DD imagerel math_factorial+325
	DD	imagerel math_factorial+357
	DD	imagerel $chain$2$math_factorial
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$math_factorial DD imagerel math_factorial+357
	DD	imagerel math_factorial+394
	DD	imagerel $chain$3$math_factorial
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$math_factorial DD 021H
	DD	imagerel math_factorial
	DD	imagerel math_factorial+267
	DD	imagerel $unwind$math_factorial
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$math_factorial DD 020021H
	DD	086400H
	DD	imagerel math_factorial
	DD	imagerel math_factorial+267
	DD	imagerel $unwind$math_factorial
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$math_factorial DD 020521H
	DD	086405H
	DD	imagerel math_factorial
	DD	imagerel math_factorial+267
	DD	imagerel $unwind$math_factorial
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_factorial DD 061d01H
	DD	02681dH
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@
CONST	SEGMENT
??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@ DB 'factori'
	DB	'al() only accepts integral values', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@
CONST	SEGMENT
??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@ DB 'factor'
	DB	'ial() not defined for negative values', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_factorial
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_factorial PROC					; COMDAT

; 1409 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1410 :     long x;
; 1411 :     PyObject *result, *odd_part, *two_valuation;
; 1412 : 
; 1413 :     if (PyFloat_Check(arg)) {

  0000a	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00018	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001d	48 3b ca	 cmp	 rcx, rdx
  00020	74 15		 je	 SHORT $LN10@math_facto
  00022	e8 00 00 00 00	 call	 PyType_IsSubtype
  00027	85 c0		 test	 eax, eax
  00029	75 0c		 jne	 SHORT $LN10@math_facto

; 1426 :     }
; 1427 :     else
; 1428 :         x = PyLong_AsLong(arg);

  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	e8 00 00 00 00	 call	 PyLong_AsLong
  00033	8b d8		 mov	 ebx, eax
  00035	eb 53		 jmp	 SHORT $LN6@math_facto
$LN10@math_facto:

; 1414 :         PyObject *lx;
; 1415 :         double dx = PyFloat_AS_DOUBLE((PyFloatObject *)arg);

  00037	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]

; 1416 :         if (!(Py_IS_FINITE(dx) && dx == floor(dx))) {

  0003c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00046	85 c0		 test	 eax, eax
  00048	0f 84 17 01 00
	00		 je	 $LN8@math_facto
  0004e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00052	e8 00 00 00 00	 call	 floor
  00057	66 0f 2e f0	 ucomisd xmm6, xmm0
  0005b	0f 8a 04 01 00
	00		 jp	 $LN8@math_facto
  00061	0f 85 fe 00 00
	00		 jne	 $LN8@math_facto

; 1419 :             return NULL;
; 1420 :         }
; 1421 :         lx = PyLong_FromDouble(dx);

  00067	66 0f 28 c6	 movapd	 xmm0, xmm6
  0006b	e8 00 00 00 00	 call	 PyLong_FromDouble
  00070	48 8b f8	 mov	 rdi, rax

; 1422 :         if (lx == NULL)

  00073	48 85 c0	 test	 rax, rax

; 1423 :             return NULL;

  00076	74 21		 je	 SHORT $LN16@math_facto

; 1424 :         x = PyLong_AsLong(lx);

  00078	48 8b c8	 mov	 rcx, rax
  0007b	e8 00 00 00 00	 call	 PyLong_AsLong

; 1425 :         Py_DECREF(lx);

  00080	48 8b cf	 mov	 rcx, rdi
  00083	8b d8		 mov	 ebx, eax
  00085	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@math_facto:

; 1429 : 
; 1430 :     if (x == -1 && PyErr_Occurred())

  0008a	83 fb ff	 cmp	 ebx, -1
  0008d	75 1c		 jne	 SHORT $LN5@math_facto
  0008f	e8 00 00 00 00	 call	 PyErr_Occurred
  00094	48 85 c0	 test	 rax, rax
  00097	74 16		 je	 SHORT $LN14@math_facto
$LN16@math_facto:

; 1431 :         return NULL;

  00099	33 c0		 xor	 eax, eax

; 1456 : }

  0009b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a0	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
$LN5@math_facto:

; 1432 :     if (x < 0) {

  000ab	85 db		 test	 ebx, ebx
  000ad	79 25		 jns	 SHORT $LN4@math_facto
$LN14@math_facto:

; 1433 :         PyErr_SetString(PyExc_ValueError,
; 1434 :                         "factorial() not defined for negative values");

  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@
  000bd	e8 00 00 00 00	 call	 PyErr_SetString

; 1435 :         return NULL;

  000c2	33 c0		 xor	 eax, eax

; 1456 : }

  000c4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c9	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
$LN4@math_facto:

; 1436 :     }
; 1437 : 
; 1438 :     /* use lookup table if x is small */
; 1439 :     if (x < (long)Py_ARRAY_LENGTH(SmallFactorials))

  000d4	83 fb 0d	 cmp	 ebx, 13
  000d7	7d 21		 jge	 SHORT $LN3@math_facto

; 1440 :         return PyLong_FromUnsignedLong(SmallFactorials[x]);

  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SmallFactorials
  000e0	48 63 c3	 movsxd	 rax, ebx
  000e3	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]

; 1456 : }

  000e6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000eb	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000f0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f4	5f		 pop	 rdi
  000f5	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
$LN3@math_facto:

; 1441 : 
; 1442 :     /* else express in the form odd_part * 2**two_valuation, and compute as
; 1443 :        odd_part << two_valuation. */
; 1444 :     odd_part = factorial_odd_part(x);

  000fa	8b cb		 mov	 ecx, ebx
  000fc	e8 00 00 00 00	 call	 factorial_odd_part
  00101	48 8b f8	 mov	 rdi, rax

; 1445 :     if (odd_part == NULL)

  00104	48 85 c0	 test	 rax, rax

; 1446 :         return NULL;

  00107	74 90		 je	 SHORT $LN16@math_facto

; 1447 :     two_valuation = PyLong_FromLong(x - count_set_bits(x));

  00109	8b cb		 mov	 ecx, ebx
  0010b	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00110	e8 00 00 00 00	 call	 count_set_bits
  00115	2b d8		 sub	 ebx, eax
  00117	8b cb		 mov	 ecx, ebx
  00119	e8 00 00 00 00	 call	 PyLong_FromLong

; 1448 :     if (two_valuation == NULL) {
; 1449 :         Py_DECREF(odd_part);

  0011e	48 8b cf	 mov	 rcx, rdi
  00121	48 8b f0	 mov	 rsi, rax
  00124	48 85 c0	 test	 rax, rax
  00127	75 1c		 jne	 SHORT $LN1@math_facto
  00129	e8 00 00 00 00	 call	 _Py_DecRef

; 1450 :         return NULL;

  0012e	33 c0		 xor	 eax, eax
$LN15@math_facto:
  00130	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1456 : }

  00135	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0013a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	5f		 pop	 rdi
  00144	c3		 ret	 0
$LN1@math_facto:

; 1451 :     }
; 1452 :     result = PyNumber_Lshift(odd_part, two_valuation);

  00145	48 8b d0	 mov	 rdx, rax
  00148	e8 00 00 00 00	 call	 PyNumber_Lshift

; 1453 :     Py_DECREF(two_valuation);

  0014d	48 8b ce	 mov	 rcx, rsi
  00150	48 8b d8	 mov	 rbx, rax
  00153	e8 00 00 00 00	 call	 _Py_DecRef

; 1454 :     Py_DECREF(odd_part);

  00158	48 8b cf	 mov	 rcx, rdi
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 1455 :     return result;

  00160	48 8b c3	 mov	 rax, rbx
  00163	eb cb		 jmp	 SHORT $LN15@math_facto
$LN8@math_facto:

; 1417 :             PyErr_SetString(PyExc_ValueError,
; 1418 :                             "factorial() only accepts integral values");

  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@
  00173	e8 00 00 00 00	 call	 PyErr_SetString

; 1456 : }

  00178	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0017d	33 c0		 xor	 eax, eax
  0017f	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00184	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00188	5f		 pop	 rdi
  00189	c3		 ret	 0
math_factorial ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_trunc DD imagerel math_trunc
	DD	imagerel math_trunc+67
	DD	imagerel $unwind$math_trunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$math_trunc DD imagerel math_trunc+67
	DD	imagerel math_trunc+135
	DD	imagerel $chain$0$math_trunc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$math_trunc DD imagerel math_trunc+135
	DD	imagerel math_trunc+170
	DD	imagerel $chain$2$math_trunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$math_trunc DD 020021H
	DD	067400H
	DD	imagerel math_trunc
	DD	imagerel math_trunc+67
	DD	imagerel $unwind$math_trunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$math_trunc DD 020521H
	DD	067405H
	DD	imagerel math_trunc
	DD	imagerel math_trunc+67
	DD	imagerel $unwind$math_trunc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_trunc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@
CONST	SEGMENT
??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@ DB 'type %.'
	DB	'100s doesn''t define __trunc__ method', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_trunc
_TEXT	SEGMENT
self$ = 48
number$ = 56
math_trunc PROC						; COMDAT

; 1465 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1466 :     _Py_IDENTIFIER(__trunc__);
; 1467 :     PyObject *trunc, *result;
; 1468 : 
; 1469 :     if (Py_TYPE(number)->tp_dict == NULL) {

  00006	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 83 b9 60 01
	00 00 00	 cmp	 QWORD PTR [rcx+352], 0
  00015	75 11		 jne	 SHORT $LN3@math_trunc

; 1470 :         if (PyType_Ready(Py_TYPE(number)) < 0)

  00017	e8 00 00 00 00	 call	 PyType_Ready
  0001c	85 c0		 test	 eax, eax
  0001e	79 08		 jns	 SHORT $LN3@math_trunc

; 1471 :             return NULL;

  00020	33 c0		 xor	 eax, eax

; 1485 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN3@math_trunc:

; 1472 :     }
; 1473 : 
; 1474 :     trunc = _PyObject_LookupSpecial(number, &PyId___trunc__);

  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00037	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___trunc__@?1??math_trunc@@9@9
  0003c	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00048	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  0004d	48 8b f8	 mov	 rdi, rax

; 1475 :     if (trunc == NULL) {

  00050	48 85 c0	 test	 rax, rax
  00053	75 32		 jne	 SHORT $LN2@math_trunc

; 1476 :         if (!PyErr_Occurred())

  00055	e8 00 00 00 00	 call	 PyErr_Occurred
  0005a	48 85 c0	 test	 rax, rax
  0005d	75 1b		 jne	 SHORT $LN1@math_trunc

; 1477 :             PyErr_Format(PyExc_TypeError,
; 1478 :                          "type %.100s doesn't define __trunc__ method",
; 1479 :                          Py_TYPE(number)->tp_name);

  0005f	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@
  00071	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00075	e8 00 00 00 00	 call	 PyErr_Format
$LN1@math_trunc:

; 1480 :         return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1485 : }

  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
$LN2@math_trunc:

; 1481 :     }
; 1482 :     result = PyObject_CallFunctionObjArgs(trunc, NULL);

  00087	33 d2		 xor	 edx, edx
  00089	48 8b c8	 mov	 rcx, rax
  0008c	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 1483 :     Py_DECREF(trunc);

  00091	48 8b cf	 mov	 rcx, rdi
  00094	48 8b d8	 mov	 rbx, rax
  00097	e8 00 00 00 00	 call	 _Py_DecRef
  0009c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1484 :     return result;

  000a1	48 8b c3	 mov	 rax, rbx

; 1485 : }

  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
math_trunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_frexp DD imagerel math_frexp
	DD	imagerel math_frexp+174
	DD	imagerel $unwind$math_frexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_frexp DD 030c01H
	DD	02680cH
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@
CONST	SEGMENT
??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@ DB '(di)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_frexp
_TEXT	SEGMENT
self$ = 64
arg$ = 72
i$ = 80
math_frexp PROC						; COMDAT

; 1494 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1495 :     int i;
; 1496 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1497 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN5@math_frexp
  0001f	75 16		 jne	 SHORT $LN5@math_frexp
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN5@math_frexp

; 1498 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1510 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN5@math_frexp:

; 1499 :     /* deal with special cases directly, to sidestep platform
; 1500 :        differences */
; 1501 :     if (Py_IS_NAN(x) || Py_IS_INFINITY(x) || !x) {

  00037	66 0f 28 c6	 movapd	 xmm0, xmm6
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00041	85 c0		 test	 eax, eax
  00043	75 42		 jne	 SHORT $LN3@math_frexp
  00045	66 0f 28 c6	 movapd	 xmm0, xmm6
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0004f	85 c0		 test	 eax, eax
  00051	75 0e		 jne	 SHORT $LN2@math_frexp
  00053	66 0f 28 c6	 movapd	 xmm0, xmm6
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0005d	85 c0		 test	 eax, eax
  0005f	74 26		 je	 SHORT $LN3@math_frexp
$LN2@math_frexp:
  00061	66 0f 2e 35 00
	00 00 00	 ucomisd xmm6, QWORD PTR lanczos_den_coeffs
  00069	7a 02		 jp	 SHORT $LN8@math_frexp
  0006b	74 1a		 je	 SHORT $LN3@math_frexp
$LN8@math_frexp:

; 1503 :     }
; 1504 :     else {
; 1505 :         PyFPE_START_PROTECT("in math_frexp", return 0);
; 1506 :         x = frexp(x, &i);

  0006d	48 8d 54 24 50	 lea	 rdx, QWORD PTR i$[rsp]
  00072	66 0f 28 c6	 movapd	 xmm0, xmm6
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  0007c	44 8b 44 24 50	 mov	 r8d, DWORD PTR i$[rsp]
  00081	66 0f 28 f0	 movapd	 xmm6, xmm0
  00085	eb 08		 jmp	 SHORT $LN1@math_frexp
$LN3@math_frexp:

; 1502 :         i = 0;

  00087	45 33 c0	 xor	 r8d, r8d
  0008a	44 89 44 24 50	 mov	 DWORD PTR i$[rsp], r8d
$LN1@math_frexp:

; 1507 :         PyFPE_END_PROTECT(x);
; 1508 :     }
; 1509 :     return Py_BuildValue("(di)", x, i);

  0008f	66 0f 28 ce	 movapd	 xmm1, xmm6
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@
  0009a	66 48 0f 7e ca	 movd	 rdx, xmm1
  0009f	e8 00 00 00 00	 call	 Py_BuildValue

; 1510 : }

  000a4	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
math_frexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@ ; `string'
PUBLIC	??_C@_08IOHGEICH@dO?3ldexp?$AA@			; `string'
EXTRN	__imp_ldexp:PROC
EXTRN	PyLong_AsLongAndOverflow:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_ldexp DD imagerel math_ldexp
	DD	imagerel math_ldexp+67
	DD	imagerel $unwind$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$math_ldexp DD imagerel math_ldexp+67
	DD	imagerel math_ldexp+106
	DD	imagerel $chain$0$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$math_ldexp DD imagerel math_ldexp+106
	DD	imagerel math_ldexp+110
	DD	imagerel $chain$2$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$math_ldexp DD imagerel math_ldexp+110
	DD	imagerel math_ldexp+364
	DD	imagerel $chain$5$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$math_ldexp DD imagerel math_ldexp+364
	DD	imagerel math_ldexp+394
	DD	imagerel $chain$6$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$math_ldexp DD imagerel math_ldexp+394
	DD	imagerel math_ldexp+418
	DD	imagerel $chain$8$math_ldexp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$math_ldexp DD imagerel math_ldexp+418
	DD	imagerel math_ldexp+444
	DD	imagerel $chain$9$math_ldexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$math_ldexp DD 021H
	DD	imagerel math_ldexp
	DD	imagerel math_ldexp+67
	DD	imagerel $unwind$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$math_ldexp DD 040021H
	DD	046800H
	DD	0c3400H
	DD	imagerel math_ldexp
	DD	imagerel math_ldexp+67
	DD	imagerel $unwind$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$math_ldexp DD 020021H
	DD	046800H
	DD	imagerel math_ldexp+106
	DD	imagerel math_ldexp+110
	DD	imagerel $chain$2$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$math_ldexp DD 060f21H
	DD	03780fH
	DD	04680aH
	DD	0a7405H
	DD	imagerel math_ldexp+106
	DD	imagerel math_ldexp+110
	DD	imagerel $chain$2$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$math_ldexp DD 020021H
	DD	0c3400H
	DD	imagerel math_ldexp
	DD	imagerel math_ldexp+67
	DD	imagerel $unwind$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$math_ldexp DD 020521H
	DD	0c3405H
	DD	imagerel math_ldexp
	DD	imagerel math_ldexp+67
	DD	imagerel $unwind$math_ldexp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_ldexp DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@
CONST	SEGMENT
??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@ DB 'Expected an'
	DB	' int as second argument to ldexp.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOHGEICH@dO?3ldexp?$AA@
CONST	SEGMENT
??_C@_08IOHGEICH@dO?3ldexp?$AA@ DB 'dO:ldexp', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_ldexp
_TEXT	SEGMENT
oexp$ = 32
self$ = 96
args$ = 104
overflow$ = 112
x$ = 120
math_ldexp PROC						; COMDAT

; 1521 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1522 :     double x, r;
; 1523 :     PyObject *oexp;
; 1524 :     long exp;
; 1525 :     int overflow;
; 1526 :     if (! PyArg_ParseTuple(args, "dO:ldexp", &x, &oexp))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 20	 lea	 r9, QWORD PTR oexp$[rsp]
  0000c	4c 8d 44 24 78	 lea	 r8, QWORD PTR x$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IOHGEICH@dO?3ldexp?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax

; 1527 :         return NULL;

  0001f	0f 84 90 01 00
	00		 je	 $LN21@math_ldexp

; 1528 : 
; 1529 :     if (PyLong_Check(oexp)) {

  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR oexp$[rsp]
  0002a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002e	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00038	0f 84 64 01 00
	00		 je	 $LN13@math_ldexp

; 1530 :         /* on overflow, replace exponent with either LONG_MAX
; 1531 :            or LONG_MIN, depending on the sign. */
; 1532 :         exp = PyLong_AsLongAndOverflow(oexp, &overflow);

  0003e	48 8d 54 24 70	 lea	 rdx, QWORD PTR overflow$[rsp]
  00043	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00048	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  0004d	8b d8		 mov	 ebx, eax

; 1533 :         if (exp == -1 && PyErr_Occurred())

  0004f	83 f8 ff	 cmp	 eax, -1
  00052	75 16		 jne	 SHORT $LN12@math_ldexp
  00054	e8 00 00 00 00	 call	 PyErr_Occurred
  00059	48 85 c0	 test	 rax, rax
  0005c	74 0c		 je	 SHORT $LN12@math_ldexp

; 1534 :             return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 1568 : }

  00065	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00069	c3		 ret	 0
$LN12@math_ldexp:

; 1535 :         if (overflow)

  0006a	8b 44 24 70	 mov	 eax, DWORD PTR overflow$[rsp]
  0006e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00073	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00078	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  0007d	bf 00 00 00 80	 mov	 edi, -2147483648	; ffffffff80000000H
  00082	85 c0		 test	 eax, eax
  00084	74 08		 je	 SHORT $LN11@math_ldexp

; 1536 :             exp = overflow < 0 ? LONG_MIN : LONG_MAX;

  00086	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0008b	0f 48 df	 cmovs	 ebx, edi
$LN11@math_ldexp:

; 1542 :     }
; 1543 : 
; 1544 :     if (x == 0. || !Py_IS_FINITE(x)) {

  0008e	f2 0f 10 74 24
	78		 movsdx	 xmm6, QWORD PTR x$[rsp]
  00094	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00098	66 0f 2e f7	 ucomisd xmm6, xmm7
  0009c	7a 06		 jp	 SHORT $LN17@math_ldexp
  0009e	0f 84 a7 00 00
	00		 je	 $LN8@math_ldexp
$LN17@math_ldexp:
  000a4	66 0f 28 c6	 movapd	 xmm0, xmm6
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000ae	85 c0		 test	 eax, eax
  000b0	0f 84 8f 00 00
	00		 je	 $LN18@math_ldexp

; 1548 :     } else if (exp > INT_MAX) {

  000b6	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  000bc	7e 29		 jle	 SHORT $LN6@math_ldexp

; 1549 :         /* overflow */
; 1550 :         r = copysign(Py_HUGE_VAL, x);

  000be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000c5	f2 0f 10 4c 24
	78		 movsdx	 xmm1, QWORD PTR x$[rsp]
  000cb	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000d5	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1551 :         errno = ERANGE;

  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000df	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  000e5	eb 70		 jmp	 SHORT $LN2@math_ldexp
$LN6@math_ldexp:

; 1552 :     } else if (exp < INT_MIN) {

  000e7	3b df		 cmp	 ebx, edi
  000e9	7d 16		 jge	 SHORT $LN4@math_ldexp

; 1553 :         /* underflow to +-0 */
; 1554 :         r = copysign(0., x);

  000eb	f2 0f 10 4c 24
	78		 movsdx	 xmm1, QWORD PTR x$[rsp]
  000f1	66 0f 28 c7	 movapd	 xmm0, xmm7
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000fb	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1555 :         errno = 0;
; 1556 :     } else {

  000ff	eb 4a		 jmp	 SHORT $LN8@math_ldexp
$LN4@math_ldexp:

; 1557 :         errno = 0;

  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 1558 :         PyFPE_START_PROTECT("in math_ldexp", return 0);
; 1559 :         r = ldexp(x, (int)exp);

  00107	8b d3		 mov	 edx, ebx
  00109	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0010f	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0011b	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1560 :         PyFPE_END_PROTECT(r);
; 1561 :         if (Py_IS_INFINITY(r))

  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00125	85 c0		 test	 eax, eax
  00127	75 2e		 jne	 SHORT $LN2@math_ldexp
  00129	66 0f 28 c6	 movapd	 xmm0, xmm6
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00133	85 c0		 test	 eax, eax
  00135	75 20		 jne	 SHORT $LN2@math_ldexp

; 1562 :             errno = ERANGE;

  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013d	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  00143	eb 12		 jmp	 SHORT $LN2@math_ldexp
$LN18@math_ldexp:
  00145	f2 0f 10 74 24
	78		 movsdx	 xmm6, QWORD PTR x$[rsp]
$LN8@math_ldexp:

; 1545 :         /* NaNs, zeros and infinities are returned unchanged */
; 1546 :         r = x;
; 1547 :         errno = 0;

  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00151	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN2@math_ldexp:

; 1563 :     }
; 1564 : 
; 1565 :     if (errno && is_error(r))

  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0015d	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  00162	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00167	83 38 00	 cmp	 DWORD PTR [rax], 0
  0016a	74 1e		 je	 SHORT $LN1@math_ldexp
  0016c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00170	e8 00 00 00 00	 call	 is_error
  00175	85 c0		 test	 eax, eax
  00177	74 11		 je	 SHORT $LN1@math_ldexp

; 1566 :         return NULL;

  00179	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0017e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00183	33 c0		 xor	 eax, eax

; 1568 : }

  00185	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00189	c3		 ret	 0
$LN1@math_ldexp:

; 1567 :     return PyFloat_FromDouble(r);

  0018a	66 0f 28 c6	 movapd	 xmm0, xmm6
  0018e	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00193	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00198	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 1568 : }

  0019d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a1	c3		 ret	 0
$LN13@math_ldexp:

; 1537 :     }
; 1538 :     else {
; 1539 :         PyErr_SetString(PyExc_TypeError,
; 1540 :                         "Expected an int as second argument to ldexp.");

  001a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@
  001b0	e8 00 00 00 00	 call	 PyErr_SetString
$LN21@math_ldexp:

; 1541 :         return NULL;

  001b5	33 c0		 xor	 eax, eax

; 1568 : }

  001b7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001bb	c3		 ret	 0
math_ldexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@		; `string'
EXTRN	__imp_modf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_modf DD imagerel math_modf
	DD	imagerel math_modf+210
	DD	imagerel $unwind$math_modf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_modf DD 030c01H
	DD	02680cH
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
CONST	SEGMENT
??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@ DB '(dd)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT math_modf
_TEXT	SEGMENT
self$ = 64
arg$ = 72
y$ = 80
math_modf PROC						; COMDAT

; 1576 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1577 :     double y, x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1578 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN5@math_modf
  0001f	75 16		 jne	 SHORT $LN5@math_modf
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN5@math_modf

; 1579 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1594 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN5@math_modf:

; 1580 :     /* some platforms don't do the right thing for NaNs and
; 1581 :        infinities, so we take care of special cases directly. */
; 1582 :     if (!Py_IS_FINITE(x)) {

  00037	66 0f 28 c6	 movapd	 xmm0, xmm6
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00041	85 c0		 test	 eax, eax
  00043	75 48		 jne	 SHORT $LN1@math_modf

; 1583 :         if (Py_IS_INFINITY(x))

  00045	66 0f 28 c6	 movapd	 xmm0, xmm6
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0004f	85 c0		 test	 eax, eax
  00051	75 22		 jne	 SHORT $LN3@math_modf
  00053	66 0f 28 c6	 movapd	 xmm0, xmm6
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0005d	85 c0		 test	 eax, eax
  0005f	75 14		 jne	 SHORT $LN3@math_modf

; 1584 :             return Py_BuildValue("(dd)", copysign(0., x), x);

  00061	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00065	66 0f 28 ce	 movapd	 xmm1, xmm6
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0006f	66 0f 28 d6	 movapd	 xmm2, xmm6
  00073	eb 39		 jmp	 SHORT $LN8@math_modf
$LN3@math_modf:

; 1585 :         else if (Py_IS_NAN(x))

  00075	66 0f 28 c6	 movapd	 xmm0, xmm6
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0007f	85 c0		 test	 eax, eax
  00081	74 0a		 je	 SHORT $LN1@math_modf

; 1586 :             return Py_BuildValue("(dd)", x, x);

  00083	66 0f 28 d6	 movapd	 xmm2, xmm6
  00087	66 0f 28 ce	 movapd	 xmm1, xmm6
  0008b	eb 25		 jmp	 SHORT $LN9@math_modf
$LN1@math_modf:

; 1587 :     }
; 1588 : 
; 1589 :     errno = 0;

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 1590 :     PyFPE_START_PROTECT("in math_modf", return 0);
; 1591 :     x = modf(x, &y);

  00093	48 8d 54 24 50	 lea	 rdx, QWORD PTR y$[rsp]
  00098	66 0f 28 c6	 movapd	 xmm0, xmm6
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 1592 :     PyFPE_END_PROTECT(x);
; 1593 :     return Py_BuildValue("(dd)", x, y);

  000a8	f2 0f 10 54 24
	50		 movsdx	 xmm2, QWORD PTR y$[rsp]
$LN8@math_modf:
  000ae	66 0f 28 c8	 movapd	 xmm1, xmm0
$LN9@math_modf:
  000b2	66 49 0f 7e d0	 movd	 r8, xmm2
  000b7	66 48 0f 7e ca	 movd	 rdx, xmm1
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  000c3	e8 00 00 00 00	 call	 Py_BuildValue

; 1594 : }

  000c8	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
math_modf ENDP
_TEXT	ENDS
EXTRN	_PyLong_Frexp:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyLong_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$loghelper DD imagerel loghelper
	DD	imagerel loghelper+75
	DD	imagerel $unwind$loghelper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$loghelper DD imagerel loghelper+75
	DD	imagerel loghelper+214
	DD	imagerel $chain$1$loghelper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$loghelper DD imagerel loghelper+214
	DD	imagerel loghelper+274
	DD	imagerel $chain$3$loghelper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$loghelper DD imagerel loghelper+274
	DD	imagerel loghelper+292
	DD	imagerel $chain$4$loghelper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$loghelper DD 021H
	DD	imagerel loghelper
	DD	imagerel loghelper+75
	DD	imagerel $unwind$loghelper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$loghelper DD 040021H
	DD	028800H
	DD	036800H
	DD	imagerel loghelper
	DD	imagerel loghelper+75
	DD	imagerel $unwind$loghelper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$loghelper DD 040b21H
	DD	02880bH
	DD	036805H
	DD	imagerel loghelper
	DD	imagerel loghelper+75
	DD	imagerel $unwind$loghelper
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$loghelper DD 040a01H
	DD	0b340aH
	DD	07006720aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT loghelper
_TEXT	SEGMENT
e$21048 = 80
arg$ = 80
func$ = 88
loghelper PROC						; COMDAT

; 1613 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1614 :     /* If it is int, do it ourselves. */
; 1615 :     if (PyLong_Check(arg)) {

  0000a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001e	0f 84 ee 00 00
	00		 je	 $LN6@loghelper

; 1616 :         double x, result;
; 1617 :         Py_ssize_t e;
; 1618 : 
; 1619 :         /* Negative or zero inputs give a ValueError. */
; 1620 :         if (Py_SIZE(arg) <= 0) {

  00024	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00029	7f 20		 jg	 SHORT $LN5@loghelper

; 1621 :             PyErr_SetString(PyExc_ValueError,
; 1622 :                             "math domain error");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 1623 :             return NULL;

  0003e	33 c0		 xor	 eax, eax

; 1647 : }

  00040	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00045	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN5@loghelper:
  0004b	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00050	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8

; 1624 :         }
; 1625 : 
; 1626 :         x = PyLong_AsDouble(arg);

  00056	e8 00 00 00 00	 call	 PyLong_AsDouble

; 1627 :         if (x == -1.0 && PyErr_Occurred()) {

  0005b	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00063	66 0f 28 f0	 movapd	 xmm6, xmm0
  00067	0f 8a 98 00 00
	00		 jp	 $LN4@loghelper
  0006d	0f 85 92 00 00
	00		 jne	 $LN4@loghelper
  00073	e8 00 00 00 00	 call	 PyErr_Occurred
  00078	48 85 c0	 test	 rax, rax
  0007b	0f 84 84 00 00
	00		 je	 $LN4@loghelper

; 1628 :             if (!PyErr_ExceptionMatches(PyExc_OverflowError))

  00081	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00088	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0008d	85 c0		 test	 eax, eax

; 1629 :                 return NULL;

  0008f	74 2d		 je	 SHORT $LN11@loghelper

; 1630 :             /* Here the conversion to double overflowed, but it's possible
; 1631 :                to compute the log anyway.  Clear the exception and continue. */
; 1632 :             PyErr_Clear();

  00091	e8 00 00 00 00	 call	 PyErr_Clear

; 1633 :             x = _PyLong_Frexp((PyLongObject *)arg, &e);

  00096	48 8d 54 24 50	 lea	 rdx, QWORD PTR e$21048[rsp]
  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 _PyLong_Frexp

; 1634 :             if (x == -1.0 && PyErr_Occurred())

  000a3	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000ab	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  000b0	7a 24		 jp	 SHORT $LN2@loghelper
  000b2	75 22		 jne	 SHORT $LN2@loghelper
  000b4	e8 00 00 00 00	 call	 PyErr_Occurred
  000b9	48 85 c0	 test	 rax, rax
  000bc	74 18		 je	 SHORT $LN2@loghelper
$LN11@loghelper:

; 1635 :                 return NULL;

  000be	33 c0		 xor	 eax, eax
$LN10@loghelper:
  000c0	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000c5	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]

; 1647 : }

  000cb	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000d0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
$LN2@loghelper:

; 1636 :             /* Value is ~= x * 2**e, so the log ~= log(x) + log(2) * e. */
; 1637 :             result = func(x) + func(2.0) * e;

  000d6	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  000de	ff d7		 call	 rdi
  000e0	66 0f 28 f0	 movapd	 xmm6, xmm0
  000e4	66 0f ef c9	 pxor	 xmm1, xmm1
  000e8	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000ed	f2 48 0f 2a 4c
	24 50		 cvtsi2sd xmm1, QWORD PTR e$21048[rsp]
  000f4	f2 0f 59 f1	 mulsd	 xmm6, xmm1
  000f8	ff d7		 call	 rdi
  000fa	f2 0f 58 c6	 addsd	 xmm0, xmm6

; 1642 :         return PyFloat_FromDouble(result);

  000fe	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00103	eb bb		 jmp	 SHORT $LN10@loghelper
$LN4@loghelper:

; 1638 :         }
; 1639 :         else
; 1640 :             /* Successfully converted x to a double. */
; 1641 :             result = func(x);

  00105	66 0f 28 c6	 movapd	 xmm0, xmm6
  00109	ff d7		 call	 rdi

; 1642 :         return PyFloat_FromDouble(result);

  0010b	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00110	eb ae		 jmp	 SHORT $LN10@loghelper
$LN6@loghelper:

; 1643 :     }
; 1644 : 
; 1645 :     /* Else let libm handle it by itself. */
; 1646 :     return math_1(arg, func, 0);

  00112	45 33 c0	 xor	 r8d, r8d

; 1647 : }

  00115	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0011a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011e	5f		 pop	 rdi
  0011f	e9 00 00 00 00	 jmp	 math_1
loghelper ENDP
_TEXT	ENDS
EXTRN	PyNumber_TrueDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_log DD imagerel math_log
	DD	imagerel math_log+84
	DD	imagerel $unwind$math_log
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_log DD imagerel math_log+84
	DD	imagerel math_log+162
	DD	imagerel $chain$1$math_log
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$math_log DD imagerel math_log+162
	DD	imagerel math_log+207
	DD	imagerel $chain$4$math_log
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$math_log DD imagerel math_log+207
	DD	imagerel math_log+217
	DD	imagerel $chain$5$math_log
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$math_log DD 020021H
	DD	067400H
	DD	imagerel math_log
	DD	imagerel math_log+84
	DD	imagerel $unwind$math_log
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$math_log DD 060821H
	DD	083408H
	DD	067400H
	DD	096400H
	DD	imagerel math_log
	DD	imagerel math_log+84
	DD	imagerel $unwind$math_log
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_log DD 042821H
	DD	096428H
	DD	067405H
	DD	imagerel math_log
	DD	imagerel math_log+84
	DD	imagerel $unwind$math_log
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_log DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_log
_TEXT	SEGMENT
self$ = 64
args$ = 72
base$ = 80
arg$ = 88
math_log PROC						; COMDAT

; 1651 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 1652 :     PyObject *arg;
; 1653 :     PyObject *base = NULL;
; 1654 :     PyObject *num, *den;
; 1655 :     PyObject *ans;
; 1656 : 
; 1657 :     if (!PyArg_UnpackTuple(args, "log", 1, 2, &arg, &base))

  00007	48 8d 4c 24 50	 lea	 rcx, QWORD PTR base$[rsp]
  0000c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00012	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00017	48 8d 4c 24 58	 lea	 rcx, QWORD PTR arg$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MGHMBJCF@log?$AA@
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR base$[rsp], 0
  00038	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003d	85 c0		 test	 eax, eax
  0003f	75 07		 jne	 SHORT $LN4@math_log

; 1658 :         return NULL;

  00041	33 c0		 xor	 eax, eax

; 1674 : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
$LN4@math_log:

; 1659 : 
; 1660 :     num = loghelper(arg, m_log, "log");

  00048	48 8b 4c 24 58	 mov	 rcx, QWORD PTR arg$[rsp]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log
  00054	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00059	e8 00 00 00 00	 call	 loghelper
  0005e	48 8b f8	 mov	 rdi, rax

; 1661 :     if (num == NULL || base == NULL)

  00061	48 85 c0	 test	 rax, rax
  00064	74 69		 je	 SHORT $LN7@math_log
  00066	48 8b 4c 24 50	 mov	 rcx, QWORD PTR base$[rsp]
  0006b	48 85 c9	 test	 rcx, rcx
  0006e	74 5f		 je	 SHORT $LN7@math_log

; 1662 :         return num;
; 1663 : 
; 1664 :     den = loghelper(base, m_log, "log");

  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log
  00077	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0007c	e8 00 00 00 00	 call	 loghelper

; 1665 :     if (den == NULL) {
; 1666 :         Py_DECREF(num);

  00081	48 8b cf	 mov	 rcx, rdi
  00084	48 8b f0	 mov	 rsi, rax
  00087	48 85 c0	 test	 rax, rax
  0008a	75 16		 jne	 SHORT $LN1@math_log
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
  00091	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00096	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1667 :         return NULL;

  0009b	33 c0		 xor	 eax, eax

; 1674 : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
$LN1@math_log:

; 1668 :     }
; 1669 : 
; 1670 :     ans = PyNumber_TrueDivide(num, den);

  000a2	48 8b d0	 mov	 rdx, rax
  000a5	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000aa	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 1671 :     Py_DECREF(num);

  000af	48 8b cf	 mov	 rcx, rdi
  000b2	48 8b d8	 mov	 rbx, rax
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1672 :     Py_DECREF(den);

  000ba	48 8b ce	 mov	 rcx, rsi
  000bd	e8 00 00 00 00	 call	 _Py_DecRef
  000c2	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1673 :     return ans;

  000c7	48 8b c3	 mov	 rax, rbx
  000ca	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN7@math_log:
  000cf	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1674 : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
math_log ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_log2
_TEXT	SEGMENT
self$ = 8
arg$ = 16
math_log2 PROC						; COMDAT

; 1684 :     return loghelper(arg, m_log2, "log2");

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log2

; 1685 : }

  0000a	e9 00 00 00 00	 jmp	 loghelper
math_log2 ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT math_log10
_TEXT	SEGMENT
self$ = 8
arg$ = 16
math_log10 PROC						; COMDAT

; 1693 :     return loghelper(arg, m_log10, "log10");

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log10

; 1694 : }

  0000a	e9 00 00 00 00	 jmp	 loghelper
math_log10 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_fmod DD imagerel math_fmod
	DD	imagerel math_fmod+69
	DD	imagerel $unwind$math_fmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_fmod DD imagerel math_fmod+69
	DD	imagerel math_fmod+156
	DD	imagerel $chain$1$math_fmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$math_fmod DD imagerel math_fmod+156
	DD	imagerel math_fmod+222
	DD	imagerel $chain$3$math_fmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$math_fmod DD imagerel math_fmod+222
	DD	imagerel math_fmod+382
	DD	imagerel $chain$6$math_fmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$math_fmod DD 060621H
	DD	038806H
	DD	047800H
	DD	056800H
	DD	imagerel math_fmod
	DD	imagerel math_fmod+69
	DD	imagerel $unwind$math_fmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$math_fmod DD 040021H
	DD	047800H
	DD	056800H
	DD	imagerel math_fmod
	DD	imagerel math_fmod+69
	DD	imagerel $unwind$math_fmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_fmod DD 040a21H
	DD	04780aH
	DD	056805H
	DD	imagerel math_fmod
	DD	imagerel math_fmod+69
	DD	imagerel $unwind$math_fmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_fmod DD 010701H
	DD	0c207H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_fmod
_TEXT	SEGMENT
self$ = 112
args$ = 120
ox$ = 128
oy$ = 136
math_fmod PROC						; COMDAT

; 1701 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1702 :     PyObject *ox, *oy;
; 1703 :     double r, x, y;
; 1704 :     if (! PyArg_UnpackTuple(args, "fmod", 2, 2, &ox, &oy))

  00007	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00014	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00018	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KEPJIHGP@fmod?$AA@
  00023	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00027	48 8b c8	 mov	 rcx, rax
  0002a	45 8b c1	 mov	 r8d, r9d
  0002d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN9@math_fmod

; 1705 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 1727 : }

  00038	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0003c	c3		 ret	 0
$LN9@math_fmod:

; 1706 :     x = PyFloat_AsDouble(ox);

  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ox$[rsp]
  00045	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  0004a	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  0004f	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1707 :     y = PyFloat_AsDouble(oy);

  00054	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR oy$[rsp]
  0005c	66 0f 28 f8	 movapd	 xmm7, xmm0
  00060	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00065	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1708 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  00069	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00071	66 0f 2e f8	 ucomisd xmm7, xmm0
  00075	7a 02		 jp	 SHORT $LN12@math_fmod
  00077	74 08		 je	 SHORT $LN7@math_fmod
$LN12@math_fmod:
  00079	66 0f 2e f0	 ucomisd xmm6, xmm0
  0007d	7a 1d		 jp	 SHORT $LN8@math_fmod
  0007f	75 1b		 jne	 SHORT $LN8@math_fmod
$LN7@math_fmod:
  00081	e8 00 00 00 00	 call	 PyErr_Occurred
  00086	48 85 c0	 test	 rax, rax
  00089	74 11		 je	 SHORT $LN8@math_fmod

; 1709 :         return NULL;

  0008b	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00090	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  00095	33 c0		 xor	 eax, eax

; 1727 : }

  00097	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009b	c3		 ret	 0
$LN8@math_fmod:

; 1710 :     /* fmod(x, +/-Inf) returns x for finite x. */
; 1711 :     if (Py_IS_INFINITY(y) && Py_IS_FINITE(x))

  0009c	66 0f 28 c6	 movapd	 xmm0, xmm6
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000a6	85 c0		 test	 eax, eax
  000a8	75 34		 jne	 SHORT $LN6@math_fmod
  000aa	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000b4	85 c0		 test	 eax, eax
  000b6	75 26		 jne	 SHORT $LN6@math_fmod
  000b8	66 0f 28 c7	 movapd	 xmm0, xmm7
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000c2	85 c0		 test	 eax, eax
  000c4	74 18		 je	 SHORT $LN6@math_fmod

; 1712 :         return PyFloat_FromDouble(x);

  000c6	66 0f 28 c7	 movapd	 xmm0, xmm7
  000ca	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000cf	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000d4	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 1727 : }

  000d9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000dd	c3		 ret	 0
$LN6@math_fmod:
  000de	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8

; 1713 :     errno = 0;

  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 1714 :     PyFPE_START_PROTECT("in math_fmod", return 0);
; 1715 :     r = fmod(x, y);

  000ea	66 0f 28 ce	 movapd	 xmm1, xmm6
  000ee	66 0f 28 c7	 movapd	 xmm0, xmm7
  000f2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000f8	e8 00 00 00 00	 call	 fmod
  000fd	66 44 0f 28 c0	 movapd	 xmm8, xmm0

; 1716 :     PyFPE_END_PROTECT(r);
; 1717 :     if (Py_IS_NAN(r)) {

  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00108	85 c0		 test	 eax, eax
  0010a	74 36		 je	 SHORT $LN3@math_fmod

; 1718 :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  0010c	66 0f 28 c7	 movapd	 xmm0, xmm7
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00116	85 c0		 test	 eax, eax
  00118	75 1c		 jne	 SHORT $LN4@math_fmod
  0011a	66 0f 28 c6	 movapd	 xmm0, xmm6
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00124	85 c0		 test	 eax, eax
  00126	75 0e		 jne	 SHORT $LN4@math_fmod

; 1719 :             errno = EDOM;

  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012e	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1720 :         else

  00134	eb 0c		 jmp	 SHORT $LN3@math_fmod
$LN4@math_fmod:

; 1721 :             errno = 0;

  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_fmod:

; 1722 :     }
; 1723 :     if (errno && is_error(r))

  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00148	83 38 00	 cmp	 DWORD PTR [rax], 0
  0014b	74 12		 je	 SHORT $LN2@math_fmod
  0014d	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00152	e8 00 00 00 00	 call	 is_error
  00157	85 c0		 test	 eax, eax
  00159	74 04		 je	 SHORT $LN2@math_fmod

; 1724 :         return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	eb 0a		 jmp	 SHORT $LN15@math_fmod
$LN2@math_fmod:

; 1725 :     else
; 1726 :         return PyFloat_FromDouble(r);

  0015f	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00164	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN15@math_fmod:
  00169	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  0016f	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00174	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 1727 : }

  00179	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017d	c3		 ret	 0
math_fmod ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
pdata	SEGMENT
$pdata$math_hypot DD imagerel math_hypot
	DD	imagerel math_hypot+69
	DD	imagerel $unwind$math_hypot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_hypot DD imagerel math_hypot+69
	DD	imagerel math_hypot+156
	DD	imagerel $chain$1$math_hypot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$math_hypot DD imagerel math_hypot+156
	DD	imagerel math_hypot+216
	DD	imagerel $chain$3$math_hypot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$math_hypot DD imagerel math_hypot+216
	DD	imagerel math_hypot+276
	DD	imagerel $chain$5$math_hypot
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$math_hypot DD imagerel math_hypot+276
	DD	imagerel math_hypot+509
	DD	imagerel $chain$8$math_hypot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$math_hypot DD 060621H
	DD	038806H
	DD	047800H
	DD	056800H
	DD	imagerel math_hypot
	DD	imagerel math_hypot+69
	DD	imagerel $unwind$math_hypot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$math_hypot DD 040021H
	DD	047800H
	DD	056800H
	DD	imagerel math_hypot
	DD	imagerel math_hypot+69
	DD	imagerel $unwind$math_hypot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$math_hypot DD 040021H
	DD	047800H
	DD	056800H
	DD	imagerel math_hypot
	DD	imagerel math_hypot+69
	DD	imagerel $unwind$math_hypot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_hypot DD 040a21H
	DD	04780aH
	DD	056805H
	DD	imagerel math_hypot
	DD	imagerel math_hypot+69
	DD	imagerel $unwind$math_hypot
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_hypot DD 010701H
	DD	0c207H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\mathmodule.c
xdata	ENDS
;	COMDAT math_hypot
_TEXT	SEGMENT
self$ = 112
args$ = 120
ox$ = 128
oy$ = 136
math_hypot PROC						; COMDAT

; 1735 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1736 :     PyObject *ox, *oy;
; 1737 :     double r, x, y;
; 1738 :     if (! PyArg_UnpackTuple(args, "hypot", 2, 2, &ox, &oy))

  00007	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00014	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00018	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DNLPMBKG@hypot?$AA@
  00023	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00027	48 8b c8	 mov	 rcx, rax
  0002a	45 8b c1	 mov	 r8d, r9d
  0002d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN14@math_hypot

; 1739 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 1769 : }

  00038	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0003c	c3		 ret	 0
$LN14@math_hypot:

; 1740 :     x = PyFloat_AsDouble(ox);

  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ox$[rsp]
  00045	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  0004a	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  0004f	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1741 :     y = PyFloat_AsDouble(oy);

  00054	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR oy$[rsp]
  0005c	66 0f 28 f8	 movapd	 xmm7, xmm0
  00060	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00065	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1742 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  00069	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00071	66 0f 2e f8	 ucomisd xmm7, xmm0
  00075	7a 02		 jp	 SHORT $LN19@math_hypot
  00077	74 08		 je	 SHORT $LN12@math_hypot
$LN19@math_hypot:
  00079	66 0f 2e f0	 ucomisd xmm6, xmm0
  0007d	7a 1d		 jp	 SHORT $LN13@math_hypot
  0007f	75 1b		 jne	 SHORT $LN13@math_hypot
$LN12@math_hypot:
  00081	e8 00 00 00 00	 call	 PyErr_Occurred
  00086	48 85 c0	 test	 rax, rax
  00089	74 11		 je	 SHORT $LN13@math_hypot

; 1743 :         return NULL;

  0008b	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00090	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  00095	33 c0		 xor	 eax, eax

; 1769 : }

  00097	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009b	c3		 ret	 0
$LN13@math_hypot:

; 1744 :     /* hypot(x, +/-Inf) returns Inf, even if x is a NaN. */
; 1745 :     if (Py_IS_INFINITY(x))

  0009c	66 0f 28 c7	 movapd	 xmm0, xmm7
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000a6	85 c0		 test	 eax, eax
  000a8	75 2e		 jne	 SHORT $LN11@math_hypot
  000aa	66 0f 28 c7	 movapd	 xmm0, xmm7
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000b4	85 c0		 test	 eax, eax
  000b6	75 20		 jne	 SHORT $LN11@math_hypot

; 1746 :         return PyFloat_FromDouble(fabs(x));

  000b8	66 0f 54 3d 00
	00 00 00	 andpd	 xmm7, QWORD PTR __mask@@AbsDouble@
  000c0	66 0f 28 c7	 movapd	 xmm0, xmm7
  000c4	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000c9	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000ce	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 1769 : }

  000d3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d7	c3		 ret	 0
$LN11@math_hypot:

; 1747 :     if (Py_IS_INFINITY(y))

  000d8	66 0f 28 c6	 movapd	 xmm0, xmm6
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000e2	85 c0		 test	 eax, eax
  000e4	75 2e		 jne	 SHORT $LN10@math_hypot
  000e6	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000f0	85 c0		 test	 eax, eax
  000f2	75 20		 jne	 SHORT $LN10@math_hypot

; 1748 :         return PyFloat_FromDouble(fabs(y));

  000f4	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@
  000fc	66 0f 28 c6	 movapd	 xmm0, xmm6
  00100	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00105	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  0010a	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 1769 : }

  0010f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00113	c3		 ret	 0
$LN10@math_hypot:
  00114	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8

; 1749 :     errno = 0;

  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 1750 :     PyFPE_START_PROTECT("in math_hypot", return 0);
; 1751 :     r = hypot(x, y);

  00120	66 0f 28 ce	 movapd	 xmm1, xmm6
  00124	66 0f 28 c7	 movapd	 xmm0, xmm7
  00128	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__hypot
  00134	66 44 0f 28 c0	 movapd	 xmm8, xmm0

; 1752 :     PyFPE_END_PROTECT(r);
; 1753 :     if (Py_IS_NAN(r)) {

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0013f	85 c0		 test	 eax, eax
  00141	74 2a		 je	 SHORT $LN9@math_hypot

; 1754 :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  00143	66 0f 28 c7	 movapd	 xmm0, xmm7
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0014d	85 c0		 test	 eax, eax
  0014f	75 64		 jne	 SHORT $LN4@math_hypot
  00151	66 0f 28 c6	 movapd	 xmm0, xmm6
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0015b	85 c0		 test	 eax, eax
  0015d	75 56		 jne	 SHORT $LN4@math_hypot

; 1755 :             errno = EDOM;

  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00165	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1756 :         else
; 1757 :             errno = 0;
; 1758 :     }
; 1759 :     else if (Py_IS_INFINITY(r)) {

  0016b	eb 54		 jmp	 SHORT $LN3@math_hypot
$LN9@math_hypot:
  0016d	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00178	85 c0		 test	 eax, eax
  0017a	75 45		 jne	 SHORT $LN3@math_hypot
  0017c	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00187	85 c0		 test	 eax, eax
  00189	75 36		 jne	 SHORT $LN3@math_hypot

; 1760 :         if (Py_IS_FINITE(x) && Py_IS_FINITE(y))

  0018b	66 0f 28 c7	 movapd	 xmm0, xmm7
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00195	85 c0		 test	 eax, eax
  00197	74 1c		 je	 SHORT $LN4@math_hypot
  00199	66 0f 28 c6	 movapd	 xmm0, xmm6
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001a3	85 c0		 test	 eax, eax
  001a5	74 0e		 je	 SHORT $LN4@math_hypot

; 1761 :             errno = ERANGE;

  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ad	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 1762 :         else

  001b3	eb 0c		 jmp	 SHORT $LN3@math_hypot
$LN4@math_hypot:

; 1763 :             errno = 0;

  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001bb	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_hypot:

; 1764 :     }
; 1765 :     if (errno && is_error(r))

  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001c7	83 38 00	 cmp	 DWORD PTR [rax], 0
  001ca	74 12		 je	 SHORT $LN2@math_hypot
  001cc	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  001d1	e8 00 00 00 00	 call	 is_error
  001d6	85 c0		 test	 eax, eax
  001d8	74 04		 je	 SHORT $LN2@math_hypot

; 1766 :         return NULL;

  001da	33 c0		 xor	 eax, eax
  001dc	eb 0a		 jmp	 SHORT $LN22@math_hypot
$LN2@math_hypot:

; 1767 :     else
; 1768 :         return PyFloat_FromDouble(r);

  001de	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  001e3	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN22@math_hypot:
  001e8	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  001ee	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  001f3	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 1769 : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	c3		 ret	 0
math_hypot ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_pow DD imagerel math_pow
	DD	imagerel math_pow+69
	DD	imagerel $unwind$math_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$math_pow DD imagerel math_pow+69
	DD	imagerel math_pow+160
	DD	imagerel $chain$1$math_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$math_pow DD imagerel math_pow+160
	DD	imagerel math_pow+804
	DD	imagerel $chain$6$math_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$math_pow DD imagerel math_pow+804
	DD	imagerel math_pow+851
	DD	imagerel $chain$7$math_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$math_pow DD 060021H
	DD	066800H
	DD	048800H
	DD	057800H
	DD	imagerel math_pow
	DD	imagerel math_pow+69
	DD	imagerel $unwind$math_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$math_pow DD 0a1021H
	DD	039810H
	DD	06680aH
	DD	0e3405H
	DD	048800H
	DD	057800H
	DD	imagerel math_pow
	DD	imagerel math_pow+69
	DD	imagerel $unwind$math_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$math_pow DD 040b21H
	DD	04880bH
	DD	057805H
	DD	imagerel math_pow
	DD	imagerel math_pow+69
	DD	imagerel $unwind$math_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_pow DD 010701H
	DD	0e207H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_pow
_TEXT	SEGMENT
self$ = 128
args$ = 136
ox$ = 144
oy$ = 152
math_pow PROC						; COMDAT

; 1782 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1783 :     PyObject *ox, *oy;
; 1784 :     double r, x, y;
; 1785 :     int odd_y;
; 1786 : 
; 1787 :     if (! PyArg_UnpackTuple(args, "pow", 2, 2, &ox, &oy))

  00007	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00014	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  00018	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JGHBODFD@pow?$AA@
  00023	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00027	48 8b c8	 mov	 rcx, rax
  0002a	45 8b c1	 mov	 r8d, r9d
  0002d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN32@math_pow

; 1788 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 1856 : }

  00038	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0003c	c3		 ret	 0
$LN32@math_pow:

; 1789 :     x = PyFloat_AsDouble(ox);

  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ox$[rsp]
  00045	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  0004a	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8
  00050	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1790 :     y = PyFloat_AsDouble(oy);

  00055	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR oy$[rsp]
  0005d	66 44 0f 28 c0	 movapd	 xmm8, xmm0
  00062	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00067	66 0f 28 f8	 movapd	 xmm7, xmm0

; 1791 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  0006b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00073	66 44 0f 2e c0	 ucomisd xmm8, xmm0
  00078	7a 02		 jp	 SHORT $LN45@math_pow
  0007a	74 08		 je	 SHORT $LN30@math_pow
$LN45@math_pow:
  0007c	66 0f 2e f8	 ucomisd xmm7, xmm0
  00080	7a 1e		 jp	 SHORT $LN31@math_pow
  00082	75 1c		 jne	 SHORT $LN31@math_pow
$LN30@math_pow:
  00084	e8 00 00 00 00	 call	 PyErr_Occurred
  00089	48 85 c0	 test	 rax, rax
  0008c	74 12		 je	 SHORT $LN31@math_pow

; 1792 :         return NULL;

  0008e	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00093	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  00099	33 c0		 xor	 eax, eax

; 1856 : }

  0009b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0009f	c3		 ret	 0
$LN31@math_pow:
  000a0	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  000a5	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  000aa	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9

; 1793 : 
; 1794 :     /* deal directly with IEEE specials, to cope with problems on various
; 1795 :        platforms whose semantics don't exactly match C99 */
; 1796 :     r = 0.; /* silence compiler warning */

  000b0	66 45 0f 57 c9	 xorpd	 xmm9, xmm9

; 1797 :     if (!Py_IS_FINITE(x) || !Py_IS_FINITE(y)) {

  000b5	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000ba	66 41 0f 28 f1	 movapd	 xmm6, xmm9
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 aa 00 00
	00		 je	 $LN28@math_pow
  000cd	66 0f 28 c7	 movapd	 xmm0, xmm7
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000d7	85 c0		 test	 eax, eax
  000d9	0f 84 98 00 00
	00		 je	 $LN28@math_pow

; 1824 :         }
; 1825 :     }
; 1826 :     else {
; 1827 :         /* let libm handle finite**finite */
; 1828 :         errno = 0;

  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e5	33 db		 xor	 ebx, ebx

; 1829 :         PyFPE_START_PROTECT("in math_pow", return 0);
; 1830 :         r = pow(x, y);

  000e7	66 0f 28 cf	 movapd	 xmm1, xmm7
  000eb	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000f0	89 18		 mov	 DWORD PTR [rax], ebx
  000f2	e8 00 00 00 00	 call	 pow
  000f7	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1831 :         PyFPE_END_PROTECT(r);
; 1832 :         /* a NaN result should arise only from (-ve)**(finite
; 1833 :            non-integer); in this case we want to raise ValueError. */
; 1834 :         if (!Py_IS_FINITE(r)) {

  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00101	85 c0		 test	 eax, eax
  00103	0f 85 05 02 00
	00		 jne	 $LN10@math_pow

; 1835 :             if (Py_IS_NAN(r)) {

  00109	66 0f 28 c6	 movapd	 xmm0, xmm6
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00113	85 c0		 test	 eax, eax
  00115	74 11		 je	 SHORT $LN7@math_pow

; 1836 :                 errno = EDOM;

  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0011d	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  00123	e9 e6 01 00 00	 jmp	 $LN10@math_pow
$LN7@math_pow:

; 1837 :             }
; 1838 :             /*
; 1839 :                an infinite result here arises either from:
; 1840 :                (A) (+/-0.)**negative (-> divide-by-zero)
; 1841 :                (B) overflow of x**y with x and y finite
; 1842 :             */
; 1843 :             else if (Py_IS_INFINITY(r)) {

  00128	66 0f 28 c6	 movapd	 xmm0, xmm6
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00132	85 c0		 test	 eax, eax
  00134	0f 85 d4 01 00
	00		 jne	 $LN10@math_pow
  0013a	66 0f 28 c6	 movapd	 xmm0, xmm6
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00144	85 c0		 test	 eax, eax
  00146	0f 85 c2 01 00
	00		 jne	 $LN10@math_pow

; 1844 :                 if (x == 0.)

  0014c	66 45 0f 2e c1	 ucomisd xmm8, xmm9
  00151	7a 13		 jp	 SHORT $LN4@math_pow
  00153	75 11		 jne	 SHORT $LN4@math_pow

; 1845 :                     errno = EDOM;

  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0015b	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1846 :                 else

  00161	e9 a8 01 00 00	 jmp	 $LN10@math_pow
$LN4@math_pow:

; 1847 :                     errno = ERANGE;

  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0016c	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  00172	e9 97 01 00 00	 jmp	 $LN10@math_pow
$LN28@math_pow:

; 1798 :         errno = 0;

  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0017d	33 db		 xor	 ebx, ebx

; 1799 :         if (Py_IS_NAN(x))

  0017f	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00184	89 18		 mov	 DWORD PTR [rax], ebx
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0018c	85 c0		 test	 eax, eax
  0018e	74 20		 je	 SHORT $LN27@math_pow

; 1800 :             r = y == 0. ? 1. : x; /* NaN**0 = 1 */

  00190	66 41 0f 2e f9	 ucomisd xmm7, xmm9
  00195	7a 0f		 jp	 SHORT $LN35@math_pow
  00197	75 0d		 jne	 SHORT $LN35@math_pow
  00199	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000
  001a1	e9 68 01 00 00	 jmp	 $LN10@math_pow
$LN35@math_pow:
  001a6	66 41 0f 28 f0	 movapd	 xmm6, xmm8
  001ab	e9 5e 01 00 00	 jmp	 $LN10@math_pow
$LN27@math_pow:

; 1801 :         else if (Py_IS_NAN(y))

  001b0	66 0f 28 c7	 movapd	 xmm0, xmm7
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  001ba	85 c0		 test	 eax, eax
  001bc	74 1e		 je	 SHORT $LN25@math_pow

; 1802 :             r = x == 1. ? 1. : y; /* 1**NaN = 1 */

  001be	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000
  001c6	66 44 0f 2e c6	 ucomisd xmm8, xmm6
  001cb	7a 06		 jp	 SHORT $LN37@math_pow
  001cd	0f 84 3b 01 00
	00		 je	 $LN10@math_pow
$LN37@math_pow:
  001d3	66 0f 28 f7	 movapd	 xmm6, xmm7
  001d7	e9 32 01 00 00	 jmp	 $LN10@math_pow
$LN25@math_pow:

; 1803 :         else if (Py_IS_INFINITY(x)) {

  001dc	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001e7	85 c0		 test	 eax, eax
  001e9	0f 85 9e 00 00
	00		 jne	 $LN23@math_pow
  001ef	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  001fa	85 c0		 test	 eax, eax
  001fc	0f 85 8b 00 00
	00		 jne	 $LN23@math_pow

; 1804 :             odd_y = Py_IS_FINITE(y) && fmod(fabs(y), 2.0) == 1.0;

  00202	66 0f 28 c7	 movapd	 xmm0, xmm7
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0020c	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000
  00214	85 c0		 test	 eax, eax
  00216	74 26		 je	 SHORT $LN39@math_pow
  00218	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00220	66 0f 28 c7	 movapd	 xmm0, xmm7
  00224	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  0022c	e8 00 00 00 00	 call	 fmod
  00231	66 0f 2e c6	 ucomisd xmm0, xmm6
  00235	7a 07		 jp	 SHORT $LN39@math_pow
  00237	75 05		 jne	 SHORT $LN39@math_pow
  00239	bb 01 00 00 00	 mov	 ebx, 1
$LN39@math_pow:

; 1805 :             if (y > 0.)

  0023e	66 41 0f 2f f9	 comisd	 xmm7, xmm9
  00243	76 1a		 jbe	 SHORT $LN22@math_pow

; 1806 :                 r = odd_y ? x : fabs(x);

  00245	66 41 0f 28 f0	 movapd	 xmm6, xmm8
  0024a	85 db		 test	 ebx, ebx
  0024c	0f 85 bc 00 00
	00		 jne	 $LN10@math_pow
  00252	66 0f 54 35 00
	00 00 00	 andpd	 xmm6, QWORD PTR __mask@@AbsDouble@
  0025a	e9 af 00 00 00	 jmp	 $LN10@math_pow
$LN22@math_pow:

; 1807 :             else if (y == 0.)

  0025f	66 41 0f 2e f9	 ucomisd xmm7, xmm9
  00264	7a 06		 jp	 SHORT $LN20@math_pow
  00266	0f 84 a2 00 00
	00		 je	 $LN10@math_pow
$LN20@math_pow:

; 1808 :                 r = 1.;
; 1809 :             else /* y < 0. */
; 1810 :                 r = odd_y ? copysign(0., x) : 0.;

  0026c	85 db		 test	 ebx, ebx
  0026e	0f 84 95 00 00
	00		 je	 $LN12@math_pow
  00274	66 41 0f 28 c8	 movapd	 xmm1, xmm8
  00279	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00284	66 0f 28 f0	 movapd	 xmm6, xmm0

; 1811 :         }
; 1812 :         else if (Py_IS_INFINITY(y)) {

  00288	e9 81 00 00 00	 jmp	 $LN10@math_pow
$LN23@math_pow:
  0028d	66 0f 28 c7	 movapd	 xmm0, xmm7
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00297	85 c0		 test	 eax, eax
  00299	75 73		 jne	 SHORT $LN10@math_pow
  0029b	66 0f 28 c7	 movapd	 xmm0, xmm7
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  002a5	85 c0		 test	 eax, eax
  002a7	75 65		 jne	 SHORT $LN10@math_pow

; 1813 :             if (fabs(x) == 1.0)

  002a9	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000
  002b1	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  002b6	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  002be	66 0f 2e c6	 ucomisd xmm0, xmm6
  002c2	7a 02		 jp	 SHORT $LN16@math_pow
  002c4	74 48		 je	 SHORT $LN10@math_pow
$LN16@math_pow:

; 1814 :                 r = 1.;
; 1815 :             else if (y > 0. && fabs(x) > 1.0)

  002c6	66 41 0f 2f f9	 comisd	 xmm7, xmm9
  002cb	76 0c		 jbe	 SHORT $LN14@math_pow
  002cd	66 0f 2f c6	 comisd	 xmm0, xmm6
  002d1	76 06		 jbe	 SHORT $LN14@math_pow

; 1816 :                 r = y;

  002d3	66 0f 28 f7	 movapd	 xmm6, xmm7
  002d7	eb 35		 jmp	 SHORT $LN10@math_pow
$LN14@math_pow:

; 1817 :             else if (y < 0. && fabs(x) < 1.0) {

  002d9	66 44 0f 2f cf	 comisd	 xmm9, xmm7
  002de	76 29		 jbe	 SHORT $LN12@math_pow
  002e0	66 0f 2f f0	 comisd	 xmm6, xmm0
  002e4	76 23		 jbe	 SHORT $LN12@math_pow

; 1818 :                 r = -y; /* result is +inf */
; 1819 :                 if (x == 0.) /* 0**-inf: divide-by-zero */

  002e6	66 45 0f 2e c1	 ucomisd xmm8, xmm9
  002eb	66 0f 28 f7	 movapd	 xmm6, xmm7
  002ef	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@
  002f7	7a 15		 jp	 SHORT $LN10@math_pow
  002f9	75 13		 jne	 SHORT $LN10@math_pow

; 1820 :                     errno = EDOM;

  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00301	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1821 :             }
; 1822 :             else

  00307	eb 05		 jmp	 SHORT $LN10@math_pow
$LN12@math_pow:

; 1823 :                 r = 0.;

  00309	66 41 0f 28 f1	 movapd	 xmm6, xmm9
$LN10@math_pow:

; 1848 :             }
; 1849 :         }
; 1850 :     }
; 1851 : 
; 1852 :     if (errno && is_error(r))

  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00314	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
  0031a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0031f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00322	74 11		 je	 SHORT $LN2@math_pow
  00324	66 0f 28 c6	 movapd	 xmm0, xmm6
  00328	e8 00 00 00 00	 call	 is_error
  0032d	85 c0		 test	 eax, eax
  0032f	74 04		 je	 SHORT $LN2@math_pow

; 1853 :         return NULL;

  00331	33 c0		 xor	 eax, eax
  00333	eb 09		 jmp	 SHORT $LN48@math_pow
$LN2@math_pow:

; 1854 :     else
; 1855 :         return PyFloat_FromDouble(r);

  00335	66 0f 28 c6	 movapd	 xmm0, xmm6
  00339	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN48@math_pow:
  0033e	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00343	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  00348	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]

; 1856 : }

  0034e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00352	c3		 ret	 0
math_pow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_degrees DD imagerel math_degrees
	DD	imagerel math_degrees+81
	DD	imagerel $unwind$math_degrees
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_degrees DD 030c01H
	DD	02680cH
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_degrees
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_degrees PROC					; COMDAT

; 1866 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1867 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1868 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN1@math_degre
  0001f	75 16		 jne	 SHORT $LN1@math_degre
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN1@math_degre

; 1869 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1871 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN1@math_degre:

; 1870 :     return PyFloat_FromDouble(x * radToDeg);

  00037	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR radToDeg
  0003f	66 0f 28 c6	 movapd	 xmm0, xmm6

; 1871 : }

  00043	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
math_degrees ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_radians DD imagerel math_radians
	DD	imagerel math_radians+81
	DD	imagerel $unwind$math_radians
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_radians DD 030c01H
	DD	02680cH
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_radians
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_radians PROC					; COMDAT

; 1879 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1880 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1881 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN1@math_radia
  0001f	75 16		 jne	 SHORT $LN1@math_radia
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN1@math_radia

; 1882 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1884 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN1@math_radia:

; 1883 :     return PyFloat_FromDouble(x * degToRad);

  00037	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR degToRad
  0003f	66 0f 28 c6	 movapd	 xmm0, xmm6

; 1884 : }

  00043	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
math_radians ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isfinite DD imagerel math_isfinite
	DD	imagerel math_isfinite+81
	DD	imagerel $unwind$math_isfinite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isfinite DD 030c01H
	DD	02680cH
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_isfinite
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_isfinite PROC					; COMDAT

; 1892 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1893 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1894 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN1@math_isfin
  0001f	75 16		 jne	 SHORT $LN1@math_isfin
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN1@math_isfin

; 1895 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1897 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN1@math_isfin:

; 1896 :     return PyBool_FromLong((long)Py_IS_FINITE(x));

  00037	66 0f 28 c6	 movapd	 xmm0, xmm6
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00041	8b c8		 mov	 ecx, eax

; 1897 : }

  00043	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	e9 00 00 00 00	 jmp	 PyBool_FromLong
math_isfinite ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isnan DD imagerel math_isnan
	DD	imagerel math_isnan+81
	DD	imagerel $unwind$math_isnan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isnan DD 030c01H
	DD	02680cH
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_isnan
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_isnan PROC						; COMDAT

; 1905 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1906 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1907 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN1@math_isnan
  0001f	75 16		 jne	 SHORT $LN1@math_isnan
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN1@math_isnan

; 1908 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1910 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN1@math_isnan:

; 1909 :     return PyBool_FromLong((long)Py_IS_NAN(x));

  00037	66 0f 28 c6	 movapd	 xmm0, xmm6
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00041	8b c8		 mov	 ecx, eax

; 1910 : }

  00043	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	e9 00 00 00 00	 jmp	 PyBool_FromLong
math_isnan ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isinf DD imagerel math_isinf
	DD	imagerel math_isinf+116
	DD	imagerel $unwind$math_isinf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isinf DD 030c01H
	DD	02680cH
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT math_isinf
_TEXT	SEGMENT
self$ = 64
arg$ = 72
math_isinf PROC						; COMDAT

; 1918 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1919 :     double x = PyFloat_AsDouble(arg);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1920 :     if (x == -1.0 && PyErr_Occurred())

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001d	7a 18		 jp	 SHORT $LN1@math_isinf
  0001f	75 16		 jne	 SHORT $LN1@math_isinf
  00021	e8 00 00 00 00	 call	 PyErr_Occurred
  00026	48 85 c0	 test	 rax, rax
  00029	74 0c		 je	 SHORT $LN1@math_isinf

; 1921 :         return NULL;

  0002b	33 c0		 xor	 eax, eax

; 1923 : }

  0002d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
$LN1@math_isinf:

; 1922 :     return PyBool_FromLong((long)Py_IS_INFINITY(x));

  00037	66 0f 28 c6	 movapd	 xmm0, xmm6
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00041	85 c0		 test	 eax, eax
  00043	75 1f		 jne	 SHORT $LN4@math_isinf
  00045	66 0f 28 c6	 movapd	 xmm0, xmm6
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0004f	85 c0		 test	 eax, eax
  00051	75 11		 jne	 SHORT $LN4@math_isinf
  00053	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]

; 1923 : }

  00056	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN4@math_isinf:

; 1922 :     return PyBool_FromLong((long)Py_IS_INFINITY(x));

  00064	33 c9		 xor	 ecx, ecx

; 1923 : }

  00066	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	e9 00 00 00 00	 jmp	 PyBool_FromLong
math_isinf ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	__real@4005bf0a8b145769
PUBLIC	??_C@_02OAHAJOFD@pi?$AA@			; `string'
PUBLIC	PyInit_math
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_math DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$PyInit_math
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_math DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4005bf0a8b145769
CONST	SEGMENT
__real@4005bf0a8b145769 DQ 04005bf0a8b145769r	; 2.71828
CONST	ENDS
;	COMDAT ??_C@_02OAHAJOFD@pi?$AA@
CONST	SEGMENT
??_C@_02OAHAJOFD@pi?$AA@ DB 'pi', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_math
_TEXT	SEGMENT
PyInit_math PROC					; COMDAT

; 1995 : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1996 :     PyObject *m;
; 1997 : 
; 1998 :     m = PyModule_Create(&mathmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mathmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 1999 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	74 41		 je	 SHORT $finally$21325

; 2000 :         goto finally;
; 2001 : 
; 2002 :     PyModule_AddObject(m, "pi", PyFloat_FromDouble(Py_MATH_PI));

  0001f	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR pi
  00027	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OAHAJOFD@pi?$AA@
  00033	48 8b cb	 mov	 rcx, rbx
  00036	4c 8b c0	 mov	 r8, rax
  00039	e8 00 00 00 00	 call	 PyModule_AddObject

; 2003 :     PyModule_AddObject(m, "e", PyFloat_FromDouble(Py_MATH_E));

  0003e	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4005bf0a8b145769
  00046	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KGKMHCOC@e?$AA@
  00052	4c 8b c0	 mov	 r8, rax
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 PyModule_AddObject

; 2004 : 
; 2005 :     finally:
; 2006 :     return m;

  0005d	48 8b c3	 mov	 rax, rbx
$finally$21325:

; 2007 : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
PyInit_math ENDP
_TEXT	ENDS
END
