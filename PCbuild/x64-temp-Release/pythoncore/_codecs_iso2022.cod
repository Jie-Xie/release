; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@		; `string'
PUBLIC	??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@		; `string'
PUBLIC	??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@		; `string'
PUBLIC	??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@		; `string'
PUBLIC	??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@		; `string'
PUBLIC	??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@		; `string'
PUBLIC	??_C@_0L@CFIMACKG@iso2022_jp?$AA@		; `string'
PUBLIC	??_C@_0L@BGHIAKBD@iso2022_kr?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_08IAFCJBEI@getcodec?$AA@			; `string'
_BSS	SEGMENT
?cofunc@?1??getmultibytecodec@@9@9 DQ 01H DUP (?)	; `getmultibytecodec'::`2'::cofunc
cp949_encmap DQ	01H DUP (?)
ksx1001_decmap DQ 01H DUP (?)
jisxcommon_encmap DQ 01H DUP (?)
jisx0208_decmap DQ 01H DUP (?)
jisx0212_decmap DQ 01H DUP (?)
jisx0213_bmp_encmap DQ 01H DUP (?)
jisx0213_1_bmp_decmap DQ 01H DUP (?)
jisx0213_2_bmp_decmap DQ 01H DUP (?)
jisx0213_emp_encmap DQ 01H DUP (?)
jisx0213_1_emp_decmap DQ 01H DUP (?)
jisx0213_2_emp_decmap DQ 01H DUP (?)
gbcommon_encmap DQ 01H DUP (?)
gb2312_decmap DQ 01H DUP (?)
?initialized@?1??ksx1001_init@@9@9 DD 01H DUP (?)	; `ksx1001_init'::`2'::initialized
?initialized@?1??jisx0208_init@@9@9 DD 01H DUP (?)	; `jisx0208_init'::`2'::initialized
?initialized@?1??jisx0212_init@@9@9 DD 01H DUP (?)	; `jisx0212_init'::`2'::initialized
?initialized@?1??jisx0213_init@@9@9 DD 01H DUP (?)	; `jisx0213_init'::`2'::initialized
?initialized@?1??gb2312_init@@9@9 DD 01H DUP (?)	; `gb2312_init'::`2'::initialized
_BSS	ENDS
;	COMDAT ??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@
CONST	SEGMENT
??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@ DB '_codecs_iso2022', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@
CONST	SEGMENT
??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@ DB 'iso2022_jp_ext', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@
CONST	SEGMENT
??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@ DB 'iso2022_jp_3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@
CONST	SEGMENT
??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@ DB 'iso2022_jp_2004', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@
CONST	SEGMENT
??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@ DB 'iso2022_jp_2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@
CONST	SEGMENT
??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@ DB 'iso2022_jp_1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CFIMACKG@iso2022_jp?$AA@
CONST	SEGMENT
??_C@_0L@CFIMACKG@iso2022_jp?$AA@ DB 'iso2022_jp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BGHIAKBD@iso2022_kr?$AA@
CONST	SEGMENT
??_C@_0L@BGHIAKBD@iso2022_kr?$AA@ DB 'iso2022_kr', 00H	; `string'
CONST	ENDS
CONST	SEGMENT
iso2022_kr_designations DB 0c3H
	DB	01H
	DB	02H
	ORG $+5
	DQ	FLAT:ksx1001_init
	DQ	FLAT:ksx1001_decoder
	DQ	FLAT:ksx1001_encoder
	DB	00H
	ORG $+31
iso2022_kr_config DD 00H
	ORG $+4
	DQ	FLAT:iso2022_kr_designations
iso2022_jp_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_designations
iso2022_jp_1_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_1_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_1_designations
iso2022_jp_2_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	0c3H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:ksx1001_init
	DQ	FLAT:ksx1001_decoder
	DQ	FLAT:ksx1001_encoder
	DB	0c1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:gb2312_init
	DQ	FLAT:gb2312_decoder
	DQ	FLAT:gb2312_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	041H
	DB	02H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:dummy_decoder
	DQ	FLAT:dummy_encoder
	DB	046H
	DB	02H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:dummy_decoder
	DQ	FLAT:dummy_encoder
	DB	00H
	ORG $+31
iso2022_jp_2_config DD 07H
	ORG $+4
	DQ	FLAT:iso2022_jp_2_designations
iso2022_jp_2004_designations DB 0d1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_1_decoder
	DQ	FLAT:jisx0213_2004_1_encoder_paironly
	DB	0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0d1H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_1_decoder
	DQ	FLAT:jisx0213_2004_1_encoder
	DB	0d0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2004_2_decoder
	DQ	FLAT:jisx0213_2004_2_encoder
	DB	00H
	ORG $+31
iso2022_jp_2004_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_2004_designations
iso2022_jp_3_designations DB 0cfH
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_1_decoder
	DQ	FLAT:jisx0213_2000_1_encoder_paironly
	DB	0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0cfH
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_1_decoder
	DQ	FLAT:jisx0213_2000_1_encoder
	DB	0d0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0213_init
	DQ	FLAT:jisx0213_2000_2_decoder
	DQ	FLAT:jisx0213_2000_2_encoder
	DB	00H
	ORG $+31
iso2022_jp_3_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_3_designations
iso2022_jp_ext_designations DB 0c2H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	0c4H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0212_init
	DQ	FLAT:jisx0212_decoder
	DQ	FLAT:jisx0212_encoder
	DB	04aH
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_r_decoder
	DQ	FLAT:jisx0201_r_encoder
	DB	049H
	DB	00H
	DB	01H
	ORG $+5
	DQ	0000000000000000H
	DQ	FLAT:jisx0201_k_decoder
	DQ	FLAT:jisx0201_k_encoder
	DB	0c0H
	DB	00H
	DB	02H
	ORG $+5
	DQ	FLAT:jisx0208_init
	DQ	FLAT:jisx0208_decoder
	DQ	FLAT:jisx0208_encoder
	DB	00H
	ORG $+31
iso2022_jp_ext_config DD 05H
	ORG $+4
	DQ	FLAT:iso2022_jp_ext_designations
_mapping_list DQ FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
_codec_list DQ	FLAT:??_C@_0L@BGHIAKBD@iso2022_kr?$AA@
	DQ	FLAT:iso2022_kr_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0L@CFIMACKG@iso2022_jp?$AA@
	DQ	FLAT:iso2022_jp_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@LHOODBPA@iso2022_jp_1?$AA@
	DQ	FLAT:iso2022_jp_1_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@JMMDGCDD@iso2022_jp_2?$AA@
	DQ	FLAT:iso2022_jp_2_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0BA@BMOBCPLM@iso2022_jp_2004?$AA@
	DQ	FLAT:iso2022_jp_2004_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0N@IFNIFDHC@iso2022_jp_3?$AA@
	DQ	FLAT:iso2022_jp_3_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_0P@BALMELIG@iso2022_jp_ext?$AA@
	DQ	FLAT:iso2022_jp_ext_config
	DQ	FLAT:iso2022_codec_init
	DQ	FLAT:iso2022_encode
	DQ	FLAT:iso2022_encode_init
	DQ	FLAT:iso2022_encode_reset
	DQ	FLAT:iso2022_decode
	DQ	FLAT:iso2022_decode_init
	DQ	FLAT:iso2022_decode_reset
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	ORG $+56
CONST	ENDS
_DATA	SEGMENT
__methods DQ	FLAT:??_C@_08IAFCJBEI@getcodec?$AA@
	DQ	FLAT:getcodec
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
mapping_list DQ	FLAT:_mapping_list
codec_list DQ	FLAT:_codec_list
__module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@NBDGFOAF@_codecs_iso2022?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:__methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAFCJBEI@getcodec?$AA@
CONST	SEGMENT
??_C@_08IAFCJBEI@getcodec?$AA@ DB 'getcodec', 00H	; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@CGBPDBNI@__create_codec?$AA@		; `string'
PUBLIC	??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@		; `string'
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\cjkcodecs.h
pdata	SEGMENT
$pdata$getmultibytecodec DD imagerel getmultibytecodec
	DD	imagerel getmultibytecodec+87
	DD	imagerel $unwind$getmultibytecodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getmultibytecodec DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0P@CGBPDBNI@__create_codec?$AA@
CONST	SEGMENT
??_C@_0P@CGBPDBNI@__create_codec?$AA@ DB '__create_codec', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@
CONST	SEGMENT
??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@ DB '_multibytecodec', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getmultibytecodec
_TEXT	SEGMENT
getmultibytecodec PROC					; COMDAT

; 246  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 247  :     static PyObject *cofunc = NULL;
; 248  : 
; 249  :     if (cofunc == NULL) {

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9
  0000d	48 85 c0	 test	 rax, rax
  00010	75 3f		 jne	 SHORT $LN2@getmultiby

; 250  :         PyObject *mod = PyImport_ImportModuleNoBlock("_multibytecodec");

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@EEJLBBNI@_multibytecodec?$AA@
  00019	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  0001e	48 8b d8	 mov	 rbx, rax

; 251  :         if (mod == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	75 06		 jne	 SHORT $LN1@getmultiby

; 255  :     }
; 256  :     return cofunc;
; 257  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN1@getmultiby:

; 252  :             return NULL;
; 253  :         cofunc = PyObject_GetAttrString(mod, "__create_codec");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CGBPDBNI@__create_codec?$AA@
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 254  :         Py_DECREF(mod);

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9, rax
  00045	e8 00 00 00 00	 call	 _Py_DecRef
  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?cofunc@?1??getmultibytecodec@@9@9
$LN2@getmultiby:

; 255  :     }
; 256  :     return cofunc;
; 257  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
getmultibytecodec ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@ ; `string'
PUBLIC	??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@ ; `string'
PUBLIC	??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@ ; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyCapsule_New:PROC
EXTRN	PyExc_LookupError:QWORD
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$getcodec DD imagerel getcodec
	DD	imagerel getcodec+49
	DD	imagerel $unwind$getcodec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$getcodec DD imagerel getcodec+49
	DD	imagerel getcodec+77
	DD	imagerel $chain$0$getcodec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$getcodec DD imagerel getcodec+77
	DD	imagerel getcodec+208
	DD	imagerel $chain$3$getcodec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$getcodec DD imagerel getcodec+208
	DD	imagerel getcodec+259
	DD	imagerel $chain$6$getcodec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$getcodec DD imagerel getcodec+259
	DD	imagerel getcodec+307
	DD	imagerel $chain$8$getcodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$getcodec DD 060021H
	DD	047400H
	DD	076400H
	DD	063400H
	DD	imagerel getcodec
	DD	imagerel getcodec+49
	DD	imagerel $unwind$getcodec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$getcodec DD 061221H
	DD	047412H
	DD	076400H
	DD	063400H
	DD	imagerel getcodec
	DD	imagerel getcodec+49
	DD	imagerel $unwind$getcodec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$getcodec DD 040521H
	DD	076405H
	DD	063400H
	DD	imagerel getcodec
	DD	imagerel getcodec+49
	DD	imagerel $unwind$getcodec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$getcodec DD 020521H
	DD	063405H
	DD	imagerel getcodec
	DD	imagerel getcodec+49
	DD	imagerel $unwind$getcodec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getcodec DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
CONST	SEGMENT
??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@ DB 'multibytecodec.__m'
	DB	'ap_*', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@
CONST	SEGMENT
??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@ DB 'no such code'
	DB	'c is supported.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@
CONST	SEGMENT
??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@ DB 'encodin'
	DB	'g name must be a string.', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getcodec
_TEXT	SEGMENT
self$ = 48
encoding$ = 56
getcodec PROC						; COMDAT

; 261  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 262  :     PyObject *codecobj, *r, *cofunc;
; 263  :     const MultibyteCodec *codec;
; 264  :     const char *enc;
; 265  : 
; 266  :     if (!PyUnicode_Check(encoding)) {

  00004	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00008	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00012	75 1a		 jne	 SHORT $LN9@getcodec

; 267  :         PyErr_SetString(PyExc_TypeError,
; 268  :                         "encoding name must be a string.");

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DAHDGLOA@encoding?5name?5must?5be?5a?5string?4?$AA@
  00022	e8 00 00 00 00	 call	 PyErr_SetString

; 269  :         return NULL;

  00027	33 c0		 xor	 eax, eax

; 297  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN9@getcodec:

; 270  :     }
; 271  :     enc = _PyUnicode_AsString(encoding);

  0002e	48 8b ca	 mov	 rcx, rdx
  00031	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00036	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  0003b	48 8b d8	 mov	 rbx, rax

; 272  :     if (enc == NULL)

  0003e	48 85 c0	 test	 rax, rax
  00041	75 0a		 jne	 SHORT $LN8@getcodec
  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 297  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN8@getcodec:
  0004d	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 273  :         return NULL;
; 274  : 
; 275  :     cofunc = getmultibytecodec();

  00052	e8 00 00 00 00	 call	 getmultibytecodec
  00057	48 8b f0	 mov	 rsi, rax

; 276  :     if (cofunc == NULL)

  0005a	48 85 c0	 test	 rax, rax

; 277  :         return NULL;

  0005d	74 60		 je	 SHORT $LN21@getcodec

; 278  : 
; 279  :     for (codec = codec_list; codec->encoding[0]; codec++)

  0005f	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR codec_list
  00066	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00069	80 38 00	 cmp	 BYTE PTR [rax], 0
  0006c	74 36		 je	 SHORT $LN17@getcodec
  0006e	66 90		 npad	 2
$LL6@getcodec:

; 280  :         if (strcmp(codec->encoding, enc) == 0)

  00070	4c 8b c3	 mov	 r8, rbx
  00073	4c 2b c0	 sub	 r8, rax
  00076	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL15@getcodec:
  00080	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00083	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  00088	2b d1		 sub	 edx, ecx
  0008a	75 07		 jne	 SHORT $LN16@getcodec
  0008c	48 ff c0	 inc	 rax
  0008f	85 c9		 test	 ecx, ecx
  00091	75 ed		 jne	 SHORT $LL15@getcodec
$LN16@getcodec:
  00093	85 d2		 test	 edx, edx
  00095	74 0d		 je	 SHORT $LN17@getcodec

; 278  : 
; 279  :     for (codec = codec_list; codec->encoding[0]; codec++)

  00097	49 8b 41 48	 mov	 rax, QWORD PTR [r9+72]
  0009b	49 83 c1 48	 add	 r9, 72			; 00000048H
  0009f	80 38 00	 cmp	 BYTE PTR [rax], 0
  000a2	75 cc		 jne	 SHORT $LL6@getcodec
$LN17@getcodec:

; 281  :             break;
; 282  : 
; 283  :     if (codec->encoding[0] == '\0') {

  000a4	49 8b 01	 mov	 rax, QWORD PTR [r9]
  000a7	80 38 00	 cmp	 BYTE PTR [rax], 0
  000aa	75 24		 jne	 SHORT $LN2@getcodec

; 284  :         PyErr_SetString(PyExc_LookupError,
; 285  :                         "no such codec is supported.");

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@KLNFDHAL@no?5such?5codec?5is?5supported?4?$AA@
  000ba	e8 00 00 00 00	 call	 PyErr_SetString
$LN21@getcodec:

; 286  :         return NULL;

  000bf	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c9	33 c0		 xor	 eax, eax

; 297  : }

  000cb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cf	c3		 ret	 0
$LN2@getcodec:

; 287  :     }
; 288  : 
; 289  :     codecobj = PyCapsule_New((void *)codec, PyMultibyteCodec_CAPSULE_NAME, NULL);

  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  000d7	45 33 c0	 xor	 r8d, r8d
  000da	49 8b c9	 mov	 rcx, r9
  000dd	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000e2	e8 00 00 00 00	 call	 PyCapsule_New
  000e7	48 8b f8	 mov	 rdi, rax

; 290  :     if (codecobj == NULL)

  000ea	48 85 c0	 test	 rax, rax
  000ed	75 14		 jne	 SHORT $LN1@getcodec
  000ef	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000f4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 297  : }

  000fe	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00102	c3		 ret	 0
$LN1@getcodec:

; 291  :         return NULL;
; 292  : 
; 293  :     r = PyObject_CallFunctionObjArgs(cofunc, codecobj, NULL);

  00103	45 33 c0	 xor	 r8d, r8d
  00106	48 8b d0	 mov	 rdx, rax
  00109	48 8b ce	 mov	 rcx, rsi
  0010c	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 294  :     Py_DECREF(codecobj);

  00111	48 8b cf	 mov	 rcx, rdi
  00114	48 8b d8	 mov	 rbx, rax
  00117	e8 00 00 00 00	 call	 _Py_DecRef
  0011c	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00121	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 295  : 
; 296  :     return r;

  00126	48 8b c3	 mov	 rax, rbx
  00129	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 297  : }

  0012e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00132	c3		 ret	 0
getcodec ENDP
_TEXT	ENDS
PUBLIC	??_C@_06MBDMAJKM@__map_?$AA@			; `string'
EXTRN	PyModule_AddObject:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$register_maps DD imagerel register_maps
	DD	imagerel register_maps+223
	DD	imagerel $unwind$register_maps
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$register_maps DD 050d01H
	DD	026340dH
	DD	024010dH
	DD	07006H
xdata	ENDS
;	COMDAT ??_C@_06MBDMAJKM@__map_?$AA@
CONST	SEGMENT
??_C@_06MBDMAJKM@__map_?$AA@ DB '__map_', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT register_maps
_TEXT	SEGMENT
mhname$20493 = 32
module$ = 304
register_maps PROC					; COMDAT

; 306  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 307  :     const struct dbcs_map *h;
; 308  : 
; 309  :     for (h = mapping_list; h->charset[0] != '\0'; h++) {

  0000d	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR mapping_list
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001a	80 38 00	 cmp	 BYTE PTR [rax], 0
  0001d	0f 84 95 00 00
	00		 je	 $LN2@register_m
$LL4@register_m:

; 310  :         char mhname[256] = "__map_";

  00023	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_06MBDMAJKM@__map_?$AA@
  00029	48 8d 4c 24 27	 lea	 rcx, QWORD PTR mhname$20493[rsp+7]
  0002e	33 d2		 xor	 edx, edx
  00030	89 44 24 20	 mov	 DWORD PTR mhname$20493[rsp], eax
  00034	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_06MBDMAJKM@__map_?$AA@+4
  0003b	41 b8 f9 00 00
	00		 mov	 r8d, 249		; 000000f9H
  00041	66 89 44 24 24	 mov	 WORD PTR mhname$20493[rsp+4], ax
  00046	0f b6 05 06 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_06MBDMAJKM@__map_?$AA@+6
  0004d	88 44 24 26	 mov	 BYTE PTR mhname$20493[rsp+6], al
  00051	e8 00 00 00 00	 call	 memset

; 311  :         int r;
; 312  :         strcpy(mhname + sizeof("__map_") - 1, h->charset);

  00056	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  00059	48 8d 4c 24 26	 lea	 rcx, QWORD PTR mhname$20493[rsp+6]
  0005e	49 2b cb	 sub	 rcx, r11
  00061	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL7@register_m:
  00070	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]
  00074	49 ff c3	 inc	 r11
  00077	42 88 44 19 ff	 mov	 BYTE PTR [rcx+r11-1], al
  0007c	84 c0		 test	 al, al
  0007e	75 f0		 jne	 SHORT $LL7@register_m

; 313  :         r = PyModule_AddObject(module, mhname,
; 314  :                         PyCapsule_New((void *)h, PyMultibyteCodec_CAPSULE_NAME, NULL));

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  00087	45 33 c0	 xor	 r8d, r8d
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 PyCapsule_New
  00092	48 8d 54 24 20	 lea	 rdx, QWORD PTR mhname$20493[rsp]
  00097	48 8b cf	 mov	 rcx, rdi
  0009a	4c 8b c0	 mov	 r8, rax
  0009d	e8 00 00 00 00	 call	 PyModule_AddObject

; 315  :         if (r == -1)

  000a2	83 f8 ff	 cmp	 eax, -1
  000a5	74 24		 je	 SHORT $LN10@register_m

; 307  :     const struct dbcs_map *h;
; 308  : 
; 309  :     for (h = mapping_list; h->charset[0] != '\0'; h++) {

  000a7	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000ab	48 83 c3 18	 add	 rbx, 24
  000af	80 38 00	 cmp	 BYTE PTR [rax], 0
  000b2	0f 85 6b ff ff
	ff		 jne	 $LL4@register_m
$LN2@register_m:

; 317  :     }
; 318  :     return 0;

  000b8	33 c0		 xor	 eax, eax

; 319  : }

  000ba	48 8b 9c 24 30
	01 00 00	 mov	 rbx, QWORD PTR [rsp+304]
  000c2	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
$LN10@register_m:

; 316  :             return -1;

  000cb	83 c8 ff	 or	 eax, -1

; 319  : }

  000ce	48 8b 9c 24 30
	01 00 00	 mov	 rbx, QWORD PTR [rsp+304]
  000d6	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
register_maps ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT find_pairencmap
_TEXT	SEGMENT
body$ = 8
modifier$ = 16
haystack$ = 24
haystacksize$ = 32
find_pairencmap PROC					; COMDAT

; 326  :     int pos, min, max;
; 327  :     ucs4_t value = body << 16 | modifier;

  00000	44 0f b7 d1	 movzx	 r10d, cx
  00004	0f b7 c2	 movzx	 eax, dx

; 328  : 
; 329  :     min = 0;
; 330  :     max = haystacksize;
; 331  : 
; 332  :     for (pos = haystacksize >> 1; min != max; pos = (min + max) >> 1)

  00007	41 8b c9	 mov	 ecx, r9d
  0000a	41 c1 e2 10	 shl	 r10d, 16
  0000e	33 d2		 xor	 edx, edx
  00010	d1 f9		 sar	 ecx, 1
  00012	44 0b d0	 or	 r10d, eax
  00015	4d 8b d8	 mov	 r11, r8
  00018	45 85 c9	 test	 r9d, r9d
  0001b	74 2c		 je	 SHORT $LN17@find_paire
  0001d	0f 1f 00	 npad	 3
$LL13@find_paire:

; 333  :         if (value < haystack[pos].uniseq) {

  00020	48 63 c1	 movsxd	 rax, ecx
  00023	45 8b 04 c3	 mov	 r8d, DWORD PTR [r11+rax*8]
  00027	45 3b d0	 cmp	 r10d, r8d
  0002a	73 0a		 jae	 SHORT $LN21@find_paire

; 334  :             if (max == pos) break;

  0002c	44 3b c9	 cmp	 r9d, ecx
  0002f	74 18		 je	 SHORT $LN17@find_paire

; 335  :             else max = pos;

  00031	44 8b c9	 mov	 r9d, ecx

; 336  :         }
; 337  :         else if (value > haystack[pos].uniseq) {

  00034	eb 08		 jmp	 SHORT $LN12@find_paire
$LN21@find_paire:
  00036	76 11		 jbe	 SHORT $LN17@find_paire

; 338  :             if (min == pos) break;

  00038	3b d1		 cmp	 edx, ecx
  0003a	74 0d		 je	 SHORT $LN17@find_paire

; 339  :             else min = pos;

  0003c	8b d1		 mov	 edx, ecx
$LN12@find_paire:

; 328  : 
; 329  :     min = 0;
; 330  :     max = haystacksize;
; 331  : 
; 332  :     for (pos = haystacksize >> 1; min != max; pos = (min + max) >> 1)

  0003e	41 8d 0c 11	 lea	 ecx, DWORD PTR [r9+rdx]
  00042	d1 f9		 sar	 ecx, 1
  00044	41 3b d1	 cmp	 edx, r9d
  00047	75 d7		 jne	 SHORT $LL13@find_paire
$LN17@find_paire:

; 340  :         }
; 341  :         else
; 342  :             break;
; 343  : 
; 344  :         if (value == haystack[pos].uniseq)

  00049	48 63 c1	 movsxd	 rax, ecx
  0004c	45 3b 14 c3	 cmp	 r10d, DWORD PTR [r11+rax*8]
  00050	75 07		 jne	 SHORT $LN2@find_paire

; 345  :             return haystack[pos].code;

  00052	41 0f b7 44 c3
	04		 movzx	 eax, WORD PTR [r11+rax*8+4]

; 348  : }

  00058	c3		 ret	 0
$LN2@find_paire:

; 346  :         else
; 347  :             return DBCINV;

  00059	b8 fd ff 00 00	 mov	 eax, 65533		; 0000fffdH

; 348  : }

  0005e	c3		 ret	 0
find_pairencmap ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@ ; `string'
EXTRN	PyCapsule_GetPointer:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyCapsule_IsValid:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$importmap DD imagerel importmap
	DD	imagerel importmap+191
	DD	imagerel $unwind$importmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$importmap DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@
CONST	SEGMENT
??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@ DB 'map data mu'
	DB	'st be a Capsule.', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT importmap
_TEXT	SEGMENT
modname$ = 48
symbol$ = 56
encmap$ = 64
decmap$ = 72
importmap PROC						; COMDAT

; 359  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f1	 mov	 rsi, r9
  00017	49 8b e8	 mov	 rbp, r8
  0001a	48 8b da	 mov	 rbx, rdx

; 360  :     PyObject *o, *mod;
; 361  : 
; 362  :     mod = PyImport_ImportModule((char *)modname);

  0001d	e8 00 00 00 00	 call	 PyImport_ImportModule
  00022	48 8b f8	 mov	 rdi, rax

; 363  :     if (mod == NULL)

  00025	48 85 c0	 test	 rax, rax

; 364  :         return -1;

  00028	74 41		 je	 SHORT $LN10@importmap

; 365  : 
; 366  :     o = PyObject_GetAttrString(mod, (char*)symbol);

  0002a	48 8b d3	 mov	 rdx, rbx
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00035	48 8b d8	 mov	 rbx, rax

; 367  :     if (o == NULL)

  00038	48 85 c0	 test	 rax, rax
  0003b	74 26		 je	 SHORT $errorexit$20545

; 368  :         goto errorexit;
; 369  :     else if (!PyCapsule_IsValid(o, PyMultibyteCodec_CAPSULE_NAME)) {

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 PyCapsule_IsValid
  0004c	85 c0		 test	 eax, eax
  0004e	75 33		 jne	 SHORT $LN4@importmap

; 370  :         PyErr_SetString(PyExc_ValueError,
; 371  :                         "map data must be a Capsule.");

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JBGGBAKI@map?5data?5must?5be?5a?5Capsule?4?$AA@
  0005e	e8 00 00 00 00	 call	 PyErr_SetString
$errorexit$20545:

; 386  : 
; 387  : errorexit:
; 388  :     Py_DECREF(mod);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@importmap:

; 389  :     return -1;

  0006b	83 c8 ff	 or	 eax, -1
$LN8@importmap:

; 390  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00078	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
$LN4@importmap:

; 372  :         goto errorexit;
; 373  :     }
; 374  :     else {
; 375  :         struct dbcs_map *map;
; 376  :         map = PyCapsule_GetPointer(o, PyMultibyteCodec_CAPSULE_NAME);

  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MFGEOELK@multibytecodec?4__map_?$CK?$AA@
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 PyCapsule_GetPointer

; 377  :         if (encmap != NULL)

  00092	48 85 ed	 test	 rbp, rbp
  00095	74 08		 je	 SHORT $LN2@importmap

; 378  :             *encmap = map->encmap;

  00097	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009b	48 89 4d 00	 mov	 QWORD PTR [rbp], rcx
$LN2@importmap:

; 379  :         if (decmap != NULL)

  0009f	48 85 f6	 test	 rsi, rsi
  000a2	74 07		 je	 SHORT $LN1@importmap

; 380  :             *decmap = map->decmap;

  000a4	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a8	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN1@importmap:

; 381  :         Py_DECREF(o);

  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 382  :     }
; 383  : 
; 384  :     Py_DECREF(mod);

  000b3	48 8b cf	 mov	 rcx, rdi
  000b6	e8 00 00 00 00	 call	 _Py_DecRef

; 385  :     return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb af		 jmp	 SHORT $LN8@importmap
importmap ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\cjkcodecs\_codecs_iso2022.c
pdata	SEGMENT
$pdata$iso2022_codec_init DD imagerel iso2022_codec_init
	DD	imagerel iso2022_codec_init+57
	DD	imagerel $unwind$iso2022_codec_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_codec_init DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso2022_codec_init
_TEXT	SEGMENT
config$ = 48
iso2022_codec_init PROC					; COMDAT

; 125  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 126  :     const struct iso2022_designation *desig;
; 127  :     for (desig = CONFIG_DESIGNATIONS; desig->mark; desig++)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  0000d	74 19		 je	 SHORT $LN10@iso2022_co
  0000f	90		 npad	 1
$LL4@iso2022_co:

; 128  :         if (desig->initializer != NULL && desig->initializer() != 0)

  00010	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00014	48 85 c0	 test	 rax, rax
  00017	74 06		 je	 SHORT $LN3@iso2022_co
  00019	ff d0		 call	 rax
  0001b	85 c0		 test	 eax, eax
  0001d	75 11		 jne	 SHORT $LN8@iso2022_co
$LN3@iso2022_co:

; 126  :     const struct iso2022_designation *desig;
; 127  :     for (desig = CONFIG_DESIGNATIONS; desig->mark; desig++)

  0001f	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00023	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  00026	75 e8		 jne	 SHORT $LL4@iso2022_co
$LN10@iso2022_co:

; 130  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 131  : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN8@iso2022_co:

; 129  :             return -1;

  00030	83 c8 ff	 or	 eax, -1

; 131  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
iso2022_codec_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT iso2022_encode_init
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_encode_init PROC				; COMDAT

; 135  :     STATE_CLEARFLAGS()

  00000	c6 41 04 00	 mov	 BYTE PTR [rcx+4], 0

; 136  :     STATE_SETG0(CHARSET_ASCII)

  00004	66 c7 01 42 42	 mov	 WORD PTR [rcx], 16962	; 00004242H

; 137  :     STATE_SETG1(CHARSET_ASCII)
; 138  :     return 0;

  00009	33 c0		 xor	 eax, eax

; 139  : }

  0000b	c3		 ret	 0
iso2022_encode_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT iso2022_encode_reset
_TEXT	SEGMENT
state$ = 8
config$ = 16
outbuf$ = 24
outleft$ = 32
iso2022_encode_reset PROC				; COMDAT

; 143  :     if (STATE_GETFLAG(F_SHIFTED)) {

  00000	f6 41 04 01	 test	 BYTE PTR [rcx+4], 1
  00004	74 1b		 je	 SHORT $LN4@iso2022_en

; 144  :         WRITE1(SI)

  00006	49 83 f9 01	 cmp	 r9, 1
  0000a	7d 05		 jge	 SHORT $LN3@iso2022_en
$LN7@iso2022_en:
  0000c	48 83 c8 ff	 or	 rax, -1

; 154  : }

  00010	c3		 ret	 0
$LN3@iso2022_en:

; 144  :         WRITE1(SI)

  00011	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 145  :         NEXT_OUT(1)

  00014	49 ff c9	 dec	 r9
  00017	c6 00 0f	 mov	 BYTE PTR [rax], 15
  0001a	49 ff 00	 inc	 QWORD PTR [r8]

; 146  :         STATE_CLEARFLAG(F_SHIFTED)

  0001d	80 61 04 fe	 and	 BYTE PTR [rcx+4], 254	; 000000feH
$LN4@iso2022_en:

; 147  :     }
; 148  :     if (STATE_G0 != CHARSET_ASCII) {

  00021	80 39 42	 cmp	 BYTE PTR [rcx], 66	; 00000042H
  00024	74 21		 je	 SHORT $LN2@iso2022_en

; 149  :         WRITE3(ESC, '(', 'B')

  00026	49 83 f9 03	 cmp	 r9, 3
  0002a	7c e0		 jl	 SHORT $LN7@iso2022_en
  0002c	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0002f	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00032	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00035	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  00039	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003c	c6 40 02 42	 mov	 BYTE PTR [rax+2], 66	; 00000042H

; 150  :         NEXT_OUT(3)

  00040	49 83 00 03	 add	 QWORD PTR [r8], 3

; 151  :         STATE_SETG0(CHARSET_ASCII)

  00044	c6 01 42	 mov	 BYTE PTR [rcx], 66	; 00000042H
$LN2@iso2022_en:

; 152  :     }
; 153  :     return 0;

  00047	33 c0		 xor	 eax, eax

; 154  : }

  00049	c3		 ret	 0
iso2022_encode_reset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022_encode DD imagerel iso2022_encode
	DD	imagerel iso2022_encode+1056
	DD	imagerel $unwind$iso2022_encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_encode DD 0a1901H
	DD	0e3419H
	DD	0f0155219H
	DD	0d011e013H
	DD	0700dc00fH
	DD	0500b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso2022_encode
_TEXT	SEGMENT
length$20714 = 32
u4in$20720 = 40
state$ = 112
config$ = 120
inbuf$ = 128
c$20696 = 136
inleft$ = 136
outbuf$ = 144
outleft$ = 152
flags$ = 160
iso2022_encode PROC					; COMDAT

; 157  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00019	4d 8b e1	 mov	 r12, r9
  0001c	4d 8b f0	 mov	 r14, r8
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	4c 8b ca	 mov	 r9, rdx

; 158  :     while (inleft > 0) {

  00025	4d 85 e4	 test	 r12, r12
  00028	0f 8e c3 03 00
	00		 jle	 $LN49@iso2022_en@2
  0002e	44 8b bc 24 a0
	00 00 00	 mov	 r15d, DWORD PTR flags$[rsp]
  00036	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR outbuf$[rsp]
  0003e	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR outleft$[rsp]
  00046	bb 00 dc 00 00	 mov	 ebx, 56320		; 0000dc00H
  0004b	41 bb 00 fc 00
	00		 mov	 r11d, 64512		; 0000fc00H
  00051	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL50@iso2022_en@2:

; 159  :         const struct iso2022_designation *dsg;
; 160  :         DBCHAR encoded;
; 161  :         ucs4_t c = **inbuf;

  00060	49 8b 16	 mov	 rdx, QWORD PTR [r14]
  00063	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00066	89 8c 24 88 00
	00 00		 mov	 DWORD PTR c$20696[rsp], ecx

; 162  :         Py_ssize_t insize;
; 163  : 
; 164  :         if (c < 0x80) {

  0006d	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00073	73 7f		 jae	 SHORT $LN48@iso2022_en@2

; 165  :             if (STATE_G0 != CHARSET_ASCII) {

  00075	80 7d 00 42	 cmp	 BYTE PTR [rbp], 66	; 00000042H
  00079	74 31		 je	 SHORT $LN47@iso2022_en@2

; 166  :                 WRITE3(ESC, '(', 'B')

  0007b	48 83 ff 03	 cmp	 rdi, 3
  0007f	0f 8c 83 03 00
	00		 jl	 $LN59@iso2022_en@2
  00085	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00088	c6 00 1b	 mov	 BYTE PTR [rax], 27
  0008b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0008e	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  00092	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00095	c6 40 02 42	 mov	 BYTE PTR [rax+2], 66	; 00000042H

; 167  :                 STATE_SETG0(CHARSET_ASCII)
; 168  :                 NEXT_OUT(3)

  00099	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR c$20696[rsp]
  000a0	c6 45 00 42	 mov	 BYTE PTR [rbp], 66	; 00000042H
  000a4	48 83 06 03	 add	 QWORD PTR [rsi], 3
  000a8	48 83 ef 03	 sub	 rdi, 3
$LN47@iso2022_en@2:

; 169  :             }
; 170  :             if (STATE_GETFLAG(F_SHIFTED)) {

  000ac	f6 45 04 01	 test	 BYTE PTR [rbp+4], 1
  000b0	74 21		 je	 SHORT $LN45@iso2022_en@2

; 171  :                 WRITE1(SI)

  000b2	48 83 ff 01	 cmp	 rdi, 1
  000b6	0f 8c 4c 03 00
	00		 jl	 $LN59@iso2022_en@2
  000bc	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000bf	c6 00 0f	 mov	 BYTE PTR [rax], 15

; 172  :                 STATE_CLEARFLAG(F_SHIFTED)

  000c2	80 65 04 fe	 and	 BYTE PTR [rbp+4], 254	; 000000feH

; 173  :                 NEXT_OUT(1)

  000c6	48 ff 06	 inc	 QWORD PTR [rsi]
  000c9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR c$20696[rsp]
  000d0	48 ff cf	 dec	 rdi
$LN45@iso2022_en@2:

; 174  :             }
; 175  :             WRITE1((unsigned char)c)

  000d3	48 83 ff 01	 cmp	 rdi, 1
  000d7	0f 8c 2b 03 00
	00		 jl	 $LN59@iso2022_en@2
  000dd	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 176  :             NEXT(1, 1)

  000e0	49 ff cc	 dec	 r12
  000e3	88 08		 mov	 BYTE PTR [rax], cl
  000e5	49 83 06 02	 add	 QWORD PTR [r14], 2
  000e9	48 ff 06	 inc	 QWORD PTR [rsi]
  000ec	48 ff cf	 dec	 rdi

; 177  :             continue;

  000ef	e9 f4 02 00 00	 jmp	 $LN74@iso2022_en@2
$LN48@iso2022_en@2:

; 178  :         }
; 179  : 
; 180  :         DECODE_SURROGATE(c)

  000f4	8b c1		 mov	 eax, ecx
  000f6	25 00 fc ff ff	 and	 eax, -1024		; fffffc00H
  000fb	3d 00 d8 00 00	 cmp	 eax, 55296		; 0000d800H
  00100	75 32		 jne	 SHORT $LN40@iso2022_en@2
  00102	49 83 fc 02	 cmp	 r12, 2
  00106	0f 8c 02 03 00
	00		 jl	 $LN62@iso2022_en@2
  0010c	44 0f b7 42 02	 movzx	 r8d, WORD PTR [rdx+2]
  00111	41 0f b7 c0	 movzx	 eax, r8w
  00115	66 41 23 c3	 and	 ax, r11w
  00119	66 3b c3	 cmp	 ax, bx
  0011c	75 16		 jne	 SHORT $LN40@iso2022_en@2
  0011e	81 c1 09 28 ff
	ff		 add	 ecx, -55287		; ffff2809H
  00124	41 0f b7 c0	 movzx	 eax, r8w
  00128	c1 e1 0a	 shl	 ecx, 10
  0012b	03 c8		 add	 ecx, eax
  0012d	89 8c 24 88 00
	00 00		 mov	 DWORD PTR c$20696[rsp], ecx
$LN40@iso2022_en@2:

; 181  :         insize = GET_INSIZE(c);
; 182  : 
; 183  :         encoded = MAP_UNMAPPABLE;
; 184  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++) {

  00134	49 8b 59 08	 mov	 rbx, QWORD PTR [r9+8]
  00138	45 33 ed	 xor	 r13d, r13d
  0013b	41 3b ca	 cmp	 ecx, r10d
  0013e	41 0f 97 c5	 seta	 r13b
  00142	49 ff c5	 inc	 r13
  00145	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  00148	0f 84 04 01 00
	00		 je	 $LN63@iso2022_en@2
  0014e	66 90		 npad	 2
$LL39@iso2022_en@2:

; 185  :             Py_ssize_t length = 1;
; 186  :             encoded = dsg->encoder(&c, &length);

  00150	48 8d 54 24 20	 lea	 rdx, QWORD PTR length$20714[rsp]
  00155	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR c$20696[rsp]
  0015d	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR length$20714[rsp], 1
  00166	ff 53 18	 call	 QWORD PTR [rbx+24]
  00169	44 0f b7 d8	 movzx	 r11d, ax

; 187  :             if (encoded == MAP_MULTIPLE_AVAIL) {

  0016d	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  00172	66 44 3b d8	 cmp	 r11w, ax
  00176	0f 85 bd 00 00
	00		 jne	 $LN36@iso2022_en@2

; 188  :                 /* this implementation won't work for pair
; 189  :                  * of non-bmp characters. */
; 190  :                 if (inleft < 2) {

  0017c	49 83 fc 02	 cmp	 r12, 2
  00180	7d 1d		 jge	 SHORT $LN35@iso2022_en@2

; 191  :                     if (!(flags & MBENC_FLUSH))

  00182	41 f6 c7 01	 test	 r15b, 1
  00186	0f 84 82 02 00
	00		 je	 $LN62@iso2022_en@2

; 192  :                         return MBERR_TOOFEW;
; 193  :                     length = -1;

  0018c	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR length$20714[rsp], -1

; 203  :                 } else
; 204  :                     encoded = dsg->encoder(&c, &length);

  00195	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR c$20696[rsp]
  0019d	eb 20		 jmp	 SHORT $LN79@iso2022_en@2
$LN35@iso2022_en@2:

; 194  :                 }
; 195  :                 else
; 196  :                     length = 2;
; 197  : #if Py_UNICODE_SIZE == 2
; 198  :                 if (length == 2) {
; 199  :                     ucs4_t u4in[2];
; 200  :                     u4in[0] = (ucs4_t)IN1;

  0019f	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  001a2	48 c7 44 24 20
	02 00 00 00	 mov	 QWORD PTR length$20714[rsp], 2
  001ab	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001ae	89 44 24 28	 mov	 DWORD PTR u4in$20720[rsp], eax

; 201  :                     u4in[1] = (ucs4_t)IN2;

  001b2	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]

; 202  :                     encoded = dsg->encoder(u4in, &length);

  001b6	48 8d 4c 24 28	 lea	 rcx, QWORD PTR u4in$20720[rsp]
  001bb	89 44 24 2c	 mov	 DWORD PTR u4in$20720[rsp+4], eax
$LN79@iso2022_en@2:
  001bf	48 8d 54 24 20	 lea	 rdx, QWORD PTR length$20714[rsp]
  001c4	ff 53 18	 call	 QWORD PTR [rbx+24]

; 205  : #else
; 206  :                 encoded = dsg->encoder(&c, &length);
; 207  : #endif
; 208  :                 if (encoded != MAP_UNMAPPABLE) {

  001c7	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  001cd	44 0f b7 d8	 movzx	 r11d, ax
  001d1	66 41 3b c2	 cmp	 ax, r10w
  001d5	74 6e		 je	 SHORT $LN38@iso2022_en@2

; 209  :                     insize = length;

  001d7	4c 8b 6c 24 20	 mov	 r13, QWORD PTR length$20714[rsp]
$LN58@iso2022_en@2:

; 214  :                 break;
; 215  :         }
; 216  : 
; 217  :         if (!dsg->mark)

  001dc	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  001df	84 d2		 test	 dl, dl
  001e1	74 6f		 je	 SHORT $LN63@iso2022_en@2

; 219  :         assert(dsg->width == 1 || dsg->width == 2);
; 220  : 
; 221  :         switch (dsg->plane) {

  001e3	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]
  001e7	85 c9		 test	 ecx, ecx
  001e9	0f 84 ce 00 00
	00		 je	 $LN24@iso2022_en@2
  001ef	ff c9		 dec	 ecx
  001f1	0f 85 20 02 00
	00		 jne	 $LN78@iso2022_en@2

; 244  :                 }
; 245  :             }
; 246  :             break;
; 247  :         case 1: /* G1 */
; 248  :             if (STATE_G1 != dsg->mark) {

  001f7	38 55 01	 cmp	 BYTE PTR [rbp+1], dl
  001fa	0f 84 94 00 00
	00		 je	 $LN9@iso2022_en@2

; 249  :                 if (dsg->width == 1) {

  00200	80 7b 02 01	 cmp	 BYTE PTR [rbx+2], 1
  00204	75 56		 jne	 SHORT $LN11@iso2022_en@2

; 250  :                     WRITE3(ESC, ')', ESCMARK(dsg->mark))

  00206	48 83 ff 03	 cmp	 rdi, 3
  0020a	0f 8c f8 01 00
	00		 jl	 $LN59@iso2022_en@2
  00210	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00213	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00216	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00219	c6 40 01 29	 mov	 BYTE PTR [rax+1], 41	; 00000029H
  0021d	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00220	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00223	80 e1 7f	 and	 cl, 127			; 0000007fH
  00226	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 251  :                     STATE_SETG1(dsg->mark)

  00229	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0022c	88 45 01	 mov	 BYTE PTR [rbp+1], al

; 252  :                     NEXT_OUT(3)

  0022f	48 83 06 03	 add	 QWORD PTR [rsi], 3
  00233	48 83 ef 03	 sub	 rdi, 3

; 253  :                 }
; 254  :                 else {

  00237	eb 5b		 jmp	 SHORT $LN9@iso2022_en@2
$LN36@iso2022_en@2:

; 210  :                     break;
; 211  :                 }
; 212  :             }
; 213  :             else if (encoded != MAP_UNMAPPABLE)

  00239	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  0023f	66 45 3b da	 cmp	 r11w, r10w
  00243	75 97		 jne	 SHORT $LN58@iso2022_en@2
$LN38@iso2022_en@2:

; 181  :         insize = GET_INSIZE(c);
; 182  : 
; 183  :         encoded = MAP_UNMAPPABLE;
; 184  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++) {

  00245	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00249	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  0024c	0f 85 fe fe ff
	ff		 jne	 $LL39@iso2022_en@2
$LN63@iso2022_en@2:

; 218  :             return 1;

  00252	b8 01 00 00 00	 mov	 eax, 1
  00257	e9 97 01 00 00	 jmp	 $LN51@iso2022_en@2
$LN11@iso2022_en@2:

; 255  :                     WRITE4(ESC, '$', ')',
; 256  :                         ESCMARK(dsg->mark))

  0025c	48 83 ff 04	 cmp	 rdi, 4
  00260	0f 8c a2 01 00
	00		 jl	 $LN59@iso2022_en@2
  00266	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00269	c6 00 1b	 mov	 BYTE PTR [rax], 27
  0026c	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0026f	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  00273	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00276	c6 40 02 29	 mov	 BYTE PTR [rax+2], 41	; 00000029H
  0027a	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0027d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00280	80 e1 7f	 and	 cl, 127			; 0000007fH
  00283	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 257  :                     STATE_SETG1(dsg->mark)

  00286	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00289	88 45 01	 mov	 BYTE PTR [rbp+1], al

; 258  :                     NEXT_OUT(4)

  0028c	48 83 06 04	 add	 QWORD PTR [rsi], 4
  00290	48 83 ef 04	 sub	 rdi, 4
$LN9@iso2022_en@2:

; 259  :                 }
; 260  :             }
; 261  :             if (!STATE_GETFLAG(F_SHIFTED)) {

  00294	f6 45 04 01	 test	 BYTE PTR [rbp+4], 1
  00298	0f 85 f3 00 00
	00		 jne	 $LN15@iso2022_en@2

; 262  :                 WRITE1(SO)

  0029e	48 83 ff 01	 cmp	 rdi, 1
  002a2	0f 8c 60 01 00
	00		 jl	 $LN59@iso2022_en@2
  002a8	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  002ab	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 263  :                 STATE_SETFLAG(F_SHIFTED)

  002ae	80 4d 04 01	 or	 BYTE PTR [rbp+4], 1

; 264  :                 NEXT_OUT(1)

  002b2	48 ff 06	 inc	 QWORD PTR [rsi]
  002b5	48 ff cf	 dec	 rdi

; 265  :             }
; 266  :             break;

  002b8	e9 d4 00 00 00	 jmp	 $LN15@iso2022_en@2
$LN24@iso2022_en@2:

; 222  :         case 0: /* G0 */
; 223  :             if (STATE_GETFLAG(F_SHIFTED)) {

  002bd	f6 45 04 01	 test	 BYTE PTR [rbp+4], 1
  002c1	74 1a		 je	 SHORT $LN23@iso2022_en@2

; 224  :                 WRITE1(SI)

  002c3	48 83 ff 01	 cmp	 rdi, 1
  002c7	0f 8c 3b 01 00
	00		 jl	 $LN59@iso2022_en@2
  002cd	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  002d0	c6 00 0f	 mov	 BYTE PTR [rax], 15

; 225  :                 STATE_CLEARFLAG(F_SHIFTED)

  002d3	80 65 04 fe	 and	 BYTE PTR [rbp+4], 254	; 000000feH

; 226  :                 NEXT_OUT(1)

  002d7	48 ff 06	 inc	 QWORD PTR [rsi]
  002da	48 ff cf	 dec	 rdi
$LN23@iso2022_en@2:

; 227  :             }
; 228  :             if (STATE_G0 != dsg->mark) {

  002dd	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  002e0	38 45 00	 cmp	 BYTE PTR [rbp], al
  002e3	0f 84 a8 00 00
	00		 je	 $LN15@iso2022_en@2

; 229  :                 if (dsg->width == 1) {

  002e9	80 7b 02 01	 cmp	 BYTE PTR [rbx+2], 1
  002ed	75 33		 jne	 SHORT $LN20@iso2022_en@2

; 230  :                     WRITE3(ESC, '(', ESCMARK(dsg->mark))

  002ef	48 83 ff 03	 cmp	 rdi, 3
  002f3	0f 8c 0f 01 00
	00		 jl	 $LN59@iso2022_en@2
  002f9	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  002fc	c6 00 1b	 mov	 BYTE PTR [rax], 27
  002ff	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00302	c6 40 01 28	 mov	 BYTE PTR [rax+1], 40	; 00000028H
  00306	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00309	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0030c	80 e1 7f	 and	 cl, 127			; 0000007fH
  0030f	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 231  :                     STATE_SETG0(dsg->mark)

  00312	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00315	88 45 00	 mov	 BYTE PTR [rbp], al

; 232  :                     NEXT_OUT(3)

  00318	48 83 06 03	 add	 QWORD PTR [rsi], 3
  0031c	48 83 ef 03	 sub	 rdi, 3
  00320	eb 6f		 jmp	 SHORT $LN15@iso2022_en@2
$LN20@iso2022_en@2:

; 233  :                 }
; 234  :                 else if (dsg->mark == CHARSET_JISX0208) {

  00322	3c c2		 cmp	 al, 194			; 000000c2H
  00324	75 33		 jne	 SHORT $LN17@iso2022_en@2

; 235  :                     WRITE3(ESC, '$', ESCMARK(dsg->mark))

  00326	48 83 ff 03	 cmp	 rdi, 3
  0032a	0f 8c d8 00 00
	00		 jl	 $LN59@iso2022_en@2
  00330	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00333	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00336	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00339	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  0033d	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00340	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00343	80 e1 7f	 and	 cl, 127			; 0000007fH
  00346	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 236  :                     STATE_SETG0(dsg->mark)

  00349	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0034c	88 45 00	 mov	 BYTE PTR [rbp], al

; 237  :                     NEXT_OUT(3)

  0034f	48 83 06 03	 add	 QWORD PTR [rsi], 3
  00353	48 83 ef 03	 sub	 rdi, 3

; 238  :                 }
; 239  :                 else {

  00357	eb 38		 jmp	 SHORT $LN15@iso2022_en@2
$LN17@iso2022_en@2:

; 240  :                     WRITE4(ESC, '$', '(',
; 241  :                         ESCMARK(dsg->mark))

  00359	48 83 ff 04	 cmp	 rdi, 4
  0035d	0f 8c a5 00 00
	00		 jl	 $LN59@iso2022_en@2
  00363	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00366	c6 00 1b	 mov	 BYTE PTR [rax], 27
  00369	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0036c	c6 40 01 24	 mov	 BYTE PTR [rax+1], 36	; 00000024H
  00370	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00373	c6 40 02 28	 mov	 BYTE PTR [rax+2], 40	; 00000028H
  00377	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0037a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0037d	80 e1 7f	 and	 cl, 127			; 0000007fH
  00380	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 242  :                     STATE_SETG0(dsg->mark)

  00383	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00386	88 45 00	 mov	 BYTE PTR [rbp], al

; 243  :                     NEXT_OUT(4)

  00389	48 83 06 04	 add	 QWORD PTR [rsi], 4
  0038d	48 83 ef 04	 sub	 rdi, 4
$LN15@iso2022_en@2:

; 270  :         }
; 271  : 
; 272  :         if (dsg->width == 1) {

  00391	80 7b 02 01	 cmp	 BYTE PTR [rbx+2], 1
  00395	75 14		 jne	 SHORT $LN4@iso2022_en@2

; 273  :             WRITE1((unsigned char)encoded)

  00397	48 83 ff 01	 cmp	 rdi, 1
  0039b	7c 6b		 jl	 SHORT $LN59@iso2022_en@2
  0039d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  003a0	44 88 18	 mov	 BYTE PTR [rax], r11b

; 274  :             NEXT_OUT(1)

  003a3	48 ff 06	 inc	 QWORD PTR [rsi]
  003a6	48 ff cf	 dec	 rdi

; 275  :         }
; 276  :         else {

  003a9	eb 22		 jmp	 SHORT $LN2@iso2022_en@2
$LN4@iso2022_en@2:

; 277  :             WRITE2(encoded >> 8, encoded & 0xff)

  003ab	48 83 ff 02	 cmp	 rdi, 2
  003af	7c 57		 jl	 SHORT $LN59@iso2022_en@2
  003b1	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  003b4	41 0f b7 cb	 movzx	 ecx, r11w
  003b8	66 c1 e9 08	 shr	 cx, 8
  003bc	88 08		 mov	 BYTE PTR [rax], cl
  003be	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  003c1	44 88 58 01	 mov	 BYTE PTR [rax+1], r11b

; 278  :             NEXT_OUT(2)

  003c5	48 83 06 02	 add	 QWORD PTR [rsi], 2
  003c9	48 83 ef 02	 sub	 rdi, 2
$LN2@iso2022_en@2:

; 279  :         }
; 280  :         NEXT_IN(insize)

  003cd	4c 8b 4c 24 78	 mov	 r9, QWORD PTR config$[rsp]
  003d2	4b 8d 44 2d 00	 lea	 rax, QWORD PTR [r13+r13]
  003d7	bb 00 dc 00 00	 mov	 ebx, 56320		; 0000dc00H
  003dc	49 01 06	 add	 QWORD PTR [r14], rax
  003df	4d 2b e5	 sub	 r12, r13
  003e2	41 bb 00 fc 00
	00		 mov	 r11d, 64512		; 0000fc00H
$LN74@iso2022_en@2:

; 158  :     while (inleft > 0) {

  003e8	4d 85 e4	 test	 r12, r12
  003eb	0f 8f 6f fc ff
	ff		 jg	 $LL50@iso2022_en@2
$LN49@iso2022_en@2:

; 281  :     }
; 282  : 
; 283  :     return 0;

  003f1	33 c0		 xor	 eax, eax
$LN51@iso2022_en@2:

; 284  : }

  003f3	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  003f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003fc	41 5f		 pop	 r15
  003fe	41 5e		 pop	 r14
  00400	41 5d		 pop	 r13
  00402	41 5c		 pop	 r12
  00404	5f		 pop	 rdi
  00405	5e		 pop	 rsi
  00406	5d		 pop	 rbp
  00407	c3		 ret	 0
$LN59@iso2022_en@2:

; 166  :                 WRITE3(ESC, '(', 'B')

  00408	48 83 c8 ff	 or	 rax, -1
  0040c	eb e5		 jmp	 SHORT $LN51@iso2022_en@2
$LN62@iso2022_en@2:

; 178  :         }
; 179  : 
; 180  :         DECODE_SURROGATE(c)

  0040e	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00415	eb dc		 jmp	 SHORT $LN51@iso2022_en@2
$LN78@iso2022_en@2:

; 267  :         default: /* G2 and G3 is not supported: no encoding in
; 268  :                   * CJKCodecs are using them yet */
; 269  :             return MBERR_INTERNAL;

  00417	48 c7 c0 fd ff
	ff ff		 mov	 rax, -3
  0041e	eb d3		 jmp	 SHORT $LN51@iso2022_en@2
iso2022_encode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT iso2022_decode_init
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_decode_init PROC				; COMDAT

; 288  :     STATE_CLEARFLAGS()

  00000	c6 41 04 00	 mov	 BYTE PTR [rcx+4], 0

; 289  :     STATE_SETG0(CHARSET_ASCII)

  00004	66 c7 01 42 42	 mov	 WORD PTR [rcx], 16962	; 00004242H

; 290  :     STATE_SETG1(CHARSET_ASCII)
; 291  :     STATE_SETG2(CHARSET_ASCII)

  00009	c6 41 02 42	 mov	 BYTE PTR [rcx+2], 66	; 00000042H

; 292  :     return 0;

  0000d	33 c0		 xor	 eax, eax

; 293  : }

  0000f	c3		 ret	 0
iso2022_decode_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT iso2022_decode_reset
_TEXT	SEGMENT
state$ = 8
config$ = 16
iso2022_decode_reset PROC				; COMDAT

; 297  :     STATE_SETG0(CHARSET_ASCII)
; 298  :     STATE_CLEARFLAG(F_SHIFTED)

  00000	80 61 04 fe	 and	 BYTE PTR [rcx+4], 254	; 000000feH
  00004	c6 01 42	 mov	 BYTE PTR [rcx], 66	; 00000042H

; 299  :     return 0;

  00007	33 c0		 xor	 eax, eax

; 300  : }

  00009	c3		 ret	 0
iso2022_decode_reset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022processesc DD imagerel iso2022processesc
	DD	imagerel iso2022processesc+434
	DD	imagerel $unwind$iso2022processesc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022processesc DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso2022processesc
_TEXT	SEGMENT
config$ = 8
state$ = 16
inbuf$ = 24
inleft$ = 32
iso2022processesc PROC					; COMDAT

; 305  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	4d 8b 19	 mov	 r11, QWORD PTR [r9]

; 306  :     unsigned char charset, designation;
; 307  :     Py_ssize_t i, esclen;
; 308  : 
; 309  :     for (i = 1;i < MAX_ESCSEQLEN;i++) {

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	49 8b f1	 mov	 rsi, r9
  0001f	49 8b d8	 mov	 rbx, r8
  00022	48 8b ea	 mov	 rbp, rdx
  00025	48 8b f9	 mov	 rdi, rcx
  00028	44 8d 50 01	 lea	 r10d, QWORD PTR [rax+1]
  0002c	0f 1f 40 00	 npad	 4
$LL37@iso2022pro:

; 310  :         if (i >= *inleft)

  00030	49 3b c3	 cmp	 rax, r11
  00033	0f 8d 5d 01 00
	00		 jge	 $LN42@iso2022pro

; 312  :         if (IS_ESCEND((*inbuf)[i])) {

  00039	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  0003c	45 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+rax]
  00041	41 80 f8 41	 cmp	 r8b, 65			; 00000041H
  00045	72 06		 jb	 SHORT $LN31@iso2022pro
  00047	41 80 f8 5a	 cmp	 r8b, 90			; 0000005aH
  0004b	76 3c		 jbe	 SHORT $LN32@iso2022pro
$LN31@iso2022pro:
  0004d	41 80 f8 40	 cmp	 r8b, 64			; 00000040H
  00051	74 36		 je	 SHORT $LN32@iso2022pro

; 314  :             break;
; 315  :         }
; 316  :         else if (CONFIG_ISSET(USE_JISX0208_EXT) && i+1 < *inleft &&
; 317  :                  (*inbuf)[i] == '&' && (*inbuf)[i+1] == '@')

  00053	f6 01 04	 test	 BYTE PTR [rcx], 4
  00056	74 1b		 je	 SHORT $LN36@iso2022pro
  00058	4d 3b d3	 cmp	 r10, r11
  0005b	7d 16		 jge	 SHORT $LN36@iso2022pro
  0005d	41 80 f8 26	 cmp	 r8b, 38			; 00000026H
  00061	75 10		 jne	 SHORT $LN36@iso2022pro
  00063	41 80 7c 01 01
	40		 cmp	 BYTE PTR [r9+rax+1], 64	; 00000040H
  00069	75 08		 jne	 SHORT $LN36@iso2022pro

; 318  :             i += 2;

  0006b	48 83 c0 02	 add	 rax, 2
  0006f	49 83 c2 02	 add	 r10, 2
$LN36@iso2022pro:

; 306  :     unsigned char charset, designation;
; 307  :     Py_ssize_t i, esclen;
; 308  : 
; 309  :     for (i = 1;i < MAX_ESCSEQLEN;i++) {

  00073	48 ff c0	 inc	 rax
  00076	49 ff c2	 inc	 r10
  00079	48 83 f8 10	 cmp	 rax, 16
  0007d	7c b1		 jl	 SHORT $LL37@iso2022pro

; 322  :         return 1; /* unterminated escape sequence */

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	e9 14 01 00 00	 jmp	 $LN38@iso2022pro
$LN32@iso2022pro:

; 313  :             esclen = i + 1;

  00089	4c 8d 48 01	 lea	 r9, QWORD PTR [rax+1]

; 319  :     }
; 320  : 
; 321  :     if (i >= MAX_ESCSEQLEN)

  0008d	48 83 f8 10	 cmp	 rax, 16
  00091	7c 0a		 jl	 SHORT $LN28@iso2022pro

; 322  :         return 1; /* unterminated escape sequence */

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	e9 00 01 00 00	 jmp	 $LN38@iso2022pro
$LN28@iso2022pro:

; 323  : 
; 324  :     switch (esclen) {

  0009d	49 8b c9	 mov	 rcx, r9
  000a0	48 83 e9 03	 sub	 rcx, 3
  000a4	74 70		 je	 SHORT $LN25@iso2022pro
  000a6	48 ff c9	 dec	 rcx
  000a9	74 39		 je	 SHORT $LN16@iso2022pro
  000ab	48 83 e9 02	 sub	 rcx, 2
  000af	74 08		 je	 SHORT $LN10@iso2022pro
$LN48@iso2022pro:

; 358  :     default:
; 359  :         return esclen;

  000b1	49 8b c1	 mov	 rax, r9
  000b4	e9 e4 00 00 00	 jmp	 $LN38@iso2022pro
$LN10@iso2022pro:

; 348  :     case 6: /* designation with prefix */
; 349  :         if (CONFIG_ISSET(USE_JISX0208_EXT) &&
; 350  :             (*inbuf)[3] == ESC && (*inbuf)[4] == '$' &&
; 351  :             (*inbuf)[5] == 'B') {

  000b9	f6 07 04	 test	 BYTE PTR [rdi], 4
  000bc	74 1c		 je	 SHORT $LN9@iso2022pro
  000be	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000c1	80 78 03 1b	 cmp	 BYTE PTR [rax+3], 27
  000c5	75 13		 jne	 SHORT $LN9@iso2022pro
  000c7	80 78 04 24	 cmp	 BYTE PTR [rax+4], 36	; 00000024H
  000cb	75 0d		 jne	 SHORT $LN9@iso2022pro
  000cd	80 78 05 42	 cmp	 BYTE PTR [rax+5], 66	; 00000042H
  000d1	75 07		 jne	 SHORT $LN9@iso2022pro

; 352  :             charset = 'B' | CHARSET_DBCS;

  000d3	b2 c2		 mov	 dl, 194			; 000000c2H

; 353  :             designation = 0;

  000d5	45 32 c0	 xor	 r8b, r8b

; 357  :         break;

  000d8	eb 76		 jmp	 SHORT $LN47@iso2022pro
$LN9@iso2022pro:

; 354  :         }
; 355  :         else
; 356  :             return 6;

  000da	b8 06 00 00 00	 mov	 eax, 6
  000df	e9 b9 00 00 00	 jmp	 $LN38@iso2022pro
$LN16@iso2022pro:

; 337  :         }
; 338  :         break;
; 339  :     case 4:
; 340  :         if (IN2 != '$')

  000e4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e7	80 78 01 24	 cmp	 BYTE PTR [rax+1], 36	; 00000024H
  000eb	74 0a		 je	 SHORT $LN15@iso2022pro
$LN12@iso2022pro:

; 341  :             return 4;

  000ed	b8 04 00 00 00	 mov	 eax, 4
  000f2	e9 a6 00 00 00	 jmp	 $LN38@iso2022pro
$LN15@iso2022pro:

; 342  : 
; 343  :         charset = IN4 | CHARSET_DBCS;

  000f7	0f b6 50 03	 movzx	 edx, BYTE PTR [rax+3]

; 344  :         if (IN3 == '(') designation = 0;

  000fb	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000ff	80 ca 80	 or	 dl, 128			; 00000080H
  00102	80 f9 28	 cmp	 cl, 40			; 00000028H
  00105	75 05		 jne	 SHORT $LN14@iso2022pro
  00107	45 32 c0	 xor	 r8b, r8b
  0010a	eb 3f		 jmp	 SHORT $LN17@iso2022pro
$LN14@iso2022pro:

; 345  :         else if (IN3 == ')') designation = 1;

  0010c	80 f9 29	 cmp	 cl, 41			; 00000029H
  0010f	75 dc		 jne	 SHORT $LN12@iso2022pro
  00111	41 b0 01	 mov	 r8b, 1

; 346  :         else return 4;
; 347  :         break;

  00114	eb 35		 jmp	 SHORT $LN17@iso2022pro
$LN25@iso2022pro:

; 325  :     case 3:
; 326  :         if (IN2 == '$') {

  00116	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00119	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 327  :             charset = IN3 | CHARSET_DBCS;

  0011d	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  00121	3c 24		 cmp	 al, 36			; 00000024H
  00123	75 08		 jne	 SHORT $LN24@iso2022pro
  00125	80 ca 80	 or	 dl, 128			; 00000080H

; 328  :             designation = 0;

  00128	45 32 c0	 xor	 r8b, r8b

; 329  :         }
; 330  :         else {

  0012b	eb 1e		 jmp	 SHORT $LN17@iso2022pro
$LN24@iso2022pro:

; 331  :             charset = IN3;
; 332  :             if (IN2 == '(') designation = 0;

  0012d	3c 28		 cmp	 al, 40			; 00000028H
  0012f	75 05		 jne	 SHORT $LN22@iso2022pro
  00131	45 32 c0	 xor	 r8b, r8b
  00134	eb 15		 jmp	 SHORT $LN17@iso2022pro
$LN22@iso2022pro:

; 333  :             else if (IN2 == ')') designation = 1;

  00136	3c 29		 cmp	 al, 41			; 00000029H
  00138	75 05		 jne	 SHORT $LN20@iso2022pro
  0013a	41 b0 01	 mov	 r8b, 1
  0013d	eb 0c		 jmp	 SHORT $LN17@iso2022pro
$LN20@iso2022pro:

; 334  :             else if (CONFIG_ISSET(USE_G2) && IN2 == '.')

  0013f	f6 07 02	 test	 BYTE PTR [rdi], 2
  00142	74 4b		 je	 SHORT $LN18@iso2022pro
  00144	3c 2e		 cmp	 al, 46			; 0000002eH
  00146	75 47		 jne	 SHORT $LN18@iso2022pro

; 335  :                 designation = 2;

  00148	41 b0 02	 mov	 r8b, 2
$LN17@iso2022pro:

; 360  :     }
; 361  : 
; 362  :     /* raise error when the charset is not designated for this encoding */
; 363  :     if (charset != CHARSET_ASCII) {

  0014b	80 fa 42	 cmp	 dl, 66			; 00000042H
  0014e	74 2e		 je	 SHORT $LN1@iso2022pro
$LN47@iso2022pro:

; 364  :         const struct iso2022_designation *dsg;
; 365  : 
; 366  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++)

  00150	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00154	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00157	84 c9		 test	 cl, cl
  00159	0f 84 52 ff ff
	ff		 je	 $LN48@iso2022pro
  0015f	90		 npad	 1
$LL5@iso2022pro:

; 367  :             if (dsg->mark == charset)

  00160	3a ca		 cmp	 cl, dl
  00162	74 11		 je	 SHORT $LN43@iso2022pro

; 364  :         const struct iso2022_designation *dsg;
; 365  : 
; 366  :         for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++)

  00164	0f b6 48 20	 movzx	 ecx, BYTE PTR [rax+32]
  00168	48 83 c0 20	 add	 rax, 32			; 00000020H
  0016c	84 c9		 test	 cl, cl
  0016e	75 f0		 jne	 SHORT $LL5@iso2022pro

; 358  :     default:
; 359  :         return esclen;

  00170	49 8b c1	 mov	 rax, r9
  00173	eb 28		 jmp	 SHORT $LN38@iso2022pro
$LN43@iso2022pro:

; 368  :                 break;
; 369  :         if (!dsg->mark)

  00175	80 38 00	 cmp	 BYTE PTR [rax], 0

; 370  :             return esclen;

  00178	0f 84 33 ff ff
	ff		 je	 $LN48@iso2022pro
$LN1@iso2022pro:

; 371  :     }
; 372  : 
; 373  :     STATE_SETG(designation, charset)

  0017e	41 0f b6 c0	 movzx	 eax, r8b
  00182	88 14 28	 mov	 BYTE PTR [rax+rbp], dl

; 374  :     *inleft -= esclen;

  00185	4c 29 0e	 sub	 QWORD PTR [rsi], r9

; 375  :     (*inbuf) += esclen;

  00188	4c 01 0b	 add	 QWORD PTR [rbx], r9

; 376  :     return 0;

  0018b	33 c0		 xor	 eax, eax
  0018d	eb 0e		 jmp	 SHORT $LN38@iso2022pro
$LN18@iso2022pro:

; 336  :             else return 3;

  0018f	b8 03 00 00 00	 mov	 eax, 3
  00194	eb 07		 jmp	 SHORT $LN38@iso2022pro
$LN42@iso2022pro:

; 311  :             return MBERR_TOOFEW;

  00196	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
$LN38@iso2022pro:

; 377  : }

  0019d	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  001a2	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
  001a7	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  001ac	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  001b1	c3		 ret	 0
iso2022processesc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022processg2 DD imagerel iso2022processg2
	DD	imagerel iso2022processg2+314
	DD	imagerel $unwind$iso2022processg2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022processg2 DD 040a01H
	DD	02740aH
	DD	013405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso2022processg2
_TEXT	SEGMENT
state$ = 8
inbuf$ = 16
inleft$ = 24
outbuf$ = 32
outleft$ = 40
iso2022processg2 PROC					; COMDAT

; 394  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi

; 395  :     /* not written to use encoder, decoder functions because only few
; 396  :      * encodings use G2 designations in CJKCodecs */
; 397  :     if (STATE_G2 == CHARSET_ISO8859_1) {

  0000a	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0000e	49 8b f8	 mov	 rdi, r8
  00011	4c 8b d2	 mov	 r10, rdx
  00014	3c 41		 cmp	 al, 65			; 00000041H
  00016	75 2e		 jne	 SHORT $LN23@iso2022pro@2

; 398  :         if (IN3 < 0x80)

  00018	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001b	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  0001f	80 f9 80	 cmp	 cl, 128			; 00000080H
  00022	73 12		 jae	 SHORT $LN22@iso2022pro@2

; 399  :             OUT1(IN3 + 0x80)

  00024	0f b6 c9	 movzx	 ecx, cl
  00027	41 bb 80 00 00
	00		 mov	 r11d, 128		; 00000080H
  0002d	66 41 03 cb	 add	 cx, r11w

; 402  :     }
; 403  :     else if (STATE_G2 == CHARSET_ISO8859_7) {

  00031	e9 cb 00 00 00	 jmp	 $LN26@iso2022pro@2
$LN22@iso2022pro@2:

; 400  :         else
; 401  :             return 3;

  00036	b8 03 00 00 00	 mov	 eax, 3

; 419  : }

  0003b	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00040	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00045	c3		 ret	 0
$LN23@iso2022pro@2:

; 402  :     }
; 403  :     else if (STATE_G2 == CHARSET_ISO8859_7) {

  00046	3c 46		 cmp	 al, 70			; 00000046H
  00048	0f 85 9d 00 00
	00		 jne	 $LN19@iso2022pro@2

; 404  :         ISO8859_7_DECODE(IN3 ^ 0x80, **outbuf)

  0004e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00051	44 0f b6 40 02	 movzx	 r8d, BYTE PTR [rax+2]
  00056	41 0f b6 d0	 movzx	 edx, r8b
  0005a	80 f2 80	 xor	 dl, 128			; 00000080H
  0005d	80 fa a0	 cmp	 dl, 160			; 000000a0H
  00060	73 08		 jae	 SHORT $LN18@iso2022pro@2
$LN27@iso2022pro@2:
  00062	0f b6 ca	 movzx	 ecx, dl
  00065	e9 97 00 00 00	 jmp	 $LN26@iso2022pro@2
$LN18@iso2022pro@2:
  0006a	bb 01 00 00 00	 mov	 ebx, 1
  0006f	44 8d 5b 7f	 lea	 r11d, QWORD PTR [rbx+127]
  00073	80 fa c0	 cmp	 dl, 192			; 000000c0H
  00076	73 18		 jae	 SHORT $LN16@iso2022pro@2
  00078	41 0f b6 c8	 movzx	 ecx, r8b
  0007c	8b c3		 mov	 eax, ebx
  0007e	41 33 cb	 xor	 ecx, r11d
  00081	81 e9 a0 00 00
	00		 sub	 ecx, 160		; 000000a0H
  00087	d3 e0		 shl	 eax, cl
  00089	a9 c9 3b 8f 28	 test	 eax, 680475593		; 288f3bc9H
  0008e	75 d2		 jne	 SHORT $LN27@iso2022pro@2
$LN16@iso2022pro@2:
  00090	80 fa b4	 cmp	 dl, 180			; 000000b4H
  00093	72 2e		 jb	 SHORT $LN14@iso2022pro@2
  00095	80 fa fe	 cmp	 dl, 254			; 000000feH
  00098	77 29		 ja	 SHORT $LN14@iso2022pro@2
  0009a	80 fa d4	 cmp	 dl, 212			; 000000d4H
  0009d	73 17		 jae	 SHORT $LN13@iso2022pro@2
  0009f	41 0f b6 c8	 movzx	 ecx, r8b
  000a3	41 33 cb	 xor	 ecx, r11d
  000a6	81 e9 b4 00 00
	00		 sub	 ecx, 180		; 000000b4H
  000ac	d3 e3		 shl	 ebx, cl
  000ae	f7 c3 77 fd ff
	bf		 test	 ebx, -1073742473	; bffffd77H
  000b4	74 0d		 je	 SHORT $LN14@iso2022pro@2
$LN13@iso2022pro@2:
  000b6	0f b6 ca	 movzx	 ecx, dl
  000b9	b8 d0 02 00 00	 mov	 eax, 720		; 000002d0H
  000be	66 03 c8	 add	 cx, ax
  000c1	eb 3e		 jmp	 SHORT $LN26@iso2022pro@2
$LN14@iso2022pro@2:
  000c3	80 fa a1	 cmp	 dl, 161			; 000000a1H
  000c6	75 07		 jne	 SHORT $LN11@iso2022pro@2
  000c8	b9 18 20 00 00	 mov	 ecx, 8216		; 00002018H
  000cd	eb 32		 jmp	 SHORT $LN26@iso2022pro@2
$LN11@iso2022pro@2:
  000cf	80 fa a2	 cmp	 dl, 162			; 000000a2H
  000d2	75 07		 jne	 SHORT $LN9@iso2022pro@2
  000d4	b9 19 20 00 00	 mov	 ecx, 8217		; 00002019H
  000d9	eb 26		 jmp	 SHORT $LN26@iso2022pro@2
$LN9@iso2022pro@2:
  000db	80 fa af	 cmp	 dl, 175			; 000000afH
  000de	0f 85 52 ff ff
	ff		 jne	 $LN22@iso2022pro@2
  000e4	b9 15 20 00 00	 mov	 ecx, 8213		; 00002015H

; 405  :         else return 3;
; 406  :     }
; 407  :     else if (STATE_G2 == CHARSET_ASCII) {

  000e9	eb 16		 jmp	 SHORT $LN26@iso2022pro@2
$LN19@iso2022pro@2:
  000eb	3c 42		 cmp	 al, 66			; 00000042H
  000ed	75 39		 jne	 SHORT $LN4@iso2022pro@2

; 408  :         if (IN3 & 0x80) return 3;

  000ef	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  000f2	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  000f6	84 c9		 test	 cl, cl
  000f8	0f 88 38 ff ff
	ff		 js	 $LN22@iso2022pro@2

; 409  :         else **outbuf = IN3;

  000fe	0f b6 c9	 movzx	 ecx, cl
$LN26@iso2022pro@2:
  00101	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00104	66 89 08	 mov	 WORD PTR [rax], cx

; 410  :     }
; 411  :     else
; 412  :         return MBERR_INTERNAL;
; 413  : 
; 414  :     (*inbuf) += 3;

  00107	49 83 02 03	 add	 QWORD PTR [r10], 3

; 415  :     *inleft -= 3;

  0010b	48 83 07 fd	 add	 QWORD PTR [rdi], -3

; 416  :     (*outbuf) += 1;
; 417  :     *outleft -= 1;

  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR outleft$[rsp]
  00114	49 83 01 02	 add	 QWORD PTR [r9], 2
  00118	48 ff 08	 dec	 QWORD PTR [rax]

; 418  :     return 0;

  0011b	33 c0		 xor	 eax, eax

; 419  : }

  0011d	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00122	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00127	c3		 ret	 0
$LN4@iso2022pro@2:
  00128	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0012d	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  00132	48 c7 c0 fd ff
	ff ff		 mov	 rax, -3
  00139	c3		 ret	 0
iso2022processg2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso2022_decode DD imagerel iso2022_decode
	DD	imagerel iso2022_decode+856
	DD	imagerel $unwind$iso2022_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso2022_decode DD 0c2001H
	DD	0e6420H
	DD	0d5420H
	DD	0c3420H
	DD	0f01c5220H
	DD	0d018e01aH
	DD	07014c016H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso2022_decode
_TEXT	SEGMENT
state$ = 96
config$ = 104
inbuf$ = 112
inleft$ = 120
outbuf$ = 128
outleft$ = 136
iso2022_decode PROC					; COMDAT

; 422  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15
  0001c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 423  :     const struct iso2022_designation *dsgcache = NULL;

  00020	45 33 f6	 xor	 r14d, r14d
  00023	49 8b f9	 mov	 rdi, r9
  00026	4d 8b e0	 mov	 r12, r8
  00029	4c 8b fa	 mov	 r15, rdx
  0002c	4c 8b e9	 mov	 r13, rcx

; 424  : 
; 425  :     while (inleft > 0) {

  0002f	4d 85 c9	 test	 r9, r9
  00032	0f 8e e5 02 00
	00		 jle	 $LN48@iso2022_de
  00038	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR outbuf$[rsp]
  00040	48 8b 70 30	 mov	 rsi, QWORD PTR [rax+48]
  00044	45 8d 56 1b	 lea	 r10d, QWORD PTR [r14+27]
  00048	45 8d 5e 0a	 lea	 r11d, QWORD PTR [r14+10]
  0004c	0f 1f 40 00	 npad	 4
$LL49@iso2022_de:

; 426  :         unsigned char c = IN1;

  00050	4d 8b 0c 24	 mov	 r9, QWORD PTR [r12]

; 427  :         Py_ssize_t err;
; 428  : 
; 429  :         if (STATE_GETFLAG(F_ESCTHROUGHOUT)) {

  00054	41 0f b6 4d 04	 movzx	 ecx, BYTE PTR [r13+4]
  00059	45 0f b6 01	 movzx	 r8d, BYTE PTR [r9]
  0005d	f6 c1 02	 test	 cl, 2
  00060	74 51		 je	 SHORT $LN47@iso2022_de

; 430  :             /* ESC throughout mode:
; 431  :              * for non-iso2022 escape sequences */
; 432  :             WRITE1(c) /* assume as ISO-8859-1 */

  00062	48 83 fe 01	 cmp	 rsi, 1
  00066	0f 8c d0 02 00
	00		 jl	 $LN55@iso2022_de
  0006c	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]

; 433  :             NEXT(1, 1)

  00070	48 ff cf	 dec	 rdi
  00073	48 ff ce	 dec	 rsi
  00076	41 0f b6 c8	 movzx	 ecx, r8b
  0007a	48 89 7c 24 78	 mov	 QWORD PTR inleft$[rsp], rdi
  0007f	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rsi
  00087	66 89 08	 mov	 WORD PTR [rax], cx
  0008a	49 ff 04 24	 inc	 QWORD PTR [r12]
  0008e	48 83 45 00 02	 add	 QWORD PTR [rbp], 2

; 434  :             if (IS_ESCEND(c)) {

  00093	41 80 f8 41	 cmp	 r8b, 65			; 00000041H
  00097	72 06		 jb	 SHORT $LN43@iso2022_de
  00099	41 80 f8 5a	 cmp	 r8b, 90			; 0000005aH
  0009d	76 0a		 jbe	 SHORT $LN44@iso2022_de
$LN43@iso2022_de:
  0009f	41 80 f8 40	 cmp	 r8b, 64			; 00000040H
  000a3	0f 85 6b 02 00
	00		 jne	 $LN41@iso2022_de
$LN44@iso2022_de:

; 435  :                 STATE_CLEARFLAG(F_ESCTHROUGHOUT)

  000a9	41 80 65 04 fd	 and	 BYTE PTR [r13+4], 253	; 000000fdH

; 436  :             }
; 437  :             continue;

  000ae	e9 61 02 00 00	 jmp	 $LN41@iso2022_de
$LN47@iso2022_de:

; 438  :         }
; 439  : 
; 440  :         switch (c) {

  000b3	41 0f b6 d0	 movzx	 edx, r8b
  000b7	83 ea 0a	 sub	 edx, 10
  000ba	0f 84 23 02 00
	00		 je	 $LN25@iso2022_de
  000c0	83 ea 04	 sub	 edx, 4
  000c3	0f 84 f1 01 00
	00		 je	 $LN27@iso2022_de
  000c9	ff ca		 dec	 edx
  000cb	0f 84 d3 01 00
	00		 je	 $LN29@iso2022_de
  000d1	83 fa 0c	 cmp	 edx, 12
  000d4	0f 84 17 01 00
	00		 je	 $LN40@iso2022_de

; 478  :             break;
; 479  :         default:
; 480  :             if (c < 0x20) /* C0 */

  000da	41 80 f8 20	 cmp	 r8b, 32			; 00000020H
  000de	0f 82 dc 01 00
	00		 jb	 $bypass$20911

; 481  :                 goto bypass;
; 482  :             else if (c >= 0x80)

  000e4	41 80 f8 80	 cmp	 r8b, 128		; 00000080H
  000e8	0f 83 5a 02 00
	00		 jae	 $LN56@iso2022_de

; 484  :             else {
; 485  :                 const struct iso2022_designation *dsg;
; 486  :                 unsigned char charset;
; 487  :                 ucs4_t decoded;
; 488  : 
; 489  :                 if (STATE_GETFLAG(F_SHIFTED))

  000ee	f6 c1 01	 test	 cl, 1
  000f1	74 07		 je	 SHORT $LN18@iso2022_de

; 490  :                     charset = STATE_G1;

  000f3	41 0f b6 45 01	 movzx	 eax, BYTE PTR [r13+1]

; 491  :                 else

  000f8	eb 05		 jmp	 SHORT $LN17@iso2022_de
$LN18@iso2022_de:

; 492  :                     charset = STATE_G0;

  000fa	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
$LN17@iso2022_de:

; 493  : 
; 494  :                 if (charset == CHARSET_ASCII) {

  000ff	3c 42		 cmp	 al, 66			; 00000042H
  00101	0f 84 b9 01 00
	00		 je	 $bypass$20911

; 498  :                                 }
; 499  : 
; 500  :                                 if (dsgcache != NULL &&
; 501  :                                     dsgcache->mark == charset)

  00107	4d 85 f6	 test	 r14, r14
  0010a	74 0a		 je	 SHORT $LN14@iso2022_de
  0010c	41 38 06	 cmp	 BYTE PTR [r14], al
  0010f	75 05		 jne	 SHORT $LN14@iso2022_de

; 502  :                                         dsg = dsgcache;

  00111	49 8b de	 mov	 rbx, r14

; 503  :                                 else {

  00114	eb 15		 jmp	 SHORT $LN13@iso2022_de
$LN14@iso2022_de:

; 504  :                                         for (dsg = CONFIG_DESIGNATIONS;
; 505  :                                              dsg->mark != charset
; 506  : #ifdef Py_DEBUG
; 507  :                                                 && dsg->mark != '\0'
; 508  : #endif
; 509  :                                              ;dsg++)

  00116	49 8b 5f 08	 mov	 rbx, QWORD PTR [r15+8]
  0011a	38 03		 cmp	 BYTE PTR [rbx], al
  0011c	74 0a		 je	 SHORT $LN10@iso2022_de
  0011e	66 90		 npad	 2
$LL12@iso2022_de:
  00120	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00124	38 03		 cmp	 BYTE PTR [rbx], al
  00126	75 f8		 jne	 SHORT $LL12@iso2022_de
$LN10@iso2022_de:

; 510  :                                                 /* noop */;
; 511  :                                         assert(dsg->mark != '\0');
; 512  :                                         dsgcache = dsg;

  00128	4c 8b f3	 mov	 r14, rbx
$LN13@iso2022_de:

; 513  :                                 }
; 514  : 
; 515  :                                 REQUIRE_INBUF(dsg->width)

  0012b	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  0012f	48 3b f8	 cmp	 rdi, rax
  00132	0f 8c 17 02 00
	00		 jl	 $LN62@iso2022_de

; 516  :                                 decoded = dsg->decoder(*inbuf);

  00138	49 8b c9	 mov	 rcx, r9
  0013b	ff 53 10	 call	 QWORD PTR [rbx+16]
  0013e	44 8b d8	 mov	 r11d, eax

; 517  :                                 if (decoded == MAP_UNMAPPABLE)

  00141	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00146	0f 84 f6 01 00
	00		 je	 $LN58@iso2022_de

; 519  : 
; 520  :                                 if (decoded < 0x10000) {

  0014c	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00151	73 1b		 jae	 SHORT $LN7@iso2022_de

; 521  :                                         WRITE1(decoded)

  00153	48 83 fe 01	 cmp	 rsi, 1
  00157	0f 8c df 01 00
	00		 jl	 $LN55@iso2022_de
  0015d	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  00161	66 89 01	 mov	 WORD PTR [rcx], ax

; 522  :                                         NEXT_OUT(1)

  00164	48 83 45 00 02	 add	 QWORD PTR [rbp], 2
  00169	48 ff ce	 dec	 rsi
  0016c	eb 65		 jmp	 SHORT $LN71@iso2022_de
$LN7@iso2022_de:

; 523  :                                 }
; 524  :                                 else if (decoded < 0x30000) {

  0016e	3d 00 00 03 00	 cmp	 eax, 196608		; 00030000H
  00173	73 36		 jae	 SHORT $LN4@iso2022_de

; 525  :                                         WRITEUCS4(decoded)

  00175	48 83 fe 02	 cmp	 rsi, 2
  00179	0f 8c bd 01 00
	00		 jl	 $LN55@iso2022_de
  0017f	8d 88 00 00 ff
	ff		 lea	 ecx, DWORD PTR [rax-65536]
  00185	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  0018a	c1 e9 0a	 shr	 ecx, 10
  0018d	66 2b c8	 sub	 cx, ax
  00190	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00194	66 89 08	 mov	 WORD PTR [rax], cx
  00197	b8 ff 03 00 00	 mov	 eax, 1023		; 000003ffH
  0019c	66 44 23 d8	 and	 r11w, ax
  001a0	b8 00 24 00 00	 mov	 eax, 9216		; 00002400H
  001a5	66 44 2b d8	 sub	 r11w, ax

; 526  :                                 }
; 527  :                                 else { /* JIS X 0213 pairs */

  001a9	eb 16		 jmp	 SHORT $LN72@iso2022_de
$LN4@iso2022_de:

; 528  :                     WRITE2(decoded >> 16, decoded & 0xffff)

  001ab	48 83 fe 02	 cmp	 rsi, 2
  001af	0f 8c 87 01 00
	00		 jl	 $LN55@iso2022_de
  001b5	8b c8		 mov	 ecx, eax
  001b7	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  001bb	c1 e9 10	 shr	 ecx, 16
  001be	66 89 08	 mov	 WORD PTR [rax], cx
$LN72@iso2022_de:
  001c1	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  001c5	66 44 89 58 02	 mov	 WORD PTR [rax+2], r11w

; 529  :                     NEXT_OUT(2)

  001ca	48 83 45 00 04	 add	 QWORD PTR [rbp], 4
  001cf	48 83 ee 02	 sub	 rsi, 2
$LN71@iso2022_de:

; 530  :                 }
; 531  :                 NEXT_IN(dsg->width)

  001d3	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]

; 532  :             }
; 533  :             break;

  001d7	41 ba 1b 00 00
	00		 mov	 r10d, 27
  001dd	49 01 04 24	 add	 QWORD PTR [r12], rax
  001e1	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  001e5	45 8d 5a ef	 lea	 r11d, QWORD PTR [r10-17]
  001e9	48 2b f8	 sub	 rdi, rax
  001ec	e9 16 01 00 00	 jmp	 $LN73@iso2022_de
$LN40@iso2022_de:

; 441  :         case ESC:
; 442  :             REQUIRE_INBUF(2)

  001f1	48 83 ff 02	 cmp	 rdi, 2
  001f5	0f 8c 54 01 00
	00		 jl	 $LN62@iso2022_de

; 443  :             if (IS_ISO2022ESC(IN2)) {

  001fb	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00200	3c 28		 cmp	 al, 40			; 00000028H
  00202	74 73		 je	 SHORT $LN37@iso2022_de
  00204	3c 29		 cmp	 al, 41			; 00000029H
  00206	74 6f		 je	 SHORT $LN37@iso2022_de
  00208	3c 24		 cmp	 al, 36			; 00000024H
  0020a	74 6b		 je	 SHORT $LN37@iso2022_de
  0020c	3c 2e		 cmp	 al, 46			; 0000002eH
  0020e	74 67		 je	 SHORT $LN37@iso2022_de
  00210	3c 26		 cmp	 al, 38			; 00000026H
  00212	74 63		 je	 SHORT $LN37@iso2022_de

; 447  :                     return err;
; 448  :             }
; 449  :             else if (CONFIG_ISSET(USE_G2) && IN2 == 'N') {/* SS2 */

  00214	41 f6 07 02	 test	 BYTE PTR [r15], 2
  00218	74 41		 je	 SHORT $LN34@iso2022_de
  0021a	3c 4e		 cmp	 al, 78			; 0000004eH
  0021c	75 3d		 jne	 SHORT $LN34@iso2022_de

; 450  :                 REQUIRE_INBUF(3)

  0021e	48 83 ff 03	 cmp	 rdi, 3
  00222	0f 8c 27 01 00
	00		 jl	 $LN62@iso2022_de

; 451  :                 err = iso2022processg2(config, state,
; 452  :                     inbuf, &inleft, outbuf, &outleft);

  00228	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR outleft$[rsp]
  00230	4c 8d 44 24 78	 lea	 r8, QWORD PTR inleft$[rsp]
  00235	4c 8b cd	 mov	 r9, rbp
  00238	49 8b d4	 mov	 rdx, r12
  0023b	49 8b cd	 mov	 rcx, r13
  0023e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00243	e8 00 00 00 00	 call	 iso2022processg2

; 453  :                 if (err != 0)

  00248	48 85 c0	 test	 rax, rax
  0024b	0f 85 ce 00 00
	00		 jne	 $LN50@iso2022_de

; 454  :                     return err;
; 455  :             }
; 456  :             else {

  00251	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR outleft$[rsp]
  00259	eb 38		 jmp	 SHORT $LN76@iso2022_de
$LN34@iso2022_de:

; 457  :                 WRITE1(ESC)

  0025b	48 83 fe 01	 cmp	 rsi, 1
  0025f	0f 8c d7 00 00
	00		 jl	 $LN55@iso2022_de
  00265	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00269	66 44 89 10	 mov	 WORD PTR [rax], r10w

; 458  :                 STATE_SETFLAG(F_ESCTHROUGHOUT)

  0026d	41 80 4d 04 02	 or	 BYTE PTR [r13+4], 2

; 459  :                 NEXT(1, 1)

  00272	e9 81 00 00 00	 jmp	 $LN74@iso2022_de
$LN37@iso2022_de:

; 444  :                 err = iso2022processesc(config, state,
; 445  :                                         inbuf, &inleft);

  00277	4c 8d 4c 24 78	 lea	 r9, QWORD PTR inleft$[rsp]
  0027c	4d 8b c4	 mov	 r8, r12
  0027f	49 8b d5	 mov	 rdx, r13
  00282	49 8b cf	 mov	 rcx, r15
  00285	e8 00 00 00 00	 call	 iso2022processesc

; 446  :                 if (err != 0)

  0028a	48 85 c0	 test	 rax, rax
  0028d	0f 85 8c 00 00
	00		 jne	 $LN50@iso2022_de
$LN76@iso2022_de:

; 460  :             }
; 461  :             break;

  00293	48 8b 7c 24 78	 mov	 rdi, QWORD PTR inleft$[rsp]
  00298	41 ba 1b 00 00
	00		 mov	 r10d, 27
  0029e	45 8d 5a ef	 lea	 r11d, QWORD PTR [r10-17]
  002a2	eb 70		 jmp	 SHORT $LN41@iso2022_de
$LN29@iso2022_de:

; 462  :         case SI:
; 463  :             if (CONFIG_ISSET(NO_SHIFT))

  002a4	41 f6 07 01	 test	 BYTE PTR [r15], 1
  002a8	75 16		 jne	 SHORT $bypass$20911

; 464  :                 goto bypass;
; 465  :             STATE_CLEARFLAG(F_SHIFTED)

  002aa	80 e1 fe	 and	 cl, 254			; 000000feH
  002ad	41 88 4d 04	 mov	 BYTE PTR [r13+4], cl

; 466  :             NEXT_IN(1)

  002b1	49 ff 04 24	 inc	 QWORD PTR [r12]
  002b5	48 ff cf	 dec	 rdi

; 467  :             break;

  002b8	eb 55		 jmp	 SHORT $LN75@iso2022_de
$LN27@iso2022_de:

; 468  :         case SO:
; 469  :             if (CONFIG_ISSET(NO_SHIFT))

  002ba	41 f6 07 01	 test	 BYTE PTR [r15], 1
  002be	74 13		 je	 SHORT $LN26@iso2022_de
$bypass$20911:

; 495  : bypass:                                 WRITE1(c)

  002c0	48 83 fe 01	 cmp	 rsi, 1
  002c4	7c 76		 jl	 SHORT $LN55@iso2022_de
  002c6	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  002ca	41 0f b6 c8	 movzx	 ecx, r8b
  002ce	66 89 08	 mov	 WORD PTR [rax], cx

; 496  :                                         NEXT(1, 1)
; 497  :                                         break;

  002d1	eb 25		 jmp	 SHORT $LN74@iso2022_de
$LN26@iso2022_de:

; 470  :                 goto bypass;
; 471  :             STATE_SETFLAG(F_SHIFTED)

  002d3	80 c9 01	 or	 cl, 1
  002d6	41 88 4d 04	 mov	 BYTE PTR [r13+4], cl

; 472  :             NEXT_IN(1)

  002da	49 ff 04 24	 inc	 QWORD PTR [r12]
  002de	48 ff cf	 dec	 rdi

; 473  :             break;

  002e1	eb 2c		 jmp	 SHORT $LN75@iso2022_de
$LN25@iso2022_de:

; 474  :         case LF:
; 475  :             STATE_CLEARFLAG(F_SHIFTED)

  002e3	80 e1 fe	 and	 cl, 254			; 000000feH
  002e6	41 88 4d 04	 mov	 BYTE PTR [r13+4], cl

; 476  :             WRITE1(LF)

  002ea	48 83 fe 01	 cmp	 rsi, 1
  002ee	7c 4c		 jl	 SHORT $LN55@iso2022_de
  002f0	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  002f4	66 44 89 18	 mov	 WORD PTR [rax], r11w
$LN74@iso2022_de:

; 477  :             NEXT(1, 1)

  002f8	49 ff 04 24	 inc	 QWORD PTR [r12]
  002fc	48 83 45 00 02	 add	 QWORD PTR [rbp], 2
  00301	48 ff cf	 dec	 rdi
  00304	48 ff ce	 dec	 rsi
$LN73@iso2022_de:
  00307	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR outleft$[rsp], rsi
$LN75@iso2022_de:
  0030f	48 89 7c 24 78	 mov	 QWORD PTR inleft$[rsp], rdi
$LN41@iso2022_de:

; 424  : 
; 425  :     while (inleft > 0) {

  00314	48 85 ff	 test	 rdi, rdi
  00317	0f 8f 33 fd ff
	ff		 jg	 $LL49@iso2022_de
$LN48@iso2022_de:

; 534  :         }
; 535  :     }
; 536  :     return 0;

  0031d	33 c0		 xor	 eax, eax
$LN50@iso2022_de:

; 537  : }

  0031f	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00324	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00329	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0032e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00332	41 5f		 pop	 r15
  00334	41 5e		 pop	 r14
  00336	41 5d		 pop	 r13
  00338	41 5c		 pop	 r12
  0033a	5f		 pop	 rdi
  0033b	c3		 ret	 0
$LN55@iso2022_de:

; 430  :             /* ESC throughout mode:
; 431  :              * for non-iso2022 escape sequences */
; 432  :             WRITE1(c) /* assume as ISO-8859-1 */

  0033c	48 83 c8 ff	 or	 rax, -1
  00340	eb dd		 jmp	 SHORT $LN50@iso2022_de
$LN58@iso2022_de:

; 518  :                                         return dsg->width;

  00342	0f b6 43 02	 movzx	 eax, BYTE PTR [rbx+2]
  00346	eb d7		 jmp	 SHORT $LN50@iso2022_de
$LN56@iso2022_de:

; 483  :                 return 1;

  00348	b8 01 00 00 00	 mov	 eax, 1
  0034d	eb d0		 jmp	 SHORT $LN50@iso2022_de
$LN62@iso2022_de:

; 441  :         case ESC:
; 442  :             REQUIRE_INBUF(2)

  0034f	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  00356	eb c7		 jmp	 SHORT $LN50@iso2022_de
iso2022_decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@		; `string'
PUBLIC	??_C@_0L@LBOMJMFO@_codecs_kr?$AA@		; `string'
PUBLIC	??_C@_0M@OADICNAA@__map_cp949?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ksx1001_init DD imagerel ksx1001_init
	DD	imagerel ksx1001_init+104
	DD	imagerel $unwind$ksx1001_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ksx1001_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@
CONST	SEGMENT
??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@ DB '__map_ksx1001', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
CONST	SEGMENT
??_C@_0L@LBOMJMFO@_codecs_kr?$AA@ DB '_codecs_kr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OADICNAA@__map_cp949?$AA@
CONST	SEGMENT
??_C@_0M@OADICNAA@__map_cp949?$AA@ DB '__map_cp949', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ksx1001_init
_TEXT	SEGMENT
ksx1001_init PROC					; COMDAT

; 569  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 570  :     static int initialized = 0;
; 571  : 
; 572  :     if (!initialized && (
; 573  :                     IMPORT_MAP(kr, cp949, &cp949_encmap, NULL) ||
; 574  :                     IMPORT_MAP(kr, ksx1001, NULL, &ksx1001_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??ksx1001_init@@9@9, 0
  0000b	75 4a		 jne	 SHORT $LN2@ksx1001_in
  0000d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cp949_encmap
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OADICNAA@__map_cp949?$AA@
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
  00022	45 33 c9	 xor	 r9d, r9d
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@ksx1001_in
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:ksx1001_decmap
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DEAIEGHE@__map_ksx1001?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LBOMJMFO@_codecs_kr?$AA@
  00043	45 33 c0	 xor	 r8d, r8d
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN2@ksx1001_in
$LN1@ksx1001_in:

; 575  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 578  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN2@ksx1001_in:

; 576  :     initialized = 1;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??ksx1001_init@@9@9, 1

; 577  :     return 0;

  00061	33 c0		 xor	 eax, eax

; 578  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
ksx1001_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ksx1001_decoder
_TEXT	SEGMENT
data$ = 8
ksx1001_decoder PROC					; COMDAT

; 583  :     ucs4_t u;
; 584  :     TRYMAP_DEC(ksx1001, u, data[0], data[1])

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ksx1001_decmap
  0000a	48 03 c0	 add	 rax, rax
  0000d	4c 8b 0c c2	 mov	 r9, QWORD PTR [rdx+rax*8]
  00011	4d 85 c9	 test	 r9, r9
  00014	74 2b		 je	 SHORT $LN2@ksx1001_de
  00016	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001a	44 0f b6 44 c2
	08		 movzx	 r8d, BYTE PTR [rdx+rax*8+8]
  00020	41 3a c8	 cmp	 cl, r8b
  00023	72 1c		 jb	 SHORT $LN2@ksx1001_de
  00025	3a 4c c2 09	 cmp	 cl, BYTE PTR [rdx+rax*8+9]
  00029	77 16		 ja	 SHORT $LN2@ksx1001_de
  0002b	41 0f b6 c0	 movzx	 eax, r8b
  0002f	0f b6 c9	 movzx	 ecx, cl
  00032	48 2b c8	 sub	 rcx, rax
  00035	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0003a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 585  :         return u;

  0003f	75 05		 jne	 SHORT $LN1@ksx1001_de
$LN2@ksx1001_de:

; 586  :     else
; 587  :         return MAP_UNMAPPABLE;

  00041	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@ksx1001_de:

; 588  : }

  00046	f3 c3		 fatret	 0
ksx1001_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ksx1001_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
ksx1001_encoder PROC					; COMDAT

; 593  :     DBCHAR coded;
; 594  :     assert(*length == 1);
; 595  :     if (*data < 0x10000) {

  00000	8b 11		 mov	 edx, DWORD PTR [rcx]
  00002	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  00008	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  0000e	73 4c		 jae	 SHORT $LN1@ksx1001_en

; 596  :         TRYMAP_ENC(cp949, coded, *data)

  00010	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR cp949_encmap
  00017	8b c2		 mov	 eax, edx
  00019	48 c1 e8 08	 shr	 rax, 8
  0001d	48 c1 e0 04	 shl	 rax, 4
  00021	4e 8b 14 00	 mov	 r10, QWORD PTR [rax+r8]
  00025	4d 85 d2	 test	 r10, r10
  00028	74 32		 je	 SHORT $LN1@ksx1001_en
  0002a	46 0f b6 4c 00
	08		 movzx	 r9d, BYTE PTR [rax+r8+8]
  00030	0f b6 ca	 movzx	 ecx, dl
  00033	41 3b c9	 cmp	 ecx, r9d
  00036	72 24		 jb	 SHORT $LN1@ksx1001_en
  00038	42 0f b6 44 00
	09		 movzx	 eax, BYTE PTR [rax+r8+9]
  0003e	3b c8		 cmp	 ecx, eax
  00040	77 1a		 ja	 SHORT $LN1@ksx1001_en
  00042	41 2b c9	 sub	 ecx, r9d
  00045	8b c1		 mov	 eax, ecx
  00047	41 0f b7 04 4a	 movzx	 eax, WORD PTR [r10+rcx*2]
  0004c	66 41 3b c3	 cmp	 ax, r11w
  00050	74 0a		 je	 SHORT $LN1@ksx1001_en

; 597  :             if (!(coded & 0x8000))

  00052	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00057	66 85 c1	 test	 ax, cx

; 598  :                 return coded;

  0005a	74 04		 je	 SHORT $LN4@ksx1001_en
$LN1@ksx1001_en:

; 599  :     }
; 600  :     return MAP_UNMAPPABLE;

  0005c	41 0f b7 c3	 movzx	 eax, r11w
$LN4@ksx1001_en:

; 601  : }

  00060	f3 c3		 fatret	 0
ksx1001_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@		; `string'
PUBLIC	??_C@_0L@ICBIJEOL@_codecs_jp?$AA@		; `string'
PUBLIC	??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0208_init DD imagerel jisx0208_init
	DD	imagerel jisx0208_init+104
	DD	imagerel $unwind$jisx0208_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0208_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@
CONST	SEGMENT
??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@ DB '__map_jisx0208', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
CONST	SEGMENT
??_C@_0L@ICBIJEOL@_codecs_jp?$AA@ DB '_codecs_jp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
CONST	SEGMENT
??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@ DB '__map_jisxcommon', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT jisx0208_init
_TEXT	SEGMENT
jisx0208_init PROC					; COMDAT

; 605  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 606  :     static int initialized = 0;
; 607  : 
; 608  :     if (!initialized && (
; 609  :                     IMPORT_MAP(jp, jisxcommon, &jisxcommon_encmap, NULL) ||
; 610  :                     IMPORT_MAP(jp, jisx0208, NULL, &jisx0208_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0208_init@@9@9, 0
  0000b	75 4a		 jne	 SHORT $LN2@jisx0208_i
  0000d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisxcommon_encmap
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00022	45 33 c9	 xor	 r9d, r9d
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@jisx0208_i
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0208_decmap
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DLFIJFNK@__map_jisx0208?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00043	45 33 c0	 xor	 r8d, r8d
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN2@jisx0208_i
$LN1@jisx0208_i:

; 611  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 614  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN2@jisx0208_i:

; 612  :     initialized = 1;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0208_init@@9@9, 1

; 613  :     return 0;

  00061	33 c0		 xor	 eax, eax

; 614  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
jisx0208_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0208_decoder
_TEXT	SEGMENT
data$ = 8
jisx0208_decoder PROC					; COMDAT

; 619  :     ucs4_t u;
; 620  :     if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	3c 21		 cmp	 al, 33			; 00000021H
  00005	75 0c		 jne	 SHORT $LN4@jisx0208_d
  00007	80 79 01 40	 cmp	 BYTE PTR [rcx+1], 64	; 00000040H
  0000b	75 06		 jne	 SHORT $LN4@jisx0208_d

; 621  :         return 0xff3c;

  0000d	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH

; 626  : }

  00012	c3		 ret	 0
$LN4@jisx0208_d:

; 622  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1])

  00013	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0208_decmap
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	48 03 c0	 add	 rax, rax
  00020	4d 8b 0c c0	 mov	 r9, QWORD PTR [r8+rax*8]
  00024	4d 85 c9	 test	 r9, r9
  00027	74 2a		 je	 SHORT $LN2@jisx0208_d
  00029	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  0002d	41 0f b6 4c c0
	08		 movzx	 ecx, BYTE PTR [r8+rax*8+8]
  00033	3a d1		 cmp	 dl, cl
  00035	72 1c		 jb	 SHORT $LN2@jisx0208_d
  00037	41 3a 54 c0 09	 cmp	 dl, BYTE PTR [r8+rax*8+9]
  0003c	77 15		 ja	 SHORT $LN2@jisx0208_d
  0003e	0f b6 c1	 movzx	 eax, cl
  00041	0f b6 ca	 movzx	 ecx, dl
  00044	48 2b c8	 sub	 rcx, rax
  00047	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0004c	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 623  :         return u;

  00051	75 05		 jne	 SHORT $LN1@jisx0208_d
$LN2@jisx0208_d:

; 624  :     else
; 625  :         return MAP_UNMAPPABLE;

  00053	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0208_d:

; 626  : }

  00058	f3 c3		 fatret	 0
jisx0208_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0208_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
jisx0208_encoder PROC					; COMDAT

; 631  :     DBCHAR coded;
; 632  :     assert(*length == 1);
; 633  :     if (*data < 0x10000) {

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  00008	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  0000d	73 59		 jae	 SHORT $LN1@jisx0208_e

; 634  :         if (*data == 0xff3c) /* F/W REVERSE SOLIDUS */

  0000f	3d 3c ff 00 00	 cmp	 eax, 65340		; 0000ff3cH
  00014	75 06		 jne	 SHORT $LN4@jisx0208_e

; 635  :             return 0x2140;

  00016	b8 40 21 00 00	 mov	 eax, 8512		; 00002140H

; 642  : }

  0001b	c3		 ret	 0
$LN4@jisx0208_e:

; 636  :         else TRYMAP_ENC(jisxcommon, coded, *data) {

  0001c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisxcommon_encmap
  00023	48 8b c8	 mov	 rcx, rax
  00026	48 c1 e9 08	 shr	 rcx, 8
  0002a	48 03 c9	 add	 rcx, rcx
  0002d	4d 8b 14 c8	 mov	 r10, QWORD PTR [r8+rcx*8]
  00031	4d 85 d2	 test	 r10, r10
  00034	74 32		 je	 SHORT $LN1@jisx0208_e
  00036	45 0f b6 4c c8
	08		 movzx	 r9d, BYTE PTR [r8+rcx*8+8]
  0003c	0f b6 d0	 movzx	 edx, al
  0003f	41 3b d1	 cmp	 edx, r9d
  00042	72 24		 jb	 SHORT $LN1@jisx0208_e
  00044	41 0f b6 44 c8
	09		 movzx	 eax, BYTE PTR [r8+rcx*8+9]
  0004a	3b d0		 cmp	 edx, eax
  0004c	77 1a		 ja	 SHORT $LN1@jisx0208_e
  0004e	41 2b d1	 sub	 edx, r9d
  00051	8b c2		 mov	 eax, edx
  00053	41 0f b7 04 52	 movzx	 eax, WORD PTR [r10+rdx*2]
  00058	66 41 3b c3	 cmp	 ax, r11w
  0005c	74 0a		 je	 SHORT $LN1@jisx0208_e

; 637  :             if (!(coded & 0x8000))

  0005e	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00063	66 85 c1	 test	 ax, cx

; 638  :                 return coded;

  00066	74 04		 je	 SHORT $LN6@jisx0208_e
$LN1@jisx0208_e:

; 639  :         }
; 640  :     }
; 641  :     return MAP_UNMAPPABLE;

  00068	41 0f b7 c3	 movzx	 eax, r11w
$LN6@jisx0208_e:

; 642  : }

  0006c	f3 c3		 fatret	 0
jisx0208_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0212_init DD imagerel jisx0212_init
	DD	imagerel jisx0212_init+104
	DD	imagerel $unwind$jisx0212_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0212_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@
CONST	SEGMENT
??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@ DB '__map_jisx0212', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT jisx0212_init
_TEXT	SEGMENT
jisx0212_init PROC					; COMDAT

; 646  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 647  :     static int initialized = 0;
; 648  : 
; 649  :     if (!initialized && (
; 650  :                     IMPORT_MAP(jp, jisxcommon, &jisxcommon_encmap, NULL) ||
; 651  :                     IMPORT_MAP(jp, jisx0212, NULL, &jisx0212_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0212_init@@9@9, 0
  0000b	75 4a		 jne	 SHORT $LN2@jisx0212_i
  0000d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisxcommon_encmap
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NNDKKHNL@__map_jisxcommon?$AA@
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00022	45 33 c9	 xor	 r9d, r9d
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@jisx0212_i
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0212_decmap
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@MAHFBHGH@__map_jisx0212?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00043	45 33 c0	 xor	 r8d, r8d
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN2@jisx0212_i
$LN1@jisx0212_i:

; 652  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 655  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN2@jisx0212_i:

; 653  :     initialized = 1;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0212_init@@9@9, 1

; 654  :     return 0;

  00061	33 c0		 xor	 eax, eax

; 655  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
jisx0212_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0212_decoder
_TEXT	SEGMENT
data$ = 8
jisx0212_decoder PROC					; COMDAT

; 660  :     ucs4_t u;
; 661  :     TRYMAP_DEC(jisx0212, u, data[0], data[1])

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR jisx0212_decmap
  0000a	48 03 c0	 add	 rax, rax
  0000d	4c 8b 0c c2	 mov	 r9, QWORD PTR [rdx+rax*8]
  00011	4d 85 c9	 test	 r9, r9
  00014	74 2b		 je	 SHORT $LN2@jisx0212_d
  00016	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001a	44 0f b6 44 c2
	08		 movzx	 r8d, BYTE PTR [rdx+rax*8+8]
  00020	41 3a c8	 cmp	 cl, r8b
  00023	72 1c		 jb	 SHORT $LN2@jisx0212_d
  00025	3a 4c c2 09	 cmp	 cl, BYTE PTR [rdx+rax*8+9]
  00029	77 16		 ja	 SHORT $LN2@jisx0212_d
  0002b	41 0f b6 c0	 movzx	 eax, r8b
  0002f	0f b6 c9	 movzx	 ecx, cl
  00032	48 2b c8	 sub	 rcx, rax
  00035	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0003a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 662  :         return u;

  0003f	75 05		 jne	 SHORT $LN1@jisx0212_d
$LN2@jisx0212_d:

; 663  :     else
; 664  :         return MAP_UNMAPPABLE;

  00041	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@jisx0212_d:

; 665  : }

  00046	f3 c3		 fatret	 0
jisx0212_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0212_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
jisx0212_encoder PROC					; COMDAT

; 670  :     DBCHAR coded;
; 671  :     assert(*length == 1);
; 672  :     if (*data < 0x10000) {

  00000	8b 11		 mov	 edx, DWORD PTR [rcx]
  00002	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  00008	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  0000e	73 55		 jae	 SHORT $LN1@jisx0212_e

; 673  :         TRYMAP_ENC(jisxcommon, coded, *data) {

  00010	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisxcommon_encmap
  00017	8b c2		 mov	 eax, edx
  00019	48 c1 e8 08	 shr	 rax, 8
  0001d	48 c1 e0 04	 shl	 rax, 4
  00021	4e 8b 14 00	 mov	 r10, QWORD PTR [rax+r8]
  00025	4d 85 d2	 test	 r10, r10
  00028	74 3b		 je	 SHORT $LN1@jisx0212_e
  0002a	46 0f b6 4c 00
	08		 movzx	 r9d, BYTE PTR [rax+r8+8]
  00030	0f b6 ca	 movzx	 ecx, dl
  00033	41 3b c9	 cmp	 ecx, r9d
  00036	72 2d		 jb	 SHORT $LN1@jisx0212_e
  00038	42 0f b6 44 00
	09		 movzx	 eax, BYTE PTR [rax+r8+9]
  0003e	3b c8		 cmp	 ecx, eax
  00040	77 23		 ja	 SHORT $LN1@jisx0212_e
  00042	41 2b c9	 sub	 ecx, r9d
  00045	8b c1		 mov	 eax, ecx
  00047	41 0f b7 0c 4a	 movzx	 ecx, WORD PTR [r10+rcx*2]
  0004c	66 41 3b cb	 cmp	 cx, r11w
  00050	74 13		 je	 SHORT $LN1@jisx0212_e

; 674  :             if (coded & 0x8000)

  00052	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00057	66 85 c8	 test	 cx, ax
  0005a	74 09		 je	 SHORT $LN1@jisx0212_e

; 675  :                 return coded & 0x7fff;

  0005c	0f b7 c1	 movzx	 eax, cx
  0005f	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH

; 679  : }

  00064	c3		 ret	 0
$LN1@jisx0212_e:

; 676  :         }
; 677  :     }
; 678  :     return MAP_UNMAPPABLE;

  00065	41 0f b7 c3	 movzx	 eax, r11w

; 679  : }

  00069	c3		 ret	 0
jisx0212_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@	; `string'
PUBLIC	??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@	; `string'
PUBLIC	??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@	; `string'
PUBLIC	??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@	; `string'
PUBLIC	??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@	; `string'
PUBLIC	??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@	; `string'
PUBLIC	??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@	; `string'
_BSS	SEGMENT
	ALIGN	8

jisx0213_pair_encmap DQ 01H DUP (?)
jisx0213_pair_decmap DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_init DD imagerel jisx0213_init
	DD	imagerel jisx0213_init+302
	DD	imagerel $unwind$jisx0213_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@
CONST	SEGMENT
??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@ DB '__map_jisx0213_pair', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@
CONST	SEGMENT
??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@ DB '__map_jisx0213_2_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@
CONST	SEGMENT
??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@ DB '__map_jisx0213_1_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@
CONST	SEGMENT
??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@ DB '__map_jisx0213_emp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@
CONST	SEGMENT
??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@ DB '__map_jisx0213_2_bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@
CONST	SEGMENT
??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@ DB '__map_jisx0213_1_bmp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@
CONST	SEGMENT
??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@ DB '__map_jisx0213_bmp', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT jisx0213_init
_TEXT	SEGMENT
jisx0213_init PROC					; COMDAT

; 683  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 684  :     static int initialized = 0;
; 685  : 
; 686  :     if (!initialized && (
; 687  :                     jisx0208_init() ||
; 688  :                     IMPORT_MAP(jp, jisx0213_bmp,
; 689  :                                &jisx0213_bmp_encmap, NULL) ||
; 690  :                     IMPORT_MAP(jp, jisx0213_1_bmp,
; 691  :                                NULL, &jisx0213_1_bmp_decmap) ||
; 692  :                     IMPORT_MAP(jp, jisx0213_2_bmp,
; 693  :                                NULL, &jisx0213_2_bmp_decmap) ||
; 694  :                     IMPORT_MAP(jp, jisx0213_emp,
; 695  :                                &jisx0213_emp_encmap, NULL) ||
; 696  :                     IMPORT_MAP(jp, jisx0213_1_emp,
; 697  :                                NULL, &jisx0213_1_emp_decmap) ||
; 698  :                     IMPORT_MAP(jp, jisx0213_2_emp,
; 699  :                                NULL, &jisx0213_2_emp_decmap) ||
; 700  :                     IMPORT_MAP(jp, jisx0213_pair, &jisx0213_pair_encmap,
; 701  :                                &jisx0213_pair_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??jisx0213_init@@9@9, 0
  0000b	0f 85 0c 01 00
	00		 jne	 $LN2@jisx0213_i
  00011	e8 00 00 00 00	 call	 jisx0208_init
  00016	85 c0		 test	 eax, eax
  00018	0f 85 f7 00 00
	00		 jne	 $LN1@jisx0213_i
  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_bmp_encmap
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJLEKAPO@__map_jisx0213_bmp?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00033	45 33 c9	 xor	 r9d, r9d
  00036	e8 00 00 00 00	 call	 importmap
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 d2 00 00
	00		 jne	 $LN1@jisx0213_i
  00043	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_1_bmp_decmap
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JIDCLJEB@__map_jisx0213_1_bmp?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  00058	45 33 c0	 xor	 r8d, r8d
  0005b	e8 00 00 00 00	 call	 importmap
  00060	85 c0		 test	 eax, eax
  00062	0f 85 ad 00 00
	00		 jne	 $LN1@jisx0213_i
  00068	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_2_bmp_decmap
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BOKGMLOP@__map_jisx0213_2_bmp?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  0007d	45 33 c0	 xor	 r8d, r8d
  00080	e8 00 00 00 00	 call	 importmap
  00085	85 c0		 test	 eax, eax
  00087	0f 85 88 00 00
	00		 jne	 $LN1@jisx0213_i
  0008d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_emp_encmap
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@GEGDJIEH@__map_jisx0213_emp?$AA@
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	e8 00 00 00 00	 call	 importmap
  000aa	85 c0		 test	 eax, eax
  000ac	75 67		 jne	 SHORT $LN1@jisx0213_i
  000ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_1_emp_decmap
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FOFIBPI@__map_jisx0213_1_emp?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	e8 00 00 00 00	 call	 importmap
  000cb	85 c0		 test	 eax, eax
  000cd	75 46		 jne	 SHORT $LN1@jisx0213_i
  000cf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_2_emp_decmap
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@IDHBPDFG@__map_jisx0213_2_emp?$AA@
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  000e4	45 33 c0	 xor	 r8d, r8d
  000e7	e8 00 00 00 00	 call	 importmap
  000ec	85 c0		 test	 eax, eax
  000ee	75 25		 jne	 SHORT $LN1@jisx0213_i
  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:jisx0213_pair_decmap
  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:jisx0213_pair_encmap
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EPEJDGK@__map_jisx0213_pair?$AA@
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICBIJEOL@_codecs_jp?$AA@
  0010c	e8 00 00 00 00	 call	 importmap
  00111	85 c0		 test	 eax, eax
  00113	74 08		 je	 SHORT $LN2@jisx0213_i
$LN1@jisx0213_i:

; 702  :         return -1;

  00115	83 c8 ff	 or	 eax, -1

; 705  : }

  00118	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011c	c3		 ret	 0
$LN2@jisx0213_i:

; 703  :     initialized = 1;

  0011d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??jisx0213_init@@9@9, 1

; 704  :     return 0;

  00127	33 c0		 xor	 eax, eax

; 705  : }

  00129	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0012d	c3		 ret	 0
jisx0213_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0213_2000_1_decoder
_TEXT	SEGMENT
data$ = 8
jisx0213_2000_1_decoder PROC				; COMDAT

; 711  :     ucs4_t u;
; 712  :     EMULATE_JISX0213_2000_DECODE_PLANE1(u, data[0], data[1])

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	48 8b d1	 mov	 rdx, rcx
  00006	3c 2e		 cmp	 al, 46			; 0000002eH
  00008	75 0a		 jne	 SHORT $LN20@jisx0213_2
  0000a	80 79 01 21	 cmp	 BYTE PTR [rcx+1], 33	; 00000021H
  0000e	0f 84 77 01 00
	00		 je	 $LN2@jisx0213_2
$LN20@jisx0213_2:
  00014	3c 2f		 cmp	 al, 47			; 0000002fH
  00016	75 0a		 jne	 SHORT $LN19@jisx0213_2
  00018	80 79 01 7e	 cmp	 BYTE PTR [rcx+1], 126	; 0000007eH
  0001c	0f 84 69 01 00
	00		 je	 $LN2@jisx0213_2
$LN19@jisx0213_2:
  00022	3c 4f		 cmp	 al, 79			; 0000004fH
  00024	75 16		 jne	 SHORT $LN17@jisx0213_2
  00026	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0002a	80 f9 54	 cmp	 cl, 84			; 00000054H
  0002d	0f 84 58 01 00
	00		 je	 $LN2@jisx0213_2
  00033	80 f9 7e	 cmp	 cl, 126			; 0000007eH
  00036	0f 84 4f 01 00
	00		 je	 $LN2@jisx0213_2
$LN17@jisx0213_2:
  0003c	3c 74		 cmp	 al, 116			; 00000074H
  0003e	75 0a		 jne	 SHORT $LN16@jisx0213_2
  00040	80 7a 01 27	 cmp	 BYTE PTR [rdx+1], 39	; 00000027H
  00044	0f 84 41 01 00
	00		 je	 $LN2@jisx0213_2
$LN16@jisx0213_2:
  0004a	3c 7e		 cmp	 al, 126			; 0000007eH
  0004c	75 30		 jne	 SHORT $LN22@jisx0213_2
  0004e	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  00052	80 f9 7a	 cmp	 cl, 122			; 0000007aH
  00055	0f 84 30 01 00
	00		 je	 $LN2@jisx0213_2
  0005b	80 f9 7b	 cmp	 cl, 123			; 0000007bH
  0005e	0f 84 27 01 00
	00		 je	 $LN2@jisx0213_2
  00064	80 f9 7c	 cmp	 cl, 124			; 0000007cH
  00067	0f 84 1e 01 00
	00		 je	 $LN2@jisx0213_2
  0006d	80 f9 7d	 cmp	 cl, 125			; 0000007dH
  00070	0f 84 15 01 00
	00		 je	 $LN2@jisx0213_2
  00076	3a c8		 cmp	 cl, al
  00078	0f 84 0d 01 00
	00		 je	 $LN2@jisx0213_2
$LN22@jisx0213_2:

; 713  :     else if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  0007e	3c 21		 cmp	 al, 33			; 00000021H
  00080	75 0c		 jne	 SHORT $LN10@jisx0213_2
  00082	80 7a 01 40	 cmp	 BYTE PTR [rdx+1], 64	; 00000040H
  00086	75 06		 jne	 SHORT $LN10@jisx0213_2

; 714  :         return 0xff3c;

  00088	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH

; 723  : }

  0008d	c3		 ret	 0
$LN10@jisx0213_2:

; 715  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1]);

  0008e	44 0f b6 c0	 movzx	 r8d, al
  00092	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0208_decmap
  00099	4d 03 c0	 add	 r8, r8
  0009c	4e 8b 14 c0	 mov	 r10, QWORD PTR [rax+r8*8]
  000a0	4d 85 d2	 test	 r10, r10
  000a3	74 30		 je	 SHORT $LN8@jisx0213_2
  000a5	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  000a9	46 0f b6 4c c0
	08		 movzx	 r9d, BYTE PTR [rax+r8*8+8]
  000af	41 3a c9	 cmp	 cl, r9b
  000b2	72 21		 jb	 SHORT $LN8@jisx0213_2
  000b4	42 3a 4c c0 09	 cmp	 cl, BYTE PTR [rax+r8*8+9]
  000b9	77 1a		 ja	 SHORT $LN8@jisx0213_2
  000bb	41 0f b6 c1	 movzx	 eax, r9b
  000bf	0f b6 c9	 movzx	 ecx, cl
  000c2	48 2b c8	 sub	 rcx, rax
  000c5	41 0f b7 04 4a	 movzx	 eax, WORD PTR [r10+rcx*2]
  000ca	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  000cf	0f 85 bb 00 00
	00		 jne	 $LN23@jisx0213_2
$LN8@jisx0213_2:

; 716  :     else TRYMAP_DEC(jisx0213_1_bmp, u, data[0], data[1]);

  000d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_1_bmp_decmap
  000dc	4e 8b 0c c0	 mov	 r9, QWORD PTR [rax+r8*8]
  000e0	4d 85 c9	 test	 r9, r9
  000e3	74 2c		 je	 SHORT $LN6@jisx0213_2
  000e5	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  000e9	46 0f b6 54 c0
	08		 movzx	 r10d, BYTE PTR [rax+r8*8+8]
  000ef	41 3a ca	 cmp	 cl, r10b
  000f2	72 1d		 jb	 SHORT $LN6@jisx0213_2
  000f4	42 3a 4c c0 09	 cmp	 cl, BYTE PTR [rax+r8*8+9]
  000f9	77 16		 ja	 SHORT $LN6@jisx0213_2
  000fb	41 0f b6 c2	 movzx	 eax, r10b
  000ff	0f b6 c9	 movzx	 ecx, cl
  00102	48 2b c8	 sub	 rcx, rax
  00105	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0010a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0010f	75 7f		 jne	 SHORT $LN23@jisx0213_2
$LN6@jisx0213_2:

; 717  :     else TRYMAP_DEC(jisx0213_1_emp, u, data[0], data[1])

  00111	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_1_emp_decmap
  00118	4e 8b 0c c0	 mov	 r9, QWORD PTR [rax+r8*8]
  0011c	4d 85 c9	 test	 r9, r9
  0011f	74 31		 je	 SHORT $LN4@jisx0213_2
  00121	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  00125	46 0f b6 54 c0
	08		 movzx	 r10d, BYTE PTR [rax+r8*8+8]
  0012b	41 3a ca	 cmp	 cl, r10b
  0012e	72 22		 jb	 SHORT $LN4@jisx0213_2
  00130	42 3a 4c c0 09	 cmp	 cl, BYTE PTR [rax+r8*8+9]
  00135	77 1b		 ja	 SHORT $LN4@jisx0213_2
  00137	41 0f b6 c2	 movzx	 eax, r10b
  0013b	0f b6 c9	 movzx	 ecx, cl
  0013e	48 2b c8	 sub	 rcx, rax
  00141	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  00146	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0014b	74 05		 je	 SHORT $LN4@jisx0213_2

; 718  :         u |= 0x20000;

  0014d	0f ba e8 11	 bts	 eax, 17

; 723  : }

  00151	c3		 ret	 0
$LN4@jisx0213_2:

; 719  :     else TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]);

  00152	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_pair_decmap
  00159	4e 8b 0c c0	 mov	 r9, QWORD PTR [rax+r8*8]
  0015d	4d 85 c9	 test	 r9, r9
  00160	74 29		 je	 SHORT $LN2@jisx0213_2
  00162	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  00166	42 0f b6 54 c0
	08		 movzx	 edx, BYTE PTR [rax+r8*8+8]
  0016c	3a ca		 cmp	 cl, dl
  0016e	72 1b		 jb	 SHORT $LN2@jisx0213_2
  00170	42 3a 4c c0 09	 cmp	 cl, BYTE PTR [rax+r8*8+9]
  00175	77 14		 ja	 SHORT $LN2@jisx0213_2
  00177	0f b6 c2	 movzx	 eax, dl
  0017a	0f b6 c9	 movzx	 ecx, cl
  0017d	48 2b c8	 sub	 rcx, rax
  00180	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00184	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 722  :     return u;

  00189	75 05		 jne	 SHORT $LN23@jisx0213_2
$LN2@jisx0213_2:

; 720  :     else
; 721  :         return MAP_UNMAPPABLE;

  0018b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN23@jisx0213_2:

; 723  : }

  00190	f3 c3		 fatret	 0
jisx0213_2000_1_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0213_2000_2_decoder
_TEXT	SEGMENT
data$ = 8
jisx0213_2000_2_decoder PROC				; COMDAT

; 728  :     ucs4_t u;
; 729  :     EMULATE_JISX0213_2000_DECODE_PLANE2(u, data[0], data[1])
; 730  :     TRYMAP_DEC(jisx0213_2_bmp, u, data[0], data[1]);

  00000	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  00003	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_2_bmp_decmap
  0000a	4c 8b d1	 mov	 r10, rcx
  0000d	48 03 d2	 add	 rdx, rdx
  00010	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  00014	4d 85 c9	 test	 r9, r9
  00017	74 2c		 je	 SHORT $LN4@jisx0213_2@2
  00019	44 0f b6 41 01	 movzx	 r8d, BYTE PTR [rcx+1]
  0001e	0f b6 4c d0 08	 movzx	 ecx, BYTE PTR [rax+rdx*8+8]
  00023	44 3a c1	 cmp	 r8b, cl
  00026	72 1d		 jb	 SHORT $LN4@jisx0213_2@2
  00028	44 3a 44 d0 09	 cmp	 r8b, BYTE PTR [rax+rdx*8+9]
  0002d	77 16		 ja	 SHORT $LN4@jisx0213_2@2
  0002f	0f b6 c1	 movzx	 eax, cl
  00032	41 0f b6 c8	 movzx	 ecx, r8b
  00036	48 2b c8	 sub	 rcx, rax
  00039	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0003e	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00043	75 46		 jne	 SHORT $LN6@jisx0213_2@2
$LN4@jisx0213_2@2:

; 731  :     else TRYMAP_DEC(jisx0213_2_emp, u, data[0], data[1])

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_2_emp_decmap
  0004c	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  00050	4d 85 c9	 test	 r9, r9
  00053	74 31		 je	 SHORT $LN2@jisx0213_2@2
  00055	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  0005a	44 0f b6 44 d0
	08		 movzx	 r8d, BYTE PTR [rax+rdx*8+8]
  00060	41 3a c8	 cmp	 cl, r8b
  00063	72 21		 jb	 SHORT $LN2@jisx0213_2@2
  00065	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  00069	77 1b		 ja	 SHORT $LN2@jisx0213_2@2
  0006b	41 0f b6 c0	 movzx	 eax, r8b
  0006f	0f b6 c9	 movzx	 ecx, cl
  00072	48 2b c8	 sub	 rcx, rax
  00075	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0007a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0007f	74 05		 je	 SHORT $LN2@jisx0213_2@2

; 732  :         u |= 0x20000;

  00081	0f ba e8 11	 bts	 eax, 17

; 735  :     return u;
; 736  : }

  00085	c3		 ret	 0
$LN2@jisx0213_2@2:

; 733  :     else
; 734  :         return MAP_UNMAPPABLE;

  00086	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN6@jisx0213_2@2:

; 735  :     return u;
; 736  : }

  0008b	f3 c3		 fatret	 0
jisx0213_2000_2_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0213_2004_1_decoder
_TEXT	SEGMENT
data$ = 8
jisx0213_2004_1_decoder PROC				; COMDAT

; 742  :     ucs4_t u;
; 743  :     if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	4c 8b c1	 mov	 r8, rcx
  00006	3c 21		 cmp	 al, 33			; 00000021H
  00008	75 0c		 jne	 SHORT $LN10@jisx0213_2@3
  0000a	80 79 01 40	 cmp	 BYTE PTR [rcx+1], 64	; 00000040H
  0000e	75 06		 jne	 SHORT $LN10@jisx0213_2@3

; 744  :         return 0xff3c;

  00010	b8 3c ff 00 00	 mov	 eax, 65340		; 0000ff3cH

; 753  : }

  00015	c3		 ret	 0
$LN10@jisx0213_2@3:

; 745  :     else TRYMAP_DEC(jisx0208, u, data[0], data[1]);

  00016	0f b6 d0	 movzx	 edx, al
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0208_decmap
  00020	48 03 d2	 add	 rdx, rdx
  00023	4c 8b 14 d0	 mov	 r10, QWORD PTR [rax+rdx*8]
  00027	4d 85 d2	 test	 r10, r10
  0002a	74 2f		 je	 SHORT $LN8@jisx0213_2@3
  0002c	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00030	44 0f b6 4c d0
	08		 movzx	 r9d, BYTE PTR [rax+rdx*8+8]
  00036	41 3a c9	 cmp	 cl, r9b
  00039	72 20		 jb	 SHORT $LN8@jisx0213_2@3
  0003b	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  0003f	77 1a		 ja	 SHORT $LN8@jisx0213_2@3
  00041	41 0f b6 c1	 movzx	 eax, r9b
  00045	0f b6 c9	 movzx	 ecx, cl
  00048	48 2b c8	 sub	 rcx, rax
  0004b	41 0f b7 04 4a	 movzx	 eax, WORD PTR [r10+rcx*2]
  00050	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00055	0f 85 c1 00 00
	00		 jne	 $LN11@jisx0213_2@3
$LN8@jisx0213_2@3:

; 746  :     else TRYMAP_DEC(jisx0213_1_bmp, u, data[0], data[1]);

  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_1_bmp_decmap
  00062	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  00066	4d 85 c9	 test	 r9, r9
  00069	74 30		 je	 SHORT $LN6@jisx0213_2@3
  0006b	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  00070	44 0f b6 54 d0
	08		 movzx	 r10d, BYTE PTR [rax+rdx*8+8]
  00076	41 3a ca	 cmp	 cl, r10b
  00079	72 20		 jb	 SHORT $LN6@jisx0213_2@3
  0007b	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  0007f	77 1a		 ja	 SHORT $LN6@jisx0213_2@3
  00081	41 0f b6 c2	 movzx	 eax, r10b
  00085	0f b6 c9	 movzx	 ecx, cl
  00088	48 2b c8	 sub	 rcx, rax
  0008b	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  00090	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00095	0f 85 81 00 00
	00		 jne	 $LN11@jisx0213_2@3
$LN6@jisx0213_2@3:

; 747  :     else TRYMAP_DEC(jisx0213_1_emp, u, data[0], data[1])

  0009b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_1_emp_decmap
  000a2	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  000a6	4d 85 c9	 test	 r9, r9
  000a9	74 31		 je	 SHORT $LN4@jisx0213_2@3
  000ab	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  000b0	44 0f b6 54 d0
	08		 movzx	 r10d, BYTE PTR [rax+rdx*8+8]
  000b6	41 3a ca	 cmp	 cl, r10b
  000b9	72 21		 jb	 SHORT $LN4@jisx0213_2@3
  000bb	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  000bf	77 1b		 ja	 SHORT $LN4@jisx0213_2@3
  000c1	41 0f b6 c2	 movzx	 eax, r10b
  000c5	0f b6 c9	 movzx	 ecx, cl
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  000d0	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  000d5	74 05		 je	 SHORT $LN4@jisx0213_2@3

; 748  :         u |= 0x20000;

  000d7	0f ba e8 11	 bts	 eax, 17

; 753  : }

  000db	c3		 ret	 0
$LN4@jisx0213_2@3:

; 749  :     else TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]);

  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_pair_decmap
  000e3	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  000e7	4d 85 c9	 test	 r9, r9
  000ea	74 2b		 je	 SHORT $LN2@jisx0213_2@3
  000ec	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  000f1	44 0f b6 44 d0
	08		 movzx	 r8d, BYTE PTR [rax+rdx*8+8]
  000f7	41 3a c8	 cmp	 cl, r8b
  000fa	72 1b		 jb	 SHORT $LN2@jisx0213_2@3
  000fc	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  00100	77 15		 ja	 SHORT $LN2@jisx0213_2@3
  00102	41 0f b6 c0	 movzx	 eax, r8b
  00106	0f b6 c9	 movzx	 ecx, cl
  00109	48 2b c8	 sub	 rcx, rax
  0010c	41 8b 04 89	 mov	 eax, DWORD PTR [r9+rcx*4]
  00110	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 752  :     return u;

  00115	75 05		 jne	 SHORT $LN11@jisx0213_2@3
$LN2@jisx0213_2@3:

; 750  :     else
; 751  :         return MAP_UNMAPPABLE;

  00117	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN11@jisx0213_2@3:

; 753  : }

  0011c	f3 c3		 fatret	 0
jisx0213_2004_1_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0213_2004_2_decoder
_TEXT	SEGMENT
data$ = 8
jisx0213_2004_2_decoder PROC				; COMDAT

; 758  :     ucs4_t u;
; 759  :     TRYMAP_DEC(jisx0213_2_bmp, u, data[0], data[1]);

  00000	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  00003	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_2_bmp_decmap
  0000a	4c 8b d1	 mov	 r10, rcx
  0000d	48 03 d2	 add	 rdx, rdx
  00010	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  00014	4d 85 c9	 test	 r9, r9
  00017	74 2c		 je	 SHORT $LN4@jisx0213_2@4
  00019	44 0f b6 41 01	 movzx	 r8d, BYTE PTR [rcx+1]
  0001e	0f b6 4c d0 08	 movzx	 ecx, BYTE PTR [rax+rdx*8+8]
  00023	44 3a c1	 cmp	 r8b, cl
  00026	72 1d		 jb	 SHORT $LN4@jisx0213_2@4
  00028	44 3a 44 d0 09	 cmp	 r8b, BYTE PTR [rax+rdx*8+9]
  0002d	77 16		 ja	 SHORT $LN4@jisx0213_2@4
  0002f	0f b6 c1	 movzx	 eax, cl
  00032	41 0f b6 c8	 movzx	 ecx, r8b
  00036	48 2b c8	 sub	 rcx, rax
  00039	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0003e	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00043	75 46		 jne	 SHORT $LN5@jisx0213_2@4
$LN4@jisx0213_2@4:

; 760  :     else TRYMAP_DEC(jisx0213_2_emp, u, data[0], data[1])

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_2_emp_decmap
  0004c	4c 8b 0c d0	 mov	 r9, QWORD PTR [rax+rdx*8]
  00050	4d 85 c9	 test	 r9, r9
  00053	74 31		 je	 SHORT $LN2@jisx0213_2@4
  00055	41 0f b6 4a 01	 movzx	 ecx, BYTE PTR [r10+1]
  0005a	44 0f b6 44 d0
	08		 movzx	 r8d, BYTE PTR [rax+rdx*8+8]
  00060	41 3a c8	 cmp	 cl, r8b
  00063	72 21		 jb	 SHORT $LN2@jisx0213_2@4
  00065	3a 4c d0 09	 cmp	 cl, BYTE PTR [rax+rdx*8+9]
  00069	77 1b		 ja	 SHORT $LN2@jisx0213_2@4
  0006b	41 0f b6 c0	 movzx	 eax, r8b
  0006f	0f b6 c9	 movzx	 ecx, cl
  00072	48 2b c8	 sub	 rcx, rax
  00075	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0007a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  0007f	74 05		 je	 SHORT $LN2@jisx0213_2@4

; 761  :         u |= 0x20000;

  00081	0f ba e8 11	 bts	 eax, 17

; 764  :     return u;
; 765  : }

  00085	c3		 ret	 0
$LN2@jisx0213_2@4:

; 762  :     else
; 763  :         return MAP_UNMAPPABLE;

  00086	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN5@jisx0213_2@4:

; 764  :     return u;
; 765  : }

  0008b	f3 c3		 fatret	 0
jisx0213_2004_2_decoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_encoder DD imagerel jisx0213_encoder
	DD	imagerel jisx0213_encoder+694
	DD	imagerel $unwind$jisx0213_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_encoder DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_encoder
_TEXT	SEGMENT
data$ = 48
length$ = 56
config$ = 64
jisx0213_encoder PROC					; COMDAT

; 769  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 770  :     DBCHAR coded;
; 771  : 
; 772  :     switch (*length) {

  0000f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx
  00018	be fd ff 00 00	 mov	 esi, 65533		; 0000fffdH
  0001d	48 83 f8 ff	 cmp	 rax, -1
  00021	74 49		 je	 SHORT $LN5@jisx0213_e
  00023	48 83 f8 01	 cmp	 rax, 1
  00027	74 79		 je	 SHORT $LN25@jisx0213_e
  00029	48 83 f8 02	 cmp	 rax, 2

; 814  :         else
; 815  :             return coded;
; 816  :     default:
; 817  :         return MAP_UNMAPPABLE;

  0002d	75 5e		 jne	 SHORT $LN18@jisx0213_e

; 791  :                 return MAP_UNMAPPABLE;
; 792  :         }
; 793  :         else
; 794  :             return MAP_UNMAPPABLE;
; 795  :         return coded;
; 796  :     case 2: /* second character of unicode pair */
; 797  :         coded = find_pairencmap((ucs2_t)data[0], (ucs2_t)data[1],
; 798  :                         jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  0002f	0f b7 51 04	 movzx	 edx, WORD PTR [rcx+4]
  00033	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  0003a	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0003d	44 8d 48 2c	 lea	 r9d, QWORD PTR [rax+44]
  00041	e8 00 00 00 00	 call	 find_pairencmap

; 799  :         if (coded == DBCINV) {

  00046	66 3b c6	 cmp	 ax, si
  00049	75 47		 jne	 SHORT $LN3@jisx0213_e

; 800  :             *length = 1;

  0004b	48 c7 07 01 00
	00 00		 mov	 QWORD PTR [rdi], 1

; 801  :             coded = find_pairencmap((ucs2_t)data[0], 0,
; 802  :                       jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  00052	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  00059	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0005c	33 d2		 xor	 edx, edx
  0005e	44 8d 4a 2e	 lea	 r9d, QWORD PTR [rdx+46]
  00062	e8 00 00 00 00	 call	 find_pairencmap

; 803  :             if (coded == DBCINV)

  00067	66 3b c6	 cmp	 ax, si
  0006a	74 21		 je	 SHORT $LN18@jisx0213_e
$LN5@jisx0213_e:

; 804  :                 return MAP_UNMAPPABLE;
; 805  :         }
; 806  :         else
; 807  :             return coded;
; 808  :     case -1: /* flush unterminated */
; 809  :         *length = 1;

  0006c	48 c7 07 01 00
	00 00		 mov	 QWORD PTR [rdi], 1

; 810  :         coded = find_pairencmap((ucs2_t)data[0], 0,
; 811  :                         jisx0213_pair_encmap, JISX0213_ENCPAIRS);

  00073	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR jisx0213_pair_encmap
  0007a	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0007d	33 d2		 xor	 edx, edx
  0007f	44 8d 4a 2e	 lea	 r9d, QWORD PTR [rdx+46]
  00083	e8 00 00 00 00	 call	 find_pairencmap

; 812  :         if (coded == DBCINV)

  00088	66 3b c6	 cmp	 ax, si
  0008b	75 05		 jne	 SHORT $LN3@jisx0213_e
$LN18@jisx0213_e:

; 813  :             return MAP_UNMAPPABLE;

  0008d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN3@jisx0213_e:

; 818  :     }
; 819  : }

  00092	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00097	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
$LN25@jisx0213_e:

; 773  :     case 1: /* first character */
; 774  :         if (*data >= 0x10000) {

  000a2	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000a4	81 f9 00 00 01
	00		 cmp	 ecx, 65536		; 00010000H
  000aa	0f 82 8f 00 00
	00		 jb	 $LN24@jisx0213_e

; 775  :             if ((*data) >> 16 == 0x20000 >> 16) {

  000b0	8b c1		 mov	 eax, ecx
  000b2	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000b7	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  000bc	3d 00 00 02 00	 cmp	 eax, 131072		; 00020000H
  000c1	75 69		 jne	 SHORT $LN20@jisx0213_e

; 776  :                 EMULATE_JISX0213_2000_ENCODE_EMP(coded, *data)

  000c3	49 81 f8 d0 07
	00 00		 cmp	 r8, 2000		; 000007d0H
  000ca	75 1a		 jne	 SHORT $LN22@jisx0213_e
  000cc	81 f9 9f 0b 02
	00		 cmp	 ecx, 134047		; 00020b9fH
  000d2	75 12		 jne	 SHORT $LN22@jisx0213_e
  000d4	8b c2		 mov	 eax, edx

; 818  :     }
; 819  : }

  000d6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000db	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
$LN22@jisx0213_e:

; 777  :                 else TRYMAP_ENC(jisx0213_emp, coded,
; 778  :                                 (*data) & 0xffff)

  000e6	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  000ea	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR jisx0213_emp_encmap
  000f1	48 c1 e0 04	 shl	 rax, 4
  000f5	4e 8b 1c 08	 mov	 r11, QWORD PTR [rax+r9]
  000f9	4d 85 db	 test	 r11, r11
  000fc	74 2e		 je	 SHORT $LN20@jisx0213_e
  000fe	46 0f b6 54 08
	08		 movzx	 r10d, BYTE PTR [rax+r9+8]
  00104	44 0f b6 c1	 movzx	 r8d, cl
  00108	45 3b c2	 cmp	 r8d, r10d
  0010b	72 1f		 jb	 SHORT $LN20@jisx0213_e
  0010d	42 0f b6 44 08
	09		 movzx	 eax, BYTE PTR [rax+r9+9]
  00113	44 3b c0	 cmp	 r8d, eax
  00116	77 14		 ja	 SHORT $LN20@jisx0213_e
  00118	45 2b c2	 sub	 r8d, r10d
  0011b	41 8b c0	 mov	 eax, r8d
  0011e	43 0f b7 04 43	 movzx	 eax, WORD PTR [r11+r8*2]
  00123	66 3b c2	 cmp	 ax, dx

; 779  :                     return coded;

  00126	0f 85 66 ff ff
	ff		 jne	 $LN3@jisx0213_e
$LN20@jisx0213_e:

; 780  :             }
; 781  :             return MAP_UNMAPPABLE;

  0012c	0f b7 c2	 movzx	 eax, dx

; 818  :     }
; 819  : }

  0012f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00134	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00139	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013d	5f		 pop	 rdi
  0013e	c3		 ret	 0
$LN24@jisx0213_e:

; 782  :         }
; 783  : 
; 784  :         EMULATE_JISX0213_2000_ENCODE_BMP(coded, *data)

  0013f	49 81 f8 d0 07
	00 00		 cmp	 r8, 2000		; 000007d0H
  00146	0f 85 95 00 00
	00		 jne	 $LN16@jisx0213_e
  0014c	81 f9 1c 9b 00
	00		 cmp	 ecx, 39708		; 00009b1cH
  00152	0f 84 35 ff ff
	ff		 je	 $LN18@jisx0213_e
  00158	81 f9 f1 4f 00
	00		 cmp	 ecx, 20465		; 00004ff1H
  0015e	0f 84 29 ff ff
	ff		 je	 $LN18@jisx0213_e
  00164	81 f9 5d 52 00
	00		 cmp	 ecx, 21085		; 0000525dH
  0016a	0f 84 1d ff ff
	ff		 je	 $LN18@jisx0213_e
  00170	81 f9 1e 54 00
	00		 cmp	 ecx, 21534		; 0000541eH
  00176	0f 84 11 ff ff
	ff		 je	 $LN18@jisx0213_e
  0017c	81 f9 53 56 00
	00		 cmp	 ecx, 22099		; 00005653H
  00182	0f 84 05 ff ff
	ff		 je	 $LN18@jisx0213_e
  00188	81 f9 f8 59 00
	00		 cmp	 ecx, 23032		; 000059f8H
  0018e	0f 84 f9 fe ff
	ff		 je	 $LN18@jisx0213_e
  00194	81 f9 5b 5c 00
	00		 cmp	 ecx, 23643		; 00005c5bH
  0019a	0f 84 ed fe ff
	ff		 je	 $LN18@jisx0213_e
  001a0	81 f9 77 5e 00
	00		 cmp	 ecx, 24183		; 00005e77H
  001a6	0f 84 e1 fe ff
	ff		 je	 $LN18@jisx0213_e
  001ac	81 f9 26 76 00
	00		 cmp	 ecx, 30246		; 00007626H
  001b2	0f 84 d5 fe ff
	ff		 je	 $LN18@jisx0213_e
  001b8	81 f9 6b 7e 00
	00		 cmp	 ecx, 32363		; 00007e6bH
  001be	0f 84 c9 fe ff
	ff		 je	 $LN18@jisx0213_e
  001c4	81 f9 1d 9b 00
	00		 cmp	 ecx, 39709		; 00009b1dH
  001ca	75 15		 jne	 SHORT $LN16@jisx0213_e
  001cc	b8 3b fd 00 00	 mov	 eax, 64827		; 0000fd3bH

; 818  :     }
; 819  : }

  001d1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001d6	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001df	5f		 pop	 rdi
  001e0	c3		 ret	 0
$LN16@jisx0213_e:

; 785  :         else TRYMAP_ENC(jisx0213_bmp, coded, *data) {

  001e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisx0213_bmp_encmap
  001e8	4c 8b c1	 mov	 r8, rcx
  001eb	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  001f0	49 c1 e8 08	 shr	 r8, 8
  001f4	4d 03 c0	 add	 r8, r8
  001f7	4e 8b 1c c0	 mov	 r11, QWORD PTR [rax+r8*8]
  001fb	4d 85 db	 test	 r11, r11
  001fe	74 4b		 je	 SHORT $LN14@jisx0213_e
  00200	46 0f b6 54 c0
	08		 movzx	 r10d, BYTE PTR [rax+r8*8+8]
  00206	44 0f b6 c9	 movzx	 r9d, cl
  0020a	45 3b ca	 cmp	 r9d, r10d
  0020d	72 3c		 jb	 SHORT $LN14@jisx0213_e
  0020f	42 0f b6 44 c0
	09		 movzx	 eax, BYTE PTR [rax+r8*8+9]
  00215	44 3b c8	 cmp	 r9d, eax
  00218	77 31		 ja	 SHORT $LN14@jisx0213_e
  0021a	45 2b ca	 sub	 r9d, r10d
  0021d	41 8b c1	 mov	 eax, r9d
  00220	43 0f b7 04 4b	 movzx	 eax, WORD PTR [r11+r9*2]
  00225	66 3b c2	 cmp	 ax, dx
  00228	74 21		 je	 SHORT $LN14@jisx0213_e

; 786  :             if (coded == MULTIC)

  0022a	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0022f	66 3b c1	 cmp	 ax, cx
  00232	0f 85 5a fe ff
	ff		 jne	 $LN3@jisx0213_e

; 787  :                 return MAP_MULTIPLE_AVAIL;

  00238	0f b7 c1	 movzx	 eax, cx

; 818  :     }
; 819  : }

  0023b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00240	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00245	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00249	5f		 pop	 rdi
  0024a	c3		 ret	 0
$LN14@jisx0213_e:

; 788  :         }
; 789  :         else TRYMAP_ENC(jisxcommon, coded, *data) {

  0024b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR jisxcommon_encmap
  00252	4e 8b 1c c0	 mov	 r11, QWORD PTR [rax+r8*8]
  00256	4d 85 db	 test	 r11, r11
  00259	0f 84 cd fe ff
	ff		 je	 $LN20@jisx0213_e
  0025f	46 0f b6 54 c0
	08		 movzx	 r10d, BYTE PTR [rax+r8*8+8]
  00265	44 0f b6 c9	 movzx	 r9d, cl
  00269	45 3b ca	 cmp	 r9d, r10d
  0026c	0f 82 ba fe ff
	ff		 jb	 $LN20@jisx0213_e
  00272	42 0f b6 44 c0
	09		 movzx	 eax, BYTE PTR [rax+r8*8+9]
  00278	44 3b c8	 cmp	 r9d, eax
  0027b	0f 87 ab fe ff
	ff		 ja	 $LN20@jisx0213_e
  00281	45 2b ca	 sub	 r9d, r10d
  00284	41 8b c1	 mov	 eax, r9d
  00287	43 0f b7 04 4b	 movzx	 eax, WORD PTR [r11+r9*2]
  0028c	66 3b c2	 cmp	 ax, dx
  0028f	0f 84 97 fe ff
	ff		 je	 $LN20@jisx0213_e

; 790  :             if (coded & 0x8000)

  00295	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  0029a	66 85 c1	 test	 ax, cx
  0029d	0f 84 ef fd ff
	ff		 je	 $LN3@jisx0213_e

; 818  :     }
; 819  : }

  002a3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  002a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  002ad	0f b7 c2	 movzx	 eax, dx
  002b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002b4	5f		 pop	 rdi
  002b5	c3		 ret	 0
jisx0213_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_1_encoder DD imagerel jisx0213_2000_1_encoder
	DD	imagerel jisx0213_2000_1_encoder+53
	DD	imagerel $unwind$jisx0213_2000_1_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_1_encoder DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2000_1_encoder
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2000_1_encoder PROC				; COMDAT

; 823  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 824  :     DBCHAR coded = jisx0213_encoder(data, length, (void *)2000);

  00004	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  0000a	e8 00 00 00 00	 call	 jisx0213_encoder

; 825  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  0000f	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00014	66 3b c2	 cmp	 ax, dx
  00017	74 17		 je	 SHORT $LN4@jisx0213_2@5
  00019	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0001e	66 3b c1	 cmp	 ax, cx
  00021	74 0d		 je	 SHORT $LN4@jisx0213_2@5

; 826  :         return coded;
; 827  :     else if (coded & 0x8000)

  00023	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00028	66 85 c1	 test	 ax, cx
  0002b	74 03		 je	 SHORT $LN4@jisx0213_2@5

; 828  :         return MAP_UNMAPPABLE;

  0002d	0f b7 c2	 movzx	 eax, dx
$LN4@jisx0213_2@5:

; 829  :     else
; 830  :         return coded;
; 831  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
jisx0213_2000_1_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_1_encoder_paironly DD imagerel jisx0213_2000_1_encoder_paironly
	DD	imagerel jisx0213_2000_1_encoder_paironly+83
	DD	imagerel $unwind$jisx0213_2000_1_encoder_paironly
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_1_encoder_paironly DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2000_1_encoder_paironly
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2000_1_encoder_paironly PROC			; COMDAT

; 835  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 836  :     DBCHAR coded;
; 837  :     Py_ssize_t ilength = *length;

  0000a	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]

; 838  : 
; 839  :     coded = jisx0213_encoder(data, length, (void *)2000);

  0000d	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  00013	48 8b fa	 mov	 rdi, rdx
  00016	e8 00 00 00 00	 call	 jisx0213_encoder

; 840  :     switch (ilength) {

  0001b	48 ff cb	 dec	 rbx
  0001e	74 1b		 je	 SHORT $LN7@jisx0213_2@6
  00020	48 ff cb	 dec	 rbx

; 849  :         else
; 850  :             return coded;
; 851  :     default:
; 852  :         return MAP_UNMAPPABLE;

  00023	75 06		 jne	 SHORT $LN6@jisx0213_2@6

; 846  :     case 2:
; 847  :         if (*length != 2)

  00025	48 83 3f 02	 cmp	 QWORD PTR [rdi], 2

; 848  :             return MAP_UNMAPPABLE;

  00029	74 05		 je	 SHORT $LN8@jisx0213_2@6
$LN6@jisx0213_2@6:

; 844  :         else
; 845  :             return MAP_UNMAPPABLE;

  0002b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN8@jisx0213_2@6:

; 853  :     }
; 854  : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN7@jisx0213_2@6:

; 841  :     case 1:
; 842  :         if (coded == MAP_MULTIPLE_AVAIL)

  0003b	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  00040	66 3b c1	 cmp	 ax, cx
  00043	75 e6		 jne	 SHORT $LN6@jisx0213_2@6

; 843  :             return MAP_MULTIPLE_AVAIL;

  00045	0f b7 c1	 movzx	 eax, cx

; 853  :     }
; 854  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
jisx0213_2000_1_encoder_paironly ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2000_2_encoder DD imagerel jisx0213_2000_2_encoder
	DD	imagerel jisx0213_2000_2_encoder+66
	DD	imagerel $unwind$jisx0213_2000_2_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2000_2_encoder DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2000_2_encoder
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2000_2_encoder PROC				; COMDAT

; 858  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 859  :     DBCHAR coded = jisx0213_encoder(data, length, (void *)2000);

  00004	41 b8 d0 07 00
	00		 mov	 r8d, 2000		; 000007d0H
  0000a	e8 00 00 00 00	 call	 jisx0213_encoder

; 860  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  0000f	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00014	66 3b c2	 cmp	 ax, dx
  00017	74 24		 je	 SHORT $LN4@jisx0213_2@7
  00019	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0001e	66 3b c1	 cmp	 ax, cx
  00021	74 1a		 je	 SHORT $LN4@jisx0213_2@7

; 861  :         return coded;
; 862  :     else if (coded & 0x8000)

  00023	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00028	66 85 c1	 test	 ax, cx
  0002b	74 0d		 je	 SHORT $LN2@jisx0213_2@7

; 863  :         return coded & 0x7fff;

  0002d	0f b7 c0	 movzx	 eax, ax
  00030	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH

; 866  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
$LN2@jisx0213_2@7:

; 864  :     else
; 865  :         return MAP_UNMAPPABLE;

  0003a	0f b7 c2	 movzx	 eax, dx
$LN4@jisx0213_2@7:

; 866  : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
jisx0213_2000_2_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_1_encoder DD imagerel jisx0213_2004_1_encoder
	DD	imagerel jisx0213_2004_1_encoder+50
	DD	imagerel $unwind$jisx0213_2004_1_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_1_encoder DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2004_1_encoder
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2004_1_encoder PROC				; COMDAT

; 870  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 871  :     DBCHAR coded = jisx0213_encoder(data, length, NULL);

  00004	45 33 c0	 xor	 r8d, r8d
  00007	e8 00 00 00 00	 call	 jisx0213_encoder

; 872  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  0000c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00011	66 3b c2	 cmp	 ax, dx
  00014	74 17		 je	 SHORT $LN4@jisx0213_2@8
  00016	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0001b	66 3b c1	 cmp	 ax, cx
  0001e	74 0d		 je	 SHORT $LN4@jisx0213_2@8

; 873  :         return coded;
; 874  :     else if (coded & 0x8000)

  00020	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00025	66 85 c1	 test	 ax, cx
  00028	74 03		 je	 SHORT $LN4@jisx0213_2@8

; 875  :         return MAP_UNMAPPABLE;

  0002a	0f b7 c2	 movzx	 eax, dx
$LN4@jisx0213_2@8:

; 876  :     else
; 877  :         return coded;
; 878  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
jisx0213_2004_1_encoder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_1_encoder_paironly DD imagerel jisx0213_2004_1_encoder_paironly
	DD	imagerel jisx0213_2004_1_encoder_paironly+80
	DD	imagerel $unwind$jisx0213_2004_1_encoder_paironly
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_1_encoder_paironly DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2004_1_encoder_paironly
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2004_1_encoder_paironly PROC			; COMDAT

; 882  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 883  :     DBCHAR coded;
; 884  :     Py_ssize_t ilength = *length;

  0000a	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]

; 885  : 
; 886  :     coded = jisx0213_encoder(data, length, NULL);

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	48 8b fa	 mov	 rdi, rdx
  00013	e8 00 00 00 00	 call	 jisx0213_encoder

; 887  :     switch (ilength) {

  00018	48 ff cb	 dec	 rbx
  0001b	74 1b		 je	 SHORT $LN7@jisx0213_2@9
  0001d	48 ff cb	 dec	 rbx

; 896  :         else
; 897  :             return coded;
; 898  :     default:
; 899  :         return MAP_UNMAPPABLE;

  00020	75 06		 jne	 SHORT $LN6@jisx0213_2@9

; 893  :     case 2:
; 894  :         if (*length != 2)

  00022	48 83 3f 02	 cmp	 QWORD PTR [rdi], 2

; 895  :             return MAP_UNMAPPABLE;

  00026	74 05		 je	 SHORT $LN8@jisx0213_2@9
$LN6@jisx0213_2@9:

; 891  :         else
; 892  :             return MAP_UNMAPPABLE;

  00028	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN8@jisx0213_2@9:

; 900  :     }
; 901  : }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN7@jisx0213_2@9:

; 888  :     case 1:
; 889  :         if (coded == MAP_MULTIPLE_AVAIL)

  00038	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0003d	66 3b c1	 cmp	 ax, cx
  00040	75 e6		 jne	 SHORT $LN6@jisx0213_2@9

; 890  :             return MAP_MULTIPLE_AVAIL;

  00042	0f b7 c1	 movzx	 eax, cx

; 900  :     }
; 901  : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
jisx0213_2004_1_encoder_paironly ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$jisx0213_2004_2_encoder DD imagerel jisx0213_2004_2_encoder
	DD	imagerel jisx0213_2004_2_encoder+63
	DD	imagerel $unwind$jisx0213_2004_2_encoder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$jisx0213_2004_2_encoder DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT jisx0213_2004_2_encoder
_TEXT	SEGMENT
data$ = 48
length$ = 56
jisx0213_2004_2_encoder PROC				; COMDAT

; 905  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 906  :     DBCHAR coded = jisx0213_encoder(data, length, NULL);

  00004	45 33 c0	 xor	 r8d, r8d
  00007	e8 00 00 00 00	 call	 jisx0213_encoder

; 907  :     if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)

  0000c	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00011	66 3b c2	 cmp	 ax, dx
  00014	74 24		 je	 SHORT $LN4@jisx0213_2@10
  00016	b9 fe ff 00 00	 mov	 ecx, 65534		; 0000fffeH
  0001b	66 3b c1	 cmp	 ax, cx
  0001e	74 1a		 je	 SHORT $LN4@jisx0213_2@10

; 908  :         return coded;
; 909  :     else if (coded & 0x8000)

  00020	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00025	66 85 c1	 test	 ax, cx
  00028	74 0d		 je	 SHORT $LN2@jisx0213_2@10

; 910  :         return coded & 0x7fff;

  0002a	0f b7 c0	 movzx	 eax, ax
  0002d	25 ff 7f 00 00	 and	 eax, 32767		; 00007fffH

; 913  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
$LN2@jisx0213_2@10:

; 911  :     else
; 912  :         return MAP_UNMAPPABLE;

  00037	0f b7 c2	 movzx	 eax, dx
$LN4@jisx0213_2@10:

; 913  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
jisx0213_2004_2_encoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0201_r_decoder
_TEXT	SEGMENT
data$ = 8
jisx0201_r_decoder PROC					; COMDAT

; 918  :     ucs4_t u;
; 919  :     JISX0201_R_DECODE(*data, u)

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	3c 5c		 cmp	 al, 92			; 0000005cH
  00005	72 0c		 jb	 SHORT $LN15@jisx0201_r
  00007	75 06		 jne	 SHORT $LN8@jisx0201_r
  00009	b8 a5 00 00 00	 mov	 eax, 165		; 000000a5H

; 921  :     return u;
; 922  : }

  0000e	c3		 ret	 0
$LN8@jisx0201_r:

; 918  :     ucs4_t u;
; 919  :     JISX0201_R_DECODE(*data, u)

  0000f	3c 7e		 cmp	 al, 126			; 0000007eH
  00011	73 04		 jae	 SHORT $LN14@jisx0201_r
$LN15@jisx0201_r:
  00013	0f b6 c0	 movzx	 eax, al

; 921  :     return u;
; 922  : }

  00016	c3		 ret	 0
$LN14@jisx0201_r:

; 918  :     ucs4_t u;
; 919  :     JISX0201_R_DECODE(*data, u)

  00017	75 06		 jne	 SHORT $LN4@jisx0201_r
  00019	b8 3e 20 00 00	 mov	 eax, 8254		; 0000203eH

; 921  :     return u;
; 922  : }

  0001e	c3		 ret	 0
$LN4@jisx0201_r:

; 918  :     ucs4_t u;
; 919  :     JISX0201_R_DECODE(*data, u)

  0001f	3c 7f		 cmp	 al, 127			; 0000007fH
  00021	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00026	74 05		 je	 SHORT $LN11@jisx0201_r

; 920  :     else return MAP_UNMAPPABLE;

  00028	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN11@jisx0201_r:

; 921  :     return u;
; 922  : }

  0002d	f3 c3		 fatret	 0
jisx0201_r_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0201_r_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
jisx0201_r_encoder PROC					; COMDAT

; 927  :     DBCHAR coded;
; 928  :     JISX0201_R_ENCODE(*data, coded)

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00007	73 0a		 jae	 SHORT $LN6@jisx0201_r@2
  00009	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0000c	74 05		 je	 SHORT $LN6@jisx0201_r@2
  0000e	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00011	75 1e		 jne	 SHORT $LN7@jisx0201_r@2
$LN6@jisx0201_r@2:
  00013	3d a5 00 00 00	 cmp	 eax, 165		; 000000a5H
  00018	75 06		 jne	 SHORT $LN4@jisx0201_r@2
  0001a	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH

; 930  :     return coded;
; 931  : }

  0001f	c3		 ret	 0
$LN4@jisx0201_r@2:

; 927  :     DBCHAR coded;
; 928  :     JISX0201_R_ENCODE(*data, coded)

  00020	3d 3e 20 00 00	 cmp	 eax, 8254		; 0000203eH
  00025	b8 7e 00 00 00	 mov	 eax, 126		; 0000007eH
  0002a	74 05		 je	 SHORT $LN7@jisx0201_r@2

; 929  :     else return MAP_UNMAPPABLE;

  0002c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN7@jisx0201_r@2:

; 930  :     return coded;
; 931  : }

  00031	f3 c3		 fatret	 0
jisx0201_r_encoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0201_k_decoder
_TEXT	SEGMENT
data$ = 8
jisx0201_k_decoder PROC					; COMDAT

; 936  :     ucs4_t u;
; 937  :     JISX0201_K_DECODE(*data ^ 0x80, u)

  00000	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  00003	0f b6 c2	 movzx	 eax, dl
  00006	34 80		 xor	 al, 128			; 00000080H
  00008	3c a1		 cmp	 al, 161			; 000000a1H
  0000a	72 11		 jb	 SHORT $LN2@jisx0201_k
  0000c	3c df		 cmp	 al, 223			; 000000dfH
  0000e	77 0d		 ja	 SHORT $LN2@jisx0201_k

; 939  :     return u;

  00010	0f b6 c2	 movzx	 eax, dl
  00013	0f ba f8 07	 btc	 eax, 7
  00017	05 c0 fe 00 00	 add	 eax, 65216		; 0000fec0H

; 940  : }

  0001c	c3		 ret	 0
$LN2@jisx0201_k:

; 938  :     else return MAP_UNMAPPABLE;

  0001d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 940  : }

  00022	c3		 ret	 0
jisx0201_k_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT jisx0201_k_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
jisx0201_k_encoder PROC					; COMDAT

; 945  :     DBCHAR coded;
; 946  :     JISX0201_K_ENCODE(*data, coded)

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	3d 61 ff 00 00	 cmp	 eax, 65377		; 0000ff61H
  00007	72 12		 jb	 SHORT $LN2@jisx0201_k@2
  00009	3d 9f ff 00 00	 cmp	 eax, 65439		; 0000ff9fH
  0000e	77 0b		 ja	 SHORT $LN2@jisx0201_k@2
  00010	ba 40 01 00 00	 mov	 edx, 320		; 00000140H
  00015	03 c2		 add	 eax, edx

; 948  :     return coded - 0x80;

  00017	83 c0 80	 add	 eax, -128		; ffffffffffffff80H

; 949  : }

  0001a	c3		 ret	 0
$LN2@jisx0201_k@2:

; 947  :     else return MAP_UNMAPPABLE;

  0001b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 949  : }

  00020	c3		 ret	 0
jisx0201_k_encoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LDNFLDMP@__map_gb2312?$AA@		; `string'
PUBLIC	??_C@_0L@FJIIJALL@_codecs_cn?$AA@		; `string'
PUBLIC	??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$gb2312_init DD imagerel gb2312_init
	DD	imagerel gb2312_init+104
	DD	imagerel $unwind$gb2312_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gb2312_init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0N@LDNFLDMP@__map_gb2312?$AA@
CONST	SEGMENT
??_C@_0N@LDNFLDMP@__map_gb2312?$AA@ DB '__map_gb2312', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FJIIJALL@_codecs_cn?$AA@
CONST	SEGMENT
??_C@_0L@FJIIJALL@_codecs_cn?$AA@ DB '_codecs_cn', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@
CONST	SEGMENT
??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@ DB '__map_gbcommon', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT gb2312_init
_TEXT	SEGMENT
gb2312_init PROC					; COMDAT

; 953  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 954  :     static int initialized = 0;
; 955  : 
; 956  :     if (!initialized && (
; 957  :                     IMPORT_MAP(cn, gbcommon, &gbcommon_encmap, NULL) ||
; 958  :                     IMPORT_MAP(cn, gb2312, NULL, &gb2312_decmap)))

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?initialized@?1??gb2312_init@@9@9, 0
  0000b	75 4a		 jne	 SHORT $LN2@gb2312_ini
  0000d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:gbcommon_encmap
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DGJMEHOH@__map_gbcommon?$AA@
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FJIIJALL@_codecs_cn?$AA@
  00022	45 33 c9	 xor	 r9d, r9d
  00025	e8 00 00 00 00	 call	 importmap
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN1@gb2312_ini
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:gb2312_decmap
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDNFLDMP@__map_gb2312?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FJIIJALL@_codecs_cn?$AA@
  00043	45 33 c0	 xor	 r8d, r8d
  00046	e8 00 00 00 00	 call	 importmap
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN2@gb2312_ini
$LN1@gb2312_ini:

; 959  :         return -1;

  0004f	83 c8 ff	 or	 eax, -1

; 962  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN2@gb2312_ini:

; 960  :     initialized = 1;

  00057	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?initialized@?1??gb2312_init@@9@9, 1

; 961  :     return 0;

  00061	33 c0		 xor	 eax, eax

; 962  : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
gb2312_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT gb2312_decoder
_TEXT	SEGMENT
data$ = 8
gb2312_decoder PROC					; COMDAT

; 967  :     ucs4_t u;
; 968  :     TRYMAP_DEC(gb2312, u, data[0], data[1])

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR gb2312_decmap
  0000a	48 03 c0	 add	 rax, rax
  0000d	4c 8b 0c c2	 mov	 r9, QWORD PTR [rdx+rax*8]
  00011	4d 85 c9	 test	 r9, r9
  00014	74 2b		 je	 SHORT $LN2@gb2312_dec
  00016	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0001a	44 0f b6 44 c2
	08		 movzx	 r8d, BYTE PTR [rdx+rax*8+8]
  00020	41 3a c8	 cmp	 cl, r8b
  00023	72 1c		 jb	 SHORT $LN2@gb2312_dec
  00025	3a 4c c2 09	 cmp	 cl, BYTE PTR [rdx+rax*8+9]
  00029	77 16		 ja	 SHORT $LN2@gb2312_dec
  0002b	41 0f b6 c0	 movzx	 eax, r8b
  0002f	0f b6 c9	 movzx	 ecx, cl
  00032	48 2b c8	 sub	 rcx, rax
  00035	41 0f b7 04 49	 movzx	 eax, WORD PTR [r9+rcx*2]
  0003a	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH

; 969  :         return u;

  0003f	75 05		 jne	 SHORT $LN1@gb2312_dec
$LN2@gb2312_dec:

; 970  :     else
; 971  :         return MAP_UNMAPPABLE;

  00041	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN1@gb2312_dec:

; 972  : }

  00046	f3 c3		 fatret	 0
gb2312_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT gb2312_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
gb2312_encoder PROC					; COMDAT

; 977  :     DBCHAR coded;
; 978  :     assert(*length == 1);
; 979  :     if (*data < 0x10000) {

  00000	8b 11		 mov	 edx, DWORD PTR [rcx]
  00002	41 bb ff ff 00
	00		 mov	 r11d, 65535		; 0000ffffH
  00008	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  0000e	73 4c		 jae	 SHORT $LN1@gb2312_enc

; 980  :         TRYMAP_ENC(gbcommon, coded, *data) {

  00010	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR gbcommon_encmap
  00017	8b c2		 mov	 eax, edx
  00019	48 c1 e8 08	 shr	 rax, 8
  0001d	48 c1 e0 04	 shl	 rax, 4
  00021	4e 8b 14 00	 mov	 r10, QWORD PTR [rax+r8]
  00025	4d 85 d2	 test	 r10, r10
  00028	74 32		 je	 SHORT $LN1@gb2312_enc
  0002a	46 0f b6 4c 00
	08		 movzx	 r9d, BYTE PTR [rax+r8+8]
  00030	0f b6 ca	 movzx	 ecx, dl
  00033	41 3b c9	 cmp	 ecx, r9d
  00036	72 24		 jb	 SHORT $LN1@gb2312_enc
  00038	42 0f b6 44 00
	09		 movzx	 eax, BYTE PTR [rax+r8+9]
  0003e	3b c8		 cmp	 ecx, eax
  00040	77 1a		 ja	 SHORT $LN1@gb2312_enc
  00042	41 2b c9	 sub	 ecx, r9d
  00045	8b c1		 mov	 eax, ecx
  00047	41 0f b7 04 4a	 movzx	 eax, WORD PTR [r10+rcx*2]
  0004c	66 41 3b c3	 cmp	 ax, r11w
  00050	74 0a		 je	 SHORT $LN1@gb2312_enc

; 981  :             if (!(coded & 0x8000))

  00052	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00057	66 85 c1	 test	 ax, cx

; 982  :                 return coded;

  0005a	74 04		 je	 SHORT $LN4@gb2312_enc
$LN1@gb2312_enc:

; 983  :         }
; 984  :     }
; 985  :     return MAP_UNMAPPABLE;

  0005c	41 0f b7 c3	 movzx	 eax, r11w
$LN4@gb2312_enc:

; 986  : }

  00060	f3 c3		 fatret	 0
gb2312_encoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT dummy_decoder
_TEXT	SEGMENT
data$ = 8
dummy_decoder PROC					; COMDAT

; 992  :     return MAP_UNMAPPABLE;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 993  : }

  00005	c3		 ret	 0
dummy_decoder ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT dummy_encoder
_TEXT	SEGMENT
data$ = 8
length$ = 16
dummy_encoder PROC					; COMDAT

; 998  :     return MAP_UNMAPPABLE;

  00000	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 999  : }

  00005	c3		 ret	 0
dummy_encoder ENDP
_TEXT	ENDS
PUBLIC	PyInit__codecs_iso2022
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__codecs_iso2022 DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$PyInit__codecs_iso2022
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__codecs_iso2022 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyInit__codecs_iso2022
_TEXT	SEGMENT
PyInit__codecs_iso2022 PROC				; COMDAT

; 1131 : I_AM_A_MODULE_FOR(iso2022)

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__module
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax
  0001a	48 85 c0	 test	 rax, rax
  0001d	74 0b		 je	 SHORT $LN1@PyInit__co
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 register_maps
  00027	48 8b c3	 mov	 rax, rbx
$LN1@PyInit__co:
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
PyInit__codecs_iso2022 ENDP
_TEXT	ENDS
END
