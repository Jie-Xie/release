; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08NIDOPABH@binascii?$AA@			; `string'
PUBLIC	??_C@_06HKDIOBHD@b2a_qp?$AA@			; `string'
PUBLIC	??_C@_06MHAIBDO@a2b_qp?$AA@			; `string'
PUBLIC	??_C@_05KBIBMHFC@crc32?$AA@			; `string'
PUBLIC	??_C@_07MHCKENFH@crc_hqx?$AA@			; `string'
PUBLIC	??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@		; `string'
PUBLIC	??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@		; `string'
PUBLIC	??_C@_09NAOIDGL@unhexlify?$AA@			; `string'
PUBLIC	??_C@_07PGHCAJO@hexlify?$AA@			; `string'
PUBLIC	??_C@_07BBHHOHFK@a2b_hex?$AA@			; `string'
PUBLIC	??_C@_07BJGMJCBH@b2a_hex?$AA@			; `string'
PUBLIC	??_C@_07CEDJJLL@b2a_hqx?$AA@			; `string'
PUBLIC	??_C@_07KFIOMPG@a2b_hqx?$AA@			; `string'
PUBLIC	??_C@_0L@MBBPDBKK@b2a_base64?$AA@		; `string'
PUBLIC	??_C@_0L@GBHAGLGO@a2b_base64?$AA@		; `string'
PUBLIC	??_C@_06EGLNOK@b2a_uu?$AA@			; `string'
PUBLIC	??_C@_06HGAONNKH@a2b_uu?$AA@			; `string'
PUBLIC	??_C@_06OABAJCPM@istext?$AA@			; `string'
PUBLIC	??_C@_09DGJGMEGB@quotetabs?$AA@			; `string'
PUBLIC	??_C@_06MBPAJAPM@header?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
;	COMDAT ??_C@_08NIDOPABH@binascii?$AA@
CONST	SEGMENT
??_C@_08NIDOPABH@binascii?$AA@ DB 'binascii', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKDIOBHD@b2a_qp?$AA@
CONST	SEGMENT
??_C@_06HKDIOBHD@b2a_qp?$AA@ DB 'b2a_qp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHAIBDO@a2b_qp?$AA@
CONST	SEGMENT
??_C@_06MHAIBDO@a2b_qp?$AA@ DB 'a2b_qp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBIBMHFC@crc32?$AA@
CONST	SEGMENT
??_C@_05KBIBMHFC@crc32?$AA@ DB 'crc32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHCKENFH@crc_hqx?$AA@
CONST	SEGMENT
??_C@_07MHCKENFH@crc_hqx?$AA@ DB 'crc_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@
CONST	SEGMENT
??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@ DB 'rledecode_hqx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@
CONST	SEGMENT
??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@ DB 'rlecode_hqx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NAOIDGL@unhexlify?$AA@
CONST	SEGMENT
??_C@_09NAOIDGL@unhexlify?$AA@ DB 'unhexlify', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGHCAJO@hexlify?$AA@
CONST	SEGMENT
??_C@_07PGHCAJO@hexlify?$AA@ DB 'hexlify', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBHHOHFK@a2b_hex?$AA@
CONST	SEGMENT
??_C@_07BBHHOHFK@a2b_hex?$AA@ DB 'a2b_hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJGMJCBH@b2a_hex?$AA@
CONST	SEGMENT
??_C@_07BJGMJCBH@b2a_hex?$AA@ DB 'b2a_hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CEDJJLL@b2a_hqx?$AA@
CONST	SEGMENT
??_C@_07CEDJJLL@b2a_hqx?$AA@ DB 'b2a_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFIOMPG@a2b_hqx?$AA@
CONST	SEGMENT
??_C@_07KFIOMPG@a2b_hqx?$AA@ DB 'a2b_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBBPDBKK@b2a_base64?$AA@
CONST	SEGMENT
??_C@_0L@MBBPDBKK@b2a_base64?$AA@ DB 'b2a_base64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBHAGLGO@a2b_base64?$AA@
CONST	SEGMENT
??_C@_0L@GBHAGLGO@a2b_base64?$AA@ DB 'a2b_base64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGLNOK@b2a_uu?$AA@
CONST	SEGMENT
??_C@_06EGLNOK@b2a_uu?$AA@ DB 'b2a_uu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGAONNKH@a2b_uu?$AA@
CONST	SEGMENT
??_C@_06HGAONNKH@a2b_uu?$AA@ DB 'a2b_uu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OABAJCPM@istext?$AA@
CONST	SEGMENT
??_C@_06OABAJCPM@istext?$AA@ DB 'istext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGJGMEGB@quotetabs?$AA@
CONST	SEGMENT
??_C@_09DGJGMEGB@quotetabs?$AA@ DB 'quotetabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MBPAJAPM@header?$AA@
CONST	SEGMENT
??_C@_06MBPAJAPM@header?$AA@ DB 'header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
table_a2b_hqx DB 07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07eH
	DB	07dH
	DB	07dH
	DB	07eH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	07dH
	DB	07dH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	07dH
	DB	014H
	DB	015H
	DB	07fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	07dH
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	07dH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	07dH
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	07dH
	DB	07dH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
table_b2a_hqx DB '!"#$%&''()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcde'
	DB	'fhijklmpqr', 00H
	ORG $+15
table_a2b_base64 DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03eH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
table_b2a_base64 DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	DB	'0123456789+/', 00H
	ORG $+15
crctab_hqx DW	00H
	DW	01021H
	DW	02042H
	DW	03063H
	DW	04084H
	DW	050a5H
	DW	060c6H
	DW	070e7H
	DW	08108H
	DW	09129H
	DW	0a14aH
	DW	0b16bH
	DW	0c18cH
	DW	0d1adH
	DW	0e1ceH
	DW	0f1efH
	DW	01231H
	DW	0210H
	DW	03273H
	DW	02252H
	DW	052b5H
	DW	04294H
	DW	072f7H
	DW	062d6H
	DW	09339H
	DW	08318H
	DW	0b37bH
	DW	0a35aH
	DW	0d3bdH
	DW	0c39cH
	DW	0f3ffH
	DW	0e3deH
	DW	02462H
	DW	03443H
	DW	0420H
	DW	01401H
	DW	064e6H
	DW	074c7H
	DW	044a4H
	DW	05485H
	DW	0a56aH
	DW	0b54bH
	DW	08528H
	DW	09509H
	DW	0e5eeH
	DW	0f5cfH
	DW	0c5acH
	DW	0d58dH
	DW	03653H
	DW	02672H
	DW	01611H
	DW	0630H
	DW	076d7H
	DW	066f6H
	DW	05695H
	DW	046b4H
	DW	0b75bH
	DW	0a77aH
	DW	09719H
	DW	08738H
	DW	0f7dfH
	DW	0e7feH
	DW	0d79dH
	DW	0c7bcH
	DW	048c4H
	DW	058e5H
	DW	06886H
	DW	078a7H
	DW	0840H
	DW	01861H
	DW	02802H
	DW	03823H
	DW	0c9ccH
	DW	0d9edH
	DW	0e98eH
	DW	0f9afH
	DW	08948H
	DW	09969H
	DW	0a90aH
	DW	0b92bH
	DW	05af5H
	DW	04ad4H
	DW	07ab7H
	DW	06a96H
	DW	01a71H
	DW	0a50H
	DW	03a33H
	DW	02a12H
	DW	0dbfdH
	DW	0cbdcH
	DW	0fbbfH
	DW	0eb9eH
	DW	09b79H
	DW	08b58H
	DW	0bb3bH
	DW	0ab1aH
	DW	06ca6H
	DW	07c87H
	DW	04ce4H
	DW	05cc5H
	DW	02c22H
	DW	03c03H
	DW	0c60H
	DW	01c41H
	DW	0edaeH
	DW	0fd8fH
	DW	0cdecH
	DW	0ddcdH
	DW	0ad2aH
	DW	0bd0bH
	DW	08d68H
	DW	09d49H
	DW	07e97H
	DW	06eb6H
	DW	05ed5H
	DW	04ef4H
	DW	03e13H
	DW	02e32H
	DW	01e51H
	DW	0e70H
	DW	0ff9fH
	DW	0efbeH
	DW	0dfddH
	DW	0cffcH
	DW	0bf1bH
	DW	0af3aH
	DW	09f59H
	DW	08f78H
	DW	09188H
	DW	081a9H
	DW	0b1caH
	DW	0a1ebH
	DW	0d10cH
	DW	0c12dH
	DW	0f14eH
	DW	0e16fH
	DW	01080H
	DW	0a1H
	DW	030c2H
	DW	020e3H
	DW	05004H
	DW	04025H
	DW	07046H
	DW	06067H
	DW	083b9H
	DW	09398H
	DW	0a3fbH
	DW	0b3daH
	DW	0c33dH
	DW	0d31cH
	DW	0e37fH
	DW	0f35eH
	DW	02b1H
	DW	01290H
	DW	022f3H
	DW	032d2H
	DW	04235H
	DW	05214H
	DW	06277H
	DW	07256H
	DW	0b5eaH
	DW	0a5cbH
	DW	095a8H
	DW	08589H
	DW	0f56eH
	DW	0e54fH
	DW	0d52cH
	DW	0c50dH
	DW	034e2H
	DW	024c3H
	DW	014a0H
	DW	0481H
	DW	07466H
	DW	06447H
	DW	05424H
	DW	04405H
	DW	0a7dbH
	DW	0b7faH
	DW	08799H
	DW	097b8H
	DW	0e75fH
	DW	0f77eH
	DW	0c71dH
	DW	0d73cH
	DW	026d3H
	DW	036f2H
	DW	0691H
	DW	016b0H
	DW	06657H
	DW	07676H
	DW	04615H
	DW	05634H
	DW	0d94cH
	DW	0c96dH
	DW	0f90eH
	DW	0e92fH
	DW	099c8H
	DW	089e9H
	DW	0b98aH
	DW	0a9abH
	DW	05844H
	DW	04865H
	DW	07806H
	DW	06827H
	DW	018c0H
	DW	08e1H
	DW	03882H
	DW	028a3H
	DW	0cb7dH
	DW	0db5cH
	DW	0eb3fH
	DW	0fb1eH
	DW	08bf9H
	DW	09bd8H
	DW	0abbbH
	DW	0bb9aH
	DW	04a75H
	DW	05a54H
	DW	06a37H
	DW	07a16H
	DW	0af1H
	DW	01ad0H
	DW	02ab3H
	DW	03a92H
	DW	0fd2eH
	DW	0ed0fH
	DW	0dd6cH
	DW	0cd4dH
	DW	0bdaaH
	DW	0ad8bH
	DW	09de8H
	DW	08dc9H
	DW	07c26H
	DW	06c07H
	DW	05c64H
	DW	04c45H
	DW	03ca2H
	DW	02c83H
	DW	01ce0H
	DW	0cc1H
	DW	0ef1fH
	DW	0ff3eH
	DW	0cf5dH
	DW	0df7cH
	DW	0af9bH
	DW	0bfbaH
	DW	08fd9H
	DW	09ff8H
	DW	06e17H
	DW	07e36H
	DW	04e55H
	DW	05e74H
	DW	02e93H
	DW	03eb2H
	DW	0ed1H
	DW	01ef0H
doc_a2b_uu DB	'(ascii) -> bin. Decode a line of uuencoded data', 00H
doc_b2a_uu DB	'(bin) -> ascii. Uuencode line of data', 00H
	ORG $+2
doc_a2b_base64 DB '(ascii) -> bin. Decode a line of base64 data', 00H
	ORG $+3
doc_b2a_base64 DB '(bin) -> ascii. Base64-code line of data', 00H
	ORG $+7
doc_a2b_hqx DB	'ascii -> bin, done. Decode .hqx coding', 00H
	ORG $+1
doc_rlecode_hqx DB 'Binhex RLE-code binary data', 00H
	ORG $+4
doc_b2a_hqx DB	'Encode .hqx data', 00H
	ORG $+7
doc_rledecode_hqx DB 'Decode hexbin RLE-coded string', 00H
	ORG $+1
doc_crc_hqx DB	'(data, oldcrc) -> newcrc. Compute hqx CRC incrementally', 00H
doc_crc32 DB	'(data, oldcrc = 0) -> newcrc. Compute CRC-32 incremental'
	DB	'ly', 00H
	ORG $+5
crc_32_tab DD	00H
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
doc_hexlify DB	'b2a_hex(data) -> s; Hexadecimal representation of binary'
	DB	' data.', 0aH, 0aH, 'The return value is a bytes object.  This'
	DB	' function is also', 0aH, 'available as "hexlify()".', 00H
	ORG $+11
doc_unhexlify DB 'a2b_hex(hexstr) -> s; Binary data of hexadecimal repres'
	DB	'entation.', 0aH, 0aH, 'hexstr must contain an even number of '
	DB	'hex digits (upper or lower case).', 0aH, 'This function is al'
	DB	'so available as "unhexlify()"', 00H
	ORG $+5
table_hex DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
doc_a2b_qp DB	'Decode a string of qp-encoded data', 00H
	ORG $+5
?kwlist@?1??binascii_a2b_qp@@9@9 DQ FLAT:??_C@_04PJOLNDGD@data?$AA@ ; `binascii_a2b_qp'::`2'::kwlist
	DQ	FLAT:??_C@_06MBPAJAPM@header?$AA@
	DQ	0000000000000000H
doc_b2a_qp DB	'b2a_qp(data, quotetabs=0, istext=1, header=0) -> s; ', 0aH
	DB	' Encode a string using quoted-printable encoding. ', 0aH, 0aH
	DB	'On encoding, when istext is set, newlines are not encoded, an'
	DB	'd white ', 0aH, 'space at end of lines is.  When istext is no'
	DB	't set, \r and \n (CR/LF) are ', 0aH, 'both encoded.  When quo'
	DB	'tetabs is set, space and tabs are encoded.', 00H
	ORG $+5
?kwlist@?1??binascii_b2a_qp@@9@9 DQ FLAT:??_C@_04PJOLNDGD@data?$AA@ ; `binascii_b2a_qp'::`2'::kwlist
	DQ	FLAT:??_C@_09DGJGMEGB@quotetabs?$AA@
	DQ	FLAT:??_C@_06OABAJCPM@istext?$AA@
	DQ	FLAT:??_C@_06MBPAJAPM@header?$AA@
	DQ	0000000000000000H
	ORG $+8
binascii_module_methods DQ FLAT:??_C@_06HGAONNKH@a2b_uu?$AA@
	DQ	FLAT:binascii_a2b_uu
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_uu
	DQ	FLAT:??_C@_06EGLNOK@b2a_uu?$AA@
	DQ	FLAT:binascii_b2a_uu
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_uu
	DQ	FLAT:??_C@_0L@GBHAGLGO@a2b_base64?$AA@
	DQ	FLAT:binascii_a2b_base64
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_base64
	DQ	FLAT:??_C@_0L@MBBPDBKK@b2a_base64?$AA@
	DQ	FLAT:binascii_b2a_base64
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_base64
	DQ	FLAT:??_C@_07KFIOMPG@a2b_hqx?$AA@
	DQ	FLAT:binascii_a2b_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_hqx
	DQ	FLAT:??_C@_07CEDJJLL@b2a_hqx?$AA@
	DQ	FLAT:binascii_b2a_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_hqx
	DQ	FLAT:??_C@_07BJGMJCBH@b2a_hex?$AA@
	DQ	FLAT:binascii_hexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_hexlify
	DQ	FLAT:??_C@_07BBHHOHFK@a2b_hex?$AA@
	DQ	FLAT:binascii_unhexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_unhexlify
	DQ	FLAT:??_C@_07PGHCAJO@hexlify?$AA@
	DQ	FLAT:binascii_hexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_hexlify
	DQ	FLAT:??_C@_09NAOIDGL@unhexlify?$AA@
	DQ	FLAT:binascii_unhexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_unhexlify
	DQ	FLAT:??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@
	DQ	FLAT:binascii_rlecode_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_rlecode_hqx
	DQ	FLAT:??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@
	DQ	FLAT:binascii_rledecode_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_rledecode_hqx
	DQ	FLAT:??_C@_07MHCKENFH@crc_hqx?$AA@
	DQ	FLAT:binascii_crc_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_crc_hqx
	DQ	FLAT:??_C@_05KBIBMHFC@crc32?$AA@
	DQ	FLAT:binascii_crc32
	DD	01H
	ORG $+4
	DQ	FLAT:doc_crc32
	DQ	FLAT:??_C@_06MHAIBDO@a2b_qp?$AA@
	DQ	FLAT:binascii_a2b_qp
	DD	03H
	ORG $+4
	DQ	FLAT:doc_a2b_qp
	DQ	FLAT:??_C@_06HKDIOBHD@b2a_qp?$AA@
	DQ	FLAT:binascii_b2a_qp
	DD	03H
	ORG $+4
	DQ	FLAT:doc_b2a_qp
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
doc_binascii DB	'Conversion between binary data and ASCII', 00H
	ORG $+7
binasciimodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_08NIDOPABH@binascii?$AA@
	DQ	FLAT:doc_binascii
	DQ	ffffffffffffffffH
	DQ	FLAT:binascii_module_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@ ; `string'
PUBLIC	??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@ ; `string'
PUBLIC	??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@ ; `string'
EXTRN	PyBuffer_IsContiguous:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\binascii.c
pdata	SEGMENT
$pdata$ascii_buffer_converter DD imagerel ascii_buffer_converter
	DD	imagerel ascii_buffer_converter+288
	DD	imagerel $unwind$ascii_buffer_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ascii_buffer_converter DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@
CONST	SEGMENT
??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@ DB 'argument sh'
	DB	'ould be a contiguous buffer, not %R', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@
CONST	SEGMENT
??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@ DB 'argument sh'
	DB	'ould be bytes, buffer or ASCII string, not %R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@
CONST	SEGMENT
??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@ DB 'string argum'
	DB	'ent should contain only ASCII characters', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ascii_buffer_converter
_TEXT	SEGMENT
arg$ = 48
buf$ = 56
ascii_buffer_converter PROC				; COMDAT

; 188  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 189  :     if (arg == NULL) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	75 16		 jne	 SHORT $LN6@ascii_buff

; 190  :         PyBuffer_Release(buf);

  00015	48 8b ca	 mov	 rcx, rdx
  00018	e8 00 00 00 00	 call	 PyBuffer_Release

; 191  :         return 1;

  0001d	8d 43 01	 lea	 eax, QWORD PTR [rbx+1]

; 221  : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN6@ascii_buff:

; 192  :     }
; 193  :     if (PyUnicode_Check(arg)) {

  0002b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0002f	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00039	74 6b		 je	 SHORT $LN5@ascii_buff

; 194  :         if (PyUnicode_READY(arg) < 0)

  0003b	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0003f	75 09		 jne	 SHORT $LN4@ascii_buff
  00041	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00046	85 c0		 test	 eax, eax

; 195  :             return 0;

  00048	78 1a		 js	 SHORT $LN15@ascii_buff
$LN4@ascii_buff:

; 196  :         if (!PyUnicode_IS_ASCII(arg)) {

  0004a	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0004d	a8 40		 test	 al, 64			; 00000040H
  0004f	75 20		 jne	 SHORT $LN3@ascii_buff

; 197  :             PyErr_SetString(PyExc_ValueError,
; 198  :                             "string argument should contain only ASCII characters");

  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@
  0005f	e8 00 00 00 00	 call	 PyErr_SetString
$LN15@ascii_buff:

; 199  :             return 0;

  00064	33 c0		 xor	 eax, eax

; 221  : }

  00066	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
$LN3@ascii_buff:

; 200  :         }
; 201  :         assert(PyUnicode_KIND(arg) == PyUnicode_1BYTE_KIND);
; 202  :         buf->buf = (void *) PyUnicode_1BYTE_DATA(arg);

  00071	a8 20		 test	 al, 32			; 00000020H
  00073	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0007a	75 07		 jne	 SHORT $LN14@ascii_buff
  0007c	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN14@ascii_buff:
  00083	48 89 07	 mov	 QWORD PTR [rdi], rax

; 203  :         buf->len = PyUnicode_GET_LENGTH(arg);

  00086	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 204  :         buf->obj = NULL;

  0008a	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
  00092	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 205  :         return 1;

  00096	b8 01 00 00 00	 mov	 eax, 1

; 221  : }

  0009b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
$LN5@ascii_buff:

; 206  :     }
; 207  :     if (PyObject_GetBuffer(arg, buf, PyBUF_SIMPLE) != 0) {

  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000ae	85 c0		 test	 eax, eax
  000b0	74 24		 je	 SHORT $LN2@ascii_buff

; 208  :         PyErr_Format(PyExc_TypeError,
; 209  :                      "argument should be bytes, buffer or ASCII string, "
; 210  :                      "not %R", Py_TYPE(arg));

  000b2	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@
  000c4	e8 00 00 00 00	 call	 PyErr_Format

; 211  :         return 0;

  000c9	33 c0		 xor	 eax, eax

; 221  : }

  000cb	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
$LN2@ascii_buff:

; 212  :     }
; 213  :     if (!PyBuffer_IsContiguous(buf, 'C')) {

  000d6	b2 43		 mov	 dl, 67			; 00000043H
  000d8	48 8b cf	 mov	 rcx, rdi
  000db	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  000e0	85 c0		 test	 eax, eax
  000e2	75 2c		 jne	 SHORT $LN1@ascii_buff

; 214  :         PyErr_Format(PyExc_TypeError,
; 215  :                      "argument should be a contiguous buffer, "
; 216  :                      "not %R", Py_TYPE(arg));

  000e4	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@
  000f6	e8 00 00 00 00	 call	 PyErr_Format

; 217  :         PyBuffer_Release(buf);

  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	e8 00 00 00 00	 call	 PyBuffer_Release

; 218  :         return 0;

  00103	33 c0		 xor	 eax, eax

; 221  : }

  00105	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	5f		 pop	 rdi
  0010f	c3		 ret	 0
$LN1@ascii_buff:

; 219  :     }
; 220  :     return Py_CLEANUP_SUPPORTED;

  00110	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H

; 221  : }

  00115	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
ascii_buffer_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@	; `string'
PUBLIC	??_C@_0N@JBCOMPIB@Illegal?5char?$AA@		; `string'
PUBLIC	??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@		; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
_BSS	SEGMENT
Error	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_uu DD imagerel binascii_a2b_uu
	DD	imagerel binascii_a2b_uu+60
	DD	imagerel $unwind$binascii_a2b_uu
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_a2b_uu DD imagerel binascii_a2b_uu+60
	DD	imagerel binascii_a2b_uu+336
	DD	imagerel $chain$3$binascii_a2b_uu
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$binascii_a2b_uu DD imagerel binascii_a2b_uu+336
	DD	imagerel binascii_a2b_uu+410
	DD	imagerel $chain$5$binascii_a2b_uu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$binascii_a2b_uu DD 080021H
	DD	0ed400H
	DD	0147400H
	DD	0136400H
	DD	0123400H
	DD	imagerel binascii_a2b_uu
	DD	imagerel binascii_a2b_uu+60
	DD	imagerel $unwind$binascii_a2b_uu
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_a2b_uu DD 082a21H
	DD	0ed42aH
	DD	0147420H
	DD	0136415H
	DD	0123408H
	DD	imagerel binascii_a2b_uu
	DD	imagerel binascii_a2b_uu+60
	DD	imagerel $unwind$binascii_a2b_uu
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_uu DD 030801H
	DD	0c004e208H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@
CONST	SEGMENT
??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@ DB 'Trailing garbage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBCOMPIB@Illegal?5char?$AA@
CONST	SEGMENT
??_C@_0N@JBCOMPIB@Illegal?5char?$AA@ DB 'Illegal char', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@
CONST	SEGMENT
??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@ DB 'O&:a2b_uu', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_a2b_uu
_TEXT	SEGMENT
pascii$ = 32
self$ = 144
args$ = 152
binascii_a2b_uu PROC					; COMDAT

; 228  : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 229  :     Py_buffer pascii;
; 230  :     unsigned char *ascii_data, *bin_data;
; 231  :     int leftbits = 0;
; 232  :     unsigned char this_ch;
; 233  :     unsigned int leftchar = 0;
; 234  :     PyObject *rv;
; 235  :     Py_ssize_t ascii_len, bin_len;
; 236  : 
; 237  :     if ( !PyArg_ParseTuple(args, "O&:a2b_uu", ascii_buffer_converter, &pascii) )

  00008	48 8b ca	 mov	 rcx, rdx
  0000b	4c 8d 4c 24 20	 lea	 r9, QWORD PTR pascii$[rsp]
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@
  0001e	45 33 e4	 xor	 r12d, r12d
  00021	41 8b ec	 mov	 ebp, r12d
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 0a		 jne	 SHORT $LN14@binascii_a

; 238  :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 308  : }

  0002f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00033	41 5c		 pop	 r12
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
$LN14@binascii_a:

; 239  :     ascii_data = pascii.buf;
; 240  :     ascii_len = pascii.len;
; 241  : 
; 242  :     assert(ascii_len >= 0);
; 243  : 
; 244  :     /* First byte: binary data length (in bytes) */
; 245  :     bin_len = (*ascii_data++ - ' ') & 077;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR pascii$[rsp]
  0003c	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 246  :     ascii_len--;

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pascii$[rsp+16]
  00049	48 89 b4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rsi
  00051	0f b6 30	 movzx	 esi, BYTE PTR [rax]
  00054	48 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rdi
  0005c	83 ee 20	 sub	 esi, 32			; 00000020H

; 247  : 
; 248  :     /* Allocate the buffer */
; 249  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len)) == NULL ) {

  0005f	33 c9		 xor	 ecx, ecx
  00061	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  00066	83 e6 3f	 and	 esi, 63			; 0000003fH
  00069	48 8d 78 01	 lea	 rdi, QWORD PTR [rax+1]
  0006d	48 ff cb	 dec	 rbx
  00070	8b d6		 mov	 edx, esi
  00072	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00077	4c 8b e8	 mov	 r13, rax
  0007a	48 85 c0	 test	 rax, rax
  0007d	75 11		 jne	 SHORT $LN13@binascii_a

; 250  :         PyBuffer_Release(&pascii);

  0007f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00084	e8 00 00 00 00	 call	 PyBuffer_Release

; 303  :             return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 9b 00 00 00	 jmp	 $LN32@binascii_a
$LN13@binascii_a:

; 251  :         return NULL;
; 252  :     }
; 253  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);

  00090	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]

; 254  : 
; 255  :     for( ; bin_len > 0 ; ascii_len--, ascii_data++ ) {

  00094	48 85 f6	 test	 rsi, rsi
  00097	7e 5d		 jle	 SHORT $LN27@binascii_a
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL12@binascii_a:

; 256  :         /* XXX is it really best to add NULs if there's no more data */
; 257  :         this_ch = (ascii_len > 0) ? *ascii_data : 0;

  000a0	48 85 db	 test	 rbx, rbx
  000a3	0f 8e a7 00 00
	00		 jle	 $LN17@binascii_a
  000a9	0f b6 07	 movzx	 eax, BYTE PTR [rdi]

; 258  :         if ( this_ch == '\n' || this_ch == '\r' || ascii_len <= 0) {

  000ac	3c 0a		 cmp	 al, 10
  000ae	74 08		 je	 SHORT $LN8@binascii_a
  000b0	3c 0d		 cmp	 al, 13
  000b2	0f 85 9a 00 00
	00		 jne	 $LN26@binascii_a
$LN8@binascii_a:

; 259  :             /*
; 260  :             ** Whitespace. Assume some spaces got eaten at
; 261  :             ** end-of-line. (We check this later)
; 262  :             */
; 263  :             this_ch = 0;

  000b8	32 c0		 xor	 al, al
$LN7@binascii_a:

; 277  :         }
; 278  :         /*
; 279  :         ** Shift it in on the low end, and see if there's
; 280  :         ** a byte ready for output.
; 281  :         */
; 282  :         leftchar = (leftchar << 6) | (this_ch);

  000ba	c1 e5 06	 shl	 ebp, 6
  000bd	0f b6 c0	 movzx	 eax, al

; 283  :         leftbits += 6;

  000c0	41 83 c4 06	 add	 r12d, 6
  000c4	0b e8		 or	 ebp, eax

; 284  :         if ( leftbits >= 8 ) {

  000c6	41 83 fc 08	 cmp	 r12d, 8
  000ca	7c 1f		 jl	 SHORT $LN11@binascii_a

; 285  :             leftbits -= 8;

  000cc	41 83 ec 08	 sub	 r12d, 8

; 286  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  000d0	8b c5		 mov	 eax, ebp
  000d2	48 ff c2	 inc	 rdx
  000d5	41 8b cc	 mov	 ecx, r12d
  000d8	d3 e8		 shr	 eax, cl
  000da	88 42 ff	 mov	 BYTE PTR [rdx-1], al

; 287  :             leftchar &= ((1 << leftbits) - 1);

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	d3 e0		 shl	 eax, cl
  000e4	ff c8		 dec	 eax
  000e6	23 e8		 and	 ebp, eax

; 288  :             bin_len--;

  000e8	48 ff ce	 dec	 rsi
$LN11@binascii_a:

; 254  : 
; 255  :     for( ; bin_len > 0 ; ascii_len--, ascii_data++ ) {

  000eb	48 ff cb	 dec	 rbx
  000ee	48 ff c7	 inc	 rdi
  000f1	48 85 f6	 test	 rsi, rsi
  000f4	7f aa		 jg	 SHORT $LL12@binascii_a
$LN27@binascii_a:

; 289  :         }
; 290  :     }
; 291  :     /*
; 292  :     ** Finally, check that if there's anything left on the line
; 293  :     ** that it's whitespace only.
; 294  :     */
; 295  :     while( ascii_len-- > 0 ) {

  000f6	48 85 db	 test	 rbx, rbx
  000f9	7e 23		 jle	 SHORT $LN28@binascii_a
  000fb	0f 1f 44 00 00	 npad	 5
$LL3@binascii_a:

; 296  :         this_ch = *ascii_data++;

  00100	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00103	48 ff cb	 dec	 rbx
  00106	48 ff c7	 inc	 rdi

; 297  :         /* Extra '`' may be written as padding in some cases */
; 298  :         if ( this_ch != ' ' && this_ch != ' '+64 &&
; 299  :              this_ch != '\n' && this_ch != '\r' ) {

  00109	3c 20		 cmp	 al, 32			; 00000020H
  0010b	74 0c		 je	 SHORT $LN1@binascii_a
  0010d	3c 60		 cmp	 al, 96			; 00000060H
  0010f	74 08		 je	 SHORT $LN1@binascii_a
  00111	3c 0a		 cmp	 al, 10
  00113	74 04		 je	 SHORT $LN1@binascii_a
  00115	3c 0d		 cmp	 al, 13
  00117	75 58		 jne	 SHORT $LN22@binascii_a
$LN1@binascii_a:

; 289  :         }
; 290  :     }
; 291  :     /*
; 292  :     ** Finally, check that if there's anything left on the line
; 293  :     ** that it's whitespace only.
; 294  :     */
; 295  :     while( ascii_len-- > 0 ) {

  00119	48 85 db	 test	 rbx, rbx
  0011c	7f e2		 jg	 SHORT $LL3@binascii_a
$LN28@binascii_a:

; 304  :         }
; 305  :     }
; 306  :     PyBuffer_Release(&pascii);

  0011e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00123	e8 00 00 00 00	 call	 PyBuffer_Release

; 307  :     return rv;

  00128	49 8b c5	 mov	 rax, r13
$LN32@binascii_a:
  0012b	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+160]
  00133	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR [rsp+152]
  0013b	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00143	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]

; 308  : }

  00148	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0014c	41 5c		 pop	 r12
  0014e	5d		 pop	 rbp
  0014f	c3		 ret	 0
$LN17@binascii_a:

; 256  :         /* XXX is it really best to add NULs if there's no more data */
; 257  :         this_ch = (ascii_len > 0) ? *ascii_data : 0;

  00150	32 c0		 xor	 al, al
$LN26@binascii_a:

; 258  :         if ( this_ch == '\n' || this_ch == '\r' || ascii_len <= 0) {

  00152	48 85 db	 test	 rbx, rbx
  00155	0f 8e 5d ff ff
	ff		 jle	 $LN8@binascii_a

; 264  :         } else {
; 265  :             /* Check the character for legality
; 266  :             ** The 64 in stead of the expected 63 is because
; 267  :             ** there are a few uuencodes out there that use
; 268  :             ** '`' as zero instead of space.
; 269  :             */
; 270  :             if ( this_ch < ' ' || this_ch > (' ' + 64)) {

  0015b	2c 20		 sub	 al, 32			; 00000020H
  0015d	3c 40		 cmp	 al, 64			; 00000040H
  0015f	77 07		 ja	 SHORT $LN21@binascii_a

; 275  :             }
; 276  :             this_ch = (this_ch - ' ') & 077;

  00161	24 3f		 and	 al, 63			; 0000003fH
  00163	e9 52 ff ff ff	 jmp	 $LN7@binascii_a
$LN21@binascii_a:

; 271  :                 PyErr_SetString(Error, "Illegal char");

  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JBCOMPIB@Illegal?5char?$AA@

; 272  :                 PyBuffer_Release(&pascii);
; 273  :                 Py_DECREF(rv);
; 274  :                 return NULL;

  0016f	eb 07		 jmp	 SHORT $LN33@binascii_a
$LN22@binascii_a:

; 300  :             PyErr_SetString(Error, "Trailing garbage");

  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@
$LN33@binascii_a:
  00178	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  0017f	e8 00 00 00 00	 call	 PyErr_SetString

; 301  :             PyBuffer_Release(&pascii);

  00184	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00189	e8 00 00 00 00	 call	 PyBuffer_Release

; 302  :             Py_DECREF(rv);

  0018e	49 8b cd	 mov	 rcx, r13
  00191	e8 00 00 00 00	 call	 _Py_DecRef

; 303  :             return NULL;

  00196	33 c0		 xor	 eax, eax
  00198	eb 91		 jmp	 SHORT $LN32@binascii_a
binascii_a2b_uu ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@ ; `string'
PUBLIC	??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@		; `string'
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_uu DD imagerel binascii_b2a_uu
	DD	imagerel binascii_b2a_uu+393
	DD	imagerel $unwind$binascii_b2a_uu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_uu DD 084b01H
	DD	011644bH
	DD	010543eH
	DD	013340aH
	DD	07006d20aH
xdata	ENDS
;	COMDAT ??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@
CONST	SEGMENT
??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@ DB 'At most 45 byte'
	DB	's at once', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@
CONST	SEGMENT
??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@ DB 'y*:b2a_uu', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_b2a_uu
_TEXT	SEGMENT
pbin$ = 32
self$ = 128
args$ = 136
rv$ = 144
binascii_b2a_uu PROC					; COMDAT

; 314  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 315  :     Py_buffer pbin;
; 316  :     unsigned char *ascii_data, *bin_data;
; 317  :     int leftbits = 0;
; 318  :     unsigned char this_ch;
; 319  :     unsigned int leftchar = 0;
; 320  :     PyObject *rv;
; 321  :     Py_ssize_t bin_len;
; 322  : 
; 323  :     if ( !PyArg_ParseTuple(args, "y*:b2a_uu", &pbin) )

  0000a	48 8b ca	 mov	 rcx, rdx
  0000d	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbin$[rsp]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@
  00019	33 ff		 xor	 edi, edi
  0001b	33 db		 xor	 ebx, ebx
  0001d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00022	85 c0		 test	 eax, eax
  00024	75 10		 jne	 SHORT $LN12@binascii_b

; 324  :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 369  : }

  00028	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00030	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN12@binascii_b:
  00036	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp

; 325  :     bin_data = pbin.buf;

  0003e	48 8b 6c 24 20	 mov	 rbp, QWORD PTR pbin$[rsp]
  00043	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi

; 326  :     bin_len = pbin.len;

  0004b	48 8b 74 24 30	 mov	 rsi, QWORD PTR pbin$[rsp+16]

; 327  :     if ( bin_len > 45 ) {

  00050	48 83 fe 2d	 cmp	 rsi, 45			; 0000002dH
  00054	7e 24		 jle	 SHORT $LN11@binascii_b

; 328  :         /* The 45 is a limit that appears in all uuencode's */
; 329  :         PyErr_SetString(Error, "At most 45 bytes at once");

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@
  00064	e8 00 00 00 00	 call	 PyErr_SetString
$LN22@binascii_b:

; 330  :         PyBuffer_Release(&pbin);

  00069	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  0006e	e8 00 00 00 00	 call	 PyBuffer_Release

; 331  :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 f1 00 00 00	 jmp	 $LN21@binascii_b
$LN11@binascii_b:

; 332  :     }
; 333  : 
; 334  :     /* We're lazy and allocate to much (fixed up later) */
; 335  :     if ( (rv=PyBytes_FromStringAndSize(NULL, 2 + (bin_len+2)/3*4)) == NULL ) {

  0007a	48 8d 4e 02	 lea	 rcx, QWORD PTR [rsi+2]
  0007e	48 b8 56 55 55
	55 55 55 55 55	 mov	 rax, 6148914691236517206 ; 5555555555555556H
  00088	48 f7 e9	 imul	 rcx
  0008b	33 c9		 xor	 ecx, ecx
  0008d	48 8b c2	 mov	 rax, rdx
  00090	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00094	48 03 d0	 add	 rdx, rax
  00097	48 8d 14 95 02
	00 00 00	 lea	 rdx, QWORD PTR [rdx*4+2]
  0009f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000a4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000ac	48 85 c0	 test	 rax, rax

; 336  :         PyBuffer_Release(&pbin);
; 337  :         return NULL;

  000af	74 b8		 je	 SHORT $LN22@binascii_b

; 338  :     }
; 339  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000b1	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 340  : 
; 341  :     /* Store the length */
; 342  :     *ascii_data++ = ' ' + (bin_len & 077);

  000b5	40 0f b6 c6	 movzx	 eax, sil
  000b9	24 3f		 and	 al, 63			; 0000003fH
  000bb	04 20		 add	 al, 32			; 00000020H
  000bd	49 ff c0	 inc	 r8
  000c0	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
$LL9@binascii_b:

; 343  : 
; 344  :     for( ; bin_len > 0 || leftbits != 0 ; bin_len--, bin_data++ ) {

  000c4	48 85 f6	 test	 rsi, rsi
  000c7	7f 09		 jg	 SHORT $LN19@binascii_b
  000c9	85 ff		 test	 edi, edi
  000cb	74 52		 je	 SHORT $LN7@binascii_b

; 348  :         else                            /* Padding */
; 349  :             leftchar <<= 8;

  000cd	c1 e3 08	 shl	 ebx, 8
  000d0	eb 09		 jmp	 SHORT $LN4@binascii_b
$LN19@binascii_b:

; 345  :         /* Shift the data (or padding) into our buffer */
; 346  :         if ( bin_len > 0 )              /* Data */
; 347  :             leftchar = (leftchar << 8) | *bin_data;

  000d2	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  000d6	c1 e3 08	 shl	 ebx, 8
  000d9	0b d8		 or	 ebx, eax
$LN4@binascii_b:

; 350  :         leftbits += 8;

  000db	83 c7 08	 add	 edi, 8

; 351  : 
; 352  :         /* See if there are 6-bit groups ready */
; 353  :         while ( leftbits >= 6 ) {

  000de	83 ff 06	 cmp	 edi, 6
  000e1	7c 34		 jl	 SHORT $LN8@binascii_b

; 350  :         leftbits += 8;

  000e3	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  000e8	8d 4f fa	 lea	 ecx, DWORD PTR [rdi-6]
  000eb	f7 e7		 mul	 edi
  000ed	c1 ea 02	 shr	 edx, 2

; 351  : 
; 352  :         /* See if there are 6-bit groups ready */
; 353  :         while ( leftbits >= 6 ) {

  000f0	8b c2		 mov	 eax, edx
  000f2	44 8b ca	 mov	 r9d, edx
  000f5	6b c0 fa	 imul	 eax, -6
  000f8	03 f8		 add	 edi, eax
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL3@binascii_b:

; 354  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  00100	8b c3		 mov	 eax, ebx

; 355  :             leftbits -= 6;
; 356  :             *ascii_data++ = this_ch + ' ';

  00102	49 ff c0	 inc	 r8
  00105	d3 e8		 shr	 eax, cl
  00107	83 e9 06	 sub	 ecx, 6
  0010a	24 3f		 and	 al, 63			; 0000003fH
  0010c	04 20		 add	 al, 32			; 00000020H
  0010e	49 ff c9	 dec	 r9
  00111	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  00115	75 e9		 jne	 SHORT $LL3@binascii_b
$LN8@binascii_b:

; 343  : 
; 344  :     for( ; bin_len > 0 || leftbits != 0 ; bin_len--, bin_data++ ) {

  00117	48 ff ce	 dec	 rsi
  0011a	48 ff c5	 inc	 rbp
  0011d	eb a5		 jmp	 SHORT $LL9@binascii_b
$LN7@binascii_b:

; 357  :         }
; 358  :     }
; 359  :     *ascii_data++ = '\n';       /* Append a courtesy newline */

  0011f	41 c6 00 0a	 mov	 BYTE PTR [r8], 10

; 360  : 
; 361  :     if (_PyBytes_Resize(&rv,
; 362  :                        (ascii_data -
; 363  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00123	4c 2b 84 24 90
	00 00 00	 sub	 r8, QWORD PTR rv$[rsp]
  0012b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00133	49 8d 50 89	 lea	 rdx, QWORD PTR [r8-119]
  00137	e8 00 00 00 00	 call	 _PyBytes_Resize
  0013c	85 c0		 test	 eax, eax
  0013e	79 19		 jns	 SHORT $LN1@binascii_b

; 364  :         Py_DECREF(rv);

  00140	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00148	e8 00 00 00 00	 call	 _Py_DecRef

; 365  :         rv = NULL;

  0014d	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b:

; 366  :     }
; 367  :     PyBuffer_Release(&pbin);

  00159	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  0015e	e8 00 00 00 00	 call	 PyBuffer_Release

; 368  :     return rv;

  00163	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN21@binascii_b:

; 369  : }

  0016b	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00173	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  0017b	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00183	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00187	5f		 pop	 rdi
  00188	c3		 ret	 0
binascii_b2a_uu ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT binascii_find_valid
_TEXT	SEGMENT
s$ = 8
slen$ = 16
num$ = 24
binascii_find_valid PROC				; COMDAT

; 375  :     /* Finds & returns the (num+1)th
; 376  :     ** valid character for base64, or -1 if none.
; 377  :     */
; 378  : 
; 379  :     int ret = -1;

  00000	41 83 c9 ff	 or	 r9d, -1

; 380  :     unsigned char c, b64val;
; 381  : 
; 382  :     while ((slen > 0) && (ret == -1)) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	7e 3c		 jle	 SHORT $LN9@binascii_f
  00009	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:table_a2b_base64
$LL4@binascii_f:
  00010	41 83 f9 ff	 cmp	 r9d, -1
  00014	75 2f		 jne	 SHORT $LN9@binascii_f

; 383  :         c = *s;

  00016	44 0f b6 11	 movzx	 r10d, BYTE PTR [rcx]

; 384  :         b64val = table_a2b_base64[c & 0x7f];
; 385  :         if ( ((c <= 0x7f) && (b64val != (unsigned char)-1)) ) {

  0001a	41 80 fa 7f	 cmp	 r10b, 127		; 0000007fH
  0001e	77 1a		 ja	 SHORT $LN2@binascii_f
  00020	41 0f b6 c2	 movzx	 eax, r10b
  00024	83 e0 7f	 and	 eax, 127		; 0000007fH
  00027	42 80 3c 18 ff	 cmp	 BYTE PTR [rax+r11], 255	; 000000ffH
  0002c	74 0c		 je	 SHORT $LN2@binascii_f

; 386  :             if (num == 0)

  0002e	45 85 c0	 test	 r8d, r8d
  00031	75 04		 jne	 SHORT $LN1@binascii_f

; 387  :                 ret = *s;

  00033	45 0f b6 ca	 movzx	 r9d, r10b
$LN1@binascii_f:

; 388  :             num--;

  00037	41 ff c8	 dec	 r8d
$LN2@binascii_f:

; 389  :         }
; 390  : 
; 391  :         s++;
; 392  :         slen--;

  0003a	48 ff ca	 dec	 rdx
  0003d	48 ff c1	 inc	 rcx
  00040	48 85 d2	 test	 rdx, rdx
  00043	7f cb		 jg	 SHORT $LL4@binascii_f
$LN9@binascii_f:

; 393  :     }
; 394  :     return ret;

  00045	41 8b c1	 mov	 eax, r9d

; 395  : }

  00048	c3		 ret	 0
binascii_find_valid ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@	; `string'
PUBLIC	??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@	; `string'
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_base64 DD imagerel binascii_a2b_base64
	DD	imagerel binascii_a2b_base64+182
	DD	imagerel $unwind$binascii_a2b_base64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$binascii_a2b_base64 DD imagerel binascii_a2b_base64+182
	DD	imagerel binascii_a2b_base64+574
	DD	imagerel $chain$4$binascii_a2b_base64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$binascii_a2b_base64 DD imagerel binascii_a2b_base64+574
	DD	imagerel binascii_a2b_base64+602
	DD	imagerel $chain$5$binascii_a2b_base64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$binascii_a2b_base64 DD 021H
	DD	imagerel binascii_a2b_base64
	DD	imagerel binascii_a2b_base64+182
	DD	imagerel $unwind$binascii_a2b_base64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$binascii_a2b_base64 DD 061521H
	DD	0ef415H
	DD	0fe40dH
	DD	017d408H
	DD	imagerel binascii_a2b_base64
	DD	imagerel binascii_a2b_base64+182
	DD	imagerel $unwind$binascii_a2b_base64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_base64 DD 085f01H
	DD	015745fH
	DD	0143448H
	DD	0c005f20cH
	DD	050026003H
xdata	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@
CONST	SEGMENT
??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@ DB 'Incorrect padding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@
CONST	SEGMENT
??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@ DB 'O&:a2b_base64', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_a2b_base64
_TEXT	SEGMENT
pascii$ = 32
self$ = 160
args$ = 168
rv$ = 176
binascii_a2b_base64 PROC				; COMDAT

; 401  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 402  :     Py_buffer pascii;
; 403  :     unsigned char *ascii_data, *bin_data;
; 404  :     int leftbits = 0;
; 405  :     unsigned char this_ch;
; 406  :     unsigned int leftchar = 0;
; 407  :     PyObject *rv;
; 408  :     Py_ssize_t ascii_len, bin_len;
; 409  :     int quad_pos = 0;
; 410  : 
; 411  :     if ( !PyArg_ParseTuple(args, "O&:a2b_base64", ascii_buffer_converter, &pascii) )

  0000c	48 8b ca	 mov	 rcx, rdx
  0000f	4c 8d 4c 24 20	 lea	 r9, QWORD PTR pascii$[rsp]
  00014	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@
  00022	33 ed		 xor	 ebp, ebp
  00024	45 33 e4	 xor	 r12d, r12d
  00027	33 f6		 xor	 esi, esi
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 0e		 jne	 SHORT $LN18@binascii_a@2

; 412  :         return NULL;

  00032	33 c0		 xor	 eax, eax

; 504  : }

  00034	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0003b	41 5c		 pop	 r12
  0003d	5e		 pop	 rsi
  0003e	5d		 pop	 rbp
  0003f	c3		 ret	 0
$LN18@binascii_a@2:
  00040	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx

; 413  :     ascii_data = pascii.buf;
; 414  :     ascii_len = pascii.len;

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pascii$[rsp+16]

; 415  : 
; 416  :     assert(ascii_len >= 0);
; 417  : 
; 418  :     if (ascii_len > PY_SSIZE_T_MAX - 3) {

  0004d	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  00057	48 89 bc 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rdi
  0005f	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pascii$[rsp]
  00064	48 3b d8	 cmp	 rbx, rax
  00067	7e 14		 jle	 SHORT $LN17@binascii_a@2

; 419  :         PyBuffer_Release(&pascii);

  00069	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  0006e	e8 00 00 00 00	 call	 PyBuffer_Release

; 420  :         return PyErr_NoMemory();

  00073	e8 00 00 00 00	 call	 PyErr_NoMemory
  00078	e9 c1 01 00 00	 jmp	 $LN25@binascii_a@2
$LN17@binascii_a@2:

; 421  :     }
; 422  : 
; 423  :     bin_len = ((ascii_len+3)/4)*3; /* Upper bound, corrected later */

  0007d	48 8d 43 03	 lea	 rax, QWORD PTR [rbx+3]

; 424  : 
; 425  :     /* Allocate the buffer */
; 426  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len)) == NULL ) {

  00081	33 c9		 xor	 ecx, ecx
  00083	48 99		 cdq
  00085	83 e2 03	 and	 edx, 3
  00088	48 03 c2	 add	 rax, rdx
  0008b	48 c1 f8 02	 sar	 rax, 2
  0008f	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00093	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00098	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000a0	48 85 c0	 test	 rax, rax
  000a3	75 11		 jne	 SHORT $LN16@binascii_a@2

; 427  :         PyBuffer_Release(&pascii);

  000a5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  000aa	e8 00 00 00 00	 call	 PyBuffer_Release

; 428  :         return NULL;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 88 01 00 00	 jmp	 $LN25@binascii_a@2
$LN16@binascii_a@2:
  000b6	4c 89 ac 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r13
  000be	4c 89 74 24 78	 mov	 QWORD PTR [rsp+120], r14

; 429  :     }
; 430  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);
; 431  :     bin_len = 0;

  000c3	45 33 ed	 xor	 r13d, r13d
  000c6	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  000cb	4c 8d 70 78	 lea	 r14, QWORD PTR [rax+120]

; 432  : 
; 433  :     for( ; ascii_len > 0; ascii_len--, ascii_data++) {

  000cf	48 85 db	 test	 rbx, rbx
  000d2	0f 8e 24 01 00
	00		 jle	 $LN3@binascii_a@2
  000d8	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:table_a2b_base64
  000df	90		 npad	 1
$LL15@binascii_a@2:

; 434  :         this_ch = *ascii_data;

  000e0	0f b6 07	 movzx	 eax, BYTE PTR [rdi]

; 435  : 
; 436  :         if (this_ch > 0x7f ||
; 437  :             this_ch == '\r' || this_ch == '\n' || this_ch == ' ')

  000e3	3c 7f		 cmp	 al, 127			; 0000007fH
  000e5	0f 87 c4 00 00
	00		 ja	 $LN14@binascii_a@2
  000eb	3c 0d		 cmp	 al, 13
  000ed	0f 84 bc 00 00
	00		 je	 $LN14@binascii_a@2
  000f3	3c 0a		 cmp	 al, 10
  000f5	0f 84 b4 00 00
	00		 je	 $LN14@binascii_a@2
  000fb	3c 20		 cmp	 al, 32			; 00000020H
  000fd	0f 84 ac 00 00
	00		 je	 $LN14@binascii_a@2

; 438  :             continue;
; 439  : 
; 440  :         /* Check for pad sequences and ignore
; 441  :         ** the invalid ones.
; 442  :         */
; 443  :         if (this_ch == BASE64_PAD) {

  00103	3c 3d		 cmp	 al, 61			; 0000003dH
  00105	75 64		 jne	 SHORT $LN7@binascii_a@2

; 444  :             if ( (quad_pos < 2) ||
; 445  :                  ((quad_pos == 2) &&
; 446  :                   (binascii_find_valid(ascii_data, ascii_len, 1)
; 447  :                    != BASE64_PAD)) )

  00107	83 fe 02	 cmp	 esi, 2
  0010a	0f 8c 9f 00 00
	00		 jl	 $LN14@binascii_a@2
  00110	75 1a		 jne	 SHORT $LN4@binascii_a@2
  00112	41 b8 01 00 00
	00		 mov	 r8d, 1
  00118	48 8b d3	 mov	 rdx, rbx
  0011b	48 8b cf	 mov	 rcx, rdi
  0011e	e8 00 00 00 00	 call	 binascii_find_valid
  00123	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00126	0f 85 83 00 00
	00		 jne	 $LN14@binascii_a@2
$LN4@binascii_a@2:

; 486  :     }
; 487  : 
; 488  :     /* And set string size correctly. If the result string is empty
; 489  :     ** (because the input was all invalid) return the shared empty
; 490  :     ** string instead; _PyBytes_Resize() won't do this for us.
; 491  :     */
; 492  :     if (bin_len > 0) {

  0012c	4d 85 ed	 test	 r13, r13
  0012f	0f 8e bf 00 00
	00		 jle	 $LN23@binascii_a@2

; 493  :         if (_PyBytes_Resize(&rv, bin_len) < 0) {

  00135	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  0013d	49 8b d5	 mov	 rdx, r13
  00140	e8 00 00 00 00	 call	 _PyBytes_Resize
  00145	85 c0		 test	 eax, eax
  00147	0f 89 cd 00 00
	00		 jns	 $LN1@binascii_a@2

; 494  :             Py_DECREF(rv);

  0014d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00155	e8 00 00 00 00	 call	 _Py_DecRef

; 495  :             rv = NULL;

  0015a	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0

; 496  :         }
; 497  :     }
; 498  :     else {

  00166	e9 af 00 00 00	 jmp	 $LN1@binascii_a@2
$LN7@binascii_a@2:

; 448  :             {
; 449  :                 continue;
; 450  :             }
; 451  :             else {
; 452  :                 /* A pad sequence means no more input.
; 453  :                 ** We've already interpreted the data
; 454  :                 ** from the quad at this point.
; 455  :                 */
; 456  :                 leftbits = 0;
; 457  :                 break;
; 458  :             }
; 459  :         }
; 460  : 
; 461  :         this_ch = table_a2b_base64[*ascii_data];

  0016b	0f b6 c0	 movzx	 eax, al
  0016e	42 0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+r15]

; 462  :         if ( this_ch == (unsigned char) -1 )

  00173	80 f9 ff	 cmp	 cl, 255			; 000000ffH
  00176	74 37		 je	 SHORT $LN14@binascii_a@2

; 463  :             continue;
; 464  : 
; 465  :         /*
; 466  :         ** Shift it in on the low end, and see if there's
; 467  :         ** a byte ready for output.
; 468  :         */
; 469  :         quad_pos = (quad_pos + 1) & 0x03;

  00178	ff c6		 inc	 esi

; 470  :         leftchar = (leftchar << 6) | (this_ch);

  0017a	41 c1 e4 06	 shl	 r12d, 6
  0017e	0f b6 c1	 movzx	 eax, cl

; 471  :         leftbits += 6;

  00181	83 c5 06	 add	 ebp, 6
  00184	83 e6 03	 and	 esi, 3
  00187	44 0b e0	 or	 r12d, eax

; 472  : 
; 473  :         if ( leftbits >= 8 ) {

  0018a	83 fd 08	 cmp	 ebp, 8
  0018d	7c 20		 jl	 SHORT $LN14@binascii_a@2

; 474  :             leftbits -= 8;

  0018f	83 ed 08	 sub	 ebp, 8

; 475  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  00192	41 8b c4	 mov	 eax, r12d
  00195	49 ff c6	 inc	 r14
  00198	8b cd		 mov	 ecx, ebp

; 476  :             bin_len++;

  0019a	49 ff c5	 inc	 r13
  0019d	d3 e8		 shr	 eax, cl
  0019f	41 88 46 ff	 mov	 BYTE PTR [r14-1], al

; 477  :             leftchar &= ((1 << leftbits) - 1);

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	d3 e0		 shl	 eax, cl
  001aa	ff c8		 dec	 eax
  001ac	44 23 e0	 and	 r12d, eax
$LN14@binascii_a@2:

; 432  : 
; 433  :     for( ; ascii_len > 0; ascii_len--, ascii_data++) {

  001af	48 ff cb	 dec	 rbx
  001b2	48 ff c7	 inc	 rdi
  001b5	48 85 db	 test	 rbx, rbx
  001b8	0f 8f 22 ff ff
	ff		 jg	 $LL15@binascii_a@2

; 478  :         }
; 479  :     }
; 480  : 
; 481  :     if (leftbits != 0) {

  001be	85 ed		 test	 ebp, ebp
  001c0	0f 84 66 ff ff
	ff		 je	 $LN4@binascii_a@2

; 482  :         PyBuffer_Release(&pascii);

  001c6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  001cb	e8 00 00 00 00	 call	 PyBuffer_Release

; 483  :         PyErr_SetString(Error, "Incorrect padding");

  001d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@
  001de	e8 00 00 00 00	 call	 PyErr_SetString

; 484  :         Py_DECREF(rv);

  001e3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  001eb	e8 00 00 00 00	 call	 _Py_DecRef

; 485  :         return NULL;

  001f0	33 c0		 xor	 eax, eax
  001f2	eb 38		 jmp	 SHORT $LN28@binascii_a@2
$LN23@binascii_a@2:

; 496  :         }
; 497  :     }
; 498  :     else {

  001f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN3@binascii_a@2:

; 499  :         Py_DECREF(rv);

  001fc	48 8b c8	 mov	 rcx, rax
  001ff	e8 00 00 00 00	 call	 _Py_DecRef

; 500  :         rv = PyBytes_FromStringAndSize("", 0);

  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0020b	33 d2		 xor	 edx, edx
  0020d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00212	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
$LN1@binascii_a@2:

; 501  :     }
; 502  :     PyBuffer_Release(&pascii);

  0021a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  0021f	e8 00 00 00 00	 call	 PyBuffer_Release

; 503  :     return rv;

  00224	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN28@binascii_a@2:
  0022c	4c 8b 74 24 78	 mov	 r14, QWORD PTR [rsp+120]
  00231	4c 8b ac 24 b8
	00 00 00	 mov	 r13, QWORD PTR [rsp+184]
  00239	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]
$LN25@binascii_a@2:
  0023e	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00246	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+168]

; 504  : }

  0024e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00255	41 5c		 pop	 r12
  00257	5e		 pop	 rsi
  00258	5d		 pop	 rbp
  00259	c3		 ret	 0
binascii_a2b_base64 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@ ; `string'
PUBLIC	??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_base64 DD imagerel binascii_b2a_base64
	DD	imagerel binascii_b2a_base64+432
	DD	imagerel $unwind$binascii_b2a_base64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_base64 DD 084b01H
	DD	011744bH
	DD	010543eH
	DD	013340aH
	DD	06006d20aH
xdata	ENDS
;	COMDAT ??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@
CONST	SEGMENT
??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@ DB 'Too much d'
	DB	'ata for base64 line', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@
CONST	SEGMENT
??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@ DB 'y*:b2a_base64', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_b2a_base64
_TEXT	SEGMENT
pbuf$ = 32
self$ = 128
args$ = 136
rv$ = 144
binascii_b2a_base64 PROC				; COMDAT

; 510  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 511  :     Py_buffer pbuf;
; 512  :     unsigned char *ascii_data, *bin_data;
; 513  :     int leftbits = 0;
; 514  :     unsigned char this_ch;
; 515  :     unsigned int leftchar = 0;
; 516  :     PyObject *rv;
; 517  :     Py_ssize_t bin_len;
; 518  : 
; 519  :     if ( !PyArg_ParseTuple(args, "y*:b2a_base64", &pbuf) )

  0000a	48 8b ca	 mov	 rcx, rdx
  0000d	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbuf$[rsp]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@
  00019	33 f6		 xor	 esi, esi
  0001b	33 db		 xor	 ebx, ebx
  0001d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00022	85 c0		 test	 eax, eax
  00024	75 10		 jne	 SHORT $LN12@binascii_b@2

; 520  :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 571  : }

  00028	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00030	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN12@binascii_b@2:
  00036	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp

; 521  :     bin_data = pbuf.buf;

  0003e	48 8b 6c 24 20	 mov	 rbp, QWORD PTR pbuf$[rsp]
  00043	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi

; 522  :     bin_len = pbuf.len;

  0004b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pbuf$[rsp+16]

; 523  : 
; 524  :     assert(bin_len >= 0);
; 525  : 
; 526  :     if ( bin_len > BASE64_MAXBIN ) {

  00050	48 b8 fe ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387902 ; 3ffffffffffffffeH
  0005a	48 3b f8	 cmp	 rdi, rax
  0005d	7e 24		 jle	 SHORT $LN11@binascii_b@2

; 527  :         PyErr_SetString(Error, "Too much data for base64 line");

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@
  0006d	e8 00 00 00 00	 call	 PyErr_SetString
$LN21@binascii_b@2:

; 528  :         PyBuffer_Release(&pbuf);

  00072	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00077	e8 00 00 00 00	 call	 PyBuffer_Release

; 529  :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	e9 0f 01 00 00	 jmp	 $LN20@binascii_b@2
$LN11@binascii_b@2:

; 530  :     }
; 531  : 
; 532  :     /* We're lazy and allocate too much (fixed up later).
; 533  :        "+3" leaves room for up to two pad characters and a trailing
; 534  :        newline.  Note that 'b' gets encoded as 'Yg==\n' (1 in, 5 out). */
; 535  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len*2 + 3)) == NULL ) {

  00083	48 8d 54 3f 03	 lea	 rdx, QWORD PTR [rdi+rdi+3]
  00088	33 c9		 xor	 ecx, ecx
  0008a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0008f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  00097	48 85 c0	 test	 rax, rax

; 536  :         PyBuffer_Release(&pbuf);
; 537  :         return NULL;

  0009a	74 d6		 je	 SHORT $LN21@binascii_b@2

; 538  :     }
; 539  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  0009c	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 540  : 
; 541  :     for( ; bin_len > 0 ; bin_len--, bin_data++ ) {

  000a0	48 85 ff	 test	 rdi, rdi
  000a3	0f 8e 9d 00 00
	00		 jle	 $LN2@binascii_b@2
  000a9	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:table_b2a_base64
$LL9@binascii_b@2:

; 542  :         /* Shift the data into our buffer */
; 543  :         leftchar = (leftchar << 8) | *bin_data;

  000b0	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  000b4	c1 e3 08	 shl	 ebx, 8

; 544  :         leftbits += 8;

  000b7	83 c6 08	 add	 esi, 8
  000ba	0b d8		 or	 ebx, eax

; 545  : 
; 546  :         /* See if there are 6-bit groups ready */
; 547  :         while ( leftbits >= 6 ) {

  000bc	83 fe 06	 cmp	 esi, 6
  000bf	7c 3c		 jl	 SHORT $LN8@binascii_b@2

; 542  :         /* Shift the data into our buffer */
; 543  :         leftchar = (leftchar << 8) | *bin_data;

  000c1	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  000c6	8d 4e fa	 lea	 ecx, DWORD PTR [rsi-6]
  000c9	f7 e6		 mul	 esi
  000cb	c1 ea 02	 shr	 edx, 2

; 545  : 
; 546  :         /* See if there are 6-bit groups ready */
; 547  :         while ( leftbits >= 6 ) {

  000ce	8b c2		 mov	 eax, edx
  000d0	44 8b ca	 mov	 r9d, edx
  000d3	6b c0 fa	 imul	 eax, -6
  000d6	03 f0		 add	 esi, eax
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@binascii_b@2:

; 548  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  000e0	8b c3		 mov	 eax, ebx

; 549  :             leftbits -= 6;
; 550  :             *ascii_data++ = table_b2a_base64[this_ch];

  000e2	49 ff c0	 inc	 r8
  000e5	d3 e8		 shr	 eax, cl
  000e7	83 e9 06	 sub	 ecx, 6
  000ea	24 3f		 and	 al, 63			; 0000003fH
  000ec	49 ff c9	 dec	 r9
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	42 0f b6 04 10	 movzx	 eax, BYTE PTR [rax+r10]
  000f7	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  000fb	75 e3		 jne	 SHORT $LL6@binascii_b@2
$LN8@binascii_b@2:

; 540  : 
; 541  :     for( ; bin_len > 0 ; bin_len--, bin_data++ ) {

  000fd	48 ff cf	 dec	 rdi
  00100	48 ff c5	 inc	 rbp
  00103	48 85 ff	 test	 rdi, rdi
  00106	7f a8		 jg	 SHORT $LL9@binascii_b@2

; 551  :         }
; 552  :     }
; 553  :     if ( leftbits == 2 ) {

  00108	83 fe 02	 cmp	 esi, 2
  0010b	75 1c		 jne	 SHORT $LN4@binascii_b@2

; 554  :         *ascii_data++ = table_b2a_base64[(leftchar&3) << 4];

  0010d	83 e3 03	 and	 ebx, 3
  00110	c1 e3 04	 shl	 ebx, 4

; 555  :         *ascii_data++ = BASE64_PAD;
; 556  :         *ascii_data++ = BASE64_PAD;

  00113	49 83 c0 03	 add	 r8, 3
  00117	42 0f b6 04 13	 movzx	 eax, BYTE PTR [rbx+r10]
  0011c	41 88 40 fd	 mov	 BYTE PTR [r8-3], al
  00120	66 41 c7 40 fe
	3d 3d		 mov	 WORD PTR [r8-2], 15677	; 00003d3dH
  00127	eb 1d		 jmp	 SHORT $LN2@binascii_b@2
$LN4@binascii_b@2:

; 557  :     } else if ( leftbits == 4 ) {

  00129	83 fe 04	 cmp	 esi, 4
  0012c	75 18		 jne	 SHORT $LN2@binascii_b@2

; 558  :         *ascii_data++ = table_b2a_base64[(leftchar&0xf) << 2];

  0012e	83 e3 0f	 and	 ebx, 15
  00131	c1 e3 02	 shl	 ebx, 2

; 559  :         *ascii_data++ = BASE64_PAD;

  00134	49 83 c0 02	 add	 r8, 2
  00138	42 0f b6 04 13	 movzx	 eax, BYTE PTR [rbx+r10]
  0013d	41 88 40 fe	 mov	 BYTE PTR [r8-2], al
  00141	41 c6 40 ff 3d	 mov	 BYTE PTR [r8-1], 61	; 0000003dH
$LN2@binascii_b@2:

; 560  :     }
; 561  :     *ascii_data++ = '\n';       /* Append a courtesy newline */

  00146	41 c6 00 0a	 mov	 BYTE PTR [r8], 10

; 562  : 
; 563  :     if (_PyBytes_Resize(&rv,
; 564  :                        (ascii_data -
; 565  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  0014a	4c 2b 84 24 90
	00 00 00	 sub	 r8, QWORD PTR rv$[rsp]
  00152	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  0015a	49 8d 50 89	 lea	 rdx, QWORD PTR [r8-119]
  0015e	e8 00 00 00 00	 call	 _PyBytes_Resize
  00163	85 c0		 test	 eax, eax
  00165	79 19		 jns	 SHORT $LN1@binascii_b@2

; 566  :         Py_DECREF(rv);

  00167	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  0016f	e8 00 00 00 00	 call	 _Py_DecRef

; 567  :         rv = NULL;

  00174	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b@2:

; 568  :     }
; 569  :     PyBuffer_Release(&pbuf);

  00180	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00185	e8 00 00 00 00	 call	 PyBuffer_Release

; 570  :     return rv;

  0018a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN20@binascii_b@2:

; 571  : }

  00192	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  0019a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  001a2	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  001aa	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
binascii_b2a_base64 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@ ; `string'
PUBLIC	??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
_BSS	SEGMENT
Incomplete DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_hqx DD imagerel binascii_a2b_hqx
	DD	imagerel binascii_a2b_hqx+58
	DD	imagerel $unwind$binascii_a2b_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$binascii_a2b_hqx DD imagerel binascii_a2b_hqx+58
	DD	imagerel binascii_a2b_hqx+423
	DD	imagerel $chain$1$binascii_a2b_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_a2b_hqx DD imagerel binascii_a2b_hqx+423
	DD	imagerel binascii_a2b_hqx+482
	DD	imagerel $chain$3$binascii_a2b_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_a2b_hqx DD 040021H
	DD	0137400H
	DD	0123400H
	DD	imagerel binascii_a2b_hqx
	DD	imagerel binascii_a2b_hqx+58
	DD	imagerel $unwind$binascii_a2b_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$binascii_a2b_hqx DD 041f21H
	DD	013741fH
	DD	0123408H
	DD	imagerel binascii_a2b_hqx
	DD	imagerel binascii_a2b_hqx+58
	DD	imagerel $unwind$binascii_a2b_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_hqx DD 040901H
	DD	0c005d209H
	DD	050026003H
xdata	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@
CONST	SEGMENT
??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@ DB 'String has '
	DB	'incomplete number of bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@
CONST	SEGMENT
??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@ DB 'O&:a2b_hqx', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_a2b_hqx
_TEXT	SEGMENT
pascii$ = 32
self$ = 144
args$ = 152
rv$ = 160
binascii_a2b_hqx PROC					; COMDAT

; 577  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 578  :     Py_buffer pascii;
; 579  :     unsigned char *ascii_data, *bin_data;
; 580  :     int leftbits = 0;
; 581  :     unsigned char this_ch;
; 582  :     unsigned int leftchar = 0;
; 583  :     PyObject *rv;
; 584  :     Py_ssize_t len;
; 585  :     int done = 0;
; 586  : 
; 587  :     if ( !PyArg_ParseTuple(args, "O&:a2b_hqx", ascii_buffer_converter, &pascii) )

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	4c 8d 4c 24 20	 lea	 r9, QWORD PTR pascii$[rsp]
  00011	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@
  0001f	33 f6		 xor	 esi, esi
  00021	33 ed		 xor	 ebp, ebp
  00023	45 33 e4	 xor	 r12d, r12d
  00026	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002b	85 c0		 test	 eax, eax
  0002d	75 0b		 jne	 SHORT $LN13@binascii_a@3

; 588  :         return NULL;

  0002f	33 c0		 xor	 eax, eax

; 657  : }

  00031	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00035	41 5c		 pop	 r12
  00037	5e		 pop	 rsi
  00038	5d		 pop	 rbp
  00039	c3		 ret	 0
$LN13@binascii_a@3:
  0003a	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx

; 589  :     ascii_data = pascii.buf;
; 590  :     len = pascii.len;

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pascii$[rsp+16]

; 591  : 
; 592  :     assert(len >= 0);
; 593  : 
; 594  :     if (len > PY_SSIZE_T_MAX - 2) {

  00047	48 b8 fd ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775805 ; 7ffffffffffffffdH
  00051	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  00059	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pascii$[rsp]
  0005e	48 3b d8	 cmp	 rbx, rax
  00061	7e 14		 jle	 SHORT $LN12@binascii_a@3

; 595  :         PyBuffer_Release(&pascii);

  00063	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00068	e8 00 00 00 00	 call	 PyBuffer_Release

; 596  :         return PyErr_NoMemory();

  0006d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00072	e9 17 01 00 00	 jmp	 $LN23@binascii_a@3
$LN12@binascii_a@3:

; 597  :     }
; 598  : 
; 599  :     /* Allocate a string that is too big (fixed later)
; 600  :        Add two to the initial length to prevent interning which
; 601  :        would preclude subsequent resizing.  */
; 602  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len+2)) == NULL ) {

  00077	48 8d 53 02	 lea	 rdx, QWORD PTR [rbx+2]
  0007b	33 c9		 xor	 ecx, ecx
  0007d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00082	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  0008a	48 85 c0	 test	 rax, rax

; 603  :         PyBuffer_Release(&pascii);
; 604  :         return NULL;

  0008d	0f 84 ef 00 00
	00		 je	 $LN1@binascii_a@3

; 605  :     }
; 606  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);

  00093	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]

; 607  : 
; 608  :     for( ; len > 0 ; len--, ascii_data++ ) {

  00097	48 85 db	 test	 rbx, rbx
  0009a	0f 8e b1 00 00
	00		 jle	 $LN3@binascii_a@3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:table_a2b_hqx
  000a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL10@binascii_a@3:

; 609  :         /* Get the byte and look it up */
; 610  :         this_ch = table_a2b_hqx[*ascii_data];

  000b0	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  000b3	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]

; 611  :         if ( this_ch == SKIP )

  000b8	80 f9 7e	 cmp	 cl, 126			; 0000007eH
  000bb	74 34		 je	 SHORT $LN9@binascii_a@3

; 612  :             continue;
; 613  :         if ( this_ch == FAIL ) {

  000bd	80 f9 7d	 cmp	 cl, 125			; 0000007dH
  000c0	74 5b		 je	 SHORT $LN17@binascii_a@3

; 618  :         }
; 619  :         if ( this_ch == DONE ) {

  000c2	80 f9 7f	 cmp	 cl, 127			; 0000007fH
  000c5	74 4e		 je	 SHORT $LN18@binascii_a@3

; 622  :             break;
; 623  :         }
; 624  : 
; 625  :         /* Shift it into the buffer and see if any bytes are ready */
; 626  :         leftchar = (leftchar << 6) | (this_ch);

  000c7	c1 e5 06	 shl	 ebp, 6
  000ca	0f b6 c1	 movzx	 eax, cl

; 627  :         leftbits += 6;

  000cd	83 c6 06	 add	 esi, 6
  000d0	0b e8		 or	 ebp, eax

; 628  :         if ( leftbits >= 8 ) {

  000d2	83 fe 08	 cmp	 esi, 8
  000d5	7c 1a		 jl	 SHORT $LN9@binascii_a@3

; 629  :             leftbits -= 8;

  000d7	83 ee 08	 sub	 esi, 8

; 630  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  000da	8b c5		 mov	 eax, ebp
  000dc	48 ff c2	 inc	 rdx
  000df	8b ce		 mov	 ecx, esi
  000e1	d3 e8		 shr	 eax, cl
  000e3	88 42 ff	 mov	 BYTE PTR [rdx-1], al

; 631  :             leftchar &= ((1 << leftbits) - 1);

  000e6	b8 01 00 00 00	 mov	 eax, 1
  000eb	d3 e0		 shl	 eax, cl
  000ed	ff c8		 dec	 eax
  000ef	23 e8		 and	 ebp, eax
$LN9@binascii_a@3:

; 607  : 
; 608  :     for( ; len > 0 ; len--, ascii_data++ ) {

  000f1	48 ff cb	 dec	 rbx
  000f4	48 ff c7	 inc	 rdi
  000f7	48 85 db	 test	 rbx, rbx
  000fa	7f b4		 jg	 SHORT $LL10@binascii_a@3
$LN21@binascii_a@3:

; 632  :         }
; 633  :     }
; 634  : 
; 635  :     if ( leftbits && !done ) {

  000fc	85 f6		 test	 esi, esi
  000fe	74 49		 je	 SHORT $LN20@binascii_a@3
  00100	45 85 e4	 test	 r12d, r12d
  00103	75 44		 jne	 SHORT $LN20@binascii_a@3

; 636  :         PyErr_SetString(Incomplete,
; 637  :                         "String has incomplete number of bytes");

  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@

; 638  :         PyBuffer_Release(&pascii);
; 639  :         Py_DECREF(rv);
; 640  :         return NULL;

  00113	eb 16		 jmp	 SHORT $LN25@binascii_a@3
$LN18@binascii_a@3:

; 620  :             /* The terminating colon */
; 621  :             done = 1;

  00115	41 bc 01 00 00
	00		 mov	 r12d, 1
  0011b	eb df		 jmp	 SHORT $LN21@binascii_a@3
$LN17@binascii_a@3:

; 614  :             PyErr_SetString(Error, "Illegal char");

  0011d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JBCOMPIB@Illegal?5char?$AA@
$LN25@binascii_a@3:
  0012b	e8 00 00 00 00	 call	 PyErr_SetString

; 615  :             PyBuffer_Release(&pascii);

  00130	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00135	e8 00 00 00 00	 call	 PyBuffer_Release

; 616  :             Py_DECREF(rv);

  0013a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00142	e8 00 00 00 00	 call	 _Py_DecRef

; 617  :             return NULL;

  00147	eb 43		 jmp	 SHORT $LN24@binascii_a@3
$LN20@binascii_a@3:

; 638  :         PyBuffer_Release(&pascii);
; 639  :         Py_DECREF(rv);
; 640  :         return NULL;

  00149	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN3@binascii_a@3:

; 641  :     }
; 642  :     if (_PyBytes_Resize(&rv,
; 643  :                        (bin_data -
; 644  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00151	48 2b d0	 sub	 rdx, rax
  00154	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  0015c	48 83 ea 78	 sub	 rdx, 120		; 00000078H
  00160	e8 00 00 00 00	 call	 _PyBytes_Resize
  00165	85 c0		 test	 eax, eax
  00167	79 3e		 jns	 SHORT $LN2@binascii_a@3

; 645  :         Py_DECREF(rv);

  00169	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00171	e8 00 00 00 00	 call	 _Py_DecRef

; 646  :         rv = NULL;

  00176	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_a@3:

; 653  :     }
; 654  : 
; 655  :     PyBuffer_Release(&pascii);

  00182	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  00187	e8 00 00 00 00	 call	 PyBuffer_Release
$LN24@binascii_a@3:

; 656  :     return NULL;

  0018c	33 c0		 xor	 eax, eax
$LN23@binascii_a@3:
  0018e	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00196	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]

; 657  : }

  0019e	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001a2	41 5c		 pop	 r12
  001a4	5e		 pop	 rsi
  001a5	5d		 pop	 rbp
  001a6	c3		 ret	 0
$LN2@binascii_a@3:

; 647  :     }
; 648  :     if (rv) {

  001a7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR rv$[rsp]
  001af	48 85 d2	 test	 rdx, rdx
  001b2	74 ce		 je	 SHORT $LN1@binascii_a@3

; 649  :         PyObject *rrv = Py_BuildValue("Oi", rv, done);

  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  001bb	45 8b c4	 mov	 r8d, r12d
  001be	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 650  :         PyBuffer_Release(&pascii);

  001c3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pascii$[rsp]
  001c8	48 8b d8	 mov	 rbx, rax
  001cb	e8 00 00 00 00	 call	 PyBuffer_Release

; 651  :         Py_DECREF(rv);

  001d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  001d8	e8 00 00 00 00	 call	 _Py_DecRef

; 652  :         return rrv;

  001dd	48 8b c3	 mov	 rax, rbx
  001e0	eb ac		 jmp	 SHORT $LN23@binascii_a@3
binascii_a2b_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_rlecode_hqx DD imagerel binascii_rlecode_hqx
	DD	imagerel binascii_rlecode_hqx+35
	DD	imagerel $unwind$binascii_rlecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$binascii_rlecode_hqx DD imagerel binascii_rlecode_hqx+35
	DD	imagerel binascii_rlecode_hqx+106
	DD	imagerel $chain$1$binascii_rlecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_rlecode_hqx DD imagerel binascii_rlecode_hqx+106
	DD	imagerel binascii_rlecode_hqx+161
	DD	imagerel $chain$3$binascii_rlecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$binascii_rlecode_hqx DD imagerel binascii_rlecode_hqx+161
	DD	imagerel binascii_rlecode_hqx+376
	DD	imagerel $chain$5$binascii_rlecode_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$binascii_rlecode_hqx DD 040021H
	DD	0e7400H
	DD	0103400H
	DD	imagerel binascii_rlecode_hqx
	DD	imagerel binascii_rlecode_hqx+35
	DD	imagerel $unwind$binascii_rlecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_rlecode_hqx DD 040021H
	DD	0e7400H
	DD	0103400H
	DD	imagerel binascii_rlecode_hqx
	DD	imagerel binascii_rlecode_hqx+35
	DD	imagerel $unwind$binascii_rlecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$binascii_rlecode_hqx DD 041c21H
	DD	0e741cH
	DD	0103408H
	DD	imagerel binascii_rlecode_hqx
	DD	imagerel binascii_rlecode_hqx+35
	DD	imagerel $unwind$binascii_rlecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_rlecode_hqx DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@
CONST	SEGMENT
??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@ DB 'y*:rlecode_hqx', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_rlecode_hqx
_TEXT	SEGMENT
pbuf$ = 32
self$ = 128
args$ = 136
rv$ = 144
binascii_rlecode_hqx PROC				; COMDAT

; 663  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 664  :     Py_buffer pbuf;
; 665  :     unsigned char *in_data, *out_data;
; 666  :     PyObject *rv;
; 667  :     unsigned char ch;
; 668  :     Py_ssize_t in, inend, len;
; 669  : 
; 670  :     if ( !PyArg_ParseTuple(args, "y*:rlecode_hqx", &pbuf) )

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbuf$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN14@binascii_r

; 671  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 721  : }

  0001e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00022	c3		 ret	 0
$LN14@binascii_r:
  00023	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx

; 672  :     in_data = pbuf.buf;
; 673  :     len = pbuf.len;

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pbuf$[rsp+16]

; 674  : 
; 675  :     assert(len >= 0);
; 676  : 
; 677  :     if (len > PY_SSIZE_T_MAX / 2 - 2) {

  00030	48 b8 fd ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387901 ; 3ffffffffffffffdH
  0003a	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  0003f	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pbuf$[rsp]
  00044	48 3b d8	 cmp	 rbx, rax
  00047	7e 21		 jle	 SHORT $LN13@binascii_r

; 678  :         PyBuffer_Release(&pbuf);

  00049	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  0004e	e8 00 00 00 00	 call	 PyBuffer_Release

; 679  :         return PyErr_NoMemory();

  00053	e8 00 00 00 00	 call	 PyErr_NoMemory
  00058	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00060	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 721  : }

  00065	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00069	c3		 ret	 0
$LN13@binascii_r:

; 680  :     }
; 681  : 
; 682  :     /* Worst case: output is twice as big as input (fixed later) */
; 683  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len*2+2)) == NULL ) {

  0006a	48 8d 54 1b 02	 lea	 rdx, QWORD PTR [rbx+rbx+2]
  0006f	33 c9		 xor	 ecx, ecx
  00071	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00076	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  0007e	48 85 c0	 test	 rax, rax
  00081	75 1e		 jne	 SHORT $LN12@binascii_r

; 684  :         PyBuffer_Release(&pbuf);

  00083	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00088	e8 00 00 00 00	 call	 PyBuffer_Release
  0008d	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00095	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 685  :         return NULL;

  0009a	33 c0		 xor	 eax, eax

; 721  : }

  0009c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a0	c3		 ret	 0
$LN12@binascii_r:

; 686  :     }
; 687  :     out_data = (unsigned char *)PyBytes_AS_STRING(rv);
; 688  : 
; 689  :     for( in=0; in<len; in++) {

  000a1	45 33 c0	 xor	 r8d, r8d
  000a4	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  000a8	48 85 db	 test	 rbx, rbx
  000ab	7e 76		 jle	 SHORT $LN9@binascii_r
  000ad	0f 1f 00	 npad	 3
$LL11@binascii_r:

; 690  :         ch = in_data[in];

  000b0	45 0f b6 0c 38	 movzx	 r9d, BYTE PTR [r8+rdi]

; 691  :         if ( ch == RUNCHAR ) {

  000b5	41 80 f9 90	 cmp	 r9b, 144		; 00000090H
  000b9	75 0b		 jne	 SHORT $LN8@binascii_r

; 692  :             /* RUNCHAR. Escape it. */
; 693  :             *out_data++ = RUNCHAR;

  000bb	66 c7 02 90 00	 mov	 WORD PTR [rdx], 144	; 00000090H

; 694  :             *out_data++ = 0;

  000c0	48 83 c2 02	 add	 rdx, 2

; 695  :         } else {

  000c4	eb 4d		 jmp	 SHORT $LN10@binascii_r
$LN8@binascii_r:

; 696  :             /* Check how many following are the same */
; 697  :             for(inend=in+1;
; 698  :                 inend<len && in_data[inend] == ch &&
; 699  :                     inend < in+255;
; 700  :                 inend++) ;

  000c6	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
  000ca	48 3b cb	 cmp	 rcx, rbx
  000cd	7d 1b		 jge	 SHORT $LN21@binascii_r
  000cf	90		 npad	 1
$LL6@binascii_r:
  000d0	44 38 0c 39	 cmp	 BYTE PTR [rcx+rdi], r9b
  000d4	75 14		 jne	 SHORT $LN21@binascii_r
  000d6	49 8d 80 ff 00
	00 00		 lea	 rax, QWORD PTR [r8+255]
  000dd	48 3b c8	 cmp	 rcx, rax
  000e0	7d 08		 jge	 SHORT $LN21@binascii_r
  000e2	48 ff c1	 inc	 rcx
  000e5	48 3b cb	 cmp	 rcx, rbx
  000e8	7c e6		 jl	 SHORT $LL6@binascii_r
$LN21@binascii_r:

; 701  :             if ( inend - in > 3 ) {

  000ea	48 8b c1	 mov	 rax, rcx

; 702  :                 /* More than 3 in a row. Output RLE. */
; 703  :                 *out_data++ = ch;

  000ed	44 88 0a	 mov	 BYTE PTR [rdx], r9b
  000f0	49 2b c0	 sub	 rax, r8
  000f3	48 83 f8 03	 cmp	 rax, 3
  000f7	7e 17		 jle	 SHORT $LN3@binascii_r

; 704  :                 *out_data++ = RUNCHAR;

  000f9	c6 42 01 90	 mov	 BYTE PTR [rdx+1], 144	; 00000090H

; 705  :                 *out_data++ = (unsigned char) (inend-in);

  000fd	0f b6 c1	 movzx	 eax, cl
  00100	41 2a c0	 sub	 al, r8b
  00103	48 83 c2 03	 add	 rdx, 3

; 706  :                 in = inend-1;

  00107	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  0010b	88 42 ff	 mov	 BYTE PTR [rdx-1], al

; 707  :             } else {

  0010e	eb 03		 jmp	 SHORT $LN10@binascii_r
$LN3@binascii_r:

; 708  :                 /* Less than 3. Output the byte itself */
; 709  :                 *out_data++ = ch;

  00110	48 ff c2	 inc	 rdx
$LN10@binascii_r:

; 686  :     }
; 687  :     out_data = (unsigned char *)PyBytes_AS_STRING(rv);
; 688  : 
; 689  :     for( in=0; in<len; in++) {

  00113	49 ff c0	 inc	 r8
  00116	4c 3b c3	 cmp	 r8, rbx
  00119	7c 95		 jl	 SHORT $LL11@binascii_r
  0011b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN9@binascii_r:

; 710  :             }
; 711  :         }
; 712  :     }
; 713  :     if (_PyBytes_Resize(&rv,
; 714  :                        (out_data -
; 715  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00123	48 2b d0	 sub	 rdx, rax
  00126	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  0012e	48 83 ea 78	 sub	 rdx, 120		; 00000078H
  00132	e8 00 00 00 00	 call	 _PyBytes_Resize
  00137	85 c0		 test	 eax, eax
  00139	79 19		 jns	 SHORT $LN1@binascii_r

; 716  :         Py_DECREF(rv);

  0013b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00143	e8 00 00 00 00	 call	 _Py_DecRef

; 717  :         rv = NULL;

  00148	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_r:

; 718  :     }
; 719  :     PyBuffer_Release(&pbuf);

  00154	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00159	e8 00 00 00 00	 call	 PyBuffer_Release

; 720  :     return rv;

  0015e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00166	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  0016e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 721  : }

  00173	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00177	c3		 ret	 0
binascii_rlecode_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_hqx DD imagerel binascii_b2a_hqx
	DD	imagerel binascii_b2a_hqx+399
	DD	imagerel $unwind$binascii_b2a_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_hqx DD 084b01H
	DD	011744bH
	DD	010543eH
	DD	013340aH
	DD	06006d20aH
xdata	ENDS
;	COMDAT ??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@
CONST	SEGMENT
??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@ DB 'y*:b2a_hqx', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_b2a_hqx
_TEXT	SEGMENT
pbin$ = 32
self$ = 128
args$ = 136
rv$ = 144
binascii_b2a_hqx PROC					; COMDAT

; 727  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 728  :     Py_buffer pbin;
; 729  :     unsigned char *ascii_data, *bin_data;
; 730  :     int leftbits = 0;
; 731  :     unsigned char this_ch;
; 732  :     unsigned int leftchar = 0;
; 733  :     PyObject *rv;
; 734  :     Py_ssize_t len;
; 735  : 
; 736  :     if ( !PyArg_ParseTuple(args, "y*:b2a_hqx", &pbin) )

  0000a	48 8b ca	 mov	 rcx, rdx
  0000d	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbin$[rsp]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@
  00019	33 f6		 xor	 esi, esi
  0001b	33 db		 xor	 ebx, ebx
  0001d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00022	85 c0		 test	 eax, eax
  00024	75 10		 jne	 SHORT $LN10@binascii_b@3

; 737  :         return NULL;

  00026	33 c0		 xor	 eax, eax

; 778  : }

  00028	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00030	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN10@binascii_b@3:
  00036	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp

; 738  :     bin_data = pbin.buf;

  0003e	48 8b 6c 24 20	 mov	 rbp, QWORD PTR pbin$[rsp]
  00043	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi

; 739  :     len = pbin.len;

  0004b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR pbin$[rsp+16]

; 740  : 
; 741  :     assert(len >= 0);
; 742  : 
; 743  :     if (len > PY_SSIZE_T_MAX / 2 - 2) {

  00050	48 b8 fd ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387901 ; 3ffffffffffffffdH
  0005a	48 3b f8	 cmp	 rdi, rax
  0005d	7e 14		 jle	 SHORT $LN9@binascii_b@3

; 744  :         PyBuffer_Release(&pbin);

  0005f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  00064	e8 00 00 00 00	 call	 PyBuffer_Release

; 745  :         return PyErr_NoMemory();

  00069	e8 00 00 00 00	 call	 PyErr_NoMemory
  0006e	e9 fe 00 00 00	 jmp	 $LN19@binascii_b@3
$LN9@binascii_b@3:

; 746  :     }
; 747  : 
; 748  :     /* Allocate a buffer that is at least large enough */
; 749  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len*2+2)) == NULL ) {

  00073	48 8d 54 3f 02	 lea	 rdx, QWORD PTR [rdi+rdi+2]
  00078	33 c9		 xor	 ecx, ecx
  0007a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0007f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  00087	48 85 c0	 test	 rax, rax
  0008a	75 11		 jne	 SHORT $LN8@binascii_b@3

; 750  :         PyBuffer_Release(&pbin);

  0008c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  00091	e8 00 00 00 00	 call	 PyBuffer_Release

; 751  :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	e9 d4 00 00 00	 jmp	 $LN19@binascii_b@3
$LN8@binascii_b@3:

; 752  :     }
; 753  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  0009d	4c 8d 40 78	 lea	 r8, QWORD PTR [rax+120]

; 754  : 
; 755  :     for( ; len > 0 ; len--, bin_data++ ) {

  000a1	48 85 ff	 test	 rdi, rdi
  000a4	0f 8e 84 00 00
	00		 jle	 $LN2@binascii_b@3
  000aa	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:table_b2a_hqx
$LL7@binascii_b@3:

; 756  :         /* Shift into our buffer, and output any 6bits ready */
; 757  :         leftchar = (leftchar << 8) | *bin_data;

  000b1	0f b6 45 00	 movzx	 eax, BYTE PTR [rbp]
  000b5	c1 e3 08	 shl	 ebx, 8

; 758  :         leftbits += 8;

  000b8	83 c6 08	 add	 esi, 8
  000bb	0b d8		 or	 ebx, eax

; 759  :         while ( leftbits >= 6 ) {

  000bd	83 fe 06	 cmp	 esi, 6
  000c0	7c 3b		 jl	 SHORT $LN6@binascii_b@3

; 756  :         /* Shift into our buffer, and output any 6bits ready */
; 757  :         leftchar = (leftchar << 8) | *bin_data;

  000c2	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  000c7	8d 4e fa	 lea	 ecx, DWORD PTR [rsi-6]
  000ca	f7 e6		 mul	 esi
  000cc	c1 ea 02	 shr	 edx, 2

; 759  :         while ( leftbits >= 6 ) {

  000cf	8b c2		 mov	 eax, edx
  000d1	44 8b ca	 mov	 r9d, edx
  000d4	6b c0 fa	 imul	 eax, -6
  000d7	03 f0		 add	 esi, eax
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@binascii_b@3:

; 760  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  000e0	8b c3		 mov	 eax, ebx

; 761  :             leftbits -= 6;
; 762  :             *ascii_data++ = table_b2a_hqx[this_ch];

  000e2	49 ff c0	 inc	 r8
  000e5	d3 e8		 shr	 eax, cl
  000e7	83 e9 06	 sub	 ecx, 6
  000ea	24 3f		 and	 al, 63			; 0000003fH
  000ec	49 ff c9	 dec	 r9
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	42 0f b6 04 10	 movzx	 eax, BYTE PTR [rax+r10]
  000f7	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  000fb	75 e3		 jne	 SHORT $LL4@binascii_b@3
$LN6@binascii_b@3:

; 754  : 
; 755  :     for( ; len > 0 ; len--, bin_data++ ) {

  000fd	48 ff cf	 dec	 rdi
  00100	48 ff c5	 inc	 rbp
  00103	48 85 ff	 test	 rdi, rdi
  00106	7f a9		 jg	 SHORT $LL7@binascii_b@3

; 763  :         }
; 764  :     }
; 765  :     /* Output a possible runt byte */
; 766  :     if ( leftbits ) {

  00108	85 f6		 test	 esi, esi
  0010a	74 1a		 je	 SHORT $LN17@binascii_b@3

; 767  :         leftchar <<= (6-leftbits);

  0010c	8b c3		 mov	 eax, ebx
  0010e	b9 06 00 00 00	 mov	 ecx, 6
  00113	2b ce		 sub	 ecx, esi
  00115	d3 e0		 shl	 eax, cl

; 768  :         *ascii_data++ = table_b2a_hqx[leftchar & 0x3f];

  00117	83 e0 3f	 and	 eax, 63			; 0000003fH
  0011a	49 ff c0	 inc	 r8
  0011d	42 0f b6 04 10	 movzx	 eax, BYTE PTR [rax+r10]
  00122	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
$LN17@binascii_b@3:
  00126	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN2@binascii_b@3:

; 769  :     }
; 770  :     if (_PyBytes_Resize(&rv,
; 771  :                        (ascii_data -
; 772  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  0012e	4c 2b c0	 sub	 r8, rax
  00131	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00139	49 8d 50 88	 lea	 rdx, QWORD PTR [r8-120]
  0013d	e8 00 00 00 00	 call	 _PyBytes_Resize
  00142	85 c0		 test	 eax, eax
  00144	79 19		 jns	 SHORT $LN1@binascii_b@3

; 773  :         Py_DECREF(rv);

  00146	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  0014e	e8 00 00 00 00	 call	 _Py_DecRef

; 774  :         rv = NULL;

  00153	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b@3:

; 775  :     }
; 776  :     PyBuffer_Release(&pbin);

  0015f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  00164	e8 00 00 00 00	 call	 PyBuffer_Release

; 777  :     return rv;

  00169	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN19@binascii_b@3:

; 778  : }

  00171	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00179	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  00181	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR [rsp+152]
  00189	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0018d	5e		 pop	 rsi
  0018e	c3		 ret	 0
binascii_b2a_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@ ; `string'
PUBLIC	??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx
	DD	imagerel binascii_rledecode_hqx+102
	DD	imagerel $unwind$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+102
	DD	imagerel binascii_rledecode_hqx+144
	DD	imagerel $chain$2$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+144
	DD	imagerel binascii_rledecode_hqx+229
	DD	imagerel $chain$3$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+229
	DD	imagerel binascii_rledecode_hqx+493
	DD	imagerel $chain$5$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+493
	DD	imagerel binascii_rledecode_hqx+893
	DD	imagerel $chain$6$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+893
	DD	imagerel binascii_rledecode_hqx+909
	DD	imagerel $chain$7$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+909
	DD	imagerel binascii_rledecode_hqx+917
	DD	imagerel $chain$8$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+917
	DD	imagerel binascii_rledecode_hqx+925
	DD	imagerel $chain$9$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx+925
	DD	imagerel binascii_rledecode_hqx+947
	DD	imagerel $chain$10$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$binascii_rledecode_hqx DD 021H
	DD	imagerel binascii_rledecode_hqx
	DD	imagerel binascii_rledecode_hqx+102
	DD	imagerel $unwind$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$binascii_rledecode_hqx DD 021H
	DD	imagerel binascii_rledecode_hqx+102
	DD	imagerel binascii_rledecode_hqx+144
	DD	imagerel $chain$2$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$binascii_rledecode_hqx DD 021H
	DD	imagerel binascii_rledecode_hqx+144
	DD	imagerel binascii_rledecode_hqx+229
	DD	imagerel $chain$3$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$binascii_rledecode_hqx DD 021H
	DD	imagerel binascii_rledecode_hqx+229
	DD	imagerel binascii_rledecode_hqx+493
	DD	imagerel $chain$5$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$binascii_rledecode_hqx DD 020521H
	DD	0fe405H
	DD	imagerel binascii_rledecode_hqx+229
	DD	imagerel binascii_rledecode_hqx+493
	DD	imagerel $chain$5$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$binascii_rledecode_hqx DD 041021H
	DD	0156410H
	DD	0143408H
	DD	imagerel binascii_rledecode_hqx+144
	DD	imagerel binascii_rledecode_hqx+229
	DD	imagerel $chain$3$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_rledecode_hqx DD 020821H
	DD	0177408H
	DD	imagerel binascii_rledecode_hqx+102
	DD	imagerel binascii_rledecode_hqx+144
	DD	imagerel $chain$2$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$binascii_rledecode_hqx DD 020821H
	DD	011c408H
	DD	imagerel binascii_rledecode_hqx
	DD	imagerel binascii_rledecode_hqx+102
	DD	imagerel $unwind$binascii_rledecode_hqx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_rledecode_hqx DD 074101H
	DD	0ef441H
	DD	010d438H
	DD	012010eH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@
CONST	SEGMENT
??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@ DB 'Orphaned RLE c'
	DB	'ode at start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@
CONST	SEGMENT
??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@ DB 'y*:rledecode_hqx', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_rledecode_hqx
_TEXT	SEGMENT
pin$ = 32
self$ = 160
args$ = 168
rv$ = 176
binascii_rledecode_hqx PROC				; COMDAT

; 784  : {

  00000	40 55		 push	 rbp
  00002	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00007	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 785  :     Py_buffer pin;
; 786  :     unsigned char *in_data, *out_data;
; 787  :     unsigned char in_byte, in_repeat;
; 788  :     PyObject *rv;
; 789  :     Py_ssize_t in_len, out_len, out_len_left;
; 790  : 
; 791  :     if ( !PyArg_ParseTuple(args, "y*:rledecode_hqx", &pin) )

  0000e	48 8b ca	 mov	 rcx, rdx
  00011	4c 8d 45 e7	 lea	 r8, QWORD PTR pin$[rbp-57]
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@
  0001c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00021	85 c0		 test	 eax, eax
  00023	75 0b		 jne	 SHORT $LN63@binascii_r@2

; 792  :         return NULL;

  00025	33 c0		 xor	 eax, eax

; 895  : }

  00027	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
$LN63@binascii_r@2:
  00030	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r13

; 793  :     in_data = pin.buf;
; 794  :     in_len = pin.len;

  00038	4c 8b 6d f7	 mov	 r13, QWORD PTR pin$[rbp-41]
  0003c	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00041	4c 8b 7d e7	 mov	 r15, QWORD PTR pin$[rbp-57]

; 795  : 
; 796  :     assert(in_len >= 0);
; 797  : 
; 798  :     /* Empty string is a special case */
; 799  :     if ( in_len == 0 ) {

  00045	4d 85 ed	 test	 r13, r13
  00048	75 1c		 jne	 SHORT $LN62@binascii_r@2

; 800  :         PyBuffer_Release(&pin);

  0004a	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  0004e	e8 00 00 00 00	 call	 PyBuffer_Release

; 801  :         return PyBytes_FromStringAndSize("", 0);

  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0005a	33 d2		 xor	 edx, edx
  0005c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00061	e9 37 03 00 00	 jmp	 $LN80@binascii_r@2
$LN62@binascii_r@2:
  00066	4c 89 a4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r12

; 802  :     }
; 803  :     else if (in_len > PY_SSIZE_T_MAX / 2) {

  0006e	49 bc ff ff ff
	ff ff ff ff 3f	 mov	 r12, 4611686018427387903 ; 3fffffffffffffffH
  00078	4d 3b ec	 cmp	 r13, r12
  0007b	7e 13		 jle	 SHORT $LN60@binascii_r@2

; 804  :         PyBuffer_Release(&pin);

  0007d	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  00081	e8 00 00 00 00	 call	 PyBuffer_Release

; 805  :         return PyErr_NoMemory();

  00086	e8 00 00 00 00	 call	 PyErr_NoMemory
  0008b	e9 05 03 00 00	 jmp	 $LN81@binascii_r@2
$LN60@binascii_r@2:
  00090	48 89 bc 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rdi

; 806  :     }
; 807  : 
; 808  :     /* Allocate a buffer of reasonable size. Resized when needed */
; 809  :     out_len = in_len*2;

  00098	4b 8d 7c 2d 00	 lea	 rdi, QWORD PTR [r13+r13]

; 810  :     if ( (rv=PyBytes_FromStringAndSize(NULL, out_len)) == NULL ) {

  0009d	33 c9		 xor	 ecx, ecx
  0009f	48 8b d7	 mov	 rdx, rdi
  000a2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000a7	48 89 45 77	 mov	 QWORD PTR rv$[rbp-57], rax
  000ab	48 85 c0	 test	 rax, rax

; 811  :         PyBuffer_Release(&pin);
; 812  :         return NULL;

  000ae	74 25		 je	 SHORT $LN90@binascii_r@2

; 813  :     }
; 814  :     out_len_left = out_len;
; 815  :     out_data = (unsigned char *)PyBytes_AS_STRING(rv);
; 816  : 
; 817  :     /*
; 818  :     ** We need two macros here to get/put bytes and handle
; 819  :     ** end-of-buffer for input and output strings.
; 820  :     */
; 821  : #define INBYTE(b) \
; 822  :     do { \
; 823  :              if ( --in_len < 0 ) { \
; 824  :                        PyErr_SetString(Incomplete, ""); \
; 825  :                        Py_DECREF(rv); \
; 826  :                        PyBuffer_Release(&pin); \
; 827  :                        return NULL; \
; 828  :              } \
; 829  :              b = *in_data++; \
; 830  :     } while(0)
; 831  : 
; 832  : #define OUTBYTE(b) \
; 833  :     do { \
; 834  :              if ( --out_len_left < 0 ) { \
; 835  :                       if ( out_len > PY_SSIZE_T_MAX / 2) return PyErr_NoMemory(); \
; 836  :                       if (_PyBytes_Resize(&rv, 2*out_len) < 0) \
; 837  :                         { Py_DECREF(rv); PyBuffer_Release(&pin); return NULL; } \
; 838  :                       out_data = (unsigned char *)PyBytes_AS_STRING(rv) \
; 839  :                                                              + out_len; \
; 840  :                       out_len_left = out_len-1; \
; 841  :                       out_len = out_len * 2; \
; 842  :              } \
; 843  :              *out_data++ = b; \
; 844  :     } while(0)
; 845  : 
; 846  :         /*
; 847  :         ** Handle first byte separately (since we have to get angry
; 848  :         ** in case of an orphaned RLE code).
; 849  :         */
; 850  :         INBYTE(in_byte);

  000b0	49 ff cd	 dec	 r13
  000b3	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  000b7	79 2c		 jns	 SHORT $LN55@binascii_r@2
  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000c7	e8 00 00 00 00	 call	 PyErr_SetString
  000cc	48 8b 4d 77	 mov	 rcx, QWORD PTR rv$[rbp-57]
  000d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN90@binascii_r@2:
  000d5	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  000d9	e8 00 00 00 00	 call	 PyBuffer_Release
  000de	33 c0		 xor	 eax, eax
  000e0	e9 a8 02 00 00	 jmp	 $LN82@binascii_r@2
$LN55@binascii_r@2:
  000e5	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  000ed	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rsi
  000f5	41 0f b6 37	 movzx	 esi, BYTE PTR [r15]
  000f9	49 ff c7	 inc	 r15

; 851  : 
; 852  :     if (in_byte == RUNCHAR) {

  000fc	40 80 fe 90	 cmp	 sil, 144		; 00000090H
  00100	0f 85 9b 00 00
	00		 jne	 $LN41@binascii_r@2

; 853  :         INBYTE(in_repeat);

  00106	49 ff cd	 dec	 r13
  00109	79 2c		 jns	 SHORT $LN50@binascii_r@2
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00119	e8 00 00 00 00	 call	 PyErr_SetString
$LN88@binascii_r@2:
  0011e	48 8b 4d 77	 mov	 rcx, QWORD PTR rv$[rbp-57]
  00122	e8 00 00 00 00	 call	 _Py_DecRef
  00127	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  0012b	e8 00 00 00 00	 call	 PyBuffer_Release
  00130	33 c0		 xor	 eax, eax
  00132	e9 46 02 00 00	 jmp	 $LN84@binascii_r@2
$LN50@binascii_r@2:
  00137	41 0f b6 07	 movzx	 eax, BYTE PTR [r15]
  0013b	49 ff c7	 inc	 r15

; 854  :         if (in_repeat != 0) {

  0013e	84 c0		 test	 al, al
  00140	74 2c		 je	 SHORT $LN48@binascii_r@2

; 855  :             /* Note Error, not Incomplete (which is at the end
; 856  :             ** of the string only). This is a programmer error.
; 857  :             */
; 858  :             PyErr_SetString(Error, "Orphaned RLE code at start");

  00142	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@
  00150	e8 00 00 00 00	 call	 PyErr_SetString

; 859  :             PyBuffer_Release(&pin);

  00155	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  00159	e8 00 00 00 00	 call	 PyBuffer_Release

; 860  :             Py_DECREF(rv);

  0015e	48 8b 4d 77	 mov	 rcx, QWORD PTR rv$[rbp-57]
  00162	e8 00 00 00 00	 call	 _Py_DecRef

; 861  :             return NULL;

  00167	33 c0		 xor	 eax, eax
  00169	e9 0f 02 00 00	 jmp	 $LN84@binascii_r@2
$LN48@binascii_r@2:

; 862  :         }
; 863  :         OUTBYTE(RUNCHAR);

  0016e	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  00172	48 85 db	 test	 rbx, rbx
  00175	79 25		 jns	 SHORT $LN45@binascii_r@2
  00177	49 3b fc	 cmp	 rdi, r12
  0017a	7f 33		 jg	 SHORT $LN89@binascii_r@2
  0017c	48 8d 34 3f	 lea	 rsi, QWORD PTR [rdi+rdi]
  00180	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  00184	48 8b d6	 mov	 rdx, rsi
  00187	e8 00 00 00 00	 call	 _PyBytes_Resize
  0018c	85 c0		 test	 eax, eax
  0018e	78 8e		 js	 SHORT $LN88@binascii_r@2
  00190	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
  00194	48 8d 54 38 78	 lea	 rdx, QWORD PTR [rax+rdi+120]
  00199	48 8b fe	 mov	 rdi, rsi
$LN45@binascii_r@2:
  0019c	c6 02 90	 mov	 BYTE PTR [rdx], 144	; 00000090H

; 864  :     } else {

  0019f	eb 49		 jmp	 SHORT $LN86@binascii_r@2
$LN41@binascii_r@2:

; 865  :         OUTBYTE(in_byte);

  001a1	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  001a5	48 85 db	 test	 rbx, rbx
  001a8	79 3d		 jns	 SHORT $LN38@binascii_r@2
  001aa	49 3b fc	 cmp	 rdi, r12
  001ad	7e 0a		 jle	 SHORT $LN37@binascii_r@2
$LN89@binascii_r@2:
  001af	e8 00 00 00 00	 call	 PyErr_NoMemory
  001b4	e9 c4 01 00 00	 jmp	 $LN84@binascii_r@2
$LN37@binascii_r@2:
  001b9	4c 8d 24 3f	 lea	 r12, QWORD PTR [rdi+rdi]
  001bd	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  001c1	49 8b d4	 mov	 rdx, r12
  001c4	e8 00 00 00 00	 call	 _PyBytes_Resize
  001c9	85 c0		 test	 eax, eax
  001cb	0f 88 4d ff ff
	ff		 js	 $LN88@binascii_r@2
  001d1	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
  001d5	48 8d 54 38 78	 lea	 rdx, QWORD PTR [rax+rdi+120]
  001da	49 8b fc	 mov	 rdi, r12
  001dd	49 bc ff ff ff
	ff ff ff ff 3f	 mov	 r12, 4611686018427387903 ; 3fffffffffffffffH
$LN38@binascii_r@2:
  001e7	40 88 32	 mov	 BYTE PTR [rdx], sil
$LN86@binascii_r@2:
  001ea	48 ff c2	 inc	 rdx
  001ed	4c 89 74 24 78	 mov	 QWORD PTR [rsp+120], r14

; 866  :     }
; 867  : 
; 868  :     while( in_len > 0 ) {

  001f2	4d 85 ed	 test	 r13, r13
  001f5	0f 8e 4a 01 00
	00		 jle	 $LN34@binascii_r@2
  001fb	0f 1f 44 00 00	 npad	 5
$LL35@binascii_r@2:

; 869  :         INBYTE(in_byte);

  00200	49 ff cd	 dec	 r13
  00203	0f 88 13 01 00
	00		 js	 $LN70@binascii_r@2
  00209	41 0f b6 37	 movzx	 esi, BYTE PTR [r15]
  0020d	49 ff c7	 inc	 r15

; 870  : 
; 871  :         if (in_byte == RUNCHAR) {

  00210	40 80 fe 90	 cmp	 sil, 144		; 00000090H
  00214	0f 85 b3 00 00
	00		 jne	 $LN7@binascii_r@2

; 872  :             INBYTE(in_repeat);

  0021a	49 ff cd	 dec	 r13
  0021d	0f 88 f9 00 00
	00		 js	 $LN70@binascii_r@2
  00223	41 0f b6 37	 movzx	 esi, BYTE PTR [r15]
  00227	49 ff c7	 inc	 r15

; 873  :             if ( in_repeat == 0 ) {

  0022a	40 84 f6	 test	 sil, sil
  0022d	75 3e		 jne	 SHORT $LN24@binascii_r@2

; 874  :                 /* Just an escaped RUNCHAR value */
; 875  :                 OUTBYTE(RUNCHAR);

  0022f	48 ff cb	 dec	 rbx
  00232	79 31		 jns	 SHORT $LN20@binascii_r@2
  00234	49 3b fc	 cmp	 rdi, r12
  00237	0f 8f d8 00 00
	00		 jg	 $LN74@binascii_r@2
  0023d	48 8d 34 3f	 lea	 rsi, QWORD PTR [rdi+rdi]
  00241	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  00245	48 8b d6	 mov	 rdx, rsi
  00248	e8 00 00 00 00	 call	 _PyBytes_Resize
  0024d	85 c0		 test	 eax, eax
  0024f	0f 88 da 00 00
	00		 js	 $LN75@binascii_r@2
  00255	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
  00259	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  0025d	48 8d 54 38 78	 lea	 rdx, QWORD PTR [rax+rdi+120]
  00262	48 8b fe	 mov	 rdi, rsi
$LN20@binascii_r@2:
  00265	c6 02 90	 mov	 BYTE PTR [rdx], 144	; 00000090H

; 876  :             } else {

  00268	e9 91 00 00 00	 jmp	 $LN87@binascii_r@2
$LN24@binascii_r@2:

; 877  :                 /* Pick up value and output a sequence of it */
; 878  :                 in_byte = out_data[-1];
; 879  :                 while ( --in_repeat > 0 )

  0026d	40 fe ce	 dec	 sil
  00270	44 0f b6 72 ff	 movzx	 r14d, BYTE PTR [rdx-1]
  00275	0f 84 86 00 00
	00		 je	 $LN5@binascii_r@2
  0027b	0f 1f 44 00 00	 npad	 5
$LL16@binascii_r@2:

; 880  :                     OUTBYTE(in_byte);

  00280	48 ff cb	 dec	 rbx
  00283	79 31		 jns	 SHORT $LN11@binascii_r@2
  00285	49 3b fc	 cmp	 rdi, r12
  00288	0f 8f 87 00 00
	00		 jg	 $LN74@binascii_r@2
  0028e	4c 8d 24 3f	 lea	 r12, QWORD PTR [rdi+rdi]
  00292	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  00296	49 8b d4	 mov	 rdx, r12
  00299	e8 00 00 00 00	 call	 _PyBytes_Resize
  0029e	85 c0		 test	 eax, eax
  002a0	0f 88 89 00 00
	00		 js	 $LN75@binascii_r@2
  002a6	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
  002aa	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  002ae	48 8d 54 38 78	 lea	 rdx, QWORD PTR [rax+rdi+120]
  002b3	49 8b fc	 mov	 rdi, r12
$LN11@binascii_r@2:
  002b6	44 88 32	 mov	 BYTE PTR [rdx], r14b
  002b9	48 ff c2	 inc	 rdx
  002bc	40 fe ce	 dec	 sil
  002bf	49 bc ff ff ff
	ff ff ff ff 3f	 mov	 r12, 4611686018427387903 ; 3fffffffffffffffH
  002c9	75 b5		 jne	 SHORT $LL16@binascii_r@2

; 881  :             }
; 882  :         } else {

  002cb	eb 34		 jmp	 SHORT $LN5@binascii_r@2
$LN7@binascii_r@2:

; 883  :             /* Normal byte */
; 884  :             OUTBYTE(in_byte);

  002cd	48 ff cb	 dec	 rbx
  002d0	79 29		 jns	 SHORT $LN4@binascii_r@2
  002d2	49 3b fc	 cmp	 rdi, r12
  002d5	7f 3e		 jg	 SHORT $LN74@binascii_r@2
  002d7	4c 8d 24 3f	 lea	 r12, QWORD PTR [rdi+rdi]
  002db	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  002df	49 8b d4	 mov	 rdx, r12
  002e2	e8 00 00 00 00	 call	 _PyBytes_Resize
  002e7	85 c0		 test	 eax, eax
  002e9	78 44		 js	 SHORT $LN75@binascii_r@2
  002eb	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
  002ef	48 8d 5f ff	 lea	 rbx, QWORD PTR [rdi-1]
  002f3	48 8d 54 38 78	 lea	 rdx, QWORD PTR [rax+rdi+120]
  002f8	49 8b fc	 mov	 rdi, r12
$LN4@binascii_r@2:
  002fb	40 88 32	 mov	 BYTE PTR [rdx], sil
$LN87@binascii_r@2:
  002fe	48 ff c2	 inc	 rdx
$LN5@binascii_r@2:

; 866  :     }
; 867  : 
; 868  :     while( in_len > 0 ) {

  00301	4d 85 ed	 test	 r13, r13
  00304	7e 3f		 jle	 SHORT $LN34@binascii_r@2
  00306	49 bc ff ff ff
	ff ff ff ff 3f	 mov	 r12, 4611686018427387903 ; 3fffffffffffffffH
  00310	e9 eb fe ff ff	 jmp	 $LL35@binascii_r@2
$LN74@binascii_r@2:

; 883  :             /* Normal byte */
; 884  :             OUTBYTE(in_byte);

  00315	e8 00 00 00 00	 call	 PyErr_NoMemory
  0031a	eb 5c		 jmp	 SHORT $LN85@binascii_r@2
$LN70@binascii_r@2:

; 869  :         INBYTE(in_byte);

  0031c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0032a	e8 00 00 00 00	 call	 PyErr_SetString
$LN75@binascii_r@2:
  0032f	48 8b 4d 77	 mov	 rcx, QWORD PTR rv$[rbp-57]
  00333	e8 00 00 00 00	 call	 _Py_DecRef
  00338	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  0033c	e8 00 00 00 00	 call	 PyBuffer_Release
  00341	33 c0		 xor	 eax, eax
  00343	eb 33		 jmp	 SHORT $LN85@binascii_r@2
$LN34@binascii_r@2:

; 885  :         }
; 886  :     }
; 887  :     if (_PyBytes_Resize(&rv,
; 888  :                        (out_data -
; 889  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00345	48 2b 55 77	 sub	 rdx, QWORD PTR rv$[rbp-57]
  00349	48 8d 4d 77	 lea	 rcx, QWORD PTR rv$[rbp-57]
  0034d	48 83 ea 78	 sub	 rdx, 120		; 00000078H
  00351	e8 00 00 00 00	 call	 _PyBytes_Resize
  00356	85 c0		 test	 eax, eax
  00358	79 11		 jns	 SHORT $LN1@binascii_r@2

; 890  :         Py_DECREF(rv);

  0035a	48 8b 4d 77	 mov	 rcx, QWORD PTR rv$[rbp-57]
  0035e	e8 00 00 00 00	 call	 _Py_DecRef

; 891  :         rv = NULL;

  00363	48 c7 45 77 00
	00 00 00	 mov	 QWORD PTR rv$[rbp-57], 0
$LN1@binascii_r@2:

; 892  :     }
; 893  :     PyBuffer_Release(&pin);

  0036b	48 8d 4d e7	 lea	 rcx, QWORD PTR pin$[rbp-57]
  0036f	e8 00 00 00 00	 call	 PyBuffer_Release

; 894  :     return rv;

  00374	48 8b 45 77	 mov	 rax, QWORD PTR rv$[rbp-57]
$LN85@binascii_r@2:
  00378	4c 8b 74 24 78	 mov	 r14, QWORD PTR [rsp+120]
$LN84@binascii_r@2:
  0037d	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]
  00385	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
$LN82@binascii_r@2:
  0038d	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+184]
$LN81@binascii_r@2:
  00395	4c 8b a4 24 88
	00 00 00	 mov	 r12, QWORD PTR [rsp+136]
$LN80@binascii_r@2:
  0039d	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR [rsp+128]
  003a5	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 895  : }

  003aa	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  003b1	5d		 pop	 rbp
  003b2	c3		 ret	 0
binascii_rledecode_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_crc_hqx DD imagerel binascii_crc_hqx
	DD	imagerel binascii_crc_hqx+167
	DD	imagerel $unwind$binascii_crc_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_crc_hqx DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@
CONST	SEGMENT
??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@ DB 'y*i:crc_hqx', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_crc_hqx
_TEXT	SEGMENT
pin$ = 32
self$ = 128
args$ = 136
crc$ = 144
binascii_crc_hqx PROC					; COMDAT

; 902  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 903  :     Py_buffer pin;
; 904  :     unsigned char *bin_data;
; 905  :     unsigned int crc;
; 906  :     Py_ssize_t len;
; 907  : 
; 908  :     if ( !PyArg_ParseTuple(args, "y*i:crc_hqx", &pin, &crc) )

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR crc$[rsp]
  0000f	4c 8d 44 24 20	 lea	 r8, QWORD PTR pin$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 07		 jne	 SHORT $LN3@binascii_c

; 909  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 919  : }

  00026	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0002a	c3		 ret	 0
$LN3@binascii_c:

; 910  :     bin_data = pin.buf;
; 911  :     len = pin.len;

  0002b	4c 8b 44 24 30	 mov	 r8, QWORD PTR pin$[rsp+16]
  00030	4c 8b 4c 24 20	 mov	 r9, QWORD PTR pin$[rsp]

; 912  : 
; 913  :     while(len-- > 0) {

  00035	4d 85 c0	 test	 r8, r8
  00038	7e 4b		 jle	 SHORT $LN7@binascii_c
  0003a	44 8b 94 24 90
	00 00 00	 mov	 r10d, DWORD PTR crc$[rsp]
  00042	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:crctab_hqx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@binascii_c:

; 914  :         crc=((crc<<8)&0xff00)^crctab_hqx[((crc>>8)&0xff)^*bin_data++];

  00050	41 8b c2	 mov	 eax, r10d
  00053	49 ff c8	 dec	 r8
  00056	49 ff c1	 inc	 r9
  00059	48 c1 e8 08	 shr	 rax, 8
  0005d	0f b6 c8	 movzx	 ecx, al
  00060	41 0f b6 41 ff	 movzx	 eax, BYTE PTR [r9-1]
  00065	48 33 c8	 xor	 rcx, rax
  00068	41 0f b6 c2	 movzx	 eax, r10b
  0006c	41 0f b7 14 4b	 movzx	 edx, WORD PTR [r11+rcx*2]
  00071	c1 e0 08	 shl	 eax, 8
  00074	33 d0		 xor	 edx, eax
  00076	44 8b d2	 mov	 r10d, edx
  00079	89 94 24 90 00
	00 00		 mov	 DWORD PTR crc$[rsp], edx
  00080	4d 85 c0	 test	 r8, r8
  00083	7f cb		 jg	 SHORT $LL2@binascii_c
$LN7@binascii_c:

; 915  :     }
; 916  : 
; 917  :     PyBuffer_Release(&pin);

  00085	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pin$[rsp]
  0008a	e8 00 00 00 00	 call	 PyBuffer_Release

; 918  :     return Py_BuildValue("i", crc);

  0008f	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR crc$[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  0009d	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 919  : }

  000a2	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a6	c3		 ret	 0
binascii_crc_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@	; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_crc32 DD imagerel binascii_crc32
	DD	imagerel binascii_crc32+164
	DD	imagerel $unwind$binascii_crc32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_crc32 DD 033f01H
	DD	0e343fH
	DD	0e207H
xdata	ENDS
;	COMDAT ??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@
CONST	SEGMENT
??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@ DB 'y*|I:crc32', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_crc32
_TEXT	SEGMENT
pbin$ = 32
self$ = 128
args$ = 136
crc$ = 144
binascii_crc32 PROC					; COMDAT

; 1064 : { /* By Jim Ahlstrom; All rights transferred to CNRI */

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1065 :     Py_buffer pbin;
; 1066 :     unsigned char *bin_data;
; 1067 :     unsigned int crc = 0;       /* initial value of CRC */
; 1068 :     Py_ssize_t len;
; 1069 :     unsigned int result;
; 1070 : 
; 1071 :     if ( !PyArg_ParseTuple(args, "y*|I:crc32", &pbin, &crc) )

  00007	48 8b ca	 mov	 rcx, rdx
  0000a	4c 8d 48 18	 lea	 r9, QWORD PTR [rax+24]
  0000e	4c 8d 40 a8	 lea	 r8, QWORD PTR [rax-88]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@
  00019	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  00020	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00025	85 c0		 test	 eax, eax
  00027	75 07		 jne	 SHORT $LN3@binascii_c@2

; 1072 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 1085 : }

  0002b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0002f	c3		 ret	 0
$LN3@binascii_c@2:

; 1073 :     bin_data = pbin.buf;
; 1074 :     len = pbin.len;

  00030	4c 8b 44 24 30	 mov	 r8, QWORD PTR pbin$[rsp+16]
  00035	4c 8b 4c 24 20	 mov	 r9, QWORD PTR pbin$[rsp]
  0003a	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx

; 1075 : 
; 1076 :     crc = ~ crc;

  0003f	8b 9c 24 90 00
	00 00		 mov	 ebx, DWORD PTR crc$[rsp]
  00046	f7 d3		 not	 ebx
  00048	89 9c 24 90 00
	00 00		 mov	 DWORD PTR crc$[rsp], ebx

; 1077 :     while (len-- > 0) {

  0004f	4d 85 c0	 test	 r8, r8
  00052	7e 33		 jle	 SHORT $LN7@binascii_c@2
  00054	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:crc_32_tab
  0005b	0f 1f 44 00 00	 npad	 5
$LL2@binascii_c@2:

; 1078 :         crc = crc_32_tab[(crc ^ *bin_data++) & 0xff] ^ (crc >> 8);

  00060	41 0f b6 09	 movzx	 ecx, BYTE PTR [r9]
  00064	8b c3		 mov	 eax, ebx
  00066	49 ff c8	 dec	 r8
  00069	48 33 c8	 xor	 rcx, rax
  0006c	c1 e8 08	 shr	 eax, 8
  0006f	49 ff c1	 inc	 r9
  00072	0f b6 d1	 movzx	 edx, cl
  00075	41 8b 1c 92	 mov	 ebx, DWORD PTR [r10+rdx*4]
  00079	33 d8		 xor	 ebx, eax
  0007b	89 9c 24 90 00
	00 00		 mov	 DWORD PTR crc$[rsp], ebx
  00082	4d 85 c0	 test	 r8, r8
  00085	7f d9		 jg	 SHORT $LL2@binascii_c@2
$LN7@binascii_c@2:

; 1079 :         /* Note:  (crc >> 8) MUST zero fill on left */
; 1080 :     }
; 1081 : 
; 1082 :     result = (crc ^ 0xFFFFFFFF);
; 1083 :     PyBuffer_Release(&pbin);

  00087	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbin$[rsp]
  0008c	f7 d3		 not	 ebx
  0008e	e8 00 00 00 00	 call	 PyBuffer_Release

; 1084 :     return PyLong_FromUnsignedLong(result & 0xffffffff);

  00093	8b cb		 mov	 ecx, ebx
  00095	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0009a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 1085 : }

  0009f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a3	c3		 ret	 0
binascii_crc32 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@		; `string'
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_hexlify DD imagerel binascii_hexlify
	DD	imagerel binascii_hexlify+99
	DD	imagerel $unwind$binascii_hexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$binascii_hexlify DD imagerel binascii_hexlify+99
	DD	imagerel binascii_hexlify+220
	DD	imagerel $chain$2$binascii_hexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_hexlify DD imagerel binascii_hexlify+220
	DD	imagerel binascii_hexlify+241
	DD	imagerel $chain$3$binascii_hexlify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_hexlify DD 021H
	DD	imagerel binascii_hexlify
	DD	imagerel binascii_hexlify+99
	DD	imagerel $unwind$binascii_hexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$binascii_hexlify DD 020521H
	DD	0e7405H
	DD	imagerel binascii_hexlify
	DD	imagerel binascii_hexlify+99
	DD	imagerel $unwind$binascii_hexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_hexlify DD 054201H
	DD	0116442H
	DD	010342bH
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@
CONST	SEGMENT
??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@ DB 'y*:b2a_hex', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_hexlify
_TEXT	SEGMENT
parg$ = 32
self$ = 128
args$ = 136
binascii_hexlify PROC					; COMDAT

; 1091 : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1092 :     Py_buffer parg;
; 1093 :     char* argbuf;
; 1094 :     Py_ssize_t arglen;
; 1095 :     PyObject *retval;
; 1096 :     char* retbuf;
; 1097 :     Py_ssize_t i, j;
; 1098 : 
; 1099 :     if (!PyArg_ParseTuple(args, "y*:b2a_hex", &parg))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 20	 lea	 r8, QWORD PTR parg$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN6@binascii_h

; 1100 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 1127 : }

  0001e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00022	c3		 ret	 0
$LN6@binascii_h:
  00023	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx

; 1101 :     argbuf = parg.buf;
; 1102 :     arglen = parg.len;

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR parg$[rsp+16]

; 1103 : 
; 1104 :     assert(arglen >= 0);
; 1105 :     if (arglen > PY_SSIZE_T_MAX / 2) {

  00030	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  0003a	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  00042	48 8b 74 24 20	 mov	 rsi, QWORD PTR parg$[rsp]
  00047	48 3b d8	 cmp	 rbx, rax
  0004a	7e 11		 jle	 SHORT $LN5@binascii_h

; 1106 :         PyBuffer_Release(&parg);

  0004c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  00051	e8 00 00 00 00	 call	 PyBuffer_Release

; 1107 :         return PyErr_NoMemory();

  00056	e8 00 00 00 00	 call	 PyErr_NoMemory
  0005b	eb 7f		 jmp	 SHORT $LN12@binascii_h
$LN5@binascii_h:

; 1108 :     }
; 1109 : 
; 1110 :     retval = PyBytes_FromStringAndSize(NULL, arglen*2);

  0005d	48 8d 14 1b	 lea	 rdx, QWORD PTR [rbx+rbx]
  00061	33 c9		 xor	 ecx, ecx
  00063	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00068	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0006d	48 8b f8	 mov	 rdi, rax

; 1111 :     if (!retval) {

  00070	48 85 c0	 test	 rax, rax
  00073	75 0e		 jne	 SHORT $LN4@binascii_h

; 1112 :         PyBuffer_Release(&parg);

  00075	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  0007a	e8 00 00 00 00	 call	 PyBuffer_Release

; 1113 :         return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 54		 jmp	 SHORT $LN13@binascii_h
$LN4@binascii_h:

; 1114 :     }
; 1115 :     retbuf = PyBytes_AS_STRING(retval);

  00083	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]

; 1116 : 
; 1117 :     /* make hex version of string, taken from shamodule.c */
; 1118 :     for (i=j=0; i < arglen; i++) {

  00087	48 85 db	 test	 rbx, rbx
  0008a	7e 3e		 jle	 SHORT $LN1@binascii_h
  0008c	0f 1f 40 00	 npad	 4
$LL3@binascii_h:

; 1119 :         unsigned char c;
; 1120 :         c = (argbuf[i] >> 4) & 0xf;

  00090	0f b6 06	 movzx	 eax, BYTE PTR [rsi]

; 1121 :         retbuf[j++] = Py_hexdigits[c];
; 1122 :         c = argbuf[i] & 0xf;
; 1123 :         retbuf[j++] = Py_hexdigits[c];

  00093	48 83 c2 02	 add	 rdx, 2
  00097	48 ff c6	 inc	 rsi
  0009a	c0 f8 04	 sar	 al, 4
  0009d	24 0f		 and	 al, 15
  0009f	0f b6 c8	 movzx	 ecx, al
  000a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000a9	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000ad	88 4a fe	 mov	 BYTE PTR [rdx-2], cl
  000b0	0f b6 4e ff	 movzx	 ecx, BYTE PTR [rsi-1]
  000b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  000bb	83 e1 0f	 and	 ecx, 15
  000be	48 ff cb	 dec	 rbx
  000c1	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  000c5	88 4a ff	 mov	 BYTE PTR [rdx-1], cl
  000c8	75 c6		 jne	 SHORT $LL3@binascii_h
$LN1@binascii_h:

; 1124 :     }
; 1125 :     PyBuffer_Release(&parg);

  000ca	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  000cf	e8 00 00 00 00	 call	 PyBuffer_Release

; 1126 :     return retval;

  000d4	48 8b c7	 mov	 rax, rdi
$LN13@binascii_h:
  000d7	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
$LN12@binascii_h:
  000dc	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  000e4	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]

; 1127 : }

  000ec	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000f0	c3		 ret	 0
binascii_hexlify ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
EXTRN	_Py_ctype_table:BYTE
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
;	COMDAT to_int
_TEXT	SEGMENT
c$ = 8
to_int	PROC						; COMDAT

; 1139 :     if (Py_ISDIGIT(c))

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00007	0f b6 d1	 movzx	 edx, cl
  0000a	41 8b 84 90 00
	00 00 00	 mov	 eax, DWORD PTR _Py_ctype_table[r8+rdx*4]
  00012	a8 04		 test	 al, 4
  00014	74 04		 je	 SHORT $LN4@to_int

; 1140 :         return c - '0';

  00016	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]

; 1148 : }

  00019	c3		 ret	 0
$LN4@to_int:

; 1141 :     else {
; 1142 :         if (Py_ISUPPER(c))

  0001a	a8 02		 test	 al, 2
  0001c	74 09		 je	 SHORT $LN2@to_int

; 1143 :             c = Py_TOLOWER(c);

  0001e	42 0f b6 8c 02
	00 00 00 00	 movzx	 ecx, BYTE PTR _Py_ctype_tolower[rdx+r8]
$LN2@to_int:

; 1144 :         if (c >= 'a' && c <= 'f')

  00027	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0002a	83 f8 05	 cmp	 eax, 5
  0002d	77 04		 ja	 SHORT $LN1@to_int

; 1145 :             return c - 'a' + 10;

  0002f	8d 41 a9	 lea	 eax, DWORD PTR [rcx-87]

; 1148 : }

  00032	c3		 ret	 0
$LN1@to_int:

; 1146 :     }
; 1147 :     return -1;

  00033	83 c8 ff	 or	 eax, -1

; 1148 : }

  00036	c3		 ret	 0
to_int	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@ ; `string'
PUBLIC	??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@	; `string'
PUBLIC	??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_unhexlify DD imagerel binascii_unhexlify
	DD	imagerel binascii_unhexlify+42
	DD	imagerel $unwind$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$binascii_unhexlify DD imagerel binascii_unhexlify+42
	DD	imagerel binascii_unhexlify+125
	DD	imagerel $chain$1$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$binascii_unhexlify DD imagerel binascii_unhexlify+125
	DD	imagerel binascii_unhexlify+168
	DD	imagerel $chain$2$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$binascii_unhexlify DD imagerel binascii_unhexlify+168
	DD	imagerel binascii_unhexlify+277
	DD	imagerel $chain$3$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$binascii_unhexlify DD imagerel binascii_unhexlify+277
	DD	imagerel binascii_unhexlify+282
	DD	imagerel $chain$4$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$binascii_unhexlify DD imagerel binascii_unhexlify+282
	DD	imagerel binascii_unhexlify+303
	DD	imagerel $chain$5$binascii_unhexlify
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$binascii_unhexlify DD imagerel binascii_unhexlify+303
	DD	imagerel binascii_unhexlify+344
	DD	imagerel $chain$7$binascii_unhexlify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$binascii_unhexlify DD 080021H
	DD	0e7400H
	DD	0126400H
	DD	0115400H
	DD	0103400H
	DD	imagerel binascii_unhexlify
	DD	imagerel binascii_unhexlify+42
	DD	imagerel $unwind$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$binascii_unhexlify DD 021H
	DD	imagerel binascii_unhexlify+42
	DD	imagerel binascii_unhexlify+125
	DD	imagerel $chain$1$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$binascii_unhexlify DD 021H
	DD	imagerel binascii_unhexlify+125
	DD	imagerel binascii_unhexlify+168
	DD	imagerel $chain$2$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$binascii_unhexlify DD 020821H
	DD	0115408H
	DD	imagerel binascii_unhexlify+125
	DD	imagerel binascii_unhexlify+168
	DD	imagerel $chain$2$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$binascii_unhexlify DD 020521H
	DD	0e7405H
	DD	imagerel binascii_unhexlify+42
	DD	imagerel binascii_unhexlify+125
	DD	imagerel $chain$1$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$binascii_unhexlify DD 041521H
	DD	0126415H
	DD	0103408H
	DD	imagerel binascii_unhexlify
	DD	imagerel binascii_unhexlify+42
	DD	imagerel $unwind$binascii_unhexlify
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_unhexlify DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@
CONST	SEGMENT
??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@ DB 'Non-hexadecima'
	DB	'l digit found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@
CONST	SEGMENT
??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@ DB 'Odd-length string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@
CONST	SEGMENT
??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@ DB 'O&:a2b_hex', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_unhexlify
_TEXT	SEGMENT
parg$ = 32
self$ = 128
args$ = 136
binascii_unhexlify PROC					; COMDAT

; 1153 : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1154 :     Py_buffer parg;
; 1155 :     char* argbuf;
; 1156 :     Py_ssize_t arglen;
; 1157 :     PyObject *retval;
; 1158 :     char* retbuf;
; 1159 :     Py_ssize_t i, j;
; 1160 : 
; 1161 :     if (!PyArg_ParseTuple(args, "O&:a2b_hex", ascii_buffer_converter, &parg))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 20	 lea	 r9, QWORD PTR parg$[rsp]
  0000c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@
  0001a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001f	85 c0		 test	 eax, eax
  00021	75 07		 jne	 SHORT $LN8@binascii_u

; 1162 :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 1202 : }

  00025	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00029	c3		 ret	 0
$LN8@binascii_u:
  0002a	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx

; 1163 :     argbuf = parg.buf;
; 1164 :     arglen = parg.len;

  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR parg$[rsp+16]
  00037	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi
  0003f	48 8b 74 24 20	 mov	 rsi, QWORD PTR parg$[rsp]

; 1165 : 
; 1166 :     assert(arglen >= 0);
; 1167 : 
; 1168 :     /* XXX What should we do about strings with an odd length?  Should
; 1169 :      * we add an implicit leading zero, or a trailing zero?  For now,
; 1170 :      * raise an exception.
; 1171 :      */
; 1172 :     if (arglen % 2) {

  00044	48 8b c3	 mov	 rax, rbx
  00047	48 99		 cdq
  00049	83 e0 01	 and	 eax, 1
  0004c	48 33 c2	 xor	 rax, rdx
  0004f	48 3b c2	 cmp	 rax, rdx
  00052	74 24		 je	 SHORT $LN7@binascii_u

; 1173 :         PyBuffer_Release(&parg);

  00054	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  00059	e8 00 00 00 00	 call	 PyBuffer_Release

; 1174 :         PyErr_SetString(Error, "Odd-length string");

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString

; 1175 :         return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	e9 a2 00 00 00	 jmp	 $LN15@binascii_u
$LN7@binascii_u:

; 1176 :     }
; 1177 : 
; 1178 :     retval = PyBytes_FromStringAndSize(NULL, (arglen/2));

  00078	48 8b c3	 mov	 rax, rbx
  0007b	33 c9		 xor	 ecx, ecx
  0007d	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00082	48 99		 cdq
  00084	48 2b c2	 sub	 rax, rdx
  00087	48 d1 f8	 sar	 rax, 1
  0008a	48 8b d0	 mov	 rdx, rax
  0008d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00092	48 8b f8	 mov	 rdi, rax

; 1179 :     if (!retval) {

  00095	48 85 c0	 test	 rax, rax
  00098	75 0e		 jne	 SHORT $LN6@binascii_u

; 1180 :         PyBuffer_Release(&parg);

  0009a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  0009f	e8 00 00 00 00	 call	 PyBuffer_Release

; 1181 :         return NULL;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 6d		 jmp	 SHORT $LN16@binascii_u
$LN6@binascii_u:
  000a8	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp

; 1182 :     }
; 1183 :     retbuf = PyBytes_AS_STRING(retval);

  000b0	4c 8d 58 78	 lea	 r11, QWORD PTR [rax+120]

; 1184 : 
; 1185 :     for (i=j=0; i < arglen; i += 2) {

  000b4	48 85 db	 test	 rbx, rbx
  000b7	7e 47		 jle	 SHORT $LN3@binascii_u

; 1182 :     }
; 1183 :     retbuf = PyBytes_AS_STRING(retval);

  000b9	48 83 cd ff	 or	 rbp, -1
  000bd	4c 8d 56 01	 lea	 r10, QWORD PTR [rsi+1]
  000c1	48 2b ee	 sub	 rbp, rsi
$LL5@binascii_u:

; 1186 :         int top = to_int(Py_CHARMASK(argbuf[i]));

  000c4	41 0f b6 4a ff	 movzx	 ecx, BYTE PTR [r10-1]
  000c9	e8 00 00 00 00	 call	 to_int

; 1187 :         int bot = to_int(Py_CHARMASK(argbuf[i+1]));

  000ce	41 0f b6 0a	 movzx	 ecx, BYTE PTR [r10]
  000d2	44 8b c8	 mov	 r9d, eax
  000d5	e8 00 00 00 00	 call	 to_int

; 1188 :         if (top == -1 || bot == -1) {

  000da	41 83 f9 ff	 cmp	 r9d, -1
  000de	74 4f		 je	 SHORT $LN12@binascii_u
  000e0	83 f8 ff	 cmp	 eax, -1
  000e3	74 4a		 je	 SHORT $LN12@binascii_u

; 1191 :             goto finally;
; 1192 :         }
; 1193 :         retbuf[j++] = (top << 4) + bot;

  000e5	41 c0 e1 04	 shl	 r9b, 4
  000e9	49 83 c2 02	 add	 r10, 2
  000ed	49 ff c3	 inc	 r11
  000f0	44 02 c8	 add	 r9b, al
  000f3	49 8d 04 2a	 lea	 rax, QWORD PTR [r10+rbp]
  000f7	45 88 4b ff	 mov	 BYTE PTR [r11-1], r9b
  000fb	48 3b c3	 cmp	 rax, rbx
  000fe	7c c4		 jl	 SHORT $LL5@binascii_u
$LN3@binascii_u:

; 1194 :     }
; 1195 :     PyBuffer_Release(&parg);

  00100	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
  00105	e8 00 00 00 00	 call	 PyBuffer_Release

; 1196 :     return retval;

  0010a	48 8b c7	 mov	 rax, rdi
$LN17@binascii_u:
  0010d	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
$LN16@binascii_u:
  00115	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
$LN15@binascii_u:
  0011a	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00122	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]

; 1202 : }

  0012a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0012e	c3		 ret	 0
$LN12@binascii_u:

; 1189 :             PyErr_SetString(Error,
; 1190 :                             "Non-hexadecimal digit found");

  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@
  0013d	e8 00 00 00 00	 call	 PyErr_SetString

; 1197 : 
; 1198 :   finally:
; 1199 :     PyBuffer_Release(&parg);

  00142	48 8d 4c 24 20	 lea	 rcx, QWORD PTR parg$[rsp]
$finally$20844:
  00147	e8 00 00 00 00	 call	 PyBuffer_Release

; 1200 :     Py_DECREF(retval);

  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 1201 :     return NULL;

  00154	33 c0		 xor	 eax, eax
  00156	eb b5		 jmp	 SHORT $LN17@binascii_u
binascii_unhexlify ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@	; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_qp DD imagerel binascii_a2b_qp
	DD	imagerel binascii_a2b_qp+512
	DD	imagerel $unwind$binascii_a2b_qp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_qp DD 097701H
	DD	0167477H
	DD	015646aH
	DD	0145462H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@
CONST	SEGMENT
??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@ DB 'O&|i:a2b_qp', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_a2b_qp
_TEXT	SEGMENT
pdata$ = 64
self$ = 160
args$ = 168
kwargs$ = 176
header$ = 184
binascii_a2b_qp PROC					; COMDAT

; 1229 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 1230 :     Py_ssize_t in, out;
; 1231 :     char ch;
; 1232 :     Py_buffer pdata;
; 1233 :     unsigned char *data, *odata;
; 1234 :     Py_ssize_t datalen = 0;
; 1235 :     PyObject *rv;
; 1236 :     static char *kwlist[] = {"data", "header", NULL};
; 1237 :     int header = 0;
; 1238 : 
; 1239 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|i:a2b_qp", kwlist,
; 1240 :                                      ascii_buffer_converter, &pdata, &header))

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	4c 8b d2	 mov	 r10, rdx
  00015	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00019	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??binascii_a2b_qp@@9@9
  00024	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ascii_buffer_converter
  0002f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@
  00036	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  0003a	33 db		 xor	 ebx, ebx
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	49 8b ca	 mov	 rcx, r10
  00042	41 89 5b 20	 mov	 DWORD PTR [r11+32], ebx
  00046	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004b	85 c0		 test	 eax, eax
  0004d	75 0b		 jne	 SHORT $LN27@binascii_a@4

; 1241 :         return NULL;

  0004f	33 c0		 xor	 eax, eax

; 1309 : }

  00051	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN27@binascii_a@4:
  0005a	48 89 ac 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbp
  00062	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rsi

; 1242 :     data = pdata.buf;

  0006a	48 8b 74 24 40	 mov	 rsi, QWORD PTR pdata$[rsp]
  0006f	48 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rdi

; 1243 :     datalen = pdata.len;

  00077	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pdata$[rsp+16]

; 1244 : 
; 1245 :     /* We allocate the output same size as input, this is overkill.
; 1246 :      * The previous implementation used calloc() so we'll zero out the
; 1247 :      * memory here too, since PyMem_Malloc() does not guarantee that.
; 1248 :      */
; 1249 :     odata = (unsigned char *) PyMem_Malloc(datalen);

  0007c	48 8b cf	 mov	 rcx, rdi
  0007f	e8 00 00 00 00	 call	 PyMem_Malloc
  00084	48 8b e8	 mov	 rbp, rax

; 1250 :     if (odata == NULL) {

  00087	48 85 c0	 test	 rax, rax
  0008a	75 16		 jne	 SHORT $LN26@binascii_a@4

; 1251 :         PyBuffer_Release(&pdata);

  0008c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pdata$[rsp]
  00091	e8 00 00 00 00	 call	 PyBuffer_Release

; 1252 :         PyErr_NoMemory();

  00096	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1253 :         return NULL;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 3d 01 00 00	 jmp	 $LN38@binascii_a@4
$LN26@binascii_a@4:

; 1254 :     }
; 1255 :     memset(odata, 0, datalen);

  000a2	4c 8b c7	 mov	 r8, rdi
  000a5	33 d2		 xor	 edx, edx
  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 memset

; 1256 : 
; 1257 :     in = out = 0;

  000af	48 8b d3	 mov	 rdx, rbx

; 1258 :     while (in < datalen) {

  000b2	48 85 ff	 test	 rdi, rdi
  000b5	0f 8e eb 00 00
	00		 jle	 $LN35@binascii_a@4
  000bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:table_hex
$LL25@binascii_a@4:

; 1259 :         if (data[in] == '=') {

  000c2	0f b6 04 32	 movzx	 eax, BYTE PTR [rdx+rsi]
  000c6	3c 3d		 cmp	 al, 61			; 0000003dH
  000c8	0f 85 ac 00 00
	00		 jne	 $LN23@binascii_a@4

; 1260 :             in++;

  000ce	48 ff c2	 inc	 rdx

; 1261 :             if (in >= datalen) break;

  000d1	48 3b d7	 cmp	 rdx, rdi
  000d4	0f 8d cc 00 00
	00		 jge	 $LN35@binascii_a@4

; 1262 :             /* Soft line breaks */
; 1263 :             if ((data[in] == '\n') || (data[in] == '\r')) {

  000da	0f b6 04 32	 movzx	 eax, BYTE PTR [rdx+rsi]
  000de	3c 0a		 cmp	 al, 10
  000e0	0f 84 8a 00 00
	00		 je	 $LN17@binascii_a@4
  000e6	3c 0d		 cmp	 al, 13
  000e8	74 70		 je	 SHORT $LN20@binascii_a@4

; 1268 :             }
; 1269 :             else if (data[in] == '=') {

  000ea	3c 3d		 cmp	 al, 61			; 0000003dH
  000ec	75 0e		 jne	 SHORT $LN14@binascii_a@4

; 1270 :                 /* broken case from broken python qp */
; 1271 :                 odata[out++] = '=';

  000ee	88 04 2b	 mov	 BYTE PTR [rbx+rbp], al
  000f1	48 ff c3	 inc	 rbx

; 1272 :                 in++;

  000f4	48 ff c2	 inc	 rdx

; 1273 :             }
; 1274 :             else if (((data[in] >= 'A' && data[in] <= 'F') ||

  000f7	e9 a1 00 00 00	 jmp	 $LN2@binascii_a@4
$LN14@binascii_a@4:

; 1275 :                       (data[in] >= 'a' && data[in] <= 'f') ||
; 1276 :                       (data[in] >= '0' && data[in] <= '9')) &&
; 1277 :                      ((data[in+1] >= 'A' && data[in+1] <= 'F') ||
; 1278 :                       (data[in+1] >= 'a' && data[in+1] <= 'f') ||
; 1279 :                       (data[in+1] >= '0' && data[in+1] <= '9'))) {

  000fc	3c 41		 cmp	 al, 65			; 00000041H
  000fe	72 04		 jb	 SHORT $LN10@binascii_a@4
  00100	3c 46		 cmp	 al, 70			; 00000046H
  00102	76 10		 jbe	 SHORT $LN11@binascii_a@4
$LN10@binascii_a@4:
  00104	3c 61		 cmp	 al, 97			; 00000061H
  00106	72 04		 jb	 SHORT $LN9@binascii_a@4
  00108	3c 66		 cmp	 al, 102			; 00000066H
  0010a	76 08		 jbe	 SHORT $LN11@binascii_a@4
$LN9@binascii_a@4:
  0010c	3c 30		 cmp	 al, 48			; 00000030H
  0010e	72 44		 jb	 SHORT $LN12@binascii_a@4
  00110	3c 39		 cmp	 al, 57			; 00000039H
  00112	77 40		 ja	 SHORT $LN12@binascii_a@4
$LN11@binascii_a@4:
  00114	0f b6 4c 32 01	 movzx	 ecx, BYTE PTR [rdx+rsi+1]
  00119	80 f9 41	 cmp	 cl, 65			; 00000041H
  0011c	72 05		 jb	 SHORT $LN7@binascii_a@4
  0011e	80 f9 46	 cmp	 cl, 70			; 00000046H
  00121	76 14		 jbe	 SHORT $LN8@binascii_a@4
$LN7@binascii_a@4:
  00123	80 f9 61	 cmp	 cl, 97			; 00000061H
  00126	72 05		 jb	 SHORT $LN6@binascii_a@4
  00128	80 f9 66	 cmp	 cl, 102			; 00000066H
  0012b	76 0a		 jbe	 SHORT $LN8@binascii_a@4
$LN6@binascii_a@4:
  0012d	80 f9 30	 cmp	 cl, 48			; 00000030H
  00130	72 22		 jb	 SHORT $LN12@binascii_a@4
  00132	80 f9 39	 cmp	 cl, 57			; 00000039H
  00135	77 1d		 ja	 SHORT $LN12@binascii_a@4
$LN8@binascii_a@4:

; 1280 :                 /* hexval */
; 1281 :                 ch = hexval(data[in]) << 4;

  00137	0f b6 c0	 movzx	 eax, al
  0013a	41 0f b6 0c 80	 movzx	 ecx, BYTE PTR [r8+rax*4]

; 1282 :                 in++;
; 1283 :                 ch |= hexval(data[in]);

  0013f	0f b6 44 32 01	 movzx	 eax, BYTE PTR [rdx+rsi+1]
  00144	c0 e1 04	 shl	 cl, 4
  00147	41 0a 0c 80	 or	 cl, BYTE PTR [r8+rax*4]

; 1284 :                 in++;

  0014b	48 83 c2 02	 add	 rdx, 2

; 1285 :                 odata[out++] = ch;

  0014f	88 0c 2b	 mov	 BYTE PTR [rbx+rbp], cl

; 1286 :             }
; 1287 :             else {

  00152	eb 46		 jmp	 SHORT $LN40@binascii_a@4
$LN12@binascii_a@4:

; 1288 :               odata[out++] = '=';

  00154	c6 04 2b 3d	 mov	 BYTE PTR [rbx+rbp], 61	; 0000003dH
  00158	eb 40		 jmp	 SHORT $LN40@binascii_a@4
$LN20@binascii_a@4:

; 1264 :                 if (data[in] != '\n') {

  0015a	3c 0a		 cmp	 al, 10
  0015c	74 12		 je	 SHORT $LN17@binascii_a@4
  0015e	66 90		 npad	 2
$LL18@binascii_a@4:

; 1265 :                     while (in < datalen && data[in] != '\n') in++;

  00160	80 3c 32 0a	 cmp	 BYTE PTR [rdx+rsi], 10
  00164	74 0a		 je	 SHORT $LN17@binascii_a@4
  00166	48 ff c2	 inc	 rdx
  00169	48 3b d7	 cmp	 rdx, rdi
  0016c	7c f2		 jl	 SHORT $LL18@binascii_a@4
  0016e	eb 36		 jmp	 SHORT $LN35@binascii_a@4
$LN17@binascii_a@4:

; 1266 :                 }
; 1267 :                 if (in < datalen) in++;

  00170	48 3b d7	 cmp	 rdx, rdi
  00173	7d 31		 jge	 SHORT $LN35@binascii_a@4
  00175	48 ff c2	 inc	 rdx

; 1289 :             }

  00178	eb 23		 jmp	 SHORT $LN2@binascii_a@4
$LN23@binascii_a@4:

; 1290 :         }
; 1291 :         else if (header && data[in] == '_') {

  0017a	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR header$[rsp], 0
  00182	74 10		 je	 SHORT $LN3@binascii_a@4
  00184	3c 5f		 cmp	 al, 95			; 0000005fH
  00186	75 0c		 jne	 SHORT $LN3@binascii_a@4

; 1292 :             odata[out++] = ' ';

  00188	c6 04 2b 20	 mov	 BYTE PTR [rbx+rbp], 32	; 00000020H
  0018c	48 ff c3	 inc	 rbx

; 1293 :             in++;

  0018f	48 ff c2	 inc	 rdx

; 1294 :         }
; 1295 :         else {

  00192	eb 09		 jmp	 SHORT $LN2@binascii_a@4
$LN3@binascii_a@4:

; 1296 :             odata[out] = data[in];

  00194	88 04 2b	 mov	 BYTE PTR [rbx+rbp], al

; 1297 :             in++;

  00197	48 ff c2	 inc	 rdx
$LN40@binascii_a@4:

; 1298 :             out++;

  0019a	48 ff c3	 inc	 rbx
$LN2@binascii_a@4:

; 1258 :     while (in < datalen) {

  0019d	48 3b d7	 cmp	 rdx, rdi
  001a0	0f 8c 1c ff ff
	ff		 jl	 $LL25@binascii_a@4
$LN35@binascii_a@4:

; 1299 :         }
; 1300 :     }
; 1301 :     if ((rv = PyBytes_FromStringAndSize((char *)odata, out)) == NULL) {

  001a6	48 8b d3	 mov	 rdx, rbx
  001a9	48 8b cd	 mov	 rcx, rbp
  001ac	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1302 :         PyBuffer_Release(&pdata);

  001b1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pdata$[rsp]
  001b6	48 8b d8	 mov	 rbx, rax
  001b9	48 85 c0	 test	 rax, rax
  001bc	75 11		 jne	 SHORT $LN1@binascii_a@4
  001be	e8 00 00 00 00	 call	 PyBuffer_Release

; 1303 :         PyMem_Free(odata);

  001c3	48 8b cd	 mov	 rcx, rbp
  001c6	e8 00 00 00 00	 call	 PyMem_Free

; 1304 :         return NULL;

  001cb	33 c0		 xor	 eax, eax
  001cd	eb 10		 jmp	 SHORT $LN38@binascii_a@4
$LN1@binascii_a@4:

; 1305 :     }
; 1306 :     PyBuffer_Release(&pdata);

  001cf	e8 00 00 00 00	 call	 PyBuffer_Release

; 1307 :     PyMem_Free(odata);

  001d4	48 8b cd	 mov	 rcx, rbp
  001d7	e8 00 00 00 00	 call	 PyMem_Free

; 1308 :     return rv;

  001dc	48 8b c3	 mov	 rax, rbx
$LN38@binascii_a@4:
  001df	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]
  001e7	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  001ef	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+176]

; 1309 : }

  001f7	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  001fe	5b		 pop	 rbx
  001ff	c3		 ret	 0
binascii_a2b_qp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@	; `string'
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ DB '0123456789ABCDEF', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT to_hex
_TEXT	SEGMENT
ch$ = 8
s$ = 16
to_hex	PROC						; COMDAT

; 1314 :     unsigned int uvalue = ch;

  00000	0f b6 c1	 movzx	 eax, cl

; 1315 : 
; 1316 :     s[1] = "0123456789ABCDEF"[uvalue % 16];

  00003	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
  0000a	8b c8		 mov	 ecx, eax
  0000c	83 e0 0f	 and	 eax, 15
  0000f	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]

; 1317 :     uvalue = (uvalue / 16);
; 1318 :     s[0] = "0123456789ABCDEF"[uvalue % 16];

  00014	48 c1 e9 04	 shr	 rcx, 4
  00018	88 42 01	 mov	 BYTE PTR [rdx+1], al
  0001b	83 e1 0f	 and	 ecx, 15
  0001e	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  00023	88 02		 mov	 BYTE PTR [rdx], al

; 1319 :     return 0;

  00025	33 c0		 xor	 eax, eax

; 1320 : }

  00027	c3		 ret	 0
to_hex	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@		; `string'
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_qp DD imagerel binascii_b2a_qp
	DD	imagerel binascii_b2a_qp+117
	DD	imagerel $unwind$binascii_b2a_qp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$binascii_b2a_qp DD imagerel binascii_b2a_qp+117
	DD	imagerel binascii_b2a_qp+1177
	DD	imagerel $chain$1$binascii_b2a_qp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$binascii_b2a_qp DD imagerel binascii_b2a_qp+1177
	DD	imagerel binascii_b2a_qp+1196
	DD	imagerel $chain$2$binascii_b2a_qp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$binascii_b2a_qp DD 021H
	DD	imagerel binascii_b2a_qp
	DD	imagerel binascii_b2a_qp+117
	DD	imagerel $unwind$binascii_b2a_qp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$binascii_b2a_qp DD 041521H
	DD	019d415H
	DD	018c408H
	DD	imagerel binascii_b2a_qp
	DD	imagerel binascii_b2a_qp+117
	DD	imagerel $unwind$binascii_b2a_qp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_qp DD 071101H
	DD	01a3411H
	DD	0140111H
	DD	06009700aH
	DD	05008H
xdata	ENDS
;	COMDAT ??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@
CONST	SEGMENT
??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@ DB 'y*|iii', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binascii_b2a_qp
_TEXT	SEGMENT
istext$ = 64
quotetabs$ = 68
pdata$ = 80
self$ = 192
args$ = 200
kwargs$ = 208
header$ = 216
binascii_b2a_qp PROC					; COMDAT

; 1335 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 1336 :     Py_ssize_t in, out;
; 1337 :     Py_buffer pdata;
; 1338 :     unsigned char *data, *odata;
; 1339 :     Py_ssize_t datalen = 0, odatalen = 0;
; 1340 :     PyObject *rv;
; 1341 :     unsigned int linelen = 0;
; 1342 :     static char *kwlist[] = {"data", "quotetabs", "istext",
; 1343 :                                    "header", NULL};
; 1344 :     int istext = 1;
; 1345 :     int quotetabs = 0;
; 1346 :     int header = 0;
; 1347 :     unsigned char ch;
; 1348 :     int crlf = 0;
; 1349 :     unsigned char *p;
; 1350 : 
; 1351 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "y*|iii", kwlist, &pdata,
; 1352 :           &quotetabs, &istext, &header))

  00011	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00015	49 8b c0	 mov	 rax, r8
  00018	4c 8b d2	 mov	 r10, rdx
  0001b	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  0001f	49 8d 4b 88	 lea	 rcx, QWORD PTR [r11-120]
  00023	33 db		 xor	 ebx, ebx
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	49 8d 4b 8c	 lea	 rcx, QWORD PTR [r11-116]
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??binascii_b2a_qp@@9@9
  00035	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0003a	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  0003e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@
  00045	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0004a	bd 01 00 00 00	 mov	 ebp, 1
  0004f	48 8b d0	 mov	 rdx, rax
  00052	49 8b ca	 mov	 rcx, r10
  00055	33 ff		 xor	 edi, edi
  00057	89 5c 24 44	 mov	 DWORD PTR quotetabs$[rsp], ebx
  0005b	89 6c 24 40	 mov	 DWORD PTR istext$[rsp], ebp
  0005f	41 89 5b 20	 mov	 DWORD PTR [r11+32], ebx
  00063	33 f6		 xor	 esi, esi
  00065	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN55@binascii_b@4

; 1353 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 24 04 00 00	 jmp	 $LN56@binascii_b@4
$LN55@binascii_b@4:
  00075	4c 89 a4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r12

; 1354 :     data = pdata.buf;

  0007d	4c 8b 64 24 50	 mov	 r12, QWORD PTR pdata$[rsp]
  00082	4c 89 ac 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r13

; 1355 :     datalen = pdata.len;

  0008a	4c 8b 6c 24 60	 mov	 r13, QWORD PTR pdata$[rsp+16]

; 1356 : 
; 1357 :     /* See if this string is using CRLF line ends */
; 1358 :     /* XXX: this function has the side effect of converting all of
; 1359 :      * the end of lines to be the same depending on this detection
; 1360 :      * here */
; 1361 :     p = (unsigned char *) memchr(data, '\n', datalen);

  0008f	ba 0a 00 00 00	 mov	 edx, 10
  00094	49 8b cc	 mov	 rcx, r12
  00097	4d 8b c5	 mov	 r8, r13
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr

; 1362 :     if ((p != NULL) && (p > data) && (*(p-1) == '\r'))

  000a0	48 85 c0	 test	 rax, rax
  000a3	74 0c		 je	 SHORT $LN54@binascii_b@4
  000a5	49 3b c4	 cmp	 rax, r12
  000a8	76 07		 jbe	 SHORT $LN54@binascii_b@4
  000aa	80 78 ff 0d	 cmp	 BYTE PTR [rax-1], 13
  000ae	0f 44 f5	 cmove	 esi, ebp
$LN54@binascii_b@4:

; 1363 :         crlf = 1;
; 1364 : 
; 1365 :     /* First, scan to see how many characters need to be encoded */
; 1366 :     in = 0;

  000b1	33 c9		 xor	 ecx, ecx

; 1400 :                 if (crlf)

  000b3	48 63 f6	 movsxd	 rsi, esi
  000b6	4d 85 ed	 test	 r13, r13
  000b9	0f 8e 69 01 00
	00		 jle	 $LN52@binascii_b@4

; 1363 :         crlf = 1;
; 1364 : 
; 1365 :     /* First, scan to see how many characters need to be encoded */
; 1366 :     in = 0;

  000bf	44 8b 4c 24 40	 mov	 r9d, DWORD PTR istext$[rsp]
  000c4	44 8b 54 24 44	 mov	 r10d, DWORD PTR quotetabs$[rsp]
  000c9	44 8b 9c 24 d8
	00 00 00	 mov	 r11d, DWORD PTR header$[rsp]
  000d1	48 8b d5	 mov	 rdx, rbp
  000d4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL53@binascii_b@4:

; 1368 :         if ((data[in] > 126) ||
; 1369 :             (data[in] == '=') ||
; 1370 :             (header && data[in] == '_') ||
; 1371 :             ((data[in] == '.') && (linelen == 0) &&
; 1372 :              (data[in+1] == '\n' || data[in+1] == '\r' || data[in+1] == 0)) ||
; 1373 :             (!istext && ((data[in] == '\r') || (data[in] == '\n'))) ||
; 1374 :             ((data[in] == '\t' || data[in] == ' ') && (in + 1 == datalen)) ||
; 1375 :             ((data[in] < 33) &&
; 1376 :              (data[in] != '\r') && (data[in] != '\n') &&
; 1377 :              (quotetabs || ((data[in] != '\t') && (data[in] != ' ')))))

  000e0	42 0f b6 04 21	 movzx	 eax, BYTE PTR [rcx+r12]
  000e5	3c 7e		 cmp	 al, 126			; 0000007eH
  000e7	0f 87 0c 01 00
	00		 ja	 $LN44@binascii_b@4
  000ed	3c 3d		 cmp	 al, 61			; 0000003dH
  000ef	0f 84 04 01 00
	00		 je	 $LN44@binascii_b@4
  000f5	45 85 db	 test	 r11d, r11d
  000f8	74 08		 je	 SHORT $LN49@binascii_b@4
  000fa	3c 5f		 cmp	 al, 95			; 0000005fH
  000fc	0f 84 f7 00 00
	00		 je	 $LN44@binascii_b@4
$LN49@binascii_b@4:
  00102	3c 2e		 cmp	 al, 46			; 0000002eH
  00104	75 27		 jne	 SHORT $LN48@binascii_b@4
  00106	85 ff		 test	 edi, edi
  00108	75 23		 jne	 SHORT $LN48@binascii_b@4
  0010a	46 0f b6 44 21
	01		 movzx	 r8d, BYTE PTR [rcx+r12+1]
  00110	41 80 f8 0a	 cmp	 r8b, 10
  00114	0f 84 df 00 00
	00		 je	 $LN44@binascii_b@4
  0011a	41 80 f8 0d	 cmp	 r8b, 13
  0011e	0f 84 d5 00 00
	00		 je	 $LN44@binascii_b@4
  00124	45 84 c0	 test	 r8b, r8b
  00127	0f 84 cc 00 00
	00		 je	 $LN44@binascii_b@4
$LN48@binascii_b@4:
  0012d	45 85 c9	 test	 r9d, r9d
  00130	75 10		 jne	 SHORT $LN47@binascii_b@4
  00132	3c 0d		 cmp	 al, 13
  00134	0f 84 bf 00 00
	00		 je	 $LN44@binascii_b@4
  0013a	3c 0a		 cmp	 al, 10
  0013c	0f 84 b7 00 00
	00		 je	 $LN44@binascii_b@4
$LN47@binascii_b@4:
  00142	3c 09		 cmp	 al, 9
  00144	74 04		 je	 SHORT $LN45@binascii_b@4
  00146	3c 20		 cmp	 al, 32			; 00000020H
  00148	75 09		 jne	 SHORT $LN46@binascii_b@4
$LN45@binascii_b@4:
  0014a	49 3b d5	 cmp	 rdx, r13
  0014d	0f 84 a6 00 00
	00		 je	 $LN44@binascii_b@4
$LN46@binascii_b@4:
  00153	3c 21		 cmp	 al, 33			; 00000021H
  00155	73 1d		 jae	 SHORT $LN51@binascii_b@4
  00157	3c 0d		 cmp	 al, 13
  00159	74 19		 je	 SHORT $LN51@binascii_b@4
  0015b	3c 0a		 cmp	 al, 10
  0015d	74 15		 je	 SHORT $LN51@binascii_b@4
  0015f	45 85 d2	 test	 r10d, r10d
  00162	0f 85 91 00 00
	00		 jne	 $LN44@binascii_b@4
  00168	3c 09		 cmp	 al, 9
  0016a	74 08		 je	 SHORT $LN51@binascii_b@4
  0016c	3c 20		 cmp	 al, 32			; 00000020H
  0016e	0f 85 85 00 00
	00		 jne	 $LN44@binascii_b@4
$LN51@binascii_b@4:

; 1389 :         }
; 1390 :         else {
; 1391 :             if (istext &&
; 1392 :                 ((data[in] == '\n') ||
; 1393 :                  ((in+1 < datalen) && (data[in] == '\r') &&
; 1394 :                  (data[in+1] == '\n'))))

  00174	45 85 c9	 test	 r9d, r9d
  00177	74 4e		 je	 SHORT $LN39@binascii_b@4
  00179	3c 0a		 cmp	 al, 10
  0017b	74 11		 je	 SHORT $LN38@binascii_b@4
  0017d	49 3b d5	 cmp	 rdx, r13
  00180	7d 48		 jge	 SHORT $LN63@binascii_b@4
  00182	3c 0d		 cmp	 al, 13
  00184	75 41		 jne	 SHORT $LN39@binascii_b@4
  00186	42 80 7c 21 01
	0a		 cmp	 BYTE PTR [rcx+r12+1], 10
  0018c	75 39		 jne	 SHORT $LN39@binascii_b@4
$LN38@binascii_b@4:

; 1395 :             {
; 1396 :                 linelen = 0;

  0018e	33 ff		 xor	 edi, edi

; 1397 :                 /* Protect against whitespace on end of line */
; 1398 :                 if (in && ((data[in-1] == ' ') || (data[in-1] == '\t')))

  00190	48 85 c9	 test	 rcx, rcx
  00193	74 16		 je	 SHORT $LN37@binascii_b@4
  00195	46 0f b6 44 21
	ff		 movzx	 r8d, BYTE PTR [rcx+r12-1]
  0019b	41 80 f8 20	 cmp	 r8b, 32			; 00000020H
  0019f	74 06		 je	 SHORT $LN36@binascii_b@4
  001a1	41 80 f8 09	 cmp	 r8b, 9
  001a5	75 04		 jne	 SHORT $LN37@binascii_b@4
$LN36@binascii_b@4:

; 1399 :                     odatalen += 2;

  001a7	48 83 c3 02	 add	 rbx, 2
$LN37@binascii_b@4:

; 1400 :                 if (crlf)

  001ab	48 85 f6	 test	 rsi, rsi
  001ae	74 06		 je	 SHORT $LN35@binascii_b@4

; 1401 :                     odatalen += 2;

  001b0	48 83 c3 02	 add	 rbx, 2

; 1402 :                 else

  001b4	eb 03		 jmp	 SHORT $LN34@binascii_b@4
$LN35@binascii_b@4:

; 1403 :                     odatalen += 1;

  001b6	48 ff c3	 inc	 rbx
$LN34@binascii_b@4:

; 1404 :                 if (data[in] == '\r')

  001b9	3c 0d		 cmp	 al, 13
  001bb	75 5c		 jne	 SHORT $LN33@binascii_b@4

; 1405 :                     in += 2;

  001bd	48 83 c1 02	 add	 rcx, 2
  001c1	48 83 c2 02	 add	 rdx, 2

; 1406 :                 else

  001c5	eb 58		 jmp	 SHORT $LN31@binascii_b@4
$LN39@binascii_b@4:

; 1407 :                     in++;
; 1408 :             }
; 1409 :             else {
; 1410 :                 if ((in + 1 != datalen) &&
; 1411 :                     (data[in+1] != '\n') &&
; 1412 :                     (linelen + 1) >= MAXLINESIZE) {

  001c7	49 3b d5	 cmp	 rdx, r13
$LN63@binascii_b@4:
  001ca	74 26		 je	 SHORT $LN28@binascii_b@4
  001cc	42 80 7c 21 01
	0a		 cmp	 BYTE PTR [rcx+r12+1], 10
  001d2	74 1e		 je	 SHORT $LN28@binascii_b@4
  001d4	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  001d7	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  001da	72 16		 jb	 SHORT $LN28@binascii_b@4

; 1413 :                     linelen = 0;

  001dc	33 ff		 xor	 edi, edi

; 1414 :                     if (crlf)

  001de	48 85 f6	 test	 rsi, rsi
  001e1	74 0b		 je	 SHORT $LN29@binascii_b@4

; 1415 :                         odatalen += 3;

  001e3	48 83 c3 03	 add	 rbx, 3

; 1418 :                 }
; 1419 :                 linelen++;

  001e7	ff c7		 inc	 edi

; 1420 :                 odatalen++;

  001e9	48 ff c3	 inc	 rbx

; 1421 :                 in++;

  001ec	eb 2b		 jmp	 SHORT $LN33@binascii_b@4
$LN29@binascii_b@4:

; 1416 :                     else
; 1417 :                         odatalen += 2;

  001ee	48 83 c3 02	 add	 rbx, 2
$LN28@binascii_b@4:

; 1418 :                 }
; 1419 :                 linelen++;

  001f2	ff c7		 inc	 edi

; 1420 :                 odatalen++;

  001f4	48 ff c3	 inc	 rbx

; 1421 :                 in++;

  001f7	eb 20		 jmp	 SHORT $LN33@binascii_b@4
$LN44@binascii_b@4:

; 1378 :         {
; 1379 :             if ((linelen + 3) >= MAXLINESIZE) {

  001f9	8d 47 03	 lea	 eax, DWORD PTR [rdi+3]
  001fc	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  001ff	72 11		 jb	 SHORT $LN41@binascii_b@4

; 1380 :                 linelen = 0;

  00201	33 ff		 xor	 edi, edi

; 1381 :                 if (crlf)

  00203	48 85 f6	 test	 rsi, rsi
  00206	74 06		 je	 SHORT $LN42@binascii_b@4

; 1382 :                     odatalen += 3;

  00208	48 83 c3 03	 add	 rbx, 3

; 1383 :                 else

  0020c	eb 04		 jmp	 SHORT $LN41@binascii_b@4
$LN42@binascii_b@4:

; 1384 :                     odatalen += 2;

  0020e	48 83 c3 02	 add	 rbx, 2
$LN41@binascii_b@4:

; 1385 :             }
; 1386 :             linelen += 3;

  00212	83 c7 03	 add	 edi, 3

; 1387 :             odatalen += 3;

  00215	48 83 c3 03	 add	 rbx, 3
$LN33@binascii_b@4:

; 1388 :             in++;

  00219	48 ff c1	 inc	 rcx
  0021c	48 ff c2	 inc	 rdx
$LN31@binascii_b@4:

; 1367 :     while (in < datalen) {

  0021f	49 3b cd	 cmp	 rcx, r13
  00222	0f 8c b8 fe ff
	ff		 jl	 $LL53@binascii_b@4
$LN52@binascii_b@4:

; 1422 :             }
; 1423 :         }
; 1424 :     }
; 1425 : 
; 1426 :     /* We allocate the output same size as input, this is overkill.
; 1427 :      * The previous implementation used calloc() so we'll zero out the
; 1428 :      * memory here too, since PyMem_Malloc() does not guarantee that.
; 1429 :      */
; 1430 :     odata = (unsigned char *) PyMem_Malloc(odatalen);

  00228	48 8b cb	 mov	 rcx, rbx
  0022b	e8 00 00 00 00	 call	 PyMem_Malloc
  00230	48 8b f8	 mov	 rdi, rax

; 1431 :     if (odata == NULL) {

  00233	48 85 c0	 test	 rax, rax
  00236	75 16		 jne	 SHORT $LN27@binascii_b@4

; 1432 :         PyBuffer_Release(&pdata);

  00238	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdata$[rsp]
  0023d	e8 00 00 00 00	 call	 PyBuffer_Release

; 1433 :         PyErr_NoMemory();

  00242	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1434 :         return NULL;

  00247	33 c0		 xor	 eax, eax
  00249	e9 3b 02 00 00	 jmp	 $LN62@binascii_b@4
$LN27@binascii_b@4:

; 1435 :     }
; 1436 :     memset(odata, 0, odatalen);

  0024e	4c 8b c3	 mov	 r8, rbx
  00251	33 d2		 xor	 edx, edx
  00253	48 8b c8	 mov	 rcx, rax
  00256	e8 00 00 00 00	 call	 memset

; 1437 : 
; 1438 :     in = out = linelen = 0;

  0025b	45 33 db	 xor	 r11d, r11d
  0025e	45 33 c9	 xor	 r9d, r9d
  00261	45 33 d2	 xor	 r10d, r10d

; 1439 :     while (in < datalen) {

  00264	4d 85 ed	 test	 r13, r13
  00267	0f 8e e3 01 00
	00		 jle	 $LN25@binascii_b@4

; 1435 :     }
; 1436 :     memset(odata, 0, odatalen);

  0026d	48 8b d7	 mov	 rdx, rdi
$LL26@binascii_b@4:

; 1440 :         if ((data[in] > 126) ||
; 1441 :             (data[in] == '=') ||
; 1442 :             (header && data[in] == '_') ||
; 1443 :             ((data[in] == '.') && (linelen == 0) &&
; 1444 :              (data[in+1] == '\n' || data[in+1] == '\r' || data[in+1] == 0)) ||
; 1445 :             (!istext && ((data[in] == '\r') || (data[in] == '\n'))) ||
; 1446 :             ((data[in] == '\t' || data[in] == ' ') && (in + 1 == datalen)) ||
; 1447 :             ((data[in] < 33) &&
; 1448 :              (data[in] != '\r') && (data[in] != '\n') &&
; 1449 :              (quotetabs ||
; 1450 :             (!quotetabs && ((data[in] != '\t') && (data[in] != ' '))))))

  00270	43 0f b6 04 22	 movzx	 eax, BYTE PTR [r10+r12]
  00275	3c 7e		 cmp	 al, 126			; 0000007eH
  00277	0f 87 7c 01 00
	00		 ja	 $LN17@binascii_b@4
  0027d	3c 3d		 cmp	 al, 61			; 0000003dH
  0027f	0f 84 74 01 00
	00		 je	 $LN17@binascii_b@4
  00285	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR header$[rsp]
  0028d	45 85 c0	 test	 r8d, r8d
  00290	74 08		 je	 SHORT $LN22@binascii_b@4
  00292	3c 5f		 cmp	 al, 95			; 0000005fH
  00294	0f 84 5f 01 00
	00		 je	 $LN17@binascii_b@4
$LN22@binascii_b@4:
  0029a	3c 2e		 cmp	 al, 46			; 0000002eH
  0029c	75 25		 jne	 SHORT $LN21@binascii_b@4
  0029e	45 85 db	 test	 r11d, r11d
  002a1	75 20		 jne	 SHORT $LN21@binascii_b@4
  002a3	43 0f b6 4c 22
	01		 movzx	 ecx, BYTE PTR [r10+r12+1]
  002a9	80 f9 0a	 cmp	 cl, 10
  002ac	0f 84 47 01 00
	00		 je	 $LN17@binascii_b@4
  002b2	80 f9 0d	 cmp	 cl, 13
  002b5	0f 84 3e 01 00
	00		 je	 $LN17@binascii_b@4
  002bb	84 c9		 test	 cl, cl
  002bd	0f 84 36 01 00
	00		 je	 $LN17@binascii_b@4
$LN21@binascii_b@4:
  002c3	8b 4c 24 40	 mov	 ecx, DWORD PTR istext$[rsp]
  002c7	85 c9		 test	 ecx, ecx
  002c9	75 10		 jne	 SHORT $LN20@binascii_b@4
  002cb	3c 0d		 cmp	 al, 13
  002cd	0f 84 26 01 00
	00		 je	 $LN17@binascii_b@4
  002d3	3c 0a		 cmp	 al, 10
  002d5	0f 84 1e 01 00
	00		 je	 $LN17@binascii_b@4
$LN20@binascii_b@4:
  002db	3c 09		 cmp	 al, 9
  002dd	74 04		 je	 SHORT $LN18@binascii_b@4
  002df	3c 20		 cmp	 al, 32			; 00000020H
  002e1	75 09		 jne	 SHORT $LN19@binascii_b@4
$LN18@binascii_b@4:
  002e3	49 3b ed	 cmp	 rbp, r13
  002e6	0f 84 0d 01 00
	00		 je	 $LN17@binascii_b@4
$LN19@binascii_b@4:
  002ec	3c 21		 cmp	 al, 33			; 00000021H
  002ee	73 1f		 jae	 SHORT $LN24@binascii_b@4
  002f0	3c 0d		 cmp	 al, 13
  002f2	74 1b		 je	 SHORT $LN24@binascii_b@4
  002f4	3c 0a		 cmp	 al, 10
  002f6	74 17		 je	 SHORT $LN24@binascii_b@4
  002f8	83 7c 24 44 00	 cmp	 DWORD PTR quotetabs$[rsp], 0
  002fd	0f 85 f6 00 00
	00		 jne	 $LN17@binascii_b@4
  00303	3c 09		 cmp	 al, 9
  00305	74 08		 je	 SHORT $LN24@binascii_b@4
  00307	3c 20		 cmp	 al, 32			; 00000020H
  00309	0f 85 ea 00 00
	00		 jne	 $LN17@binascii_b@4
$LN24@binascii_b@4:

; 1463 :         }
; 1464 :         else {
; 1465 :             if (istext &&
; 1466 :                 ((data[in] == '\n') ||
; 1467 :                  ((in+1 < datalen) && (data[in] == '\r') &&
; 1468 :                  (data[in+1] == '\n'))))

  0030f	85 c9		 test	 ecx, ecx
  00311	74 6f		 je	 SHORT $LN13@binascii_b@4
  00313	3c 0a		 cmp	 al, 10
  00315	74 11		 je	 SHORT $LN12@binascii_b@4
  00317	49 3b ed	 cmp	 rbp, r13
  0031a	7d 69		 jge	 SHORT $LN64@binascii_b@4
  0031c	3c 0d		 cmp	 al, 13
  0031e	75 62		 jne	 SHORT $LN13@binascii_b@4
  00320	43 80 7c 22 01
	0a		 cmp	 BYTE PTR [r10+r12+1], 10
  00326	75 5a		 jne	 SHORT $LN13@binascii_b@4
$LN12@binascii_b@4:

; 1469 :             {
; 1470 :                 linelen = 0;

  00328	45 33 db	 xor	 r11d, r11d

; 1471 :                 /* Protect against whitespace on end of line */
; 1472 :                 if (out && ((odata[out-1] == ' ') || (odata[out-1] == '\t'))) {

  0032b	4d 85 c9	 test	 r9, r9
  0032e	74 27		 je	 SHORT $LN11@binascii_b@4
  00330	41 0f b6 44 39
	ff		 movzx	 eax, BYTE PTR [r9+rdi-1]
  00336	3c 20		 cmp	 al, 32			; 00000020H
  00338	74 04		 je	 SHORT $LN10@binascii_b@4
  0033a	3c 09		 cmp	 al, 9
  0033c	75 19		 jne	 SHORT $LN11@binascii_b@4
$LN10@binascii_b@4:

; 1473 :                     ch = odata[out-1];

  0033e	41 0f b6 4c 39
	ff		 movzx	 ecx, BYTE PTR [r9+rdi-1]

; 1474 :                     odata[out-1] = '=';

  00344	41 c6 44 39 ff
	3d		 mov	 BYTE PTR [r9+rdi-1], 61	; 0000003dH

; 1475 :                     to_hex(ch, &odata[out]);

  0034a	e8 00 00 00 00	 call	 to_hex

; 1476 :                     out += 2;

  0034f	49 83 c1 02	 add	 r9, 2
  00353	48 83 c2 02	 add	 rdx, 2
$LN11@binascii_b@4:

; 1477 :                 }
; 1478 : 
; 1479 :                 if (crlf) odata[out++] = '\r';

  00357	48 85 f6	 test	 rsi, rsi
  0035a	74 09		 je	 SHORT $LN9@binascii_b@4
  0035c	c6 02 0d	 mov	 BYTE PTR [rdx], 13
  0035f	49 ff c1	 inc	 r9
  00362	48 ff c2	 inc	 rdx
$LN9@binascii_b@4:

; 1480 :                 odata[out++] = '\n';

  00365	c6 02 0a	 mov	 BYTE PTR [rdx], 10
  00368	48 ff c2	 inc	 rdx
  0036b	49 ff c1	 inc	 r9

; 1481 :                 if (data[in] == '\r')

  0036e	43 80 3c 22 0d	 cmp	 BYTE PTR [r10+r12], 13
  00373	75 66		 jne	 SHORT $LN8@binascii_b@4

; 1482 :                     in += 2;

  00375	49 83 c2 02	 add	 r10, 2
  00379	48 83 c5 02	 add	 rbp, 2

; 1483 :                 else

  0037d	e9 c5 00 00 00	 jmp	 $LN2@binascii_b@4
$LN13@binascii_b@4:

; 1484 :                     in++;
; 1485 :             }
; 1486 :             else {
; 1487 :                 if ((in + 1 != datalen) &&
; 1488 :                     (data[in+1] != '\n') &&
; 1489 :                     (linelen + 1) >= MAXLINESIZE) {

  00382	49 3b ed	 cmp	 rbp, r13
$LN64@binascii_b@4:
  00385	74 3c		 je	 SHORT $LN5@binascii_b@4
  00387	43 80 7c 22 01
	0a		 cmp	 BYTE PTR [r10+r12+1], 10
  0038d	74 34		 je	 SHORT $LN5@binascii_b@4
  0038f	41 8d 43 01	 lea	 eax, DWORD PTR [r11+1]
  00393	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00396	72 2b		 jb	 SHORT $LN5@binascii_b@4

; 1490 :                     odata[out++] = '=';

  00398	c6 02 3d	 mov	 BYTE PTR [rdx], 61	; 0000003dH
  0039b	48 ff c2	 inc	 rdx
  0039e	49 ff c1	 inc	 r9

; 1491 :                     if (crlf) odata[out++] = '\r';

  003a1	48 85 f6	 test	 rsi, rsi
  003a4	74 09		 je	 SHORT $LN4@binascii_b@4
  003a6	c6 02 0d	 mov	 BYTE PTR [rdx], 13
  003a9	49 ff c1	 inc	 r9
  003ac	48 ff c2	 inc	 rdx
$LN4@binascii_b@4:

; 1492 :                     odata[out++] = '\n';

  003af	c6 02 0a	 mov	 BYTE PTR [rdx], 10

; 1493 :                     linelen = 0;

  003b2	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR header$[rsp]
  003ba	48 ff c2	 inc	 rdx
  003bd	49 ff c1	 inc	 r9
  003c0	45 33 db	 xor	 r11d, r11d
$LN5@binascii_b@4:

; 1494 :                 }
; 1495 :                 linelen++;

  003c3	41 ff c3	 inc	 r11d

; 1496 :                 if (header && data[in] == ' ') {

  003c6	45 85 c0	 test	 r8d, r8d
  003c9	74 18		 je	 SHORT $LN3@binascii_b@4
  003cb	43 80 3c 22 20	 cmp	 BYTE PTR [r10+r12], 32	; 00000020H
  003d0	75 11		 jne	 SHORT $LN3@binascii_b@4

; 1497 :                     odata[out++] = '_';

  003d2	c6 02 5f	 mov	 BYTE PTR [rdx], 95	; 0000005fH
  003d5	49 ff c1	 inc	 r9
  003d8	48 ff c2	 inc	 rdx
$LN8@binascii_b@4:

; 1498 :                     in++;

  003db	49 ff c2	 inc	 r10
  003de	48 ff c5	 inc	 rbp

; 1499 :                 }
; 1500 :                 else {

  003e1	eb 64		 jmp	 SHORT $LN2@binascii_b@4
$LN3@binascii_b@4:

; 1501 :                     odata[out++] = data[in++];

  003e3	43 0f b6 04 22	 movzx	 eax, BYTE PTR [r10+r12]
  003e8	48 ff c2	 inc	 rdx
  003eb	49 ff c1	 inc	 r9
  003ee	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  003f1	49 ff c2	 inc	 r10
  003f4	48 ff c5	 inc	 rbp
  003f7	eb 4e		 jmp	 SHORT $LN2@binascii_b@4
$LN17@binascii_b@4:

; 1451 :         {
; 1452 :             if ((linelen + 3 )>= MAXLINESIZE) {

  003f9	41 8d 43 03	 lea	 eax, DWORD PTR [r11+3]
  003fd	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00400	72 23		 jb	 SHORT $LN16@binascii_b@4

; 1453 :                 odata[out++] = '=';

  00402	c6 02 3d	 mov	 BYTE PTR [rdx], 61	; 0000003dH
  00405	48 ff c2	 inc	 rdx
  00408	49 ff c1	 inc	 r9

; 1454 :                 if (crlf) odata[out++] = '\r';

  0040b	48 85 f6	 test	 rsi, rsi
  0040e	74 09		 je	 SHORT $LN15@binascii_b@4
  00410	c6 02 0d	 mov	 BYTE PTR [rdx], 13
  00413	49 ff c1	 inc	 r9
  00416	48 ff c2	 inc	 rdx
$LN15@binascii_b@4:

; 1455 :                 odata[out++] = '\n';

  00419	c6 02 0a	 mov	 BYTE PTR [rdx], 10
  0041c	48 ff c2	 inc	 rdx
  0041f	49 ff c1	 inc	 r9

; 1456 :                 linelen = 0;

  00422	45 33 db	 xor	 r11d, r11d
$LN16@binascii_b@4:

; 1457 :             }
; 1458 :             odata[out++] = '=';

  00425	c6 02 3d	 mov	 BYTE PTR [rdx], 61	; 0000003dH

; 1459 :             to_hex(data[in], &odata[out]);

  00428	43 0f b6 0c 22	 movzx	 ecx, BYTE PTR [r10+r12]
  0042d	48 ff c2	 inc	 rdx
  00430	e8 00 00 00 00	 call	 to_hex

; 1460 :             out += 2;

  00435	49 83 c1 03	 add	 r9, 3
  00439	48 83 c2 02	 add	 rdx, 2

; 1461 :             in++;

  0043d	49 ff c2	 inc	 r10
  00440	48 ff c5	 inc	 rbp

; 1462 :             linelen += 3;

  00443	41 83 c3 03	 add	 r11d, 3
$LN2@binascii_b@4:

; 1439 :     while (in < datalen) {

  00447	4d 3b d5	 cmp	 r10, r13
  0044a	0f 8c 20 fe ff
	ff		 jl	 $LL26@binascii_b@4
$LN25@binascii_b@4:

; 1502 :                 }
; 1503 :             }
; 1504 :         }
; 1505 :     }
; 1506 :     if ((rv = PyBytes_FromStringAndSize((char *)odata, out)) == NULL) {

  00450	49 8b d1	 mov	 rdx, r9
  00453	48 8b cf	 mov	 rcx, rdi
  00456	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1507 :         PyBuffer_Release(&pdata);

  0045b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdata$[rsp]
  00460	48 8b d8	 mov	 rbx, rax
  00463	48 85 c0	 test	 rax, rax
  00466	75 11		 jne	 SHORT $LN1@binascii_b@4
  00468	e8 00 00 00 00	 call	 PyBuffer_Release

; 1508 :         PyMem_Free(odata);

  0046d	48 8b cf	 mov	 rcx, rdi
  00470	e8 00 00 00 00	 call	 PyMem_Free

; 1509 :         return NULL;

  00475	33 c0		 xor	 eax, eax
  00477	eb 10		 jmp	 SHORT $LN62@binascii_b@4
$LN1@binascii_b@4:

; 1510 :     }
; 1511 :     PyBuffer_Release(&pdata);

  00479	e8 00 00 00 00	 call	 PyBuffer_Release

; 1512 :     PyMem_Free(odata);

  0047e	48 8b cf	 mov	 rcx, rdi
  00481	e8 00 00 00 00	 call	 PyMem_Free

; 1513 :     return rv;

  00486	48 8b c3	 mov	 rax, rbx
$LN62@binascii_b@4:
  00489	4c 8b a4 24 c0
	00 00 00	 mov	 r12, QWORD PTR [rsp+192]
  00491	4c 8b ac 24 c8
	00 00 00	 mov	 r13, QWORD PTR [rsp+200]
$LN56@binascii_b@4:

; 1514 : }

  00499	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+208]
  004a1	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  004a8	5f		 pop	 rdi
  004a9	5e		 pop	 rsi
  004aa	5d		 pop	 rbp
  004ab	c3		 ret	 0
binascii_b2a_qp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GAHNLADL@Incomplete?$AA@		; `string'
PUBLIC	??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@	; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0P@BJDIBMKL@binascii?4Error?$AA@		; `string'
PUBLIC	PyInit_binascii
EXTRN	PyErr_Occurred:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_binascii DD imagerel $LN5
	DD	imagerel $LN5+40
	DD	imagerel $unwind$PyInit_binascii
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit_binascii DD imagerel $LN5+40
	DD	imagerel $LN5+157
	DD	imagerel $chain$0$PyInit_binascii
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyInit_binascii DD imagerel $LN5+157
	DD	imagerel $LN5+176
	DD	imagerel $chain$1$PyInit_binascii
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyInit_binascii DD 021H
	DD	imagerel $LN5
	DD	imagerel $LN5+40
	DD	imagerel $unwind$PyInit_binascii
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit_binascii DD 020521H
	DD	063405H
	DD	imagerel $LN5
	DD	imagerel $LN5+40
	DD	imagerel $unwind$PyInit_binascii
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_binascii DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0L@GAHNLADL@Incomplete?$AA@
CONST	SEGMENT
??_C@_0L@GAHNLADL@Incomplete?$AA@ DB 'Incomplete', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@
CONST	SEGMENT
??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@ DB 'binascii.Incomplete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BJDIBMKL@binascii?4Error?$AA@
CONST	SEGMENT
??_C@_0P@BJDIBMKL@binascii?4Error?$AA@ DB 'binascii.Error', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_binascii
_TEXT	SEGMENT
PyInit_binascii PROC					; COMDAT

; 1560 : {

$LN5:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1561 :     PyObject *m, *d;
; 1562 : 
; 1563 :     /* Create the module and add the functions */
; 1564 :     m = PyModule_Create(&binasciimodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:binasciimodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b f8	 mov	 rdi, rax

; 1565 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 06		 jne	 SHORT $LN2@PyInit_bin

; 1579 : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN2@PyInit_bin:

; 1566 :         return NULL;
; 1567 : 
; 1568 :     d = PyModule_GetDict(m);

  00025	48 8b c8	 mov	 rcx, rax
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002d	e8 00 00 00 00	 call	 PyModule_GetDict

; 1569 : 
; 1570 :     Error = PyErr_NewException("binascii.Error", PyExc_ValueError, NULL);

  00032	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@BJDIBMKL@binascii?4Error?$AA@
  00040	45 33 c0	 xor	 r8d, r8d
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 PyErr_NewException

; 1571 :     PyDict_SetItemString(d, "Error", Error);

  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
  00052	48 8b cb	 mov	 rcx, rbx
  00055	4c 8b c0	 mov	 r8, rax
  00058	48 89 05 00 00
	00 00		 mov	 QWORD PTR Error, rax
  0005f	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1572 :     Incomplete = PyErr_NewException("binascii.Incomplete", NULL, NULL);

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@
  0006b	45 33 c0	 xor	 r8d, r8d
  0006e	33 d2		 xor	 edx, edx
  00070	e8 00 00 00 00	 call	 PyErr_NewException

; 1573 :     PyDict_SetItemString(d, "Incomplete", Incomplete);

  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GAHNLADL@Incomplete?$AA@
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	4c 8b c0	 mov	 r8, rax
  00082	48 89 05 00 00
	00 00		 mov	 QWORD PTR Incomplete, rax
  00089	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1574 :     if (PyErr_Occurred()) {

  0008e	e8 00 00 00 00	 call	 PyErr_Occurred
  00093	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00098	48 85 c0	 test	 rax, rax
  0009b	74 0a		 je	 SHORT $LN1@PyInit_bin

; 1575 :         Py_DECREF(m);

  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1576 :         m = NULL;

  000a5	33 ff		 xor	 edi, edi
$LN1@PyInit_bin:

; 1577 :     }
; 1578 :     return m;

  000a7	48 8b c7	 mov	 rax, rdi

; 1579 : }

  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
PyInit_binascii ENDP
_TEXT	ENDS
END
