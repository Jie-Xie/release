; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@FGONANPD@faulthandler?$AA@		; `string'
PUBLIC	??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@ ; `string'
PUBLIC	??_C@_0N@CKLIJFLO@_fatal_error?$AA@		; `string'
PUBLIC	??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@ ; `string'
PUBLIC	??_C@_07BBJFAOD@_sigill?$AA@			; `string'
PUBLIC	??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@ ; `string'
PUBLIC	??_C@_07JNIEKBOI@_sigfpe?$AA@			; `string'
PUBLIC	??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@ ; `string'
PUBLIC	??_C@_08LEEGKEOI@_sigabrt?$AA@			; `string'
PUBLIC	??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@ ; `string'
PUBLIC	??_C@_08BLGKFLKK@_sigsegv?$AA@			; `string'
PUBLIC	??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@ ; `string'
PUBLIC	??_C@_0L@PHHAALCD@_read_null?$AA@		; `string'
PUBLIC	??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@ ; `string'
PUBLIC	??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@ ; `string'
PUBLIC	??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@ ; `string'
PUBLIC	??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@	; `string'
PUBLIC	??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@ ; `string'
PUBLIC	??_C@_0P@HLFAMGNN@dump_traceback?$AA@		; `string'
PUBLIC	??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@ ; `string'
PUBLIC	??_C@_0L@FCNBNIPE@is_enabled?$AA@		; `string'
PUBLIC	??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@ ; `string'
PUBLIC	??_C@_07DBNODEFN@disable?$AA@			; `string'
PUBLIC	??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@ ; `string'
PUBLIC	??_C@_06OFNJOBDK@enable?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_06LGDBIFHB@repeat?$AA@			; `string'
PUBLIC	??_C@_07DDHNKDGP@timeout?$AA@			; `string'
PUBLIC	??_C@_0M@EEAOGHOB@all_threads?$AA@		; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@	; `string'
PUBLIC	??_C@_07LCKDCBKK@Aborted?$AA@			; `string'
PUBLIC	??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@ ; `string'
PUBLIC	??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@	; `string'
;	COMDAT ??_C@_0N@FGONANPD@faulthandler?$AA@
CONST	SEGMENT
??_C@_0N@FGONANPD@faulthandler?$AA@ DB 'faulthandler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@
CONST	SEGMENT
??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@ DB '_fatal_'
	DB	'error(message): call Py_FatalError(message)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKLIJFLO@_fatal_error?$AA@
CONST	SEGMENT
??_C@_0N@CKLIJFLO@_fatal_error?$AA@ DB '_fatal_error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@
CONST	SEGMENT
??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@ DB '_sigi'
	DB	'll(): raise a SIGILL signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBJFAOD@_sigill?$AA@
CONST	SEGMENT
??_C@_07BBJFAOD@_sigill?$AA@ DB '_sigill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@
CONST	SEGMENT
??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@ DB '_sigf'
	DB	'pe(): raise a SIGFPE signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNIEKBOI@_sigfpe?$AA@
CONST	SEGMENT
??_C@_07JNIEKBOI@_sigfpe?$AA@ DB '_sigfpe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@
CONST	SEGMENT
??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@ DB '_siga'
	DB	'brt(): raise a SIGABRT signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEEGKEOI@_sigabrt?$AA@
CONST	SEGMENT
??_C@_08LEEGKEOI@_sigabrt?$AA@ DB '_sigabrt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@
CONST	SEGMENT
??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@ DB '_sigs'
	DB	'egv(): raise a SIGSEGV signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLGKFLKK@_sigsegv?$AA@
CONST	SEGMENT
??_C@_08BLGKFLKK@_sigsegv?$AA@ DB '_sigsegv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@
CONST	SEGMENT
??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@ DB '_read'
	DB	'_null(release_gil=False): read from NULL, raise a SIGSEGV or '
	DB	'SIGBUS signal depending on the platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHHAALCD@_read_null?$AA@
CONST	SEGMENT
??_C@_0L@PHHAALCD@_read_null?$AA@ DB '_read_null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@
CONST	SEGMENT
??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@ DB 'cancel_du'
	DB	'mp_traceback_later():', 0aH, 'cancel the previous call to dum'
	DB	'p_traceback_later().', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@ DB 'cancel_dump_trace'
	DB	'back_later', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@
CONST	SEGMENT
??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@ DB 'dump_traceb'
	DB	'ack_later(timeout, repeat=False, file=sys.stderrn, exit=False'
	DB	'):', 0aH, 'dump the traceback of all threads in timeout secon'
	DB	'ds,', 0aH, 'or each timeout seconds if repeat is True. If exi'
	DB	't is True, call _exit(1) which is not safe.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@ DB 'dump_traceback_later', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@
CONST	SEGMENT
??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@ DB 'dump_tr'
	DB	'aceback(file=sys.stderr, all_threads=True): dump the tracebac'
	DB	'k of the current thread, or of all threads if all_threads is '
	DB	'True, into file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLFAMGNN@dump_traceback?$AA@
CONST	SEGMENT
??_C@_0P@HLFAMGNN@dump_traceback?$AA@ DB 'dump_traceback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@
CONST	SEGMENT
??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@ DB 'is'
	DB	'_enabled()->bool: check if the handler is enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCNBNIPE@is_enabled?$AA@
CONST	SEGMENT
??_C@_0L@FCNBNIPE@is_enabled?$AA@ DB 'is_enabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@
CONST	SEGMENT
??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@ DB 'disab'
	DB	'le(): disable the fault handler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBNODEFN@disable?$AA@
CONST	SEGMENT
??_C@_07DBNODEFN@disable?$AA@ DB 'disable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@
CONST	SEGMENT
??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@ DB 'enable('
	DB	'file=sys.stderr, all_threads=True): enable the fault handler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OFNJOBDK@enable?$AA@
CONST	SEGMENT
??_C@_06OFNJOBDK@enable?$AA@ DB 'enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGDBIFHB@repeat?$AA@
CONST	SEGMENT
??_C@_06LGDBIFHB@repeat?$AA@ DB 'repeat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDHNKDGP@timeout?$AA@
CONST	SEGMENT
??_C@_07DDHNKDGP@timeout?$AA@ DB 'timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEAOGHOB@all_threads?$AA@
CONST	SEGMENT
??_C@_0M@EEAOGHOB@all_threads?$AA@ DB 'all_threads', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_enable@?1??faulthandler_env_options@@9@9 DQ 0000000000000000H ; `faulthandler_env_options'::`2'::PyId_enable
	DQ	FLAT:??_C@_06OFNJOBDK@enable?$AA@
	DQ	0000000000000000H
?PyId_flush@?1??faulthandler_get_fileno@@9@9 DQ 0000000000000000H ; `faulthandler_get_fileno'::`2'::PyId_flush
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	0000000000000000H
?PyId_fileno@?1??faulthandler_get_fileno@@9@9 DQ 0000000000000000H ; `faulthandler_get_fileno'::`2'::PyId_fileno
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
faulthandler_nsignals DB 04H
CONST	ENDS
;	COMDAT ??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@
CONST	SEGMENT
??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@ DB 'Segmentation fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCKDCBKK@Aborted?$AA@
CONST	SEGMENT
??_C@_07LCKDCBKK@Aborted?$AA@ DB 'Aborted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@
CONST	SEGMENT
??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@ DB 'Floating point exce'
	DB	'ption', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@
CONST	SEGMENT
??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@ DB 'Illegal instruction', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
fatal_error DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	0ffffffffH
	DD	00H
	ORG $+8
faulthandler_handlers DD 04H
	DD	00H
	DQ	FLAT:??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@
	ORG $+16
	DD	08H
	DD	00H
	DQ	FLAT:??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@
	ORG $+16
	DD	016H
	DD	00H
	DQ	FLAT:??_C@_07LCKDCBKK@Aborted?$AA@
	ORG $+16
	DD	0bH
	DD	00H
	DQ	FLAT:??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@
	ORG $+16
?kwlist@?1??faulthandler_dump_traceback_py@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `faulthandler_dump_traceback_py'::`2'::kwlist
	DQ	FLAT:??_C@_0M@EEAOGHOB@all_threads?$AA@
	DQ	0000000000000000H
?kwlist@?1??faulthandler_enable@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `faulthandler_enable'::`2'::kwlist
	DQ	FLAT:??_C@_0M@EEAOGHOB@all_threads?$AA@
	DQ	0000000000000000H
?kwlist@?1??faulthandler_dump_traceback_later@@9@9 DQ FLAT:??_C@_07DDHNKDGP@timeout?$AA@ ; `faulthandler_dump_traceback_later'::`2'::kwlist
	DQ	FLAT:??_C@_06LGDBIFHB@repeat?$AA@
	DQ	FLAT:??_C@_04DAMGJPCA@file?$AA@
	DQ	FLAT:??_C@_04MKNBDEPB@exit?$AA@
	DQ	0000000000000000H
module_doc DB	'faulthandler module.', 00H
	ORG $+3
module_methods DQ FLAT:??_C@_06OFNJOBDK@enable?$AA@
	DQ	FLAT:faulthandler_enable
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@
	DQ	FLAT:??_C@_07DBNODEFN@disable?$AA@
	DQ	FLAT:faulthandler_disable_py
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@
	DQ	FLAT:??_C@_0L@FCNBNIPE@is_enabled?$AA@
	DQ	FLAT:faulthandler_is_enabled
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@
	DQ	FLAT:??_C@_0P@HLFAMGNN@dump_traceback?$AA@
	DQ	FLAT:faulthandler_dump_traceback_py
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@
	DQ	FLAT:??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@
	DQ	FLAT:faulthandler_dump_traceback_later
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@
	DQ	FLAT:??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
	DQ	FLAT:faulthandler_cancel_dump_traceback_later_py
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@
	DQ	FLAT:??_C@_0L@PHHAALCD@_read_null?$AA@
	DQ	FLAT:faulthandler_read_null
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@
	DQ	FLAT:??_C@_08BLGKFLKK@_sigsegv?$AA@
	DQ	FLAT:faulthandler_sigsegv
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@
	DQ	FLAT:??_C@_08LEEGKEOI@_sigabrt?$AA@
	DQ	FLAT:faulthandler_sigabrt
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@
	DQ	FLAT:??_C@_07JNIEKBOI@_sigfpe?$AA@
	DQ	FLAT:faulthandler_sigfpe
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@
	DQ	FLAT:??_C@_07BBJFAOD@_sigill?$AA@
	DQ	FLAT:faulthandler_sigill
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@
	DQ	FLAT:??_C@_0N@CKLIJFLO@_fatal_error?$AA@
	DQ	FLAT:faulthandler_fatal_error_py
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_def DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
	DQ	FLAT:module_doc
	DQ	0000000000000000H
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	FLAT:faulthandler_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@ ; `string'
PUBLIC	??_C@_06FJGNEBG@stderr?$AA@			; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PySys_GetObject:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\faulthandler.c
pdata	SEGMENT
$pdata$faulthandler_get_fileno DD imagerel faulthandler_get_fileno
	DD	imagerel faulthandler_get_fileno+153
	DD	imagerel $unwind$faulthandler_get_fileno
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$faulthandler_get_fileno DD imagerel faulthandler_get_fileno+153
	DD	imagerel faulthandler_get_fileno+279
	DD	imagerel $chain$2$faulthandler_get_fileno
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$faulthandler_get_fileno DD imagerel faulthandler_get_fileno+279
	DD	imagerel faulthandler_get_fileno+300
	DD	imagerel $chain$3$faulthandler_get_fileno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$faulthandler_get_fileno DD 021H
	DD	imagerel faulthandler_get_fileno
	DD	imagerel faulthandler_get_fileno+153
	DD	imagerel $unwind$faulthandler_get_fileno
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$faulthandler_get_fileno DD 020521H
	DD	077405H
	DD	imagerel faulthandler_get_fileno
	DD	imagerel faulthandler_get_fileno+153
	DD	imagerel $unwind$faulthandler_get_fileno
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_get_fileno DD 086e01H
	DD	08c46eH
	DD	066469H
	DD	09340aH
	DD	05006320aH
xdata	ENDS
;	COMDAT ??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@
CONST	SEGMENT
??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@ DB 'file'
	DB	'.fileno() is not a valid file descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@
CONST	SEGMENT
??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@ DB 'unable to get sy'
	DB	's.stderr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJGNEBG@stderr?$AA@
CONST	SEGMENT
??_C@_06FJGNEBG@stderr?$AA@ DB 'stderr', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_get_fileno
_TEXT	SEGMENT
file$ = 48
p_fd$ = 56
faulthandler_get_fileno PROC				; COMDAT

; 132  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 133  :     PyObject *result;
; 134  :     _Py_IDENTIFIER(fileno);
; 135  :     _Py_IDENTIFIER(flush);
; 136  :     long fd_long;
; 137  :     int fd;
; 138  : 
; 139  :     if (file == NULL || file == Py_None) {

  00010	48 85 c9	 test	 rcx, rcx
  00013	74 0c		 je	 SHORT $LN8@faulthandl
  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001c	48 3b c8	 cmp	 rcx, rax
  0001f	75 34		 jne	 SHORT $LN7@faulthandl
$LN8@faulthandl:

; 140  :         file = PySys_GetObject("stderr");

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06FJGNEBG@stderr?$AA@
  00028	e8 00 00 00 00	 call	 PySys_GetObject
  0002d	48 8b d8	 mov	 rbx, rax

; 141  :         if (file == NULL) {

  00030	48 85 c0	 test	 rax, rax
  00033	75 20		 jne	 SHORT $LN7@faulthandl

; 142  :             PyErr_SetString(PyExc_RuntimeError, "unable to get sys.stderr");

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@
  00043	e8 00 00 00 00	 call	 PyErr_SetString

; 143  :             return NULL;

  00048	33 c0		 xor	 eax, eax

; 174  : }

  0004a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5d		 pop	 rbp
  00054	c3		 ret	 0
$LN7@faulthandl:

; 144  :         }
; 145  :     }
; 146  : 
; 147  :     result = _PyObject_CallMethodId(file, &PyId_fileno, "");

  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0005b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00064	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00069	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  0006e	4c 8b 24 c8	 mov	 r12, QWORD PTR [rax+rcx*8]
  00072	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_fileno@?1??faulthandler_get_fileno@@9@9
  00077	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007e	49 03 d4	 add	 rdx, r12
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00089	48 8b f0	 mov	 rsi, rax

; 148  :     if (result == NULL)

  0008c	48 85 c0	 test	 rax, rax
  0008f	0f 84 82 00 00
	00		 je	 $LN13@faulthandl
$LN6@faulthandl:

; 149  :         return NULL;
; 150  : 
; 151  :     fd = -1;
; 152  :     if (PyLong_Check(result)) {

  00095	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00099	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0009e	83 cf ff	 or	 edi, -1
  000a1	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  000ab	74 10		 je	 SHORT $LN4@faulthandl

; 153  :         fd_long = PyLong_AsLong(result);

  000ad	48 8b ce	 mov	 rcx, rsi
  000b0	e8 00 00 00 00	 call	 PyLong_AsLong

; 154  :         if (0 <= fd_long && fd_long < INT_MAX)

  000b5	3d fe ff ff 7f	 cmp	 eax, 2147483646		; 7ffffffeH
  000ba	0f 46 f8	 cmovbe	 edi, eax
$LN4@faulthandl:

; 155  :             fd = (int)fd_long;
; 156  :     }
; 157  :     Py_DECREF(result);

  000bd	48 8b ce	 mov	 rcx, rsi
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 158  : 
; 159  :     if (fd == -1) {

  000c5	83 ff ff	 cmp	 edi, -1
  000c8	75 17		 jne	 SHORT $LN3@faulthandl

; 160  :         PyErr_SetString(PyExc_RuntimeError,
; 161  :                         "file.fileno() is not a valid file descriptor");

  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@
  000d8	e8 00 00 00 00	 call	 PyErr_SetString

; 162  :         return NULL;

  000dd	33 c0		 xor	 eax, eax
  000df	eb 31		 jmp	 SHORT $LN14@faulthandl
$LN3@faulthandl:

; 163  :     }
; 164  : 
; 165  :     result = _PyObject_CallMethodId(file, &PyId_flush, "");

  000e1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_flush@?1??faulthandler_get_fileno@@9@9
  000e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000ed	48 8b cb	 mov	 rcx, rbx
  000f0	49 03 d4	 add	 rdx, r12
  000f3	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 166  :     if (result != NULL)

  000f8	48 85 c0	 test	 rax, rax
  000fb	74 0a		 je	 SHORT $LN2@faulthandl

; 167  :         Py_DECREF(result);

  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 _Py_DecRef

; 168  :     else {

  00105	eb 05		 jmp	 SHORT $LN1@faulthandl
$LN2@faulthandl:

; 169  :         /* ignore flush() error */
; 170  :         PyErr_Clear();

  00107	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@faulthandl:

; 171  :     }
; 172  :     *p_fd = fd;

  0010c	89 7d 00	 mov	 DWORD PTR [rbp], edi

; 173  :     return file;

  0010f	48 8b c3	 mov	 rax, rbx
$LN14@faulthandl:
  00112	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN13@faulthandl:
  00117	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0011c	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 174  : }

  00121	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00126	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012a	5d		 pop	 rbp
  0012b	c3		 ret	 0
faulthandler_get_fileno ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@ ; `string'
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_thread_state DD imagerel get_thread_state
	DD	imagerel get_thread_state+40
	DD	imagerel $unwind$get_thread_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_thread_state DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@
CONST	SEGMENT
??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@ DB 'unable to g'
	DB	'et the current thread state', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_thread_state
_TEXT	SEGMENT
get_thread_state PROC					; COMDAT

; 180  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 181  :     PyThreadState *tstate = PyThreadState_Get();

  00004	e8 00 00 00 00	 call	 PyThreadState_Get

; 182  :     if (tstate == NULL) {

  00009	48 85 c0	 test	 rax, rax
  0000c	75 15		 jne	 SHORT $LN1@get_thread

; 183  :         PyErr_SetString(PyExc_RuntimeError,
; 184  :                         "unable to get the current thread state");

  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@
  0001c	e8 00 00 00 00	 call	 PyErr_SetString

; 185  :         return NULL;

  00021	33 c0		 xor	 eax, eax
$LN1@get_thread:

; 186  :     }
; 187  :     return tstate;
; 188  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
get_thread_state ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@	; `string'
EXTRN	_Py_DumpTraceback:PROC
EXTRN	_Py_DumpTracebackThreads:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_dump_traceback_py DD imagerel faulthandler_dump_traceback_py
	DD	imagerel faulthandler_dump_traceback_py+250
	DD	imagerel $unwind$faulthandler_dump_traceback_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_dump_traceback_py DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@
CONST	SEGMENT
??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@ DB '|Oi:dump_traceback', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
CONST	ENDS
;	COMDAT faulthandler_dump_traceback_py
_TEXT	SEGMENT
fd$ = 48
file$ = 56
self$ = 80
args$ = 88
kwargs$ = 96
all_threads$ = 104
faulthandler_dump_traceback_py PROC			; COMDAT

; 193  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	49 8b c0	 mov	 rax, r8
  00007	4c 8b d2	 mov	 r10, rdx

; 194  :     static char *kwlist[] = {"file", "all_threads", NULL};
; 195  :     PyObject *file = NULL;
; 196  :     int all_threads = 1;
; 197  :     PyThreadState *tstate;
; 198  :     const char *errmsg;
; 199  :     int fd;
; 200  : 
; 201  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 202  :         "|Oi:dump_traceback", kwlist,
; 203  :         &file, &all_threads))

  0000a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR all_threads$[rsp]
  0000f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00014	48 8d 4c 24 38	 lea	 rcx, QWORD PTR file$[rsp]
  00019	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_dump_traceback_py@@9@9
  00020	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00025	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@
  0002c	48 8b d0	 mov	 rdx, rax
  0002f	49 8b ca	 mov	 rcx, r10
  00032	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR file$[rsp], 0
  0003b	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR all_threads$[rsp], 1
  00043	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00048	85 c0		 test	 eax, eax

; 204  :         return NULL;

  0004a	74 4e		 je	 SHORT $LN13@faulthandl@2

; 205  : 
; 206  :     file = faulthandler_get_fileno(file, &fd);

  0004c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00051	48 8d 54 24 30	 lea	 rdx, QWORD PTR fd$[rsp]
  00056	e8 00 00 00 00	 call	 faulthandler_get_fileno
  0005b	48 89 44 24 38	 mov	 QWORD PTR file$[rsp], rax

; 207  :     if (file == NULL)

  00060	48 85 c0	 test	 rax, rax

; 208  :         return NULL;

  00063	74 35		 je	 SHORT $LN13@faulthandl@2

; 209  : 
; 210  :     tstate = get_thread_state();

  00065	e8 00 00 00 00	 call	 get_thread_state

; 211  :     if (tstate == NULL)

  0006a	48 85 c0	 test	 rax, rax

; 212  :         return NULL;

  0006d	74 2b		 je	 SHORT $LN13@faulthandl@2

; 213  : 
; 214  :     if (all_threads) {

  0006f	83 7c 24 68 00	 cmp	 DWORD PTR all_threads$[rsp], 0

; 215  :         errmsg = _Py_DumpTracebackThreads(fd, tstate->interp, tstate);

  00074	8b 4c 24 30	 mov	 ecx, DWORD PTR fd$[rsp]
  00078	74 27		 je	 SHORT $LN3@faulthandl@2
  0007a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0007e	4c 8b c0	 mov	 r8, rax
  00081	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads

; 216  :         if (errmsg != NULL) {

  00086	48 85 c0	 test	 rax, rax
  00089	74 1e		 je	 SHORT $LN1@faulthandl@2

; 217  :             PyErr_SetString(PyExc_RuntimeError, errmsg);

  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00092	48 8b d0	 mov	 rdx, rax
  00095	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@faulthandl@2:

; 218  :             return NULL;

  0009a	33 c0		 xor	 eax, eax

; 225  : }

  0009c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a0	c3		 ret	 0
$LN3@faulthandl@2:

; 219  :         }
; 220  :     }
; 221  :     else {
; 222  :         _Py_DumpTraceback(fd, tstate);

  000a1	48 8b d0	 mov	 rdx, rax
  000a4	e8 00 00 00 00	 call	 _Py_DumpTraceback
$LN1@faulthandl@2:

; 223  :     }
; 224  :     Py_RETURN_NONE;

  000a9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ae	85 c0		 test	 eax, eax
  000b0	75 3c		 jne	 SHORT $LN10@faulthandl@2
  000b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000cd	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000da	85 c0		 test	 eax, eax
  000dc	75 09		 jne	 SHORT $LN9@faulthandl@2
  000de	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000e5	74 07		 je	 SHORT $LN10@faulthandl@2
$LN9@faulthandl@2:
  000e7	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@faulthandl@2:
  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 225  : }

  000f5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f9	c3		 ret	 0
faulthandler_dump_traceback_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@ ; `string'
EXTRN	__imp_raise:PROC
EXTRN	PyGILState_GetThisThreadState:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp_signal:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_fatal_error DD imagerel faulthandler_fatal_error
	DD	imagerel faulthandler_fatal_error+44
	DD	imagerel $unwind$faulthandler_fatal_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$faulthandler_fatal_error DD imagerel faulthandler_fatal_error+44
	DD	imagerel faulthandler_fatal_error+192
	DD	imagerel $chain$0$faulthandler_fatal_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$faulthandler_fatal_error DD imagerel faulthandler_fatal_error+192
	DD	imagerel faulthandler_fatal_error+263
	DD	imagerel $chain$1$faulthandler_fatal_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$faulthandler_fatal_error DD 021H
	DD	imagerel faulthandler_fatal_error
	DD	imagerel faulthandler_fatal_error+44
	DD	imagerel $unwind$faulthandler_fatal_error
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$faulthandler_fatal_error DD 020521H
	DD	067405H
	DD	imagerel faulthandler_fatal_error
	DD	imagerel faulthandler_fatal_error+44
	DD	imagerel $unwind$faulthandler_fatal_error
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_fatal_error DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@
CONST	SEGMENT
??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@ DB 'Fatal Python error: '
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_fatal_error
_TEXT	SEGMENT
signum$ = 48
faulthandler_fatal_error PROC				; COMDAT

; 243  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 244  :     const int fd = fatal_error.fd;

  0000f	8b 35 10 00 00
	00		 mov	 esi, DWORD PTR fatal_error+16
  00015	8b d9		 mov	 ebx, ecx

; 245  :     unsigned int i;
; 246  :     fault_handler_t *handler = NULL;
; 247  :     PyThreadState *tstate;
; 248  :     int save_errno = errno;

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 249  : 
; 250  :     if (!fatal_error.enabled)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  00024	8b 28		 mov	 ebp, DWORD PTR [rax]
  00026	0f 84 cb 00 00
	00		 je	 $LN11@faulthandl@3

; 251  :         return;
; 252  : 
; 253  :     for (i=0; i < faulthandler_nsignals; i++) {

  0002c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00031	33 d2		 xor	 edx, edx
  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:faulthandler_handlers
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL9@faulthandl@3:

; 254  :         handler = &faulthandler_handlers[i];

  00040	48 8b f8	 mov	 rdi, rax

; 255  :         if (handler->signum == signum)

  00043	39 18		 cmp	 DWORD PTR [rax], ebx
  00045	74 0b		 je	 SHORT $LN14@faulthandl@3

; 251  :         return;
; 252  : 
; 253  :     for (i=0; i < faulthandler_nsignals; i++) {

  00047	ff c2		 inc	 edx
  00049	48 83 c0 20	 add	 rax, 32			; 00000020H
  0004d	83 fa 04	 cmp	 edx, 4
  00050	72 ee		 jb	 SHORT $LL9@faulthandl@3
$LN14@faulthandl@3:

; 256  :             break;
; 257  :     }
; 258  :     if (handler == NULL) {
; 259  :         /* faulthandler_nsignals == 0 (unlikely) */
; 260  :         return;
; 261  :     }
; 262  : 
; 263  :     /* restore the previous handler */
; 264  : #ifdef HAVE_SIGACTION
; 265  :     (void)sigaction(signum, &handler->previous, NULL);
; 266  : #else
; 267  :     (void)signal(signum, handler->previous);

  00052	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00056	8b cb		 mov	 ecx, ebx
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 268  : #endif
; 269  :     handler->enabled = 0;
; 270  : 
; 271  :     PUTS(fd, "Fatal Python error: ");

  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@
  00065	41 b8 14 00 00
	00		 mov	 r8d, 20
  0006b	8b ce		 mov	 ecx, esi
  0006d	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [rdi+4], 0
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 272  :     PUTS(fd, handler->name);

  0007a	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0007e	48 83 c9 ff	 or	 rcx, -1
  00082	48 8b fa	 mov	 rdi, rdx
  00085	33 c0		 xor	 eax, eax
  00087	f2 ae		 repne scasb
  00089	48 f7 d1	 not	 rcx
  0008c	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  00090	8b ce		 mov	 ecx, esi
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 273  :     PUTS(fd, "\n\n");

  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PHMGELLB@?6?6?$AA@
  0009f	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a5	8b ce		 mov	 ecx, esi
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 274  : 
; 275  : #ifdef WITH_THREAD
; 276  :     /* SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL are synchronous signals and
; 277  :        are thus delivered to the thread that caused the fault. Get the Python
; 278  :        thread state of the current thread.
; 279  : 
; 280  :        PyThreadState_Get() doesn't give the state of the thread that caused the
; 281  :        fault if the thread released the GIL, and so this function cannot be
; 282  :        used. Read the thread local storage (TLS) instead: call
; 283  :        PyGILState_GetThisThreadState(). */
; 284  :     tstate = PyGILState_GetThisThreadState();

  000ad	e8 00 00 00 00	 call	 PyGILState_GetThisThreadState

; 285  : #else
; 286  :     tstate = PyThreadState_Get();
; 287  : #endif
; 288  : 
; 289  :     if (fatal_error.all_threads)

  000b2	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR fatal_error+20, 0
  000b9	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000be	74 13		 je	 SHORT $LN4@faulthandl@3

; 290  :         _Py_DumpTracebackThreads(fd, fatal_error.interp, tstate);

  000c0	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR fatal_error+24
  000c7	4c 8b c0	 mov	 r8, rax
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads

; 291  :     else {

  000d1	eb 0f		 jmp	 SHORT $LN2@faulthandl@3
$LN4@faulthandl@3:

; 292  :         if (tstate != NULL)

  000d3	48 85 c0	 test	 rax, rax
  000d6	74 0a		 je	 SHORT $LN2@faulthandl@3

; 293  :             _Py_DumpTraceback(fd, tstate);

  000d8	48 8b d0	 mov	 rdx, rax
  000db	8b ce		 mov	 ecx, esi
  000dd	e8 00 00 00 00	 call	 _Py_DumpTraceback
$LN2@faulthandl@3:

; 294  :     }
; 295  : 
; 296  :     errno = save_errno;

  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e8	89 28		 mov	 DWORD PTR [rax], ebp

; 297  : #ifdef MS_WINDOWS
; 298  :     if (signum == SIGSEGV) {

  000ea	83 fb 0b	 cmp	 ebx, 11
  000ed	74 08		 je	 SHORT $LN11@faulthandl@3

; 299  :         /* don't explicitly call the previous handler for SIGSEGV in this signal
; 300  :            handler, because the Windows signal handler would not be called */
; 301  :         return;
; 302  :     }
; 303  : #endif
; 304  :     /* call the previous signal handler: it is called immediately if we use
; 305  :        sigaction() thanks to SA_NODEFER flag, otherwise it is deferred */
; 306  :     raise(signum);

  000ef	8b cb		 mov	 ecx, ebx
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise
$LN11@faulthandl@3:

; 307  : }

  000f7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000fc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00101	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00105	5e		 pop	 rsi
  00106	c3		 ret	 0
faulthandler_fatal_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@		; `string'
EXTRN	PyErr_SetFromErrno:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_enable DD imagerel faulthandler_enable
	DD	imagerel faulthandler_enable+109
	DD	imagerel $unwind$faulthandler_enable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$faulthandler_enable DD imagerel faulthandler_enable+109
	DD	imagerel faulthandler_enable+370
	DD	imagerel $chain$0$faulthandler_enable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$faulthandler_enable DD imagerel faulthandler_enable+370
	DD	imagerel faulthandler_enable+395
	DD	imagerel $chain$2$faulthandler_enable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$faulthandler_enable DD 020021H
	DD	0a3400H
	DD	imagerel faulthandler_enable
	DD	imagerel faulthandler_enable+109
	DD	imagerel $unwind$faulthandler_enable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$faulthandler_enable DD 020521H
	DD	0a3405H
	DD	imagerel faulthandler_enable
	DD	imagerel faulthandler_enable+109
	DD	imagerel $unwind$faulthandler_enable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_enable DD 020601H
	DD	070027206H
xdata	ENDS
;	COMDAT ??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@
CONST	SEGMENT
??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@ DB '|Oi:enable', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
CONST	ENDS
;	COMDAT faulthandler_enable
_TEXT	SEGMENT
fd$ = 48
file$ = 56
self$ = 80
args$ = 88
kwargs$ = 96
all_threads$ = 104
faulthandler_enable PROC				; COMDAT

; 313  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	49 8b c0	 mov	 rax, r8
  00009	4c 8b d2	 mov	 r10, rdx

; 314  :     static char *kwlist[] = {"file", "all_threads", NULL};
; 315  :     PyObject *file = NULL;
; 316  :     int all_threads = 1;
; 317  :     unsigned int i;
; 318  :     fault_handler_t *handler;
; 319  : #ifdef HAVE_SIGACTION
; 320  :     struct sigaction action;
; 321  : #endif
; 322  :     int err;
; 323  :     int fd;
; 324  :     PyThreadState *tstate;
; 325  : 
; 326  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 327  :         "|Oi:enable", kwlist, &file, &all_threads))

  0000c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR all_threads$[rsp]
  00011	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00016	48 8d 4c 24 38	 lea	 rcx, QWORD PTR file$[rsp]
  0001b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_enable@@9@9
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@
  0002e	33 ff		 xor	 edi, edi
  00030	49 8b ca	 mov	 rcx, r10
  00033	48 8b d0	 mov	 rdx, rax
  00036	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR all_threads$[rsp], 1
  0003e	48 89 7c 24 38	 mov	 QWORD PTR file$[rsp], rdi
  00043	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00048	85 c0		 test	 eax, eax
  0004a	75 08		 jne	 SHORT $LN12@faulthandl@4
$LN24@faulthandl@4:

; 328  :         return NULL;

  0004c	33 c0		 xor	 eax, eax

; 377  : }

  0004e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN12@faulthandl@4:

; 329  : 
; 330  :     file = faulthandler_get_fileno(file, &fd);

  00054	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00059	48 8d 54 24 30	 lea	 rdx, QWORD PTR fd$[rsp]
  0005e	e8 00 00 00 00	 call	 faulthandler_get_fileno
  00063	48 89 44 24 38	 mov	 QWORD PTR file$[rsp], rax

; 331  :     if (file == NULL)

  00068	48 85 c0	 test	 rax, rax

; 332  :         return NULL;

  0006b	74 df		 je	 SHORT $LN24@faulthandl@4

; 333  : 
; 334  :     tstate = get_thread_state();

  0006d	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00072	e8 00 00 00 00	 call	 get_thread_state
  00077	48 8b d8	 mov	 rbx, rax

; 335  :     if (tstate == NULL)

  0007a	48 85 c0	 test	 rax, rax

; 336  :         return NULL;

  0007d	0f 84 fb 00 00
	00		 je	 $LN23@faulthandl@4

; 337  : 
; 338  :     Py_XDECREF(fatal_error.file);

  00083	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR fatal_error+8
  0008a	48 85 c9	 test	 rcx, rcx
  0008d	74 05		 je	 SHORT $LN8@faulthandl@4
  0008f	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@faulthandl@4:

; 339  :     Py_INCREF(file);

  00094	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00099	e8 00 00 00 00	 call	 _Py_IncRef

; 340  :     fatal_error.file = file;
; 341  :     fatal_error.fd = fd;
; 342  :     fatal_error.all_threads = all_threads;
; 343  :     fatal_error.interp = tstate->interp;
; 344  : 
; 345  :     if (!fatal_error.enabled) {

  0009e	39 3d 00 00 00
	00		 cmp	 DWORD PTR fatal_error, edi
  000a4	8b 44 24 30	 mov	 eax, DWORD PTR fd$[rsp]
  000a8	4c 8b 5c 24 38	 mov	 r11, QWORD PTR file$[rsp]
  000ad	89 05 10 00 00
	00		 mov	 DWORD PTR fatal_error+16, eax
  000b3	8b 44 24 68	 mov	 eax, DWORD PTR all_threads$[rsp]
  000b7	89 05 14 00 00
	00		 mov	 DWORD PTR fatal_error+20, eax
  000bd	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000c1	4c 89 1d 08 00
	00 00		 mov	 QWORD PTR fatal_error+8, r11
  000c8	48 89 05 18 00
	00 00		 mov	 QWORD PTR fatal_error+24, rax
  000cf	75 4a		 jne	 SHORT $LN2@faulthandl@4

; 346  :         fatal_error.enabled = 1;

  000d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR fatal_error, 1
  000db	48 8d 1d 04 00
	00 00		 lea	 rbx, OFFSET FLAT:faulthandler_handlers+4
  000e2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@faulthandl@4:

; 347  : 
; 348  :         for (i=0; i < faulthandler_nsignals; i++) {
; 349  :             handler = &faulthandler_handlers[i];
; 350  : #ifdef HAVE_SIGACTION
; 351  :             action.sa_handler = faulthandler_fatal_error;
; 352  :             sigemptyset(&action.sa_mask);
; 353  :             /* Do not prevent the signal from being received from within
; 354  :                its own signal handler */
; 355  :             action.sa_flags = SA_NODEFER;
; 356  : #ifdef HAVE_SIGALTSTACK
; 357  :             if (stack.ss_sp != NULL) {
; 358  :                 /* Call the signal handler on an alternate signal stack
; 359  :                    provided by sigaltstack() */
; 360  :                 action.sa_flags |= SA_ONSTACK;
; 361  :             }
; 362  : #endif
; 363  :             err = sigaction(handler->signum, &action, &handler->previous);
; 364  : #else
; 365  :             handler->previous = signal(handler->signum,
; 366  :                                        faulthandler_fatal_error);

  000f0	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:faulthandler_fatal_error
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal
  00100	48 89 43 0c	 mov	 QWORD PTR [rbx+12], rax

; 367  :             err = (handler->previous == SIG_ERR);

  00104	48 83 f8 ff	 cmp	 rax, -1

; 368  : #endif
; 369  :             if (err) {

  00108	74 68		 je	 SHORT $LN20@faulthandl@4

; 372  :             }
; 373  :             handler->enabled = 1;

  0010a	ff c7		 inc	 edi
  0010c	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1
  00112	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00116	83 ff 04	 cmp	 edi, 4
  00119	72 d5		 jb	 SHORT $LL4@faulthandl@4
$LN2@faulthandl@4:

; 374  :         }
; 375  :     }
; 376  :     Py_RETURN_NONE;

  0011b	e8 00 00 00 00	 call	 _Py_PXCTX
  00120	85 c0		 test	 eax, eax
  00122	75 3c		 jne	 SHORT $LN16@faulthandl@4
  00124	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00139	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0013f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00147	e8 00 00 00 00	 call	 _PyParallel_Guard
  0014c	85 c0		 test	 eax, eax
  0014e	75 09		 jne	 SHORT $LN15@faulthandl@4
  00150	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00157	74 07		 je	 SHORT $LN16@faulthandl@4
$LN15@faulthandl@4:
  00159	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN16@faulthandl@4:
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00167	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 377  : }

  0016c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00170	5f		 pop	 rdi
  00171	c3		 ret	 0
$LN20@faulthandl@4:

; 370  :                 PyErr_SetFromErrno(PyExc_RuntimeError);

  00172	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00179	e8 00 00 00 00	 call	 PyErr_SetFromErrno
$LN23@faulthandl@4:

; 371  :                 return NULL;

  0017e	33 c0		 xor	 eax, eax
  00180	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 377  : }

  00185	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00189	5f		 pop	 rdi
  0018a	c3		 ret	 0
faulthandler_enable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@	; `string'
PUBLIC	??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_disable DD imagerel faulthandler_disable
	DD	imagerel faulthandler_disable+20
	DD	imagerel $unwind$faulthandler_disable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$faulthandler_disable DD imagerel faulthandler_disable+20
	DD	imagerel faulthandler_disable+81
	DD	imagerel $chain$0$faulthandler_disable
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$faulthandler_disable DD imagerel faulthandler_disable+81
	DD	imagerel faulthandler_disable+281
	DD	imagerel $chain$1$faulthandler_disable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$faulthandler_disable DD 021H
	DD	imagerel faulthandler_disable
	DD	imagerel faulthandler_disable+20
	DD	imagerel $unwind$faulthandler_disable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$faulthandler_disable DD 020521H
	DD	087405H
	DD	imagerel faulthandler_disable
	DD	imagerel faulthandler_disable+20
	DD	imagerel $unwind$faulthandler_disable
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_disable DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@
CONST	SEGMENT
??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@ DB 'faulthandler_disable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
CONST	SEGMENT
??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@ DB '..\Modules\fau'
	DB	'lthandler.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
CONST	ENDS
;	COMDAT faulthandler_disable
_TEXT	SEGMENT
faulthandler_disable PROC				; COMDAT

; 381  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 382  :     unsigned int i;
; 383  :     fault_handler_t *handler;
; 384  : 
; 385  :     if (fatal_error.enabled) {

  0000a	33 f6		 xor	 esi, esi
  0000c	39 35 00 00 00
	00		 cmp	 DWORD PTR fatal_error, esi
  00012	74 3d		 je	 SHORT $LN4@faulthandl@5

; 386  :         fatal_error.enabled = 0;

  00014	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00019	89 35 00 00 00
	00		 mov	 DWORD PTR fatal_error, esi
  0001f	48 8d 1d 04 00
	00 00		 lea	 rbx, OFFSET FLAT:faulthandler_handlers+4
  00026	8d 7e 04	 lea	 edi, QWORD PTR [rsi+4]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@faulthandl@5:

; 388  :             handler = &faulthandler_handlers[i];
; 389  :             if (!handler->enabled)

  00030	39 33		 cmp	 DWORD PTR [rbx], esi
  00032	74 0f		 je	 SHORT $LN7@faulthandl@5

; 390  :                 continue;
; 391  : #ifdef HAVE_SIGACTION
; 392  :             (void)sigaction(handler->signum, &handler->previous, NULL);
; 393  : #else
; 394  :             (void)signal(handler->signum, handler->previous);

  00034	48 8b 53 0c	 mov	 rdx, QWORD PTR [rbx+12]
  00038	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 395  : #endif
; 396  :             handler->enabled = 0;

  00041	89 33		 mov	 DWORD PTR [rbx], esi
$LN7@faulthandl@5:

; 387  :         for (i=0; i < faulthandler_nsignals; i++) {

  00043	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00047	48 ff cf	 dec	 rdi
  0004a	75 e4		 jne	 SHORT $LL8@faulthandl@5
  0004c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN4@faulthandl@5:

; 397  :         }
; 398  :     }
; 399  : 
; 400  :     Py_CLEAR(fatal_error.file);

  00051	4c 8b 0d 08 00
	00 00		 mov	 r9, QWORD PTR fatal_error+8
  00058	4d 85 c9	 test	 r9, r9
  0005b	0f 84 ad 00 00
	00		 je	 $LN3@faulthandl@5
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@
  0006f	41 b8 90 01 00
	00		 mov	 r8d, 400		; 00000190H
  00075	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00082	85 c0		 test	 eax, eax
  00084	0f 85 84 00 00
	00		 jne	 $LN3@faulthandl@5
  0008a	48 8b 1d 08 00
	00 00		 mov	 rbx, QWORD PTR fatal_error+8
  00091	48 89 35 08 00
	00 00		 mov	 QWORD PTR fatal_error+8, rsi
  00098	e8 00 00 00 00	 call	 _Py_PXCTX
  0009d	85 c0		 test	 eax, eax
  0009f	75 6d		 jne	 SHORT $LN3@faulthandl@5
  000a1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000a5	a8 20		 test	 al, 32			; 00000020H
  000a7	75 5d		 jne	 SHORT $LN16@faulthandl@5
  000a9	84 c0		 test	 al, al
  000ab	78 59		 js	 SHORT $LN16@faulthandl@5
  000ad	a8 02		 test	 al, 2
  000af	75 5d		 jne	 SHORT $LN3@faulthandl@5
  000b1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000b5	75 57		 jne	 SHORT $LN3@faulthandl@5
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	4c 8b cb	 mov	 r9, rbx
  000c8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000ce	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000db	48 8b cb	 mov	 rcx, rbx
  000de	85 c0		 test	 eax, eax
  000e0	74 0f		 je	 SHORT $LN21@faulthandl@5

; 401  : }

  000e2	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000e7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000eb	5e		 pop	 rsi
  000ec	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 397  :         }
; 398  :     }
; 399  : 
; 400  :     Py_CLEAR(fatal_error.file);

$LN21@faulthandl@5:
  000f1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 401  : }

  000f5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000fa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000fe	5e		 pop	 rsi
  000ff	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 397  :         }
; 398  :     }
; 399  : 
; 400  :     Py_CLEAR(fatal_error.file);

$LN16@faulthandl@5:
  00106	48 8b cb	 mov	 rcx, rbx
  00109	e8 00 00 00 00	 call	 Px_DecRef
$LN3@faulthandl@5:

; 401  : }

  0010e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00113	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00117	5e		 pop	 rsi
  00118	c3		 ret	 0
faulthandler_disable ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_disable_py DD imagerel faulthandler_disable_py
	DD	imagerel faulthandler_disable_py+180
	DD	imagerel $unwind$faulthandler_disable_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_disable_py DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT faulthandler_disable_py
_TEXT	SEGMENT
self$ = 64
faulthandler_disable_py PROC				; COMDAT

; 405  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 406  :     if (!fatal_error.enabled) {

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  0000b	75 51		 jne	 SHORT $LN1@faulthandl@6

; 407  :         Py_INCREF(Py_False);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	75 3c		 jne	 SHORT $LN5@faulthandl@6
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00031	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00039	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003e	85 c0		 test	 eax, eax
  00040	75 09		 jne	 SHORT $LN4@faulthandl@6
  00042	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00049	74 07		 je	 SHORT $LN5@faulthandl@6
$LN4@faulthandl@6:
  0004b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN5@faulthandl@6:

; 408  :         return Py_False;

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 413  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN1@faulthandl@6:

; 409  :     }
; 410  :     faulthandler_disable();

  0005e	e8 00 00 00 00	 call	 faulthandler_disable

; 411  :     Py_INCREF(Py_True);

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 3c		 jne	 SHORT $LN9@faulthandl@6
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 09		 jne	 SHORT $LN8@faulthandl@6
  00098	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  0009f	74 07		 je	 SHORT $LN9@faulthandl@6
$LN8@faulthandl@6:
  000a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN9@faulthandl@6:

; 412  :     return Py_True;

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 413  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
faulthandler_disable_py ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT faulthandler_is_enabled
_TEXT	SEGMENT
self$ = 8
faulthandler_is_enabled PROC				; COMDAT

; 418  :     return PyBool_FromLong(fatal_error.enabled);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fatal_error

; 419  : }

  00006	e9 00 00 00 00	 jmp	 PyBool_FromLong
faulthandler_is_enabled ENDP
_TEXT	ENDS
EXTRN	PyThread_release_lock:PROC
EXTRN	__imp__exit:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	PyThread_acquire_lock_timed:PROC
_BSS	SEGMENT
thread	DB	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_thread DD imagerel faulthandler_thread
	DD	imagerel faulthandler_thread+174
	DD	imagerel $unwind$faulthandler_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_thread DD 030901H
	DD	043409H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT faulthandler_thread
_TEXT	SEGMENT
unused$ = 48
faulthandler_thread PROC				; COMDAT

; 425  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@faulthandl@7:

; 426  :     PyLockStatus st;
; 427  :     const char* errmsg;
; 428  :     PyThreadState *current;
; 429  :     int ok;
; 430  : #if defined(HAVE_PTHREAD_SIGMASK) && !defined(HAVE_BROKEN_PTHREAD_SIGMASK)
; 431  :     sigset_t set;
; 432  : 
; 433  :     /* we don't want to receive any signal */
; 434  :     sigfillset(&set);
; 435  :     pthread_sigmask(SIG_SETMASK, &set, NULL);
; 436  : #endif
; 437  : 
; 438  :     do {
; 439  :         st = PyThread_acquire_lock_timed(thread.cancel_event,
; 440  :                                          thread.timeout_us, 0);

  00010	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR thread+16
  00017	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	e8 00 00 00 00	 call	 PyThread_acquire_lock_timed

; 441  :         if (st == PY_LOCK_ACQUIRED) {

  00026	83 f8 01	 cmp	 eax, 1
  00029	74 62		 je	 SHORT $LN10@faulthandl@7

; 443  :             break;
; 444  :         }
; 445  :         /* Timeout => dump traceback */
; 446  :         assert(st == PY_LOCK_FAILURE);
; 447  : 
; 448  :         /* get the thread holding the GIL, NULL if no thread hold the GIL */
; 449  :         current = _Py_atomic_load_relaxed(&_PyThreadState_Current);
; 450  : 
; 451  :         write(thread.fd, thread.header, thread.header_len);

  0002b	44 8b 05 38 00
	00 00		 mov	 r8d, DWORD PTR thread+56
  00032	48 8b 15 30 00
	00 00		 mov	 rdx, QWORD PTR thread+48
  00039	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR thread+8
  0003f	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyThreadState_Current
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 452  : 
; 453  :         errmsg = _Py_DumpTracebackThreads(thread.fd, thread.interp, current);

  0004c	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR thread+32
  00053	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR thread+8
  00059	4c 8b c3	 mov	 r8, rbx
  0005c	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads

; 454  :         ok = (errmsg == NULL);

  00061	33 c9		 xor	 ecx, ecx
  00063	48 85 c0	 test	 rax, rax
  00066	0f 94 c1	 sete	 cl

; 455  : 
; 456  :         if (thread.exit)

  00069	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR thread+40, 0
  00070	75 0f		 jne	 SHORT $LN11@faulthandl@7

; 458  :     } while (ok && thread.repeat);

  00072	85 c9		 test	 ecx, ecx
  00074	74 23		 je	 SHORT $LN4@faulthandl@7
  00076	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR thread+24, 0
  0007d	75 91		 jne	 SHORT $LL6@faulthandl@7
  0007f	eb 18		 jmp	 SHORT $LN4@faulthandl@7
$LN11@faulthandl@7:

; 457  :             _exit(1);

  00081	b9 01 00 00 00	 mov	 ecx, 1
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__exit
  0008c	cc		 int	 3
$LN10@faulthandl@7:

; 442  :             PyThread_release_lock(thread.cancel_event);

  0008d	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00094	e8 00 00 00 00	 call	 PyThread_release_lock
$LN4@faulthandl@7:

; 459  : 
; 460  :     /* The only way out */
; 461  :     PyThread_release_lock(thread.running);

  00099	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  000a0	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 462  : }

  000a5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a9	e9 00 00 00 00	 jmp	 PyThread_release_lock
$LN12@faulthandl@7:
faulthandler_thread ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	PyThread_acquire_lock:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$cancel_dump_traceback_later DD imagerel cancel_dump_traceback_later
	DD	imagerel cancel_dump_traceback_later+119
	DD	imagerel $unwind$cancel_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cancel_dump_traceback_later DD imagerel cancel_dump_traceback_later+119
	DD	imagerel cancel_dump_traceback_later+248
	DD	imagerel $chain$0$cancel_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$cancel_dump_traceback_later DD imagerel cancel_dump_traceback_later+248
	DD	imagerel cancel_dump_traceback_later+282
	DD	imagerel $chain$1$cancel_dump_traceback_later
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$cancel_dump_traceback_later DD 021H
	DD	imagerel cancel_dump_traceback_later
	DD	imagerel cancel_dump_traceback_later+119
	DD	imagerel $unwind$cancel_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cancel_dump_traceback_later DD 020521H
	DD	063405H
	DD	imagerel cancel_dump_traceback_later
	DD	imagerel cancel_dump_traceback_later+119
	DD	imagerel $unwind$cancel_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cancel_dump_traceback_later DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT cancel_dump_traceback_later
_TEXT	SEGMENT
cancel_dump_traceback_later PROC			; COMDAT

; 466  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 467  :     /* Notify cancellation */
; 468  :     PyThread_release_lock(thread.cancel_event);

  00004	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0000b	e8 00 00 00 00	 call	 PyThread_release_lock

; 469  : 
; 470  :     /* Wait for thread to join */
; 471  :     PyThread_acquire_lock(thread.running, 1);

  00010	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  00017	ba 01 00 00 00	 mov	 edx, 1
  0001c	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 472  :     PyThread_release_lock(thread.running);

  00021	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  00028	e8 00 00 00 00	 call	 PyThread_release_lock

; 473  : 
; 474  :     /* The main thread should always hold the cancel_event lock */
; 475  :     PyThread_acquire_lock(thread.cancel_event, 1);

  0002d	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00034	ba 01 00 00 00	 mov	 edx, 1
  00039	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 476  : 
; 477  :     Py_CLEAR(thread.file);

  0003e	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR thread
  00045	4d 85 c9	 test	 r9, r9
  00048	0f 84 aa 00 00
	00		 je	 $LN4@cancel_dum
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
  0005c	41 b8 dd 01 00
	00		 mov	 r8d, 477		; 000001ddH
  00062	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0006a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006f	85 c0		 test	 eax, eax
  00071	0f 85 81 00 00
	00		 jne	 $LN4@cancel_dum
  00077	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0007c	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR thread
  00083	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread, 0
  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	75 5c		 jne	 SHORT $LN19@cancel_dum
  00097	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009b	a8 20		 test	 al, 32			; 00000020H
  0009d	75 4c		 jne	 SHORT $LN12@cancel_dum
  0009f	84 c0		 test	 al, al
  000a1	78 48		 js	 SHORT $LN12@cancel_dum
  000a3	a8 02		 test	 al, 2
  000a5	75 4c		 jne	 SHORT $LN19@cancel_dum
  000a7	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ab	75 46		 jne	 SHORT $LN19@cancel_dum
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bb	4c 8b cb	 mov	 r9, rbx
  000be	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d1	48 8b cb	 mov	 rcx, rbx
  000d4	85 c0		 test	 eax, eax
  000d6	74 07		 je	 SHORT $LN17@cancel_dum
  000d8	e8 00 00 00 00	 call	 _Px_Dealloc
  000dd	eb 14		 jmp	 SHORT $LN19@cancel_dum
$LN17@cancel_dum:
  000df	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e9	eb 08		 jmp	 SHORT $LN19@cancel_dum
$LN12@cancel_dum:
  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	e8 00 00 00 00	 call	 Px_DecRef
$LN19@cancel_dum:
  000f3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN4@cancel_dum:

; 478  :     if (thread.header) {

  000f8	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR thread+48
  000ff	48 85 c9	 test	 rcx, rcx
  00102	74 11		 je	 SHORT $LN1@cancel_dum

; 479  :         free(thread.header);

  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 480  :         thread.header = NULL;

  0010a	48 c7 05 30 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+48, 0
$LN1@cancel_dum:

; 481  :     }
; 482  : }

  00115	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00119	c3		 ret	 0
cancel_dump_traceback_later ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@ ; `string'
PUBLIC	__real@412e848000000000
EXTRN	__imp_strdup:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	__imp_modf:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_timeout DD imagerel format_timeout
	DD	imagerel format_timeout+200
	DD	imagerel $unwind$format_timeout
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_timeout DD 020701H
	DD	0170107H
xdata	ENDS
;	COMDAT ??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@ DB 'T'
	DB	'imeout (%lu:%02lu:%02lu)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@
CONST	SEGMENT
??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@ DB 'T'
	DB	'imeout (%lu:%02lu:%02lu.%06lu)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_timeout
_TEXT	SEGMENT
buffer$ = 64
timeout$ = 192
intpart$ = 200
format_timeout PROC					; COMDAT

; 486  : {

  00000	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 487  :     unsigned long us, sec, min, hour;
; 488  :     double intpart, fracpart;
; 489  :     char buffer[100];
; 490  : 
; 491  :     fracpart = modf(timeout, &intpart);

  00007	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR intpart$[rsp]
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 492  :     sec = (unsigned long)intpart;
; 493  :     us = (unsigned long)(fracpart * 1e6);
; 494  :     min = sec / 60;

  00015	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0001a	f2 4c 0f 2c 94
	24 c8 00 00 00	 cvttsd2si r10, QWORD PTR intpart$[rsp]
  00024	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  0002c	41 f7 e2	 mul	 r10d

; 495  :     sec %= 60;
; 496  :     hour = min / 60;

  0002f	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00034	f2 4c 0f 2c c8	 cvttsd2si r9, xmm0
  00039	44 8b c2	 mov	 r8d, edx
  0003c	41 c1 e8 05	 shr	 r8d, 5
  00040	41 8b c8	 mov	 ecx, r8d
  00043	41 f7 e0	 mul	 r8d
  00046	6b c9 c4	 imul	 ecx, -60		; ffffffc4H
  00049	c1 ea 05	 shr	 edx, 5

; 497  :     min %= 60;

  0004c	8b c2		 mov	 eax, edx
  0004e	6b c0 c4	 imul	 eax, -60		; ffffffc4H
  00051	44 03 d1	 add	 r10d, ecx

; 498  : 
; 499  :     if (us != 0)
; 500  :         PyOS_snprintf(buffer, sizeof(buffer),
; 501  :                       "Timeout (%lu:%02lu:%02lu.%06lu)!\n",
; 502  :                       hour, min, sec, us);

  00054	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  00059	44 03 c0	 add	 r8d, eax
  0005c	45 85 c9	 test	 r9d, r9d
  0005f	74 36		 je	 SHORT $LN2@format_tim
  00061	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  00066	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0006b	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00070	44 8b ca	 mov	 r9d, edx
  00073	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@
  0007a	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0007f	e8 00 00 00 00	 call	 PyOS_snprintf

; 507  : 
; 508  :     return strdup(buffer);

  00084	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 509  : }

  0008f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00096	c3		 ret	 0
$LN2@format_tim:

; 503  :     else
; 504  :         PyOS_snprintf(buffer, sizeof(buffer),
; 505  :                       "Timeout (%lu:%02lu:%02lu)!\n",
; 506  :                       hour, min, sec);

  00097	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  0009c	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  000a1	44 8b ca	 mov	 r9d, edx
  000a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@
  000ab	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000b0	e8 00 00 00 00	 call	 PyOS_snprintf

; 507  : 
; 508  :     return strdup(buffer);

  000b5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 509  : }

  000c0	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  000c7	c3		 ret	 0
format_timeout ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@ ; `string'
PUBLIC	??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@ ; `string'
PUBLIC	??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@ ; `string'
PUBLIC	??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ ; `string'
PUBLIC	__real@428f3fffffe0c000
PUBLIC	??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@ ; `string'
EXTRN	PyThread_start_new_thread:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later
	DD	imagerel faulthandler_dump_traceback_later+145
	DD	imagerel $unwind$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later+145
	DD	imagerel faulthandler_dump_traceback_later+194
	DD	imagerel $chain$0$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later+194
	DD	imagerel faulthandler_dump_traceback_later+253
	DD	imagerel $chain$3$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later+253
	DD	imagerel faulthandler_dump_traceback_later+593
	DD	imagerel $chain$4$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later+593
	DD	imagerel faulthandler_dump_traceback_later+614
	DD	imagerel $chain$5$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$faulthandler_dump_traceback_later DD 021H
	DD	imagerel faulthandler_dump_traceback_later+194
	DD	imagerel faulthandler_dump_traceback_later+253
	DD	imagerel $chain$3$faulthandler_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$faulthandler_dump_traceback_later DD 020821H
	DD	0103408H
	DD	imagerel faulthandler_dump_traceback_later+194
	DD	imagerel faulthandler_dump_traceback_later+253
	DD	imagerel $chain$3$faulthandler_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$faulthandler_dump_traceback_later DD 040821H
	DD	0115408H
	DD	0c6400H
	DD	imagerel faulthandler_dump_traceback_later
	DD	imagerel faulthandler_dump_traceback_later+145
	DD	imagerel $unwind$faulthandler_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$faulthandler_dump_traceback_later DD 020521H
	DD	0c6405H
	DD	imagerel faulthandler_dump_traceback_later
	DD	imagerel faulthandler_dump_traceback_later+145
	DD	imagerel $unwind$faulthandler_dump_traceback_later
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_dump_traceback_later DD 030a01H
	DD	0c006c20aH
	DD	07004H
xdata	ENDS
;	COMDAT ??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@
CONST	SEGMENT
??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@ DB 'unable to'
	DB	' start watchdog thread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@
CONST	SEGMENT
??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@ DB 'faulthandler_dum'
	DB	'p_traceback_later', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@
CONST	SEGMENT
??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@ DB 'timeout m'
	DB	'ust be greater than 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ DB 'timeout value '
	DB	'is too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@428f3fffffe0c000
CONST	SEGMENT
__real@428f3fffffe0c000 DQ 0428f3fffffe0c000r	; 4.29497e+012
CONST	ENDS
;	COMDAT ??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@ DB 'd|iOi:dump_tra'
	DB	'ceback_later', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_dump_traceback_later
_TEXT	SEGMENT
exit$ = 64
fd$ = 68
file$ = 72
timeout$ = 80
self$ = 128
args$ = 136
kwargs$ = 144
repeat$ = 152
faulthandler_dump_traceback_later PROC			; COMDAT

; 514  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 515  :     static char *kwlist[] = {"timeout", "repeat", "file", "exit", NULL};
; 516  :     double timeout;
; 517  :     PY_TIMEOUT_T timeout_us;
; 518  :     int repeat = 0;
; 519  :     PyObject *file = NULL;
; 520  :     int fd;
; 521  :     int exit = 0;
; 522  :     PyThreadState *tstate;
; 523  :     char *header;
; 524  :     size_t header_len;
; 525  : 
; 526  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 527  :         "d|iOi:dump_traceback_later", kwlist,
; 528  :         &timeout, &repeat, &file, &exit))

  0000a	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  0000e	49 8b c0	 mov	 rax, r8
  00011	48 8b fa	 mov	 rdi, rdx
  00014	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00018	49 8d 4b d0	 lea	 rcx, QWORD PTR [r11-48]
  0001c	45 33 e4	 xor	 r12d, r12d
  0001f	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00023	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_dump_traceback_later@@9@9
  0002e	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  00032	49 8d 4b d8	 lea	 rcx, QWORD PTR [r11-40]
  00036	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@
  0003d	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00041	48 8b d0	 mov	 rdx, rax
  00044	48 8b cf	 mov	 rcx, rdi
  00047	45 89 63 20	 mov	 DWORD PTR [r11+32], r12d
  0004b	4d 89 63 d0	 mov	 QWORD PTR [r11-48], r12
  0004f	45 89 63 c8	 mov	 DWORD PTR [r11-56], r12d
  00053	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00058	85 c0		 test	 eax, eax

; 529  :         return NULL;

  0005a	74 2b		 je	 SHORT $LN22@faulthandl@8

; 530  :     if ((timeout * 1e6) >= (double) PY_TIMEOUT_MAX) {

  0005c	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00062	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  0006a	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@428f3fffffe0c000
  00072	72 1d		 jb	 SHORT $LN14@faulthandl@8

; 531  :         PyErr_SetString(PyExc_OverflowError,  "timeout value is too large");

  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
  00082	e8 00 00 00 00	 call	 PyErr_SetString
$LN22@faulthandl@8:

; 532  :         return NULL;

  00087	33 c0		 xor	 eax, eax

; 582  : }

  00089	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0008d	41 5c		 pop	 r12
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN14@faulthandl@8:
  00091	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi

; 533  :     }
; 534  :     timeout_us = (PY_TIMEOUT_T)(timeout * 1e6);

  00096	f2 48 0f 2c f0	 cvttsd2si rsi, xmm0

; 535  :     if (timeout_us <= 0) {

  0009b	48 85 f6	 test	 rsi, rsi
  0009e	7f 22		 jg	 SHORT $LN13@faulthandl@8

; 536  :         PyErr_SetString(PyExc_ValueError, "timeout must be greater than 0");

  000a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@
  000ae	e8 00 00 00 00	 call	 PyErr_SetString
  000b3	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 537  :         return NULL;

  000b8	33 c0		 xor	 eax, eax

; 582  : }

  000ba	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000be	41 5c		 pop	 r12
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
$LN13@faulthandl@8:
  000c2	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp

; 538  :     }
; 539  : 
; 540  :     tstate = get_thread_state();

  000ca	e8 00 00 00 00	 call	 get_thread_state
  000cf	48 8b e8	 mov	 rbp, rax

; 541  :     if (tstate == NULL)

  000d2	48 85 c0	 test	 rax, rax

; 542  :         return NULL;

  000d5	74 19		 je	 SHORT $LN21@faulthandl@8

; 543  : 
; 544  :     file = faulthandler_get_fileno(file, &fd);

  000d7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR file$[rsp]
  000dc	48 8d 54 24 44	 lea	 rdx, QWORD PTR fd$[rsp]
  000e1	e8 00 00 00 00	 call	 faulthandler_get_fileno
  000e6	48 89 44 24 48	 mov	 QWORD PTR file$[rsp], rax

; 545  :     if (file == NULL)

  000eb	48 85 c0	 test	 rax, rax
  000ee	75 07		 jne	 SHORT $LN11@faulthandl@8
$LN21@faulthandl@8:

; 546  :         return NULL;

  000f0	33 c0		 xor	 eax, eax
  000f2	e9 5a 01 00 00	 jmp	 $LN19@faulthandl@8
$LN11@faulthandl@8:

; 547  : 
; 548  :     /* format the timeout */
; 549  :     header = format_timeout(timeout);

  000f7	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  000fd	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00105	e8 00 00 00 00	 call	 format_timeout
  0010a	48 8b d8	 mov	 rbx, rax

; 550  :     if (header == NULL)

  0010d	48 85 c0	 test	 rax, rax
  00110	75 0a		 jne	 SHORT $LN10@faulthandl@8

; 551  :         return PyErr_NoMemory();

  00112	e8 00 00 00 00	 call	 PyErr_NoMemory
  00117	e9 2d 01 00 00	 jmp	 $LN20@faulthandl@8
$LN10@faulthandl@8:

; 552  :     header_len = strlen(header);

  0011c	48 83 c9 ff	 or	 rcx, -1
  00120	33 c0		 xor	 eax, eax
  00122	48 8b fb	 mov	 rdi, rbx
  00125	f2 ae		 repne scasb
  00127	48 f7 d1	 not	 rcx
  0012a	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]

; 553  : 
; 554  :     /* Cancel previous thread, if running */
; 555  :     cancel_dump_traceback_later();

  0012e	e8 00 00 00 00	 call	 cancel_dump_traceback_later

; 556  : 
; 557  :     Py_XDECREF(thread.file);

  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR thread
  0013a	48 85 c9	 test	 rcx, rcx
  0013d	74 05		 je	 SHORT $LN8@faulthandl@8
  0013f	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@faulthandl@8:

; 558  :     Py_INCREF(file);

  00144	48 8b 4c 24 48	 mov	 rcx, QWORD PTR file$[rsp]
  00149	e8 00 00 00 00	 call	 _Py_IncRef

; 559  :     thread.file = file;
; 560  :     thread.fd = fd;

  0014e	8b 44 24 44	 mov	 eax, DWORD PTR fd$[rsp]
  00152	48 8b 54 24 48	 mov	 rdx, QWORD PTR file$[rsp]

; 561  :     thread.timeout_us = timeout_us;
; 562  :     thread.repeat = repeat;
; 563  :     thread.interp = tstate->interp;
; 564  :     thread.exit = exit;
; 565  :     thread.header = header;
; 566  :     thread.header_len = header_len;
; 567  : 
; 568  :     /* Arm these locks to serve as events when released */
; 569  :     PyThread_acquire_lock(thread.running, 1);

  00157	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  0015e	89 05 08 00 00
	00		 mov	 DWORD PTR thread+8, eax
  00164	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR repeat$[rsp]
  0016b	89 05 18 00 00
	00		 mov	 DWORD PTR thread+24, eax
  00171	48 8b 45 08	 mov	 rax, QWORD PTR [rbp+8]
  00175	48 89 15 00 00
	00 00		 mov	 QWORD PTR thread, rdx
  0017c	48 89 05 20 00
	00 00		 mov	 QWORD PTR thread+32, rax
  00183	8b 44 24 40	 mov	 eax, DWORD PTR exit$[rsp]
  00187	ba 01 00 00 00	 mov	 edx, 1
  0018c	48 89 35 10 00
	00 00		 mov	 QWORD PTR thread+16, rsi
  00193	48 89 1d 30 00
	00 00		 mov	 QWORD PTR thread+48, rbx
  0019a	48 89 3d 38 00
	00 00		 mov	 QWORD PTR thread+56, rdi
  001a1	89 05 28 00 00
	00		 mov	 DWORD PTR thread+40, eax
  001a7	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 570  : 
; 571  :     if (PyThread_start_new_thread(faulthandler_thread, NULL) == -1) {

  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:faulthandler_thread
  001b3	33 d2		 xor	 edx, edx
  001b5	e8 00 00 00 00	 call	 PyThread_start_new_thread
  001ba	83 f8 ff	 cmp	 eax, -1
  001bd	75 77		 jne	 SHORT $LN5@faulthandl@8

; 572  :         PyThread_release_lock(thread.running);

  001bf	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  001c6	e8 00 00 00 00	 call	 PyThread_release_lock

; 573  :         Py_CLEAR(thread.file);

  001cb	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR thread
  001d2	4d 85 c9	 test	 r9, r9
  001d5	74 38		 je	 SHORT $LN3@faulthandl@8
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@
  001e5	41 b8 3d 02 00
	00		 mov	 r8d, 573		; 0000023dH
  001eb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f8	85 c0		 test	 eax, eax
  001fa	75 13		 jne	 SHORT $LN3@faulthandl@8
  001fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR thread
  00203	4c 89 25 00 00
	00 00		 mov	 QWORD PTR thread, r12
  0020a	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@faulthandl@8:

; 574  :         free(header);

  0020f	48 8b cb	 mov	 rcx, rbx
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 575  :         thread.header = NULL;
; 576  :         PyErr_SetString(PyExc_RuntimeError,
; 577  :                         "unable to start watchdog thread");

  00218	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@
  00226	4c 89 25 30 00
	00 00		 mov	 QWORD PTR thread+48, r12
  0022d	e8 00 00 00 00	 call	 PyErr_SetString

; 578  :         return NULL;

  00232	33 c0		 xor	 eax, eax
  00234	eb 13		 jmp	 SHORT $LN20@faulthandl@8
$LN5@faulthandl@8:

; 579  :     }
; 580  : 
; 581  :     Py_RETURN_NONE;

  00236	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0023d	e8 00 00 00 00	 call	 _Py_IncRef
  00242	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN20@faulthandl@8:
  00249	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
$LN19@faulthandl@8:
  00251	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  00259	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 582  : }

  0025e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00262	41 5c		 pop	 r12
  00264	5f		 pop	 rdi
  00265	c3		 ret	 0
faulthandler_dump_traceback_later ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_cancel_dump_traceback_later_py DD imagerel faulthandler_cancel_dump_traceback_later_py
	DD	imagerel faulthandler_cancel_dump_traceback_later_py+105
	DD	imagerel $unwind$faulthandler_cancel_dump_traceback_later_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_cancel_dump_traceback_later_py DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT faulthandler_cancel_dump_traceback_later_py
_TEXT	SEGMENT
self$ = 64
faulthandler_cancel_dump_traceback_later_py PROC	; COMDAT

; 586  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 587  :     cancel_dump_traceback_later();

  00006	e8 00 00 00 00	 call	 cancel_dump_traceback_later

; 588  :     Py_RETURN_NONE;

  0000b	e8 00 00 00 00	 call	 _Py_PXCTX
  00010	85 c0		 test	 eax, eax
  00012	75 48		 jne	 SHORT $LN7@faulthandl@9
  00014	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00029	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002f	4c 8b cb	 mov	 r9, rbx
  00032	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 09		 jne	 SHORT $LN3@faulthandl@9
  00043	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0004a	74 07		 je	 SHORT $LN9@faulthandl@9
$LN3@faulthandl@9:
  0004c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@faulthandl@9:
  00053	48 8b c3	 mov	 rax, rbx

; 589  : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN7@faulthandl@9:

; 588  :     Py_RETURN_NONE;

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 589  : }

  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
faulthandler_cancel_dump_traceback_later_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyEval_RestoreThread:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_read_null DD imagerel faulthandler_read_null
	DD	imagerel faulthandler_read_null+105
	DD	imagerel $unwind$faulthandler_read_null
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_read_null DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@
CONST	SEGMENT
??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@ DB '|i:_read_null', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_read_null
_TEXT	SEGMENT
self$ = 48
args$ = 56
release_gil$ = 64
y$ = 72
faulthandler_read_null PROC				; COMDAT

; 802  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 803  :     volatile int *x;
; 804  :     volatile int y;
; 805  :     int release_gil = 0;
; 806  :     if (!PyArg_ParseTuple(args, "|i:_read_null", &release_gil))

  00006	48 8b ca	 mov	 rcx, rdx
  00009	4c 8d 44 24 40	 lea	 r8, QWORD PTR release_gil$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@
  00015	33 db		 xor	 ebx, ebx
  00017	89 5c 24 40	 mov	 DWORD PTR release_gil$[rsp], ebx
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN3@faulthandl@10

; 807  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 817  : 
; 818  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN3@faulthandl@10:

; 808  : 
; 809  :     x = NULL;
; 810  :     if (release_gil) {

  0002c	39 5c 24 40	 cmp	 DWORD PTR release_gil$[rsp], ebx
  00030	74 22		 je	 SHORT $LN2@faulthandl@10

; 811  :         Py_BEGIN_ALLOW_THREADS

  00032	e8 00 00 00 00	 call	 PyEval_SaveThread

; 812  :         y = *x;

  00037	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00039	89 4c 24 48	 mov	 DWORD PTR y$[rsp], ecx

; 813  :         Py_END_ALLOW_THREADS

  0003d	48 8b c8	 mov	 rcx, rax
  00040	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 816  :     return PyLong_FromLong(y);

  00045	8b 4c 24 48	 mov	 ecx, DWORD PTR y$[rsp]
  00049	e8 00 00 00 00	 call	 PyLong_FromLong

; 817  : 
; 818  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN2@faulthandl@10:

; 814  :     } else
; 815  :         y = *x;

  00054	8b 03		 mov	 eax, DWORD PTR [rbx]
  00056	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax

; 816  :     return PyLong_FromLong(y);

  0005a	8b 4c 24 48	 mov	 ecx, DWORD PTR y$[rsp]
  0005e	e8 00 00 00 00	 call	 PyLong_FromLong

; 817  : 
; 818  : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
faulthandler_read_null ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_sigsegv DD imagerel faulthandler_sigsegv
	DD	imagerel faulthandler_sigsegv+17
	DD	imagerel $unwind$faulthandler_sigsegv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigsegv DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT faulthandler_sigsegv
_TEXT	SEGMENT
self$ = 48
args$ = 56
faulthandler_sigsegv PROC				; COMDAT

; 822  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LL2@faulthandl@11:

; 823  : #if defined(MS_WINDOWS)
; 824  :     /* For SIGSEGV, faulthandler_fatal_error() restores the previous signal
; 825  :        handler and then gives back the execution flow to the program (without
; 826  :        explicitly calling the previous error handler). In a normal case, the
; 827  :        SIGSEGV was raised by the kernel because of a fault, and so if the
; 828  :        program retries to execute the same instruction, the fault will be
; 829  :        raised again.
; 830  : 
; 831  :        Here the fault is simulated by a fake SIGSEGV signal raised by the
; 832  :        application. We have to raise SIGSEGV at lease twice: once for
; 833  :        faulthandler_fatal_error(), and one more time for the previous signal
; 834  :        handler. */
; 835  :     while(1)
; 836  :         raise(SIGSEGV);

  00004	b9 0b 00 00 00	 mov	 ecx, 11
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise
  0000f	eb f3		 jmp	 SHORT $LL2@faulthandl@11
faulthandler_sigsegv ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_sigfpe DD imagerel faulthandler_sigfpe
	DD	imagerel faulthandler_sigfpe+59
	DD	imagerel $unwind$faulthandler_sigfpe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigfpe DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT faulthandler_sigfpe
_TEXT	SEGMENT
self$ = 48
args$ = 56
z$ = 64
y$ = 64
x$ = 72
faulthandler_sigfpe PROC				; COMDAT

; 845  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 846  :     /* Do an integer division by zero: raise a SIGFPE on Intel CPU, but not on
; 847  :        PowerPC. Use volatile to disable compile-time optimizations. */
; 848  :     volatile int x = 1, y = 0, z;

  00004	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR x$[rsp], 1
  0000c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0

; 849  :     z = x / y;

  00014	8b 4c 24 40	 mov	 ecx, DWORD PTR y$[rsp]
  00018	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0001c	99		 cdq
  0001d	f7 f9		 idiv	 ecx

; 850  :     /* If the division by zero didn't raise a SIGFPE (e.g. on PowerPC),
; 851  :        raise it manually. */
; 852  :     raise(SIGFPE);

  0001f	b9 08 00 00 00	 mov	 ecx, 8
  00024	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise

; 853  :     /* This line is never reached, but we pretend to make something with z
; 854  :        to silence a compiler warning. */
; 855  :     return PyLong_FromLong(z);

  0002e	8b 4c 24 40	 mov	 ecx, DWORD PTR z$[rsp]

; 856  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	e9 00 00 00 00	 jmp	 PyLong_FromLong
faulthandler_sigfpe ENDP
_TEXT	ENDS
EXTRN	__imp_abort:PROC
EXTRN	__imp__set_abort_behavior:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_sigabrt DD imagerel faulthandler_sigabrt
	DD	imagerel faulthandler_sigabrt+119
	DD	imagerel $unwind$faulthandler_sigabrt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigabrt DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT faulthandler_sigabrt
_TEXT	SEGMENT
self$ = 64
args$ = 72
faulthandler_sigabrt PROC				; COMDAT

; 860  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 861  : #ifdef _MSC_VER
; 862  :     /* Visual Studio: configure abort() to not display an error message nor
; 863  :        open a popup asking to report the fault. */
; 864  :     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);

  00006	ba 03 00 00 00	 mov	 edx, 3
  0000b	33 c9		 xor	 ecx, ecx
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__set_abort_behavior

; 865  : #endif
; 866  :     abort();

  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_abort

; 867  :     Py_RETURN_NONE;

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 48		 jne	 SHORT $LN7@faulthandl@12
  00022	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00037	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003d	4c 8b cb	 mov	 r9, rbx
  00040	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00048	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004d	85 c0		 test	 eax, eax
  0004f	75 09		 jne	 SHORT $LN3@faulthandl@12
  00051	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00058	74 07		 je	 SHORT $LN9@faulthandl@12
$LN3@faulthandl@12:
  0005a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@faulthandl@12:
  00061	48 8b c3	 mov	 rax, rbx

; 868  : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN7@faulthandl@12:

; 867  :     Py_RETURN_NONE;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 868  : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
faulthandler_sigabrt ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_sigill DD imagerel faulthandler_sigill
	DD	imagerel faulthandler_sigill+111
	DD	imagerel $unwind$faulthandler_sigill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigill DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
xdata	ENDS
;	COMDAT faulthandler_sigill
_TEXT	SEGMENT
self$ = 64
args$ = 72
faulthandler_sigill PROC				; COMDAT

; 882  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 883  :     raise(SIGILL);

  00006	b9 04 00 00 00	 mov	 ecx, 4
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise

; 884  :     Py_RETURN_NONE;

  00011	e8 00 00 00 00	 call	 _Py_PXCTX
  00016	85 c0		 test	 eax, eax
  00018	75 48		 jne	 SHORT $LN7@faulthandl@13
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00035	4c 8b cb	 mov	 r9, rbx
  00038	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 09		 jne	 SHORT $LN3@faulthandl@13
  00049	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00050	74 07		 je	 SHORT $LN9@faulthandl@13
$LN3@faulthandl@13:
  00052	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@faulthandl@13:
  00059	48 8b c3	 mov	 rax, rbx

; 885  : }

  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
$LN7@faulthandl@13:

; 884  :     Py_RETURN_NONE;

  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 885  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
faulthandler_sigill ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@		; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$faulthandler_fatal_error_py DD imagerel faulthandler_fatal_error_py
	DD	imagerel faulthandler_fatal_error_py+126
	DD	imagerel $unwind$faulthandler_fatal_error_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_fatal_error_py DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@
CONST	SEGMENT
??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@ DB 'y:fatal_error', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\faulthandler.c
CONST	ENDS
;	COMDAT faulthandler_fatal_error_py
_TEXT	SEGMENT
self$ = 64
args$ = 72
message$ = 80
faulthandler_fatal_error_py PROC			; COMDAT

; 890  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 891  :     char *message;
; 892  :     if (!PyArg_ParseTuple(args, "y:fatal_error", &message))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR message$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@faulthandl@14

; 893  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 896  : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN1@faulthandl@14:

; 894  :     Py_FatalError(message);

  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR message$[rsp]
  00028	e8 00 00 00 00	 call	 Py_FatalError

; 895  :     Py_RETURN_NONE;

  0002d	e8 00 00 00 00	 call	 _Py_PXCTX
  00032	85 c0		 test	 eax, eax
  00034	75 3c		 jne	 SHORT $LN5@faulthandl@14
  00036	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005e	85 c0		 test	 eax, eax
  00060	75 09		 jne	 SHORT $LN4@faulthandl@14
  00062	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00069	74 07		 je	 SHORT $LN5@faulthandl@14
$LN4@faulthandl@14:
  0006b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@faulthandl@14:
  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 896  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
faulthandler_fatal_error_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_traverse DD imagerel faulthandler_traverse
	DD	imagerel faulthandler_traverse+145
	DD	imagerel $unwind$faulthandler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_traverse DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
CONST	SEGMENT
??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@ DB 'faulthandler_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_traverse
_TEXT	SEGMENT
module$ = 48
visit$ = 56
arg$ = 64
faulthandler_traverse PROC				; COMDAT

; 938  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d8	 mov	 rbx, r8
  0000d	48 8b fa	 mov	 rdi, rdx

; 939  : #ifdef FAULTHANDLER_USER
; 940  :     unsigned int signum;
; 941  : #endif
; 942  : 
; 943  : #ifdef FAULTHANDLER_LATER
; 944  :     Py_VISIT(thread.file);

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 1c		 je	 SHORT $LN9@faulthandl@15
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
  00027	45 33 c9	 xor	 r9d, r9d
  0002a	41 b8 b0 03 00
	00		 mov	 r8d, 944		; 000003b0H
  00030	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@faulthandl@15:
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR thread
  0003c	48 85 c9	 test	 rcx, rcx
  0003f	74 09		 je	 SHORT $LN11@faulthandl@15
  00041	48 8b d3	 mov	 rdx, rbx
  00044	ff d7		 call	 rdi
  00046	85 c0		 test	 eax, eax
  00048	75 3c		 jne	 SHORT $LN13@faulthandl@15
$LN11@faulthandl@15:

; 945  : #endif
; 946  : #ifdef FAULTHANDLER_USER
; 947  :     if (user_signals != NULL) {
; 948  :         for (signum=0; signum < NSIG; signum++)
; 949  :             Py_VISIT(user_signals[signum].file);
; 950  :     }
; 951  : #endif
; 952  :     Py_VISIT(fatal_error.file);

  0004a	e8 00 00 00 00	 call	 _Py_PXCTX
  0004f	85 c0		 test	 eax, eax
  00051	74 1c		 je	 SHORT $LN3@faulthandl@15
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
  00061	45 33 c9	 xor	 r9d, r9d
  00064	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  0006a	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@faulthandl@15:
  0006f	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR fatal_error+8
  00076	48 85 c9	 test	 rcx, rcx
  00079	74 09		 je	 SHORT $LN5@faulthandl@15
  0007b	48 8b d3	 mov	 rdx, rbx
  0007e	ff d7		 call	 rdi
  00080	85 c0		 test	 eax, eax
  00082	75 02		 jne	 SHORT $LN13@faulthandl@15
$LN5@faulthandl@15:

; 953  :     return 0;

  00084	33 c0		 xor	 eax, eax
$LN13@faulthandl@15:

; 954  : }

  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
faulthandler_traverse ENDP
_TEXT	ENDS
PUBLIC	PyInit_faulthandler
EXTRN	PyModule_Create2:PROC
; Function compile flags: /Ogtpy
;	COMDAT PyInit_faulthandler
_TEXT	SEGMENT
PyInit_faulthandler PROC				; COMDAT

; 1040 :     return PyModule_Create(&module_def);

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:module_def
  00007	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H

; 1041 : }

  0000c	e9 00 00 00 00	 jmp	 PyModule_Create2
PyInit_faulthandler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@	; `string'
EXTRN	PyImport_ImportModule:PROC
EXTRN	PyDict_Contains:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PySys_GetXOptions:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_env_options DD imagerel faulthandler_env_options
	DD	imagerel faulthandler_env_options+209
	DD	imagerel $unwind$faulthandler_env_options
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_env_options DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@
CONST	SEGMENT
??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@ DB 'PYTHONFAULTHANDLER', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT faulthandler_env_options
_TEXT	SEGMENT
faulthandler_env_options PROC				; COMDAT

; 1048 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1049 :     PyObject *xoptions, *key, *module, *res;
; 1050 :     _Py_IDENTIFIER(enable);
; 1051 : 
; 1052 :     if (!Py_GETENV("PYTHONFAULTHANDLER")) {

  0000a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00011	75 12		 jne	 SHORT $LN11@faulthandl@16
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00020	48 85 c0	 test	 rax, rax
  00023	75 48		 jne	 SHORT $LN3@faulthandl@16
$LN11@faulthandl@16:

; 1053 :         int has_key;
; 1054 : 
; 1055 :         xoptions = PySys_GetXOptions();

  00025	e8 00 00 00 00	 call	 PySys_GetXOptions
  0002a	48 8b d8	 mov	 rbx, rax

; 1056 :         if (xoptions == NULL)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 0e		 jne	 SHORT $LN5@faulthandl@16
$LN13@faulthandl@16:

; 1057 :             return -1;

  00032	83 c8 ff	 or	 eax, -1

; 1079 : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN5@faulthandl@16:

; 1058 : 
; 1059 :         key = PyUnicode_FromString("faulthandler");

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
  00047	e8 00 00 00 00	 call	 PyUnicode_FromString
  0004c	48 8b f8	 mov	 rdi, rax

; 1060 :         if (key == NULL)

  0004f	48 85 c0	 test	 rax, rax

; 1061 :             return -1;

  00052	74 de		 je	 SHORT $LN13@faulthandl@16

; 1062 : 
; 1063 :         has_key = PyDict_Contains(xoptions, key);

  00054	48 8b d0	 mov	 rdx, rax
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	e8 00 00 00 00	 call	 PyDict_Contains

; 1064 :         Py_DECREF(key);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	8b d8		 mov	 ebx, eax
  00064	e8 00 00 00 00	 call	 _Py_DecRef

; 1065 :         if (!has_key)

  00069	85 db		 test	 ebx, ebx

; 1066 :             return 0;

  0006b	74 57		 je	 SHORT $LN12@faulthandl@16
$LN3@faulthandl@16:

; 1067 :     }
; 1068 : 
; 1069 :     module = PyImport_ImportModule("faulthandler");

  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
  00074	e8 00 00 00 00	 call	 PyImport_ImportModule
  00079	48 8b d8	 mov	 rbx, rax

; 1070 :     if (module == NULL) {

  0007c	48 85 c0	 test	 rax, rax

; 1071 :         return -1;

  0007f	74 b1		 je	 SHORT $LN13@faulthandl@16

; 1072 :     }
; 1073 :     res = _PyObject_CallMethodId(module, &PyId_enable, "");

  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00087	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00090	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_enable@?1??faulthandler_env_options@@9@9
  00095	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 1074 :     Py_DECREF(module);

  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 1075 :     if (res == NULL)

  000b3	48 85 ff	 test	 rdi, rdi

; 1076 :         return -1;

  000b6	0f 84 76 ff ff
	ff		 je	 $LN13@faulthandl@16

; 1077 :     Py_DECREF(res);

  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@faulthandl@16:

; 1078 :     return 0;

  000c4	33 c0		 xor	 eax, eax

; 1079 : }

  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
faulthandler_env_options ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@ ; `string'
PUBLIC	_PyFaulthandler_Init
EXTRN	PyThread_allocate_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFaulthandler_Init DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$_PyFaulthandler_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFaulthandler_Init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@
CONST	SEGMENT
??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@ DB 'could not a'
	DB	'llocate locks for faulthandler', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFaulthandler_Init
_TEXT	SEGMENT
_PyFaulthandler_Init PROC				; COMDAT

; 1082 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1083 : #ifdef HAVE_SIGALTSTACK
; 1084 :     int err;
; 1085 : 
; 1086 :     /* Try to allocate an alternate stack for faulthandler() signal handler to
; 1087 :      * be able to allocate memory on the stack, even on a stack overflow. If it
; 1088 :      * fails, ignore the error. */
; 1089 :     stack.ss_flags = 0;
; 1090 :     stack.ss_size = SIGSTKSZ;
; 1091 :     stack.ss_sp = PyMem_Malloc(stack.ss_size);
; 1092 :     if (stack.ss_sp != NULL) {
; 1093 :         err = sigaltstack(&stack, NULL);
; 1094 :         if (err) {
; 1095 :             PyMem_Free(stack.ss_sp);
; 1096 :             stack.ss_sp = NULL;
; 1097 :         }
; 1098 :     }
; 1099 : #endif
; 1100 : #ifdef FAULTHANDLER_LATER
; 1101 :     thread.file = NULL;

  00004	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread, 0

; 1102 :     thread.cancel_event = PyThread_allocate_lock();

  0000f	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00014	48 89 05 40 00
	00 00		 mov	 QWORD PTR thread+64, rax

; 1103 :     thread.running = PyThread_allocate_lock();

  0001b	e8 00 00 00 00	 call	 PyThread_allocate_lock

; 1104 :     if (!thread.cancel_event || !thread.running) {

  00020	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00027	48 89 05 48 00
	00 00		 mov	 QWORD PTR thread+72, rax
  0002e	48 85 c9	 test	 rcx, rcx
  00031	74 18		 je	 SHORT $LN1@PyFaulthan
  00033	48 85 c0	 test	 rax, rax
  00036	74 13		 je	 SHORT $LN1@PyFaulthan

; 1108 :     }
; 1109 :     PyThread_acquire_lock(thread.cancel_event, 1);

  00038	ba 01 00 00 00	 mov	 edx, 1
  0003d	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 1110 : #endif
; 1111 : 
; 1112 :     return faulthandler_env_options();
; 1113 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	e9 00 00 00 00	 jmp	 faulthandler_env_options
$LN1@PyFaulthan:

; 1105 :         PyErr_SetString(PyExc_RuntimeError,
; 1106 :                         "could not allocate locks for faulthandler");

  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@
  00059	e8 00 00 00 00	 call	 PyErr_SetString

; 1107 :         return -1;

  0005e	83 c8 ff	 or	 eax, -1

; 1110 : #endif
; 1111 : 
; 1112 :     return faulthandler_env_options();
; 1113 : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
_PyFaulthandler_Init ENDP
_TEXT	ENDS
PUBLIC	_PyFaulthandler_Fini
EXTRN	PyThread_free_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFaulthandler_Fini DD imagerel $LN5
	DD	imagerel $LN5+91
	DD	imagerel $unwind$_PyFaulthandler_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFaulthandler_Fini DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyFaulthandler_Fini
_TEXT	SEGMENT
_PyFaulthandler_Fini PROC				; COMDAT

; 1116 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1117 : #ifdef FAULTHANDLER_USER
; 1118 :     unsigned int signum;
; 1119 : #endif
; 1120 : 
; 1121 : #ifdef FAULTHANDLER_LATER
; 1122 :     /* later */
; 1123 :     if (thread.cancel_event) {

  00004	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR thread+64, 0
  0000c	74 28		 je	 SHORT $LN2@PyFaulthan@2

; 1124 :         cancel_dump_traceback_later();

  0000e	e8 00 00 00 00	 call	 cancel_dump_traceback_later

; 1125 :         PyThread_release_lock(thread.cancel_event);

  00013	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0001a	e8 00 00 00 00	 call	 PyThread_release_lock

; 1126 :         PyThread_free_lock(thread.cancel_event);

  0001f	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00026	e8 00 00 00 00	 call	 PyThread_free_lock

; 1127 :         thread.cancel_event = NULL;

  0002b	48 c7 05 40 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+64, 0
$LN2@PyFaulthan@2:

; 1128 :     }
; 1129 :     if (thread.running) {

  00036	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  0003d	48 85 c9	 test	 rcx, rcx
  00040	74 10		 je	 SHORT $LN1@PyFaulthan@2

; 1130 :         PyThread_free_lock(thread.running);

  00042	e8 00 00 00 00	 call	 PyThread_free_lock

; 1131 :         thread.running = NULL;

  00047	48 c7 05 48 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+72, 0
$LN1@PyFaulthan@2:

; 1132 :     }
; 1133 : #endif
; 1134 : 
; 1135 : #ifdef FAULTHANDLER_USER
; 1136 :     /* user */
; 1137 :     if (user_signals != NULL) {
; 1138 :         for (signum=0; signum < NSIG; signum++)
; 1139 :             faulthandler_unregister(&user_signals[signum], signum);
; 1140 :         free(user_signals);
; 1141 :         user_signals = NULL;
; 1142 :     }
; 1143 : #endif
; 1144 : 
; 1145 :     /* fatal */
; 1146 :     faulthandler_disable();
; 1147 : #ifdef HAVE_SIGALTSTACK
; 1148 :     if (stack.ss_sp != NULL) {
; 1149 :         PyMem_Free(stack.ss_sp);
; 1150 :         stack.ss_sp = NULL;
; 1151 :     }
; 1152 : #endif
; 1153 : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	e9 00 00 00 00	 jmp	 faulthandler_disable
_PyFaulthandler_Fini ENDP
_TEXT	ENDS
END
