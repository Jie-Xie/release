; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	Py_OptimizeFlag
_BSS	SEGMENT
Py_OptimizeFlag DD 01H DUP (?)
	ALIGN	8

?assertion_error@?1??compiler_assert@@9@9 DQ 01H DUP (?) ; `compiler_assert'::`2'::assertion_error
_BSS	ENDS
CONST	SEGMENT
?LOOP_ERROR_MSG@?1??compiler_continue@@9@9 DB '''continue'' not properly '
	DB	'in loop', 00H				; `compiler_continue'::`2'::LOOP_ERROR_MSG
?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9 DB '''continue'' not sup'
	DB	'ported inside ''finally'' clause', 00H	; `compiler_continue'::`2'::IN_FINALLY_ERROR_MSG
CONST	ENDS
;	COMDAT ??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@
CONST	SEGMENT
??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@ DB '<locals>', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?locals@?1??compiler_scope_qualname@@9@9 DQ 0000000000000000H ; `compiler_scope_qualname'::`2'::locals
	DQ	FLAT:??_C@_08GHPJPHKJ@?$DMlocals?$DO?$AA@
	DQ	0000000000000000H
?dot@?1??compiler_scope_qualname@@9@9 DQ 0000000000000000H ; `compiler_scope_qualname'::`2'::dot
	DQ	FLAT:??_C@_01LFCBOECM@?4?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@ ; `string'
PUBLIC	_Py_Mangle
EXTRN	PyUnicode_CopyCharacters:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyUnicode_FindChar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_Mangle DD imagerel $LN139
	DD	imagerel $LN139+373
	DD	imagerel $unwind$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_Py_Mangle DD imagerel $LN139+373
	DD	imagerel $LN139+786
	DD	imagerel $chain$1$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_Py_Mangle DD imagerel $LN139+786
	DD	imagerel $LN139+1041
	DD	imagerel $chain$4$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_Py_Mangle DD imagerel $LN139+1041
	DD	imagerel $LN139+1444
	DD	imagerel $chain$5$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_Py_Mangle DD imagerel $LN139+1444
	DD	imagerel $LN139+1466
	DD	imagerel $chain$6$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_Py_Mangle DD imagerel $LN139+1466
	DD	imagerel $LN139+1471
	DD	imagerel $chain$8$_Py_Mangle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$_Py_Mangle DD imagerel $LN139+1471
	DD	imagerel $LN139+1540
	DD	imagerel $chain$9$_Py_Mangle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$_Py_Mangle DD 021H
	DD	imagerel $LN139
	DD	imagerel $LN139+373
	DD	imagerel $unwind$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_Py_Mangle DD 080021H
	DD	06d400H
	DD	0cc400H
	DD	0b7400H
	DD	0a5400H
	DD	imagerel $LN139
	DD	imagerel $LN139+373
	DD	imagerel $unwind$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_Py_Mangle DD 021H
	DD	imagerel $LN139+786
	DD	imagerel $LN139+1041
	DD	imagerel $chain$4$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_Py_Mangle DD 020521H
	DD	0b7405H
	DD	imagerel $LN139+786
	DD	imagerel $LN139+1041
	DD	imagerel $chain$4$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_Py_Mangle DD 060821H
	DD	0a5408H
	DD	06d400H
	DD	0cc400H
	DD	imagerel $LN139
	DD	imagerel $LN139+373
	DD	imagerel $unwind$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_Py_Mangle DD 040e21H
	DD	06d40eH
	DD	0cc405H
	DD	imagerel $LN139
	DD	imagerel $LN139+373
	DD	imagerel $unwind$_Py_Mangle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_Mangle DD 030701H
	DD	060036207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@
CONST	SEGMENT
??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@ DB 'private ide'
	DB	'ntifier too large to be mangled', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT _Py_Mangle
_TEXT	SEGMENT
privateobj$ = 80
ident$ = 88
_Py_Mangle PROC						; COMDAT

; 212  : {

$LN139:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00007	48 8b da	 mov	 rbx, rdx
  0000a	48 8b f1	 mov	 rsi, rcx

; 213  :     /* Name mangling: __private becomes _classname__private.
; 214  :        This is independent from how the name is used. */
; 215  :     PyObject *result;
; 216  :     size_t nlen, plen, ipriv;
; 217  :     Py_UCS4 maxchar;
; 218  :     if (privateobj == NULL || !PyUnicode_Check(privateobj) ||
; 219  :         PyUnicode_READ_CHAR(ident, 0) != '_' ||
; 220  :         PyUnicode_READ_CHAR(ident, 1) != '_') {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 a9 05 00
	00		 je	 $LN20@Py_Mangle
  00016	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00024	0f 84 95 05 00
	00		 je	 $LN20@Py_Mangle
  0002a	8b 4a 70	 mov	 ecx, DWORD PTR [rdx+112]
  0002d	8b d1		 mov	 edx, ecx
  0002f	8b c1		 mov	 eax, ecx
  00031	c1 ea 02	 shr	 edx, 2
  00034	c1 e8 05	 shr	 eax, 5
  00037	83 e2 07	 and	 edx, 7
  0003a	83 fa 01	 cmp	 edx, 1
  0003d	75 30		 jne	 SHORT $LN38@Py_Mangle
  0003f	23 c2		 and	 eax, edx
  00041	74 1f		 je	 SHORT $LN26@Py_Mangle
  00043	f6 c1 40	 test	 cl, 64			; 00000040H
  00046	74 0d		 je	 SHORT $LN24@Py_Mangle
  00048	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  0004f	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]
  00053	eb 76		 jmp	 SHORT $LN37@Py_Mangle
$LN24@Py_Mangle:
  00055	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  0005c	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]
  00060	eb 69		 jmp	 SHORT $LN37@Py_Mangle
$LN26@Py_Mangle:
  00062	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  00069	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]
  0006d	eb 5c		 jmp	 SHORT $LN37@Py_Mangle
$LN38@Py_Mangle:
  0006f	83 fa 02	 cmp	 edx, 2
  00072	75 31		 jne	 SHORT $LN36@Py_Mangle
  00074	83 e0 01	 and	 eax, 1
  00077	74 1f		 je	 SHORT $LN30@Py_Mangle
  00079	f6 c1 40	 test	 cl, 64			; 00000040H
  0007c	74 0d		 je	 SHORT $LN28@Py_Mangle
  0007e	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00085	45 0f b7 08	 movzx	 r9d, WORD PTR [r8]
  00089	eb 40		 jmp	 SHORT $LN37@Py_Mangle
$LN28@Py_Mangle:
  0008b	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00092	45 0f b7 08	 movzx	 r9d, WORD PTR [r8]
  00096	eb 33		 jmp	 SHORT $LN37@Py_Mangle
$LN30@Py_Mangle:
  00098	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  0009f	45 0f b7 08	 movzx	 r9d, WORD PTR [r8]
  000a3	eb 26		 jmp	 SHORT $LN37@Py_Mangle
$LN36@Py_Mangle:
  000a5	83 e0 01	 and	 eax, 1
  000a8	74 17		 je	 SHORT $LN34@Py_Mangle
  000aa	f6 c1 40	 test	 cl, 64			; 00000040H
  000ad	74 09		 je	 SHORT $LN32@Py_Mangle
  000af	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  000b6	eb 10		 jmp	 SHORT $LN35@Py_Mangle
$LN32@Py_Mangle:
  000b8	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  000bf	eb 07		 jmp	 SHORT $LN35@Py_Mangle
$LN34@Py_Mangle:
  000c1	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN35@Py_Mangle:
  000c8	45 8b 08	 mov	 r9d, DWORD PTR [r8]
$LN37@Py_Mangle:
  000cb	41 83 f9 5f	 cmp	 r9d, 95			; 0000005fH
  000cf	0f 85 ea 04 00
	00		 jne	 $LN20@Py_Mangle
  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 33		 jne	 SHORT $LN54@Py_Mangle
  000da	85 c0		 test	 eax, eax
  000dc	74 21		 je	 SHORT $LN42@Py_Mangle
  000de	f6 c1 40	 test	 cl, 64			; 00000040H
  000e1	74 0e		 je	 SHORT $LN40@Py_Mangle
  000e3	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  000ea	45 0f b6 48 01	 movzx	 r9d, BYTE PTR [r8+1]
  000ef	eb 7a		 jmp	 SHORT $LN53@Py_Mangle
$LN40@Py_Mangle:
  000f1	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  000f8	45 0f b6 48 01	 movzx	 r9d, BYTE PTR [r8+1]
  000fd	eb 6c		 jmp	 SHORT $LN53@Py_Mangle
$LN42@Py_Mangle:
  000ff	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  00106	45 0f b6 48 01	 movzx	 r9d, BYTE PTR [r8+1]
  0010b	eb 5e		 jmp	 SHORT $LN53@Py_Mangle
$LN54@Py_Mangle:
  0010d	83 fa 02	 cmp	 edx, 2
  00110	75 33		 jne	 SHORT $LN52@Py_Mangle
  00112	85 c0		 test	 eax, eax
  00114	74 21		 je	 SHORT $LN46@Py_Mangle
  00116	f6 c1 40	 test	 cl, 64			; 00000040H
  00119	74 0e		 je	 SHORT $LN44@Py_Mangle
  0011b	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00122	45 0f b7 48 02	 movzx	 r9d, WORD PTR [r8+2]
  00127	eb 42		 jmp	 SHORT $LN53@Py_Mangle
$LN44@Py_Mangle:
  00129	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00130	45 0f b7 48 02	 movzx	 r9d, WORD PTR [r8+2]
  00135	eb 34		 jmp	 SHORT $LN53@Py_Mangle
$LN46@Py_Mangle:
  00137	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  0013e	45 0f b7 48 02	 movzx	 r9d, WORD PTR [r8+2]
  00143	eb 26		 jmp	 SHORT $LN53@Py_Mangle
$LN52@Py_Mangle:
  00145	85 c0		 test	 eax, eax
  00147	74 17		 je	 SHORT $LN50@Py_Mangle
  00149	f6 c1 40	 test	 cl, 64			; 00000040H
  0014c	74 09		 je	 SHORT $LN48@Py_Mangle
  0014e	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00155	eb 10		 jmp	 SHORT $LN51@Py_Mangle
$LN48@Py_Mangle:
  00157	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  0015e	eb 07		 jmp	 SHORT $LN51@Py_Mangle
$LN50@Py_Mangle:
  00160	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN51@Py_Mangle:
  00167	45 8b 48 04	 mov	 r9d, DWORD PTR [r8+4]
$LN53@Py_Mangle:
  0016b	41 83 f9 5f	 cmp	 r9d, 95			; 0000005fH
  0016f	0f 85 4a 04 00
	00		 jne	 $LN20@Py_Mangle

; 223  :     }
; 224  :     nlen = PyUnicode_GET_LENGTH(ident);

  00175	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  0017a	4c 8b 63 60	 mov	 r12, QWORD PTR [rbx+96]
  0017e	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 225  :     plen = PyUnicode_GET_LENGTH(privateobj);

  00183	4c 8b 6e 60	 mov	 r13, QWORD PTR [rsi+96]

; 226  :     /* Don't mangle __id__ or names with dots.
; 227  : 
; 228  :        The only time a name with a dot can occur is when
; 229  :        we are compiling an import statement that has a
; 230  :        package name.
; 231  : 
; 232  :        TODO(jhylton): Decide whether we want to support
; 233  :        mangling of the module name, e.g. __M.X.
; 234  :     */
; 235  :     if ((PyUnicode_READ_CHAR(ident, nlen-1) == '_' &&
; 236  :          PyUnicode_READ_CHAR(ident, nlen-2) == '_') ||
; 237  :         PyUnicode_FindChar(ident, '.', 0, nlen, 1) != -1) {

  00187	83 fa 01	 cmp	 edx, 1
  0018a	75 39		 jne	 SHORT $LN70@Py_Mangle
  0018c	85 c0		 test	 eax, eax
  0018e	74 26		 je	 SHORT $LN58@Py_Mangle
  00190	f6 c1 40	 test	 cl, 64			; 00000040H
  00193	74 12		 je	 SHORT $LN56@Py_Mangle
  00195	46 0f b6 4c 23
	7f		 movzx	 r9d, BYTE PTR [rbx+r12+127]
  0019b	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  001a2	e9 80 00 00 00	 jmp	 $LN69@Py_Mangle
$LN56@Py_Mangle:
  001a7	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  001ae	47 0f b6 4c 20
	ff		 movzx	 r9d, BYTE PTR [r8+r12-1]
  001b4	eb 71		 jmp	 SHORT $LN69@Py_Mangle
$LN58@Py_Mangle:
  001b6	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  001bd	47 0f b6 4c 20
	ff		 movzx	 r9d, BYTE PTR [r8+r12-1]
  001c3	eb 62		 jmp	 SHORT $LN69@Py_Mangle
$LN70@Py_Mangle:
  001c5	83 fa 02	 cmp	 edx, 2
  001c8	75 36		 jne	 SHORT $LN68@Py_Mangle
  001ca	85 c0		 test	 eax, eax
  001cc	74 23		 je	 SHORT $LN62@Py_Mangle
  001ce	f6 c1 40	 test	 cl, 64			; 00000040H
  001d1	74 0f		 je	 SHORT $LN60@Py_Mangle
  001d3	46 0f b7 4c 63
	7e		 movzx	 r9d, WORD PTR [rbx+r12*2+126]
  001d9	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  001e0	eb 45		 jmp	 SHORT $LN69@Py_Mangle
$LN60@Py_Mangle:
  001e2	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  001e9	47 0f b7 4c 60
	fe		 movzx	 r9d, WORD PTR [r8+r12*2-2]
  001ef	eb 36		 jmp	 SHORT $LN69@Py_Mangle
$LN62@Py_Mangle:
  001f1	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  001f8	47 0f b7 4c 60
	fe		 movzx	 r9d, WORD PTR [r8+r12*2-2]
  001fe	eb 27		 jmp	 SHORT $LN69@Py_Mangle
$LN68@Py_Mangle:
  00200	85 c0		 test	 eax, eax
  00202	74 17		 je	 SHORT $LN66@Py_Mangle
  00204	f6 c1 40	 test	 cl, 64			; 00000040H
  00207	74 09		 je	 SHORT $LN64@Py_Mangle
  00209	4c 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [rbx+128]
  00210	eb 10		 jmp	 SHORT $LN67@Py_Mangle
$LN64@Py_Mangle:
  00212	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  00219	eb 07		 jmp	 SHORT $LN67@Py_Mangle
$LN66@Py_Mangle:
  0021b	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
$LN67@Py_Mangle:
  00222	47 8b 4c a0 fc	 mov	 r9d, DWORD PTR [r8+r12*4-4]
$LN69@Py_Mangle:
  00227	41 83 f9 5f	 cmp	 r9d, 95			; 0000005fH
  0022b	0f 85 a5 00 00
	00		 jne	 $LN17@Py_Mangle
  00231	83 fa 01	 cmp	 edx, 1
  00234	75 39		 jne	 SHORT $LN86@Py_Mangle
  00236	85 c0		 test	 eax, eax
  00238	74 26		 je	 SHORT $LN74@Py_Mangle
  0023a	f6 c1 40	 test	 cl, 64			; 00000040H
  0023d	74 12		 je	 SHORT $LN72@Py_Mangle
  0023f	42 0f b6 4c 23
	7e		 movzx	 ecx, BYTE PTR [rbx+r12+126]
  00245	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0024c	e9 80 00 00 00	 jmp	 $LN85@Py_Mangle
$LN72@Py_Mangle:
  00251	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00258	42 0f b6 4c 20
	fe		 movzx	 ecx, BYTE PTR [rax+r12-2]
  0025e	eb 71		 jmp	 SHORT $LN85@Py_Mangle
$LN74@Py_Mangle:
  00260	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00267	42 0f b6 4c 20
	fe		 movzx	 ecx, BYTE PTR [rax+r12-2]
  0026d	eb 62		 jmp	 SHORT $LN85@Py_Mangle
$LN86@Py_Mangle:
  0026f	83 fa 02	 cmp	 edx, 2
  00272	75 36		 jne	 SHORT $LN84@Py_Mangle
  00274	85 c0		 test	 eax, eax
  00276	74 23		 je	 SHORT $LN78@Py_Mangle
  00278	f6 c1 40	 test	 cl, 64			; 00000040H
  0027b	74 0f		 je	 SHORT $LN76@Py_Mangle
  0027d	42 0f b7 4c 63
	7c		 movzx	 ecx, WORD PTR [rbx+r12*2+124]
  00283	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  0028a	eb 45		 jmp	 SHORT $LN85@Py_Mangle
$LN76@Py_Mangle:
  0028c	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00293	42 0f b7 4c 60
	fc		 movzx	 ecx, WORD PTR [rax+r12*2-4]
  00299	eb 36		 jmp	 SHORT $LN85@Py_Mangle
$LN78@Py_Mangle:
  0029b	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  002a2	42 0f b7 4c 60
	fc		 movzx	 ecx, WORD PTR [rax+r12*2-4]
  002a8	eb 27		 jmp	 SHORT $LN85@Py_Mangle
$LN84@Py_Mangle:
  002aa	85 c0		 test	 eax, eax
  002ac	74 17		 je	 SHORT $LN82@Py_Mangle
  002ae	f6 c1 40	 test	 cl, 64			; 00000040H
  002b1	74 09		 je	 SHORT $LN80@Py_Mangle
  002b3	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  002ba	eb 10		 jmp	 SHORT $LN83@Py_Mangle
$LN80@Py_Mangle:
  002bc	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  002c3	eb 07		 jmp	 SHORT $LN83@Py_Mangle
$LN82@Py_Mangle:
  002c5	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN83@Py_Mangle:
  002cc	42 8b 4c a0 f8	 mov	 ecx, DWORD PTR [rax+r12*4-8]
$LN85@Py_Mangle:
  002d1	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  002d4	74 20		 je	 SHORT $LN18@Py_Mangle
$LN17@Py_Mangle:
  002d6	45 33 c0	 xor	 r8d, r8d
  002d9	4d 8b cc	 mov	 r9, r12
  002dc	48 8b cb	 mov	 rcx, rbx
  002df	41 8d 50 2e	 lea	 edx, QWORD PTR [r8+46]
  002e3	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  002eb	e8 00 00 00 00	 call	 PyUnicode_FindChar
  002f0	48 83 f8 ff	 cmp	 rax, -1
  002f4	74 1c		 je	 SHORT $LN19@Py_Mangle
$LN18@Py_Mangle:

; 238  :         Py_INCREF(ident);

  002f6	48 8b cb	 mov	 rcx, rbx
  002f9	e8 00 00 00 00	 call	 _Py_IncRef
  002fe	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00303	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 239  :         return ident; /* Don't mangle __whatever__ */

  00308	48 8b c3	 mov	 rax, rbx

; 276  : }

  0030b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0030f	5e		 pop	 rsi
  00310	5b		 pop	 rbx
  00311	c3		 ret	 0
$LN19@Py_Mangle:

; 240  :     }
; 241  :     /* Strip leading underscores from class name */
; 242  :     ipriv = 0;

  00312	8b 56 70	 mov	 edx, DWORD PTR [rsi+112]
  00315	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0031a	33 ed		 xor	 ebp, ebp
  0031c	44 8b c2	 mov	 r8d, edx
  0031f	41 c1 e8 02	 shr	 r8d, 2
  00323	41 83 e0 07	 and	 r8d, 7
$LL16@Py_Mangle:

; 243  :     while (PyUnicode_READ_CHAR(privateobj, ipriv) == '_')

  00327	41 83 f8 01	 cmp	 r8d, 1
  0032b	75 31		 jne	 SHORT $LN102@Py_Mangle
  0032d	f6 c2 20	 test	 dl, 32			; 00000020H
  00330	74 1f		 je	 SHORT $LN90@Py_Mangle
  00332	f6 c2 40	 test	 dl, 64			; 00000040H
  00335	74 0d		 je	 SHORT $LN88@Py_Mangle
  00337	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  0033e	0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+rbp]
  00342	eb 77		 jmp	 SHORT $LN101@Py_Mangle
$LN88@Py_Mangle:
  00344	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  0034b	0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+rbp]
  0034f	eb 6a		 jmp	 SHORT $LN101@Py_Mangle
$LN90@Py_Mangle:
  00351	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  00358	0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+rbp]
  0035c	eb 5d		 jmp	 SHORT $LN101@Py_Mangle
$LN102@Py_Mangle:
  0035e	41 83 f8 02	 cmp	 r8d, 2
  00362	75 31		 jne	 SHORT $LN100@Py_Mangle
  00364	f6 c2 20	 test	 dl, 32			; 00000020H
  00367	74 1f		 je	 SHORT $LN94@Py_Mangle
  00369	f6 c2 40	 test	 dl, 64			; 00000040H
  0036c	74 0d		 je	 SHORT $LN92@Py_Mangle
  0036e	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  00375	0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+rbp*2]
  00379	eb 40		 jmp	 SHORT $LN101@Py_Mangle
$LN92@Py_Mangle:
  0037b	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  00382	0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+rbp*2]
  00386	eb 33		 jmp	 SHORT $LN101@Py_Mangle
$LN94@Py_Mangle:
  00388	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
  0038f	0f b7 0c 68	 movzx	 ecx, WORD PTR [rax+rbp*2]
  00393	eb 26		 jmp	 SHORT $LN101@Py_Mangle
$LN100@Py_Mangle:
  00395	f6 c2 20	 test	 dl, 32			; 00000020H
  00398	74 17		 je	 SHORT $LN98@Py_Mangle
  0039a	f6 c2 40	 test	 dl, 64			; 00000040H
  0039d	74 09		 je	 SHORT $LN96@Py_Mangle
  0039f	48 8d 86 80 00
	00 00		 lea	 rax, QWORD PTR [rsi+128]
  003a6	eb 10		 jmp	 SHORT $LN99@Py_Mangle
$LN96@Py_Mangle:
  003a8	48 8d 86 a0 00
	00 00		 lea	 rax, QWORD PTR [rsi+160]
  003af	eb 07		 jmp	 SHORT $LN99@Py_Mangle
$LN98@Py_Mangle:
  003b1	48 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [rsi+160]
$LN99@Py_Mangle:
  003b8	8b 0c a8	 mov	 ecx, DWORD PTR [rax+rbp*4]
$LN101@Py_Mangle:
  003bb	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  003be	75 08		 jne	 SHORT $LN15@Py_Mangle

; 244  :         ipriv++;

  003c0	48 ff c5	 inc	 rbp
  003c3	e9 5f ff ff ff	 jmp	 $LL16@Py_Mangle
$LN15@Py_Mangle:

; 245  :     if (ipriv == plen) {

  003c8	49 3b ed	 cmp	 rbp, r13
  003cb	75 10		 jne	 SHORT $LN14@Py_Mangle

; 246  :         Py_INCREF(ident);

  003cd	48 8b cb	 mov	 rcx, rbx
  003d0	e8 00 00 00 00	 call	 _Py_IncRef

; 247  :         return ident; /* Don't mangle if class is just underscores */

  003d5	48 8b c3	 mov	 rax, rbx
  003d8	e9 c7 01 00 00	 jmp	 $LN135@Py_Mangle
$LN14@Py_Mangle:

; 248  :     }
; 249  :     plen -= ipriv;

  003dd	4c 2b ed	 sub	 r13, rbp

; 250  : 
; 251  :     if (plen + nlen >= PY_SSIZE_T_MAX - 1) {

  003e0	48 b8 fe ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775806 ; 7ffffffffffffffeH
  003ea	4f 8d 4c 25 00	 lea	 r9, QWORD PTR [r13+r12]
  003ef	4c 3b c8	 cmp	 r9, rax
  003f2	72 1a		 jb	 SHORT $LN13@Py_Mangle

; 252  :         PyErr_SetString(PyExc_OverflowError,
; 253  :                         "private identifier too large to be mangled");

  003f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  003fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FMJEBAFL@private?5identifier?5too?5large?5to?5@
  00402	e8 00 00 00 00	 call	 PyErr_SetString

; 254  :         return NULL;

  00407	33 c0		 xor	 eax, eax
  00409	e9 96 01 00 00	 jmp	 $LN135@Py_Mangle
$LN13@Py_Mangle:

; 255  :     }
; 256  : 
; 257  :     maxchar = PyUnicode_MAX_CHAR_VALUE(ident);

  0040e	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00411	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00416	41 ba ff ff 00
	00		 mov	 r10d, 65535		; 0000ffffH
  0041c	f6 c1 40	 test	 cl, 64			; 00000040H
  0041f	74 07		 je	 SHORT $LN106@Py_Mangle
  00421	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00426	eb 1e		 jmp	 SHORT $LN105@Py_Mangle
$LN106@Py_Mangle:
  00428	c1 e9 02	 shr	 ecx, 2
  0042b	83 e1 07	 and	 ecx, 7
  0042e	83 f9 01	 cmp	 ecx, 1
  00431	75 07		 jne	 SHORT $LN104@Py_Mangle
  00433	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00438	eb 0c		 jmp	 SHORT $LN105@Py_Mangle
$LN104@Py_Mangle:
  0043a	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  0043f	83 f9 02	 cmp	 ecx, 2
  00442	41 0f 44 c2	 cmove	 eax, r10d
$LN105@Py_Mangle:

; 258  :     if (PyUnicode_MAX_CHAR_VALUE(privateobj) > maxchar)

  00446	c1 ea 06	 shr	 edx, 6
  00449	83 e2 01	 and	 edx, 1
  0044c	74 07		 je	 SHORT $LN110@Py_Mangle
  0044e	b9 7f 00 00 00	 mov	 ecx, 127		; 0000007fH
  00453	eb 1a		 jmp	 SHORT $LN109@Py_Mangle
$LN110@Py_Mangle:
  00455	41 83 f8 01	 cmp	 r8d, 1
  00459	75 07		 jne	 SHORT $LN108@Py_Mangle
  0045b	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00460	eb 0d		 jmp	 SHORT $LN109@Py_Mangle
$LN108@Py_Mangle:
  00462	b9 ff ff 10 00	 mov	 ecx, 1114111		; 0010ffffH
  00467	41 83 f8 02	 cmp	 r8d, 2
  0046b	41 0f 44 ca	 cmove	 ecx, r10d
$LN109@Py_Mangle:
  0046f	3b c8		 cmp	 ecx, eax
  00471	76 25		 jbe	 SHORT $LN113@Py_Mangle

; 259  :         maxchar = PyUnicode_MAX_CHAR_VALUE(privateobj);

  00473	85 d2		 test	 edx, edx
  00475	74 07		 je	 SHORT $LN114@Py_Mangle
  00477	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  0047c	eb 1a		 jmp	 SHORT $LN113@Py_Mangle
$LN114@Py_Mangle:
  0047e	41 83 f8 01	 cmp	 r8d, 1
  00482	75 07		 jne	 SHORT $LN112@Py_Mangle
  00484	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00489	eb 0d		 jmp	 SHORT $LN113@Py_Mangle
$LN112@Py_Mangle:
  0048b	b8 ff ff 10 00	 mov	 eax, 1114111		; 0010ffffH
  00490	41 83 f8 02	 cmp	 r8d, 2
  00494	41 0f 44 c2	 cmove	 eax, r10d
$LN113@Py_Mangle:

; 260  : 
; 261  :     result = PyUnicode_New(1 + nlen + plen, maxchar);

  00498	49 8d 49 01	 lea	 rcx, QWORD PTR [r9+1]
  0049c	8b d0		 mov	 edx, eax
  0049e	e8 00 00 00 00	 call	 PyUnicode_New
  004a3	48 8b f8	 mov	 rdi, rax

; 262  :     if (!result)

  004a6	48 85 c0	 test	 rax, rax

; 263  :         return 0;

  004a9	0f 84 ee 00 00
	00		 je	 $LN138@Py_Mangle

; 264  :     /* ident = "_" + priv[ipriv:] + ident # i.e. 1+plen+nlen bytes */
; 265  :     PyUnicode_WRITE(PyUnicode_KIND(result), PyUnicode_DATA(result), 0, '_');

  004af	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004b2	8b c8		 mov	 ecx, eax
  004b4	c1 e9 02	 shr	 ecx, 2
  004b7	83 e1 07	 and	 ecx, 7
  004ba	ff c9		 dec	 ecx
  004bc	74 7a		 je	 SHORT $LN5@Py_Mangle
  004be	ff c9		 dec	 ecx
  004c0	74 3b		 je	 SHORT $LN4@Py_Mangle
  004c2	a8 20		 test	 al, 32			; 00000020H
  004c4	74 27		 je	 SHORT $LN126@Py_Mangle
  004c6	a8 40		 test	 al, 64			; 00000040H
  004c8	74 13		 je	 SHORT $LN124@Py_Mangle
  004ca	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  004d1	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  004d6	89 08		 mov	 DWORD PTR [rax], ecx
  004d8	e9 7f 00 00 00	 jmp	 $LN9@Py_Mangle
$LN124@Py_Mangle:
  004dd	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  004e4	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  004e9	89 08		 mov	 DWORD PTR [rax], ecx
  004eb	eb 6f		 jmp	 SHORT $LN9@Py_Mangle
$LN126@Py_Mangle:
  004ed	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  004f4	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  004f9	89 08		 mov	 DWORD PTR [rax], ecx
  004fb	eb 5f		 jmp	 SHORT $LN9@Py_Mangle
$LN4@Py_Mangle:
  004fd	a8 20		 test	 al, 32			; 00000020H
  004ff	74 26		 je	 SHORT $LN122@Py_Mangle
  00501	a8 40		 test	 al, 64			; 00000040H
  00503	74 11		 je	 SHORT $LN120@Py_Mangle
  00505	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  0050c	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00511	66 89 08	 mov	 WORD PTR [rax], cx
  00514	eb 46		 jmp	 SHORT $LN9@Py_Mangle
$LN120@Py_Mangle:
  00516	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0051d	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00522	66 89 08	 mov	 WORD PTR [rax], cx
  00525	eb 35		 jmp	 SHORT $LN9@Py_Mangle
$LN122@Py_Mangle:
  00527	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0052e	b9 5f 00 00 00	 mov	 ecx, 95			; 0000005fH
  00533	66 89 08	 mov	 WORD PTR [rax], cx
  00536	eb 24		 jmp	 SHORT $LN9@Py_Mangle
$LN5@Py_Mangle:
  00538	a8 20		 test	 al, 32			; 00000020H
  0053a	74 16		 je	 SHORT $LN118@Py_Mangle
  0053c	a8 40		 test	 al, 64			; 00000040H
  0053e	74 09		 je	 SHORT $LN116@Py_Mangle
  00540	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00547	eb 10		 jmp	 SHORT $LN119@Py_Mangle
$LN116@Py_Mangle:
  00549	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00550	eb 07		 jmp	 SHORT $LN119@Py_Mangle
$LN118@Py_Mangle:
  00552	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN119@Py_Mangle:
  00559	c6 00 5f	 mov	 BYTE PTR [rax], 95	; 0000005fH
$LN9@Py_Mangle:

; 266  :     if (PyUnicode_CopyCharacters(result, 1, privateobj, ipriv, plen) < 0) {

  0055c	4c 8b cd	 mov	 r9, rbp
  0055f	4c 8b c6	 mov	 r8, rsi
  00562	ba 01 00 00 00	 mov	 edx, 1
  00567	48 8b cf	 mov	 rcx, rdi
  0056a	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0056f	e8 00 00 00 00	 call	 PyUnicode_CopyCharacters

; 267  :         Py_DECREF(result);

  00574	48 8b cf	 mov	 rcx, rdi
  00577	48 85 c0	 test	 rax, rax

; 268  :         return NULL;

  0057a	78 1c		 js	 SHORT $LN137@Py_Mangle

; 269  :     }
; 270  :     if (PyUnicode_CopyCharacters(result, plen+1, ident, 0, nlen) < 0) {

  0057c	49 8d 55 01	 lea	 rdx, QWORD PTR [r13+1]
  00580	45 33 c9	 xor	 r9d, r9d
  00583	4c 8b c3	 mov	 r8, rbx
  00586	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0058b	e8 00 00 00 00	 call	 PyUnicode_CopyCharacters
  00590	48 85 c0	 test	 rax, rax
  00593	79 25		 jns	 SHORT $LN1@Py_Mangle

; 271  :         Py_DECREF(result);

  00595	48 8b cf	 mov	 rcx, rdi
$LN137@Py_Mangle:
  00598	e8 00 00 00 00	 call	 _Py_DecRef
$LN138@Py_Mangle:

; 272  :         return NULL;

  0059d	33 c0		 xor	 eax, eax
$LN136@Py_Mangle:
  0059f	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
$LN135@Py_Mangle:
  005a4	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  005a9	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  005ae	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]

; 276  : }

  005b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  005b7	5e		 pop	 rsi
  005b8	5b		 pop	 rbx
  005b9	c3		 ret	 0
$LN1@Py_Mangle:

; 273  :     }
; 274  :     assert(_PyUnicode_CheckConsistency(result, 1));
; 275  :     return result;

  005ba	48 8b c7	 mov	 rax, rdi
  005bd	eb e0		 jmp	 SHORT $LN136@Py_Mangle
$LN20@Py_Mangle:

; 221  :         Py_INCREF(ident);

  005bf	e8 00 00 00 00	 call	 _Py_PXCTX
  005c4	85 c0		 test	 eax, eax
  005c6	75 32		 jne	 SHORT $LN129@Py_Mangle
  005c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  005d6	4c 8b cb	 mov	 r9, rbx
  005d9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  005df	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  005e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  005ec	85 c0		 test	 eax, eax
  005ee	75 06		 jne	 SHORT $LN128@Py_Mangle
  005f0	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  005f4	74 04		 je	 SHORT $LN129@Py_Mangle
$LN128@Py_Mangle:
  005f6	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN129@Py_Mangle:

; 222  :         return ident;

  005fa	48 8b c3	 mov	 rax, rbx

; 276  : }

  005fd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00601	5e		 pop	 rsi
  00602	5b		 pop	 rbx
  00603	c3		 ret	 0
_Py_Mangle ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_init DD imagerel compiler_init
	DD	imagerel compiler_init+47
	DD	imagerel $unwind$compiler_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_init DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_init
_TEXT	SEGMENT
c$ = 48
compiler_init PROC					; COMDAT

; 280  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 281  :     memset(c, 0, sizeof(struct compiler));

  00006	33 d2		 xor	 edx, edx
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	44 8d 42 50	 lea	 r8d, QWORD PTR [rdx+80]
  0000f	e8 00 00 00 00	 call	 memset

; 282  : 
; 283  :     c->c_stack = PyList_New(0);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 PyList_New

; 284  :     if (!c->c_stack)

  0001b	33 c9		 xor	 ecx, ecx
  0001d	48 85 c0	 test	 rax, rax
  00020	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
  00024	0f 95 c1	 setne	 cl
  00027	8b c1		 mov	 eax, ecx

; 285  :         return 0;
; 286  : 
; 287  :     return 1;
; 288  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
compiler_init ENDP
_TEXT	ENDS
EXTRN	PyObject_Free:PROC
EXTRN	PySymtable_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_free DD imagerel compiler_free
	DD	imagerel compiler_free+65
	DD	imagerel $unwind$compiler_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_free DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_free
_TEXT	SEGMENT
c$ = 48
compiler_free PROC					; COMDAT

; 358  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 359  :     if (c->c_st)

  00009	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 05		 je	 SHORT $LN3@compiler_f

; 360  :         PySymtable_Free(c->c_st);

  00012	e8 00 00 00 00	 call	 PySymtable_Free
$LN3@compiler_f:

; 361  :     if (c->c_future)

  00017	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 05		 je	 SHORT $LN2@compiler_f

; 362  :         PyObject_Free(c->c_future);

  00020	e8 00 00 00 00	 call	 PyObject_Free
$LN2@compiler_f:

; 363  :     if (c->c_filename_obj)

  00025	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 05		 je	 SHORT $LN1@compiler_f

; 364  :         Py_DECREF(c->c_filename_obj);

  0002e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compiler_f:

; 365  :     Py_DECREF(c->c_stack);

  00033	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]

; 366  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	e9 00 00 00 00	 jmp	 _Py_DecRef
compiler_free ENDP
_TEXT	ENDS
EXTRN	PyDict_SetItem:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyList_Size:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$list2dict DD imagerel list2dict
	DD	imagerel list2dict+32
	DD	imagerel $unwind$list2dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$list2dict DD imagerel list2dict+32
	DD	imagerel list2dict+196
	DD	imagerel $chain$3$list2dict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$list2dict DD imagerel list2dict+196
	DD	imagerel list2dict+438
	DD	imagerel $chain$5$list2dict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$list2dict DD 080021H
	DD	06c400H
	DD	0c7400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel list2dict
	DD	imagerel list2dict+32
	DD	imagerel $unwind$list2dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$list2dict DD 081721H
	DD	06c417H
	DD	0c7412H
	DD	0b640aH
	DD	0a5405H
	DD	imagerel list2dict
	DD	imagerel list2dict+32
	DD	imagerel $unwind$list2dict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$list2dict DD 030801H
	DD	0d0046208H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT list2dict
_TEXT	SEGMENT
list$ = 80
list2dict PROC						; COMDAT

; 370  : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	4c 8b e9	 mov	 r13, rcx

; 371  :     Py_ssize_t i, n;
; 372  :     PyObject *v, *k;
; 373  :     PyObject *dict = PyDict_New();

  0000b	e8 00 00 00 00	 call	 PyDict_New
  00010	48 8b d8	 mov	 rbx, rax

; 374  :     if (!dict) return NULL;

  00013	48 85 c0	 test	 rax, rax
  00016	75 08		 jne	 SHORT $LN11@list2dict

; 395  : }

  00018	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001c	41 5d		 pop	 r13
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
$LN11@list2dict:
  00020	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00025	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi

; 375  : 
; 376  :     n = PyList_Size(list);

  0002a	49 8b cd	 mov	 rcx, r13
  0002d	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00032	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00037	e8 00 00 00 00	 call	 PyList_Size

; 377  :     for (i = 0; i < n; i++) {

  0003c	33 f6		 xor	 esi, esi
  0003e	4c 8b e0	 mov	 r12, rax
  00041	48 85 c0	 test	 rax, rax
  00044	7e 5f		 jle	 SHORT $LN8@list2dict
$LL10@list2dict:

; 378  :         v = PyLong_FromLong(i);

  00046	8b ce		 mov	 ecx, esi
  00048	e8 00 00 00 00	 call	 PyLong_FromLong
  0004d	48 8b e8	 mov	 rbp, rax

; 379  :         if (!v) {

  00050	48 85 c0	 test	 rax, rax
  00053	0f 84 e7 00 00
	00		 je	 $LN37@list2dict

; 382  :         }
; 383  :         k = PyList_GET_ITEM(list, i);

  00059	49 8b 4d 70	 mov	 rcx, QWORD PTR [r13+112]
  0005d	48 8b 14 f1	 mov	 rdx, QWORD PTR [rcx+rsi*8]

; 384  :         k = PyTuple_Pack(2, k, k->ob_type);

  00061	b9 02 00 00 00	 mov	 ecx, 2
  00066	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0006a	e8 00 00 00 00	 call	 PyTuple_Pack
  0006f	48 8b f8	 mov	 rdi, rax

; 385  :         if (k == NULL || PyDict_SetItem(dict, k, v) < 0) {

  00072	48 85 c0	 test	 rax, rax
  00075	0f 84 ae 00 00
	00		 je	 $LN3@list2dict
  0007b	4c 8b c5	 mov	 r8, rbp
  0007e	48 8b d0	 mov	 rdx, rax
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 PyDict_SetItem
  00089	85 c0		 test	 eax, eax
  0008b	78 37		 js	 SHORT $LN4@list2dict

; 390  :         }
; 391  :         Py_DECREF(k);

  0008d	48 8b cf	 mov	 rcx, rdi
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 392  :         Py_DECREF(v);

  00095	48 8b cd	 mov	 rcx, rbp
  00098	e8 00 00 00 00	 call	 _Py_DecRef
  0009d	48 ff c6	 inc	 rsi
  000a0	49 3b f4	 cmp	 rsi, r12
  000a3	7c a1		 jl	 SHORT $LL10@list2dict
$LN8@list2dict:

; 393  :     }
; 394  :     return dict;

  000a5	48 8b c3	 mov	 rax, rbx
$LN43@list2dict:
  000a8	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  000ad	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000b2	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000b7	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 395  : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	41 5d		 pop	 r13
  000c2	5b		 pop	 rbx
  000c3	c3		 ret	 0
$LN4@list2dict:

; 386  :             Py_XDECREF(k);

  000c4	e8 00 00 00 00	 call	 _Py_PXCTX
  000c9	85 c0		 test	 eax, eax
  000cb	75 5c		 jne	 SHORT $LN3@list2dict
  000cd	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000d1	a8 20		 test	 al, 32			; 00000020H
  000d3	75 4c		 jne	 SHORT $LN29@list2dict
  000d5	84 c0		 test	 al, al
  000d7	78 48		 js	 SHORT $LN29@list2dict
  000d9	a8 02		 test	 al, 2
  000db	75 4c		 jne	 SHORT $LN3@list2dict
  000dd	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000e1	75 46		 jne	 SHORT $LN3@list2dict
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f1	4c 8b cf	 mov	 r9, rdi
  000f4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000fa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00102	e8 00 00 00 00	 call	 _PyParallel_Guard
  00107	48 8b cf	 mov	 rcx, rdi
  0010a	85 c0		 test	 eax, eax
  0010c	74 07		 je	 SHORT $LN34@list2dict
  0010e	e8 00 00 00 00	 call	 _Px_Dealloc
  00113	eb 14		 jmp	 SHORT $LN3@list2dict
$LN34@list2dict:
  00115	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00119	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0011f	eb 08		 jmp	 SHORT $LN3@list2dict
$LN29@list2dict:
  00121	48 8b cf	 mov	 rcx, rdi
  00124	e8 00 00 00 00	 call	 Px_DecRef
$LN3@list2dict:

; 387  :             Py_DECREF(v);

  00129	48 8b cd	 mov	 rcx, rbp
  0012c	e8 00 00 00 00	 call	 _Py_DecRef

; 388  :             Py_DECREF(dict);

  00131	48 8b cb	 mov	 rcx, rbx
  00134	e8 00 00 00 00	 call	 _Py_DecRef

; 389  :             return NULL;

  00139	33 c0		 xor	 eax, eax
  0013b	e9 68 ff ff ff	 jmp	 $LN43@list2dict
$LN37@list2dict:

; 380  :             Py_DECREF(dict);

  00140	e8 00 00 00 00	 call	 _Py_PXCTX
  00145	85 c0		 test	 eax, eax
  00147	75 66		 jne	 SHORT $LN24@list2dict
  00149	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0014d	a8 20		 test	 al, 32			; 00000020H
  0014f	75 56		 jne	 SHORT $LN18@list2dict
  00151	84 c0		 test	 al, al
  00153	78 52		 js	 SHORT $LN18@list2dict
  00155	a8 02		 test	 al, 2
  00157	75 56		 jne	 SHORT $LN24@list2dict
  00159	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0015d	75 50		 jne	 SHORT $LN24@list2dict
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016d	4c 8b cb	 mov	 r9, rbx
  00170	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00176	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00183	48 8b cb	 mov	 rcx, rbx
  00186	85 c0		 test	 eax, eax
  00188	74 0c		 je	 SHORT $LN23@list2dict
  0018a	e8 00 00 00 00	 call	 _Px_Dealloc

; 381  :             return NULL;

  0018f	33 c0		 xor	 eax, eax
  00191	e9 12 ff ff ff	 jmp	 $LN43@list2dict

; 380  :             Py_DECREF(dict);

$LN23@list2dict:
  00196	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0019a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 381  :             return NULL;

  001a0	33 c0		 xor	 eax, eax
  001a2	e9 01 ff ff ff	 jmp	 $LN43@list2dict

; 380  :             Py_DECREF(dict);

$LN18@list2dict:
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	e8 00 00 00 00	 call	 Px_DecRef
$LN24@list2dict:

; 381  :             return NULL;

  001af	33 c0		 xor	 eax, eax
  001b1	e9 f2 fe ff ff	 jmp	 $LN43@list2dict
list2dict ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyList_Sort:PROC
EXTRN	PyDict_Keys:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$dictbytype DD imagerel dictbytype
	DD	imagerel dictbytype+57
	DD	imagerel $unwind$dictbytype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$dictbytype DD imagerel dictbytype+57
	DD	imagerel dictbytype+114
	DD	imagerel $chain$0$dictbytype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$dictbytype DD imagerel dictbytype+114
	DD	imagerel dictbytype+332
	DD	imagerel $chain$5$dictbytype
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$dictbytype DD imagerel dictbytype+332
	DD	imagerel dictbytype+393
	DD	imagerel $chain$7$dictbytype
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$dictbytype DD 080021H
	DD	04e400H
	DD	056400H
	DD	065400H
	DD	0e3400H
	DD	imagerel dictbytype
	DD	imagerel dictbytype+57
	DD	imagerel $unwind$dictbytype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$dictbytype DD 080f21H
	DD	04e40fH
	DD	05640aH
	DD	0e3405H
	DD	065400H
	DD	imagerel dictbytype
	DD	imagerel dictbytype+57
	DD	imagerel $unwind$dictbytype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$dictbytype DD 020521H
	DD	065405H
	DD	imagerel dictbytype
	DD	imagerel dictbytype+57
	DD	imagerel $unwind$dictbytype
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dictbytype DD 051401H
	DD	0f0106214H
	DD	0c00cd00eH
	DD	0700aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT dictbytype
_TEXT	SEGMENT
src$ = 96
scope_type$ = 104
flag$ = 112
offset$ = 120
dictbytype PROC						; COMDAT

; 407  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 57		 push	 r15
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00014	45 8b f8	 mov	 r15d, r8d
  00017	48 8b f9	 mov	 rdi, rcx

; 408  :     Py_ssize_t i = offset, scope, num_keys, key_i;

  0001a	4d 63 e9	 movsxd	 r13, r9d

; 409  :     PyObject *k, *v, *dest = PyDict_New();

  0001d	e8 00 00 00 00	 call	 PyDict_New
  00022	4c 8b e0	 mov	 r12, rax

; 410  :     PyObject *sorted_keys;
; 411  : 
; 412  :     assert(offset >= 0);
; 413  :     if (dest == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 0c		 jne	 SHORT $LN15@dictbytype

; 461  : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	41 5f		 pop	 r15
  00030	41 5d		 pop	 r13
  00032	41 5c		 pop	 r12
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN15@dictbytype:

; 414  :         return NULL;
; 415  : 
; 416  :     /* Sort the keys so that we have a deterministic order on the indexes
; 417  :        saved in the returned dictionary.  These indexes are used as indexes
; 418  :        into the free and cell var storage.  Therefore if they aren't
; 419  :        deterministic, then the generated bytecode is not deterministic.
; 420  :     */
; 421  :     sorted_keys = PyDict_Keys(src);

  00036	48 8b cf	 mov	 rcx, rdi
  00039	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003e	e8 00 00 00 00	 call	 PyDict_Keys
  00043	48 8b e8	 mov	 rbp, rax

; 422  :     if (sorted_keys == NULL)

  00046	48 85 c0	 test	 rax, rax

; 423  :         return NULL;

  00049	74 14		 je	 SHORT $LN26@dictbytype

; 424  :     if (PyList_Sort(sorted_keys) != 0) {

  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 PyList_Sort
  00053	85 c0		 test	 eax, eax
  00055	74 1b		 je	 SHORT $LN13@dictbytype

; 425  :         Py_DECREF(sorted_keys);

  00057	48 8b cd	 mov	 rcx, rbp
  0005a	e8 00 00 00 00	 call	 _Py_DecRef
$LN26@dictbytype:

; 426  :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 461  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	41 5f		 pop	 r15
  0006c	41 5d		 pop	 r13
  0006e	41 5c		 pop	 r12
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
$LN13@dictbytype:
  00072	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00077	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  0007c	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 427  :     }
; 428  :     num_keys = PyList_GET_SIZE(sorted_keys);

  00081	4c 8b 75 60	 mov	 r14, QWORD PTR [rbp+96]

; 429  : 
; 430  :     for (key_i = 0; key_i < num_keys; key_i++) {

  00085	33 f6		 xor	 esi, esi
  00087	4d 85 f6	 test	 r14, r14
  0008a	0f 8e 91 00 00
	00		 jle	 $LN10@dictbytype
$LL12@dictbytype:

; 431  :         /* XXX this should probably be a macro in symtable.h */
; 432  :         long vi;
; 433  :         k = PyList_GET_ITEM(sorted_keys, key_i);

  00090	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]

; 434  :         v = PyDict_GetItem(src, k);

  00094	48 8b cf	 mov	 rcx, rdi
  00097	48 8b 1c f0	 mov	 rbx, QWORD PTR [rax+rsi*8]
  0009b	48 8b d3	 mov	 rdx, rbx
  0009e	e8 00 00 00 00	 call	 PyDict_GetItem

; 435  :         assert(PyLong_Check(v));
; 436  :         vi = PyLong_AS_LONG(v);

  000a3	48 8b c8	 mov	 rcx, rax
  000a6	e8 00 00 00 00	 call	 PyLong_AsLong

; 437  :         scope = (vi >> SCOPE_OFFSET) & SCOPE_MASK;
; 438  : 
; 439  :         if (scope == scope_type || vi & flag) {

  000ab	8b c8		 mov	 ecx, eax
  000ad	c1 f9 0b	 sar	 ecx, 11
  000b0	83 e1 0f	 and	 ecx, 15
  000b3	3b 4c 24 68	 cmp	 ecx, DWORD PTR scope_type$[rsp]
  000b7	74 05		 je	 SHORT $LN8@dictbytype
  000b9	41 85 c7	 test	 eax, r15d
  000bc	74 57		 je	 SHORT $LN11@dictbytype
$LN8@dictbytype:

; 440  :             PyObject *tuple, *item = PyLong_FromLong(i);

  000be	41 8b cd	 mov	 ecx, r13d
  000c1	e8 00 00 00 00	 call	 PyLong_FromLong
  000c6	48 8b f8	 mov	 rdi, rax

; 441  :             if (item == NULL) {

  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 84 a3 00 00
	00		 je	 $LN19@dictbytype

; 445  :             }
; 446  :             i++;
; 447  :             tuple = PyTuple_Pack(2, k, k->ob_type);

  000d2	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000d6	48 8b d3	 mov	 rdx, rbx
  000d9	b9 02 00 00 00	 mov	 ecx, 2
  000de	49 ff c5	 inc	 r13
  000e1	e8 00 00 00 00	 call	 PyTuple_Pack
  000e6	48 8b d8	 mov	 rbx, rax

; 448  :             if (!tuple || PyDict_SetItem(dest, tuple, item) < 0) {

  000e9	48 85 c0	 test	 rax, rax
  000ec	74 5e		 je	 SHORT $LN20@dictbytype
  000ee	4c 8b c7	 mov	 r8, rdi
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	49 8b cc	 mov	 rcx, r12
  000f7	e8 00 00 00 00	 call	 PyDict_SetItem
  000fc	85 c0		 test	 eax, eax
  000fe	78 4c		 js	 SHORT $LN20@dictbytype

; 454  :             }
; 455  :             Py_DECREF(item);

  00100	48 8b cf	 mov	 rcx, rdi
  00103	e8 00 00 00 00	 call	 _Py_DecRef

; 456  :             Py_DECREF(tuple);

  00108	48 8b cb	 mov	 rcx, rbx
  0010b	e8 00 00 00 00	 call	 _Py_DecRef
  00110	48 8b 7c 24 60	 mov	 rdi, QWORD PTR src$[rsp]
$LN11@dictbytype:

; 429  : 
; 430  :     for (key_i = 0; key_i < num_keys; key_i++) {

  00115	48 ff c6	 inc	 rsi
  00118	49 3b f6	 cmp	 rsi, r14
  0011b	0f 8c 6f ff ff
	ff		 jl	 $LL12@dictbytype
$LN10@dictbytype:

; 457  :         }
; 458  :     }
; 459  :     Py_DECREF(sorted_keys);

  00121	48 8b cd	 mov	 rcx, rbp
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 460  :     return dest;

  00129	49 8b c4	 mov	 rax, r12
$LN25@dictbytype:
  0012c	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  00131	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00136	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  0013b	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 461  : }

  00140	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00144	41 5f		 pop	 r15
  00146	41 5d		 pop	 r13
  00148	41 5c		 pop	 r12
  0014a	5f		 pop	 rdi
  0014b	c3		 ret	 0
$LN20@dictbytype:

; 449  :                 Py_DECREF(sorted_keys);

  0014c	48 8b cd	 mov	 rcx, rbp
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 450  :                 Py_DECREF(item);

  00154	48 8b cf	 mov	 rcx, rdi
  00157	e8 00 00 00 00	 call	 _Py_DecRef

; 451  :                 Py_DECREF(dest);

  0015c	49 8b cc	 mov	 rcx, r12
  0015f	e8 00 00 00 00	 call	 _Py_DecRef

; 452  :                 Py_XDECREF(tuple);

  00164	48 85 db	 test	 rbx, rbx
  00167	74 08		 je	 SHORT $LN3@dictbytype
  00169	48 8b cb	 mov	 rcx, rbx
  0016c	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@dictbytype:

; 453  :                 return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	eb b7		 jmp	 SHORT $LN25@dictbytype
$LN19@dictbytype:

; 442  :                 Py_DECREF(sorted_keys);

  00175	48 8b cd	 mov	 rcx, rbp
  00178	e8 00 00 00 00	 call	 _Py_DecRef

; 443  :                 Py_DECREF(dest);

  0017d	49 8b cc	 mov	 rcx, r12
  00180	e8 00 00 00 00	 call	 _Py_DecRef

; 444  :                 return NULL;

  00185	33 c0		 xor	 eax, eax
  00187	eb a3		 jmp	 SHORT $LN25@dictbytype
dictbytype ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_unit_check
_TEXT	SEGMENT
u$ = 8
compiler_unit_check PROC				; COMDAT

; 466  :     basicblock *block;
; 467  :     for (block = u->u_blocks; block != NULL; block = block->b_list) {

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 85 c0	 test	 rax, rax
  00007	74 0f		 je	 SHORT $LN3@compiler_u
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@compiler_u:
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 85 c0	 test	 rax, rax
  00016	75 f8		 jne	 SHORT $LL5@compiler_u
$LN3@compiler_u:

; 468  :         assert((void *)block != (void *)0xcbcbcbcb);
; 469  :         assert((void *)block != (void *)0xfbfbfbfb);
; 470  :         assert((void *)block != (void *)0xdbdbdbdb);
; 471  :         if (block->b_instr != NULL) {
; 472  :             assert(block->b_ialloc > 0);
; 473  :             assert(block->b_iused > 0);
; 474  :             assert(block->b_ialloc >= block->b_iused);
; 475  :         }
; 476  :         else {
; 477  :             assert (block->b_iused == 0);
; 478  :             assert (block->b_ialloc == 0);
; 479  :         }
; 480  :     }
; 481  : }

  00018	f3 c3		 fatret	 0
compiler_unit_check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@	; `string'
PUBLIC	??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_unit_free DD imagerel compiler_unit_free
	DD	imagerel compiler_unit_free+1518
	DD	imagerel $unwind$compiler_unit_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_unit_free DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
CONST	SEGMENT
??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@ DB 'compiler_unit_free', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
CONST	SEGMENT
??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@ DB '..\Python\compile.c', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT compiler_unit_free
_TEXT	SEGMENT
u$ = 64
compiler_unit_free PROC					; COMDAT

; 485  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 486  :     basicblock *b, *next;
; 487  : 
; 488  :     compiler_unit_check(u);
; 489  :     b = u->u_blocks;

  0000f	48 8b 79 58	 mov	 rdi, QWORD PTR [rcx+88]
  00013	48 8b f1	 mov	 rsi, rcx

; 490  :     while (b != NULL) {

  00016	48 85 ff	 test	 rdi, rdi
  00019	74 26		 je	 SHORT $LN36@compiler_u@2
  0001b	0f 1f 44 00 00	 npad	 5
$LL39@compiler_u@2:

; 491  :         if (b->b_instr)

  00020	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00024	48 85 c9	 test	 rcx, rcx
  00027	74 05		 je	 SHORT $LN37@compiler_u@2

; 492  :             PyObject_Free((void *)b->b_instr);

  00029	e8 00 00 00 00	 call	 PyObject_Free
$LN37@compiler_u@2:

; 493  :         next = b->b_list;

  0002e	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 494  :         PyObject_Free((void *)b);

  00031	48 8b cf	 mov	 rcx, rdi
  00034	e8 00 00 00 00	 call	 PyObject_Free

; 495  :         b = next;

  00039	48 8b fb	 mov	 rdi, rbx
  0003c	48 85 db	 test	 rbx, rbx
  0003f	75 df		 jne	 SHORT $LL39@compiler_u@2
$LN36@compiler_u@2:

; 496  :     }
; 497  :     Py_CLEAR(u->u_ste);

  00041	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
  00044	33 ff		 xor	 edi, edi
  00046	4d 85 c9	 test	 r9, r9
  00049	0f 84 90 00 00
	00		 je	 $LN35@compiler_u@2
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  0005d	41 b8 f1 01 00
	00		 mov	 r8d, 497		; 000001f1H
  00063	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0006b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00070	85 c0		 test	 eax, eax
  00072	75 6b		 jne	 SHORT $LN35@compiler_u@2
  00074	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  00077	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0007a	e8 00 00 00 00	 call	 _Py_PXCTX
  0007f	85 c0		 test	 eax, eax
  00081	75 5c		 jne	 SHORT $LN35@compiler_u@2
  00083	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00087	a8 20		 test	 al, 32			; 00000020H
  00089	75 4c		 jne	 SHORT $LN46@compiler_u@2
  0008b	84 c0		 test	 al, al
  0008d	78 48		 js	 SHORT $LN46@compiler_u@2
  0008f	a8 02		 test	 al, 2
  00091	75 4c		 jne	 SHORT $LN35@compiler_u@2
  00093	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00097	75 46		 jne	 SHORT $LN35@compiler_u@2
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	85 c0		 test	 eax, eax
  000c2	74 07		 je	 SHORT $LN51@compiler_u@2
  000c4	e8 00 00 00 00	 call	 _Px_Dealloc
  000c9	eb 14		 jmp	 SHORT $LN35@compiler_u@2
$LN51@compiler_u@2:
  000cb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000cf	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000d5	eb 08		 jmp	 SHORT $LN35@compiler_u@2
$LN46@compiler_u@2:
  000d7	48 8b cb	 mov	 rcx, rbx
  000da	e8 00 00 00 00	 call	 Px_DecRef
$LN35@compiler_u@2:

; 498  :     Py_CLEAR(u->u_name);

  000df	4c 8b 4e 08	 mov	 r9, QWORD PTR [rsi+8]
  000e3	4d 85 c9	 test	 r9, r9
  000e6	0f 84 92 00 00
	00		 je	 $LN31@compiler_u@2
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  000fa	41 b8 f2 01 00
	00		 mov	 r8d, 498		; 000001f2H
  00100	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00108	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010d	85 c0		 test	 eax, eax
  0010f	75 6d		 jne	 SHORT $LN31@compiler_u@2
  00111	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00115	48 89 7e 08	 mov	 QWORD PTR [rsi+8], rdi
  00119	e8 00 00 00 00	 call	 _Py_PXCTX
  0011e	85 c0		 test	 eax, eax
  00120	75 5c		 jne	 SHORT $LN31@compiler_u@2
  00122	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00126	a8 20		 test	 al, 32			; 00000020H
  00128	75 4c		 jne	 SHORT $LN57@compiler_u@2
  0012a	84 c0		 test	 al, al
  0012c	78 48		 js	 SHORT $LN57@compiler_u@2
  0012e	a8 02		 test	 al, 2
  00130	75 4c		 jne	 SHORT $LN31@compiler_u@2
  00132	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00136	75 46		 jne	 SHORT $LN31@compiler_u@2
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00146	4c 8b cb	 mov	 r9, rbx
  00149	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0014f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00157	e8 00 00 00 00	 call	 _PyParallel_Guard
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	85 c0		 test	 eax, eax
  00161	74 07		 je	 SHORT $LN62@compiler_u@2
  00163	e8 00 00 00 00	 call	 _Px_Dealloc
  00168	eb 14		 jmp	 SHORT $LN31@compiler_u@2
$LN62@compiler_u@2:
  0016a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0016e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00174	eb 08		 jmp	 SHORT $LN31@compiler_u@2
$LN57@compiler_u@2:
  00176	48 8b cb	 mov	 rcx, rbx
  00179	e8 00 00 00 00	 call	 Px_DecRef
$LN31@compiler_u@2:

; 499  :     Py_CLEAR(u->u_qualname);

  0017e	4c 8b 4e 10	 mov	 r9, QWORD PTR [rsi+16]
  00182	4d 85 c9	 test	 r9, r9
  00185	0f 84 92 00 00
	00		 je	 $LN27@compiler_u@2
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00199	41 b8 f3 01 00
	00		 mov	 r8d, 499		; 000001f3H
  0019f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a7	e8 00 00 00 00	 call	 _PyParallel_Guard
  001ac	85 c0		 test	 eax, eax
  001ae	75 6d		 jne	 SHORT $LN27@compiler_u@2
  001b0	48 8b 5e 10	 mov	 rbx, QWORD PTR [rsi+16]
  001b4	48 89 7e 10	 mov	 QWORD PTR [rsi+16], rdi
  001b8	e8 00 00 00 00	 call	 _Py_PXCTX
  001bd	85 c0		 test	 eax, eax
  001bf	75 5c		 jne	 SHORT $LN27@compiler_u@2
  001c1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001c5	a8 20		 test	 al, 32			; 00000020H
  001c7	75 4c		 jne	 SHORT $LN68@compiler_u@2
  001c9	84 c0		 test	 al, al
  001cb	78 48		 js	 SHORT $LN68@compiler_u@2
  001cd	a8 02		 test	 al, 2
  001cf	75 4c		 jne	 SHORT $LN27@compiler_u@2
  001d1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001d5	75 46		 jne	 SHORT $LN27@compiler_u@2
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001e5	4c 8b cb	 mov	 r9, rbx
  001e8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001ee	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	85 c0		 test	 eax, eax
  00200	74 07		 je	 SHORT $LN73@compiler_u@2
  00202	e8 00 00 00 00	 call	 _Px_Dealloc
  00207	eb 14		 jmp	 SHORT $LN27@compiler_u@2
$LN73@compiler_u@2:
  00209	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0020d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00213	eb 08		 jmp	 SHORT $LN27@compiler_u@2
$LN68@compiler_u@2:
  00215	48 8b cb	 mov	 rcx, rbx
  00218	e8 00 00 00 00	 call	 Px_DecRef
$LN27@compiler_u@2:

; 500  :     Py_CLEAR(u->u_consts);

  0021d	4c 8b 4e 20	 mov	 r9, QWORD PTR [rsi+32]
  00221	4d 85 c9	 test	 r9, r9
  00224	0f 84 92 00 00
	00		 je	 $LN23@compiler_u@2
  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00238	41 b8 f4 01 00
	00		 mov	 r8d, 500		; 000001f4H
  0023e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00246	e8 00 00 00 00	 call	 _PyParallel_Guard
  0024b	85 c0		 test	 eax, eax
  0024d	75 6d		 jne	 SHORT $LN23@compiler_u@2
  0024f	48 8b 5e 20	 mov	 rbx, QWORD PTR [rsi+32]
  00253	48 89 7e 20	 mov	 QWORD PTR [rsi+32], rdi
  00257	e8 00 00 00 00	 call	 _Py_PXCTX
  0025c	85 c0		 test	 eax, eax
  0025e	75 5c		 jne	 SHORT $LN23@compiler_u@2
  00260	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00264	a8 20		 test	 al, 32			; 00000020H
  00266	75 4c		 jne	 SHORT $LN79@compiler_u@2
  00268	84 c0		 test	 al, al
  0026a	78 48		 js	 SHORT $LN79@compiler_u@2
  0026c	a8 02		 test	 al, 2
  0026e	75 4c		 jne	 SHORT $LN23@compiler_u@2
  00270	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00274	75 46		 jne	 SHORT $LN23@compiler_u@2
  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00284	4c 8b cb	 mov	 r9, rbx
  00287	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0028d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00295	e8 00 00 00 00	 call	 _PyParallel_Guard
  0029a	48 8b cb	 mov	 rcx, rbx
  0029d	85 c0		 test	 eax, eax
  0029f	74 07		 je	 SHORT $LN84@compiler_u@2
  002a1	e8 00 00 00 00	 call	 _Px_Dealloc
  002a6	eb 14		 jmp	 SHORT $LN23@compiler_u@2
$LN84@compiler_u@2:
  002a8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002ac	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002b2	eb 08		 jmp	 SHORT $LN23@compiler_u@2
$LN79@compiler_u@2:
  002b4	48 8b cb	 mov	 rcx, rbx
  002b7	e8 00 00 00 00	 call	 Px_DecRef
$LN23@compiler_u@2:

; 501  :     Py_CLEAR(u->u_names);

  002bc	4c 8b 4e 28	 mov	 r9, QWORD PTR [rsi+40]
  002c0	4d 85 c9	 test	 r9, r9
  002c3	0f 84 92 00 00
	00		 je	 $LN19@compiler_u@2
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  002d7	41 b8 f5 01 00
	00		 mov	 r8d, 501		; 000001f5H
  002dd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002e5	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ea	85 c0		 test	 eax, eax
  002ec	75 6d		 jne	 SHORT $LN19@compiler_u@2
  002ee	48 8b 5e 28	 mov	 rbx, QWORD PTR [rsi+40]
  002f2	48 89 7e 28	 mov	 QWORD PTR [rsi+40], rdi
  002f6	e8 00 00 00 00	 call	 _Py_PXCTX
  002fb	85 c0		 test	 eax, eax
  002fd	75 5c		 jne	 SHORT $LN19@compiler_u@2
  002ff	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00303	a8 20		 test	 al, 32			; 00000020H
  00305	75 4c		 jne	 SHORT $LN90@compiler_u@2
  00307	84 c0		 test	 al, al
  00309	78 48		 js	 SHORT $LN90@compiler_u@2
  0030b	a8 02		 test	 al, 2
  0030d	75 4c		 jne	 SHORT $LN19@compiler_u@2
  0030f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00313	75 46		 jne	 SHORT $LN19@compiler_u@2
  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0031c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00323	4c 8b cb	 mov	 r9, rbx
  00326	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0032c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00334	e8 00 00 00 00	 call	 _PyParallel_Guard
  00339	48 8b cb	 mov	 rcx, rbx
  0033c	85 c0		 test	 eax, eax
  0033e	74 07		 je	 SHORT $LN95@compiler_u@2
  00340	e8 00 00 00 00	 call	 _Px_Dealloc
  00345	eb 14		 jmp	 SHORT $LN19@compiler_u@2
$LN95@compiler_u@2:
  00347	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0034b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00351	eb 08		 jmp	 SHORT $LN19@compiler_u@2
$LN90@compiler_u@2:
  00353	48 8b cb	 mov	 rcx, rbx
  00356	e8 00 00 00 00	 call	 Px_DecRef
$LN19@compiler_u@2:

; 502  :     Py_CLEAR(u->u_varnames);

  0035b	4c 8b 4e 30	 mov	 r9, QWORD PTR [rsi+48]
  0035f	4d 85 c9	 test	 r9, r9
  00362	0f 84 92 00 00
	00		 je	 $LN15@compiler_u@2
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00376	41 b8 f6 01 00
	00		 mov	 r8d, 502		; 000001f6H
  0037c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00384	e8 00 00 00 00	 call	 _PyParallel_Guard
  00389	85 c0		 test	 eax, eax
  0038b	75 6d		 jne	 SHORT $LN15@compiler_u@2
  0038d	48 8b 5e 30	 mov	 rbx, QWORD PTR [rsi+48]
  00391	48 89 7e 30	 mov	 QWORD PTR [rsi+48], rdi
  00395	e8 00 00 00 00	 call	 _Py_PXCTX
  0039a	85 c0		 test	 eax, eax
  0039c	75 5c		 jne	 SHORT $LN15@compiler_u@2
  0039e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  003a2	a8 20		 test	 al, 32			; 00000020H
  003a4	75 4c		 jne	 SHORT $LN101@compiler_u@2
  003a6	84 c0		 test	 al, al
  003a8	78 48		 js	 SHORT $LN101@compiler_u@2
  003aa	a8 02		 test	 al, 2
  003ac	75 4c		 jne	 SHORT $LN15@compiler_u@2
  003ae	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  003b2	75 46		 jne	 SHORT $LN15@compiler_u@2
  003b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003c2	4c 8b cb	 mov	 r9, rbx
  003c5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003cb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003d3	e8 00 00 00 00	 call	 _PyParallel_Guard
  003d8	48 8b cb	 mov	 rcx, rbx
  003db	85 c0		 test	 eax, eax
  003dd	74 07		 je	 SHORT $LN106@compiler_u@2
  003df	e8 00 00 00 00	 call	 _Px_Dealloc
  003e4	eb 14		 jmp	 SHORT $LN15@compiler_u@2
$LN106@compiler_u@2:
  003e6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003ea	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003f0	eb 08		 jmp	 SHORT $LN15@compiler_u@2
$LN101@compiler_u@2:
  003f2	48 8b cb	 mov	 rcx, rbx
  003f5	e8 00 00 00 00	 call	 Px_DecRef
$LN15@compiler_u@2:

; 503  :     Py_CLEAR(u->u_freevars);

  003fa	4c 8b 4e 40	 mov	 r9, QWORD PTR [rsi+64]
  003fe	4d 85 c9	 test	 r9, r9
  00401	0f 84 92 00 00
	00		 je	 $LN11@compiler_u@2
  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00415	41 b8 f7 01 00
	00		 mov	 r8d, 503		; 000001f7H
  0041b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00423	e8 00 00 00 00	 call	 _PyParallel_Guard
  00428	85 c0		 test	 eax, eax
  0042a	75 6d		 jne	 SHORT $LN11@compiler_u@2
  0042c	48 8b 5e 40	 mov	 rbx, QWORD PTR [rsi+64]
  00430	48 89 7e 40	 mov	 QWORD PTR [rsi+64], rdi
  00434	e8 00 00 00 00	 call	 _Py_PXCTX
  00439	85 c0		 test	 eax, eax
  0043b	75 5c		 jne	 SHORT $LN11@compiler_u@2
  0043d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00441	a8 20		 test	 al, 32			; 00000020H
  00443	75 4c		 jne	 SHORT $LN112@compiler_u@2
  00445	84 c0		 test	 al, al
  00447	78 48		 js	 SHORT $LN112@compiler_u@2
  00449	a8 02		 test	 al, 2
  0044b	75 4c		 jne	 SHORT $LN11@compiler_u@2
  0044d	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00451	75 46		 jne	 SHORT $LN11@compiler_u@2
  00453	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0045a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00461	4c 8b cb	 mov	 r9, rbx
  00464	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0046a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00472	e8 00 00 00 00	 call	 _PyParallel_Guard
  00477	48 8b cb	 mov	 rcx, rbx
  0047a	85 c0		 test	 eax, eax
  0047c	74 07		 je	 SHORT $LN117@compiler_u@2
  0047e	e8 00 00 00 00	 call	 _Px_Dealloc
  00483	eb 14		 jmp	 SHORT $LN11@compiler_u@2
$LN117@compiler_u@2:
  00485	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00489	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0048f	eb 08		 jmp	 SHORT $LN11@compiler_u@2
$LN112@compiler_u@2:
  00491	48 8b cb	 mov	 rcx, rbx
  00494	e8 00 00 00 00	 call	 Px_DecRef
$LN11@compiler_u@2:

; 504  :     Py_CLEAR(u->u_cellvars);

  00499	4c 8b 4e 38	 mov	 r9, QWORD PTR [rsi+56]
  0049d	4d 85 c9	 test	 r9, r9
  004a0	0f 84 92 00 00
	00		 je	 $LN7@compiler_u@2
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  004b4	41 b8 f8 01 00
	00		 mov	 r8d, 504		; 000001f8H
  004ba	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  004c7	85 c0		 test	 eax, eax
  004c9	75 6d		 jne	 SHORT $LN7@compiler_u@2
  004cb	48 8b 5e 38	 mov	 rbx, QWORD PTR [rsi+56]
  004cf	48 89 7e 38	 mov	 QWORD PTR [rsi+56], rdi
  004d3	e8 00 00 00 00	 call	 _Py_PXCTX
  004d8	85 c0		 test	 eax, eax
  004da	75 5c		 jne	 SHORT $LN7@compiler_u@2
  004dc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  004e0	a8 20		 test	 al, 32			; 00000020H
  004e2	75 4c		 jne	 SHORT $LN123@compiler_u@2
  004e4	84 c0		 test	 al, al
  004e6	78 48		 js	 SHORT $LN123@compiler_u@2
  004e8	a8 02		 test	 al, 2
  004ea	75 4c		 jne	 SHORT $LN7@compiler_u@2
  004ec	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  004f0	75 46		 jne	 SHORT $LN7@compiler_u@2
  004f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00500	4c 8b cb	 mov	 r9, rbx
  00503	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00509	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00511	e8 00 00 00 00	 call	 _PyParallel_Guard
  00516	48 8b cb	 mov	 rcx, rbx
  00519	85 c0		 test	 eax, eax
  0051b	74 07		 je	 SHORT $LN128@compiler_u@2
  0051d	e8 00 00 00 00	 call	 _Px_Dealloc
  00522	eb 14		 jmp	 SHORT $LN7@compiler_u@2
$LN128@compiler_u@2:
  00524	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00528	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0052e	eb 08		 jmp	 SHORT $LN7@compiler_u@2
$LN123@compiler_u@2:
  00530	48 8b cb	 mov	 rcx, rbx
  00533	e8 00 00 00 00	 call	 Px_DecRef
$LN7@compiler_u@2:

; 505  :     Py_CLEAR(u->u_private);

  00538	4c 8b 4e 48	 mov	 r9, QWORD PTR [rsi+72]
  0053c	4d 85 c9	 test	 r9, r9
  0053f	0f 84 92 00 00
	00		 je	 $LN3@compiler_u@2
  00545	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DFKENOMI@?4?4?2Python?2compile?4c?$AA@
  0054c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@MPGDIPMH@compiler_unit_free?$AA@
  00553	41 b8 f9 01 00
	00		 mov	 r8d, 505		; 000001f9H
  00559	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00561	e8 00 00 00 00	 call	 _PyParallel_Guard
  00566	85 c0		 test	 eax, eax
  00568	75 6d		 jne	 SHORT $LN3@compiler_u@2
  0056a	48 8b 5e 48	 mov	 rbx, QWORD PTR [rsi+72]
  0056e	48 89 7e 48	 mov	 QWORD PTR [rsi+72], rdi
  00572	e8 00 00 00 00	 call	 _Py_PXCTX
  00577	85 c0		 test	 eax, eax
  00579	75 5c		 jne	 SHORT $LN3@compiler_u@2
  0057b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0057f	a8 20		 test	 al, 32			; 00000020H
  00581	75 4c		 jne	 SHORT $LN134@compiler_u@2
  00583	84 c0		 test	 al, al
  00585	78 48		 js	 SHORT $LN134@compiler_u@2
  00587	a8 02		 test	 al, 2
  00589	75 4c		 jne	 SHORT $LN3@compiler_u@2
  0058b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0058f	75 46		 jne	 SHORT $LN3@compiler_u@2
  00591	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00598	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0059f	4c 8b cb	 mov	 r9, rbx
  005a2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  005a8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  005b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  005b5	48 8b cb	 mov	 rcx, rbx
  005b8	85 c0		 test	 eax, eax
  005ba	74 07		 je	 SHORT $LN139@compiler_u@2
  005bc	e8 00 00 00 00	 call	 _Px_Dealloc
  005c1	eb 14		 jmp	 SHORT $LN3@compiler_u@2
$LN139@compiler_u@2:
  005c3	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  005c7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  005cd	eb 08		 jmp	 SHORT $LN3@compiler_u@2
$LN134@compiler_u@2:
  005cf	48 8b cb	 mov	 rcx, rbx
  005d2	e8 00 00 00 00	 call	 Px_DecRef
$LN3@compiler_u@2:

; 506  :     PyObject_Free(u);

  005d7	48 8b ce	 mov	 rcx, rsi

; 507  : }

  005da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  005df	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  005e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  005e8	5f		 pop	 rdi
  005e9	e9 00 00 00 00	 jmp	 PyObject_Free
compiler_unit_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	PySequence_DelItem:PROC
EXTRN	PyCapsule_GetPointer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_exit_scope DD imagerel compiler_exit_scope
	DD	imagerel compiler_exit_scope+32
	DD	imagerel $unwind$compiler_exit_scope
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_exit_scope DD imagerel compiler_exit_scope+32
	DD	imagerel compiler_exit_scope+85
	DD	imagerel $chain$0$compiler_exit_scope
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_exit_scope DD imagerel compiler_exit_scope+85
	DD	imagerel compiler_exit_scope+116
	DD	imagerel $chain$1$compiler_exit_scope
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_exit_scope DD 021H
	DD	imagerel compiler_exit_scope
	DD	imagerel compiler_exit_scope+32
	DD	imagerel $unwind$compiler_exit_scope
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_exit_scope DD 020521H
	DD	063405H
	DD	imagerel compiler_exit_scope
	DD	imagerel compiler_exit_scope+32
	DD	imagerel $unwind$compiler_exit_scope
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_exit_scope DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@ DB 'compiler_exit_sco'
	DB	'pe()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
CONST	SEGMENT
??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@ DB 'compile.c compiler'
	DB	' unit', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_exit_scope
_TEXT	SEGMENT
c$ = 48
compiler_exit_scope PROC				; COMDAT

; 588  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 589  :     int n;
; 590  :     PyObject *capsule;
; 591  : 
; 592  :     c->c_nestlevel--;

  00006	ff 49 30	 dec	 DWORD PTR [rcx+48]
  00009	48 8b f9	 mov	 rdi, rcx

; 593  :     compiler_unit_free(c->u);

  0000c	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00010	e8 00 00 00 00	 call	 compiler_unit_free

; 594  :     /* Restore c->u to the parent unit. */
; 595  :     n = PyList_GET_SIZE(c->c_stack) - 1;

  00015	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00019	8b 41 60	 mov	 eax, DWORD PTR [rcx+96]
  0001c	ff c8		 dec	 eax

; 596  :     if (n >= 0) {

  0001e	78 46		 js	 SHORT $LN3@compiler_e

; 597  :         capsule = PyList_GET_ITEM(c->c_stack, n);

  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	48 63 d8	 movsxd	 rbx, eax
  00028	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 598  :         c->u = (struct compiler_unit *)PyCapsule_GetPointer(capsule, COMPILER_CAPSULE_NAME_COMPILER_UNIT);

  0002c	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  00037	e8 00 00 00 00	 call	 PyCapsule_GetPointer

; 599  :         assert(c->u);
; 600  :         /* we are deleting from a list so this really shouldn't fail */
; 601  :         if (PySequence_DelItem(c->c_stack, n) < 0)

  0003c	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
  00047	e8 00 00 00 00	 call	 PySequence_DelItem
  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	85 c0		 test	 eax, eax
  00053	79 19		 jns	 SHORT $LN1@compiler_e

; 602  :             Py_FatalError("compiler_exit_scope()");

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@CJOLMGIJ@compiler_exit_scope?$CI?$CJ?$AA@

; 607  : 
; 608  : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	e9 00 00 00 00	 jmp	 Py_FatalError
$LN3@compiler_e:

; 603  :         compiler_unit_check(c->u);
; 604  :     }
; 605  :     else
; 606  :         c->u = NULL;

  00066	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$LN1@compiler_e:

; 607  : 
; 608  : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
compiler_exit_scope ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Join:PROC
EXTRN	_PyUnicode_FromId:PROC
EXTRN	PyList_Append:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_scope_qualname DD imagerel compiler_scope_qualname
	DD	imagerel compiler_scope_qualname+569
	DD	imagerel $unwind$compiler_scope_qualname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_scope_qualname DD 0c9f01H
	DD	0de49fH
	DD	0cd491H
	DD	0b6488H
	DD	0a5483H
	DD	0c0055209H
	DD	030027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT compiler_scope_qualname
_TEXT	SEGMENT
c$ = 80
compiler_scope_qualname PROC				; COMDAT

; 612  : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 613  :     Py_ssize_t stack_size, i;
; 614  :     _Py_static_string(dot, ".");
; 615  :     _Py_static_string(locals, "<locals>");
; 616  :     struct compiler_unit *u;
; 617  :     PyObject *capsule, *name, *seq, *dot_str, *locals_str;
; 618  : 
; 619  :     u = c->u;

  00009	48 8b 79 38	 mov	 rdi, QWORD PTR [rcx+56]
  0000d	4c 8b e1	 mov	 r12, rcx

; 620  :     if (u->u_qualname != NULL) {

  00010	48 8b 5f 10	 mov	 rbx, QWORD PTR [rdi+16]
  00014	48 85 db	 test	 rbx, rbx
  00017	74 48		 je	 SHORT $LN20@compiler_s

; 621  :         Py_INCREF(u->u_qualname);

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 32		 jne	 SHORT $LN24@compiler_s
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00030	4c 8b cb	 mov	 r9, rbx
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 06		 jne	 SHORT $LN23@compiler_s
  0004a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004e	74 04		 je	 SHORT $LN24@compiler_s
$LN23@compiler_s:
  00050	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN24@compiler_s:

; 622  :         return u->u_qualname;

  00054	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 661  : }

  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	41 5c		 pop	 r12
  0005e	5f		 pop	 rdi
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
$LN20@compiler_s:

; 623  :     }
; 624  : 
; 625  :     seq = PyList_New(0);

  00061	33 c9		 xor	 ecx, ecx
  00063	e8 00 00 00 00	 call	 PyList_New
  00068	48 8b d8	 mov	 rbx, rax

; 626  :     if (seq == NULL)

  0006b	48 85 c0	 test	 rax, rax
  0006e	75 09		 jne	 SHORT $LN19@compiler_s

; 661  : }

  00070	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00074	41 5c		 pop	 r12
  00076	5f		 pop	 rdi
  00077	5b		 pop	 rbx
  00078	c3		 ret	 0
$LN19@compiler_s:

; 627  :         return NULL;
; 628  : 
; 629  :     stack_size = PyList_GET_SIZE(c->c_stack);

  00079	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  0007e	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00083	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00088	48 8b 68 60	 mov	 rbp, QWORD PTR [rax+96]
  0008c	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13

; 630  :     for (i = 0; i < stack_size; i++) {

  00091	44 8b 2d 00 00
	00 00		 mov	 r13d, DWORD PTR _tls_index
  00098	33 ff		 xor	 edi, edi
  0009a	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  0009f	48 85 ed	 test	 rbp, rbp
  000a2	0f 8e 7d 00 00
	00		 jle	 $LN16@compiler_s
  000a8	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:?locals@?1??compiler_scope_qualname@@9@9
  000ae	66 90		 npad	 2
$LL18@compiler_s:

; 631  :         capsule = PyList_GET_ITEM(c->c_stack, i);

  000b0	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]

; 632  :         u = (struct compiler_unit *)PyCapsule_GetPointer(capsule, COMPILER_CAPSULE_NAME_COMPILER_UNIT);

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  000bc	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000c0	48 8b 0c f9	 mov	 rcx, QWORD PTR [rcx+rdi*8]
  000c4	e8 00 00 00 00	 call	 PyCapsule_GetPointer
  000c9	48 8b f0	 mov	 rsi, rax

; 633  :         assert(u);
; 634  :         if (u->u_scope_type == COMPILER_SCOPE_MODULE)

  000cc	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000d0	74 4b		 je	 SHORT $LN17@compiler_s

; 635  :             continue;
; 636  :         if (PyList_Append(seq, u->u_name))

  000d2	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	e8 00 00 00 00	 call	 PyList_Append
  000de	85 c0		 test	 eax, eax
  000e0	0f 85 cf 00 00
	00		 jne	 $_error$22397

; 637  :             goto _error;
; 638  :         if (u->u_scope_type == COMPILER_SCOPE_FUNCTION) {

  000e6	83 7e 18 02	 cmp	 DWORD PTR [rsi+24], 2
  000ea	75 31		 jne	 SHORT $LN17@compiler_s

; 639  :             locals_str = _PyUnicode_FromId(&locals);

  000ec	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000f5	41 8b ce	 mov	 ecx, r14d
  000f8	4a 03 0c e8	 add	 rcx, QWORD PTR [rax+r13*8]
  000fc	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 640  :             if (locals_str == NULL)

  00101	48 85 c0	 test	 rax, rax
  00104	0f 84 ab 00 00
	00		 je	 $_error$22397

; 641  :                 goto _error;
; 642  :             if (PyList_Append(seq, locals_str))

  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8b cb	 mov	 rcx, rbx
  00110	e8 00 00 00 00	 call	 PyList_Append
  00115	85 c0		 test	 eax, eax
  00117	0f 85 98 00 00
	00		 jne	 $_error$22397
$LN17@compiler_s:

; 630  :     for (i = 0; i < stack_size; i++) {

  0011d	48 ff c7	 inc	 rdi
  00120	48 3b fd	 cmp	 rdi, rbp
  00123	7c 8b		 jl	 SHORT $LL18@compiler_s
$LN16@compiler_s:

; 643  :                 goto _error;
; 644  :         }
; 645  :     }
; 646  :     u = c->u;

  00125	49 8b 74 24 38	 mov	 rsi, QWORD PTR [r12+56]

; 647  :     if (PyList_Append(seq, u->u_name))

  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00131	e8 00 00 00 00	 call	 PyList_Append
  00136	85 c0		 test	 eax, eax
  00138	75 7b		 jne	 SHORT $_error$22397

; 648  :         goto _error;
; 649  :     dot_str = _PyUnicode_FromId(&dot);

  0013a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00143	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?dot@?1??compiler_scope_qualname@@9@9
  00148	4a 03 0c e8	 add	 rcx, QWORD PTR [rax+r13*8]
  0014c	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 650  :     if (dot_str == NULL)

  00151	48 85 c0	 test	 rax, rax
  00154	74 5f		 je	 SHORT $_error$22397

; 651  :         goto _error;
; 652  :     name = PyUnicode_Join(dot_str, seq);

  00156	48 8b d3	 mov	 rdx, rbx
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 PyUnicode_Join

; 653  :     Py_DECREF(seq);

  00161	48 8b cb	 mov	 rcx, rbx
  00164	48 8b f8	 mov	 rdi, rax
  00167	e8 00 00 00 00	 call	 _Py_DecRef

; 654  :     u->u_qualname = name;

  0016c	48 89 7e 10	 mov	 QWORD PTR [rsi+16], rdi

; 655  :     Py_XINCREF(name);

  00170	48 85 ff	 test	 rdi, rdi
  00173	74 3b		 je	 SHORT $LN7@compiler_s
  00175	e8 00 00 00 00	 call	 _Py_PXCTX
  0017a	85 c0		 test	 eax, eax
  0017c	75 32		 jne	 SHORT $LN7@compiler_s
  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0018c	4c 8b cf	 mov	 r9, rdi
  0018f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00195	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0019d	e8 00 00 00 00	 call	 _PyParallel_Guard
  001a2	85 c0		 test	 eax, eax
  001a4	75 06		 jne	 SHORT $LN27@compiler_s
  001a6	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001aa	74 04		 je	 SHORT $LN7@compiler_s
$LN27@compiler_s:
  001ac	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@compiler_s:

; 656  :     return name;

  001b0	48 8b c7	 mov	 rax, rdi
  001b3	eb 67		 jmp	 SHORT $LN50@compiler_s
$_error$22397:

; 657  : 
; 658  : _error:
; 659  :     Py_XDECREF(seq);

  001b5	e8 00 00 00 00	 call	 _Py_PXCTX
  001ba	85 c0		 test	 eax, eax
  001bc	75 5c		 jne	 SHORT $LN3@compiler_s
  001be	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001c2	a8 20		 test	 al, 32			; 00000020H
  001c4	75 4c		 jne	 SHORT $LN35@compiler_s
  001c6	84 c0		 test	 al, al
  001c8	78 48		 js	 SHORT $LN35@compiler_s
  001ca	a8 02		 test	 al, 2
  001cc	75 4c		 jne	 SHORT $LN3@compiler_s
  001ce	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001d2	75 46		 jne	 SHORT $LN3@compiler_s
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001e2	4c 8b cb	 mov	 r9, rbx
  001e5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001eb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f8	48 8b cb	 mov	 rcx, rbx
  001fb	85 c0		 test	 eax, eax
  001fd	74 07		 je	 SHORT $LN40@compiler_s
  001ff	e8 00 00 00 00	 call	 _Px_Dealloc
  00204	eb 14		 jmp	 SHORT $LN3@compiler_s
$LN40@compiler_s:
  00206	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0020a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00210	eb 08		 jmp	 SHORT $LN3@compiler_s
$LN35@compiler_s:
  00212	48 8b cb	 mov	 rcx, rbx
  00215	e8 00 00 00 00	 call	 Px_DecRef
$LN3@compiler_s:

; 660  :     return NULL;

  0021a	33 c0		 xor	 eax, eax
$LN50@compiler_s:
  0021c	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  00221	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00226	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0022b	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]

; 661  : }

  00230	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00234	41 5c		 pop	 r12
  00236	5f		 pop	 rdi
  00237	5b		 pop	 rbx
  00238	c3		 ret	 0
compiler_scope_qualname ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_new_block DD imagerel compiler_new_block
	DD	imagerel compiler_new_block+86
	DD	imagerel $unwind$compiler_new_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_new_block DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_new_block
_TEXT	SEGMENT
c$ = 48
compiler_new_block PROC					; COMDAT

; 669  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 670  :     basicblock *b;
; 671  :     struct compiler_unit *u;
; 672  : 
; 673  :     u = c->u;

  00006	48 8b 59 38	 mov	 rbx, QWORD PTR [rcx+56]

; 674  :     b = (basicblock *)PyObject_Malloc(sizeof(basicblock));

  0000a	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0000f	e8 00 00 00 00	 call	 PyObject_Malloc
  00014	4c 8b d8	 mov	 r11, rax

; 675  :     if (b == NULL) {

  00017	48 85 c0	 test	 rax, rax
  0001a	75 0d		 jne	 SHORT $LN1@compiler_n

; 676  :         PyErr_NoMemory();

  0001c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 677  :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 684  : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
$LN1@compiler_n:

; 678  :     }
; 679  :     memset((void *)b, 0, sizeof(basicblock));

  00029	33 c0		 xor	 eax, eax
  0002b	49 89 03	 mov	 QWORD PTR [r11], rax
  0002e	49 89 43 08	 mov	 QWORD PTR [r11+8], rax
  00032	49 89 43 10	 mov	 QWORD PTR [r11+16], rax
  00036	49 89 43 18	 mov	 QWORD PTR [r11+24], rax
  0003a	49 89 43 20	 mov	 QWORD PTR [r11+32], rax
  0003e	49 89 43 28	 mov	 QWORD PTR [r11+40], rax

; 680  :     /* Extend the singly linked list of blocks with new block. */
; 681  :     b->b_list = u->u_blocks;

  00042	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00046	49 89 03	 mov	 QWORD PTR [r11], rax

; 682  :     u->u_blocks = b;

  00049	4c 89 5b 58	 mov	 QWORD PTR [rbx+88], r11

; 683  :     return b;

  0004d	49 8b c3	 mov	 rax, r11

; 684  : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
compiler_new_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_use_new_block DD imagerel compiler_use_new_block
	DD	imagerel compiler_use_new_block+45
	DD	imagerel $unwind$compiler_use_new_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_use_new_block DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_use_new_block
_TEXT	SEGMENT
c$ = 48
compiler_use_new_block PROC				; COMDAT

; 688  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 689  :     basicblock *block = compiler_new_block(c);

  00009	e8 00 00 00 00	 call	 compiler_new_block
  0000e	4c 8b d8	 mov	 r11, rax

; 690  :     if (block == NULL)

  00011	48 85 c0	 test	 rax, rax
  00014	75 06		 jne	 SHORT $LN1@compiler_u@3

; 694  : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN1@compiler_u@3:

; 691  :         return NULL;
; 692  :     c->u->u_curblock = block;

  0001c	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00020	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 693  :     return block;

  00024	49 8b c3	 mov	 rax, r11

; 694  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
compiler_use_new_block ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_next_block DD imagerel compiler_next_block
	DD	imagerel compiler_next_block+57
	DD	imagerel $unwind$compiler_next_block
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_next_block DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_next_block
_TEXT	SEGMENT
c$ = 48
compiler_next_block PROC				; COMDAT

; 698  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 699  :     basicblock *block = compiler_new_block(c);

  00009	e8 00 00 00 00	 call	 compiler_new_block
  0000e	4c 8b d8	 mov	 r11, rax

; 700  :     if (block == NULL)

  00011	48 85 c0	 test	 rax, rax
  00014	75 06		 jne	 SHORT $LN1@compiler_n@2

; 705  : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN1@compiler_n@2:

; 701  :         return NULL;
; 702  :     c->u->u_curblock->b_next = block;

  0001c	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00020	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00024	4c 89 59 18	 mov	 QWORD PTR [rcx+24], r11

; 703  :     c->u->u_curblock = block;

  00028	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0002c	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 704  :     return block;

  00030	49 8b c3	 mov	 rax, r11

; 705  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
compiler_next_block ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_use_next_block
_TEXT	SEGMENT
c$ = 8
block$ = 16
compiler_use_next_block PROC				; COMDAT

; 710  :     assert(block != NULL);
; 711  :     c->u->u_curblock->b_next = block;

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00004	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00008	49 89 50 18	 mov	 QWORD PTR [r8+24], rdx

; 712  :     c->u->u_curblock = block;

  0000c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00010	48 89 50 60	 mov	 QWORD PTR [rax+96], rdx

; 713  :     return block;

  00014	48 8b c2	 mov	 rax, rdx

; 714  : }

  00017	c3		 ret	 0
compiler_use_next_block ENDP
_TEXT	ENDS
EXTRN	PyObject_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_next_instr DD imagerel compiler_next_instr
	DD	imagerel compiler_next_instr+192
	DD	imagerel $unwind$compiler_next_instr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_next_instr DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_next_instr
_TEXT	SEGMENT
b$ = 48
compiler_next_instr PROC				; COMDAT

; 723  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 724  :     assert(b != NULL);
; 725  :     if (b->b_instr == NULL) {

  00012	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00016	48 85 c9	 test	 rcx, rcx
  00019	75 3d		 jne	 SHORT $LN7@compiler_n@3

; 726  :         b->b_instr = (struct instr *)PyObject_Malloc(
; 727  :                          sizeof(struct instr) * DEFAULT_BLOCK_SIZE);

  0001b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00020	e8 00 00 00 00	 call	 PyObject_Malloc
  00025	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 728  :         if (b->b_instr == NULL) {

  00029	48 85 c0	 test	 rax, rax
  0002c	75 18		 jne	 SHORT $LN6@compiler_n@3
$LN11@compiler_n@3:

; 729  :             PyErr_NoMemory();

  0002e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 730  :             return -1;

  00033	83 c8 ff	 or	 eax, -1

; 762  : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN6@compiler_n@3:

; 731  :         }
; 732  :         b->b_ialloc = DEFAULT_BLOCK_SIZE;

  00046	c7 43 0c 10 00
	00 00		 mov	 DWORD PTR [rbx+12], 16

; 733  :         memset((char *)b->b_instr, 0,
; 734  :                sizeof(struct instr) * DEFAULT_BLOCK_SIZE);

  0004d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00053	48 8b c8	 mov	 rcx, rax
  00056	eb 48		 jmp	 SHORT $LN10@compiler_n@3
$LN7@compiler_n@3:

; 735  :     }
; 736  :     else if (b->b_iused == b->b_ialloc) {

  00058	48 63 43 0c	 movsxd	 rax, DWORD PTR [rbx+12]
  0005c	39 43 08	 cmp	 DWORD PTR [rbx+8], eax
  0005f	75 46		 jne	 SHORT $LN4@compiler_n@3

; 737  :         struct instr *tmp;
; 738  :         size_t oldsize, newsize;
; 739  :         oldsize = b->b_ialloc * sizeof(struct instr);

  00061	48 8b f8	 mov	 rdi, rax

; 740  :         newsize = oldsize << 1;
; 741  : 
; 742  :         if (oldsize > (PY_SIZE_MAX >> 1)) {

  00064	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  0006e	48 c1 e7 05	 shl	 rdi, 5
  00072	48 8d 34 3f	 lea	 rsi, QWORD PTR [rdi+rdi]
  00076	48 3b fa	 cmp	 rdi, rdx

; 743  :             PyErr_NoMemory();
; 744  :             return -1;

  00079	77 b3		 ja	 SHORT $LN11@compiler_n@3

; 745  :         }
; 746  : 
; 747  :         if (newsize == 0) {

  0007b	48 85 f6	 test	 rsi, rsi

; 748  :             PyErr_NoMemory();
; 749  :             return -1;

  0007e	74 ae		 je	 SHORT $LN11@compiler_n@3

; 750  :         }
; 751  :         b->b_ialloc <<= 1;

  00080	03 c0		 add	 eax, eax

; 752  :         tmp = (struct instr *)PyObject_Realloc(
; 753  :                                         (void *)b->b_instr, newsize);

  00082	48 8b d6	 mov	 rdx, rsi
  00085	89 43 0c	 mov	 DWORD PTR [rbx+12], eax
  00088	e8 00 00 00 00	 call	 PyObject_Realloc

; 754  :         if (tmp == NULL) {

  0008d	48 85 c0	 test	 rax, rax

; 755  :             PyErr_NoMemory();
; 756  :             return -1;

  00090	74 9c		 je	 SHORT $LN11@compiler_n@3

; 757  :         }
; 758  :         b->b_instr = tmp;
; 759  :         memset((char *)b->b_instr + oldsize, 0, newsize - oldsize);

  00092	48 2b f7	 sub	 rsi, rdi
  00095	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00099	48 8d 0c 38	 lea	 rcx, QWORD PTR [rax+rdi]
  0009d	4c 8b c6	 mov	 r8, rsi
$LN10@compiler_n@3:
  000a0	33 d2		 xor	 edx, edx
  000a2	e8 00 00 00 00	 call	 memset
$LN4@compiler_n@3:

; 760  :     }
; 761  :     return b->b_iused++;

  000a7	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]

; 762  : }

  000aa	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000af	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]
  000b2	89 4b 08	 mov	 DWORD PTR [rbx+8], ecx
  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
compiler_next_instr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_set_lineno
_TEXT	SEGMENT
c$ = 8
off$ = 16
compiler_set_lineno PROC				; COMDAT

; 779  :     basicblock *b;
; 780  :     if (c->u->u_lineno_set)

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00004	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [rax+444], 0
  0000b	75 27		 jne	 SHORT $LN2@compiler_s@2

; 781  :         return;
; 782  :     c->u->u_lineno_set = 1;

  0000d	c7 80 bc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+444], 1

; 783  :     b = c->u->u_curblock;
; 784  :     b->b_instr[off].i_lineno = c->u->u_lineno;

  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 63 d2	 movsxd	 rdx, edx
  0001e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00022	8b 80 b4 01 00
	00		 mov	 eax, DWORD PTR [rax+436]
  00028	48 c1 e2 05	 shl	 rdx, 5
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	89 44 11 18	 mov	 DWORD PTR [rcx+rdx+24], eax
$LN2@compiler_s@2:

; 785  : }

  00034	f3 c3		 fatret	 0
compiler_set_lineno ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@	; `string'
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$opcode_stack_effect DD imagerel opcode_stack_effect
	DD	imagerel opcode_stack_effect+755
	DD	imagerel $unwind$opcode_stack_effect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$opcode_stack_effect DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@ DB 'opcode_stack_effe'
	DB	'ct()', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@ DB 'opcode = %d', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT opcode_stack_effect
_TEXT	SEGMENT
opcode$ = 48
oparg$ = 56
opcode_stack_effect PROC				; COMDAT

; 789  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 790  :     switch (opcode) {

  00006	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00009	44 8b ca	 mov	 r9d, edx
  0000c	8b d9		 mov	 ebx, ecx
  0000e	3d 92 00 00 00	 cmp	 eax, 146		; 00000092H
  00013	0f 87 ca 01 00
	00		 ja	 $LN1@opcode_sta
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00020	48 98		 cdqe
  00022	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN80@opcode_sta[rcx+rax]
  0002a	44 8b 84 81 00
	00 00 00	 mov	 r8d, DWORD PTR $LN81@opcode_sta[rcx+rax*4]
  00032	4c 03 c1	 add	 r8, rcx
  00035	41 ff e0	 jmp	 r8
$LN70@opcode_sta:

; 791  :         case POP_TOP:
; 792  :             return -1;

  00038	83 c8 ff	 or	 eax, -1

; 984  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN68@opcode_sta:

; 793  :         case ROT_TWO:
; 794  :         case ROT_THREE:
; 795  :             return 0;
; 796  :         case DUP_TOP:
; 797  :             return 1;

  00041	b8 01 00 00 00	 mov	 eax, 1

; 984  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
$LN67@opcode_sta:

; 798  :         case DUP_TOP_TWO:
; 799  :             return 2;

  0004c	b8 02 00 00 00	 mov	 eax, 2

; 984  : }

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN64@opcode_sta:

; 800  : 
; 801  :         case UNARY_POSITIVE:
; 802  :         case UNARY_NEGATIVE:
; 803  :         case UNARY_NOT:
; 804  :         case UNARY_INVERT:
; 805  :             return 0;
; 806  : 
; 807  :         case SET_ADD:
; 808  :         case LIST_APPEND:
; 809  :             return -1;
; 810  :         case MAP_ADD:
; 811  :             return -2;

  00057	b8 fe ff ff ff	 mov	 eax, -2

; 984  : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
$LN60@opcode_sta:

; 812  : 
; 813  :         case BINARY_POWER:
; 814  :         case BINARY_MULTIPLY:
; 815  :         case BINARY_MODULO:
; 816  :         case BINARY_ADD:
; 817  :         case BINARY_SUBTRACT:
; 818  :         case BINARY_SUBSCR:
; 819  :         case BINARY_FLOOR_DIVIDE:
; 820  :         case BINARY_TRUE_DIVIDE:
; 821  :             return -1;
; 822  :         case INPLACE_FLOOR_DIVIDE:
; 823  :         case INPLACE_TRUE_DIVIDE:
; 824  :             return -1;
; 825  : 
; 826  :         case INPLACE_ADD:
; 827  :         case INPLACE_SUBTRACT:
; 828  :         case INPLACE_MULTIPLY:
; 829  :         case INPLACE_MODULO:
; 830  :             return -1;
; 831  :         case STORE_SUBSCR:
; 832  :             return -3;

  00062	b8 fd ff ff ff	 mov	 eax, -3

; 984  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
$LN50@opcode_sta:

; 833  :         case STORE_MAP:
; 834  :             return -2;
; 835  :         case DELETE_SUBSCR:
; 836  :             return -2;
; 837  : 
; 838  :         case BINARY_LSHIFT:
; 839  :         case BINARY_RSHIFT:
; 840  :         case BINARY_AND:
; 841  :         case BINARY_XOR:
; 842  :         case BINARY_OR:
; 843  :             return -1;
; 844  :         case INPLACE_POWER:
; 845  :             return -1;
; 846  :         case GET_ITER:
; 847  :             return 0;
; 848  : 
; 849  :         case PRINT_EXPR:
; 850  :             return -1;
; 851  :         case LOAD_BUILD_CLASS:
; 852  :             return 1;
; 853  :         case INPLACE_LSHIFT:
; 854  :         case INPLACE_RSHIFT:
; 855  :         case INPLACE_AND:
; 856  :         case INPLACE_XOR:
; 857  :         case INPLACE_OR:
; 858  :             return -1;
; 859  :         case BREAK_LOOP:
; 860  :             return 0;
; 861  :         case SETUP_WITH:
; 862  :             return 7;

  0006d	b8 07 00 00 00	 mov	 eax, 7

; 984  : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$LN38@opcode_sta:

; 863  :         case WITH_CLEANUP:
; 864  :             return -1; /* XXX Sometimes more */
; 865  :         case STORE_LOCALS:
; 866  :             return -1;
; 867  :         case RETURN_VALUE:
; 868  :             return -1;
; 869  :         case IMPORT_STAR:
; 870  :             return -1;
; 871  :         case YIELD_VALUE:
; 872  :             return 0;
; 873  :         case YIELD_FROM:
; 874  :             return -1;
; 875  :         case POP_BLOCK:
; 876  :             return 0;
; 877  :         case POP_EXCEPT:
; 878  :             return 0;  /* -3 except if bad bytecode */
; 879  :         case END_FINALLY:
; 880  :             return -1; /* or -2 or -3 if exception occurred */
; 881  : 
; 882  :         case STORE_NAME:
; 883  :             return -1;
; 884  :         case DELETE_NAME:
; 885  :             return 0;
; 886  :         case UNPACK_SEQUENCE:
; 887  :             return oparg-1;

  00078	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]

; 984  : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
$LN37@opcode_sta:

; 888  :         case UNPACK_EX:
; 889  :             return (oparg&0xFF) + (oparg>>8);

  00081	0f b6 c2	 movzx	 eax, dl
  00084	41 c1 f9 08	 sar	 r9d, 8
  00088	41 03 c1	 add	 eax, r9d

; 984  : }

  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5b		 pop	 rbx
  00090	c3		 ret	 0
$LN29@opcode_sta:

; 890  :         case FOR_ITER:
; 891  :             return 1; /* or -1, at end of iterator */
; 892  : 
; 893  :         case STORE_ATTR:
; 894  :             return -2;
; 895  :         case DELETE_ATTR:
; 896  :             return -1;
; 897  :         case STORE_GLOBAL:
; 898  :             return -1;
; 899  :         case DELETE_GLOBAL:
; 900  :             return 0;
; 901  :         case LOAD_CONST:
; 902  :             return 1;
; 903  :         case LOAD_NAME:
; 904  :             return 1;
; 905  :         case BUILD_TUPLE:
; 906  :         case BUILD_LIST:
; 907  :         case BUILD_SET:
; 908  :             return 1-oparg;

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	2b c2		 sub	 eax, edx

; 984  : }

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN18@opcode_sta:

; 909  :         case BUILD_MAP:
; 910  :             return 1;
; 911  :         case LOAD_ATTR:
; 912  :             return 0;
; 913  :         case COMPARE_OP:
; 914  :             return -1;
; 915  :         case IMPORT_NAME:
; 916  :             return -1;
; 917  :         case IMPORT_FROM:
; 918  :             return 1;
; 919  : 
; 920  :         case JUMP_FORWARD:
; 921  :         case JUMP_IF_TRUE_OR_POP:  /* -1 if jump not taken */
; 922  :         case JUMP_IF_FALSE_OR_POP:  /*  "" */
; 923  :         case JUMP_ABSOLUTE:
; 924  :             return 0;
; 925  : 
; 926  :         case POP_JUMP_IF_FALSE:
; 927  :         case POP_JUMP_IF_TRUE:
; 928  :             return -1;
; 929  : 
; 930  :         case LOAD_GLOBAL:
; 931  :             return 1;
; 932  : 
; 933  :         case CONTINUE_LOOP:
; 934  :             return 0;
; 935  :         case SETUP_LOOP:
; 936  :             return 0;
; 937  :         case SETUP_EXCEPT:
; 938  :         case SETUP_FINALLY:
; 939  :             return 6; /* can push 3 values for the new exception

  0009e	b8 06 00 00 00	 mov	 eax, 6

; 984  : }

  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
$LN14@opcode_sta:

; 940  :                 + 3 others for the previous exception state */
; 941  : 
; 942  :         case LOAD_FAST:
; 943  :             return 1;
; 944  :         case STORE_FAST:
; 945  :             return -1;
; 946  :         case DELETE_FAST:
; 947  :             return 0;
; 948  : 
; 949  :         case RAISE_VARARGS:
; 950  :             return -oparg;

  000a9	41 f7 d9	 neg	 r9d
  000ac	41 8b c1	 mov	 eax, r9d

; 984  : }

  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	5b		 pop	 rbx
  000b4	c3		 ret	 0
$LN13@opcode_sta:

; 951  : #define NARGS(o) (((o) % 256) + 2*(((o) / 256) % 256))
; 952  :         case CALL_FUNCTION:
; 953  :             return -NARGS(oparg);

  000b5	8b c2		 mov	 eax, edx
  000b7	99		 cdq
  000b8	0f b6 d2	 movzx	 edx, dl
  000bb	03 c2		 add	 eax, edx
  000bd	8b c8		 mov	 ecx, eax
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	c1 f9 08	 sar	 ecx, 8
  000c5	2b c2		 sub	 eax, edx
  000c7	81 e1 ff 00 00
	80		 and	 ecx, -2147483393	; ffffffff800000ffH
  000cd	7d 0a		 jge	 SHORT $LN79@opcode_sta
  000cf	ff c9		 dec	 ecx
  000d1	81 c9 00 ff ff
	ff		 or	 ecx, -256		; ffffffffffffff00H
  000d7	ff c1		 inc	 ecx
$LN79@opcode_sta:
  000d9	03 c9		 add	 ecx, ecx
  000db	f7 d8		 neg	 eax
  000dd	2b c1		 sub	 eax, ecx

; 984  : }

  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5b		 pop	 rbx
  000e4	c3		 ret	 0
$LN12@opcode_sta:

; 954  :         case CALL_FUNCTION_VAR:
; 955  :         case CALL_FUNCTION_KW:
; 956  :             return -NARGS(oparg)-1;

  000e5	8b c2		 mov	 eax, edx
  000e7	99		 cdq
  000e8	0f b6 d2	 movzx	 edx, dl
  000eb	03 c2		 add	 eax, edx
  000ed	8b c8		 mov	 ecx, eax
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	2b c2		 sub	 eax, edx
  000f4	c1 f9 08	 sar	 ecx, 8
  000f7	81 e1 ff 00 00
	80		 and	 ecx, -2147483393	; ffffffff800000ffH
  000fd	8b d0		 mov	 edx, eax
  000ff	7d 0a		 jge	 SHORT $LN78@opcode_sta
  00101	ff c9		 dec	 ecx
  00103	81 c9 00 ff ff
	ff		 or	 ecx, -256		; ffffffffffffff00H
  00109	ff c1		 inc	 ecx
$LN78@opcode_sta:
  0010b	03 c9		 add	 ecx, ecx
  0010d	83 c8 ff	 or	 eax, -1
  00110	2b c1		 sub	 eax, ecx
  00112	2b c2		 sub	 eax, edx

; 984  : }

  00114	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00118	5b		 pop	 rbx
  00119	c3		 ret	 0
$LN11@opcode_sta:

; 957  :         case CALL_FUNCTION_VAR_KW:
; 958  :             return -NARGS(oparg)-2;

  0011a	8b c2		 mov	 eax, edx
  0011c	99		 cdq
  0011d	0f b6 d2	 movzx	 edx, dl
  00120	03 c2		 add	 eax, edx
  00122	8b c8		 mov	 ecx, eax
  00124	0f b6 c0	 movzx	 eax, al
  00127	c1 f9 08	 sar	 ecx, 8
  0012a	2b c2		 sub	 eax, edx
  0012c	81 e1 ff 00 00
	80		 and	 ecx, -2147483393	; ffffffff800000ffH
  00132	7d 0a		 jge	 SHORT $LN77@opcode_sta
  00134	ff c9		 dec	 ecx
  00136	81 c9 00 ff ff
	ff		 or	 ecx, -256		; ffffffffffffff00H
  0013c	ff c1		 inc	 ecx
$LN77@opcode_sta:
  0013e	8d 4c 09 02	 lea	 ecx, DWORD PTR [rcx+rcx+2]
  00142	f7 d8		 neg	 eax
  00144	2b c1		 sub	 eax, ecx

; 984  : }

  00146	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014a	5b		 pop	 rbx
  0014b	c3		 ret	 0
$LN10@opcode_sta:

; 959  :         case MAKE_FUNCTION:
; 960  :             return -1 -NARGS(oparg) - ((oparg >> 16) & 0xffff);

  0014c	8b c2		 mov	 eax, edx
  0014e	99		 cdq
  0014f	0f b6 d2	 movzx	 edx, dl
  00152	03 c2		 add	 eax, edx
  00154	44 8b c0	 mov	 r8d, eax
  00157	0f b6 c0	 movzx	 eax, al
  0015a	41 c1 f8 08	 sar	 r8d, 8
  0015e	2b c2		 sub	 eax, edx
  00160	41 81 e0 ff 00
	00 80		 and	 r8d, -2147483393	; ffffffff800000ffH
  00167	7d 0d		 jge	 SHORT $LN76@opcode_sta
  00169	41 ff c8	 dec	 r8d
  0016c	41 81 c8 00 ff
	ff ff		 or	 r8d, -256		; ffffffffffffff00H
  00173	41 ff c0	 inc	 r8d
$LN76@opcode_sta:
  00176	41 f7 d8	 neg	 r8d
  00179	41 c1 f9 10	 sar	 r9d, 16
  0017d	45 03 c0	 add	 r8d, r8d
  00180	41 0f b7 c9	 movzx	 ecx, r9w
  00184	44 2b c1	 sub	 r8d, ecx
  00187	44 2b c0	 sub	 r8d, eax
  0018a	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]

; 984  : }

  0018e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00192	5b		 pop	 rbx
  00193	c3		 ret	 0
$LN9@opcode_sta:

; 961  :         case MAKE_CLOSURE:
; 962  :             return -2 - NARGS(oparg) - ((oparg >> 16) & 0xffff);

  00194	8b c2		 mov	 eax, edx
  00196	99		 cdq
  00197	0f b6 d2	 movzx	 edx, dl
  0019a	03 c2		 add	 eax, edx
  0019c	8b c8		 mov	 ecx, eax
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	2b c2		 sub	 eax, edx
  001a3	c1 f9 08	 sar	 ecx, 8
  001a6	81 e1 ff 00 00
	80		 and	 ecx, -2147483393	; ffffffff800000ffH
  001ac	8b d0		 mov	 edx, eax
  001ae	7d 0a		 jge	 SHORT $LN75@opcode_sta
  001b0	ff c9		 dec	 ecx
  001b2	81 c9 00 ff ff
	ff		 or	 ecx, -256		; ffffffffffffff00H
  001b8	ff c1		 inc	 ecx
$LN75@opcode_sta:
  001ba	41 c1 f9 10	 sar	 r9d, 16
  001be	8d 4c 09 02	 lea	 ecx, DWORD PTR [rcx+rcx+2]
  001c2	41 0f b7 c1	 movzx	 eax, r9w
  001c6	f7 d8		 neg	 eax
  001c8	2b c1		 sub	 eax, ecx
  001ca	2b c2		 sub	 eax, edx

; 984  : }

  001cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d0	5b		 pop	 rbx
  001d1	c3		 ret	 0
$LN8@opcode_sta:

; 963  : #undef NARGS
; 964  :         case BUILD_SLICE:
; 965  :             if (oparg == 3)

  001d2	33 c0		 xor	 eax, eax
  001d4	83 fa 03	 cmp	 edx, 3
  001d7	0f 95 c0	 setne	 al
  001da	83 c0 fe	 add	 eax, -2

; 984  : }

  001dd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e1	5b		 pop	 rbx
  001e2	c3		 ret	 0
$LN1@opcode_sta:

; 966  :                 return -2;
; 967  :             else
; 968  :                 return -1;
; 969  : 
; 970  :         case LOAD_CLOSURE:
; 971  :             return 1;
; 972  :         case LOAD_DEREF:
; 973  :             return 1;
; 974  :         case STORE_DEREF:
; 975  :             return -1;
; 976  :         case DELETE_DEREF:
; 977  :             return 0;
; 978  :         default:
; 979  :             fprintf(stderr, "opcode = %d\n", opcode);

  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BJFJDAMA@opcode?5?$DN?5?$CFd?6?$AA@
  001f0	44 8b c3	 mov	 r8d, ebx
  001f3	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 980  :             Py_FatalError("opcode_stack_effect()");

  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MPCMOCCE@opcode_stack_effect?$CI?$CJ?$AA@
  00204	e8 00 00 00 00	 call	 Py_FatalError
$LN69@opcode_sta:

; 981  : 
; 982  :     }
; 983  :     return 0; /* not reachable */

  00209	33 c0		 xor	 eax, eax

; 984  : }

  0020b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0020f	5b		 pop	 rbx
  00210	c3		 ret	 0
  00211	0f 1f 00	 npad	 3
$LN81@opcode_sta:
  00214	00 00 00 00	 DD	 $LN70@opcode_sta
  00218	00 00 00 00	 DD	 $LN69@opcode_sta
  0021c	00 00 00 00	 DD	 $LN68@opcode_sta
  00220	00 00 00 00	 DD	 $LN67@opcode_sta
  00224	00 00 00 00	 DD	 $LN64@opcode_sta
  00228	00 00 00 00	 DD	 $LN60@opcode_sta
  0022c	00 00 00 00	 DD	 $LN38@opcode_sta
  00230	00 00 00 00	 DD	 $LN37@opcode_sta
  00234	00 00 00 00	 DD	 $LN29@opcode_sta
  00238	00 00 00 00	 DD	 $LN18@opcode_sta
  0023c	00 00 00 00	 DD	 $LN14@opcode_sta
  00240	00 00 00 00	 DD	 $LN13@opcode_sta
  00244	00 00 00 00	 DD	 $LN10@opcode_sta
  00248	00 00 00 00	 DD	 $LN8@opcode_sta
  0024c	00 00 00 00	 DD	 $LN9@opcode_sta
  00250	00 00 00 00	 DD	 $LN12@opcode_sta
  00254	00 00 00 00	 DD	 $LN11@opcode_sta
  00258	00 00 00 00	 DD	 $LN50@opcode_sta
  0025c	00 00 00 00	 DD	 $LN1@opcode_sta
$LN80@opcode_sta:
  00260	00		 DB	 0
  00261	01		 DB	 1
  00262	01		 DB	 1
  00263	02		 DB	 2
  00264	03		 DB	 3
  00265	12		 DB	 18
  00266	12		 DB	 18
  00267	12		 DB	 18
  00268	12		 DB	 18
  00269	01		 DB	 1
  0026a	01		 DB	 1
  0026b	01		 DB	 1
  0026c	12		 DB	 18
  0026d	12		 DB	 18
  0026e	01		 DB	 1
  0026f	12		 DB	 18
  00270	12		 DB	 18
  00271	12		 DB	 18
  00272	00		 DB	 0
  00273	00		 DB	 0
  00274	12		 DB	 18
  00275	00		 DB	 0
  00276	00		 DB	 0
  00277	00		 DB	 0
  00278	00		 DB	 0
  00279	00		 DB	 0
  0027a	00		 DB	 0
  0027b	00		 DB	 0
  0027c	00		 DB	 0
  0027d	12		 DB	 18
  0027e	12		 DB	 18
  0027f	12		 DB	 18
  00280	12		 DB	 18
  00281	12		 DB	 18
  00282	12		 DB	 18
  00283	12		 DB	 18
  00284	12		 DB	 18
  00285	12		 DB	 18
  00286	12		 DB	 18
  00287	12		 DB	 18
  00288	12		 DB	 18
  00289	12		 DB	 18
  0028a	12		 DB	 18
  0028b	12		 DB	 18
  0028c	12		 DB	 18
  0028d	12		 DB	 18
  0028e	12		 DB	 18
  0028f	12		 DB	 18
  00290	12		 DB	 18
  00291	12		 DB	 18
  00292	12		 DB	 18
  00293	12		 DB	 18
  00294	12		 DB	 18
  00295	04		 DB	 4
  00296	00		 DB	 0
  00297	00		 DB	 0
  00298	00		 DB	 0
  00299	12		 DB	 18
  0029a	00		 DB	 0
  0029b	05		 DB	 5
  0029c	04		 DB	 4
  0029d	00		 DB	 0
  0029e	00		 DB	 0
  0029f	00		 DB	 0
  002a0	00		 DB	 0
  002a1	00		 DB	 0
  002a2	00		 DB	 0
  002a3	01		 DB	 1
  002a4	00		 DB	 0
  002a5	00		 DB	 0
  002a6	02		 DB	 2
  002a7	00		 DB	 0
  002a8	12		 DB	 18
  002a9	12		 DB	 18
  002aa	00		 DB	 0
  002ab	00		 DB	 0
  002ac	00		 DB	 0
  002ad	00		 DB	 0
  002ae	00		 DB	 0
  002af	01		 DB	 1
  002b0	00		 DB	 0
  002b1	12		 DB	 18
  002b2	00		 DB	 0
  002b3	00		 DB	 0
  002b4	12		 DB	 18
  002b5	01		 DB	 1
  002b6	01		 DB	 1
  002b7	00		 DB	 0
  002b8	01		 DB	 1
  002b9	00		 DB	 0
  002ba	01		 DB	 1
  002bb	06		 DB	 6
  002bc	02		 DB	 2
  002bd	07		 DB	 7
  002be	04		 DB	 4
  002bf	00		 DB	 0
  002c0	00		 DB	 0
  002c1	01		 DB	 1
  002c2	12		 DB	 18
  002c3	02		 DB	 2
  002c4	02		 DB	 2
  002c5	08		 DB	 8
  002c6	08		 DB	 8
  002c7	08		 DB	 8
  002c8	02		 DB	 2
  002c9	01		 DB	 1
  002ca	00		 DB	 0
  002cb	00		 DB	 0
  002cc	02		 DB	 2
  002cd	01		 DB	 1
  002ce	01		 DB	 1
  002cf	01		 DB	 1
  002d0	01		 DB	 1
  002d1	00		 DB	 0
  002d2	00		 DB	 0
  002d3	02		 DB	 2
  002d4	12		 DB	 18
  002d5	12		 DB	 18
  002d6	01		 DB	 1
  002d7	01		 DB	 1
  002d8	09		 DB	 9
  002d9	09		 DB	 9
  002da	12		 DB	 18
  002db	02		 DB	 2
  002dc	00		 DB	 0
  002dd	01		 DB	 1
  002de	12		 DB	 18
  002df	12		 DB	 18
  002e0	12		 DB	 18
  002e1	0a		 DB	 10
  002e2	0b		 DB	 11
  002e3	0c		 DB	 12
  002e4	0d		 DB	 13
  002e5	0e		 DB	 14
  002e6	02		 DB	 2
  002e7	02		 DB	 2
  002e8	00		 DB	 0
  002e9	01		 DB	 1
  002ea	12		 DB	 18
  002eb	0f		 DB	 15
  002ec	0f		 DB	 15
  002ed	10		 DB	 16
  002ee	11		 DB	 17
  002ef	12		 DB	 18
  002f0	00		 DB	 0
  002f1	00		 DB	 0
  002f2	04		 DB	 4
opcode_stack_effect ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop DD imagerel compiler_addop
	DD	imagerel compiler_addop+107
	DD	imagerel $unwind$compiler_addop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_addop
_TEXT	SEGMENT
c$ = 48
opcode$ = 56
compiler_addop PROC					; COMDAT

; 992  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 993  :     basicblock *b;
; 994  :     struct instr *i;
; 995  :     int off;
; 996  :     off = compiler_next_instr(c, c->u->u_curblock);

  0000d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00011	8b fa		 mov	 edi, edx
  00013	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00017	e8 00 00 00 00	 call	 compiler_next_instr
  0001c	48 63 d0	 movsxd	 rdx, eax

; 997  :     if (off < 0)

  0001f	85 c0		 test	 eax, eax
  00021	79 0d		 jns	 SHORT $LN2@compiler_a

; 998  :         return 0;

  00023	33 c0		 xor	 eax, eax

; 1006 :     return 1;
; 1007 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN2@compiler_a:

; 999  :     b = c->u->u_curblock;

  00030	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00034	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]

; 1000 :     i = &b->b_instr[off];

  00038	48 8b c2	 mov	 rax, rdx
  0003b	48 c1 e0 05	 shl	 rax, 5
  0003f	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]

; 1001 :     i->i_opcode = opcode;
; 1002 :     i->i_hasarg = 0;

  00043	83 20 fb	 and	 DWORD PTR [rax], -5	; fffffffbH
  00046	40 88 78 04	 mov	 BYTE PTR [rax+4], dil

; 1003 :     if (opcode == RETURN_VALUE)

  0004a	83 ff 53	 cmp	 edi, 83			; 00000053H
  0004d	75 04		 jne	 SHORT $LN1@compiler_a

; 1004 :         b->b_return = 1;

  0004f	83 49 20 02	 or	 DWORD PTR [rcx+32], 2
$LN1@compiler_a:

; 1005 :     compiler_set_lineno(c, off);

  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 compiler_set_lineno

; 1006 :     return 1;
; 1007 : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
compiler_addop ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
EXTRN	PyDict_Size:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__imp__copysign:PROC
EXTRN	PyComplex_AsCComplex:PROC
EXTRN	PyComplex_Type:BYTE
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_add_o DD imagerel compiler_add_o
	DD	imagerel compiler_add_o+37
	DD	imagerel $unwind$compiler_add_o
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_add_o DD imagerel compiler_add_o+37
	DD	imagerel compiler_add_o+373
	DD	imagerel $chain$0$compiler_add_o
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_add_o DD imagerel compiler_add_o+373
	DD	imagerel compiler_add_o+532
	DD	imagerel $chain$1$compiler_add_o
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_add_o DD 021H
	DD	imagerel compiler_add_o
	DD	imagerel compiler_add_o+37
	DD	imagerel $unwind$compiler_add_o
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_add_o DD 020521H
	DD	056805H
	DD	imagerel compiler_add_o
	DD	imagerel compiler_add_o+37
	DD	imagerel $unwind$compiler_add_o
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_add_o DD 081401H
	DD	0106414H
	DD	0f5414H
	DD	0e3414H
	DD	07010b214H
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_add_o
_TEXT	SEGMENT
z$22603 = 48
$T26094 = 64
dict$ = 112
o$ = 120
compiler_add_o PROC					; COMDAT

; 1011 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	48 8b e9	 mov	 rbp, rcx

; 1012 :     PyObject *t, *v;
; 1013 :     Py_ssize_t arg;
; 1014 :     double d;
; 1015 : 
; 1016 :     /* necessary to make sure types aren't coerced (e.g., float and complex) */
; 1017 :     /* _and_ to distinguish 0.0 from -0.0 e.g. on IEEE platforms */
; 1018 :     if (PyFloat_Check(o)) {

  00017	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00025	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  0002a	48 3b ca	 cmp	 rcx, rdx
  0002d	0f 84 e5 00 00
	00		 je	 $LN19@compiler_a@2
  00033	e8 00 00 00 00	 call	 PyType_IsSubtype
  00038	85 c0		 test	 eax, eax
  0003a	0f 85 d8 00 00
	00		 jne	 $LN19@compiler_a@2

; 1027 :     }
; 1028 :     else if (PyComplex_Check(o)) {

  00040	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyComplex_Type
  0004b	48 3b ca	 cmp	 rcx, rdx
  0004e	74 0d		 je	 SHORT $LN14@compiler_a@2
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax

; 1044 :         }
; 1045 :         else if (real_negzero) {
; 1046 :             t = PyTuple_Pack(3, o, o->ob_type, Py_None);
; 1047 :         }
; 1048 :         else {
; 1049 :             t = PyTuple_Pack(2, o, o->ob_type);
; 1050 :         }
; 1051 :     }
; 1052 :     else {
; 1053 :         t = PyTuple_Pack(2, o, o->ob_type);

  00057	0f 84 fa 00 00
	00		 je	 $LN18@compiler_a@2
$LN14@compiler_a@2:

; 1029 :         Py_complex z;
; 1030 :         int real_negzero, imag_negzero;
; 1031 :         /* For the complex case we must make complex(x, 0.)
; 1032 :            different from complex(x, -0.) and complex(0., y)
; 1033 :            different from complex(-0., y), for any x and y.
; 1034 :            All four complex zeros must be distinguished.*/
; 1035 :         z = PyComplex_AsCComplex(o);

  0005d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T26094[rsp]
  00062	48 8b d3	 mov	 rdx, rbx
  00065	e8 00 00 00 00	 call	 PyComplex_AsCComplex

; 1036 :         real_negzero = z.real == 0.0 && copysign(1.0, z.real) < 0.0;

  0006a	bf 01 00 00 00	 mov	 edi, 1
  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00072	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00076	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0007a	48 89 4c 24 30	 mov	 QWORD PTR z$22603[rsp], rcx
  0007f	48 89 44 24 38	 mov	 QWORD PTR z$22603[rsp+8], rax
  00084	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR z$22603[rsp]
  0008a	66 0f 2e ce	 ucomisd xmm1, xmm6
  0008e	7a 1a		 jp	 SHORT $LN23@compiler_a@2
  00090	75 18		 jne	 SHORT $LN23@compiler_a@2
  00092	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000a0	66 0f 2f f0	 comisd	 xmm6, xmm0
  000a4	76 04		 jbe	 SHORT $LN23@compiler_a@2
  000a6	8b f7		 mov	 esi, edi
  000a8	eb 02		 jmp	 SHORT $LN24@compiler_a@2
$LN23@compiler_a@2:
  000aa	33 f6		 xor	 esi, esi
$LN24@compiler_a@2:

; 1037 :         imag_negzero = z.imag == 0.0 && copysign(1.0, z.imag) < 0.0;

  000ac	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR z$22603[rsp+8]
  000b2	66 0f 2e ce	 ucomisd xmm1, xmm6
  000b6	7a 16		 jp	 SHORT $LN25@compiler_a@2
  000b8	75 14		 jne	 SHORT $LN25@compiler_a@2
  000ba	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000c8	66 0f 2f f0	 comisd	 xmm6, xmm0
  000cc	77 02		 ja	 SHORT $LN26@compiler_a@2
$LN25@compiler_a@2:
  000ce	33 ff		 xor	 edi, edi
$LN26@compiler_a@2:

; 1038 :         if (real_negzero && imag_negzero) {
; 1039 :             t = PyTuple_Pack(5, o, o->ob_type,
; 1040 :                              Py_None, Py_None, Py_None);

  000d0	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  000d4	48 8b d3	 mov	 rdx, rbx
  000d7	85 f6		 test	 esi, esi
  000d9	74 21		 je	 SHORT $LN13@compiler_a@2
  000db	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000e2	85 ff		 test	 edi, edi
  000e4	74 65		 je	 SHORT $LN11@compiler_a@2
  000e6	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  000eb	b9 05 00 00 00	 mov	 ecx, 5
  000f0	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  000f5	e8 00 00 00 00	 call	 PyTuple_Pack
  000fa	eb 6c		 jmp	 SHORT $LN27@compiler_a@2
$LN13@compiler_a@2:

; 1041 :         }
; 1042 :         else if (imag_negzero) {

  000fc	85 ff		 test	 edi, edi
  000fe	74 5e		 je	 SHORT $LN9@compiler_a@2

; 1043 :             t = PyTuple_Pack(4, o, o->ob_type, Py_None, Py_None);

  00100	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00107	b9 04 00 00 00	 mov	 ecx, 4
  0010c	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00111	e8 00 00 00 00	 call	 PyTuple_Pack
  00116	eb 50		 jmp	 SHORT $LN27@compiler_a@2
$LN19@compiler_a@2:

; 1019 :         d = PyFloat_AS_DOUBLE(o);

  00118	f2 0f 10 4b 60	 movsdx	 xmm1, QWORD PTR [rbx+96]

; 1020 :         /* all we need is to make the tuple different in either the 0.0
; 1021 :          * or -0.0 case from all others, just to avoid the "coercion".
; 1022 :          */
; 1023 :         if (d == 0.0 && copysign(1.0, d) < 0.0)

  0011d	66 0f 57 f6	 xorpd	 xmm6, xmm6
  00121	66 0f 2e ce	 ucomisd xmm1, xmm6
  00125	7a 30		 jp	 SHORT $LN18@compiler_a@2
  00127	75 2e		 jne	 SHORT $LN18@compiler_a@2
  00129	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00137	66 0f 2f f0	 comisd	 xmm6, xmm0
  0013b	76 1a		 jbe	 SHORT $LN18@compiler_a@2

; 1024 :             t = PyTuple_Pack(3, o, o->ob_type, Py_None);

  0013d	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00141	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00148	48 8b d3	 mov	 rdx, rbx
$LN11@compiler_a@2:
  0014b	b9 03 00 00 00	 mov	 ecx, 3
  00150	e8 00 00 00 00	 call	 PyTuple_Pack

; 1025 :         else

  00155	eb 11		 jmp	 SHORT $LN27@compiler_a@2
$LN18@compiler_a@2:

; 1026 :             t = PyTuple_Pack(2, o, o->ob_type);

  00157	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  0015b	48 8b d3	 mov	 rdx, rbx
$LN9@compiler_a@2:
  0015e	b9 02 00 00 00	 mov	 ecx, 2
  00163	e8 00 00 00 00	 call	 PyTuple_Pack
$LN27@compiler_a@2:
  00168	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  0016d	48 8b d8	 mov	 rbx, rax

; 1054 :     }
; 1055 :     if (t == NULL)

  00170	48 85 c0	 test	 rax, rax

; 1056 :         return -1;

  00173	74 3c		 je	 SHORT $LN28@compiler_a@2

; 1057 : 
; 1058 :     v = PyDict_GetItem(dict, t);

  00175	48 8b d0	 mov	 rdx, rax
  00178	48 8b cd	 mov	 rcx, rbp
  0017b	e8 00 00 00 00	 call	 PyDict_GetItem

; 1059 :     if (!v) {

  00180	48 85 c0	 test	 rax, rax
  00183	75 62		 jne	 SHORT $LN5@compiler_a@2

; 1060 :         if (PyErr_Occurred())

  00185	e8 00 00 00 00	 call	 PyErr_Occurred
  0018a	48 85 c0	 test	 rax, rax

; 1061 :             return -1;

  0018d	75 22		 jne	 SHORT $LN28@compiler_a@2

; 1062 :         arg = PyDict_Size(dict);

  0018f	48 8b cd	 mov	 rcx, rbp
  00192	e8 00 00 00 00	 call	 PyDict_Size

; 1063 :         v = PyLong_FromLong(arg);

  00197	8b c8		 mov	 ecx, eax
  00199	48 8b f0	 mov	 rsi, rax
  0019c	e8 00 00 00 00	 call	 PyLong_FromLong
  001a1	48 8b f8	 mov	 rdi, rax

; 1064 :         if (!v) {

  001a4	48 85 c0	 test	 rax, rax
  001a7	75 0d		 jne	 SHORT $LN3@compiler_a@2

; 1065 :             Py_DECREF(t);

  001a9	48 8b cb	 mov	 rcx, rbx
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@compiler_a@2:

; 1066 :             return -1;

  001b1	83 c8 ff	 or	 eax, -1
  001b4	eb 46		 jmp	 SHORT $LN21@compiler_a@2
$LN3@compiler_a@2:

; 1067 :         }
; 1068 :         if (PyDict_SetItem(dict, t, v) < 0) {

  001b6	4c 8b c0	 mov	 r8, rax
  001b9	48 8b d3	 mov	 rdx, rbx
  001bc	48 8b cd	 mov	 rcx, rbp
  001bf	e8 00 00 00 00	 call	 PyDict_SetItem
  001c4	85 c0		 test	 eax, eax
  001c6	79 15		 jns	 SHORT $LN2@compiler_a@2

; 1069 :             Py_DECREF(t);

  001c8	48 8b cb	 mov	 rcx, rbx
  001cb	e8 00 00 00 00	 call	 _Py_DecRef

; 1070 :             Py_DECREF(v);

  001d0	48 8b cf	 mov	 rcx, rdi
  001d3	e8 00 00 00 00	 call	 _Py_DecRef

; 1071 :             return -1;

  001d8	83 c8 ff	 or	 eax, -1
  001db	eb 1f		 jmp	 SHORT $LN21@compiler_a@2
$LN2@compiler_a@2:

; 1072 :         }
; 1073 :         Py_DECREF(v);

  001dd	48 8b cf	 mov	 rcx, rdi
  001e0	e8 00 00 00 00	 call	 _Py_DecRef

; 1074 :     }
; 1075 :     else

  001e5	eb 0b		 jmp	 SHORT $LN1@compiler_a@2
$LN5@compiler_a@2:

; 1076 :         arg = PyLong_AsLong(v);

  001e7	48 8b c8	 mov	 rcx, rax
  001ea	e8 00 00 00 00	 call	 PyLong_AsLong
  001ef	48 63 f0	 movsxd	 rsi, eax
$LN1@compiler_a@2:

; 1077 :     Py_DECREF(t);

  001f2	48 8b cb	 mov	 rcx, rbx
  001f5	e8 00 00 00 00	 call	 _Py_DecRef

; 1078 :     return arg;

  001fa	8b c6		 mov	 eax, esi
$LN21@compiler_a@2:

; 1079 : }

  001fc	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00201	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00206	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0020e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00212	5f		 pop	 rdi
  00213	c3		 ret	 0
compiler_add_o ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_i DD imagerel compiler_addop_i
	DD	imagerel compiler_addop_i+119
	DD	imagerel $unwind$compiler_addop_i
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_i DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_addop_i
_TEXT	SEGMENT
c$ = 48
opcode$ = 56
oparg$ = 64
compiler_addop_i PROC					; COMDAT

; 1112 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1113 :     struct instr *i;
; 1114 :     int off;
; 1115 :     off = compiler_next_instr(c, c->u->u_curblock);

  00012	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00016	41 8b f8	 mov	 edi, r8d
  00019	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001d	8b f2		 mov	 esi, edx
  0001f	e8 00 00 00 00	 call	 compiler_next_instr
  00024	48 63 d0	 movsxd	 rdx, eax

; 1116 :     if (off < 0)

  00027	85 c0		 test	 eax, eax
  00029	79 12		 jns	 SHORT $LN1@compiler_a@3

; 1117 :         return 0;

  0002b	33 c0		 xor	 eax, eax

; 1123 :     return 1;
; 1124 : }

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN1@compiler_a@3:

; 1118 :     i = &c->u->u_curblock->b_instr[off];

  0003d	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00041	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00045	48 8b c2	 mov	 rax, rdx
  00048	48 c1 e0 05	 shl	 rax, 5
  0004c	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]

; 1119 :     i->i_opcode = opcode;
; 1120 :     i->i_oparg = oparg;
; 1121 :     i->i_hasarg = 1;
; 1122 :     compiler_set_lineno(c, off);

  00050	48 8b cb	 mov	 rcx, rbx
  00053	83 08 04	 or	 DWORD PTR [rax], 4
  00056	40 88 70 04	 mov	 BYTE PTR [rax+4], sil
  0005a	89 78 08	 mov	 DWORD PTR [rax+8], edi
  0005d	e8 00 00 00 00	 call	 compiler_set_lineno

; 1123 :     return 1;
; 1124 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006c	b8 01 00 00 00	 mov	 eax, 1
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
compiler_addop_i ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_j DD imagerel compiler_addop_j
	DD	imagerel compiler_addop_j+138
	DD	imagerel $unwind$compiler_addop_j
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_j DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_addop_j
_TEXT	SEGMENT
c$ = 48
opcode$ = 56
b$ = 64
absolute$ = 72
compiler_addop_j PROC					; COMDAT

; 1128 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b d9	 mov	 rbx, rcx

; 1129 :     struct instr *i;
; 1130 :     int off;
; 1131 : 
; 1132 :     assert(b != NULL);
; 1133 :     off = compiler_next_instr(c, c->u->u_curblock);

  00017	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0001b	41 8b f9	 mov	 edi, r9d
  0001e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00022	49 8b f0	 mov	 rsi, r8
  00025	8b ea		 mov	 ebp, edx
  00027	e8 00 00 00 00	 call	 compiler_next_instr
  0002c	4c 63 d8	 movsxd	 r11, eax

; 1134 :     if (off < 0)

  0002f	85 c0		 test	 eax, eax
  00031	79 04		 jns	 SHORT $LN3@compiler_a@4

; 1135 :         return 0;

  00033	33 c0		 xor	 eax, eax
  00035	eb 3e		 jmp	 SHORT $LN4@compiler_a@4
$LN3@compiler_a@4:

; 1136 :     i = &c->u->u_curblock->b_instr[off];

  00037	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003b	49 8b d3	 mov	 rdx, r11
  0003e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00042	48 c1 e2 05	 shl	 rdx, 5
  00046	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]

; 1137 :     i->i_opcode = opcode;
; 1138 :     i->i_target = b;
; 1139 :     i->i_hasarg = 1;

  0004a	83 0a 04	 or	 DWORD PTR [rdx], 4
  0004d	8b 02		 mov	 eax, DWORD PTR [rdx]
  0004f	40 88 6a 04	 mov	 BYTE PTR [rdx+4], bpl
  00053	48 89 72 10	 mov	 QWORD PTR [rdx+16], rsi

; 1140 :     if (absolute)

  00057	85 ff		 test	 edi, edi
  00059	74 05		 je	 SHORT $LN2@compiler_a@4

; 1141 :         i->i_jabs = 1;

  0005b	83 c8 01	 or	 eax, 1

; 1142 :     else

  0005e	eb 03		 jmp	 SHORT $LN6@compiler_a@4
$LN2@compiler_a@4:

; 1143 :         i->i_jrel = 1;

  00060	83 c8 02	 or	 eax, 2
$LN6@compiler_a@4:
  00063	89 02		 mov	 DWORD PTR [rdx], eax

; 1144 :     compiler_set_lineno(c, off);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	41 8b d3	 mov	 edx, r11d
  0006b	e8 00 00 00 00	 call	 compiler_set_lineno

; 1145 :     return 1;

  00070	b8 01 00 00 00	 mov	 eax, 1
$LN4@compiler_a@4:

; 1146 : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0007f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
compiler_addop_j ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_isdocstring
_TEXT	SEGMENT
s$ = 8
compiler_isdocstring PROC				; COMDAT

; 1252 :     if (s->kind != Expr_kind)
; 1253 :         return 0;

  00000	33 c0		 xor	 eax, eax
  00002	83 39 12	 cmp	 DWORD PTR [rcx], 18
  00005	75 0a		 jne	 SHORT $LN2@compiler_i

; 1254 :     return s->v.Expr.value->kind == Str_kind;

  00007	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0000b	83 39 11	 cmp	 DWORD PTR [rcx], 17
  0000e	0f 94 c0	 sete	 al
$LN2@compiler_i:

; 1255 : }

  00011	f3 c3		 fatret	 0
compiler_isdocstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@ ; `string'
EXTRN	PyOS_snprintf:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyObject_Repr:PROC
EXTRN	PyST_GetScope:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ref_type DD imagerel get_ref_type
	DD	imagerel get_ref_type+46
	DD	imagerel $unwind$get_ref_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_ref_type DD imagerel get_ref_type+46
	DD	imagerel get_ref_type+277
	DD	imagerel $chain$2$get_ref_type
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$get_ref_type DD imagerel get_ref_type+277
	DD	imagerel get_ref_type+290
	DD	imagerel $chain$3$get_ref_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$get_ref_type DD 021H
	DD	imagerel get_ref_type
	DD	imagerel get_ref_type+46
	DD	imagerel $unwind$get_ref_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_ref_type DD 061c21H
	DD	03c741cH
	DD	03b6410H
	DD	03a3408H
	DD	imagerel get_ref_type
	DD	imagerel get_ref_type+46
	DD	imagerel $unwind$get_ref_type
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ref_type DD 050d01H
	DD	036010dH
	DD	0c004d006H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@
CONST	SEGMENT
??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@ DB 'unk'
	DB	'nown scope for %.100s in %.100s(%s) in %s', 0aH, 'symbols: %s'
	DB	0aH, 'locals: %s', 0aH, 'globals: %s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_ref_type
_TEXT	SEGMENT
buf$22760 = 80
c$ = 464
name$ = 472
get_ref_type PROC					; COMDAT

; 1332 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 81 ec b0 01
	00 00		 sub	 rsp, 432		; 000001b0H
  0000d	4c 8b e1	 mov	 r12, rcx

; 1333 :     int scope = PyST_GetScope(c->u->u_ste, name);

  00010	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00014	4c 8b ea	 mov	 r13, rdx
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	e8 00 00 00 00	 call	 PyST_GetScope
  0001f	8b e8		 mov	 ebp, eax

; 1334 :     if (scope == 0) {

  00021	85 c0		 test	 eax, eax
  00023	0f 85 ec 00 00
	00		 jne	 $LN1@get_ref_ty

; 1335 :         char buf[350];
; 1336 :         PyOS_snprintf(buf, sizeof(buf),
; 1337 :                       "unknown scope for %.100s in %.100s(%s) in %s\n"
; 1338 :                       "symbols: %s\nlocals: %s\nglobals: %s",
; 1339 :                       PyBytes_AS_STRING(name),
; 1340 :                       PyBytes_AS_STRING(c->u->u_name),
; 1341 :                       PyObject_REPR(c->u->u_ste->ste_id),
; 1342 :                       c->c_filename,
; 1343 :                       PyObject_REPR(c->u->u_ste->ste_symbols),
; 1344 :                       PyObject_REPR(c->u->u_varnames),
; 1345 :                       PyObject_REPR(c->u->u_names)
; 1346 :         );

  00029	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  0002e	48 89 9c 24 d0
	01 00 00	 mov	 QWORD PTR [rsp+464], rbx
  00036	48 89 b4 24 d8
	01 00 00	 mov	 QWORD PTR [rsp+472], rsi
  0003e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00042	48 89 bc 24 e0
	01 00 00	 mov	 QWORD PTR [rsp+480], rdi
  0004a	e8 00 00 00 00	 call	 PyObject_Repr
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00057	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  0005c	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00060	48 8b f0	 mov	 rsi, rax
  00063	e8 00 00 00 00	 call	 PyObject_Repr
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00070	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  00075	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00078	48 8b f8	 mov	 rdi, rax
  0007b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0007f	e8 00 00 00 00	 call	 PyObject_Repr
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  0008c	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  00091	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00094	48 8b d8	 mov	 rbx, rax
  00097	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0009b	e8 00 00 00 00	 call	 PyObject_Repr
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  000a8	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  000ad	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000b2	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000b6	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  000ba	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000bf	48 83 c2 78	 add	 rdx, 120		; 00000078H
  000c3	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  000c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$22760[rsp]
  000dc	4d 8d 4d 78	 lea	 r9, QWORD PTR [r13+120]
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0FA@EGMNBIBK@unknown?5scope?5for?5?$CF?4100s?5in?5?$CF?410@
  000e7	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  000ec	e8 00 00 00 00	 call	 PyOS_snprintf

; 1347 :         Py_FatalError(buf);

  000f1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$22760[rsp]
  000f6	e8 00 00 00 00	 call	 Py_FatalError
  000fb	48 8b bc 24 e0
	01 00 00	 mov	 rdi, QWORD PTR [rsp+480]
  00103	48 8b b4 24 d8
	01 00 00	 mov	 rsi, QWORD PTR [rsp+472]
  0010b	48 8b 9c 24 d0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+464]

; 1348 :     }
; 1349 : 
; 1350 :     return scope;

  00113	8b c5		 mov	 eax, ebp
$LN1@get_ref_ty:

; 1351 : }

  00115	48 81 c4 b0 01
	00 00		 add	 rsp, 432		; 000001b0H
  0011c	41 5d		 pop	 r13
  0011e	41 5c		 pop	 r12
  00120	5d		 pop	 rbp
  00121	c3		 ret	 0
get_ref_type ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_lookup_arg DD imagerel compiler_lookup_arg
	DD	imagerel compiler_lookup_arg+94
	DD	imagerel $unwind$compiler_lookup_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_lookup_arg DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_lookup_arg
_TEXT	SEGMENT
dict$ = 48
name$ = 56
compiler_lookup_arg PROC				; COMDAT

; 1355 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1356 :     PyObject *k, *v;
; 1357 :     k = PyTuple_Pack(2, name, name->ob_type);

  0000a	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	b9 02 00 00 00	 mov	 ecx, 2
  00016	e8 00 00 00 00	 call	 PyTuple_Pack
  0001b	48 8b f8	 mov	 rdi, rax

; 1358 :     if (k == NULL)

  0001e	48 85 c0	 test	 rax, rax
  00021	75 0e		 jne	 SHORT $LN2@compiler_l
$LN5@compiler_l:

; 1359 :         return -1;

  00023	83 c8 ff	 or	 eax, -1

; 1365 : }

  00026	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
$LN2@compiler_l:

; 1360 :     v = PyDict_GetItem(dict, k);

  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8b cb	 mov	 rcx, rbx
  00037	e8 00 00 00 00	 call	 PyDict_GetItem

; 1361 :     Py_DECREF(k);

  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	48 8b d8	 mov	 rbx, rax
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1362 :     if (v == NULL)

  00047	48 85 db	 test	 rbx, rbx

; 1363 :         return -1;

  0004a	74 d7		 je	 SHORT $LN5@compiler_l

; 1364 :     return PyLong_AS_LONG(v);

  0004c	48 8b cb	 mov	 rcx, rbx

; 1365 : }

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	e9 00 00 00 00	 jmp	 PyLong_AsLong
compiler_lookup_arg ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_ifexp DD imagerel compiler_ifexp
	DD	imagerel compiler_ifexp+215
	DD	imagerel $unwind$compiler_ifexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_ifexp DD 083a01H
	DD	06643aH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_ifexp
_TEXT	SEGMENT
c$ = 48
e$ = 56
compiler_ifexp PROC					; COMDAT

; 1764 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b ea	 mov	 rbp, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 1765 :     basicblock *end, *next;
; 1766 : 
; 1767 :     assert(e->kind == IfExp_kind);
; 1768 :     end = compiler_new_block(c);

  00015	e8 00 00 00 00	 call	 compiler_new_block
  0001a	48 8b f8	 mov	 rdi, rax

; 1769 :     if (end == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN7@compiler_i@2

; 1782 : }

  00022	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00027	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN7@compiler_i@2:

; 1770 :         return 0;
; 1771 :     next = compiler_new_block(c);

  00032	48 8b cb	 mov	 rcx, rbx
  00035	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003a	e8 00 00 00 00	 call	 compiler_new_block
  0003f	48 8b f0	 mov	 rsi, rax

; 1772 :     if (next == NULL)

  00042	48 85 c0	 test	 rax, rax

; 1773 :         return 0;

  00045	74 67		 je	 SHORT $LN11@compiler_i@2

; 1774 :     VISIT(c, expr, e->v.IfExp.test);

  00047	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  0004b	48 8b cb	 mov	 rcx, rbx
  0004e	e8 00 00 00 00	 call	 compiler_visit_expr
  00053	85 c0		 test	 eax, eax
  00055	74 57		 je	 SHORT $LN11@compiler_i@2

; 1775 :     ADDOP_JABS(c, POP_JUMP_IF_FALSE, next);

  00057	41 b9 01 00 00
	00		 mov	 r9d, 1
  0005d	4c 8b c6	 mov	 r8, rsi
  00060	48 8b cb	 mov	 rcx, rbx
  00063	41 8d 51 71	 lea	 edx, QWORD PTR [r9+113]
  00067	e8 00 00 00 00	 call	 compiler_addop_j
  0006c	85 c0		 test	 eax, eax
  0006e	74 3e		 je	 SHORT $LN11@compiler_i@2

; 1776 :     VISIT(c, expr, e->v.IfExp.body);

  00070	48 8b 55 10	 mov	 rdx, QWORD PTR [rbp+16]
  00074	48 8b cb	 mov	 rcx, rbx
  00077	e8 00 00 00 00	 call	 compiler_visit_expr
  0007c	85 c0		 test	 eax, eax
  0007e	74 2e		 je	 SHORT $LN11@compiler_i@2

; 1777 :     ADDOP_JREL(c, JUMP_FORWARD, end);

  00080	45 33 c9	 xor	 r9d, r9d
  00083	4c 8b c7	 mov	 r8, rdi
  00086	48 8b cb	 mov	 rcx, rbx
  00089	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  0008d	e8 00 00 00 00	 call	 compiler_addop_j
  00092	85 c0		 test	 eax, eax
  00094	74 18		 je	 SHORT $LN11@compiler_i@2

; 1778 :     compiler_use_next_block(c, next);

  00096	48 8b d6	 mov	 rdx, rsi
  00099	48 8b cb	 mov	 rcx, rbx
  0009c	e8 00 00 00 00	 call	 compiler_use_next_block

; 1779 :     VISIT(c, expr, e->v.IfExp.orelse);

  000a1	48 8b 55 18	 mov	 rdx, QWORD PTR [rbp+24]
  000a5	e8 00 00 00 00	 call	 compiler_visit_expr
  000aa	85 c0		 test	 eax, eax
  000ac	75 04		 jne	 SHORT $LN1@compiler_i@2
$LN11@compiler_i@2:
  000ae	33 c0		 xor	 eax, eax
  000b0	eb 10		 jmp	 SHORT $LN10@compiler_i@2
$LN1@compiler_i@2:

; 1780 :     compiler_use_next_block(c, end);

  000b2	48 8b d7	 mov	 rdx, rdi
  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	e8 00 00 00 00	 call	 compiler_use_next_block

; 1781 :     return 1;

  000bd	b8 01 00 00 00	 mov	 eax, 1
$LN10@compiler_i@2:

; 1782 : }

  000c2	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000c7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000cc	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
compiler_ifexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unaryop DD imagerel unaryop
	DD	imagerel unaryop+91
	DD	imagerel $unwind$unaryop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unaryop DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@
CONST	SEGMENT
??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@ DB 'unary o'
	DB	'p %d should not be possible', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unaryop
_TEXT	SEGMENT
op$ = 48
unaryop	PROC						; COMDAT

; 2511 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2512 :     switch (op) {

  00004	8b d1		 mov	 edx, ecx
  00006	ff ca		 dec	 edx
  00008	74 47		 je	 SHORT $LN5@unaryop
  0000a	ff ca		 dec	 edx
  0000c	74 39		 je	 SHORT $LN4@unaryop
  0000e	ff ca		 dec	 edx
  00010	74 2b		 je	 SHORT $LN3@unaryop
  00012	ff ca		 dec	 edx
  00014	74 1d		 je	 SHORT $LN2@unaryop

; 2521 :     default:
; 2522 :         PyErr_Format(PyExc_SystemError,
; 2523 :             "unary op %d should not be possible", op);

  00016	44 8b c1	 mov	 r8d, ecx
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@LCCMHKOH@unary?5op?5?$CFd?5should?5not?5be?5possib@
  00027	e8 00 00 00 00	 call	 PyErr_Format

; 2524 :         return 0;

  0002c	33 c0		 xor	 eax, eax

; 2525 :     }
; 2526 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN2@unaryop:

; 2519 :     case USub:
; 2520 :         return UNARY_NEGATIVE;

  00033	b8 0b 00 00 00	 mov	 eax, 11

; 2525 :     }
; 2526 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN3@unaryop:

; 2517 :     case UAdd:
; 2518 :         return UNARY_POSITIVE;

  0003d	b8 0a 00 00 00	 mov	 eax, 10

; 2525 :     }
; 2526 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
$LN4@unaryop:

; 2515 :     case Not:
; 2516 :         return UNARY_NOT;

  00047	b8 0c 00 00 00	 mov	 eax, 12

; 2525 :     }
; 2526 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
$LN5@unaryop:

; 2513 :     case Invert:
; 2514 :         return UNARY_INVERT;

  00051	b8 0f 00 00 00	 mov	 eax, 15

; 2525 :     }
; 2526 : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
unaryop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binop DD	imagerel binop
	DD	imagerel binop+236
	DD	imagerel $unwind$binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binop DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@
CONST	SEGMENT
??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@ DB 'binary o'
	DB	'p %d should not be possible', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT binop
_TEXT	SEGMENT
op$ = 48
binop	PROC						; COMDAT

; 2530 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2531 :     switch (op) {

  00004	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00007	83 f8 0b	 cmp	 eax, 11
  0000a	0f 87 8e 00 00
	00		 ja	 $LN1@binop
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00017	48 98		 cdqe
  00019	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN18@binop[r8+rax*4]
  00021	49 03 d0	 add	 rdx, r8
  00024	ff e2		 jmp	 rdx
$LN13@binop:

; 2532 :     case Add:
; 2533 :         return BINARY_ADD;

  00026	b8 17 00 00 00	 mov	 eax, 23

; 2560 :     }
; 2561 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN12@binop:

; 2534 :     case Sub:
; 2535 :         return BINARY_SUBTRACT;

  00030	b8 18 00 00 00	 mov	 eax, 24

; 2560 :     }
; 2561 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
$LN11@binop:

; 2536 :     case Mult:
; 2537 :         return BINARY_MULTIPLY;

  0003a	b8 14 00 00 00	 mov	 eax, 20

; 2560 :     }
; 2561 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN10@binop:

; 2538 :     case Div:
; 2539 :         return BINARY_TRUE_DIVIDE;

  00044	b8 1b 00 00 00	 mov	 eax, 27

; 2560 :     }
; 2561 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
$LN9@binop:

; 2540 :     case Mod:
; 2541 :         return BINARY_MODULO;

  0004e	b8 16 00 00 00	 mov	 eax, 22

; 2560 :     }
; 2561 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
$LN8@binop:

; 2542 :     case Pow:
; 2543 :         return BINARY_POWER;

  00058	b8 13 00 00 00	 mov	 eax, 19

; 2560 :     }
; 2561 : }

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
$LN7@binop:

; 2544 :     case LShift:
; 2545 :         return BINARY_LSHIFT;

  00062	b8 3e 00 00 00	 mov	 eax, 62			; 0000003eH

; 2560 :     }
; 2561 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
$LN6@binop:

; 2546 :     case RShift:
; 2547 :         return BINARY_RSHIFT;

  0006c	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH

; 2560 :     }
; 2561 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
$LN5@binop:

; 2548 :     case BitOr:
; 2549 :         return BINARY_OR;

  00076	b8 42 00 00 00	 mov	 eax, 66			; 00000042H

; 2560 :     }
; 2561 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
$LN4@binop:

; 2550 :     case BitXor:
; 2551 :         return BINARY_XOR;

  00080	b8 41 00 00 00	 mov	 eax, 65			; 00000041H

; 2560 :     }
; 2561 : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
$LN3@binop:

; 2552 :     case BitAnd:
; 2553 :         return BINARY_AND;

  0008a	b8 40 00 00 00	 mov	 eax, 64			; 00000040H

; 2560 :     }
; 2561 : }

  0008f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00093	c3		 ret	 0
$LN2@binop:

; 2554 :     case FloorDiv:
; 2555 :         return BINARY_FLOOR_DIVIDE;

  00094	b8 1a 00 00 00	 mov	 eax, 26

; 2560 :     }
; 2561 : }

  00099	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009d	c3		 ret	 0
$LN1@binop:

; 2556 :     default:
; 2557 :         PyErr_Format(PyExc_SystemError,
; 2558 :             "binary op %d should not be possible", op);

  0009e	44 8b c1	 mov	 r8d, ecx
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@HMDMBIJ@binary?5op?5?$CFd?5should?5not?5be?5possi@
  000af	e8 00 00 00 00	 call	 PyErr_Format

; 2559 :         return 0;

  000b4	33 c0		 xor	 eax, eax

; 2560 :     }
; 2561 : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN18@binop:
  000bc	00 00 00 00	 DD	 $LN13@binop
  000c0	00 00 00 00	 DD	 $LN12@binop
  000c4	00 00 00 00	 DD	 $LN11@binop
  000c8	00 00 00 00	 DD	 $LN10@binop
  000cc	00 00 00 00	 DD	 $LN9@binop
  000d0	00 00 00 00	 DD	 $LN8@binop
  000d4	00 00 00 00	 DD	 $LN7@binop
  000d8	00 00 00 00	 DD	 $LN6@binop
  000dc	00 00 00 00	 DD	 $LN5@binop
  000e0	00 00 00 00	 DD	 $LN4@binop
  000e4	00 00 00 00	 DD	 $LN3@binop
  000e8	00 00 00 00	 DD	 $LN2@binop
binop	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT cmpop
_TEXT	SEGMENT
op$ = 8
cmpop	PROC						; COMDAT

; 2566 :     switch (op) {

  00000	ff c9		 dec	 ecx
  00002	83 f9 09	 cmp	 ecx, 9
  00005	77 4f		 ja	 SHORT $LN1@cmpop
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0000e	48 63 c1	 movsxd	 rax, ecx
  00011	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN16@cmpop[rdx+rax*4]
  00018	48 03 ca	 add	 rcx, rdx
  0001b	ff e1		 jmp	 rcx
$LN11@cmpop:

; 2567 :     case Eq:
; 2568 :         return PyCmp_EQ;

  0001d	b8 02 00 00 00	 mov	 eax, 2

; 2589 :     }
; 2590 : }

  00022	c3		 ret	 0
$LN10@cmpop:

; 2569 :     case NotEq:
; 2570 :         return PyCmp_NE;

  00023	b8 03 00 00 00	 mov	 eax, 3

; 2589 :     }
; 2590 : }

  00028	c3		 ret	 0
$LN9@cmpop:

; 2571 :     case Lt:
; 2572 :         return PyCmp_LT;

  00029	33 c0		 xor	 eax, eax

; 2589 :     }
; 2590 : }

  0002b	c3		 ret	 0
$LN8@cmpop:

; 2573 :     case LtE:
; 2574 :         return PyCmp_LE;

  0002c	b8 01 00 00 00	 mov	 eax, 1

; 2589 :     }
; 2590 : }

  00031	c3		 ret	 0
$LN7@cmpop:

; 2575 :     case Gt:
; 2576 :         return PyCmp_GT;

  00032	b8 04 00 00 00	 mov	 eax, 4

; 2589 :     }
; 2590 : }

  00037	c3		 ret	 0
$LN6@cmpop:

; 2577 :     case GtE:
; 2578 :         return PyCmp_GE;

  00038	b8 05 00 00 00	 mov	 eax, 5

; 2589 :     }
; 2590 : }

  0003d	c3		 ret	 0
$LN5@cmpop:

; 2579 :     case Is:
; 2580 :         return PyCmp_IS;

  0003e	b8 08 00 00 00	 mov	 eax, 8

; 2589 :     }
; 2590 : }

  00043	c3		 ret	 0
$LN4@cmpop:

; 2581 :     case IsNot:
; 2582 :         return PyCmp_IS_NOT;

  00044	b8 09 00 00 00	 mov	 eax, 9

; 2589 :     }
; 2590 : }

  00049	c3		 ret	 0
$LN3@cmpop:

; 2583 :     case In:
; 2584 :         return PyCmp_IN;

  0004a	b8 06 00 00 00	 mov	 eax, 6

; 2589 :     }
; 2590 : }

  0004f	c3		 ret	 0
$LN2@cmpop:

; 2585 :     case NotIn:
; 2586 :         return PyCmp_NOT_IN;

  00050	b8 07 00 00 00	 mov	 eax, 7

; 2589 :     }
; 2590 : }

  00055	c3		 ret	 0
$LN1@cmpop:

; 2587 :     default:
; 2588 :         return PyCmp_BAD;

  00056	b8 0b 00 00 00	 mov	 eax, 11

; 2589 :     }
; 2590 : }

  0005b	c3		 ret	 0
$LN16@cmpop:
  0005c	00 00 00 00	 DD	 $LN11@cmpop
  00060	00 00 00 00	 DD	 $LN10@cmpop
  00064	00 00 00 00	 DD	 $LN9@cmpop
  00068	00 00 00 00	 DD	 $LN8@cmpop
  0006c	00 00 00 00	 DD	 $LN7@cmpop
  00070	00 00 00 00	 DD	 $LN6@cmpop
  00074	00 00 00 00	 DD	 $LN5@cmpop
  00078	00 00 00 00	 DD	 $LN4@cmpop
  0007c	00 00 00 00	 DD	 $LN3@cmpop
  00080	00 00 00 00	 DD	 $LN2@cmpop
cmpop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$inplace_binop DD imagerel inplace_binop
	DD	imagerel inplace_binop+236
	DD	imagerel $unwind$inplace_binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inplace_binop DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@
CONST	SEGMENT
??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@ DB 'inplace '
	DB	'binary op %d should not be possible', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT inplace_binop
_TEXT	SEGMENT
op$ = 48
inplace_binop PROC					; COMDAT

; 2594 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2595 :     switch (op) {

  00004	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00007	83 f8 0b	 cmp	 eax, 11
  0000a	0f 87 8e 00 00
	00		 ja	 $LN1@inplace_bi
  00010	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00017	48 98		 cdqe
  00019	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN18@inplace_bi[r8+rax*4]
  00021	49 03 d0	 add	 rdx, r8
  00024	ff e2		 jmp	 rdx
$LN13@inplace_bi:

; 2596 :     case Add:
; 2597 :         return INPLACE_ADD;

  00026	b8 37 00 00 00	 mov	 eax, 55			; 00000037H

; 2624 :     }
; 2625 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN12@inplace_bi:

; 2598 :     case Sub:
; 2599 :         return INPLACE_SUBTRACT;

  00030	b8 38 00 00 00	 mov	 eax, 56			; 00000038H

; 2624 :     }
; 2625 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
$LN11@inplace_bi:

; 2600 :     case Mult:
; 2601 :         return INPLACE_MULTIPLY;

  0003a	b8 39 00 00 00	 mov	 eax, 57			; 00000039H

; 2624 :     }
; 2625 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
$LN10@inplace_bi:

; 2602 :     case Div:
; 2603 :         return INPLACE_TRUE_DIVIDE;

  00044	b8 1d 00 00 00	 mov	 eax, 29

; 2624 :     }
; 2625 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
$LN9@inplace_bi:

; 2604 :     case Mod:
; 2605 :         return INPLACE_MODULO;

  0004e	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH

; 2624 :     }
; 2625 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
$LN8@inplace_bi:

; 2606 :     case Pow:
; 2607 :         return INPLACE_POWER;

  00058	b8 43 00 00 00	 mov	 eax, 67			; 00000043H

; 2624 :     }
; 2625 : }

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00061	c3		 ret	 0
$LN7@inplace_bi:

; 2608 :     case LShift:
; 2609 :         return INPLACE_LSHIFT;

  00062	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH

; 2624 :     }
; 2625 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
$LN6@inplace_bi:

; 2610 :     case RShift:
; 2611 :         return INPLACE_RSHIFT;

  0006c	b8 4c 00 00 00	 mov	 eax, 76			; 0000004cH

; 2624 :     }
; 2625 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
$LN5@inplace_bi:

; 2612 :     case BitOr:
; 2613 :         return INPLACE_OR;

  00076	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH

; 2624 :     }
; 2625 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
$LN4@inplace_bi:

; 2614 :     case BitXor:
; 2615 :         return INPLACE_XOR;

  00080	b8 4e 00 00 00	 mov	 eax, 78			; 0000004eH

; 2624 :     }
; 2625 : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
$LN3@inplace_bi:

; 2616 :     case BitAnd:
; 2617 :         return INPLACE_AND;

  0008a	b8 4d 00 00 00	 mov	 eax, 77			; 0000004dH

; 2624 :     }
; 2625 : }

  0008f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00093	c3		 ret	 0
$LN2@inplace_bi:

; 2618 :     case FloorDiv:
; 2619 :         return INPLACE_FLOOR_DIVIDE;

  00094	b8 1c 00 00 00	 mov	 eax, 28

; 2624 :     }
; 2625 : }

  00099	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009d	c3		 ret	 0
$LN1@inplace_bi:

; 2620 :     default:
; 2621 :         PyErr_Format(PyExc_SystemError,
; 2622 :             "inplace binary op %d should not be possible", op);

  0009e	44 8b c1	 mov	 r8d, ecx
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LKMPPKN@inplace?5binary?5op?5?$CFd?5should?5not?5@
  000af	e8 00 00 00 00	 call	 PyErr_Format

; 2623 :         return 0;

  000b4	33 c0		 xor	 eax, eax

; 2624 :     }
; 2625 : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
  000bb	90		 npad	 1
$LN18@inplace_bi:
  000bc	00 00 00 00	 DD	 $LN13@inplace_bi
  000c0	00 00 00 00	 DD	 $LN12@inplace_bi
  000c4	00 00 00 00	 DD	 $LN11@inplace_bi
  000c8	00 00 00 00	 DD	 $LN10@inplace_bi
  000cc	00 00 00 00	 DD	 $LN9@inplace_bi
  000d0	00 00 00 00	 DD	 $LN8@inplace_bi
  000d4	00 00 00 00	 DD	 $LN7@inplace_bi
  000d8	00 00 00 00	 DD	 $LN6@inplace_bi
  000dc	00 00 00 00	 DD	 $LN5@inplace_bi
  000e0	00 00 00 00	 DD	 $LN4@inplace_bi
  000e4	00 00 00 00	 DD	 $LN3@inplace_bi
  000e8	00 00 00 00	 DD	 $LN2@inplace_bi
inplace_binop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_boolop DD imagerel compiler_boolop
	DD	imagerel compiler_boolop+55
	DD	imagerel $unwind$compiler_boolop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_boolop DD imagerel compiler_boolop+55
	DD	imagerel compiler_boolop+195
	DD	imagerel $chain$1$compiler_boolop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_boolop DD imagerel compiler_boolop+195
	DD	imagerel compiler_boolop+215
	DD	imagerel $chain$2$compiler_boolop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_boolop DD 021H
	DD	imagerel compiler_boolop
	DD	imagerel compiler_boolop+55
	DD	imagerel $unwind$compiler_boolop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_boolop DD 040a21H
	DD	09c40aH
	DD	085405H
	DD	imagerel compiler_boolop
	DD	imagerel compiler_boolop+55
	DD	imagerel $unwind$compiler_boolop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_boolop DD 081301H
	DD	0b6413H
	DD	0a3413H
	DD	0e00f3213H
	DD	0700bd00dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_boolop
_TEXT	SEGMENT
c$ = 64
e$ = 72
compiler_boolop PROC					; COMDAT

; 2748 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2749 :     basicblock *end;
; 2750 :     int jumpi, i, n;
; 2751 :     asdl_seq *s;
; 2752 : 
; 2753 :     assert(e->kind == BoolOp_kind);
; 2754 :     if (e->v.BoolOp.op == And)

  00013	33 db		 xor	 ebx, ebx
  00015	83 7a 08 01	 cmp	 DWORD PTR [rdx+8], 1
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	44 8b eb	 mov	 r13d, ebx
  0001f	41 0f 95 c5	 setne	 r13b
  00023	48 8b f1	 mov	 rsi, rcx

; 2755 :         jumpi = JUMP_IF_FALSE_OR_POP;
; 2756 :     else
; 2757 :         jumpi = JUMP_IF_TRUE_OR_POP;
; 2758 :     end = compiler_new_block(c);

  00026	e8 00 00 00 00	 call	 compiler_new_block
  0002b	4c 8b f0	 mov	 r14, rax

; 2759 :     if (end == NULL)

  0002e	48 85 c0	 test	 rax, rax
  00031	0f 84 8c 00 00
	00		 je	 $LN10@compiler_b
$LN7@compiler_b:
  00037	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0003c	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12

; 2760 :         return 0;
; 2761 :     s = e->v.BoolOp.values;

  00041	4c 8b 67 10	 mov	 r12, QWORD PTR [rdi+16]

; 2762 :     n = asdl_seq_LEN(s) - 1;

  00045	48 8b c3	 mov	 rax, rbx
  00048	4d 85 e4	 test	 r12, r12
  0004b	74 04		 je	 SHORT $LN13@compiler_b
  0004d	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
$LN13@compiler_b:
  00051	ff c8		 dec	 eax

; 2763 :     assert(n >= 0);
; 2764 :     for (i = 0; i < n; ++i) {

  00053	48 63 e8	 movsxd	 rbp, eax
  00056	85 c0		 test	 eax, eax
  00058	7e 3a		 jle	 SHORT $LN4@compiler_b

; 2762 :     n = asdl_seq_LEN(s) - 1;

  0005a	49 8d 7c 24 08	 lea	 rdi, QWORD PTR [r12+8]
  0005f	90		 npad	 1
$LL6@compiler_b:

; 2765 :         VISIT(c, expr, (expr_ty)asdl_seq_GET(s, i));

  00060	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00063	48 8b ce	 mov	 rcx, rsi
  00066	e8 00 00 00 00	 call	 compiler_visit_expr
  0006b	85 c0		 test	 eax, eax
  0006d	74 36		 je	 SHORT $LN15@compiler_b

; 2766 :         ADDOP_JABS(c, jumpi, end);

  0006f	41 8d 55 6f	 lea	 edx, DWORD PTR [r13+111]
  00073	41 b9 01 00 00
	00		 mov	 r9d, 1
  00079	4d 8b c6	 mov	 r8, r14
  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	e8 00 00 00 00	 call	 compiler_addop_j
  00084	85 c0		 test	 eax, eax
  00086	74 1d		 je	 SHORT $LN15@compiler_b

; 2763 :     assert(n >= 0);
; 2764 :     for (i = 0; i < n; ++i) {

  00088	48 ff c3	 inc	 rbx
  0008b	48 83 c7 08	 add	 rdi, 8
  0008f	48 3b dd	 cmp	 rbx, rbp
  00092	7c cc		 jl	 SHORT $LL6@compiler_b
$LN4@compiler_b:

; 2767 :     }
; 2768 :     VISIT(c, expr, (expr_ty)asdl_seq_GET(s, n));

  00094	49 8b 54 ec 08	 mov	 rdx, QWORD PTR [r12+rbp*8+8]
  00099	48 8b ce	 mov	 rcx, rsi
  0009c	e8 00 00 00 00	 call	 compiler_visit_expr
  000a1	85 c0		 test	 eax, eax
  000a3	75 04		 jne	 SHORT $LN1@compiler_b
$LN15@compiler_b:
  000a5	33 c0		 xor	 eax, eax
  000a7	eb 10		 jmp	 SHORT $LN19@compiler_b
$LN1@compiler_b:

; 2769 :     compiler_use_next_block(c, end);

  000a9	49 8b d6	 mov	 rdx, r14
  000ac	48 8b ce	 mov	 rcx, rsi
  000af	e8 00 00 00 00	 call	 compiler_use_next_block

; 2770 :     return 1;

  000b4	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_b:
  000b9	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000be	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
$LN10@compiler_b:

; 2771 : }

  000c3	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c8	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d1	41 5e		 pop	 r14
  000d3	41 5d		 pop	 r13
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
compiler_boolop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_compare DD imagerel compiler_compare
	DD	imagerel compiler_compare+47
	DD	imagerel $unwind$compiler_compare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_compare DD imagerel compiler_compare+47
	DD	imagerel compiler_compare+64
	DD	imagerel $chain$0$compiler_compare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_compare DD imagerel compiler_compare+64
	DD	imagerel compiler_compare+420
	DD	imagerel $chain$3$compiler_compare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compiler_compare DD imagerel compiler_compare+420
	DD	imagerel compiler_compare+489
	DD	imagerel $chain$4$compiler_compare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$compiler_compare DD imagerel compiler_compare+489
	DD	imagerel compiler_compare+535
	DD	imagerel $chain$6$compiler_compare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$compiler_compare DD 080021H
	DD	0bd400H
	DD	0a7400H
	DD	096400H
	DD	085400H
	DD	imagerel compiler_compare
	DD	imagerel compiler_compare+47
	DD	imagerel $unwind$compiler_compare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compiler_compare DD 021H
	DD	imagerel compiler_compare+47
	DD	imagerel compiler_compare+64
	DD	imagerel $chain$0$compiler_compare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_compare DD 061421H
	DD	0bd414H
	DD	0a740aH
	DD	096405H
	DD	imagerel compiler_compare+47
	DD	imagerel compiler_compare+64
	DD	imagerel $chain$0$compiler_compare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_compare DD 020521H
	DD	085405H
	DD	imagerel compiler_compare
	DD	imagerel compiler_compare+47
	DD	imagerel $unwind$compiler_compare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_compare DD 040a01H
	DD	0e006320aH
	DD	03002c004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_compare
_TEXT	SEGMENT
c$ = 64
e$ = 72
compiler_compare PROC					; COMDAT

; 2841 : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 56		 push	 r14
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4c 8b e2	 mov	 r12, rdx

; 2842 :     int i, n;
; 2843 :     basicblock *cleanup = NULL;
; 2844 : 
; 2845 :     /* XXX the logic can be cleaned up for 1 or multiple comparisons */
; 2846 :     VISIT(c, expr, e->v.Compare.left);

  0000d	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	45 33 f6	 xor	 r14d, r14d
  00017	e8 00 00 00 00	 call	 compiler_visit_expr
  0001c	85 c0		 test	 eax, eax
  0001e	75 0a		 jne	 SHORT $LN21@compiler_c

; 2882 : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	41 5e		 pop	 r14
  00026	41 5c		 pop	 r12
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$LN21@compiler_c:

; 2847 :     n = asdl_seq_LEN(e->v.Compare.ops);

  0002a	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  0002f	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00034	48 85 c0	 test	 rax, rax
  00037	0f 85 67 01 00
	00		 jne	 $LN24@compiler_c
  0003d	41 8b ee	 mov	 ebp, r14d
$LN18@compiler_c:
  00040	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00045	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 2855 :     }
; 2856 :     for (i = 1; i < n; i++) {

  0004a	be 01 00 00 00	 mov	 esi, 1
  0004f	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00054	4c 63 ed	 movsxd	 r13, ebp
  00057	8b fe		 mov	 edi, esi
  00059	49 3b f5	 cmp	 rsi, r13
  0005c	0f 8d ad 00 00
	00		 jge	 $LN15@compiler_c
$LL17@compiler_c:

; 2857 :         ADDOP(c, DUP_TOP);

  00062	ba 04 00 00 00	 mov	 edx, 4
  00067	48 8b cb	 mov	 rcx, rbx
  0006a	e8 00 00 00 00	 call	 compiler_addop
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 29 01 00
	00		 je	 $LN39@compiler_c

; 2858 :         ADDOP(c, ROT_THREE);

  00077	ba 03 00 00 00	 mov	 edx, 3
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 compiler_addop
  00084	85 c0		 test	 eax, eax
  00086	0f 84 14 01 00
	00		 je	 $LN39@compiler_c

; 2859 :         ADDOP_I(c, COMPARE_OP,
; 2860 :             cmpop((cmpop_ty)(asdl_seq_GET(
; 2861 :                                       e->v.Compare.ops, i - 1))));

  0008c	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  00091	8b 4c b8 04	 mov	 ecx, DWORD PTR [rax+rdi*4+4]
  00095	e8 00 00 00 00	 call	 cmpop
  0009a	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	44 8b c0	 mov	 r8d, eax
  000a5	e8 00 00 00 00	 call	 compiler_addop_i
  000aa	85 c0		 test	 eax, eax
  000ac	0f 84 ee 00 00
	00		 je	 $LN39@compiler_c

; 2862 :         ADDOP_JABS(c, JUMP_IF_FALSE_OR_POP, cleanup);

  000b2	41 b9 01 00 00
	00		 mov	 r9d, 1
  000b8	4d 8b c6	 mov	 r8, r14
  000bb	48 8b cb	 mov	 rcx, rbx
  000be	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  000c2	e8 00 00 00 00	 call	 compiler_addop_j
  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 d1 00 00
	00		 je	 $LN39@compiler_c

; 2863 :         NEXT_BLOCK(c);

  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	e8 00 00 00 00	 call	 compiler_next_block
  000d7	48 85 c0	 test	 rax, rax
  000da	0f 84 c0 00 00
	00		 je	 $LN39@compiler_c

; 2864 :         if (i < (n - 1))

  000e0	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]
  000e3	3b f0		 cmp	 esi, eax
  000e5	7d 1a		 jge	 SHORT $LN16@compiler_c

; 2865 :             VISIT(c, expr,
; 2866 :                 (expr_ty)asdl_seq_GET(e->v.Compare.comparators, i));

  000e7	49 8b 54 24 18	 mov	 rdx, QWORD PTR [r12+24]
  000ec	48 8b cb	 mov	 rcx, rbx
  000ef	48 8b 54 fa 08	 mov	 rdx, QWORD PTR [rdx+rdi*8+8]
  000f4	e8 00 00 00 00	 call	 compiler_visit_expr
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 9f 00 00
	00		 je	 $LN39@compiler_c
$LN16@compiler_c:

; 2855 :     }
; 2856 :     for (i = 1; i < n; i++) {

  00101	48 ff c7	 inc	 rdi
  00104	ff c6		 inc	 esi
  00106	49 3b fd	 cmp	 rdi, r13
  00109	0f 8c 53 ff ff
	ff		 jl	 $LL17@compiler_c
$LN15@compiler_c:

; 2867 :     }
; 2868 :     VISIT(c, expr, (expr_ty)asdl_seq_GET(e->v.Compare.comparators, n - 1));

  0010f	49 8b 54 24 18	 mov	 rdx, QWORD PTR [r12+24]
  00114	48 8b cb	 mov	 rcx, rbx
  00117	4a 8b 14 ea	 mov	 rdx, QWORD PTR [rdx+r13*8]
  0011b	e8 00 00 00 00	 call	 compiler_visit_expr
  00120	85 c0		 test	 eax, eax
  00122	74 7c		 je	 SHORT $LN39@compiler_c

; 2869 :     ADDOP_I(c, COMPARE_OP,
; 2870 :            cmpop((cmpop_ty)(asdl_seq_GET(e->v.Compare.ops, n - 1))));

  00124	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  00129	42 8b 4c a8 04	 mov	 ecx, DWORD PTR [rax+r13*4+4]
  0012e	e8 00 00 00 00	 call	 cmpop
  00133	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00138	48 8b cb	 mov	 rcx, rbx
  0013b	44 8b c0	 mov	 r8d, eax
  0013e	e8 00 00 00 00	 call	 compiler_addop_i
  00143	85 c0		 test	 eax, eax
  00145	74 59		 je	 SHORT $LN39@compiler_c

; 2871 :     if (n > 1) {

  00147	83 fd 01	 cmp	 ebp, 1
  0014a	0f 8e a4 00 00
	00		 jle	 $LN5@compiler_c

; 2872 :         basicblock *end = compiler_new_block(c);

  00150	48 8b cb	 mov	 rcx, rbx
  00153	e8 00 00 00 00	 call	 compiler_new_block
  00158	48 8b f8	 mov	 rdi, rax

; 2873 :         if (end == NULL)

  0015b	48 85 c0	 test	 rax, rax

; 2874 :             return 0;

  0015e	74 40		 je	 SHORT $LN39@compiler_c

; 2875 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  00160	45 33 c9	 xor	 r9d, r9d
  00163	4c 8b c0	 mov	 r8, rax
  00166	48 8b cb	 mov	 rcx, rbx
  00169	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  0016d	e8 00 00 00 00	 call	 compiler_addop_j
  00172	85 c0		 test	 eax, eax
  00174	74 2a		 je	 SHORT $LN39@compiler_c

; 2876 :         compiler_use_next_block(c, cleanup);

  00176	49 8b d6	 mov	 rdx, r14
  00179	48 8b cb	 mov	 rcx, rbx
  0017c	e8 00 00 00 00	 call	 compiler_use_next_block

; 2877 :         ADDOP(c, ROT_TWO);

  00181	ba 02 00 00 00	 mov	 edx, 2
  00186	e8 00 00 00 00	 call	 compiler_addop
  0018b	85 c0		 test	 eax, eax
  0018d	74 11		 je	 SHORT $LN39@compiler_c

; 2878 :         ADDOP(c, POP_TOP);

  0018f	ba 01 00 00 00	 mov	 edx, 1
  00194	48 8b cb	 mov	 rcx, rbx
  00197	e8 00 00 00 00	 call	 compiler_addop
  0019c	85 c0		 test	 eax, eax
  0019e	75 49		 jne	 SHORT $LN1@compiler_c
$LN39@compiler_c:
  001a0	33 c0		 xor	 eax, eax
  001a2	eb 55		 jmp	 SHORT $LN38@compiler_c
$LN24@compiler_c:

; 2847 :     n = asdl_seq_LEN(e->v.Compare.ops);

  001a4	8b 28		 mov	 ebp, DWORD PTR [rax]

; 2848 :     assert(n > 0);
; 2849 :     if (n > 1) {

  001a6	83 fd 01	 cmp	 ebp, 1
  001a9	0f 8e 91 fe ff
	ff		 jle	 $LN18@compiler_c

; 2850 :         cleanup = compiler_new_block(c);

  001af	48 8b cb	 mov	 rcx, rbx
  001b2	e8 00 00 00 00	 call	 compiler_new_block
  001b7	4c 8b f0	 mov	 r14, rax

; 2851 :         if (cleanup == NULL)

  001ba	48 85 c0	 test	 rax, rax

; 2852 :             return 0;

  001bd	74 19		 je	 SHORT $LN40@compiler_c

; 2853 :         VISIT(c, expr,
; 2854 :             (expr_ty)asdl_seq_GET(e->v.Compare.comparators, 0));

  001bf	49 8b 54 24 18	 mov	 rdx, QWORD PTR [r12+24]
  001c4	48 8b cb	 mov	 rcx, rbx
  001c7	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  001cb	e8 00 00 00 00	 call	 compiler_visit_expr
  001d0	85 c0		 test	 eax, eax
  001d2	0f 85 68 fe ff
	ff		 jne	 $LN18@compiler_c
$LN40@compiler_c:
  001d8	33 c0		 xor	 eax, eax
  001da	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 2882 : }

  001df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e3	41 5e		 pop	 r14
  001e5	41 5c		 pop	 r12
  001e7	5b		 pop	 rbx
  001e8	c3		 ret	 0
$LN1@compiler_c:

; 2879 :         compiler_use_next_block(c, end);

  001e9	48 8b d7	 mov	 rdx, rdi
  001ec	48 8b cb	 mov	 rcx, rbx
  001ef	e8 00 00 00 00	 call	 compiler_use_next_block
$LN5@compiler_c:

; 2880 :     }
; 2881 :     return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
$LN38@compiler_c:
  001f9	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001fe	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00203	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  00208	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 2882 : }

  0020d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00211	41 5e		 pop	 r14
  00213	41 5c		 pop	 r12
  00215	5b		 pop	 rbx
  00216	c3		 ret	 0
compiler_compare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_comprehension_generator DD imagerel compiler_comprehension_generator
	DD	imagerel compiler_comprehension_generator+817
	DD	imagerel $unwind$compiler_comprehension_generator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_comprehension_generator DD 061b01H
	DD	0e341bH
	DD	07017921bH
	DD	050156016H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_comprehension_generator
_TEXT	SEGMENT
start$1$ = 48
skip$1$ = 56
if_cleanup$1$ = 64
anchor$1$ = 72
c$ = 112
generators$ = 120
gen_index$ = 128
elt$ = 136
val$ = 144
type$ = 152
compiler_comprehension_generator PROC			; COMDAT

; 2957 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000f	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0001b	49 63 f8	 movsxd	 rdi, r8d
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	48 8b d9	 mov	 rbx, rcx

; 2958 :     /* generate code for the iterator, then each of the ifs,
; 2959 :        and then write to the element */
; 2960 : 
; 2961 :     comprehension_ty gen;
; 2962 :     basicblock *start, *anchor, *skip, *if_cleanup;
; 2963 :     int i, n;
; 2964 : 
; 2965 :     start = compiler_new_block(c);

  00024	e8 00 00 00 00	 call	 compiler_new_block

; 2966 :     skip = compiler_new_block(c);

  00029	48 8b cb	 mov	 rcx, rbx
  0002c	48 89 44 24 30	 mov	 QWORD PTR start$1$[rsp], rax
  00031	e8 00 00 00 00	 call	 compiler_new_block

; 2967 :     if_cleanup = compiler_new_block(c);

  00036	48 8b cb	 mov	 rcx, rbx
  00039	48 89 44 24 38	 mov	 QWORD PTR skip$1$[rsp], rax
  0003e	e8 00 00 00 00	 call	 compiler_new_block

; 2968 :     anchor = compiler_new_block(c);

  00043	48 8b cb	 mov	 rcx, rbx
  00046	48 8b f0	 mov	 rsi, rax
  00049	48 89 44 24 40	 mov	 QWORD PTR if_cleanup$1$[rsp], rax
  0004e	e8 00 00 00 00	 call	 compiler_new_block

; 2969 : 
; 2970 :     if (start == NULL || skip == NULL || if_cleanup == NULL ||
; 2971 :         anchor == NULL)

  00053	48 83 7c 24 30
	00		 cmp	 QWORD PTR start$1$[rsp], 0
  00059	48 89 44 24 48	 mov	 QWORD PTR anchor$1$[rsp], rax
  0005e	74 38		 je	 SHORT $LN36@compiler_c@2
  00060	48 83 7c 24 38
	00		 cmp	 QWORD PTR skip$1$[rsp], 0
  00066	74 30		 je	 SHORT $LN36@compiler_c@2
  00068	48 85 f6	 test	 rsi, rsi
  0006b	74 2b		 je	 SHORT $LN36@compiler_c@2
  0006d	48 85 c0	 test	 rax, rax
  00070	74 26		 je	 SHORT $LN36@compiler_c@2

; 2973 : 
; 2974 :     gen = (comprehension_ty)asdl_seq_GET(generators, gen_index);

  00072	48 8b 6c fd 08	 mov	 rbp, QWORD PTR [rbp+rdi*8+8]

; 2975 : 
; 2976 :     if (gen_index == 0) {
; 2977 :         /* Receive outermost iter as an implicit argument */
; 2978 :         c->u->u_argcount = 1;
; 2979 :         ADDOP_I(c, LOAD_FAST, 0);

  00077	48 8b cb	 mov	 rcx, rbx
  0007a	85 ff		 test	 edi, edi
  0007c	75 29		 jne	 SHORT $LN35@compiler_c@2
  0007e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00082	8d 57 7c	 lea	 edx, QWORD PTR [rdi+124]
  00085	45 33 c0	 xor	 r8d, r8d
  00088	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1
  0008f	e8 00 00 00 00	 call	 compiler_addop_i
  00094	85 c0		 test	 eax, eax
  00096	75 2d		 jne	 SHORT $LN31@compiler_c@2
$LN36@compiler_c@2:

; 2972 :         return 0;

  00098	33 c0		 xor	 eax, eax

; 3039 : 
; 3040 :     return 1;
; 3041 : }

  0009a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0009f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	5d		 pop	 rbp
  000a6	c3		 ret	 0
$LN35@compiler_c@2:

; 2980 :     }
; 2981 :     else {
; 2982 :         /* Sub-iter - calculate on the fly */
; 2983 :         VISIT(c, expr, gen->iter);

  000a7	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  000ab	e8 00 00 00 00	 call	 compiler_visit_expr
  000b0	85 c0		 test	 eax, eax
  000b2	74 e4		 je	 SHORT $LN36@compiler_c@2

; 2984 :         ADDOP(c, GET_ITER);

  000b4	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  000b9	48 8b cb	 mov	 rcx, rbx
  000bc	e8 00 00 00 00	 call	 compiler_addop
  000c1	85 c0		 test	 eax, eax
  000c3	74 d3		 je	 SHORT $LN36@compiler_c@2
$LN31@compiler_c@2:

; 2985 :     }
; 2986 :     compiler_use_next_block(c, start);

  000c5	48 8b 54 24 30	 mov	 rdx, QWORD PTR start$1$[rsp]
  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 compiler_use_next_block

; 2987 :     ADDOP_JREL(c, FOR_ITER, anchor);

  000d2	4c 8b 44 24 48	 mov	 r8, QWORD PTR anchor$1$[rsp]
  000d7	45 33 c9	 xor	 r9d, r9d
  000da	41 8d 51 5d	 lea	 edx, QWORD PTR [r9+93]
  000de	e8 00 00 00 00	 call	 compiler_addop_j
  000e3	85 c0		 test	 eax, eax
  000e5	74 b1		 je	 SHORT $LN36@compiler_c@2

; 2988 :     NEXT_BLOCK(c);

  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 compiler_next_block
  000ef	48 85 c0	 test	 rax, rax
  000f2	74 a4		 je	 SHORT $LN36@compiler_c@2

; 2989 :     VISIT(c, expr, gen->target);

  000f4	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 compiler_visit_expr
  00100	85 c0		 test	 eax, eax
  00102	74 94		 je	 SHORT $LN36@compiler_c@2

; 2990 : 
; 2991 :     /* XXX this needs to be cleaned up...a lot! */
; 2992 :     n = asdl_seq_LEN(gen->ifs);

  00104	48 8b 45 10	 mov	 rax, QWORD PTR [rbp+16]
  00108	33 c9		 xor	 ecx, ecx
  0010a	48 85 c0	 test	 rax, rax
  0010d	75 04		 jne	 SHORT $LN40@compiler_c@2
  0010f	8b c1		 mov	 eax, ecx
  00111	eb 02		 jmp	 SHORT $LN41@compiler_c@2
$LN40@compiler_c@2:
  00113	8b 00		 mov	 eax, DWORD PTR [rax]
$LN41@compiler_c@2:

; 2993 :     for (i = 0; i < n; i++) {

  00115	48 8b f9	 mov	 rdi, rcx
  00118	48 63 f0	 movsxd	 rsi, eax
  0011b	85 c0		 test	 eax, eax
  0011d	7e 54		 jle	 SHORT $LN25@compiler_c@2
  0011f	90		 npad	 1
$LL27@compiler_c@2:

; 2994 :         expr_ty e = (expr_ty)asdl_seq_GET(gen->ifs, i);

  00120	48 8b 45 10	 mov	 rax, QWORD PTR [rbp+16]

; 2995 :         VISIT(c, expr, e);

  00124	48 8b cb	 mov	 rcx, rbx
  00127	48 8b 54 f8 08	 mov	 rdx, QWORD PTR [rax+rdi*8+8]
  0012c	e8 00 00 00 00	 call	 compiler_visit_expr
  00131	85 c0		 test	 eax, eax
  00133	0f 84 5f ff ff
	ff		 je	 $LN36@compiler_c@2

; 2996 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, if_cleanup);

  00139	4c 8b 44 24 40	 mov	 r8, QWORD PTR if_cleanup$1$[rsp]
  0013e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00144	48 8b cb	 mov	 rcx, rbx
  00147	41 8d 51 71	 lea	 edx, QWORD PTR [r9+113]
  0014b	e8 00 00 00 00	 call	 compiler_addop_j
  00150	85 c0		 test	 eax, eax
  00152	0f 84 40 ff ff
	ff		 je	 $LN36@compiler_c@2

; 2997 :         NEXT_BLOCK(c);

  00158	48 8b cb	 mov	 rcx, rbx
  0015b	e8 00 00 00 00	 call	 compiler_next_block
  00160	48 85 c0	 test	 rax, rax
  00163	0f 84 2f ff ff
	ff		 je	 $LN36@compiler_c@2

; 2993 :     for (i = 0; i < n; i++) {

  00169	48 ff c7	 inc	 rdi
  0016c	48 3b fe	 cmp	 rdi, rsi
  0016f	7c af		 jl	 SHORT $LL27@compiler_c@2

; 2997 :         NEXT_BLOCK(c);

  00171	33 c9		 xor	 ecx, ecx
$LN25@compiler_c@2:

; 2998 :     }
; 2999 : 
; 3000 :     if (++gen_index < asdl_seq_LEN(generators))

  00173	48 8b 54 24 78	 mov	 rdx, QWORD PTR generators$[rsp]
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 85 d2	 test	 rdx, rdx
  0017e	74 03		 je	 SHORT $LN43@compiler_c@2
  00180	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN43@compiler_c@2:
  00183	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR gen_index$[rsp]
  0018a	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR type$[rsp]
  00191	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR val$[rsp]
  00199	ff c1		 inc	 ecx
  0019b	48 63 f1	 movsxd	 rsi, ecx
  0019e	89 8c 24 80 00
	00 00		 mov	 DWORD PTR gen_index$[rsp], ecx
  001a5	48 3b f0	 cmp	 rsi, rax
  001a8	7d 29		 jge	 SHORT $LN20@compiler_c@2

; 3001 :         if (!compiler_comprehension_generator(c,
; 3002 :                                               generators, gen_index,
; 3003 :                                               elt, val, type))

  001aa	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR elt$[rsp]
  001b2	44 8b c1	 mov	 r8d, ecx
  001b5	48 8b cb	 mov	 rcx, rbx
  001b8	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  001bc	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  001c1	e8 00 00 00 00	 call	 compiler_comprehension_generator
  001c6	85 c0		 test	 eax, eax

; 3004 :         return 0;

  001c8	0f 84 ca fe ff
	ff		 je	 $LN36@compiler_c@2

; 2957 : {

  001ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR generators$[rsp]
$LN20@compiler_c@2:

; 3005 : 
; 3006 :     /* only append after the last for generator */
; 3007 :     if (gen_index >= asdl_seq_LEN(generators)) {

  001d3	48 85 d2	 test	 rdx, rdx
  001d6	75 04		 jne	 SHORT $LN44@compiler_c@2
  001d8	33 c0		 xor	 eax, eax
  001da	eb 03		 jmp	 SHORT $LN45@compiler_c@2
$LN44@compiler_c@2:
  001dc	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN45@compiler_c@2:
  001df	48 3b f0	 cmp	 rsi, rax
  001e2	0f 8c 01 01 00
	00		 jl	 $LN19@compiler_c@2

; 3008 :         /* comprehension specific code */
; 3009 :         switch (type) {

  001e8	85 ff		 test	 edi, edi
  001ea	0f 84 aa 00 00
	00		 je	 $LN16@compiler_c@2
  001f0	ff cf		 dec	 edi
  001f2	0f 84 83 00 00
	00		 je	 $LN12@compiler_c@2
  001f8	ff cf		 dec	 edi
  001fa	74 60		 je	 SHORT $LN9@compiler_c@2
  001fc	ff cf		 dec	 edi

; 3029 :             break;
; 3030 :         default:
; 3031 :             return 0;

  001fe	0f 85 94 fe ff
	ff		 jne	 $LN36@compiler_c@2

; 3022 :             break;
; 3023 :         case COMP_DICTCOMP:
; 3024 :             /* With 'd[k] = v', v is evaluated before k, so we do
; 3025 :                the same. */
; 3026 :             VISIT(c, expr, val);

  00204	48 8b d5	 mov	 rdx, rbp
  00207	48 8b cb	 mov	 rcx, rbx
  0020a	e8 00 00 00 00	 call	 compiler_visit_expr
  0020f	85 c0		 test	 eax, eax
  00211	0f 84 81 fe ff
	ff		 je	 $LN36@compiler_c@2

; 3027 :             VISIT(c, expr, elt);

  00217	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  0021f	48 8b cb	 mov	 rcx, rbx
  00222	e8 00 00 00 00	 call	 compiler_visit_expr
  00227	85 c0		 test	 eax, eax
  00229	0f 84 69 fe ff
	ff		 je	 $LN36@compiler_c@2

; 3028 :             ADDOP_I(c, MAP_ADD, gen_index + 1);

  0022f	ba 93 00 00 00	 mov	 edx, 147		; 00000093H
$LN53@compiler_c@2:
  00234	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR gen_index$[rsp]
  0023c	48 8b cb	 mov	 rcx, rbx
  0023f	41 ff c0	 inc	 r8d
  00242	e8 00 00 00 00	 call	 compiler_addop_i
  00247	85 c0		 test	 eax, eax
  00249	0f 85 8d 00 00
	00		 jne	 $LN13@compiler_c@2

; 3039 : 
; 3040 :     return 1;
; 3041 : }

  0024f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00254	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00258	5f		 pop	 rdi
  00259	5e		 pop	 rsi
  0025a	5d		 pop	 rbp
  0025b	c3		 ret	 0
$LN9@compiler_c@2:

; 3018 :             break;
; 3019 :         case COMP_SETCOMP:
; 3020 :             VISIT(c, expr, elt);

  0025c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  00264	48 8b cb	 mov	 rcx, rbx
  00267	e8 00 00 00 00	 call	 compiler_visit_expr
  0026c	85 c0		 test	 eax, eax
  0026e	0f 84 24 fe ff
	ff		 je	 $LN36@compiler_c@2

; 3021 :             ADDOP_I(c, SET_ADD, gen_index + 1);

  00274	ba 92 00 00 00	 mov	 edx, 146		; 00000092H
  00279	eb b9		 jmp	 SHORT $LN53@compiler_c@2
$LN12@compiler_c@2:

; 3014 :             break;
; 3015 :         case COMP_LISTCOMP:
; 3016 :             VISIT(c, expr, elt);

  0027b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  00283	48 8b cb	 mov	 rcx, rbx
  00286	e8 00 00 00 00	 call	 compiler_visit_expr
  0028b	85 c0		 test	 eax, eax
  0028d	0f 84 05 fe ff
	ff		 je	 $LN36@compiler_c@2

; 3017 :             ADDOP_I(c, LIST_APPEND, gen_index + 1);

  00293	ba 91 00 00 00	 mov	 edx, 145		; 00000091H
  00298	eb 9a		 jmp	 SHORT $LN53@compiler_c@2
$LN16@compiler_c@2:

; 3010 :         case COMP_GENEXP:
; 3011 :             VISIT(c, expr, elt);

  0029a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR elt$[rsp]
  002a2	48 8b cb	 mov	 rcx, rbx
  002a5	e8 00 00 00 00	 call	 compiler_visit_expr
  002aa	85 c0		 test	 eax, eax
  002ac	0f 84 e6 fd ff
	ff		 je	 $LN36@compiler_c@2

; 3012 :             ADDOP(c, YIELD_VALUE);

  002b2	ba 56 00 00 00	 mov	 edx, 86			; 00000056H
  002b7	48 8b cb	 mov	 rcx, rbx
  002ba	e8 00 00 00 00	 call	 compiler_addop
  002bf	85 c0		 test	 eax, eax
  002c1	0f 84 d1 fd ff
	ff		 je	 $LN36@compiler_c@2

; 3013 :             ADDOP(c, POP_TOP);

  002c7	ba 01 00 00 00	 mov	 edx, 1
  002cc	48 8b cb	 mov	 rcx, rbx
  002cf	e8 00 00 00 00	 call	 compiler_addop
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 bc fd ff
	ff		 je	 $LN36@compiler_c@2
$LN13@compiler_c@2:

; 3032 :         }
; 3033 : 
; 3034 :         compiler_use_next_block(c, skip);

  002dc	48 8b 54 24 38	 mov	 rdx, QWORD PTR skip$1$[rsp]
  002e1	48 8b cb	 mov	 rcx, rbx
  002e4	e8 00 00 00 00	 call	 compiler_use_next_block
$LN19@compiler_c@2:

; 3035 :     }
; 3036 :     compiler_use_next_block(c, if_cleanup);

  002e9	48 8b 54 24 40	 mov	 rdx, QWORD PTR if_cleanup$1$[rsp]
  002ee	48 8b cb	 mov	 rcx, rbx
  002f1	e8 00 00 00 00	 call	 compiler_use_next_block

; 3037 :     ADDOP_JABS(c, JUMP_ABSOLUTE, start);

  002f6	4c 8b 44 24 30	 mov	 r8, QWORD PTR start$1$[rsp]
  002fb	41 b9 01 00 00
	00		 mov	 r9d, 1
  00301	41 8d 51 70	 lea	 edx, QWORD PTR [r9+112]
  00305	e8 00 00 00 00	 call	 compiler_addop_j
  0030a	85 c0		 test	 eax, eax
  0030c	0f 84 86 fd ff
	ff		 je	 $LN36@compiler_c@2

; 3038 :     compiler_use_next_block(c, anchor);

  00312	48 8b 54 24 48	 mov	 rdx, QWORD PTR anchor$1$[rsp]
  00317	48 8b cb	 mov	 rcx, rbx
  0031a	e8 00 00 00 00	 call	 compiler_use_next_block

; 3039 : 
; 3040 :     return 1;
; 3041 : }

  0031f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0032d	5f		 pop	 rdi
  0032e	5e		 pop	 rsi
  0032f	5d		 pop	 rbp
  00330	c3		 ret	 0
compiler_comprehension_generator ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PMJCCPKK@__debug__?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
PUBLIC	??_C@_05MKDOIIA@False?$AA@			; `string'
PUBLIC	??_C@_04HPMIDMKH@True?$AA@			; `string'
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$expr_constant DD imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$expr_constant DD imagerel expr_constant+37
	DD	imagerel expr_constant+105
	DD	imagerel $chain$1$expr_constant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$expr_constant DD imagerel expr_constant+105
	DD	imagerel expr_constant+161
	DD	imagerel $chain$3$expr_constant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$expr_constant DD imagerel expr_constant+161
	DD	imagerel expr_constant+204
	DD	imagerel $chain$5$expr_constant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$expr_constant DD imagerel expr_constant+204
	DD	imagerel expr_constant+223
	DD	imagerel $chain$7$expr_constant
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$expr_constant DD imagerel expr_constant+223
	DD	imagerel expr_constant+248
	DD	imagerel $chain$8$expr_constant
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$expr_constant DD 021H
	DD	imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$expr_constant DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$expr_constant DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$expr_constant DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$expr_constant DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel expr_constant
	DD	imagerel expr_constant+37
	DD	imagerel $unwind$expr_constant
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$expr_constant DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09PMJCCPKK@__debug__?$AA@
CONST	SEGMENT
??_C@_09PMJCCPKK@__debug__?$AA@ DB '__debug__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MKDOIIA@False?$AA@
CONST	SEGMENT
??_C@_05MKDOIIA@False?$AA@ DB 'False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True?$AA@
CONST	SEGMENT
??_C@_04HPMIDMKH@True?$AA@ DB 'True', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT expr_constant
_TEXT	SEGMENT
c$ = 48
e$ = 56
expr_constant PROC					; COMDAT

; 3188 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3189 :     char *id;
; 3190 :     switch (e->kind) {

  00006	8b 02		 mov	 eax, DWORD PTR [rdx]
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	83 e8 10	 sub	 eax, 16
  0000e	0f 84 d6 00 00
	00		 je	 $LN7@expr_const
  00014	ff c8		 dec	 eax
  00016	0f 84 ce 00 00
	00		 je	 $LN7@expr_const
  0001c	83 e8 02	 sub	 eax, 2
  0001f	0f 84 ba 00 00
	00		 je	 $LN9@expr_const
  00025	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0002f	83 f8 04	 cmp	 eax, 4
  00032	0f 85 94 00 00
	00		 jne	 $LN2@expr_const

; 3197 :     case Name_kind:
; 3198 :         /* optimize away names that can't be reassigned */
; 3199 :         id = PyUnicode_AsUTF8(e->v.Name.id);

  00038	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0003c	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 3200 :         if (strcmp(id, "True") == 0) return 1;

  00041	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04HPMIDMKH@True?$AA@
  00048	b9 05 00 00 00	 mov	 ecx, 5
  0004d	48 8b f0	 mov	 rsi, rax
  00050	f3 a6		 repe cmpsb
  00052	75 15		 jne	 SHORT $LN5@expr_const
  00054	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00059	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  0005e	b8 01 00 00 00	 mov	 eax, 1

; 3208 :     }
; 3209 : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN5@expr_const:

; 3201 :         if (strcmp(id, "False") == 0) return 0;

  00069	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05MKDOIIA@False?$AA@
  00070	48 8b f0	 mov	 rsi, rax
  00073	b9 06 00 00 00	 mov	 ecx, 6
  00078	f3 a6		 repe cmpsb
  0007a	74 13		 je	 SHORT $LN16@expr_const

; 3202 :         if (strcmp(id, "None") == 0) return 0;

  0007c	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04OHJIHAFH@None?$AA@
  00083	48 8b f0	 mov	 rsi, rax
  00086	b9 05 00 00 00	 mov	 ecx, 5
  0008b	f3 a6		 repe cmpsb
  0008d	75 12		 jne	 SHORT $LN3@expr_const
$LN16@expr_const:
  0008f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00094	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00099	33 c0		 xor	 eax, eax

; 3208 :     }
; 3209 : }

  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
$LN3@expr_const:

; 3203 :         if (strcmp(id, "__debug__") == 0)

  000a1	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_09PMJCCPKK@__debug__?$AA@
  000a8	48 8b f0	 mov	 rsi, rax
  000ab	b9 0a 00 00 00	 mov	 ecx, 10
  000b0	f3 a6		 repe cmpsb
  000b2	75 18		 jne	 SHORT $LN2@expr_const

; 3204 :             return ! c->c_optimize;

  000b4	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000b9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000be	33 c0		 xor	 eax, eax
  000c0	39 43 28	 cmp	 DWORD PTR [rbx+40], eax
  000c3	0f 94 c0	 sete	 al

; 3208 :     }
; 3209 : }

  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5b		 pop	 rbx
  000cb	c3		 ret	 0
$LN2@expr_const:
  000cc	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000d1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 3205 :         /* fall through */
; 3206 :     default:
; 3207 :         return -1;

  000d6	83 c8 ff	 or	 eax, -1

; 3208 :     }
; 3209 : }

  000d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dd	5b		 pop	 rbx
  000de	c3		 ret	 0
$LN9@expr_const:

; 3191 :     case Ellipsis_kind:
; 3192 :         return 1;

  000df	b8 01 00 00 00	 mov	 eax, 1

; 3208 :     }
; 3209 : }

  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5b		 pop	 rbx
  000e9	c3		 ret	 0
$LN7@expr_const:

; 3193 :     case Num_kind:
; 3194 :         return PyObject_IsTrue(e->v.Num.n);
; 3195 :     case Str_kind:
; 3196 :         return PyObject_IsTrue(e->v.Str.s);

  000ea	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]

; 3208 :     }
; 3209 : }

  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	5b		 pop	 rbx
  000f3	e9 00 00 00 00	 jmp	 PyObject_IsTrue
expr_constant ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_push_fblock DD imagerel compiler_push_fblock
	DD	imagerel compiler_push_fblock+81
	DD	imagerel $unwind$compiler_push_fblock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_push_fblock DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@
CONST	SEGMENT
??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@ DB 'too many stat'
	DB	'ically nested blocks', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_push_fblock
_TEXT	SEGMENT
c$ = 48
t$ = 56
b$ = 64
compiler_push_fblock PROC				; COMDAT

; 3507 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3508 :     struct fblockinfo *f;
; 3509 :     if (c->u->u_nfblocks >= CO_MAXBLOCKS) {

  00004	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00008	44 8b ca	 mov	 r9d, edx
  0000b	83 78 68 14	 cmp	 DWORD PTR [rax+104], 20
  0000f	7c 1a		 jl	 SHORT $LN1@compiler_p

; 3510 :         PyErr_SetString(PyExc_SystemError,
; 3511 :                         "too many statically nested blocks");

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LMOHMEG@too?5many?5statically?5nested?5block@
  0001f	e8 00 00 00 00	 call	 PyErr_SetString

; 3512 :         return 0;

  00024	33 c0		 xor	 eax, eax

; 3518 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
$LN1@compiler_p:

; 3513 :     }
; 3514 :     f = &c->u->u_fblock[c->u->u_nfblocks++];

  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 63 40 68	 movsxd	 rax, DWORD PTR [rax+104]
  00032	48 8d 48 07	 lea	 rcx, QWORD PTR [rax+7]
  00036	48 03 c9	 add	 rcx, rcx
  00039	ff c0		 inc	 eax
  0003b	89 42 68	 mov	 DWORD PTR [rdx+104], eax

; 3515 :     f->fb_type = t;

  0003e	44 89 0c ca	 mov	 DWORD PTR [rdx+rcx*8], r9d

; 3516 :     f->fb_block = b;

  00042	4c 89 44 ca 08	 mov	 QWORD PTR [rdx+rcx*8+8], r8

; 3517 :     return 1;

  00047	b8 01 00 00 00	 mov	 eax, 1

; 3518 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
compiler_push_fblock ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_pop_fblock
_TEXT	SEGMENT
c$ = 8
compiler_pop_fblock PROC				; COMDAT

; 3523 :     struct compiler_unit *u = c->u;

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]

; 3524 :     assert(u->u_nfblocks > 0);
; 3525 :     u->u_nfblocks--;

  00004	ff 48 68	 dec	 DWORD PTR [rax+104]

; 3526 :     assert(u->u_fblock[u->u_nfblocks].fb_type == t);
; 3527 :     assert(u->u_fblock[u->u_nfblocks].fb_block == b);
; 3528 : }

  00007	c3		 ret	 0
compiler_pop_fblock ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_in_loop
_TEXT	SEGMENT
c$ = 8
compiler_in_loop PROC					; COMDAT

; 3532 :     int i;
; 3533 :     struct compiler_unit *u = c->u;

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]

; 3534 :     for (i = 0; i < u->u_nfblocks; ++i) {

  00004	33 c9		 xor	 ecx, ecx
  00006	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  00009	85 d2		 test	 edx, edx
  0000b	7e 13		 jle	 SHORT $LN2@compiler_i@3

; 3532 :     int i;
; 3533 :     struct compiler_unit *u = c->u;

  0000d	48 83 c0 70	 add	 rax, 112		; 00000070H
$LL4@compiler_i@3:

; 3535 :         if (u->u_fblock[i].fb_type == LOOP)

  00011	83 38 00	 cmp	 DWORD PTR [rax], 0
  00014	74 0d		 je	 SHORT $LN8@compiler_i@3

; 3534 :     for (i = 0; i < u->u_nfblocks; ++i) {

  00016	ff c1		 inc	 ecx
  00018	48 83 c0 10	 add	 rax, 16
  0001c	3b ca		 cmp	 ecx, edx
  0001e	7c f1		 jl	 SHORT $LL4@compiler_i@3
$LN2@compiler_i@3:

; 3537 :     }
; 3538 :     return 0;

  00020	33 c0		 xor	 eax, eax

; 3539 : }

  00022	c3		 ret	 0
$LN8@compiler_i@3:

; 3536 :             return 1;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 3539 : }

  00028	c3		 ret	 0
compiler_in_loop ENDP
_TEXT	ENDS
PUBLIC	??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@		; `string'
PUBLIC	??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	Py_BuildValue:PROC
EXTRN	PyErr_ProgramText:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_error DD imagerel compiler_error
	DD	imagerel compiler_error+457
	DD	imagerel $unwind$compiler_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_error DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@
CONST	SEGMENT
??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@ DB '(zO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@
CONST	SEGMENT
??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@ DB '(OiiO)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT compiler_error
_TEXT	SEGMENT
c$ = 64
errstr$ = 72
compiler_error PROC					; COMDAT

; 3546 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3547 :     PyObject *loc;
; 3548 :     PyObject *u = NULL, *v = NULL;
; 3549 : 
; 3550 :     loc = PyErr_ProgramText(c->c_filename, c->u->u_lineno);

  00014	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00018	48 8b ea	 mov	 rbp, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00021	8b 90 b4 01 00
	00		 mov	 edx, DWORD PTR [rax+436]
  00027	33 db		 xor	 ebx, ebx
  00029	e8 00 00 00 00	 call	 PyErr_ProgramText
  0002e	48 8b f0	 mov	 rsi, rax

; 3551 :     if (!loc) {

  00031	48 85 c0	 test	 rax, rax
  00034	75 48		 jne	 SHORT $LN15@compiler_e@2

; 3552 :         Py_INCREF(Py_None);

  00036	e8 00 00 00 00	 call	 _Py_PXCTX
  0003b	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00042	85 c0		 test	 eax, eax
  00044	75 38		 jne	 SHORT $LN15@compiler_e@2
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00054	4c 8b ce	 mov	 r9, rsi
  00057	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00065	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006a	85 c0		 test	 eax, eax
  0006c	75 09		 jne	 SHORT $LN14@compiler_e@2
  0006e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00075	74 07		 je	 SHORT $LN15@compiler_e@2
$LN14@compiler_e@2:
  00077	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN15@compiler_e@2:

; 3553 :         loc = Py_None;
; 3554 :     }
; 3555 :     u = Py_BuildValue("(OiiO)", c->c_filename_obj, c->u->u_lineno,
; 3556 :                       c->u->u_col_offset, loc);

  0007e	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00082	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06INEDBHGA@?$CIOiiO?$CJ?$AA@
  0008d	44 8b 88 b8 01
	00 00		 mov	 r9d, DWORD PTR [rax+440]
  00094	44 8b 80 b4 01
	00 00		 mov	 r8d, DWORD PTR [rax+436]
  0009b	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000a0	e8 00 00 00 00	 call	 Py_BuildValue
  000a5	48 8b f8	 mov	 rdi, rax

; 3557 :     if (!u)

  000a8	48 85 c0	 test	 rax, rax
  000ab	74 29		 je	 SHORT $exit$24545

; 3558 :         goto exit;
; 3559 :     v = Py_BuildValue("(zO)", errstr, u);

  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04PDGOHJMJ@?$CIzO?$CJ?$AA@
  000b4	4c 8b c0	 mov	 r8, rax
  000b7	48 8b d5	 mov	 rdx, rbp
  000ba	e8 00 00 00 00	 call	 Py_BuildValue
  000bf	48 8b d8	 mov	 rbx, rax

; 3560 :     if (!v)

  000c2	48 85 c0	 test	 rax, rax
  000c5	74 0f		 je	 SHORT $exit$24545

; 3561 :         goto exit;
; 3562 :     PyErr_SetObject(PyExc_SyntaxError, v);

  000c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  000ce	48 8b d0	 mov	 rdx, rax
  000d1	e8 00 00 00 00	 call	 PyErr_SetObject
$exit$24545:

; 3563 :  exit:
; 3564 :     Py_DECREF(loc);

  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 3565 :     Py_XDECREF(u);

  000de	48 85 ff	 test	 rdi, rdi
  000e1	74 65		 je	 SHORT $LN7@compiler_e@2
  000e3	e8 00 00 00 00	 call	 _Py_PXCTX
  000e8	85 c0		 test	 eax, eax
  000ea	75 5c		 jne	 SHORT $LN7@compiler_e@2
  000ec	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000f0	a8 20		 test	 al, 32			; 00000020H
  000f2	75 4c		 jne	 SHORT $LN22@compiler_e@2
  000f4	84 c0		 test	 al, al
  000f6	78 48		 js	 SHORT $LN22@compiler_e@2
  000f8	a8 02		 test	 al, 2
  000fa	75 4c		 jne	 SHORT $LN7@compiler_e@2
  000fc	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00100	75 46		 jne	 SHORT $LN7@compiler_e@2
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00110	4c 8b cf	 mov	 r9, rdi
  00113	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00119	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00121	e8 00 00 00 00	 call	 _PyParallel_Guard
  00126	48 8b cf	 mov	 rcx, rdi
  00129	85 c0		 test	 eax, eax
  0012b	74 07		 je	 SHORT $LN27@compiler_e@2
  0012d	e8 00 00 00 00	 call	 _Px_Dealloc
  00132	eb 14		 jmp	 SHORT $LN7@compiler_e@2
$LN27@compiler_e@2:
  00134	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00138	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0013e	eb 08		 jmp	 SHORT $LN7@compiler_e@2
$LN22@compiler_e@2:
  00140	48 8b cf	 mov	 rcx, rdi
  00143	e8 00 00 00 00	 call	 Px_DecRef
$LN7@compiler_e@2:

; 3566 :     Py_XDECREF(v);

  00148	48 85 db	 test	 rbx, rbx
  0014b	74 65		 je	 SHORT $LN42@compiler_e@2
  0014d	e8 00 00 00 00	 call	 _Py_PXCTX
  00152	85 c0		 test	 eax, eax
  00154	75 5c		 jne	 SHORT $LN42@compiler_e@2
  00156	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0015a	a8 20		 test	 al, 32			; 00000020H
  0015c	75 4c		 jne	 SHORT $LN33@compiler_e@2
  0015e	84 c0		 test	 al, al
  00160	78 48		 js	 SHORT $LN33@compiler_e@2
  00162	a8 02		 test	 al, 2
  00164	75 4c		 jne	 SHORT $LN42@compiler_e@2
  00166	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0016a	75 46		 jne	 SHORT $LN42@compiler_e@2
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0017a	4c 8b cb	 mov	 r9, rbx
  0017d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00183	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00190	48 8b cb	 mov	 rcx, rbx
  00193	85 c0		 test	 eax, eax
  00195	74 07		 je	 SHORT $LN38@compiler_e@2
  00197	e8 00 00 00 00	 call	 _Px_Dealloc
  0019c	eb 14		 jmp	 SHORT $LN42@compiler_e@2
$LN38@compiler_e@2:
  0019e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001a2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a8	eb 08		 jmp	 SHORT $LN42@compiler_e@2
$LN33@compiler_e@2:
  001aa	48 8b cb	 mov	 rcx, rbx
  001ad	e8 00 00 00 00	 call	 Px_DecRef
$LN42@compiler_e@2:

; 3567 :     return 0;
; 3568 : }

  001b2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001bc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001c1	33 c0		 xor	 eax, eax
  001c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c7	5f		 pop	 rdi
  001c8	c3		 ret	 0
compiler_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_handle_subscr DD imagerel compiler_handle_subscr
	DD	imagerel compiler_handle_subscr+236
	DD	imagerel $unwind$compiler_handle_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_handle_subscr DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@
CONST	SEGMENT
??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@ DB 'inva'
	DB	'lid %s kind %d in subscript', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_handle_subscr
_TEXT	SEGMENT
c$ = 48
kind$ = 56
ctx$ = 64
compiler_handle_subscr PROC				; COMDAT

; 3573 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3574 :     int op = 0;

  0000f	33 f6		 xor	 esi, esi

; 3575 : 
; 3576 :     /* XXX this code is duplicated */
; 3577 :     switch (ctx) {

  00011	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00015	48 8b f9	 mov	 rdi, rcx
  00018	8b de		 mov	 ebx, esi
  0001a	83 f8 05	 cmp	 eax, 5
  0001d	77 1c		 ja	 SHORT $LN11@compiler_h
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00026	48 98		 cdqe
  00028	44 8b 8c 81 00
	00 00 00	 mov	 r9d, DWORD PTR $LN15@compiler_h[rcx+rax*4]
  00030	4c 03 c9	 add	 r9, rcx
  00033	41 ff e1	 jmp	 r9
$LN10@compiler_h:

; 3578 :         case AugLoad: /* fall through to Load */
; 3579 :         case Load:    op = BINARY_SUBSCR; break;

  00036	bb 19 00 00 00	 mov	 ebx, 25
$LN11@compiler_h:

; 3588 :     }
; 3589 :     if (ctx == AugLoad) {

  0003b	41 83 f8 04	 cmp	 r8d, 4
  0003f	75 59		 jne	 SHORT $LN6@compiler_h

; 3590 :         ADDOP(c, DUP_TOP_TWO);

  00041	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00045	48 8b cf	 mov	 rcx, rdi
  00048	e8 00 00 00 00	 call	 compiler_addop
  0004d	85 c0		 test	 eax, eax
  0004f	75 5f		 jne	 SHORT $LN2@compiler_h

; 3596 :     return 1;
; 3597 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
$LN9@compiler_h:

; 3580 :         case AugStore:/* fall through to Store */
; 3581 :         case Store:   op = STORE_SUBSCR; break;

  00061	bb 3c 00 00 00	 mov	 ebx, 60			; 0000003cH
  00066	eb d3		 jmp	 SHORT $LN11@compiler_h
$LN8@compiler_h:

; 3582 :         case Del:     op = DELETE_SUBSCR; break;

  00068	bb 3d 00 00 00	 mov	 ebx, 61			; 0000003dH
  0006d	eb cc		 jmp	 SHORT $LN11@compiler_h
$LN7@compiler_h:

; 3583 :         case Param:
; 3584 :             PyErr_Format(PyExc_SystemError,
; 3585 :                          "invalid %s kind %d in subscript\n",
; 3586 :                          kind, ctx);

  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00076	45 8b c8	 mov	 r9d, r8d
  00079	4c 8b c2	 mov	 r8, rdx
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@GFGBAOAN@invalid?5?$CFs?5kind?5?$CFd?5in?5subscript?6@
  00083	e8 00 00 00 00	 call	 PyErr_Format
$LN16@compiler_h:

; 3587 :             return 0;

  00088	33 c0		 xor	 eax, eax

; 3596 :     return 1;
; 3597 : }

  0008a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00094	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
$LN6@compiler_h:

; 3591 :     }
; 3592 :     else if (ctx == AugStore) {

  0009a	41 83 f8 05	 cmp	 r8d, 5
  0009e	75 10		 jne	 SHORT $LN2@compiler_h

; 3593 :         ADDOP(c, ROT_THREE);

  000a0	41 8d 50 fe	 lea	 edx, QWORD PTR [r8-2]
  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	e8 00 00 00 00	 call	 compiler_addop
  000ac	85 c0		 test	 eax, eax
  000ae	74 d8		 je	 SHORT $LN16@compiler_h
$LN2@compiler_h:

; 3594 :     }
; 3595 :     ADDOP(c, op);

  000b0	8b d3		 mov	 edx, ebx
  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	e8 00 00 00 00	 call	 compiler_addop

; 3596 :     return 1;
; 3597 : }

  000ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bf	85 c0		 test	 eax, eax
  000c1	40 0f 95 c6	 setne	 sil
  000c5	8b c6		 mov	 eax, esi
  000c7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
  000d2	66 90		 npad	 2
$LN15@compiler_h:
  000d4	00 00 00 00	 DD	 $LN10@compiler_h
  000d8	00 00 00 00	 DD	 $LN9@compiler_h
  000dc	00 00 00 00	 DD	 $LN8@compiler_h
  000e0	00 00 00 00	 DD	 $LN10@compiler_h
  000e4	00 00 00 00	 DD	 $LN9@compiler_h
  000e8	00 00 00 00	 DD	 $LN7@compiler_h
compiler_handle_subscr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dfs DD	imagerel dfs
	DD	imagerel dfs+31
	DD	imagerel $unwind$dfs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$dfs DD	imagerel dfs+31
	DD	imagerel dfs+65
	DD	imagerel $chain$0$dfs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$dfs DD	imagerel dfs+65
	DD	imagerel dfs+129
	DD	imagerel $chain$1$dfs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$dfs DD	imagerel dfs+129
	DD	imagerel dfs+149
	DD	imagerel $chain$2$dfs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$dfs DD	imagerel dfs+149
	DD	imagerel dfs+160
	DD	imagerel $chain$3$dfs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$dfs DD	021H
	DD	imagerel dfs
	DD	imagerel dfs+31
	DD	imagerel $unwind$dfs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$dfs DD	021H
	DD	imagerel dfs+31
	DD	imagerel dfs+65
	DD	imagerel $chain$0$dfs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$dfs DD	020521H
	DD	087405H
	DD	imagerel dfs+31
	DD	imagerel dfs+65
	DD	imagerel $chain$0$dfs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$dfs DD	020521H
	DD	073405H
	DD	imagerel dfs
	DD	imagerel dfs+31
	DD	imagerel $unwind$dfs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dfs DD	040f01H
	DD	09540fH
	DD	0600b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT dfs
_TEXT	SEGMENT
c$ = 48
b$ = 56
a$ = 64
dfs	PROC						; COMDAT

; 3707 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3708 :     int i;
; 3709 :     struct instr *instr = NULL;
; 3710 : 
; 3711 :     if (b->b_seen)

  0000f	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  00012	49 8b e8	 mov	 rbp, r8
  00015	48 8b f2	 mov	 rsi, rdx
  00018	a8 01		 test	 al, 1
  0001a	75 79		 jne	 SHORT $LN8@dfs

; 3712 :         return;
; 3713 :     b->b_seen = 1;

  0001c	83 c8 01	 or	 eax, 1
  0001f	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00024	89 42 20	 mov	 DWORD PTR [rdx+32], eax

; 3714 :     if (b->b_next != NULL)

  00027	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0002b	48 85 d2	 test	 rdx, rdx
  0002e	74 0a		 je	 SHORT $LN6@dfs

; 3715 :         dfs(c, b->b_next, a);

  00030	e8 00 00 00 00	 call	 dfs
  00035	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
$LN6@dfs:

; 3716 :     for (i = 0; i < b->b_iused; i++) {

  0003a	33 db		 xor	 ebx, ebx
  0003c	39 5e 08	 cmp	 DWORD PTR [rsi+8], ebx
  0003f	7e 40		 jle	 SHORT $LN3@dfs
  00041	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00046	8b fb		 mov	 edi, ebx
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL5@dfs:

; 3717 :         instr = &b->b_instr[i];

  00050	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]

; 3718 :         if (instr->i_jrel || instr->i_jabs)

  00054	8b 04 17	 mov	 eax, DWORD PTR [rdi+rdx]
  00057	a8 02		 test	 al, 2
  00059	75 04		 jne	 SHORT $LN1@dfs
  0005b	a8 01		 test	 al, 1
  0005d	74 0d		 je	 SHORT $LN4@dfs
$LN1@dfs:

; 3719 :             dfs(c, instr->i_target, a);

  0005f	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  00064	4c 8b c5	 mov	 r8, rbp
  00067	e8 00 00 00 00	 call	 dfs
$LN4@dfs:

; 3716 :     for (i = 0; i < b->b_iused; i++) {

  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00071	ff c3		 inc	 ebx
  00073	48 83 c7 20	 add	 rdi, 32			; 00000020H
  00077	3b 5e 08	 cmp	 ebx, DWORD PTR [rsi+8]
  0007a	7c d4		 jl	 SHORT $LL5@dfs
  0007c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN3@dfs:

; 3720 :     }
; 3721 :     a->a_postorder[a->a_nblocks++] = b;

  00081	48 63 4d 0c	 movsxd	 rcx, DWORD PTR [rbp+12]
  00085	48 8b 45 10	 mov	 rax, QWORD PTR [rbp+16]
  00089	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008e	48 89 34 c8	 mov	 QWORD PTR [rax+rcx*8], rsi
  00092	ff 45 0c	 inc	 DWORD PTR [rbp+12]
$LN8@dfs:

; 3722 : }

  00095	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5e		 pop	 rsi
  0009f	c3		 ret	 0
dfs	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stackdepth_walk DD imagerel stackdepth_walk
	DD	imagerel stackdepth_walk+45
	DD	imagerel $unwind$stackdepth_walk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$stackdepth_walk DD imagerel stackdepth_walk+45
	DD	imagerel stackdepth_walk+262
	DD	imagerel $chain$0$stackdepth_walk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$stackdepth_walk DD imagerel stackdepth_walk+262
	DD	imagerel stackdepth_walk+272
	DD	imagerel $chain$1$stackdepth_walk
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$stackdepth_walk DD 021H
	DD	imagerel stackdepth_walk
	DD	imagerel stackdepth_walk+45
	DD	imagerel $unwind$stackdepth_walk
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$stackdepth_walk DD 020521H
	DD	0c7405H
	DD	imagerel stackdepth_walk
	DD	imagerel stackdepth_walk+45
	DD	imagerel $unwind$stackdepth_walk
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stackdepth_walk DD 040c01H
	DD	06008520cH
	DD	030065007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT stackdepth_walk
_TEXT	SEGMENT
tv261 = 32
c$ = 80
tv285 = 88
b$ = 88
depth$ = 96
maxdepth$ = 104
stackdepth_walk PROC					; COMDAT

; 3726 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3727 :     int i, target_depth;
; 3728 :     struct instr *instr;
; 3729 :     if (b->b_seen || b->b_startdepth >= depth)

  0000c	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  0000f	41 8b d9	 mov	 ebx, r9d
  00012	41 8b f0	 mov	 esi, r8d
  00015	48 8b ea	 mov	 rbp, rdx
  00018	a8 01		 test	 al, 1
  0001a	0f 85 e6 00 00
	00		 jne	 $LN15@stackdepth
  00020	44 39 42 24	 cmp	 DWORD PTR [rdx+36], r8d
  00024	0f 8d dc 00 00
	00		 jge	 $LN15@stackdepth

; 3731 :     b->b_seen = 1;

  0002a	83 c8 01	 or	 eax, 1
  0002d	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 3732 :     b->b_startdepth = depth;
; 3733 :     for (i = 0; i < b->b_iused; i++) {

  00032	33 ff		 xor	 edi, edi
  00034	89 42 20	 mov	 DWORD PTR [rdx+32], eax
  00037	44 89 42 24	 mov	 DWORD PTR [rdx+36], r8d
  0003b	48 89 7c 24 20	 mov	 QWORD PTR tv261[rsp], rdi
  00040	39 7a 08	 cmp	 DWORD PTR [rdx+8], edi
  00043	0f 8e 9e 00 00
	00		 jle	 $LN12@stackdepth
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@stackdepth:

; 3734 :         instr = &b->b_instr[i];

  00050	48 8b 45 10	 mov	 rax, QWORD PTR [rbp+16]
  00054	48 89 44 24 58	 mov	 QWORD PTR tv285[rsp], rax

; 3735 :         depth += opcode_stack_effect(instr->i_opcode, instr->i_oparg);

  00059	0f b6 4c 07 04	 movzx	 ecx, BYTE PTR [rdi+rax+4]
  0005e	8b 54 07 08	 mov	 edx, DWORD PTR [rdi+rax+8]
  00062	e8 00 00 00 00	 call	 opcode_stack_effect

; 3736 :         if (depth > maxdepth)
; 3737 :             maxdepth = depth;
; 3738 :         assert(depth >= 0); /* invalid code or bug in stackdepth() */
; 3739 :         if (instr->i_jrel || instr->i_jabs) {

  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv285[rsp]
  0006c	03 f0		 add	 esi, eax
  0006e	8b 04 0f	 mov	 eax, DWORD PTR [rdi+rcx]
  00071	3b f3		 cmp	 esi, ebx
  00073	0f 4f de	 cmovg	 ebx, esi
  00076	a8 02		 test	 al, 2
  00078	75 04		 jne	 SHORT $LN9@stackdepth
  0007a	a8 01		 test	 al, 1
  0007c	74 4b		 je	 SHORT $LN13@stackdepth
$LN9@stackdepth:

; 3740 :             target_depth = depth;
; 3741 :             if (instr->i_opcode == FOR_ITER) {

  0007e	0f b6 44 0f 04	 movzx	 eax, BYTE PTR [rdi+rcx+4]
  00083	44 8b c6	 mov	 r8d, esi
  00086	3c 5d		 cmp	 al, 93			; 0000005dH
  00088	75 06		 jne	 SHORT $LN8@stackdepth

; 3742 :                 target_depth = depth-2;

  0008a	44 8d 46 fe	 lea	 r8d, DWORD PTR [rsi-2]

; 3743 :             } else if (instr->i_opcode == SETUP_FINALLY ||

  0008e	eb 13		 jmp	 SHORT $LN4@stackdepth
$LN8@stackdepth:

; 3744 :                        instr->i_opcode == SETUP_EXCEPT) {

  00090	3c 7a		 cmp	 al, 122			; 0000007aH
  00092	74 04		 je	 SHORT $LN5@stackdepth
  00094	3c 79		 cmp	 al, 121			; 00000079H
  00096	75 0b		 jne	 SHORT $LN4@stackdepth
$LN5@stackdepth:

; 3745 :                 target_depth = depth+3;

  00098	44 8d 46 03	 lea	 r8d, DWORD PTR [rsi+3]

; 3746 :                 if (target_depth > maxdepth)

  0009c	44 3b c3	 cmp	 r8d, ebx
  0009f	41 0f 4f d8	 cmovg	 ebx, r8d
$LN4@stackdepth:

; 3747 :                     maxdepth = target_depth;
; 3748 :             }
; 3749 :             maxdepth = stackdepth_walk(c, instr->i_target,
; 3750 :                                        target_depth, maxdepth);

  000a3	48 8b 54 0f 10	 mov	 rdx, QWORD PTR [rdi+rcx+16]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000ad	44 8b cb	 mov	 r9d, ebx
  000b0	e8 00 00 00 00	 call	 stackdepth_walk
  000b5	8b d8		 mov	 ebx, eax

; 3751 :             if (instr->i_opcode == JUMP_ABSOLUTE ||
; 3752 :                 instr->i_opcode == JUMP_FORWARD) {

  000b7	48 8b 44 24 58	 mov	 rax, QWORD PTR tv285[rsp]
  000bc	0f b6 44 07 04	 movzx	 eax, BYTE PTR [rdi+rax+4]
  000c1	3c 71		 cmp	 al, 113			; 00000071H
  000c3	74 38		 je	 SHORT $out$24714
  000c5	3c 6e		 cmp	 al, 110			; 0000006eH
  000c7	74 34		 je	 SHORT $out$24714
$LN13@stackdepth:

; 3732 :     b->b_startdepth = depth;
; 3733 :     for (i = 0; i < b->b_iused; i++) {

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR tv261[rsp]
  000ce	48 83 c7 20	 add	 rdi, 32			; 00000020H
  000d2	ff c0		 inc	 eax
  000d4	48 89 44 24 20	 mov	 QWORD PTR tv261[rsp], rax
  000d9	3b 45 08	 cmp	 eax, DWORD PTR [rbp+8]
  000dc	0f 8c 6e ff ff
	ff		 jl	 $LL14@stackdepth
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
$LN12@stackdepth:

; 3753 :                 goto out; /* remaining code is dead */
; 3754 :             }
; 3755 :         }
; 3756 :     }
; 3757 :     if (b->b_next)

  000e7	48 8b 55 18	 mov	 rdx, QWORD PTR [rbp+24]
  000eb	48 85 d2	 test	 rdx, rdx
  000ee	74 0d		 je	 SHORT $out$24714

; 3758 :         maxdepth = stackdepth_walk(c, b->b_next, depth, maxdepth);

  000f0	44 8b cb	 mov	 r9d, ebx
  000f3	44 8b c6	 mov	 r8d, esi
  000f6	e8 00 00 00 00	 call	 stackdepth_walk
  000fb	8b d8		 mov	 ebx, eax
$out$24714:

; 3759 : out:
; 3760 :     b->b_seen = 0;

  000fd	83 65 20 fe	 and	 DWORD PTR [rbp+32], -2	; fffffffeH
  00101	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN15@stackdepth:

; 3730 :         return maxdepth;

  00106	8b c3		 mov	 eax, ebx

; 3761 :     return maxdepth;
; 3762 : }

  00108	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010c	5e		 pop	 rsi
  0010d	5d		 pop	 rbp
  0010e	5b		 pop	 rbx
  0010f	c3		 ret	 0
stackdepth_walk ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT stackdepth
_TEXT	SEGMENT
c$ = 8
stackdepth PROC						; COMDAT

; 3770 :     basicblock *b, *entryblock;
; 3771 :     entryblock = NULL;
; 3772 :     for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00004	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00008	4d 85 c0	 test	 r8, r8
  0000b	74 28		 je	 SHORT $LN9@stackdepth@2
  0000d	0f 1f 00	 npad	 3
$LL4@stackdepth@2:

; 3773 :         b->b_seen = 0;

  00010	41 83 60 20 fe	 and	 DWORD PTR [r8+32], -2	; fffffffeH

; 3774 :         b->b_startdepth = INT_MIN;

  00015	41 c7 40 24 00
	00 00 80	 mov	 DWORD PTR [r8+36], -2147483648 ; ffffffff80000000H

; 3775 :         entryblock = b;

  0001d	49 8b d0	 mov	 rdx, r8
  00020	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00023	4d 85 c0	 test	 r8, r8
  00026	75 e8		 jne	 SHORT $LL4@stackdepth@2

; 3776 :     }
; 3777 :     if (!entryblock)

  00028	48 85 d2	 test	 rdx, rdx
  0002b	74 08		 je	 SHORT $LN9@stackdepth@2

; 3779 :     return stackdepth_walk(c, entryblock, 0, 0);

  0002d	45 33 c9	 xor	 r9d, r9d

; 3780 : }

  00030	e9 00 00 00 00	 jmp	 stackdepth_walk
$LN9@stackdepth@2:

; 3778 :         return 0;

  00035	33 c0		 xor	 eax, eax

; 3780 : }

  00037	c3		 ret	 0
stackdepth ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_init DD imagerel assemble_init
	DD	imagerel assemble_init+156
	DD	imagerel $unwind$assemble_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_init DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT assemble_init
_TEXT	SEGMENT
a$ = 48
nblocks$ = 56
firstlineno$ = 64
assemble_init PROC					; COMDAT

; 3784 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3785 :     memset(a, 0, sizeof(struct assembler));

  0000a	33 c0		 xor	 eax, eax
  0000c	48 63 fa	 movsxd	 rdi, edx
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00019	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0001d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00021	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00025	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 3786 :     a->a_lineno = firstlineno;

  00029	44 89 41 24	 mov	 DWORD PTR [rcx+36], r8d

; 3787 :     a->a_bytecode = PyBytes_FromStringAndSize(NULL, DEFAULT_CODE_SIZE);

  0002d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00032	33 c9		 xor	 ecx, ecx
  00034	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00039	48 89 03	 mov	 QWORD PTR [rbx], rax

; 3788 :     if (!a->a_bytecode)

  0003c	48 85 c0	 test	 rax, rax

; 3789 :         return 0;

  0003f	74 2c		 je	 SHORT $LN7@assemble_i

; 3790 :     a->a_lnotab = PyBytes_FromStringAndSize(NULL, DEFAULT_LNOTAB_SIZE);

  00041	ba 10 00 00 00	 mov	 edx, 16
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 3791 :     if (!a->a_lnotab)

  00051	48 85 c0	 test	 rax, rax

; 3792 :         return 0;

  00054	74 17		 je	 SHORT $LN7@assemble_i

; 3793 :     if (nblocks > PY_SIZE_MAX / sizeof(basicblock *)) {

  00056	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00060	48 8b cf	 mov	 rcx, rdi
  00063	48 3b f8	 cmp	 rdi, rax
  00066	76 12		 jbe	 SHORT $LN2@assemble_i
$LN8@assemble_i:

; 3794 :         PyErr_NoMemory();

  00068	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN7@assemble_i:

; 3795 :         return 0;

  0006d	33 c0		 xor	 eax, eax

; 3804 : }

  0006f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
$LN2@assemble_i:

; 3796 :     }
; 3797 :     a->a_postorder = (basicblock **)PyObject_Malloc(
; 3798 :                                         sizeof(basicblock *) * nblocks);

  0007a	48 c1 e1 03	 shl	 rcx, 3
  0007e	e8 00 00 00 00	 call	 PyObject_Malloc
  00083	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 3799 :     if (!a->a_postorder) {

  00087	48 85 c0	 test	 rax, rax

; 3800 :         PyErr_NoMemory();
; 3801 :         return 0;

  0008a	74 dc		 je	 SHORT $LN8@assemble_i

; 3802 :     }
; 3803 :     return 1;

  0008c	b8 01 00 00 00	 mov	 eax, 1

; 3804 : }

  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
assemble_init ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$assemble_free DD imagerel assemble_free
	DD	imagerel assemble_free+257
	DD	imagerel $unwind$assemble_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_free DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT assemble_free
_TEXT	SEGMENT
a$ = 64
assemble_free PROC					; COMDAT

; 3808 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3809 :     Py_XDECREF(a->a_bytecode);

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 85 db	 test	 rbx, rbx
  00013	74 65		 je	 SHORT $LN8@assemble_f
  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	85 c0		 test	 eax, eax
  0001c	75 5c		 jne	 SHORT $LN8@assemble_f
  0001e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00022	a8 20		 test	 al, 32			; 00000020H
  00024	75 4c		 jne	 SHORT $LN16@assemble_f
  00026	84 c0		 test	 al, al
  00028	78 48		 js	 SHORT $LN16@assemble_f
  0002a	a8 02		 test	 al, 2
  0002c	75 4c		 jne	 SHORT $LN8@assemble_f
  0002e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00032	75 46		 jne	 SHORT $LN8@assemble_f
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00042	4c 8b cb	 mov	 r9, rbx
  00045	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0004b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00053	e8 00 00 00 00	 call	 _PyParallel_Guard
  00058	48 8b cb	 mov	 rcx, rbx
  0005b	85 c0		 test	 eax, eax
  0005d	74 07		 je	 SHORT $LN21@assemble_f
  0005f	e8 00 00 00 00	 call	 _Px_Dealloc
  00064	eb 14		 jmp	 SHORT $LN8@assemble_f
$LN21@assemble_f:
  00066	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00070	eb 08		 jmp	 SHORT $LN8@assemble_f
$LN16@assemble_f:
  00072	48 8b cb	 mov	 rcx, rbx
  00075	e8 00 00 00 00	 call	 Px_DecRef
$LN8@assemble_f:

; 3810 :     Py_XDECREF(a->a_lnotab);

  0007a	48 8b 5f 18	 mov	 rbx, QWORD PTR [rdi+24]
  0007e	48 85 db	 test	 rbx, rbx
  00081	74 65		 je	 SHORT $LN4@assemble_f
  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	75 5c		 jne	 SHORT $LN4@assemble_f
  0008c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00090	a8 20		 test	 al, 32			; 00000020H
  00092	75 4c		 jne	 SHORT $LN27@assemble_f
  00094	84 c0		 test	 al, al
  00096	78 48		 js	 SHORT $LN27@assemble_f
  00098	a8 02		 test	 al, 2
  0009a	75 4c		 jne	 SHORT $LN4@assemble_f
  0009c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a0	75 46		 jne	 SHORT $LN4@assemble_f
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b0	4c 8b cb	 mov	 r9, rbx
  000b3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	85 c0		 test	 eax, eax
  000cb	74 07		 je	 SHORT $LN32@assemble_f
  000cd	e8 00 00 00 00	 call	 _Px_Dealloc
  000d2	eb 14		 jmp	 SHORT $LN4@assemble_f
$LN32@assemble_f:
  000d4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000de	eb 08		 jmp	 SHORT $LN4@assemble_f
$LN27@assemble_f:
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	e8 00 00 00 00	 call	 Px_DecRef
$LN4@assemble_f:

; 3811 :     if (a->a_postorder)

  000e8	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000ec	48 85 c9	 test	 rcx, rcx
  000ef	74 05		 je	 SHORT $LN1@assemble_f

; 3812 :         PyObject_Free(a->a_postorder);

  000f1	e8 00 00 00 00	 call	 PyObject_Free
$LN1@assemble_f:

; 3813 : }

  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
assemble_free ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT instrsize
_TEXT	SEGMENT
instr$ = 8
instrsize PROC						; COMDAT

; 3820 :     if (!instr->i_hasarg)

  00000	f6 01 04	 test	 BYTE PTR [rcx], 4
  00003	75 06		 jne	 SHORT $LN2@instrsize

; 3821 :         return 1;               /* 1 byte for the opcode*/

  00005	b8 01 00 00 00	 mov	 eax, 1

; 3823 :         return 6;               /* 1 (opcode) + 1 (EXTENDED_ARG opcode) + 2 (oparg) + 2(oparg extended) */
; 3824 :     return 3;                   /* 1 (opcode) + 2 (oparg) */
; 3825 : }

  0000a	c3		 ret	 0
$LN2@instrsize:

; 3822 :     if (instr->i_oparg > 0xffff)

  0000b	81 79 08 ff ff
	00 00		 cmp	 DWORD PTR [rcx+8], 65535 ; 0000ffffH
  00012	b8 03 00 00 00	 mov	 eax, 3
  00017	ba 06 00 00 00	 mov	 edx, 6
  0001c	0f 4f c2	 cmovg	 eax, edx

; 3823 :         return 6;               /* 1 (opcode) + 1 (EXTENDED_ARG opcode) + 2 (oparg) + 2(oparg extended) */
; 3824 :     return 3;                   /* 1 (opcode) + 2 (oparg) */
; 3825 : }

  0001f	c3		 ret	 0
instrsize ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$blocksize DD imagerel blocksize
	DD	imagerel blocksize+46
	DD	imagerel $unwind$blocksize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$blocksize DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT blocksize
_TEXT	SEGMENT
b$ = 48
blocksize PROC						; COMDAT

; 3829 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3832 : 
; 3833 :     for (i = 0; i < b->b_iused; i++)

  00004	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00007	45 33 c0	 xor	 r8d, r8d
  0000a	85 c0		 test	 eax, eax
  0000c	7e 18		 jle	 SHORT $LN8@blocksize

; 3830 :     int i;
; 3831 :     int size = 0;

  0000e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00012	44 8b c8	 mov	 r9d, eax
$LL3@blocksize:

; 3834 :         size += instrsize(&b->b_instr[i]);

  00015	e8 00 00 00 00	 call	 instrsize
  0001a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0001e	44 03 c0	 add	 r8d, eax
  00021	49 ff c9	 dec	 r9
  00024	75 ef		 jne	 SHORT $LL3@blocksize
$LN8@blocksize:

; 3835 :     return size;

  00026	41 8b c0	 mov	 eax, r8d

; 3836 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
blocksize ENDP
_TEXT	ENDS
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_lnotab DD imagerel assemble_lnotab
	DD	imagerel assemble_lnotab+505
	DD	imagerel $unwind$assemble_lnotab
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_lnotab DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT assemble_lnotab
_TEXT	SEGMENT
a$ = 64
i$ = 72
assemble_lnotab PROC					; COMDAT

; 3844 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3845 :     int d_bytecode, d_lineno;
; 3846 :     int len;
; 3847 :     unsigned char *lnotab;
; 3848 : 
; 3849 :     d_bytecode = a->a_offset - a->a_lineno_off;

  0001e	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]

; 3850 :     d_lineno = i->i_lineno - a->a_lineno;

  00021	8b 72 18	 mov	 esi, DWORD PTR [rdx+24]
  00024	4c 8b f2	 mov	 r14, rdx
  00027	2b 79 28	 sub	 edi, DWORD PTR [rcx+40]
  0002a	2b 71 24	 sub	 esi, DWORD PTR [rcx+36]
  0002d	48 8b d9	 mov	 rbx, rcx

; 3851 : 
; 3852 :     assert(d_bytecode >= 0);
; 3853 :     assert(d_lineno >= 0);
; 3854 : 
; 3855 :     if(d_bytecode == 0 && d_lineno == 0)

  00030	85 ff		 test	 edi, edi
  00032	75 0d		 jne	 SHORT $LN25@assemble_l
  00034	85 f6		 test	 esi, esi
  00036	0f 85 9e 00 00
	00		 jne	 $LN24@assemble_l

; 3856 :         return 1;

  0003c	e9 94 01 00 00	 jmp	 $LN32@assemble_l
$LN25@assemble_l:

; 3857 : 
; 3858 :     if (d_bytecode > 255) {

  00041	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00047	0f 8e 8d 00 00
	00		 jle	 $LN24@assemble_l

; 3859 :         int j, nbytes, ncodes = d_bytecode / 255;

  0004d	b8 81 80 80 80	 mov	 eax, -2139062143	; ffffffff80808081H
  00052	f7 ef		 imul	 edi
  00054	8d 2c 17	 lea	 ebp, DWORD PTR [rdi+rdx]
  00057	c1 fd 07	 sar	 ebp, 7
  0005a	8b c5		 mov	 eax, ebp
  0005c	c1 e8 1f	 shr	 eax, 31
  0005f	03 e8		 add	 ebp, eax

; 3860 :         nbytes = a->a_lnotab_off + 2 * ncodes;

  00061	8b 41 20	 mov	 eax, DWORD PTR [rcx+32]
  00064	44 8d 6c 2d 00	 lea	 r13d, DWORD PTR [rbp+rbp]
  00069	41 8d 4c 05 00	 lea	 ecx, DWORD PTR [r13+rax]

; 3861 :         len = PyBytes_GET_SIZE(a->a_lnotab);

  0006e	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00072	8b 40 60	 mov	 eax, DWORD PTR [rax+96]

; 3862 :         if (nbytes >= len) {

  00075	3b c8		 cmp	 ecx, eax
  00077	7c 31		 jl	 SHORT $LN18@assemble_l

; 3863 :             if ((len <= INT_MAX / 2) && (len * 2 < nbytes))

  00079	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0007e	7f 1e		 jg	 SHORT $LN20@assemble_l
  00080	03 c0		 add	 eax, eax
  00082	3b c1		 cmp	 eax, ecx
  00084	0f 4c c1	 cmovl	 eax, ecx

; 3870 :             }
; 3871 :             if (_PyBytes_Resize(&a->a_lnotab, len) < 0)

  00087	48 8d 4b 18	 lea	 rcx, QWORD PTR [rbx+24]
  0008b	48 63 d0	 movsxd	 rdx, eax
  0008e	e8 00 00 00 00	 call	 _PyBytes_Resize
  00093	85 c0		 test	 eax, eax
  00095	79 13		 jns	 SHORT $LN18@assemble_l

; 3872 :                 return 0;

  00097	33 c0		 xor	 eax, eax
  00099	e9 3c 01 00 00	 jmp	 $LN26@assemble_l
$LN20@assemble_l:

; 3864 :                 len = nbytes;
; 3865 :             else if (len <= INT_MAX / 2)
; 3866 :                 len *= 2;
; 3867 :             else {
; 3868 :                 PyErr_NoMemory();

  0009e	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN34@assemble_l:

; 3869 :                 return 0;

  000a3	33 c0		 xor	 eax, eax
  000a5	e9 30 01 00 00	 jmp	 $LN26@assemble_l
$LN18@assemble_l:

; 3873 :         }
; 3874 :         lnotab = (unsigned char *)
; 3875 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  000aa	48 63 4b 20	 movsxd	 rcx, DWORD PTR [rbx+32]
  000ae	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000b2	48 8d 54 01 78	 lea	 rdx, QWORD PTR [rcx+rax+120]

; 3876 :         for (j = 0; j < ncodes; j++) {

  000b7	85 ed		 test	 ebp, ebp
  000b9	7e 13		 jle	 SHORT $LN15@assemble_l

; 3873 :         }
; 3874 :         lnotab = (unsigned char *)
; 3875 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  000bb	8b cd		 mov	 ecx, ebp
  000bd	0f 1f 00	 npad	 3
$LL17@assemble_l:

; 3877 :             *lnotab++ = 255;

  000c0	66 c7 02 ff 00	 mov	 WORD PTR [rdx], 255	; 000000ffH

; 3878 :             *lnotab++ = 0;

  000c5	48 83 c2 02	 add	 rdx, 2
  000c9	48 ff c9	 dec	 rcx
  000cc	75 f2		 jne	 SHORT $LL17@assemble_l
$LN15@assemble_l:

; 3879 :         }
; 3880 :         d_bytecode -= ncodes * 255;

  000ce	69 ed 01 ff ff
	ff		 imul	 ebp, -255		; ffffffffffffff01H
  000d4	03 fd		 add	 edi, ebp

; 3881 :         a->a_lnotab_off += ncodes * 2;

  000d6	44 01 6b 20	 add	 DWORD PTR [rbx+32], r13d
$LN24@assemble_l:

; 3882 :     }
; 3883 :     assert(d_bytecode <= 255);
; 3884 :     if (d_lineno > 255) {

  000da	81 fe ff 00 00
	00		 cmp	 esi, 255		; 000000ffH
  000e0	0f 8e 94 00 00
	00		 jle	 $LN14@assemble_l

; 3885 :         int j, nbytes, ncodes = d_lineno / 255;

  000e6	b8 81 80 80 80	 mov	 eax, -2139062143	; ffffffff80808081H
  000eb	f7 ee		 imul	 esi
  000ed	8d 2c 16	 lea	 ebp, DWORD PTR [rsi+rdx]
  000f0	c1 fd 07	 sar	 ebp, 7
  000f3	8b c5		 mov	 eax, ebp
  000f5	c1 e8 1f	 shr	 eax, 31
  000f8	03 e8		 add	 ebp, eax

; 3886 :         nbytes = a->a_lnotab_off + 2 * ncodes;

  000fa	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  000fd	44 8d 6c 2d 00	 lea	 r13d, DWORD PTR [rbp+rbp]
  00102	41 8d 4c 05 00	 lea	 ecx, DWORD PTR [r13+rax]

; 3887 :         len = PyBytes_GET_SIZE(a->a_lnotab);

  00107	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0010b	8b 40 60	 mov	 eax, DWORD PTR [rax+96]

; 3888 :         if (nbytes >= len) {

  0010e	3b c8		 cmp	 ecx, eax
  00110	7c 22		 jl	 SHORT $LN8@assemble_l

; 3889 :             if ((len <= INT_MAX / 2) && len * 2 < nbytes)

  00112	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00117	7f 85		 jg	 SHORT $LN20@assemble_l
  00119	03 c0		 add	 eax, eax
  0011b	3b c1		 cmp	 eax, ecx
  0011d	0f 4c c1	 cmovl	 eax, ecx

; 3890 :                 len = nbytes;
; 3891 :             else if (len <= INT_MAX / 2)
; 3892 :                 len *= 2;
; 3893 :             else {
; 3894 :                 PyErr_NoMemory();
; 3895 :                 return 0;
; 3896 :             }
; 3897 :             if (_PyBytes_Resize(&a->a_lnotab, len) < 0)

  00120	48 8d 4b 18	 lea	 rcx, QWORD PTR [rbx+24]
  00124	48 63 d0	 movsxd	 rdx, eax
  00127	e8 00 00 00 00	 call	 _PyBytes_Resize
  0012c	85 c0		 test	 eax, eax

; 3898 :                 return 0;

  0012e	0f 88 6f ff ff
	ff		 js	 $LN34@assemble_l
$LN8@assemble_l:

; 3899 :         }
; 3900 :         lnotab = (unsigned char *)
; 3901 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  00134	48 63 4b 20	 movsxd	 rcx, DWORD PTR [rbx+32]
  00138	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 3902 :         *lnotab++ = d_bytecode;

  0013c	40 88 7c 01 78	 mov	 BYTE PTR [rcx+rax+120], dil
  00141	48 8d 54 01 78	 lea	 rdx, QWORD PTR [rcx+rax+120]

; 3903 :         *lnotab++ = 255;
; 3904 :         d_bytecode = 0;

  00146	33 ff		 xor	 edi, edi
  00148	c6 42 01 ff	 mov	 BYTE PTR [rdx+1], 255	; 000000ffH
  0014c	48 83 c2 02	 add	 rdx, 2

; 3905 :         for (j = 1; j < ncodes; j++) {

  00150	83 fd 01	 cmp	 ebp, 1
  00153	7e 19		 jle	 SHORT $LN5@assemble_l

; 3899 :         }
; 3900 :         lnotab = (unsigned char *)
; 3901 :                    PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  00155	8d 4d ff	 lea	 ecx, DWORD PTR [rbp-1]
  00158	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@assemble_l:

; 3906 :             *lnotab++ = 0;

  00160	66 c7 02 00 ff	 mov	 WORD PTR [rdx], 65280	; 0000ff00H

; 3907 :             *lnotab++ = 255;

  00165	48 83 c2 02	 add	 rdx, 2
  00169	48 ff c9	 dec	 rcx
  0016c	75 f2		 jne	 SHORT $LL7@assemble_l
$LN5@assemble_l:

; 3908 :         }
; 3909 :         d_lineno -= ncodes * 255;

  0016e	69 ed 01 ff ff
	ff		 imul	 ebp, -255		; ffffffffffffff01H
  00174	03 f5		 add	 esi, ebp

; 3910 :         a->a_lnotab_off += ncodes * 2;

  00176	44 01 6b 20	 add	 DWORD PTR [rbx+32], r13d
$LN14@assemble_l:

; 3911 :     }
; 3912 : 
; 3913 :     len = PyBytes_GET_SIZE(a->a_lnotab);

  0017a	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0017e	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]

; 3914 :     if (a->a_lnotab_off + 2 >= len) {

  00181	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  00184	83 c0 02	 add	 eax, 2
  00187	3b c1		 cmp	 eax, ecx
  00189	7c 17		 jl	 SHORT $LN3@assemble_l

; 3915 :         if (_PyBytes_Resize(&a->a_lnotab, len * 2) < 0)

  0018b	8d 04 09	 lea	 eax, DWORD PTR [rcx+rcx]
  0018e	48 8d 4b 18	 lea	 rcx, QWORD PTR [rbx+24]
  00192	48 63 d0	 movsxd	 rdx, eax
  00195	e8 00 00 00 00	 call	 _PyBytes_Resize
  0019a	85 c0		 test	 eax, eax

; 3916 :             return 0;

  0019c	0f 88 01 ff ff
	ff		 js	 $LN34@assemble_l
$LN3@assemble_l:

; 3917 :     }
; 3918 :     lnotab = (unsigned char *)
; 3919 :                     PyBytes_AS_STRING(a->a_lnotab) + a->a_lnotab_off;

  001a2	48 63 43 20	 movsxd	 rax, DWORD PTR [rbx+32]
  001a6	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  001aa	48 8b c8	 mov	 rcx, rax

; 3920 : 
; 3921 :     a->a_lnotab_off += 2;

  001ad	83 c0 02	 add	 eax, 2
  001b0	89 43 20	 mov	 DWORD PTR [rbx+32], eax

; 3922 :     if (d_bytecode) {

  001b3	85 ff		 test	 edi, edi
  001b5	74 07		 je	 SHORT $LN2@assemble_l

; 3923 :         *lnotab++ = d_bytecode;

  001b7	40 88 7c 11 78	 mov	 BYTE PTR [rcx+rdx+120], dil

; 3924 :         *lnotab++ = d_lineno;
; 3925 :     }
; 3926 :     else {      /* First line of a block; def stmt, etc. */

  001bc	eb 05		 jmp	 SHORT $LN33@assemble_l
$LN2@assemble_l:

; 3927 :         *lnotab++ = 0;

  001be	c6 44 11 78 00	 mov	 BYTE PTR [rcx+rdx+120], 0
$LN33@assemble_l:

; 3928 :         *lnotab++ = d_lineno;

  001c3	40 88 74 11 79	 mov	 BYTE PTR [rcx+rdx+121], sil

; 3929 :     }
; 3930 :     a->a_lineno = i->i_lineno;

  001c8	41 8b 46 18	 mov	 eax, DWORD PTR [r14+24]
  001cc	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 3931 :     a->a_lineno_off = a->a_offset;

  001cf	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  001d2	89 43 28	 mov	 DWORD PTR [rbx+40], eax
$LN32@assemble_l:

; 3932 :     return 1;

  001d5	b8 01 00 00 00	 mov	 eax, 1
$LN26@assemble_l:

; 3933 : }

  001da	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001df	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001e4	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001e9	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f2	41 5e		 pop	 r14
  001f4	41 5d		 pop	 r13
  001f6	41 5c		 pop	 r12
  001f8	c3		 ret	 0
assemble_lnotab ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_emit DD imagerel assemble_emit
	DD	imagerel assemble_emit+235
	DD	imagerel $unwind$assemble_emit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_emit DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT assemble_emit
_TEXT	SEGMENT
a$ = 64
i$ = 72
assemble_emit PROC					; COMDAT

; 3942 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3943 :     int size, arg = 0, ext = 0;
; 3944 :     Py_ssize_t len = PyBytes_GET_SIZE(a->a_bytecode);

  00018	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001b	48 8b e9	 mov	 rbp, rcx
  0001e	33 db		 xor	 ebx, ebx
  00020	4c 8b 60 60	 mov	 r12, QWORD PTR [rax+96]

; 3945 :     char *code;
; 3946 : 
; 3947 :     size = instrsize(i);

  00024	48 8b ca	 mov	 rcx, rdx
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	8b fb		 mov	 edi, ebx
  0002c	e8 00 00 00 00	 call	 instrsize

; 3948 :     if (i->i_hasarg) {

  00031	f6 01 04	 test	 BYTE PTR [rcx], 4
  00034	44 8b e8	 mov	 r13d, eax
  00037	74 08		 je	 SHORT $LN7@assemble_e

; 3949 :         arg = i->i_oparg;

  00039	8b 59 08	 mov	 ebx, DWORD PTR [rcx+8]

; 3950 :         ext = arg >> 16;

  0003c	8b fb		 mov	 edi, ebx
  0003e	c1 ff 10	 sar	 edi, 16
$LN7@assemble_e:

; 3951 :     }
; 3952 :     if (i->i_lineno && !assemble_lnotab(a, i))

  00041	83 7e 18 00	 cmp	 DWORD PTR [rsi+24], 0
  00045	74 13		 je	 SHORT $LN6@assemble_e
  00047	48 8b d6	 mov	 rdx, rsi
  0004a	48 8b cd	 mov	 rcx, rbp
  0004d	e8 00 00 00 00	 call	 assemble_lnotab
  00052	85 c0		 test	 eax, eax
  00054	75 04		 jne	 SHORT $LN6@assemble_e
$LN10@assemble_e:

; 3953 :         return 0;

  00056	33 c0		 xor	 eax, eax
  00058	eb 78		 jmp	 SHORT $LN8@assemble_e
$LN6@assemble_e:

; 3954 :     if (a->a_offset + size >= len) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR [rbp+8]
  0005d	41 03 c5	 add	 eax, r13d
  00060	48 98		 cdqe
  00062	49 3b c4	 cmp	 rax, r12
  00065	7c 1f		 jl	 SHORT $LN3@assemble_e

; 3955 :         if (len > PY_SSIZE_T_MAX / 2)

  00067	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  00071	4c 3b e0	 cmp	 r12, rax

; 3956 :             return 0;

  00074	7f e0		 jg	 SHORT $LN10@assemble_e

; 3957 :         if (_PyBytes_Resize(&a->a_bytecode, len * 2) < 0)

  00076	4b 8d 14 24	 lea	 rdx, QWORD PTR [r12+r12]
  0007a	48 8b cd	 mov	 rcx, rbp
  0007d	e8 00 00 00 00	 call	 _PyBytes_Resize
  00082	85 c0		 test	 eax, eax

; 3958 :             return 0;

  00084	78 d0		 js	 SHORT $LN10@assemble_e
$LN3@assemble_e:

; 3959 :     }
; 3960 :     code = PyBytes_AS_STRING(a->a_bytecode) + a->a_offset;

  00086	48 63 55 08	 movsxd	 rdx, DWORD PTR [rbp+8]
  0008a	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  0008e	4c 8d 44 02 78	 lea	 r8, QWORD PTR [rdx+rax+120]

; 3961 :     a->a_offset += size;

  00093	42 8d 04 2a	 lea	 eax, DWORD PTR [rdx+r13]
  00097	89 45 08	 mov	 DWORD PTR [rbp+8], eax

; 3962 :     if (size == 6) {

  0009a	41 83 fd 06	 cmp	 r13d, 6
  0009e	75 16		 jne	 SHORT $LN2@assemble_e

; 3963 :         assert(i->i_hasarg);
; 3964 :         *code++ = (char)EXTENDED_ARG;

  000a0	41 c6 00 90	 mov	 BYTE PTR [r8], -112	; ffffffffffffff90H

; 3965 :         *code++ = ext & 0xff;

  000a4	41 88 78 01	 mov	 BYTE PTR [r8+1], dil

; 3966 :         *code++ = ext >> 8;

  000a8	c1 ff 08	 sar	 edi, 8
  000ab	41 88 78 02	 mov	 BYTE PTR [r8+2], dil
  000af	49 83 c0 03	 add	 r8, 3

; 3967 :         arg &= 0xffff;

  000b3	0f b7 db	 movzx	 ebx, bx
$LN2@assemble_e:

; 3968 :     }
; 3969 :     *code++ = i->i_opcode;

  000b6	0f b6 46 04	 movzx	 eax, BYTE PTR [rsi+4]
  000ba	41 88 00	 mov	 BYTE PTR [r8], al

; 3970 :     if (i->i_hasarg) {

  000bd	f6 06 04	 test	 BYTE PTR [rsi], 4
  000c0	74 0b		 je	 SHORT $LN1@assemble_e

; 3971 :         assert(size == 3 || size == 6);
; 3972 :         *code++ = arg & 0xff;

  000c2	41 88 58 01	 mov	 BYTE PTR [r8+1], bl

; 3973 :         *code++ = arg >> 8;

  000c6	c1 fb 08	 sar	 ebx, 8
  000c9	41 88 58 02	 mov	 BYTE PTR [r8+2], bl
$LN1@assemble_e:

; 3974 :     }
; 3975 :     return 1;

  000cd	b8 01 00 00 00	 mov	 eax, 1
$LN8@assemble_e:

; 3976 : }

  000d2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000dc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	41 5d		 pop	 r13
  000e7	41 5c		 pop	 r12
  000e9	5f		 pop	 rdi
  000ea	c3		 ret	 0
assemble_emit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble_jump_offsets DD imagerel assemble_jump_offsets
	DD	imagerel assemble_jump_offsets+229
	DD	imagerel $unwind$assemble_jump_offsets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble_jump_offsets DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT assemble_jump_offsets
_TEXT	SEGMENT
a$ = 48
c$ = 56
assemble_jump_offsets PROC				; COMDAT

; 3980 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	4c 8b e2	 mov	 r12, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 3981 :     basicblock *b;
; 3982 :     int bsize, totsize, extended_arg_count = 0, last_extended_arg_count;

  00020	33 ff		 xor	 edi, edi
$LL17@assemble_j:

; 3983 :     int i;
; 3984 : 
; 3985 :     /* Compute the size of each block and fixup jump args.
; 3986 :        Replace block pointer with position in bytecode. */
; 3987 :     do {
; 3988 :         totsize = 0;
; 3989 :         for (i = a->a_nblocks - 1; i >= 0; i--) {

  00022	8b 46 0c	 mov	 eax, DWORD PTR [rsi+12]
  00025	33 db		 xor	 ebx, ebx
  00027	ff c8		 dec	 eax
  00029	4c 63 d8	 movsxd	 r11, eax
  0002c	78 1d		 js	 SHORT $LN12@assemble_j
  0002e	66 90		 npad	 2
$LL14@assemble_j:

; 3990 :             b = a->a_postorder[i];

  00030	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  00034	4e 8b 14 d8	 mov	 r10, QWORD PTR [rax+r11*8]

; 3991 :             bsize = blocksize(b);

  00038	49 8b ca	 mov	 rcx, r10
  0003b	e8 00 00 00 00	 call	 blocksize

; 3992 :             b->b_offset = totsize;

  00040	41 89 5a 28	 mov	 DWORD PTR [r10+40], ebx

; 3993 :             totsize += bsize;

  00044	03 d8		 add	 ebx, eax
  00046	49 ff cb	 dec	 r11
  00049	79 e5		 jns	 SHORT $LL14@assemble_j
$LN12@assemble_j:

; 3994 :         }
; 3995 :         last_extended_arg_count = extended_arg_count;
; 3996 :         extended_arg_count = 0;
; 3997 :         for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  0004b	49 8b 44 24 38	 mov	 rax, QWORD PTR [r12+56]
  00050	8b ef		 mov	 ebp, edi
  00052	33 ff		 xor	 edi, edi
  00054	4c 8b 48 58	 mov	 r9, QWORD PTR [rax+88]
  00058	4d 85 c9	 test	 r9, r9
  0005b	74 65		 je	 SHORT $LN16@assemble_j
  0005d	0f 1f 00	 npad	 3
$LL11@assemble_j:

; 3998 :             bsize = b->b_offset;

  00060	41 8b 59 28	 mov	 ebx, DWORD PTR [r9+40]

; 3999 :             for (i = 0; i < b->b_iused; i++) {

  00064	45 33 d2	 xor	 r10d, r10d
  00067	45 39 51 08	 cmp	 DWORD PTR [r9+8], r10d
  0006b	7e 4d		 jle	 SHORT $LN10@assemble_j

; 3998 :             bsize = b->b_offset;

  0006d	45 33 db	 xor	 r11d, r11d
$LL8@assemble_j:

; 4000 :                 struct instr *instr = &b->b_instr[i];

  00070	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]
  00074	4d 8d 04 03	 lea	 r8, QWORD PTR [r11+rax]

; 4001 :                 /* Relative jumps are computed relative to
; 4002 :                    the instruction pointer after fetching
; 4003 :                    the jump instruction.
; 4004 :                 */
; 4005 :                 bsize += instrsize(instr);

  00078	49 8b c8	 mov	 rcx, r8
  0007b	e8 00 00 00 00	 call	 instrsize
  00080	03 d8		 add	 ebx, eax

; 4006 :                 if (instr->i_jabs)

  00082	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00085	a8 01		 test	 al, 1
  00087	74 09		 je	 SHORT $LN5@assemble_j

; 4007 :                     instr->i_oparg = instr->i_target->b_offset;

  00089	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  0008d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00090	eb 0d		 jmp	 SHORT $LN27@assemble_j
$LN5@assemble_j:

; 4008 :                 else if (instr->i_jrel) {

  00092	a8 02		 test	 al, 2
  00094	74 17		 je	 SHORT $LN7@assemble_j

; 4009 :                     int delta = instr->i_target->b_offset - bsize;

  00096	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  0009a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0009d	2b cb		 sub	 ecx, ebx
$LN27@assemble_j:

; 4010 :                     instr->i_oparg = delta;

  0009f	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx

; 4011 :                 }
; 4012 :                 else
; 4013 :                     continue;
; 4014 :                 if (instr->i_oparg > 0xffff)

  000a3	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  000a9	7e 02		 jle	 SHORT $LN7@assemble_j

; 4015 :                     extended_arg_count++;

  000ab	ff c7		 inc	 edi
$LN7@assemble_j:

; 3999 :             for (i = 0; i < b->b_iused; i++) {

  000ad	41 ff c2	 inc	 r10d
  000b0	49 83 c3 20	 add	 r11, 32			; 00000020H
  000b4	45 3b 51 08	 cmp	 r10d, DWORD PTR [r9+8]
  000b8	7c b6		 jl	 SHORT $LL8@assemble_j
$LN10@assemble_j:

; 3994 :         }
; 3995 :         last_extended_arg_count = extended_arg_count;
; 3996 :         extended_arg_count = 0;
; 3997 :         for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  000ba	4d 8b 09	 mov	 r9, QWORD PTR [r9]
  000bd	4d 85 c9	 test	 r9, r9
  000c0	75 9e		 jne	 SHORT $LL11@assemble_j
$LN16@assemble_j:

; 4016 :             }
; 4017 :         }
; 4018 : 
; 4019 :     /* XXX: This is an awful hack that could hurt performance, but
; 4020 :         on the bright side it should work until we come up
; 4021 :         with a better solution.
; 4022 : 
; 4023 :         The issue is that in the first loop blocksize() is called
; 4024 :         which calls instrsize() which requires i_oparg be set
; 4025 :         appropriately.          There is a bootstrap problem because
; 4026 :         i_oparg is calculated in the second loop above.
; 4027 : 
; 4028 :         So we loop until we stop seeing new EXTENDED_ARGs.
; 4029 :         The only EXTENDED_ARGs that could be popping up are
; 4030 :         ones in jump instructions.  So this should converge
; 4031 :         fairly quickly.
; 4032 :     */
; 4033 :     } while (last_extended_arg_count != extended_arg_count);

  000c2	3b ef		 cmp	 ebp, edi
  000c4	0f 85 58 ff ff
	ff		 jne	 $LL17@assemble_j

; 4034 : }

  000ca	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cf	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000d4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000de	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e2	41 5c		 pop	 r12
  000e4	c3		 ret	 0
assemble_jump_offsets ENDP
_TEXT	ENDS
EXTRN	PyDict_Next:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$dict_keys_inorder DD imagerel dict_keys_inorder
	DD	imagerel dict_keys_inorder+83
	DD	imagerel $unwind$dict_keys_inorder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$dict_keys_inorder DD imagerel dict_keys_inorder+83
	DD	imagerel dict_keys_inorder+232
	DD	imagerel $chain$1$dict_keys_inorder
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$dict_keys_inorder DD imagerel dict_keys_inorder+232
	DD	imagerel dict_keys_inorder+243
	DD	imagerel $chain$2$dict_keys_inorder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$dict_keys_inorder DD 021H
	DD	imagerel dict_keys_inorder
	DD	imagerel dict_keys_inorder+83
	DD	imagerel $unwind$dict_keys_inorder
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$dict_keys_inorder DD 040a21H
	DD	0dc40aH
	DD	0c5405H
	DD	imagerel dict_keys_inorder
	DD	imagerel dict_keys_inorder+83
	DD	imagerel $unwind$dict_keys_inorder
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dict_keys_inorder DD 040801H
	DD	070047208H
	DD	030026003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT dict_keys_inorder
_TEXT	SEGMENT
pos$ = 48
dict$ = 96
offset$ = 104
k$ = 112
v$ = 120
dict_keys_inorder PROC					; COMDAT

; 4038 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00008	48 63 da	 movsxd	 rbx, edx
  0000b	48 8b f1	 mov	 rsi, rcx

; 4039 :     PyObject *tuple, *k, *v;
; 4040 :     Py_ssize_t i, pos = 0, size = PyDict_Size(dict);

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0
  00017	e8 00 00 00 00	 call	 PyDict_Size

; 4041 : 
; 4042 :     tuple = PyTuple_New(size);

  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 PyTuple_New
  00024	48 8b f8	 mov	 rdi, rax

; 4043 :     if (tuple == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 08		 jne	 SHORT $LN10@dict_keys_

; 4056 : }

  0002c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00030	5f		 pop	 rdi
  00031	5e		 pop	 rsi
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
$LN10@dict_keys_:

; 4044 :         return NULL;
; 4045 :     while (PyDict_Next(dict, &pos, &k, &v)) {

  00034	4c 8d 4c 24 78	 lea	 r9, QWORD PTR v$[rsp]
  00039	4c 8d 44 24 70	 lea	 r8, QWORD PTR k$[rsp]
  0003e	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos$[rsp]
  00043	48 8b ce	 mov	 rcx, rsi
  00046	e8 00 00 00 00	 call	 PyDict_Next
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 95 00 00
	00		 je	 $LN1@dict_keys_
  00053	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00058	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0005d	4c 8b e3	 mov	 r12, rbx
$LL2@dict_keys_:

; 4046 :         i = PyLong_AS_LONG(v);

  00060	48 8b 4c 24 78	 mov	 rcx, QWORD PTR v$[rsp]
  00065	e8 00 00 00 00	 call	 PyLong_AsLong
  0006a	48 63 e8	 movsxd	 rbp, eax

; 4047 :         /* The keys of the dictionary are tuples. (see compiler_add_o)
; 4048 :            The object we want is always first, though. */
; 4049 :         k = PyTuple_GET_ITEM(k, 0);

  0006d	48 8b 44 24 70	 mov	 rax, QWORD PTR k$[rsp]
  00072	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]
  00076	48 89 5c 24 70	 mov	 QWORD PTR k$[rsp], rbx

; 4050 :         Py_INCREF(k);

  0007b	e8 00 00 00 00	 call	 _Py_PXCTX
  00080	85 c0		 test	 eax, eax
  00082	75 32		 jne	 SHORT $LN7@dict_keys_
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00092	4c 8b cb	 mov	 r9, rbx
  00095	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a8	85 c0		 test	 eax, eax
  000aa	75 06		 jne	 SHORT $LN6@dict_keys_
  000ac	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b0	74 04		 je	 SHORT $LN7@dict_keys_
$LN6@dict_keys_:
  000b2	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN7@dict_keys_:

; 4051 :         assert((i - offset) < size);
; 4052 :         assert((i - offset) >= 0);
; 4053 :         PyTuple_SET_ITEM(tuple, i - offset, k);

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR k$[rsp]
  000bb	49 2b ec	 sub	 rbp, r12
  000be	4c 8d 4c 24 78	 lea	 r9, QWORD PTR v$[rsp]
  000c3	4c 8d 44 24 70	 lea	 r8, QWORD PTR k$[rsp]
  000c8	48 8d 54 24 30	 lea	 rdx, QWORD PTR pos$[rsp]
  000cd	48 8b ce	 mov	 rcx, rsi
  000d0	48 89 44 ef 70	 mov	 QWORD PTR [rdi+rbp*8+112], rax
  000d5	e8 00 00 00 00	 call	 PyDict_Next
  000da	85 c0		 test	 eax, eax
  000dc	75 82		 jne	 SHORT $LL2@dict_keys_
  000de	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  000e3	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
$LN1@dict_keys_:

; 4054 :     }
; 4055 :     return tuple;

  000e8	48 8b c7	 mov	 rax, rdi

; 4056 : }

  000eb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ef	5f		 pop	 rdi
  000f0	5e		 pop	 rsi
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
dict_keys_inorder ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compute_code_flags DD imagerel compute_code_flags
	DD	imagerel compute_code_flags+173
	DD	imagerel $unwind$compute_code_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compute_code_flags DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compute_code_flags
_TEXT	SEGMENT
c$ = 48
compute_code_flags PROC					; COMDAT

; 4060 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4061 :     PySTEntryObject *ste = c->u->u_ste;
; 4062 :     int flags = 0, n;

  0000a	33 db		 xor	 ebx, ebx

; 4063 :     if (ste->ste_type != ModuleBlock)

  0000c	41 b8 02 00 00
	00		 mov	 r8d, 2
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00019	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0001c	8b 82 88 00 00
	00		 mov	 eax, DWORD PTR [rdx+136]
  00022	41 3b c0	 cmp	 eax, r8d
  00025	41 0f 45 d8	 cmovne	 ebx, r8d

; 4064 :         flags |= CO_NEWLOCALS;
; 4065 :     if (ste->ste_type == FunctionBlock) {

  00029	85 c0		 test	 eax, eax
  0002b	75 32		 jne	 SHORT $LN5@compute_co

; 4066 :         if (!ste->ste_unoptimized)

  0002d	39 82 8c 00 00
	00		 cmp	 DWORD PTR [rdx+140], eax
  00033	75 03		 jne	 SHORT $LN9@compute_co

; 4067 :             flags |= CO_OPTIMIZED;

  00035	83 cb 01	 or	 ebx, 1
$LN9@compute_co:

; 4068 :         if (ste->ste_nested)

  00038	83 ba 90 00 00
	00 00		 cmp	 DWORD PTR [rdx+144], 0
  0003f	74 03		 je	 SHORT $LN8@compute_co

; 4069 :             flags |= CO_NESTED;

  00041	83 cb 10	 or	 ebx, 16
$LN8@compute_co:

; 4070 :         if (ste->ste_generator)

  00044	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  0004a	a8 04		 test	 al, 4
  0004c	74 03		 je	 SHORT $LN7@compute_co

; 4071 :             flags |= CO_GENERATOR;

  0004e	83 cb 20	 or	 ebx, 32			; 00000020H
$LN7@compute_co:

; 4072 :         if (ste->ste_varargs)

  00051	a8 08		 test	 al, 8
  00053	74 03		 je	 SHORT $LN6@compute_co

; 4073 :             flags |= CO_VARARGS;

  00055	83 cb 04	 or	 ebx, 4
$LN6@compute_co:

; 4074 :         if (ste->ste_varkeywords)

  00058	a8 10		 test	 al, 16
  0005a	74 03		 je	 SHORT $LN5@compute_co

; 4075 :             flags |= CO_VARKEYWORDS;

  0005c	83 cb 08	 or	 ebx, 8
$LN5@compute_co:

; 4076 :     }
; 4077 : 
; 4078 :     /* (Only) inherit compilerflags in PyCF_MASK */
; 4079 :     flags |= (c->c_flags->cf_flags & PyCF_MASK);

  0005f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]

; 4080 : 
; 4081 :     n = PyDict_Size(c->u->u_freevars);

  00063	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00067	8b 10		 mov	 edx, DWORD PTR [rax]
  00069	81 e2 00 e0 07
	00		 and	 edx, 516096		; 0007e000H
  0006f	0b da		 or	 ebx, edx
  00071	e8 00 00 00 00	 call	 PyDict_Size

; 4082 :     if (n < 0)

  00076	85 c0		 test	 eax, eax
  00078	79 0e		 jns	 SHORT $LN14@compute_co
$LN16@compute_co:

; 4083 :         return -1;

  0007a	83 c8 ff	 or	 eax, -1

; 4094 : }

  0007d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
$LN14@compute_co:

; 4084 :     if (n == 0) {

  00088	75 16		 jne	 SHORT $LN1@compute_co

; 4085 :         n = PyDict_Size(c->u->u_cellvars);

  0008a	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0008e	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00092	e8 00 00 00 00	 call	 PyDict_Size

; 4086 :         if (n < 0)

  00097	85 c0		 test	 eax, eax

; 4087 :         return -1;

  00099	78 df		 js	 SHORT $LN16@compute_co

; 4088 :         if (n == 0) {

  0009b	75 03		 jne	 SHORT $LN1@compute_co

; 4089 :         flags |= CO_NOFREE;

  0009d	83 cb 40	 or	 ebx, 64			; 00000040H
$LN1@compute_co:

; 4090 :         }
; 4091 :     }
; 4092 : 
; 4093 :     return flags;

  000a0	8b c3		 mov	 eax, ebx

; 4094 : }

  000a2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ab	5f		 pop	 rdi
  000ac	c3		 ret	 0
compute_code_flags ENDP
_TEXT	ENDS
EXTRN	PyCode_New:PROC
EXTRN	PyList_AsTuple:PROC
EXTRN	PyCode_Optimize:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PySequence_List:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$makecode DD imagerel makecode
	DD	imagerel makecode+69
	DD	imagerel $unwind$makecode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$makecode DD imagerel makecode+69
	DD	imagerel makecode+608
	DD	imagerel $chain$1$makecode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$makecode DD imagerel makecode+608
	DD	imagerel makecode+831
	DD	imagerel $chain$2$makecode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$makecode DD imagerel makecode+831
	DD	imagerel makecode+1164
	DD	imagerel $chain$3$makecode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$makecode DD 021H
	DD	imagerel makecode
	DD	imagerel makecode+69
	DD	imagerel $unwind$makecode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$makecode DD 020021H
	DD	013f400H
	DD	imagerel makecode
	DD	imagerel makecode+69
	DD	imagerel $unwind$makecode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$makecode DD 041021H
	DD	013f410H
	DD	0145408H
	DD	imagerel makecode
	DD	imagerel makecode+69
	DD	imagerel $unwind$makecode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$makecode DD 081a01H
	DD	015011aH
	DD	0d011e013H
	DD	0700dc00fH
	DD	0300b600cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT makecode
_TEXT	SEGMENT
tv133 = 128
c$ = 224
a$ = 232
flags$1$ = 240
tmp$2$ = 248
makecode PROC						; COMDAT

; 4098 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001a	48 8b f9	 mov	 rdi, rcx

; 4099 :     PyObject *tmp;
; 4100 :     PyCodeObject *co = NULL;
; 4101 :     PyObject *consts = NULL;
; 4102 :     PyObject *names = NULL;
; 4103 :     PyObject *varnames = NULL;
; 4104 :     PyObject *name = NULL;
; 4105 :     PyObject *freevars = NULL;
; 4106 :     PyObject *cellvars = NULL;
; 4107 :     PyObject *bytecode = NULL;
; 4108 :     int nlocals, flags;
; 4109 : 
; 4110 :     tmp = dict_keys_inorder(c->u->u_consts, 0);

  0001d	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00021	33 db		 xor	 ebx, ebx
  00023	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00027	33 d2		 xor	 edx, edx
  00029	44 8b f3	 mov	 r14d, ebx
  0002c	8b f3		 mov	 esi, ebx
  0002e	44 8b eb	 mov	 r13d, ebx
  00031	e8 00 00 00 00	 call	 dict_keys_inorder
  00036	4c 8b e0	 mov	 r12, rax

; 4111 :     if (!tmp)

  00039	48 85 c0	 test	 rax, rax
  0003c	0f 84 36 04 00
	00		 je	 $LN120@makecode

; 4112 :         goto error;
; 4113 :     consts = PySequence_List(tmp); /* optimize_code requires a list */

  00042	48 8b c8	 mov	 rcx, rax
  00045	48 89 ac 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbp
  0004d	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r15
  00055	e8 00 00 00 00	 call	 PySequence_List

; 4114 :     Py_DECREF(tmp);

  0005a	49 8b cc	 mov	 rcx, r12
  0005d	48 8b e8	 mov	 rbp, rax
  00060	e8 00 00 00 00	 call	 _Py_DecRef

; 4115 : 
; 4116 :     names = dict_keys_inorder(c->u->u_names, 0);

  00065	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00069	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0006d	33 d2		 xor	 edx, edx
  0006f	e8 00 00 00 00	 call	 dict_keys_inorder

; 4117 :     varnames = dict_keys_inorder(c->u->u_varnames, 0);

  00074	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00078	33 d2		 xor	 edx, edx
  0007a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0007e	4c 8b e0	 mov	 r12, rax
  00081	e8 00 00 00 00	 call	 dict_keys_inorder
  00086	4c 8b f8	 mov	 r15, rax

; 4118 :     if (!consts || !names || !varnames)

  00089	48 85 ed	 test	 rbp, rbp
  0008c	0f 84 c1 01 00
	00		 je	 $LN27@makecode
  00092	4d 85 e4	 test	 r12, r12
  00095	0f 84 4e 01 00
	00		 je	 $error$24961
  0009b	48 85 c0	 test	 rax, rax
  0009e	0f 84 45 01 00
	00		 je	 $error$24961

; 4119 :         goto error;
; 4120 : 
; 4121 :     cellvars = dict_keys_inorder(c->u->u_cellvars, 0);

  000a4	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000a8	33 d2		 xor	 edx, edx
  000aa	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000ae	e8 00 00 00 00	 call	 dict_keys_inorder
  000b3	48 8b f0	 mov	 rsi, rax

; 4122 :     if (!cellvars)

  000b6	48 85 c0	 test	 rax, rax
  000b9	0f 84 2a 01 00
	00		 je	 $error$24961

; 4123 :         goto error;
; 4124 :     freevars = dict_keys_inorder(c->u->u_freevars, PyTuple_Size(cellvars));

  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 PyTuple_Size
  000c7	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000cb	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000cf	48 8b d0	 mov	 rdx, rax
  000d2	e8 00 00 00 00	 call	 dict_keys_inorder
  000d7	4c 8b f0	 mov	 r14, rax

; 4125 :     if (!freevars)

  000da	48 85 c0	 test	 rax, rax
  000dd	0f 84 06 01 00
	00		 je	 $error$24961

; 4126 :         goto error;
; 4127 :     nlocals = PyDict_Size(c->u->u_varnames);

  000e3	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  000e7	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000eb	e8 00 00 00 00	 call	 PyDict_Size

; 4128 :     flags = compute_code_flags(c);

  000f0	48 8b cf	 mov	 rcx, rdi
  000f3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  000fb	e8 00 00 00 00	 call	 compute_code_flags
  00100	89 84 24 f0 00
	00 00		 mov	 DWORD PTR flags$1$[rsp], eax

; 4129 :     if (flags < 0)

  00107	85 c0		 test	 eax, eax
  00109	0f 88 da 00 00
	00		 js	 $error$24961

; 4130 :         goto error;
; 4131 : 
; 4132 :     bytecode = PyCode_Optimize(a->a_bytecode, consts, names, a->a_lnotab);

  0010f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00117	4d 8b c4	 mov	 r8, r12
  0011a	48 8b d5	 mov	 rdx, rbp
  0011d	4c 8b 48 18	 mov	 r9, QWORD PTR [rax+24]
  00121	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00124	e8 00 00 00 00	 call	 PyCode_Optimize
  00129	4c 8b e8	 mov	 r13, rax

; 4133 :     if (!bytecode)

  0012c	48 85 c0	 test	 rax, rax
  0012f	0f 84 b4 00 00
	00		 je	 $error$24961

; 4134 :         goto error;
; 4135 : 
; 4136 :     tmp = PyList_AsTuple(consts); /* PyCode_New requires a tuple */

  00135	48 8b cd	 mov	 rcx, rbp
  00138	e8 00 00 00 00	 call	 PyList_AsTuple
  0013d	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tmp$2$[rsp], rax

; 4137 :     if (!tmp)

  00145	48 85 c0	 test	 rax, rax
  00148	0f 84 9b 00 00
	00		 je	 $error$24961

; 4138 :         goto error;
; 4139 :     Py_DECREF(consts);

  0014e	48 8b cd	 mov	 rcx, rbp
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 4140 :     consts = tmp;
; 4141 : 
; 4142 :     co = PyCode_New(c->u->u_argcount, c->u->u_kwonlyargcount,
; 4143 :                     nlocals, stackdepth(c), flags,
; 4144 :                     bytecode, consts, names, varnames,
; 4145 :                     freevars, cellvars,
; 4146 :                     c->c_filename_obj, c->u->u_name,
; 4147 :                     c->u->u_firstlineno,
; 4148 :                     a->a_lnotab);

  00156	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0015e	48 8b ac 24 f8
	00 00 00	 mov	 rbp, QWORD PTR tmp$2$[rsp]
  00166	48 8b 5f 38	 mov	 rbx, QWORD PTR [rdi+56]
  0016a	e8 00 00 00 00	 call	 stackdepth
  0016f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00177	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR tv133[rsp]
  0017f	8b 4b 50	 mov	 ecx, DWORD PTR [rbx+80]
  00182	44 8b c8	 mov	 r9d, eax
  00185	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  00189	8b 53 54	 mov	 edx, DWORD PTR [rbx+84]
  0018c	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00191	8b 83 b0 01 00
	00		 mov	 eax, DWORD PTR [rbx+432]
  00197	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0019b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0019f	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  001a4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001ac	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001b0	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  001b5	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  001ba	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14
  001bf	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  001c4	48 8b c5	 mov	 rax, rbp
  001c7	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  001cc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001d1	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR flags$1$[rsp]
  001d8	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  001dd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e1	e8 00 00 00 00	 call	 PyCode_New
  001e6	48 8b d8	 mov	 rbx, rax
$error$24961:

; 4149 :  error:
; 4150 :     Py_XDECREF(consts);

  001e9	48 85 ed	 test	 rbp, rbp
  001ec	74 65		 je	 SHORT $LN27@makecode
  001ee	e8 00 00 00 00	 call	 _Py_PXCTX
  001f3	85 c0		 test	 eax, eax
  001f5	75 5c		 jne	 SHORT $LN27@makecode
  001f7	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001fb	a8 20		 test	 al, 32			; 00000020H
  001fd	75 4c		 jne	 SHORT $LN43@makecode
  001ff	84 c0		 test	 al, al
  00201	78 48		 js	 SHORT $LN43@makecode
  00203	a8 02		 test	 al, 2
  00205	75 4c		 jne	 SHORT $LN27@makecode
  00207	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  0020b	75 46		 jne	 SHORT $LN27@makecode
  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0021b	4c 8b cd	 mov	 r9, rbp
  0021e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00224	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0022c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00231	48 8b cd	 mov	 rcx, rbp
  00234	85 c0		 test	 eax, eax
  00236	74 07		 je	 SHORT $LN48@makecode
  00238	e8 00 00 00 00	 call	 _Px_Dealloc
  0023d	eb 14		 jmp	 SHORT $LN27@makecode
$LN48@makecode:
  0023f	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00243	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00249	eb 08		 jmp	 SHORT $LN27@makecode
$LN43@makecode:
  0024b	48 8b cd	 mov	 rcx, rbp
  0024e	e8 00 00 00 00	 call	 Px_DecRef
$LN27@makecode:

; 4151 :     Py_XDECREF(names);

  00253	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  0025b	4d 85 e4	 test	 r12, r12
  0025e	74 68		 je	 SHORT $LN23@makecode
  00260	e8 00 00 00 00	 call	 _Py_PXCTX
  00265	85 c0		 test	 eax, eax
  00267	75 5f		 jne	 SHORT $LN23@makecode
  00269	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0026e	a8 20		 test	 al, 32			; 00000020H
  00270	75 4e		 jne	 SHORT $LN54@makecode
  00272	84 c0		 test	 al, al
  00274	78 4a		 js	 SHORT $LN54@makecode
  00276	a8 02		 test	 al, 2
  00278	75 4e		 jne	 SHORT $LN23@makecode
  0027a	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0027f	75 47		 jne	 SHORT $LN23@makecode
  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0028f	4d 8b cc	 mov	 r9, r12
  00292	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00298	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a5	49 8b cc	 mov	 rcx, r12
  002a8	85 c0		 test	 eax, eax
  002aa	74 07		 je	 SHORT $LN59@makecode
  002ac	e8 00 00 00 00	 call	 _Px_Dealloc
  002b1	eb 15		 jmp	 SHORT $LN23@makecode
$LN59@makecode:
  002b3	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  002b8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002be	eb 08		 jmp	 SHORT $LN23@makecode
$LN54@makecode:
  002c0	49 8b cc	 mov	 rcx, r12
  002c3	e8 00 00 00 00	 call	 Px_DecRef
$LN23@makecode:

; 4152 :     Py_XDECREF(varnames);

  002c8	4d 85 ff	 test	 r15, r15
  002cb	74 65		 je	 SHORT $LN15@makecode
  002cd	e8 00 00 00 00	 call	 _Py_PXCTX
  002d2	85 c0		 test	 eax, eax
  002d4	75 5c		 jne	 SHORT $LN15@makecode
  002d6	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  002da	a8 20		 test	 al, 32			; 00000020H
  002dc	75 4c		 jne	 SHORT $LN65@makecode
  002de	84 c0		 test	 al, al
  002e0	78 48		 js	 SHORT $LN65@makecode
  002e2	a8 02		 test	 al, 2
  002e4	75 4c		 jne	 SHORT $LN15@makecode
  002e6	49 ff 4f 50	 dec	 QWORD PTR [r15+80]
  002ea	75 46		 jne	 SHORT $LN15@makecode
  002ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002fa	4d 8b cf	 mov	 r9, r15
  002fd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00303	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0030b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00310	49 8b cf	 mov	 rcx, r15
  00313	85 c0		 test	 eax, eax
  00315	74 07		 je	 SHORT $LN70@makecode
  00317	e8 00 00 00 00	 call	 _Px_Dealloc
  0031c	eb 14		 jmp	 SHORT $LN15@makecode
$LN70@makecode:
  0031e	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  00322	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00328	eb 08		 jmp	 SHORT $LN15@makecode
$LN65@makecode:
  0032a	49 8b cf	 mov	 rcx, r15
  0032d	e8 00 00 00 00	 call	 Px_DecRef
$LN15@makecode:

; 4153 :     Py_XDECREF(name);
; 4154 :     Py_XDECREF(freevars);

  00332	4c 8b bc 24 98
	00 00 00	 mov	 r15, QWORD PTR [rsp+152]
  0033a	4d 85 f6	 test	 r14, r14
  0033d	74 65		 je	 SHORT $LN11@makecode
  0033f	e8 00 00 00 00	 call	 _Py_PXCTX
  00344	85 c0		 test	 eax, eax
  00346	75 5c		 jne	 SHORT $LN11@makecode
  00348	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  0034c	a8 20		 test	 al, 32			; 00000020H
  0034e	75 4c		 jne	 SHORT $LN87@makecode
  00350	84 c0		 test	 al, al
  00352	78 48		 js	 SHORT $LN87@makecode
  00354	a8 02		 test	 al, 2
  00356	75 4c		 jne	 SHORT $LN11@makecode
  00358	49 ff 4e 50	 dec	 QWORD PTR [r14+80]
  0035c	75 46		 jne	 SHORT $LN11@makecode
  0035e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00365	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0036c	4d 8b ce	 mov	 r9, r14
  0036f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00375	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0037d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00382	49 8b ce	 mov	 rcx, r14
  00385	85 c0		 test	 eax, eax
  00387	74 07		 je	 SHORT $LN92@makecode
  00389	e8 00 00 00 00	 call	 _Px_Dealloc
  0038e	eb 14		 jmp	 SHORT $LN11@makecode
$LN92@makecode:
  00390	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00394	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0039a	eb 08		 jmp	 SHORT $LN11@makecode
$LN87@makecode:
  0039c	49 8b ce	 mov	 rcx, r14
  0039f	e8 00 00 00 00	 call	 Px_DecRef
$LN11@makecode:

; 4155 :     Py_XDECREF(cellvars);

  003a4	48 85 f6	 test	 rsi, rsi
  003a7	74 65		 je	 SHORT $LN7@makecode
  003a9	e8 00 00 00 00	 call	 _Py_PXCTX
  003ae	85 c0		 test	 eax, eax
  003b0	75 5c		 jne	 SHORT $LN7@makecode
  003b2	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  003b6	a8 20		 test	 al, 32			; 00000020H
  003b8	75 4c		 jne	 SHORT $LN98@makecode
  003ba	84 c0		 test	 al, al
  003bc	78 48		 js	 SHORT $LN98@makecode
  003be	a8 02		 test	 al, 2
  003c0	75 4c		 jne	 SHORT $LN7@makecode
  003c2	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  003c6	75 46		 jne	 SHORT $LN7@makecode
  003c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003d6	4c 8b ce	 mov	 r9, rsi
  003d9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003df	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  003ec	48 8b ce	 mov	 rcx, rsi
  003ef	85 c0		 test	 eax, eax
  003f1	74 07		 je	 SHORT $LN103@makecode
  003f3	e8 00 00 00 00	 call	 _Px_Dealloc
  003f8	eb 14		 jmp	 SHORT $LN7@makecode
$LN103@makecode:
  003fa	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  003fe	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00404	eb 08		 jmp	 SHORT $LN7@makecode
$LN98@makecode:
  00406	48 8b ce	 mov	 rcx, rsi
  00409	e8 00 00 00 00	 call	 Px_DecRef
$LN7@makecode:

; 4156 :     Py_XDECREF(bytecode);

  0040e	4d 85 ed	 test	 r13, r13
  00411	74 65		 je	 SHORT $LN120@makecode
  00413	e8 00 00 00 00	 call	 _Py_PXCTX
  00418	85 c0		 test	 eax, eax
  0041a	75 5c		 jne	 SHORT $LN120@makecode
  0041c	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00420	a8 20		 test	 al, 32			; 00000020H
  00422	75 4c		 jne	 SHORT $LN109@makecode
  00424	84 c0		 test	 al, al
  00426	78 48		 js	 SHORT $LN109@makecode
  00428	a8 02		 test	 al, 2
  0042a	75 4c		 jne	 SHORT $LN120@makecode
  0042c	49 ff 4d 50	 dec	 QWORD PTR [r13+80]
  00430	75 46		 jne	 SHORT $LN120@makecode
  00432	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00440	4d 8b cd	 mov	 r9, r13
  00443	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00449	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00451	e8 00 00 00 00	 call	 _PyParallel_Guard
  00456	49 8b cd	 mov	 rcx, r13
  00459	85 c0		 test	 eax, eax
  0045b	74 07		 je	 SHORT $LN114@makecode
  0045d	e8 00 00 00 00	 call	 _Px_Dealloc
  00462	eb 14		 jmp	 SHORT $LN120@makecode
$LN114@makecode:
  00464	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00468	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0046e	eb 08		 jmp	 SHORT $LN120@makecode
$LN109@makecode:
  00470	49 8b cd	 mov	 rcx, r13
  00473	e8 00 00 00 00	 call	 Px_DecRef
$LN120@makecode:

; 4157 :     return co;

  00478	48 8b c3	 mov	 rax, rbx

; 4158 : }

  0047b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00482	41 5e		 pop	 r14
  00484	41 5d		 pop	 r13
  00486	41 5c		 pop	 r12
  00488	5f		 pop	 rdi
  00489	5e		 pop	 rsi
  0048a	5b		 pop	 rbx
  0048b	c3		 ret	 0
makecode ENDP
_TEXT	ENDS
EXTRN	PyCapsule_New:PROC
EXTRN	PySymtable_Lookup:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_enter_scope DD imagerel compiler_enter_scope
	DD	imagerel compiler_enter_scope+492
	DD	imagerel $unwind$compiler_enter_scope
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_enter_scope DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT compiler_enter_scope
_TEXT	SEGMENT
c$ = 64
name$ = 72
scope_type$ = 80
key$ = 88
lineno$ = 96
compiler_enter_scope PROC				; COMDAT

; 512  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 513  :     struct compiler_unit *u;
; 514  : 
; 515  :     u = (struct compiler_unit *)PyObject_Malloc(sizeof(
; 516  :                                             struct compiler_unit));

  0001d	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  00022	4d 8b e1	 mov	 r12, r9
  00025	41 8b f8	 mov	 edi, r8d
  00028	48 8b ea	 mov	 rbp, rdx
  0002b	e8 00 00 00 00	 call	 PyObject_Malloc
  00030	48 8b d8	 mov	 rbx, rax

; 517  :     if (!u) {

  00033	48 85 c0	 test	 rax, rax
  00036	75 0a		 jne	 SHORT $LN19@compiler_e@3

; 518  :         PyErr_NoMemory();

  00038	e8 00 00 00 00	 call	 PyErr_NoMemory

; 519  :         return 0;

  0003d	e9 8d 01 00 00	 jmp	 $LN26@compiler_e@3
$LN19@compiler_e@3:

; 520  :     }
; 521  :     memset(u, 0, sizeof(struct compiler_unit));

  00042	33 d2		 xor	 edx, edx
  00044	41 b8 c0 01 00
	00		 mov	 r8d, 448		; 000001c0H
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memset

; 522  :     u->u_scope_type = scope_type;

  00052	89 7b 18	 mov	 DWORD PTR [rbx+24], edi

; 523  :     u->u_argcount = 0;

  00055	33 ff		 xor	 edi, edi
  00057	48 89 7b 50	 mov	 QWORD PTR [rbx+80], rdi

; 524  :     u->u_kwonlyargcount = 0;
; 525  :     u->u_ste = PySymtable_Lookup(c->c_st, key);

  0005b	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  0005f	49 8b d4	 mov	 rdx, r12
  00062	e8 00 00 00 00	 call	 PySymtable_Lookup
  00067	48 89 03	 mov	 QWORD PTR [rbx], rax

; 526  :     if (!u->u_ste) {

  0006a	48 85 c0	 test	 rax, rax

; 527  :         compiler_unit_free(u);
; 528  :         return 0;

  0006d	0f 84 54 01 00
	00		 je	 $LN16@compiler_e@3

; 529  :     }
; 530  :     Py_INCREF(name);

  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	75 32		 jne	 SHORT $LN23@compiler_e@3
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008a	4c 8b cd	 mov	 r9, rbp
  0008d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00093	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009b	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a0	85 c0		 test	 eax, eax
  000a2	75 06		 jne	 SHORT $LN22@compiler_e@3
  000a4	f6 45 20 20	 test	 BYTE PTR [rbp+32], 32	; 00000020H
  000a8	74 04		 je	 SHORT $LN23@compiler_e@3
$LN22@compiler_e@3:
  000aa	48 ff 45 50	 inc	 QWORD PTR [rbp+80]
$LN23@compiler_e@3:

; 531  :     u->u_name = name;
; 532  :     u->u_varnames = list2dict(u->u_ste->ste_varnames);

  000ae	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000b1	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp
  000b5	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  000b9	e8 00 00 00 00	 call	 list2dict

; 533  :     u->u_cellvars = dictbytype(u->u_ste->ste_symbols, CELL, 0, 0);

  000be	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c1	45 33 c9	 xor	 r9d, r9d
  000c4	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  000c8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000cc	41 8d 51 05	 lea	 edx, QWORD PTR [r9+5]
  000d0	45 33 c0	 xor	 r8d, r8d
  000d3	e8 00 00 00 00	 call	 dictbytype
  000d8	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 534  :     if (!u->u_varnames || !u->u_cellvars) {

  000dc	48 39 7b 30	 cmp	 QWORD PTR [rbx+48], rdi
  000e0	0f 84 e1 00 00
	00		 je	 $LN16@compiler_e@3
  000e6	48 85 c0	 test	 rax, rax
  000e9	0f 84 d8 00 00
	00		 je	 $LN16@compiler_e@3

; 537  :     }
; 538  : 
; 539  :     u->u_freevars = dictbytype(u->u_ste->ste_symbols, FREE, DEF_FREE_CLASS,
; 540  :                                PyDict_Size(u->u_cellvars));

  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 PyDict_Size
  000f7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000fa	ba 04 00 00 00	 mov	 edx, 4
  000ff	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00103	44 8d 42 3c	 lea	 r8d, QWORD PTR [rdx+60]
  00107	4c 8b c8	 mov	 r9, rax
  0010a	e8 00 00 00 00	 call	 dictbytype
  0010f	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 541  :     if (!u->u_freevars) {

  00113	48 85 c0	 test	 rax, rax

; 542  :         compiler_unit_free(u);
; 543  :         return 0;

  00116	0f 84 ab 00 00
	00		 je	 $LN16@compiler_e@3

; 544  :     }
; 545  : 
; 546  :     u->u_blocks = NULL;
; 547  :     u->u_nfblocks = 0;
; 548  :     u->u_firstlineno = lineno;

  0011c	8b 44 24 60	 mov	 eax, DWORD PTR lineno$[rsp]
  00120	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00124	89 7b 68	 mov	 DWORD PTR [rbx+104], edi

; 549  :     u->u_lineno = 0;

  00127	48 89 bb b4 01
	00 00		 mov	 QWORD PTR [rbx+436], rdi

; 550  :     u->u_col_offset = 0;
; 551  :     u->u_lineno_set = 0;

  0012e	89 bb bc 01 00
	00		 mov	 DWORD PTR [rbx+444], edi
  00134	89 83 b0 01 00
	00		 mov	 DWORD PTR [rbx+432], eax

; 552  :     u->u_consts = PyDict_New();

  0013a	e8 00 00 00 00	 call	 PyDict_New
  0013f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 553  :     if (!u->u_consts) {

  00143	48 85 c0	 test	 rax, rax

; 554  :         compiler_unit_free(u);
; 555  :         return 0;

  00146	74 7f		 je	 SHORT $LN16@compiler_e@3

; 556  :     }
; 557  :     u->u_names = PyDict_New();

  00148	e8 00 00 00 00	 call	 PyDict_New
  0014d	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 558  :     if (!u->u_names) {

  00151	48 85 c0	 test	 rax, rax

; 559  :         compiler_unit_free(u);
; 560  :         return 0;

  00154	74 71		 je	 SHORT $LN16@compiler_e@3

; 561  :     }
; 562  : 
; 563  :     u->u_private = NULL;

  00156	48 89 7b 48	 mov	 QWORD PTR [rbx+72], rdi

; 564  : 
; 565  :     /* Push the old compiler_unit on the stack. */
; 566  :     if (c->u) {

  0015a	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0015e	48 85 c9	 test	 rcx, rcx
  00161	74 45		 je	 SHORT $LN3@compiler_e@3

; 567  :         PyObject *capsule = PyCapsule_New(c->u, COMPILER_CAPSULE_NAME_COMPILER_UNIT, NULL);

  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JJFPLBCE@compile?4c?5compiler?5unit?$AA@
  0016a	45 33 c0	 xor	 r8d, r8d
  0016d	e8 00 00 00 00	 call	 PyCapsule_New
  00172	48 8b e8	 mov	 rbp, rax

; 568  :         if (!capsule || PyList_Append(c->c_stack, capsule) < 0) {

  00175	48 85 c0	 test	 rax, rax
  00178	74 4d		 je	 SHORT $LN16@compiler_e@3
  0017a	48 8b 4e 40	 mov	 rcx, QWORD PTR [rsi+64]
  0017e	48 8b d0	 mov	 rdx, rax
  00181	e8 00 00 00 00	 call	 PyList_Append

; 570  :             compiler_unit_free(u);
; 571  :             return 0;
; 572  :         }
; 573  :         Py_DECREF(capsule);

  00186	48 8b cd	 mov	 rcx, rbp
  00189	85 c0		 test	 eax, eax
  0018b	78 35		 js	 SHORT $LN9@compiler_e@3
  0018d	e8 00 00 00 00	 call	 _Py_DecRef

; 574  :         u->u_private = c->u->u_private;

  00192	4c 8b 5e 38	 mov	 r11, QWORD PTR [rsi+56]
  00196	49 8b 4b 48	 mov	 rcx, QWORD PTR [r11+72]
  0019a	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx

; 575  :         Py_XINCREF(u->u_private);

  0019e	48 85 c9	 test	 rcx, rcx
  001a1	74 05		 je	 SHORT $LN3@compiler_e@3
  001a3	e8 00 00 00 00	 call	 _Py_IncRef
$LN3@compiler_e@3:

; 576  :     }
; 577  :     c->u = u;
; 578  : 
; 579  :     c->c_nestlevel++;

  001a8	ff 46 30	 inc	 DWORD PTR [rsi+48]

; 580  :     if (compiler_use_new_block(c) == NULL)

  001ab	48 8b ce	 mov	 rcx, rsi
  001ae	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
  001b2	e8 00 00 00 00	 call	 compiler_use_new_block
  001b7	48 85 c0	 test	 rax, rax
  001ba	40 0f 95 c7	 setne	 dil
  001be	8b c7		 mov	 eax, edi

; 581  :         return 0;
; 582  : 
; 583  :     return 1;

  001c0	eb 0f		 jmp	 SHORT $LN20@compiler_e@3
$LN9@compiler_e@3:

; 569  :             Py_XDECREF(capsule);

  001c2	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@compiler_e@3:

; 535  :         compiler_unit_free(u);

  001c7	48 8b cb	 mov	 rcx, rbx
  001ca	e8 00 00 00 00	 call	 compiler_unit_free
$LN26@compiler_e@3:

; 536  :         return 0;

  001cf	33 c0		 xor	 eax, eax
$LN20@compiler_e@3:

; 584  : }

  001d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001d6	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001db	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001e0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e9	41 5c		 pop	 r12
  001eb	c3		 ret	 0
compiler_enter_scope ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_o DD imagerel compiler_addop_o
	DD	imagerel compiler_addop_o+66
	DD	imagerel $unwind$compiler_addop_o
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_o DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_addop_o
_TEXT	SEGMENT
c$ = 48
opcode$ = 56
dict$ = 64
o$ = 72
compiler_addop_o PROC					; COMDAT

; 1084 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f9	 mov	 rdi, rcx

; 1085 :     int arg = compiler_add_o(c, dict, o);

  0000f	49 8b d1	 mov	 rdx, r9
  00012	49 8b c8	 mov	 rcx, r8
  00015	e8 00 00 00 00	 call	 compiler_add_o

; 1086 :     if (arg < 0)

  0001a	85 c0		 test	 eax, eax
  0001c	79 0d		 jns	 SHORT $LN1@compiler_a@5

; 1087 :         return 0;

  0001e	33 c0		 xor	 eax, eax

; 1089 : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@compiler_a@5:

; 1088 :     return compiler_addop_i(c, opcode, arg);

  0002b	44 8b c0	 mov	 r8d, eax
  0002e	8b d3		 mov	 edx, ebx
  00030	48 8b cf	 mov	 rcx, rdi

; 1089 : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	e9 00 00 00 00	 jmp	 compiler_addop_i
compiler_addop_o ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_addop_name DD imagerel compiler_addop_name
	DD	imagerel compiler_addop_name+115
	DD	imagerel $unwind$compiler_addop_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_addop_name DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_addop_name
_TEXT	SEGMENT
c$ = 48
opcode$ = 56
dict$ = 64
o$ = 72
compiler_addop_name PROC				; COMDAT

; 1094 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f1	 mov	 rsi, rcx

; 1095 :     int arg;
; 1096 :     PyObject *mangled = _Py_Mangle(c->u->u_private, o);

  00017	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0001b	8b ea		 mov	 ebp, edx
  0001d	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00021	49 8b d1	 mov	 rdx, r9
  00024	49 8b d8	 mov	 rbx, r8
  00027	e8 00 00 00 00	 call	 _Py_Mangle
  0002c	48 8b f8	 mov	 rdi, rax

; 1097 :     if (!mangled)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 04		 jne	 SHORT $LN2@compiler_a@6
$LN5@compiler_a@6:

; 1098 :         return 0;

  00034	33 c0		 xor	 eax, eax
  00036	eb 26		 jmp	 SHORT $LN3@compiler_a@6
$LN2@compiler_a@6:

; 1099 :     arg = compiler_add_o(c, dict, mangled);

  00038	48 8b d0	 mov	 rdx, rax
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 compiler_add_o

; 1100 :     Py_DECREF(mangled);

  00043	48 8b cf	 mov	 rcx, rdi
  00046	8b d8		 mov	 ebx, eax
  00048	e8 00 00 00 00	 call	 _Py_DecRef

; 1101 :     if (arg < 0)

  0004d	85 db		 test	 ebx, ebx

; 1102 :         return 0;

  0004f	78 e3		 js	 SHORT $LN5@compiler_a@6

; 1103 :     return compiler_addop_i(c, opcode, arg);

  00051	44 8b c3	 mov	 r8d, ebx
  00054	8b d5		 mov	 edx, ebp
  00056	48 8b ce	 mov	 rcx, rsi
  00059	e8 00 00 00 00	 call	 compiler_addop_i
$LN3@compiler_a@6:

; 1104 : }

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00068	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
compiler_addop_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_make_closure DD imagerel compiler_make_closure
	DD	imagerel compiler_make_closure+629
	DD	imagerel $unwind$compiler_make_closure
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_make_closure DD 0dc401H
	DD	0af4c4H
	DD	0be4bcH
	DD	0cd4b7H
	DD	01264b2H
	DD	0c014c218H
	DD	050117012H
	DD	03010H
xdata	ENDS
;	COMDAT ??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@ DB 'compiler_make_c'
	DB	'losure()', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@
CONST	SEGMENT
??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@ DB 'l'
	DB	'ookup %s in %s %d %d', 0aH, 'freevars of %s: %s', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_make_closure
_TEXT	SEGMENT
reftype$1$ = 64
free$1$ = 68
$T26964 = 72
c$ = 144
co$ = 152
args$ = 160
qualname$ = 168
compiler_make_closure PROC				; COMDAT

; 1369 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  00007	45 89 43 18	 mov	 DWORD PTR [r11+24], r8d
  0000b	49 89 53 10	 mov	 QWORD PTR [r11+16], rdx
  0000f	53		 push	 rbx
  00010	55		 push	 rbp
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1370 :     int i, free = PyCode_GetNumFree(co);

  00018	48 8b 82 98 00
	00 00		 mov	 rax, QWORD PTR [rdx+152]
  0001f	49 8b d9	 mov	 rbx, r9
  00022	41 8b e8	 mov	 ebp, r8d
  00025	48 63 40 60	 movsxd	 rax, DWORD PTR [rax+96]
  00029	48 8b fa	 mov	 rdi, rdx
  0002c	4c 8b e1	 mov	 r12, rcx
  0002f	89 44 24 44	 mov	 DWORD PTR free$1$[rsp], eax

; 1371 :     if (qualname == NULL)

  00033	4d 85 c9	 test	 r9, r9
  00036	75 0b		 jne	 SHORT $LN16@compiler_m

; 1372 :         qualname = co->co_name;

  00038	48 8b 9a b8 00
	00 00		 mov	 rbx, QWORD PTR [rdx+184]
  0003f	49 89 5b 20	 mov	 QWORD PTR [r11+32], rbx
$LN16@compiler_m:

; 1373 : 
; 1374 :     if (free == 0) {

  00043	85 c0		 test	 eax, eax
  00045	75 63		 jne	 SHORT $LN15@compiler_m

; 1375 :         ADDOP_O(c, LOAD_CONST, (PyObject*)co, consts);

  00047	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0004b	4c 8b ca	 mov	 r9, rdx
  0004e	8d 50 64	 lea	 edx, QWORD PTR [rax+100]
  00051	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00055	e8 00 00 00 00	 call	 compiler_addop_o
  0005a	85 c0		 test	 eax, eax
  0005c	75 0c		 jne	 SHORT $LN14@compiler_m
$LN28@compiler_m:
  0005e	33 c0		 xor	 eax, eax

; 1415 :     return 1;
; 1416 : }

  00060	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00064	41 5c		 pop	 r12
  00066	5f		 pop	 rdi
  00067	5d		 pop	 rbp
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN14@compiler_m:

; 1376 :         ADDOP_O(c, LOAD_CONST, qualname, consts);

  0006a	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  0006f	4c 8b cb	 mov	 r9, rbx
  00072	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00077	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0007b	49 8b cc	 mov	 rcx, r12
  0007e	e8 00 00 00 00	 call	 compiler_addop_o
  00083	85 c0		 test	 eax, eax
  00085	74 d7		 je	 SHORT $LN28@compiler_m

; 1377 :         ADDOP_I(c, MAKE_FUNCTION, args);

  00087	44 8b c5	 mov	 r8d, ebp
  0008a	ba 84 00 00 00	 mov	 edx, 132		; 00000084H
  0008f	49 8b cc	 mov	 rcx, r12
  00092	e8 00 00 00 00	 call	 compiler_addop_i
  00097	33 c9		 xor	 ecx, ecx
  00099	85 c0		 test	 eax, eax
  0009b	0f 95 c1	 setne	 cl
  0009e	8b c1		 mov	 eax, ecx

; 1415 :     return 1;
; 1416 : }

  000a0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000a4	41 5c		 pop	 r12
  000a6	5f		 pop	 rdi
  000a7	5d		 pop	 rbp
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
$LN15@compiler_m:
  000aa	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi
  000b2	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  000b7	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14

; 1378 :         return 1;
; 1379 :     }
; 1380 :     for (i = 0; i < free; ++i) {

  000bc	45 33 f6	 xor	 r14d, r14d
  000bf	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  000c4	48 8b f0	 mov	 rsi, rax
  000c7	48 89 44 24 48	 mov	 QWORD PTR $T26964[rsp], rax
  000cc	85 c0		 test	 eax, eax
  000ce	0f 8e 0d 01 00
	00		 jle	 $LN9@compiler_m
  000d4	41 bf 70 00 00
	00		 mov	 r15d, 112		; 00000070H
  000da	66 0f 1f 44 00
	00		 npad	 6
$LL11@compiler_m:

; 1381 :         /* Bypass com_addop_varname because it will generate
; 1382 :            LOAD_DEREF but LOAD_CLOSURE is needed.
; 1383 :         */
; 1384 :         PyObject *name = PyTuple_GET_ITEM(co->co_freevars, i);

  000e0	48 8b 87 98 00
	00 00		 mov	 rax, QWORD PTR [rdi+152]

; 1385 :         int arg, reftype;
; 1386 : 
; 1387 :         /* Special case: If a class contains a method with a
; 1388 :            free variable that has the same name as a method,
; 1389 :            the name will be considered free *and* local in the
; 1390 :            class.  It should be handled by the closure, as
; 1391 :            well as by the normal name loookup logic.
; 1392 :         */
; 1393 :         reftype = get_ref_type(c, name);

  000e7	49 8b cc	 mov	 rcx, r12
  000ea	49 8b 1c 07	 mov	 rbx, QWORD PTR [r15+rax]
  000ee	48 8b d3	 mov	 rdx, rbx
  000f1	e8 00 00 00 00	 call	 get_ref_type

; 1394 :         if (reftype == CELL)
; 1395 :             arg = compiler_lookup_arg(c->u->u_cellvars, name);

  000f6	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  000fb	48 8b d3	 mov	 rdx, rbx
  000fe	89 44 24 40	 mov	 DWORD PTR reftype$1$[rsp], eax
  00102	83 f8 05	 cmp	 eax, 5
  00105	75 06		 jne	 SHORT $LN8@compiler_m
  00107	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]

; 1396 :         else /* (reftype == FREE) */

  0010b	eb 04		 jmp	 SHORT $LN26@compiler_m
$LN8@compiler_m:

; 1397 :             arg = compiler_lookup_arg(c->u->u_freevars, name);

  0010d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
$LN26@compiler_m:
  00111	e8 00 00 00 00	 call	 compiler_lookup_arg
  00116	44 8b e8	 mov	 r13d, eax

; 1398 :         if (arg == -1) {

  00119	83 f8 ff	 cmp	 eax, -1
  0011c	0f 85 90 00 00
	00		 jne	 $LN6@compiler_m

; 1399 :             fprintf(stderr,
; 1400 :                 "lookup %s in %s %d %d\n"
; 1401 :                 "freevars of %s: %s\n",
; 1402 :                 PyObject_REPR(name),
; 1403 :                 PyBytes_AS_STRING(c->u->u_name),
; 1404 :                 reftype, arg,
; 1405 :                 _PyUnicode_AsString(co->co_name),
; 1406 :                 PyObject_REPR(co->co_freevars));

  00122	48 8b 8f 98 00
	00 00		 mov	 rcx, QWORD PTR [rdi+152]
  00129	e8 00 00 00 00	 call	 PyObject_Repr
  0012e	48 8b c8	 mov	 rcx, rax
  00131	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00136	48 8b 8f b8 00
	00 00		 mov	 rcx, QWORD PTR [rdi+184]
  0013d	48 8b e8	 mov	 rbp, rax
  00140	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00145	49 8b 54 24 38	 mov	 rdx, QWORD PTR [r12+56]
  0014a	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  0014e	48 8b cb	 mov	 rcx, rbx
  00151	48 8b f8	 mov	 rdi, rax
  00154	e8 00 00 00 00	 call	 PyObject_Repr
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00161	48 8b d8	 mov	 rbx, rax
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0016a	8b 4c 24 40	 mov	 ecx, DWORD PTR reftype$1$[rsp]
  0016e	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00173	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00178	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  0017d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00181	4c 8d 4e 78	 lea	 r9, QWORD PTR [rsi+120]
  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@EEBFFKMB@lookup?5?$CFs?5in?5?$CFs?5?$CFd?5?$CFd?6freevars?5o@
  0018c	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00190	4c 8b c3	 mov	 r8, rbx
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1407 :             Py_FatalError("compiler_make_closure()");

  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@HDJKJIHM@compiler_make_closure?$CI?$CJ?$AA@
  001a0	e8 00 00 00 00	 call	 Py_FatalError
  001a5	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR co$[rsp]
  001ad	48 8b 74 24 48	 mov	 rsi, QWORD PTR $T26964[rsp]
$LN6@compiler_m:

; 1408 :         }
; 1409 :         ADDOP_I(c, LOAD_CLOSURE, arg);

  001b2	45 8b c5	 mov	 r8d, r13d
  001b5	ba 87 00 00 00	 mov	 edx, 135		; 00000087H
  001ba	49 8b cc	 mov	 rcx, r12
  001bd	e8 00 00 00 00	 call	 compiler_addop_i
  001c2	85 c0		 test	 eax, eax
  001c4	74 6e		 je	 SHORT $LN27@compiler_m

; 1378 :         return 1;
; 1379 :     }
; 1380 :     for (i = 0; i < free; ++i) {

  001c6	49 ff c6	 inc	 r14
  001c9	49 83 c7 08	 add	 r15, 8
  001cd	4c 3b f6	 cmp	 r14, rsi
  001d0	0f 8c 0a ff ff
	ff		 jl	 $LL11@compiler_m

; 1408 :         }
; 1409 :         ADDOP_I(c, LOAD_CLOSURE, arg);

  001d6	8b 44 24 44	 mov	 eax, DWORD PTR free$1$[rsp]
  001da	8b ac 24 a0 00
	00 00		 mov	 ebp, DWORD PTR args$[rsp]
$LN9@compiler_m:

; 1410 :     }
; 1411 :     ADDOP_I(c, BUILD_TUPLE, free);

  001e1	44 8b c0	 mov	 r8d, eax
  001e4	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  001e9	49 8b cc	 mov	 rcx, r12
  001ec	e8 00 00 00 00	 call	 compiler_addop_i
  001f1	85 c0		 test	 eax, eax
  001f3	74 3f		 je	 SHORT $LN27@compiler_m

; 1412 :     ADDOP_O(c, LOAD_CONST, (PyObject*)co, consts);

  001f5	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  001fa	4c 8b cf	 mov	 r9, rdi
  001fd	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00202	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00206	49 8b cc	 mov	 rcx, r12
  00209	e8 00 00 00 00	 call	 compiler_addop_o
  0020e	85 c0		 test	 eax, eax
  00210	74 22		 je	 SHORT $LN27@compiler_m

; 1413 :     ADDOP_O(c, LOAD_CONST, qualname, consts);

  00212	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  00217	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR qualname$[rsp]
  0021f	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00224	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00228	49 8b cc	 mov	 rcx, r12
  0022b	e8 00 00 00 00	 call	 compiler_addop_o
  00230	85 c0		 test	 eax, eax
  00232	75 04		 jne	 SHORT $LN2@compiler_m
$LN27@compiler_m:
  00234	33 c0		 xor	 eax, eax
  00236	eb 1c		 jmp	 SHORT $LN25@compiler_m
$LN2@compiler_m:

; 1414 :     ADDOP_I(c, MAKE_CLOSURE, args);

  00238	44 8b c5	 mov	 r8d, ebp
  0023b	ba 86 00 00 00	 mov	 edx, 134		; 00000086H
  00240	49 8b cc	 mov	 rcx, r12
  00243	e8 00 00 00 00	 call	 compiler_addop_i
  00248	b9 00 00 00 00	 mov	 ecx, 0
  0024d	85 c0		 test	 eax, eax
  0024f	0f 95 c1	 setne	 cl
  00252	8b c1		 mov	 eax, ecx
$LN25@compiler_m:
  00254	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00259	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
  0025e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]
  00266	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 1415 :     return 1;
; 1416 : }

  0026b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0026f	41 5c		 pop	 r12
  00271	5f		 pop	 rdi
  00272	5d		 pop	 rbp
  00273	5b		 pop	 rbx
  00274	c3		 ret	 0
compiler_make_closure ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_kwonlydefaults DD imagerel compiler_visit_kwonlydefaults
	DD	imagerel compiler_visit_kwonlydefaults+205
	DD	imagerel $unwind$compiler_visit_kwonlydefaults
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_kwonlydefaults DD 0c2f01H
	DD	0bd42fH
	DD	0a641dH
	DD	0c3411H
	DD	0f00d3211H
	DD	0c009e00bH
	DD	050067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_visit_kwonlydefaults
_TEXT	SEGMENT
c$ = 80
kwonlyargs$ = 88
kw_defaults$ = 96
compiler_visit_kwonlydefaults PROC			; COMDAT

; 1435 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1436 :     int i, default_count = 0;
; 1437 :     for (i = 0; i < asdl_seq_LEN(kwonlyargs); i++) {

  00011	4c 8b fa	 mov	 r15, rdx
  00014	33 ed		 xor	 ebp, ebp
  00016	33 ff		 xor	 edi, edi
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	4c 8b e2	 mov	 r12, rdx
  00020	4c 8b f1	 mov	 r14, rcx
  00023	4d 2b f8	 sub	 r15, r8
  00026	49 8d 58 08	 lea	 rbx, QWORD PTR [r8+8]
  0002a	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  0002f	90		 npad	 1
$LL7@compiler_v:
  00030	4d 85 e4	 test	 r12, r12
  00033	75 04		 jne	 SHORT $LN10@compiler_v
  00035	33 c9		 xor	 ecx, ecx
  00037	eb 04		 jmp	 SHORT $LN11@compiler_v
$LN10@compiler_v:
  00039	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
$LN11@compiler_v:
  0003d	48 63 c7	 movsxd	 rax, edi
  00040	48 3b c1	 cmp	 rax, rcx
  00043	7d 6a		 jge	 SHORT $LN5@compiler_v

; 1438 :         arg_ty arg = asdl_seq_GET(kwonlyargs, i);
; 1439 :         expr_ty default_ = asdl_seq_GET(kw_defaults, i);

  00045	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
  00048	49 8b 14 1f	 mov	 rdx, QWORD PTR [r15+rbx]

; 1440 :         if (default_) {

  0004c	48 85 f6	 test	 rsi, rsi
  0004f	74 4d		 je	 SHORT $LN6@compiler_v

; 1441 :             PyObject *mangled = _Py_Mangle(c->u->u_private, arg->arg);

  00051	49 8b 4e 38	 mov	 rcx, QWORD PTR [r14+56]
  00055	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00058	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0005c	e8 00 00 00 00	 call	 _Py_Mangle
  00061	4c 8b e8	 mov	 r13, rax

; 1442 :             if (!mangled)

  00064	48 85 c0	 test	 rax, rax
  00067	74 41		 je	 SHORT $LN13@compiler_v

; 1444 :             ADDOP_O(c, LOAD_CONST, mangled, consts);

  00069	4d 8b 46 38	 mov	 r8, QWORD PTR [r14+56]
  0006d	4c 8b c8	 mov	 r9, rax
  00070	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00075	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00079	49 8b ce	 mov	 rcx, r14
  0007c	e8 00 00 00 00	 call	 compiler_addop_o
  00081	85 c0		 test	 eax, eax
  00083	74 21		 je	 SHORT $LN14@compiler_v

; 1445 :             Py_DECREF(mangled);

  00085	49 8b cd	 mov	 rcx, r13
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 1446 :             if (!compiler_visit_expr(c, default_)) {

  0008d	48 8b d6	 mov	 rdx, rsi
  00090	49 8b ce	 mov	 rcx, r14
  00093	e8 00 00 00 00	 call	 compiler_visit_expr
  00098	85 c0		 test	 eax, eax
  0009a	74 0e		 je	 SHORT $LN13@compiler_v

; 1447 :                 return -1;
; 1448 :             }
; 1449 :             default_count++;

  0009c	ff c5		 inc	 ebp
$LN6@compiler_v:

; 1436 :     int i, default_count = 0;
; 1437 :     for (i = 0; i < asdl_seq_LEN(kwonlyargs); i++) {

  0009e	ff c7		 inc	 edi
  000a0	48 83 c3 08	 add	 rbx, 8
  000a4	eb 8a		 jmp	 SHORT $LL7@compiler_v
$LN14@compiler_v:

; 1444 :             ADDOP_O(c, LOAD_CONST, mangled, consts);

  000a6	33 c0		 xor	 eax, eax
  000a8	eb 07		 jmp	 SHORT $LN8@compiler_v
$LN13@compiler_v:

; 1443 :                 return -1;

  000aa	83 c8 ff	 or	 eax, -1
  000ad	eb 02		 jmp	 SHORT $LN8@compiler_v
$LN5@compiler_v:

; 1450 :         }
; 1451 :     }
; 1452 :     return default_count;

  000af	8b c5		 mov	 eax, ebp
$LN8@compiler_v:
  000b1	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
  000b6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]

; 1453 : }

  000bb	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	41 5f		 pop	 r15
  000c6	41 5e		 pop	 r14
  000c8	41 5c		 pop	 r12
  000ca	5f		 pop	 rdi
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
compiler_visit_kwonlydefaults ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_continue DD imagerel compiler_continue
	DD	imagerel compiler_continue+265
	DD	imagerel $unwind$compiler_continue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_continue DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_continue
_TEXT	SEGMENT
c$ = 48
compiler_continue PROC					; COMDAT

; 1966 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1967 :     static const char LOOP_ERROR_MSG[] = "'continue' not properly in loop";
; 1968 :     static const char IN_FINALLY_ERROR_MSG[] =
; 1969 :                     "'continue' not supported inside 'finally' clause";
; 1970 :     int i;
; 1971 : 
; 1972 :     if (!c->u->u_nfblocks)

  00006	48 8b 59 38	 mov	 rbx, QWORD PTR [rcx+56]
  0000a	4c 8b d1	 mov	 r10, rcx
  0000d	83 7b 68 00	 cmp	 DWORD PTR [rbx+104], 0
  00011	75 11		 jne	 SHORT $LN12@compiler_c@3
$LN17@compiler_c@3:

; 1973 :         return compiler_error(c, LOOP_ERROR_MSG);

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?LOOP_ERROR_MSG@?1??compiler_continue@@9@9

; 1996 : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	e9 00 00 00 00	 jmp	 compiler_error
$LN12@compiler_c@3:

; 1974 :     i = c->u->u_nfblocks - 1;

  00024	8b 53 68	 mov	 edx, DWORD PTR [rbx+104]
  00027	ff ca		 dec	 edx

; 1975 :     switch (c->u->u_fblock[i].fb_type) {

  00029	4c 63 da	 movsxd	 r11, edx
  0002c	49 8d 43 07	 lea	 rax, QWORD PTR [r11+7]
  00030	48 03 c0	 add	 rax, rax
  00033	44 8b 04 c3	 mov	 r8d, DWORD PTR [rbx+rax*8]
  00037	45 85 c0	 test	 r8d, r8d
  0003a	0f 84 9d 00 00
	00		 je	 $LN9@compiler_c@3
  00040	0f 8e b8 00 00
	00		 jle	 $LN8@compiler_c@3
  00046	41 83 f8 02	 cmp	 r8d, 2
  0004a	7e 1b		 jle	 SHORT $LN15@compiler_c@3
  0004c	41 83 f8 03	 cmp	 r8d, 3
  00050	0f 85 a8 00 00
	00		 jne	 $LN8@compiler_c@3

; 1990 :         break;
; 1991 :     case FINALLY_END:
; 1992 :         return compiler_error(c, IN_FINALLY_ERROR_MSG);

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9

; 1996 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	e9 00 00 00 00	 jmp	 compiler_error
$LN15@compiler_c@3:

; 1978 :         break;
; 1979 :     case EXCEPT:
; 1980 :     case FINALLY_TRY:
; 1981 :         while (--i >= 0 && c->u->u_fblock[i].fb_type != LOOP) {

  00067	ff ca		 dec	 edx
  00069	48 63 ca	 movsxd	 rcx, edx
  0006c	78 2b		 js	 SHORT $LN5@compiler_c@3
  0006e	48 8d 41 07	 lea	 rax, QWORD PTR [rcx+7]
  00072	48 c1 e0 04	 shl	 rax, 4
  00076	48 03 c3	 add	 rax, rbx
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@compiler_c@3:
  00080	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00083	45 85 c0	 test	 r8d, r8d
  00086	74 11		 je	 SHORT $LN5@compiler_c@3

; 1982 :             /* Prevent continue anywhere under a finally
; 1983 :                   even if hidden in a sub-try or except. */
; 1984 :             if (c->u->u_fblock[i].fb_type == FINALLY_END)

  00088	41 83 f8 03	 cmp	 r8d, 3
  0008c	74 3b		 je	 SHORT $LN16@compiler_c@3

; 1978 :         break;
; 1979 :     case EXCEPT:
; 1980 :     case FINALLY_TRY:
; 1981 :         while (--i >= 0 && c->u->u_fblock[i].fb_type != LOOP) {

  0008e	ff ca		 dec	 edx
  00090	48 83 e8 10	 sub	 rax, 16
  00094	48 ff c9	 dec	 rcx
  00097	79 e7		 jns	 SHORT $LL6@compiler_c@3
$LN5@compiler_c@3:

; 1986 :         }
; 1987 :         if (i == -1)
; 1988 :             return compiler_error(c, LOOP_ERROR_MSG);

  00099	49 8b ca	 mov	 rcx, r10
  0009c	83 fa ff	 cmp	 edx, -1
  0009f	0f 84 6e ff ff
	ff		 je	 $LN17@compiler_c@3

; 1989 :         ADDOP_JABS(c, CONTINUE_LOOP, c->u->u_fblock[i].fb_block);

  000a5	4c 63 c2	 movsxd	 r8, edx
  000a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  000ae	4d 03 c0	 add	 r8, r8
  000b1	41 8d 51 76	 lea	 edx, QWORD PTR [r9+118]
  000b5	4e 8b 44 c3 78	 mov	 r8, QWORD PTR [rbx+r8*8+120]
  000ba	e8 00 00 00 00	 call	 compiler_addop_j
  000bf	85 c0		 test	 eax, eax
  000c1	75 3b		 jne	 SHORT $LN8@compiler_c@3

; 1996 : }

  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5b		 pop	 rbx
  000c8	c3		 ret	 0
$LN16@compiler_c@3:

; 1985 :                 return compiler_error(c, IN_FINALLY_ERROR_MSG);

  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?IN_FINALLY_ERROR_MSG@?1??compiler_continue@@9@9
  000d0	49 8b ca	 mov	 rcx, r10

; 1996 : }

  000d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d7	5b		 pop	 rbx
  000d8	e9 00 00 00 00	 jmp	 compiler_error
$LN9@compiler_c@3:

; 1976 :     case LOOP:
; 1977 :         ADDOP_JABS(c, JUMP_ABSOLUTE, c->u->u_fblock[i].fb_block);

  000dd	4d 03 db	 add	 r11, r11
  000e0	41 b9 01 00 00
	00		 mov	 r9d, 1
  000e6	4e 8b 44 db 78	 mov	 r8, QWORD PTR [rbx+r11*8+120]
  000eb	41 8d 51 70	 lea	 edx, QWORD PTR [r9+112]
  000ef	e8 00 00 00 00	 call	 compiler_addop_j
  000f4	85 c0		 test	 eax, eax
  000f6	75 06		 jne	 SHORT $LN8@compiler_c@3

; 1996 : }

  000f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fc	5b		 pop	 rbx
  000fd	c3		 ret	 0
$LN8@compiler_c@3:

; 1993 :     }
; 1994 : 
; 1995 :     return 1;

  000fe	b8 01 00 00 00	 mov	 eax, 1

; 1996 : }

  00103	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00107	5b		 pop	 rbx
  00108	c3		 ret	 0
compiler_continue ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@ ; `string'
PUBLIC	??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@ ; `string'
PUBLIC	??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@ ; `string'
PUBLIC	??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_nameop DD imagerel compiler_nameop
	DD	imagerel compiler_nameop+597
	DD	imagerel $unwind$compiler_nameop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_nameop DD 0a4a01H
	DD	09744aH
	DD	086445H
	DD	0a340eH
	DD	0d00a320eH
	DD	05006c008H
xdata	ENDS
;	COMDAT ??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@
CONST	SEGMENT
??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@ DB 'param invali'
	DB	'd for local variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@
CONST	SEGMENT
??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@ DB 'param invali'
	DB	'd for global variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@
CONST	SEGMENT
??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@ DB 'param invali'
	DB	'd for deref variable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@
CONST	SEGMENT
??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@ DB 'param inva'
	DB	'lid for name variable', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_nameop
_TEXT	SEGMENT
c$ = 64
name$ = 72
ctx$ = 80
compiler_nameop PROC					; COMDAT

; 2629 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 8b e9	 mov	 rbp, rcx

; 2630 :     int op, scope, arg;
; 2631 :     enum { OP_FAST, OP_GLOBAL, OP_DEREF, OP_NAME } optype;
; 2632 : 
; 2633 :     PyObject *dict = c->u->u_names;

  00011	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00015	41 8b d8	 mov	 ebx, r8d
  00018	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]

; 2634 :     PyObject *mangled;
; 2635 :     /* XXX AugStore isn't used anywhere! */
; 2636 : 
; 2637 :     mangled = _Py_Mangle(c->u->u_private, name);

  0001c	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00020	e8 00 00 00 00	 call	 _Py_Mangle
  00025	4c 8b e0	 mov	 r12, rax

; 2638 :     if (!mangled)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0f		 jne	 SHORT $LN47@compiler_n@4

; 2744 : }

  0002d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	41 5d		 pop	 r13
  00038	41 5c		 pop	 r12
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
$LN47@compiler_n@4:

; 2639 :         return 0;
; 2640 : 
; 2641 :     op = 0;
; 2642 :     optype = OP_NAME;
; 2643 :     scope = PyST_GetScope(c->u->u_ste, mangled);

  0003c	48 8b 4d 38	 mov	 rcx, QWORD PTR [rbp+56]
  00040	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00045	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0004a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004d	33 ff		 xor	 edi, edi
  0004f	48 8b d0	 mov	 rdx, rax
  00052	8d 77 03	 lea	 esi, QWORD PTR [rdi+3]
  00055	e8 00 00 00 00	 call	 PyST_GetScope

; 2644 :     switch (scope) {

  0005a	ff c8		 dec	 eax
  0005c	74 4a		 je	 SHORT $LN42@compiler_n@4
  0005e	ff c8		 dec	 eax
  00060	74 3f		 je	 SHORT $LN38@compiler_n@4
  00062	ff c8		 dec	 eax
  00064	74 24		 je	 SHORT $LN40@compiler_n@4
  00066	ff c8		 dec	 eax
  00068	74 11		 je	 SHORT $LN44@compiler_n@4
  0006a	ff c8		 dec	 eax
  0006c	75 4a		 jne	 SHORT $LN41@compiler_n@4

; 2649 :     case CELL:
; 2650 :         dict = c->u->u_cellvars;

  0006e	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]

; 2651 :         optype = OP_DEREF;

  00072	8d 77 02	 lea	 esi, QWORD PTR [rdi+2]
  00075	4c 8b 68 38	 mov	 r13, QWORD PTR [rax+56]

; 2652 :         break;

  00079	eb 3d		 jmp	 SHORT $LN41@compiler_n@4
$LN44@compiler_n@4:

; 2645 :     case FREE:
; 2646 :         dict = c->u->u_freevars;

  0007b	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]

; 2647 :         optype = OP_DEREF;

  0007f	be 02 00 00 00	 mov	 esi, 2
  00084	4c 8b 68 40	 mov	 r13, QWORD PTR [rax+64]

; 2648 :         break;

  00088	eb 2e		 jmp	 SHORT $LN41@compiler_n@4
$LN40@compiler_n@4:

; 2655 :             optype = OP_FAST;
; 2656 :         break;
; 2657 :     case GLOBAL_IMPLICIT:
; 2658 :         if (c->u->u_ste->ste_type == FunctionBlock &&
; 2659 :             !c->u->u_ste->ste_unoptimized)

  0008a	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  0008e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00091	39 b9 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], edi
  00097	75 1f		 jne	 SHORT $LN41@compiler_n@4
  00099	39 b9 8c 00 00
	00		 cmp	 DWORD PTR [rcx+140], edi
  0009f	75 17		 jne	 SHORT $LN41@compiler_n@4
$LN38@compiler_n@4:

; 2660 :             optype = OP_GLOBAL;

  000a1	be 01 00 00 00	 mov	 esi, 1

; 2661 :         break;

  000a6	eb 10		 jmp	 SHORT $LN41@compiler_n@4
$LN42@compiler_n@4:

; 2653 :     case LOCAL:
; 2654 :         if (c->u->u_ste->ste_type == FunctionBlock)

  000a8	48 8b 45 38	 mov	 rax, QWORD PTR [rbp+56]
  000ac	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000af	39 b9 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], edi
  000b5	0f 44 f7	 cmove	 esi, edi
$LN41@compiler_n@4:

; 2662 :     case GLOBAL_EXPLICIT:
; 2663 :         optype = OP_GLOBAL;
; 2664 :         break;
; 2665 :     default:
; 2666 :         /* scope can be 0 */
; 2667 :         break;
; 2668 :     }
; 2669 : 
; 2670 :     /* XXX Leave assert here, but handle __doc__ and the like better */
; 2671 :     assert(scope || PyUnicode_READ_CHAR(name, 0) == '_');
; 2672 : 
; 2673 :     switch (optype) {

  000b8	85 f6		 test	 esi, esi
  000ba	0f 84 16 01 00
	00		 je	 $LN26@compiler_n@4
  000c0	ff ce		 dec	 esi
  000c2	0f 84 a3 00 00
	00		 je	 $LN17@compiler_n@4
  000c8	ff ce		 dec	 esi
  000ca	74 5a		 je	 SHORT $LN34@compiler_n@4
  000cc	ff ce		 dec	 esi
  000ce	0f 85 da 00 00
	00		 jne	 $LN15@compiler_n@4

; 2719 :         }
; 2720 :         break;
; 2721 :     case OP_NAME:
; 2722 :         switch (ctx) {

  000d4	83 fb 01	 cmp	 ebx, 1
  000d7	74 43		 je	 SHORT $LN6@compiler_n@4
  000d9	83 fb 02	 cmp	 ebx, 2
  000dc	74 34		 je	 SHORT $LN5@compiler_n@4
  000de	83 fb 03	 cmp	 ebx, 3
  000e1	74 25		 je	 SHORT $LN4@compiler_n@4
  000e3	7e 09		 jle	 SHORT $LN2@compiler_n@4
  000e5	83 fb 05	 cmp	 ebx, 5
  000e8	0f 8e c0 00 00
	00		 jle	 $LN15@compiler_n@4
$LN2@compiler_n@4:

; 2726 :         case AugLoad:
; 2727 :         case AugStore:
; 2728 :             break;
; 2729 :         case Param:
; 2730 :         default:
; 2731 :             PyErr_SetString(PyExc_SystemError,
; 2732 :                             "param invalid for name variable");

  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@NCEOFLI@param?5invalid?5for?5name?5variable?$AA@
  000fc	e8 00 00 00 00	 call	 PyErr_SetString

; 2733 :             return 0;

  00101	33 c0		 xor	 eax, eax
  00103	e9 34 01 00 00	 jmp	 $LN51@compiler_n@4
$LN4@compiler_n@4:

; 2725 :         case Del: op = DELETE_NAME; break;

  00108	bf 5b 00 00 00	 mov	 edi, 91			; 0000005bH
  0010d	e9 9c 00 00 00	 jmp	 $LN15@compiler_n@4
$LN5@compiler_n@4:

; 2724 :         case Store: op = STORE_NAME; break;

  00112	bf 5a 00 00 00	 mov	 edi, 90			; 0000005aH
  00117	e9 92 00 00 00	 jmp	 $LN15@compiler_n@4
$LN6@compiler_n@4:

; 2723 :         case Load: op = LOAD_NAME; break;

  0011c	bf 65 00 00 00	 mov	 edi, 101		; 00000065H

; 2734 :         }
; 2735 :         break;

  00121	e9 88 00 00 00	 jmp	 $LN15@compiler_n@4
$LN34@compiler_n@4:

; 2674 :     case OP_DEREF:
; 2675 :         switch (ctx) {

  00126	83 fb 01	 cmp	 ebx, 1
  00129	74 39		 je	 SHORT $LN31@compiler_n@4
  0012b	83 fb 02	 cmp	 ebx, 2
  0012e	74 2d		 je	 SHORT $LN30@compiler_n@4
  00130	83 fb 03	 cmp	 ebx, 3
  00133	74 21		 je	 SHORT $LN28@compiler_n@4
  00135	7e 05		 jle	 SHORT $LN27@compiler_n@4
  00137	83 fb 05	 cmp	 ebx, 5
  0013a	7e 72		 jle	 SHORT $LN15@compiler_n@4
$LN27@compiler_n@4:

; 2682 :         case Param:
; 2683 :         default:
; 2684 :             PyErr_SetString(PyExc_SystemError,
; 2685 :                             "param invalid for deref variable");

  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@KBKPEBLN@param?5invalid?5for?5deref?5variable@
  0014a	e8 00 00 00 00	 call	 PyErr_SetString

; 2686 :             return 0;

  0014f	33 c0		 xor	 eax, eax
  00151	e9 e6 00 00 00	 jmp	 $LN51@compiler_n@4
$LN28@compiler_n@4:

; 2678 :         case AugLoad:
; 2679 :         case AugStore:
; 2680 :             break;
; 2681 :         case Del: op = DELETE_DEREF; break;

  00156	bf 8a 00 00 00	 mov	 edi, 138		; 0000008aH
  0015b	eb 51		 jmp	 SHORT $LN15@compiler_n@4
$LN30@compiler_n@4:

; 2677 :         case Store: op = STORE_DEREF; break;

  0015d	bf 89 00 00 00	 mov	 edi, 137		; 00000089H
  00162	eb 4a		 jmp	 SHORT $LN15@compiler_n@4
$LN31@compiler_n@4:

; 2676 :         case Load: op = LOAD_DEREF; break;

  00164	bf 88 00 00 00	 mov	 edi, 136		; 00000088H

; 2687 :         }
; 2688 :         break;

  00169	eb 43		 jmp	 SHORT $LN15@compiler_n@4
$LN17@compiler_n@4:

; 2706 :     case OP_GLOBAL:
; 2707 :         switch (ctx) {

  0016b	83 fb 01	 cmp	 ebx, 1
  0016e	74 39		 je	 SHORT $LN14@compiler_n@4
  00170	83 fb 02	 cmp	 ebx, 2
  00173	74 2d		 je	 SHORT $LN13@compiler_n@4
  00175	83 fb 03	 cmp	 ebx, 3
  00178	74 21		 je	 SHORT $LN12@compiler_n@4
  0017a	7e 05		 jle	 SHORT $LN10@compiler_n@4
  0017c	83 fb 05	 cmp	 ebx, 5
  0017f	7e 2d		 jle	 SHORT $LN15@compiler_n@4
$LN10@compiler_n@4:

; 2711 :         case AugLoad:
; 2712 :         case AugStore:
; 2713 :             break;
; 2714 :         case Param:
; 2715 :         default:
; 2716 :             PyErr_SetString(PyExc_SystemError,
; 2717 :                             "param invalid for global variable");

  00181	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00188	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@FJALOHIN@param?5invalid?5for?5global?5variabl@
  0018f	e8 00 00 00 00	 call	 PyErr_SetString

; 2718 :             return 0;

  00194	33 c0		 xor	 eax, eax
  00196	e9 a1 00 00 00	 jmp	 $LN51@compiler_n@4
$LN12@compiler_n@4:

; 2710 :         case Del: op = DELETE_GLOBAL; break;

  0019b	bf 62 00 00 00	 mov	 edi, 98			; 00000062H
  001a0	eb 0c		 jmp	 SHORT $LN15@compiler_n@4
$LN13@compiler_n@4:

; 2709 :         case Store: op = STORE_GLOBAL; break;

  001a2	bf 61 00 00 00	 mov	 edi, 97			; 00000061H
  001a7	eb 05		 jmp	 SHORT $LN15@compiler_n@4
$LN14@compiler_n@4:

; 2708 :         case Load: op = LOAD_GLOBAL; break;

  001a9	bf 74 00 00 00	 mov	 edi, 116		; 00000074H
$LN15@compiler_n@4:

; 2736 :     }
; 2737 : 
; 2738 :     assert(op);
; 2739 :     arg = compiler_add_o(c, dict, mangled);

  001ae	49 8b d4	 mov	 rdx, r12
  001b1	49 8b cd	 mov	 rcx, r13
  001b4	e8 00 00 00 00	 call	 compiler_add_o

; 2740 :     Py_DECREF(mangled);

  001b9	49 8b cc	 mov	 rcx, r12
  001bc	8b d8		 mov	 ebx, eax
  001be	e8 00 00 00 00	 call	 _Py_DecRef

; 2741 :     if (arg < 0)

  001c3	85 db		 test	 ebx, ebx

; 2742 :         return 0;

  001c5	78 38		 js	 SHORT $LN52@compiler_n@4

; 2743 :     return compiler_addop_i(c, op, arg);

  001c7	44 8b c3	 mov	 r8d, ebx
  001ca	8b d7		 mov	 edx, edi
  001cc	48 8b cd	 mov	 rcx, rbp
  001cf	e8 00 00 00 00	 call	 compiler_addop_i
  001d4	eb 66		 jmp	 SHORT $LN51@compiler_n@4
$LN26@compiler_n@4:

; 2689 :     case OP_FAST:
; 2690 :         switch (ctx) {

  001d6	83 fb 01	 cmp	 ebx, 1
  001d9	74 36		 je	 SHORT $LN23@compiler_n@4
  001db	83 fb 02	 cmp	 ebx, 2
  001de	74 2a		 je	 SHORT $LN22@compiler_n@4
  001e0	83 fb 03	 cmp	 ebx, 3
  001e3	74 1e		 je	 SHORT $LN21@compiler_n@4
  001e5	7e 05		 jle	 SHORT $LN19@compiler_n@4
  001e7	83 fb 05	 cmp	 ebx, 5
  001ea	7e 2a		 jle	 SHORT $LN24@compiler_n@4
$LN19@compiler_n@4:

; 2694 :         case AugLoad:
; 2695 :         case AugStore:
; 2696 :             break;
; 2697 :         case Param:
; 2698 :         default:
; 2699 :             PyErr_SetString(PyExc_SystemError,
; 2700 :                             "param invalid for local variable");

  001ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DECJELAF@param?5invalid?5for?5local?5variable@
  001fa	e8 00 00 00 00	 call	 PyErr_SetString
$LN52@compiler_n@4:

; 2701 :             return 0;

  001ff	33 c0		 xor	 eax, eax
  00201	eb 39		 jmp	 SHORT $LN51@compiler_n@4
$LN21@compiler_n@4:

; 2693 :         case Del: op = DELETE_FAST; break;

  00203	bf 7e 00 00 00	 mov	 edi, 126		; 0000007eH
  00208	eb 0c		 jmp	 SHORT $LN24@compiler_n@4
$LN22@compiler_n@4:

; 2692 :         case Store: op = STORE_FAST; break;

  0020a	bf 7d 00 00 00	 mov	 edi, 125		; 0000007dH
  0020f	eb 05		 jmp	 SHORT $LN24@compiler_n@4
$LN23@compiler_n@4:

; 2691 :         case Load: op = LOAD_FAST; break;

  00211	bf 7c 00 00 00	 mov	 edi, 124		; 0000007cH
$LN24@compiler_n@4:

; 2702 :         }
; 2703 :         ADDOP_O(c, op, mangled, varnames);

  00216	4c 8b 45 38	 mov	 r8, QWORD PTR [rbp+56]
  0021a	4d 8b cc	 mov	 r9, r12
  0021d	8b d7		 mov	 edx, edi
  0021f	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  00223	48 8b cd	 mov	 rcx, rbp
  00226	e8 00 00 00 00	 call	 compiler_addop_o
  0022b	85 c0		 test	 eax, eax
  0022d	74 d0		 je	 SHORT $LN52@compiler_n@4

; 2704 :         Py_DECREF(mangled);

  0022f	49 8b cc	 mov	 rcx, r12
  00232	e8 00 00 00 00	 call	 _Py_DecRef

; 2705 :         return 1;

  00237	b8 01 00 00 00	 mov	 eax, 1
$LN51@compiler_n@4:

; 2744 : }

  0023c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00241	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00246	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0024b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0024f	41 5d		 pop	 r13
  00251	41 5c		 pop	 r12
  00253	5d		 pop	 rbp
  00254	c3		 ret	 0
compiler_nameop ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@ ; `string'
PUBLIC	??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_list DD imagerel compiler_list
	DD	imagerel compiler_list+393
	DD	imagerel $unwind$compiler_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_list DD 0f3b01H
	DD	04f43bH
	DD	05e436H
	DD	06c431H
	DD	0d742cH
	DD	0c6427H
	DD	0a3422H
	DD	0d0046208H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
CONST	SEGMENT
??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@ DB 'two starred e'
	DB	'xpressions in assignment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
CONST	SEGMENT
??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@ DB 'too many ex'
	DB	'pressions in star-unpacking assignment', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_list
_TEXT	SEGMENT
c$ = 80
n$1$ = 88
e$ = 88
compiler_list PROC					; COMDAT

; 2775 : {

  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2776 :     int n = asdl_seq_LEN(e->v.List.elts);

  00008	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000c	4c 8b ea	 mov	 r13, rdx
  0000f	48 8b e9	 mov	 rbp, rcx
  00012	48 85 c0	 test	 rax, rax
  00015	74 02		 je	 SHORT $LN34@compiler_l@2
$LN21@compiler_l@2:
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
$LN34@compiler_l@2:

; 2777 :     if (e->v.List.ctx == Store) {

  00019	83 7a 10 02	 cmp	 DWORD PTR [rdx+16], 2
  0001d	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00022	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00027	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  0002c	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00031	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00036	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0003b	89 44 24 58	 mov	 DWORD PTR n$1$[rsp], eax
  0003f	0f 85 9d 00 00
	00		 jne	 $LN7@compiler_l@2

; 2778 :         int i, seen_star = 0;

  00045	33 d2		 xor	 edx, edx

; 2779 :         for (i = 0; i < n; i++) {

  00047	45 33 e4	 xor	 r12d, r12d
  0004a	33 db		 xor	 ebx, ebx
  0004c	4c 63 f8	 movsxd	 r15, eax
  0004f	85 c0		 test	 eax, eax
  00051	7e 7b		 jle	 SHORT $LN32@compiler_l@2

; 2778 :         int i, seen_star = 0;

  00053	8b f0		 mov	 esi, eax
  00055	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  00058	c1 e6 08	 shl	 esi, 8
  0005b	0f 1f 44 00 00	 npad	 5
$LL17@compiler_l@2:

; 2780 :             expr_ty elt = asdl_seq_GET(e->v.List.elts, i);

  00060	49 8b 45 08	 mov	 rax, QWORD PTR [r13+8]
  00064	4c 8b 74 d8 08	 mov	 r14, QWORD PTR [rax+rbx*8+8]

; 2781 :             if (elt->kind == Starred_kind && !seen_star) {

  00069	41 83 3e 16	 cmp	 DWORD PTR [r14], 22
  0006d	75 44		 jne	 SHORT $LN16@compiler_l@2
  0006f	85 d2		 test	 edx, edx
  00071	0f 85 97 00 00
	00		 jne	 $LN29@compiler_l@2

; 2782 :                 if ((i >= (1 << 8)) ||
; 2783 :                     (n-i-1 >= (INT_MAX >> 8)))

  00077	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  0007e	7d 7d		 jge	 SHORT $LN12@compiler_l@2
  00080	81 ff ff ff 7f
	00		 cmp	 edi, 8388607		; 007fffffH
  00086	7d 75		 jge	 SHORT $LN12@compiler_l@2

; 2787 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  00088	46 8d 84 26 00
	ff ff ff	 lea	 r8d, DWORD PTR [rsi+r12-256]
  00090	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  00095	48 8b cd	 mov	 rcx, rbp
  00098	e8 00 00 00 00	 call	 compiler_addop_i
  0009d	85 c0		 test	 eax, eax
  0009f	74 58		 je	 SHORT $LN28@compiler_l@2

; 2788 :                 seen_star = 1;
; 2789 :                 asdl_seq_SET(e->v.List.elts, i, elt->v.Starred.value);

  000a1	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  000a5	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  000a9	ba 01 00 00 00	 mov	 edx, 1
  000ae	48 89 44 d9 08	 mov	 QWORD PTR [rcx+rbx*8+8], rax
$LN16@compiler_l@2:

; 2779 :         for (i = 0; i < n; i++) {

  000b3	48 ff c3	 inc	 rbx
  000b6	41 ff c4	 inc	 r12d
  000b9	81 ee 00 01 00
	00		 sub	 esi, 256		; 00000100H
  000bf	ff cf		 dec	 edi
  000c1	49 3b df	 cmp	 rbx, r15
  000c4	7c 9a		 jl	 SHORT $LL17@compiler_l@2

; 2793 :             }
; 2794 :         }
; 2795 :         if (!seen_star) {

  000c6	85 d2		 test	 edx, edx
  000c8	75 18		 jne	 SHORT $LN7@compiler_l@2
  000ca	8b 44 24 58	 mov	 eax, DWORD PTR n$1$[rsp]
$LN32@compiler_l@2:

; 2796 :             ADDOP_I(c, UNPACK_SEQUENCE, n);

  000ce	44 8b c0	 mov	 r8d, eax
  000d1	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  000d6	48 8b cd	 mov	 rcx, rbp
  000d9	e8 00 00 00 00	 call	 compiler_addop_i
  000de	85 c0		 test	 eax, eax
  000e0	74 17		 je	 SHORT $LN28@compiler_l@2
$LN7@compiler_l@2:

; 2797 :         }
; 2798 :     }
; 2799 :     VISIT_SEQ(c, expr, e->v.List.elts);

  000e2	49 8b 75 08	 mov	 rsi, QWORD PTR [r13+8]
  000e6	33 db		 xor	 ebx, ebx
  000e8	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  000ec	0f 1f 40 00	 npad	 4
$LL6@compiler_l@2:
  000f0	48 85 f6	 test	 rsi, rsi
  000f3	75 2a		 jne	 SHORT $LN23@compiler_l@2
  000f5	33 c9		 xor	 ecx, ecx
  000f7	eb 29		 jmp	 SHORT $LN24@compiler_l@2
$LN28@compiler_l@2:

; 2787 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  000f9	33 c0		 xor	 eax, eax
  000fb	eb 66		 jmp	 SHORT $LN19@compiler_l@2
$LN12@compiler_l@2:

; 2784 :                     return compiler_error(c,
; 2785 :                         "too many expressions in "
; 2786 :                         "star-unpacking assignment");

  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
  00104	48 8b cd	 mov	 rcx, rbp
  00107	e8 00 00 00 00	 call	 compiler_error
  0010c	eb 55		 jmp	 SHORT $LN19@compiler_l@2
$LN29@compiler_l@2:

; 2790 :             } else if (elt->kind == Starred_kind) {
; 2791 :                 return compiler_error(c,
; 2792 :                     "two starred expressions in assignment");

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
  00115	48 8b cd	 mov	 rcx, rbp
  00118	e8 00 00 00 00	 call	 compiler_error
  0011d	eb 44		 jmp	 SHORT $LN19@compiler_l@2
$LN23@compiler_l@2:

; 2797 :         }
; 2798 :     }
; 2799 :     VISIT_SEQ(c, expr, e->v.List.elts);

  0011f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN24@compiler_l@2:
  00122	48 63 c3	 movsxd	 rax, ebx
  00125	48 3b c1	 cmp	 rax, rcx
  00128	7d 17		 jge	 SHORT $LN4@compiler_l@2
  0012a	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0012d	48 8b cd	 mov	 rcx, rbp
  00130	e8 00 00 00 00	 call	 compiler_visit_expr
  00135	85 c0		 test	 eax, eax
  00137	74 c0		 je	 SHORT $LN28@compiler_l@2
  00139	ff c3		 inc	 ebx
  0013b	48 83 c7 08	 add	 rdi, 8
  0013f	eb af		 jmp	 SHORT $LL6@compiler_l@2
$LN4@compiler_l@2:

; 2800 :     if (e->v.List.ctx == Load) {

  00141	41 83 7d 10 01	 cmp	 DWORD PTR [r13+16], 1
  00146	75 16		 jne	 SHORT $LN1@compiler_l@2

; 2801 :         ADDOP_I(c, BUILD_LIST, n);

  00148	44 8b 44 24 58	 mov	 r8d, DWORD PTR n$1$[rsp]
  0014d	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  00152	48 8b cd	 mov	 rcx, rbp
  00155	e8 00 00 00 00	 call	 compiler_addop_i
  0015a	85 c0		 test	 eax, eax
  0015c	74 9b		 je	 SHORT $LN28@compiler_l@2
$LN1@compiler_l@2:

; 2802 :     }
; 2803 :     return 1;

  0015e	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_l@2:
  00163	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00168	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0016d	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  00172	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00177	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0017c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 2804 : }

  00181	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00185	41 5d		 pop	 r13
  00187	5d		 pop	 rbp
  00188	c3		 ret	 0
compiler_list ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_tuple DD imagerel compiler_tuple
	DD	imagerel compiler_tuple+393
	DD	imagerel $unwind$compiler_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_tuple DD 0f3b01H
	DD	04f43bH
	DD	05e436H
	DD	06c431H
	DD	0d742cH
	DD	0c6427H
	DD	0a3422H
	DD	0d0046208H
	DD	05002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_tuple
_TEXT	SEGMENT
c$ = 80
n$1$ = 88
e$ = 88
compiler_tuple PROC					; COMDAT

; 2808 : {

  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2809 :     int n = asdl_seq_LEN(e->v.Tuple.elts);

  00008	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000c	4c 8b ea	 mov	 r13, rdx
  0000f	48 8b e9	 mov	 rbp, rcx
  00012	48 85 c0	 test	 rax, rax
  00015	74 02		 je	 SHORT $LN34@compiler_t
$LN21@compiler_t:
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
$LN34@compiler_t:

; 2810 :     if (e->v.Tuple.ctx == Store) {

  00019	83 7a 10 02	 cmp	 DWORD PTR [rdx+16], 2
  0001d	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00022	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00027	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  0002c	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00031	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00036	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0003b	89 44 24 58	 mov	 DWORD PTR n$1$[rsp], eax
  0003f	0f 85 9d 00 00
	00		 jne	 $LN7@compiler_t

; 2811 :         int i, seen_star = 0;

  00045	33 d2		 xor	 edx, edx

; 2812 :         for (i = 0; i < n; i++) {

  00047	45 33 e4	 xor	 r12d, r12d
  0004a	33 db		 xor	 ebx, ebx
  0004c	4c 63 f8	 movsxd	 r15, eax
  0004f	85 c0		 test	 eax, eax
  00051	7e 7b		 jle	 SHORT $LN32@compiler_t

; 2811 :         int i, seen_star = 0;

  00053	8b f0		 mov	 esi, eax
  00055	8d 78 ff	 lea	 edi, DWORD PTR [rax-1]
  00058	c1 e6 08	 shl	 esi, 8
  0005b	0f 1f 44 00 00	 npad	 5
$LL17@compiler_t:

; 2813 :             expr_ty elt = asdl_seq_GET(e->v.Tuple.elts, i);

  00060	49 8b 45 08	 mov	 rax, QWORD PTR [r13+8]
  00064	4c 8b 74 d8 08	 mov	 r14, QWORD PTR [rax+rbx*8+8]

; 2814 :             if (elt->kind == Starred_kind && !seen_star) {

  00069	41 83 3e 16	 cmp	 DWORD PTR [r14], 22
  0006d	75 44		 jne	 SHORT $LN16@compiler_t
  0006f	85 d2		 test	 edx, edx
  00071	0f 85 97 00 00
	00		 jne	 $LN29@compiler_t

; 2815 :                 if ((i >= (1 << 8)) ||
; 2816 :                     (n-i-1 >= (INT_MAX >> 8)))

  00077	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  0007e	7d 7d		 jge	 SHORT $LN12@compiler_t
  00080	81 ff ff ff 7f
	00		 cmp	 edi, 8388607		; 007fffffH
  00086	7d 75		 jge	 SHORT $LN12@compiler_t

; 2820 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  00088	46 8d 84 26 00
	ff ff ff	 lea	 r8d, DWORD PTR [rsi+r12-256]
  00090	ba 5e 00 00 00	 mov	 edx, 94			; 0000005eH
  00095	48 8b cd	 mov	 rcx, rbp
  00098	e8 00 00 00 00	 call	 compiler_addop_i
  0009d	85 c0		 test	 eax, eax
  0009f	74 58		 je	 SHORT $LN28@compiler_t

; 2821 :                 seen_star = 1;
; 2822 :                 asdl_seq_SET(e->v.Tuple.elts, i, elt->v.Starred.value);

  000a1	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  000a5	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  000a9	ba 01 00 00 00	 mov	 edx, 1
  000ae	48 89 44 d9 08	 mov	 QWORD PTR [rcx+rbx*8+8], rax
$LN16@compiler_t:

; 2812 :         for (i = 0; i < n; i++) {

  000b3	48 ff c3	 inc	 rbx
  000b6	41 ff c4	 inc	 r12d
  000b9	81 ee 00 01 00
	00		 sub	 esi, 256		; 00000100H
  000bf	ff cf		 dec	 edi
  000c1	49 3b df	 cmp	 rbx, r15
  000c4	7c 9a		 jl	 SHORT $LL17@compiler_t

; 2826 :             }
; 2827 :         }
; 2828 :         if (!seen_star) {

  000c6	85 d2		 test	 edx, edx
  000c8	75 18		 jne	 SHORT $LN7@compiler_t
  000ca	8b 44 24 58	 mov	 eax, DWORD PTR n$1$[rsp]
$LN32@compiler_t:

; 2829 :             ADDOP_I(c, UNPACK_SEQUENCE, n);

  000ce	44 8b c0	 mov	 r8d, eax
  000d1	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  000d6	48 8b cd	 mov	 rcx, rbp
  000d9	e8 00 00 00 00	 call	 compiler_addop_i
  000de	85 c0		 test	 eax, eax
  000e0	74 17		 je	 SHORT $LN28@compiler_t
$LN7@compiler_t:

; 2830 :         }
; 2831 :     }
; 2832 :     VISIT_SEQ(c, expr, e->v.Tuple.elts);

  000e2	49 8b 75 08	 mov	 rsi, QWORD PTR [r13+8]
  000e6	33 db		 xor	 ebx, ebx
  000e8	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  000ec	0f 1f 40 00	 npad	 4
$LL6@compiler_t:
  000f0	48 85 f6	 test	 rsi, rsi
  000f3	75 2a		 jne	 SHORT $LN23@compiler_t
  000f5	33 c9		 xor	 ecx, ecx
  000f7	eb 29		 jmp	 SHORT $LN24@compiler_t
$LN28@compiler_t:

; 2820 :                 ADDOP_I(c, UNPACK_EX, (i + ((n-i-1) << 8)));

  000f9	33 c0		 xor	 eax, eax
  000fb	eb 66		 jmp	 SHORT $LN19@compiler_t
$LN12@compiler_t:

; 2817 :                     return compiler_error(c,
; 2818 :                         "too many expressions in "
; 2819 :                         "star-unpacking assignment");

  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DEOGEHAB@too?5many?5expressions?5in?5star?9unp@
  00104	48 8b cd	 mov	 rcx, rbp
  00107	e8 00 00 00 00	 call	 compiler_error
  0010c	eb 55		 jmp	 SHORT $LN19@compiler_t
$LN29@compiler_t:

; 2823 :             } else if (elt->kind == Starred_kind) {
; 2824 :                 return compiler_error(c,
; 2825 :                     "two starred expressions in assignment");

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OJEPACC@two?5starred?5expressions?5in?5assig@
  00115	48 8b cd	 mov	 rcx, rbp
  00118	e8 00 00 00 00	 call	 compiler_error
  0011d	eb 44		 jmp	 SHORT $LN19@compiler_t
$LN23@compiler_t:

; 2830 :         }
; 2831 :     }
; 2832 :     VISIT_SEQ(c, expr, e->v.Tuple.elts);

  0011f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN24@compiler_t:
  00122	48 63 c3	 movsxd	 rax, ebx
  00125	48 3b c1	 cmp	 rax, rcx
  00128	7d 17		 jge	 SHORT $LN4@compiler_t
  0012a	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0012d	48 8b cd	 mov	 rcx, rbp
  00130	e8 00 00 00 00	 call	 compiler_visit_expr
  00135	85 c0		 test	 eax, eax
  00137	74 c0		 je	 SHORT $LN28@compiler_t
  00139	ff c3		 inc	 ebx
  0013b	48 83 c7 08	 add	 rdi, 8
  0013f	eb af		 jmp	 SHORT $LL6@compiler_t
$LN4@compiler_t:

; 2833 :     if (e->v.Tuple.ctx == Load) {

  00141	41 83 7d 10 01	 cmp	 DWORD PTR [r13+16], 1
  00146	75 16		 jne	 SHORT $LN1@compiler_t

; 2834 :         ADDOP_I(c, BUILD_TUPLE, n);

  00148	44 8b 44 24 58	 mov	 r8d, DWORD PTR n$1$[rsp]
  0014d	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  00152	48 8b cd	 mov	 rcx, rbp
  00155	e8 00 00 00 00	 call	 compiler_addop_i
  0015a	85 c0		 test	 eax, eax
  0015c	74 9b		 je	 SHORT $LN28@compiler_t
$LN1@compiler_t:

; 2835 :     }
; 2836 :     return 1;

  0015e	b8 01 00 00 00	 mov	 eax, 1
$LN19@compiler_t:
  00163	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00168	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0016d	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  00172	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00177	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0017c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 2837 : }

  00181	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00185	41 5d		 pop	 r13
  00187	5d		 pop	 rbp
  00188	c3		 ret	 0
compiler_tuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_keyword DD imagerel compiler_visit_keyword
	DD	imagerel compiler_visit_keyword+84
	DD	imagerel $unwind$compiler_visit_keyword
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_keyword DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_visit_keyword
_TEXT	SEGMENT
c$ = 48
k$ = 56
compiler_visit_keyword PROC				; COMDAT

; 3174 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3175 :     ADDOP_O(c, LOAD_CONST, k->arg, consts);

  0000a	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0000e	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00018	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	e8 00 00 00 00	 call	 compiler_addop_o
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@compiler_v@2

; 3177 :     return 1;
; 3178 : }

  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
$LN2@compiler_v@2:

; 3176 :     VISIT(c, expr, k->value);

  00034	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 compiler_visit_expr

; 3177 :     return 1;
; 3178 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	33 c9		 xor	 ecx, ecx
  00047	85 c0		 test	 eax, eax
  00049	0f 95 c1	 setne	 cl
  0004c	8b c1		 mov	 eax, ecx
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
compiler_visit_keyword ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_slice DD imagerel compiler_slice
	DD	imagerel compiler_slice+230
	DD	imagerel $unwind$compiler_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_slice DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_slice
_TEXT	SEGMENT
c$ = 48
s$ = 56
compiler_slice PROC					; COMDAT

; 3601 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx

; 3602 :     int n = 2;
; 3603 :     assert(s->kind == Slice_kind);
; 3604 : 
; 3605 :     /* only handles the cases where BUILD_SLICE is emitted */
; 3606 :     if (s->v.Slice.lower) {

  00012	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00016	48 8b d9	 mov	 rbx, rcx
  00019	be 02 00 00 00	 mov	 esi, 2
  0001e	48 85 d2	 test	 rdx, rdx
  00021	74 1b		 je	 SHORT $LN11@compiler_s@3

; 3607 :         VISIT(c, expr, s->v.Slice.lower);

  00023	e8 00 00 00 00	 call	 compiler_visit_expr
  00028	85 c0		 test	 eax, eax
  0002a	75 2f		 jne	 SHORT $LN8@compiler_s@3
$LN14@compiler_s@3:
  0002c	33 c0		 xor	 eax, eax

; 3625 :     return 1;
; 3626 : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN11@compiler_s@3:

; 3608 :     }
; 3609 :     else {
; 3610 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0003e	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  00042	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00049	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0004e	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00052	e8 00 00 00 00	 call	 compiler_addop_o
  00057	85 c0		 test	 eax, eax
  00059	74 15		 je	 SHORT $LN15@compiler_s@3
$LN8@compiler_s@3:

; 3611 :     }
; 3612 : 
; 3613 :     if (s->v.Slice.upper) {

  0005b	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]

; 3614 :         VISIT(c, expr, s->v.Slice.upper);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	48 85 d2	 test	 rdx, rdx
  00065	74 1b		 je	 SHORT $LN7@compiler_s@3
  00067	e8 00 00 00 00	 call	 compiler_visit_expr
  0006c	85 c0		 test	 eax, eax
  0006e	75 2f		 jne	 SHORT $LN4@compiler_s@3
$LN15@compiler_s@3:
  00070	33 c0		 xor	 eax, eax

; 3625 :     return 1;
; 3626 : }

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN7@compiler_s@3:

; 3615 :     }
; 3616 :     else {
; 3617 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00082	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00086	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0008d	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00092	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00096	e8 00 00 00 00	 call	 compiler_addop_o
  0009b	85 c0		 test	 eax, eax
  0009d	74 8d		 je	 SHORT $LN14@compiler_s@3
$LN4@compiler_s@3:

; 3618 :     }
; 3619 : 
; 3620 :     if (s->v.Slice.step) {

  0009f	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  000a3	48 85 d2	 test	 rdx, rdx
  000a6	74 15		 je	 SHORT $LN2@compiler_s@3

; 3621 :         n++;
; 3622 :         VISIT(c, expr, s->v.Slice.step);

  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	be 03 00 00 00	 mov	 esi, 3
  000b0	e8 00 00 00 00	 call	 compiler_visit_expr
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 6f ff ff
	ff		 je	 $LN14@compiler_s@3
$LN2@compiler_s@3:

; 3623 :     }
; 3624 :     ADDOP_I(c, BUILD_SLICE, n);

  000bd	44 8b c6	 mov	 r8d, esi
  000c0	ba 85 00 00 00	 mov	 edx, 133		; 00000085H
  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 compiler_addop_i

; 3625 :     return 1;
; 3626 : }

  000cd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d7	33 c9		 xor	 ecx, ecx
  000d9	85 c0		 test	 eax, eax
  000db	0f 95 c1	 setne	 cl
  000de	8b c1		 mov	 eax, ecx
  000e0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e4	5f		 pop	 rdi
  000e5	c3		 ret	 0
compiler_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_nested_slice DD imagerel compiler_visit_nested_slice
	DD	imagerel compiler_visit_nested_slice+76
	DD	imagerel $unwind$compiler_visit_nested_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_nested_slice DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@
CONST	SEGMENT
??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@ DB 'extended sli'
	DB	'ce invalid in nested slice', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_visit_nested_slice
_TEXT	SEGMENT
c$ = 48
s$ = 56
compiler_visit_nested_slice PROC			; COMDAT

; 3631 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3632 :     switch (s->kind) {

  00004	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  00007	41 ff c8	 dec	 r8d
  0000a	74 37		 je	 SHORT $LN4@compiler_v@3
  0000c	41 83 f8 02	 cmp	 r8d, 2
  00010	74 1a		 je	 SHORT $LN3@compiler_v@3

; 3637 :         break;
; 3638 :     case ExtSlice_kind:
; 3639 :     default:
; 3640 :         PyErr_SetString(PyExc_SystemError,
; 3641 :                         "extended slice invalid in nested slice");

  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@PGJJNNIN@extended?5slice?5invalid?5in?5nested@
  00020	e8 00 00 00 00	 call	 PyErr_SetString

; 3642 :         return 0;

  00025	33 c0		 xor	 eax, eax

; 3643 :     }
; 3644 :     return 1;
; 3645 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN3@compiler_v@3:

; 3633 :     case Slice_kind:
; 3634 :         return compiler_slice(c, s, ctx);
; 3635 :     case Index_kind:
; 3636 :         VISIT(c, expr, s->v.Index.value);

  0002c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00030	e8 00 00 00 00	 call	 compiler_visit_expr
  00035	33 c9		 xor	 ecx, ecx
  00037	85 c0		 test	 eax, eax
  00039	0f 95 c1	 setne	 cl
  0003c	8b c1		 mov	 eax, ecx

; 3643 :     }
; 3644 :     return 1;
; 3645 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
$LN4@compiler_v@3:
  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	e9 00 00 00 00	 jmp	 compiler_slice
compiler_visit_nested_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_05ILHMOJGN@slice?$AA@			; `string'
PUBLIC	??_C@_0P@NIBIFKDK@extended?5slice?$AA@		; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_slice DD imagerel compiler_visit_slice
	DD	imagerel compiler_visit_slice+284
	DD	imagerel $unwind$compiler_visit_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_slice DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
xdata	ENDS
;	COMDAT ??_C@_05ILHMOJGN@slice?$AA@
CONST	SEGMENT
??_C@_05ILHMOJGN@slice?$AA@ DB 'slice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NIBIFKDK@extended?5slice?$AA@
CONST	SEGMENT
??_C@_0P@NIBIFKDK@extended?5slice?$AA@ DB 'extended slice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@ DB 'invalid subscr'
	DB	'ipt kind %d', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_visit_slice
_TEXT	SEGMENT
c$ = 64
s$ = 72
ctx$ = 80
compiler_visit_slice PROC				; COMDAT

; 3649 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	41 8b e8	 mov	 ebp, r8d

; 3650 :     char * kindname = NULL;
; 3651 :     switch (s->kind) {

  00021	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  00024	48 8b f2	 mov	 rsi, rdx
  00027	45 8b c8	 mov	 r9d, r8d
  0002a	4c 8b e1	 mov	 r12, rcx
  0002d	41 ff c9	 dec	 r9d
  00030	0f 84 a0 00 00
	00		 je	 $LN11@compiler_v@4
  00036	41 ff c9	 dec	 r9d
  00039	74 43		 je	 SHORT $LN8@compiler_v@4
  0003b	41 ff c9	 dec	 r9d
  0003e	74 1a		 je	 SHORT $LN14@compiler_v@4

; 3676 :         }
; 3677 :         break;
; 3678 :     default:
; 3679 :         PyErr_Format(PyExc_SystemError,
; 3680 :                      "invalid subscript kind %d", s->kind);

  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DMIFGBD@invalid?5subscript?5kind?5?$CFd?$AA@
  0004e	e8 00 00 00 00	 call	 PyErr_Format
$LN24@compiler_v@4:

; 3681 :         return 0;

  00053	33 c0		 xor	 eax, eax
  00055	e9 a3 00 00 00	 jmp	 $LN17@compiler_v@4
$LN14@compiler_v@4:

; 3652 :     case Index_kind:
; 3653 :         kindname = "index";

  0005a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_05FKHKFDID@index?$AA@

; 3654 :         if (ctx != AugStore) {

  00061	83 fd 05	 cmp	 ebp, 5
  00064	0f 84 85 00 00
	00		 je	 $LN9@compiler_v@4

; 3655 :             VISIT(c, expr, s->v.Index.value);

  0006a	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0006e	e8 00 00 00 00	 call	 compiler_visit_expr
  00073	85 c0		 test	 eax, eax
  00075	75 78		 jne	 SHORT $LN9@compiler_v@4
$LN22@compiler_v@4:
  00077	33 c0		 xor	 eax, eax
  00079	e9 7f 00 00 00	 jmp	 $LN17@compiler_v@4
$LN8@compiler_v@4:

; 3663 :         }
; 3664 :         break;
; 3665 :     case ExtSlice_kind:
; 3666 :         kindname = "extended slice";

  0007e	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_0P@NIBIFKDK@extended?5slice?$AA@

; 3667 :         if (ctx != AugStore) {

  00085	83 fd 05	 cmp	 ebp, 5
  00088	74 65		 je	 SHORT $LN9@compiler_v@4

; 3668 :             int i, n = asdl_seq_LEN(s->v.ExtSlice.dims);

  0008a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0008e	33 db		 xor	 ebx, ebx
  00090	44 8b f3	 mov	 r14d, ebx
  00093	48 85 c0	 test	 rax, rax
  00096	74 03		 je	 SHORT $LN20@compiler_v@4
  00098	44 8b 30	 mov	 r14d, DWORD PTR [rax]
$LN20@compiler_v@4:

; 3669 :             for (i = 0; i < n; i++) {

  0009b	49 63 fe	 movsxd	 rdi, r14d
  0009e	45 85 f6	 test	 r14d, r14d
  000a1	7e 1d		 jle	 SHORT $LN4@compiler_v@4
$LL6@compiler_v@4:

; 3670 :                 slice_ty sub = (slice_ty)asdl_seq_GET(
; 3671 :                     s->v.ExtSlice.dims, i);

  000a3	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]

; 3672 :                 if (!compiler_visit_nested_slice(c, sub, ctx))

  000a7	49 8b cc	 mov	 rcx, r12
  000aa	48 8b 54 d8 08	 mov	 rdx, QWORD PTR [rax+rbx*8+8]
  000af	e8 00 00 00 00	 call	 compiler_visit_nested_slice
  000b4	85 c0		 test	 eax, eax
  000b6	74 bf		 je	 SHORT $LN22@compiler_v@4

; 3669 :             for (i = 0; i < n; i++) {

  000b8	48 ff c3	 inc	 rbx
  000bb	48 3b df	 cmp	 rbx, rdi
  000be	7c e3		 jl	 SHORT $LL6@compiler_v@4
$LN4@compiler_v@4:

; 3673 :                     return 0;
; 3674 :             }
; 3675 :             ADDOP_I(c, BUILD_TUPLE, n);

  000c0	45 8b c6	 mov	 r8d, r14d
  000c3	ba 66 00 00 00	 mov	 edx, 102		; 00000066H
  000c8	49 8b cc	 mov	 rcx, r12
  000cb	e8 00 00 00 00	 call	 compiler_addop_i
  000d0	85 c0		 test	 eax, eax
  000d2	75 1b		 jne	 SHORT $LN9@compiler_v@4
  000d4	eb 27		 jmp	 SHORT $LN17@compiler_v@4
$LN11@compiler_v@4:

; 3656 :         }
; 3657 :         break;
; 3658 :     case Slice_kind:
; 3659 :         kindname = "slice";

  000d6	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_C@_05ILHMOJGN@slice?$AA@

; 3660 :         if (ctx != AugStore) {

  000dd	83 fd 05	 cmp	 ebp, 5
  000e0	74 0d		 je	 SHORT $LN9@compiler_v@4

; 3661 :             if (!compiler_slice(c, s, ctx))

  000e2	e8 00 00 00 00	 call	 compiler_slice
  000e7	85 c0		 test	 eax, eax

; 3662 :                 return 0;

  000e9	0f 84 64 ff ff
	ff		 je	 $LN24@compiler_v@4
$LN9@compiler_v@4:

; 3682 :     }
; 3683 :     return compiler_handle_subscr(c, kindname, ctx);

  000ef	44 8b c5	 mov	 r8d, ebp
  000f2	49 8b d5	 mov	 rdx, r13
  000f5	49 8b cc	 mov	 rcx, r12
  000f8	e8 00 00 00 00	 call	 compiler_handle_subscr
$LN17@compiler_v@4:

; 3684 : }

  000fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00102	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00107	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0010c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00111	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00115	41 5e		 pop	 r14
  00117	41 5d		 pop	 r13
  00119	41 5c		 pop	 r12
  0011b	c3		 ret	 0
compiler_visit_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$assemble DD imagerel assemble
	DD	imagerel assemble+241
	DD	imagerel $unwind$assemble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$assemble DD imagerel assemble+241
	DD	imagerel assemble+405
	DD	imagerel $chain$1$assemble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$assemble DD imagerel assemble+405
	DD	imagerel assemble+435
	DD	imagerel $chain$2$assemble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$assemble DD 021H
	DD	imagerel assemble
	DD	imagerel assemble+241
	DD	imagerel $unwind$assemble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$assemble DD 040a21H
	DD	0d740aH
	DD	0c6405H
	DD	imagerel assemble
	DD	imagerel assemble+241
	DD	imagerel $unwind$assemble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$assemble DD 061001H
	DD	0f5410H
	DD	0e3410H
	DD	0c00c9210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT assemble
_TEXT	SEGMENT
a$ = 32
c$ = 96
addNone$ = 104
assemble PROC						; COMDAT

; 4197 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4198 :     basicblock *b, *entryblock;
; 4199 :     struct assembler a;
; 4200 :     int i, j, nblocks;
; 4201 :     PyCodeObject *co = NULL;
; 4202 : 
; 4203 :     /* Make sure every block that falls off the end returns None.
; 4204 :        XXX NEXT_BLOCK() isn't quite right, because if the last
; 4205 :        block ends with a jump or return b_next shouldn't set.
; 4206 :      */
; 4207 :     if (!c->u->u_curblock->b_return) {

  00010	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00014	33 ed		 xor	 ebp, ebp
  00016	8b da		 mov	 ebx, edx
  00018	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001c	4c 8b e1	 mov	 r12, rcx
  0001f	41 f6 40 20 02	 test	 BYTE PTR [r8+32], 2
  00024	75 53		 jne	 SHORT $LN17@assemble

; 4208 :         NEXT_BLOCK(c);

  00026	e8 00 00 00 00	 call	 compiler_next_block
  0002b	48 85 c0	 test	 rax, rax
  0002e	75 13		 jne	 SHORT $LN20@assemble
$LN33@assemble:
  00030	33 c0		 xor	 eax, eax

; 4251 :     return co;
; 4252 : }

  00032	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00037	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  0003c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00040	41 5c		 pop	 r12
  00042	c3		 ret	 0
$LN20@assemble:

; 4209 :         if (addNone)

  00043	85 db		 test	 ebx, ebx
  00045	74 21		 je	 SHORT $LN18@assemble

; 4210 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00047	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  0004c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00053	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00058	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0005c	49 8b cc	 mov	 rcx, r12
  0005f	e8 00 00 00 00	 call	 compiler_addop_o
  00064	85 c0		 test	 eax, eax
  00066	74 c8		 je	 SHORT $LN33@assemble
$LN18@assemble:

; 4211 :         ADDOP(c, RETURN_VALUE);

  00068	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  0006d	49 8b cc	 mov	 rcx, r12
  00070	e8 00 00 00 00	 call	 compiler_addop
  00075	85 c0		 test	 eax, eax
  00077	74 b7		 je	 SHORT $LN33@assemble
$LN17@assemble:

; 4212 :     }
; 4213 : 
; 4214 :     nblocks = 0;
; 4215 :     entryblock = NULL;
; 4216 :     for (b = c->u->u_blocks; b != NULL; b = b->b_list) {

  00079	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  0007e	8b d5		 mov	 edx, ebp
  00080	48 8b dd	 mov	 rbx, rbp
  00083	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00087	48 85 c0	 test	 rax, rax
  0008a	74 11		 je	 SHORT $LN14@assemble
  0008c	0f 1f 40 00	 npad	 4
$LL16@assemble:

; 4217 :         nblocks++;
; 4218 :         entryblock = b;

  00090	48 8b d8	 mov	 rbx, rax
  00093	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00096	ff c2		 inc	 edx
  00098	48 85 c0	 test	 rax, rax
  0009b	75 f3		 jne	 SHORT $LL16@assemble
$LN14@assemble:

; 4219 :     }
; 4220 : 
; 4221 :     /* Set firstlineno if it wasn't explicitly set. */
; 4222 :     if (!c->u->u_firstlineno) {

  0009d	39 a9 b0 01 00
	00		 cmp	 DWORD PTR [rcx+432], ebp
  000a3	75 23		 jne	 SHORT $LN11@assemble

; 4223 :         if (entryblock && entryblock->b_instr)

  000a5	48 85 db	 test	 rbx, rbx
  000a8	74 14		 je	 SHORT $LN12@assemble
  000aa	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000ae	48 85 c0	 test	 rax, rax
  000b1	74 0b		 je	 SHORT $LN12@assemble

; 4224 :             c->u->u_firstlineno = entryblock->b_instr->i_lineno;

  000b3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000b6	89 81 b0 01 00
	00		 mov	 DWORD PTR [rcx+432], eax

; 4225 :         else

  000bc	eb 0a		 jmp	 SHORT $LN11@assemble
$LN12@assemble:

; 4226 :             c->u->u_firstlineno = 1;

  000be	c7 81 b0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+432], 1
$LN11@assemble:

; 4227 :     }
; 4228 :     if (!assemble_init(&a, nblocks, c->u->u_firstlineno))

  000c8	49 8b 44 24 38	 mov	 rax, QWORD PTR [r12+56]
  000cd	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  000d2	44 8b 80 b0 01
	00 00		 mov	 r8d, DWORD PTR [rax+432]
  000d9	e8 00 00 00 00	 call	 assemble_init
  000de	85 c0		 test	 eax, eax
  000e0	0f 84 af 00 00
	00		 je	 $error$25034

; 4229 :         goto error;
; 4230 :     dfs(c, entryblock, &a);

  000e6	4c 8d 44 24 20	 lea	 r8, QWORD PTR a$[rsp]
  000eb	48 8b d3	 mov	 rdx, rbx
  000ee	49 8b cc	 mov	 rcx, r12
  000f1	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  000f6	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  000fb	e8 00 00 00 00	 call	 dfs

; 4231 : 
; 4232 :     /* Can't modify the bytecode after computing jump offsets. */
; 4233 :     assemble_jump_offsets(&a, c);

  00100	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  00105	49 8b d4	 mov	 rdx, r12
  00108	e8 00 00 00 00	 call	 assemble_jump_offsets

; 4234 : 
; 4235 :     /* Emit code in reverse postorder from dfs. */
; 4236 :     for (i = a.a_nblocks - 1; i >= 0; i--) {

  0010d	44 8b 5c 24 2c	 mov	 r11d, DWORD PTR a$[rsp+12]
  00112	41 ff cb	 dec	 r11d
  00115	49 63 f3	 movsxd	 rsi, r11d
  00118	78 3b		 js	 SHORT $LN7@assemble
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL9@assemble:

; 4237 :         b = a.a_postorder[i];

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp+16]

; 4238 :         for (j = 0; j < b->b_iused; j++)

  00125	8b dd		 mov	 ebx, ebp
  00127	48 8b 3c f0	 mov	 rdi, QWORD PTR [rax+rsi*8]
  0012b	39 5f 08	 cmp	 DWORD PTR [rdi+8], ebx
  0012e	7e 20		 jle	 SHORT $LN8@assemble
$LL6@assemble:

; 4239 :             if (!assemble_emit(&a, &b->b_instr[j]))

  00130	48 63 d3	 movsxd	 rdx, ebx
  00133	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  00138	48 c1 e2 05	 shl	 rdx, 5
  0013c	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  00140	e8 00 00 00 00	 call	 assemble_emit
  00145	85 c0		 test	 eax, eax
  00147	74 42		 je	 SHORT $LN32@assemble

; 4238 :         for (j = 0; j < b->b_iused; j++)

  00149	ff c3		 inc	 ebx
  0014b	3b 5f 08	 cmp	 ebx, DWORD PTR [rdi+8]
  0014e	7c e0		 jl	 SHORT $LL6@assemble
$LN8@assemble:

; 4234 : 
; 4235 :     /* Emit code in reverse postorder from dfs. */
; 4236 :     for (i = a.a_nblocks - 1; i >= 0; i--) {

  00150	48 ff ce	 dec	 rsi
  00153	79 cb		 jns	 SHORT $LL9@assemble
$LN7@assemble:

; 4240 :                 goto error;
; 4241 :     }
; 4242 : 
; 4243 :     if (_PyBytes_Resize(&a.a_lnotab, a.a_lnotab_off) < 0)

  00155	48 63 54 24 40	 movsxd	 rdx, DWORD PTR a$[rsp+32]
  0015a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR a$[rsp+24]
  0015f	e8 00 00 00 00	 call	 _PyBytes_Resize
  00164	85 c0		 test	 eax, eax
  00166	78 23		 js	 SHORT $LN32@assemble

; 4244 :         goto error;
; 4245 :     if (_PyBytes_Resize(&a.a_bytecode, a.a_offset) < 0)

  00168	48 63 54 24 28	 movsxd	 rdx, DWORD PTR a$[rsp+8]
  0016d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  00172	e8 00 00 00 00	 call	 _PyBytes_Resize
  00177	85 c0		 test	 eax, eax
  00179	78 10		 js	 SHORT $LN32@assemble

; 4246 :         goto error;
; 4247 : 
; 4248 :     co = makecode(c, &a);

  0017b	48 8d 54 24 20	 lea	 rdx, QWORD PTR a$[rsp]
  00180	49 8b cc	 mov	 rcx, r12
  00183	e8 00 00 00 00	 call	 makecode
  00188	48 8b e8	 mov	 rbp, rax
$LN32@assemble:
  0018b	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00190	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
$error$25034:

; 4249 :  error:
; 4250 :     assemble_free(&a);

  00195	48 8d 4c 24 20	 lea	 rcx, QWORD PTR a$[rsp]
  0019a	e8 00 00 00 00	 call	 assemble_free

; 4251 :     return co;
; 4252 : }

  0019f	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001a4	48 8b c5	 mov	 rax, rbp
  001a7	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001ac	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001b0	41 5c		 pop	 r12
  001b2	c3		 ret	 0
assemble ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@		; `string'
EXTRN	PyUnicode_InternFromString:PROC
_BSS	SEGMENT
?name@?1??compiler_lambda@@9@9 DQ 01H DUP (?)		; `compiler_lambda'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_lambda DD imagerel compiler_lambda
	DD	imagerel compiler_lambda+123
	DD	imagerel $unwind$compiler_lambda
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_lambda DD imagerel compiler_lambda+123
	DD	imagerel compiler_lambda+401
	DD	imagerel $chain$2$compiler_lambda
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compiler_lambda DD imagerel compiler_lambda+401
	DD	imagerel compiler_lambda+515
	DD	imagerel $chain$4$compiler_lambda
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compiler_lambda DD 060021H
	DD	0e7400H
	DD	0d6400H
	DD	0c5400H
	DD	imagerel compiler_lambda
	DD	imagerel compiler_lambda+123
	DD	imagerel $unwind$compiler_lambda
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_lambda DD 061321H
	DD	0e7413H
	DD	0d640aH
	DD	0c5405H
	DD	imagerel compiler_lambda
	DD	imagerel compiler_lambda+123
	DD	imagerel $unwind$compiler_lambda
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_lambda DD 060e01H
	DD	0f00a520eH
	DD	0d006e008H
	DD	03002c004H
xdata	ENDS
;	COMDAT ??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@
CONST	SEGMENT
??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@ DB '<lambda>', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_lambda
_TEXT	SEGMENT
c$ = 96
e$ = 104
compiler_lambda PROC					; COMDAT

; 1786 : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1787 :     PyCodeObject *co;
; 1788 :     PyObject *qualname;
; 1789 :     static identifier name;
; 1790 :     int kw_default_count = 0, arglength;
; 1791 :     arguments_ty args = e->v.Lambda.args;

  0000e	4c 8b 6a 08	 mov	 r13, QWORD PTR [rdx+8]
  00012	45 33 e4	 xor	 r12d, r12d
  00015	4c 8b f2	 mov	 r14, rdx

; 1792 :     assert(e->kind == Lambda_kind);
; 1793 : 
; 1794 :     if (!name) {

  00018	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name@?1??compiler_lambda@@9@9
  0001f	48 8b d9	 mov	 rbx, rcx
  00022	45 8b fc	 mov	 r15d, r12d
  00025	48 85 d2	 test	 rdx, rdx
  00028	75 2b		 jne	 SHORT $LN17@compiler_l@3

; 1795 :         name = PyUnicode_InternFromString("<lambda>");

  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08JAHKMIKF@?$DMlambda?$DO?$AA@
  00031	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00036	48 8b d0	 mov	 rdx, rax
  00039	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_lambda@@9@9, rax

; 1796 :         if (!name)

  00040	48 85 c0	 test	 rax, rax
  00043	75 10		 jne	 SHORT $LN17@compiler_l@3
$LN37@compiler_l@3:

; 1797 :             return 0;

  00045	33 c0		 xor	 eax, eax

; 1839 : }

  00047	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004b	41 5f		 pop	 r15
  0004d	41 5e		 pop	 r14
  0004f	41 5d		 pop	 r13
  00051	41 5c		 pop	 r12
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN17@compiler_l@3:

; 1798 :     }
; 1799 : 
; 1800 :     if (args->kwonlyargs) {

  00055	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  00059	48 85 c0	 test	 rax, rax
  0005c	74 1d		 je	 SHORT $LN16@compiler_l@3

; 1801 :         int res = compiler_visit_kwonlydefaults(c, args->kwonlyargs,
; 1802 :                                                 args->kw_defaults);

  0005e	4d 8b 45 38	 mov	 r8, QWORD PTR [r13+56]
  00062	48 8b d0	 mov	 rdx, rax
  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 compiler_visit_kwonlydefaults
  0006d	44 8b f8	 mov	 r15d, eax

; 1803 :         if (res < 0) return 0;

  00070	85 c0		 test	 eax, eax
  00072	78 d1		 js	 SHORT $LN37@compiler_l@3

; 1804 :         kw_default_count = res;

  00074	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name@?1??compiler_lambda@@9@9
$LN16@compiler_l@3:
  0007b	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00080	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi

; 1805 :     }
; 1806 :     if (args->defaults)

  00085	49 8b 75 30	 mov	 rsi, QWORD PTR [r13+48]
  00089	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  0008e	48 85 f6	 test	 rsi, rsi
  00091	74 43		 je	 SHORT $LN11@compiler_l@3

; 1807 :         VISIT_SEQ(c, expr, args->defaults);

  00093	41 8b fc	 mov	 edi, r12d
  00096	48 8d 6e 08	 lea	 rbp, QWORD PTR [rsi+8]
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL13@compiler_l@3:
  000a0	49 8b cc	 mov	 rcx, r12
  000a3	48 85 f6	 test	 rsi, rsi
  000a6	74 03		 je	 SHORT $LN22@compiler_l@3
  000a8	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN22@compiler_l@3:
  000ab	48 63 c7	 movsxd	 rax, edi
  000ae	48 3b c1	 cmp	 rax, rcx
  000b1	7d 1c		 jge	 SHORT $LN31@compiler_l@3
  000b3	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 compiler_visit_expr
  000bf	85 c0		 test	 eax, eax
  000c1	0f 84 ab 00 00
	00		 je	 $LN1@compiler_l@3
  000c7	ff c7		 inc	 edi
  000c9	48 83 c5 08	 add	 rbp, 8
  000cd	eb d1		 jmp	 SHORT $LL13@compiler_l@3
$LN31@compiler_l@3:
  000cf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?name@?1??compiler_lambda@@9@9
$LN11@compiler_l@3:

; 1808 :     if (!compiler_enter_scope(c, name, COMPILER_SCOPE_FUNCTION,
; 1809 :                               (void *)e, e->lineno))

  000d6	41 8b 46 30	 mov	 eax, DWORD PTR [r14+48]
  000da	4d 8b ce	 mov	 r9, r14
  000dd	41 b8 02 00 00
	00		 mov	 r8d, 2
  000e3	48 8b cb	 mov	 rcx, rbx
  000e6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ea	e8 00 00 00 00	 call	 compiler_enter_scope
  000ef	85 c0		 test	 eax, eax

; 1810 :         return 0;

  000f1	74 7f		 je	 SHORT $LN1@compiler_l@3

; 1811 : 
; 1812 :     /* Make None the first constant, so the lambda can't have a
; 1813 :        docstring. */
; 1814 :     if (compiler_add_o(c, c->u->u_consts, Py_None) < 0)

  000f3	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  000fe	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00102	e8 00 00 00 00	 call	 compiler_add_o
  00107	85 c0		 test	 eax, eax

; 1815 :         return 0;

  00109	78 67		 js	 SHORT $LN1@compiler_l@3

; 1816 : 
; 1817 :     c->u->u_argcount = asdl_seq_LEN(args->args);

  0010b	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  0010f	49 8b cc	 mov	 rcx, r12
  00112	48 85 c0	 test	 rax, rax
  00115	74 03		 je	 SHORT $LN24@compiler_l@3
  00117	48 8b 08	 mov	 rcx, QWORD PTR [rax]
$LN24@compiler_l@3:
  0011a	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0011e	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1818 :     c->u->u_kwonlyargcount = asdl_seq_LEN(args->kwonlyargs);

  00121	49 8b 4d 18	 mov	 rcx, QWORD PTR [r13+24]
  00125	48 85 c9	 test	 rcx, rcx
  00128	75 05		 jne	 SHORT $LN25@compiler_l@3
  0012a	49 8b cc	 mov	 rcx, r12
  0012d	eb 03		 jmp	 SHORT $LN26@compiler_l@3
$LN25@compiler_l@3:
  0012f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN26@compiler_l@3:
  00132	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00136	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 1819 :     VISIT_IN_SCOPE(c, expr, e->v.Lambda.body);

  00139	49 8b 56 10	 mov	 rdx, QWORD PTR [r14+16]
  0013d	48 8b cb	 mov	 rcx, rbx
  00140	e8 00 00 00 00	 call	 compiler_visit_expr
  00145	85 c0		 test	 eax, eax
  00147	74 21		 je	 SHORT $LN35@compiler_l@3

; 1820 :     if (c->u->u_ste->ste_generator) {

  00149	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0014d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00150	f6 81 94 00 00
	00 04		 test	 BYTE PTR [rcx+148], 4

; 1821 :         ADDOP_IN_SCOPE(c, POP_TOP);

  00157	48 8b cb	 mov	 rcx, rbx
  0015a	74 35		 je	 SHORT $LN6@compiler_l@3
  0015c	ba 01 00 00 00	 mov	 edx, 1
$LN36@compiler_l@3:
  00161	e8 00 00 00 00	 call	 compiler_addop
  00166	85 c0		 test	 eax, eax
  00168	75 2e		 jne	 SHORT $LN3@compiler_l@3
$LN35@compiler_l@3:
  0016a	48 8b cb	 mov	 rcx, rbx
  0016d	e8 00 00 00 00	 call	 compiler_exit_scope
$LN1@compiler_l@3:

; 1830 :         return 0;

  00172	33 c0		 xor	 eax, eax
$LN34@compiler_l@3:
  00174	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00179	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0017e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 1839 : }

  00183	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00187	41 5f		 pop	 r15
  00189	41 5e		 pop	 r14
  0018b	41 5d		 pop	 r13
  0018d	41 5c		 pop	 r12
  0018f	5b		 pop	 rbx
  00190	c3		 ret	 0
$LN6@compiler_l@3:

; 1822 :     }
; 1823 :     else {
; 1824 :         ADDOP_IN_SCOPE(c, RETURN_VALUE);

  00191	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00196	eb c9		 jmp	 SHORT $LN36@compiler_l@3
$LN3@compiler_l@3:

; 1825 :     }
; 1826 :     co = assemble(c, 1);

  00198	ba 01 00 00 00	 mov	 edx, 1
  0019d	48 8b cb	 mov	 rcx, rbx
  001a0	e8 00 00 00 00	 call	 assemble

; 1827 :     qualname = compiler_scope_qualname(c);

  001a5	48 8b cb	 mov	 rcx, rbx
  001a8	48 8b f8	 mov	 rdi, rax
  001ab	e8 00 00 00 00	 call	 compiler_scope_qualname

; 1828 :     compiler_exit_scope(c);

  001b0	48 8b cb	 mov	 rcx, rbx
  001b3	48 8b f0	 mov	 rsi, rax
  001b6	e8 00 00 00 00	 call	 compiler_exit_scope

; 1829 :     if (qualname == NULL || co == NULL)

  001bb	48 85 f6	 test	 rsi, rsi
  001be	74 b2		 je	 SHORT $LN1@compiler_l@3
  001c0	48 85 ff	 test	 rdi, rdi
  001c3	74 ad		 je	 SHORT $LN1@compiler_l@3

; 1831 : 
; 1832 :     arglength = asdl_seq_LEN(args->defaults);

  001c5	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  001c9	48 85 c9	 test	 rcx, rcx
  001cc	74 03		 je	 SHORT $LN28@compiler_l@3
  001ce	44 8b 21	 mov	 r12d, DWORD PTR [rcx]
$LN28@compiler_l@3:

; 1833 :     arglength |= kw_default_count << 8;

  001d1	41 c1 e7 08	 shl	 r15d, 8

; 1834 :     compiler_make_closure(c, co, arglength, qualname);

  001d5	4c 8b ce	 mov	 r9, rsi
  001d8	48 8b d7	 mov	 rdx, rdi
  001db	45 0b fc	 or	 r15d, r12d
  001de	48 8b cb	 mov	 rcx, rbx
  001e1	45 8b c7	 mov	 r8d, r15d
  001e4	e8 00 00 00 00	 call	 compiler_make_closure

; 1835 :     Py_DECREF(qualname);

  001e9	48 8b ce	 mov	 rcx, rsi
  001ec	e8 00 00 00 00	 call	 _Py_DecRef

; 1836 :     Py_DECREF(co);

  001f1	48 8b cf	 mov	 rcx, rdi
  001f4	e8 00 00 00 00	 call	 _Py_DecRef

; 1837 : 
; 1838 :     return 1;

  001f9	b8 01 00 00 00	 mov	 eax, 1
  001fe	e9 71 ff ff ff	 jmp	 $LN34@compiler_l@3
compiler_lambda ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Substring:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_import_as DD imagerel compiler_import_as
	DD	imagerel compiler_import_as+78
	DD	imagerel $unwind$compiler_import_as
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_import_as DD imagerel compiler_import_as+78
	DD	imagerel compiler_import_as+380
	DD	imagerel $chain$1$compiler_import_as
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_import_as DD imagerel compiler_import_as+380
	DD	imagerel compiler_import_as+389
	DD	imagerel $chain$3$compiler_import_as
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_import_as DD 040021H
	DD	097400H
	DD	083400H
	DD	imagerel compiler_import_as
	DD	imagerel compiler_import_as+78
	DD	imagerel $unwind$compiler_import_as
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_import_as DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel compiler_import_as
	DD	imagerel compiler_import_as+78
	DD	imagerel $unwind$compiler_import_as
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_import_as DD 061001H
	DD	0b6410H
	DD	0a5410H
	DD	0c00c5210H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT compiler_import_as
_TEXT	SEGMENT
c$ = 64
name$ = 72
asname$ = 80
compiler_import_as PROC					; COMDAT

; 2223 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2224 :     /* The IMPORT_NAME opcode was already generated.  This function
; 2225 :        merely needs to bind the result to a name.
; 2226 : 
; 2227 :        If there is a dot in name, we need to split it and emit a
; 2228 :        LOAD_ATTR for each name.
; 2229 :     */
; 2230 :     Py_ssize_t dot = PyUnicode_FindChar(name, '.', 0,
; 2231 :                                         PyUnicode_GET_LENGTH(name), 1);

  00010	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  00014	48 8b f2	 mov	 rsi, rdx
  00017	4d 8b e0	 mov	 r12, r8
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	48 8b e9	 mov	 rbp, rcx
  00020	48 8b ce	 mov	 rcx, rsi
  00023	41 8d 50 2e	 lea	 edx, QWORD PTR [r8+46]
  00027	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002f	e8 00 00 00 00	 call	 PyUnicode_FindChar

; 2232 :     if (dot == -2)

  00034	48 83 f8 fe	 cmp	 rax, -2
  00038	75 14		 jne	 SHORT $LN7@compiler_i@4

; 2233 :         return -1;

  0003a	83 c8 ff	 or	 eax, -1

; 2254 : }

  0003d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00042	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00047	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004b	41 5c		 pop	 r12
  0004d	c3		 ret	 0
$LN7@compiler_i@4:
  0004e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00053	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 2234 :     if (dot != -1) {

  00058	48 83 f8 ff	 cmp	 rax, -1
  0005c	0f 84 ee 00 00
	00		 je	 $LN4@compiler_i@4

; 2235 :         /* Consume the base module name to get the first attribute */
; 2236 :         Py_ssize_t pos = dot + 1;

  00062	48 8d 58 01	 lea	 rbx, QWORD PTR [rax+1]
  00066	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@compiler_i@4:

; 2237 :         while (dot != -1) {
; 2238 :             PyObject *attr;
; 2239 :             dot = PyUnicode_FindChar(name, '.', pos,
; 2240 :                                      PyUnicode_GET_LENGTH(name), 1);

  00070	4c 8b 4e 60	 mov	 r9, QWORD PTR [rsi+96]
  00074	4c 8b c3	 mov	 r8, rbx
  00077	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  0007c	48 8b ce	 mov	 rcx, rsi
  0007f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00087	e8 00 00 00 00	 call	 PyUnicode_FindChar
  0008c	48 8b f8	 mov	 rdi, rax

; 2241 :             if (dot == -2)

  0008f	48 83 f8 fe	 cmp	 rax, -2
  00093	0f 84 e7 00 00
	00		 je	 $LN24@compiler_i@4

; 2243 :             attr = PyUnicode_Substring(name, pos,
; 2244 :                                        (dot != -1) ? dot :
; 2245 :                                        PyUnicode_GET_LENGTH(name));

  00099	4c 8b c0	 mov	 r8, rax
  0009c	48 83 f8 ff	 cmp	 rax, -1
  000a0	75 04		 jne	 SHORT $LN11@compiler_i@4
  000a2	4c 8b 46 60	 mov	 r8, QWORD PTR [rsi+96]
$LN11@compiler_i@4:
  000a6	48 8b d3	 mov	 rdx, rbx
  000a9	48 8b ce	 mov	 rcx, rsi
  000ac	e8 00 00 00 00	 call	 PyUnicode_Substring
  000b1	48 8b d8	 mov	 rbx, rax

; 2246 :             if (!attr)

  000b4	48 85 c0	 test	 rax, rax
  000b7	0f 84 c3 00 00
	00		 je	 $LN24@compiler_i@4

; 2247 :                 return -1;
; 2248 :             ADDOP_O(c, LOAD_ATTR, attr, names);

  000bd	4c 8b 45 38	 mov	 r8, QWORD PTR [rbp+56]
  000c1	4c 8b c8	 mov	 r9, rax
  000c4	ba 6a 00 00 00	 mov	 edx, 106		; 0000006aH
  000c9	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  000cd	48 8b cd	 mov	 rcx, rbp
  000d0	e8 00 00 00 00	 call	 compiler_addop_o
  000d5	85 c0		 test	 eax, eax
  000d7	0f 84 9f 00 00
	00		 je	 $LN26@compiler_i@4

; 2249 :             Py_DECREF(attr);

  000dd	e8 00 00 00 00	 call	 _Py_PXCTX
  000e2	85 c0		 test	 eax, eax
  000e4	75 5c		 jne	 SHORT $LN22@compiler_i@4
  000e6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ea	a8 20		 test	 al, 32			; 00000020H
  000ec	75 4c		 jne	 SHORT $LN16@compiler_i@4
  000ee	84 c0		 test	 al, al
  000f0	78 48		 js	 SHORT $LN16@compiler_i@4
  000f2	a8 02		 test	 al, 2
  000f4	75 4c		 jne	 SHORT $LN22@compiler_i@4
  000f6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000fa	75 46		 jne	 SHORT $LN22@compiler_i@4
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0010a	4c 8b cb	 mov	 r9, rbx
  0010d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00113	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00120	48 8b cb	 mov	 rcx, rbx
  00123	85 c0		 test	 eax, eax
  00125	74 07		 je	 SHORT $LN21@compiler_i@4
  00127	e8 00 00 00 00	 call	 _Px_Dealloc
  0012c	eb 14		 jmp	 SHORT $LN22@compiler_i@4
$LN21@compiler_i@4:
  0012e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00132	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00138	eb 08		 jmp	 SHORT $LN22@compiler_i@4
$LN16@compiler_i@4:
  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	e8 00 00 00 00	 call	 Px_DecRef
$LN22@compiler_i@4:

; 2250 :             pos = dot + 1;

  00142	48 8d 5f 01	 lea	 rbx, QWORD PTR [rdi+1]
  00146	48 83 ff ff	 cmp	 rdi, -1
  0014a	0f 85 20 ff ff
	ff		 jne	 $LL5@compiler_i@4
$LN4@compiler_i@4:

; 2251 :         }
; 2252 :     }
; 2253 :     return compiler_nameop(c, asname, Store);

  00150	41 b8 02 00 00
	00		 mov	 r8d, 2
  00156	49 8b d4	 mov	 rdx, r12
  00159	48 8b cd	 mov	 rcx, rbp
  0015c	e8 00 00 00 00	 call	 compiler_nameop
$LN29@compiler_i@4:

; 2254 : }

  00161	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00166	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0016b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00170	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00175	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00179	41 5c		 pop	 r12
  0017b	c3		 ret	 0
$LN26@compiler_i@4:

; 2247 :                 return -1;
; 2248 :             ADDOP_O(c, LOAD_ATTR, attr, names);

  0017c	33 c0		 xor	 eax, eax
  0017e	eb e1		 jmp	 SHORT $LN29@compiler_i@4
$LN24@compiler_i@4:

; 2242 :                 return -1;

  00180	83 c8 ff	 or	 eax, -1
  00183	eb dc		 jmp	 SHORT $LN29@compiler_i@4
compiler_import_as ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_import DD imagerel compiler_import
	DD	imagerel compiler_import+371
	DD	imagerel $unwind$compiler_import
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_import DD 0c3801H
	DD	0c7438H
	DD	0b5430H
	DD	0a342bH
	DD	0d640fH
	DD	0e00b520fH
	DD	0c007d009H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_import
_TEXT	SEGMENT
c$ = 80
s$ = 88
compiler_import PROC					; COMDAT

; 2258 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2259 :     /* The Import node stores a module name like a.b.c as a single
; 2260 :        string.  This is convenient for all cases except
; 2261 :          import a.b.c as d
; 2262 :        where we need to parse that string to extract the individual
; 2263 :        module names.
; 2264 :        XXX Perhaps change the representation to make this case simpler?
; 2265 :      */
; 2266 :     int i, n = asdl_seq_LEN(s->v.Import.names);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	33 f6		 xor	 esi, esi
  00015	4c 8b f2	 mov	 r14, rdx
  00018	4c 8b e1	 mov	 r12, rcx
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 04		 jne	 SHORT $LN16@compiler_i@5
  00020	8b c6		 mov	 eax, esi
  00022	eb 02		 jmp	 SHORT $LN17@compiler_i@5
$LN16@compiler_i@5:
  00024	8b 00		 mov	 eax, DWORD PTR [rax]
$LN17@compiler_i@5:
  00026	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0002b	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 2267 : 
; 2268 :     for (i = 0; i < n; i++) {

  00030	4c 63 e8	 movsxd	 r13, eax
  00033	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00038	85 c0		 test	 eax, eax
  0003a	0f 8e 0b 01 00
	00		 jle	 $LN11@compiler_i@5
$LL13@compiler_i@5:

; 2269 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.Import.names, i);

  00040	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]

; 2270 :         int r;
; 2271 :         PyObject *level;
; 2272 : 
; 2273 :         level = PyLong_FromLong(0);

  00044	33 c9		 xor	 ecx, ecx
  00046	48 8b 7c f0 08	 mov	 rdi, QWORD PTR [rax+rsi*8+8]
  0004b	e8 00 00 00 00	 call	 PyLong_FromLong
  00050	48 8b d8	 mov	 rbx, rax

; 2274 :         if (level == NULL)

  00053	48 85 c0	 test	 rax, rax
  00056	0f 84 13 01 00
	00		 je	 $LN19@compiler_i@5

; 2276 : 
; 2277 :         ADDOP_O(c, LOAD_CONST, level, consts);

  0005c	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  00061	4c 8b c8	 mov	 r9, rax
  00064	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00069	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0006d	49 8b cc	 mov	 rcx, r12
  00070	e8 00 00 00 00	 call	 compiler_addop_o
  00075	85 c0		 test	 eax, eax
  00077	0f 84 f2 00 00
	00		 je	 $LN19@compiler_i@5

; 2278 :         Py_DECREF(level);

  0007d	48 8b cb	 mov	 rcx, rbx
  00080	e8 00 00 00 00	 call	 _Py_DecRef

; 2279 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00085	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  0008a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00091	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00095	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0009a	49 8b cc	 mov	 rcx, r12
  0009d	e8 00 00 00 00	 call	 compiler_addop_o
  000a2	85 c0		 test	 eax, eax
  000a4	0f 84 c5 00 00
	00		 je	 $LN19@compiler_i@5

; 2280 :         ADDOP_NAME(c, IMPORT_NAME, alias->name, names);

  000aa	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  000af	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  000b2	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  000b7	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  000bb	49 8b cc	 mov	 rcx, r12
  000be	e8 00 00 00 00	 call	 compiler_addop_name
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 a4 00 00
	00		 je	 $LN19@compiler_i@5

; 2281 : 
; 2282 :         if (alias->asname) {

  000cb	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  000cf	4d 85 c0	 test	 r8, r8
  000d2	74 0f		 je	 SHORT $LN6@compiler_i@5

; 2283 :             r = compiler_import_as(c, alias->name, alias->asname);

  000d4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000d7	49 8b cc	 mov	 rcx, r12
  000da	e8 00 00 00 00	 call	 compiler_import_as

; 2284 :             if (!r)

  000df	85 c0		 test	 eax, eax

; 2285 :                 return r;
; 2286 :         }
; 2287 :         else {

  000e1	eb 5a		 jmp	 SHORT $LN27@compiler_i@5
$LN6@compiler_i@5:

; 2288 :             identifier tmp = alias->name;

  000e3	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 2289 :             Py_ssize_t dot = PyUnicode_FindChar(
; 2290 :                 alias->name, '.', 0, PyUnicode_GET_LENGTH(alias->name), 1);

  000e6	45 33 c0	 xor	 r8d, r8d
  000e9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f1	4c 8b 4b 60	 mov	 r9, QWORD PTR [rbx+96]
  000f5	41 8d 50 2e	 lea	 edx, QWORD PTR [r8+46]
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00101	48 8b e8	 mov	 rbp, rax

; 2291 :             if (dot != -1)

  00104	48 83 f8 ff	 cmp	 rax, -1
  00108	74 10		 je	 SHORT $LN3@compiler_i@5

; 2292 :                 tmp = PyUnicode_Substring(alias->name, 0, dot);

  0010a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0010d	4c 8b c0	 mov	 r8, rax
  00110	33 d2		 xor	 edx, edx
  00112	e8 00 00 00 00	 call	 PyUnicode_Substring
  00117	48 8b d8	 mov	 rbx, rax
$LN3@compiler_i@5:

; 2293 :             r = compiler_nameop(c, tmp, Store);

  0011a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00120	48 8b d3	 mov	 rdx, rbx
  00123	49 8b cc	 mov	 rcx, r12
  00126	e8 00 00 00 00	 call	 compiler_nameop
  0012b	8b f8		 mov	 edi, eax

; 2294 :             if (dot != -1) {

  0012d	48 83 fd ff	 cmp	 rbp, -1
  00131	74 08		 je	 SHORT $LN2@compiler_i@5

; 2295 :                 Py_DECREF(tmp);

  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@compiler_i@5:

; 2296 :             }
; 2297 :             if (!r)

  0013b	85 ff		 test	 edi, edi
$LN27@compiler_i@5:
  0013d	74 30		 je	 SHORT $LN19@compiler_i@5

; 2267 : 
; 2268 :     for (i = 0; i < n; i++) {

  0013f	48 ff c6	 inc	 rsi
  00142	49 3b f5	 cmp	 rsi, r13
  00145	0f 8c f5 fe ff
	ff		 jl	 $LL13@compiler_i@5
$LN11@compiler_i@5:

; 2298 :                 return r;
; 2299 :         }
; 2300 :     }
; 2301 :     return 1;

  0014b	b8 01 00 00 00	 mov	 eax, 1
$LN14@compiler_i@5:
  00150	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00155	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  0015a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 2302 : }

  0015f	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00164	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00168	41 5e		 pop	 r14
  0016a	41 5d		 pop	 r13
  0016c	41 5c		 pop	 r12
  0016e	c3		 ret	 0
$LN19@compiler_i@5:

; 2275 :             return 0;

  0016f	33 c0		 xor	 eax, eax
  00171	eb dd		 jmp	 SHORT $LN14@compiler_i@5
compiler_import ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ ; `string'
PUBLIC	??_C@_0L@GKAJCJCM@__future__?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyUnicode_CompareWithASCIIString:PROC
EXTRN	PyUnicode_FromString:PROC
_BSS	SEGMENT
?empty_string@?1??compiler_from_import@@9@9 DQ 01H DUP (?) ; `compiler_from_import'::`2'::empty_string
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_from_import DD imagerel compiler_from_import
	DD	imagerel compiler_from_import+109
	DD	imagerel $unwind$compiler_from_import
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_from_import DD imagerel compiler_from_import+109
	DD	imagerel compiler_from_import+156
	DD	imagerel $chain$0$compiler_from_import
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compiler_from_import DD imagerel compiler_from_import+156
	DD	imagerel compiler_from_import+793
	DD	imagerel $chain$4$compiler_from_import
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$compiler_from_import DD imagerel compiler_from_import+793
	DD	imagerel compiler_from_import+833
	DD	imagerel $chain$6$compiler_from_import
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$compiler_from_import DD 060021H
	DD	0e7400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel compiler_from_import
	DD	imagerel compiler_from_import+109
	DD	imagerel $unwind$compiler_from_import
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compiler_from_import DD 060a21H
	DD	0e740aH
	DD	0c3405H
	DD	0d5400H
	DD	imagerel compiler_from_import
	DD	imagerel compiler_from_import+109
	DD	imagerel $unwind$compiler_from_import
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_from_import DD 020521H
	DD	0d5405H
	DD	imagerel compiler_from_import
	DD	imagerel compiler_from_import+109
	DD	imagerel $unwind$compiler_from_import
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_from_import DD 060e01H
	DD	0f00a520eH
	DD	0d006e008H
	DD	06002c004H
xdata	ENDS
;	COMDAT ??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
CONST	SEGMENT
??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@ DB 'from __futur'
	DB	'e__ imports must occur at the beginning of the file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GKAJCJCM@__future__?$AA@
CONST	SEGMENT
??_C@_0L@GKAJCJCM@__future__?$AA@ DB '__future__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT compiler_from_import
_TEXT	SEGMENT
c$ = 96
s$ = 104
compiler_from_import PROC				; COMDAT

; 2306 : {

  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2307 :     int i, n = asdl_seq_LEN(s->v.ImportFrom.names);

  0000e	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00012	33 f6		 xor	 esi, esi
  00014	4c 8b ea	 mov	 r13, rdx
  00017	4c 8b e1	 mov	 r12, rcx
  0001a	48 85 c0	 test	 rax, rax
  0001d	75 04		 jne	 SHORT $LN26@compiler_f@2
  0001f	8b c6		 mov	 eax, esi
  00021	eb 02		 jmp	 SHORT $LN27@compiler_f@2
$LN26@compiler_f@2:
  00023	8b 00		 mov	 eax, DWORD PTR [rax]
$LN27@compiler_f@2:

; 2308 : 
; 2309 :     PyObject *names = PyTuple_New(n);

  00025	4c 63 f0	 movsxd	 r14, eax
  00028	49 8b ce	 mov	 rcx, r14
  0002b	e8 00 00 00 00	 call	 PyTuple_New

; 2310 :     PyObject *level;
; 2311 :     static PyObject *empty_string;
; 2312 : 
; 2313 :     if (!empty_string) {

  00030	48 39 35 00 00
	00 00		 cmp	 QWORD PTR ?empty_string@?1??compiler_from_import@@9@9, rsi
  00037	4c 8b f8	 mov	 r15, rax
  0003a	75 28		 jne	 SHORT $LN22@compiler_f@2

; 2314 :         empty_string = PyUnicode_FromString("");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00043	e8 00 00 00 00	 call	 PyUnicode_FromString
  00048	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?empty_string@?1??compiler_from_import@@9@9, rax

; 2315 :         if (!empty_string)

  0004f	48 85 c0	 test	 rax, rax
  00052	75 10		 jne	 SHORT $LN22@compiler_f@2
$LN59@compiler_f@2:

; 2316 :             return 0;

  00054	33 c0		 xor	 eax, eax

; 2375 :     return 1;
; 2376 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	41 5f		 pop	 r15
  0005c	41 5e		 pop	 r14
  0005e	41 5d		 pop	 r13
  00060	41 5c		 pop	 r12
  00062	5e		 pop	 rsi
  00063	c3		 ret	 0
$LN22@compiler_f@2:

; 2317 :     }
; 2318 : 
; 2319 :     if (!names)

  00064	4d 85 ff	 test	 r15, r15

; 2320 :         return 0;

  00067	74 eb		 je	 SHORT $LN59@compiler_f@2

; 2321 : 
; 2322 :     level = PyLong_FromLong(s->v.ImportFrom.level);

  00069	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  0006d	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00072	e8 00 00 00 00	 call	 PyLong_FromLong
  00077	48 8b e8	 mov	 rbp, rax

; 2323 :     if (!level) {

  0007a	48 85 c0	 test	 rax, rax
  0007d	75 1d		 jne	 SHORT $LN20@compiler_f@2

; 2324 :         Py_DECREF(names);

  0007f	49 8b cf	 mov	 rcx, r15
  00082	e8 00 00 00 00	 call	 _Py_DecRef
  00087	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 2325 :         return 0;

  0008c	33 c0		 xor	 eax, eax

; 2375 :     return 1;
; 2376 : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	41 5f		 pop	 r15
  00094	41 5e		 pop	 r14
  00096	41 5d		 pop	 r13
  00098	41 5c		 pop	 r12
  0009a	5e		 pop	 rsi
  0009b	c3		 ret	 0
$LN20@compiler_f@2:
  0009c	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  000a1	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 2326 :     }
; 2327 : 
; 2328 :     /* build up the names */
; 2329 :     for (i = 0; i < n; i++) {

  000a6	48 8b de	 mov	 rbx, rsi
  000a9	4d 85 f6	 test	 r14, r14
  000ac	7e 5b		 jle	 SHORT $LN17@compiler_f@2
  000ae	66 90		 npad	 2
$LL19@compiler_f@2:

; 2330 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.ImportFrom.names, i);

  000b0	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  000b4	48 8b 74 d8 08	 mov	 rsi, QWORD PTR [rax+rbx*8+8]

; 2331 :         Py_INCREF(alias->name);

  000b9	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]
  000bc	e8 00 00 00 00	 call	 _Py_PXCTX
  000c1	85 c0		 test	 eax, eax
  000c3	75 32		 jne	 SHORT $LN45@compiler_f@2
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d3	4c 8b cf	 mov	 r9, rdi
  000d6	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000dc	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e9	85 c0		 test	 eax, eax
  000eb	75 06		 jne	 SHORT $LN44@compiler_f@2
  000ed	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000f1	74 04		 je	 SHORT $LN45@compiler_f@2
$LN44@compiler_f@2:
  000f3	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN45@compiler_f@2:

; 2332 :         PyTuple_SET_ITEM(names, i, alias->name);

  000f7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000fa	48 ff c3	 inc	 rbx
  000fd	49 89 44 df 68	 mov	 QWORD PTR [r15+rbx*8+104], rax
  00102	49 3b de	 cmp	 rbx, r14
  00105	7c a9		 jl	 SHORT $LL19@compiler_f@2
  00107	33 f6		 xor	 esi, esi
$LN17@compiler_f@2:

; 2333 :     }
; 2334 : 
; 2335 :     if (s->lineno > c->c_future->ff_lineno && s->v.ImportFrom.module &&
; 2336 :         !PyUnicode_CompareWithASCIIString(s->v.ImportFrom.module, "__future__")) {

  00109	49 8b 44 24 18	 mov	 rax, QWORD PTR [r12+24]
  0010e	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00111	41 39 4d 40	 cmp	 DWORD PTR [r13+64], ecx
  00115	7e 3d		 jle	 SHORT $LN16@compiler_f@2
  00117	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  0011b	48 85 c9	 test	 rcx, rcx
  0011e	74 34		 je	 SHORT $LN16@compiler_f@2
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKAJCJCM@__future__?$AA@
  00127	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0012c	85 c0		 test	 eax, eax
  0012e	75 24		 jne	 SHORT $LN16@compiler_f@2

; 2337 :         Py_DECREF(level);

  00130	48 8b cd	 mov	 rcx, rbp
  00133	e8 00 00 00 00	 call	 _Py_DecRef

; 2338 :         Py_DECREF(names);

  00138	49 8b cf	 mov	 rcx, r15
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 2339 :         return compiler_error(c, "from __future__ imports must occur "
; 2340 :                               "at the beginning of the file");

  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@GLIDBFMH@from?5__future__?5imports?5must?5occ@
  00147	49 8b cc	 mov	 rcx, r12
  0014a	e8 00 00 00 00	 call	 compiler_error
  0014f	e9 a8 01 00 00	 jmp	 $LN58@compiler_f@2
$LN16@compiler_f@2:

; 2341 :     }
; 2342 : 
; 2343 :     ADDOP_O(c, LOAD_CONST, level, consts);

  00154	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  00159	4c 8b cd	 mov	 r9, rbp
  0015c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00161	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00165	49 8b cc	 mov	 rcx, r12
  00168	e8 00 00 00 00	 call	 compiler_addop_o
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 c8 01 00
	00		 je	 $LN51@compiler_f@2

; 2344 :     Py_DECREF(level);

  00175	48 8b cd	 mov	 rcx, rbp
  00178	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :     ADDOP_O(c, LOAD_CONST, names, consts);

  0017d	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  00182	4d 8b cf	 mov	 r9, r15
  00185	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00189	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0018e	49 8b cc	 mov	 rcx, r12
  00191	e8 00 00 00 00	 call	 compiler_addop_o
  00196	85 c0		 test	 eax, eax
  00198	0f 84 9f 01 00
	00		 je	 $LN51@compiler_f@2

; 2346 :     Py_DECREF(names);

  0019e	49 8b cf	 mov	 rcx, r15
  001a1	e8 00 00 00 00	 call	 _Py_DecRef

; 2347 :     if (s->v.ImportFrom.module) {

  001a6	4d 8b 4d 08	 mov	 r9, QWORD PTR [r13+8]

; 2348 :         ADDOP_NAME(c, IMPORT_NAME, s->v.ImportFrom.module, names);

  001aa	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  001af	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  001b3	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  001b8	49 8b cc	 mov	 rcx, r12
  001bb	4d 85 c9	 test	 r9, r9
  001be	74 0e		 je	 SHORT $LN13@compiler_f@2
  001c0	e8 00 00 00 00	 call	 compiler_addop_name
  001c5	85 c0		 test	 eax, eax
  001c7	75 19		 jne	 SHORT $LN10@compiler_f@2
  001c9	e9 2e 01 00 00	 jmp	 $LN58@compiler_f@2
$LN13@compiler_f@2:

; 2349 :     }
; 2350 :     else {
; 2351 :         ADDOP_NAME(c, IMPORT_NAME, empty_string, names);

  001ce	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?empty_string@?1??compiler_from_import@@9@9
  001d5	e8 00 00 00 00	 call	 compiler_addop_name
  001da	85 c0		 test	 eax, eax
  001dc	0f 84 5b 01 00
	00		 je	 $LN51@compiler_f@2
$LN10@compiler_f@2:

; 2352 :     }
; 2353 :     for (i = 0; i < n; i++) {

  001e2	48 8b de	 mov	 rbx, rsi
  001e5	4d 85 f6	 test	 r14, r14
  001e8	0f 8e f7 00 00
	00		 jle	 $LN7@compiler_f@2
  001ee	66 90		 npad	 2
$LL9@compiler_f@2:

; 2354 :         alias_ty alias = (alias_ty)asdl_seq_GET(s->v.ImportFrom.names, i);

  001f0	49 8b 45 10	 mov	 rax, QWORD PTR [r13+16]
  001f4	48 8b 7c d8 08	 mov	 rdi, QWORD PTR [rax+rbx*8+8]

; 2355 :         identifier store_name;
; 2356 : 
; 2357 :         if (i == 0 && PyUnicode_READ_CHAR(alias->name, 0) == '*') {

  001f9	48 85 db	 test	 rbx, rbx
  001fc	0f 85 96 00 00
	00		 jne	 $LN6@compiler_f@2
  00202	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00205	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00208	8b d1		 mov	 edx, ecx
  0020a	c1 ea 02	 shr	 edx, 2
  0020d	83 e2 07	 and	 edx, 7
  00210	83 fa 01	 cmp	 edx, 1
  00213	75 2a		 jne	 SHORT $LN42@compiler_f@2
  00215	f6 c1 20	 test	 cl, 32			; 00000020H
  00218	74 19		 je	 SHORT $LN30@compiler_f@2
  0021a	f6 c1 40	 test	 cl, 64			; 00000040H
  0021d	74 09		 je	 SHORT $LN28@compiler_f@2
  0021f	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00223	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00226	eb 67		 jmp	 SHORT $LN41@compiler_f@2
$LN28@compiler_f@2:
  00228	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0022e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00231	eb 5c		 jmp	 SHORT $LN41@compiler_f@2
$LN30@compiler_f@2:
  00233	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0023a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023d	eb 50		 jmp	 SHORT $LN41@compiler_f@2
$LN42@compiler_f@2:
  0023f	83 fa 02	 cmp	 edx, 2
  00242	75 2a		 jne	 SHORT $LN40@compiler_f@2
  00244	f6 c1 20	 test	 cl, 32			; 00000020H
  00247	74 19		 je	 SHORT $LN34@compiler_f@2
  00249	f6 c1 40	 test	 cl, 64			; 00000040H
  0024c	74 09		 je	 SHORT $LN32@compiler_f@2
  0024e	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  00252	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00255	eb 38		 jmp	 SHORT $LN41@compiler_f@2
$LN32@compiler_f@2:
  00257	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0025d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00260	eb 2d		 jmp	 SHORT $LN41@compiler_f@2
$LN34@compiler_f@2:
  00262	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00269	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0026c	eb 21		 jmp	 SHORT $LN41@compiler_f@2
$LN40@compiler_f@2:
  0026e	f6 c1 20	 test	 cl, 32			; 00000020H
  00271	74 13		 je	 SHORT $LN38@compiler_f@2
  00273	f6 c1 40	 test	 cl, 64			; 00000040H
  00276	74 06		 je	 SHORT $LN36@compiler_f@2
  00278	48 83 e8 80	 sub	 rax, -128		; ffffffffffffff80H
  0027c	eb 0f		 jmp	 SHORT $LN39@compiler_f@2
$LN36@compiler_f@2:
  0027e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00284	eb 07		 jmp	 SHORT $LN39@compiler_f@2
$LN38@compiler_f@2:
  00286	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
$LN39@compiler_f@2:
  0028d	8b 00		 mov	 eax, DWORD PTR [rax]
$LN41@compiler_f@2:
  0028f	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00292	0f 84 81 00 00
	00		 je	 $LN50@compiler_f@2
$LN6@compiler_f@2:

; 2361 :         }
; 2362 : 
; 2363 :         ADDOP_NAME(c, IMPORT_FROM, alias->name, names);

  00298	4d 8b 44 24 38	 mov	 r8, QWORD PTR [r12+56]
  0029d	4c 8b 0f	 mov	 r9, QWORD PTR [rdi]
  002a0	ba 6d 00 00 00	 mov	 edx, 109		; 0000006dH
  002a5	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  002a9	49 8b cc	 mov	 rcx, r12
  002ac	e8 00 00 00 00	 call	 compiler_addop_name
  002b1	85 c0		 test	 eax, eax
  002b3	0f 84 84 00 00
	00		 je	 $LN51@compiler_f@2

; 2364 :         store_name = alias->name;
; 2365 :         if (alias->asname)

  002b9	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  002bd	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 2366 :             store_name = alias->asname;
; 2367 : 
; 2368 :         if (!compiler_nameop(c, store_name, Store)) {

  002c0	41 b8 02 00 00
	00		 mov	 r8d, 2
  002c6	48 85 c0	 test	 rax, rax
  002c9	49 8b cc	 mov	 rcx, r12
  002cc	48 0f 45 d0	 cmovne	 rdx, rax
  002d0	e8 00 00 00 00	 call	 compiler_nameop
  002d5	85 c0		 test	 eax, eax
  002d7	74 5c		 je	 SHORT $LN52@compiler_f@2

; 2352 :     }
; 2353 :     for (i = 0; i < n; i++) {

  002d9	48 ff c3	 inc	 rbx
  002dc	49 3b de	 cmp	 rbx, r14
  002df	0f 8c 0b ff ff
	ff		 jl	 $LL9@compiler_f@2
$LN7@compiler_f@2:

; 2371 :         }
; 2372 :     }
; 2373 :     /* remove imported module */
; 2374 :     ADDOP(c, POP_TOP);

  002e5	ba 01 00 00 00	 mov	 edx, 1
  002ea	49 8b cc	 mov	 rcx, r12
  002ed	e8 00 00 00 00	 call	 compiler_addop
  002f2	85 c0		 test	 eax, eax
  002f4	b8 00 00 00 00	 mov	 eax, 0
  002f9	0f 95 c0	 setne	 al
$LN58@compiler_f@2:
  002fc	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00301	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00306	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 2375 :     return 1;
; 2376 : }

  0030b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0030f	41 5f		 pop	 r15
  00311	41 5e		 pop	 r14
  00313	41 5d		 pop	 r13
  00315	41 5c		 pop	 r12
  00317	5e		 pop	 rsi
  00318	c3		 ret	 0
$LN50@compiler_f@2:

; 2358 :             assert(n == 1);
; 2359 :             ADDOP(c, IMPORT_STAR);

  00319	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  0031e	49 8b cc	 mov	 rcx, r12
  00321	e8 00 00 00 00	 call	 compiler_addop
  00326	be 00 00 00 00	 mov	 esi, 0
  0032b	85 c0		 test	 eax, eax
  0032d	40 0f 95 c6	 setne	 sil
  00331	8b c6		 mov	 eax, esi

; 2360 :             return 1;

  00333	eb c7		 jmp	 SHORT $LN58@compiler_f@2
$LN52@compiler_f@2:

; 2369 :             Py_DECREF(names);

  00335	49 8b cf	 mov	 rcx, r15
  00338	e8 00 00 00 00	 call	 _Py_DecRef
$LN51@compiler_f@2:

; 2370 :             return 0;

  0033d	33 c0		 xor	 eax, eax
  0033f	eb bb		 jmp	 SHORT $LN58@compiler_f@2
compiler_from_import ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_call_helper DD imagerel compiler_call_helper
	DD	imagerel compiler_call_helper+333
	DD	imagerel $unwind$compiler_call_helper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_call_helper DD 0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0e01a321eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_call_helper
_TEXT	SEGMENT
c$ = 64
n$ = 72
args$ = 80
keywords$ = 88
starargs$ = 96
kwargs$ = 104
compiler_call_helper PROC				; COMDAT

; 2903 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2904 :     int code = 0;

  0001e	33 db		 xor	 ebx, ebx
  00020	4d 8b e9	 mov	 r13, r9
  00023	49 8b f0	 mov	 rsi, r8
  00026	44 8b f2	 mov	 r14d, edx
  00029	4c 8b e1	 mov	 r12, rcx

; 2905 : 
; 2906 :     n += asdl_seq_LEN(args);

  0002c	8b c3		 mov	 eax, ebx
  0002e	4d 85 c0	 test	 r8, r8
  00031	74 03		 je	 SHORT $LN27@compiler_c@4
  00033	49 8b 00	 mov	 rax, QWORD PTR [r8]
$LN27@compiler_c@4:
  00036	44 03 f0	 add	 r14d, eax

; 2907 :     VISIT_SEQ(c, expr, args);

  00039	8b fb		 mov	 edi, ebx
  0003b	49 8d 68 08	 lea	 rbp, QWORD PTR [r8+8]
  0003f	90		 npad	 1
$LL23@compiler_c@4:
  00040	48 8b cb	 mov	 rcx, rbx
  00043	48 85 f6	 test	 rsi, rsi
  00046	74 03		 je	 SHORT $LN29@compiler_c@4
  00048	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN29@compiler_c@4:
  0004b	48 63 c7	 movsxd	 rax, edi
  0004e	48 3b c1	 cmp	 rax, rcx
  00051	7d 1c		 jge	 SHORT $LN21@compiler_c@4
  00053	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00057	49 8b cc	 mov	 rcx, r12
  0005a	e8 00 00 00 00	 call	 compiler_visit_expr
  0005f	85 c0		 test	 eax, eax
  00061	0f 84 aa 00 00
	00		 je	 $LN36@compiler_c@4
  00067	ff c7		 inc	 edi
  00069	48 83 c5 08	 add	 rbp, 8
  0006d	eb d1		 jmp	 SHORT $LL23@compiler_c@4
$LN21@compiler_c@4:

; 2908 :     if (keywords) {

  0006f	4d 85 ed	 test	 r13, r13
  00072	74 37		 je	 SHORT $LN19@compiler_c@4

; 2909 :         VISIT_SEQ(c, keyword, keywords);

  00074	8b fb		 mov	 edi, ebx
  00076	49 8d 75 08	 lea	 rsi, QWORD PTR [r13+8]
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL18@compiler_c@4:
  00080	48 63 c7	 movsxd	 rax, edi
  00083	49 3b 45 00	 cmp	 rax, QWORD PTR [r13]
  00087	7d 17		 jge	 SHORT $LN16@compiler_c@4
  00089	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0008c	49 8b cc	 mov	 rcx, r12
  0008f	e8 00 00 00 00	 call	 compiler_visit_keyword
  00094	85 c0		 test	 eax, eax
  00096	74 79		 je	 SHORT $LN36@compiler_c@4
  00098	ff c7		 inc	 edi
  0009a	48 83 c6 08	 add	 rsi, 8
  0009e	eb e0		 jmp	 SHORT $LL18@compiler_c@4
$LN16@compiler_c@4:

; 2910 :         n |= asdl_seq_LEN(keywords) << 8;

  000a0	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  000a4	48 c1 e0 08	 shl	 rax, 8
  000a8	44 0b f0	 or	 r14d, eax
$LN19@compiler_c@4:

; 2911 :     }
; 2912 :     if (starargs) {

  000ab	48 8b 54 24 60	 mov	 rdx, QWORD PTR starargs$[rsp]
  000b0	48 85 d2	 test	 rdx, rdx
  000b3	74 11		 je	 SHORT $LN14@compiler_c@4

; 2913 :         VISIT(c, expr, starargs);

  000b5	49 8b cc	 mov	 rcx, r12
  000b8	e8 00 00 00 00	 call	 compiler_visit_expr
  000bd	85 c0		 test	 eax, eax
  000bf	74 50		 je	 SHORT $LN36@compiler_c@4

; 2914 :         code |= 1;

  000c1	bb 01 00 00 00	 mov	 ebx, 1
$LN14@compiler_c@4:

; 2915 :     }
; 2916 :     if (kwargs) {

  000c6	48 8b 54 24 68	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000cb	48 85 d2	 test	 rdx, rdx
  000ce	74 0f		 je	 SHORT $LN12@compiler_c@4

; 2917 :         VISIT(c, expr, kwargs);

  000d0	49 8b cc	 mov	 rcx, r12
  000d3	e8 00 00 00 00	 call	 compiler_visit_expr
  000d8	85 c0		 test	 eax, eax
  000da	74 35		 je	 SHORT $LN36@compiler_c@4

; 2918 :         code |= 2;

  000dc	83 cb 02	 or	 ebx, 2
$LN12@compiler_c@4:

; 2919 :     }
; 2920 :     switch (code) {

  000df	85 db		 test	 ebx, ebx
  000e1	74 32		 je	 SHORT $LN8@compiler_c@4
  000e3	ff cb		 dec	 ebx
  000e5	74 16		 je	 SHORT $LN6@compiler_c@4
  000e7	ff cb		 dec	 ebx
  000e9	74 0b		 je	 SHORT $LN4@compiler_c@4
  000eb	ff cb		 dec	 ebx
  000ed	75 3a		 jne	 SHORT $LN7@compiler_c@4

; 2929 :         break;
; 2930 :     case 3:
; 2931 :         ADDOP_I(c, CALL_FUNCTION_VAR_KW, n);

  000ef	ba 8e 00 00 00	 mov	 edx, 142		; 0000008eH
  000f4	eb 0c		 jmp	 SHORT $LN39@compiler_c@4
$LN4@compiler_c@4:

; 2926 :         break;
; 2927 :     case 2:
; 2928 :         ADDOP_I(c, CALL_FUNCTION_KW, n);

  000f6	ba 8d 00 00 00	 mov	 edx, 141		; 0000008dH
  000fb	eb 05		 jmp	 SHORT $LN39@compiler_c@4
$LN6@compiler_c@4:

; 2923 :         break;
; 2924 :     case 1:
; 2925 :         ADDOP_I(c, CALL_FUNCTION_VAR, n);

  000fd	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
$LN39@compiler_c@4:
  00102	45 8b c6	 mov	 r8d, r14d
  00105	49 8b cc	 mov	 rcx, r12
  00108	e8 00 00 00 00	 call	 compiler_addop_i
  0010d	85 c0		 test	 eax, eax
  0010f	75 18		 jne	 SHORT $LN7@compiler_c@4
$LN36@compiler_c@4:
  00111	33 c0		 xor	 eax, eax
  00113	eb 19		 jmp	 SHORT $LN24@compiler_c@4
$LN8@compiler_c@4:

; 2921 :     case 0:
; 2922 :         ADDOP_I(c, CALL_FUNCTION, n);

  00115	45 8b c6	 mov	 r8d, r14d
  00118	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  0011d	49 8b cc	 mov	 rcx, r12
  00120	e8 00 00 00 00	 call	 compiler_addop_i
  00125	85 c0		 test	 eax, eax
  00127	74 e8		 je	 SHORT $LN36@compiler_c@4
$LN7@compiler_c@4:

; 2932 :         break;
; 2933 :     }
; 2934 :     return 1;

  00129	b8 01 00 00 00	 mov	 eax, 1
$LN24@compiler_c@4:

; 2935 : }

  0012e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00133	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00138	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0013d	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00142	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00146	41 5e		 pop	 r14
  00148	41 5d		 pop	 r13
  0014a	41 5c		 pop	 r12
  0014c	c3		 ret	 0
compiler_call_helper ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_comprehension DD imagerel compiler_comprehension
	DD	imagerel compiler_comprehension+629
	DD	imagerel $unwind$compiler_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_comprehension DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT ??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@ DB 'unknown c'
	DB	'omprehension type %d', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT compiler_comprehension
_TEXT	SEGMENT
c$ = 64
e$ = 72
type$ = 80
name$ = 88
generators$ = 96
elt$ = 104
val$ = 112
compiler_comprehension PROC				; COMDAT

; 3046 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3047 :     PyCodeObject *co = NULL;
; 3048 :     expr_ty outermost_iter;
; 3049 :     PyObject *qualname = NULL;
; 3050 : 
; 3051 :     outermost_iter = ((comprehension_ty)
; 3052 :                       asdl_seq_GET(generators, 0))->iter;

  00014	48 8b 7c 24 60	 mov	 rdi, QWORD PTR generators$[rsp]
  00019	4d 8b d1	 mov	 r10, r9
  0001c	41 8b d8	 mov	 ebx, r8d
  0001f	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 3053 : 
; 3054 :     if (!compiler_enter_scope(c, name, COMPILER_SCOPE_COMPREHENSION,
; 3055 :                               (void *)e, e->lineno))

  00023	4c 8b ca	 mov	 r9, rdx
  00026	41 b8 03 00 00
	00		 mov	 r8d, 3
  0002c	48 8b 68 08	 mov	 rbp, QWORD PTR [rax+8]
  00030	8b 42 30	 mov	 eax, DWORD PTR [rdx+48]
  00033	49 8b d2	 mov	 rdx, r10
  00036	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003a	48 8b f1	 mov	 rsi, rcx
  0003d	e8 00 00 00 00	 call	 compiler_enter_scope
  00042	85 c0		 test	 eax, eax
  00044	0f 84 14 02 00
	00		 je	 $LN3@compiler_c@5

; 3056 :         goto error;
; 3057 : 
; 3058 :     if (type != COMP_GENEXP) {

  0004a	85 db		 test	 ebx, ebx
  0004c	74 57		 je	 SHORT $LN18@compiler_c@5

; 3059 :         int op;
; 3060 :         switch (type) {

  0004e	8b cb		 mov	 ecx, ebx
  00050	ff c9		 dec	 ecx
  00052	74 39		 je	 SHORT $LN22@compiler_c@5
  00054	ff c9		 dec	 ecx
  00056	74 2e		 je	 SHORT $LN21@compiler_c@5
  00058	ff c9		 dec	 ecx
  0005a	74 23		 je	 SHORT $LN20@compiler_c@5

; 3070 :         default:
; 3071 :             PyErr_Format(PyExc_SystemError,
; 3072 :                          "unknown comprehension type %d", type);

  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJACIMDF@unknown?5comprehension?5type?5?$CFd?$AA@
  0006a	44 8b c3	 mov	 r8d, ebx
  0006d	e8 00 00 00 00	 call	 PyErr_Format

; 3102 : error_in_scope:
; 3103 :     compiler_exit_scope(c);

  00072	48 8b ce	 mov	 rcx, rsi
  00075	e8 00 00 00 00	 call	 compiler_exit_scope
  0007a	e9 df 01 00 00	 jmp	 $LN3@compiler_c@5
$LN20@compiler_c@5:

; 3067 :         case COMP_DICTCOMP:
; 3068 :             op = BUILD_MAP;

  0007f	ba 69 00 00 00	 mov	 edx, 105		; 00000069H

; 3069 :             break;

  00084	eb 0c		 jmp	 SHORT $LN23@compiler_c@5
$LN21@compiler_c@5:

; 3063 :             break;
; 3064 :         case COMP_SETCOMP:
; 3065 :             op = BUILD_SET;

  00086	ba 68 00 00 00	 mov	 edx, 104		; 00000068H

; 3066 :             break;

  0008b	eb 05		 jmp	 SHORT $LN23@compiler_c@5
$LN22@compiler_c@5:

; 3061 :         case COMP_LISTCOMP:
; 3062 :             op = BUILD_LIST;

  0008d	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
$LN23@compiler_c@5:

; 3073 :             goto error_in_scope;
; 3074 :         }
; 3075 : 
; 3076 :         ADDOP_I(c, op, 0);

  00092	45 33 c0	 xor	 r8d, r8d
  00095	48 8b ce	 mov	 rcx, rsi
  00098	e8 00 00 00 00	 call	 compiler_addop_i
  0009d	85 c0		 test	 eax, eax
  0009f	0f 84 b9 01 00
	00		 je	 $LN3@compiler_c@5
$LN18@compiler_c@5:

; 3077 :     }
; 3078 : 
; 3079 :     if (!compiler_comprehension_generator(c, generators, 0, elt,
; 3080 :                                           val, type))

  000a5	48 8b 44 24 70	 mov	 rax, QWORD PTR val$[rsp]
  000aa	4c 8b 4c 24 68	 mov	 r9, QWORD PTR elt$[rsp]
  000af	45 33 c0	 xor	 r8d, r8d
  000b2	48 8b d7	 mov	 rdx, rdi
  000b5	48 8b ce	 mov	 rcx, rsi
  000b8	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c1	e8 00 00 00 00	 call	 compiler_comprehension_generator
  000c6	85 c0		 test	 eax, eax
  000c8	75 0d		 jne	 SHORT $LN17@compiler_c@5

; 3102 : error_in_scope:
; 3103 :     compiler_exit_scope(c);

  000ca	48 8b ce	 mov	 rcx, rsi
$error_in_scope$24200:
  000cd	e8 00 00 00 00	 call	 compiler_exit_scope
  000d2	e9 87 01 00 00	 jmp	 $LN3@compiler_c@5
$LN17@compiler_c@5:

; 3081 :         goto error_in_scope;
; 3082 : 
; 3083 :     if (type != COMP_GENEXP) {

  000d7	85 db		 test	 ebx, ebx
  000d9	74 15		 je	 SHORT $LN15@compiler_c@5

; 3084 :         ADDOP(c, RETURN_VALUE);

  000db	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  000e0	48 8b ce	 mov	 rcx, rsi
  000e3	e8 00 00 00 00	 call	 compiler_addop
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 6e 01 00
	00		 je	 $LN3@compiler_c@5
$LN15@compiler_c@5:

; 3085 :     }
; 3086 : 
; 3087 :     co = assemble(c, 1);

  000f0	ba 01 00 00 00	 mov	 edx, 1
  000f5	48 8b ce	 mov	 rcx, rsi
  000f8	e8 00 00 00 00	 call	 assemble

; 3088 :     qualname = compiler_scope_qualname(c);

  000fd	48 8b ce	 mov	 rcx, rsi
  00100	48 8b d8	 mov	 rbx, rax
  00103	e8 00 00 00 00	 call	 compiler_scope_qualname

; 3089 :     compiler_exit_scope(c);

  00108	48 8b ce	 mov	 rcx, rsi
  0010b	48 8b f8	 mov	 rdi, rax
  0010e	e8 00 00 00 00	 call	 compiler_exit_scope

; 3090 :     if (qualname == NULL || co == NULL)

  00113	48 85 ff	 test	 rdi, rdi
  00116	0f 84 d8 00 00
	00		 je	 $LN7@compiler_c@5
  0011c	48 85 db	 test	 rbx, rbx
  0011f	74 6e		 je	 SHORT $error$24188

; 3091 :         goto error;
; 3092 : 
; 3093 :     if (!compiler_make_closure(c, co, 0, qualname))

  00121	4c 8b cf	 mov	 r9, rdi
  00124	45 33 c0	 xor	 r8d, r8d
  00127	48 8b d3	 mov	 rdx, rbx
  0012a	48 8b ce	 mov	 rcx, rsi
  0012d	e8 00 00 00 00	 call	 compiler_make_closure
  00132	85 c0		 test	 eax, eax
  00134	74 59		 je	 SHORT $error$24188

; 3094 :         goto error;
; 3095 :     Py_DECREF(qualname);

  00136	48 8b cf	 mov	 rcx, rdi
  00139	e8 00 00 00 00	 call	 _Py_DecRef

; 3096 :     Py_DECREF(co);

  0013e	48 8b cb	 mov	 rcx, rbx
  00141	e8 00 00 00 00	 call	 _Py_DecRef

; 3097 : 
; 3098 :     VISIT(c, expr, outermost_iter);

  00146	48 8b d5	 mov	 rdx, rbp
  00149	48 8b ce	 mov	 rcx, rsi
  0014c	e8 00 00 00 00	 call	 compiler_visit_expr
  00151	85 c0		 test	 eax, eax
  00153	0f 84 05 01 00
	00		 je	 $LN3@compiler_c@5

; 3099 :     ADDOP(c, GET_ITER);

  00159	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0015e	48 8b ce	 mov	 rcx, rsi
  00161	e8 00 00 00 00	 call	 compiler_addop
  00166	85 c0		 test	 eax, eax
  00168	0f 84 f0 00 00
	00		 je	 $LN3@compiler_c@5

; 3100 :     ADDOP_I(c, CALL_FUNCTION, 1);

  0016e	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  00173	41 b8 01 00 00
	00		 mov	 r8d, 1
  00179	48 8b ce	 mov	 rcx, rsi
  0017c	e8 00 00 00 00	 call	 compiler_addop_i
  00181	33 c9		 xor	 ecx, ecx
  00183	85 c0		 test	 eax, eax
  00185	0f 95 c1	 setne	 cl
  00188	8b c1		 mov	 eax, ecx

; 3101 :     return 1;

  0018a	e9 d1 00 00 00	 jmp	 $LN27@compiler_c@5
$error$24188:

; 3104 : error:
; 3105 :     Py_XDECREF(qualname);

  0018f	e8 00 00 00 00	 call	 _Py_PXCTX
  00194	85 c0		 test	 eax, eax
  00196	75 5c		 jne	 SHORT $LN7@compiler_c@5
  00198	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0019c	a8 20		 test	 al, 32			; 00000020H
  0019e	75 4c		 jne	 SHORT $LN33@compiler_c@5
  001a0	84 c0		 test	 al, al
  001a2	78 48		 js	 SHORT $LN33@compiler_c@5
  001a4	a8 02		 test	 al, 2
  001a6	75 4c		 jne	 SHORT $LN7@compiler_c@5
  001a8	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001ac	75 46		 jne	 SHORT $LN7@compiler_c@5
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001bc	4c 8b cf	 mov	 r9, rdi
  001bf	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d2	48 8b cf	 mov	 rcx, rdi
  001d5	85 c0		 test	 eax, eax
  001d7	74 07		 je	 SHORT $LN38@compiler_c@5
  001d9	e8 00 00 00 00	 call	 _Px_Dealloc
  001de	eb 14		 jmp	 SHORT $LN7@compiler_c@5
$LN38@compiler_c@5:
  001e0	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001e4	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001ea	eb 08		 jmp	 SHORT $LN7@compiler_c@5
$LN33@compiler_c@5:
  001ec	48 8b cf	 mov	 rcx, rdi
  001ef	e8 00 00 00 00	 call	 Px_DecRef
$LN7@compiler_c@5:

; 3106 :     Py_XDECREF(co);

  001f4	48 85 db	 test	 rbx, rbx
  001f7	74 65		 je	 SHORT $LN3@compiler_c@5
  001f9	e8 00 00 00 00	 call	 _Py_PXCTX
  001fe	85 c0		 test	 eax, eax
  00200	75 5c		 jne	 SHORT $LN3@compiler_c@5
  00202	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00206	a8 20		 test	 al, 32			; 00000020H
  00208	75 4c		 jne	 SHORT $LN44@compiler_c@5
  0020a	84 c0		 test	 al, al
  0020c	78 48		 js	 SHORT $LN44@compiler_c@5
  0020e	a8 02		 test	 al, 2
  00210	75 4c		 jne	 SHORT $LN3@compiler_c@5
  00212	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00216	75 46		 jne	 SHORT $LN3@compiler_c@5
  00218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00226	4c 8b cb	 mov	 r9, rbx
  00229	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0022f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00237	e8 00 00 00 00	 call	 _PyParallel_Guard
  0023c	48 8b cb	 mov	 rcx, rbx
  0023f	85 c0		 test	 eax, eax
  00241	74 07		 je	 SHORT $LN49@compiler_c@5
  00243	e8 00 00 00 00	 call	 _Px_Dealloc
  00248	eb 14		 jmp	 SHORT $LN3@compiler_c@5
$LN49@compiler_c@5:
  0024a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0024e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00254	eb 08		 jmp	 SHORT $LN3@compiler_c@5
$LN44@compiler_c@5:
  00256	48 8b cb	 mov	 rcx, rbx
  00259	e8 00 00 00 00	 call	 Px_DecRef
$LN3@compiler_c@5:

; 3107 :     return 0;

  0025e	33 c0		 xor	 eax, eax
$LN27@compiler_c@5:

; 3108 : }

  00260	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00265	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0026a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0026f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00273	5f		 pop	 rdi
  00274	c3		 ret	 0
compiler_comprehension ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_genexp@@9@9 DQ 01H DUP (?)		; `compiler_genexp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_genexp DD imagerel compiler_genexp
	DD	imagerel compiler_genexp+118
	DD	imagerel $unwind$compiler_genexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_genexp DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@
CONST	SEGMENT
??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@ DB '<genexpr>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_genexp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_genexp PROC					; COMDAT

; 3112 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3113 :     static identifier name;
; 3114 :     if (!name) {

  0000a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_genexp@@9@9
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	4d 85 c9	 test	 r9, r9
  0001a	75 26		 jne	 SHORT $LN1@compiler_g

; 3115 :         name = PyUnicode_FromString("<genexpr>");

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09PJCOLCAN@?$DMgenexpr?$DO?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromString
  00028	4c 8b c8	 mov	 r9, rax
  0002b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_genexp@@9@9, rax

; 3116 :         if (!name)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN1@compiler_g

; 3123 : }

  00037	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN1@compiler_g:

; 3117 :             return 0;
; 3118 :     }
; 3119 :     assert(e->kind == GeneratorExp_kind);
; 3120 :     return compiler_comprehension(c, e, COMP_GENEXP, name,
; 3121 :                                   e->v.GeneratorExp.generators,
; 3122 :                                   e->v.GeneratorExp.elt, NULL);

  00042	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00046	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004f	45 33 c0	 xor	 r8d, r8d
  00052	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00057	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0005b	48 8b d3	 mov	 rdx, rbx
  0005e	48 8b cf	 mov	 rcx, rdi
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	e8 00 00 00 00	 call	 compiler_comprehension

; 3123 : }

  0006b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00070	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
compiler_genexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_listcomp@@9@9 DQ 01H DUP (?)		; `compiler_listcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_listcomp DD imagerel compiler_listcomp
	DD	imagerel compiler_listcomp+121
	DD	imagerel $unwind$compiler_listcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_listcomp DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@
CONST	SEGMENT
??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@ DB '<listcomp>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_listcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_listcomp PROC					; COMDAT

; 3127 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3128 :     static identifier name;
; 3129 :     if (!name) {

  0000a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_listcomp@@9@9
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	4d 85 c9	 test	 r9, r9
  0001a	75 26		 jne	 SHORT $LN1@compiler_l@4

; 3130 :         name = PyUnicode_FromString("<listcomp>");

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@POJBOHBJ@?$DMlistcomp?$DO?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromString
  00028	4c 8b c8	 mov	 r9, rax
  0002b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_listcomp@@9@9, rax

; 3131 :         if (!name)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN1@compiler_l@4

; 3138 : }

  00037	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN1@compiler_l@4:

; 3132 :             return 0;
; 3133 :     }
; 3134 :     assert(e->kind == ListComp_kind);
; 3135 :     return compiler_comprehension(c, e, COMP_LISTCOMP, name,
; 3136 :                                   e->v.ListComp.generators,
; 3137 :                                   e->v.ListComp.elt, NULL);

  00042	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00046	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00055	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0005e	48 8b d3	 mov	 rdx, rbx
  00061	48 8b cf	 mov	 rcx, rdi
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 compiler_comprehension

; 3138 : }

  0006e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00073	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
compiler_listcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_setcomp@@9@9 DQ 01H DUP (?)		; `compiler_setcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_setcomp DD imagerel compiler_setcomp
	DD	imagerel compiler_setcomp+121
	DD	imagerel $unwind$compiler_setcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_setcomp DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@
CONST	SEGMENT
??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@ DB '<setcomp>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_setcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_setcomp PROC					; COMDAT

; 3142 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3143 :     static identifier name;
; 3144 :     if (!name) {

  0000a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_setcomp@@9@9
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	4d 85 c9	 test	 r9, r9
  0001a	75 26		 jne	 SHORT $LN1@compiler_s@4

; 3145 :         name = PyUnicode_FromString("<setcomp>");

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09GOMCJBFD@?$DMsetcomp?$DO?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromString
  00028	4c 8b c8	 mov	 r9, rax
  0002b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_setcomp@@9@9, rax

; 3146 :         if (!name)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN1@compiler_s@4

; 3153 : }

  00037	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN1@compiler_s@4:

; 3147 :             return 0;
; 3148 :     }
; 3149 :     assert(e->kind == SetComp_kind);
; 3150 :     return compiler_comprehension(c, e, COMP_SETCOMP, name,
; 3151 :                                   e->v.SetComp.generators,
; 3152 :                                   e->v.SetComp.elt, NULL);

  00042	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00046	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0004f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00055	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0005e	48 8b d3	 mov	 rdx, rbx
  00061	48 8b cf	 mov	 rcx, rdi
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 compiler_comprehension

; 3153 : }

  0006e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00073	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
compiler_setcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@		; `string'
_BSS	SEGMENT
?name@?1??compiler_dictcomp@@9@9 DQ 01H DUP (?)		; `compiler_dictcomp'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_dictcomp DD imagerel compiler_dictcomp
	DD	imagerel compiler_dictcomp+121
	DD	imagerel $unwind$compiler_dictcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_dictcomp DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@
CONST	SEGMENT
??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@ DB '<dictcomp>', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_dictcomp
_TEXT	SEGMENT
c$ = 80
e$ = 88
compiler_dictcomp PROC					; COMDAT

; 3158 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3159 :     static identifier name;
; 3160 :     if (!name) {

  0000a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?name@?1??compiler_dictcomp@@9@9
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	4d 85 c9	 test	 r9, r9
  0001a	75 26		 jne	 SHORT $LN1@compiler_d

; 3161 :         name = PyUnicode_FromString("<dictcomp>");

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JBPNJGMG@?$DMdictcomp?$DO?$AA@
  00023	e8 00 00 00 00	 call	 PyUnicode_FromString
  00028	4c 8b c8	 mov	 r9, rax
  0002b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?name@?1??compiler_dictcomp@@9@9, rax

; 3162 :         if (!name)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN1@compiler_d

; 3169 : }

  00037	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN1@compiler_d:

; 3163 :             return 0;
; 3164 :     }
; 3165 :     assert(e->kind == DictComp_kind);
; 3166 :     return compiler_comprehension(c, e, COMP_DICTCOMP, name,
; 3167 :                                   e->v.DictComp.generators,
; 3168 :                                   e->v.DictComp.key, e->v.DictComp.value);

  00042	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00046	41 b8 03 00 00
	00		 mov	 r8d, 3
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00054	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00058	48 8b cf	 mov	 rcx, rdi
  0005b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00060	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00064	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00069	e8 00 00 00 00	 call	 compiler_comprehension

; 3169 : }

  0006e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00073	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
compiler_dictcomp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_call DD imagerel compiler_call
	DD	imagerel compiler_call+87
	DD	imagerel $unwind$compiler_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_call DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_call
_TEXT	SEGMENT
c$ = 64
e$ = 72
compiler_call PROC					; COMDAT

; 2886 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx

; 2887 :     VISIT(c, expr, e->v.Call.func);

  0000d	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00011	48 8b f9	 mov	 rdi, rcx
  00014	e8 00 00 00 00	 call	 compiler_visit_expr
  00019	85 c0		 test	 eax, eax
  0001b	75 0b		 jne	 SHORT $LN1@compiler_c@6

; 2893 : }

  0001d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@compiler_c@6:

; 2888 :     return compiler_call_helper(c, 0,
; 2889 :                                 e->v.Call.args,
; 2890 :                                 e->v.Call.keywords,
; 2891 :                                 e->v.Call.starargs,
; 2892 :                                 e->v.Call.kwargs);

  00028	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  0002c	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
  00030	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00034	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00039	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0003d	33 d2		 xor	 edx, edx
  0003f	48 8b cf	 mov	 rcx, rdi
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	e8 00 00 00 00	 call	 compiler_call_helper

; 2893 : }

  0004c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
compiler_call ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@ ; `string'
PUBLIC	??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@ ; `string'
PUBLIC	??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@ ; `string'
PUBLIC	??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@ ; `string'
PUBLIC	??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@ ; `string'
EXTRN	_Py_EllipsisObject:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_expr DD imagerel compiler_visit_expr
	DD	imagerel compiler_visit_expr+1668
	DD	imagerel $unwind$compiler_visit_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_expr DD 063b01H
	DD	0a543bH
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@
CONST	SEGMENT
??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@ DB 'starred assi'
	DB	'gnment target must be in a list or tuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@
CONST	SEGMENT
??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@ DB 'can use sta'
	DB	'rred expression only as assignment target', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@
CONST	SEGMENT
??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@ DB 'param invali'
	DB	'd in subscript expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@
CONST	SEGMENT
??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@ DB 'param invali'
	DB	'd in attribute expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@
CONST	SEGMENT
??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@ DB '''yield'' outsid'
	DB	'e function', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_visit_expr
_TEXT	SEGMENT
n$2$ = 64
c$ = 64
tv655 = 72
e$ = 72
compiler_visit_expr PROC				; COMDAT

; 3294 : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	48 8b d9	 mov	 rbx, rcx

; 3295 :     int i, n;
; 3296 : 
; 3297 :     /* If expr e has a different line number than the last expr/stmt,
; 3298 :        set a new line number for the next instruction.
; 3299 :     */
; 3300 :     if (e->lineno > c->u->u_lineno) {

  0000b	8b 4a 30	 mov	 ecx, DWORD PTR [rdx+48]
  0000e	33 f6		 xor	 esi, esi
  00010	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00014	48 8b fa	 mov	 rdi, rdx
  00017	3b 88 b4 01 00
	00		 cmp	 ecx, DWORD PTR [rax+436]
  0001d	7e 10		 jle	 SHORT $LN96@compiler_v@5

; 3301 :         c->u->u_lineno = e->lineno;

  0001f	89 88 b4 01 00
	00		 mov	 DWORD PTR [rax+436], ecx

; 3302 :         c->u->u_lineno_set = 0;

  00025	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00029	89 b0 bc 01 00
	00		 mov	 DWORD PTR [rax+444], esi
$LN96@compiler_v@5:

; 3303 :     }
; 3304 :     /* Updating the column offset is always harmless. */
; 3305 :     c->u->u_col_offset = e->col_offset;

  0002f	8b 42 34	 mov	 eax, DWORD PTR [rdx+52]
  00032	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00036	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0003b	89 81 b8 01 00
	00		 mov	 DWORD PTR [rcx+440], eax

; 3306 :     switch (e->kind) {

  00041	8b 02		 mov	 eax, DWORD PTR [rdx]
  00043	ff c8		 dec	 eax
  00045	83 f8 18	 cmp	 eax, 24
  00048	0f 87 61 01 00
	00		 ja	 $LN94@compiler_v@5
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00055	48 98		 cdqe
  00057	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN112@compiler_v@5[rdx+rax*4]
  0005e	48 03 ca	 add	 rcx, rdx
  00061	ff e1		 jmp	 rcx
$LN93@compiler_v@5:

; 3307 :     case BoolOp_kind:
; 3308 :         return compiler_boolop(c, e);

  00063	48 8b d7	 mov	 rdx, rdi
  00066	48 8b cb	 mov	 rcx, rbx
  00069	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	5e		 pop	 rsi
  00074	5b		 pop	 rbx
  00075	e9 00 00 00 00	 jmp	 compiler_boolop
$LN92@compiler_v@5:

; 3309 :     case BinOp_kind:
; 3310 :         VISIT(c, expr, e->v.BinOp.left);

  0007a	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 compiler_visit_expr
  00086	85 c0		 test	 eax, eax
  00088	74 2a		 je	 SHORT $LN114@compiler_v@5

; 3311 :         VISIT(c, expr, e->v.BinOp.right);

  0008a	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	e8 00 00 00 00	 call	 compiler_visit_expr
  00096	85 c0		 test	 eax, eax
  00098	74 1a		 je	 SHORT $LN114@compiler_v@5

; 3312 :         ADDOP(c, binop(c, e->v.BinOp.op));

  0009a	8b 4f 10	 mov	 ecx, DWORD PTR [rdi+16]
  0009d	e8 00 00 00 00	 call	 binop
  000a2	8b d0		 mov	 edx, eax
$LN115@compiler_v@5:
  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	e8 00 00 00 00	 call	 compiler_addop
$LN116@compiler_v@5:
  000ac	85 c0		 test	 eax, eax
  000ae	0f 85 fb 00 00
	00		 jne	 $LN94@compiler_v@5
$LN114@compiler_v@5:
  000b4	33 c0		 xor	 eax, eax
  000b6	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5f		 pop	 rdi
  000c0	5e		 pop	 rsi
  000c1	5b		 pop	 rbx
  000c2	c3		 ret	 0
$LN88@compiler_v@5:

; 3313 :         break;
; 3314 :     case UnaryOp_kind:
; 3315 :         VISIT(c, expr, e->v.UnaryOp.operand);

  000c3	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  000c7	48 8b cb	 mov	 rcx, rbx
  000ca	e8 00 00 00 00	 call	 compiler_visit_expr
  000cf	85 c0		 test	 eax, eax
  000d1	74 e1		 je	 SHORT $LN114@compiler_v@5

; 3316 :         ADDOP(c, unaryop(e->v.UnaryOp.op));

  000d3	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]
  000d6	e8 00 00 00 00	 call	 unaryop
  000db	48 8b cb	 mov	 rcx, rbx
  000de	8b d0		 mov	 edx, eax
  000e0	e8 00 00 00 00	 call	 compiler_addop
  000e5	85 c0		 test	 eax, eax
  000e7	0f 85 c2 00 00
	00		 jne	 $LN94@compiler_v@5
  000ed	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  000f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f6	5f		 pop	 rdi
  000f7	5e		 pop	 rsi
  000f8	5b		 pop	 rbx
  000f9	c3		 ret	 0
$LN85@compiler_v@5:

; 3317 :         break;
; 3318 :     case Lambda_kind:
; 3319 :         return compiler_lambda(c, e);

  000fa	48 8b d7	 mov	 rdx, rdi
  000fd	48 8b cb	 mov	 rcx, rbx
  00100	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5f		 pop	 rdi
  0010a	5e		 pop	 rsi
  0010b	5b		 pop	 rbx
  0010c	e9 00 00 00 00	 jmp	 compiler_lambda
$LN84@compiler_v@5:

; 3320 :     case IfExp_kind:
; 3321 :         return compiler_ifexp(c, e);

  00111	48 8b d7	 mov	 rdx, rdi
  00114	48 8b cb	 mov	 rcx, rbx
  00117	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0011c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00120	5f		 pop	 rdi
  00121	5e		 pop	 rsi
  00122	5b		 pop	 rbx
  00123	e9 00 00 00 00	 jmp	 compiler_ifexp
$LN83@compiler_v@5:

; 3322 :     case Dict_kind:
; 3323 :         n = asdl_seq_LEN(e->v.Dict.values);

  00128	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0012c	8b ee		 mov	 ebp, esi
  0012e	48 85 c0	 test	 rax, rax
  00131	74 02		 je	 SHORT $LN100@compiler_v@5
  00133	8b 28		 mov	 ebp, DWORD PTR [rax]
$LN100@compiler_v@5:

; 3324 :         ADDOP_I(c, BUILD_MAP, (n>0xFFFF ? 0xFFFF : n));

  00135	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0013a	44 8b c5	 mov	 r8d, ebp
  0013d	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  00142	3b e8		 cmp	 ebp, eax
  00144	48 8b cb	 mov	 rcx, rbx
  00147	44 0f 4f c0	 cmovg	 r8d, eax
  0014b	e8 00 00 00 00	 call	 compiler_addop_i
  00150	85 c0		 test	 eax, eax
  00152	0f 84 5c ff ff
	ff		 je	 $LN114@compiler_v@5

; 3325 :         for (i = 0; i < n; i++) {

  00158	48 63 ed	 movsxd	 rbp, ebp
  0015b	48 85 ed	 test	 rbp, rbp
  0015e	7e 4f		 jle	 SHORT $LN94@compiler_v@5
$LL81@compiler_v@5:

; 3326 :             VISIT(c, expr,
; 3327 :                 (expr_ty)asdl_seq_GET(e->v.Dict.values, i));

  00160	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00164	48 8b cb	 mov	 rcx, rbx
  00167	48 8b 54 f2 08	 mov	 rdx, QWORD PTR [rdx+rsi*8+8]
  0016c	e8 00 00 00 00	 call	 compiler_visit_expr
  00171	85 c0		 test	 eax, eax
  00173	0f 84 3b ff ff
	ff		 je	 $LN114@compiler_v@5

; 3328 :             VISIT(c, expr,
; 3329 :                 (expr_ty)asdl_seq_GET(e->v.Dict.keys, i));

  00179	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0017d	48 8b cb	 mov	 rcx, rbx
  00180	48 8b 54 f2 08	 mov	 rdx, QWORD PTR [rdx+rsi*8+8]
  00185	e8 00 00 00 00	 call	 compiler_visit_expr
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 22 ff ff
	ff		 je	 $LN114@compiler_v@5

; 3330 :             ADDOP(c, STORE_MAP);

  00192	ba 36 00 00 00	 mov	 edx, 54			; 00000036H
  00197	48 8b cb	 mov	 rcx, rbx
  0019a	e8 00 00 00 00	 call	 compiler_addop
  0019f	85 c0		 test	 eax, eax
  001a1	0f 84 0d ff ff
	ff		 je	 $LN114@compiler_v@5

; 3325 :         for (i = 0; i < n; i++) {

  001a7	48 ff c6	 inc	 rsi
  001aa	48 3b f5	 cmp	 rsi, rbp
  001ad	7c b1		 jl	 SHORT $LL81@compiler_v@5
$LN94@compiler_v@5:

; 3455 :     }
; 3456 :     return 1;

  001af	b8 01 00 00 00	 mov	 eax, 1
  001b4	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  001b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001bd	5f		 pop	 rdi
  001be	5e		 pop	 rsi
  001bf	5b		 pop	 rbx
  001c0	c3		 ret	 0
$LN75@compiler_v@5:

; 3331 :         }
; 3332 :         break;
; 3333 :     case Set_kind:
; 3334 :         n = asdl_seq_LEN(e->v.Set.elts);

  001c1	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  001c5	48 85 ff	 test	 rdi, rdi
  001c8	75 06		 jne	 SHORT $LN101@compiler_v@5
  001ca	89 74 24 40	 mov	 DWORD PTR n$2$[rsp], esi
  001ce	eb 08		 jmp	 SHORT $LN102@compiler_v@5
$LN101@compiler_v@5:
  001d0	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  001d3	44 89 44 24 40	 mov	 DWORD PTR n$2$[rsp], r8d
$LN102@compiler_v@5:

; 3335 :         VISIT_SEQ(c, expr, e->v.Set.elts);

  001d8	8b ee		 mov	 ebp, esi
  001da	48 8d 57 08	 lea	 rdx, QWORD PTR [rdi+8]
$LN113@compiler_v@5:
  001de	48 89 54 24 48	 mov	 QWORD PTR tv655[rsp], rdx
  001e3	48 8b ce	 mov	 rcx, rsi
  001e6	48 85 ff	 test	 rdi, rdi
  001e9	74 03		 je	 SHORT $LN104@compiler_v@5
  001eb	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN104@compiler_v@5:
  001ee	48 63 c5	 movsxd	 rax, ebp
  001f1	48 3b c1	 cmp	 rax, rcx
  001f4	48 8b cb	 mov	 rcx, rbx
  001f7	7d 1d		 jge	 SHORT $LN72@compiler_v@5
  001f9	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001fc	e8 00 00 00 00	 call	 compiler_visit_expr
  00201	85 c0		 test	 eax, eax
  00203	0f 84 ab fe ff
	ff		 je	 $LN114@compiler_v@5
  00209	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv655[rsp]
  0020e	ff c5		 inc	 ebp
  00210	48 83 c2 08	 add	 rdx, 8
  00214	eb c8		 jmp	 SHORT $LN113@compiler_v@5
$LN72@compiler_v@5:

; 3336 :         ADDOP_I(c, BUILD_SET, n);

  00216	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$2$[rsp]
  0021b	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  00220	e8 00 00 00 00	 call	 compiler_addop_i
  00225	85 c0		 test	 eax, eax
  00227	75 86		 jne	 SHORT $LN94@compiler_v@5
  00229	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0022e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00232	5f		 pop	 rdi
  00233	5e		 pop	 rsi
  00234	5b		 pop	 rbx
  00235	c3		 ret	 0
$LN69@compiler_v@5:

; 3337 :         break;
; 3338 :     case GeneratorExp_kind:
; 3339 :         return compiler_genexp(c, e);

  00236	48 8b d7	 mov	 rdx, rdi
  00239	48 8b cb	 mov	 rcx, rbx
  0023c	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00241	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00245	5f		 pop	 rdi
  00246	5e		 pop	 rsi
  00247	5b		 pop	 rbx
  00248	e9 00 00 00 00	 jmp	 compiler_genexp
$LN68@compiler_v@5:

; 3340 :     case ListComp_kind:
; 3341 :         return compiler_listcomp(c, e);

  0024d	48 8b d7	 mov	 rdx, rdi
  00250	48 8b cb	 mov	 rcx, rbx
  00253	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00258	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0025c	5f		 pop	 rdi
  0025d	5e		 pop	 rsi
  0025e	5b		 pop	 rbx
  0025f	e9 00 00 00 00	 jmp	 compiler_listcomp
$LN67@compiler_v@5:

; 3342 :     case SetComp_kind:
; 3343 :         return compiler_setcomp(c, e);

  00264	48 8b d7	 mov	 rdx, rdi
  00267	48 8b cb	 mov	 rcx, rbx
  0026a	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0026f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00273	5f		 pop	 rdi
  00274	5e		 pop	 rsi
  00275	5b		 pop	 rbx
  00276	e9 00 00 00 00	 jmp	 compiler_setcomp
$LN66@compiler_v@5:

; 3344 :     case DictComp_kind:
; 3345 :         return compiler_dictcomp(c, e);

  0027b	48 8b d7	 mov	 rdx, rdi
  0027e	48 8b cb	 mov	 rcx, rbx
  00281	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00286	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028a	5f		 pop	 rdi
  0028b	5e		 pop	 rsi
  0028c	5b		 pop	 rbx
  0028d	e9 00 00 00 00	 jmp	 compiler_dictcomp
$LN65@compiler_v@5:

; 3346 :     case Yield_kind:
; 3347 :         if (c->u->u_ste->ste_type != FunctionBlock)

  00292	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]

; 3348 :             return compiler_error(c, "'yield' outside function");

  00296	48 8b cb	 mov	 rcx, rbx
  00299	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0029c	39 b0 88 00 00
	00		 cmp	 DWORD PTR [rax+136], esi
  002a2	74 18		 je	 SHORT $LN64@compiler_v@5
$LN119@compiler_v@5:
  002a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KHLOCEPE@?8yield?8?5outside?5function?$AA@
  002ab	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  002b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002b4	5f		 pop	 rdi
  002b5	5e		 pop	 rsi
  002b6	5b		 pop	 rbx
  002b7	e9 00 00 00 00	 jmp	 compiler_error
$LN64@compiler_v@5:

; 3349 :         if (e->v.Yield.value) {

  002bc	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  002c0	48 85 d2	 test	 rdx, rdx
  002c3	74 16		 je	 SHORT $LN63@compiler_v@5

; 3350 :             VISIT(c, expr, e->v.Yield.value);

  002c5	e8 00 00 00 00	 call	 compiler_visit_expr
  002ca	85 c0		 test	 eax, eax
  002cc	75 2a		 jne	 SHORT $LN60@compiler_v@5
  002ce	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  002d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002d7	5f		 pop	 rdi
  002d8	5e		 pop	 rsi
  002d9	5b		 pop	 rbx
  002da	c3		 ret	 0
$LN63@compiler_v@5:

; 3351 :         }
; 3352 :         else {
; 3353 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  002db	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  002df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  002e6	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  002eb	e8 00 00 00 00	 call	 compiler_addop_o
  002f0	85 c0		 test	 eax, eax
  002f2	0f 84 bc fd ff
	ff		 je	 $LN114@compiler_v@5
$LN60@compiler_v@5:

; 3354 :         }
; 3355 :         ADDOP(c, YIELD_VALUE);

  002f8	ba 56 00 00 00	 mov	 edx, 86			; 00000056H
  002fd	e9 a2 fd ff ff	 jmp	 $LN115@compiler_v@5
$LN58@compiler_v@5:

; 3356 :         break;
; 3357 :     case YieldFrom_kind:
; 3358 :         if (c->u->u_ste->ste_type != FunctionBlock)

  00302	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00306	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00309	39 b1 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], esi

; 3359 :             return compiler_error(c, "'yield' outside function");

  0030f	48 8b cb	 mov	 rcx, rbx
  00312	75 90		 jne	 SHORT $LN119@compiler_v@5

; 3360 :         VISIT(c, expr, e->v.YieldFrom.value);

  00314	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00318	e8 00 00 00 00	 call	 compiler_visit_expr
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 8f fd ff
	ff		 je	 $LN114@compiler_v@5

; 3361 :         ADDOP(c, GET_ITER);

  00325	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0032a	48 8b cb	 mov	 rcx, rbx
  0032d	e8 00 00 00 00	 call	 compiler_addop
  00332	85 c0		 test	 eax, eax
  00334	0f 84 7a fd ff
	ff		 je	 $LN114@compiler_v@5

; 3362 :         ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0033a	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0033e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00345	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0034a	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0034e	48 8b cb	 mov	 rcx, rbx
  00351	e8 00 00 00 00	 call	 compiler_addop_o
  00356	85 c0		 test	 eax, eax
  00358	0f 84 56 fd ff
	ff		 je	 $LN114@compiler_v@5

; 3363 :         ADDOP(c, YIELD_FROM);

  0035e	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  00363	e9 3c fd ff ff	 jmp	 $LN115@compiler_v@5
$LN52@compiler_v@5:

; 3364 :         break;
; 3365 :     case Compare_kind:
; 3366 :         return compiler_compare(c, e);

  00368	48 8b d7	 mov	 rdx, rdi
  0036b	48 8b cb	 mov	 rcx, rbx
  0036e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00373	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00377	5f		 pop	 rdi
  00378	5e		 pop	 rsi
  00379	5b		 pop	 rbx
  0037a	e9 00 00 00 00	 jmp	 compiler_compare
$LN51@compiler_v@5:

; 3367 :     case Call_kind:
; 3368 :         return compiler_call(c, e);

  0037f	48 8b d7	 mov	 rdx, rdi
  00382	48 8b cb	 mov	 rcx, rbx
  00385	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0038a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0038e	5f		 pop	 rdi
  0038f	5e		 pop	 rsi
  00390	5b		 pop	 rbx
  00391	e9 00 00 00 00	 jmp	 compiler_call
$LN50@compiler_v@5:

; 3369 :     case Num_kind:
; 3370 :         ADDOP_O(c, LOAD_CONST, e->v.Num.n, consts);

  00396	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]
$LN118@compiler_v@5:
  0039a	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0039e	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  003a3	48 8b cb	 mov	 rcx, rbx
  003a6	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  003aa	e8 00 00 00 00	 call	 compiler_addop_o
  003af	e9 f8 fc ff ff	 jmp	 $LN116@compiler_v@5
$LN44@compiler_v@5:

; 3371 :         break;
; 3372 :     case Str_kind:
; 3373 :         ADDOP_O(c, LOAD_CONST, e->v.Str.s, consts);
; 3374 :         break;
; 3375 :     case Bytes_kind:
; 3376 :         ADDOP_O(c, LOAD_CONST, e->v.Bytes.s, consts);
; 3377 :         break;
; 3378 :     case Ellipsis_kind:
; 3379 :         ADDOP_O(c, LOAD_CONST, Py_Ellipsis, consts);

  003b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_EllipsisObject
  003bb	eb dd		 jmp	 SHORT $LN118@compiler_v@5
$LN42@compiler_v@5:

; 3380 :         break;
; 3381 :     /* The following exprs can be assignment targets. */
; 3382 :     case Attribute_kind:
; 3383 :         if (e->v.Attribute.ctx != AugStore)

  003bd	83 7f 18 05	 cmp	 DWORD PTR [rdi+24], 5
  003c1	74 14		 je	 SHORT $LN40@compiler_v@5

; 3384 :             VISIT(c, expr, e->v.Attribute.value);

  003c3	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  003c7	48 8b cb	 mov	 rcx, rbx
  003ca	e8 00 00 00 00	 call	 compiler_visit_expr
  003cf	85 c0		 test	 eax, eax
  003d1	0f 84 dd fc ff
	ff		 je	 $LN114@compiler_v@5
$LN40@compiler_v@5:

; 3385 :         switch (e->v.Attribute.ctx) {

  003d7	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]
  003da	ff c9		 dec	 ecx
  003dc	74 7e		 je	 SHORT $LN36@compiler_v@5
  003de	ff c9		 dec	 ecx
  003e0	74 47		 je	 SHORT $LN32@compiler_v@5
  003e2	ff c9		 dec	 ecx
  003e4	0f 84 90 00 00
	00		 je	 $LN29@compiler_v@5
  003ea	ff c9		 dec	 ecx
  003ec	74 59		 je	 SHORT $LN37@compiler_v@5
  003ee	ff c9		 dec	 ecx
  003f0	74 22		 je	 SHORT $LN33@compiler_v@5

; 3400 :             break;
; 3401 :         case Param:
; 3402 :         default:
; 3403 :             PyErr_SetString(PyExc_SystemError,
; 3404 :                             "param invalid in attribute expression");

  003f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@COAMAJAK@param?5invalid?5in?5attribute?5expre@
  00400	e8 00 00 00 00	 call	 PyErr_SetString
  00405	33 c0		 xor	 eax, eax
  00407	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  0040c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00410	5f		 pop	 rdi
  00411	5e		 pop	 rsi
  00412	5b		 pop	 rbx
  00413	c3		 ret	 0
$LN33@compiler_v@5:

; 3391 :             break;
; 3392 :         case AugStore:
; 3393 :             ADDOP(c, ROT_TWO);

  00414	ba 02 00 00 00	 mov	 edx, 2
  00419	48 8b cb	 mov	 rcx, rbx
  0041c	e8 00 00 00 00	 call	 compiler_addop
  00421	85 c0		 test	 eax, eax
  00423	0f 84 8b fc ff
	ff		 je	 $LN114@compiler_v@5
$LN32@compiler_v@5:

; 3394 :             /* Fall through to save */
; 3395 :         case Store:
; 3396 :             ADDOP_NAME(c, STORE_ATTR, e->v.Attribute.attr, names);

  00429	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0042d	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00431	ba 5f 00 00 00	 mov	 edx, 95			; 0000005fH
  00436	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  0043a	48 8b cb	 mov	 rcx, rbx
  0043d	e8 00 00 00 00	 call	 compiler_addop_name
  00442	e9 65 fc ff ff	 jmp	 $LN116@compiler_v@5
$LN37@compiler_v@5:

; 3386 :         case AugLoad:
; 3387 :             ADDOP(c, DUP_TOP);

  00447	ba 04 00 00 00	 mov	 edx, 4
  0044c	48 8b cb	 mov	 rcx, rbx
  0044f	e8 00 00 00 00	 call	 compiler_addop
  00454	85 c0		 test	 eax, eax
  00456	0f 84 58 fc ff
	ff		 je	 $LN114@compiler_v@5
$LN36@compiler_v@5:

; 3388 :             /* Fall through to load */
; 3389 :         case Load:
; 3390 :             ADDOP_NAME(c, LOAD_ATTR, e->v.Attribute.attr, names);

  0045c	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00460	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00464	ba 6a 00 00 00	 mov	 edx, 106		; 0000006aH
  00469	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  0046d	48 8b cb	 mov	 rcx, rbx
  00470	e8 00 00 00 00	 call	 compiler_addop_name
  00475	e9 32 fc ff ff	 jmp	 $LN116@compiler_v@5
$LN29@compiler_v@5:

; 3397 :             break;
; 3398 :         case Del:
; 3399 :             ADDOP_NAME(c, DELETE_ATTR, e->v.Attribute.attr, names);

  0047a	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0047e	4c 8b 4f 10	 mov	 r9, QWORD PTR [rdi+16]
  00482	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00487	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  0048b	48 8b cb	 mov	 rcx, rbx
  0048e	e8 00 00 00 00	 call	 compiler_addop_name
  00493	e9 14 fc ff ff	 jmp	 $LN116@compiler_v@5
$LN26@compiler_v@5:

; 3405 :             return 0;
; 3406 :         }
; 3407 :         break;
; 3408 :     case Subscript_kind:
; 3409 :         switch (e->v.Subscript.ctx) {

  00498	8b 4f 18	 mov	 ecx, DWORD PTR [rdi+24]
  0049b	ff c9		 dec	 ecx
  0049d	0f 84 ce 00 00
	00		 je	 $LN20@compiler_v@5
  004a3	ff c9		 dec	 ecx
  004a5	0f 84 9b 00 00
	00		 je	 $LN15@compiler_v@5
  004ab	ff c9		 dec	 ecx
  004ad	74 6c		 je	 SHORT $LN12@compiler_v@5
  004af	ff c9		 dec	 ecx
  004b1	74 3d		 je	 SHORT $LN23@compiler_v@5
  004b3	ff c9		 dec	 ecx
  004b5	74 22		 je	 SHORT $LN17@compiler_v@5

; 3428 :             break;
; 3429 :         case Param:
; 3430 :         default:
; 3431 :             PyErr_SetString(PyExc_SystemError,
; 3432 :                 "param invalid in subscript expression");

  004b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  004be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CACGIAAN@param?5invalid?5in?5subscript?5expre@
  004c5	e8 00 00 00 00	 call	 PyErr_SetString
  004ca	33 c0		 xor	 eax, eax
  004cc	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  004d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  004d5	5f		 pop	 rdi
  004d6	5e		 pop	 rsi
  004d7	5b		 pop	 rbx
  004d8	c3		 ret	 0
$LN17@compiler_v@5:

; 3417 :             break;
; 3418 :         case AugStore:
; 3419 :             VISIT_SLICE(c, e->v.Subscript.slice, AugStore);

  004d9	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  004dd	41 b8 05 00 00
	00		 mov	 r8d, 5
  004e3	48 8b cb	 mov	 rcx, rbx
  004e6	e8 00 00 00 00	 call	 compiler_visit_slice
  004eb	e9 bc fb ff ff	 jmp	 $LN116@compiler_v@5
$LN23@compiler_v@5:

; 3410 :         case AugLoad:
; 3411 :             VISIT(c, expr, e->v.Subscript.value);

  004f0	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  004f4	48 8b cb	 mov	 rcx, rbx
  004f7	e8 00 00 00 00	 call	 compiler_visit_expr
  004fc	85 c0		 test	 eax, eax
  004fe	0f 84 b0 fb ff
	ff		 je	 $LN114@compiler_v@5

; 3412 :             VISIT_SLICE(c, e->v.Subscript.slice, AugLoad);

  00504	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00508	41 b8 04 00 00
	00		 mov	 r8d, 4
  0050e	48 8b cb	 mov	 rcx, rbx
  00511	e8 00 00 00 00	 call	 compiler_visit_slice
  00516	e9 91 fb ff ff	 jmp	 $LN116@compiler_v@5
$LN12@compiler_v@5:

; 3424 :             break;
; 3425 :         case Del:
; 3426 :             VISIT(c, expr, e->v.Subscript.value);

  0051b	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0051f	48 8b cb	 mov	 rcx, rbx
  00522	e8 00 00 00 00	 call	 compiler_visit_expr
  00527	85 c0		 test	 eax, eax
  00529	0f 84 85 fb ff
	ff		 je	 $LN114@compiler_v@5

; 3427 :             VISIT_SLICE(c, e->v.Subscript.slice, Del);

  0052f	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00533	41 b8 03 00 00
	00		 mov	 r8d, 3
  00539	48 8b cb	 mov	 rcx, rbx
  0053c	e8 00 00 00 00	 call	 compiler_visit_slice
  00541	e9 66 fb ff ff	 jmp	 $LN116@compiler_v@5
$LN15@compiler_v@5:

; 3420 :             break;
; 3421 :         case Store:
; 3422 :             VISIT(c, expr, e->v.Subscript.value);

  00546	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0054a	48 8b cb	 mov	 rcx, rbx
  0054d	e8 00 00 00 00	 call	 compiler_visit_expr
  00552	85 c0		 test	 eax, eax
  00554	0f 84 5a fb ff
	ff		 je	 $LN114@compiler_v@5

; 3423 :             VISIT_SLICE(c, e->v.Subscript.slice, Store);

  0055a	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0055e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00564	48 8b cb	 mov	 rcx, rbx
  00567	e8 00 00 00 00	 call	 compiler_visit_slice
  0056c	e9 3b fb ff ff	 jmp	 $LN116@compiler_v@5
$LN20@compiler_v@5:

; 3413 :             break;
; 3414 :         case Load:
; 3415 :             VISIT(c, expr, e->v.Subscript.value);

  00571	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00575	48 8b cb	 mov	 rcx, rbx
  00578	e8 00 00 00 00	 call	 compiler_visit_expr
  0057d	85 c0		 test	 eax, eax
  0057f	0f 84 2f fb ff
	ff		 je	 $LN114@compiler_v@5

; 3416 :             VISIT_SLICE(c, e->v.Subscript.slice, Load);

  00585	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00589	41 b8 01 00 00
	00		 mov	 r8d, 1
  0058f	48 8b cb	 mov	 rcx, rbx
  00592	e8 00 00 00 00	 call	 compiler_visit_slice
  00597	e9 10 fb ff ff	 jmp	 $LN116@compiler_v@5
$LN8@compiler_v@5:

; 3433 :             return 0;
; 3434 :         }
; 3435 :         break;
; 3436 :     case Starred_kind:
; 3437 :         switch (e->v.Starred.ctx) {

  0059c	83 7f 10 02	 cmp	 DWORD PTR [rdi+16], 2

; 3443 :         default:
; 3444 :             return compiler_error(c,
; 3445 :                 "can use starred expression only as assignment target");

  005a0	48 8b cb	 mov	 rcx, rbx
  005a3	74 18		 je	 SHORT $LN5@compiler_v@5
  005a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@NHBPOLCF@can?5use?5starred?5expression?5only?5@
  005ac	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  005b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005b5	5f		 pop	 rdi
  005b6	5e		 pop	 rsi
  005b7	5b		 pop	 rbx
  005b8	e9 00 00 00 00	 jmp	 compiler_error
$LN5@compiler_v@5:

; 3438 :         case Store:
; 3439 :             /* In all legitimate cases, the Starred node was already replaced
; 3440 :              * by compiler_list/compiler_tuple. XXX: is that okay? */
; 3441 :             return compiler_error(c,
; 3442 :                 "starred assignment target must be in a list or tuple");

  005bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@IPNNMMFP@starred?5assignment?5target?5must?5b@
  005c4	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  005c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005cd	5f		 pop	 rdi
  005ce	5e		 pop	 rsi
  005cf	5b		 pop	 rbx
  005d0	e9 00 00 00 00	 jmp	 compiler_error
$LN3@compiler_v@5:

; 3446 :         }
; 3447 :         break;
; 3448 :     case Name_kind:
; 3449 :         return compiler_nameop(c, e->v.Name.id, e->v.Name.ctx);

  005d5	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  005d9	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  005dd	48 8b cb	 mov	 rcx, rbx
  005e0	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  005e5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005e9	5f		 pop	 rdi
  005ea	5e		 pop	 rsi
  005eb	5b		 pop	 rbx
  005ec	e9 00 00 00 00	 jmp	 compiler_nameop
$LN2@compiler_v@5:

; 3450 :     /* child nodes of List and Tuple will have expr_context set */
; 3451 :     case List_kind:
; 3452 :         return compiler_list(c, e);

  005f1	48 8b d7	 mov	 rdx, rdi
  005f4	48 8b cb	 mov	 rcx, rbx
  005f7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  005fc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00600	5f		 pop	 rdi
  00601	5e		 pop	 rsi
  00602	5b		 pop	 rbx
  00603	e9 00 00 00 00	 jmp	 compiler_list
$LN1@compiler_v@5:

; 3453 :     case Tuple_kind:
; 3454 :         return compiler_tuple(c, e);

  00608	48 8b d7	 mov	 rdx, rdi
  0060b	48 8b cb	 mov	 rcx, rbx
  0060e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]

; 3457 : }

  00613	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00617	5f		 pop	 rdi
  00618	5e		 pop	 rsi
  00619	5b		 pop	 rbx
  0061a	e9 00 00 00 00	 jmp	 compiler_tuple
  0061f	90		 npad	 1
$LN112@compiler_v@5:
  00620	00 00 00 00	 DD	 $LN93@compiler_v@5
  00624	00 00 00 00	 DD	 $LN92@compiler_v@5
  00628	00 00 00 00	 DD	 $LN88@compiler_v@5
  0062c	00 00 00 00	 DD	 $LN85@compiler_v@5
  00630	00 00 00 00	 DD	 $LN84@compiler_v@5
  00634	00 00 00 00	 DD	 $LN83@compiler_v@5
  00638	00 00 00 00	 DD	 $LN75@compiler_v@5
  0063c	00 00 00 00	 DD	 $LN68@compiler_v@5
  00640	00 00 00 00	 DD	 $LN67@compiler_v@5
  00644	00 00 00 00	 DD	 $LN66@compiler_v@5
  00648	00 00 00 00	 DD	 $LN69@compiler_v@5
  0064c	00 00 00 00	 DD	 $LN65@compiler_v@5
  00650	00 00 00 00	 DD	 $LN58@compiler_v@5
  00654	00 00 00 00	 DD	 $LN52@compiler_v@5
  00658	00 00 00 00	 DD	 $LN51@compiler_v@5
  0065c	00 00 00 00	 DD	 $LN50@compiler_v@5
  00660	00 00 00 00	 DD	 $LN50@compiler_v@5
  00664	00 00 00 00	 DD	 $LN50@compiler_v@5
  00668	00 00 00 00	 DD	 $LN44@compiler_v@5
  0066c	00 00 00 00	 DD	 $LN42@compiler_v@5
  00670	00 00 00 00	 DD	 $LN26@compiler_v@5
  00674	00 00 00 00	 DD	 $LN8@compiler_v@5
  00678	00 00 00 00	 DD	 $LN3@compiler_v@5
  0067c	00 00 00 00	 DD	 $LN2@compiler_v@5
  00680	00 00 00 00	 DD	 $LN1@compiler_v@5
compiler_visit_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@ ; `string'
EXTRN	_Py_Attribute:PROC
EXTRN	_Py_Subscript:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_augassign DD imagerel compiler_augassign
	DD	imagerel compiler_augassign+486
	DD	imagerel $unwind$compiler_augassign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_augassign DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@
CONST	SEGMENT
??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@ DB 'in'
	DB	'valid node type (%d) for augmented assignment', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_augassign
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_augassign PROC					; COMDAT

; 3461 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3462 :     expr_ty e = s->v.AugAssign.target;

  0000f	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  00013	48 8b d9	 mov	 rbx, rcx
  00016	48 8b fa	 mov	 rdi, rdx

; 3463 :     expr_ty auge;
; 3464 : 
; 3465 :     assert(s->kind == AugAssign_kind);
; 3466 : 
; 3467 :     switch (e->kind) {

  00019	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  0001c	41 8b c8	 mov	 ecx, r8d
  0001f	83 e9 14	 sub	 ecx, 20
  00022	0f 84 2b 01 00
	00		 je	 $LN17@compiler_a@7
  00028	ff c9		 dec	 ecx
  0002a	0f 84 93 00 00
	00		 je	 $LN11@compiler_a@7
  00030	83 f9 02	 cmp	 ecx, 2
  00033	74 25		 je	 SHORT $LN5@compiler_a@7

; 3496 :     default:
; 3497 :         PyErr_Format(PyExc_SystemError,
; 3498 :             "invalid node type (%d) for augmented assignment",
; 3499 :             e->kind);

  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EGNPBIDB@invalid?5node?5type?5?$CI?$CFd?$CJ?5for?5augme@
  00043	e8 00 00 00 00	 call	 PyErr_Format

; 3500 :         return 0;

  00048	33 c0		 xor	 eax, eax

; 3501 :     }
; 3502 :     return 1;
; 3503 : }

  0004a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN5@compiler_a@7:

; 3489 :         break;
; 3490 :     case Name_kind:
; 3491 :         if (!compiler_nameop(c, e->v.Name.id, Load))

  0005a	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  0005e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00064	48 8b cb	 mov	 rcx, rbx
  00067	e8 00 00 00 00	 call	 compiler_nameop
  0006c	85 c0		 test	 eax, eax

; 3492 :             return 0;

  0006e	0f 84 cd 00 00
	00		 je	 $LN22@compiler_a@7

; 3493 :         VISIT(c, expr, s->v.AugAssign.value);

  00074	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 compiler_visit_expr
  00080	85 c0		 test	 eax, eax
  00082	0f 84 b9 00 00
	00		 je	 $LN22@compiler_a@7

; 3494 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  00088	8b 4f 10	 mov	 ecx, DWORD PTR [rdi+16]
  0008b	e8 00 00 00 00	 call	 inplace_binop
  00090	48 8b cb	 mov	 rcx, rbx
  00093	8b d0		 mov	 edx, eax
  00095	e8 00 00 00 00	 call	 compiler_addop
  0009a	85 c0		 test	 eax, eax
  0009c	0f 84 9f 00 00
	00		 je	 $LN22@compiler_a@7

; 3495 :         return compiler_nameop(c, e->v.Name.id, Store);

  000a2	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  000a6	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ac	48 8b cb	 mov	 rcx, rbx

; 3501 :     }
; 3502 :     return 1;
; 3503 : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	e9 00 00 00 00	 jmp	 compiler_nameop
$LN11@compiler_a@7:

; 3478 :         break;
; 3479 :     case Subscript_kind:
; 3480 :         auge = Subscript(e->v.Subscript.value, e->v.Subscript.slice,
; 3481 :                          AugLoad, e->lineno, e->col_offset, c->c_arena);

  000c3	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000c7	44 8b 4e 30	 mov	 r9d, DWORD PTR [rsi+48]
  000cb	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  000cf	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000d3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d8	8b 46 34	 mov	 eax, DWORD PTR [rsi+52]
  000db	41 b8 04 00 00
	00		 mov	 r8d, 4
  000e1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e5	e8 00 00 00 00	 call	 _Py_Subscript
  000ea	48 8b f0	 mov	 rsi, rax

; 3482 :         if (auge == NULL)

  000ed	48 85 c0	 test	 rax, rax

; 3483 :             return 0;

  000f0	74 4f		 je	 SHORT $LN22@compiler_a@7

; 3484 :         VISIT(c, expr, auge);

  000f2	48 8b d0	 mov	 rdx, rax
  000f5	48 8b cb	 mov	 rcx, rbx
  000f8	e8 00 00 00 00	 call	 compiler_visit_expr
  000fd	85 c0		 test	 eax, eax
  000ff	74 40		 je	 SHORT $LN22@compiler_a@7

; 3485 :         VISIT(c, expr, s->v.AugAssign.value);

  00101	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00105	48 8b cb	 mov	 rcx, rbx
  00108	e8 00 00 00 00	 call	 compiler_visit_expr
  0010d	85 c0		 test	 eax, eax
  0010f	74 30		 je	 SHORT $LN22@compiler_a@7

; 3486 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  00111	8b 4f 10	 mov	 ecx, DWORD PTR [rdi+16]
  00114	e8 00 00 00 00	 call	 inplace_binop
  00119	48 8b cb	 mov	 rcx, rbx
  0011c	8b d0		 mov	 edx, eax
  0011e	e8 00 00 00 00	 call	 compiler_addop
  00123	85 c0		 test	 eax, eax
  00125	74 1a		 je	 SHORT $LN22@compiler_a@7

; 3487 :         auge->v.Subscript.ctx = AugStore;
; 3488 :         VISIT(c, expr, auge);

  00127	48 8b d6	 mov	 rdx, rsi
  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	c7 46 18 05 00
	00 00		 mov	 DWORD PTR [rsi+24], 5
  00134	e8 00 00 00 00	 call	 compiler_visit_expr
  00139	85 c0		 test	 eax, eax
  0013b	0f 85 90 00 00
	00		 jne	 $LN12@compiler_a@7
$LN22@compiler_a@7:
  00141	33 c0		 xor	 eax, eax

; 3501 :     }
; 3502 :     return 1;
; 3503 : }

  00143	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00148	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0014d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00151	5f		 pop	 rdi
  00152	c3		 ret	 0
$LN17@compiler_a@7:

; 3468 :     case Attribute_kind:
; 3469 :         auge = Attribute(e->v.Attribute.value, e->v.Attribute.attr,
; 3470 :                          AugLoad, e->lineno, e->col_offset, c->c_arena);

  00153	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00157	44 8b 4e 30	 mov	 r9d, DWORD PTR [rsi+48]
  0015b	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  0015f	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00163	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00168	8b 46 34	 mov	 eax, DWORD PTR [rsi+52]
  0016b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00171	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00175	e8 00 00 00 00	 call	 _Py_Attribute
  0017a	48 8b f0	 mov	 rsi, rax

; 3471 :         if (auge == NULL)

  0017d	48 85 c0	 test	 rax, rax

; 3472 :             return 0;

  00180	74 bf		 je	 SHORT $LN22@compiler_a@7

; 3473 :         VISIT(c, expr, auge);

  00182	48 8b d0	 mov	 rdx, rax
  00185	48 8b cb	 mov	 rcx, rbx
  00188	e8 00 00 00 00	 call	 compiler_visit_expr
  0018d	85 c0		 test	 eax, eax
  0018f	74 b0		 je	 SHORT $LN22@compiler_a@7

; 3474 :         VISIT(c, expr, s->v.AugAssign.value);

  00191	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00195	48 8b cb	 mov	 rcx, rbx
  00198	e8 00 00 00 00	 call	 compiler_visit_expr
  0019d	85 c0		 test	 eax, eax
  0019f	74 a0		 je	 SHORT $LN22@compiler_a@7

; 3475 :         ADDOP(c, inplace_binop(c, s->v.AugAssign.op));

  001a1	8b 4f 10	 mov	 ecx, DWORD PTR [rdi+16]
  001a4	e8 00 00 00 00	 call	 inplace_binop
  001a9	48 8b cb	 mov	 rcx, rbx
  001ac	8b d0		 mov	 edx, eax
  001ae	e8 00 00 00 00	 call	 compiler_addop
  001b3	85 c0		 test	 eax, eax
  001b5	74 8a		 je	 SHORT $LN22@compiler_a@7

; 3476 :         auge->v.Attribute.ctx = AugStore;
; 3477 :         VISIT(c, expr, auge);

  001b7	48 8b d6	 mov	 rdx, rsi
  001ba	48 8b cb	 mov	 rcx, rbx
  001bd	c7 46 18 05 00
	00 00		 mov	 DWORD PTR [rsi+24], 5
  001c4	e8 00 00 00 00	 call	 compiler_visit_expr
  001c9	85 c0		 test	 eax, eax
  001cb	0f 84 70 ff ff
	ff		 je	 $LN22@compiler_a@7
$LN12@compiler_a@7:

; 3501 :     }
; 3502 :     return 1;
; 3503 : }

  001d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001d6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001db	b8 01 00 00 00	 mov	 eax, 1
  001e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e4	5f		 pop	 rdi
  001e5	c3		 ret	 0
compiler_augassign ENDP
_TEXT	ENDS
_BSS	SEGMENT
__doc__	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_body DD imagerel compiler_body
	DD	imagerel compiler_body+130
	DD	imagerel $unwind$compiler_body
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_body DD imagerel compiler_body+130
	DD	imagerel compiler_body+198
	DD	imagerel $chain$0$compiler_body
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_body DD imagerel compiler_body+198
	DD	imagerel compiler_body+205
	DD	imagerel $chain$2$compiler_body
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_body DD imagerel compiler_body+205
	DD	imagerel compiler_body+226
	DD	imagerel $chain$3$compiler_body
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_body DD 021H
	DD	imagerel compiler_body
	DD	imagerel compiler_body+130
	DD	imagerel $unwind$compiler_body
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_body DD 020021H
	DD	067400H
	DD	imagerel compiler_body
	DD	imagerel compiler_body+130
	DD	imagerel $unwind$compiler_body
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_body DD 020521H
	DD	067405H
	DD	imagerel compiler_body
	DD	imagerel compiler_body+130
	DD	imagerel $unwind$compiler_body
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_body DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0600b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_body
_TEXT	SEGMENT
c$ = 48
stmts$ = 56
compiler_body PROC					; COMDAT

; 1261 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1262 :     int i = 0;

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8b e9	 mov	 rbp, rcx

; 1263 :     stmt_ty st;
; 1264 : 
; 1265 :     if (!asdl_seq_LEN(stmts))

  00017	48 85 d2	 test	 rdx, rdx
  0001a	0f 84 ad 00 00
	00		 je	 $LN17@compiler_b@2
  00020	48 39 1a	 cmp	 QWORD PTR [rdx], rbx
  00023	0f 84 a4 00 00
	00		 je	 $LN17@compiler_b@2

; 1266 :         return 1;
; 1267 :     st = (stmt_ty)asdl_seq_GET(stmts, 0);

  00029	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]

; 1268 :     if (compiler_isdocstring(st) && c->c_optimize < 2) {

  0002d	48 8b ca	 mov	 rcx, rdx
  00030	e8 00 00 00 00	 call	 compiler_isdocstring
  00035	85 c0		 test	 eax, eax
  00037	74 46		 je	 SHORT $LN5@compiler_b@2
  00039	83 7d 28 02	 cmp	 DWORD PTR [rbp+40], 2
  0003d	7d 40		 jge	 SHORT $LN5@compiler_b@2

; 1269 :         /* don't generate docstrings if -OO */
; 1270 :         i = 1;
; 1271 :         VISIT(c, expr, st->v.Expr.value);

  0003f	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00043	48 8b cd	 mov	 rcx, rbp
  00046	bb 01 00 00 00	 mov	 ebx, 1
  0004b	e8 00 00 00 00	 call	 compiler_visit_expr
  00050	85 c0		 test	 eax, eax
  00052	75 12		 jne	 SHORT $LN6@compiler_b@2
$LN19@compiler_b@2:
  00054	33 c0		 xor	 eax, eax

; 1278 : }

  00056	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5e		 pop	 rsi
  00065	c3		 ret	 0
$LN6@compiler_b@2:

; 1272 :         if (!compiler_nameop(c, __doc__, Store))

  00066	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __doc__
  0006d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00073	48 8b cd	 mov	 rcx, rbp
  00076	e8 00 00 00 00	 call	 compiler_nameop
  0007b	85 c0		 test	 eax, eax

; 1273 :             return 0;

  0007d	74 d5		 je	 SHORT $LN19@compiler_b@2
$LN5@compiler_b@2:
  0007f	48 63 c3	 movsxd	 rax, ebx
  00082	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1276 :         VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));

  00087	48 8d 7c c6 08	 lea	 rdi, QWORD PTR [rsi+rax*8+8]
  0008c	0f 1f 40 00	 npad	 4
$LL4@compiler_b@2:

; 1274 :     }
; 1275 :     for (; i < asdl_seq_LEN(stmts); i++)

  00090	48 63 c3	 movsxd	 rax, ebx
  00093	48 3b 06	 cmp	 rax, QWORD PTR [rsi]
  00096	7d 2e		 jge	 SHORT $LN2@compiler_b@2

; 1276 :         VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));

  00098	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0009b	48 8b cd	 mov	 rcx, rbp
  0009e	e8 00 00 00 00	 call	 compiler_visit_stmt
  000a3	85 c0		 test	 eax, eax
  000a5	74 08		 je	 SHORT $LN16@compiler_b@2

; 1274 :     }
; 1275 :     for (; i < asdl_seq_LEN(stmts); i++)

  000a7	ff c3		 inc	 ebx
  000a9	48 83 c7 08	 add	 rdi, 8
  000ad	eb e1		 jmp	 SHORT $LL4@compiler_b@2
$LN16@compiler_b@2:

; 1276 :         VISIT(c, stmt, (stmt_ty)asdl_seq_GET(stmts, i));

  000af	33 c0		 xor	 eax, eax
$LN18@compiler_b@2:
  000b1	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1278 : }

  000b6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000bb	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5e		 pop	 rsi
  000c5	c3		 ret	 0
$LN2@compiler_b@2:

; 1277 :     return 1;

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	eb e4		 jmp	 SHORT $LN18@compiler_b@2
$LN17@compiler_b@2:

; 1278 : }

  000cd	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d2	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
compiler_body ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_decorators DD imagerel compiler_decorators
	DD	imagerel compiler_decorators+112
	DD	imagerel $unwind$compiler_decorators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_decorators DD 082d01H
	DD	07742dH
	DD	063428H
	DD	08540aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_decorators
_TEXT	SEGMENT
c$ = 48
decos$ = 56
compiler_decorators PROC				; COMDAT

; 1420 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	48 8b e9	 mov	 rbp, rcx

; 1421 :     int i;
; 1422 : 
; 1423 :     if (!decos)

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 0e		 jne	 SHORT $LN5@compiler_d@2

; 1424 :         return 1;

  00015	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 1430 : }

  00018	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5e		 pop	 rsi
  00022	c3		 ret	 0
$LN5@compiler_d@2:
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 1425 : 
; 1426 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0002d	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  00031	33 db		 xor	 ebx, ebx
$LL4@compiler_d@2:
  00033	48 63 c3	 movsxd	 rax, ebx
  00036	48 3b 06	 cmp	 rax, QWORD PTR [rsi]
  00039	7d 1b		 jge	 SHORT $LN2@compiler_d@2

; 1427 :         VISIT(c, expr, (expr_ty)asdl_seq_GET(decos, i));

  0003b	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0003e	48 8b cd	 mov	 rcx, rbp
  00041	e8 00 00 00 00	 call	 compiler_visit_expr
  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN11@compiler_d@2

; 1425 : 
; 1426 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0004a	ff c3		 inc	 ebx
  0004c	48 83 c7 08	 add	 rdi, 8
  00050	eb e1		 jmp	 SHORT $LL4@compiler_d@2
$LN11@compiler_d@2:

; 1427 :         VISIT(c, expr, (expr_ty)asdl_seq_GET(decos, i));

  00052	33 c0		 xor	 eax, eax
  00054	eb 05		 jmp	 SHORT $LN13@compiler_d@2
$LN2@compiler_d@2:

; 1428 :     }
; 1429 :     return 1;

  00056	b8 01 00 00 00	 mov	 eax, 1
$LN13@compiler_d@2:
  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 1430 : }

  00065	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5e		 pop	 rsi
  0006f	c3		 ret	 0
compiler_decorators ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_argannotation DD imagerel compiler_visit_argannotation
	DD	imagerel compiler_visit_argannotation+75
	DD	imagerel $unwind$compiler_visit_argannotation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_argannotation DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_visit_argannotation
_TEXT	SEGMENT
c$ = 48
id$ = 56
annotation$ = 64
names$ = 72
compiler_visit_argannotation PROC			; COMDAT

; 1458 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b d9	 mov	 rbx, r9
  0000d	48 8b fa	 mov	 rdi, rdx

; 1459 :     if (annotation) {

  00010	4d 85 c0	 test	 r8, r8
  00013	74 29		 je	 SHORT $LN1@compiler_v@6

; 1460 :         VISIT(c, expr, annotation);

  00015	49 8b d0	 mov	 rdx, r8
  00018	e8 00 00 00 00	 call	 compiler_visit_expr
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN1@compiler_v@6

; 1461 :         if (PyList_Append(names, id))

  00021	48 8b d7	 mov	 rdx, rdi
  00024	48 8b cb	 mov	 rcx, rbx
  00027	e8 00 00 00 00	 call	 PyList_Append
  0002c	85 c0		 test	 eax, eax
  0002e	74 0e		 je	 SHORT $LN1@compiler_v@6

; 1462 :             return -1;

  00030	83 c8 ff	 or	 eax, -1

; 1465 : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN1@compiler_v@6:

; 1463 :     }
; 1464 :     return 0;

  0003e	33 c0		 xor	 eax, eax

; 1465 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
compiler_visit_argannotation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_argannotations DD imagerel compiler_visit_argannotations
	DD	imagerel compiler_visit_argannotations+131
	DD	imagerel $unwind$compiler_visit_argannotations
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_argannotations DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_visit_argannotations
_TEXT	SEGMENT
c$ = 48
args$ = 56
names$ = 64
compiler_visit_argannotations PROC			; COMDAT

; 1470 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	49 8b e8	 mov	 rbp, r8
  0001d	48 8b f2	 mov	 rsi, rdx
  00020	4c 8b e1	 mov	 r12, rcx

; 1471 :     int i, error;
; 1472 :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  00023	33 db		 xor	 ebx, ebx
  00025	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@compiler_v@7:
  00030	48 85 f6	 test	 rsi, rsi
  00033	75 05		 jne	 SHORT $LN7@compiler_v@7
  00035	45 33 c9	 xor	 r9d, r9d
  00038	eb 03		 jmp	 SHORT $LN8@compiler_v@7
$LN7@compiler_v@7:
  0003a	4c 8b 0e	 mov	 r9, QWORD PTR [rsi]
$LN8@compiler_v@7:
  0003d	48 63 c3	 movsxd	 rax, ebx
  00040	49 3b c1	 cmp	 rax, r9
  00043	7d 21		 jge	 SHORT $LN2@compiler_v@7

; 1473 :         arg_ty arg = (arg_ty)asdl_seq_GET(args, i);

  00045	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 1474 :         error = compiler_visit_argannotation(
; 1475 :                         c,
; 1476 :                         arg->arg,
; 1477 :                         arg->annotation,
; 1478 :                         names);

  00048	4c 8b cd	 mov	 r9, rbp
  0004b	49 8b cc	 mov	 rcx, r12
  0004e	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00052	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00055	e8 00 00 00 00	 call	 compiler_visit_argannotation

; 1479 :         if (error)

  0005a	85 c0		 test	 eax, eax
  0005c	75 0a		 jne	 SHORT $LN5@compiler_v@7

; 1471 :     int i, error;
; 1472 :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  0005e	ff c3		 inc	 ebx
  00060	48 83 c7 08	 add	 rdi, 8
  00064	eb ca		 jmp	 SHORT $LL4@compiler_v@7
$LN2@compiler_v@7:

; 1480 :             return error;
; 1481 :     }
; 1482 :     return 0;

  00066	33 c0		 xor	 eax, eax
$LN5@compiler_v@7:

; 1483 : }

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00072	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00077	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	41 5c		 pop	 r12
  00082	c3		 ret	 0
compiler_visit_argannotations ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@	; `string'
PUBLIC	??_C@_06LNOFJDNM@return?$AA@			; `string'
_BSS	SEGMENT
?return_str@?1??compiler_visit_annotations@@9@9 DQ 01H DUP (?) ; `compiler_visit_annotations'::`2'::return_str
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_annotations DD imagerel compiler_visit_annotations
	DD	imagerel compiler_visit_annotations+63
	DD	imagerel $unwind$compiler_visit_annotations
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_visit_annotations DD imagerel compiler_visit_annotations+63
	DD	imagerel compiler_visit_annotations+288
	DD	imagerel $chain$1$compiler_visit_annotations
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_visit_annotations DD imagerel compiler_visit_annotations+288
	DD	imagerel compiler_visit_annotations+308
	DD	imagerel $chain$3$compiler_visit_annotations
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compiler_visit_annotations DD imagerel compiler_visit_annotations+308
	DD	imagerel compiler_visit_annotations+382
	DD	imagerel $chain$4$compiler_visit_annotations
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$compiler_visit_annotations DD imagerel compiler_visit_annotations+382
	DD	imagerel compiler_visit_annotations+407
	DD	imagerel $chain$5$compiler_visit_annotations
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$compiler_visit_annotations DD 021H
	DD	imagerel compiler_visit_annotations+288
	DD	imagerel compiler_visit_annotations+308
	DD	imagerel $chain$3$compiler_visit_annotations
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compiler_visit_annotations DD 020521H
	DD	085405H
	DD	imagerel compiler_visit_annotations+288
	DD	imagerel compiler_visit_annotations+308
	DD	imagerel $chain$3$compiler_visit_annotations
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_visit_annotations DD 040021H
	DD	0ad400H
	DD	09c400H
	DD	imagerel compiler_visit_annotations
	DD	imagerel compiler_visit_annotations+63
	DD	imagerel $unwind$compiler_visit_annotations
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_visit_annotations DD 040a21H
	DD	0ad40aH
	DD	09c405H
	DD	imagerel compiler_visit_annotations
	DD	imagerel compiler_visit_annotations+63
	DD	imagerel $unwind$compiler_visit_annotations
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_annotations DD 060d01H
	DD	0b340dH
	DD	0e009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@
CONST	SEGMENT
??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@ DB 'too many annotations', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LNOFJDNM@return?$AA@
CONST	SEGMENT
??_C@_06LNOFJDNM@return?$AA@ DB 'return', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_visit_annotations
_TEXT	SEGMENT
c$ = 64
args$ = 72
returns$ = 80
compiler_visit_annotations PROC				; COMDAT

; 1488 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000d	4c 8b f1	 mov	 r14, rcx

; 1489 :     /* Push arg annotations and a list of the argument names. Return the #
; 1490 :        of items pushed. The expressions are evaluated out-of-order wrt the
; 1491 :        source code.
; 1492 : 
; 1493 :        More than 2^16-1 annotations is a SyntaxError. Returns -1 on error.
; 1494 :        */
; 1495 :     static identifier return_str;
; 1496 :     PyObject *names;
; 1497 :     int len;
; 1498 :     names = PyList_New(0);

  00010	33 c9		 xor	 ecx, ecx
  00012	49 8b f8	 mov	 rdi, r8
  00015	48 8b da	 mov	 rbx, rdx
  00018	e8 00 00 00 00	 call	 PyList_New
  0001d	48 8b f0	 mov	 rsi, rax

; 1499 :     if (!names)

  00020	48 85 c0	 test	 rax, rax
  00023	75 11		 jne	 SHORT $LN15@compiler_v@8

; 1500 :         return -1;

  00025	83 c8 ff	 or	 eax, -1

; 1553 : }

  00028	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	41 5e		 pop	 r14
  00033	5f		 pop	 rdi
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN15@compiler_v@8:

; 1501 : 
; 1502 :     if (compiler_visit_argannotations(c, args->args, names))

  00036	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00039	4c 8b c0	 mov	 r8, rax
  0003c	49 8b ce	 mov	 rcx, r14
  0003f	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  00044	4c 89 6c 24 50	 mov	 QWORD PTR [rsp+80], r13
  00049	e8 00 00 00 00	 call	 compiler_visit_argannotations
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 a7 00 00
	00		 jne	 $error$22899

; 1503 :         goto error;
; 1504 :     if (args->varargannotation &&
; 1505 :         compiler_visit_argannotation(c, args->vararg,
; 1506 :                                      args->varargannotation, names))

  00056	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  0005a	4d 85 c0	 test	 r8, r8
  0005d	74 17		 je	 SHORT $LN13@compiler_v@8
  0005f	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00063	4c 8b ce	 mov	 r9, rsi
  00066	49 8b ce	 mov	 rcx, r14
  00069	e8 00 00 00 00	 call	 compiler_visit_argannotation
  0006e	85 c0		 test	 eax, eax
  00070	0f 85 87 00 00
	00		 jne	 $error$22899
$LN13@compiler_v@8:

; 1507 :         goto error;
; 1508 :     if (compiler_visit_argannotations(c, args->kwonlyargs, names))

  00076	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0007a	4c 8b c6	 mov	 r8, rsi
  0007d	49 8b ce	 mov	 rcx, r14
  00080	e8 00 00 00 00	 call	 compiler_visit_argannotations
  00085	85 c0		 test	 eax, eax
  00087	75 74		 jne	 SHORT $error$22899

; 1509 :         goto error;
; 1510 :     if (args->kwargannotation &&
; 1511 :         compiler_visit_argannotation(c, args->kwarg,
; 1512 :                                      args->kwargannotation, names))

  00089	4c 8b 43 28	 mov	 r8, QWORD PTR [rbx+40]
  0008d	4d 85 c0	 test	 r8, r8
  00090	74 13		 je	 SHORT $LN11@compiler_v@8
  00092	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00096	4c 8b ce	 mov	 r9, rsi
  00099	49 8b ce	 mov	 rcx, r14
  0009c	e8 00 00 00 00	 call	 compiler_visit_argannotation
  000a1	85 c0		 test	 eax, eax
  000a3	75 58		 jne	 SHORT $error$22899
$LN11@compiler_v@8:

; 1513 :         goto error;
; 1514 : 
; 1515 :     if (!return_str) {

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9
  000ac	48 85 c0	 test	 rax, rax
  000af	75 18		 jne	 SHORT $LN9@compiler_v@8

; 1516 :         return_str = PyUnicode_InternFromString("return");

  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06LNOFJDNM@return?$AA@
  000b8	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  000bd	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?return_str@?1??compiler_visit_annotations@@9@9, rax

; 1517 :         if (!return_str)

  000c4	48 85 c0	 test	 rax, rax
  000c7	74 34		 je	 SHORT $error$22899
$LN9@compiler_v@8:

; 1518 :             goto error;
; 1519 :     }
; 1520 :     if (compiler_visit_argannotation(c, return_str, returns, names)) {

  000c9	4c 8b ce	 mov	 r9, rsi
  000cc	4c 8b c7	 mov	 r8, rdi
  000cf	48 8b d0	 mov	 rdx, rax
  000d2	49 8b ce	 mov	 rcx, r14
  000d5	e8 00 00 00 00	 call	 compiler_visit_argannotation
  000da	85 c0		 test	 eax, eax
  000dc	75 1f		 jne	 SHORT $error$22899

; 1521 :         goto error;
; 1522 :     }
; 1523 : 
; 1524 :     len = PyList_GET_SIZE(names);

  000de	48 63 7e 60	 movsxd	 rdi, DWORD PTR [rsi+96]

; 1525 :     if (len > 65534) {

  000e2	81 ff fe ff 00
	00		 cmp	 edi, 65534		; 0000fffeH
  000e8	7e 36		 jle	 SHORT $LN7@compiler_v@8

; 1526 :         /* len must fit in 16 bits, and len is incremented below */
; 1527 :         PyErr_SetString(PyExc_SyntaxError,
; 1528 :                         "too many annotations");

  000ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@NFIMIMON@too?5many?5annotations?$AA@
  000f8	e8 00 00 00 00	 call	 PyErr_SetString
$error$22899:

; 1549 : 
; 1550 : error:
; 1551 :     Py_DECREF(names);

  000fd	48 8b ce	 mov	 rcx, rsi
  00100	e8 00 00 00 00	 call	 _Py_DecRef

; 1552 :     return -1;

  00105	83 c8 ff	 or	 eax, -1
$LN21@compiler_v@8:

; 1553 : }

  00108	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0010d	4c 8b 6c 24 50	 mov	 r13, QWORD PTR [rsp+80]
  00112	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	41 5e		 pop	 r14
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
$LN7@compiler_v@8:

; 1529 :         goto error;
; 1530 :     }
; 1531 :     if (len) {

  00120	85 ff		 test	 edi, edi
  00122	74 64		 je	 SHORT $LN6@compiler_v@8

; 1532 :         /* convert names to a tuple and place on stack */
; 1533 :         PyObject *elt;
; 1534 :         int i;
; 1535 :         PyObject *s = PyTuple_New(len);

  00124	48 8b cf	 mov	 rcx, rdi
  00127	e8 00 00 00 00	 call	 PyTuple_New
  0012c	4c 8b e0	 mov	 r12, rax

; 1536 :         if (!s)

  0012f	48 85 c0	 test	 rax, rax
  00132	74 c9		 je	 SHORT $error$22899

; 1537 :             goto error;
; 1538 :         for (i = 0; i < len; i++) {

  00134	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00139	33 ed		 xor	 ebp, ebp
  0013b	85 ff		 test	 edi, edi
  0013d	7e 1e		 jle	 SHORT $LN2@compiler_v@8
  0013f	90		 npad	 1
$LL4@compiler_v@8:

; 1539 :             elt = PyList_GET_ITEM(names, i);

  00140	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00144	48 8b 1c e8	 mov	 rbx, QWORD PTR [rax+rbp*8]

; 1540 :             Py_INCREF(elt);

  00148	48 8b cb	 mov	 rcx, rbx
  0014b	e8 00 00 00 00	 call	 _Py_IncRef

; 1541 :             PyTuple_SET_ITEM(s, i, elt);

  00150	49 89 5c ec 70	 mov	 QWORD PTR [r12+rbp*8+112], rbx
  00155	48 ff c5	 inc	 rbp
  00158	48 3b ef	 cmp	 rbp, rdi
  0015b	7c e3		 jl	 SHORT $LL4@compiler_v@8
$LN2@compiler_v@8:

; 1542 :         }
; 1543 :         ADDOP_O(c, LOAD_CONST, s, consts);

  0015d	4d 8b 46 38	 mov	 r8, QWORD PTR [r14+56]
  00161	4d 8b cc	 mov	 r9, r12
  00164	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00169	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0016d	49 8b ce	 mov	 rcx, r14
  00170	e8 00 00 00 00	 call	 compiler_addop_o
  00175	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0017a	85 c0		 test	 eax, eax
  0017c	74 8a		 je	 SHORT $LN21@compiler_v@8
$LN1@compiler_v@8:

; 1544 :         Py_DECREF(s);

  0017e	49 8b cc	 mov	 rcx, r12
  00181	e8 00 00 00 00	 call	 _Py_DecRef

; 1545 :         len++; /* include the just-pushed tuple */

  00186	ff c7		 inc	 edi
$LN6@compiler_v@8:

; 1546 :     }
; 1547 :     Py_DECREF(names);

  00188	48 8b ce	 mov	 rcx, rsi
  0018b	e8 00 00 00 00	 call	 _Py_DecRef

; 1548 :     return len;

  00190	8b c7		 mov	 eax, edi
  00192	e9 71 ff ff ff	 jmp	 $LN21@compiler_v@8
compiler_visit_annotations ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_function DD imagerel compiler_function
	DD	imagerel compiler_function+123
	DD	imagerel $unwind$compiler_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_function DD imagerel compiler_function+123
	DD	imagerel compiler_function+832
	DD	imagerel $chain$1$compiler_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_function DD imagerel compiler_function+832
	DD	imagerel compiler_function+856
	DD	imagerel $chain$2$compiler_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_function DD 021H
	DD	imagerel compiler_function
	DD	imagerel compiler_function+123
	DD	imagerel $unwind$compiler_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_function DD 020521H
	DD	0e5405H
	DD	imagerel compiler_function
	DD	imagerel compiler_function+123
	DD	imagerel $unwind$compiler_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_function DD 0a5b01H
	DD	0c345bH
	DD	0f6412H
	DD	0f00e5212H
	DD	0d00ae00cH
	DD	07006c008H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
xdata	ENDS
;	COMDAT compiler_function
_TEXT	SEGMENT
c$ = 96
kw_default_count$1$ = 104
s$ = 104
compiler_function PROC					; COMDAT

; 1557 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1558 :     PyCodeObject *co;
; 1559 :     PyObject *qualname, *first_const = Py_None;
; 1560 :     arguments_ty args = s->v.FunctionDef.args;
; 1561 :     expr_ty returns = s->v.FunctionDef.returns;
; 1562 :     asdl_seq* decos = s->v.FunctionDef.decorator_list;

  00012	4c 8b 62 20	 mov	 r12, QWORD PTR [rdx+32]
  00016	4c 8b 6a 10	 mov	 r13, QWORD PTR [rdx+16]
  0001a	4c 8b 7a 28	 mov	 r15, QWORD PTR [rdx+40]
  0001e	4c 8b f2	 mov	 r14, rdx

; 1563 :     stmt_ty st;
; 1564 :     int i, n, docstring, kw_default_count = 0, arglength;
; 1565 :     int num_annotations;
; 1566 : 
; 1567 :     assert(s->kind == FunctionDef_kind);
; 1568 : 
; 1569 :     if (!compiler_decorators(c, decos))

  00021	49 8b d4	 mov	 rdx, r12
  00024	48 8b f1	 mov	 rsi, rcx
  00027	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0002e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR kw_default_count$1$[rsp], 0
  00036	e8 00 00 00 00	 call	 compiler_decorators
  0003b	85 c0		 test	 eax, eax
  0003d	75 13		 jne	 SHORT $LN30@compiler_f@3

; 1629 : }

  0003f	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	41 5f		 pop	 r15
  0004a	41 5e		 pop	 r14
  0004c	41 5d		 pop	 r13
  0004e	41 5c		 pop	 r12
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN30@compiler_f@3:

; 1570 :         return 0;
; 1571 :     if (args->kwonlyargs) {

  00052	49 8b 55 18	 mov	 rdx, QWORD PTR [r13+24]
  00056	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0005b	48 85 d2	 test	 rdx, rdx
  0005e	74 1b		 je	 SHORT $LN28@compiler_f@3

; 1572 :         int res = compiler_visit_kwonlydefaults(c, args->kwonlyargs,
; 1573 :                                                 args->kw_defaults);

  00060	4d 8b 45 38	 mov	 r8, QWORD PTR [r13+56]
  00064	48 8b ce	 mov	 rcx, rsi
  00067	e8 00 00 00 00	 call	 compiler_visit_kwonlydefaults
  0006c	89 44 24 68	 mov	 DWORD PTR kw_default_count$1$[rsp], eax

; 1574 :         if (res < 0)

  00070	85 c0		 test	 eax, eax
  00072	79 07		 jns	 SHORT $LN28@compiler_f@3

; 1575 :             return 0;

  00074	33 c0		 xor	 eax, eax
  00076	e9 c5 02 00 00	 jmp	 $LN75@compiler_f@3
$LN28@compiler_f@3:
  0007b	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp

; 1576 :         kw_default_count = res;
; 1577 :     }
; 1578 :     if (args->defaults)

  00080	49 8b 6d 30	 mov	 rbp, QWORD PTR [r13+48]
  00084	48 85 ed	 test	 rbp, rbp
  00087	74 3e		 je	 SHORT $LN24@compiler_f@3

; 1579 :         VISIT_SEQ(c, expr, args->defaults);

  00089	33 db		 xor	 ebx, ebx
  0008b	48 8d 7d 08	 lea	 rdi, QWORD PTR [rbp+8]
  0008f	90		 npad	 1
$LL26@compiler_f@3:
  00090	48 85 ed	 test	 rbp, rbp
  00093	75 04		 jne	 SHORT $LN33@compiler_f@3
  00095	33 c9		 xor	 ecx, ecx
  00097	eb 04		 jmp	 SHORT $LN34@compiler_f@3
$LN33@compiler_f@3:
  00099	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN34@compiler_f@3:
  0009d	48 63 c3	 movsxd	 rax, ebx
  000a0	48 3b c1	 cmp	 rax, rcx
  000a3	7d 1b		 jge	 SHORT $LN74@compiler_f@3
  000a5	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000a8	48 8b ce	 mov	 rcx, rsi
  000ab	e8 00 00 00 00	 call	 compiler_visit_expr
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 81 02 00
	00		 je	 $LN7@compiler_f@3
  000b8	ff c3		 inc	 ebx
  000ba	48 83 c7 08	 add	 rdi, 8
  000be	eb d0		 jmp	 SHORT $LL26@compiler_f@3
$LN74@compiler_f@3:
  000c0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
$LN24@compiler_f@3:

; 1580 :     num_annotations = compiler_visit_annotations(c, args, returns);

  000c7	4d 8b c7	 mov	 r8, r15
  000ca	49 8b d5	 mov	 rdx, r13
  000cd	48 8b ce	 mov	 rcx, rsi
  000d0	e8 00 00 00 00	 call	 compiler_visit_annotations
  000d5	8b e8		 mov	 ebp, eax

; 1581 :     if (num_annotations < 0)

  000d7	85 c0		 test	 eax, eax

; 1582 :         return 0;

  000d9	0f 88 5a 02 00
	00		 js	 $LN7@compiler_f@3

; 1583 :     assert((num_annotations & 0xFFFF) == num_annotations);
; 1584 : 
; 1585 :     if (!compiler_enter_scope(c, s->v.FunctionDef.name,
; 1586 :                               COMPILER_SCOPE_FUNCTION, (void *)s,
; 1587 :                               s->lineno))

  000df	41 8b 46 40	 mov	 eax, DWORD PTR [r14+64]
  000e3	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  000e7	4d 8b ce	 mov	 r9, r14
  000ea	41 b8 02 00 00
	00		 mov	 r8d, 2
  000f0	48 8b ce	 mov	 rcx, rsi
  000f3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f7	e8 00 00 00 00	 call	 compiler_enter_scope
  000fc	85 c0		 test	 eax, eax

; 1588 :         return 0;

  000fe	0f 84 35 02 00
	00		 je	 $LN7@compiler_f@3

; 1589 : 
; 1590 :     st = (stmt_ty)asdl_seq_GET(s->v.FunctionDef.body, 0);

  00104	49 8b 46 18	 mov	 rax, QWORD PTR [r14+24]
  00108	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]

; 1591 :     docstring = compiler_isdocstring(st);

  0010c	48 8b ca	 mov	 rcx, rdx
  0010f	e8 00 00 00 00	 call	 compiler_isdocstring
  00114	48 63 d8	 movsxd	 rbx, eax

; 1592 :     if (docstring && c->c_optimize < 2)

  00117	85 c0		 test	 eax, eax
  00119	74 0e		 je	 SHORT $LN20@compiler_f@3
  0011b	83 7e 28 02	 cmp	 DWORD PTR [rsi+40], 2
  0011f	7d 08		 jge	 SHORT $LN20@compiler_f@3

; 1593 :         first_const = st->v.Expr.value->v.Str.s;

  00121	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00125	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
$LN20@compiler_f@3:

; 1594 :     if (compiler_add_o(c, c->u->u_consts, first_const) < 0)      {

  00129	48 8b 4e 38	 mov	 rcx, QWORD PTR [rsi+56]
  0012d	48 8b d7	 mov	 rdx, rdi
  00130	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00134	e8 00 00 00 00	 call	 compiler_add_o
  00139	85 c0		 test	 eax, eax
  0013b	79 0d		 jns	 SHORT $LN19@compiler_f@3
$LN71@compiler_f@3:

; 1595 :         compiler_exit_scope(c);

  0013d	48 8b ce	 mov	 rcx, rsi
  00140	e8 00 00 00 00	 call	 compiler_exit_scope

; 1596 :         return 0;

  00145	e9 ef 01 00 00	 jmp	 $LN7@compiler_f@3
$LN19@compiler_f@3:

; 1597 :     }
; 1598 : 
; 1599 :     c->u->u_argcount = asdl_seq_LEN(args->args);

  0014a	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  0014e	48 85 c0	 test	 rax, rax
  00151	75 04		 jne	 SHORT $LN35@compiler_f@3
  00153	33 c9		 xor	 ecx, ecx
  00155	eb 03		 jmp	 SHORT $LN36@compiler_f@3
$LN35@compiler_f@3:
  00157	48 8b 08	 mov	 rcx, QWORD PTR [rax]
$LN36@compiler_f@3:
  0015a	48 8b 46 38	 mov	 rax, QWORD PTR [rsi+56]
  0015e	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1600 :     c->u->u_kwonlyargcount = asdl_seq_LEN(args->kwonlyargs);

  00161	49 8b 4d 18	 mov	 rcx, QWORD PTR [r13+24]
  00165	48 85 c9	 test	 rcx, rcx
  00168	74 03		 je	 SHORT $LN38@compiler_f@3
$LN37@compiler_f@3:
  0016a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN38@compiler_f@3:
  0016d	48 8b 46 38	 mov	 rax, QWORD PTR [rsi+56]
  00171	89 48 54	 mov	 DWORD PTR [rax+84], ecx

; 1601 :     n = asdl_seq_LEN(s->v.FunctionDef.body);

  00174	49 8b 46 18	 mov	 rax, QWORD PTR [r14+24]
  00178	48 85 c0	 test	 rax, rax
  0017b	74 02		 je	 SHORT $LN40@compiler_f@3
$LN39@compiler_f@3:
  0017d	8b 00		 mov	 eax, DWORD PTR [rax]
$LN40@compiler_f@3:

; 1602 :     /* if there was a docstring, we need to skip the first statement */
; 1603 :     for (i = docstring; i < n; i++) {

  0017f	48 63 f8	 movsxd	 rdi, eax
  00182	48 3b df	 cmp	 rbx, rdi
  00185	7d 26		 jge	 SHORT $LN16@compiler_f@3
  00187	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@compiler_f@3:

; 1604 :         st = (stmt_ty)asdl_seq_GET(s->v.FunctionDef.body, i);

  00190	49 8b 46 18	 mov	 rax, QWORD PTR [r14+24]

; 1605 :         VISIT_IN_SCOPE(c, stmt, st);

  00194	48 8b ce	 mov	 rcx, rsi
  00197	48 8b 54 d8 08	 mov	 rdx, QWORD PTR [rax+rbx*8+8]
  0019c	e8 00 00 00 00	 call	 compiler_visit_stmt
  001a1	85 c0		 test	 eax, eax
  001a3	74 98		 je	 SHORT $LN71@compiler_f@3

; 1602 :     /* if there was a docstring, we need to skip the first statement */
; 1603 :     for (i = docstring; i < n; i++) {

  001a5	48 ff c3	 inc	 rbx
  001a8	48 3b df	 cmp	 rbx, rdi
  001ab	7c e3		 jl	 SHORT $LL18@compiler_f@3
$LN16@compiler_f@3:

; 1606 :     }
; 1607 :     co = assemble(c, 1);

  001ad	ba 01 00 00 00	 mov	 edx, 1
  001b2	48 8b ce	 mov	 rcx, rsi
  001b5	e8 00 00 00 00	 call	 assemble

; 1608 :     qualname = compiler_scope_qualname(c);

  001ba	48 8b ce	 mov	 rcx, rsi
  001bd	48 8b d8	 mov	 rbx, rax
  001c0	e8 00 00 00 00	 call	 compiler_scope_qualname

; 1609 :     compiler_exit_scope(c);

  001c5	48 8b ce	 mov	 rcx, rsi
  001c8	48 8b f8	 mov	 rdi, rax
  001cb	e8 00 00 00 00	 call	 compiler_exit_scope

; 1610 :     if (qualname == NULL || co == NULL) {

  001d0	48 85 ff	 test	 rdi, rdi
  001d3	0f 84 f6 00 00
	00		 je	 $LN11@compiler_f@3
  001d9	48 85 db	 test	 rbx, rbx
  001dc	0f 84 86 00 00
	00		 je	 $LN12@compiler_f@3

; 1614 :     }
; 1615 : 
; 1616 :     arglength = asdl_seq_LEN(args->defaults);

  001e2	49 8b 45 30	 mov	 rax, QWORD PTR [r13+48]
  001e6	48 85 c0	 test	 rax, rax
  001e9	74 02		 je	 SHORT $LN42@compiler_f@3
$LN41@compiler_f@3:
  001eb	8b 00		 mov	 eax, DWORD PTR [rax]
$LN42@compiler_f@3:

; 1617 :     arglength |= kw_default_count << 8;
; 1618 :     arglength |= num_annotations << 16;
; 1619 :     compiler_make_closure(c, co, arglength, qualname);

  001ed	c1 e5 08	 shl	 ebp, 8
  001f0	4c 8b cf	 mov	 r9, rdi
  001f3	48 8b d3	 mov	 rdx, rbx
  001f6	0b 6c 24 68	 or	 ebp, DWORD PTR kw_default_count$1$[rsp]
  001fa	48 8b ce	 mov	 rcx, rsi
  001fd	c1 e5 08	 shl	 ebp, 8
  00200	0b e8		 or	 ebp, eax
  00202	44 8b c5	 mov	 r8d, ebp
  00205	e8 00 00 00 00	 call	 compiler_make_closure

; 1620 :     Py_DECREF(qualname);

  0020a	48 8b cf	 mov	 rcx, rdi
  0020d	e8 00 00 00 00	 call	 _Py_DecRef

; 1621 :     Py_DECREF(co);

  00212	48 8b cb	 mov	 rcx, rbx
  00215	e8 00 00 00 00	 call	 _Py_DecRef

; 1622 : 
; 1623 :     /* decorators */
; 1624 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0021a	33 db		 xor	 ebx, ebx
  0021c	0f 1f 40 00	 npad	 4
$LL4@compiler_f@3:
  00220	4d 85 e4	 test	 r12, r12
  00223	75 04		 jne	 SHORT $LN43@compiler_f@3
  00225	33 c9		 xor	 ecx, ecx
  00227	eb 04		 jmp	 SHORT $LN44@compiler_f@3
$LN43@compiler_f@3:
  00229	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
$LN44@compiler_f@3:
  0022d	48 63 c3	 movsxd	 rax, ebx
  00230	48 3b c1	 cmp	 rax, rcx

; 1625 :         ADDOP_I(c, CALL_FUNCTION, 1);

  00233	48 8b ce	 mov	 rcx, rsi
  00236	7d 1c		 jge	 SHORT $LN2@compiler_f@3
  00238	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  0023d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00243	e8 00 00 00 00	 call	 compiler_addop_i
  00248	85 c0		 test	 eax, eax
  0024a	0f 84 e9 00 00
	00		 je	 $LN7@compiler_f@3

; 1622 : 
; 1623 :     /* decorators */
; 1624 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  00250	ff c3		 inc	 ebx
  00252	eb cc		 jmp	 SHORT $LL4@compiler_f@3
$LN2@compiler_f@3:

; 1626 :     }
; 1627 : 
; 1628 :     return compiler_nameop(c, s->v.FunctionDef.name, Store);

  00254	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00258	41 b8 02 00 00
	00		 mov	 r8d, 2
  0025e	e8 00 00 00 00	 call	 compiler_nameop
  00263	e9 d3 00 00 00	 jmp	 $LN76@compiler_f@3
$LN12@compiler_f@3:

; 1611 :         Py_XDECREF(qualname);

  00268	e8 00 00 00 00	 call	 _Py_PXCTX
  0026d	85 c0		 test	 eax, eax
  0026f	0f 85 c4 00 00
	00		 jne	 $LN7@compiler_f@3
  00275	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00279	a8 20		 test	 al, 32			; 00000020H
  0027b	75 4d		 jne	 SHORT $LN49@compiler_f@3
  0027d	84 c0		 test	 al, al
  0027f	78 49		 js	 SHORT $LN49@compiler_f@3
  00281	a8 02		 test	 al, 2
  00283	0f 85 b0 00 00
	00		 jne	 $LN7@compiler_f@3
  00289	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0028d	0f 85 a6 00 00
	00		 jne	 $LN7@compiler_f@3
  00293	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002a1	4c 8b cf	 mov	 r9, rdi
  002a4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002aa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002b2	e8 00 00 00 00	 call	 _PyParallel_Guard
  002b7	48 8b cf	 mov	 rcx, rdi
  002ba	85 c0		 test	 eax, eax
  002bc	75 60		 jne	 SHORT $LN78@compiler_f@3
  002be	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  002c2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002c8	eb 6f		 jmp	 SHORT $LN7@compiler_f@3
$LN49@compiler_f@3:
  002ca	48 8b cf	 mov	 rcx, rdi

; 1612 :         Py_XDECREF(co);

  002cd	eb 65		 jmp	 SHORT $LN77@compiler_f@3
$LN11@compiler_f@3:
  002cf	48 85 db	 test	 rbx, rbx
  002d2	74 65		 je	 SHORT $LN7@compiler_f@3
  002d4	e8 00 00 00 00	 call	 _Py_PXCTX
  002d9	85 c0		 test	 eax, eax
  002db	75 5c		 jne	 SHORT $LN7@compiler_f@3
  002dd	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002e1	a8 20		 test	 al, 32			; 00000020H
  002e3	75 4c		 jne	 SHORT $LN60@compiler_f@3
  002e5	84 c0		 test	 al, al
  002e7	78 48		 js	 SHORT $LN60@compiler_f@3
  002e9	a8 02		 test	 al, 2
  002eb	75 4c		 jne	 SHORT $LN7@compiler_f@3
  002ed	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002f1	75 46		 jne	 SHORT $LN7@compiler_f@3
  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00301	4c 8b cb	 mov	 r9, rbx
  00304	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0030a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00312	e8 00 00 00 00	 call	 _PyParallel_Guard
  00317	48 8b cb	 mov	 rcx, rbx
  0031a	85 c0		 test	 eax, eax
  0031c	74 07		 je	 SHORT $LN65@compiler_f@3
$LN78@compiler_f@3:
  0031e	e8 00 00 00 00	 call	 _Px_Dealloc
  00323	eb 14		 jmp	 SHORT $LN7@compiler_f@3
$LN65@compiler_f@3:
  00325	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00329	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0032f	eb 08		 jmp	 SHORT $LN7@compiler_f@3
$LN60@compiler_f@3:
  00331	48 8b cb	 mov	 rcx, rbx
$LN77@compiler_f@3:
  00334	e8 00 00 00 00	 call	 Px_DecRef
$LN7@compiler_f@3:

; 1613 :         return 0;

  00339	33 c0		 xor	 eax, eax
$LN76@compiler_f@3:
  0033b	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
$LN75@compiler_f@3:
  00340	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 1629 : }

  00345	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0034a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0034e	41 5f		 pop	 r15
  00350	41 5e		 pop	 r14
  00352	41 5d		 pop	 r13
  00354	41 5c		 pop	 r12
  00356	5f		 pop	 rdi
  00357	c3		 ret	 0
compiler_function ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	??_C@_0N@FMLGAKCE@__qualname__?$AA@		; `string'
PUBLIC	??_C@_0L@LNCJCPDP@__module__?$AA@		; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$compiler_class DD imagerel compiler_class
	DD	imagerel compiler_class+92
	DD	imagerel $unwind$compiler_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_class DD imagerel compiler_class+92
	DD	imagerel compiler_class+530
	DD	imagerel $chain$0$compiler_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_class DD imagerel compiler_class+530
	DD	imagerel compiler_class+601
	DD	imagerel $chain$1$compiler_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_class DD imagerel compiler_class+601
	DD	imagerel compiler_class+623
	DD	imagerel $chain$2$compiler_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$compiler_class DD imagerel compiler_class+623
	DD	imagerel compiler_class+912
	DD	imagerel $chain$4$compiler_class
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$compiler_class DD imagerel compiler_class+912
	DD	imagerel compiler_class+932
	DD	imagerel $chain$5$compiler_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$compiler_class DD 020021H
	DD	097400H
	DD	imagerel compiler_class
	DD	imagerel compiler_class+92
	DD	imagerel $unwind$compiler_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$compiler_class DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel compiler_class
	DD	imagerel compiler_class+92
	DD	imagerel $unwind$compiler_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_class DD 021H
	DD	imagerel compiler_class+92
	DD	imagerel compiler_class+530
	DD	imagerel $chain$0$compiler_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_class DD 020521H
	DD	086405H
	DD	imagerel compiler_class+92
	DD	imagerel compiler_class+530
	DD	imagerel $chain$0$compiler_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_class DD 020521H
	DD	097405H
	DD	imagerel compiler_class
	DD	imagerel compiler_class+92
	DD	imagerel $unwind$compiler_class
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_class DD 061001H
	DD	0b5410H
	DD	0a3410H
	DD	0c00c5210H
xdata	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMLGAKCE@__qualname__?$AA@
CONST	SEGMENT
??_C@_0N@FMLGAKCE@__qualname__?$AA@ DB '__qualname__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LNCJCPDP@__module__?$AA@
CONST	SEGMENT
??_C@_0L@LNCJCPDP@__module__?$AA@ DB '__module__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\compile.c
CONST	ENDS
;	COMDAT compiler_class
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_class PROC					; COMDAT

; 1633 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1634 :     PyCodeObject *co;
; 1635 :     PyObject *str;
; 1636 :     int i;
; 1637 :     asdl_seq* decos = s->v.ClassDef.decorator_list;

  00010	48 8b 6a 38	 mov	 rbp, QWORD PTR [rdx+56]
  00014	4c 8b e2	 mov	 r12, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 1638 : 
; 1639 :     if (!compiler_decorators(c, decos))

  0001a	48 8b d5	 mov	 rdx, rbp
  0001d	e8 00 00 00 00	 call	 compiler_decorators
  00022	85 c0		 test	 eax, eax
  00024	75 13		 jne	 SHORT $LN44@compiler_c@7
$LN60@compiler_c@7:

; 1640 :         return 0;

  00026	33 c0		 xor	 eax, eax

; 1760 : }

  00028	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0002d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	41 5c		 pop	 r12
  00038	c3		 ret	 0
$LN44@compiler_c@7:

; 1641 : 
; 1642 :     /* ultimately generate code for:
; 1643 :          <name> = __build_class__(<func>, <name>, *<bases>, **<keywords>)
; 1644 :        where:
; 1645 :          <func> is a function/closure created from the class body;
; 1646 :             it has a single argument (__locals__) where the dict
; 1647 :             (or MutableSequence) representing the locals is passed
; 1648 :          <name> is the class name
; 1649 :          <bases> is the positional arguments and *varargs argument
; 1650 :          <keywords> is the keyword arguments and **kwds argument
; 1651 :        This borrows from compiler_call.
; 1652 :     */
; 1653 : 
; 1654 :     /* 1. compile the class body into a code object */
; 1655 :     if (!compiler_enter_scope(c, s->v.ClassDef.name,
; 1656 :                               COMPILER_SCOPE_CLASS, (void *)s, s->lineno))

  00039	41 8b 44 24 40	 mov	 eax, DWORD PTR [r12+64]
  0003e	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  00043	4d 8b cc	 mov	 r9, r12
  00046	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00053	e8 00 00 00 00	 call	 compiler_enter_scope
  00058	85 c0		 test	 eax, eax

; 1657 :         return 0;

  0005a	74 ca		 je	 SHORT $LN60@compiler_c@7

; 1658 :     /* this block represents what we do in the new scope */
; 1659 :     {
; 1660 :         /* use the class name for name mangling */
; 1661 :         Py_INCREF(s->v.ClassDef.name);

  0005c	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00061	49 8b 7c 24 08	 mov	 rdi, QWORD PTR [r12+8]
  00066	e8 00 00 00 00	 call	 _Py_PXCTX
  0006b	85 c0		 test	 eax, eax
  0006d	75 32		 jne	 SHORT $LN42@compiler_c@7
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007d	4c 8b cf	 mov	 r9, rdi
  00080	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00086	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	85 c0		 test	 eax, eax
  00095	75 06		 jne	 SHORT $LN49@compiler_c@7
  00097	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0009b	74 04		 je	 SHORT $LN42@compiler_c@7
$LN49@compiler_c@7:
  0009d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN42@compiler_c@7:

; 1662 :         Py_XDECREF(c->u->u_private);

  000a1	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000a5	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000a9	48 85 c9	 test	 rcx, rcx
  000ac	74 05		 je	 SHORT $LN41@compiler_c@7
  000ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN41@compiler_c@7:

; 1663 :         c->u->u_private = s->v.ClassDef.name;

  000b3	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b7	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]

; 1664 :         /* force it to have one mandatory argument */
; 1665 :         c->u->u_argcount = 1;
; 1666 :         /* load the first argument (__locals__) ... */
; 1667 :         ADDOP_I(c, LOAD_FAST, 0);

  000bc	45 33 c0	 xor	 r8d, r8d
  000bf	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
  000c3	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000c7	41 8d 50 7c	 lea	 edx, QWORD PTR [r8+124]
  000cb	48 8b cb	 mov	 rcx, rbx
  000ce	c7 40 50 01 00
	00 00		 mov	 DWORD PTR [rax+80], 1
  000d5	e8 00 00 00 00	 call	 compiler_addop_i
  000da	85 c0		 test	 eax, eax
  000dc	0f 84 bb 02 00
	00		 je	 $LN58@compiler_c@7

; 1668 :         /* ... and store it into f_locals */
; 1669 :         ADDOP_IN_SCOPE(c, STORE_LOCALS);

  000e2	ba 45 00 00 00	 mov	 edx, 69			; 00000045H
  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 compiler_addop
  000ef	85 c0		 test	 eax, eax
  000f1	0f 84 9e 02 00
	00		 je	 $LN33@compiler_c@7

; 1670 :         /* load (global) __name__ ... */
; 1671 :         str = PyUnicode_InternFromString("__name__");

  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08BHKDPDAA@__name__?$AA@
  000fe	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00103	48 8b f8	 mov	 rdi, rax

; 1672 :         if (!str || !compiler_nameop(c, str, Load)) {

  00106	48 85 c0	 test	 rax, rax
  00109	0f 84 86 02 00
	00		 je	 $LN33@compiler_c@7
  0010f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00115	48 8b d0	 mov	 rdx, rax
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	e8 00 00 00 00	 call	 compiler_nameop

; 1676 :         }
; 1677 :         Py_DECREF(str);

  00120	48 8b cf	 mov	 rcx, rdi
  00123	85 c0		 test	 eax, eax
  00125	0f 84 65 02 00
	00		 je	 $LN34@compiler_c@7
  0012b	e8 00 00 00 00	 call	 _Py_DecRef

; 1678 :         /* ... and store it as __module__ */
; 1679 :         str = PyUnicode_InternFromString("__module__");

  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LNCJCPDP@__module__?$AA@
  00137	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0013c	48 8b f8	 mov	 rdi, rax

; 1680 :         if (!str || !compiler_nameop(c, str, Store)) {

  0013f	48 85 c0	 test	 rax, rax
  00142	0f 84 4d 02 00
	00		 je	 $LN33@compiler_c@7
  00148	41 b8 02 00 00
	00		 mov	 r8d, 2
  0014e	48 8b d0	 mov	 rdx, rax
  00151	48 8b cb	 mov	 rcx, rbx
  00154	e8 00 00 00 00	 call	 compiler_nameop

; 1681 :             Py_XDECREF(str);
; 1682 :             compiler_exit_scope(c);
; 1683 :             return 0;
; 1684 :         }
; 1685 :         Py_DECREF(str);

  00159	48 8b cf	 mov	 rcx, rdi
  0015c	85 c0		 test	 eax, eax
  0015e	0f 84 2c 02 00
	00		 je	 $LN34@compiler_c@7
  00164	e8 00 00 00 00	 call	 _Py_DecRef

; 1686 :         /* store the __qualname__ */
; 1687 :         str = compiler_scope_qualname(c);

  00169	48 8b cb	 mov	 rcx, rbx
  0016c	e8 00 00 00 00	 call	 compiler_scope_qualname

; 1688 :         if (!str) {
; 1689 :             compiler_exit_scope(c);

  00171	48 8b cb	 mov	 rcx, rbx
  00174	48 8b f8	 mov	 rdi, rax
  00177	48 85 c0	 test	 rax, rax

; 1690 :             return 0;

  0017a	0f 84 18 02 00
	00		 je	 $LN59@compiler_c@7

; 1691 :         }
; 1692 :         ADDOP_O(c, LOAD_CONST, str, consts);

  00180	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00184	4c 8b c8	 mov	 r9, rax
  00187	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0018c	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00190	e8 00 00 00 00	 call	 compiler_addop_o
  00195	85 c0		 test	 eax, eax
  00197	0f 84 00 02 00
	00		 je	 $LN58@compiler_c@7

; 1693 :         Py_DECREF(str);

  0019d	48 8b cf	 mov	 rcx, rdi
  001a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1694 :         str = PyUnicode_InternFromString("__qualname__");

  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FMLGAKCE@__qualname__?$AA@
  001ac	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  001b1	48 8b f8	 mov	 rdi, rax

; 1695 :         if (!str || !compiler_nameop(c, str, Store)) {

  001b4	48 85 c0	 test	 rax, rax
  001b7	0f 84 d8 01 00
	00		 je	 $LN33@compiler_c@7
  001bd	41 b8 02 00 00
	00		 mov	 r8d, 2
  001c3	48 8b d0	 mov	 rdx, rax
  001c6	48 8b cb	 mov	 rcx, rbx
  001c9	e8 00 00 00 00	 call	 compiler_nameop

; 1696 :             Py_XDECREF(str);
; 1697 :             compiler_exit_scope(c);
; 1698 :             return 0;
; 1699 :         }
; 1700 :         Py_DECREF(str);

  001ce	48 8b cf	 mov	 rcx, rdi
  001d1	85 c0		 test	 eax, eax
  001d3	0f 84 b7 01 00
	00		 je	 $LN34@compiler_c@7
  001d9	e8 00 00 00 00	 call	 _Py_DecRef

; 1701 :         /* compile the body proper */
; 1702 :         if (!compiler_body(c, s->v.ClassDef.body)) {

  001de	49 8b 54 24 30	 mov	 rdx, QWORD PTR [r12+48]
  001e3	48 8b cb	 mov	 rcx, rbx
  001e6	e8 00 00 00 00	 call	 compiler_body
  001eb	85 c0		 test	 eax, eax

; 1703 :             compiler_exit_scope(c);
; 1704 :             return 0;

  001ed	0f 84 a2 01 00
	00		 je	 $LN33@compiler_c@7

; 1705 :         }
; 1706 :         /* return the (empty) __class__ cell */
; 1707 :         str = PyUnicode_InternFromString("__class__");

  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09LFGACEKG@__class__?$AA@
  001fa	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  001ff	48 8b f8	 mov	 rdi, rax

; 1708 :         if (str == NULL) {

  00202	48 85 c0	 test	 rax, rax

; 1709 :             compiler_exit_scope(c);
; 1710 :             return 0;

  00205	0f 84 8a 01 00
	00		 je	 $LN33@compiler_c@7

; 1711 :         }
; 1712 :         i = compiler_lookup_arg(c->u->u_cellvars, str);

  0020b	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0020f	48 8b d0	 mov	 rdx, rax
  00212	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00217	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  0021b	e8 00 00 00 00	 call	 compiler_lookup_arg

; 1713 :         Py_DECREF(str);

  00220	48 8b cf	 mov	 rcx, rdi
  00223	8b f0		 mov	 esi, eax
  00225	e8 00 00 00 00	 call	 _Py_DecRef

; 1714 :         if (i == -1) {

  0022a	83 fe ff	 cmp	 esi, -1
  0022d	75 40		 jne	 SHORT $LN14@compiler_c@7

; 1715 :             /* This happens when nobody references the cell */
; 1716 :             PyErr_Clear();

  0022f	e8 00 00 00 00	 call	 PyErr_Clear

; 1717 :             /* Return None */
; 1718 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00234	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  00238	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0023f	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00243	8d 56 65	 lea	 edx, QWORD PTR [rsi+101]
  00246	48 8b cb	 mov	 rcx, rbx
  00249	e8 00 00 00 00	 call	 compiler_addop_o
$LN57@compiler_c@7:
  0024e	85 c0		 test	 eax, eax
  00250	75 2f		 jne	 SHORT $LN11@compiler_c@7
$LN54@compiler_c@7:
  00252	33 c0		 xor	 eax, eax
$LN56@compiler_c@7:
  00254	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
$LN55@compiler_c@7:
  00259	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1760 : }

  0025e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00263	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00268	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0026c	41 5c		 pop	 r12
  0026e	c3		 ret	 0
$LN14@compiler_c@7:

; 1719 :         }
; 1720 :         else {
; 1721 :             /* Return the cell where to store __class__ */
; 1722 :             ADDOP_I(c, LOAD_CLOSURE, i);

  0026f	44 8b c6	 mov	 r8d, esi
  00272	ba 87 00 00 00	 mov	 edx, 135		; 00000087H
  00277	48 8b cb	 mov	 rcx, rbx
  0027a	e8 00 00 00 00	 call	 compiler_addop_i
  0027f	eb cd		 jmp	 SHORT $LN57@compiler_c@7
$LN11@compiler_c@7:

; 1723 :         }
; 1724 :         ADDOP_IN_SCOPE(c, RETURN_VALUE);

  00281	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00286	48 8b cb	 mov	 rcx, rbx
  00289	e8 00 00 00 00	 call	 compiler_addop
  0028e	48 8b cb	 mov	 rcx, rbx
  00291	85 c0		 test	 eax, eax
  00293	75 07		 jne	 SHORT $LN10@compiler_c@7
  00295	e8 00 00 00 00	 call	 compiler_exit_scope
  0029a	eb b6		 jmp	 SHORT $LN54@compiler_c@7
$LN10@compiler_c@7:

; 1725 :         /* create the code object */
; 1726 :         co = assemble(c, 1);

  0029c	ba 01 00 00 00	 mov	 edx, 1
  002a1	e8 00 00 00 00	 call	 assemble

; 1727 :     }
; 1728 :     /* leave the new scope */
; 1729 :     compiler_exit_scope(c);

  002a6	48 8b cb	 mov	 rcx, rbx
  002a9	48 8b f8	 mov	 rdi, rax
  002ac	e8 00 00 00 00	 call	 compiler_exit_scope

; 1730 :     if (co == NULL)

  002b1	48 85 ff	 test	 rdi, rdi

; 1731 :         return 0;

  002b4	74 9c		 je	 SHORT $LN54@compiler_c@7

; 1732 : 
; 1733 :     /* 2. load the 'build_class' function */
; 1734 :     ADDOP(c, LOAD_BUILD_CLASS);

  002b6	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  002bb	48 8b cb	 mov	 rcx, rbx
  002be	e8 00 00 00 00	 call	 compiler_addop
  002c3	85 c0		 test	 eax, eax
  002c5	74 8b		 je	 SHORT $LN54@compiler_c@7

; 1735 : 
; 1736 :     /* 3. load a function (or closure) made from the code object */
; 1737 :     compiler_make_closure(c, co, 0, NULL);

  002c7	45 33 c9	 xor	 r9d, r9d
  002ca	45 33 c0	 xor	 r8d, r8d
  002cd	48 8b d7	 mov	 rdx, rdi
  002d0	48 8b cb	 mov	 rcx, rbx
  002d3	e8 00 00 00 00	 call	 compiler_make_closure

; 1738 :     Py_DECREF(co);

  002d8	48 8b cf	 mov	 rcx, rdi
  002db	e8 00 00 00 00	 call	 _Py_DecRef

; 1739 : 
; 1740 :     /* 4. load class name */
; 1741 :     ADDOP_O(c, LOAD_CONST, s->v.ClassDef.name, consts);

  002e0	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  002e4	4d 8b 4c 24 08	 mov	 r9, QWORD PTR [r12+8]
  002e9	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  002ed	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  002f2	48 8b cb	 mov	 rcx, rbx
  002f5	e8 00 00 00 00	 call	 compiler_addop_o
  002fa	85 c0		 test	 eax, eax
  002fc	0f 84 50 ff ff
	ff		 je	 $LN54@compiler_c@7

; 1742 : 
; 1743 :     /* 5. generate the rest of the code for the call */
; 1744 :     if (!compiler_call_helper(c, 2,
; 1745 :                               s->v.ClassDef.bases,
; 1746 :                               s->v.ClassDef.keywords,
; 1747 :                               s->v.ClassDef.starargs,
; 1748 :                               s->v.ClassDef.kwargs))

  00302	49 8b 44 24 28	 mov	 rax, QWORD PTR [r12+40]
  00307	4d 8b 4c 24 18	 mov	 r9, QWORD PTR [r12+24]
  0030c	4d 8b 44 24 10	 mov	 r8, QWORD PTR [r12+16]
  00311	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00316	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0031b	ba 02 00 00 00	 mov	 edx, 2
  00320	48 8b cb	 mov	 rcx, rbx
  00323	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00328	e8 00 00 00 00	 call	 compiler_call_helper
  0032d	85 c0		 test	 eax, eax

; 1749 :         return 0;

  0032f	0f 84 1d ff ff
	ff		 je	 $LN54@compiler_c@7

; 1750 : 
; 1751 :     /* 6. apply decorators */
; 1752 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  00335	33 f6		 xor	 esi, esi
  00337	8b fe		 mov	 edi, esi
  00339	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@compiler_c@7:
  00340	48 8b ce	 mov	 rcx, rsi
  00343	48 85 ed	 test	 rbp, rbp
  00346	74 04		 je	 SHORT $LN48@compiler_c@7
  00348	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN48@compiler_c@7:
  0034c	48 63 c7	 movsxd	 rax, edi
  0034f	48 3b c1	 cmp	 rax, rcx

; 1753 :         ADDOP_I(c, CALL_FUNCTION, 1);

  00352	48 8b cb	 mov	 rcx, rbx
  00355	7d 1c		 jge	 SHORT $LN3@compiler_c@7
  00357	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  0035c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00362	e8 00 00 00 00	 call	 compiler_addop_i
  00367	85 c0		 test	 eax, eax
  00369	0f 84 e3 fe ff
	ff		 je	 $LN54@compiler_c@7

; 1750 : 
; 1751 :     /* 6. apply decorators */
; 1752 :     for (i = 0; i < asdl_seq_LEN(decos); i++) {

  0036f	ff c7		 inc	 edi
  00371	eb cd		 jmp	 SHORT $LL5@compiler_c@7
$LN3@compiler_c@7:

; 1754 :     }
; 1755 : 
; 1756 :     /* 7. store into <name> */
; 1757 :     if (!compiler_nameop(c, s->v.ClassDef.name, Store))

  00373	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  00378	41 b8 02 00 00
	00		 mov	 r8d, 2
  0037e	e8 00 00 00 00	 call	 compiler_nameop
  00383	85 c0		 test	 eax, eax
  00385	40 0f 95 c6	 setne	 sil
  00389	8b c6		 mov	 eax, esi

; 1758 :         return 0;
; 1759 :     return 1;

  0038b	e9 c4 fe ff ff	 jmp	 $LN56@compiler_c@7
$LN34@compiler_c@7:

; 1673 :             Py_XDECREF(str);

  00390	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@compiler_c@7:

; 1674 :             compiler_exit_scope(c);

  00395	48 8b cb	 mov	 rcx, rbx
$LN59@compiler_c@7:
  00398	e8 00 00 00 00	 call	 compiler_exit_scope
$LN58@compiler_c@7:

; 1675 :             return 0;

  0039d	33 c0		 xor	 eax, eax
  0039f	e9 b5 fe ff ff	 jmp	 $LN55@compiler_c@7
compiler_class ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_if DD imagerel compiler_if
	DD	imagerel compiler_if+477
	DD	imagerel $unwind$compiler_if
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_if DD 0c4201H
	DD	0bd442H
	DD	0a743dH
	DD	096435H
	DD	083430H
	DD	0e006320aH
	DD	05002c004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_if
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_if PROC					; COMDAT

; 1843 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 56		 push	 r14
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
  0000d	4c 8b e1	 mov	 r12, rcx

; 1844 :     basicblock *end, *next;
; 1845 :     int constant;
; 1846 :     assert(s->kind == If_kind);
; 1847 :     end = compiler_new_block(c);

  00010	e8 00 00 00 00	 call	 compiler_new_block
  00015	4c 8b f0	 mov	 r14, rax

; 1848 :     if (end == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0a		 jne	 SHORT $LN29@compiler_i@6

; 1879 : }

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	41 5e		 pop	 r14
  00023	41 5c		 pop	 r12
  00025	5d		 pop	 rbp
  00026	c3		 ret	 0
$LN29@compiler_i@6:

; 1849 :         return 0;
; 1850 : 
; 1851 :     constant = expr_constant(c, s->v.If.test);

  00027	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  0002b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00030	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00035	49 8b cc	 mov	 rcx, r12
  00038	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0003d	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00042	e8 00 00 00 00	 call	 expr_constant

; 1852 :     /* constant = 0: "if 0"
; 1853 :      * constant = 1: "if 1", "if 2", ...
; 1854 :      * constant = -1: rest */
; 1855 :     if (constant == 0) {

  00047	85 c0		 test	 eax, eax
  00049	75 44		 jne	 SHORT $LN28@compiler_i@6

; 1856 :         if (s->v.If.orelse)

  0004b	48 8b 7d 18	 mov	 rdi, QWORD PTR [rbp+24]
  0004f	48 85 ff	 test	 rdi, rdi
  00052	0f 84 57 01 00
	00		 je	 $LN2@compiler_i@6

; 1857 :             VISIT_SEQ(c, stmt, s->v.If.orelse);

  00058	33 db		 xor	 ebx, ebx
  0005a	48 8d 77 08	 lea	 rsi, QWORD PTR [rdi+8]
  0005e	66 90		 npad	 2
$LL26@compiler_i@6:
  00060	48 85 ff	 test	 rdi, rdi
  00063	75 04		 jne	 SHORT $LN32@compiler_i@6
  00065	33 c9		 xor	 ecx, ecx
  00067	eb 03		 jmp	 SHORT $LN33@compiler_i@6
$LN32@compiler_i@6:
  00069	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
$LN33@compiler_i@6:
  0006c	48 63 c3	 movsxd	 rax, ebx
  0006f	48 3b c1	 cmp	 rax, rcx
  00072	0f 8d 37 01 00
	00		 jge	 $LN2@compiler_i@6
  00078	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0007b	49 8b cc	 mov	 rcx, r12
  0007e	e8 00 00 00 00	 call	 compiler_visit_stmt
  00083	85 c0		 test	 eax, eax
  00085	74 5f		 je	 SHORT $LN47@compiler_i@6
  00087	ff c3		 inc	 ebx
  00089	48 83 c6 08	 add	 rsi, 8
  0008d	eb d1		 jmp	 SHORT $LL26@compiler_i@6
$LN28@compiler_i@6:

; 1858 :     } else if (constant == 1) {

  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 3b		 jne	 SHORT $LN21@compiler_i@6

; 1859 :         VISIT_SEQ(c, stmt, s->v.If.body);

  00094	48 8b 75 10	 mov	 rsi, QWORD PTR [rbp+16]
  00098	33 db		 xor	 ebx, ebx
  0009a	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  0009e	66 90		 npad	 2
$LL20@compiler_i@6:
  000a0	48 85 f6	 test	 rsi, rsi
  000a3	75 04		 jne	 SHORT $LN34@compiler_i@6
  000a5	33 c9		 xor	 ecx, ecx
  000a7	eb 03		 jmp	 SHORT $LN35@compiler_i@6
$LN34@compiler_i@6:
  000a9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN35@compiler_i@6:
  000ac	48 63 c3	 movsxd	 rax, ebx
  000af	48 3b c1	 cmp	 rax, rcx
  000b2	0f 8d f7 00 00
	00		 jge	 $LN2@compiler_i@6
  000b8	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000bb	49 8b cc	 mov	 rcx, r12
  000be	e8 00 00 00 00	 call	 compiler_visit_stmt
  000c3	85 c0		 test	 eax, eax
  000c5	74 1f		 je	 SHORT $LN47@compiler_i@6
  000c7	ff c3		 inc	 ebx
  000c9	48 83 c7 08	 add	 rdi, 8
  000cd	eb d1		 jmp	 SHORT $LL20@compiler_i@6
$LN21@compiler_i@6:

; 1860 :     } else {
; 1861 :         if (s->v.If.orelse) {

  000cf	48 83 7d 18 00	 cmp	 QWORD PTR [rbp+24], 0
  000d4	74 17		 je	 SHORT $LN15@compiler_i@6

; 1862 :             next = compiler_new_block(c);

  000d6	49 8b cc	 mov	 rcx, r12
  000d9	e8 00 00 00 00	 call	 compiler_new_block
  000de	4c 8b e8	 mov	 r13, rax

; 1863 :             if (next == NULL)

  000e1	48 85 c0	 test	 rax, rax
  000e4	75 0a		 jne	 SHORT $LN13@compiler_i@6
$LN47@compiler_i@6:

; 1864 :                 return 0;

  000e6	33 c0		 xor	 eax, eax
  000e8	e9 d2 00 00 00	 jmp	 $LN51@compiler_i@6
$LN15@compiler_i@6:

; 1865 :         }
; 1866 :         else
; 1867 :             next = end;

  000ed	4d 8b ee	 mov	 r13, r14
$LN13@compiler_i@6:

; 1868 :         VISIT(c, expr, s->v.If.test);

  000f0	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]
  000f4	49 8b cc	 mov	 rcx, r12
  000f7	e8 00 00 00 00	 call	 compiler_visit_expr
  000fc	85 c0		 test	 eax, eax
  000fe	74 e6		 je	 SHORT $LN47@compiler_i@6

; 1869 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, next);

  00100	41 b9 01 00 00
	00		 mov	 r9d, 1
  00106	4d 8b c5	 mov	 r8, r13
  00109	49 8b cc	 mov	 rcx, r12
  0010c	41 8d 51 71	 lea	 edx, QWORD PTR [r9+113]
  00110	e8 00 00 00 00	 call	 compiler_addop_j
  00115	85 c0		 test	 eax, eax
  00117	74 cd		 je	 SHORT $LN47@compiler_i@6

; 1870 :         VISIT_SEQ(c, stmt, s->v.If.body);

  00119	48 8b 75 10	 mov	 rsi, QWORD PTR [rbp+16]
  0011d	33 db		 xor	 ebx, ebx
  0011f	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL10@compiler_i@6:
  00123	48 85 f6	 test	 rsi, rsi
  00126	75 04		 jne	 SHORT $LN36@compiler_i@6
  00128	33 c9		 xor	 ecx, ecx
  0012a	eb 03		 jmp	 SHORT $LN37@compiler_i@6
$LN36@compiler_i@6:
  0012c	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN37@compiler_i@6:
  0012f	48 63 c3	 movsxd	 rax, ebx
  00132	48 3b c1	 cmp	 rax, rcx
  00135	49 8b cc	 mov	 rcx, r12
  00138	7d 14		 jge	 SHORT $LN8@compiler_i@6
  0013a	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0013d	e8 00 00 00 00	 call	 compiler_visit_stmt
  00142	85 c0		 test	 eax, eax
  00144	74 a0		 je	 SHORT $LN47@compiler_i@6
  00146	ff c3		 inc	 ebx
  00148	48 83 c7 08	 add	 rdi, 8
  0014c	eb d5		 jmp	 SHORT $LL10@compiler_i@6
$LN8@compiler_i@6:

; 1871 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  0014e	45 33 c9	 xor	 r9d, r9d
  00151	4d 8b c6	 mov	 r8, r14
  00154	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  00158	e8 00 00 00 00	 call	 compiler_addop_j
  0015d	85 c0		 test	 eax, eax
  0015f	74 85		 je	 SHORT $LN47@compiler_i@6

; 1872 :         if (s->v.If.orelse) {

  00161	48 83 7d 18 00	 cmp	 QWORD PTR [rbp+24], 0
  00166	74 47		 je	 SHORT $LN2@compiler_i@6

; 1873 :             compiler_use_next_block(c, next);

  00168	49 8b d5	 mov	 rdx, r13
  0016b	49 8b cc	 mov	 rcx, r12
  0016e	e8 00 00 00 00	 call	 compiler_use_next_block

; 1874 :             VISIT_SEQ(c, stmt, s->v.If.orelse);

  00173	48 8b 75 18	 mov	 rsi, QWORD PTR [rbp+24]
  00177	33 db		 xor	 ebx, ebx
  00179	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  0017d	0f 1f 00	 npad	 3
$LL4@compiler_i@6:
  00180	48 85 f6	 test	 rsi, rsi
  00183	75 04		 jne	 SHORT $LN38@compiler_i@6
  00185	33 c9		 xor	 ecx, ecx
  00187	eb 03		 jmp	 SHORT $LN39@compiler_i@6
$LN38@compiler_i@6:
  00189	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN39@compiler_i@6:
  0018c	48 63 c3	 movsxd	 rax, ebx
  0018f	48 3b c1	 cmp	 rax, rcx
  00192	7d 1b		 jge	 SHORT $LN2@compiler_i@6
  00194	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00197	49 8b cc	 mov	 rcx, r12
  0019a	e8 00 00 00 00	 call	 compiler_visit_stmt
  0019f	85 c0		 test	 eax, eax
  001a1	0f 84 3f ff ff
	ff		 je	 $LN47@compiler_i@6
  001a7	ff c3		 inc	 ebx
  001a9	48 83 c7 08	 add	 rdi, 8
  001ad	eb d1		 jmp	 SHORT $LL4@compiler_i@6
$LN2@compiler_i@6:

; 1875 :         }
; 1876 :     }
; 1877 :     compiler_use_next_block(c, end);

  001af	49 8b d6	 mov	 rdx, r14
  001b2	49 8b cc	 mov	 rcx, r12
  001b5	e8 00 00 00 00	 call	 compiler_use_next_block

; 1878 :     return 1;

  001ba	b8 01 00 00 00	 mov	 eax, 1
$LN51@compiler_i@6:
  001bf	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001c4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001c9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001ce	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]

; 1879 : }

  001d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d7	41 5e		 pop	 r14
  001d9	41 5c		 pop	 r12
  001db	5d		 pop	 rbp
  001dc	c3		 ret	 0
compiler_if ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_for DD imagerel compiler_for
	DD	imagerel compiler_for+425
	DD	imagerel $unwind$compiler_for
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_for DD 0cdd01H
	DD	0c74ddH
	DD	0b64d3H
	DD	0a34ceH
	DD	0f00a320eH
	DD	0d006e008H
	DD	05002c004H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_for
_TEXT	SEGMENT
c$ = 80
s$ = 88
compiler_for PROC					; COMDAT

; 1883 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	4c 8b e2	 mov	 r12, rdx
  00011	48 8b e9	 mov	 rbp, rcx

; 1884 :     basicblock *start, *cleanup, *end;
; 1885 : 
; 1886 :     start = compiler_new_block(c);

  00014	e8 00 00 00 00	 call	 compiler_new_block

; 1887 :     cleanup = compiler_new_block(c);

  00019	48 8b cd	 mov	 rcx, rbp
  0001c	4c 8b f0	 mov	 r14, rax
  0001f	e8 00 00 00 00	 call	 compiler_new_block

; 1888 :     end = compiler_new_block(c);

  00024	48 8b cd	 mov	 rcx, rbp
  00027	4c 8b e8	 mov	 r13, rax
  0002a	e8 00 00 00 00	 call	 compiler_new_block
  0002f	4c 8b f8	 mov	 r15, rax

; 1889 :     if (start == NULL || end == NULL || cleanup == NULL)

  00032	4d 85 f6	 test	 r14, r14
  00035	74 20		 je	 SHORT $LN32@compiler_f@4
  00037	48 85 c0	 test	 rax, rax
  0003a	74 1b		 je	 SHORT $LN32@compiler_f@4
  0003c	4d 85 ed	 test	 r13, r13
  0003f	74 16		 je	 SHORT $LN32@compiler_f@4

; 1890 :         return 0;
; 1891 :     ADDOP_JREL(c, SETUP_LOOP, end);

  00041	45 33 c9	 xor	 r9d, r9d
  00044	4c 8b c0	 mov	 r8, rax
  00047	48 8b cd	 mov	 rcx, rbp
  0004a	41 8d 51 78	 lea	 edx, QWORD PTR [r9+120]
  0004e	e8 00 00 00 00	 call	 compiler_addop_j
  00053	85 c0		 test	 eax, eax
  00055	75 10		 jne	 SHORT $LN16@compiler_f@4
$LN32@compiler_f@4:
  00057	33 c0		 xor	 eax, eax

; 1907 : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	41 5f		 pop	 r15
  0005f	41 5e		 pop	 r14
  00061	41 5d		 pop	 r13
  00063	41 5c		 pop	 r12
  00065	5d		 pop	 rbp
  00066	c3		 ret	 0
$LN16@compiler_f@4:

; 1892 :     if (!compiler_push_fblock(c, LOOP, start))

  00067	4d 8b c6	 mov	 r8, r14
  0006a	33 d2		 xor	 edx, edx
  0006c	48 8b cd	 mov	 rcx, rbp
  0006f	e8 00 00 00 00	 call	 compiler_push_fblock
  00074	85 c0		 test	 eax, eax

; 1893 :         return 0;

  00076	74 df		 je	 SHORT $LN32@compiler_f@4

; 1894 :     VISIT(c, expr, s->v.For.iter);

  00078	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  0007d	48 8b cd	 mov	 rcx, rbp
  00080	e8 00 00 00 00	 call	 compiler_visit_expr
  00085	85 c0		 test	 eax, eax
  00087	74 ce		 je	 SHORT $LN32@compiler_f@4

; 1895 :     ADDOP(c, GET_ITER);

  00089	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  0008e	48 8b cd	 mov	 rcx, rbp
  00091	e8 00 00 00 00	 call	 compiler_addop
  00096	85 c0		 test	 eax, eax
  00098	74 bd		 je	 SHORT $LN32@compiler_f@4

; 1896 :     compiler_use_next_block(c, start);

  0009a	49 8b d6	 mov	 rdx, r14
  0009d	48 8b cd	 mov	 rcx, rbp
  000a0	e8 00 00 00 00	 call	 compiler_use_next_block

; 1897 :     ADDOP_JREL(c, FOR_ITER, cleanup);

  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	4d 8b c5	 mov	 r8, r13
  000ab	41 8d 51 5d	 lea	 edx, QWORD PTR [r9+93]
  000af	e8 00 00 00 00	 call	 compiler_addop_j
  000b4	85 c0		 test	 eax, eax
  000b6	74 9f		 je	 SHORT $LN32@compiler_f@4

; 1898 :     VISIT(c, expr, s->v.For.target);

  000b8	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  000bd	48 8b cd	 mov	 rcx, rbp
  000c0	e8 00 00 00 00	 call	 compiler_visit_expr
  000c5	85 c0		 test	 eax, eax
  000c7	74 8e		 je	 SHORT $LN32@compiler_f@4

; 1899 :     VISIT_SEQ(c, stmt, s->v.For.body);

  000c9	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  000ce	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  000d3	49 8b 74 24 18	 mov	 rsi, QWORD PTR [r12+24]
  000d8	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  000dd	33 db		 xor	 ebx, ebx
  000df	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL10@compiler_f@4:
  000e3	48 85 f6	 test	 rsi, rsi
  000e6	75 04		 jne	 SHORT $LN21@compiler_f@4
  000e8	33 c9		 xor	 ecx, ecx
  000ea	eb 03		 jmp	 SHORT $LN22@compiler_f@4
$LN21@compiler_f@4:
  000ec	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN22@compiler_f@4:
  000ef	48 63 c3	 movsxd	 rax, ebx
  000f2	48 3b c1	 cmp	 rax, rcx
  000f5	48 8b cd	 mov	 rcx, rbp
  000f8	7d 14		 jge	 SHORT $LN8@compiler_f@4
  000fa	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000fd	e8 00 00 00 00	 call	 compiler_visit_stmt
  00102	85 c0		 test	 eax, eax
  00104	74 75		 je	 SHORT $LN28@compiler_f@4
  00106	ff c3		 inc	 ebx
  00108	48 83 c7 08	 add	 rdi, 8
  0010c	eb d5		 jmp	 SHORT $LL10@compiler_f@4
$LN8@compiler_f@4:

; 1900 :     ADDOP_JABS(c, JUMP_ABSOLUTE, start);

  0010e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00114	4d 8b c6	 mov	 r8, r14
  00117	41 8d 51 70	 lea	 edx, QWORD PTR [r9+112]
  0011b	e8 00 00 00 00	 call	 compiler_addop_j
  00120	85 c0		 test	 eax, eax
  00122	74 57		 je	 SHORT $LN28@compiler_f@4

; 1901 :     compiler_use_next_block(c, cleanup);

  00124	49 8b d5	 mov	 rdx, r13
  00127	48 8b cd	 mov	 rcx, rbp
  0012a	e8 00 00 00 00	 call	 compiler_use_next_block

; 1902 :     ADDOP(c, POP_BLOCK);

  0012f	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00134	e8 00 00 00 00	 call	 compiler_addop
  00139	85 c0		 test	 eax, eax
  0013b	74 3e		 je	 SHORT $LN28@compiler_f@4

; 1903 :     compiler_pop_fblock(c, LOOP, start);

  0013d	48 8b cd	 mov	 rcx, rbp
  00140	e8 00 00 00 00	 call	 compiler_pop_fblock

; 1904 :     VISIT_SEQ(c, stmt, s->v.For.orelse);

  00145	49 8b 74 24 20	 mov	 rsi, QWORD PTR [r12+32]
  0014a	33 db		 xor	 ebx, ebx
  0014c	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL4@compiler_f@4:
  00150	48 85 f6	 test	 rsi, rsi
  00153	75 04		 jne	 SHORT $LN23@compiler_f@4
  00155	33 c9		 xor	 ecx, ecx
  00157	eb 03		 jmp	 SHORT $LN24@compiler_f@4
$LN23@compiler_f@4:
  00159	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN24@compiler_f@4:
  0015c	48 63 c3	 movsxd	 rax, ebx
  0015f	48 3b c1	 cmp	 rax, rcx
  00162	48 8b cd	 mov	 rcx, rbp
  00165	7d 18		 jge	 SHORT $LN2@compiler_f@4
  00167	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0016a	e8 00 00 00 00	 call	 compiler_visit_stmt
  0016f	85 c0		 test	 eax, eax
  00171	74 08		 je	 SHORT $LN28@compiler_f@4
  00173	ff c3		 inc	 ebx
  00175	48 83 c7 08	 add	 rdi, 8
  00179	eb d5		 jmp	 SHORT $LL4@compiler_f@4
$LN28@compiler_f@4:
  0017b	33 c0		 xor	 eax, eax
  0017d	eb 0d		 jmp	 SHORT $LN31@compiler_f@4
$LN2@compiler_f@4:

; 1905 :     compiler_use_next_block(c, end);

  0017f	49 8b d7	 mov	 rdx, r15
  00182	e8 00 00 00 00	 call	 compiler_use_next_block

; 1906 :     return 1;

  00187	b8 01 00 00 00	 mov	 eax, 1
$LN31@compiler_f@4:
  0018c	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00191	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00196	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 1907 : }

  0019b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019f	41 5f		 pop	 r15
  001a1	41 5e		 pop	 r14
  001a3	41 5d		 pop	 r13
  001a5	41 5c		 pop	 r12
  001a7	5d		 pop	 rbp
  001a8	c3		 ret	 0
compiler_for ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_while DD imagerel compiler_while
	DD	imagerel compiler_while+565
	DD	imagerel $unwind$compiler_while
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_while DD 0ad301H
	DD	0ce4d3H
	DD	0f00b320fH
	DD	0c007d009H
	DD	060047005H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_while
_TEXT	SEGMENT
c$ = 96
loop$1$ = 104
s$ = 104
end$1$ = 112
compiler_while PROC					; COMDAT

; 1911 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 57		 push	 r15
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	4c 8b e2	 mov	 r12, rdx

; 1912 :     basicblock *loop, *orelse, *end, *anchor = NULL;
; 1913 :     int constant = expr_constant(c, s->v.While.test);

  00012	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00016	48 8b e9	 mov	 rbp, rcx
  00019	45 33 ff	 xor	 r15d, r15d
  0001c	e8 00 00 00 00	 call	 expr_constant
  00021	44 8b e8	 mov	 r13d, eax

; 1914 : 
; 1915 :     if (constant == 0) {

  00024	85 c0		 test	 eax, eax
  00026	75 60		 jne	 SHORT $LN30@compiler_w

; 1916 :         if (s->v.While.orelse)

  00028	49 8b 74 24 18	 mov	 rsi, QWORD PTR [r12+24]
  0002d	48 85 f6	 test	 rsi, rsi
  00030	74 42		 je	 SHORT $LN26@compiler_w

; 1917 :             VISIT_SEQ(c, stmt, s->v.While.orelse);

  00032	33 db		 xor	 ebx, ebx
  00034	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL28@compiler_w:
  00038	48 85 f6	 test	 rsi, rsi
  0003b	75 04		 jne	 SHORT $LN33@compiler_w
  0003d	33 c9		 xor	 ecx, ecx
  0003f	eb 03		 jmp	 SHORT $LN34@compiler_w
$LN33@compiler_w:
  00041	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN34@compiler_w:
  00044	48 63 c3	 movsxd	 rax, ebx
  00047	48 3b c1	 cmp	 rax, rcx
  0004a	7d 28		 jge	 SHORT $LN26@compiler_w
  0004c	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0004f	48 8b cd	 mov	 rcx, rbp
  00052	e8 00 00 00 00	 call	 compiler_visit_stmt
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $LN42@compiler_w
  0005b	ff c3		 inc	 ebx
  0005d	48 83 c7 08	 add	 rdi, 8
  00061	eb d5		 jmp	 SHORT $LL28@compiler_w
$LN42@compiler_w:
  00063	33 c0		 xor	 eax, eax

; 1962 : }

  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	41 5f		 pop	 r15
  0006b	41 5d		 pop	 r13
  0006d	41 5c		 pop	 r12
  0006f	5f		 pop	 rdi
  00070	5e		 pop	 rsi
  00071	5d		 pop	 rbp
  00072	5b		 pop	 rbx
  00073	c3		 ret	 0
$LN26@compiler_w:

; 1918 :         return 1;

  00074	b8 01 00 00 00	 mov	 eax, 1

; 1962 : }

  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	41 5f		 pop	 r15
  0007f	41 5d		 pop	 r13
  00081	41 5c		 pop	 r12
  00083	5f		 pop	 rdi
  00084	5e		 pop	 rsi
  00085	5d		 pop	 rbp
  00086	5b		 pop	 rbx
  00087	c3		 ret	 0
$LN30@compiler_w:

; 1919 :     }
; 1920 :     loop = compiler_new_block(c);

  00088	48 8b cd	 mov	 rcx, rbp
  0008b	e8 00 00 00 00	 call	 compiler_new_block

; 1921 :     end = compiler_new_block(c);

  00090	48 8b cd	 mov	 rcx, rbp
  00093	48 8b d8	 mov	 rbx, rax
  00096	48 89 44 24 68	 mov	 QWORD PTR loop$1$[rsp], rax
  0009b	e8 00 00 00 00	 call	 compiler_new_block
  000a0	48 8b f8	 mov	 rdi, rax
  000a3	48 89 44 24 70	 mov	 QWORD PTR end$1$[rsp], rax

; 1922 :     if (constant == -1) {

  000a8	41 83 fd ff	 cmp	 r13d, -1
  000ac	75 10		 jne	 SHORT $LN23@compiler_w

; 1923 :         anchor = compiler_new_block(c);

  000ae	48 8b cd	 mov	 rcx, rbp
  000b1	e8 00 00 00 00	 call	 compiler_new_block
  000b6	4c 8b f8	 mov	 r15, rax

; 1924 :         if (anchor == NULL)

  000b9	48 85 c0	 test	 rax, rax

; 1925 :             return 0;

  000bc	74 a5		 je	 SHORT $LN42@compiler_w
$LN23@compiler_w:

; 1926 :     }
; 1927 :     if (loop == NULL || end == NULL)

  000be	48 85 db	 test	 rbx, rbx
  000c1	74 a0		 je	 SHORT $LN42@compiler_w
  000c3	48 85 ff	 test	 rdi, rdi
  000c6	74 9b		 je	 SHORT $LN42@compiler_w

; 1928 :         return 0;
; 1929 :     if (s->v.While.orelse) {

  000c8	49 83 7c 24 18
	00		 cmp	 QWORD PTR [r12+24], 0
  000ce	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  000d3	74 17		 je	 SHORT $LN20@compiler_w

; 1930 :         orelse = compiler_new_block(c);

  000d5	48 8b cd	 mov	 rcx, rbp
  000d8	e8 00 00 00 00	 call	 compiler_new_block
  000dd	4c 8b f0	 mov	 r14, rax

; 1931 :         if (orelse == NULL)

  000e0	48 85 c0	 test	 rax, rax
  000e3	75 0a		 jne	 SHORT $LN18@compiler_w
$LN44@compiler_w:

; 1932 :             return 0;

  000e5	33 c0		 xor	 eax, eax
  000e7	e9 35 01 00 00	 jmp	 $LN45@compiler_w
$LN20@compiler_w:

; 1933 :     }
; 1934 :     else
; 1935 :         orelse = NULL;

  000ec	45 33 f6	 xor	 r14d, r14d
$LN18@compiler_w:

; 1936 : 
; 1937 :     ADDOP_JREL(c, SETUP_LOOP, end);

  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	4c 8b c7	 mov	 r8, rdi
  000f5	48 8b cd	 mov	 rcx, rbp
  000f8	41 8d 51 78	 lea	 edx, QWORD PTR [r9+120]
  000fc	e8 00 00 00 00	 call	 compiler_addop_j
  00101	85 c0		 test	 eax, eax
  00103	74 e0		 je	 SHORT $LN44@compiler_w

; 1938 :     compiler_use_next_block(c, loop);

  00105	48 8b d3	 mov	 rdx, rbx
  00108	48 8b cd	 mov	 rcx, rbp
  0010b	e8 00 00 00 00	 call	 compiler_use_next_block

; 1939 :     if (!compiler_push_fblock(c, LOOP, loop))

  00110	4c 8b c3	 mov	 r8, rbx
  00113	33 d2		 xor	 edx, edx
  00115	e8 00 00 00 00	 call	 compiler_push_fblock
  0011a	85 c0		 test	 eax, eax

; 1940 :         return 0;

  0011c	74 c7		 je	 SHORT $LN44@compiler_w

; 1941 :     if (constant == -1) {

  0011e	41 83 fd ff	 cmp	 r13d, -1
  00122	75 28		 jne	 SHORT $LN13@compiler_w

; 1942 :         VISIT(c, expr, s->v.While.test);

  00124	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  00129	48 8b cd	 mov	 rcx, rbp
  0012c	e8 00 00 00 00	 call	 compiler_visit_expr
  00131	85 c0		 test	 eax, eax
  00133	74 b0		 je	 SHORT $LN44@compiler_w

; 1943 :         ADDOP_JABS(c, POP_JUMP_IF_FALSE, anchor);

  00135	45 8d 4d 02	 lea	 r9d, QWORD PTR [r13+2]
  00139	41 8d 55 73	 lea	 edx, QWORD PTR [r13+115]
  0013d	4d 8b c7	 mov	 r8, r15
  00140	48 8b cd	 mov	 rcx, rbp
  00143	e8 00 00 00 00	 call	 compiler_addop_j
  00148	85 c0		 test	 eax, eax
  0014a	74 99		 je	 SHORT $LN44@compiler_w
$LN13@compiler_w:

; 1944 :     }
; 1945 :     VISIT_SEQ(c, stmt, s->v.While.body);

  0014c	49 8b 74 24 10	 mov	 rsi, QWORD PTR [r12+16]
  00151	33 db		 xor	 ebx, ebx
  00153	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
$LL12@compiler_w:
  00157	48 85 f6	 test	 rsi, rsi
  0015a	75 04		 jne	 SHORT $LN35@compiler_w
  0015c	33 c9		 xor	 ecx, ecx
  0015e	eb 03		 jmp	 SHORT $LN36@compiler_w
$LN35@compiler_w:
  00160	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN36@compiler_w:
  00163	48 63 c3	 movsxd	 rax, ebx
  00166	48 3b c1	 cmp	 rax, rcx
  00169	48 8b cd	 mov	 rcx, rbp
  0016c	7d 18		 jge	 SHORT $LN10@compiler_w
  0016e	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00171	e8 00 00 00 00	 call	 compiler_visit_stmt
  00176	85 c0		 test	 eax, eax
  00178	0f 84 67 ff ff
	ff		 je	 $LN44@compiler_w
  0017e	ff c3		 inc	 ebx
  00180	48 83 c7 08	 add	 rdi, 8
  00184	eb d1		 jmp	 SHORT $LL12@compiler_w
$LN10@compiler_w:

; 1946 :     ADDOP_JABS(c, JUMP_ABSOLUTE, loop);

  00186	4c 8b 44 24 68	 mov	 r8, QWORD PTR loop$1$[rsp]
  0018b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00191	41 8d 51 70	 lea	 edx, QWORD PTR [r9+112]
  00195	e8 00 00 00 00	 call	 compiler_addop_j
  0019a	85 c0		 test	 eax, eax
  0019c	0f 84 43 ff ff
	ff		 je	 $LN44@compiler_w

; 1947 : 
; 1948 :     /* XXX should the two POP instructions be in a separate block
; 1949 :        if there is no else clause ?
; 1950 :     */
; 1951 : 
; 1952 :     if (constant == -1) {

  001a2	41 83 fd ff	 cmp	 r13d, -1
  001a6	75 1c		 jne	 SHORT $LN6@compiler_w

; 1953 :         compiler_use_next_block(c, anchor);

  001a8	49 8b d7	 mov	 rdx, r15
  001ab	48 8b cd	 mov	 rcx, rbp
  001ae	e8 00 00 00 00	 call	 compiler_use_next_block

; 1954 :         ADDOP(c, POP_BLOCK);

  001b3	41 8d 55 58	 lea	 edx, QWORD PTR [r13+88]
  001b7	e8 00 00 00 00	 call	 compiler_addop
  001bc	85 c0		 test	 eax, eax
  001be	0f 84 21 ff ff
	ff		 je	 $LN44@compiler_w
$LN6@compiler_w:

; 1955 :     }
; 1956 :     compiler_pop_fblock(c, LOOP, loop);

  001c4	48 8b cd	 mov	 rcx, rbp
  001c7	e8 00 00 00 00	 call	 compiler_pop_fblock

; 1957 :     if (orelse != NULL) /* what if orelse is just pass? */

  001cc	4d 85 f6	 test	 r14, r14
  001cf	74 3e		 je	 SHORT $LN2@compiler_w

; 1958 :         VISIT_SEQ(c, stmt, s->v.While.orelse);

  001d1	49 8b 74 24 18	 mov	 rsi, QWORD PTR [r12+24]
  001d6	33 db		 xor	 ebx, ebx
  001d8	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  001dc	0f 1f 40 00	 npad	 4
$LL4@compiler_w:
  001e0	48 85 f6	 test	 rsi, rsi
  001e3	75 04		 jne	 SHORT $LN37@compiler_w
  001e5	33 c9		 xor	 ecx, ecx
  001e7	eb 03		 jmp	 SHORT $LN38@compiler_w
$LN37@compiler_w:
  001e9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN38@compiler_w:
  001ec	48 63 c3	 movsxd	 rax, ebx
  001ef	48 3b c1	 cmp	 rax, rcx
  001f2	7d 1b		 jge	 SHORT $LN2@compiler_w
  001f4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  001f7	48 8b cd	 mov	 rcx, rbp
  001fa	e8 00 00 00 00	 call	 compiler_visit_stmt
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 de fe ff
	ff		 je	 $LN44@compiler_w
  00207	ff c3		 inc	 ebx
  00209	48 83 c7 08	 add	 rdi, 8
  0020d	eb d1		 jmp	 SHORT $LL4@compiler_w
$LN2@compiler_w:

; 1959 :     compiler_use_next_block(c, end);

  0020f	48 8b 54 24 70	 mov	 rdx, QWORD PTR end$1$[rsp]
  00214	48 8b cd	 mov	 rcx, rbp
  00217	e8 00 00 00 00	 call	 compiler_use_next_block

; 1960 : 
; 1961 :     return 1;

  0021c	b8 01 00 00 00	 mov	 eax, 1
$LN45@compiler_w:
  00221	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 1962 : }

  00226	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0022a	41 5f		 pop	 r15
  0022c	41 5d		 pop	 r13
  0022e	41 5c		 pop	 r12
  00230	5f		 pop	 rdi
  00231	5e		 pop	 rsi
  00232	5d		 pop	 rbp
  00233	5b		 pop	 rbx
  00234	c3		 ret	 0
compiler_while ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_try_except DD imagerel compiler_try_except
	DD	imagerel compiler_try_except+275
	DD	imagerel $unwind$compiler_try_except
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_try_except DD imagerel compiler_try_except+275
	DD	imagerel compiler_try_except+1394
	DD	imagerel $chain$2$compiler_try_except
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_try_except DD imagerel compiler_try_except+1394
	DD	imagerel compiler_try_except+1420
	DD	imagerel $chain$3$compiler_try_except
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_try_except DD 021H
	DD	imagerel compiler_try_except
	DD	imagerel compiler_try_except+275
	DD	imagerel $unwind$compiler_try_except
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_try_except DD 020521H
	DD	08e405H
	DD	imagerel compiler_try_except
	DD	imagerel compiler_try_except+275
	DD	imagerel $unwind$compiler_try_except
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_try_except DD 0aad01H
	DD	0964adH
	DD	01054a4H
	DD	0f00d9211H
	DD	0c009d00bH
	DD	030067007H
xdata	ENDS
;	COMDAT ??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@
CONST	SEGMENT
??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@ DB 'default'
	DB	' ''except:'' must be last', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_try_except
_TEXT	SEGMENT
end$1$ = 32
$T28047 = 40
orelse$1$ = 48
c$ = 128
s$ = 136
i$1$ = 144
n$1$ = 152
compiler_try_except PROC				; COMDAT

; 2098 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 57		 push	 r15
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00011	4c 8b fa	 mov	 r15, rdx
  00014	48 8b d9	 mov	 rbx, rcx

; 2099 :     basicblock *body, *orelse, *except, *end;
; 2100 :     int i, n;
; 2101 : 
; 2102 :     body = compiler_new_block(c);

  00017	e8 00 00 00 00	 call	 compiler_new_block

; 2103 :     except = compiler_new_block(c);

  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	48 8b f8	 mov	 rdi, rax
  00022	e8 00 00 00 00	 call	 compiler_new_block

; 2104 :     orelse = compiler_new_block(c);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	4c 8b e0	 mov	 r12, rax
  0002d	e8 00 00 00 00	 call	 compiler_new_block

; 2105 :     end = compiler_new_block(c);

  00032	48 8b cb	 mov	 rcx, rbx
  00035	4c 8b e8	 mov	 r13, rax
  00038	48 89 44 24 30	 mov	 QWORD PTR orelse$1$[rsp], rax
  0003d	e8 00 00 00 00	 call	 compiler_new_block
  00042	48 89 44 24 20	 mov	 QWORD PTR end$1$[rsp], rax

; 2106 :     if (body == NULL || except == NULL || orelse == NULL || end == NULL)

  00047	48 85 ff	 test	 rdi, rdi
  0004a	74 25		 je	 SHORT $LN105@compiler_t@2
  0004c	4d 85 e4	 test	 r12, r12
  0004f	74 20		 je	 SHORT $LN105@compiler_t@2
  00051	4d 85 ed	 test	 r13, r13
  00054	74 1b		 je	 SHORT $LN105@compiler_t@2
  00056	48 85 c0	 test	 rax, rax
  00059	74 16		 je	 SHORT $LN105@compiler_t@2

; 2107 :         return 0;
; 2108 :     ADDOP_JREL(c, SETUP_EXCEPT, except);

  0005b	45 33 c9	 xor	 r9d, r9d
  0005e	4d 8b c4	 mov	 r8, r12
  00061	48 8b cb	 mov	 rcx, rbx
  00064	41 8d 51 79	 lea	 edx, QWORD PTR [r9+121]
  00068	e8 00 00 00 00	 call	 compiler_addop_j
  0006d	85 c0		 test	 eax, eax
  0006f	75 0f		 jne	 SHORT $LN50@compiler_t@2
$LN105@compiler_t@2:
  00071	33 c0		 xor	 eax, eax

; 2210 : }

  00073	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00077	41 5f		 pop	 r15
  00079	41 5d		 pop	 r13
  0007b	41 5c		 pop	 r12
  0007d	5f		 pop	 rdi
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
$LN50@compiler_t@2:

; 2109 :     compiler_use_next_block(c, body);

  00080	48 8b d7	 mov	 rdx, rdi
  00083	48 8b cb	 mov	 rcx, rbx
  00086	e8 00 00 00 00	 call	 compiler_use_next_block

; 2110 :     if (!compiler_push_fblock(c, EXCEPT, body))

  0008b	4c 8b c7	 mov	 r8, rdi
  0008e	ba 01 00 00 00	 mov	 edx, 1
  00093	e8 00 00 00 00	 call	 compiler_push_fblock
  00098	85 c0		 test	 eax, eax

; 2111 :         return 0;

  0009a	74 d5		 je	 SHORT $LN105@compiler_t@2

; 2112 :     VISIT_SEQ(c, stmt, s->v.Try.body);

  0009c	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  000a4	49 8b 6f 08	 mov	 rbp, QWORD PTR [r15+8]
  000a8	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000ad	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
  000b1	33 ff		 xor	 edi, edi
$LL48@compiler_t@2:
  000b3	48 85 ed	 test	 rbp, rbp
  000b6	75 04		 jne	 SHORT $LN55@compiler_t@2
  000b8	33 c9		 xor	 ecx, ecx
  000ba	eb 04		 jmp	 SHORT $LN56@compiler_t@2
$LN55@compiler_t@2:
  000bc	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN56@compiler_t@2:
  000c0	48 63 c7	 movsxd	 rax, edi
  000c3	48 3b c1	 cmp	 rax, rcx
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	7d 14		 jge	 SHORT $LN46@compiler_t@2
  000cb	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000ce	e8 00 00 00 00	 call	 compiler_visit_stmt
  000d3	85 c0		 test	 eax, eax
  000d5	74 31		 je	 SHORT $LN104@compiler_t@2
  000d7	ff c7		 inc	 edi
  000d9	48 83 c6 08	 add	 rsi, 8
  000dd	eb d4		 jmp	 SHORT $LL48@compiler_t@2
$LN46@compiler_t@2:

; 2113 :     ADDOP(c, POP_BLOCK);

  000df	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  000e4	e8 00 00 00 00	 call	 compiler_addop
  000e9	85 c0		 test	 eax, eax
  000eb	74 1b		 je	 SHORT $LN104@compiler_t@2

; 2114 :     compiler_pop_fblock(c, EXCEPT, body);

  000ed	48 8b cb	 mov	 rcx, rbx
  000f0	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2115 :     ADDOP_JREL(c, JUMP_FORWARD, orelse);

  000f5	45 33 c9	 xor	 r9d, r9d
  000f8	4d 8b c5	 mov	 r8, r13
  000fb	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  000ff	e8 00 00 00 00	 call	 compiler_addop_j
  00104	85 c0		 test	 eax, eax
  00106	75 07		 jne	 SHORT $LN43@compiler_t@2
$LN104@compiler_t@2:
  00108	33 c0		 xor	 eax, eax
  0010a	e9 63 04 00 00	 jmp	 $LN101@compiler_t@2
$LN43@compiler_t@2:

; 2116 :     n = asdl_seq_LEN(s->v.Try.handlers);

  0010f	49 8b 47 10	 mov	 rax, QWORD PTR [r15+16]
  00113	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00118	48 85 c0	 test	 rax, rax
  0011b	75 05		 jne	 SHORT $LN57@compiler_t@2
  0011d	45 33 c9	 xor	 r9d, r9d
  00120	eb 03		 jmp	 SHORT $LN103@compiler_t@2
$LN57@compiler_t@2:
  00122	44 8b 08	 mov	 r9d, DWORD PTR [rax]
$LN103@compiler_t@2:

; 2117 :     compiler_use_next_block(c, except);

  00125	49 8b d4	 mov	 rdx, r12
  00128	48 8b cb	 mov	 rcx, rbx
  0012b	44 89 8c 24 98
	00 00 00	 mov	 DWORD PTR n$1$[rsp], r9d
  00133	e8 00 00 00 00	 call	 compiler_use_next_block

; 2118 :     for (i = 0; i < n; i++) {

  00138	45 33 ed	 xor	 r13d, r13d
  0013b	49 63 c1	 movsxd	 rax, r9d
  0013e	45 33 f6	 xor	 r14d, r14d
  00141	44 89 ac 24 90
	00 00 00	 mov	 DWORD PTR i$1$[rsp], r13d
  00149	48 89 44 24 28	 mov	 QWORD PTR $T28047[rsp], rax
  0014e	45 85 c9	 test	 r9d, r9d
  00151	0f 8e aa 03 00
	00		 jle	 $LN99@compiler_t@2
  00157	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL42@compiler_t@2:

; 2119 :         excepthandler_ty handler = (excepthandler_ty)asdl_seq_GET(
; 2120 :             s->v.Try.handlers, i);

  00160	49 8b 47 10	 mov	 rax, QWORD PTR [r15+16]
  00164	4e 8b 64 f0 08	 mov	 r12, QWORD PTR [rax+r14*8+8]

; 2121 :         if (!handler->v.ExceptHandler.type && i < n-1)

  00169	49 83 7c 24 08
	00		 cmp	 QWORD PTR [r12+8], 0
  0016f	75 0d		 jne	 SHORT $LN39@compiler_t@2
  00171	41 8d 41 ff	 lea	 eax, DWORD PTR [r9-1]
  00175	44 3b e8	 cmp	 r13d, eax
  00178	0f 8c 72 03 00
	00		 jl	 $LN73@compiler_t@2
$LN39@compiler_t@2:

; 2123 :         c->u->u_lineno_set = 0;

  0017e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00182	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0

; 2124 :         c->u->u_lineno = handler->lineno;

  0018c	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00190	41 8b 44 24 20	 mov	 eax, DWORD PTR [r12+32]
  00195	89 81 b4 01 00
	00		 mov	 DWORD PTR [rcx+436], eax

; 2125 :         c->u->u_col_offset = handler->col_offset;

  0019b	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0019f	41 8b 44 24 24	 mov	 eax, DWORD PTR [r12+36]
  001a4	89 81 b8 01 00
	00		 mov	 DWORD PTR [rcx+440], eax

; 2126 :         except = compiler_new_block(c);

  001aa	48 8b cb	 mov	 rcx, rbx
  001ad	e8 00 00 00 00	 call	 compiler_new_block
  001b2	4c 8b f8	 mov	 r15, rax

; 2127 :         if (except == NULL)

  001b5	48 85 c0	 test	 rax, rax
  001b8	0f 84 9e 03 00
	00		 je	 $LN96@compiler_t@2

; 2128 :             return 0;
; 2129 :         if (handler->v.ExceptHandler.type) {

  001be	49 83 7c 24 08
	00		 cmp	 QWORD PTR [r12+8], 0
  001c4	74 60		 je	 SHORT $LN33@compiler_t@2

; 2130 :             ADDOP(c, DUP_TOP);

  001c6	ba 04 00 00 00	 mov	 edx, 4
  001cb	48 8b cb	 mov	 rcx, rbx
  001ce	e8 00 00 00 00	 call	 compiler_addop
  001d3	85 c0		 test	 eax, eax
  001d5	0f 84 81 03 00
	00		 je	 $LN96@compiler_t@2

; 2131 :             VISIT(c, expr, handler->v.ExceptHandler.type);

  001db	49 8b 54 24 08	 mov	 rdx, QWORD PTR [r12+8]
  001e0	48 8b cb	 mov	 rcx, rbx
  001e3	e8 00 00 00 00	 call	 compiler_visit_expr
  001e8	85 c0		 test	 eax, eax
  001ea	0f 84 6c 03 00
	00		 je	 $LN96@compiler_t@2

; 2132 :             ADDOP_I(c, COMPARE_OP, PyCmp_EXC_MATCH);

  001f0	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  001f5	48 8b cb	 mov	 rcx, rbx
  001f8	44 8d 42 9f	 lea	 r8d, QWORD PTR [rdx-97]
  001fc	e8 00 00 00 00	 call	 compiler_addop_i
  00201	85 c0		 test	 eax, eax
  00203	0f 84 53 03 00
	00		 je	 $LN96@compiler_t@2

; 2133 :             ADDOP_JABS(c, POP_JUMP_IF_FALSE, except);

  00209	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020f	4d 8b c7	 mov	 r8, r15
  00212	48 8b cb	 mov	 rcx, rbx
  00215	41 8d 51 71	 lea	 edx, QWORD PTR [r9+113]
  00219	e8 00 00 00 00	 call	 compiler_addop_j
  0021e	85 c0		 test	 eax, eax
  00220	0f 84 36 03 00
	00		 je	 $LN96@compiler_t@2
$LN33@compiler_t@2:

; 2134 :         }
; 2135 :         ADDOP(c, POP_TOP);

  00226	ba 01 00 00 00	 mov	 edx, 1
  0022b	48 8b cb	 mov	 rcx, rbx
  0022e	e8 00 00 00 00	 call	 compiler_addop
  00233	85 c0		 test	 eax, eax
  00235	0f 84 21 03 00
	00		 je	 $LN96@compiler_t@2

; 2136 :         if (handler->v.ExceptHandler.name) {

  0023b	49 83 7c 24 10
	00		 cmp	 QWORD PTR [r12+16], 0

; 2137 :             basicblock *cleanup_end, *cleanup_body;
; 2138 : 
; 2139 :             cleanup_end = compiler_new_block(c);

  00241	48 8b cb	 mov	 rcx, rbx
  00244	0f 84 a2 01 00
	00		 je	 $LN31@compiler_t@2
  0024a	e8 00 00 00 00	 call	 compiler_new_block

; 2140 :             cleanup_body = compiler_new_block(c);

  0024f	48 8b cb	 mov	 rcx, rbx
  00252	4c 8b e8	 mov	 r13, rax
  00255	e8 00 00 00 00	 call	 compiler_new_block
  0025a	48 8b f8	 mov	 rdi, rax

; 2141 :             if (!(cleanup_end || cleanup_body))

  0025d	4d 85 ed	 test	 r13, r13
  00260	75 09		 jne	 SHORT $LN30@compiler_t@2
  00262	48 85 c0	 test	 rax, rax
  00265	0f 84 f1 02 00
	00		 je	 $LN96@compiler_t@2
$LN30@compiler_t@2:

; 2142 :                 return 0;
; 2143 : 
; 2144 :             compiler_nameop(c, handler->v.ExceptHandler.name, Store);

  0026b	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  00270	41 b8 02 00 00
	00		 mov	 r8d, 2
  00276	48 8b cb	 mov	 rcx, rbx
  00279	e8 00 00 00 00	 call	 compiler_nameop

; 2145 :             ADDOP(c, POP_TOP);

  0027e	ba 01 00 00 00	 mov	 edx, 1
  00283	48 8b cb	 mov	 rcx, rbx
  00286	e8 00 00 00 00	 call	 compiler_addop
  0028b	85 c0		 test	 eax, eax
  0028d	0f 84 c9 02 00
	00		 je	 $LN96@compiler_t@2

; 2146 : 
; 2147 :             /*
; 2148 :               try:
; 2149 :                   # body
; 2150 :               except type as name:
; 2151 :                   try:
; 2152 :                       # body
; 2153 :                   finally:
; 2154 :                       name = None
; 2155 :                       del name
; 2156 :             */
; 2157 : 
; 2158 :             /* second try: */
; 2159 :             ADDOP_JREL(c, SETUP_FINALLY, cleanup_end);

  00293	45 33 c9	 xor	 r9d, r9d
  00296	4d 8b c5	 mov	 r8, r13
  00299	48 8b cb	 mov	 rcx, rbx
  0029c	41 8d 51 7a	 lea	 edx, QWORD PTR [r9+122]
  002a0	e8 00 00 00 00	 call	 compiler_addop_j
  002a5	85 c0		 test	 eax, eax
  002a7	0f 84 af 02 00
	00		 je	 $LN96@compiler_t@2

; 2160 :             compiler_use_next_block(c, cleanup_body);

  002ad	48 8b d7	 mov	 rdx, rdi
  002b0	48 8b cb	 mov	 rcx, rbx
  002b3	e8 00 00 00 00	 call	 compiler_use_next_block

; 2161 :             if (!compiler_push_fblock(c, FINALLY_TRY, cleanup_body))

  002b8	4c 8b c7	 mov	 r8, rdi
  002bb	ba 02 00 00 00	 mov	 edx, 2
  002c0	e8 00 00 00 00	 call	 compiler_push_fblock
  002c5	85 c0		 test	 eax, eax
  002c7	0f 84 8f 02 00
	00		 je	 $LN96@compiler_t@2

; 2162 :                 return 0;
; 2163 : 
; 2164 :             /* second # body */
; 2165 :             VISIT_SEQ(c, stmt, handler->v.ExceptHandler.body);

  002cd	49 8b 6c 24 18	 mov	 rbp, QWORD PTR [r12+24]
  002d2	33 ff		 xor	 edi, edi
  002d4	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
$LL26@compiler_t@2:
  002d8	48 85 ed	 test	 rbp, rbp
  002db	75 04		 jne	 SHORT $LN59@compiler_t@2
  002dd	33 c9		 xor	 ecx, ecx
  002df	eb 04		 jmp	 SHORT $LN60@compiler_t@2
$LN59@compiler_t@2:
  002e1	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN60@compiler_t@2:
  002e5	48 63 c7	 movsxd	 rax, edi
  002e8	48 3b c1	 cmp	 rax, rcx
  002eb	48 8b cb	 mov	 rcx, rbx
  002ee	7d 18		 jge	 SHORT $LN24@compiler_t@2
  002f0	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  002f3	e8 00 00 00 00	 call	 compiler_visit_stmt
  002f8	85 c0		 test	 eax, eax
  002fa	0f 84 5c 02 00
	00		 je	 $LN96@compiler_t@2
  00300	ff c7		 inc	 edi
  00302	48 83 c6 08	 add	 rsi, 8
  00306	eb d0		 jmp	 SHORT $LL26@compiler_t@2
$LN24@compiler_t@2:

; 2166 :             ADDOP(c, POP_BLOCK);

  00308	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  0030d	e8 00 00 00 00	 call	 compiler_addop
  00312	85 c0		 test	 eax, eax
  00314	0f 84 42 02 00
	00		 je	 $LN96@compiler_t@2

; 2167 :             ADDOP(c, POP_EXCEPT);

  0031a	ba 59 00 00 00	 mov	 edx, 89			; 00000059H
  0031f	48 8b cb	 mov	 rcx, rbx
  00322	e8 00 00 00 00	 call	 compiler_addop
  00327	85 c0		 test	 eax, eax
  00329	0f 84 2d 02 00
	00		 je	 $LN96@compiler_t@2

; 2168 :             compiler_pop_fblock(c, FINALLY_TRY, cleanup_body);

  0032f	48 8b cb	 mov	 rcx, rbx
  00332	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2169 : 
; 2170 :             /* finally: */
; 2171 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00337	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0033b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00342	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00346	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0034b	e8 00 00 00 00	 call	 compiler_addop_o
  00350	85 c0		 test	 eax, eax
  00352	0f 84 04 02 00
	00		 je	 $LN96@compiler_t@2

; 2172 :             compiler_use_next_block(c, cleanup_end);

  00358	49 8b d5	 mov	 rdx, r13
  0035b	48 8b cb	 mov	 rcx, rbx
  0035e	e8 00 00 00 00	 call	 compiler_use_next_block

; 2173 :             if (!compiler_push_fblock(c, FINALLY_END, cleanup_end))

  00363	4d 8b c5	 mov	 r8, r13
  00366	ba 03 00 00 00	 mov	 edx, 3
  0036b	e8 00 00 00 00	 call	 compiler_push_fblock
  00370	85 c0		 test	 eax, eax
  00372	0f 84 e4 01 00
	00		 je	 $LN96@compiler_t@2

; 2174 :                 return 0;
; 2175 : 
; 2176 :             /* name = None */
; 2177 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  00378	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0037c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00383	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00388	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0038c	48 8b cb	 mov	 rcx, rbx
  0038f	e8 00 00 00 00	 call	 compiler_addop_o
  00394	85 c0		 test	 eax, eax
  00396	0f 84 c0 01 00
	00		 je	 $LN96@compiler_t@2

; 2178 :             compiler_nameop(c, handler->v.ExceptHandler.name, Store);

  0039c	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  003a1	41 b8 02 00 00
	00		 mov	 r8d, 2
  003a7	48 8b cb	 mov	 rcx, rbx
  003aa	e8 00 00 00 00	 call	 compiler_nameop

; 2179 : 
; 2180 :             /* del name */
; 2181 :             compiler_nameop(c, handler->v.ExceptHandler.name, Del);

  003af	49 8b 54 24 10	 mov	 rdx, QWORD PTR [r12+16]
  003b4	41 b8 03 00 00
	00		 mov	 r8d, 3
  003ba	48 8b cb	 mov	 rcx, rbx
  003bd	e8 00 00 00 00	 call	 compiler_nameop

; 2182 : 
; 2183 :             ADDOP(c, END_FINALLY);

  003c2	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  003c7	48 8b cb	 mov	 rcx, rbx
  003ca	e8 00 00 00 00	 call	 compiler_addop
  003cf	85 c0		 test	 eax, eax
  003d1	0f 84 85 01 00
	00		 je	 $LN96@compiler_t@2

; 2184 :             compiler_pop_fblock(c, FINALLY_END, cleanup_end);

  003d7	48 8b cb	 mov	 rcx, rbx
  003da	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2185 :         }
; 2186 :         else {

  003df	44 8b ac 24 90
	00 00 00	 mov	 r13d, DWORD PTR i$1$[rsp]
  003e7	e9 b0 00 00 00	 jmp	 $LN16@compiler_t@2
$LN31@compiler_t@2:

; 2187 :             basicblock *cleanup_body;
; 2188 : 
; 2189 :             cleanup_body = compiler_new_block(c);

  003ec	e8 00 00 00 00	 call	 compiler_new_block
  003f1	48 8b f8	 mov	 rdi, rax

; 2190 :             if (!cleanup_body)

  003f4	48 85 c0	 test	 rax, rax
  003f7	0f 84 5f 01 00
	00		 je	 $LN96@compiler_t@2

; 2191 :                 return 0;
; 2192 : 
; 2193 :             ADDOP(c, POP_TOP);

  003fd	ba 01 00 00 00	 mov	 edx, 1
  00402	48 8b cb	 mov	 rcx, rbx
  00405	e8 00 00 00 00	 call	 compiler_addop
  0040a	85 c0		 test	 eax, eax
  0040c	0f 84 4a 01 00
	00		 je	 $LN96@compiler_t@2

; 2194 :             ADDOP(c, POP_TOP);

  00412	ba 01 00 00 00	 mov	 edx, 1
  00417	48 8b cb	 mov	 rcx, rbx
  0041a	e8 00 00 00 00	 call	 compiler_addop
  0041f	85 c0		 test	 eax, eax
  00421	0f 84 35 01 00
	00		 je	 $LN96@compiler_t@2

; 2195 :             compiler_use_next_block(c, cleanup_body);

  00427	48 8b d7	 mov	 rdx, rdi
  0042a	48 8b cb	 mov	 rcx, rbx
  0042d	e8 00 00 00 00	 call	 compiler_use_next_block

; 2196 :             if (!compiler_push_fblock(c, FINALLY_TRY, cleanup_body))

  00432	4c 8b c7	 mov	 r8, rdi
  00435	ba 02 00 00 00	 mov	 edx, 2
  0043a	e8 00 00 00 00	 call	 compiler_push_fblock
  0043f	85 c0		 test	 eax, eax
  00441	0f 84 15 01 00
	00		 je	 $LN96@compiler_t@2

; 2197 :                 return 0;
; 2198 :             VISIT_SEQ(c, stmt, handler->v.ExceptHandler.body);

  00447	49 8b 6c 24 18	 mov	 rbp, QWORD PTR [r12+24]
  0044c	33 ff		 xor	 edi, edi
  0044e	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
$LL11@compiler_t@2:
  00452	48 85 ed	 test	 rbp, rbp
  00455	75 04		 jne	 SHORT $LN61@compiler_t@2
  00457	33 c9		 xor	 ecx, ecx
  00459	eb 04		 jmp	 SHORT $LN62@compiler_t@2
$LN61@compiler_t@2:
  0045b	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN62@compiler_t@2:
  0045f	48 63 c7	 movsxd	 rax, edi
  00462	48 3b c1	 cmp	 rax, rcx
  00465	48 8b cb	 mov	 rcx, rbx
  00468	7d 18		 jge	 SHORT $LN9@compiler_t@2
  0046a	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0046d	e8 00 00 00 00	 call	 compiler_visit_stmt
  00472	85 c0		 test	 eax, eax
  00474	0f 84 e2 00 00
	00		 je	 $LN96@compiler_t@2
  0047a	ff c7		 inc	 edi
  0047c	48 83 c6 08	 add	 rsi, 8
  00480	eb d0		 jmp	 SHORT $LL11@compiler_t@2
$LN9@compiler_t@2:

; 2199 :             ADDOP(c, POP_EXCEPT);

  00482	ba 59 00 00 00	 mov	 edx, 89			; 00000059H
  00487	e8 00 00 00 00	 call	 compiler_addop
  0048c	85 c0		 test	 eax, eax
  0048e	0f 84 c8 00 00
	00		 je	 $LN96@compiler_t@2

; 2200 :             compiler_pop_fblock(c, FINALLY_TRY, cleanup_body);

  00494	48 8b cb	 mov	 rcx, rbx
  00497	e8 00 00 00 00	 call	 compiler_pop_fblock
$LN16@compiler_t@2:

; 2201 :         }
; 2202 :         ADDOP_JREL(c, JUMP_FORWARD, end);

  0049c	4c 8b 64 24 20	 mov	 r12, QWORD PTR end$1$[rsp]
  004a1	45 33 c9	 xor	 r9d, r9d
  004a4	48 8b cb	 mov	 rcx, rbx
  004a7	41 8d 51 6e	 lea	 edx, QWORD PTR [r9+110]
  004ab	4d 8b c4	 mov	 r8, r12
  004ae	e8 00 00 00 00	 call	 compiler_addop_j
  004b3	85 c0		 test	 eax, eax
  004b5	0f 84 a1 00 00
	00		 je	 $LN96@compiler_t@2

; 2203 :         compiler_use_next_block(c, except);

  004bb	49 8b d7	 mov	 rdx, r15
  004be	48 8b cb	 mov	 rcx, rbx
  004c1	e8 00 00 00 00	 call	 compiler_use_next_block
  004c6	4c 8b bc 24 88
	00 00 00	 mov	 r15, QWORD PTR s$[rsp]
  004ce	41 ff c5	 inc	 r13d
  004d1	49 ff c6	 inc	 r14
  004d4	44 89 ac 24 90
	00 00 00	 mov	 DWORD PTR i$1$[rsp], r13d
  004dc	4c 3b 74 24 28	 cmp	 r14, QWORD PTR $T28047[rsp]
  004e1	7d 23		 jge	 SHORT $LN40@compiler_t@2

; 2118 :     for (i = 0; i < n; i++) {

  004e3	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR n$1$[rsp]
  004eb	e9 70 fc ff ff	 jmp	 $LL42@compiler_t@2
$LN73@compiler_t@2:

; 2122 :             return compiler_error(c, "default 'except:' must be last");

  004f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@BGMGGMIC@default?5?8except?3?8?5must?5be?5last?$AA@
  004f7	48 8b cb	 mov	 rcx, rbx
  004fa	e8 00 00 00 00	 call	 compiler_error
  004ff	eb 6c		 jmp	 SHORT $LN102@compiler_t@2
$LN99@compiler_t@2:

; 2104 :     orelse = compiler_new_block(c);

  00501	4c 8b 64 24 20	 mov	 r12, QWORD PTR end$1$[rsp]
$LN40@compiler_t@2:

; 2204 :     }
; 2205 :     ADDOP(c, END_FINALLY);

  00506	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  0050b	48 8b cb	 mov	 rcx, rbx
  0050e	e8 00 00 00 00	 call	 compiler_addop
  00513	85 c0		 test	 eax, eax
  00515	74 45		 je	 SHORT $LN96@compiler_t@2

; 2206 :     compiler_use_next_block(c, orelse);

  00517	48 8b 54 24 30	 mov	 rdx, QWORD PTR orelse$1$[rsp]
  0051c	48 8b cb	 mov	 rcx, rbx
  0051f	e8 00 00 00 00	 call	 compiler_use_next_block

; 2207 :     VISIT_SEQ(c, stmt, s->v.Try.orelse);

  00524	49 8b 6f 18	 mov	 rbp, QWORD PTR [r15+24]
  00528	33 ff		 xor	 edi, edi
  0052a	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
  0052e	66 90		 npad	 2
$LL4@compiler_t@2:
  00530	48 85 ed	 test	 rbp, rbp
  00533	75 04		 jne	 SHORT $LN63@compiler_t@2
  00535	33 c9		 xor	 ecx, ecx
  00537	eb 04		 jmp	 SHORT $LN64@compiler_t@2
$LN63@compiler_t@2:
  00539	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN64@compiler_t@2:
  0053d	48 63 c7	 movsxd	 rax, edi
  00540	48 3b c1	 cmp	 rax, rcx
  00543	48 8b cb	 mov	 rcx, rbx
  00546	7d 18		 jge	 SHORT $LN2@compiler_t@2
  00548	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0054b	e8 00 00 00 00	 call	 compiler_visit_stmt
  00550	85 c0		 test	 eax, eax
  00552	74 08		 je	 SHORT $LN96@compiler_t@2
  00554	ff c7		 inc	 edi
  00556	48 83 c6 08	 add	 rsi, 8
  0055a	eb d4		 jmp	 SHORT $LL4@compiler_t@2
$LN96@compiler_t@2:
  0055c	33 c0		 xor	 eax, eax
  0055e	eb 0d		 jmp	 SHORT $LN102@compiler_t@2
$LN2@compiler_t@2:

; 2208 :     compiler_use_next_block(c, end);

  00560	49 8b d4	 mov	 rdx, r12
  00563	e8 00 00 00 00	 call	 compiler_use_next_block

; 2209 :     return 1;

  00568	b8 01 00 00 00	 mov	 eax, 1
$LN102@compiler_t@2:
  0056d	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN101@compiler_t@2:
  00572	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  0057a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 2210 : }

  0057f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00583	41 5f		 pop	 r15
  00585	41 5d		 pop	 r13
  00587	41 5c		 pop	 r12
  00589	5f		 pop	 rdi
  0058a	5b		 pop	 rbx
  0058b	c3		 ret	 0
compiler_try_except ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@ ; `string'
PUBLIC	??_C@_0P@ECLAGKMP@AssertionError?$AA@		; `string'
EXTRN	PyErr_WarnExplicit:PROC
EXTRN	PyExc_SyntaxWarning:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_assert DD imagerel compiler_assert
	DD	imagerel compiler_assert+178
	DD	imagerel $unwind$compiler_assert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compiler_assert DD imagerel compiler_assert+178
	DD	imagerel compiler_assert+338
	DD	imagerel $chain$0$compiler_assert
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compiler_assert DD imagerel compiler_assert+338
	DD	imagerel compiler_assert+370
	DD	imagerel $chain$2$compiler_assert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compiler_assert DD 020021H
	DD	086400H
	DD	imagerel compiler_assert
	DD	imagerel compiler_assert+178
	DD	imagerel $unwind$compiler_assert
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compiler_assert DD 020521H
	DD	086405H
	DD	imagerel compiler_assert
	DD	imagerel compiler_assert+178
	DD	imagerel $unwind$compiler_assert
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_assert DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@
CONST	SEGMENT
??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@ DB 'assertion i'
	DB	's always true, perhaps remove parentheses?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ECLAGKMP@AssertionError?$AA@
CONST	SEGMENT
??_C@_0P@ECLAGKMP@AssertionError?$AA@ DB 'AssertionError', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_assert
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_assert PROC					; COMDAT

; 2380 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2381 :     static PyObject *assertion_error = NULL;
; 2382 :     basicblock *end;
; 2383 : 
; 2384 :     if (c->c_optimize)

  0000a	83 79 28 00	 cmp	 DWORD PTR [rcx+40], 0
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	74 10		 je	 SHORT $LN13@compiler_a@8

; 2385 :         return 1;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 2411 :     return 1;
; 2412 : }

  0001b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00020	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
$LN13@compiler_a@8:

; 2386 :     if (assertion_error == NULL) {

  00026	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?assertion_error@?1??compiler_assert@@9@9, 0
  0002e	75 25		 jne	 SHORT $LN11@compiler_a@8

; 2387 :         assertion_error = PyUnicode_InternFromString("AssertionError");

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@ECLAGKMP@AssertionError?$AA@
  00037	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  0003c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?assertion_error@?1??compiler_assert@@9@9, rax

; 2388 :         if (assertion_error == NULL)

  00043	48 85 c0	 test	 rax, rax
  00046	75 0d		 jne	 SHORT $LN11@compiler_a@8
$LN20@compiler_a@8:

; 2389 :             return 0;

  00048	33 c0		 xor	 eax, eax

; 2411 :     return 1;
; 2412 : }

  0004a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
$LN11@compiler_a@8:

; 2390 :     }
; 2391 :     if (s->v.Assert.test->kind == Tuple_kind &&
; 2392 :         asdl_seq_LEN(s->v.Assert.test->v.Tuple.elts) > 0) {

  00055	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00059	83 38 19	 cmp	 DWORD PTR [rax], 25
  0005c	75 41		 jne	 SHORT $LN9@compiler_a@8
  0005e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00062	48 85 c9	 test	 rcx, rcx
  00065	74 38		 je	 SHORT $LN9@compiler_a@8
  00067	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0006b	7e 32		 jle	 SHORT $LN9@compiler_a@8

; 2393 :         const char* msg =
; 2394 :             "assertion is always true, perhaps remove parentheses?";
; 2395 :         if (PyErr_WarnExplicit(PyExc_SyntaxWarning, msg, c->c_filename,
; 2396 :                                c->u->u_lineno, NULL, NULL) == -1)

  0006d	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00071	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00074	33 c9		 xor	 ecx, ecx
  00076	44 8b 88 b4 01
	00 00		 mov	 r9d, DWORD PTR [rax+436]
  0007d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00082	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxWarning
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@LAKOGDJB@assertion?5is?5always?5true?0?5perhap@
  00095	e8 00 00 00 00	 call	 PyErr_WarnExplicit
  0009a	83 f8 ff	 cmp	 eax, -1

; 2397 :             return 0;

  0009d	74 a9		 je	 SHORT $LN20@compiler_a@8
$LN9@compiler_a@8:

; 2398 :     }
; 2399 :     VISIT(c, expr, s->v.Assert.test);

  0009f	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 compiler_visit_expr
  000ab	85 c0		 test	 eax, eax
  000ad	74 99		 je	 SHORT $LN20@compiler_a@8

; 2400 :     end = compiler_new_block(c);

  000af	48 8b cb	 mov	 rcx, rbx
  000b2	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000b7	e8 00 00 00 00	 call	 compiler_new_block
  000bc	48 8b f0	 mov	 rsi, rax

; 2401 :     if (end == NULL)

  000bf	48 85 c0	 test	 rax, rax

; 2402 :         return 0;

  000c2	74 7c		 je	 SHORT $LN19@compiler_a@8

; 2403 :     ADDOP_JABS(c, POP_JUMP_IF_TRUE, end);

  000c4	41 b9 01 00 00
	00		 mov	 r9d, 1
  000ca	4c 8b c0	 mov	 r8, rax
  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	41 8d 51 72	 lea	 edx, QWORD PTR [r9+114]
  000d4	e8 00 00 00 00	 call	 compiler_addop_j
  000d9	85 c0		 test	 eax, eax
  000db	74 63		 je	 SHORT $LN19@compiler_a@8

; 2404 :     ADDOP_O(c, LOAD_GLOBAL, assertion_error, names);

  000dd	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  000e1	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?assertion_error@?1??compiler_assert@@9@9
  000e8	ba 74 00 00 00	 mov	 edx, 116		; 00000074H
  000ed	4d 8b 40 28	 mov	 r8, QWORD PTR [r8+40]
  000f1	48 8b cb	 mov	 rcx, rbx
  000f4	e8 00 00 00 00	 call	 compiler_addop_o
  000f9	85 c0		 test	 eax, eax
  000fb	74 43		 je	 SHORT $LN19@compiler_a@8

; 2405 :     if (s->v.Assert.msg) {

  000fd	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00101	48 85 d2	 test	 rdx, rdx
  00104	74 23		 je	 SHORT $LN2@compiler_a@8

; 2406 :         VISIT(c, expr, s->v.Assert.msg);

  00106	48 8b cb	 mov	 rcx, rbx
  00109	e8 00 00 00 00	 call	 compiler_visit_expr
  0010e	85 c0		 test	 eax, eax
  00110	74 2e		 je	 SHORT $LN19@compiler_a@8

; 2407 :         ADDOP_I(c, CALL_FUNCTION, 1);

  00112	ba 83 00 00 00	 mov	 edx, 131		; 00000083H
  00117	41 b8 01 00 00
	00		 mov	 r8d, 1
  0011d	48 8b cb	 mov	 rcx, rbx
  00120	e8 00 00 00 00	 call	 compiler_addop_i
  00125	85 c0		 test	 eax, eax
  00127	74 17		 je	 SHORT $LN19@compiler_a@8
$LN2@compiler_a@8:

; 2408 :     }
; 2409 :     ADDOP_I(c, RAISE_VARARGS, 1);

  00129	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  0012e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00134	48 8b cb	 mov	 rcx, rbx
  00137	e8 00 00 00 00	 call	 compiler_addop_i
  0013c	85 c0		 test	 eax, eax
  0013e	75 12		 jne	 SHORT $LN1@compiler_a@8
$LN19@compiler_a@8:
  00140	33 c0		 xor	 eax, eax
  00142	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2411 :     return 1;
; 2412 : }

  00147	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0014c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00150	5f		 pop	 rdi
  00151	c3		 ret	 0
$LN1@compiler_a@8:

; 2410 :     compiler_use_next_block(c, end);

  00152	48 8b d6	 mov	 rdx, rsi
  00155	48 8b cb	 mov	 rcx, rbx
  00158	e8 00 00 00 00	 call	 compiler_use_next_block
  0015d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2411 :     return 1;
; 2412 : }

  00162	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00170	5f		 pop	 rdi
  00171	c3		 ret	 0
compiler_assert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_with DD imagerel compiler_with
	DD	imagerel compiler_with+450
	DD	imagerel $unwind$compiler_with
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_with DD 060c01H
	DD	08340cH
	DD	07008320cH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_with
_TEXT	SEGMENT
c$ = 64
block$1$ = 72
s$ = 72
pos$ = 80
finally$1$ = 88
compiler_with PROC					; COMDAT

; 3236 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3237 :     basicblock *block, *finally;
; 3238 :     withitem_ty item = asdl_seq_GET(s->v.With.items, pos);

  0000c	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00010	49 63 f8	 movsxd	 rdi, r8d
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b 6c f8 08	 mov	 rbp, QWORD PTR [rax+rdi*8+8]
  0001b	48 8b d9	 mov	 rbx, rcx

; 3239 : 
; 3240 :     assert(s->kind == With_kind);
; 3241 : 
; 3242 :     block = compiler_new_block(c);

  0001e	e8 00 00 00 00	 call	 compiler_new_block

; 3243 :     finally = compiler_new_block(c);

  00023	48 8b cb	 mov	 rcx, rbx
  00026	48 89 44 24 48	 mov	 QWORD PTR block$1$[rsp], rax
  0002b	e8 00 00 00 00	 call	 compiler_new_block

; 3244 :     if (!block || !finally)

  00030	48 83 7c 24 48
	00		 cmp	 QWORD PTR block$1$[rsp], 0
  00036	48 89 44 24 58	 mov	 QWORD PTR finally$1$[rsp], rax
  0003b	74 61		 je	 SHORT $LN20@compiler_w@2
  0003d	48 85 c0	 test	 rax, rax
  00040	74 5c		 je	 SHORT $LN20@compiler_w@2

; 3246 : 
; 3247 :     /* Evaluate EXPR */
; 3248 :     VISIT(c, expr, item->context_expr);

  00042	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	e8 00 00 00 00	 call	 compiler_visit_expr
  0004e	85 c0		 test	 eax, eax
  00050	74 4c		 je	 SHORT $LN20@compiler_w@2

; 3249 :     ADDOP_JREL(c, SETUP_WITH, finally);

  00052	4c 8b 44 24 58	 mov	 r8, QWORD PTR finally$1$[rsp]
  00057	45 33 c9	 xor	 r9d, r9d
  0005a	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 compiler_addop_j
  00067	85 c0		 test	 eax, eax
  00069	74 33		 je	 SHORT $LN20@compiler_w@2

; 3250 : 
; 3251 :     /* SETUP_WITH pushes a finally block. */
; 3252 :     compiler_use_next_block(c, block);

  0006b	48 8b 54 24 48	 mov	 rdx, QWORD PTR block$1$[rsp]
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 compiler_use_next_block

; 3253 :     if (!compiler_push_fblock(c, FINALLY_TRY, block)) {

  00078	4c 8b c2	 mov	 r8, rdx
  0007b	ba 02 00 00 00	 mov	 edx, 2
  00080	e8 00 00 00 00	 call	 compiler_push_fblock
  00085	85 c0		 test	 eax, eax

; 3254 :         return 0;

  00087	74 15		 je	 SHORT $LN20@compiler_w@2

; 3255 :     }
; 3256 : 
; 3257 :     if (item->optional_vars) {

  00089	48 8b 55 08	 mov	 rdx, QWORD PTR [rbp+8]

; 3258 :         VISIT(c, expr, item->optional_vars);

  0008d	48 8b cb	 mov	 rcx, rbx
  00090	48 85 d2	 test	 rdx, rdx
  00093	74 18		 je	 SHORT $LN16@compiler_w@2
  00095	e8 00 00 00 00	 call	 compiler_visit_expr
  0009a	85 c0		 test	 eax, eax
  0009c	75 1d		 jne	 SHORT $LN13@compiler_w@2
$LN20@compiler_w@2:

; 3245 :         return 0;

  0009e	33 c0		 xor	 eax, eax

; 3289 :     return 1;
; 3290 : }

  000a0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	5e		 pop	 rsi
  000ab	5d		 pop	 rbp
  000ac	c3		 ret	 0
$LN16@compiler_w@2:

; 3259 :     }
; 3260 :     else {
; 3261 :     /* Discard result from context.__enter__() */
; 3262 :         ADDOP(c, POP_TOP);

  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	e8 00 00 00 00	 call	 compiler_addop
  000b7	85 c0		 test	 eax, eax
  000b9	74 e3		 je	 SHORT $LN20@compiler_w@2
$LN13@compiler_w@2:

; 3263 :     }
; 3264 : 
; 3265 :     pos++;
; 3266 :     if (pos == asdl_seq_LEN(s->v.With.items))

  000bb	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  000bf	ff c7		 inc	 edi
  000c1	48 85 c9	 test	 rcx, rcx
  000c4	74 03		 je	 SHORT $LN25@compiler_w@2
$LN24@compiler_w@2:
  000c6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN25@compiler_w@2:
  000c9	48 63 c7	 movsxd	 rax, edi
  000cc	48 3b c1	 cmp	 rax, rcx
  000cf	75 3b		 jne	 SHORT $LN12@compiler_w@2

; 3267 :         /* BLOCK code */
; 3268 :         VISIT_SEQ(c, stmt, s->v.With.body)

  000d1	48 8b 6e 10	 mov	 rbp, QWORD PTR [rsi+16]
  000d5	33 ff		 xor	 edi, edi
  000d7	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
  000db	0f 1f 44 00 00	 npad	 5
$LL11@compiler_w@2:
  000e0	48 85 ed	 test	 rbp, rbp
  000e3	75 04		 jne	 SHORT $LN26@compiler_w@2
  000e5	33 c9		 xor	 ecx, ecx
  000e7	eb 04		 jmp	 SHORT $LN27@compiler_w@2
$LN26@compiler_w@2:
  000e9	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN27@compiler_w@2:
  000ed	48 63 c7	 movsxd	 rax, edi
  000f0	48 3b c1	 cmp	 rax, rcx
  000f3	7d 29		 jge	 SHORT $LN6@compiler_w@2
  000f5	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 compiler_visit_stmt
  00100	85 c0		 test	 eax, eax
  00102	74 9a		 je	 SHORT $LN20@compiler_w@2
  00104	ff c7		 inc	 edi
  00106	48 83 c6 08	 add	 rsi, 8
  0010a	eb d4		 jmp	 SHORT $LL11@compiler_w@2
$LN12@compiler_w@2:

; 3269 :     else if (!compiler_with(c, s, pos))

  0010c	44 8b c7	 mov	 r8d, edi
  0010f	48 8b d6	 mov	 rdx, rsi
  00112	48 8b cb	 mov	 rcx, rbx
  00115	e8 00 00 00 00	 call	 compiler_with
  0011a	85 c0		 test	 eax, eax

; 3270 :             return 0;

  0011c	74 80		 je	 SHORT $LN20@compiler_w@2
$LN6@compiler_w@2:

; 3271 : 
; 3272 :     /* End of try block; start the finally block */
; 3273 :     ADDOP(c, POP_BLOCK);

  0011e	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00123	48 8b cb	 mov	 rcx, rbx
  00126	e8 00 00 00 00	 call	 compiler_addop
  0012b	85 c0		 test	 eax, eax
  0012d	0f 84 6b ff ff
	ff		 je	 $LN20@compiler_w@2

; 3274 :     compiler_pop_fblock(c, FINALLY_TRY, block);

  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 compiler_pop_fblock

; 3275 : 
; 3276 :     ADDOP_O(c, LOAD_CONST, Py_None, consts);

  0013b	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
  0013f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00146	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  0014a	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0014f	e8 00 00 00 00	 call	 compiler_addop_o
  00154	85 c0		 test	 eax, eax
  00156	0f 84 42 ff ff
	ff		 je	 $LN20@compiler_w@2

; 3277 :     compiler_use_next_block(c, finally);

  0015c	48 8b 54 24 58	 mov	 rdx, QWORD PTR finally$1$[rsp]
  00161	48 8b cb	 mov	 rcx, rbx
  00164	e8 00 00 00 00	 call	 compiler_use_next_block

; 3278 :     if (!compiler_push_fblock(c, FINALLY_END, finally))

  00169	4c 8b c2	 mov	 r8, rdx
  0016c	ba 03 00 00 00	 mov	 edx, 3
  00171	e8 00 00 00 00	 call	 compiler_push_fblock
  00176	85 c0		 test	 eax, eax

; 3279 :         return 0;

  00178	0f 84 20 ff ff
	ff		 je	 $LN20@compiler_w@2

; 3280 : 
; 3281 :     /* Finally block starts; context.__exit__ is on the stack under
; 3282 :        the exception or return information. Just issue our magic
; 3283 :        opcode. */
; 3284 :     ADDOP(c, WITH_CLEANUP);

  0017e	ba 51 00 00 00	 mov	 edx, 81			; 00000051H
  00183	48 8b cb	 mov	 rcx, rbx
  00186	e8 00 00 00 00	 call	 compiler_addop
  0018b	85 c0		 test	 eax, eax
  0018d	0f 84 0b ff ff
	ff		 je	 $LN20@compiler_w@2

; 3285 : 
; 3286 :     /* Finally block ends. */
; 3287 :     ADDOP(c, END_FINALLY);

  00193	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00198	48 8b cb	 mov	 rcx, rbx
  0019b	e8 00 00 00 00	 call	 compiler_addop
  001a0	85 c0		 test	 eax, eax
  001a2	0f 84 f6 fe ff
	ff		 je	 $LN20@compiler_w@2

; 3288 :     compiler_pop_fblock(c, FINALLY_END, finally);

  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	e8 00 00 00 00	 call	 compiler_pop_fblock

; 3289 :     return 1;
; 3290 : }

  001b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001be	5f		 pop	 rdi
  001bf	5e		 pop	 rsi
  001c0	5d		 pop	 rbp
  001c1	c3		 ret	 0
compiler_with ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_try_finally DD imagerel compiler_try_finally
	DD	imagerel compiler_try_finally+423
	DD	imagerel $unwind$compiler_try_finally
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_try_finally DD 0a8301H
	DD	097483H
	DD	08647eH
	DD	0a340eH
	DD	0d00a320eH
	DD	05006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compiler_try_finally
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_try_finally PROC				; COMDAT

; 2033 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	4c 8b e2	 mov	 r12, rdx
  00011	48 8b e9	 mov	 rbp, rcx

; 2034 :     basicblock *body, *end;
; 2035 :     body = compiler_new_block(c);

  00014	e8 00 00 00 00	 call	 compiler_new_block

; 2036 :     end = compiler_new_block(c);

  00019	48 8b cd	 mov	 rcx, rbp
  0001c	48 8b d8	 mov	 rbx, rax
  0001f	e8 00 00 00 00	 call	 compiler_new_block
  00024	4c 8b e8	 mov	 r13, rax

; 2037 :     if (body == NULL || end == NULL)

  00027	48 85 db	 test	 rbx, rbx
  0002a	74 1b		 je	 SHORT $LN34@compiler_t@3
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 16		 je	 SHORT $LN34@compiler_t@3

; 2038 :         return 0;
; 2039 : 
; 2040 :     ADDOP_JREL(c, SETUP_FINALLY, end);

  00031	45 33 c9	 xor	 r9d, r9d
  00034	4c 8b c0	 mov	 r8, rax
  00037	48 8b cd	 mov	 rcx, rbp
  0003a	41 8d 51 7a	 lea	 edx, QWORD PTR [r9+122]
  0003e	e8 00 00 00 00	 call	 compiler_addop_j
  00043	85 c0		 test	 eax, eax
  00045	75 11		 jne	 SHORT $LN17@compiler_t@3
$LN34@compiler_t@3:
  00047	33 c0		 xor	 eax, eax

; 2063 : }

  00049	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	41 5d		 pop	 r13
  00054	41 5c		 pop	 r12
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
$LN17@compiler_t@3:

; 2041 :     compiler_use_next_block(c, body);

  00058	48 8b d3	 mov	 rdx, rbx
  0005b	48 8b cd	 mov	 rcx, rbp
  0005e	e8 00 00 00 00	 call	 compiler_use_next_block

; 2042 :     if (!compiler_push_fblock(c, FINALLY_TRY, body))

  00063	4c 8b c3	 mov	 r8, rbx
  00066	ba 02 00 00 00	 mov	 edx, 2
  0006b	e8 00 00 00 00	 call	 compiler_push_fblock
  00070	85 c0		 test	 eax, eax

; 2043 :         return 0;

  00072	74 d3		 je	 SHORT $LN34@compiler_t@3

; 2044 :     if (s->v.Try.handlers && asdl_seq_LEN(s->v.Try.handlers)) {

  00074	49 8b 44 24 10	 mov	 rax, QWORD PTR [r12+16]
  00079	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0007e	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00083	48 85 c0	 test	 rax, rax
  00086	74 1c		 je	 SHORT $LN15@compiler_t@3
  00088	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008c	74 16		 je	 SHORT $LN15@compiler_t@3

; 2045 :         if (!compiler_try_except(c, s))

  0008e	49 8b d4	 mov	 rdx, r12
  00091	48 8b cd	 mov	 rcx, rbp
  00094	e8 00 00 00 00	 call	 compiler_try_except
  00099	85 c0		 test	 eax, eax
  0009b	75 3e		 jne	 SHORT $LN10@compiler_t@3
$LN31@compiler_t@3:

; 2046 :             return 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 ea 00 00 00	 jmp	 $LN33@compiler_t@3
$LN15@compiler_t@3:

; 2047 :     }
; 2048 :     else {
; 2049 :         VISIT_SEQ(c, stmt, s->v.Try.body);

  000a4	49 8b 74 24 08	 mov	 rsi, QWORD PTR [r12+8]
  000a9	33 db		 xor	 ebx, ebx
  000ab	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  000af	90		 npad	 1
$LL12@compiler_t@3:
  000b0	48 85 f6	 test	 rsi, rsi
  000b3	75 04		 jne	 SHORT $LN24@compiler_t@3
  000b5	33 c9		 xor	 ecx, ecx
  000b7	eb 03		 jmp	 SHORT $LN25@compiler_t@3
$LN24@compiler_t@3:
  000b9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN25@compiler_t@3:
  000bc	48 63 c3	 movsxd	 rax, ebx
  000bf	48 3b c1	 cmp	 rax, rcx
  000c2	7d 17		 jge	 SHORT $LN10@compiler_t@3
  000c4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  000c7	48 8b cd	 mov	 rcx, rbp
  000ca	e8 00 00 00 00	 call	 compiler_visit_stmt
  000cf	85 c0		 test	 eax, eax
  000d1	74 ca		 je	 SHORT $LN31@compiler_t@3
  000d3	ff c3		 inc	 ebx
  000d5	48 83 c7 08	 add	 rdi, 8
  000d9	eb d5		 jmp	 SHORT $LL12@compiler_t@3
$LN10@compiler_t@3:

; 2050 :     }
; 2051 :     ADDOP(c, POP_BLOCK);

  000db	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  000e0	48 8b cd	 mov	 rcx, rbp
  000e3	e8 00 00 00 00	 call	 compiler_addop
  000e8	85 c0		 test	 eax, eax
  000ea	74 b1		 je	 SHORT $LN31@compiler_t@3

; 2052 :     compiler_pop_fblock(c, FINALLY_TRY, body);

  000ec	48 8b cd	 mov	 rcx, rbp
  000ef	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2053 : 
; 2054 :     ADDOP_O(c, LOAD_CONST, Py_None, consts);

  000f4	4c 8b 45 38	 mov	 r8, QWORD PTR [rbp+56]
  000f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000ff	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00103	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00108	e8 00 00 00 00	 call	 compiler_addop_o
  0010d	85 c0		 test	 eax, eax
  0010f	74 8c		 je	 SHORT $LN31@compiler_t@3

; 2055 :     compiler_use_next_block(c, end);

  00111	49 8b d5	 mov	 rdx, r13
  00114	48 8b cd	 mov	 rcx, rbp
  00117	e8 00 00 00 00	 call	 compiler_use_next_block

; 2056 :     if (!compiler_push_fblock(c, FINALLY_END, end))

  0011c	4d 8b c5	 mov	 r8, r13
  0011f	ba 03 00 00 00	 mov	 edx, 3
  00124	e8 00 00 00 00	 call	 compiler_push_fblock
  00129	85 c0		 test	 eax, eax

; 2057 :         return 0;

  0012b	0f 84 6c ff ff
	ff		 je	 $LN31@compiler_t@3

; 2058 :     VISIT_SEQ(c, stmt, s->v.Try.finalbody);

  00131	49 8b 74 24 20	 mov	 rsi, QWORD PTR [r12+32]
  00136	33 db		 xor	 ebx, ebx
  00138	48 8d 7e 08	 lea	 rdi, QWORD PTR [rsi+8]
  0013c	0f 1f 40 00	 npad	 4
$LL5@compiler_t@3:
  00140	48 85 f6	 test	 rsi, rsi
  00143	75 04		 jne	 SHORT $LN26@compiler_t@3
  00145	33 c9		 xor	 ecx, ecx
  00147	eb 03		 jmp	 SHORT $LN27@compiler_t@3
$LN26@compiler_t@3:
  00149	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
$LN27@compiler_t@3:
  0014c	48 63 c3	 movsxd	 rax, ebx
  0014f	48 3b c1	 cmp	 rax, rcx
  00152	48 8b cd	 mov	 rcx, rbp
  00155	7d 18		 jge	 SHORT $LN3@compiler_t@3
  00157	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0015a	e8 00 00 00 00	 call	 compiler_visit_stmt
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 36 ff ff
	ff		 je	 $LN31@compiler_t@3
  00167	ff c3		 inc	 ebx
  00169	48 83 c7 08	 add	 rdi, 8
  0016d	eb d1		 jmp	 SHORT $LL5@compiler_t@3
$LN3@compiler_t@3:

; 2059 :     ADDOP(c, END_FINALLY);

  0016f	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00174	e8 00 00 00 00	 call	 compiler_addop
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 1c ff ff
	ff		 je	 $LN31@compiler_t@3

; 2060 :     compiler_pop_fblock(c, FINALLY_END, end);

  00181	48 8b cd	 mov	 rcx, rbp
  00184	e8 00 00 00 00	 call	 compiler_pop_fblock

; 2061 : 
; 2062 :     return 1;

  00189	b8 01 00 00 00	 mov	 eax, 1
$LN33@compiler_t@3:

; 2063 : }

  0018e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00193	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00198	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0019d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a1	41 5d		 pop	 r13
  001a3	41 5c		 pop	 r12
  001a5	5d		 pop	 rbp
  001a6	c3		 ret	 0
compiler_try_finally ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT compiler_try
_TEXT	SEGMENT
c$ = 8
s$ = 16
compiler_try PROC					; COMDAT

; 2214 :     if (s->v.Try.finalbody && asdl_seq_LEN(s->v.Try.finalbody))

  00000	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00004	48 85 c0	 test	 rax, rax
  00007	74 0b		 je	 SHORT $LN2@compiler_t@4
  00009	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0000d	74 05		 je	 SHORT $LN2@compiler_t@4

; 2215 :         return compiler_try_finally(c, s);
; 2216 :     else
; 2217 :         return compiler_try_except(c, s);
; 2218 : }

  0000f	e9 00 00 00 00	 jmp	 compiler_try_finally
$LN2@compiler_t@4:
  00014	e9 00 00 00 00	 jmp	 compiler_try_except
compiler_try ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@	; `string'
PUBLIC	??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_visit_stmt DD imagerel compiler_visit_stmt
	DD	imagerel compiler_visit_stmt+904
	DD	imagerel $unwind$compiler_visit_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_visit_stmt DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@
CONST	SEGMENT
??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@ DB '''break'' outside loo'
	DB	'p', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@
CONST	SEGMENT
??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@ DB '''return'' outs'
	DB	'ide function', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_visit_stmt
_TEXT	SEGMENT
c$ = 64
s$ = 72
compiler_visit_stmt PROC				; COMDAT

; 2416 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2417 :     int i, n;
; 2418 : 
; 2419 :     /* Always assign a lineno to the next instruction for a stmt. */
; 2420 :     c->u->u_lineno = s->lineno;

  00018	8b 42 40	 mov	 eax, DWORD PTR [rdx+64]
  0001b	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]

; 2421 :     c->u->u_col_offset = s->col_offset;
; 2422 :     c->u->u_lineno_set = 0;

  0001f	33 f6		 xor	 esi, esi
  00021	41 89 80 b4 01
	00 00		 mov	 DWORD PTR [r8+436], eax
  00028	8b 42 44	 mov	 eax, DWORD PTR [rdx+68]
  0002b	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0002f	41 89 80 b8 01
	00 00		 mov	 DWORD PTR [r8+440], eax
  00036	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0003a	48 8b fa	 mov	 rdi, rdx
  0003d	89 b0 bc 01 00
	00		 mov	 DWORD PTR [rax+444], esi

; 2423 : 
; 2424 :     switch (s->kind) {

  00043	8b 02		 mov	 eax, DWORD PTR [rdx]
  00045	48 8b d9	 mov	 rbx, rcx
  00048	ff c8		 dec	 eax
  0004a	83 f8 14	 cmp	 eax, 20
  0004d	0f 87 4f 01 00
	00		 ja	 $LN52@compiler_v@9
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0005a	48 98		 cdqe
  0005c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN66@compiler_v@9[rdx+rax*4]
  00063	48 03 ca	 add	 rcx, rdx
  00066	ff e1		 jmp	 rcx
$LN51@compiler_v@9:

; 2425 :     case FunctionDef_kind:
; 2426 :         return compiler_function(c, s);

  00068	48 8b d7	 mov	 rdx, rdi
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 compiler_function
  00073	e9 2f 01 00 00	 jmp	 $LN54@compiler_v@9
$LN50@compiler_v@9:

; 2427 :     case ClassDef_kind:
; 2428 :         return compiler_class(c, s);

  00078	48 8b d7	 mov	 rdx, rdi
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 compiler_class
  00083	e9 1f 01 00 00	 jmp	 $LN54@compiler_v@9
$LN49@compiler_v@9:

; 2429 :     case Return_kind:
; 2430 :         if (c->u->u_ste->ste_type != FunctionBlock)

  00088	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]

; 2431 :             return compiler_error(c, "'return' outside function");

  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00092	39 b0 88 00 00
	00		 cmp	 DWORD PTR [rax+136], esi
  00098	74 11		 je	 SHORT $LN48@compiler_v@9
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@DDMKJOGO@?8return?8?5outside?5function?$AA@
  000a1	e8 00 00 00 00	 call	 compiler_error
  000a6	e9 fc 00 00 00	 jmp	 $LN54@compiler_v@9
$LN48@compiler_v@9:

; 2432 :         if (s->v.Return.value) {

  000ab	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  000af	48 85 d2	 test	 rdx, rdx
  000b2	74 10		 je	 SHORT $LN47@compiler_v@9

; 2433 :             VISIT(c, expr, s->v.Return.value);

  000b4	e8 00 00 00 00	 call	 compiler_visit_expr
  000b9	85 c0		 test	 eax, eax
  000bb	75 20		 jne	 SHORT $LN44@compiler_v@9
$LN62@compiler_v@9:
  000bd	33 c0		 xor	 eax, eax
  000bf	e9 e3 00 00 00	 jmp	 $LN54@compiler_v@9
$LN47@compiler_v@9:

; 2434 :         }
; 2435 :         else
; 2436 :             ADDOP_O(c, LOAD_CONST, Py_None, consts);

  000c4	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  000c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000cf	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000d4	e8 00 00 00 00	 call	 compiler_addop_o
  000d9	85 c0		 test	 eax, eax
  000db	74 15		 je	 SHORT $LN68@compiler_v@9
$LN44@compiler_v@9:

; 2437 :         ADDOP(c, RETURN_VALUE);

  000dd	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
$LN69@compiler_v@9:
  000e2	48 8b cb	 mov	 rcx, rbx
$LN70@compiler_v@9:
  000e5	e8 00 00 00 00	 call	 compiler_addop
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 b0 00 00
	00		 jne	 $LN52@compiler_v@9
$LN68@compiler_v@9:
  000f2	33 c0		 xor	 eax, eax
  000f4	e9 ae 00 00 00	 jmp	 $LN54@compiler_v@9
$LN42@compiler_v@9:

; 2438 :         break;
; 2439 :     case Delete_kind:
; 2440 :         VISIT_SEQ(c, expr, s->v.Delete.targets)

  000f9	4c 8b 67 08	 mov	 r12, QWORD PTR [rdi+8]
  000fd	8b fe		 mov	 edi, esi
  000ff	49 8d 6c 24 08	 lea	 rbp, QWORD PTR [r12+8]
$LL41@compiler_v@9:
  00104	48 8b ce	 mov	 rcx, rsi
  00107	4d 85 e4	 test	 r12, r12
  0010a	74 04		 je	 SHORT $LN57@compiler_v@9
  0010c	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
$LN57@compiler_v@9:
  00110	48 63 c7	 movsxd	 rax, edi
  00113	48 3b c1	 cmp	 rax, rcx
  00116	0f 8d 86 00 00
	00		 jge	 $LN52@compiler_v@9
  0011c	48 8b 55 00	 mov	 rdx, QWORD PTR [rbp]
  00120	48 8b cb	 mov	 rcx, rbx
  00123	e8 00 00 00 00	 call	 compiler_visit_expr
  00128	85 c0		 test	 eax, eax
  0012a	74 91		 je	 SHORT $LN62@compiler_v@9
  0012c	ff c7		 inc	 edi
  0012e	48 83 c5 08	 add	 rbp, 8
  00132	eb d0		 jmp	 SHORT $LL41@compiler_v@9
$LN37@compiler_v@9:

; 2441 :         break;
; 2442 :     case Assign_kind:
; 2443 :         n = asdl_seq_LEN(s->v.Assign.targets);

  00134	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00138	44 8b e6	 mov	 r12d, esi
  0013b	48 85 c0	 test	 rax, rax
  0013e	74 03		 je	 SHORT $LN59@compiler_v@9
  00140	44 8b 20	 mov	 r12d, DWORD PTR [rax]
$LN59@compiler_v@9:

; 2444 :         VISIT(c, expr, s->v.Assign.value);

  00143	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00147	48 8b cb	 mov	 rcx, rbx
  0014a	e8 00 00 00 00	 call	 compiler_visit_expr
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 66 ff ff
	ff		 je	 $LN62@compiler_v@9

; 2445 :         for (i = 0; i < n; i++) {

  00157	48 8b ee	 mov	 rbp, rsi
  0015a	4d 63 ec	 movsxd	 r13, r12d
  0015d	45 85 e4	 test	 r12d, r12d
  00160	7e 40		 jle	 SHORT $LN52@compiler_v@9
  00162	41 ff cc	 dec	 r12d
$LL35@compiler_v@9:

; 2446 :             if (i < n - 1)

  00165	41 3b f4	 cmp	 esi, r12d
  00168	7d 15		 jge	 SHORT $LN31@compiler_v@9

; 2447 :                 ADDOP(c, DUP_TOP);

  0016a	ba 04 00 00 00	 mov	 edx, 4
  0016f	48 8b cb	 mov	 rcx, rbx
  00172	e8 00 00 00 00	 call	 compiler_addop
  00177	85 c0		 test	 eax, eax
  00179	0f 84 3e ff ff
	ff		 je	 $LN62@compiler_v@9
$LN31@compiler_v@9:

; 2448 :             VISIT(c, expr,
; 2449 :                   (expr_ty)asdl_seq_GET(s->v.Assign.targets, i));

  0017f	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  00183	48 8b cb	 mov	 rcx, rbx
  00186	48 8b 54 ea 08	 mov	 rdx, QWORD PTR [rdx+rbp*8+8]
  0018b	e8 00 00 00 00	 call	 compiler_visit_expr
  00190	85 c0		 test	 eax, eax
  00192	0f 84 25 ff ff
	ff		 je	 $LN62@compiler_v@9

; 2445 :         for (i = 0; i < n; i++) {

  00198	48 ff c5	 inc	 rbp
  0019b	ff c6		 inc	 esi
  0019d	49 3b ed	 cmp	 rbp, r13
  001a0	7c c3		 jl	 SHORT $LL35@compiler_v@9
$LN52@compiler_v@9:

; 2505 :     }
; 2506 :     return 1;

  001a2	b8 01 00 00 00	 mov	 eax, 1
$LN54@compiler_v@9:

; 2507 : }

  001a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001ac	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001b1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ba	41 5d		 pop	 r13
  001bc	41 5c		 pop	 r12
  001be	5f		 pop	 rdi
  001bf	c3		 ret	 0
$LN29@compiler_v@9:

; 2450 :         }
; 2451 :         break;
; 2452 :     case AugAssign_kind:
; 2453 :         return compiler_augassign(c, s);

  001c0	48 8b d7	 mov	 rdx, rdi
  001c3	48 8b cb	 mov	 rcx, rbx
  001c6	e8 00 00 00 00	 call	 compiler_augassign
  001cb	eb da		 jmp	 SHORT $LN54@compiler_v@9
$LN28@compiler_v@9:

; 2454 :     case For_kind:
; 2455 :         return compiler_for(c, s);

  001cd	48 8b d7	 mov	 rdx, rdi
  001d0	48 8b cb	 mov	 rcx, rbx
  001d3	e8 00 00 00 00	 call	 compiler_for
  001d8	eb cd		 jmp	 SHORT $LN54@compiler_v@9
$LN27@compiler_v@9:

; 2456 :     case While_kind:
; 2457 :         return compiler_while(c, s);

  001da	48 8b d7	 mov	 rdx, rdi
  001dd	48 8b cb	 mov	 rcx, rbx
  001e0	e8 00 00 00 00	 call	 compiler_while
  001e5	eb c0		 jmp	 SHORT $LN54@compiler_v@9
$LN26@compiler_v@9:

; 2458 :     case If_kind:
; 2459 :         return compiler_if(c, s);

  001e7	48 8b d7	 mov	 rdx, rdi
  001ea	48 8b cb	 mov	 rcx, rbx
  001ed	e8 00 00 00 00	 call	 compiler_if
  001f2	eb b3		 jmp	 SHORT $LN54@compiler_v@9
$LN25@compiler_v@9:

; 2460 :     case Raise_kind:
; 2461 :         n = 0;
; 2462 :         if (s->v.Raise.exc) {

  001f4	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  001f8	48 85 d2	 test	 rdx, rdx
  001fb	74 33		 je	 SHORT $LN22@compiler_v@9

; 2463 :             VISIT(c, expr, s->v.Raise.exc);

  001fd	48 8b cb	 mov	 rcx, rbx
  00200	e8 00 00 00 00	 call	 compiler_visit_expr
  00205	85 c0		 test	 eax, eax
  00207	0f 84 b0 fe ff
	ff		 je	 $LN62@compiler_v@9

; 2464 :             n++;
; 2465 :         if (s->v.Raise.cause) {

  0020d	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00211	be 01 00 00 00	 mov	 esi, 1
  00216	48 85 d2	 test	 rdx, rdx
  00219	74 15		 je	 SHORT $LN22@compiler_v@9

; 2466 :         VISIT(c, expr, s->v.Raise.cause);

  0021b	48 8b cb	 mov	 rcx, rbx
  0021e	e8 00 00 00 00	 call	 compiler_visit_expr
  00223	85 c0		 test	 eax, eax
  00225	0f 84 92 fe ff
	ff		 je	 $LN62@compiler_v@9

; 2467 :         n++;

  0022b	be 02 00 00 00	 mov	 esi, 2
$LN22@compiler_v@9:

; 2468 :         }
; 2469 :         }
; 2470 :         ADDOP_I(c, RAISE_VARARGS, n);

  00230	44 8b c6	 mov	 r8d, esi
  00233	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  00238	48 8b cb	 mov	 rcx, rbx
  0023b	e8 00 00 00 00	 call	 compiler_addop_i
  00240	85 c0		 test	 eax, eax
  00242	0f 85 5a ff ff
	ff		 jne	 $LN52@compiler_v@9
  00248	e9 5a ff ff ff	 jmp	 $LN54@compiler_v@9
$LN19@compiler_v@9:

; 2471 :         break;
; 2472 :     case Try_kind:
; 2473 :         return compiler_try(c, s);

  0024d	48 8b d7	 mov	 rdx, rdi
  00250	48 8b cb	 mov	 rcx, rbx
  00253	e8 00 00 00 00	 call	 compiler_try
  00258	e9 4a ff ff ff	 jmp	 $LN54@compiler_v@9
$LN18@compiler_v@9:

; 2474 :     case Assert_kind:
; 2475 :         return compiler_assert(c, s);

  0025d	48 8b d7	 mov	 rdx, rdi
  00260	48 8b cb	 mov	 rcx, rbx
  00263	e8 00 00 00 00	 call	 compiler_assert
  00268	e9 3a ff ff ff	 jmp	 $LN54@compiler_v@9
$LN17@compiler_v@9:

; 2476 :     case Import_kind:
; 2477 :         return compiler_import(c, s);

  0026d	48 8b d7	 mov	 rdx, rdi
  00270	48 8b cb	 mov	 rcx, rbx
  00273	e8 00 00 00 00	 call	 compiler_import
  00278	e9 2a ff ff ff	 jmp	 $LN54@compiler_v@9
$LN16@compiler_v@9:

; 2478 :     case ImportFrom_kind:
; 2479 :         return compiler_from_import(c, s);

  0027d	48 8b d7	 mov	 rdx, rdi
  00280	48 8b cb	 mov	 rcx, rbx
  00283	e8 00 00 00 00	 call	 compiler_from_import
  00288	e9 1a ff ff ff	 jmp	 $LN54@compiler_v@9
$LN14@compiler_v@9:

; 2480 :     case Global_kind:
; 2481 :     case Nonlocal_kind:
; 2482 :         break;
; 2483 :     case Expr_kind:
; 2484 :         if (c->c_interactive && c->c_nestlevel <= 1) {

  0028d	39 73 2c	 cmp	 DWORD PTR [rbx+44], esi
  00290	74 24		 je	 SHORT $LN13@compiler_v@9
  00292	83 7b 30 01	 cmp	 DWORD PTR [rbx+48], 1
  00296	7f 1e		 jg	 SHORT $LN13@compiler_v@9

; 2485 :             VISIT(c, expr, s->v.Expr.value);

  00298	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  0029c	48 8b cb	 mov	 rcx, rbx
  0029f	e8 00 00 00 00	 call	 compiler_visit_expr
  002a4	85 c0		 test	 eax, eax
  002a6	0f 84 11 fe ff
	ff		 je	 $LN62@compiler_v@9

; 2486 :             ADDOP(c, PRINT_EXPR);

  002ac	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  002b1	e9 2c fe ff ff	 jmp	 $LN69@compiler_v@9
$LN13@compiler_v@9:

; 2487 :         }
; 2488 :         else if (s->v.Expr.value->kind != Str_kind &&
; 2489 :                  s->v.Expr.value->kind != Num_kind) {

  002b6	48 8b 57 08	 mov	 rdx, QWORD PTR [rdi+8]
  002ba	8b 02		 mov	 eax, DWORD PTR [rdx]
  002bc	83 f8 11	 cmp	 eax, 17
  002bf	0f 84 dd fe ff
	ff		 je	 $LN52@compiler_v@9
  002c5	83 f8 10	 cmp	 eax, 16
  002c8	0f 84 d4 fe ff
	ff		 je	 $LN52@compiler_v@9

; 2490 :             VISIT(c, expr, s->v.Expr.value);

  002ce	48 8b cb	 mov	 rcx, rbx
  002d1	e8 00 00 00 00	 call	 compiler_visit_expr
  002d6	85 c0		 test	 eax, eax
  002d8	0f 84 df fd ff
	ff		 je	 $LN62@compiler_v@9

; 2491 :             ADDOP(c, POP_TOP);

  002de	ba 01 00 00 00	 mov	 edx, 1
  002e3	e9 fa fd ff ff	 jmp	 $LN69@compiler_v@9
$LN5@compiler_v@9:

; 2492 :         }
; 2493 :         break;
; 2494 :     case Pass_kind:
; 2495 :         break;
; 2496 :     case Break_kind:
; 2497 :         if (!compiler_in_loop(c))

  002e8	48 8b cb	 mov	 rcx, rbx
  002eb	e8 00 00 00 00	 call	 compiler_in_loop

; 2498 :             return compiler_error(c, "'break' outside loop");

  002f0	48 8b cb	 mov	 rcx, rbx
  002f3	85 c0		 test	 eax, eax
  002f5	75 11		 jne	 SHORT $LN4@compiler_v@9
  002f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MLDPDGD@?8break?8?5outside?5loop?$AA@
  002fe	e8 00 00 00 00	 call	 compiler_error
  00303	e9 9f fe ff ff	 jmp	 $LN54@compiler_v@9
$LN4@compiler_v@9:

; 2499 :         ADDOP(c, BREAK_LOOP);

  00308	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0030d	e9 d3 fd ff ff	 jmp	 $LN70@compiler_v@9
$LN2@compiler_v@9:

; 2500 :         break;
; 2501 :     case Continue_kind:
; 2502 :         return compiler_continue(c);

  00312	48 8b cb	 mov	 rcx, rbx
  00315	e8 00 00 00 00	 call	 compiler_continue
  0031a	e9 88 fe ff ff	 jmp	 $LN54@compiler_v@9
$LN1@compiler_v@9:

; 2503 :     case With_kind:
; 2504 :         return compiler_with(c, s, 0);

  0031f	45 33 c0	 xor	 r8d, r8d
  00322	48 8b d7	 mov	 rdx, rdi
  00325	48 8b cb	 mov	 rcx, rbx
  00328	e8 00 00 00 00	 call	 compiler_with
  0032d	e9 75 fe ff ff	 jmp	 $LN54@compiler_v@9
  00332	66 90		 npad	 2
$LN66@compiler_v@9:

; 2507 : }

  00334	00 00 00 00	 DD	 $LN51@compiler_v@9
  00338	00 00 00 00	 DD	 $LN50@compiler_v@9
  0033c	00 00 00 00	 DD	 $LN49@compiler_v@9
  00340	00 00 00 00	 DD	 $LN42@compiler_v@9
  00344	00 00 00 00	 DD	 $LN37@compiler_v@9
  00348	00 00 00 00	 DD	 $LN29@compiler_v@9
  0034c	00 00 00 00	 DD	 $LN28@compiler_v@9
  00350	00 00 00 00	 DD	 $LN27@compiler_v@9
  00354	00 00 00 00	 DD	 $LN26@compiler_v@9
  00358	00 00 00 00	 DD	 $LN1@compiler_v@9
  0035c	00 00 00 00	 DD	 $LN25@compiler_v@9
  00360	00 00 00 00	 DD	 $LN19@compiler_v@9
  00364	00 00 00 00	 DD	 $LN18@compiler_v@9
  00368	00 00 00 00	 DD	 $LN17@compiler_v@9
  0036c	00 00 00 00	 DD	 $LN16@compiler_v@9
  00370	00 00 00 00	 DD	 $LN52@compiler_v@9
  00374	00 00 00 00	 DD	 $LN52@compiler_v@9
  00378	00 00 00 00	 DD	 $LN14@compiler_v@9
  0037c	00 00 00 00	 DD	 $LN52@compiler_v@9
  00380	00 00 00 00	 DD	 $LN5@compiler_v@9
  00384	00 00 00 00	 DD	 $LN2@compiler_v@9
compiler_visit_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@ ; `string'
PUBLIC	??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@ ; `string'
PUBLIC	??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@		; `string'
_BSS	SEGMENT
?module@?1??compiler_mod@@9@9 DQ 01H DUP (?)		; `compiler_mod'::`2'::module
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compiler_mod DD imagerel compiler_mod
	DD	imagerel compiler_mod+115
	DD	imagerel $unwind$compiler_mod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$compiler_mod DD imagerel compiler_mod+115
	DD	imagerel compiler_mod+262
	DD	imagerel $chain$1$compiler_mod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$compiler_mod DD imagerel compiler_mod+262
	DD	imagerel compiler_mod+348
	DD	imagerel $chain$3$compiler_mod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$compiler_mod DD 040021H
	DD	096400H
	DD	085400H
	DD	imagerel compiler_mod
	DD	imagerel compiler_mod+115
	DD	imagerel $unwind$compiler_mod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$compiler_mod DD 040a21H
	DD	09640aH
	DD	085405H
	DD	imagerel compiler_mod
	DD	imagerel compiler_mod+115
	DD	imagerel $unwind$compiler_mod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compiler_mod DD 061001H
	DD	0b7410H
	DD	0a3410H
	DD	0c00c5210H
xdata	ENDS
;	COMDAT ??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@
CONST	SEGMENT
??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@ DB 'suite should'
	DB	' not be possible', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@
CONST	SEGMENT
??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@ DB 'module '
	DB	'kind %d should not be possible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@
CONST	SEGMENT
??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@ DB '<module>', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT compiler_mod
_TEXT	SEGMENT
c$ = 64
mod$ = 72
compiler_mod PROC					; COMDAT

; 1282 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1283 :     PyCodeObject *co;
; 1284 :     int addNone = 1;
; 1285 :     static PyObject *module;
; 1286 :     if (!module) {

  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?module@?1??compiler_mod@@9@9
  00017	48 8b da	 mov	 rbx, rdx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	41 bc 01 00 00
	00		 mov	 r12d, 1
  00023	48 85 c0	 test	 rax, rax
  00026	75 2b		 jne	 SHORT $LN15@compiler_m@2

; 1287 :         module = PyUnicode_InternFromString("<module>");

  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DLJNCJAP@?$DMmodule?$DO?$AA@
  0002f	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00034	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module@?1??compiler_mod@@9@9, rax

; 1288 :         if (!module)

  0003b	48 85 c0	 test	 rax, rax
  0003e	75 13		 jne	 SHORT $LN15@compiler_m@2
$LN25@compiler_m@2:

; 1289 :             return NULL;

  00040	33 c0		 xor	 eax, eax

; 1323 : }

  00042	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00047	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	41 5c		 pop	 r12
  00052	c3		 ret	 0
$LN15@compiler_m@2:

; 1290 :     }
; 1291 :     /* Use 0 for firstlineno initially, will fixup in assemble(). */
; 1292 :     if (!compiler_enter_scope(c, module, COMPILER_SCOPE_MODULE, mod, 0))

  00053	4c 8b cb	 mov	 r9, rbx
  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00067	e8 00 00 00 00	 call	 compiler_enter_scope
  0006c	85 c0		 test	 eax, eax

; 1293 :         return NULL;

  0006e	74 d0		 je	 SHORT $LN25@compiler_m@2

; 1294 :     switch (mod->kind) {

  00070	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00073	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00078	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0007d	41 8b c8	 mov	 ecx, r8d
  00080	ff c9		 dec	 ecx
  00082	0f 84 b8 00 00
	00		 je	 $LN11@compiler_m@2
  00088	ff c9		 dec	 ecx
  0008a	74 7a		 je	 SHORT $LN9@compiler_m@2
  0008c	ff c9		 dec	 ecx
  0008e	74 2b		 je	 SHORT $LN4@compiler_m@2
  00090	ff c9		 dec	 ecx

; 1314 :     default:
; 1315 :         PyErr_Format(PyExc_SystemError,
; 1316 :                      "module kind %d should not be possible",
; 1317 :                      mod->kind);

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00099	74 10		 je	 SHORT $LN2@compiler_m@2
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HHMOOPMI@module?5kind?5?$CFd?5should?5not?5be?5pos@
  000a2	e8 00 00 00 00	 call	 PyErr_Format

; 1318 :         return 0;

  000a7	33 c0		 xor	 eax, eax
  000a9	eb 40		 jmp	 SHORT $LN24@compiler_m@2
$LN2@compiler_m@2:

; 1309 :         break;
; 1310 :     case Suite_kind:
; 1311 :         PyErr_SetString(PyExc_SystemError,
; 1312 :                         "suite should not be possible");

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PLBJONFI@suite?5should?5not?5be?5possible?$AA@
  000b2	e8 00 00 00 00	 call	 PyErr_SetString

; 1313 :         return 0;

  000b7	33 c0		 xor	 eax, eax
  000b9	eb 30		 jmp	 SHORT $LN24@compiler_m@2
$LN4@compiler_m@2:

; 1305 :         break;
; 1306 :     case Expression_kind:
; 1307 :         VISIT_IN_SCOPE(c, expr, mod->v.Expression.body);

  000bb	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	e8 00 00 00 00	 call	 compiler_visit_expr
  000c7	85 c0		 test	 eax, eax
  000c9	0f 84 81 00 00
	00		 je	 $LN22@compiler_m@2

; 1308 :         addNone = 0;

  000cf	45 33 e4	 xor	 r12d, r12d
$LN10@compiler_m@2:

; 1319 :     }
; 1320 :     co = assemble(c, addNone);

  000d2	41 8b d4	 mov	 edx, r12d
  000d5	48 8b cf	 mov	 rcx, rdi
  000d8	e8 00 00 00 00	 call	 assemble

; 1321 :     compiler_exit_scope(c);

  000dd	48 8b cf	 mov	 rcx, rdi
  000e0	48 8b d8	 mov	 rbx, rax
  000e3	e8 00 00 00 00	 call	 compiler_exit_scope

; 1322 :     return co;

  000e8	48 8b c3	 mov	 rax, rbx
$LN24@compiler_m@2:

; 1323 : }

  000eb	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f0	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fa	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00103	41 5c		 pop	 r12
  00105	c3		 ret	 0
$LN9@compiler_m@2:

; 1299 :         }
; 1300 :         break;
; 1301 :     case Interactive_kind:
; 1302 :         c->c_interactive = 1;

  00106	44 89 67 2c	 mov	 DWORD PTR [rdi+44], r12d

; 1303 :         VISIT_SEQ_IN_SCOPE(c, stmt,
; 1304 :                                 mod->v.Interactive.body);

  0010a	48 8b 6b 08	 mov	 rbp, QWORD PTR [rbx+8]
  0010e	33 db		 xor	 ebx, ebx
  00110	48 8d 75 08	 lea	 rsi, QWORD PTR [rbp+8]
$LL8@compiler_m@2:
  00114	48 85 ed	 test	 rbp, rbp
  00117	75 04		 jne	 SHORT $LN19@compiler_m@2
  00119	33 c9		 xor	 ecx, ecx
  0011b	eb 04		 jmp	 SHORT $LN20@compiler_m@2
$LN19@compiler_m@2:
  0011d	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
$LN20@compiler_m@2:
  00121	48 63 c3	 movsxd	 rax, ebx
  00124	48 3b c1	 cmp	 rax, rcx
  00127	7d a9		 jge	 SHORT $LN10@compiler_m@2
  00129	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  0012c	48 8b cf	 mov	 rcx, rdi
  0012f	e8 00 00 00 00	 call	 compiler_visit_stmt
  00134	85 c0		 test	 eax, eax
  00136	74 18		 je	 SHORT $LN22@compiler_m@2
  00138	ff c3		 inc	 ebx
  0013a	48 83 c6 08	 add	 rsi, 8
  0013e	eb d4		 jmp	 SHORT $LL8@compiler_m@2
$LN11@compiler_m@2:

; 1295 :     case Module_kind:
; 1296 :         if (!compiler_body(c, mod->v.Module.body)) {

  00140	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00144	48 8b cf	 mov	 rcx, rdi
  00147	e8 00 00 00 00	 call	 compiler_body
  0014c	85 c0		 test	 eax, eax
  0014e	75 82		 jne	 SHORT $LN10@compiler_m@2
$LN22@compiler_m@2:

; 1297 :             compiler_exit_scope(c);

  00150	48 8b cf	 mov	 rcx, rdi
  00153	e8 00 00 00 00	 call	 compiler_exit_scope

; 1298 :             return 0;

  00158	33 c0		 xor	 eax, eax
  0015a	eb 8f		 jmp	 SHORT $LN24@compiler_m@2
compiler_mod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KFOBDMCC@no?5symtable?$AA@		; `string'
PUBLIC	??_C@_07DIBBIFIJ@__doc__?$AA@			; `string'
PUBLIC	PyAST_CompileEx
EXTRN	PySymtable_Build:PROC
EXTRN	PyFuture_FromAST:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_CompileEx DD imagerel $LN12
	DD	imagerel $LN12+322
	DD	imagerel $unwind$PyAST_CompileEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_CompileEx DD 0a1d01H
	DD	015741dH
	DD	014641dH
	DD	013541dH
	DD	012341dH
	DD	0c016f21dH
xdata	ENDS
;	COMDAT ??_C@_0M@KFOBDMCC@no?5symtable?$AA@
CONST	SEGMENT
??_C@_0M@KFOBDMCC@no?5symtable?$AA@ DB 'no symtable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIBBIFIJ@__doc__?$AA@
CONST	SEGMENT
??_C@_07DIBBIFIJ@__doc__?$AA@ DB '__doc__', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyAST_CompileEx
_TEXT	SEGMENT
local_flags$ = 32
c$ = 48
mod$ = 144
filename$ = 152
flags$ = 160
optimize$ = 168
arena$ = 176
PyAST_CompileEx PROC					; COMDAT

; 293  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 294  :     struct compiler c;
; 295  :     PyCodeObject *co = NULL;

  0001d	33 db		 xor	 ebx, ebx
  0001f	45 8b e1	 mov	 r12d, r9d
  00022	49 8b f0	 mov	 rsi, r8

; 296  :     PyCompilerFlags local_flags;
; 297  :     int merged;
; 298  : 
; 299  :     if (!__doc__) {

  00025	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR __doc__, rbx
  0002c	48 8b fa	 mov	 rdi, rdx
  0002f	48 8b e9	 mov	 rbp, rcx
  00032	75 1f		 jne	 SHORT $LN7@PyAST_Comp

; 300  :         __doc__ = PyUnicode_InternFromString("__doc__");

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DIBBIFIJ@__doc__?$AA@
  0003b	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00040	48 89 05 00 00
	00 00		 mov	 QWORD PTR __doc__, rax

; 301  :         if (!__doc__)

  00047	48 85 c0	 test	 rax, rax
  0004a	75 07		 jne	 SHORT $LN7@PyAST_Comp
$LN11@PyAST_Comp:

; 302  :             return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 d1 00 00 00	 jmp	 $LN9@PyAST_Comp
$LN7@PyAST_Comp:

; 303  :     }
; 304  : 
; 305  :     if (!compiler_init(&c))

  00053	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  00058	e8 00 00 00 00	 call	 compiler_init
  0005d	85 c0		 test	 eax, eax

; 306  :         return NULL;

  0005f	74 eb		 je	 SHORT $LN11@PyAST_Comp

; 307  :     c.c_filename = filename;
; 308  :     c.c_filename_obj = PyUnicode_DecodeFSDefault(filename);

  00061	48 8b cf	 mov	 rcx, rdi
  00064	48 89 7c 24 30	 mov	 QWORD PTR c$[rsp], rdi
  00069	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
  0006e	48 89 44 24 38	 mov	 QWORD PTR c$[rsp+8], rax

; 309  :     if (!c.c_filename_obj)

  00073	48 85 c0	 test	 rax, rax
  00076	0f 84 9b 00 00
	00		 je	 $finally$22078

; 310  :         goto finally;
; 311  :     c.c_arena = arena;

  0007c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR arena$[rsp]

; 312  :     c.c_future = PyFuture_FromAST(mod, filename);

  00084	48 8b d7	 mov	 rdx, rdi
  00087	48 8b cd	 mov	 rcx, rbp
  0008a	48 89 44 24 78	 mov	 QWORD PTR c$[rsp+72], rax
  0008f	e8 00 00 00 00	 call	 PyFuture_FromAST
  00094	48 89 44 24 48	 mov	 QWORD PTR c$[rsp+24], rax

; 313  :     if (c.c_future == NULL)

  00099	48 85 c0	 test	 rax, rax
  0009c	74 79		 je	 SHORT $finally$22078

; 314  :         goto finally;
; 315  :     if (!flags) {

  0009e	48 85 f6	 test	 rsi, rsi
  000a1	75 09		 jne	 SHORT $LN3@PyAST_Comp

; 316  :         local_flags.cf_flags = 0;

  000a3	89 5c 24 20	 mov	 DWORD PTR local_flags$[rsp], ebx

; 317  :         flags = &local_flags;

  000a7	48 8d 74 24 20	 lea	 rsi, QWORD PTR local_flags$[rsp]
$LN3@PyAST_Comp:

; 318  :     }
; 319  :     merged = c.c_future->ff_features | flags->cf_flags;

  000ac	8b 08		 mov	 ecx, DWORD PTR [rax]

; 320  :     c.c_future->ff_features = merged;
; 321  :     flags->cf_flags = merged;
; 322  :     c.c_flags = flags;
; 323  :     c.c_optimize = (optimize == -1) ? Py_OptimizeFlag : optimize;
; 324  :     c.c_nestlevel = 0;
; 325  : 
; 326  :     c.c_st = PySymtable_Build(mod, filename, c.c_future);

  000ae	48 8b d7	 mov	 rdx, rdi
  000b1	0b 0e		 or	 ecx, DWORD PTR [rsi]
  000b3	41 83 fc ff	 cmp	 r12d, -1
  000b7	89 08		 mov	 DWORD PTR [rax], ecx
  000b9	4c 8b 44 24 48	 mov	 r8, QWORD PTR c$[rsp+24]
  000be	89 0e		 mov	 DWORD PTR [rsi], ecx
  000c0	44 0f 44 25 00
	00 00 00	 cmove	 r12d, DWORD PTR Py_OptimizeFlag
  000c8	48 8b cd	 mov	 rcx, rbp
  000cb	48 89 74 24 50	 mov	 QWORD PTR c$[rsp+32], rsi
  000d0	44 89 64 24 58	 mov	 DWORD PTR c$[rsp+40], r12d
  000d5	89 5c 24 60	 mov	 DWORD PTR c$[rsp+48], ebx
  000d9	e8 00 00 00 00	 call	 PySymtable_Build
  000de	48 89 44 24 40	 mov	 QWORD PTR c$[rsp+16], rax

; 327  :     if (c.c_st == NULL) {

  000e3	48 85 c0	 test	 rax, rax
  000e6	75 1f		 jne	 SHORT $LN2@PyAST_Comp

; 328  :         if (!PyErr_Occurred())

  000e8	e8 00 00 00 00	 call	 PyErr_Occurred
  000ed	48 85 c0	 test	 rax, rax
  000f0	75 25		 jne	 SHORT $finally$22078

; 329  :             PyErr_SetString(PyExc_SystemError, "no symtable");

  000f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KFOBDMCC@no?5symtable?$AA@
  00100	e8 00 00 00 00	 call	 PyErr_SetString

; 330  :         goto finally;

  00105	eb 10		 jmp	 SHORT $finally$22078
$LN2@PyAST_Comp:

; 331  :     }
; 332  : 
; 333  :     co = compiler_mod(&c, mod);

  00107	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  0010c	48 8b d5	 mov	 rdx, rbp
  0010f	e8 00 00 00 00	 call	 compiler_mod
  00114	48 8b d8	 mov	 rbx, rax
$finally$22078:

; 334  : 
; 335  :  finally:
; 336  :     compiler_free(&c);

  00117	48 8d 4c 24 30	 lea	 rcx, QWORD PTR c$[rsp]
  0011c	e8 00 00 00 00	 call	 compiler_free

; 337  :     assert(co || PyErr_Occurred());
; 338  :     return co;

  00121	48 8b c3	 mov	 rax, rbx
$LN9@PyAST_Comp:

; 339  : }

  00124	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  0012c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00130	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00134	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00138	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  0013c	49 8b e3	 mov	 rsp, r11
  0013f	41 5c		 pop	 r12
  00141	c3		 ret	 0
PyAST_CompileEx ENDP
_TEXT	ENDS
PUBLIC	PyNode_Compile
EXTRN	PyArena_Free:PROC
EXTRN	PyAST_FromNode:PROC
EXTRN	PyArena_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNode_Compile DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$PyNode_Compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNode_Compile DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyNode_Compile
_TEXT	SEGMENT
n$ = 64
filename$ = 72
PyNode_Compile PROC					; COMDAT

; 343  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 344  :     PyCodeObject *co = NULL;

  0001a	33 ff		 xor	 edi, edi

; 345  :     mod_ty mod;
; 346  :     PyArena *arena = PyArena_New();

  0001c	e8 00 00 00 00	 call	 PyArena_New
  00021	48 8b d8	 mov	 rbx, rax

; 347  :     if (!arena)

  00024	48 85 c0	 test	 rax, rax
  00027	74 3a		 je	 SHORT $LN3@PyNode_Com
$LN2@PyNode_Com:

; 348  :         return NULL;
; 349  :     mod = PyAST_FromNode(n, NULL, filename, arena);

  00029	4c 8b c8	 mov	 r9, rax
  0002c	4c 8b c6	 mov	 r8, rsi
  0002f	33 d2		 xor	 edx, edx
  00031	48 8b cd	 mov	 rcx, rbp
  00034	e8 00 00 00 00	 call	 PyAST_FromNode

; 350  :     if (mod)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 1a		 je	 SHORT $LN1@PyNode_Com

; 351  :         co = PyAST_Compile(mod, filename, NULL, arena);

  0003e	41 83 c9 ff	 or	 r9d, -1
  00042	45 33 c0	 xor	 r8d, r8d
  00045	48 8b d6	 mov	 rdx, rsi
  00048	48 8b c8	 mov	 rcx, rax
  0004b	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00050	e8 00 00 00 00	 call	 PyAST_CompileEx
  00055	48 8b f8	 mov	 rdi, rax
$LN1@PyNode_Com:

; 352  :     PyArena_Free(arena);

  00058	48 8b cb	 mov	 rcx, rbx
  0005b	e8 00 00 00 00	 call	 PyArena_Free

; 353  :     return co;

  00060	48 8b c7	 mov	 rax, rdi
$LN3@PyNode_Com:

; 354  : }

  00063	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00068	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0006d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
PyNode_Compile ENDP
_TEXT	ENDS
PUBLIC	PyAST_Compile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_Compile DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$PyAST_Compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_Compile DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyAST_Compile
_TEXT	SEGMENT
mod$ = 64
filename$ = 72
flags$ = 80
arena$ = 88
PyAST_Compile PROC					; COMDAT

; 4258 : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4259 :     return PyAST_CompileEx(mod, filename, flags, -1, arena);

  00004	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00009	41 83 c9 ff	 or	 r9d, -1
  0000d	e8 00 00 00 00	 call	 PyAST_CompileEx

; 4260 : }

  00012	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00016	c3		 ret	 0
PyAST_Compile ENDP
_TEXT	ENDS
END
