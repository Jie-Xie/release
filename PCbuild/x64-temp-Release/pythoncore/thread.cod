; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@	; `string'
PUBLIC	??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@ ; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@ ; `string'
PUBLIC	??_C@_04MKMCLCOO@lock?$AA@			; `string'
PUBLIC	??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
_BSS	SEGMENT
_pythread_stacksize DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@
CONST	SEGMENT
??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@ DB 'sys.thread_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@
CONST	SEGMENT
??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@ DB 'name and v'
	DB	'ersion of the thread library', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@
CONST	SEGMENT
??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@ DB 'name of t'
	DB	'he lock implementation', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKMCLCOO@lock?$AA@
CONST	SEGMENT
??_C@_04MKMCLCOO@lock?$AA@ DB 'lock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@
CONST	SEGMENT
??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@ DB 'name of the '
	DB	'thread implementation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
threadinfo__doc__ DB 'sys.thread_info', 0aH, 0aH, 'A struct sequence hold'
	DB	'ing information about the thread implementation.', 00H
	ORG $+8
threadinfo_fields DQ FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@
	DQ	FLAT:??_C@_04MKMCLCOO@lock?$AA@
	DQ	FLAT:??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@
	DQ	FLAT:??_C@_07CPCPJPKL@version?$AA@
	DQ	FLAT:??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@
	DQ	0000000000000000H
	ORG $+8
threadinfo_desc DQ FLAT:??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@
	DQ	FLAT:threadinfo__doc__
	DQ	FLAT:threadinfo_fields
	DD	03H
	ORG $+4
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	__imp_InitializeCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_INIT DD imagerel PyMUTEX_INIT
	DD	imagerel PyMUTEX_INIT+17
	DD	imagerel $unwind$PyMUTEX_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_INIT DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_INIT
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_INIT PROC					; COMDAT

; 175  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     InitializeCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 177  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 178  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_DeleteCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_FINI DD imagerel PyMUTEX_FINI
	DD	imagerel PyMUTEX_FINI+17
	DD	imagerel $unwind$PyMUTEX_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_FINI
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_FINI PROC					; COMDAT

; 182  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     DeleteCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 184  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 185  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_FINI ENDP
_TEXT	ENDS
EXTRN	__imp_EnterCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_LOCK DD imagerel PyMUTEX_LOCK
	DD	imagerel PyMUTEX_LOCK+17
	DD	imagerel $unwind$PyMUTEX_LOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_LOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_LOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_LOCK PROC					; COMDAT

; 189  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     EnterCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 191  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 192  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_LOCK ENDP
_TEXT	ENDS
EXTRN	__imp_LeaveCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_UNLOCK DD imagerel PyMUTEX_UNLOCK
	DD	imagerel PyMUTEX_UNLOCK+17
	DD	imagerel $unwind$PyMUTEX_UNLOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_UNLOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_UNLOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_UNLOCK PROC					; COMDAT

; 196  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     LeaveCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 198  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 199  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_UNLOCK ENDP
_TEXT	ENDS
EXTRN	__imp_CreateSemaphoreA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_INIT DD imagerel PyCOND_INIT
	DD	imagerel PyCOND_INIT+60
	DD	imagerel $unwind$PyCOND_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_INIT DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_INIT
_TEXT	SEGMENT
cv$ = 48
PyCOND_INIT PROC					; COMDAT

; 213  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 214  :     /* A semaphore with a "large" max value,  The positive value
; 215  :      * is only needed to catch those "lost wakeup" events and
; 216  :      * race conditions when a timed wait elapses.
; 217  :      */
; 218  :     cv->sem = CreateSemaphore(NULL, 0, 100000, NULL);

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	33 d2		 xor	 edx, edx
  0000e	33 c9		 xor	 ecx, ecx
  00010	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 219  :     if (cv->sem==NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	75 09		 jne	 SHORT $LN1@PyCOND_INI

; 220  :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 223  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN1@PyCOND_INI:

; 221  :     cv->waiting = 0;

  0002d	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [rbx+8], 0

; 222  :     return 0;

  00034	33 c0		 xor	 eax, eax

; 223  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
PyCOND_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_CloseHandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_FINI DD imagerel PyCOND_FINI
	DD	imagerel PyCOND_FINI+26
	DD	imagerel $unwind$PyCOND_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_FINI
_TEXT	SEGMENT
cv$ = 48
PyCOND_FINI PROC					; COMDAT

; 227  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 228  :     return CloseHandle(cv->sem) ? 0 : -1;

  00004	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0000d	f7 d8		 neg	 eax
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax
  00013	ff c8		 dec	 eax

; 229  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
PyCOND_FINI ENDP
_TEXT	ENDS
EXTRN	__imp_WaitForSingleObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCOND_WAIT_MS DD imagerel _PyCOND_WAIT_MS
	DD	imagerel _PyCOND_WAIT_MS+112
	DD	imagerel $unwind$_PyCOND_WAIT_MS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCOND_WAIT_MS DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyCOND_WAIT_MS
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
ms$ = 64
_PyCOND_WAIT_MS PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 237  :     DWORD wait;
; 238  :     cv->waiting++;

  0000f	ff 41 08	 inc	 DWORD PTR [rcx+8]
  00012	48 8b f1	 mov	 rsi, rcx

; 239  :     PyMUTEX_UNLOCK(cs);

  00015	48 8b ca	 mov	 rcx, rdx
  00018	41 8b d8	 mov	 ebx, r8d
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 240  :     /* "lost wakeup bug" would occur if the caller were interrupted here,
; 241  :      * but we are safe because we are using a semaphore wich has an internal
; 242  :      * count.
; 243  :      */
; 244  :     wait = WaitForSingleObject(cv->sem, ms);

  00024	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00027	8b d3		 mov	 edx, ebx
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 245  :     PyMUTEX_LOCK(cs);

  0002f	48 8b cf	 mov	 rcx, rdi
  00032	8b d8		 mov	 ebx, eax
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 246  :     if (wait != WAIT_OBJECT_0)

  0003a	85 db		 test	 ebx, ebx
  0003c	74 03		 je	 SHORT $LN2@PyCOND_WAI

; 247  :         --cv->waiting;

  0003e	ff 4e 08	 dec	 DWORD PTR [rsi+8]
$LN2@PyCOND_WAI:

; 248  :         /* Here we have a benign race condition with PyCOND_SIGNAL.
; 249  :          * When failure occurs or timeout, it is possible that
; 250  :          * PyCOND_SIGNAL also decrements this value
; 251  :          * and signals releases the mutex.  This is benign because it
; 252  :          * just means an extra spurious wakeup for a waiting thread.
; 253  :          * ('waiting' corresponds to the semaphore's "negative" count and
; 254  :          * we may end up with e.g. (waiting == -1 && sem.count == 1).  When
; 255  :          * a new thread comes along, it will pass right throuhgh, having
; 256  :          * adjusted it to (waiting == 0 && sem.count == 0).
; 257  :          */
; 258  :          
; 259  :     if (wait == WAIT_FAILED)

  00041	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00044	75 13		 jne	 SHORT $LN1@PyCOND_WAI

; 260  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 261  :     /* return 0 on success, 1 on timeout */
; 262  :     return wait != WAIT_OBJECT_0;
; 263  : }

  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN1@PyCOND_WAI:
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	33 c0		 xor	 eax, eax
  00060	85 db		 test	 ebx, ebx
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	0f 95 c0	 setne	 al
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
_PyCOND_WAIT_MS ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_WAIT DD imagerel PyCOND_WAIT
	DD	imagerel PyCOND_WAIT+103
	DD	imagerel $unwind$PyCOND_WAIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_WAIT DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_WAIT
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
PyCOND_WAIT PROC					; COMDAT

; 267  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 268  :     int result = _PyCOND_WAIT_MS(cv, cs, INFINITE);

  0000f	ff 41 08	 inc	 DWORD PTR [rcx+8]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 8b ca	 mov	 rcx, rdx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00021	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00024	83 ca ff	 or	 edx, -1			; ffffffffH
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	8b f0		 mov	 esi, eax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00038	85 f6		 test	 esi, esi
  0003a	74 03		 je	 SHORT $LN4@PyCOND_WAI@2
  0003c	ff 4f 08	 dec	 DWORD PTR [rdi+8]
$LN4@PyCOND_WAI@2:
  0003f	33 c9		 xor	 ecx, ecx
  00041	83 fe ff	 cmp	 esi, -1			; ffffffffH
  00044	75 05		 jne	 SHORT $LN3@PyCOND_WAI@2
  00046	83 c8 ff	 or	 eax, -1
  00049	eb 07		 jmp	 SHORT $LN5@PyCOND_WAI@2
$LN3@PyCOND_WAI@2:
  0004b	85 f6		 test	 esi, esi
  0004d	8b c1		 mov	 eax, ecx
  0004f	0f 95 c0	 setne	 al
$LN5@PyCOND_WAI@2:

; 269  :     return result >= 0 ? 0 : result;
; 270  : }

  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005c	85 c0		 test	 eax, eax
  0005e	0f 49 c1	 cmovns	 eax, ecx
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
PyCOND_WAIT ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT PyCOND_TIMEDWAIT
_TEXT	SEGMENT
cv$ = 8
cs$ = 16
us$ = 24
PyCOND_TIMEDWAIT PROC					; COMDAT

; 274  : {

  00000	4c 8b ca	 mov	 r9, rdx

; 275  :     return _PyCOND_WAIT_MS(cv, cs, us/1000);

  00003	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00008	41 f7 e8	 imul	 r8d
  0000b	c1 fa 06	 sar	 edx, 6
  0000e	44 8b c2	 mov	 r8d, edx
  00011	41 c1 e8 1f	 shr	 r8d, 31
  00015	44 03 c2	 add	 r8d, edx
  00018	49 8b d1	 mov	 rdx, r9

; 276  : }

  0001b	e9 00 00 00 00	 jmp	 _PyCOND_WAIT_MS
PyCOND_TIMEDWAIT ENDP
_TEXT	ENDS
EXTRN	__imp_ReleaseSemaphore:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_SIGNAL DD imagerel PyCOND_SIGNAL
	DD	imagerel PyCOND_SIGNAL+52
	DD	imagerel $unwind$PyCOND_SIGNAL
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_SIGNAL DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_SIGNAL
_TEXT	SEGMENT
cv$ = 48
PyCOND_SIGNAL PROC					; COMDAT

; 280  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 281  :     /* this test allows PyCOND_SIGNAL to be a no-op unless required
; 282  :      * to wake someone up, thus preventing an unbounded increase of
; 283  :      * the semaphore's internal counter.
; 284  :      */
; 285  :     if (cv->waiting > 0) {

  00004	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00007	85 c0		 test	 eax, eax
  00009	7e 22		 jle	 SHORT $LN1@PyCOND_SIG

; 286  :         /* notifying thread decreases the cv->waiting count so that
; 287  :          * a delay between notify and actual wakeup of the target thread
; 288  :          * doesn't cause a number of extra ReleaseSemaphore calls.
; 289  :          */
; 290  :         cv->waiting--;

  0000b	ff c8		 dec	 eax

; 291  :         return ReleaseSemaphore(cv->sem, 1, NULL) ? 0 : -1;

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  00020	f7 d8		 neg	 eax
  00022	1b c0		 sbb	 eax, eax
  00024	f7 d8		 neg	 eax
  00026	ff c8		 dec	 eax

; 294  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyCOND_SIG:

; 292  :     }
; 293  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 294  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
PyCOND_SIGNAL ENDP
_TEXT	ENDS
PUBLIC	AllocNonRecursiveMutex
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllocNonRecursiveMutex DD imagerel $LN15
	DD	imagerel $LN15+99
	DD	imagerel $unwind$AllocNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocNonRecursiveMutex DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread_nt.h
xdata	ENDS
;	COMDAT AllocNonRecursiveMutex
_TEXT	SEGMENT
AllocNonRecursiveMutex PROC				; COMDAT

; 36   : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 37   :     PNRMUTEX m = (PNRMUTEX)malloc(sizeof(NRMUTEX));

  00006	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00011	48 8b d8	 mov	 rbx, rax

; 38   :     if (!m)

  00014	48 85 c0	 test	 rax, rax

; 39   :         return NULL;

  00017	74 42		 je	 SHORT $LN14@AllocNonRe

; 40   :     if (PyCOND_INIT(&m->cv))

  00019	45 33 c9	 xor	 r9d, r9d
  0001c	33 d2		 xor	 edx, edx
  0001e	33 c9		 xor	 ecx, ecx
  00020	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
$fail$120743:

; 41   :         goto fail;
; 42   :     if (PyMUTEX_INIT(&m->cs)) {

  0002c	48 8b cb	 mov	 rcx, rbx
  0002f	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00033	48 85 c0	 test	 rax, rax
  00036	74 1d		 je	 SHORT $LN13@AllocNonRe
  00038	c7 43 30 00 00
	00 00		 mov	 DWORD PTR [rbx+48], 0
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 43   :         PyCOND_FINI(&m->cv);
; 44   :         goto fail;
; 45   :     }
; 46   :     m->locked = 0;

  00045	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [rbx+56], 0

; 47   :     return m;

  0004c	48 8b c3	 mov	 rax, rbx

; 51   : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN13@AllocNonRe:

; 48   : fail:
; 49   :     free(m);

  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN14@AllocNonRe:

; 50   :     return NULL;

  0005b	33 c0		 xor	 eax, eax

; 51   : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
AllocNonRecursiveMutex ENDP
_TEXT	ENDS
PUBLIC	FreeNonRecursiveMutex
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$FreeNonRecursiveMutex DD imagerel $LN9
	DD	imagerel $LN9+48
	DD	imagerel $unwind$FreeNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreeNonRecursiveMutex DD 020a01H
	DD	03006320aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread_nt.h
xdata	ENDS
;	COMDAT FreeNonRecursiveMutex
_TEXT	SEGMENT
mutex$ = 48
FreeNonRecursiveMutex PROC				; COMDAT

; 55   : {

$LN9:

; 56   :     if (mutex) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 29		 je	 SHORT $LN8@FreeNonRec
  00005	53		 push	 rbx
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 55   : {

  0000a	48 8b d9	 mov	 rbx, rcx

; 57   :         PyCOND_FINI(&mutex->cv);

  0000d	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 58   :         PyMUTEX_FINI(&mutex->cs);

  00017	48 8b cb	 mov	 rcx, rbx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 59   :         free(mutex);

  00020	48 8b cb	 mov	 rcx, rbx
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 60   :     }
; 61   : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
$LN8@FreeNonRec:
  0002e	f3 c3		 fatret	 0
FreeNonRecursiveMutex ENDP
_TEXT	ENDS
PUBLIC	EnterNonRecursiveMutex
EXTRN	__imp_GetTickCount:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$EnterNonRecursiveMutex DD imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$EnterNonRecursiveMutex DD imagerel $LN50+18
	DD	imagerel $LN50+147
	DD	imagerel $chain$0$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$EnterNonRecursiveMutex DD imagerel $LN50+147
	DD	imagerel $LN50+285
	DD	imagerel $chain$1$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$EnterNonRecursiveMutex DD imagerel $LN50+285
	DD	imagerel $LN50+295
	DD	imagerel $chain$2$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$EnterNonRecursiveMutex DD imagerel $LN50+295
	DD	imagerel $LN50+346
	DD	imagerel $chain$3$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$EnterNonRecursiveMutex DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$EnterNonRecursiveMutex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$EnterNonRecursiveMutex DD 021H
	DD	imagerel $LN50+18
	DD	imagerel $LN50+147
	DD	imagerel $chain$0$EnterNonRecursiveMutex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$EnterNonRecursiveMutex DD 020521H
	DD	065405H
	DD	imagerel $LN50+18
	DD	imagerel $LN50+147
	DD	imagerel $chain$0$EnterNonRecursiveMutex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$EnterNonRecursiveMutex DD 020521H
	DD	077405H
	DD	imagerel $LN50
	DD	imagerel $LN50+18
	DD	imagerel $unwind$EnterNonRecursiveMutex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EnterNonRecursiveMutex DD 061001H
	DD	096410H
	DD	083410H
	DD	0c00c3210H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread_nt.h
xdata	ENDS
;	COMDAT EnterNonRecursiveMutex
_TEXT	SEGMENT
mutex$ = 48
milliseconds$ = 56
EnterNonRecursiveMutex PROC				; COMDAT

; 65   : {

$LN50:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 66   :     DWORD result = WAIT_OBJECT_0;

  00010	33 f6		 xor	 esi, esi
  00012	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	44 8b e6	 mov	 r12d, esi
  0001d	8b fa		 mov	 edi, edx

; 67   :     if (PyMUTEX_LOCK(&mutex->cs))

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 68   :         return WAIT_FAILED;
; 69   :     if (milliseconds == INFINITE) {

  00025	83 ff ff	 cmp	 edi, -1			; ffffffffH
  00028	75 61		 jne	 SHORT $LN13@EnterNonRe

; 70   :         while (mutex->locked) {

  0002a	39 73 38	 cmp	 DWORD PTR [rbx+56], esi
  0002d	0f 84 ea 00 00
	00		 je	 $LN45@EnterNonRe
$LL12@EnterNonRe:

; 71   :             if (PyCOND_WAIT(&mutex->cv, &mutex->cs)) {

  00033	ff 43 30	 inc	 DWORD PTR [rbx+48]
  00036	48 8b cb	 mov	 rcx, rbx
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  0003f	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00043	83 ca ff	 or	 edx, -1			; ffffffffH
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	8b f8		 mov	 edi, eax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00057	85 ff		 test	 edi, edi
  00059	74 03		 je	 SHORT $LN22@EnterNonRe
  0005b	ff 4b 30	 dec	 DWORD PTR [rbx+48]
$LN22@EnterNonRe:
  0005e	83 ff ff	 cmp	 edi, -1			; ffffffffH
  00061	75 05		 jne	 SHORT $LN21@EnterNonRe
  00063	83 c8 ff	 or	 eax, -1
  00066	eb 07		 jmp	 SHORT $LN23@EnterNonRe
$LN21@EnterNonRe:
  00068	85 ff		 test	 edi, edi
  0006a	8b c6		 mov	 eax, esi
  0006c	0f 95 c0	 setne	 al
$LN23@EnterNonRe:
  0006f	85 c0		 test	 eax, eax
  00071	0f 49 c6	 cmovns	 eax, esi
  00074	85 c0		 test	 eax, eax
  00076	75 0a		 jne	 SHORT $LN43@EnterNonRe

; 70   :         while (mutex->locked) {

  00078	39 73 38	 cmp	 DWORD PTR [rbx+56], esi
  0007b	75 b6		 jne	 SHORT $LL12@EnterNonRe

; 85   :             if (target <= now)

  0007d	e9 9b 00 00 00	 jmp	 $LN45@EnterNonRe
$LN43@EnterNonRe:

; 72   :                 result = WAIT_FAILED;

  00082	41 83 cc ff	 or	 r12d, -1		; ffffffffH

; 73   :                 break;
; 74   :             }
; 75   :         }
; 76   :     } else if (milliseconds != 0) {

  00086	e9 92 00 00 00	 jmp	 $LN45@EnterNonRe
$LN13@EnterNonRe:
  0008b	85 ff		 test	 edi, edi
  0008d	0f 84 8a 00 00
	00		 je	 $LN45@EnterNonRe

; 77   :         /* wait at least until the target */
; 78   :         DWORD now, target = GetTickCount() + milliseconds;

  00093	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0009e	8d 2c 07	 lea	 ebp, DWORD PTR [rdi+rax]

; 79   :         while (mutex->locked) {

  000a1	39 73 38	 cmp	 DWORD PTR [rbx+56], esi
  000a4	74 72		 je	 SHORT $LN49@EnterNonRe
  000a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@EnterNonRe:

; 80   :             if (PyCOND_TIMEDWAIT(&mutex->cv, &mutex->cs, milliseconds*1000) < 0) {

  000b0	ff 43 30	 inc	 DWORD PTR [rbx+48]
  000b3	48 8b cb	 mov	 rcx, rbx
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  000bc	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  000c0	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  000c5	69 ff e8 03 00
	00		 imul	 edi, 1000		; 000003e8H
  000cb	f7 ef		 imul	 edi
  000cd	c1 fa 06	 sar	 edx, 6
  000d0	8b c2		 mov	 eax, edx
  000d2	c1 e8 1f	 shr	 eax, 31
  000d5	03 d0		 add	 edx, eax
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000dd	48 8b cb	 mov	 rcx, rbx
  000e0	8b f8		 mov	 edi, eax
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000e8	85 ff		 test	 edi, edi
  000ea	74 03		 je	 SHORT $LN32@EnterNonRe
  000ec	ff 4b 30	 dec	 DWORD PTR [rbx+48]
$LN32@EnterNonRe:
  000ef	83 ff ff	 cmp	 edi, -1			; ffffffffH
  000f2	74 20		 je	 SHORT $LN44@EnterNonRe
  000f4	85 ff		 test	 edi, edi
  000f6	8b ce		 mov	 ecx, esi
  000f8	0f 95 c1	 setne	 cl
  000fb	85 c9		 test	 ecx, ecx
  000fd	78 15		 js	 SHORT $LN44@EnterNonRe

; 82   :                 break;
; 83   :             }
; 84   :             now = GetTickCount();

  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount

; 85   :             if (target <= now)

  00105	3b e8		 cmp	 ebp, eax
  00107	76 0f		 jbe	 SHORT $LN49@EnterNonRe

; 86   :                 break;
; 87   :             milliseconds = target-now;

  00109	8b fd		 mov	 edi, ebp
  0010b	2b f8		 sub	 edi, eax
  0010d	39 73 38	 cmp	 DWORD PTR [rbx+56], esi
  00110	75 9e		 jne	 SHORT $LL7@EnterNonRe

; 79   :         while (mutex->locked) {

  00112	eb 04		 jmp	 SHORT $LN49@EnterNonRe
$LN44@EnterNonRe:

; 81   :                 result = WAIT_FAILED;

  00114	41 83 cc ff	 or	 r12d, -1		; ffffffffH
$LN49@EnterNonRe:
  00118	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN45@EnterNonRe:
  0011d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 88   :         }
; 89   :     }
; 90   :     if (!mutex->locked) {

  00122	39 73 38	 cmp	 DWORD PTR [rbx+56], esi
  00125	75 09		 jne	 SHORT $LN3@EnterNonRe

; 91   :         mutex->locked = 1;

  00127	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [rbx+56], 1

; 92   :         result = WAIT_OBJECT_0;

  0012e	eb 0e		 jmp	 SHORT $LN1@EnterNonRe
$LN3@EnterNonRe:

; 93   :     } else if (result == WAIT_OBJECT_0)

  00130	41 8b f4	 mov	 esi, r12d
  00133	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00138	45 85 e4	 test	 r12d, r12d
  0013b	0f 44 f0	 cmove	 esi, eax
$LN1@EnterNonRe:

; 94   :         result = WAIT_TIMEOUT;
; 95   :     /* else, it is WAIT_FAILED */
; 96   :     PyMUTEX_UNLOCK(&mutex->cs); /* must ignore result here */

  0013e	48 8b cb	 mov	 rcx, rbx
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 97   :     return result;
; 98   : }

  00147	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014c	8b c6		 mov	 eax, esi
  0014e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00153	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00157	41 5c		 pop	 r12
  00159	c3		 ret	 0
EnterNonRecursiveMutex ENDP
_TEXT	ENDS
PUBLIC	LeaveNonRecursiveMutex
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$LeaveNonRecursiveMutex DD imagerel $LN11
	DD	imagerel $LN11+68
	DD	imagerel $unwind$LeaveNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LeaveNonRecursiveMutex DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread_nt.h
xdata	ENDS
;	COMDAT LeaveNonRecursiveMutex
_TEXT	SEGMENT
mutex$ = 48
LeaveNonRecursiveMutex PROC				; COMDAT

; 102  : {

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 103  :     BOOL result;
; 104  :     if (PyMUTEX_LOCK(&mutex->cs))

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 105  :         return FALSE;
; 106  :     mutex->locked = 0;

  0000f	c7 43 38 00 00
	00 00		 mov	 DWORD PTR [rbx+56], 0

; 107  :     result = PyCOND_SIGNAL(&mutex->cv);

  00016	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00019	85 c0		 test	 eax, eax
  0001b	7e 16		 jle	 SHORT $LN6@LeaveNonRe
  0001d	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00021	45 33 c0	 xor	 r8d, r8d
  00024	ff c8		 dec	 eax
  00026	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0002a	89 43 30	 mov	 DWORD PTR [rbx+48], eax
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN6@LeaveNonRe:

; 108  :     result &= PyMUTEX_UNLOCK(&mutex->cs);

  00033	48 8b cb	 mov	 rcx, rbx
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 109  :     return result;

  0003c	33 c0		 xor	 eax, eax

; 110  : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
LeaveNonRecursiveMutex ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT PyThread__init_thread
_TEXT	SEGMENT
PyThread__init_thread PROC				; COMDAT

; 151  : }

  00000	c2 00 00	 ret	 0
PyThread__init_thread ENDP
_TEXT	ENDS
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_GetProcessHeap:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bootstrap DD imagerel bootstrap
	DD	imagerel bootstrap+71
	DD	imagerel $unwind$bootstrap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bootstrap DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bootstrap
_TEXT	SEGMENT
call$ = 48
bootstrap PROC						; COMDAT

; 170  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 171  :     callobj *obj = (callobj*)call;
; 172  :     void (*func)(void*) = obj->func;

  0000f	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 173  :     void *arg = obj->arg;

  00012	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00016	48 8b d9	 mov	 rbx, rcx

; 174  :     HeapFree(GetProcessHeap(), 0, obj);

  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  0001f	4c 8b c3	 mov	 r8, rbx
  00022	33 d2		 xor	 edx, edx
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapFree

; 175  :     func(arg);

  0002d	48 8b cf	 mov	 rcx, rdi
  00030	48 8b c6	 mov	 rax, rsi
  00033	ff d0		 call	 rax

; 176  :     return 0;
; 177  : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003f	33 c0		 xor	 eax, eax
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
bootstrap ENDP
_TEXT	ENDS
PUBLIC	PyThread_exit_thread
EXTRN	__imp__endthreadex:PROC
EXTRN	__imp_exit:PROC
_BSS	SEGMENT
initialized DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_exit_thread DD imagerel $LN5
	DD	imagerel $LN5+32
	DD	imagerel $unwind$PyThread_exit_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_exit_thread DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_exit_thread
_TEXT	SEGMENT
PyThread_exit_thread PROC				; COMDAT

; 248  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 249  :     dprintf(("%ld: PyThread_exit_thread called\n", PyThread_get_thread_ident()));
; 250  :     if (!initialized)
; 251  :         exit(0);

  00004	33 c9		 xor	 ecx, ecx
  00006	39 0d 00 00 00
	00		 cmp	 DWORD PTR initialized, ecx
  0000c	75 07		 jne	 SHORT $LN1@PyThread_e
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00014	cc		 int	 3
$LN1@PyThread_e:

; 252  : #if defined(MS_WINCE)
; 253  :     ExitThread(0);
; 254  : #else
; 255  :     _endthreadex(0);
; 256  : #endif
; 257  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__endthreadex
$LN4@PyThread_e:
PyThread_exit_thread ENDP
_TEXT	ENDS
PUBLIC	PyThread_free_lock
; Function compile flags: /Ogtpy
;	COMDAT PyThread_free_lock
_TEXT	SEGMENT
aLock$ = 8
PyThread_free_lock PROC					; COMDAT

; 283  :     dprintf(("%ld: PyThread_free_lock(%p) called\n", PyThread_get_thread_ident(),aLock));
; 284  : 
; 285  :     FreeNonRecursiveMutex(aLock) ;
; 286  : }

  00000	e9 00 00 00 00	 jmp	 FreeNonRecursiveMutex
PyThread_free_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@ ; `string'
PUBLIC	PyThread_acquire_lock_timed
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_acquire_lock_timed DD imagerel $LN9
	DD	imagerel $LN9+146
	DD	imagerel $unwind$PyThread_acquire_lock_timed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_acquire_lock_timed DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@
CONST	SEGMENT
??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@ DB 'Timeout t'
	DB	'oo large for a DWORD, please check PY_TIMEOUT_MAX', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyThread_acquire_lock_timed
_TEXT	SEGMENT
aLock$ = 48
microseconds$ = 56
intr_flag$ = 64
PyThread_acquire_lock_timed PROC			; COMDAT

; 297  : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4c 8b c2	 mov	 r8, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 298  :     /* Fow now, intr_flag does nothing on Windows, and lock acquires are
; 299  :      * uninterruptible.  */
; 300  :     PyLockStatus success;
; 301  :     PY_TIMEOUT_T milliseconds;
; 302  : 
; 303  :     if (microseconds >= 0) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	78 48		 js	 SHORT $LN6@PyThread_a

; 304  :         milliseconds = microseconds / 1000;

  00015	48 b8 cf f7 53
	e3 a5 9b c4 20	 mov	 rax, 2361183241434822607 ; 20c49ba5e353f7cfH
  0001f	49 f7 e8	 imul	 r8
  00022	48 8b da	 mov	 rbx, rdx
  00025	48 c1 fb 07	 sar	 rbx, 7
  00029	48 8b c3	 mov	 rax, rbx
  0002c	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00030	48 03 d8	 add	 rbx, rax

; 305  :         if (microseconds % 1000 > 0)

  00033	48 8b c3	 mov	 rax, rbx
  00036	48 69 c0 e8 03
	00 00		 imul	 rax, 1000		; 000003e8H
  0003d	4c 2b c0	 sub	 r8, rax
  00040	4d 85 c0	 test	 r8, r8
  00043	7e 03		 jle	 SHORT $LN5@PyThread_a

; 306  :             ++milliseconds;

  00045	48 ff c3	 inc	 rbx
$LN5@PyThread_a:

; 307  :         if ((DWORD) milliseconds != milliseconds)

  00048	8b c3		 mov	 eax, ebx
  0004a	48 3b c3	 cmp	 rax, rbx
  0004d	74 13		 je	 SHORT $LN3@PyThread_a

; 308  :             Py_FatalError("Timeout too large for a DWORD, "
; 309  :                            "please check PY_TIMEOUT_MAX");

  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@
  00056	e8 00 00 00 00	 call	 Py_FatalError

; 310  :     }
; 311  :     else

  0005b	eb 05		 jmp	 SHORT $LN3@PyThread_a
$LN6@PyThread_a:

; 312  :         milliseconds = INFINITE;

  0005d	bb ff ff ff ff	 mov	 ebx, -1
$LN3@PyThread_a:

; 313  : 
; 314  :     dprintf(("%ld: PyThread_acquire_lock_timed(%p, %lld) called\n",
; 315  :              PyThread_get_thread_ident(), aLock, microseconds));
; 316  : 
; 317  :     if (aLock && EnterNonRecursiveMutex((PNRMUTEX)aLock,
; 318  :                                         (DWORD)milliseconds) == WAIT_OBJECT_0) {

  00062	48 85 ff	 test	 rdi, rdi
  00065	74 1e		 je	 SHORT $LN2@PyThread_a
  00067	8b d3		 mov	 edx, ebx
  00069	48 8b cf	 mov	 rcx, rdi
  0006c	e8 00 00 00 00	 call	 EnterNonRecursiveMutex
  00071	85 c0		 test	 eax, eax
  00073	75 10		 jne	 SHORT $LN2@PyThread_a

; 319  :         success = PY_LOCK_ACQUIRED;
; 320  :     }
; 321  :     else {
; 322  :         success = PY_LOCK_FAILURE;
; 323  :     }
; 324  : 
; 325  :     dprintf(("%ld: PyThread_acquire_lock(%p, %lld) -> %d\n",
; 326  :              PyThread_get_thread_ident(), aLock, microseconds, success));
; 327  : 
; 328  :     return success;

  00075	b8 01 00 00 00	 mov	 eax, 1

; 329  : }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN2@PyThread_a:

; 319  :         success = PY_LOCK_ACQUIRED;
; 320  :     }
; 321  :     else {
; 322  :         success = PY_LOCK_FAILURE;
; 323  :     }
; 324  : 
; 325  :     dprintf(("%ld: PyThread_acquire_lock(%p, %lld) -> %d\n",
; 326  :              PyThread_get_thread_ident(), aLock, microseconds, success));
; 327  : 
; 328  :     return success;

  00085	33 c0		 xor	 eax, eax

; 329  : }

  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
PyThread_acquire_lock_timed ENDP
_TEXT	ENDS
PUBLIC	PyThread_acquire_lock
; Function compile flags: /Ogtpy
;	COMDAT PyThread_acquire_lock
_TEXT	SEGMENT
aLock$ = 8
waitflag$ = 16
PyThread_acquire_lock PROC				; COMDAT

; 333  :     return PyThread_acquire_lock_timed(aLock, waitflag ? -1 : 0, 0);

  00000	f7 da		 neg	 edx
  00002	48 1b d2	 sbb	 rdx, rdx
  00005	45 33 c0	 xor	 r8d, r8d

; 334  : }

  00008	e9 00 00 00 00	 jmp	 PyThread_acquire_lock_timed
PyThread_acquire_lock ENDP
_TEXT	ENDS
PUBLIC	PyThread_release_lock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_release_lock DD imagerel $LN5
	DD	imagerel $LN5+19
	DD	imagerel $unwind$PyThread_release_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_release_lock DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_release_lock
_TEXT	SEGMENT
aLock$ = 48
PyThread_release_lock PROC				; COMDAT

; 338  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 339  :     dprintf(("%ld: PyThread_release_lock(%p) called\n", PyThread_get_thread_ident(),aLock));
; 340  : 
; 341  :     if (!(aLock && LeaveNonRecursiveMutex((PNRMUTEX) aLock)))

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 05		 je	 SHORT $LN1@PyThread_r
  00009	e8 00 00 00 00	 call	 LeaveNonRecursiveMutex
$LN1@PyThread_r:

; 342  :         dprintf(("%ld: Could not PyThread_release_lock(%p) error: %ld\n", PyThread_get_thread_ident(), aLock, GetLastError()));
; 343  : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
PyThread_release_lock ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _pythread_nt_set_stacksize
_TEXT	SEGMENT
size$ = 8
_pythread_nt_set_stacksize PROC				; COMDAT

; 355  :     /* set to default */
; 356  :     if (size == 0) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 0a		 jne	 SHORT $LN2@pythread_n

; 357  :         _pythread_stacksize = 0;

  00005	48 89 0d 00 00
	00 00		 mov	 QWORD PTR _pythread_stacksize, rcx

; 358  :         return 0;

  0000c	33 c0		 xor	 eax, eax

; 368  : }

  0000e	c3		 ret	 0
$LN2@pythread_n:

; 359  :     }
; 360  : 
; 361  :     /* valid range? */
; 362  :     if (size >= THREAD_MIN_STACKSIZE && size < THREAD_MAX_STACKSIZE) {

  0000f	48 8d 81 00 80
	ff ff		 lea	 rax, QWORD PTR [rcx-32768]
  00016	48 3d ff 7f ff
	0f		 cmp	 rax, 268402687		; 0fff7fffH
  0001c	77 0a		 ja	 SHORT $LN1@pythread_n

; 363  :         _pythread_stacksize = size;

  0001e	48 89 0d 00 00
	00 00		 mov	 QWORD PTR _pythread_stacksize, rcx

; 364  :         return 0;

  00025	33 c0		 xor	 eax, eax

; 368  : }

  00027	c3		 ret	 0
$LN1@pythread_n:

; 365  :     }
; 366  : 
; 367  :     return -1;

  00028	83 c8 ff	 or	 eax, -1

; 368  : }

  0002b	c3		 ret	 0
_pythread_nt_set_stacksize ENDP
_TEXT	ENDS
PUBLIC	PyThread_create_key
EXTRN	__imp_TlsAlloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_create_key DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$PyThread_create_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_create_key DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_create_key
_TEXT	SEGMENT
PyThread_create_key PROC				; COMDAT

; 379  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     DWORD result= TlsAlloc();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsAlloc

; 381  :     if (result == TLS_OUT_OF_INDEXES)

  0000a	83 c9 ff	 or	 ecx, -1
  0000d	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00010	0f 44 c1	 cmove	 eax, ecx

; 382  :         return -1;
; 383  :     return (int)result;
; 384  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyThread_create_key ENDP
_TEXT	ENDS
PUBLIC	PyThread_delete_key
EXTRN	__imp_TlsFree:PROC
; Function compile flags: /Ogtpy
;	COMDAT PyThread_delete_key
_TEXT	SEGMENT
key$ = 8
PyThread_delete_key PROC				; COMDAT

; 389  :     TlsFree(key);
; 390  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_TlsFree
PyThread_delete_key ENDP
_TEXT	ENDS
PUBLIC	PyThread_set_key_value
EXTRN	__imp_TlsSetValue:PROC
EXTRN	__imp_TlsGetValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_set_key_value DD imagerel $LN5
	DD	imagerel $LN5+69
	DD	imagerel $unwind$PyThread_set_key_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_set_key_value DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_set_key_value
_TEXT	SEGMENT
key$ = 48
value$ = 56
PyThread_set_key_value PROC				; COMDAT

; 397  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	8b d9		 mov	 ebx, ecx

; 398  :     BOOL ok;
; 399  :     void *oldvalue;
; 400  : 
; 401  :     assert(value != NULL);
; 402  :     oldvalue = TlsGetValue(key);

  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsGetValue

; 403  :     if (oldvalue != NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	74 0d		 je	 SHORT $LN2@PyThread_s

; 404  :         /* ignore value if already set */
; 405  :         return 0;

  0001a	33 c0		 xor	 eax, eax

; 407  :     if (!ok)
; 408  :         return -1;
; 409  :     return 0;
; 410  : }

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN2@PyThread_s:

; 406  :     ok = TlsSetValue(key, value);

  00027	48 8b d7	 mov	 rdx, rdi
  0002a	8b cb		 mov	 ecx, ebx
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsSetValue

; 407  :     if (!ok)
; 408  :         return -1;
; 409  :     return 0;
; 410  : }

  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00037	f7 d8		 neg	 eax
  00039	1b c0		 sbb	 eax, eax
  0003b	f7 d8		 neg	 eax
  0003d	ff c8		 dec	 eax
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
PyThread_set_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_get_key_value
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_GetLastError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_get_key_value DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$PyThread_get_key_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_get_key_value DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_get_key_value
_TEXT	SEGMENT
key$ = 48
PyThread_get_key_value PROC				; COMDAT

; 414  : {

$LN3:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b d9		 mov	 ebx, ecx

; 415  :     /* because TLS is used in the Py_END_ALLOW_THREAD macro,
; 416  :      * it is necessary to preserve the windows error state, because
; 417  :      * it is assumed to be preserved across the call to the macro.
; 418  :      * Ideally, the macro should be fixed, but it is simpler to
; 419  :      * do it here.
; 420  :      */
; 421  :     DWORD error = GetLastError();

  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 422  :     void *result = TlsGetValue(key);

  00012	8b cb		 mov	 ecx, ebx
  00014	8b f8		 mov	 edi, eax
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsGetValue

; 423  :     SetLastError(error);

  0001c	8b cf		 mov	 ecx, edi
  0001e	48 8b d8	 mov	 rbx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 424  :     return result;

  00027	48 8b c3	 mov	 rax, rbx

; 425  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
PyThread_get_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_delete_key_value
; Function compile flags: /Ogtpy
;	COMDAT PyThread_delete_key_value
_TEXT	SEGMENT
key$ = 8
PyThread_delete_key_value PROC				; COMDAT

; 430  :     /* NULL is used as "key missing", and it is also the default
; 431  :      * given by TlsGetValue() if nothing has been set yet.
; 432  :      */
; 433  :     TlsSetValue(key, NULL);

  00000	33 d2		 xor	 edx, edx

; 434  : }

  00002	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_TlsSetValue
PyThread_delete_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_ReInitTLS
; Function compile flags: /Ogtpy
;	COMDAT PyThread_ReInitTLS
_TEXT	SEGMENT
PyThread_ReInitTLS PROC					; COMDAT

; 441  : {}

  00000	c2 00 00	 ret	 0
PyThread_ReInitTLS ENDP
_TEXT	ENDS
PUBLIC	PyThread_get_stacksize
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread.c
;	COMDAT PyThread_get_stacksize
_TEXT	SEGMENT
PyThread_get_stacksize PROC				; COMDAT

; 109  :     return _pythread_stacksize;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _pythread_stacksize

; 110  : }

  00007	c3		 ret	 0
PyThread_get_stacksize ENDP
_TEXT	ENDS
PUBLIC	PyThread_set_stacksize
; Function compile flags: /Ogtpy
;	COMDAT PyThread_set_stacksize
_TEXT	SEGMENT
size$ = 8
PyThread_set_stacksize PROC				; COMDAT

; 120  : #if defined(THREAD_SET_STACKSIZE)
; 121  :     return THREAD_SET_STACKSIZE(size);
; 122  : #else
; 123  :     return -2;
; 124  : #endif
; 125  : }

  00000	e9 00 00 00 00	 jmp	 _pythread_nt_set_stacksize
PyThread_set_stacksize ENDP
_TEXT	ENDS
PUBLIC	??_C@_02JKEHMDF@nt?$AA@				; `string'
PUBLIC	PyThread_GetInfo
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyStructSequence_New:PROC
EXTRN	PyStructSequence_InitType:PROC
_BSS	SEGMENT
ThreadInfoType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyThread_GetInfo DD imagerel $LN15
	DD	imagerel $LN15+259
	DD	imagerel $unwind$PyThread_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_GetInfo DD 045d01H
	DD	08745dH
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_02JKEHMDF@nt?$AA@
CONST	SEGMENT
??_C@_02JKEHMDF@nt?$AA@ DB 'nt', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\thread.c
CONST	ENDS
;	COMDAT PyThread_GetInfo
_TEXT	SEGMENT
PyThread_GetInfo PROC					; COMDAT

; 397  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 398  :     PyObject *threadinfo, *value;
; 399  :     int pos = 0;
; 400  : #if (defined(_POSIX_THREADS) && defined(HAVE_CONFSTR) \
; 401  :      && defined(_CS_GNU_LIBPTHREAD_VERSION))
; 402  :     char buffer[255];
; 403  :     int len;
; 404  : #endif
; 405  : 
; 406  :     if (ThreadInfoType.tp_name == 0)

  00006	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR ThreadInfoType+112, 0
  0000e	75 13		 jne	 SHORT $LN3@PyThread_G

; 407  :         PyStructSequence_InitType(&ThreadInfoType, &threadinfo_desc);

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:threadinfo_desc
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadInfoType
  0001e	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN3@PyThread_G:

; 408  : 
; 409  :     threadinfo = PyStructSequence_New(&ThreadInfoType);

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadInfoType
  0002a	e8 00 00 00 00	 call	 PyStructSequence_New
  0002f	48 8b d8	 mov	 rbx, rax

; 410  :     if (threadinfo == NULL)

  00032	48 85 c0	 test	 rax, rax

; 411  :         return NULL;

  00035	74 19		 je	 SHORT $LN14@PyThread_G

; 412  : 
; 413  :     value = PyUnicode_FromString(PYTHREAD_NAME);

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02JKEHMDF@nt?$AA@
  0003e	e8 00 00 00 00	 call	 PyUnicode_FromString

; 414  :     if (value == NULL) {

  00043	48 85 c0	 test	 rax, rax
  00046	75 10		 jne	 SHORT $LN1@PyThread_G

; 415  :         Py_DECREF(threadinfo);

  00048	48 8b cb	 mov	 rcx, rbx
  0004b	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@PyThread_G:

; 416  :         return NULL;

  00050	33 c0		 xor	 eax, eax

; 453  : }

  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN1@PyThread_G:
  00058	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 417  :     }
; 418  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  0005d	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 419  : 
; 420  : #ifdef _POSIX_THREADS
; 421  : #ifdef USE_SEMAPHORES
; 422  :     value = PyUnicode_FromString("semaphore");
; 423  : #else
; 424  :     value = PyUnicode_FromString("mutex+cond");
; 425  : #endif
; 426  :     if (value == NULL) {
; 427  :         Py_DECREF(threadinfo);
; 428  :         return NULL;
; 429  :     }
; 430  : #else
; 431  :     Py_INCREF(Py_None);

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0006d	85 c0		 test	 eax, eax
  0006f	75 38		 jne	 SHORT $LN7@PyThread_G
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007f	4c 8b cf	 mov	 r9, rdi
  00082	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00088	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00090	e8 00 00 00 00	 call	 _PyParallel_Guard
  00095	85 c0		 test	 eax, eax
  00097	75 09		 jne	 SHORT $LN6@PyThread_G
  00099	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000a0	74 07		 je	 SHORT $LN7@PyThread_G
$LN6@PyThread_G:
  000a2	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@PyThread_G:

; 432  :     value = Py_None;
; 433  : #endif
; 434  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  000a9	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi

; 435  : 
; 436  : #if (defined(_POSIX_THREADS) && defined(HAVE_CONFSTR) \
; 437  :      && defined(_CS_GNU_LIBPTHREAD_VERSION))
; 438  :     value = NULL;
; 439  :     len = confstr(_CS_GNU_LIBPTHREAD_VERSION, buffer, sizeof(buffer));
; 440  :     if (1 < len && len < sizeof(buffer)) {
; 441  :         value = PyUnicode_DecodeFSDefaultAndSize(buffer, len-1);
; 442  :         if (value == NULL)
; 443  :             PyErr_Clear();
; 444  :     }
; 445  :     if (value == NULL)
; 446  : #endif
; 447  :     {
; 448  :         Py_INCREF(Py_None);

  000ad	e8 00 00 00 00	 call	 _Py_PXCTX
  000b2	85 c0		 test	 eax, eax
  000b4	75 38		 jne	 SHORT $LN11@PyThread_G
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c4	4c 8b cf	 mov	 r9, rdi
  000c7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000cd	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000da	85 c0		 test	 eax, eax
  000dc	75 09		 jne	 SHORT $LN10@PyThread_G
  000de	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000e5	74 07		 je	 SHORT $LN11@PyThread_G
$LN10@PyThread_G:
  000e7	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@PyThread_G:

; 449  :         value = Py_None;
; 450  :     }
; 451  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  000ee	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
  000f5	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 452  :     return threadinfo;

  000fa	48 8b c3	 mov	 rax, rbx

; 453  : }

  000fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00101	5b		 pop	 rbx
  00102	c3		 ret	 0
PyThread_GetInfo ENDP
_TEXT	ENDS
PUBLIC	PyThread_init_thread
; Function compile flags: /Ogtpy
;	COMDAT PyThread_init_thread
_TEXT	SEGMENT
PyThread_init_thread PROC				; COMDAT

; 62   : #ifdef Py_DEBUG
; 63   :     char *p = Py_GETENV("PYTHONTHREADDEBUG");
; 64   : 
; 65   :     if (p) {
; 66   :         if (*p)
; 67   :             thread_debug = atoi(p);
; 68   :         else
; 69   :             thread_debug = 1;
; 70   :     }
; 71   : #endif /* Py_DEBUG */
; 72   :     if (initialized)

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR initialized
  00006	b9 01 00 00 00	 mov	 ecx, 1
  0000b	85 c0		 test	 eax, eax
  0000d	0f 44 c1	 cmove	 eax, ecx
  00010	89 05 00 00 00
	00		 mov	 DWORD PTR initialized, eax

; 73   :         return;
; 74   :     initialized = 1;
; 75   :     dprintf(("PyThread_init_thread called\n"));
; 76   :     PyThread__init_thread();
; 77   : }

  00016	c3		 ret	 0
PyThread_init_thread ENDP
_TEXT	ENDS
PUBLIC	PyThread_start_new_thread
EXTRN	__imp__errno:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	__imp_HeapAlloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\thread_nt.h
pdata	SEGMENT
$pdata$PyThread_start_new_thread DD imagerel $LN7
	DD	imagerel $LN7+220
	DD	imagerel $unwind$PyThread_start_new_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_start_new_thread DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_start_new_thread
_TEXT	SEGMENT
func$ = 64
arg$ = 72
threadID$ = 80
PyThread_start_new_thread PROC				; COMDAT

; 181  : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 182  :     HANDLE hThread;
; 183  :     unsigned threadID;
; 184  :     callobj *obj;
; 185  : 
; 186  :     dprintf(("%ld: PyThread_start_new_thread called\n",
; 187  :              PyThread_get_thread_ident()));
; 188  :     if (!initialized)

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	75 05		 jne	 SHORT $LN4@PyThread_s@2

; 189  :         PyThread_init_thread();

  0001e	e8 00 00 00 00	 call	 PyThread_init_thread
$LN4@PyThread_s@2:

; 190  : 
; 191  :     obj = (callobj*)HeapAlloc(GetProcessHeap(), 0, sizeof(*obj));

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  00029	33 d2		 xor	 edx, edx
  0002b	44 8d 42 10	 lea	 r8d, QWORD PTR [rdx+16]
  0002f	48 8b c8	 mov	 rcx, rax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapAlloc
  00038	48 8b d8	 mov	 rbx, rax

; 192  :     if (!obj)

  0003b	48 85 c0	 test	 rax, rax
  0003e	75 13		 jne	 SHORT $LN3@PyThread_s@2

; 193  :         return -1;

  00040	83 c8 ff	 or	 eax, -1

; 231  : }

  00043	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00048	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN3@PyThread_s@2:

; 194  :     obj->func = func;
; 195  :     obj->arg = arg;
; 196  : #if defined(MS_WINCE)
; 197  :     hThread = CreateThread(NULL,
; 198  :                            Py_SAFE_DOWNCAST(_pythread_stacksize, Py_ssize_t, SIZE_T),
; 199  :                            bootstrap, obj, 0, &threadID);
; 200  : #else
; 201  :     hThread = (HANDLE)_beginthreadex(0,
; 202  :                       Py_SAFE_DOWNCAST(_pythread_stacksize,
; 203  :                                        Py_ssize_t, unsigned int),
; 204  :                       bootstrap, obj,
; 205  :                       0, &threadID);

  00053	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pythread_stacksize
  00059	48 89 30	 mov	 QWORD PTR [rax], rsi
  0005c	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  00060	48 8d 44 24 50	 lea	 rax, QWORD PTR threadID$[rsp]
  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:bootstrap
  0006c	4c 8b cb	 mov	 r9, rbx
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	33 c9		 xor	 ecx, ecx
  00076	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex

; 206  : #endif
; 207  :     if (hThread == 0) {

  00084	48 85 c0	 test	 rax, rax
  00087	75 36		 jne	 SHORT $LN2@PyThread_s@2

; 208  : #if defined(MS_WINCE)
; 209  :         /* Save error in variable, to prevent PyThread_get_thread_ident
; 210  :            from clobbering it. */
; 211  :         unsigned e = GetLastError();
; 212  :         dprintf(("%ld: PyThread_start_new_thread failed, win32 error code %u\n",
; 213  :                  PyThread_get_thread_ident(), e));
; 214  : #else
; 215  :         /* I've seen errno == EAGAIN here, which means "there are
; 216  :          * too many threads".
; 217  :          */
; 218  :         int e = errno;

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 219  :         dprintf(("%ld: PyThread_start_new_thread failed, errno %d\n",
; 220  :                  PyThread_get_thread_ident(), e));
; 221  : #endif
; 222  :         threadID = (unsigned)-1;

  0008f	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR threadID$[rsp], -1 ; ffffffffH

; 223  :         HeapFree(GetProcessHeap(), 0, obj);

  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	4c 8b c3	 mov	 r8, rbx
  000a3	33 d2		 xor	 edx, edx
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapFree

; 229  :     }
; 230  :     return (long) threadID;

  000ab	8b 44 24 50	 mov	 eax, DWORD PTR threadID$[rsp]

; 231  : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN2@PyThread_s@2:

; 224  :     }
; 225  :     else {
; 226  :         dprintf(("%ld: PyThread_start_new_thread succeeded: %p\n",
; 227  :                  PyThread_get_thread_ident(), (void*)hThread));
; 228  :         CloseHandle(hThread);

  000bf	48 8b c8	 mov	 rcx, rax
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 229  :     }
; 230  :     return (long) threadID;

  000c8	8b 44 24 50	 mov	 eax, DWORD PTR threadID$[rsp]

; 231  : }

  000cc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
PyThread_start_new_thread ENDP
_TEXT	ENDS
PUBLIC	PyThread_get_thread_ident
EXTRN	__imp_GetCurrentThreadId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_get_thread_ident DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$PyThread_get_thread_ident
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_get_thread_ident DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_get_thread_ident
_TEXT	SEGMENT
PyThread_get_thread_ident PROC				; COMDAT

; 239  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 240  :     if (!initialized)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0000b	75 05		 jne	 SHORT $LN1@PyThread_g

; 241  :         PyThread_init_thread();

  0000d	e8 00 00 00 00	 call	 PyThread_init_thread
$LN1@PyThread_g:

; 242  : 
; 243  :     return GetCurrentThreadId();
; 244  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_GetCurrentThreadId
PyThread_get_thread_ident ENDP
_TEXT	ENDS
PUBLIC	PyThread_allocate_lock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_allocate_lock DD imagerel $LN4
	DD	imagerel $LN4+27
	DD	imagerel $unwind$PyThread_allocate_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_allocate_lock DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyThread_allocate_lock
_TEXT	SEGMENT
PyThread_allocate_lock PROC				; COMDAT

; 266  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 267  :     PNRMUTEX aLock;
; 268  : 
; 269  :     dprintf(("PyThread_allocate_lock called\n"));
; 270  :     if (!initialized)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0000b	75 05		 jne	 SHORT $LN1@PyThread_a@2

; 271  :         PyThread_init_thread();

  0000d	e8 00 00 00 00	 call	 PyThread_init_thread
$LN1@PyThread_a@2:

; 272  : 
; 273  :     aLock = AllocNonRecursiveMutex() ;
; 274  : 
; 275  :     dprintf(("%ld: PyThread_allocate_lock() -> %p\n", PyThread_get_thread_ident(), aLock));
; 276  : 
; 277  :     return (PyThread_type_lock) aLock;
; 278  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	e9 00 00 00 00	 jmp	 AllocNonRecursiveMutex
PyThread_allocate_lock ENDP
_TEXT	ENDS
END
