; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07IFNJGOBH@_struct?$AA@			; `string'
PUBLIC	??_C@_08BLJPPNIC@calcsize?$AA@			; `string'
PUBLIC	??_C@_0M@OEIFDDHI@_clearcache?$AA@		; `string'
PUBLIC	??_C@_06DOCMLGPG@Struct?$AA@			; `string'
PUBLIC	??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@	; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@	; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0M@OJKBBEFN@unpack_from?$AA@		; `string'
PUBLIC	??_C@_06FIONAGJL@unpack?$AA@			; `string'
PUBLIC	??_C@_09HFGPKAHL@pack_into?$AA@			; `string'
PUBLIC	??_C@_04IPANLPFO@pack?$AA@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset?$AA@			; `string'
PUBLIC	??_C@_06HOHPNJLC@buffer?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
EXTRN	PyObject_Free:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericSetAttr:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
cache	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_07IFNJGOBH@_struct?$AA@
CONST	SEGMENT
??_C@_07IFNJGOBH@_struct?$AA@ DB '_struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLJPPNIC@calcsize?$AA@
CONST	SEGMENT
??_C@_08BLJPPNIC@calcsize?$AA@ DB 'calcsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OEIFDDHI@_clearcache?$AA@
CONST	SEGMENT
??_C@_0M@OEIFDDHI@_clearcache?$AA@ DB '_clearcache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOCMLGPG@Struct?$AA@
CONST	SEGMENT
??_C@_06DOCMLGPG@Struct?$AA@ DB 'Struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@
CONST	SEGMENT
??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@ DB 'struct size in bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@
CONST	SEGMENT
??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@ DB 'struct format string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OJKBBEFN@unpack_from?$AA@
CONST	SEGMENT
??_C@_0M@OJKBBEFN@unpack_from?$AA@ DB 'unpack_from', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIONAGJL@unpack?$AA@
CONST	SEGMENT
??_C@_06FIONAGJL@unpack?$AA@ DB 'unpack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HFGPKAHL@pack_into?$AA@
CONST	SEGMENT
??_C@_09HFGPKAHL@pack_into?$AA@ DB 'pack_into', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPANLPFO@pack?$AA@
CONST	SEGMENT
??_C@_04IPANLPFO@pack?$AA@ DB 'pack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset?$AA@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset?$AA@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOHPNJLC@buffer?$AA@
CONST	SEGMENT
??_C@_06HOHPNJLC@buffer?$AA@ DB 'buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
native_table DB	078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000002H
	DQ	FLAT:nu_short
	DQ	FLAT:np_short
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000002H
	DQ	FLAT:nu_ushort
	DQ	FLAT:np_ushort
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_int
	DQ	FLAT:np_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_uint
	DQ	FLAT:np_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_long
	DQ	FLAT:np_long
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_ulong
	DQ	FLAT:np_ulong
	DB	06eH
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_ssize_t
	DQ	FLAT:np_ssize_t
	DB	04eH
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_size_t
	DQ	FLAT:np_size_t
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_longlong
	DQ	FLAT:np_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_ulonglong
	DQ	FLAT:np_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_bool
	DQ	FLAT:np_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000004H
	DQ	FLAT:nu_float
	DQ	FLAT:np_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_double
	DQ	FLAT:np_double
	DB	050H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000008H
	DQ	FLAT:nu_void_p
	DQ	FLAT:np_void_p
	DB	00H
	ORG $+7
	ORG $+32
?kwlist@?1??s_unpack_from@@9@9 DQ FLAT:??_C@_06HOHPNJLC@buffer?$AA@ ; `s_unpack_from'::`2'::kwlist
	DQ	FLAT:??_C@_06KLHHMIGM@offset?$AA@
	DQ	0000000000000000H
bigendian_table DB 078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_int
	DQ	FLAT:bp_int
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_uint
	DQ	FLAT:bp_uint
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_longlong
	DQ	FLAT:bp_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_ulonglong
	DQ	FLAT:bp_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:bu_bool
	DQ	FLAT:bp_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:bu_float
	DQ	FLAT:bp_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:bu_double
	DQ	FLAT:bp_double
	DB	00H
	ORG $+7
	ORG $+32
lilendian_table DB 078H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	062H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_byte
	DQ	FLAT:np_byte
	DB	042H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_ubyte
	DQ	FLAT:np_ubyte
	DB	063H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:nu_char
	DQ	FLAT:np_char
	DB	073H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	070H
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DB	068H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	048H
	ORG $+7
	DQ	0000000000000002H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	069H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	049H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	06cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_int
	DQ	FLAT:lp_int
	DB	04cH
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_uint
	DQ	FLAT:lp_uint
	DB	071H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_longlong
	DQ	FLAT:lp_longlong
	DB	051H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_ulonglong
	DQ	FLAT:lp_ulonglong
	DB	03fH
	ORG $+7
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	FLAT:bu_bool
	DQ	FLAT:bp_bool
	DB	066H
	ORG $+7
	DQ	0000000000000004H
	DQ	0000000000000000H
	DQ	FLAT:lu_float
	DQ	FLAT:lp_float
	DB	064H
	ORG $+7
	DQ	0000000000000008H
	DQ	0000000000000000H
	DQ	FLAT:lu_double
	DQ	FLAT:lp_double
	DB	00H
	ORG $+7
	ORG $+32
?kwlist@?1??s_init@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `s_init'::`2'::kwlist
	DQ	0000000000000000H
s_unpack__doc__ DB 'S.unpack(buffer) -> (v1, v2, ...)', 0aH, 0aH, 'Return'
	DB	' a tuple containing values unpacked according to the format', 0aH
	DB	'string S.format.  Requires len(buffer) == S.size.  See help(s'
	DB	'truct)', 0aH, 'for more on format strings.', 00H
	ORG $+11
s_unpack_from__doc__ DB 'S.unpack_from(buffer, offset=0) -> (v1, v2, ...)'
	DB	0aH, 0aH, 'Return a tuple containing values unpacked according'
	DB	' to the format', 0aH, 'string S.format.  Requires len(buffer['
	DB	'offset:]) >= S.size.  See', 0aH, 'help(struct) for more on fo'
	DB	'rmat strings.', 00H
	ORG $+3
s_pack__doc__ DB 'S.pack(v1, v2, ...) -> bytes', 0aH, 0aH, 'Return a byte'
	DB	's object containing values v1, v2, ... packed according', 0aH
	DB	'to the format string S.format.  See help(struct) for more on '
	DB	'format', 0aH, 'strings.', 00H
s_pack_into__doc__ DB 'S.pack_into(buffer, offset, v1, v2, ...)', 0aH, 0aH
	DB	'Pack the values v1, v2, ... according to the format string S.'
	DB	'format', 0aH, 'and write the packed bytes into the writable b'
	DB	'uffer buf starting at', 0aH, 'offset.  Note that the offset i'
	DB	's a required argument.  See', 0aH, 'help(struct) for more on '
	DB	'format strings.', 00H
	ORG $+2
s_sizeof__doc__ DB 'S.__sizeof__() -> size of S in memory, in bytes', 00H
	ORG $+8
s_methods DQ	FLAT:??_C@_04IPANLPFO@pack?$AA@
	DQ	FLAT:s_pack
	DD	01H
	ORG $+4
	DQ	FLAT:s_pack__doc__
	DQ	FLAT:??_C@_09HFGPKAHL@pack_into?$AA@
	DQ	FLAT:s_pack_into
	DD	01H
	ORG $+4
	DQ	FLAT:s_pack_into__doc__
	DQ	FLAT:??_C@_06FIONAGJL@unpack?$AA@
	DQ	FLAT:s_unpack
	DD	08H
	ORG $+4
	DQ	FLAT:s_unpack__doc__
	DQ	FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
	DQ	FLAT:s_unpack_from
	DD	03H
	ORG $+4
	DQ	FLAT:s_unpack_from__doc__
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:s_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:s_sizeof__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
s__doc__ DB	'Struct(fmt) --> compiled struct object', 0aH, 0aH, 'Retu'
	DB	'rn a new Struct object which writes and reads binary data acc'
	DB	'ording to', 0aH, 'the format string fmt.  See help(struct) fo'
	DB	'r more on format strings.', 00H
	ORG $+8
s_getsetlist DQ	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DQ	FLAT:s_get_format
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BF@GKEJOILN@struct?5format?5string?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04IAGNFIBA@size?$AA@
	DQ	FLAT:s_get_size
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BF@LEHIHPPG@struct?5size?5in?5bytes?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
PyStructType DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06DOCMLGPG@Struct?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:s_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	FLAT:PyObject_GenericSetAttr
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:s__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:s_methods
	DQ	0000000000000000H
	DQ	FLAT:s_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:s_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:s_new
	DQ	FLAT:PyObject_Free
	ORG $+64
clearcache_doc DB 'Clear the internal cache.', 00H
	ORG $+6
calcsize_doc DB	'calcsize(fmt) -> integer', 0aH, 0aH, 'Return size in byt'
	DB	'es of the struct described by the format string fmt.', 00H
	ORG $+15
pack_doc DB	'pack(fmt, v1, v2, ...) -> bytes', 0aH, 0aH, 'Return a by'
	DB	'tes object containing the values v1, v2, ... packed according'
	DB	0aH, 'to the format string fmt.  See help(struct) for more on '
	DB	'format strings.', 00H
	ORG $+14
pack_into_doc DB 'pack_into(fmt, buffer, offset, v1, v2, ...)', 0aH, 0aH, 'P'
	DB	'ack the values v1, v2, ... according to the format string fmt'
	DB	' and write', 0aH, 'the packed bytes into the writable buffer '
	DB	'buf starting at offset.  Note', 0aH, 'that the offset is a re'
	DB	'quired argument.  See help(struct) for more', 0aH, 'on format'
	DB	' strings.', 00H
	ORG $+12
unpack_doc DB	'unpack(fmt, buffer) -> (v1, v2, ...)', 0aH, 0aH, 'Return'
	DB	' a tuple containing values unpacked according to the format s'
	DB	'tring', 0aH, 'fmt.  Requires len(buffer) == calcsize(fmt). Se'
	DB	'e help(struct) for more', 0aH, 'on format strings.', 00H
	ORG $+7
unpack_from_doc DB 'unpack_from(fmt, buffer, offset=0) -> (v1, v2, ...)', 0aH
	DB	0aH, 'Return a tuple containing values unpacked according to t'
	DB	'he format string', 0aH, 'fmt.  Requires len(buffer[offset:]) '
	DB	'>= calcsize(fmt).  See help(struct)', 0aH, 'for more on forma'
	DB	't strings.', 00H
	ORG $+14
module_functions DQ FLAT:??_C@_0M@OEIFDDHI@_clearcache?$AA@
	DQ	FLAT:clearcache
	DD	04H
	ORG $+4
	DQ	FLAT:clearcache_doc
	DQ	FLAT:??_C@_08BLJPPNIC@calcsize?$AA@
	DQ	FLAT:calcsize
	DD	08H
	ORG $+4
	DQ	FLAT:calcsize_doc
	DQ	FLAT:??_C@_04IPANLPFO@pack?$AA@
	DQ	FLAT:pack
	DD	01H
	ORG $+4
	DQ	FLAT:pack_doc
	DQ	FLAT:??_C@_09HFGPKAHL@pack_into?$AA@
	DQ	FLAT:pack_into
	DD	01H
	ORG $+4
	DQ	FLAT:pack_into_doc
	DQ	FLAT:??_C@_06FIONAGJL@unpack?$AA@
	DQ	FLAT:unpack
	DD	01H
	ORG $+4
	DQ	FLAT:unpack_doc
	DQ	FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
	DQ	FLAT:unpack_from
	DD	03H
	ORG $+4
	DQ	FLAT:unpack_from_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'Functions to convert between Python values and C structs'
	DB	'.', 0aH, 'Python bytes objects are used to hold the data repr'
	DB	'esenting the C struct', 0aH, 'and also as format strings (exp'
	DB	'lained below) to describe the layout of data', 0aH, 'in the C'
	DB	' struct.', 0aH, 0aH, 'The optional first format char indicate'
	DB	's byte order, size and alignment:', 0aH, '  @: native order, '
	DB	'size & alignment (default)', 0aH, '  =: native order, std. si'
	DB	'ze & alignment', 0aH, '  <: little-endian, std. size & alignm'
	DB	'ent', 0aH, '  >: big-endian, std. size & alignment', 0aH, '  '
	DB	'!: same as >', 0aH, 0aH, 'The remaining chars indicate types '
	DB	'of args and must match exactly;', 0aH, 'these can be preceded'
	DB	' by a decimal repeat count:', 0aH, '  x: pad byte (no data); '
	DB	'c:char; b:signed byte; B:unsigned byte;', 0aH, '  ?: _Bool (r'
	DB	'equires C99; if not available, char is used instead)', 0aH, ' '
	DB	' h:short; H:unsigned short; i:int; I:unsigned int;', 0aH, '  '
	DB	'l:long; L:unsigned long; f:float; d:double.', 0aH, 'Special c'
	DB	'ases (preceding decimal count indicates length):', 0aH, '  s:'
	DB	'string (array of char); p: pascal string (with count byte).', 0aH
	DB	'Special cases (only available in native format):', 0aH, '  n:'
	DB	'ssize_t; N:size_t;', 0aH, '  P:an integer type that is wide e'
	DB	'nough to hold a pointer.', 0aH, 'Special case (not in native '
	DB	'mode unless ''long long'' in platform C):', 0aH, '  q:long lo'
	DB	'ng; Q:unsigned long long', 0aH, 'Whitespace between formats i'
	DB	's ignored.', 0aH, 0aH, 'The variable struct.error is an excep'
	DB	'tion raised on errors.', 0aH, 00H
	ORG $+11
_structmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07IFNJGOBH@_struct?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:module_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyNumber_Index:PROC
_BSS	SEGMENT
StructError DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_pylong DD imagerel get_pylong
	DD	imagerel get_pylong+161
	DD	imagerel $unwind$get_pylong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_pylong DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@
CONST	SEGMENT
??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@ DB 'required ar'
	DB	'gument is not an integer', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
CONST	ENDS
;	COMDAT get_pylong
_TEXT	SEGMENT
v$ = 64
get_pylong PROC						; COMDAT

; 98   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 99   :     assert(v != NULL);
; 100  :     if (!PyLong_Check(v)) {

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00017	75 44		 jne	 SHORT $LN5@get_pylong

; 101  :         /* Not an integer;  try to use __index__ to convert. */
; 102  :         if (PyIndex_Check(v)) {

  00019	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00020	48 85 c0	 test	 rax, rax
  00023	74 1d		 je	 SHORT $LN4@get_pylong
  00025	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0002d	74 13		 je	 SHORT $LN4@get_pylong

; 103  :             v = PyNumber_Index(v);

  0002f	e8 00 00 00 00	 call	 PyNumber_Index
  00034	48 8b d8	 mov	 rbx, rax

; 104  :             if (v == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	75 5c		 jne	 SHORT $LN9@get_pylong

; 118  : }

  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
$LN4@get_pylong:

; 105  :                 return NULL;
; 106  :         }
; 107  :         else {
; 108  :             PyErr_SetString(StructError,
; 109  :                             "required argument is not an integer");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MJBIACHN@required?5argument?5is?5not?5an?5inte@
  00050	e8 00 00 00 00	 call	 PyErr_SetString

; 110  :             return NULL;

  00055	33 c0		 xor	 eax, eax

; 118  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$LN5@get_pylong:

; 111  :         }
; 112  :     }
; 113  :     else
; 114  :         Py_INCREF(v);

  0005d	e8 00 00 00 00	 call	 _Py_PXCTX
  00062	85 c0		 test	 eax, eax
  00064	75 32		 jne	 SHORT $LN9@get_pylong
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00074	4c 8b cb	 mov	 r9, rbx
  00077	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0007d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00085	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008a	85 c0		 test	 eax, eax
  0008c	75 06		 jne	 SHORT $LN8@get_pylong
  0008e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00092	74 04		 je	 SHORT $LN9@get_pylong
$LN8@get_pylong:
  00094	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@get_pylong:

; 115  : 
; 116  :     assert(PyLong_Check(v));
; 117  :     return v;

  00098	48 8b c3	 mov	 rax, rbx

; 118  : }

  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
get_pylong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@ ; `string'
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_long DD imagerel get_long
	DD	imagerel get_long+43
	DD	imagerel $unwind$get_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_long DD imagerel get_long+43
	DD	imagerel get_long+132
	DD	imagerel $chain$0$get_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_long DD imagerel get_long+132
	DD	imagerel get_long+152
	DD	imagerel $chain$2$get_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_long DD 020021H
	DD	063400H
	DD	imagerel get_long
	DD	imagerel get_long+43
	DD	imagerel $unwind$get_long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_long DD 020521H
	DD	063405H
	DD	imagerel get_long
	DD	imagerel get_long+43
	DD	imagerel $unwind$get_long
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_long DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@ DB 'argument out of rang'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_long
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_long PROC						; COMDAT

; 125  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 126  :     long x;
; 127  : 
; 128  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 129  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_long

; 130  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 141  :     return 0;
; 142  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_long:

; 131  :     assert(PyLong_Check(v));
; 132  :     x = PyLong_AsLong(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsLong

; 133  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	8b d8		 mov	 ebx, eax
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 134  :     if (x == (long)-1 && PyErr_Occurred()) {

  0003f	83 fb ff	 cmp	 ebx, -1
  00042	75 40		 jne	 SHORT $LN2@get_long
  00044	e8 00 00 00 00	 call	 PyErr_Occurred
  00049	48 85 c0	 test	 rax, rax
  0004c	74 36		 je	 SHORT $LN2@get_long

; 135  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00055	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005a	85 c0		 test	 eax, eax
  0005c	74 13		 je	 SHORT $LN1@get_long

; 136  :             PyErr_SetString(StructError,
; 137  :                             "argument out of range");

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_long:

; 138  :         return -1;

  00071	83 c8 ff	 or	 eax, -1
  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 141  :     return 0;
; 142  : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
$LN2@get_long:

; 139  :     }
; 140  :     *p = x;

  00084	89 1e		 mov	 DWORD PTR [rsi], ebx
  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 141  :     return 0;
; 142  : }

  0008b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00090	33 c0		 xor	 eax, eax
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
get_long ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ulong DD imagerel get_ulong
	DD	imagerel get_ulong+43
	DD	imagerel $unwind$get_ulong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_ulong DD imagerel get_ulong+43
	DD	imagerel get_ulong+132
	DD	imagerel $chain$0$get_ulong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_ulong DD imagerel get_ulong+132
	DD	imagerel get_ulong+152
	DD	imagerel $chain$2$get_ulong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_ulong DD 020021H
	DD	063400H
	DD	imagerel get_ulong
	DD	imagerel get_ulong+43
	DD	imagerel $unwind$get_ulong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_ulong DD 020521H
	DD	063405H
	DD	imagerel get_ulong
	DD	imagerel get_ulong+43
	DD	imagerel $unwind$get_ulong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ulong DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_ulong
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_ulong PROC						; COMDAT

; 149  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 150  :     unsigned long x;
; 151  : 
; 152  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 153  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_ulong

; 154  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 165  :     return 0;
; 166  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_ulong:

; 155  :     assert(PyLong_Check(v));
; 156  :     x = PyLong_AsUnsignedLong(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong

; 157  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	8b d8		 mov	 ebx, eax
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 158  :     if (x == (unsigned long)-1 && PyErr_Occurred()) {

  0003f	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00042	75 40		 jne	 SHORT $LN2@get_ulong
  00044	e8 00 00 00 00	 call	 PyErr_Occurred
  00049	48 85 c0	 test	 rax, rax
  0004c	74 36		 je	 SHORT $LN2@get_ulong

; 159  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00055	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005a	85 c0		 test	 eax, eax
  0005c	74 13		 je	 SHORT $LN1@get_ulong

; 160  :             PyErr_SetString(StructError,
; 161  :                             "argument out of range");

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ulong:

; 162  :         return -1;

  00071	83 c8 ff	 or	 eax, -1
  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 165  :     return 0;
; 166  : }

  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
$LN2@get_ulong:

; 163  :     }
; 164  :     *p = x;

  00084	89 1e		 mov	 DWORD PTR [rsi], ebx
  00086	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 165  :     return 0;
; 166  : }

  0008b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00090	33 c0		 xor	 eax, eax
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
get_ulong ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_longlong DD imagerel get_longlong
	DD	imagerel get_longlong+43
	DD	imagerel $unwind$get_longlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_longlong DD imagerel get_longlong+43
	DD	imagerel get_longlong+134
	DD	imagerel $chain$0$get_longlong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_longlong DD imagerel get_longlong+134
	DD	imagerel get_longlong+155
	DD	imagerel $chain$2$get_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_longlong DD 020021H
	DD	063400H
	DD	imagerel get_longlong
	DD	imagerel get_longlong+43
	DD	imagerel $unwind$get_longlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_longlong DD 020521H
	DD	063405H
	DD	imagerel get_longlong
	DD	imagerel get_longlong+43
	DD	imagerel $unwind$get_longlong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_longlong DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_longlong
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_longlong PROC					; COMDAT

; 174  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 175  :     PY_LONG_LONG x;
; 176  : 
; 177  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 178  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_longlo

; 179  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 190  :     return 0;
; 191  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_longlo:

; 180  :     assert(PyLong_Check(v));
; 181  :     x = PyLong_AsLongLong(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsLongLong

; 182  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	48 8b d8	 mov	 rbx, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 183  :     if (x == (PY_LONG_LONG)-1 && PyErr_Occurred()) {

  00040	48 83 fb ff	 cmp	 rbx, -1
  00044	75 40		 jne	 SHORT $LN2@get_longlo
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 36		 je	 SHORT $LN2@get_longlo

; 184  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00057	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005c	85 c0		 test	 eax, eax
  0005e	74 13		 je	 SHORT $LN1@get_longlo

; 185  :             PyErr_SetString(StructError,
; 186  :                             "argument out of range");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_longlo:

; 187  :         return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 190  :     return 0;
; 191  : }

  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN2@get_longlo:

; 188  :     }
; 189  :     *p = x;

  00086	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 190  :     return 0;
; 191  : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	33 c0		 xor	 eax, eax
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
get_longlong ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ulonglong DD imagerel get_ulonglong
	DD	imagerel get_ulonglong+43
	DD	imagerel $unwind$get_ulonglong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_ulonglong DD imagerel get_ulonglong+43
	DD	imagerel get_ulonglong+134
	DD	imagerel $chain$0$get_ulonglong
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_ulonglong DD imagerel get_ulonglong+134
	DD	imagerel get_ulonglong+155
	DD	imagerel $chain$2$get_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_ulonglong DD 020021H
	DD	063400H
	DD	imagerel get_ulonglong
	DD	imagerel get_ulonglong+43
	DD	imagerel $unwind$get_ulonglong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_ulonglong DD 020521H
	DD	063405H
	DD	imagerel get_ulonglong
	DD	imagerel get_ulonglong+43
	DD	imagerel $unwind$get_ulonglong
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ulonglong DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_ulonglong
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_ulonglong PROC					; COMDAT

; 197  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 198  :     unsigned PY_LONG_LONG x;
; 199  : 
; 200  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 201  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_ulongl

; 202  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 213  :     return 0;
; 214  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_ulongl:

; 203  :     assert(PyLong_Check(v));
; 204  :     x = PyLong_AsUnsignedLongLong(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong

; 205  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	48 8b d8	 mov	 rbx, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 206  :     if (x == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred()) {

  00040	48 83 fb ff	 cmp	 rbx, -1
  00044	75 40		 jne	 SHORT $LN2@get_ulongl
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 36		 je	 SHORT $LN2@get_ulongl

; 207  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00057	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005c	85 c0		 test	 eax, eax
  0005e	74 13		 je	 SHORT $LN1@get_ulongl

; 208  :             PyErr_SetString(StructError,
; 209  :                             "argument out of range");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ulongl:

; 210  :         return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 213  :     return 0;
; 214  : }

  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN2@get_ulongl:

; 211  :     }
; 212  :     *p = x;

  00086	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 213  :     return 0;
; 214  : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	33 c0		 xor	 eax, eax
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
get_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_ssize_t DD imagerel get_ssize_t
	DD	imagerel get_ssize_t+43
	DD	imagerel $unwind$get_ssize_t
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_ssize_t DD imagerel get_ssize_t+43
	DD	imagerel get_ssize_t+134
	DD	imagerel $chain$0$get_ssize_t
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_ssize_t DD imagerel get_ssize_t+134
	DD	imagerel get_ssize_t+155
	DD	imagerel $chain$2$get_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_ssize_t DD 020021H
	DD	063400H
	DD	imagerel get_ssize_t
	DD	imagerel get_ssize_t+43
	DD	imagerel $unwind$get_ssize_t
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_ssize_t DD 020521H
	DD	063405H
	DD	imagerel get_ssize_t
	DD	imagerel get_ssize_t+43
	DD	imagerel $unwind$get_ssize_t
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_ssize_t DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_ssize_t
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_ssize_t PROC					; COMDAT

; 222  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 223  :     Py_ssize_t x;
; 224  : 
; 225  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 226  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_ssize_

; 227  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 238  :     return 0;
; 239  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_ssize_:

; 228  :     assert(PyLong_Check(v));
; 229  :     x = PyLong_AsSsize_t(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 230  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	48 8b d8	 mov	 rbx, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 231  :     if (x == (Py_ssize_t)-1 && PyErr_Occurred()) {

  00040	48 83 fb ff	 cmp	 rbx, -1
  00044	75 40		 jne	 SHORT $LN2@get_ssize_
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 36		 je	 SHORT $LN2@get_ssize_

; 232  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00057	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005c	85 c0		 test	 eax, eax
  0005e	74 13		 je	 SHORT $LN1@get_ssize_

; 233  :             PyErr_SetString(StructError,
; 234  :                             "argument out of range");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_ssize_:

; 235  :         return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 238  :     return 0;
; 239  : }

  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN2@get_ssize_:

; 236  :     }
; 237  :     *p = x;

  00086	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 238  :     return 0;
; 239  : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	33 c0		 xor	 eax, eax
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
get_ssize_t ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_size_t DD imagerel get_size_t
	DD	imagerel get_size_t+43
	DD	imagerel $unwind$get_size_t
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_size_t DD imagerel get_size_t+43
	DD	imagerel get_size_t+134
	DD	imagerel $chain$0$get_size_t
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_size_t DD imagerel get_size_t+134
	DD	imagerel get_size_t+155
	DD	imagerel $chain$2$get_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_size_t DD 020021H
	DD	063400H
	DD	imagerel get_size_t
	DD	imagerel get_size_t+43
	DD	imagerel $unwind$get_size_t
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_size_t DD 020521H
	DD	063405H
	DD	imagerel get_size_t
	DD	imagerel get_size_t+43
	DD	imagerel $unwind$get_size_t
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_size_t DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_size_t
_TEXT	SEGMENT
v$ = 48
p$ = 56
get_size_t PROC						; COMDAT

; 245  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f2	 mov	 rsi, rdx

; 246  :     size_t x;
; 247  : 
; 248  :     v = get_pylong(v);

  0000d	e8 00 00 00 00	 call	 get_pylong
  00012	48 8b f8	 mov	 rdi, rax

; 249  :     if (v == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0e		 jne	 SHORT $LN3@get_size_t

; 250  :         return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 261  :     return 0;
; 262  : }

  0001d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@get_size_t:

; 251  :     assert(PyLong_Check(v));
; 252  :     x = PyLong_AsSize_t(v);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	e8 00 00 00 00	 call	 PyLong_AsSize_t

; 253  :     Py_DECREF(v);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	48 8b d8	 mov	 rbx, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 254  :     if (x == (size_t)-1 && PyErr_Occurred()) {

  00040	48 83 fb ff	 cmp	 rbx, -1
  00044	75 40		 jne	 SHORT $LN2@get_size_t
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	74 36		 je	 SHORT $LN2@get_size_t

; 255  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00057	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005c	85 c0		 test	 eax, eax
  0005e	74 13		 je	 SHORT $LN1@get_size_t

; 256  :             PyErr_SetString(StructError,
; 257  :                             "argument out of range");

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CPPCKPNI@argument?5out?5of?5range?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@get_size_t:

; 258  :         return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 261  :     return 0;
; 262  : }

  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN2@get_size_t:

; 259  :     }
; 260  :     *p = x;

  00086	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 261  :     return 0;
; 262  : }

  0008e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00093	33 c0		 xor	 eax, eax
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
get_size_t ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_PyFloat_Unpack4:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_float DD imagerel unpack_float
	DD	imagerel unpack_float+70
	DD	imagerel $unwind$unpack_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_float DD 030901H
	DD	026809H
	DD	06204H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unpack_float
_TEXT	SEGMENT
p$ = 64
le$ = 72
unpack_float PROC					; COMDAT

; 273  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 274  :     double x;
; 275  : 
; 276  :     x = _PyFloat_Unpack4((unsigned char *)p, le);

  00009	e8 00 00 00 00	 call	 _PyFloat_Unpack4

; 277  :     if (x == -1.0 && PyErr_Occurred())

  0000e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00016	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001a	7a 18		 jp	 SHORT $LN1@unpack_flo
  0001c	75 16		 jne	 SHORT $LN1@unpack_flo
  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 0c		 je	 SHORT $LN1@unpack_flo

; 278  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 280  : }

  0002a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
$LN1@unpack_flo:

; 279  :     return PyFloat_FromDouble(x);

  00034	66 0f 28 c6	 movapd	 xmm0, xmm6

; 280  : }

  00038	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
unpack_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Unpack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_double DD imagerel unpack_double
	DD	imagerel unpack_double+70
	DD	imagerel $unwind$unpack_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_double DD 030901H
	DD	026809H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unpack_double
_TEXT	SEGMENT
p$ = 64
le$ = 72
unpack_double PROC					; COMDAT

; 285  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6

; 286  :     double x;
; 287  : 
; 288  :     x = _PyFloat_Unpack8((unsigned char *)p, le);

  00009	e8 00 00 00 00	 call	 _PyFloat_Unpack8

; 289  :     if (x == -1.0 && PyErr_Occurred())

  0000e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00016	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001a	7a 18		 jp	 SHORT $LN1@unpack_dou
  0001c	75 16		 jne	 SHORT $LN1@unpack_dou
  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 0c		 je	 SHORT $LN1@unpack_dou

; 290  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 292  : }

  0002a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
$LN1@unpack_dou:

; 291  :     return PyFloat_FromDouble(x);

  00034	66 0f 28 c6	 movapd	 xmm0, xmm6

; 292  : }

  00038	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
unpack_double ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@ ; `string'
PUBLIC	??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@ ; `string'
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_range_error DD imagerel _range_error
	DD	imagerel _range_error+98
	DD	imagerel $unwind$_range_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_range_error DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@
CONST	SEGMENT
??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@ DB ''''
	DB	'%c'' format requires %zd <= number <= %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@
CONST	SEGMENT
??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@ DB ''''
	DB	'%c'' format requires 0 <= number <= %zu', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _range_error
_TEXT	SEGMENT
f$ = 64
is_unsigned$ = 72
_range_error PROC					; COMDAT

; 297  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b c1	 mov	 r8, rcx

; 298  :     /* ulargest is the largest unsigned value with f->size bytes.
; 299  :      * Note that the simpler:
; 300  :      *     ((size_t)1 << (f->size * 8)) - 1
; 301  :      * doesn't work when f->size == sizeof(size_t) because C doesn't
; 302  :      * define what happens when a left shift count is >= the number of
; 303  :      * bits in the integer being shifted; e.g., on some boxes it doesn't
; 304  :      * shift at all when they're equal.
; 305  :      */
; 306  :     const size_t ulargest = (size_t)-1 >> ((SIZEOF_SIZE_T - f->size)*8);

  00007	b9 08 00 00 00	 mov	 ecx, 8
  0000c	49 83 ca ff	 or	 r10, -1
  00010	41 2a 48 08	 sub	 cl, BYTE PTR [r8+8]

; 307  :     assert(f->size >= 1 && f->size <= SIZEOF_SIZE_T);
; 308  :     if (is_unsigned)
; 309  :         PyErr_Format(StructError,
; 310  :             "'%c' format requires 0 <= number <= %zu",
; 311  :             f->format,
; 312  :             ulargest);

  00014	45 0f be 00	 movsx	 r8d, BYTE PTR [r8]
  00018	c0 e1 03	 shl	 cl, 3
  0001b	49 d3 ea	 shr	 r10, cl
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00025	85 d2		 test	 edx, edx
  00027	74 17		 je	 SHORT $LN2@range_erro
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@FDMMBEIJ@?8?$CFc?8?5format?5requires?50?5?$DM?$DN?5number@
  00030	4d 8b ca	 mov	 r9, r10
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 320  :     }
; 321  : 
; 322  :     return -1;

  00038	83 c8 ff	 or	 eax, -1

; 323  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
$LN2@range_erro:

; 313  :     else {
; 314  :         const Py_ssize_t largest = (Py_ssize_t)(ulargest >> 1);

  00040	49 d1 ea	 shr	 r10, 1

; 315  :         PyErr_Format(StructError,
; 316  :             "'%c' format requires %zd <= number <= %zd",
; 317  :             f->format,
; 318  :             ~ largest,
; 319  :             largest);

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NKGCPOGG@?8?$CFc?8?5format?5requires?5?$CFzd?5?$DM?$DN?5numb@
  0004a	4d 8b ca	 mov	 r9, r10
  0004d	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  00052	49 f7 d1	 not	 r9
  00055	e8 00 00 00 00	 call	 PyErr_Format

; 320  :     }
; 321  : 
; 322  :     return -1;

  0005a	83 c8 ff	 or	 eax, -1

; 323  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
_range_error ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_char
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_char	PROC						; COMDAT

; 349  :     return PyBytes_FromStringAndSize(p, 1);

  00000	ba 01 00 00 00	 mov	 edx, 1

; 350  : }

  00005	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
nu_char	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_byte
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_byte	PROC						; COMDAT

; 355  :     return PyLong_FromLong((long) *(signed char *)p);

  00000	0f be 09	 movsx	 ecx, BYTE PTR [rcx]

; 356  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_byte	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_ubyte
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_ubyte PROC						; COMDAT

; 361  :     return PyLong_FromLong((long) *(unsigned char *)p);

  00000	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]

; 362  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_ubyte ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_short
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_short PROC						; COMDAT

; 367  :     short x;
; 368  :     memcpy((char *)&x, p, sizeof x);
; 369  :     return PyLong_FromLong((long)x);

  00000	0f bf 09	 movsx	 ecx, WORD PTR [rcx]

; 370  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_short ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_ushort
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_ushort PROC						; COMDAT

; 375  :     unsigned short x;
; 376  :     memcpy((char *)&x, p, sizeof x);
; 377  :     return PyLong_FromLong((long)x);

  00000	0f b7 09	 movzx	 ecx, WORD PTR [rcx]

; 378  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_ushort ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_int
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_int	PROC						; COMDAT

; 383  :     int x;
; 384  :     memcpy((char *)&x, p, sizeof x);
; 385  :     return PyLong_FromLong((long)x);

  00000	8b 09		 mov	 ecx, DWORD PTR [rcx]

; 386  : }

  00002	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_int	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_uint
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_uint	PROC						; COMDAT

; 391  :     unsigned int x;
; 392  :     memcpy((char *)&x, p, sizeof x);

  00000	8b 09		 mov	 ecx, DWORD PTR [rcx]

; 393  : #if (SIZEOF_LONG > SIZEOF_INT)
; 394  :     return PyLong_FromLong((long)x);
; 395  : #else
; 396  :     if (x <= ((unsigned int)LONG_MAX))

  00002	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00008	77 05		 ja	 SHORT $LN1@nu_uint

; 397  :         return PyLong_FromLong((long)x);
; 398  :     return PyLong_FromUnsignedLong((unsigned long)x);
; 399  : #endif
; 400  : }

  0000a	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@nu_uint:
  0000f	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
nu_uint	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_long
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_long	PROC						; COMDAT

; 405  :     long x;
; 406  :     memcpy((char *)&x, p, sizeof x);
; 407  :     return PyLong_FromLong(x);

  00000	8b 09		 mov	 ecx, DWORD PTR [rcx]

; 408  : }

  00002	e9 00 00 00 00	 jmp	 PyLong_FromLong
nu_long	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_ulong
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_ulong PROC						; COMDAT

; 413  :     unsigned long x;
; 414  :     memcpy((char *)&x, p, sizeof x);

  00000	8b 09		 mov	 ecx, DWORD PTR [rcx]

; 415  :     if (x <= LONG_MAX)

  00002	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  00008	77 05		 ja	 SHORT $LN1@nu_ulong

; 416  :         return PyLong_FromLong((long)x);
; 417  :     return PyLong_FromUnsignedLong(x);
; 418  : }

  0000a	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@nu_ulong:
  0000f	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
nu_ulong ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_ssize_t
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_ssize_t PROC						; COMDAT

; 423  :     Py_ssize_t x;
; 424  :     memcpy((char *)&x, p, sizeof x);
; 425  :     return PyLong_FromSsize_t(x);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 426  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
nu_ssize_t ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSize_t:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_size_t
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_size_t PROC						; COMDAT

; 431  :     size_t x;
; 432  :     memcpy((char *)&x, p, sizeof x);
; 433  :     return PyLong_FromSize_t(x);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 434  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromSize_t
nu_size_t ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_longlong
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_longlong PROC					; COMDAT

; 445  :     PY_LONG_LONG x;
; 446  :     memcpy((char *)&x, p, sizeof x);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 447  :     if (x >= LONG_MIN && x <= LONG_MAX)

  00003	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00008	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  0000d	48 03 c1	 add	 rax, rcx
  00010	48 3b c2	 cmp	 rax, rdx
  00013	77 05		 ja	 SHORT $LN1@nu_longlon

; 448  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));
; 449  :     return PyLong_FromLongLong(x);
; 450  : }

  00015	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@nu_longlon:
  0001a	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
nu_longlong ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLongLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_ulonglong
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_ulonglong PROC					; COMDAT

; 455  :     unsigned PY_LONG_LONG x;
; 456  :     memcpy((char *)&x, p, sizeof x);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 457  :     if (x <= LONG_MAX)

  00003	48 81 f9 ff ff
	ff 7f		 cmp	 rcx, 2147483647		; 7fffffffH
  0000a	77 05		 ja	 SHORT $LN1@nu_ulonglo

; 458  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));
; 459  :     return PyLong_FromUnsignedLongLong(x);
; 460  : }

  0000c	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@nu_ulonglo:
  00011	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
nu_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_bool
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_bool	PROC						; COMDAT

; 467  :     BOOL_TYPE x;
; 468  :     memcpy((char *)&x, p, sizeof x);
; 469  :     return PyBool_FromLong(x != 0);

  00000	33 c0		 xor	 eax, eax
  00002	38 01		 cmp	 BYTE PTR [rcx], al
  00004	0f 95 c0	 setne	 al
  00007	8b c8		 mov	 ecx, eax

; 470  : }

  00009	e9 00 00 00 00	 jmp	 PyBool_FromLong
nu_bool	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_float
_TEXT	SEGMENT
x$ = 8
p$ = 8
f$ = 16
nu_float PROC						; COMDAT

; 476  :     float x;
; 477  :     memcpy((char *)&x, p, sizeof x);

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	89 44 24 08	 mov	 DWORD PTR x$[rsp], eax

; 478  :     return PyFloat_FromDouble((double)x);

  00006	66 0f 6e 44 24
	08		 movd	 xmm0, DWORD PTR x$[rsp]
  0000c	0f 5a c0	 cvtps2pd xmm0, xmm0

; 479  : }

  0000f	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
nu_float ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT nu_double
_TEXT	SEGMENT
x$ = 8
p$ = 8
f$ = 16
nu_double PROC						; COMDAT

; 484  :     double x;
; 485  :     memcpy((char *)&x, p, sizeof x);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 44 24 08	 mov	 QWORD PTR x$[rsp], rax

; 486  :     return PyFloat_FromDouble(x);

  00008	f2 0f 10 44 24
	08		 movsdx	 xmm0, QWORD PTR x$[rsp]

; 487  : }

  0000e	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
nu_double ENDP
_TEXT	ENDS
EXTRN	PyLong_FromVoidPtr:PROC
; Function compile flags: /Ogtpy
;	COMDAT nu_void_p
_TEXT	SEGMENT
p$ = 8
f$ = 16
nu_void_p PROC						; COMDAT

; 492  :     void *x;
; 493  :     memcpy((char *)&x, p, sizeof x);
; 494  :     return PyLong_FromVoidPtr(x);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 495  : }

  00003	e9 00 00 00 00	 jmp	 PyLong_FromVoidPtr
nu_void_p ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_byte DD imagerel np_byte
	DD	imagerel np_byte+84
	DD	imagerel $unwind$np_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_byte DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@
CONST	SEGMENT
??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@ DB 'byte'
	DB	' format requires -128 <= number <= 127', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_byte
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_byte	PROC						; COMDAT

; 499  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 500  :     long x;
; 501  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax

; 502  :         return -1;

  0001b	78 2e		 js	 SHORT $LN6@np_byte

; 503  :     if (x < -128 || x > 127){

  0001d	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  00021	8d 81 80 00 00
	00		 lea	 eax, DWORD PTR [rcx+128]
  00027	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0002c	77 0a		 ja	 SHORT $LN1@np_byte

; 507  :     }
; 508  :     *p = (char)x;

  0002e	88 0b		 mov	 BYTE PTR [rbx], cl

; 509  :     return 0;

  00030	33 c0		 xor	 eax, eax

; 510  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
$LN1@np_byte:

; 504  :         PyErr_SetString(StructError,
; 505  :                         "byte format requires -128 <= number <= 127");

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HPOFFIBE@byte?5format?5requires?5?9128?5?$DM?$DN?5num@
  00046	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@np_byte:

; 506  :         return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 510  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
np_byte	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ubyte DD imagerel np_ubyte
	DD	imagerel np_ubyte+78
	DD	imagerel $unwind$np_ubyte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ubyte DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@
CONST	SEGMENT
??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@ DB 'ubyte '
	DB	'format requires 0 <= number <= 255', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_ubyte
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_ubyte PROC						; COMDAT

; 514  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 515  :     long x;
; 516  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax

; 517  :         return -1;

  0001b	78 28		 js	 SHORT $LN6@np_ubyte

; 518  :     if (x < 0 || x > 255){

  0001d	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00021	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00026	77 0a		 ja	 SHORT $LN1@np_ubyte

; 522  :     }
; 523  :     *p = (char)x;

  00028	88 03		 mov	 BYTE PTR [rbx], al

; 524  :     return 0;

  0002a	33 c0		 xor	 eax, eax

; 525  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN1@np_ubyte:

; 519  :         PyErr_SetString(StructError,
; 520  :                         "ubyte format requires 0 <= number <= 255");

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@GHDNPKL@ubyte?5format?5requires?50?5?$DM?$DN?5numbe@
  00040	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@np_ubyte:

; 521  :         return -1;

  00045	83 c8 ff	 or	 eax, -1

; 525  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
np_ubyte ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@ ; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_char DD imagerel np_char
	DD	imagerel np_char+105
	DD	imagerel $unwind$np_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_char DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@
CONST	SEGMENT
??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@ DB 'char format'
	DB	' requires a bytes object of length 1', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_char
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
np_char	PROC						; COMDAT

; 529  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 530  :     if (!PyBytes_Check(v) || PyBytes_Size(v) != 1) {

  0000a	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  0001e	74 28		 je	 SHORT $LN1@np_char
  00020	48 8b ca	 mov	 rcx, rdx
  00023	e8 00 00 00 00	 call	 PyBytes_Size
  00028	48 83 f8 01	 cmp	 rax, 1
  0002c	75 1a		 jne	 SHORT $LN1@np_char

; 533  :         return -1;
; 534  :     }
; 535  :     *p = *PyBytes_AsString(v);

  0002e	48 8b cb	 mov	 rcx, rbx
  00031	e8 00 00 00 00	 call	 PyBytes_AsString
  00036	0f b6 08	 movzx	 ecx, BYTE PTR [rax]

; 536  :     return 0;

  00039	33 c0		 xor	 eax, eax
  0003b	88 0f		 mov	 BYTE PTR [rdi], cl

; 537  : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
$LN1@np_char:

; 531  :         PyErr_SetString(StructError,
; 532  :                         "char format requires a bytes object of length 1");

  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@FMJFJOIA@char?5format?5requires?5a?5bytes?5obj@
  00056	e8 00 00 00 00	 call	 PyErr_SetString

; 537  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	83 c8 ff	 or	 eax, -1
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
np_char	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_short DD imagerel np_short
	DD	imagerel np_short+85
	DD	imagerel $unwind$np_short
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_short DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@
CONST	SEGMENT
??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@ DB 'short for'
	DB	'mat requires SHRT_MIN <= number <= SHRT_MAX', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_short
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_short PROC						; COMDAT

; 541  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 542  :     long x;
; 543  :     short y;
; 544  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax

; 545  :         return -1;

  0001b	78 2f		 js	 SHORT $LN6@np_short

; 546  :     if (x < SHRT_MIN || x > SHRT_MAX){

  0001d	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  00021	8d 81 00 80 00
	00		 lea	 eax, DWORD PTR [rcx+32768]
  00027	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0002c	77 0b		 ja	 SHORT $LN1@np_short

; 551  :     }
; 552  :     y = (short)x;
; 553  :     memcpy(p, (char *)&y, sizeof y);

  0002e	66 89 0b	 mov	 WORD PTR [rbx], cx

; 554  :     return 0;

  00031	33 c0		 xor	 eax, eax

; 555  : }

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
$LN1@np_short:

; 547  :         PyErr_SetString(StructError,
; 548  :                         "short format requires " STRINGIFY(SHRT_MIN)
; 549  :                         " <= number <= " STRINGIFY(SHRT_MAX));

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@KNANBGPI@short?5format?5requires?5SHRT_MIN?5?$DM@
  00047	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@np_short:

; 550  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1

; 555  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
np_short ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ushort DD imagerel np_ushort
	DD	imagerel np_ushort+79
	DD	imagerel $unwind$np_ushort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ushort DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@
CONST	SEGMENT
??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@ DB 'ushor'
	DB	't format requires 0 <= number <= USHRT_MAX', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_ushort
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_ushort PROC						; COMDAT

; 559  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 560  :     long x;
; 561  :     unsigned short y;
; 562  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax

; 563  :         return -1;

  0001b	78 29		 js	 SHORT $LN6@np_ushort

; 564  :     if (x < 0 || x > USHRT_MAX){

  0001d	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00021	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00026	77 0b		 ja	 SHORT $LN1@np_ushort

; 568  :     }
; 569  :     y = (unsigned short)x;
; 570  :     memcpy(p, (char *)&y, sizeof y);

  00028	66 89 03	 mov	 WORD PTR [rbx], ax

; 571  :     return 0;

  0002b	33 c0		 xor	 eax, eax

; 572  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
$LN1@np_ushort:

; 565  :         PyErr_SetString(StructError,
; 566  :                         "ushort format requires 0 <= number <= " STRINGIFY(USHRT_MAX));

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@JHGGNNCI@ushort?5format?5requires?50?5?$DM?$DN?5numb@
  00041	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@np_ushort:

; 567  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 572  : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
np_ushort ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_int DD imagerel np_int
	DD	imagerel np_int+52
	DD	imagerel $unwind$np_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_int DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_int
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_int	PROC						; COMDAT

; 576  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 577  :     long x;
; 578  :     int y;
; 579  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_int

; 580  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 588  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_int:

; 581  : #if (SIZEOF_LONG > SIZEOF_INT)
; 582  :     if ((x < ((long)INT_MIN)) || (x > ((long)INT_MAX)))
; 583  :         RANGE_ERROR(x, f, 0, -1);
; 584  : #endif
; 585  :     y = (int)x;
; 586  :     memcpy(p, (char *)&y, sizeof y);

  00026	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0002a	89 03		 mov	 DWORD PTR [rbx], eax

; 587  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 588  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
np_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_uint DD imagerel np_uint
	DD	imagerel np_uint+52
	DD	imagerel $unwind$np_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_uint DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_uint
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_uint	PROC						; COMDAT

; 592  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 593  :     unsigned long x;
; 594  :     unsigned int y;
; 595  :     if (get_ulong(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_ulong
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_uint

; 596  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 604  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_uint:

; 597  :     y = (unsigned int)x;
; 598  : #if (SIZEOF_LONG > SIZEOF_INT)
; 599  :     if (x > ((unsigned long)UINT_MAX))
; 600  :         RANGE_ERROR(y, f, 1, -1);
; 601  : #endif
; 602  :     memcpy(p, (char *)&y, sizeof y);

  00026	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0002a	89 03		 mov	 DWORD PTR [rbx], eax

; 603  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 604  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
np_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_long DD imagerel np_long
	DD	imagerel np_long+52
	DD	imagerel $unwind$np_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_long DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_long
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_long	PROC						; COMDAT

; 608  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 609  :     long x;
; 610  :     if (get_long(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_long
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_long

; 611  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 614  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_long:

; 612  :     memcpy(p, (char *)&x, sizeof x);

  00026	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0002a	89 03		 mov	 DWORD PTR [rbx], eax

; 613  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 614  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
np_long	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ulong DD imagerel np_ulong
	DD	imagerel np_ulong+52
	DD	imagerel $unwind$np_ulong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ulong DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_ulong
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_ulong PROC						; COMDAT

; 618  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 619  :     unsigned long x;
; 620  :     if (get_ulong(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_ulong
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_ulong

; 621  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 624  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_ulong:

; 622  :     memcpy(p, (char *)&x, sizeof x);

  00026	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0002a	89 03		 mov	 DWORD PTR [rbx], eax

; 623  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 624  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
np_ulong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ssize_t DD imagerel np_ssize_t
	DD	imagerel np_ssize_t+54
	DD	imagerel $unwind$np_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ssize_t DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_ssize_t
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_ssize_t PROC						; COMDAT

; 628  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 629  :     Py_ssize_t x;
; 630  :     if (get_ssize_t(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_ssize_t
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_ssize_t

; 631  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 634  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_ssize_t:

; 632  :     memcpy(p, (char *)&x, sizeof x);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0002b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 633  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 634  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
np_ssize_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_size_t DD imagerel np_size_t
	DD	imagerel np_size_t+54
	DD	imagerel $unwind$np_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_size_t DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_size_t
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_size_t PROC						; COMDAT

; 638  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 639  :     size_t x;
; 640  :     if (get_size_t(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_size_t
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_size_t

; 641  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 644  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_size_t:

; 642  :     memcpy(p, (char *)&x, sizeof x);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0002b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 643  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 644  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
np_size_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_longlong DD imagerel np_longlong
	DD	imagerel np_longlong+54
	DD	imagerel $unwind$np_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_longlong DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_longlong
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_longlong PROC					; COMDAT

; 650  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 651  :     PY_LONG_LONG x;
; 652  :     if (get_longlong(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_longlong
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_longlon

; 653  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 656  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_longlon:

; 654  :     memcpy(p, (char *)&x, sizeof x);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0002b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 655  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 656  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
np_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_ulonglong DD imagerel np_ulonglong
	DD	imagerel np_ulonglong+54
	DD	imagerel $unwind$np_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_ulonglong DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_ulonglong
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_ulonglong PROC					; COMDAT

; 660  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 661  :     unsigned PY_LONG_LONG x;
; 662  :     if (get_ulonglong(v, &x) < 0)

  0000c	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 get_ulonglong
  00019	85 c0		 test	 eax, eax
  0001b	79 09		 jns	 SHORT $LN1@np_ulonglo

; 663  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 666  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
$LN1@np_ulonglo:

; 664  :     memcpy(p, (char *)&x, sizeof x);

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0002b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 665  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 666  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
np_ulonglong ENDP
_TEXT	ENDS
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_bool DD imagerel np_bool
	DD	imagerel np_bool+40
	DD	imagerel $unwind$np_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_bool DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_bool
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
np_bool	PROC						; COMDAT

; 672  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 673  :     int y;
; 674  :     BOOL_TYPE x;
; 675  :     y = PyObject_IsTrue(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyObject_IsTrue

; 676  :     if (y < 0)

  00011	85 c0		 test	 eax, eax
  00013	79 09		 jns	 SHORT $LN1@np_bool

; 677  :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 681  : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN1@np_bool:

; 678  :     x = y;
; 679  :     memcpy(p, (char *)&x, sizeof x);

  0001e	88 03		 mov	 BYTE PTR [rbx], al

; 680  :     return 0;

  00020	33 c0		 xor	 eax, eax

; 681  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
np_bool	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@ ; `string'
PUBLIC	__real@bf800000
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_float DD imagerel np_float
	DD	imagerel np_float+90
	DD	imagerel $unwind$np_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_float DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
CONST	SEGMENT
??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@ DB 'required ar'
	DB	'gument is not a float', 00H			; `string'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT np_float
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_float PROC						; COMDAT

; 685  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 686  :     float x = (float)PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00011	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0

; 687  :     if (x == -1 && PyErr_Occurred()) {

  00015	0f 2e 0d 00 00
	00 00		 ucomiss xmm1, DWORD PTR __real@bf800000
  0001c	f3 0f 11 4c 24
	48		 movss	 DWORD PTR x$[rsp], xmm1
  00022	7a 28		 jp	 SHORT $LN1@np_float
  00024	75 26		 jne	 SHORT $LN1@np_float
  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 1c		 je	 SHORT $LN1@np_float

; 688  :         PyErr_SetString(StructError,
; 689  :                         "required argument is not a float");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 690  :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 694  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
$LN1@np_float:

; 691  :     }
; 692  :     memcpy(p, (char *)&x, sizeof x);

  0004c	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00050	89 03		 mov	 DWORD PTR [rbx], eax

; 693  :     return 0;

  00052	33 c0		 xor	 eax, eax

; 694  : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
np_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_double DD imagerel np_double
	DD	imagerel np_double+89
	DD	imagerel $unwind$np_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_double DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_double
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
np_double PROC						; COMDAT

; 698  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 699  :     double x = PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 700  :     if (x == -1 && PyErr_Occurred()) {

  00011	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00019	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR x$[rsp], xmm0
  0001f	7a 28		 jp	 SHORT $LN1@np_double
  00021	75 26		 jne	 SHORT $LN1@np_double
  00023	e8 00 00 00 00	 call	 PyErr_Occurred
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN1@np_double

; 701  :         PyErr_SetString(StructError,
; 702  :                         "required argument is not a float");

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003b	e8 00 00 00 00	 call	 PyErr_SetString

; 703  :         return -1;

  00040	83 c8 ff	 or	 eax, -1

; 707  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN1@np_double:

; 704  :     }
; 705  :     memcpy(p, (char *)&x, sizeof(double));

  00049	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  0004e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 706  :     return 0;

  00051	33 c0		 xor	 eax, eax

; 707  : }

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
np_double ENDP
_TEXT	ENDS
EXTRN	PyLong_AsVoidPtr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$np_void_p DD imagerel np_void_p
	DD	imagerel np_void_p+46
	DD	imagerel $unwind$np_void_p
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$np_void_p DD imagerel np_void_p+46
	DD	imagerel np_void_p+101
	DD	imagerel $chain$0$np_void_p
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$np_void_p DD imagerel np_void_p+101
	DD	imagerel np_void_p+122
	DD	imagerel $chain$2$np_void_p
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$np_void_p DD 020021H
	DD	063400H
	DD	imagerel np_void_p
	DD	imagerel np_void_p+46
	DD	imagerel $unwind$np_void_p
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$np_void_p DD 020521H
	DD	063405H
	DD	imagerel np_void_p
	DD	imagerel np_void_p+46
	DD	imagerel $unwind$np_void_p
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$np_void_p DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT np_void_p
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
np_void_p PROC						; COMDAT

; 711  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 712  :     void *x;
; 713  : 
; 714  :     v = get_pylong(v);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 get_pylong
  00015	48 8b f8	 mov	 rdi, rax

; 715  :     if (v == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN2@np_void_p

; 716  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 723  :     return 0;
; 724  : }

  00020	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN2@np_void_p:

; 717  :     assert(PyLong_Check(v));
; 718  :     x = PyLong_AsVoidPtr(v);

  0002b	48 8b c8	 mov	 rcx, rax
  0002e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00033	e8 00 00 00 00	 call	 PyLong_AsVoidPtr

; 719  :     Py_DECREF(v);

  00038	48 8b cf	 mov	 rcx, rdi
  0003b	48 8b d8	 mov	 rbx, rax
  0003e	e8 00 00 00 00	 call	 _Py_DecRef

; 720  :     if (x == NULL && PyErr_Occurred())

  00043	48 85 db	 test	 rbx, rbx
  00046	75 1d		 jne	 SHORT $LN1@np_void_p
  00048	e8 00 00 00 00	 call	 PyErr_Occurred
  0004d	48 85 c0	 test	 rax, rax
  00050	74 13		 je	 SHORT $LN1@np_void_p

; 721  :         return -1;

  00052	83 c8 ff	 or	 eax, -1
  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 723  :     return 0;
; 724  : }

  0005a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
$LN1@np_void_p:

; 722  :     memcpy(p, (char *)&x, sizeof x);

  00065	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 723  :     return 0;
; 724  : }

  0006d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00072	33 c0		 xor	 eax, eax
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
np_void_p ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_int
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_int	PROC						; COMDAT

; 757  :     long x = 0;
; 758  :     Py_ssize_t i = f->size;

  00000	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	45 33 c0	 xor	 r8d, r8d
  0000a	49 8b ca	 mov	 rcx, r10
  0000d	0f 1f 00	 npad	 3
$LL4@bu_int:

; 759  :     const unsigned char *bytes = (const unsigned char *)p;
; 760  :     do {
; 761  :         x = (x<<8) | *bytes++;

  00010	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00014	41 c1 e0 08	 shl	 r8d, 8

; 762  :     } while (--i > 0);

  00018	48 ff c9	 dec	 rcx
  0001b	44 0b c0	 or	 r8d, eax
  0001e	49 ff c1	 inc	 r9
  00021	48 85 c9	 test	 rcx, rcx
  00024	7f ea		 jg	 SHORT $LL4@bu_int

; 763  :     /* Extend the sign bit. */
; 764  :     if (SIZEOF_LONG > f->size)

  00026	49 83 fa 04	 cmp	 r10, 4
  0002a	7d 17		 jge	 SHORT $LN1@bu_int

; 765  :         x |= -(x & (1L << ((8 * f->size) - 1)));

  0002c	41 c0 e2 03	 shl	 r10b, 3
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00039	d3 e2		 shl	 edx, cl
  0003b	41 23 d0	 and	 edx, r8d
  0003e	f7 da		 neg	 edx
  00040	44 0b c2	 or	 r8d, edx
$LN1@bu_int:

; 766  :     return PyLong_FromLong(x);

  00043	41 8b c8	 mov	 ecx, r8d

; 767  : }

  00046	e9 00 00 00 00	 jmp	 PyLong_FromLong
bu_int	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_uint
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_uint	PROC						; COMDAT

; 772  :     unsigned long x = 0;
; 773  :     Py_ssize_t i = f->size;

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	33 c9		 xor	 ecx, ecx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@bu_uint:

; 774  :     const unsigned char *bytes = (const unsigned char *)p;
; 775  :     do {
; 776  :         x = (x<<8) | *bytes++;

  00010	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00014	c1 e1 08	 shl	 ecx, 8

; 777  :     } while (--i > 0);

  00017	49 ff c8	 dec	 r8
  0001a	0b c8		 or	 ecx, eax
  0001c	49 ff c1	 inc	 r9
  0001f	4d 85 c0	 test	 r8, r8
  00022	7f ec		 jg	 SHORT $LL4@bu_uint

; 778  :     if (x <= LONG_MAX)

  00024	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0002a	77 05		 ja	 SHORT $LN1@bu_uint

; 779  :         return PyLong_FromLong((long)x);
; 780  :     return PyLong_FromUnsignedLong(x);
; 781  : }

  0002c	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@bu_uint:
  00031	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
bu_uint	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_longlong
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_longlong PROC					; COMDAT

; 786  : #ifdef HAVE_LONG_LONG
; 787  :     PY_LONG_LONG x = 0;
; 788  :     Py_ssize_t i = f->size;

  00000	4c 8b 52 08	 mov	 r10, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	45 33 c0	 xor	 r8d, r8d
  0000a	49 8b ca	 mov	 rcx, r10
  0000d	0f 1f 00	 npad	 3
$LL5@bu_longlon:

; 789  :     const unsigned char *bytes = (const unsigned char *)p;
; 790  :     do {
; 791  :         x = (x<<8) | *bytes++;

  00010	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00014	49 c1 e0 08	 shl	 r8, 8

; 792  :     } while (--i > 0);

  00018	48 ff c9	 dec	 rcx
  0001b	4c 0b c0	 or	 r8, rax
  0001e	49 ff c1	 inc	 r9
  00021	48 85 c9	 test	 rcx, rcx
  00024	7f ea		 jg	 SHORT $LL5@bu_longlon

; 793  :     /* Extend the sign bit. */
; 794  :     if (SIZEOF_LONG_LONG > f->size)

  00026	49 83 fa 08	 cmp	 r10, 8
  0002a	7d 19		 jge	 SHORT $LN2@bu_longlon

; 795  :         x |= -(x & ((PY_LONG_LONG)1 << ((8 * f->size) - 1)));

  0002c	41 c0 e2 03	 shl	 r10b, 3
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	41 8d 4a ff	 lea	 ecx, DWORD PTR [r10-1]
  00039	48 d3 e2	 shl	 rdx, cl
  0003c	49 23 d0	 and	 rdx, r8
  0003f	48 f7 da	 neg	 rdx
  00042	4c 0b c2	 or	 r8, rdx
$LN2@bu_longlon:

; 796  :     if (x >= LONG_MIN && x <= LONG_MAX)

  00045	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0004a	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0004f	49 03 c0	 add	 rax, r8
  00052	48 3b c1	 cmp	 rax, rcx
  00055	77 08		 ja	 SHORT $LN1@bu_longlon

; 797  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));

  00057	41 8b c8	 mov	 ecx, r8d

; 799  : #else
; 800  :     return _PyLong_FromByteArray((const unsigned char *)p,
; 801  :                                   8,
; 802  :                                   0, /* little-endian */
; 803  :                       1  /* signed */);
; 804  : #endif
; 805  : }

  0005a	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@bu_longlon:

; 798  :     return PyLong_FromLongLong(x);

  0005f	49 8b c8	 mov	 rcx, r8

; 799  : #else
; 800  :     return _PyLong_FromByteArray((const unsigned char *)p,
; 801  :                                   8,
; 802  :                                   0, /* little-endian */
; 803  :                       1  /* signed */);
; 804  : #endif
; 805  : }

  00062	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
bu_longlong ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_ulonglong
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_ulonglong PROC					; COMDAT

; 810  : #ifdef HAVE_LONG_LONG
; 811  :     unsigned PY_LONG_LONG x = 0;
; 812  :     Py_ssize_t i = f->size;

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	33 c9		 xor	 ecx, ecx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@bu_ulonglo:

; 813  :     const unsigned char *bytes = (const unsigned char *)p;
; 814  :     do {
; 815  :         x = (x<<8) | *bytes++;

  00010	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00014	48 c1 e1 08	 shl	 rcx, 8

; 816  :     } while (--i > 0);

  00018	49 ff c8	 dec	 r8
  0001b	48 0b c8	 or	 rcx, rax
  0001e	49 ff c1	 inc	 r9
  00021	4d 85 c0	 test	 r8, r8
  00024	7f ea		 jg	 SHORT $LL4@bu_ulonglo

; 817  :     if (x <= LONG_MAX)

  00026	48 81 f9 ff ff
	ff 7f		 cmp	 rcx, 2147483647		; 7fffffffH
  0002d	77 05		 ja	 SHORT $LN1@bu_ulonglo

; 818  :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));
; 819  :     return PyLong_FromUnsignedLongLong(x);
; 820  : #else
; 821  :     return _PyLong_FromByteArray((const unsigned char *)p,
; 822  :                                   8,
; 823  :                                   0, /* little-endian */
; 824  :                       0  /* signed */);
; 825  : #endif
; 826  : }

  0002f	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@bu_ulonglo:
  00034	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
bu_ulonglong ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_float
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_float PROC						; COMDAT

; 831  :     return unpack_float(p, 0);

  00000	33 d2		 xor	 edx, edx

; 832  : }

  00002	e9 00 00 00 00	 jmp	 unpack_float
bu_float ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_double
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_double PROC						; COMDAT

; 837  :     return unpack_double(p, 0);

  00000	33 d2		 xor	 edx, edx

; 838  : }

  00002	e9 00 00 00 00	 jmp	 unpack_double
bu_double ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bu_bool
_TEXT	SEGMENT
p$ = 8
f$ = 16
bu_bool	PROC						; COMDAT

; 843  :     char x;
; 844  :     memcpy((char *)&x, p, sizeof x);
; 845  :     return PyBool_FromLong(x != 0);

  00000	33 c0		 xor	 eax, eax
  00002	38 01		 cmp	 BYTE PTR [rcx], al
  00004	0f 95 c0	 setne	 al
  00007	8b c8		 mov	 ecx, eax

; 846  : }

  00009	e9 00 00 00 00	 jmp	 PyBool_FromLong
bu_bool	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_int DD imagerel bp_int
	DD	imagerel bp_int+139
	DD	imagerel $unwind$bp_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_int DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_int
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
bp_int	PROC						; COMDAT

; 850  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 851  :     long x;
; 852  :     Py_ssize_t i;
; 853  :     if (get_long(v, &x) < 0)

  00010	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	49 8b f8	 mov	 rdi, r8
  0001b	e8 00 00 00 00	 call	 get_long
  00020	85 c0		 test	 eax, eax
  00022	79 0e		 jns	 SHORT $LN7@bp_int

; 854  :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 869  : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN7@bp_int:

; 855  :     i = f->size;

  00032	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 856  :     if (i != SIZEOF_LONG) {

  00036	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  0003a	48 83 f8 04	 cmp	 rax, 4
  0003e	74 30		 je	 SHORT $LL3@bp_int

; 857  :         if ((i == 2) && (x < -32768 || x > 32767))

  00040	48 83 f8 02	 cmp	 rax, 2
  00044	75 2a		 jne	 SHORT $LL3@bp_int
  00046	81 f9 00 80 ff
	ff		 cmp	 ecx, -32768		; ffffffffffff8000H
  0004c	7c 08		 jl	 SHORT $LN4@bp_int
  0004e	81 f9 ff 7f 00
	00		 cmp	 ecx, 32767		; 00007fffH
  00054	7e 1a		 jle	 SHORT $LL3@bp_int
$LN4@bp_int:

; 858  :             RANGE_ERROR(x, f, 0, 0xffffL);

  00056	33 d2		 xor	 edx, edx
  00058	48 8b cf	 mov	 rcx, rdi

; 869  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	e9 00 00 00 00	 jmp	 _range_error
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL3@bp_int:

; 859  : #if (SIZEOF_LONG != 4)
; 860  :         else if ((i == 4) && (x < -2147483648L || x > 2147483647L))
; 861  :             RANGE_ERROR(x, f, 0, 0xffffffffL);
; 862  : #endif
; 863  :     }
; 864  :     do {
; 865  :         p[--i] = (char)x;

  00070	48 ff c8	 dec	 rax
  00073	88 0c 18	 mov	 BYTE PTR [rax+rbx], cl

; 866  :         x >>= 8;

  00076	c1 f9 08	 sar	 ecx, 8

; 867  :     } while (i > 0);

  00079	48 85 c0	 test	 rax, rax
  0007c	7f f2		 jg	 SHORT $LL3@bp_int

; 868  :     return 0;

  0007e	33 c0		 xor	 eax, eax

; 869  : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5f		 pop	 rdi
  0008a	c3		 ret	 0
bp_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_uint DD imagerel bp_uint
	DD	imagerel bp_uint+141
	DD	imagerel $unwind$bp_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_uint DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_uint
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
bp_uint	PROC						; COMDAT

; 873  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 874  :     unsigned long x;
; 875  :     Py_ssize_t i;
; 876  :     if (get_ulong(v, &x) < 0)

  00010	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	49 8b f8	 mov	 rdi, r8
  0001b	e8 00 00 00 00	 call	 get_ulong
  00020	85 c0		 test	 eax, eax
  00022	79 0e		 jns	 SHORT $LN6@bp_uint

; 877  :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 890  : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN6@bp_uint:

; 878  :     i = f->size;

  00032	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]

; 879  :     if (i != SIZEOF_LONG) {

  00036	44 8b 4c 24 48	 mov	 r9d, DWORD PTR x$[rsp]
  0003b	49 83 f8 04	 cmp	 r8, 4
  0003f	74 2f		 je	 SHORT $LL3@bp_uint

; 880  :         unsigned long maxint = 1;
; 881  :         maxint <<= (unsigned long)(i * 8);

  00041	42 8d 0c c5 00
	00 00 00	 lea	 ecx, DWORD PTR [r8*8]
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	d3 e0		 shl	 eax, cl

; 882  :         if (x >= maxint)

  00050	44 3b c8	 cmp	 r9d, eax
  00053	72 1b		 jb	 SHORT $LL3@bp_uint

; 883  :             RANGE_ERROR(x, f, 1, maxint - 1);

  00055	ba 01 00 00 00	 mov	 edx, 1
  0005a	48 8b cf	 mov	 rcx, rdi

; 890  : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	e9 00 00 00 00	 jmp	 _range_error
  0006c	0f 1f 40 00	 npad	 4
$LL3@bp_uint:

; 884  :     }
; 885  :     do {
; 886  :         p[--i] = (char)x;

  00070	49 ff c8	 dec	 r8
  00073	45 88 0c 18	 mov	 BYTE PTR [r8+rbx], r9b

; 887  :         x >>= 8;

  00077	41 c1 e9 08	 shr	 r9d, 8

; 888  :     } while (i > 0);

  0007b	4d 85 c0	 test	 r8, r8
  0007e	7f f0		 jg	 SHORT $LL3@bp_uint

; 889  :     return 0;

  00080	33 c0		 xor	 eax, eax

; 890  : }

  00082	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
bp_uint	ENDP
_TEXT	ENDS
EXTRN	_PyLong_AsByteArray:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_longlong DD imagerel bp_longlong
	DD	imagerel bp_longlong+92
	DD	imagerel $unwind$bp_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_longlong DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_longlong
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
bp_longlong PROC					; COMDAT

; 894  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 895  :     int res;
; 896  :     v = get_pylong(v);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 get_pylong
  00015	48 8b f8	 mov	 rdi, rax

; 897  :     if (v == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN1@bp_longlon

; 898  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 906  : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@bp_longlon:

; 899  :     res = _PyLong_AsByteArray((PyLongObject *)v,
; 900  :                               (unsigned char *)p,
; 901  :                               8,
; 902  :                               0, /* little_endian */
; 903  :                   1  /* signed */);

  0002b	45 33 c9	 xor	 r9d, r9d
  0002e	48 8b d3	 mov	 rdx, rbx
  00031	48 8b c8	 mov	 rcx, rax
  00034	45 8d 41 08	 lea	 r8d, QWORD PTR [r9+8]
  00038	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00040	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 904  :     Py_DECREF(v);

  00045	48 8b cf	 mov	 rcx, rdi
  00048	8b d8		 mov	 ebx, eax
  0004a	e8 00 00 00 00	 call	 _Py_DecRef

; 905  :     return res;

  0004f	8b c3		 mov	 eax, ebx

; 906  : }

  00051	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
bp_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_ulonglong DD imagerel bp_ulonglong
	DD	imagerel bp_ulonglong+92
	DD	imagerel $unwind$bp_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_ulonglong DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_ulonglong
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
bp_ulonglong PROC					; COMDAT

; 910  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 911  :     int res;
; 912  :     v = get_pylong(v);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 get_pylong
  00015	48 8b f8	 mov	 rdi, rax

; 913  :     if (v == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN1@bp_ulonglo

; 914  :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 922  : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@bp_ulonglo:

; 915  :     res = _PyLong_AsByteArray((PyLongObject *)v,
; 916  :                               (unsigned char *)p,
; 917  :                               8,
; 918  :                               0, /* little_endian */
; 919  :                   0  /* signed */);

  0002b	45 33 c9	 xor	 r9d, r9d
  0002e	48 8b d3	 mov	 rdx, rbx
  00031	48 8b c8	 mov	 rcx, rax
  00034	45 8d 41 08	 lea	 r8d, QWORD PTR [r9+8]
  00038	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00040	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 920  :     Py_DECREF(v);

  00045	48 8b cf	 mov	 rcx, rdi
  00048	8b d8		 mov	 ebx, eax
  0004a	e8 00 00 00 00	 call	 _Py_DecRef

; 921  :     return res;

  0004f	8b c3		 mov	 eax, ebx

; 922  : }

  00051	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
bp_ulonglong ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Pack4:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_float DD imagerel bp_float
	DD	imagerel bp_float+106
	DD	imagerel $unwind$bp_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_float DD 041101H
	DD	026811H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_float
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
bp_float PROC						; COMDAT

; 926  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 927  :     double x = PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00011	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 928  :     if (x == -1 && PyErr_Occurred()) {

  00016	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0001e	66 0f 28 f0	 movapd	 xmm6, xmm0
  00022	7a 2d		 jp	 SHORT $LN1@bp_float
  00024	75 2b		 jne	 SHORT $LN1@bp_float
  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 21		 je	 SHORT $LN1@bp_float

; 929  :         PyErr_SetString(StructError,
; 930  :                         "required argument is not a float");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 931  :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 934  : }

  00046	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN1@bp_float:

; 932  :     }
; 933  :     return _PyFloat_Pack4(x, (unsigned char *)p, 0);

  00051	66 0f 28 c6	 movapd	 xmm0, xmm6
  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 8b d3	 mov	 rdx, rbx

; 934  : }

  0005b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5b		 pop	 rbx
  00065	e9 00 00 00 00	 jmp	 _PyFloat_Pack4
bp_float ENDP
_TEXT	ENDS
EXTRN	_PyFloat_Pack8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_double DD imagerel bp_double
	DD	imagerel bp_double+106
	DD	imagerel $unwind$bp_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_double DD 041101H
	DD	026811H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_double
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
bp_double PROC						; COMDAT

; 938  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 939  :     double x = PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00011	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 940  :     if (x == -1 && PyErr_Occurred()) {

  00016	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0001e	66 0f 28 f0	 movapd	 xmm6, xmm0
  00022	7a 2d		 jp	 SHORT $LN1@bp_double
  00024	75 2b		 jne	 SHORT $LN1@bp_double
  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 21		 je	 SHORT $LN1@bp_double

; 941  :         PyErr_SetString(StructError,
; 942  :                         "required argument is not a float");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 943  :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 946  : }

  00046	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN1@bp_double:

; 944  :     }
; 945  :     return _PyFloat_Pack8(x, (unsigned char *)p, 0);

  00051	66 0f 28 c6	 movapd	 xmm0, xmm6
  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 8b d3	 mov	 rdx, rbx

; 946  : }

  0005b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5b		 pop	 rbx
  00065	e9 00 00 00 00	 jmp	 _PyFloat_Pack8
bp_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bp_bool DD imagerel bp_bool
	DD	imagerel bp_bool+40
	DD	imagerel $unwind$bp_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bp_bool DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bp_bool
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
bp_bool	PROC						; COMDAT

; 950  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 951  :     int y;
; 952  :     y = PyObject_IsTrue(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 PyObject_IsTrue

; 953  :     if (y < 0)

  00011	85 c0		 test	 eax, eax
  00013	79 09		 jns	 SHORT $LN1@bp_bool

; 954  :         return -1;

  00015	83 c8 ff	 or	 eax, -1

; 957  : }

  00018	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001c	5b		 pop	 rbx
  0001d	c3		 ret	 0
$LN1@bp_bool:

; 955  :     *p = (char)y;

  0001e	88 03		 mov	 BYTE PTR [rbx], al

; 956  :     return 0;

  00020	33 c0		 xor	 eax, eax

; 957  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
bp_bool	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_int
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_int	PROC						; COMDAT

; 985  :     long x = 0;
; 986  :     Py_ssize_t i = f->size;

  00000	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  00004	45 33 c0	 xor	 r8d, r8d
  00007	49 8b d1	 mov	 rdx, r9
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL4@lu_int:

; 987  :     const unsigned char *bytes = (const unsigned char *)p;
; 988  :     do {
; 989  :         x = (x<<8) | bytes[--i];

  00010	0f b6 44 0a ff	 movzx	 eax, BYTE PTR [rdx+rcx-1]
  00015	41 c1 e0 08	 shl	 r8d, 8
  00019	48 ff ca	 dec	 rdx
  0001c	41 0b c0	 or	 eax, r8d
  0001f	44 8b c0	 mov	 r8d, eax

; 990  :     } while (i > 0);

  00022	48 85 d2	 test	 rdx, rdx
  00025	7f e9		 jg	 SHORT $LL4@lu_int

; 991  :     /* Extend the sign bit. */
; 992  :     if (SIZEOF_LONG > f->size)

  00027	49 83 f9 04	 cmp	 r9, 4
  0002b	7d 16		 jge	 SHORT $LN1@lu_int

; 993  :         x |= -(x & (1L << ((8 * f->size) - 1)));

  0002d	41 c0 e1 03	 shl	 r9b, 3
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	41 8d 49 ff	 lea	 ecx, DWORD PTR [r9-1]
  0003a	d3 e2		 shl	 edx, cl
  0003c	23 d0		 and	 edx, eax
  0003e	f7 da		 neg	 edx
  00040	44 0b c2	 or	 r8d, edx
$LN1@lu_int:

; 994  :     return PyLong_FromLong(x);

  00043	41 8b c8	 mov	 ecx, r8d

; 995  : }

  00046	e9 00 00 00 00	 jmp	 PyLong_FromLong
lu_int	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_uint
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_uint	PROC						; COMDAT

; 1000 :     unsigned long x = 0;
; 1001 :     Py_ssize_t i = f->size;

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	33 c9		 xor	 ecx, ecx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@lu_uint:

; 1002 :     const unsigned char *bytes = (const unsigned char *)p;
; 1003 :     do {
; 1004 :         x = (x<<8) | bytes[--i];

  00010	43 0f b6 44 08
	ff		 movzx	 eax, BYTE PTR [r8+r9-1]
  00016	c1 e1 08	 shl	 ecx, 8
  00019	49 ff c8	 dec	 r8
  0001c	0b c1		 or	 eax, ecx
  0001e	8b c8		 mov	 ecx, eax

; 1005 :     } while (i > 0);

  00020	4d 85 c0	 test	 r8, r8
  00023	7f eb		 jg	 SHORT $LL4@lu_uint

; 1006 :     if (x <= LONG_MAX)

  00025	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0002a	77 05		 ja	 SHORT $LN1@lu_uint

; 1007 :         return PyLong_FromLong((long)x);
; 1008 :     return PyLong_FromUnsignedLong((long)x);
; 1009 : }

  0002c	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@lu_uint:
  00031	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
lu_uint	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_longlong
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_longlong PROC					; COMDAT

; 1014 : #ifdef HAVE_LONG_LONG
; 1015 :     PY_LONG_LONG x = 0;
; 1016 :     Py_ssize_t i = f->size;

  00000	4c 8b 4a 08	 mov	 r9, QWORD PTR [rdx+8]
  00004	45 33 c0	 xor	 r8d, r8d
  00007	49 8b d1	 mov	 rdx, r9
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL5@lu_longlon:

; 1017 :     const unsigned char *bytes = (const unsigned char *)p;
; 1018 :     do {
; 1019 :         x = (x<<8) | bytes[--i];

  00010	0f b6 44 0a ff	 movzx	 eax, BYTE PTR [rdx+rcx-1]
  00015	49 c1 e0 08	 shl	 r8, 8
  00019	48 ff ca	 dec	 rdx
  0001c	49 0b c0	 or	 rax, r8
  0001f	4c 8b c0	 mov	 r8, rax

; 1020 :     } while (i > 0);

  00022	48 85 d2	 test	 rdx, rdx
  00025	7f e9		 jg	 SHORT $LL5@lu_longlon

; 1021 :     /* Extend the sign bit. */
; 1022 :     if (SIZEOF_LONG_LONG > f->size)

  00027	49 83 f9 08	 cmp	 r9, 8
  0002b	7d 19		 jge	 SHORT $LN2@lu_longlon

; 1023 :         x |= -(x & ((PY_LONG_LONG)1 << ((8 * f->size) - 1)));

  0002d	41 c0 e1 03	 shl	 r9b, 3
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	41 8d 49 ff	 lea	 ecx, DWORD PTR [r9-1]
  0003a	48 d3 e2	 shl	 rdx, cl
  0003d	48 23 d0	 and	 rdx, rax
  00040	48 f7 da	 neg	 rdx
  00043	4c 0b c2	 or	 r8, rdx
$LN2@lu_longlon:

; 1024 :     if (x >= LONG_MIN && x <= LONG_MAX)

  00046	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0004b	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00050	49 03 c0	 add	 rax, r8
  00053	48 3b c1	 cmp	 rax, rcx
  00056	77 08		 ja	 SHORT $LN1@lu_longlon

; 1025 :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, PY_LONG_LONG, long));

  00058	41 8b c8	 mov	 ecx, r8d

; 1027 : #else
; 1028 :     return _PyLong_FromByteArray((const unsigned char *)p,
; 1029 :                                   8,
; 1030 :                                   1, /* little-endian */
; 1031 :                       1  /* signed */);
; 1032 : #endif
; 1033 : }

  0005b	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@lu_longlon:

; 1026 :     return PyLong_FromLongLong(x);

  00060	49 8b c8	 mov	 rcx, r8

; 1027 : #else
; 1028 :     return _PyLong_FromByteArray((const unsigned char *)p,
; 1029 :                                   8,
; 1030 :                                   1, /* little-endian */
; 1031 :                       1  /* signed */);
; 1032 : #endif
; 1033 : }

  00063	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
lu_longlong ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_ulonglong
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_ulonglong PROC					; COMDAT

; 1038 : #ifdef HAVE_LONG_LONG
; 1039 :     unsigned PY_LONG_LONG x = 0;
; 1040 :     Py_ssize_t i = f->size;

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	4c 8b c9	 mov	 r9, rcx
  00007	33 c9		 xor	 ecx, ecx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@lu_ulonglo:

; 1041 :     const unsigned char *bytes = (const unsigned char *)p;
; 1042 :     do {
; 1043 :         x = (x<<8) | bytes[--i];

  00010	43 0f b6 44 08
	ff		 movzx	 eax, BYTE PTR [r8+r9-1]
  00016	48 c1 e1 08	 shl	 rcx, 8
  0001a	49 ff c8	 dec	 r8
  0001d	48 0b c1	 or	 rax, rcx
  00020	48 8b c8	 mov	 rcx, rax

; 1044 :     } while (i > 0);

  00023	4d 85 c0	 test	 r8, r8
  00026	7f e8		 jg	 SHORT $LL4@lu_ulonglo

; 1045 :     if (x <= LONG_MAX)

  00028	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  0002e	77 05		 ja	 SHORT $LN1@lu_ulonglo

; 1046 :         return PyLong_FromLong(Py_SAFE_DOWNCAST(x, unsigned PY_LONG_LONG, long));
; 1047 :     return PyLong_FromUnsignedLongLong(x);
; 1048 : #else
; 1049 :     return _PyLong_FromByteArray((const unsigned char *)p,
; 1050 :                                   8,
; 1051 :                                   1, /* little-endian */
; 1052 :                       0  /* signed */);
; 1053 : #endif
; 1054 : }

  00030	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@lu_ulonglo:
  00035	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
lu_ulonglong ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_float
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_float PROC						; COMDAT

; 1059 :     return unpack_float(p, 1);

  00000	ba 01 00 00 00	 mov	 edx, 1

; 1060 : }

  00005	e9 00 00 00 00	 jmp	 unpack_float
lu_float ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lu_double
_TEXT	SEGMENT
p$ = 8
f$ = 16
lu_double PROC						; COMDAT

; 1065 :     return unpack_double(p, 1);

  00000	ba 01 00 00 00	 mov	 edx, 1

; 1066 : }

  00005	e9 00 00 00 00	 jmp	 unpack_double
lu_double ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_int DD imagerel lp_int
	DD	imagerel lp_int+141
	DD	imagerel $unwind$lp_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_int DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_int
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
lp_int	PROC						; COMDAT

; 1070 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1071 :     long x;
; 1072 :     Py_ssize_t i;
; 1073 :     if (get_long(v, &x) < 0)

  00010	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	49 8b f8	 mov	 rdi, r8
  0001b	e8 00 00 00 00	 call	 get_long
  00020	85 c0		 test	 eax, eax
  00022	79 0e		 jns	 SHORT $LN7@lp_int

; 1074 :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 1089 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN7@lp_int:

; 1075 :     i = f->size;

  00032	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]

; 1076 :     if (i != SIZEOF_LONG) {

  00036	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  0003a	48 83 f9 04	 cmp	 rcx, 4
  0003e	74 30		 je	 SHORT $LL3@lp_int

; 1077 :         if ((i == 2) && (x < -32768 || x > 32767))

  00040	48 83 f9 02	 cmp	 rcx, 2
  00044	75 2a		 jne	 SHORT $LL3@lp_int
  00046	3d 00 80 ff ff	 cmp	 eax, -32768		; ffffffffffff8000H
  0004b	7c 07		 jl	 SHORT $LN4@lp_int
  0004d	3d ff 7f 00 00	 cmp	 eax, 32767		; 00007fffH
  00052	7e 1c		 jle	 SHORT $LL3@lp_int
$LN4@lp_int:

; 1078 :             RANGE_ERROR(x, f, 0, 0xffffL);

  00054	33 d2		 xor	 edx, edx
  00056	48 8b cf	 mov	 rcx, rdi

; 1089 : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	e9 00 00 00 00	 jmp	 _range_error
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@lp_int:

; 1079 : #if (SIZEOF_LONG != 4)
; 1080 :         else if ((i == 4) && (x < -2147483648L || x > 2147483647L))
; 1081 :             RANGE_ERROR(x, f, 0, 0xffffffffL);
; 1082 : #endif
; 1083 :     }
; 1084 :     do {
; 1085 :         *p++ = (char)x;

  00070	88 03		 mov	 BYTE PTR [rbx], al

; 1086 :         x >>= 8;
; 1087 :     } while (--i > 0);

  00072	48 ff c9	 dec	 rcx
  00075	48 ff c3	 inc	 rbx
  00078	c1 f8 08	 sar	 eax, 8
  0007b	48 85 c9	 test	 rcx, rcx
  0007e	7f f0		 jg	 SHORT $LL3@lp_int

; 1088 :     return 0;

  00080	33 c0		 xor	 eax, eax

; 1089 : }

  00082	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
lp_int	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_uint DD imagerel lp_uint
	DD	imagerel lp_uint+143
	DD	imagerel $unwind$lp_uint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_uint DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_uint
_TEXT	SEGMENT
p$ = 48
v$ = 56
f$ = 64
x$ = 72
lp_uint	PROC						; COMDAT

; 1093 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 1094 :     unsigned long x;
; 1095 :     Py_ssize_t i;
; 1096 :     if (get_ulong(v, &x) < 0)

  00010	48 8d 54 24 48	 lea	 rdx, QWORD PTR x$[rsp]
  00015	48 8b c8	 mov	 rcx, rax
  00018	49 8b f8	 mov	 rdi, r8
  0001b	e8 00 00 00 00	 call	 get_ulong
  00020	85 c0		 test	 eax, eax
  00022	79 0e		 jns	 SHORT $LN6@lp_uint

; 1097 :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 1110 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN6@lp_uint:

; 1098 :     i = f->size;

  00032	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]

; 1099 :     if (i != SIZEOF_LONG) {

  00036	44 8b 4c 24 48	 mov	 r9d, DWORD PTR x$[rsp]
  0003b	49 83 f8 04	 cmp	 r8, 4
  0003f	74 2f		 je	 SHORT $LL3@lp_uint

; 1100 :         unsigned long maxint = 1;
; 1101 :         maxint <<= (unsigned long)(i * 8);

  00041	42 8d 0c c5 00
	00 00 00	 lea	 ecx, DWORD PTR [r8*8]
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	d3 e0		 shl	 eax, cl

; 1102 :         if (x >= maxint)

  00050	44 3b c8	 cmp	 r9d, eax
  00053	72 1b		 jb	 SHORT $LL3@lp_uint

; 1103 :             RANGE_ERROR(x, f, 1, maxint - 1);

  00055	ba 01 00 00 00	 mov	 edx, 1
  0005a	48 8b cf	 mov	 rcx, rdi

; 1110 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	e9 00 00 00 00	 jmp	 _range_error
  0006c	0f 1f 40 00	 npad	 4
$LL3@lp_uint:

; 1104 :     }
; 1105 :     do {
; 1106 :         *p++ = (char)x;

  00070	44 88 0b	 mov	 BYTE PTR [rbx], r9b

; 1107 :         x >>= 8;
; 1108 :     } while (--i > 0);

  00073	49 ff c8	 dec	 r8
  00076	48 ff c3	 inc	 rbx
  00079	41 c1 e9 08	 shr	 r9d, 8
  0007d	4d 85 c0	 test	 r8, r8
  00080	7f ee		 jg	 SHORT $LL3@lp_uint

; 1109 :     return 0;

  00082	33 c0		 xor	 eax, eax

; 1110 : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
lp_uint	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_longlong DD imagerel lp_longlong
	DD	imagerel lp_longlong+95
	DD	imagerel $unwind$lp_longlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_longlong DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_longlong
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
lp_longlong PROC					; COMDAT

; 1114 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1115 :     int res;
; 1116 :     v = get_pylong(v);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 get_pylong
  00015	48 8b f8	 mov	 rdi, rax

; 1117 :     if (v == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN1@lp_longlon

; 1118 :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 1126 : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@lp_longlon:

; 1119 :     res = _PyLong_AsByteArray((PyLongObject*)v,
; 1120 :                               (unsigned char *)p,
; 1121 :                               8,
; 1122 :                               1, /* little_endian */
; 1123 :                   1  /* signed */);

  0002b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00031	48 8b d3	 mov	 rdx, rbx
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  0003b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00043	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 1124 :     Py_DECREF(v);

  00048	48 8b cf	 mov	 rcx, rdi
  0004b	8b d8		 mov	 ebx, eax
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 1125 :     return res;

  00052	8b c3		 mov	 eax, ebx

; 1126 : }

  00054	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00059	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
lp_longlong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_ulonglong DD imagerel lp_ulonglong
	DD	imagerel lp_ulonglong+95
	DD	imagerel $unwind$lp_ulonglong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_ulonglong DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_ulonglong
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
lp_ulonglong PROC					; COMDAT

; 1130 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1131 :     int res;
; 1132 :     v = get_pylong(v);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 get_pylong
  00015	48 8b f8	 mov	 rdi, rax

; 1133 :     if (v == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0e		 jne	 SHORT $LN1@lp_ulonglo

; 1134 :         return -1;

  0001d	83 c8 ff	 or	 eax, -1

; 1142 : }

  00020	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN1@lp_ulonglo:

; 1135 :     res = _PyLong_AsByteArray((PyLongObject*)v,
; 1136 :                               (unsigned char *)p,
; 1137 :                               8,
; 1138 :                               1, /* little_endian */
; 1139 :                   0  /* signed */);

  0002b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00031	48 8b d3	 mov	 rdx, rbx
  00034	48 8b c8	 mov	 rcx, rax
  00037	45 8d 41 07	 lea	 r8d, QWORD PTR [r9+7]
  0003b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00043	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 1140 :     Py_DECREF(v);

  00048	48 8b cf	 mov	 rcx, rdi
  0004b	8b d8		 mov	 ebx, eax
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 1141 :     return res;

  00052	8b c3		 mov	 eax, ebx

; 1142 : }

  00054	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00059	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
lp_ulonglong ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_float DD imagerel lp_float
	DD	imagerel lp_float+109
	DD	imagerel $unwind$lp_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_float DD 041101H
	DD	026811H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_float
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
lp_float PROC						; COMDAT

; 1146 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1147 :     double x = PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00011	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1148 :     if (x == -1 && PyErr_Occurred()) {

  00016	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0001e	66 0f 28 f0	 movapd	 xmm6, xmm0
  00022	7a 2d		 jp	 SHORT $LN1@lp_float
  00024	75 2b		 jne	 SHORT $LN1@lp_float
  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 21		 je	 SHORT $LN1@lp_float

; 1149 :         PyErr_SetString(StructError,
; 1150 :                         "required argument is not a float");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 1151 :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 1154 : }

  00046	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN1@lp_float:

; 1152 :     }
; 1153 :     return _PyFloat_Pack4(x, (unsigned char *)p, 1);

  00051	66 0f 28 c6	 movapd	 xmm0, xmm6
  00055	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005b	48 8b d3	 mov	 rdx, rbx

; 1154 : }

  0005e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	e9 00 00 00 00	 jmp	 _PyFloat_Pack4
lp_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lp_double DD imagerel lp_double
	DD	imagerel lp_double+109
	DD	imagerel $unwind$lp_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lp_double DD 041101H
	DD	026811H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lp_double
_TEXT	SEGMENT
p$ = 64
v$ = 72
f$ = 80
lp_double PROC						; COMDAT

; 1158 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1159 :     double x = PyFloat_AsDouble(v);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00011	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1160 :     if (x == -1 && PyErr_Occurred()) {

  00016	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0001e	66 0f 28 f0	 movapd	 xmm6, xmm0
  00022	7a 2d		 jp	 SHORT $LN1@lp_double
  00024	75 2b		 jne	 SHORT $LN1@lp_double
  00026	e8 00 00 00 00	 call	 PyErr_Occurred
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 21		 je	 SHORT $LN1@lp_double

; 1161 :         PyErr_SetString(StructError,
; 1162 :                         "required argument is not a float");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FJNAGIKC@required?5argument?5is?5not?5a?5float@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 1163 :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 1166 : }

  00046	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN1@lp_double:

; 1164 :     }
; 1165 :     return _PyFloat_Pack8(x, (unsigned char *)p, 1);

  00051	66 0f 28 c6	 movapd	 xmm0, xmm6
  00055	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005b	48 8b d3	 mov	 rdx, rbx

; 1166 : }

  0005e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5b		 pop	 rbx
  00068	e9 00 00 00 00	 jmp	 _PyFloat_Pack8
lp_double ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT whichtable
_TEXT	SEGMENT
pfmt$ = 8
whichtable PROC						; COMDAT

; 1194 :     const char *fmt = (*pfmt)++; /* May be backed out of later */

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8d 40 01	 lea	 r8, QWORD PTR [rax+1]
  00007	4c 89 01	 mov	 QWORD PTR [rcx], r8

; 1195 :     switch (*fmt) {

  0000a	0f be 10	 movsx	 edx, BYTE PTR [rax]
  0000d	83 ea 21	 sub	 edx, 33			; 00000021H
  00010	74 29		 je	 SHORT $LN6@whichtable
  00012	83 ea 1b	 sub	 edx, 27
  00015	74 1c		 je	 SHORT $LN7@whichtable
  00017	ff ca		 dec	 edx
  00019	74 18		 je	 SHORT $LN7@whichtable
  0001b	ff ca		 dec	 edx
  0001d	74 1c		 je	 SHORT $LN6@whichtable
  0001f	83 fa 02	 cmp	 edx, 2
  00022	74 07		 je	 SHORT $LN1@whichtable

; 1201 :     case '=': { /* Host byte order -- different from native in alignment! */
; 1202 :         int n = 1;
; 1203 :         char *p = (char *) &n;
; 1204 :         if (*p == 1)
; 1205 :             return lilendian_table;
; 1206 :         else
; 1207 :             return bigendian_table;
; 1208 :     }
; 1209 :     default:
; 1210 :         --*pfmt; /* Back out of pointer increment */

  00024	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@whichtable:

; 1211 :         /* Fall through */
; 1212 :     case '@':
; 1213 :         return native_table;

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:native_table

; 1214 :     }
; 1215 : }

  00032	c3		 ret	 0
$LN7@whichtable:

; 1196 :     case '<':
; 1197 :         return lilendian_table;

  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:lilendian_table

; 1214 :     }
; 1215 : }

  0003a	c3		 ret	 0
$LN6@whichtable:

; 1198 :     case '>':
; 1199 :     case '!': /* Network byte order is big-endian */
; 1200 :         return bigendian_table;

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigendian_table

; 1214 :     }
; 1215 : }

  00042	c3		 ret	 0
whichtable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$getentry DD imagerel getentry
	DD	imagerel getentry+69
	DD	imagerel $unwind$getentry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getentry DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@
CONST	SEGMENT
??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@ DB 'bad char in str'
	DB	'uct format', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT getentry
_TEXT	SEGMENT
c$ = 48
f$ = 56
getentry PROC						; COMDAT

; 1222 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1223 :     for (; f->format != '\0'; f++) {

  00004	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00007	84 c0		 test	 al, al
  00009	74 18		 je	 SHORT $LN2@getentry
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@getentry:

; 1224 :         if (f->format == c) {

  00010	0f be c0	 movsx	 eax, al
  00013	3b c1		 cmp	 eax, ecx
  00015	74 26		 je	 SHORT $LN8@getentry

; 1223 :     for (; f->format != '\0'; f++) {

  00017	0f b6 42 28	 movzx	 eax, BYTE PTR [rdx+40]
  0001b	48 83 c2 28	 add	 rdx, 40			; 00000028H
  0001f	84 c0		 test	 al, al
  00021	75 ed		 jne	 SHORT $LL4@getentry
$LN2@getentry:

; 1226 :         }
; 1227 :     }
; 1228 :     PyErr_SetString(StructError, "bad char in struct format");

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@CKDNFKKL@bad?5char?5in?5struct?5format?$AA@
  00031	e8 00 00 00 00	 call	 PyErr_SetString

; 1229 :     return NULL;

  00036	33 c0		 xor	 eax, eax

; 1230 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN8@getentry:

; 1225 :             return f;

  0003d	48 8b c2	 mov	 rax, rdx

; 1230 : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
getentry ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT align
_TEXT	SEGMENT
size$ = 8
c$ = 16
e$ = 24
align	PROC						; COMDAT

; 1238 :     Py_ssize_t extra;
; 1239 : 
; 1240 :     if (e->format == c) {

  00000	41 38 10	 cmp	 BYTE PTR [r8], dl
  00003	75 39		 jne	 SHORT $LN2@align

; 1241 :         if (e->alignment && size > 0) {

  00005	49 83 78 10 00	 cmp	 QWORD PTR [r8+16], 0
  0000a	74 32		 je	 SHORT $LN2@align
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	7e 2d		 jle	 SHORT $LN2@align

; 1242 :             extra = (e->alignment - 1) - (size - 1) % (e->alignment);

  00011	4d 8b 48 10	 mov	 r9, QWORD PTR [r8+16]
  00015	48 8d 41 ff	 lea	 rax, QWORD PTR [rcx-1]
  00019	48 99		 cdq
  0001b	49 f7 f9	 idiv	 r9

; 1243 :             if (extra > PY_SSIZE_T_MAX - size)

  0001e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00028	48 2b c1	 sub	 rax, rcx
  0002b	4c 2b ca	 sub	 r9, rdx
  0002e	49 ff c9	 dec	 r9
  00031	4c 3b c8	 cmp	 r9, rax
  00034	7e 05		 jle	 SHORT $LN1@align

; 1244 :                 return -1;

  00036	48 83 c8 ff	 or	 rax, -1

; 1249 : }

  0003a	c3		 ret	 0
$LN1@align:

; 1245 :             size += extra;

  0003b	49 03 c9	 add	 rcx, r9
$LN2@align:

; 1246 :         }
; 1247 :     }
; 1248 :     return size;

  0003e	48 8b c1	 mov	 rax, rcx

; 1249 : }

  00041	c3		 ret	 0
align	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@ ; `string'
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$prepare_s DD imagerel prepare_s
	DD	imagerel prepare_s+866
	DD	imagerel $unwind$prepare_s
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$prepare_s DD 0c1c01H
	DD	0d641cH
	DD	0c541cH
	DD	0b341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@ DB 'total struct s'
	DB	'ize too long', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@
CONST	SEGMENT
??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@ DB 'repeat count'
	DB	' given without format specifier', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT prepare_s
_TEXT	SEGMENT
fmt$ = 80
self$ = 80
prepare_s PROC						; COMDAT

; 1256 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1257 :     const formatdef *f;
; 1258 :     const formatdef *e;
; 1259 :     formatcode *codes;
; 1260 : 
; 1261 :     const char *s;
; 1262 :     const char *fmt;
; 1263 :     char c;
; 1264 :     Py_ssize_t size, len, num, itemsize;
; 1265 : 
; 1266 :     fmt = PyBytes_AS_STRING(self->s_format);

  0001c	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  00020	4c 8b f1	 mov	 r14, rcx

; 1267 : 
; 1268 :     f = whichtable((char **)&fmt);

  00023	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fmt$[rsp]
  00028	48 83 c0 78	 add	 rax, 120		; 00000078H
  0002c	48 89 44 24 50	 mov	 QWORD PTR fmt$[rsp], rax
  00031	e8 00 00 00 00	 call	 whichtable

; 1269 : 
; 1270 :     s = fmt;

  00036	4c 8b 64 24 50	 mov	 r12, QWORD PTR fmt$[rsp]

; 1271 :     size = 0;
; 1272 :     len = 0;
; 1273 :     while ((c = *s++) != '\0') {

  0003b	41 0f b6 1c 24	 movzx	 ebx, BYTE PTR [r12]
  00040	45 33 ed	 xor	 r13d, r13d
  00043	33 ed		 xor	 ebp, ebp
  00045	4c 8b f8	 mov	 r15, rax
  00048	49 8b f4	 mov	 rsi, r12
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ctype_table
  00052	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
  0005c	84 db		 test	 bl, bl
  0005e	0f 84 27 01 00
	00		 je	 $LN68@prepare_s
  00064	48 b9 cc cc cc
	cc cc cc cc 0c	 mov	 rcx, 922337203685477580	; 0cccccccccccccccH
  0006e	66 90		 npad	 2
$LL36@prepare_s:

; 1274 :         if (Py_ISSPACE(Py_CHARMASK(c)))

  00070	0f b6 c3	 movzx	 eax, bl
  00073	48 ff c6	 inc	 rsi
  00076	f6 04 82 08	 test	 BYTE PTR [rdx+rax*4], 8
  0007a	0f 85 f6 00 00
	00		 jne	 $LN62@prepare_s

; 1275 :             continue;
; 1276 :         if ('0' <= c && c <= '9') {

  00080	8d 43 d0	 lea	 eax, DWORD PTR [rbx-48]
  00083	3c 09		 cmp	 al, 9
  00085	77 75		 ja	 SHORT $LN33@prepare_s

; 1277 :             num = c - '0';

  00087	0f be c3	 movsx	 eax, bl

; 1278 :             while ('0' <= (c = *s++) && c <= '9') {

  0008a	0f b6 1e	 movzx	 ebx, BYTE PTR [rsi]
  0008d	83 e8 30	 sub	 eax, 48			; 00000030H
  00090	48 63 f8	 movsxd	 rdi, eax
  00093	80 fb 30	 cmp	 bl, 48			; 00000030H
  00096	7c 45		 jl	 SHORT $LN59@prepare_s
$LL32@prepare_s:
  00098	48 ff c6	 inc	 rsi
  0009b	80 fb 39	 cmp	 bl, 57			; 00000039H
  0009e	7f 40		 jg	 SHORT $LN31@prepare_s

; 1279 :                 /* overflow-safe version of
; 1280 :                    if (num*10 + (c - '0') > PY_SSIZE_T_MAX) { ... } */
; 1281 :                 if (num >= PY_SSIZE_T_MAX / 10 && (
; 1282 :                         num > PY_SSIZE_T_MAX / 10 ||
; 1283 :                         (c - '0') > PY_SSIZE_T_MAX % 10))

  000a0	48 3b f9	 cmp	 rdi, rcx
  000a3	7c 15		 jl	 SHORT $LN30@prepare_s
  000a5	0f 8f 18 01 00
	00		 jg	 $overflow$21276
  000ab	0f be c3	 movsx	 eax, bl
  000ae	83 e8 30	 sub	 eax, 48			; 00000030H
  000b1	83 f8 07	 cmp	 eax, 7
  000b4	0f 8f 09 01 00
	00		 jg	 $overflow$21276
$LN30@prepare_s:

; 1284 :                     goto overflow;
; 1285 :                 num = num*10 + (c - '0');

  000ba	0f be c3	 movsx	 eax, bl
  000bd	0f b6 1e	 movzx	 ebx, BYTE PTR [rsi]
  000c0	83 e8 30	 sub	 eax, 48			; 00000030H
  000c3	48 63 c8	 movsxd	 rcx, eax
  000c6	48 8d 04 bf	 lea	 rax, QWORD PTR [rdi+rdi*4]
  000ca	48 8d 3c 41	 lea	 rdi, QWORD PTR [rcx+rax*2]
  000ce	48 b9 cc cc cc
	cc cc cc cc 0c	 mov	 rcx, 922337203685477580	; 0cccccccccccccccH
  000d8	80 fb 30	 cmp	 bl, 48			; 00000030H
  000db	7d bb		 jge	 SHORT $LL32@prepare_s
$LN59@prepare_s:

; 1278 :             while ('0' <= (c = *s++) && c <= '9') {

  000dd	48 ff c6	 inc	 rsi
$LN31@prepare_s:

; 1286 :             }
; 1287 :             if (c == '\0') {

  000e0	84 db		 test	 bl, bl
  000e2	75 1d		 jne	 SHORT $LN27@prepare_s

; 1288 :                 PyErr_SetString(StructError,
; 1289 :                                 "repeat count given without format specifier");

  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@MBFNOLLD@repeat?5count?5given?5without?5forma@
  000f2	e8 00 00 00 00	 call	 PyErr_SetString

; 1290 :                 return -1;

  000f7	e9 46 02 00 00	 jmp	 $LN71@prepare_s
$LN33@prepare_s:

; 1291 :             }
; 1292 :         }
; 1293 :         else
; 1294 :             num = 1;

  000fc	bf 01 00 00 00	 mov	 edi, 1
$LN27@prepare_s:

; 1295 : 
; 1296 :         e = getentry(c, f);

  00101	0f be cb	 movsx	 ecx, bl
  00104	49 8b d7	 mov	 rdx, r15
  00107	e8 00 00 00 00	 call	 getentry

; 1297 :         if (e == NULL)

  0010c	48 85 c0	 test	 rax, rax
  0010f	0f 84 2d 02 00
	00		 je	 $LN71@prepare_s

; 1298 :             return -1;
; 1299 : 
; 1300 :         switch (c) {

  00115	80 fb 70	 cmp	 bl, 112			; 00000070H
  00118	74 0f		 je	 SHORT $LN23@prepare_s
  0011a	80 fb 73	 cmp	 bl, 115			; 00000073H
  0011d	74 0a		 je	 SHORT $LN23@prepare_s
  0011f	80 fb 78	 cmp	 bl, 120			; 00000078H
  00122	74 08		 je	 SHORT $LN24@prepare_s

; 1303 :             case 'x': break;
; 1304 :             default: len += num; break;

  00124	48 03 ef	 add	 rbp, rdi
  00127	eb 03		 jmp	 SHORT $LN24@prepare_s
$LN23@prepare_s:

; 1301 :             case 's': /* fall through */
; 1302 :             case 'p': len++; break;

  00129	48 ff c5	 inc	 rbp
$LN24@prepare_s:

; 1305 :         }
; 1306 : 
; 1307 :         itemsize = e->size;

  0012c	4c 8b 50 08	 mov	 r10, QWORD PTR [rax+8]

; 1308 :         size = align(size, c, e);

  00130	4c 8b c0	 mov	 r8, rax
  00133	0f b6 d3	 movzx	 edx, bl
  00136	49 8b cd	 mov	 rcx, r13
  00139	e8 00 00 00 00	 call	 align
  0013e	4c 8b e8	 mov	 r13, rax

; 1309 :         if (size == -1)

  00141	48 83 f8 ff	 cmp	 rax, -1
  00145	74 7c		 je	 SHORT $overflow$21276

; 1310 :             goto overflow;
; 1311 : 
; 1312 :         /* if (size + num * itemsize > PY_SSIZE_T_MAX) { ... } */
; 1313 :         if (num > (PY_SSIZE_T_MAX - size) / itemsize)

  00147	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00151	49 2b c5	 sub	 rax, r13
  00154	48 99		 cdq
  00156	49 f7 fa	 idiv	 r10
  00159	48 3b f8	 cmp	 rdi, rax
  0015c	7f 65		 jg	 SHORT $overflow$21276

; 1314 :             goto overflow;
; 1315 :         size += num * itemsize;

  0015e	4c 0f af d7	 imul	 r10, rdi
  00162	48 b9 cc cc cc
	cc cc cc cc 0c	 mov	 rcx, 922337203685477580	; 0cccccccccccccccH
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_ctype_table
  00173	4d 03 ea	 add	 r13, r10
$LN62@prepare_s:

; 1271 :     size = 0;
; 1272 :     len = 0;
; 1273 :     while ((c = *s++) != '\0') {

  00176	0f b6 1e	 movzx	 ebx, BYTE PTR [rsi]
  00179	84 db		 test	 bl, bl
  0017b	0f 85 ef fe ff
	ff		 jne	 $LL36@prepare_s
  00181	48 bf ff ff ff
	ff ff ff ff 7f	 mov	 rdi, 9223372036854775807 ; 7fffffffffffffffH
$LN68@prepare_s:

; 1316 :     }
; 1317 : 
; 1318 :     /* check for overflow */
; 1319 :     if ((len + 1) > (PY_SSIZE_T_MAX / sizeof(formatcode))) {

  0018b	48 8d 45 01	 lea	 rax, QWORD PTR [rbp+1]
  0018f	48 b9 55 55 55
	55 55 55 55 05	 mov	 rcx, 384307168202282325	; 0555555555555555H
  00199	48 3b c1	 cmp	 rax, rcx

; 1320 :         PyErr_NoMemory();
; 1321 :         return -1;

  0019c	0f 87 9b 01 00
	00		 ja	 $LN67@prepare_s

; 1322 :     }
; 1323 : 
; 1324 :     self->s_size = size;

  001a2	4d 89 6e 60	 mov	 QWORD PTR [r14+96], r13

; 1325 :     self->s_len = len;

  001a6	49 89 6e 68	 mov	 QWORD PTR [r14+104], rbp

; 1326 :     codes = PyMem_MALLOC((len + 1) * sizeof(formatcode));

  001aa	e8 00 00 00 00	 call	 _Py_PXCTX
  001af	85 c0		 test	 eax, eax
  001b1	74 28		 je	 SHORT $LN43@prepare_s
  001b3	48 8d 4c 6d 03	 lea	 rcx, QWORD PTR [rbp+rbp*2+3]
  001b8	48 c1 e1 03	 shl	 rcx, 3
  001bc	e8 00 00 00 00	 call	 _PxMem_Malloc
  001c1	eb 3c		 jmp	 SHORT $LN72@prepare_s
$overflow$21276:

; 1377 : 
; 1378 :   overflow:
; 1379 :     PyErr_SetString(StructError,
; 1380 :                     "total struct size too long");

  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@BKFKBDHI@total?5struct?5size?5too?5long?$AA@
  001d1	e8 00 00 00 00	 call	 PyErr_SetString

; 1381 :     return -1;

  001d6	e9 67 01 00 00	 jmp	 $LN71@prepare_s
$LN43@prepare_s:

; 1326 :     codes = PyMem_MALLOC((len + 1) * sizeof(formatcode));

  001db	48 8d 44 6d 03	 lea	 rax, QWORD PTR [rbp+rbp*2+3]
  001e0	48 c1 e0 03	 shl	 rax, 3
  001e4	48 3b c7	 cmp	 rax, rdi
  001e7	0f 87 50 01 00
	00		 ja	 $LN67@prepare_s
  001ed	48 85 c0	 test	 rax, rax
  001f0	b9 01 00 00 00	 mov	 ecx, 1
  001f5	48 0f 45 c8	 cmovne	 rcx, rax
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN72@prepare_s:
  001ff	48 8b d8	 mov	 rbx, rax

; 1327 :     if (codes == NULL) {

  00202	48 85 c0	 test	 rax, rax
  00205	0f 84 32 01 00
	00		 je	 $LN67@prepare_s

; 1330 :     }
; 1331 :     /* Free any s_codes value left over from a previous initialization. */
; 1332 :     if (self->s_codes != NULL)

  0020b	49 83 7e 70 00	 cmp	 QWORD PTR [r14+112], 0
  00210	74 1a		 je	 SHORT $LN46@prepare_s

; 1333 :         PyMem_FREE(self->s_codes);

  00212	e8 00 00 00 00	 call	 _Py_PXCTX
  00217	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0021b	85 c0		 test	 eax, eax
  0021d	74 07		 je	 SHORT $LN45@prepare_s
  0021f	e8 00 00 00 00	 call	 _PxMem_Free
  00224	eb 06		 jmp	 SHORT $LN46@prepare_s
$LN45@prepare_s:
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN46@prepare_s:

; 1334 :     self->s_codes = codes;

  0022c	49 89 5e 70	 mov	 QWORD PTR [r14+112], rbx

; 1335 : 
; 1336 :     s = fmt;
; 1337 :     size = 0;
; 1338 :     while ((c = *s++) != '\0') {

  00230	41 0f b6 3c 24	 movzx	 edi, BYTE PTR [r12]
  00235	45 33 f6	 xor	 r14d, r14d
  00238	41 8b ee	 mov	 ebp, r14d
  0023b	40 84 ff	 test	 dil, dil
  0023e	0f 84 ea 00 00
	00		 je	 $LN69@prepare_s
  00244	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_ctype_table
  0024b	0f 1f 44 00 00	 npad	 5
$LL15@prepare_s:

; 1339 :         if (Py_ISSPACE(Py_CHARMASK(c)))

  00250	40 0f b6 c7	 movzx	 eax, dil
  00254	49 ff c4	 inc	 r12
  00257	41 f6 44 85 00
	08		 test	 BYTE PTR [r13+rax*4], 8
  0025d	0f 85 bd 00 00
	00		 jne	 $LN1@prepare_s

; 1340 :             continue;
; 1341 :         if ('0' <= c && c <= '9') {

  00263	8d 47 d0	 lea	 eax, DWORD PTR [rdi-48]
  00266	3c 09		 cmp	 al, 9
  00268	77 4a		 ja	 SHORT $LN12@prepare_s

; 1342 :             num = c - '0';

  0026a	40 0f be c7	 movsx	 eax, dil

; 1343 :             while ('0' <= (c = *s++) && c <= '9')

  0026e	41 0f b6 3c 24	 movzx	 edi, BYTE PTR [r12]
  00273	83 e8 30	 sub	 eax, 48			; 00000030H
  00276	48 63 f0	 movsxd	 rsi, eax
  00279	40 80 ff 30	 cmp	 dil, 48			; 00000030H
  0027d	7c 27		 jl	 SHORT $LN63@prepare_s
  0027f	90		 npad	 1
$LL11@prepare_s:
  00280	49 ff c4	 inc	 r12
  00283	40 80 ff 39	 cmp	 dil, 57			; 00000039H
  00287	7f 20		 jg	 SHORT $LN10@prepare_s

; 1344 :                 num = num*10 + (c - '0');

  00289	40 0f be c7	 movsx	 eax, dil
  0028d	41 0f b6 3c 24	 movzx	 edi, BYTE PTR [r12]
  00292	83 e8 30	 sub	 eax, 48			; 00000030H
  00295	48 63 c8	 movsxd	 rcx, eax
  00298	48 8d 04 b6	 lea	 rax, QWORD PTR [rsi+rsi*4]
  0029c	48 8d 34 41	 lea	 rsi, QWORD PTR [rcx+rax*2]
  002a0	40 80 ff 30	 cmp	 dil, 48			; 00000030H
  002a4	7d da		 jge	 SHORT $LL11@prepare_s
$LN63@prepare_s:

; 1343 :             while ('0' <= (c = *s++) && c <= '9')

  002a6	49 ff c4	 inc	 r12
$LN10@prepare_s:

; 1345 :             if (c == '\0')

  002a9	40 84 ff	 test	 dil, dil
  002ac	0f 84 7c 00 00
	00		 je	 $LN69@prepare_s

; 1346 :                 break;
; 1347 :         }
; 1348 :         else

  002b2	eb 05		 jmp	 SHORT $LN8@prepare_s
$LN12@prepare_s:

; 1349 :             num = 1;

  002b4	be 01 00 00 00	 mov	 esi, 1
$LN8@prepare_s:

; 1350 : 
; 1351 :         e = getentry(c, f);

  002b9	40 0f be cf	 movsx	 ecx, dil
  002bd	49 8b d7	 mov	 rdx, r15
  002c0	e8 00 00 00 00	 call	 getentry

; 1352 : 
; 1353 :         size = align(size, c, e);

  002c5	40 0f b6 d7	 movzx	 edx, dil
  002c9	48 8b cd	 mov	 rcx, rbp
  002cc	4c 8b c0	 mov	 r8, rax
  002cf	e8 00 00 00 00	 call	 align
  002d4	48 8b e8	 mov	 rbp, rax

; 1354 :         if (c == 's' || c == 'p') {

  002d7	40 80 ff 73	 cmp	 dil, 115		; 00000073H
  002db	74 31		 je	 SHORT $LN6@prepare_s
  002dd	40 80 ff 70	 cmp	 dil, 112		; 00000070H
  002e1	74 2b		 je	 SHORT $LN6@prepare_s

; 1360 :         } else if (c == 'x') {

  002e3	40 80 ff 78	 cmp	 dil, 120		; 00000078H

; 1361 :             size += num;
; 1362 :         } else {

  002e7	74 34		 je	 SHORT $LN73@prepare_s

; 1363 :             while (--num >= 0) {

  002e9	48 ff ce	 dec	 rsi
  002ec	78 32		 js	 SHORT $LN1@prepare_s
  002ee	66 90		 npad	 2
$LL2@prepare_s:

; 1364 :                 codes->offset = size;

  002f0	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1365 :                 codes->size = e->size;

  002f4	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]

; 1366 :                 codes->fmtdef = e;

  002f8	4c 89 03	 mov	 QWORD PTR [rbx], r8
  002fb	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1367 :                 codes++;
; 1368 :                 size += e->size;

  002ff	49 03 68 08	 add	 rbp, QWORD PTR [r8+8]
  00303	48 83 c3 18	 add	 rbx, 24
  00307	48 ff ce	 dec	 rsi
  0030a	79 e4		 jns	 SHORT $LL2@prepare_s

; 1345 :             if (c == '\0')

  0030c	eb 12		 jmp	 SHORT $LN1@prepare_s
$LN6@prepare_s:

; 1355 :             codes->offset = size;

  0030e	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1356 :             codes->size = num;

  00312	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 1357 :             codes->fmtdef = e;

  00316	4c 89 03	 mov	 QWORD PTR [rbx], r8

; 1358 :             codes++;

  00319	48 83 c3 18	 add	 rbx, 24
$LN73@prepare_s:

; 1359 :             size += num;

  0031d	48 03 ee	 add	 rbp, rsi
$LN1@prepare_s:

; 1335 : 
; 1336 :     s = fmt;
; 1337 :     size = 0;
; 1338 :     while ((c = *s++) != '\0') {

  00320	41 0f b6 3c 24	 movzx	 edi, BYTE PTR [r12]
  00325	40 84 ff	 test	 dil, dil
  00328	0f 85 22 ff ff
	ff		 jne	 $LL15@prepare_s
$LN69@prepare_s:

; 1369 :             }
; 1370 :         }
; 1371 :     }
; 1372 :     codes->fmtdef = NULL;

  0032e	4c 89 33	 mov	 QWORD PTR [rbx], r14

; 1373 :     codes->offset = size;

  00331	48 89 6b 08	 mov	 QWORD PTR [rbx+8], rbp

; 1374 :     codes->size = 0;

  00335	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 1375 : 
; 1376 :     return 0;

  00339	33 c0		 xor	 eax, eax
  0033b	eb 08		 jmp	 SHORT $LN37@prepare_s
$LN67@prepare_s:

; 1328 :         PyErr_NoMemory();

  0033d	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN71@prepare_s:

; 1329 :         return -1;

  00342	83 c8 ff	 or	 eax, -1
$LN37@prepare_s:

; 1382 : }

  00345	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0034a	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0034f	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00354	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00358	41 5f		 pop	 r15
  0035a	41 5e		 pop	 r14
  0035c	41 5d		 pop	 r13
  0035e	41 5c		 pop	 r12
  00360	5f		 pop	 rdi
  00361	c3		 ret	 0
prepare_s ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$s_new DD	imagerel s_new
	DD	imagerel s_new+25
	DD	imagerel $unwind$s_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$s_new DD imagerel s_new+25
	DD	imagerel s_new+138
	DD	imagerel $chain$0$s_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$s_new DD imagerel s_new+138
	DD	imagerel s_new+144
	DD	imagerel $chain$1$s_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$s_new DD 021H
	DD	imagerel s_new
	DD	imagerel s_new+25
	DD	imagerel $unwind$s_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$s_new DD 020521H
	DD	087405H
	DD	imagerel s_new
	DD	imagerel s_new+25
	DD	imagerel $unwind$s_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_new DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
xdata	ENDS
;	COMDAT s_new
_TEXT	SEGMENT
type$ = 64
args$ = 72
kwds$ = 80
s_new	PROC						; COMDAT

; 1386 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c1	 mov	 rax, rcx

; 1387 :     PyObject *self;
; 1388 : 
; 1389 :     assert(type != NULL && type->tp_alloc != NULL);
; 1390 : 
; 1391 :     self = type->tp_alloc(type, 0);

  00009	33 d2		 xor	 edx, edx
  0000b	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00011	48 8b d8	 mov	 rbx, rax

; 1392 :     if (self != NULL) {

  00014	48 85 c0	 test	 rax, rax
  00017	74 71		 je	 SHORT $LN1@s_new

; 1393 :         PyStructObject *s = (PyStructObject*)self;
; 1394 :         Py_INCREF(Py_None);

  00019	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0002a	85 c0		 test	 eax, eax
  0002c	75 38		 jne	 SHORT $LN5@s_new
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003c	4c 8b cf	 mov	 r9, rdi
  0003f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00045	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00052	85 c0		 test	 eax, eax
  00054	75 09		 jne	 SHORT $LN4@s_new
  00056	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0005d	74 07		 je	 SHORT $LN5@s_new
$LN4@s_new:
  0005f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@s_new:

; 1395 :         s->s_format = Py_None;

  00066	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
  0006a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1396 :         s->s_codes = NULL;

  0006f	48 c7 43 70 00
	00 00 00	 mov	 QWORD PTR [rbx+112], 0

; 1397 :         s->s_size = -1;

  00077	48 c7 43 60 ff
	ff ff ff	 mov	 QWORD PTR [rbx+96], -1

; 1398 :         s->s_len = -1;

  0007f	48 c7 43 68 ff
	ff ff ff	 mov	 QWORD PTR [rbx+104], -1

; 1399 :     }
; 1400 :     return self;

  00087	48 8b c3	 mov	 rax, rbx
$LN1@s_new:

; 1401 : }

  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
s_new	ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BEFIJEE@s_init?$AA@			; `string'
PUBLIC	??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@ ; `string'
PUBLIC	??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@ ; `string'
PUBLIC	??_C@_08FAGPPOEF@O?3Struct?$AA@			; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyUnicode_AsASCIIString:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$s_init DD imagerel s_init
	DD	imagerel s_init+72
	DD	imagerel $unwind$s_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$s_init DD imagerel s_init+72
	DD	imagerel s_init+133
	DD	imagerel $chain$0$s_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$s_init DD imagerel s_init+133
	DD	imagerel s_init+267
	DD	imagerel $chain$2$s_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$s_init DD imagerel s_init+267
	DD	imagerel s_init+358
	DD	imagerel $chain$4$s_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$s_init DD 020021H
	DD	093400H
	DD	imagerel s_init
	DD	imagerel s_init+72
	DD	imagerel $unwind$s_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$s_init DD 020021H
	DD	093400H
	DD	imagerel s_init
	DD	imagerel s_init+72
	DD	imagerel $unwind$s_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$s_init DD 020521H
	DD	093405H
	DD	imagerel s_init
	DD	imagerel s_init+72
	DD	imagerel $unwind$s_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_init DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_06BEFIJEE@s_init?$AA@
CONST	SEGMENT
??_C@_06BEFIJEE@s_init?$AA@ DB 's_init', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
CONST	SEGMENT
??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@ DB '..\Modules\_struct.'
	DB	'c', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@
CONST	SEGMENT
??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@ DB 'Stru'
	DB	'ct() argument 1 must be a bytes object, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FAGPPOEF@O?3Struct?$AA@
CONST	SEGMENT
??_C@_08FAGPPOEF@O?3Struct?$AA@ DB 'O:Struct', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
CONST	ENDS
;	COMDAT s_init
_TEXT	SEGMENT
o_format$ = 64
self$ = 64
args$ = 72
kwds$ = 80
s_init	PROC						; COMDAT

; 1405 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 1406 :     PyStructObject *soself = (PyStructObject *)self;
; 1407 :     PyObject *o_format = NULL;
; 1408 :     int ret = 0;
; 1409 :     static char *kwlist[] = {"format", 0};
; 1410 : 
; 1411 :     assert(PyStruct_Check(self));
; 1412 : 
; 1413 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:Struct", kwlist,
; 1414 :                                      &o_format))

  0000f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR o_format$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??s_init@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08FAGPPOEF@O?3Struct?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8b d0	 mov	 rdx, rax
  0002a	49 8b ca	 mov	 rcx, r10
  0002d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR o_format$[rsp], 0
  00036	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003b	85 c0		 test	 eax, eax
  0003d	75 09		 jne	 SHORT $LN9@s_init

; 1415 :         return -1;

  0003f	83 c8 ff	 or	 eax, -1

; 1439 :     return ret;
; 1440 : }

  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
$LN9@s_init:
  00048	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx

; 1416 : 
; 1417 :     if (PyUnicode_Check(o_format)) {

  0004d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR o_format$[rsp]
  00052	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00056	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00060	74 23		 je	 SHORT $LN8@s_init

; 1418 :         o_format = PyUnicode_AsASCIIString(o_format);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 PyUnicode_AsASCIIString
  0006a	4c 8b d8	 mov	 r11, rax
  0006d	48 89 44 24 40	 mov	 QWORD PTR o_format$[rsp], rax

; 1419 :         if (o_format == NULL)

  00072	48 85 c0	 test	 rax, rax
  00075	75 4e		 jne	 SHORT $LN13@s_init

; 1420 :             return -1;

  00077	83 c8 ff	 or	 eax, -1
  0007a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1439 :     return ret;
; 1440 : }

  0007f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN8@s_init:

; 1421 :     }
; 1422 :     /* XXX support buffer interface, too */
; 1423 :     else {
; 1424 :         Py_INCREF(o_format);

  00085	e8 00 00 00 00	 call	 _Py_PXCTX
  0008a	85 c0		 test	 eax, eax
  0008c	75 32		 jne	 SHORT $LN16@s_init
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009c	4c 8b cb	 mov	 r9, rbx
  0009f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ad	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b2	85 c0		 test	 eax, eax
  000b4	75 06		 jne	 SHORT $LN12@s_init
  000b6	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ba	74 04		 je	 SHORT $LN16@s_init
$LN12@s_init:
  000bc	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN16@s_init:
  000c0	4c 8b 5c 24 40	 mov	 r11, QWORD PTR o_format$[rsp]
$LN13@s_init:

; 1425 :     }
; 1426 : 
; 1427 :     if (!PyBytes_Check(o_format)) {

  000c5	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  000c9	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  000d3	75 36		 jne	 SHORT $LN4@s_init

; 1428 :         Py_DECREF(o_format);

  000d5	49 8b cb	 mov	 rcx, r11
  000d8	e8 00 00 00 00	 call	 _Py_DecRef

; 1429 :         PyErr_Format(PyExc_TypeError,
; 1430 :                      "Struct() argument 1 must be a bytes object, not %.200s",
; 1431 :                      Py_TYPE(o_format)->tp_name);

  000dd	4c 8b 5c 24 40	 mov	 r11, QWORD PTR o_format$[rsp]
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e9	4d 8b 43 58	 mov	 r8, QWORD PTR [r11+88]
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@JKNHLINK@Struct?$CI?$CJ?5argument?51?5must?5be?5a?5by@
  000f4	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000f8	e8 00 00 00 00	 call	 PyErr_Format
  000fd	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1432 :         return -1;

  00102	83 c8 ff	 or	 eax, -1

; 1439 :     return ret;
; 1440 : }

  00105	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00109	5f		 pop	 rdi
  0010a	c3		 ret	 0
$LN4@s_init:

; 1433 :     }
; 1434 : 
; 1435 :     Py_CLEAR(soself->s_format);

  0010b	4c 8b 4f 78	 mov	 r9, QWORD PTR [rdi+120]
  0010f	4d 85 c9	 test	 r9, r9
  00112	74 3b		 je	 SHORT $LN3@s_init
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BEFIJEE@s_init?$AA@
  00122	41 b8 9b 05 00
	00		 mov	 r8d, 1435		; 0000059bH
  00128	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00130	e8 00 00 00 00	 call	 _PyParallel_Guard
  00135	85 c0		 test	 eax, eax
  00137	75 11		 jne	 SHORT $LN17@s_init
  00139	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  0013d	48 c7 47 78 00
	00 00 00	 mov	 QWORD PTR [rdi+120], 0
  00145	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@s_init:
  0014a	4c 8b 5c 24 40	 mov	 r11, QWORD PTR o_format$[rsp]
$LN3@s_init:

; 1436 :     soself->s_format = o_format;
; 1437 : 
; 1438 :     ret = prepare_s(soself);

  0014f	48 8b cf	 mov	 rcx, rdi
  00152	4c 89 5f 78	 mov	 QWORD PTR [rdi+120], r11
  00156	e8 00 00 00 00	 call	 prepare_s
  0015b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]

; 1439 :     return ret;
; 1440 : }

  00160	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00164	5f		 pop	 rdi
  00165	c3		 ret	 0
s_init	ENDP
_TEXT	ENDS
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$s_dealloc DD imagerel s_dealloc
	DD	imagerel s_dealloc+195
	DD	imagerel $unwind$s_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
xdata	ENDS
;	COMDAT s_dealloc
_TEXT	SEGMENT
s$ = 64
s_dealloc PROC						; COMDAT

; 1444 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1445 :     if (s->weakreflist != NULL)

  0000a	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00012	48 8b d9	 mov	 rbx, rcx
  00015	74 05		 je	 SHORT $LN6@s_dealloc

; 1446 :         PyObject_ClearWeakRefs((PyObject *)s);

  00017	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN6@s_dealloc:

; 1447 :     if (s->s_codes != NULL) {

  0001c	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0
  00021	74 1a		 je	 SHORT $LN4@s_dealloc

; 1448 :         PyMem_FREE(s->s_codes);

  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0002c	85 c0		 test	 eax, eax
  0002e	74 07		 je	 SHORT $LN9@s_dealloc
  00030	e8 00 00 00 00	 call	 _PxMem_Free
  00035	eb 06		 jmp	 SHORT $LN4@s_dealloc
$LN9@s_dealloc:
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@s_dealloc:

; 1449 :     }
; 1450 :     Py_XDECREF(s->s_format);

  0003d	48 8b 7b 78	 mov	 rdi, QWORD PTR [rbx+120]
  00041	48 85 ff	 test	 rdi, rdi
  00044	74 65		 je	 SHORT $LN3@s_dealloc
  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 5c		 jne	 SHORT $LN3@s_dealloc
  0004f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00053	a8 20		 test	 al, 32			; 00000020H
  00055	75 4c		 jne	 SHORT $LN15@s_dealloc
  00057	84 c0		 test	 al, al
  00059	78 48		 js	 SHORT $LN15@s_dealloc
  0005b	a8 02		 test	 al, 2
  0005d	75 4c		 jne	 SHORT $LN3@s_dealloc
  0005f	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00063	75 46		 jne	 SHORT $LN3@s_dealloc
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00073	4c 8b cf	 mov	 r9, rdi
  00076	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	48 8b cf	 mov	 rcx, rdi
  0008c	85 c0		 test	 eax, eax
  0008e	74 07		 je	 SHORT $LN20@s_dealloc
  00090	e8 00 00 00 00	 call	 _Px_Dealloc
  00095	eb 14		 jmp	 SHORT $LN3@s_dealloc
$LN20@s_dealloc:
  00097	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0009b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a1	eb 08		 jmp	 SHORT $LN3@s_dealloc
$LN15@s_dealloc:
  000a3	48 8b cf	 mov	 rcx, rdi
  000a6	e8 00 00 00 00	 call	 Px_DecRef
$LN3@s_dealloc:

; 1451 :     Py_TYPE(s)->tp_free((PyObject *)s);

  000ab	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000af	48 8b cb	 mov	 rcx, rbx

; 1452 : }

  000b2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bb	5f		 pop	 rdi
  000bc	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
s_dealloc ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$s_unpack_internal DD imagerel s_unpack_internal
	DD	imagerel s_unpack_internal+58
	DD	imagerel $unwind$s_unpack_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$s_unpack_internal DD imagerel s_unpack_internal+58
	DD	imagerel s_unpack_internal+192
	DD	imagerel $chain$0$s_unpack_internal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$s_unpack_internal DD imagerel s_unpack_internal+192
	DD	imagerel s_unpack_internal+304
	DD	imagerel $chain$2$s_unpack_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$s_unpack_internal DD 020021H
	DD	086400H
	DD	imagerel s_unpack_internal
	DD	imagerel s_unpack_internal+58
	DD	imagerel $unwind$s_unpack_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$s_unpack_internal DD 020521H
	DD	086405H
	DD	imagerel s_unpack_internal
	DD	imagerel s_unpack_internal+58
	DD	imagerel $unwind$s_unpack_internal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack_internal DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
xdata	ENDS
;	COMDAT s_unpack_internal
_TEXT	SEGMENT
soself$ = 64
startfrom$ = 72
s_unpack_internal PROC					; COMDAT

; 1455 : s_unpack_internal(PyStructObject *soself, char *startfrom) {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1456 :     formatcode *code;
; 1457 :     Py_ssize_t i = 0;
; 1458 :     PyObject *result = PyTuple_New(soself->s_len);

  00012	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00016	48 8b ea	 mov	 rbp, rdx
  00019	e8 00 00 00 00	 call	 PyTuple_New
  0001e	48 8b f8	 mov	 rdi, rax

; 1459 :     if (result == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	75 10		 jne	 SHORT $LN10@s_unpack_i

; 1485 : }

  00026	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0002b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00030	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN10@s_unpack_i:

; 1460 :         return NULL;
; 1461 : 
; 1462 :     for (code = soself->s_codes; code->fmtdef != NULL; code++) {

  00036	48 8b 5b 70	 mov	 rbx, QWORD PTR [rbx+112]
  0003a	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0003f	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00042	4d 85 c0	 test	 r8, r8
  00045	74 61		 je	 SHORT $LN7@s_unpack_i
  00047	48 8d 70 70	 lea	 rsi, QWORD PTR [rax+112]
  0004b	0f 1f 44 00 00	 npad	 5
$LL9@s_unpack_i:

; 1463 :         PyObject *v;
; 1464 :         const formatdef *e = code->fmtdef;
; 1465 :         const char *res = startfrom + code->offset;

  00050	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00054	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]

; 1466 :         if (e->format == 's') {

  00058	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0005c	3c 73		 cmp	 al, 115			; 00000073H
  0005e	75 0b		 jne	 SHORT $LN6@s_unpack_i

; 1467 :             v = PyBytes_FromStringAndSize(res, code->size);

  00060	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  00064	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00069	eb 25		 jmp	 SHORT $LN2@s_unpack_i
$LN6@s_unpack_i:

; 1468 :         } else if (e->format == 'p') {

  0006b	3c 70		 cmp	 al, 112			; 00000070H
  0006d	75 1a		 jne	 SHORT $LN4@s_unpack_i

; 1469 :             Py_ssize_t n = *(unsigned char*)res;

  0006f	0f b6 11	 movzx	 edx, BYTE PTR [rcx]

; 1470 :             if (n >= code->size)

  00072	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00076	48 3b d0	 cmp	 rdx, rax
  00079	7c 04		 jl	 SHORT $LN3@s_unpack_i

; 1471 :                 n = code->size - 1;

  0007b	48 8d 50 ff	 lea	 rdx, QWORD PTR [rax-1]
$LN3@s_unpack_i:

; 1472 :             v = PyBytes_FromStringAndSize(res + 1, n);

  0007f	48 ff c1	 inc	 rcx
  00082	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1473 :         } else {

  00087	eb 07		 jmp	 SHORT $LN2@s_unpack_i
$LN4@s_unpack_i:

; 1474 :             v = e->unpack(res, e);

  00089	49 8b d0	 mov	 rdx, r8
  0008c	41 ff 50 18	 call	 QWORD PTR [r8+24]
$LN2@s_unpack_i:

; 1475 :         }
; 1476 :         if (v == NULL)

  00090	48 85 c0	 test	 rax, rax
  00093	74 2b		 je	 SHORT $fail$21436

; 1477 :             goto fail;
; 1478 :         PyTuple_SET_ITEM(result, i++, v);

  00095	48 83 c3 18	 add	 rbx, 24
  00099	48 89 06	 mov	 QWORD PTR [rsi], rax
  0009c	48 83 c6 08	 add	 rsi, 8
  000a0	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  000a3	4d 85 c0	 test	 r8, r8
  000a6	75 a8		 jne	 SHORT $LL9@s_unpack_i
$LN7@s_unpack_i:

; 1479 :     }
; 1480 : 
; 1481 :     return result;

  000a8	48 8b c7	 mov	 rax, rdi
$LN27@s_unpack_i:
  000ab	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1485 : }

  000b0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
$fail$21436:

; 1482 : fail:
; 1483 :     Py_DECREF(result);

  000c0	e8 00 00 00 00	 call	 _Py_PXCTX
  000c5	85 c0		 test	 eax, eax
  000c7	75 60		 jne	 SHORT $LN23@s_unpack_i
  000c9	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000cd	a8 20		 test	 al, 32			; 00000020H
  000cf	75 50		 jne	 SHORT $LN17@s_unpack_i
  000d1	84 c0		 test	 al, al
  000d3	78 4c		 js	 SHORT $LN17@s_unpack_i
  000d5	a8 02		 test	 al, 2
  000d7	75 50		 jne	 SHORT $LN23@s_unpack_i
  000d9	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000dd	75 4a		 jne	 SHORT $LN23@s_unpack_i
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ed	4c 8b cf	 mov	 r9, rdi
  000f0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000fe	e8 00 00 00 00	 call	 _PyParallel_Guard
  00103	48 8b cf	 mov	 rcx, rdi
  00106	85 c0		 test	 eax, eax
  00108	74 09		 je	 SHORT $LN22@s_unpack_i
  0010a	e8 00 00 00 00	 call	 _Px_Dealloc

; 1484 :     return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	eb 98		 jmp	 SHORT $LN27@s_unpack_i

; 1482 : fail:
; 1483 :     Py_DECREF(result);

$LN22@s_unpack_i:
  00113	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00117	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1484 :     return NULL;

  0011d	33 c0		 xor	 eax, eax
  0011f	eb 8a		 jmp	 SHORT $LN27@s_unpack_i

; 1482 : fail:
; 1483 :     Py_DECREF(result);

$LN17@s_unpack_i:
  00121	48 8b cf	 mov	 rcx, rdi
  00124	e8 00 00 00 00	 call	 Px_DecRef
$LN23@s_unpack_i:

; 1484 :     return NULL;

  00129	33 c0		 xor	 eax, eax
  0012b	e9 7b ff ff ff	 jmp	 $LN27@s_unpack_i
s_unpack_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_unpack DD imagerel s_unpack
	DD	imagerel s_unpack+115
	DD	imagerel $unwind$s_unpack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@
CONST	SEGMENT
??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@ DB 'unpack requ'
	DB	'ires a bytes object of length %zd', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_unpack
_TEXT	SEGMENT
vbuf$ = 32
self$ = 128
input$ = 136
s_unpack PROC						; COMDAT

; 1497 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1498 :     Py_buffer vbuf;
; 1499 :     PyObject *result;
; 1500 :     PyStructObject *soself = (PyStructObject *)self;
; 1501 : 
; 1502 :     assert(PyStruct_Check(self));
; 1503 :     assert(soself->s_codes != NULL);
; 1504 :     if (PyObject_GetBuffer(input, &vbuf, PyBUF_SIMPLE) < 0)

  0000c	48 8d 54 24 20	 lea	 rdx, QWORD PTR vbuf$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	45 33 c0	 xor	 r8d, r8d
  00017	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0001c	85 c0		 test	 eax, eax

; 1505 :         return NULL;

  0001e	78 28		 js	 SHORT $LN5@s_unpack

; 1506 :     if (vbuf.len != soself->s_size) {

  00020	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  00024	4c 39 44 24 30	 cmp	 QWORD PTR vbuf$[rsp+16], r8
  00029	74 25		 je	 SHORT $LN1@s_unpack

; 1507 :         PyErr_Format(StructError,
; 1508 :                      "unpack requires a bytes object of length %zd",
; 1509 :                      soself->s_size);

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@POOICKIL@unpack?5requires?5a?5bytes?5object?5o@
  00039	e8 00 00 00 00	 call	 PyErr_Format

; 1510 :         PyBuffer_Release(&vbuf);

  0003e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vbuf$[rsp]
  00043	e8 00 00 00 00	 call	 PyBuffer_Release
$LN5@s_unpack:

; 1511 :         return NULL;

  00048	33 c0		 xor	 eax, eax

; 1516 : }

  0004a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
$LN1@s_unpack:

; 1512 :     }
; 1513 :     result = s_unpack_internal(soself, vbuf.buf);

  00050	48 8b 54 24 20	 mov	 rdx, QWORD PTR vbuf$[rsp]
  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 s_unpack_internal

; 1514 :     PyBuffer_Release(&vbuf);

  0005d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR vbuf$[rsp]
  00062	48 8b d8	 mov	 rbx, rax
  00065	e8 00 00 00 00	 call	 PyBuffer_Release

; 1515 :     return result;

  0006a	48 8b c3	 mov	 rax, rbx

; 1516 : }

  0006d	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
s_unpack ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@ ; `string'
PUBLIC	??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_unpack_from DD imagerel s_unpack_from
	DD	imagerel s_unpack_from+227
	DD	imagerel $unwind$s_unpack_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_unpack_from DD 020b01H
	DD	03004f20bH
xdata	ENDS
;	COMDAT ??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@
CONST	SEGMENT
??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@ DB 'unpack_from '
	DB	'requires a buffer of at least %zd bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@
CONST	SEGMENT
??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@ DB 'O|n:unpack_from', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_unpack_from
_TEXT	SEGMENT
vbuf$ = 48
offset$ = 144
self$ = 144
args$ = 152
kwds$ = 160
input$ = 168
s_unpack_from PROC					; COMDAT

; 1527 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000b	48 8b d9	 mov	 rbx, rcx

; 1528 :     static char *kwlist[] = {"buffer", "offset", 0};
; 1529 : 
; 1530 :     PyObject *input;
; 1531 :     Py_ssize_t offset = 0;
; 1532 :     Py_buffer vbuf;
; 1533 :     PyObject *result;
; 1534 :     PyStructObject *soself = (PyStructObject *)self;
; 1535 : 
; 1536 :     assert(PyStruct_Check(self));
; 1537 :     assert(soself->s_codes != NULL);
; 1538 : 
; 1539 :     if (!PyArg_ParseTupleAndKeywords(args, kwds,
; 1540 :                                      "O|n:unpack_from", kwlist,
; 1541 :                                      &input, &offset))

  0000e	49 8d 4b 08	 lea	 rcx, QWORD PTR [r11+8]
  00012	49 8b c0	 mov	 rax, r8
  00015	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  00019	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001d	4c 8b d2	 mov	 r10, rdx
  00020	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00024	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??s_unpack_from@@9@9
  0002b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@OHJCCKEP@O?$HMn?3unpack_from?$AA@
  00032	49 8b ca	 mov	 rcx, r10
  00035	48 8b d0	 mov	 rdx, rax
  00038	49 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [r11+8], 0
  00040	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00045	85 c0		 test	 eax, eax

; 1542 :         return NULL;

  00047	0f 84 8b 00 00
	00		 je	 $LN9@s_unpack_f

; 1543 :     if (PyObject_GetBuffer(input, &vbuf, PyBUF_SIMPLE) < 0)

  0004d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR input$[rsp]
  00055	48 8d 54 24 30	 lea	 rdx, QWORD PTR vbuf$[rsp]
  0005a	45 33 c0	 xor	 r8d, r8d
  0005d	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00062	85 c0		 test	 eax, eax

; 1544 :         return NULL;

  00064	78 72		 js	 SHORT $LN9@s_unpack_f

; 1545 :     if (offset < 0)

  00066	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR vbuf$[rsp+16]
  00073	48 85 c9	 test	 rcx, rcx
  00076	79 0d		 jns	 SHORT $LN8@s_unpack_f

; 1546 :         offset += vbuf.len;

  00078	48 03 c8	 add	 rcx, rax
  0007b	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR offset$[rsp], rcx

; 1547 :     if (offset < 0 || vbuf.len - offset < soself->s_size) {

  00083	78 32		 js	 SHORT $LN1@s_unpack_f
$LN8@s_unpack_f:
  00085	48 2b c1	 sub	 rax, rcx
  00088	48 3b 43 60	 cmp	 rax, QWORD PTR [rbx+96]
  0008c	7c 29		 jl	 SHORT $LN1@s_unpack_f

; 1553 :     }
; 1554 :     result = s_unpack_internal(soself, (char*)vbuf.buf + offset);

  0008e	48 8b 54 24 30	 mov	 rdx, QWORD PTR vbuf$[rsp]
  00093	48 03 d1	 add	 rdx, rcx
  00096	48 8b cb	 mov	 rcx, rbx
  00099	e8 00 00 00 00	 call	 s_unpack_internal

; 1555 :     PyBuffer_Release(&vbuf);

  0009e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vbuf$[rsp]
  000a3	48 8b d8	 mov	 rbx, rax
  000a6	e8 00 00 00 00	 call	 PyBuffer_Release

; 1556 :     return result;

  000ab	48 8b c3	 mov	 rax, rbx

; 1557 : }

  000ae	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
$LN1@s_unpack_f:

; 1548 :         PyErr_Format(StructError,
; 1549 :             "unpack_from requires a buffer of at least %zd bytes",
; 1550 :             soself->s_size);

  000b7	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@LKFPHCHB@unpack_from?5requires?5a?5buffer?5of@
  000c9	e8 00 00 00 00	 call	 PyErr_Format

; 1551 :         PyBuffer_Release(&vbuf);

  000ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR vbuf$[rsp]
  000d3	e8 00 00 00 00	 call	 PyBuffer_Release
$LN9@s_unpack_f:

; 1552 :         return NULL;

  000d8	33 c0		 xor	 eax, eax

; 1557 : }

  000da	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000e1	5b		 pop	 rbx
  000e2	c3		 ret	 0
s_unpack_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@ ; `string'
PUBLIC	??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@ ; `string'
PUBLIC	??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@ ; `string'
EXTRN	PyType_IsSubtype:PROC
EXTRN	_PyByteArray_empty_string:BYTE
EXTRN	PyByteArray_Type:BYTE
EXTRN	memset:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack_internal DD imagerel s_pack_internal
	DD	imagerel s_pack_internal+519
	DD	imagerel $unwind$s_pack_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack_internal DD 0c1c01H
	DD	0d641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@
CONST	SEGMENT
??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@ DB 'int too large to'
	DB	' convert', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@
CONST	SEGMENT
??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@ DB 'argument'
	DB	' for ''p'' must be a bytes object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@
CONST	SEGMENT
??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@ DB 'argument'
	DB	' for ''s'' must be a bytes object', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_pack_internal
_TEXT	SEGMENT
soself$ = 80
args$ = 88
offset$ = 96
buf$ = 104
s_pack_internal PROC					; COMDAT

; 1572 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	49 63 f8	 movsxd	 rdi, r8d

; 1573 :     formatcode *code;
; 1574 :     /* XXX(nnorwitz): why does i need to be a local?  can we use
; 1575 :        the offset parameter or do we need the wider width? */
; 1576 :     Py_ssize_t i;
; 1577 : 
; 1578 :     memset(buf, '\0', soself->s_size);

  0001f	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00023	48 8b ea	 mov	 rbp, rdx
  00026	48 8b d9	 mov	 rbx, rcx
  00029	33 d2		 xor	 edx, edx
  0002b	49 8b c9	 mov	 rcx, r9
  0002e	4d 8b e9	 mov	 r13, r9
  00031	e8 00 00 00 00	 call	 memset

; 1579 :     i = offset;
; 1580 :     for (code = soself->s_codes; code->fmtdef != NULL; code++) {

  00036	48 8b 73 70	 mov	 rsi, QWORD PTR [rbx+112]
  0003a	4c 8b 16	 mov	 r10, QWORD PTR [rsi]
  0003d	4d 85 d2	 test	 r10, r10
  00040	0f 84 37 01 00
	00		 je	 $LN18@s_pack_int

; 1573 :     formatcode *code;
; 1574 :     /* XXX(nnorwitz): why does i need to be a local?  can we use
; 1575 :        the offset parameter or do we need the wider width? */
; 1576 :     Py_ssize_t i;
; 1577 : 
; 1578 :     memset(buf, '\0', soself->s_size);

  00046	4c 8d 64 fd 70	 lea	 r12, QWORD PTR [rbp+rdi*8+112]
  0004b	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:PyByteArray_Type
  00052	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_PyByteArray_empty_string
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@s_pack_int:

; 1581 :         Py_ssize_t n;
; 1582 :         PyObject *v = PyTuple_GET_ITEM(args, i++);
; 1583 :         const formatdef *e = code->fmtdef;
; 1584 :         char *res = buf + code->offset;

  00060	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00064	49 8b 1c 24	 mov	 rbx, QWORD PTR [r12]
  00068	49 83 c4 08	 add	 r12, 8
  0006c	49 8d 6c 05 00	 lea	 rbp, QWORD PTR [r13+rax]

; 1585 :         if (e->format == 's') {

  00071	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00075	3c 73		 cmp	 al, 115			; 00000073H
  00077	75 67		 jne	 SHORT $LN17@s_pack_int

; 1586 :             int isstring;
; 1587 :             void *p;
; 1588 :             isstring = PyBytes_Check(v);

  00079	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0007d	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  00083	c1 e8 1b	 shr	 eax, 27
  00086	83 e0 01	 and	 eax, 1

; 1589 :             if (!isstring && !PyByteArray_Check(v)) {

  00089	75 2c		 jne	 SHORT $LN33@s_pack_int
  0008b	49 3b ce	 cmp	 rcx, r14
  0008e	74 10		 je	 SHORT $LN15@s_pack_int
  00090	49 8b d6	 mov	 rdx, r14
  00093	e8 00 00 00 00	 call	 PyType_IsSubtype
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 fc 00 00
	00		 je	 $LN28@s_pack_int
$LN15@s_pack_int:

; 1597 :             }
; 1598 :             else {
; 1599 :                 n = PyByteArray_GET_SIZE(v);

  000a0	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]

; 1600 :                 p = PyByteArray_AS_STRING(v);

  000a4	4d 85 c0	 test	 r8, r8
  000a7	74 09		 je	 SHORT $LN23@s_pack_int
  000a9	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000b0	eb 0d		 jmp	 SHORT $LN24@s_pack_int
$LN23@s_pack_int:
  000b2	49 8b d7	 mov	 rdx, r15
  000b5	eb 08		 jmp	 SHORT $LN24@s_pack_int
$LN33@s_pack_int:

; 1593 :             }
; 1594 :             if (isstring) {
; 1595 :                 n = PyBytes_GET_SIZE(v);

  000b7	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]

; 1596 :                 p = PyBytes_AS_STRING(v);

  000bb	48 8d 53 78	 lea	 rdx, QWORD PTR [rbx+120]
$LN24@s_pack_int:

; 1601 :             }
; 1602 :             if (n > code->size)

  000bf	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  000c3	4c 3b c0	 cmp	 r8, rax
  000c6	4c 0f 4f c0	 cmovg	 r8, rax

; 1603 :                 n = code->size;
; 1604 :             if (n > 0)

  000ca	4d 85 c0	 test	 r8, r8
  000cd	0f 8e 99 00 00
	00		 jle	 $LN19@s_pack_int

; 1605 :                 memcpy(res, p, n);

  000d3	48 8b cd	 mov	 rcx, rbp
  000d6	e8 00 00 00 00	 call	 memcpy

; 1606 :         } else if (e->format == 'p') {

  000db	e9 8c 00 00 00	 jmp	 $LN19@s_pack_int
$LN17@s_pack_int:
  000e0	3c 70		 cmp	 al, 112			; 00000070H
  000e2	75 77		 jne	 SHORT $LN10@s_pack_int

; 1607 :             int isstring;
; 1608 :             void *p;
; 1609 :             isstring = PyBytes_Check(v);

  000e4	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  000e8	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  000ee	c1 e8 1b	 shr	 eax, 27
  000f1	83 e0 01	 and	 eax, 1

; 1610 :             if (!isstring && !PyByteArray_Check(v)) {

  000f4	75 2c		 jne	 SHORT $LN32@s_pack_int
  000f6	49 3b ce	 cmp	 rcx, r14
  000f9	74 10		 je	 SHORT $LN8@s_pack_int
  000fb	49 8b d6	 mov	 rdx, r14
  000fe	e8 00 00 00 00	 call	 PyType_IsSubtype
  00103	85 c0		 test	 eax, eax
  00105	0f 84 a9 00 00
	00		 je	 $LN29@s_pack_int
$LN8@s_pack_int:

; 1618 :             }
; 1619 :             else {
; 1620 :                 n = PyByteArray_GET_SIZE(v);

  0010b	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]

; 1621 :                 p = PyByteArray_AS_STRING(v);

  0010f	48 85 ff	 test	 rdi, rdi
  00112	74 09		 je	 SHORT $LN25@s_pack_int
  00114	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0011b	eb 0d		 jmp	 SHORT $LN26@s_pack_int
$LN25@s_pack_int:
  0011d	49 8b d7	 mov	 rdx, r15
  00120	eb 08		 jmp	 SHORT $LN26@s_pack_int
$LN32@s_pack_int:

; 1614 :             }
; 1615 :             if (isstring) {
; 1616 :                 n = PyBytes_GET_SIZE(v);

  00122	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]

; 1617 :                 p = PyBytes_AS_STRING(v);

  00126	48 8d 53 78	 lea	 rdx, QWORD PTR [rbx+120]
$LN26@s_pack_int:

; 1622 :             }
; 1623 :             if (n > (code->size - 1))

  0012a	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  0012e	48 ff c8	 dec	 rax
  00131	48 3b f8	 cmp	 rdi, rax
  00134	48 0f 4f f8	 cmovg	 rdi, rax

; 1624 :                 n = code->size - 1;
; 1625 :             if (n > 0)

  00138	48 85 ff	 test	 rdi, rdi
  0013b	7e 0c		 jle	 SHORT $LN5@s_pack_int

; 1626 :                 memcpy(res + 1, p, n);

  0013d	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
  00141	4c 8b c7	 mov	 r8, rdi
  00144	e8 00 00 00 00	 call	 memcpy
$LN5@s_pack_int:

; 1627 :             if (n > 255)

  00149	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0014e	48 3b f9	 cmp	 rdi, rcx
  00151	48 0f 4f f9	 cmovg	 rdi, rcx

; 1628 :                 n = 255;
; 1629 :             *res = Py_SAFE_DOWNCAST(n, Py_ssize_t, unsigned char);

  00155	40 88 7d 00	 mov	 BYTE PTR [rbp], dil

; 1630 :         } else {

  00159	eb 11		 jmp	 SHORT $LN19@s_pack_int
$LN10@s_pack_int:

; 1631 :             if (e->pack(res, v, e) < 0) {

  0015b	4d 8b c2	 mov	 r8, r10
  0015e	48 8b d3	 mov	 rdx, rbx
  00161	48 8b cd	 mov	 rcx, rbp
  00164	41 ff 52 20	 call	 QWORD PTR [r10+32]
  00168	85 c0		 test	 eax, eax
  0016a	78 60		 js	 SHORT $LN30@s_pack_int
$LN19@s_pack_int:

; 1579 :     i = offset;
; 1580 :     for (code = soself->s_codes; code->fmtdef != NULL; code++) {

  0016c	4c 8b 56 18	 mov	 r10, QWORD PTR [rsi+24]
  00170	48 83 c6 18	 add	 rsi, 24
  00174	4d 85 d2	 test	 r10, r10
  00177	0f 85 e3 fe ff
	ff		 jne	 $LL20@s_pack_int
$LN18@s_pack_int:

; 1636 :             }
; 1637 :         }
; 1638 :     }
; 1639 : 
; 1640 :     /* Success */
; 1641 :     return 0;

  0017d	33 c0		 xor	 eax, eax
$LN21@s_pack_int:

; 1642 : }

  0017f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00184	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00189	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0018e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00192	41 5f		 pop	 r15
  00194	41 5e		 pop	 r14
  00196	41 5d		 pop	 r13
  00198	41 5c		 pop	 r12
  0019a	5f		 pop	 rdi
  0019b	c3		 ret	 0
$LN28@s_pack_int:

; 1590 :                 PyErr_SetString(StructError,
; 1591 :                                 "argument for 's' must be a bytes object");

  0019c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NJILNDPO@argument?5for?5?8s?8?5must?5be?5a?5bytes@
  001aa	e8 00 00 00 00	 call	 PyErr_SetString

; 1592 :                 return -1;

  001af	83 c8 ff	 or	 eax, -1
  001b2	eb cb		 jmp	 SHORT $LN21@s_pack_int
$LN29@s_pack_int:

; 1611 :                 PyErr_SetString(StructError,
; 1612 :                                 "argument for 'p' must be a bytes object");

  001b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@CLNMDOAG@argument?5for?5?8p?8?5must?5be?5a?5bytes@
  001c2	e8 00 00 00 00	 call	 PyErr_SetString

; 1613 :                 return -1;

  001c7	83 c8 ff	 or	 eax, -1
  001ca	eb b3		 jmp	 SHORT $LN21@s_pack_int
$LN30@s_pack_int:

; 1632 :                 if (PyLong_Check(v) && PyErr_ExceptionMatches(PyExc_OverflowError))

  001cc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001d0	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  001da	74 23		 je	 SHORT $LN1@s_pack_int
  001dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001e3	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  001e8	85 c0		 test	 eax, eax
  001ea	74 13		 je	 SHORT $LN1@s_pack_int

; 1633 :                     PyErr_SetString(StructError,
; 1634 :                                     "int too large to convert");

  001ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BKNAGDBC@int?5too?5large?5to?5convert?$AA@
  001fa	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@s_pack_int:

; 1635 :                 return -1;

  001ff	83 c8 ff	 or	 eax, -1
  00202	e9 78 ff ff ff	 jmp	 $LN21@s_pack_int
s_pack_internal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack DD imagerel s_pack
	DD	imagerel s_pack+67
	DD	imagerel $unwind$s_pack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$s_pack DD imagerel s_pack+67
	DD	imagerel s_pack+133
	DD	imagerel $chain$0$s_pack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$s_pack DD imagerel s_pack+133
	DD	imagerel s_pack+152
	DD	imagerel $chain$2$s_pack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$s_pack DD 020021H
	DD	063400H
	DD	imagerel s_pack
	DD	imagerel s_pack+67
	DD	imagerel $unwind$s_pack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$s_pack DD 020521H
	DD	063405H
	DD	imagerel s_pack
	DD	imagerel s_pack+67
	DD	imagerel $unwind$s_pack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@
CONST	SEGMENT
??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@ DB 'pack exp'
	DB	'ected %zd items for packing (got %zd)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_pack
_TEXT	SEGMENT
self$ = 48
args$ = 56
s_pack	PROC						; COMDAT

; 1654 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1655 :     PyStructObject *soself;
; 1656 :     PyObject *result;
; 1657 : 
; 1658 :     /* Validate arguments. */
; 1659 :     soself = (PyStructObject *)self;
; 1660 :     assert(PyStruct_Check(self));
; 1661 :     assert(soself->s_codes != NULL);
; 1662 :     if (PyTuple_GET_SIZE(args) != soself->s_len)

  0000a	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  0000e	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	4d 3b c8	 cmp	 r9, r8
  0001b	74 20		 je	 SHORT $LN3@s_pack

; 1663 :     {
; 1664 :         PyErr_Format(StructError,
; 1665 :             "pack expected %zd items for packing (got %zd)", soself->s_len, PyTuple_GET_SIZE(args));

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@ODBGMAEE@pack?5expected?5?$CFzd?5items?5for?5pack@
  0002b	e8 00 00 00 00	 call	 PyErr_Format

; 1666 :         return NULL;

  00030	33 c0		 xor	 eax, eax

; 1678 :     }
; 1679 : 
; 1680 :     return result;
; 1681 : }

  00032	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN3@s_pack:

; 1667 :     }
; 1668 : 
; 1669 :     /* Allocate a new string */
; 1670 :     result = PyBytes_FromStringAndSize((char *)NULL, soself->s_size);

  0003d	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00041	33 c9		 xor	 ecx, ecx
  00043	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00048	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0004d	48 8b d8	 mov	 rbx, rax

; 1671 :     if (result == NULL)

  00050	48 85 c0	 test	 rax, rax

; 1672 :         return NULL;

  00053	74 1e		 je	 SHORT $LN7@s_pack

; 1673 : 
; 1674 :     /* Call the guts */
; 1675 :     if ( s_pack_internal(soself, args, 0, PyBytes_AS_STRING(result)) != 0 ) {

  00055	4c 8d 48 78	 lea	 r9, QWORD PTR [rax+120]
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	48 8b d6	 mov	 rdx, rsi
  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 s_pack_internal
  00067	85 c0		 test	 eax, eax
  00069	74 1a		 je	 SHORT $LN1@s_pack

; 1676 :         Py_DECREF(result);

  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@s_pack:

; 1677 :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1678 :     }
; 1679 : 
; 1680 :     return result;
; 1681 : }

  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN1@s_pack:
  00085	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008a	48 8b c3	 mov	 rax, rbx
  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
s_pack	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@ ; `string'
PUBLIC	??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@ ; `string'
PUBLIC	??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@ ; `string'
PUBLIC	??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@ ; `string'
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyObject_AsWriteBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pack_into DD imagerel s_pack_into
	DD	imagerel s_pack_into+165
	DD	imagerel $unwind$s_pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$s_pack_into DD imagerel s_pack_into+165
	DD	imagerel s_pack_into+212
	DD	imagerel $chain$0$s_pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$s_pack_into DD imagerel s_pack_into+212
	DD	imagerel s_pack_into+268
	DD	imagerel $chain$2$s_pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$s_pack_into DD imagerel s_pack_into+268
	DD	imagerel s_pack_into+347
	DD	imagerel $chain$4$s_pack_into
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$s_pack_into DD 020021H
	DD	083400H
	DD	imagerel s_pack_into
	DD	imagerel s_pack_into+165
	DD	imagerel $unwind$s_pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$s_pack_into DD 020021H
	DD	083400H
	DD	imagerel s_pack_into
	DD	imagerel s_pack_into+165
	DD	imagerel $unwind$s_pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$s_pack_into DD 020521H
	DD	083405H
	DD	imagerel s_pack_into
	DD	imagerel s_pack_into+165
	DD	imagerel $unwind$s_pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pack_into DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@
CONST	SEGMENT
??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@ DB 'pack_into r'
	DB	'equires a buffer of at least %zd bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@
CONST	SEGMENT
??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@ DB 'pack_into'
	DB	' expected %zd items for packing (got %zd)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@
CONST	SEGMENT
??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@ DB 'pack_into exp'
	DB	'ected offset argument', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@
CONST	SEGMENT
??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@ DB 'pack_into exp'
	DB	'ected buffer argument', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT s_pack_into
_TEXT	SEGMENT
buffer_len$ = 48
self$ = 48
buffer$ = 56
args$ = 56
s_pack_into PROC					; COMDAT

; 1693 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1694 :     PyStructObject *soself;
; 1695 :     char *buffer;
; 1696 :     Py_ssize_t buffer_len, offset;
; 1697 : 
; 1698 :     /* Validate arguments.  +1 is for the first arg as buffer. */
; 1699 :     soself = (PyStructObject *)self;
; 1700 :     assert(PyStruct_Check(self));
; 1701 :     assert(soself->s_codes != NULL);
; 1702 :     if (PyTuple_GET_SIZE(args) != (soself->s_len + 2))

  0000a	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  0000e	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	49 8d 40 02	 lea	 rax, QWORD PTR [r8+2]
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	4c 3b c8	 cmp	 r9, rax
  0001f	74 61		 je	 SHORT $LN11@s_pack_int@2

; 1703 :     {
; 1704 :         if (PyTuple_GET_SIZE(args) == 0) {
; 1705 :             PyErr_Format(StructError,
; 1706 :                         "pack_into expected buffer argument");

  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  00028	4d 85 c9	 test	 r9, r9
  0002b	75 19		 jne	 SHORT $LN10@s_pack_int@2
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FKEIKOLF@pack_into?5expected?5buffer?5argume@
  00034	e8 00 00 00 00	 call	 PyErr_Format

; 1716 :         }
; 1717 :         return NULL;

  00039	33 c0		 xor	 eax, eax

; 1750 : }

  0003b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN10@s_pack_int@2:

; 1707 :         }
; 1708 :         else if (PyTuple_GET_SIZE(args) == 1) {

  00046	49 83 f9 01	 cmp	 r9, 1
  0004a	75 19		 jne	 SHORT $LN8@s_pack_int@2

; 1709 :             PyErr_Format(StructError,
; 1710 :                         "pack_into expected offset argument");

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@EHIAMGFA@pack_into?5expected?5offset?5argume@
  00053	e8 00 00 00 00	 call	 PyErr_Format

; 1716 :         }
; 1717 :         return NULL;

  00058	33 c0		 xor	 eax, eax

; 1750 : }

  0005a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
$LN8@s_pack_int@2:

; 1711 :         }
; 1712 :         else {
; 1713 :             PyErr_Format(StructError,
; 1714 :                         "pack_into expected %zd items for packing (got %zd)",
; 1715 :                         soself->s_len, (PyTuple_GET_SIZE(args) - 2));

  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@IMGMLBJO@pack_into?5expected?5?$CFzd?5items?5for@
  0006c	49 83 c1 fe	 add	 r9, -2
  00070	e8 00 00 00 00	 call	 PyErr_Format
$LN7@s_pack_int@2:

; 1716 :         }
; 1717 :         return NULL;

  00075	33 c0		 xor	 eax, eax

; 1750 : }

  00077	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN11@s_pack_int@2:

; 1718 :     }
; 1719 : 
; 1720 :     /* Extract a writable memory buffer from the first argument */
; 1721 :     if ( PyObject_AsWriteBuffer(PyTuple_GET_ITEM(args, 0),
; 1722 :                                                             (void**)&buffer, &buffer_len) == -1 ) {

  00082	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00086	4c 8d 44 24 30	 lea	 r8, QWORD PTR buffer_len$[rsp]
  0008b	48 8d 54 24 38	 lea	 rdx, QWORD PTR buffer$[rsp]
  00090	e8 00 00 00 00	 call	 PyObject_AsWriteBuffer
  00095	83 f8 ff	 cmp	 eax, -1

; 1723 :         return NULL;

  00098	74 db		 je	 SHORT $LN7@s_pack_int@2

; 1724 :     }
; 1725 :     assert( buffer_len >= 0 );
; 1726 : 
; 1727 :     /* Extract the offset from the first argument */
; 1728 :     offset = PyNumber_AsSsize_t(PyTuple_GET_ITEM(args, 1), PyExc_IndexError);

  0009a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000a1	48 8b 4e 78	 mov	 rcx, QWORD PTR [rsi+120]
  000a5	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000aa	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000af	48 8b d8	 mov	 rbx, rax

; 1729 :     if (offset == -1 && PyErr_Occurred())

  000b2	48 83 f8 ff	 cmp	 rax, -1
  000b6	75 1c		 jne	 SHORT $LN5@s_pack_int@2
  000b8	e8 00 00 00 00	 call	 PyErr_Occurred
  000bd	48 85 c0	 test	 rax, rax
  000c0	74 17		 je	 SHORT $LN15@s_pack_int@2

; 1741 :         return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1750 : }

  000c9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
$LN5@s_pack_int@2:

; 1730 :         return NULL;
; 1731 : 
; 1732 :     /* Support negative offsets. */
; 1733 :     if (offset < 0)

  000d4	48 85 c0	 test	 rax, rax
  000d7	79 33		 jns	 SHORT $LN16@s_pack_int@2
$LN15@s_pack_int@2:

; 1734 :         offset += buffer_len;

  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer_len$[rsp]
  000de	48 03 d8	 add	 rbx, rax

; 1735 : 
; 1736 :     /* Check boundaries */
; 1737 :     if (offset < 0 || (buffer_len - offset) < soself->s_size) {

  000e1	79 2e		 jns	 SHORT $LN14@s_pack_int@2
$LN2@s_pack_int@2:

; 1738 :         PyErr_Format(StructError,
; 1739 :                      "pack_into requires a buffer of at least %zd bytes",
; 1740 :                      soself->s_size);

  000e3	4c 8b 47 60	 mov	 r8, QWORD PTR [rdi+96]
  000e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR StructError
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@GDDDEOGE@pack_into?5requires?5a?5buffer?5of?5a@
  000f5	e8 00 00 00 00	 call	 PyErr_Format
$LN18@s_pack_int@2:

; 1741 :         return NULL;

  000fa	33 c0		 xor	 eax, eax
  000fc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1750 : }

  00101	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00106	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010a	5f		 pop	 rdi
  0010b	c3		 ret	 0
$LN16@s_pack_int@2:

; 1735 : 
; 1736 :     /* Check boundaries */
; 1737 :     if (offset < 0 || (buffer_len - offset) < soself->s_size) {

  0010c	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer_len$[rsp]
$LN14@s_pack_int@2:
  00111	48 2b c3	 sub	 rax, rbx
  00114	48 3b 47 60	 cmp	 rax, QWORD PTR [rdi+96]
  00118	7c c9		 jl	 SHORT $LN2@s_pack_int@2

; 1742 :     }
; 1743 : 
; 1744 :     /* Call the guts */
; 1745 :     if ( s_pack_internal(soself, args, 2, buffer + offset) != 0 ) {

  0011a	48 8b 44 24 38	 mov	 rax, QWORD PTR buffer$[rsp]
  0011f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00125	48 8b d6	 mov	 rdx, rsi
  00128	4c 8d 0c 03	 lea	 r9, QWORD PTR [rbx+rax]
  0012c	48 8b cf	 mov	 rcx, rdi
  0012f	e8 00 00 00 00	 call	 s_pack_internal
  00134	85 c0		 test	 eax, eax

; 1746 :         return NULL;

  00136	75 c2		 jne	 SHORT $LN18@s_pack_int@2

; 1747 :     }
; 1748 : 
; 1749 :     Py_RETURN_NONE;

  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0013f	e8 00 00 00 00	 call	 _Py_IncRef
  00144	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1750 : }

  00149	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0014e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00155	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00159	5f		 pop	 rdi
  0015a	c3		 ret	 0
s_pack_into ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$s_get_format DD imagerel s_get_format
	DD	imagerel s_get_format+91
	DD	imagerel $unwind$s_get_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_get_format DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
xdata	ENDS
;	COMDAT s_get_format
_TEXT	SEGMENT
self$ = 64
unused$ = 72
s_get_format PROC					; COMDAT

; 1754 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1755 :     Py_INCREF(self->s_format);

  0000a	48 8b 79 78	 mov	 rdi, QWORD PTR [rcx+120]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	e8 00 00 00 00	 call	 _Py_PXCTX
  00016	85 c0		 test	 eax, eax
  00018	75 32		 jne	 SHORT $LN7@s_get_form
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00028	4c 8b cf	 mov	 r9, rdi
  0002b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00031	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00039	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003e	85 c0		 test	 eax, eax
  00040	75 06		 jne	 SHORT $LN3@s_get_form
  00042	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00046	74 04		 je	 SHORT $LN7@s_get_form
$LN3@s_get_form:
  00048	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@s_get_form:

; 1756 :     return self->s_format;

  0004c	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 1757 : }

  00050	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
s_get_format ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT s_get_size
_TEXT	SEGMENT
self$ = 8
unused$ = 16
s_get_size PROC						; COMDAT

; 1762 :     return PyLong_FromSsize_t(self->s_size);

  00000	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]

; 1763 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
s_get_size ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT s_sizeof
_TEXT	SEGMENT
self$ = 8
unused$ = 16
s_sizeof PROC						; COMDAT

; 1771 :     Py_ssize_t size;
; 1772 : 
; 1773 :     size = sizeof(PyStructObject) + sizeof(formatcode) * (self->s_len + 1);

  00000	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00004	48 8d 4c 40 15	 lea	 rcx, QWORD PTR [rax+rax*2+21]
  00009	48 c1 e1 03	 shl	 rcx, 3

; 1774 :     return PyLong_FromSsize_t(size);
; 1775 : }

  0000d	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
s_sizeof ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_Clear:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$cache_struct DD imagerel cache_struct
	DD	imagerel cache_struct+50
	DD	imagerel $unwind$cache_struct
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cache_struct DD imagerel cache_struct+50
	DD	imagerel cache_struct+145
	DD	imagerel $chain$0$cache_struct
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$cache_struct DD imagerel cache_struct+145
	DD	imagerel cache_struct+243
	DD	imagerel $chain$2$cache_struct
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$cache_struct DD 020021H
	DD	083400H
	DD	imagerel cache_struct
	DD	imagerel cache_struct+50
	DD	imagerel $unwind$cache_struct
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cache_struct DD 020521H
	DD	083405H
	DD	imagerel cache_struct
	DD	imagerel cache_struct+50
	DD	imagerel $unwind$cache_struct
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cache_struct DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
xdata	ENDS
;	COMDAT cache_struct
_TEXT	SEGMENT
fmt$ = 64
cache_struct PROC					; COMDAT

; 1854 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1855 :     PyObject * s_object;
; 1856 : 
; 1857 :     if (cache == NULL) {

  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR cache
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 85 c0	 test	 rax, rax
  00013	75 17		 jne	 SHORT $LN5@cache_stru

; 1858 :         cache = PyDict_New();

  00015	e8 00 00 00 00	 call	 PyDict_New
  0001a	48 89 05 00 00
	00 00		 mov	 QWORD PTR cache, rax

; 1859 :         if (cache == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	75 06		 jne	 SHORT $LN5@cache_stru

; 1878 : }

  00026	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN5@cache_stru:

; 1860 :             return NULL;
; 1861 :     }
; 1862 : 
; 1863 :     s_object = PyDict_GetItem(cache, fmt);

  0002c	48 8b d7	 mov	 rdx, rdi
  0002f	48 8b c8	 mov	 rcx, rax
  00032	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00037	e8 00 00 00 00	 call	 PyDict_GetItem
  0003c	48 8b d8	 mov	 rbx, rax

; 1864 :     if (s_object != NULL) {

  0003f	48 85 c0	 test	 rax, rax
  00042	74 4d		 je	 SHORT $LN4@cache_stru

; 1865 :         Py_INCREF(s_object);

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	0f 85 94 00 00
	00		 jne	 $LN1@cache_stru
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005f	4c 8b cb	 mov	 r9, rbx
  00062	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00068	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00070	e8 00 00 00 00	 call	 _PyParallel_Guard
  00075	85 c0		 test	 eax, eax
  00077	75 06		 jne	 SHORT $LN9@cache_stru
  00079	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0007d	74 66		 je	 SHORT $LN1@cache_stru
$LN9@cache_stru:
  0007f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]

; 1876 :     }
; 1877 :     return s_object;

  00083	48 8b c3	 mov	 rax, rbx
  00086	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1878 : }

  0008b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
$LN4@cache_stru:

; 1866 :         return s_object;
; 1867 :     }
; 1868 : 
; 1869 :     s_object = PyObject_CallFunctionObjArgs((PyObject *)(&PyStructType), fmt, NULL);

  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStructType
  00098	45 33 c0	 xor	 r8d, r8d
  0009b	48 8b d7	 mov	 rdx, rdi
  0009e	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000a3	48 8b d8	 mov	 rbx, rax

; 1870 :     if (s_object != NULL) {

  000a6	48 85 c0	 test	 rax, rax
  000a9	74 3a		 je	 SHORT $LN1@cache_stru

; 1871 :         if (PyDict_Size(cache) >= MAXCACHE)

  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  000b2	e8 00 00 00 00	 call	 PyDict_Size
  000b7	48 83 f8 64	 cmp	 rax, 100		; 00000064H
  000bb	7c 0c		 jl	 SHORT $LN2@cache_stru

; 1872 :             PyDict_Clear(cache);

  000bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  000c4	e8 00 00 00 00	 call	 PyDict_Clear
$LN2@cache_stru:

; 1873 :         /* Attempt to cache the result */
; 1874 :         if (PyDict_SetItem(cache, fmt, s_object) == -1)

  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cache
  000d0	4c 8b c3	 mov	 r8, rbx
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	e8 00 00 00 00	 call	 PyDict_SetItem
  000db	83 f8 ff	 cmp	 eax, -1
  000de	75 05		 jne	 SHORT $LN1@cache_stru

; 1875 :             PyErr_Clear();

  000e0	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@cache_stru:

; 1876 :     }
; 1877 :     return s_object;

  000e5	48 8b c3	 mov	 rax, rbx
  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1878 : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
cache_struct ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LKDIIBIG@clearcache?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$clearcache DD imagerel clearcache
	DD	imagerel clearcache+272
	DD	imagerel $unwind$clearcache
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$clearcache DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@LKDIIBIG@clearcache?$AA@
CONST	SEGMENT
??_C@_0L@LKDIIBIG@clearcache?$AA@ DB 'clearcache', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
CONST	ENDS
;	COMDAT clearcache
_TEXT	SEGMENT
self$ = 64
clearcache PROC						; COMDAT

; 1885 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1886 :     Py_CLEAR(cache);

  00006	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR cache
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 9c 00 00
	00		 je	 $LN3@clearcache
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@DIOKFDPL@?4?4?2Modules?2_struct?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LKDIIBIG@clearcache?$AA@
  00024	41 b8 5e 07 00
	00		 mov	 r8d, 1886		; 0000075eH
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	75 77		 jne	 SHORT $LN3@clearcache
  0003b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR cache
  00042	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR cache, 0
  0004d	e8 00 00 00 00	 call	 _Py_PXCTX
  00052	85 c0		 test	 eax, eax
  00054	75 5c		 jne	 SHORT $LN3@clearcache
  00056	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005a	a8 20		 test	 al, 32			; 00000020H
  0005c	75 4c		 jne	 SHORT $LN11@clearcache
  0005e	84 c0		 test	 al, al
  00060	78 48		 js	 SHORT $LN11@clearcache
  00062	a8 02		 test	 al, 2
  00064	75 4c		 jne	 SHORT $LN3@clearcache
  00066	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006a	75 46		 jne	 SHORT $LN3@clearcache
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007a	4c 8b cb	 mov	 r9, rbx
  0007d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00083	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00090	48 8b cb	 mov	 rcx, rbx
  00093	85 c0		 test	 eax, eax
  00095	74 07		 je	 SHORT $LN16@clearcache
  00097	e8 00 00 00 00	 call	 _Px_Dealloc
  0009c	eb 14		 jmp	 SHORT $LN3@clearcache
$LN16@clearcache:
  0009e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a8	eb 08		 jmp	 SHORT $LN3@clearcache
$LN11@clearcache:
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 Px_DecRef
$LN3@clearcache:

; 1887 :     Py_RETURN_NONE;

  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	85 c0		 test	 eax, eax
  000b9	75 48		 jne	 SHORT $LN22@clearcache
  000bb	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d6	4c 8b cb	 mov	 r9, rbx
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e6	85 c0		 test	 eax, eax
  000e8	75 09		 jne	 SHORT $LN18@clearcache
  000ea	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000f1	74 07		 je	 SHORT $LN24@clearcache
$LN18@clearcache:
  000f3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN24@clearcache:
  000fa	48 8b c3	 mov	 rax, rbx

; 1888 : }

  000fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00101	5b		 pop	 rbx
  00102	c3		 ret	 0
$LN22@clearcache:

; 1887 :     Py_RETURN_NONE;

  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1888 : }

  0010a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010e	5b		 pop	 rbx
  0010f	c3		 ret	 0
clearcache ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$calcsize DD imagerel calcsize
	DD	imagerel calcsize+56
	DD	imagerel $unwind$calcsize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calcsize DD 031e01H
	DD	04341eH
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT calcsize
_TEXT	SEGMENT
self$ = 48
fmt$ = 56
calcsize PROC						; COMDAT

; 1897 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1898 :     Py_ssize_t n;
; 1899 :     PyObject *s_object = cache_struct(fmt);

  00004	48 8b ca	 mov	 rcx, rdx
  00007	e8 00 00 00 00	 call	 cache_struct

; 1900 :     if (s_object == NULL)

  0000c	48 85 c0	 test	 rax, rax
  0000f	75 05		 jne	 SHORT $LN1@calcsize

; 1905 : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
$LN1@calcsize:

; 1901 :         return NULL;
; 1902 :     n = ((PyStructObject *)s_object)->s_size;
; 1903 :     Py_DECREF(s_object);

  00016	48 8b c8	 mov	 rcx, rax
  00019	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001e	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]
  00022	e8 00 00 00 00	 call	 _Py_DecRef

; 1904 :     return PyLong_FromSsize_t(n);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 1905 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
calcsize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@ ; `string'
EXTRN	PyTuple_GetSlice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack DD	imagerel pack
	DD	imagerel pack+42
	DD	imagerel $unwind$pack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pack DD imagerel pack+42
	DD	imagerel pack+92
	DD	imagerel $chain$1$pack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pack DD imagerel pack+92
	DD	imagerel pack+143
	DD	imagerel $chain$4$pack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pack DD imagerel pack+143
	DD	imagerel pack+196
	DD	imagerel $chain$6$pack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pack DD 060021H
	DD	047400H
	DD	076400H
	DD	063400H
	DD	imagerel pack
	DD	imagerel pack+42
	DD	imagerel $unwind$pack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pack DD 060821H
	DD	076408H
	DD	047400H
	DD	063400H
	DD	imagerel pack
	DD	imagerel pack+42
	DD	imagerel $unwind$pack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pack DD 041621H
	DD	047416H
	DD	063405H
	DD	imagerel pack
	DD	imagerel pack+42
	DD	imagerel $unwind$pack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack DD	010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
CONST	SEGMENT
??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@ DB 'missing format argu'
	DB	'ment', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pack
_TEXT	SEGMENT
self$ = 48
args$ = 56
pack	PROC						; COMDAT

; 1915 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1916 :     PyObject *s_object, *fmt, *newargs, *result;
; 1917 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  00004	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00008	48 8b c2	 mov	 rax, rdx

; 1918 : 
; 1919 :     if (n == 0) {

  0000b	4d 85 c0	 test	 r8, r8
  0000e	75 1a		 jne	 SHORT $LN3@pack

; 1920 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString

; 1921 :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 1937 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN3@pack:
  0002a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1922 :     }
; 1923 :     fmt = PyTuple_GET_ITEM(args, 0);

  0002f	48 8b 5a 70	 mov	 rbx, QWORD PTR [rdx+112]

; 1924 :     newargs = PyTuple_GetSlice(args, 1, n);

  00033	48 8b c8	 mov	 rcx, rax
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00040	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00045	48 8b f8	 mov	 rdi, rax

; 1925 :     if (newargs == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	75 0f		 jne	 SHORT $LN2@pack
  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1937 : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
$LN2@pack:

; 1926 :         return NULL;
; 1927 : 
; 1928 :     s_object = cache_struct(fmt);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00064	e8 00 00 00 00	 call	 cache_struct
  00069	48 8b f0	 mov	 rsi, rax

; 1929 :     if (s_object == NULL) {

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 1e		 jne	 SHORT $LN1@pack

; 1930 :         Py_DECREF(newargs);

  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 _Py_DecRef
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1931 :         return NULL;

  00088	33 c0		 xor	 eax, eax

; 1937 : }

  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	c3		 ret	 0
$LN1@pack:

; 1932 :     }
; 1933 :     result = s_pack(s_object, newargs);

  0008f	48 8b d7	 mov	 rdx, rdi
  00092	48 8b c8	 mov	 rcx, rax
  00095	e8 00 00 00 00	 call	 s_pack

; 1934 :     Py_DECREF(newargs);

  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	48 8b d8	 mov	 rbx, rax
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1935 :     Py_DECREF(s_object);

  000a5	48 8b ce	 mov	 rcx, rsi
  000a8	e8 00 00 00 00	 call	 _Py_DecRef
  000ad	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b2	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1936 :     return result;

  000b7	48 8b c3	 mov	 rax, rbx
  000ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1937 : }

  000bf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c3	c3		 ret	 0
pack	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack_into DD imagerel pack_into
	DD	imagerel pack_into+42
	DD	imagerel $unwind$pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pack_into DD imagerel pack_into+42
	DD	imagerel pack_into+92
	DD	imagerel $chain$1$pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pack_into DD imagerel pack_into+92
	DD	imagerel pack_into+143
	DD	imagerel $chain$4$pack_into
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pack_into DD imagerel pack_into+143
	DD	imagerel pack_into+196
	DD	imagerel $chain$6$pack_into
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pack_into DD 060021H
	DD	047400H
	DD	076400H
	DD	063400H
	DD	imagerel pack_into
	DD	imagerel pack_into+42
	DD	imagerel $unwind$pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pack_into DD 060821H
	DD	076408H
	DD	047400H
	DD	063400H
	DD	imagerel pack_into
	DD	imagerel pack_into+42
	DD	imagerel $unwind$pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pack_into DD 041621H
	DD	047416H
	DD	063405H
	DD	imagerel pack_into
	DD	imagerel pack_into+42
	DD	imagerel $unwind$pack_into
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack_into DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pack_into
_TEXT	SEGMENT
self$ = 48
args$ = 56
pack_into PROC						; COMDAT

; 1949 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1950 :     PyObject *s_object, *fmt, *newargs, *result;
; 1951 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  00004	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  00008	48 8b c2	 mov	 rax, rdx

; 1952 : 
; 1953 :     if (n == 0) {

  0000b	4d 85 c0	 test	 r8, r8
  0000e	75 1a		 jne	 SHORT $LN3@pack_into

; 1954 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString

; 1955 :         return NULL;

  00023	33 c0		 xor	 eax, eax

; 1971 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN3@pack_into:
  0002a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1956 :     }
; 1957 :     fmt = PyTuple_GET_ITEM(args, 0);

  0002f	48 8b 5a 70	 mov	 rbx, QWORD PTR [rdx+112]

; 1958 :     newargs = PyTuple_GetSlice(args, 1, n);

  00033	48 8b c8	 mov	 rcx, rax
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00040	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00045	48 8b f8	 mov	 rdi, rax

; 1959 :     if (newargs == NULL)

  00048	48 85 c0	 test	 rax, rax
  0004b	75 0f		 jne	 SHORT $LN2@pack_into
  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1971 : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
$LN2@pack_into:

; 1960 :         return NULL;
; 1961 : 
; 1962 :     s_object = cache_struct(fmt);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00064	e8 00 00 00 00	 call	 cache_struct
  00069	48 8b f0	 mov	 rsi, rax

; 1963 :     if (s_object == NULL) {

  0006c	48 85 c0	 test	 rax, rax
  0006f	75 1e		 jne	 SHORT $LN1@pack_into

; 1964 :         Py_DECREF(newargs);

  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 _Py_DecRef
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1965 :         return NULL;

  00088	33 c0		 xor	 eax, eax

; 1971 : }

  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	c3		 ret	 0
$LN1@pack_into:

; 1966 :     }
; 1967 :     result = s_pack_into(s_object, newargs);

  0008f	48 8b d7	 mov	 rdx, rdi
  00092	48 8b c8	 mov	 rcx, rax
  00095	e8 00 00 00 00	 call	 s_pack_into

; 1968 :     Py_DECREF(newargs);

  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	48 8b d8	 mov	 rbx, rax
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1969 :     Py_DECREF(s_object);

  000a5	48 8b ce	 mov	 rcx, rsi
  000a8	e8 00 00 00 00	 call	 _Py_DecRef
  000ad	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b2	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1970 :     return result;

  000b7	48 8b c3	 mov	 rax, rbx
  000ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1971 : }

  000bf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c3	c3		 ret	 0
pack_into ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack DD imagerel unpack
	DD	imagerel unpack+67
	DD	imagerel $unwind$unpack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unpack DD imagerel unpack+67
	DD	imagerel unpack+95
	DD	imagerel $chain$0$unpack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unpack DD imagerel unpack+95
	DD	imagerel unpack+142
	DD	imagerel $chain$3$unpack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unpack DD 040d21H
	DD	08340dH
	DD	067400H
	DD	imagerel unpack
	DD	imagerel unpack+67
	DD	imagerel $unwind$unpack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unpack DD 020521H
	DD	067405H
	DD	imagerel unpack
	DD	imagerel unpack+67
	DD	imagerel $unwind$unpack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unpack
_TEXT	SEGMENT
self$ = 64
args$ = 72
fmt$ = 80
inputstr$ = 88
unpack	PROC						; COMDAT

; 1982 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 8b c2	 mov	 rax, rdx

; 1983 :     PyObject *s_object, *fmt, *inputstr, *result;
; 1984 : 
; 1985 :     if (!PyArg_UnpackTuple(args, "unpack", 2, 2, &fmt, &inputstr))

  00007	48 8d 4c 24 58	 lea	 rcx, QWORD PTR inputstr$[rsp]
  0000c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00012	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00017	48 8d 4c 24 50	 lea	 rcx, QWORD PTR fmt$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FIONAGJL@unpack?$AA@
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	48 8b c8	 mov	 rcx, rax
  0002b	45 8b c1	 mov	 r8d, r9d
  0002e	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN2@unpack

; 1986 :         return NULL;

  00037	33 c0		 xor	 eax, eax

; 1994 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
$LN2@unpack:

; 1987 : 
; 1988 :     s_object = cache_struct(fmt);

  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fmt$[rsp]
  00043	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00048	e8 00 00 00 00	 call	 cache_struct
  0004d	48 8b f8	 mov	 rdi, rax

; 1989 :     if (s_object == NULL)

  00050	48 85 c0	 test	 rax, rax
  00053	75 0a		 jne	 SHORT $LN1@unpack
  00055	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1994 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
$LN1@unpack:

; 1990 :         return NULL;
; 1991 :     result = s_unpack(s_object, inputstr);

  0005f	48 8b 54 24 58	 mov	 rdx, QWORD PTR inputstr$[rsp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0006c	e8 00 00 00 00	 call	 s_unpack

; 1992 :     Py_DECREF(s_object);

  00071	48 8b cf	 mov	 rcx, rdi
  00074	48 8b d8	 mov	 rbx, rax
  00077	e8 00 00 00 00	 call	 _Py_DecRef
  0007c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1993 :     return result;

  00081	48 8b c3	 mov	 rax, rbx
  00084	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1994 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
unpack	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_from DD imagerel unpack_from
	DD	imagerel unpack_from+48
	DD	imagerel $unwind$unpack_from
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unpack_from DD imagerel unpack_from+48
	DD	imagerel unpack_from+99
	DD	imagerel $chain$1$unpack_from
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$unpack_from DD imagerel unpack_from+99
	DD	imagerel unpack_from+189
	DD	imagerel $chain$4$unpack_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$unpack_from DD 060821H
	DD	076408H
	DD	087400H
	DD	063400H
	DD	imagerel unpack_from
	DD	imagerel unpack_from+48
	DD	imagerel $unwind$unpack_from
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unpack_from DD 041621H
	DD	087416H
	DD	063405H
	DD	imagerel unpack_from
	DD	imagerel unpack_from+48
	DD	imagerel $unwind$unpack_from
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_from DD 020601H
	DD	050023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unpack_from
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwds$ = 64
unpack_from PROC					; COMDAT

; 2005 : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b e8	 mov	 rbp, r8

; 2006 :     PyObject *s_object, *fmt, *newargs, *result;
; 2007 :     Py_ssize_t n = PyTuple_GET_SIZE(args);

  00009	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  0000d	48 8b c2	 mov	 rax, rdx

; 2008 : 
; 2009 :     if (n == 0) {

  00010	4d 85 c0	 test	 r8, r8
  00013	75 1b		 jne	 SHORT $LN3@unpack_fro

; 2010 :         PyErr_SetString(PyExc_TypeError, "missing format argument");

  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PLEHCLDH@missing?5format?5argument?$AA@
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 2011 :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 2027 : }

  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5d		 pop	 rbp
  0002f	c3		 ret	 0
$LN3@unpack_fro:
  00030	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 2012 :     }
; 2013 :     fmt = PyTuple_GET_ITEM(args, 0);

  00035	48 8b 5a 70	 mov	 rbx, QWORD PTR [rdx+112]

; 2014 :     newargs = PyTuple_GetSlice(args, 1, n);

  00039	48 8b c8	 mov	 rcx, rax
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00046	e8 00 00 00 00	 call	 PyTuple_GetSlice
  0004b	48 8b f8	 mov	 rdi, rax

; 2015 :     if (newargs == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	75 10		 jne	 SHORT $LN2@unpack_fro
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2027 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
$LN2@unpack_fro:

; 2016 :         return NULL;
; 2017 : 
; 2018 :     s_object = cache_struct(fmt);

  00063	48 8b cb	 mov	 rcx, rbx
  00066	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0006b	e8 00 00 00 00	 call	 cache_struct
  00070	48 8b f0	 mov	 rsi, rax

; 2019 :     if (s_object == NULL) {

  00073	48 85 c0	 test	 rax, rax
  00076	75 0c		 jne	 SHORT $LN1@unpack_fro

; 2020 :         Py_DECREF(newargs);

  00078	48 8b cf	 mov	 rcx, rdi
  0007b	e8 00 00 00 00	 call	 _Py_DecRef

; 2021 :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	eb 24		 jmp	 SHORT $LN8@unpack_fro
$LN1@unpack_fro:

; 2022 :     }
; 2023 :     result = s_unpack_from(s_object, newargs, kwds);

  00084	4c 8b c5	 mov	 r8, rbp
  00087	48 8b d7	 mov	 rdx, rdi
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 s_unpack_from

; 2024 :     Py_DECREF(newargs);

  00092	48 8b cf	 mov	 rcx, rdi
  00095	48 8b d8	 mov	 rbx, rax
  00098	e8 00 00 00 00	 call	 _Py_DecRef

; 2025 :     Py_DECREF(s_object);

  0009d	48 8b ce	 mov	 rcx, rsi
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 2026 :     return result;

  000a5	48 8b c3	 mov	 rax, rbx
$LN8@unpack_fro:
  000a8	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ad	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2027 : }

  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	5d		 pop	 rbp
  000bc	c3		 ret	 0
unpack_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0N@PADOAEKA@struct?4error?$AA@		; `string'
PUBLIC	PyInit__struct
EXTRN	PyModule_AddObject:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_Type:BYTE
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__struct DD imagerel $LN29
	DD	imagerel $LN29+357
	DD	imagerel $unwind$PyInit__struct
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__struct DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PADOAEKA@struct?4error?$AA@
CONST	SEGMENT
??_C@_0N@PADOAEKA@struct?4error?$AA@ DB 'struct.error', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_struct.c
CONST	ENDS
;	COMDAT PyInit__struct
_TEXT	SEGMENT
PyInit__struct PROC					; COMDAT

; 2088 : {

$LN29:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2089 :     PyObject *m;
; 2090 : 
; 2091 :     m = PyModule_Create(&_structmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_structmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 2092 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 08		 jne	 SHORT $LN15@PyInit__st
$LN28@PyInit__st:

; 2093 :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 2152 : }

  00021	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN15@PyInit__st:

; 2094 : 
; 2095 :     Py_TYPE(&PyStructType) = &PyType_Type;

  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type

; 2096 :     if (PyType_Ready(&PyStructType) < 0)

  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyStructType
  00035	48 89 05 58 00
	00 00		 mov	 QWORD PTR PyStructType+88, rax
  0003c	e8 00 00 00 00	 call	 PyType_Ready
  00041	85 c0		 test	 eax, eax

; 2097 :         return NULL;

  00043	78 da		 js	 SHORT $LN28@PyInit__st

; 2103 :         formatdef *other, *ptr;
; 2104 :         if ((int)*(unsigned char*)&one)
; 2105 :             other = lilendian_table;
; 2106 :         else
; 2107 :             other = bigendian_table;
; 2108 :         /* Scan through the native table, find a matching
; 2109 :            entry in the endian table and swap in the
; 2110 :            native implementations whenever possible
; 2111 :            (64-bit platforms may not have "standard" sizes) */
; 2112 :         while (native->format != '\0' && other->format != '\0') {

  00045	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR native_table, 0
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:lilendian_table
  00053	74 61		 je	 SHORT $LN27@PyInit__st

; 2098 : 
; 2099 :     /* Check endian and swap in faster functions */
; 2100 :     {
; 2101 :         int one = 1;
; 2102 :         formatdef *native = native_table;

  00055	48 8d 15 20 00
	00 00		 lea	 rdx, OFFSET FLAT:native_table+32
  0005c	0f 1f 40 00	 npad	 4
$LL11@PyInit__st:

; 2103 :         formatdef *other, *ptr;
; 2104 :         if ((int)*(unsigned char*)&one)
; 2105 :             other = lilendian_table;
; 2106 :         else
; 2107 :             other = bigendian_table;
; 2108 :         /* Scan through the native table, find a matching
; 2109 :            entry in the endian table and swap in the
; 2110 :            native implementations whenever possible
; 2111 :            (64-bit platforms may not have "standard" sizes) */
; 2112 :         while (native->format != '\0' && other->format != '\0') {

  00060	41 80 38 00	 cmp	 BYTE PTR [r8], 0
  00064	74 50		 je	 SHORT $LN27@PyInit__st

; 2113 :             ptr = other;
; 2114 :             while (ptr->format != '\0') {

  00066	0f b6 42 e0	 movzx	 eax, BYTE PTR [rdx-32]
  0006a	49 8b c8	 mov	 rcx, r8
  0006d	0f 1f 00	 npad	 3
$LL9@PyInit__st:

; 2115 :                 if (ptr->format == native->format) {

  00070	38 01		 cmp	 BYTE PTR [rcx], al
  00072	74 0b		 je	 SHORT $LN24@PyInit__st

; 2130 :                     break;
; 2131 :                 }
; 2132 :                 ptr++;

  00074	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00078	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0007b	75 f3		 jne	 SHORT $LL9@PyInit__st

; 2115 :                 if (ptr->format == native->format) {

  0007d	eb 2d		 jmp	 SHORT $LN3@PyInit__st
$LN24@PyInit__st:

; 2116 :                     /* Match faster when formats are
; 2117 :                        listed in the same order */
; 2118 :                     if (ptr == other)

  0007f	49 3b c8	 cmp	 rcx, r8
  00082	75 04		 jne	 SHORT $LN6@PyInit__st

; 2119 :                         other++;

  00084	49 83 c0 28	 add	 r8, 40			; 00000028H
$LN6@PyInit__st:

; 2120 :                     /* Only use the trick if the
; 2121 :                        size matches */
; 2122 :                     if (ptr->size != native->size)

  00088	48 8b 42 e8	 mov	 rax, QWORD PTR [rdx-24]
  0008c	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00090	75 1a		 jne	 SHORT $LN3@PyInit__st

; 2123 :                         break;
; 2124 :                     /* Skip float and double, could be
; 2125 :                        "unknown" float format */
; 2126 :                     if (ptr->format == 'd' || ptr->format == 'f')

  00092	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00095	3c 64		 cmp	 al, 100			; 00000064H
  00097	74 13		 je	 SHORT $LN3@PyInit__st
  00099	3c 66		 cmp	 al, 102			; 00000066H
  0009b	74 0f		 je	 SHORT $LN3@PyInit__st

; 2127 :                         break;
; 2128 :                     ptr->pack = native->pack;

  0009d	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  000a0	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 2129 :                     ptr->unpack = native->unpack;

  000a4	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]
  000a8	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
$LN3@PyInit__st:

; 2133 :             }
; 2134 :             native++;

  000ac	48 83 c2 28	 add	 rdx, 40			; 00000028H
  000b0	80 7a e0 00	 cmp	 BYTE PTR [rdx-32], 0
  000b4	75 aa		 jne	 SHORT $LL11@PyInit__st
$LN27@PyInit__st:

; 2135 :         }
; 2136 :     }
; 2137 : 
; 2138 :     /* Add some symbolic constants to the module */
; 2139 :     if (StructError == NULL) {

  000b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR StructError
  000bd	48 85 c0	 test	 rax, rax
  000c0	75 21		 jne	 SHORT $LN1@PyInit__st

; 2140 :         StructError = PyErr_NewException("struct.error", NULL, NULL);

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@PADOAEKA@struct?4error?$AA@
  000c9	45 33 c0	 xor	 r8d, r8d
  000cc	33 d2		 xor	 edx, edx
  000ce	e8 00 00 00 00	 call	 PyErr_NewException
  000d3	48 89 05 00 00
	00 00		 mov	 QWORD PTR StructError, rax

; 2141 :         if (StructError == NULL)

  000da	48 85 c0	 test	 rax, rax

; 2142 :             return NULL;

  000dd	0f 84 3c ff ff
	ff		 je	 $LN28@PyInit__st
$LN1@PyInit__st:

; 2143 :     }
; 2144 : 
; 2145 :     Py_INCREF(StructError);

  000e3	48 8b c8	 mov	 rcx, rax
  000e6	e8 00 00 00 00	 call	 _Py_IncRef

; 2146 :     PyModule_AddObject(m, "error", StructError);

  000eb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR StructError
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 PyModule_AddObject

; 2147 : 
; 2148 :     Py_INCREF((PyObject*)&PyStructType);

  00101	e8 00 00 00 00	 call	 _Py_PXCTX
  00106	85 c0		 test	 eax, eax
  00108	75 3c		 jne	 SHORT $LN19@PyInit__st
  0010a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyStructType
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0011f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00125	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0012d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00132	85 c0		 test	 eax, eax
  00134	75 09		 jne	 SHORT $LN18@PyInit__st
  00136	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyStructType+32, 32 ; 00000020H
  0013d	74 07		 je	 SHORT $LN19@PyInit__st
$LN18@PyInit__st:
  0013f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyStructType+80
$LN19@PyInit__st:

; 2149 :     PyModule_AddObject(m, "Struct", (PyObject*)&PyStructType);

  00146	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyStructType
  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DOCMLGPG@Struct?$AA@
  00154	48 8b cb	 mov	 rcx, rbx
  00157	e8 00 00 00 00	 call	 PyModule_AddObject

; 2150 : 
; 2151 :     return m;

  0015c	48 8b c3	 mov	 rax, rbx

; 2152 : }

  0015f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00163	5b		 pop	 rbx
  00164	c3		 ret	 0
PyInit__struct ENDP
_TEXT	ENDS
END
