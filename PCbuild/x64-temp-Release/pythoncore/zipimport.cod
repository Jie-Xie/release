; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09INHLDGFD@zipimport?$AA@			; `string'
PUBLIC	??_C@_0L@BDJCADKN@decompress?$AA@		; `string'
PUBLIC	??_C@_0BG@NCACOKML@zipimport?4zipimporter?$AA@	; `string'
PUBLIC	??_C@_06MGHPCLOB@_files?$AA@			; `string'
PUBLIC	??_C@_06CHGOAPND@prefix?$AA@			; `string'
PUBLIC	??_C@_07NEJBDDEA@archive?$AA@			; `string'
PUBLIC	??_C@_0L@DIOPGJNK@is_package?$AA@		; `string'
PUBLIC	??_C@_0N@DMPBOHMK@get_filename?$AA@		; `string'
PUBLIC	??_C@_0L@HNCNOLCF@get_source?$AA@		; `string'
PUBLIC	??_C@_08LGIDPBCP@get_code?$AA@			; `string'
PUBLIC	??_C@_08JMDGDMHI@get_data?$AA@			; `string'
PUBLIC	??_C@_0M@KDCFJIEE@load_module?$AA@		; `string'
PUBLIC	??_C@_0M@NMMMOKMM@find_loader?$AA@		; `string'
PUBLIC	??_C@_0M@FAKMOBOL@find_module?$AA@		; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericNew:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
zip_directory_cache DQ 01H DUP (?)
?importing_zlib@?1??get_decompress_func@@9@9 DD 01H DUP (?) ; `get_decompress_func'::`2'::importing_zlib
_BSS	ENDS
;	COMDAT ??_C@_09INHLDGFD@zipimport?$AA@
CONST	SEGMENT
??_C@_09INHLDGFD@zipimport?$AA@ DB 'zipimport', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BDJCADKN@decompress?$AA@
CONST	SEGMENT
??_C@_0L@BDJCADKN@decompress?$AA@ DB 'decompress', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NCACOKML@zipimport?4zipimporter?$AA@
CONST	SEGMENT
??_C@_0BG@NCACOKML@zipimport?4zipimporter?$AA@ DB 'zipimport.zipimporter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MGHPCLOB@_files?$AA@
CONST	SEGMENT
??_C@_06MGHPCLOB@_files?$AA@ DB '_files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHGOAPND@prefix?$AA@
CONST	SEGMENT
??_C@_06CHGOAPND@prefix?$AA@ DB 'prefix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NEJBDDEA@archive?$AA@
CONST	SEGMENT
??_C@_07NEJBDDEA@archive?$AA@ DB 'archive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DIOPGJNK@is_package?$AA@
CONST	SEGMENT
??_C@_0L@DIOPGJNK@is_package?$AA@ DB 'is_package', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DMPBOHMK@get_filename?$AA@
CONST	SEGMENT
??_C@_0N@DMPBOHMK@get_filename?$AA@ DB 'get_filename', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HNCNOLCF@get_source?$AA@
CONST	SEGMENT
??_C@_0L@HNCNOLCF@get_source?$AA@ DB 'get_source', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGIDPBCP@get_code?$AA@
CONST	SEGMENT
??_C@_08LGIDPBCP@get_code?$AA@ DB 'get_code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JMDGDMHI@get_data?$AA@
CONST	SEGMENT
??_C@_08JMDGDMHI@get_data?$AA@ DB 'get_data', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KDCFJIEE@load_module?$AA@
CONST	SEGMENT
??_C@_0M@KDCFJIEE@load_module?$AA@ DB 'load_module', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMMMOKMM@find_loader?$AA@
CONST	SEGMENT
??_C@_0M@NMMMOKMM@find_loader?$AA@ DB 'find_loader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FAKMOBOL@find_module?$AA@
CONST	SEGMENT
??_C@_0M@FAKMOBOL@find_module?$AA@ DB 'find_module', 00H ; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_decompress@?1??get_decompress_func@@9@9 DQ 0000000000000000H ; `get_decompress_func'::`2'::PyId_decompress
	DQ	FLAT:??_C@_0L@BDJCADKN@decompress?$AA@
	DQ	0000000000000000H
?PyId_replace@?1??zipimporter_get_data@@9@9 DQ 0000000000000000H ; `zipimporter_get_data'::`2'::PyId_replace
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	0000000000000000H
?PyId_replace@?1??zipimporter_init@@9@9 DQ 0000000000000000H ; `zipimporter_init'::`2'::PyId_replace
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
zip_searchorder DB '/__init__.pyc', 00H
	ORG $+2
	DD	03H
	DB	'/__init__.pyo', 00H
	ORG $+2
	DD	03H
	DB	'/__init__.py', 00H
	ORG $+1
	ORG $+2
	DD	02H
	DB	'.pyc', 00H
	ORG $+9
	ORG $+2
	DD	01H
	DB	'.pyo', 00H
	ORG $+9
	ORG $+2
	DD	01H
	DB	'.py', 00H
	ORG $+10
	ORG $+2
	DD	00H
	DB	00H
	ORG $+13
	ORG $+2
	DD	00H
	ORG $+4
doc_find_module DB 'find_module(fullname, path=None) -> self or None.', 0aH
	DB	0aH, 'Search for a module specified by ''fullname''. ''fullnam'
	DB	'e'' must be the', 0aH, 'fully qualified (dotted) module name.'
	DB	' It returns the zipimporter', 0aH, 'instance itself if the mo'
	DB	'dule was found, or None if it wasn''t.', 0aH, 'The optional '''
	DB	'path'' argument is ignored -- it''s there for compatibility', 0aH
	DB	'with the importer protocol.', 00H
	ORG $+5
doc_find_loader DB 'find_loader(fullname, path=None) -> self, str or None'
	DB	'.', 0aH, 0aH, 'Search for a module specified by ''fullname''.'
	DB	' ''fullname'' must be the', 0aH, 'fully qualified (dotted) mo'
	DB	'dule name. It returns the zipimporter', 0aH, 'instance itself'
	DB	' if the module was found, a string containing the', 0aH, 'ful'
	DB	'l path name if it''s possibly a portion of a namespace packag'
	DB	'e,', 0aH, 'or None otherwise. The optional ''path'' argument '
	DB	'is ignored -- it''s', 0aH, ' there for compatibility with the'
	DB	' importer protocol.', 00H
	ORG $+8
doc_load_module DB 'load_module(fullname) -> module.', 0aH, 0aH, 'Load th'
	DB	'e module specified by ''fullname''. ''fullname'' must be the', 0aH
	DB	'fully qualified (dotted) module name. It returns the imported'
	DB	0aH, 'module, or raises ZipImportError if it wasn''t found.', 00H
	ORG $+11
doc_get_data DB	'get_data(pathname) -> string with file data.', 0aH, 0aH, 'R'
	DB	'eturn the data associated with ''pathname''. Raise IOError if'
	DB	0aH, 'the file wasn''t found.', 00H
	ORG $+14
doc_is_package DB 'is_package(fullname) -> bool.', 0aH, 0aH, 'Return True'
	DB	' if the module specified by fullname is a package.', 0aH, 'Ra'
	DB	'ise ZipImportError if the module couldn''t be found.', 00H
	ORG $+13
doc_get_code DB	'get_code(fullname) -> code object.', 0aH, 0aH, 'Return t'
	DB	'he code object for the specified module. Raise ZipImportError'
	DB	0aH, 'if the module couldn''t be found.', 00H
	ORG $+5
doc_get_source DB 'get_source(fullname) -> source string.', 0aH, 0aH, 'Re'
	DB	'turn the source code for the specified module. Raise ZipImpor'
	DB	'tError', 0aH, 'if the module couldn''t be found, return None '
	DB	'if the archive does', 0aH, 'contain the module, but has no so'
	DB	'urce for it.', 00H
	ORG $+3
doc_get_filename DB 'get_filename(fullname) -> filename string.', 0aH, 0aH
	DB	'Return the filename for the specified module.', 00H
	ORG $+6
zipimporter_methods DQ FLAT:??_C@_0M@FAKMOBOL@find_module?$AA@
	DQ	FLAT:zipimporter_find_module
	DD	01H
	ORG $+4
	DQ	FLAT:doc_find_module
	DQ	FLAT:??_C@_0M@NMMMOKMM@find_loader?$AA@
	DQ	FLAT:zipimporter_find_loader
	DD	01H
	ORG $+4
	DQ	FLAT:doc_find_loader
	DQ	FLAT:??_C@_0M@KDCFJIEE@load_module?$AA@
	DQ	FLAT:zipimporter_load_module
	DD	01H
	ORG $+4
	DQ	FLAT:doc_load_module
	DQ	FLAT:??_C@_08JMDGDMHI@get_data?$AA@
	DQ	FLAT:zipimporter_get_data
	DD	01H
	ORG $+4
	DQ	FLAT:doc_get_data
	DQ	FLAT:??_C@_08LGIDPBCP@get_code?$AA@
	DQ	FLAT:zipimporter_get_code
	DD	01H
	ORG $+4
	DQ	FLAT:doc_get_code
	DQ	FLAT:??_C@_0L@HNCNOLCF@get_source?$AA@
	DQ	FLAT:zipimporter_get_source
	DD	01H
	ORG $+4
	DQ	FLAT:doc_get_source
	DQ	FLAT:??_C@_0N@DMPBOHMK@get_filename?$AA@
	DQ	FLAT:zipimporter_get_filename
	DD	01H
	ORG $+4
	DQ	FLAT:doc_get_filename
	DQ	FLAT:??_C@_0L@DIOPGJNK@is_package?$AA@
	DQ	FLAT:zipimporter_is_package
	DD	01H
	ORG $+4
	DQ	FLAT:doc_is_package
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
zipimporter_members DQ FLAT:??_C@_07NEJBDDEA@archive?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06CHGOAPND@prefix?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06MGHPCLOB@_files?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
zipimporter_doc DB 'zipimporter(archivepath) -> zipimporter object', 0aH, 0aH
	DB	'Create a new zipimporter instance. ''archivepath'' must be a '
	DB	'path to', 0aH, 'a zipfile, or to a specific path inside a zip'
	DB	'file. For example, it can be', 0aH, '''/tmp/myimport.zip'', o'
	DB	'r ''/tmp/myimport.zip/mydirectory'', if mydirectory is a', 0aH
	DB	'valid directory inside the archive.', 0aH, 0aH, '''ZipImportE'
	DB	'rror is raised if ''archivepath'' doesn''t point to a valid Z'
	DB	'ip', 0aH, 'archive.', 0aH, 0aH, 'The ''archive'' attribute of'
	DB	' zipimporter objects contains the name of the', 0aH, 'zipfile'
	DB	' targeted.', 00H
	ORG $+5
ZipImporter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BG@NCACOKML@zipimport?4zipimporter?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:zipimporter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zipimporter_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:zipimporter_doc
	DQ	FLAT:zipimporter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zipimporter_methods
	DQ	FLAT:zipimporter_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zipimporter_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:PyType_GenericNew
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
zipimport_doc DB 'zipimport provides support for importing Python modules'
	DB	' from Zip archives.', 0aH, 0aH, 'This module exports three ob'
	DB	'jects:', 0aH, '- zipimporter: a class; its constructor takes '
	DB	'a path to a Zip archive.', 0aH, '- ZipImportError: exception '
	DB	'raised by zipimporter objects. It''s a', 0aH, '  subclass of '
	DB	'ImportError, so it can be caught as ImportError, too.', 0aH, '-'
	DB	' _zip_directory_cache: a dict, mapping archive paths to zip d'
	DB	'irectory', 0aH, '  info dicts, as used in zipimporter._files.'
	DB	0aH, 0aH, 'It is usually not needed to use the zipimport modul'
	DB	'e explicitly; it is', 0aH, 'used by the builtin import mechan'
	DB	'ism for sys.path items that are paths', 0aH, 'to Zip archives'
	DB	'.', 00H
zipimportmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09INHLDGFD@zipimport?$AA@
	DQ	FLAT:zipimport_doc
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	__imp__mktime64:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT mktime
_TEXT	SEGMENT
_Tm$ = 8
mktime	PROC						; COMDAT

; 125  :     return _mktime64(_Tm);
; 126  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__mktime64
mktime	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NIANNMO@zipimporter_traverse?$AA@	; `string'
PUBLIC	??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@ ; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\zipimport.c
pdata	SEGMENT
$pdata$zipimporter_traverse DD imagerel zipimporter_traverse
	DD	imagerel zipimporter_traverse+97
	DD	imagerel $unwind$zipimporter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BF@NIANNMO@zipimporter_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@NIANNMO@zipimporter_traverse?$AA@ DB 'zipimporter_traverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
CONST	SEGMENT
??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@ DB '..\Modules\zipimp'
	DB	'ort.c', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_traverse
_TEXT	SEGMENT
obj$ = 48
visit$ = 56
arg$ = 64
zipimporter_traverse PROC				; COMDAT

; 175  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 176  :     ZipImporter *self = (ZipImporter *)obj;
; 177  :     Py_VISIT(self->files);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@zipimporte
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NIANNMO@zipimporter_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 b1 00 00
	00		 mov	 r8d, 177		; 000000b1H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@zipimporte:
  0003d	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@zipimporte
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@zipimporte
$LN5@zipimporte:

; 178  :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@zipimporte:

; 179  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
zipimporter_traverse ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$zipimporter_dealloc DD imagerel zipimporter_dealloc
	DD	imagerel zipimporter_dealloc+372
	DD	imagerel $unwind$zipimporter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
xdata	ENDS
;	COMDAT zipimporter_dealloc
_TEXT	SEGMENT
self$ = 64
zipimporter_dealloc PROC				; COMDAT

; 183  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 184  :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 185  :     Py_XDECREF(self->archive);

  00012	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00016	48 85 db	 test	 rbx, rbx
  00019	74 65		 je	 SHORT $LN11@zipimporte@2
  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	75 5c		 jne	 SHORT $LN11@zipimporte@2
  00024	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00028	a8 20		 test	 al, 32			; 00000020H
  0002a	75 4c		 jne	 SHORT $LN19@zipimporte@2
  0002c	84 c0		 test	 al, al
  0002e	78 48		 js	 SHORT $LN19@zipimporte@2
  00030	a8 02		 test	 al, 2
  00032	75 4c		 jne	 SHORT $LN11@zipimporte@2
  00034	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00038	75 46		 jne	 SHORT $LN11@zipimporte@2
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00048	4c 8b cb	 mov	 r9, rbx
  0004b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00051	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	85 c0		 test	 eax, eax
  00063	74 07		 je	 SHORT $LN24@zipimporte@2
  00065	e8 00 00 00 00	 call	 _Px_Dealloc
  0006a	eb 14		 jmp	 SHORT $LN11@zipimporte@2
$LN24@zipimporte@2:
  0006c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00070	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00076	eb 08		 jmp	 SHORT $LN11@zipimporte@2
$LN19@zipimporte@2:
  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 Px_DecRef
$LN11@zipimporte@2:

; 186  :     Py_XDECREF(self->prefix);

  00080	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 65		 je	 SHORT $LN7@zipimporte@2
  00089	e8 00 00 00 00	 call	 _Py_PXCTX
  0008e	85 c0		 test	 eax, eax
  00090	75 5c		 jne	 SHORT $LN7@zipimporte@2
  00092	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00096	a8 20		 test	 al, 32			; 00000020H
  00098	75 4c		 jne	 SHORT $LN30@zipimporte@2
  0009a	84 c0		 test	 al, al
  0009c	78 48		 js	 SHORT $LN30@zipimporte@2
  0009e	a8 02		 test	 al, 2
  000a0	75 4c		 jne	 SHORT $LN7@zipimporte@2
  000a2	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a6	75 46		 jne	 SHORT $LN7@zipimporte@2
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b6	4c 8b cb	 mov	 r9, rbx
  000b9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	85 c0		 test	 eax, eax
  000d1	74 07		 je	 SHORT $LN35@zipimporte@2
  000d3	e8 00 00 00 00	 call	 _Px_Dealloc
  000d8	eb 14		 jmp	 SHORT $LN7@zipimporte@2
$LN35@zipimporte@2:
  000da	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000de	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e4	eb 08		 jmp	 SHORT $LN7@zipimporte@2
$LN30@zipimporte@2:
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	e8 00 00 00 00	 call	 Px_DecRef
$LN7@zipimporte@2:

; 187  :     Py_XDECREF(self->files);

  000ee	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  000f2	48 85 db	 test	 rbx, rbx
  000f5	74 65		 je	 SHORT $LN3@zipimporte@2
  000f7	e8 00 00 00 00	 call	 _Py_PXCTX
  000fc	85 c0		 test	 eax, eax
  000fe	75 5c		 jne	 SHORT $LN3@zipimporte@2
  00100	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00104	a8 20		 test	 al, 32			; 00000020H
  00106	75 4c		 jne	 SHORT $LN41@zipimporte@2
  00108	84 c0		 test	 al, al
  0010a	78 48		 js	 SHORT $LN41@zipimporte@2
  0010c	a8 02		 test	 al, 2
  0010e	75 4c		 jne	 SHORT $LN3@zipimporte@2
  00110	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00114	75 46		 jne	 SHORT $LN3@zipimporte@2
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00124	4c 8b cb	 mov	 r9, rbx
  00127	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0012d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00135	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	85 c0		 test	 eax, eax
  0013f	74 07		 je	 SHORT $LN46@zipimporte@2
  00141	e8 00 00 00 00	 call	 _Px_Dealloc
  00146	eb 14		 jmp	 SHORT $LN3@zipimporte@2
$LN46@zipimporte@2:
  00148	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0014c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00152	eb 08		 jmp	 SHORT $LN3@zipimporte@2
$LN41@zipimporte@2:
  00154	48 8b cb	 mov	 rcx, rbx
  00157	e8 00 00 00 00	 call	 Px_DecRef
$LN3@zipimporte@2:

; 188  :     Py_TYPE(self)->tp_free((PyObject *)self);

  0015c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00160	48 8b cf	 mov	 rcx, rdi

; 189  : }

  00163	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00168	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0016c	5f		 pop	 rdi
  0016d	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
zipimporter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@HMJGBKML@?$DMzipimporter?5object?5?$CC?$CFU?$CC?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BO@DEBMKMJK@?$DMzipimporter?5object?5?$CC?$CFU?$CFc?$CFU?$CC?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BL@ILIPANBI@?$DMzipimporter?5object?5?$CC?$DP?$DP?$DP?$CC?$DO?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT ??_C@_0BK@HMJGBKML@?$DMzipimporter?5object?5?$CC?$CFU?$CC?$DO?$AA@
CONST	SEGMENT
??_C@_0BK@HMJGBKML@?$DMzipimporter?5object?5?$CC?$CFU?$CC?$DO?$AA@ DB '<z'
	DB	'ipimporter object "%U">', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DEBMKMJK@?$DMzipimporter?5object?5?$CC?$CFU?$CFc?$CFU?$CC?$DO?$AA@
CONST	SEGMENT
??_C@_0BO@DEBMKMJK@?$DMzipimporter?5object?5?$CC?$CFU?$CFc?$CFU?$CC?$DO?$AA@ DB '<'
	DB	'zipimporter object "%U%c%U">', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ILIPANBI@?$DMzipimporter?5object?5?$CC?$DP?$DP?$DP?$CC?$DO?$AA@
CONST	SEGMENT
??_C@_0BL@ILIPANBI@?$DMzipimporter?5object?5?$CC?$DP?$DP?$DP?$CC?$DO?$AA@ DB '<'
	DB	'zipimporter object "???">', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_repr
_TEXT	SEGMENT
self$ = 8
zipimporter_repr PROC					; COMDAT

; 194  :     if (self->archive == NULL)

  00000	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00004	48 85 d2	 test	 rdx, rdx
  00007	75 0c		 jne	 SHORT $LN4@zipimporte@3

; 195  :         return PyUnicode_FromString("<zipimporter object \"???\">");

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@ILIPANBI@?$DMzipimporter?5object?5?$CC?$DP?$DP?$DP?$CC?$DO?$AA@

; 202  : }

  00010	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN4@zipimporte@3:

; 196  :     else if (self->prefix != NULL && PyUnicode_GET_LENGTH(self->prefix) != 0)

  00015	4c 8b 49 68	 mov	 r9, QWORD PTR [rcx+104]
  00019	4d 85 c9	 test	 r9, r9
  0001c	74 19		 je	 SHORT $LN2@zipimporte@3
  0001e	49 83 79 60 00	 cmp	 QWORD PTR [r9+96], 0
  00023	74 12		 je	 SHORT $LN2@zipimporte@3

; 197  :         return PyUnicode_FromFormat("<zipimporter object \"%U%c%U\">",
; 198  :                                     self->archive, SEP, self->prefix);

  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DEBMKMJK@?$DMzipimporter?5object?5?$CC?$CFU?$CFc?$CFU?$CC?$DO?$AA@
  0002c	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH

; 202  : }

  00032	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN2@zipimporte@3:

; 199  :     else
; 200  :         return PyUnicode_FromFormat("<zipimporter object \"%U\">",
; 201  :                                     self->archive);

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@HMJGBKML@?$DMzipimporter?5object?5?$CC?$CFU?$CC?$DO?$AA@

; 202  : }

  0003e	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
zipimporter_repr ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Substring:PROC
EXTRN	PyUnicode_FindChar:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_subname DD imagerel get_subname
	DD	imagerel get_subname+35
	DD	imagerel $unwind$get_subname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_subname DD imagerel get_subname+35
	DD	imagerel get_subname+146
	DD	imagerel $chain$0$get_subname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_subname DD imagerel get_subname+146
	DD	imagerel get_subname+171
	DD	imagerel $chain$2$get_subname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_subname DD 020021H
	DD	087400H
	DD	imagerel get_subname
	DD	imagerel get_subname+35
	DD	imagerel $unwind$get_subname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_subname DD 020521H
	DD	087405H
	DD	imagerel get_subname
	DD	imagerel get_subname+35
	DD	imagerel $unwind$get_subname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_subname DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
xdata	ENDS
;	COMDAT get_subname
_TEXT	SEGMENT
fullname$ = 64
get_subname PROC					; COMDAT

; 207  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 208  :     Py_ssize_t len, dot;
; 209  :     if (PyUnicode_READY(fullname) < 0)

  00006	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 11		 jne	 SHORT $LN3@get_subnam
  0000f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00014	85 c0		 test	 eax, eax
  00016	79 08		 jns	 SHORT $LN3@get_subnam

; 210  :         return NULL;

  00018	33 c0		 xor	 eax, eax

; 218  : }

  0001a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
$LN3@get_subnam:

; 211  :     len = PyUnicode_GET_LENGTH(fullname);
; 212  :     dot = PyUnicode_FindChar(fullname, '.', 0, len, -1);

  00020	45 33 c0	 xor	 r8d, r8d
  00023	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00028	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]
  0002c	41 8d 50 2e	 lea	 edx, QWORD PTR [r8+46]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	4c 8b cf	 mov	 r9, rdi
  00036	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0003e	e8 00 00 00 00	 call	 PyUnicode_FindChar

; 213  :     if (dot == -1) {

  00043	48 83 f8 ff	 cmp	 rax, -1
  00047	75 49		 jne	 SHORT $LN2@get_subnam

; 214  :         Py_INCREF(fullname);

  00049	e8 00 00 00 00	 call	 _Py_PXCTX
  0004e	85 c0		 test	 eax, eax
  00050	75 32		 jne	 SHORT $LN9@get_subnam
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00060	4c 8b cb	 mov	 r9, rbx
  00063	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00069	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00071	e8 00 00 00 00	 call	 _PyParallel_Guard
  00076	85 c0		 test	 eax, eax
  00078	75 06		 jne	 SHORT $LN8@get_subnam
  0007a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0007e	74 04		 je	 SHORT $LN9@get_subnam
$LN8@get_subnam:
  00080	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@get_subnam:

; 215  :         return fullname;

  00084	48 8b c3	 mov	 rax, rbx
  00087	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 218  : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
$LN2@get_subnam:

; 216  :     } else
; 217  :         return PyUnicode_Substring(fullname, dot+1, len);

  00092	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  00096	4c 8b c7	 mov	 r8, rdi
  00099	48 8b cb	 mov	 rcx, rbx
  0009c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 218  : }

  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5b		 pop	 rbx
  000a6	e9 00 00 00 00	 jmp	 PyUnicode_Substring
get_subname ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromKindAndData:PROC
EXTRN	PyMem_Free:PROC
EXTRN	PyUnicode_AsUCS4:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_filename DD imagerel make_filename
	DD	imagerel make_filename+238
	DD	imagerel $unwind$make_filename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_filename DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT make_filename
_TEXT	SEGMENT
prefix$ = 48
name$ = 56
make_filename PROC					; COMDAT

; 227  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 228  :     PyObject *pathobj;
; 229  :     Py_UCS4 *p, *buf;
; 230  :     Py_ssize_t len;
; 231  : 
; 232  :     len = PyUnicode_GET_LENGTH(prefix) + PyUnicode_GET_LENGTH(name) + 1;

  00014	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00018	4c 8b 42 60	 mov	 r8, QWORD PTR [rdx+96]
  0001c	48 8b d9	 mov	 rbx, rcx
  0001f	49 8d 74 00 01	 lea	 rsi, QWORD PTR [r8+rax+1]
  00024	48 8b ea	 mov	 rbp, rdx

; 233  :     p = buf = PyMem_Malloc(sizeof(Py_UCS4) * len);

  00027	48 8d 0c b5 00
	00 00 00	 lea	 rcx, QWORD PTR [rsi*4]
  0002f	e8 00 00 00 00	 call	 PyMem_Malloc
  00034	48 8b f8	 mov	 rdi, rax

; 234  :     if (buf == NULL) {

  00037	48 85 c0	 test	 rax, rax
  0003a	75 0c		 jne	 SHORT $LN7@make_filen

; 235  :         PyErr_NoMemory();

  0003c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 236  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 91 00 00 00	 jmp	 $LN8@make_filen
$LN7@make_filen:

; 237  :     }
; 238  : 
; 239  :     if (!PyUnicode_AsUCS4(prefix, p, len, 0)) {

  00048	45 33 c9	 xor	 r9d, r9d
  0004b	4c 8b c6	 mov	 r8, rsi
  0004e	48 8b d0	 mov	 rdx, rax
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 PyUnicode_AsUCS4
  00059	48 85 c0	 test	 rax, rax
  0005c	75 0c		 jne	 SHORT $LN6@make_filen
$LN12@make_filen:

; 240  :         PyMem_Free(buf);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	e8 00 00 00 00	 call	 PyMem_Free

; 241  :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	eb 6f		 jmp	 SHORT $LN8@make_filen
$LN6@make_filen:

; 242  :     }
; 243  :     p += PyUnicode_GET_LENGTH(prefix);

  0006a	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 244  :     len -= PyUnicode_GET_LENGTH(prefix);
; 245  :     if (!PyUnicode_AsUCS4(name, p, len, 1)) {

  0006e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00074	48 8b cd	 mov	 rcx, rbp
  00077	48 8d 1c 87	 lea	 rbx, QWORD PTR [rdi+rax*4]
  0007b	48 2b f0	 sub	 rsi, rax
  0007e	48 8b d3	 mov	 rdx, rbx
  00081	4c 8b c6	 mov	 r8, rsi
  00084	e8 00 00 00 00	 call	 PyUnicode_AsUCS4
  00089	48 85 c0	 test	 rax, rax

; 246  :         PyMem_Free(buf);
; 247  :         return NULL;

  0008c	74 d0		 je	 SHORT $LN12@make_filen

; 248  :     }
; 249  :     for (; *p; p++) {

  0008e	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  00091	74 21		 je	 SHORT $LN2@make_filen
  00093	b9 5c 00 00 00	 mov	 ecx, 92			; 0000005cH
  00098	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@make_filen:

; 250  :         if (*p == '.')

  000a0	8b 03		 mov	 eax, DWORD PTR [rbx]
  000a2	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000a5	0f 44 c1	 cmove	 eax, ecx
  000a8	48 83 c3 04	 add	 rbx, 4
  000ac	89 43 fc	 mov	 DWORD PTR [rbx-4], eax
  000af	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  000b2	75 ec		 jne	 SHORT $LL4@make_filen
$LN2@make_filen:

; 251  :             *p = SEP;
; 252  :     }
; 253  :     pathobj = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
; 254  :                                         buf, p-buf);

  000b4	48 2b df	 sub	 rbx, rdi
  000b7	48 8b d7	 mov	 rdx, rdi
  000ba	b9 04 00 00 00	 mov	 ecx, 4
  000bf	48 c1 fb 02	 sar	 rbx, 2
  000c3	4c 8b c3	 mov	 r8, rbx
  000c6	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData

; 255  :     PyMem_Free(buf);

  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	48 8b d8	 mov	 rbx, rax
  000d1	e8 00 00 00 00	 call	 PyMem_Free

; 256  :     return pathobj;

  000d6	48 8b c3	 mov	 rax, rbx
$LN8@make_filen:

; 257  : }

  000d9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000de	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ec	5f		 pop	 rdi
  000ed	c3		 ret	 0
make_filename ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CGPBEMHF@?$CFU?$CFU?$CFc?$AA@		; `string'
EXTRN	PyDict_Contains:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_is_directory DD imagerel check_is_directory
	DD	imagerel check_is_directory+88
	DD	imagerel $unwind$check_is_directory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_is_directory DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_06CGPBEMHF@?$CFU?$CFU?$CFc?$AA@
CONST	SEGMENT
??_C@_06CGPBEMHF@?$CFU?$CFU?$CFc?$AA@ DB '%U%U%c', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_is_directory
_TEXT	SEGMENT
self$ = 48
prefix$ = 56
path$ = 64
check_is_directory PROC					; COMDAT

; 273  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 274  :     PyObject *dirpath;
; 275  :     int res;
; 276  : 
; 277  :     /* See if this is a "directory". If so, it's eligible to be part
; 278  :        of a namespace package. We test by seeing if the name, with an
; 279  :        appended path separator, exists. */
; 280  :     dirpath = PyUnicode_FromFormat("%U%U%c", prefix, path, SEP);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CGPBEMHF@?$CFU?$CFU?$CFc?$AA@
  00014	41 b9 5c 00 00
	00		 mov	 r9d, 92			; 0000005cH
  0001a	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0001f	48 8b f8	 mov	 rdi, rax

; 281  :     if (dirpath == NULL)

  00022	48 85 c0	 test	 rax, rax
  00025	75 0e		 jne	 SHORT $LN1@check_is_d

; 282  :         return -1;

  00027	83 c8 ff	 or	 eax, -1

; 287  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN1@check_is_d:

; 283  :     /* If dirpath is present in self->files, we have a directory. */
; 284  :     res = PyDict_Contains(self->files, dirpath);

  00035	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00039	48 8b d0	 mov	 rdx, rax
  0003c	e8 00 00 00 00	 call	 PyDict_Contains

; 285  :     Py_DECREF(dirpath);

  00041	48 8b cf	 mov	 rcx, rdi
  00044	8b d8		 mov	 ebx, eax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 286  :     return res;

  0004b	8b c3		 mov	 eax, ebx

; 287  : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
check_is_directory ENDP
_TEXT	ENDS
PUBLIC	??_C@_04PGLLPJDI@?$CFU?$CFs?$AA@		; `string'
EXTRN	PyDict_GetItem:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_module_info DD imagerel get_module_info
	DD	imagerel get_module_info+50
	DD	imagerel $unwind$get_module_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_module_info DD imagerel get_module_info+50
	DD	imagerel get_module_info+95
	DD	imagerel $chain$0$get_module_info
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$get_module_info DD imagerel get_module_info+95
	DD	imagerel get_module_info+362
	DD	imagerel $chain$4$get_module_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$get_module_info DD 061121H
	DD	0a7411H
	DD	08540cH
	DD	096400H
	DD	imagerel get_module_info
	DD	imagerel get_module_info+50
	DD	imagerel $unwind$get_module_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_module_info DD 020521H
	DD	096405H
	DD	imagerel get_module_info
	DD	imagerel get_module_info+50
	DD	imagerel $unwind$get_module_info
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_module_info DD 040b01H
	DD	0b340bH
	DD	0c007520bH
xdata	ENDS
;	COMDAT ??_C@_04PGLLPJDI@?$CFU?$CFs?$AA@
CONST	SEGMENT
??_C@_04PGLLPJDI@?$CFU?$CFs?$AA@ DB '%U%s', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
CONST	ENDS
;	COMDAT get_module_info
_TEXT	SEGMENT
self$ = 64
fullname$ = 72
get_module_info PROC					; COMDAT

; 292  : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	41 54		 push	 r12
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000b	4c 8b e1	 mov	 r12, rcx

; 293  :     PyObject *subname;
; 294  :     PyObject *path, *fullpath, *item;
; 295  :     struct st_zip_searchorder *zso;
; 296  : 
; 297  :     subname = get_subname(fullname);

  0000e	48 8b ca	 mov	 rcx, rdx
  00011	e8 00 00 00 00	 call	 get_subname
  00016	48 8b d8	 mov	 rbx, rax

; 298  :     if (subname == NULL)

  00019	48 85 c0	 test	 rax, rax
  0001c	75 0c		 jne	 SHORT $LN9@get_module

; 324  : }

  0001e	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00023	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00027	41 5c		 pop	 r12
  00029	c3		 ret	 0
$LN9@get_module:

; 299  :         return MI_ERROR;
; 300  : 
; 301  :     path = make_filename(self->prefix, subname);

  0002a	49 8b 4c 24 68	 mov	 rcx, QWORD PTR [r12+104]
  0002f	48 8b d0	 mov	 rdx, rax
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00037	e8 00 00 00 00	 call	 make_filename

; 302  :     Py_DECREF(subname);

  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	48 8b f0	 mov	 rsi, rax
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 303  :     if (path == NULL)

  00047	48 85 f6	 test	 rsi, rsi
  0004a	75 13		 jne	 SHORT $LN8@get_module

; 304  :         return MI_ERROR;

  0004c	33 c0		 xor	 eax, eax
  0004e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 324  : }

  00053	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	41 5c		 pop	 r12
  0005e	c3		 ret	 0
$LN8@get_module:

; 305  : 
; 306  :     for (zso = zip_searchorder; *zso->suffix; zso++) {

  0005f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR zip_searchorder, 0
  00066	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0006b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00070	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:zip_searchorder
  00077	74 4a		 je	 SHORT $LN5@get_module
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@get_module:

; 307  :         fullpath = PyUnicode_FromFormat("%U%s", path, zso->suffix);

  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04PGLLPJDI@?$CFU?$CFs?$AA@
  00087	4c 8b c7	 mov	 r8, rdi
  0008a	48 8b d6	 mov	 rdx, rsi
  0008d	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00092	48 8b e8	 mov	 rbp, rax

; 308  :         if (fullpath == NULL) {

  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 8c 00 00
	00		 je	 $LN24@get_module

; 311  :         }
; 312  :         item = PyDict_GetItem(self->files, fullpath);

  0009e	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	e8 00 00 00 00	 call	 PyDict_GetItem

; 313  :         Py_DECREF(fullpath);

  000ab	48 8b cd	 mov	 rcx, rbp
  000ae	48 8b d8	 mov	 rbx, rax
  000b1	e8 00 00 00 00	 call	 _Py_DecRef

; 314  :         if (item != NULL) {

  000b6	48 85 db	 test	 rbx, rbx
  000b9	75 59		 jne	 SHORT $LN25@get_module

; 305  : 
; 306  :     for (zso = zip_searchorder; *zso->suffix; zso++) {

  000bb	48 83 c7 14	 add	 rdi, 20
  000bf	38 1f		 cmp	 BYTE PTR [rdi], bl
  000c1	75 bd		 jne	 SHORT $LL7@get_module
$LN5@get_module:

; 320  :         }
; 321  :     }
; 322  :     Py_DECREF(path);

  000c3	e8 00 00 00 00	 call	 _Py_PXCTX
  000c8	85 c0		 test	 eax, eax
  000ca	75 7e		 jne	 SHORT $LN22@get_module
  000cc	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000d0	a8 20		 test	 al, 32			; 00000020H
  000d2	75 6e		 jne	 SHORT $LN16@get_module
  000d4	84 c0		 test	 al, al
  000d6	78 6a		 js	 SHORT $LN16@get_module
  000d8	a8 02		 test	 al, 2
  000da	75 6e		 jne	 SHORT $LN22@get_module
  000dc	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  000e0	75 68		 jne	 SHORT $LN22@get_module
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f0	4c 8b ce	 mov	 r9, rsi
  000f3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00101	e8 00 00 00 00	 call	 _PyParallel_Guard
  00106	48 8b ce	 mov	 rcx, rsi
  00109	85 c0		 test	 eax, eax
  0010b	74 29		 je	 SHORT $LN21@get_module
  0010d	e8 00 00 00 00	 call	 _Px_Dealloc
  00112	eb 36		 jmp	 SHORT $LN22@get_module
$LN25@get_module:

; 315  :             Py_DECREF(path);

  00114	48 8b ce	 mov	 rcx, rsi
  00117	e8 00 00 00 00	 call	 _Py_DecRef

; 316  :             if (zso->type & IS_PACKAGE)

  0011c	0f be 47 10	 movsx	 eax, BYTE PTR [rdi+16]
  00120	83 e0 02	 and	 eax, 2
  00123	83 c8 04	 or	 eax, 4
  00126	d1 e8		 shr	 eax, 1

; 317  :                 return MI_PACKAGE;
; 318  :             else
; 319  :                 return MI_MODULE;

  00128	eb 25		 jmp	 SHORT $LN29@get_module
$LN24@get_module:

; 309  :             Py_DECREF(path);

  0012a	48 8b ce	 mov	 rcx, rsi
  0012d	e8 00 00 00 00	 call	 _Py_DecRef

; 310  :             return MI_ERROR;

  00132	33 c0		 xor	 eax, eax
  00134	eb 19		 jmp	 SHORT $LN29@get_module

; 320  :         }
; 321  :     }
; 322  :     Py_DECREF(path);

$LN21@get_module:
  00136	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0013a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00140	eb 08		 jmp	 SHORT $LN22@get_module
$LN16@get_module:
  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 Px_DecRef
$LN22@get_module:

; 323  :     return MI_NOT_FOUND;

  0014a	b8 01 00 00 00	 mov	 eax, 1
$LN29@get_module:
  0014f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00154	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00159	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 324  : }

  0015e	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00163	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00167	41 5c		 pop	 r12
  00169	c3		 ret	 0
get_module_info ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NDALMICO@?$CFU?$CFc?$CFU?$CFU?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$find_loader DD imagerel find_loader
	DD	imagerel find_loader+201
	DD	imagerel $unwind$find_loader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_loader DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_08NDALMICO@?$CFU?$CFc?$CFU?$CFU?$AA@
CONST	SEGMENT
??_C@_08NDALMICO@?$CFU?$CFc?$CFU?$CFU?$AA@ DB '%U%c%U%U', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT find_loader
_TEXT	SEGMENT
self$ = 64
fullname$ = 72
namespace_portion$ = 80
find_loader PROC					; COMDAT

; 341  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 342  :     enum zi_module_info mi;
; 343  : 
; 344  :     *namespace_portion = NULL;

  00018	49 c7 00 00 00
	00 00		 mov	 QWORD PTR [r8], 0

; 345  : 
; 346  :     mi = get_module_info(self, fullname);

  0001f	e8 00 00 00 00	 call	 get_module_info

; 347  :     if (mi == MI_ERROR)

  00024	85 c0		 test	 eax, eax
  00026	75 10		 jne	 SHORT $LN5@find_loade

; 367  :     }
; 368  :     /* This is a module or package. */
; 369  :     return FL_MODULE_FOUND;
; 370  : }

  00028	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN5@find_loade:

; 348  :         return FL_ERROR;
; 349  :     if (mi == MI_NOT_FOUND) {

  00038	83 f8 01	 cmp	 eax, 1
  0003b	75 77		 jne	 SHORT $LN4@find_loade

; 350  :         /* Not a module or regular package. See if this is a directory, and
; 351  :            therefore possibly a portion of a namespace package. */
; 352  :         int is_dir = check_is_directory(self, self->prefix, fullname);

  0003d	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  00041	4c 8b c7	 mov	 r8, rdi
  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 check_is_directory

; 353  :         if (is_dir < 0)

  0004c	85 c0		 test	 eax, eax
  0004e	79 13		 jns	 SHORT $LN8@find_loade

; 354  :             return -1;

  00050	83 c8 ff	 or	 eax, -1

; 367  :     }
; 368  :     /* This is a module or package. */
; 369  :     return FL_MODULE_FOUND;
; 370  : }

  00053	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00058	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN8@find_loade:

; 355  :         if (is_dir) {

  00063	74 3a		 je	 SHORT $LN2@find_loade

; 356  :             /* This is possibly a portion of a namespace
; 357  :                package. Return the string representing its path,
; 358  :                without a trailing separator. */
; 359  :             *namespace_portion = PyUnicode_FromFormat("%U%c%U%U",
; 360  :                                                       self->archive, SEP,
; 361  :                                                       self->prefix, fullname);

  00065	4c 8b 4b 68	 mov	 r9, QWORD PTR [rbx+104]
  00069	48 8b 53 60	 mov	 rdx, QWORD PTR [rbx+96]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NDALMICO@?$CFU?$CFc?$CFU?$CFU?$AA@
  00074	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  0007a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0007f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00084	48 89 06	 mov	 QWORD PTR [rsi], rax

; 362  :             if (*namespace_portion == NULL)

  00087	48 f7 d8	 neg	 rax
  0008a	1b c0		 sbb	 eax, eax
  0008c	83 e0 03	 and	 eax, 3

; 367  :     }
; 368  :     /* This is a module or package. */
; 369  :     return FL_MODULE_FOUND;
; 370  : }

  0008f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00094	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
$LN2@find_loade:

; 363  :                 return FL_ERROR;
; 364  :             return FL_NS_FOUND;
; 365  :         }
; 366  :         return FL_NOT_FOUND;

  0009f	b8 01 00 00 00	 mov	 eax, 1

; 367  :     }
; 368  :     /* This is a module or package. */
; 369  :     return FL_MODULE_FOUND;
; 370  : }

  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
$LN4@find_loade:
  000b4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000be	b8 02 00 00 00	 mov	 eax, 2
  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
find_loader ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@FOJHLGJM@U?$HMO?3zipimporter?4find_module?$AA@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$zipimporter_find_module DD imagerel zipimporter_find_module
	DD	imagerel zipimporter_find_module+209
	DD	imagerel $unwind$zipimporter_find_module
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_find_module DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BM@FOJHLGJM@U?$HMO?3zipimporter?4find_module?$AA@
CONST	SEGMENT
??_C@_0BM@FOJHLGJM@U?$HMO?3zipimporter?4find_module?$AA@ DB 'U|O:zipimpor'
	DB	'ter.find_module', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
CONST	ENDS
;	COMDAT zipimporter_find_module
_TEXT	SEGMENT
namespace_portion$ = 64
obj$ = 64
args$ = 72
path$ = 80
fullname$ = 88
zipimporter_find_module PROC				; COMDAT

; 377  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 378  :     ZipImporter *self = (ZipImporter *)obj;
; 379  :     PyObject *path = NULL;

  00010	33 db		 xor	 ebx, ebx

; 380  :     PyObject *fullname;
; 381  :     PyObject *namespace_portion = NULL;
; 382  :     PyObject *result = NULL;
; 383  : 
; 384  :     if (!PyArg_ParseTuple(args, "U|O:zipimporter.find_module", &fullname, &path))

  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@FOJHLGJM@U?$HMO?3zipimporter?4find_module?$AA@
  00019	4c 8d 4c 24 50	 lea	 r9, QWORD PTR path$[rsp]
  0001e	4c 8d 44 24 58	 lea	 r8, QWORD PTR fullname$[rsp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	48 89 5c 24 50	 mov	 QWORD PTR path$[rsp], rbx
  0002b	48 89 5c 24 40	 mov	 QWORD PTR namespace_portion$[rsp], rbx
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax

; 385  :         return NULL;

  00037	0f 84 87 00 00
	00		 je	 $LN4@zipimporte@4

; 386  : 
; 387  :     switch (find_loader(self, fullname, &namespace_portion)) {

  0003d	48 8b 54 24 58	 mov	 rdx, QWORD PTR fullname$[rsp]
  00042	4c 8d 44 24 40	 lea	 r8, QWORD PTR namespace_portion$[rsp]
  00047	48 8b cf	 mov	 rcx, rdi
  0004a	e8 00 00 00 00	 call	 find_loader
  0004f	44 8b d8	 mov	 r11d, eax
  00052	85 c0		 test	 eax, eax
  00054	74 6e		 je	 SHORT $LN4@zipimporte@4
  00056	41 ff cb	 dec	 r11d
  00059	74 14		 je	 SHORT $LN2@zipimporte@4
  0005b	41 ff cb	 dec	 r11d
  0005e	74 5f		 je	 SHORT $LN1@zipimporte@4
  00060	41 ff cb	 dec	 r11d
  00063	75 11		 jne	 SHORT $LN5@zipimporte@4

; 390  :     case FL_NS_FOUND:
; 391  :         /* A namespace portion is not allowed via find_module, so return None. */
; 392  :         Py_DECREF(namespace_portion);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR namespace_portion$[rsp]
  0006a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@zipimporte@4:

; 393  :         /* FALL THROUGH */
; 394  :     case FL_NOT_FOUND:
; 395  :         result = Py_None;

  0006f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
$LN5@zipimporte@4:

; 400  :     }
; 401  :     Py_INCREF(result);

  00076	e8 00 00 00 00	 call	 _Py_PXCTX
  0007b	85 c0		 test	 eax, eax
  0007d	75 32		 jne	 SHORT $LN11@zipimporte@4
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008d	4c 8b cb	 mov	 r9, rbx
  00090	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00096	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009e	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a3	85 c0		 test	 eax, eax
  000a5	75 06		 jne	 SHORT $LN10@zipimporte@4
  000a7	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ab	74 04		 je	 SHORT $LN11@zipimporte@4
$LN10@zipimporte@4:
  000ad	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@zipimporte@4:

; 402  :     return result;

  000b1	48 8b c3	 mov	 rax, rbx

; 403  : }

  000b4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
$LN1@zipimporte@4:

; 396  :         break;
; 397  :     case FL_MODULE_FOUND:
; 398  :         result = (PyObject *)self;

  000bf	48 8b df	 mov	 rbx, rdi

; 399  :         break;

  000c2	eb b2		 jmp	 SHORT $LN5@zipimporte@4
$LN4@zipimporte@4:

; 388  :     case FL_ERROR:
; 389  :         return NULL;

  000c4	33 c0		 xor	 eax, eax

; 403  : }

  000c6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
zipimporter_find_module ENDP
_TEXT	ENDS
PUBLIC	??_C@_03HCDAIKMA@O?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_04ILKBKGDN@O?$FLO?$FN?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_find_loader DD imagerel zipimporter_find_loader
	DD	imagerel zipimporter_find_loader+207
	DD	imagerel $unwind$zipimporter_find_loader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_find_loader DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_03HCDAIKMA@O?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_03HCDAIKMA@O?$FL?$FN?$AA@ DB 'O[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04ILKBKGDN@O?$FLO?$FN?$AA@
CONST	SEGMENT
??_C@_04ILKBKGDN@O?$FLO?$FN?$AA@ DB 'O[O]', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_find_loader
_TEXT	SEGMENT
namespace_portion$ = 48
obj$ = 48
args$ = 56
path$ = 64
fullname$ = 72
zipimporter_find_loader PROC				; COMDAT

; 413  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 414  :     ZipImporter *self = (ZipImporter *)obj;
; 415  :     PyObject *path = NULL;

  00010	33 db		 xor	 ebx, ebx

; 416  :     PyObject *fullname;
; 417  :     PyObject *result = NULL;
; 418  :     PyObject *namespace_portion = NULL;
; 419  : 
; 420  :     if (!PyArg_ParseTuple(args, "U|O:zipimporter.find_module", &fullname, &path))

  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@FOJHLGJM@U?$HMO?3zipimporter?4find_module?$AA@
  00019	4c 8d 4c 24 40	 lea	 r9, QWORD PTR path$[rsp]
  0001e	4c 8d 44 24 48	 lea	 r8, QWORD PTR fullname$[rsp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	48 89 5c 24 40	 mov	 QWORD PTR path$[rsp], rbx
  0002b	48 89 5c 24 30	 mov	 QWORD PTR namespace_portion$[rsp], rbx
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax

; 421  :         return NULL;

  00037	0f 84 85 00 00
	00		 je	 $LN4@zipimporte@5

; 422  : 
; 423  :     switch (find_loader(self, fullname, &namespace_portion)) {

  0003d	48 8b 54 24 48	 mov	 rdx, QWORD PTR fullname$[rsp]
  00042	4c 8d 44 24 30	 lea	 r8, QWORD PTR namespace_portion$[rsp]
  00047	48 8b cf	 mov	 rcx, rdi
  0004a	e8 00 00 00 00	 call	 find_loader
  0004f	44 8b d8	 mov	 r11d, eax
  00052	85 c0		 test	 eax, eax
  00054	74 6c		 je	 SHORT $LN4@zipimporte@5
  00056	41 ff cb	 dec	 r11d
  00059	74 43		 je	 SHORT $LN3@zipimporte@5
  0005b	41 ff cb	 dec	 r11d
  0005e	74 39		 je	 SHORT $LN2@zipimporte@5
  00060	41 ff cb	 dec	 r11d
  00063	75 4f		 jne	 SHORT $LN5@zipimporte@5

; 432  :     case FL_NS_FOUND:         /* Return (None, [namespace_portion]) */
; 433  :         result = Py_BuildValue("O[O]", Py_None, namespace_portion);

  00065	48 8b 7c 24 30	 mov	 rdi, QWORD PTR namespace_portion$[rsp]
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04ILKBKGDN@O?$FLO?$FN?$AA@
  00078	4c 8b c7	 mov	 r8, rdi
  0007b	e8 00 00 00 00	 call	 Py_BuildValue

; 434  :         Py_DECREF(namespace_portion);

  00080	48 8b cf	 mov	 rcx, rdi
  00083	48 8b d8	 mov	 rbx, rax
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 435  :         return result;

  0008b	48 8b c3	 mov	 rax, rbx

; 438  : }

  0008e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
$LN2@zipimporte@5:

; 428  :         break;
; 429  :     case FL_MODULE_FOUND:     /* Return (self, []) */
; 430  :         result = Py_BuildValue("O[]", self);

  00099	48 8b d7	 mov	 rdx, rdi

; 431  :         break;

  0009c	eb 07		 jmp	 SHORT $LN10@zipimporte@5
$LN3@zipimporte@5:

; 426  :     case FL_NOT_FOUND:        /* Not found, return (None, []) */
; 427  :         result = Py_BuildValue("O[]", Py_None);

  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
$LN10@zipimporte@5:
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03HCDAIKMA@O?$FL?$FN?$AA@
  000ac	e8 00 00 00 00	 call	 Py_BuildValue
  000b1	48 8b d8	 mov	 rbx, rax
$LN5@zipimporte@5:

; 436  :     }
; 437  :     return result;

  000b4	48 8b c3	 mov	 rax, rbx

; 438  : }

  000b7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
$LN4@zipimporte@5:

; 424  :     case FL_ERROR:
; 425  :         return NULL;

  000c2	33 c0		 xor	 eax, eax

; 438  : }

  000c4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
zipimporter_find_loader ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BJ@KCAFKFKG@U?3zipimporter?4is_package?$AA@ ; `string'
EXTRN	PyBool_FromLong:PROC
EXTRN	PyErr_Format:PROC
_BSS	SEGMENT
	ALIGN	8

ZipImportError DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_is_package DD imagerel zipimporter_is_package
	DD	imagerel zipimporter_is_package+109
	DD	imagerel $unwind$zipimporter_is_package
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_is_package DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@ DB 'can''t find modul'
	DB	'e %R', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KCAFKFKG@U?3zipimporter?4is_package?$AA@
CONST	SEGMENT
??_C@_0BJ@KCAFKFKG@U?3zipimporter?4is_package?$AA@ DB 'U:zipimporter.is_p'
	DB	'ackage', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_is_package
_TEXT	SEGMENT
fullname$ = 48
obj$ = 48
args$ = 56
zipimporter_is_package PROC				; COMDAT

; 532  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 533  :     ZipImporter *self = (ZipImporter *)obj;
; 534  :     PyObject *fullname;
; 535  :     enum zi_module_info mi;
; 536  : 
; 537  :     if (!PyArg_ParseTuple(args, "U:zipimporter.is_package",
; 538  :                           &fullname))

  0000c	4c 8d 44 24 30	 lea	 r8, QWORD PTR fullname$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KCAFKFKG@U?3zipimporter?4is_package?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax

; 539  :         return NULL;

  00022	74 2e		 je	 SHORT $LN6@zipimporte@6

; 540  : 
; 541  :     mi = get_module_info(self, fullname);

  00024	48 8b 54 24 30	 mov	 rdx, QWORD PTR fullname$[rsp]
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 get_module_info

; 542  :     if (mi == MI_ERROR)

  00031	85 c0		 test	 eax, eax

; 543  :         return NULL;

  00033	74 1d		 je	 SHORT $LN6@zipimporte@6

; 544  :     if (mi == MI_NOT_FOUND) {

  00035	83 f8 01	 cmp	 eax, 1
  00038	75 20		 jne	 SHORT $LN1@zipimporte@6

; 545  :         PyErr_Format(ZipImportError, "can't find module %R", fullname);

  0003a	4c 8b 44 24 30	 mov	 r8, QWORD PTR fullname$[rsp]
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@
  0004d	e8 00 00 00 00	 call	 PyErr_Format
$LN6@zipimporte@6:

; 546  :         return NULL;

  00052	33 c0		 xor	 eax, eax

; 549  : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN1@zipimporte@6:

; 547  :     }
; 548  :     return PyBool_FromLong(mi == MI_PACKAGE);

  0005a	33 c9		 xor	 ecx, ecx
  0005c	83 f8 03	 cmp	 eax, 3
  0005f	0f 94 c1	 sete	 cl
  00062	e8 00 00 00 00	 call	 PyBool_FromLong

; 549  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
zipimporter_is_package ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT get_long
_TEXT	SEGMENT
buf$ = 8
get_long PROC						; COMDAT

; 819  :     long x;
; 820  :     x =  buf[0];
; 821  :     x |= (long)buf[1] <<  8;
; 822  :     x |= (long)buf[2] << 16;
; 823  :     x |= (long)buf[3] << 24;
; 824  : #if SIZEOF_LONG > 4
; 825  :     /* Sign extension for 64-bit machines */
; 826  :     x |= -(x & 0x80000000L);
; 827  : #endif
; 828  :     return x;

  00000	0f b6 51 02	 movzx	 edx, BYTE PTR [rcx+2]
  00004	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  00008	c1 e0 08	 shl	 eax, 8
  0000b	0b c2		 or	 eax, edx
  0000d	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  00011	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00014	c1 e0 08	 shl	 eax, 8
  00017	0b c2		 or	 eax, edx
  00019	c1 e0 08	 shl	 eax, 8
  0001c	0b c1		 or	 eax, ecx

; 829  : }

  0001e	c3		 ret	 0
get_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DAGBHPLA@?$CD?5zipimport?3?5found?5?$CFld?5names?5in?5@ ; `string'
PUBLIC	??_C@_0FG@JDPOMHML@bootstrap?5issue?3?5python?$CFi?$CFi?4zip?5@ ; `string'
PUBLIC	??_C@_0P@MKDHMPFK@read_directory?$AA@		; `string'
PUBLIC	??_C@_08GIJEMJIJ@Nhllnhhl?$AA@			; `string'
PUBLIC	??_C@_06HKKNHKHN@?$CFU?$CFc?$CFU?$AA@		; `string'
PUBLIC	??_C@_05PAOMFHGM@cp437?$AA@			; `string'
PUBLIC	??_C@_05OJENGABA@ascii?$AA@			; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_0BD@MDJLLLPP@not?5a?5Zip?5file?3?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BI@PKKLABEO@can?8t?5open?5Zip?5file?3?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
EXTRN	PySys_FormatStderr:PROC
EXTRN	Py_VerboseFlag:DWORD
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	PyDict_SetItem:PROC
EXTRN	PyUnicode_Decode:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	__imp_getc:PROC
EXTRN	PyMarshal_ReadShortFromFile:PROC
EXTRN	PyMarshal_ReadLongFromFile:PROC
EXTRN	PyDict_New:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fseek:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	_Py_fopen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_directory DD imagerel read_directory
	DD	imagerel read_directory+151
	DD	imagerel $unwind$read_directory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$read_directory DD imagerel read_directory+151
	DD	imagerel read_directory+290
	DD	imagerel $chain$0$read_directory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$read_directory DD imagerel read_directory+290
	DD	imagerel read_directory+1230
	DD	imagerel $chain$4$read_directory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$read_directory DD imagerel read_directory+1230
	DD	imagerel read_directory+1250
	DD	imagerel $chain$5$read_directory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$read_directory DD imagerel read_directory+1250
	DD	imagerel read_directory+1287
	DD	imagerel $chain$7$read_directory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$read_directory DD 0a0021H
	DD	034f400H
	DD	035d400H
	DD	036c400H
	DD	0375400H
	DD	03c3400H
	DD	imagerel read_directory
	DD	imagerel read_directory+151
	DD	imagerel $unwind$read_directory
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$read_directory DD 021H
	DD	imagerel read_directory+151
	DD	imagerel read_directory+290
	DD	imagerel $chain$0$read_directory
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$read_directory DD 082821H
	DD	034f428H
	DD	035d420H
	DD	036c410H
	DD	0375408H
	DD	imagerel read_directory+151
	DD	imagerel read_directory+290
	DD	imagerel $chain$0$read_directory
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$read_directory DD 020821H
	DD	03c3408H
	DD	imagerel read_directory
	DD	imagerel read_directory+151
	DD	imagerel $unwind$read_directory
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_directory DD 050c01H
	DD	038010cH
	DD	07003e005H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_0CE@DAGBHPLA@?$CD?5zipimport?3?5found?5?$CFld?5names?5in?5@
CONST	SEGMENT
??_C@_0CE@DAGBHPLA@?$CD?5zipimport?3?5found?5?$CFld?5names?5in?5@ DB '# z'
	DB	'ipimport: found %ld names in %R', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@JDPOMHML@bootstrap?5issue?3?5python?$CFi?$CFi?4zip?5@
CONST	SEGMENT
??_C@_0FG@JDPOMHML@bootstrap?5issue?3?5python?$CFi?$CFi?4zip?5@ DB 'boots'
	DB	'trap issue: python%i%i.zip contains non-ASCII filenames witho'
	DB	'ut the unicode flag', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MKDHMPFK@read_directory?$AA@
CONST	SEGMENT
??_C@_0P@MKDHMPFK@read_directory?$AA@ DB 'read_directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GIJEMJIJ@Nhllnhhl?$AA@
CONST	SEGMENT
??_C@_08GIJEMJIJ@Nhllnhhl?$AA@ DB 'Nhllnhhl', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKKNHKHN@?$CFU?$CFc?$CFU?$AA@
CONST	SEGMENT
??_C@_06HKKNHKHN@?$CFU?$CFc?$CFU?$AA@ DB '%U%c%U', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PAOMFHGM@cp437?$AA@
CONST	SEGMENT
??_C@_05PAOMFHGM@cp437?$AA@ DB 'cp437', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJENGABA@ascii?$AA@
CONST	SEGMENT
??_C@_05OJENGABA@ascii?$AA@ DB 'ascii', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDJLLLPP@not?5a?5Zip?5file?3?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BD@MDJLLLPP@not?5a?5Zip?5file?3?5?$CFR?$AA@ DB 'not a Zip file: %R'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@ DB 'can''t read '
	DB	'Zip file: %R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PKKLABEO@can?8t?5open?5Zip?5file?3?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BI@PKKLABEO@can?8t?5open?5Zip?5file?3?5?$CFR?$AA@ DB 'can''t open '
	DB	'Zip file: %R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT read_directory
_TEXT	SEGMENT
file_size$1$ = 80
tv171 = 84
data_size$1$ = 88
tv165 = 92
tv168 = 96
crc$1$ = 100
arc_offset$1$ = 104
endof_central_dir$ = 112
name$ = 144
archive$ = 480
count$1$ = 488
header_size$1$ = 496
tv162 = 504
read_directory PROC					; COMDAT

; 855  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 81 ec c0 01
	00 00		 sub	 rsp, 448		; 000001c0H

; 856  :     PyObject *files = NULL;
; 857  :     FILE *fp;
; 858  :     unsigned short flags;
; 859  :     short compress, time, date, name_size;
; 860  :     long crc, data_size, file_size, header_size;
; 861  :     Py_ssize_t file_offset, header_position, header_offset;
; 862  :     long l, count;
; 863  :     Py_ssize_t i;
; 864  :     char name[MAXPATHLEN + 5];
; 865  :     PyObject *nameobj = NULL;
; 866  :     char *p, endof_central_dir[22];
; 867  :     Py_ssize_t arc_offset;  /* Absolute offset to start of the zip-archive. */
; 868  :     PyObject *path;
; 869  :     const char *charset;
; 870  :     int bootstrap;
; 871  : 
; 872  :     fp = _Py_fopen(archive, "rb");

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00013	4c 8b f1	 mov	 r14, rcx
  00016	33 ff		 xor	 edi, edi
  00018	e8 00 00 00 00	 call	 _Py_fopen
  0001d	48 8b f0	 mov	 rsi, rax

; 873  :     if (fp == NULL) {

  00020	48 85 c0	 test	 rax, rax
  00023	75 2e		 jne	 SHORT $LN48@read_direc

; 874  :         if (!PyErr_Occurred())

  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	75 16		 jne	 SHORT $LN47@read_direc

; 875  :             PyErr_Format(ZipImportError, "can't open Zip file: %R", archive);

  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@PKKLABEO@can?8t?5open?5Zip?5file?3?5?$CFR?$AA@
  0003d	4d 8b c6	 mov	 r8, r14
  00040	e8 00 00 00 00	 call	 PyErr_Format
$LN47@read_direc:

; 876  :         return NULL;

  00045	33 c0		 xor	 eax, eax

; 1002 : }

  00047	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  0004e	41 5e		 pop	 r14
  00050	5f		 pop	 rdi
  00051	5e		 pop	 rsi
  00052	c3		 ret	 0
$LN48@read_direc:

; 877  :     }
; 878  : 
; 879  :     if (fseek(fp, -22, SEEK_END) == -1) {

  00053	ba ea ff ff ff	 mov	 edx, -22
  00058	48 8b c8	 mov	 rcx, rax
  0005b	44 8d 42 18	 lea	 r8d, QWORD PTR [rdx+24]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 880  :         fclose(fp);

  00065	48 8b ce	 mov	 rcx, rsi
  00068	83 f8 ff	 cmp	 eax, -1
  0006b	75 2a		 jne	 SHORT $LN46@read_direc
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 881  :         PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);

  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
  00081	4d 8b c6	 mov	 r8, r14
  00084	e8 00 00 00 00	 call	 PyErr_Format

; 882  :         return NULL;

  00089	33 c0		 xor	 eax, eax

; 1002 : }

  0008b	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  00092	41 5e		 pop	 r14
  00094	5f		 pop	 rdi
  00095	5e		 pop	 rsi
  00096	c3		 ret	 0
$LN46@read_direc:
  00097	48 89 9c 24 e0
	01 00 00	 mov	 QWORD PTR [rsp+480], rbx

; 883  :     }
; 884  :     header_position = ftell(fp);

  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell

; 885  :     if (fread(endof_central_dir, 1, 22, fp) != 22) {

  000a5	ba 01 00 00 00	 mov	 edx, 1
  000aa	48 8d 4c 24 70	 lea	 rcx, QWORD PTR endof_central_dir$[rsp]
  000af	44 8d 42 15	 lea	 r8d, QWORD PTR [rdx+21]
  000b3	4c 8b ce	 mov	 r9, rsi
  000b6	48 63 d8	 movsxd	 rbx, eax
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000bf	48 83 f8 16	 cmp	 rax, 22
  000c3	74 26		 je	 SHORT $LN45@read_direc

; 886  :         fclose(fp);

  000c5	48 8b ce	 mov	 rcx, rsi
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 887  :         PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);

  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
  000dc	4d 8b c6	 mov	 r8, r14
  000df	e8 00 00 00 00	 call	 PyErr_Format

; 888  :         return NULL;

  000e4	33 c0		 xor	 eax, eax
  000e6	e9 e3 03 00 00	 jmp	 $LN70@read_direc
$LN45@read_direc:

; 889  :     }
; 890  :     if (get_long((unsigned char *)endof_central_dir) != 0x06054B50) {

  000eb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR endof_central_dir$[rsp]
  000f0	e8 00 00 00 00	 call	 get_long
  000f5	3d 50 4b 05 06	 cmp	 eax, 101010256		; 06054b50H
  000fa	74 26		 je	 SHORT $LN44@read_direc

; 891  :         /* Bad: End of Central Dir signature */
; 892  :         fclose(fp);

  000fc	48 8b ce	 mov	 rcx, rsi
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 893  :         PyErr_Format(ZipImportError, "not a Zip file: %R", archive);

  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@MDJLLLPP@not?5a?5Zip?5file?3?5?$CFR?$AA@
  00113	4d 8b c6	 mov	 r8, r14
  00116	e8 00 00 00 00	 call	 PyErr_Format

; 894  :         return NULL;

  0011b	33 c0		 xor	 eax, eax
  0011d	e9 ac 03 00 00	 jmp	 $LN70@read_direc
$LN44@read_direc:
  00122	48 89 ac 24 b8
	01 00 00	 mov	 QWORD PTR [rsp+440], rbp
  0012a	4c 89 a4 24 b0
	01 00 00	 mov	 QWORD PTR [rsp+432], r12

; 895  :     }
; 896  : 
; 897  :     header_size = get_long((unsigned char *)endof_central_dir + 12);
; 898  :     header_offset = get_long((unsigned char *)endof_central_dir + 16);

  00132	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR endof_central_dir$[rsp+16]
  0013a	4c 89 ac 24 a8
	01 00 00	 mov	 QWORD PTR [rsp+424], r13
  00142	4c 89 bc 24 a0
	01 00 00	 mov	 QWORD PTR [rsp+416], r15
  0014a	e8 00 00 00 00	 call	 get_long
  0014f	48 8d 4c 24 7c	 lea	 rcx, QWORD PTR endof_central_dir$[rsp+12]
  00154	4c 63 e0	 movsxd	 r12, eax
  00157	e8 00 00 00 00	 call	 get_long

; 899  :     arc_offset = header_position - header_offset - header_size;

  0015c	49 2b dc	 sub	 rbx, r12
  0015f	48 63 c8	 movsxd	 rcx, eax
  00162	48 2b d9	 sub	 rbx, rcx
  00165	48 89 5c 24 68	 mov	 QWORD PTR arc_offset$1$[rsp], rbx

; 900  :     header_offset += arc_offset;

  0016a	4c 03 e3	 add	 r12, rbx

; 901  : 
; 902  :     files = PyDict_New();

  0016d	e8 00 00 00 00	 call	 PyDict_New
  00172	4c 8b f8	 mov	 r15, rax

; 903  :     if (files == NULL)

  00175	48 85 c0	 test	 rax, rax
  00178	0f 84 0b 03 00
	00		 je	 $error$21033

; 904  :         goto error;
; 905  : 
; 906  :     /* Start of Central Directory */
; 907  :     count = 0;

  0017e	33 db		 xor	 ebx, ebx

; 908  :     for (;;) {
; 909  :         PyObject *t;
; 910  :         int err;
; 911  : 
; 912  :         if (fseek(fp, header_offset, 0) == -1)  /* Start of file header */

  00180	45 33 c0	 xor	 r8d, r8d
  00183	41 8b d4	 mov	 edx, r12d
  00186	48 8b ce	 mov	 rcx, rsi
  00189	89 9c 24 e8 01
	00 00		 mov	 DWORD PTR count$1$[rsp], ebx
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  00196	83 f8 ff	 cmp	 eax, -1
  00199	0f 84 94 02 00
	00		 je	 $fseek_error$21040
  0019f	90		 npad	 1
$LL42@read_direc:

; 913  :             goto fseek_error;
; 914  :         l = PyMarshal_ReadLongFromFile(fp);

  001a0	48 8b ce	 mov	 rcx, rsi
  001a3	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile

; 915  :         if (l != 0x02014B50)
; 916  :             break;              /* Bad: Central Dir File Header */
; 917  :         if (fseek(fp, header_offset + 8, 0) == -1)

  001a8	48 8b ce	 mov	 rcx, rsi
  001ab	3d 50 4b 01 02	 cmp	 eax, 33639248		; 02014b50H
  001b0	0f 85 2c 03 00
	00		 jne	 $LN59@read_direc
  001b6	41 8d 54 24 08	 lea	 edx, DWORD PTR [r12+8]
  001bb	45 33 c0	 xor	 r8d, r8d
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  001c4	83 f8 ff	 cmp	 eax, -1
  001c7	0f 84 66 02 00
	00		 je	 $fseek_error$21040

; 918  :             goto fseek_error;
; 919  :         flags = (unsigned short)PyMarshal_ReadShortFromFile(fp);

  001cd	48 8b ce	 mov	 rcx, rsi
  001d0	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 920  :         compress = PyMarshal_ReadShortFromFile(fp);

  001d5	48 8b ce	 mov	 rcx, rsi
  001d8	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  001df	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 921  :         time = PyMarshal_ReadShortFromFile(fp);

  001e4	48 8b ce	 mov	 rcx, rsi
  001e7	89 44 24 5c	 mov	 DWORD PTR tv165[rsp], eax
  001eb	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 922  :         date = PyMarshal_ReadShortFromFile(fp);

  001f0	48 8b ce	 mov	 rcx, rsi
  001f3	89 44 24 60	 mov	 DWORD PTR tv168[rsp], eax
  001f7	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 923  :         crc = PyMarshal_ReadLongFromFile(fp);

  001fc	48 8b ce	 mov	 rcx, rsi
  001ff	89 44 24 54	 mov	 DWORD PTR tv171[rsp], eax
  00203	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile

; 924  :         data_size = PyMarshal_ReadLongFromFile(fp);

  00208	48 8b ce	 mov	 rcx, rsi
  0020b	89 44 24 64	 mov	 DWORD PTR crc$1$[rsp], eax
  0020f	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile

; 925  :         file_size = PyMarshal_ReadLongFromFile(fp);

  00214	48 8b ce	 mov	 rcx, rsi
  00217	89 44 24 58	 mov	 DWORD PTR data_size$1$[rsp], eax
  0021b	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile

; 926  :         name_size = PyMarshal_ReadShortFromFile(fp);

  00220	48 8b ce	 mov	 rcx, rsi
  00223	89 44 24 50	 mov	 DWORD PTR file_size$1$[rsp], eax
  00227	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 927  :         header_size = 46 + name_size +
; 928  :            PyMarshal_ReadShortFromFile(fp) +
; 929  :            PyMarshal_ReadShortFromFile(fp);

  0022c	48 8b ce	 mov	 rcx, rsi
  0022f	8b e8		 mov	 ebp, eax
  00231	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile
  00236	48 8b ce	 mov	 rcx, rsi
  00239	8b d8		 mov	 ebx, eax
  0023b	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile

; 930  :         if (fseek(fp, header_offset + 42, 0) == -1)

  00240	41 8d 54 24 2a	 lea	 edx, DWORD PTR [r12+42]
  00245	03 d8		 add	 ebx, eax
  00247	0f bf c5	 movsx	 eax, bp
  0024a	45 33 c0	 xor	 r8d, r8d
  0024d	8d 44 03 2e	 lea	 eax, DWORD PTR [rbx+rax+46]
  00251	48 8b ce	 mov	 rcx, rsi
  00254	89 84 24 f0 01
	00 00		 mov	 DWORD PTR header_size$1$[rsp], eax
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  00261	83 f8 ff	 cmp	 eax, -1
  00264	0f 84 c9 01 00
	00		 je	 $fseek_error$21040

; 931  :             goto fseek_error;
; 932  :         file_offset = PyMarshal_ReadLongFromFile(fp) + arc_offset;

  0026a	48 8b ce	 mov	 rcx, rsi
  0026d	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile
  00272	4c 63 e8	 movsxd	 r13, eax

; 933  :         if (name_size > MAXPATHLEN)

  00275	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  0027a	4c 03 6c 24 68	 add	 r13, QWORD PTR arc_offset$1$[rsp]
  0027f	66 3b e8	 cmp	 bp, ax
  00282	7e 03		 jle	 SHORT $LN36@read_direc

; 934  :             name_size = MAXPATHLEN;

  00284	0f b7 e8	 movzx	 ebp, ax
$LN36@read_direc:

; 937  :         for (i = 0; i < (Py_ssize_t)name_size; i++) {

  00287	48 0f bf ed	 movsx	 rbp, bp
  0028b	48 8d 9c 24 90
	00 00 00	 lea	 rbx, QWORD PTR name$[rsp]
  00293	48 85 ed	 test	 rbp, rbp
  00296	7e 22		 jle	 SHORT $LN33@read_direc

; 935  : 
; 936  :         p = name;

  00298	48 8b fd	 mov	 rdi, rbp
  0029b	0f 1f 44 00 00	 npad	 5
$LL35@read_direc:

; 938  :             *p = (char)getc(fp);

  002a0	48 8b ce	 mov	 rcx, rsi
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
  002a9	88 03		 mov	 BYTE PTR [rbx], al

; 939  :             if (*p == '/')

  002ab	3c 2f		 cmp	 al, 47			; 0000002fH
  002ad	75 03		 jne	 SHORT $LN32@read_direc

; 940  :                 *p = SEP;

  002af	c6 03 5c	 mov	 BYTE PTR [rbx], 92	; 0000005cH
$LN32@read_direc:

; 941  :             p++;

  002b2	48 ff c3	 inc	 rbx
  002b5	48 ff cf	 dec	 rdi
  002b8	75 e6		 jne	 SHORT $LL35@read_direc
$LN33@read_direc:

; 942  :         }
; 943  :         *p = 0;         /* Add terminating null byte */
; 944  :         header_offset += header_size;

  002ba	48 63 84 24 f0
	01 00 00	 movsxd	 rax, DWORD PTR header_size$1$[rsp]
  002c2	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 945  : 
; 946  :         bootstrap = 0;

  002c5	33 db		 xor	 ebx, ebx
  002c7	4c 03 e0	 add	 r12, rax

; 947  :         if (flags & 0x0800)

  002ca	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  002cf	66 85 84 24 f8
	01 00 00	 test	 WORD PTR tv162[rsp], ax
  002d7	74 09		 je	 SHORT $LN31@read_direc

; 948  :             charset = "utf-8";

  002d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  002e0	eb 35		 jmp	 SHORT $LN28@read_direc
$LN31@read_direc:

; 949  :         else if (!PyThreadState_GET()->interp->codecs_initialized) {

  002e2	e8 00 00 00 00	 call	 _Py_PXCTX
  002e7	85 c0		 test	 eax, eax
  002e9	74 07		 je	 SHORT $LN51@read_direc
  002eb	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  002f0	eb 07		 jmp	 SHORT $LN52@read_direc
$LN51@read_direc:
  002f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN52@read_direc:
  002f9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002fd	39 58 50	 cmp	 DWORD PTR [rax+80], ebx
  00300	75 0e		 jne	 SHORT $LN29@read_direc

; 950  :             /* During bootstrap, we may need to load the encodings
; 951  :                package from a ZIP file. But the cp437 encoding is implemented
; 952  :                in Python in the encodings package.
; 953  : 
; 954  :                Break out of this dependency by assuming that the path to
; 955  :                the encodings module is ASCII-only. */
; 956  :             charset = "ascii";

  00302	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@

; 957  :             bootstrap = 1;

  00309	bb 01 00 00 00	 mov	 ebx, 1

; 958  :         }
; 959  :         else

  0030e	eb 07		 jmp	 SHORT $LN28@read_direc
$LN29@read_direc:

; 960  :             charset = "cp437";

  00310	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05PAOMFHGM@cp437?$AA@
$LN28@read_direc:

; 961  :         nameobj = PyUnicode_Decode(name, name_size, charset, NULL);

  00317	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR name$[rsp]
  0031f	45 33 c9	 xor	 r9d, r9d
  00322	48 8b d5	 mov	 rdx, rbp
  00325	e8 00 00 00 00	 call	 PyUnicode_Decode
  0032a	48 8b f8	 mov	 rdi, rax

; 962  :         if (nameobj == NULL) {

  0032d	48 85 c0	 test	 rax, rax
  00330	0f 84 33 01 00
	00		 je	 $LN62@read_direc

; 968  :             goto error;
; 969  :         }
; 970  :         if (PyUnicode_READY(nameobj) == -1)

  00336	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0033a	75 11		 jne	 SHORT $LN69@read_direc
  0033c	48 8b c8	 mov	 rcx, rax
  0033f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00344	83 f8 ff	 cmp	 eax, -1
  00347	0f 84 3c 01 00
	00		 je	 $error$21033
$LN69@read_direc:

; 971  :             goto error;
; 972  :         path = PyUnicode_FromFormat("%U%c%U", archive, SEP, nameobj);

  0034d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06HKKNHKHN@?$CFU?$CFc?$CFU?$AA@
  00354	4c 8b cf	 mov	 r9, rdi
  00357	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  0035d	49 8b d6	 mov	 rdx, r14
  00360	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 973  :         if (path == NULL)

  00365	48 85 c0	 test	 rax, rax
  00368	0f 84 1b 01 00
	00		 je	 $error$21033

; 974  :             goto error;
; 975  :         t = Py_BuildValue("Nhllnhhl", path, compress, data_size,
; 976  :                           file_size, file_offset, time, date, crc);

  0036e	44 8b 4c 24 64	 mov	 r9d, DWORD PTR crc$1$[rsp]
  00373	0f bf 4c 24 54	 movsx	 ecx, WORD PTR tv171[rsp]
  00378	0f bf 54 24 60	 movsx	 edx, WORD PTR tv168[rsp]
  0037d	44 0f bf 44 24
	5c		 movsx	 r8d, WORD PTR tv165[rsp]
  00383	44 89 4c 24 40	 mov	 DWORD PTR [rsp+64], r9d
  00388	44 8b 4c 24 58	 mov	 r9d, DWORD PTR data_size$1$[rsp]
  0038d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00391	8b 4c 24 50	 mov	 ecx, DWORD PTR file_size$1$[rsp]
  00395	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00399	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0039e	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GIJEMJIJ@Nhllnhhl?$AA@
  003a9	48 8b d0	 mov	 rdx, rax
  003ac	e8 00 00 00 00	 call	 Py_BuildValue
  003b1	48 8b d8	 mov	 rbx, rax

; 977  :         if (t == NULL)

  003b4	48 85 c0	 test	 rax, rax
  003b7	0f 84 cc 00 00
	00		 je	 $error$21033

; 978  :             goto error;
; 979  :         err = PyDict_SetItem(files, nameobj, t);

  003bd	4c 8b c0	 mov	 r8, rax
  003c0	48 8b d7	 mov	 rdx, rdi
  003c3	49 8b cf	 mov	 rcx, r15
  003c6	e8 00 00 00 00	 call	 PyDict_SetItem

; 980  :         Py_CLEAR(nameobj);

  003cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MKDHMPFK@read_directory?$AA@
  003d9	4c 8b cf	 mov	 r9, rdi
  003dc	41 b8 d4 03 00
	00		 mov	 r8d, 980		; 000003d4H
  003e2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003ea	8b e8		 mov	 ebp, eax
  003ec	e8 00 00 00 00	 call	 _PyParallel_Guard
  003f1	85 c0		 test	 eax, eax
  003f3	75 0a		 jne	 SHORT $LN21@read_direc
  003f5	48 8b cf	 mov	 rcx, rdi
  003f8	33 ff		 xor	 edi, edi
  003fa	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@read_direc:

; 981  :         Py_DECREF(t);

  003ff	48 8b cb	 mov	 rcx, rbx
  00402	e8 00 00 00 00	 call	 _Py_DecRef

; 982  :         if (err != 0)

  00407	85 ed		 test	 ebp, ebp
  00409	75 7e		 jne	 SHORT $error$21033

; 983  :             goto error;
; 984  :         count++;

  0040b	8b 9c 24 e8 01
	00 00		 mov	 ebx, DWORD PTR count$1$[rsp]
  00412	45 33 c0	 xor	 r8d, r8d
  00415	41 8b d4	 mov	 edx, r12d
  00418	ff c3		 inc	 ebx
  0041a	48 8b ce	 mov	 rcx, rsi
  0041d	89 9c 24 e8 01
	00 00		 mov	 DWORD PTR count$1$[rsp], ebx
  00424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  0042a	83 f8 ff	 cmp	 eax, -1
  0042d	0f 85 6d fd ff
	ff		 jne	 $LL42@read_direc
$fseek_error$21040:

; 991  : fseek_error:
; 992  :     fclose(fp);

  00433	48 8b ce	 mov	 rcx, rsi
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 993  :     Py_XDECREF(files);

  0043c	49 8b cf	 mov	 rcx, r15
  0043f	e8 00 00 00 00	 call	 _Py_DecRef

; 994  :     Py_XDECREF(nameobj);

  00444	48 85 ff	 test	 rdi, rdi
  00447	74 08		 je	 SHORT $LN11@read_direc
  00449	48 8b cf	 mov	 rcx, rdi
  0044c	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@read_direc:

; 995  :     PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);

  00451	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00458	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
  0045f	4d 8b c6	 mov	 r8, r14
  00462	e8 00 00 00 00	 call	 PyErr_Format

; 996  :     return NULL;

  00467	eb 43		 jmp	 SHORT $LN3@read_direc
$LN62@read_direc:

; 963  :             if (bootstrap)

  00469	85 db		 test	 ebx, ebx
  0046b	74 1c		 je	 SHORT $error$21033

; 964  :                 PyErr_Format(PyExc_NotImplementedError,
; 965  :                     "bootstrap issue: python%i%i.zip contains non-ASCII "
; 966  :                     "filenames without the unicode flag",
; 967  :                     PY_MAJOR_VERSION, PY_MINOR_VERSION);

  0046d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00474	41 b9 03 00 00
	00		 mov	 r9d, 3
  0047a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FG@JDPOMHML@bootstrap?5issue?3?5python?$CFi?$CFi?4zip?5@
  00481	45 8b c1	 mov	 r8d, r9d
  00484	e8 00 00 00 00	 call	 PyErr_Format
$error$21033:

; 997  : error:
; 998  :     fclose(fp);

  00489	48 8b ce	 mov	 rcx, rsi
  0048c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 999  :     Py_XDECREF(files);

  00492	4d 85 ff	 test	 r15, r15
  00495	74 08		 je	 SHORT $LN7@read_direc
  00497	49 8b cf	 mov	 rcx, r15
  0049a	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@read_direc:

; 1000 :     Py_XDECREF(nameobj);

  0049f	48 85 ff	 test	 rdi, rdi
  004a2	74 08		 je	 SHORT $LN3@read_direc
  004a4	48 8b cf	 mov	 rcx, rdi
  004a7	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@read_direc:

; 1001 :     return NULL;

  004ac	33 c0		 xor	 eax, eax
$LN74@read_direc:
  004ae	4c 8b ac 24 a8
	01 00 00	 mov	 r13, QWORD PTR [rsp+424]
  004b6	4c 8b a4 24 b0
	01 00 00	 mov	 r12, QWORD PTR [rsp+432]
  004be	48 8b ac 24 b8
	01 00 00	 mov	 rbp, QWORD PTR [rsp+440]
  004c6	4c 8b bc 24 a0
	01 00 00	 mov	 r15, QWORD PTR [rsp+416]
$LN70@read_direc:
  004ce	48 8b 9c 24 e0
	01 00 00	 mov	 rbx, QWORD PTR [rsp+480]

; 1002 : }

  004d6	48 81 c4 c0 01
	00 00		 add	 rsp, 448		; 000001c0H
  004dd	41 5e		 pop	 r14
  004df	5f		 pop	 rdi
  004e0	5e		 pop	 rsi
  004e1	c3		 ret	 0
$LN59@read_direc:

; 985  :     }
; 986  :     fclose(fp);

  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 987  :     if (Py_VerboseFlag)

  004e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  004ef	74 11		 je	 SHORT $LN17@read_direc

; 988  :         PySys_FormatStderr("# zipimport: found %ld names in %R\n",
; 989  :                            count, archive);

  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@DAGBHPLA@?$CD?5zipimport?3?5found?5?$CFld?5names?5in?5@
  004f8	4d 8b c6	 mov	 r8, r14
  004fb	8b d3		 mov	 edx, ebx
  004fd	e8 00 00 00 00	 call	 PySys_FormatStderr
$LN17@read_direc:

; 990  :     return files;

  00502	49 8b c7	 mov	 rax, r15
  00505	eb a7		 jmp	 SHORT $LN74@read_direc
read_directory ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FABGLHMK@?$CD?5zipimport?3?5zlib?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0M@DIMCGEGC@UNAVAILABLE?$AA@		; `string'
PUBLIC	??_C@_09LAIKOIHJ@available?$AA@			; `string'
PUBLIC	??_C@_04OLICEBLN@zlib?$AA@			; `string'
EXTRN	PySys_WriteStderr:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_decompress_func DD imagerel get_decompress_func
	DD	imagerel get_decompress_func+179
	DD	imagerel $unwind$get_decompress_func
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_decompress_func DD 052f01H
	DD	04742fH
	DD	063420H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BG@FABGLHMK@?$CD?5zipimport?3?5zlib?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BG@FABGLHMK@?$CD?5zipimport?3?5zlib?5?$CFs?6?$AA@ DB '# zipimport:'
	DB	' zlib %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIMCGEGC@UNAVAILABLE?$AA@
CONST	SEGMENT
??_C@_0M@DIMCGEGC@UNAVAILABLE?$AA@ DB 'UNAVAILABLE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LAIKOIHJ@available?$AA@
CONST	SEGMENT
??_C@_09LAIKOIHJ@available?$AA@ DB 'available', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04OLICEBLN@zlib?$AA@
CONST	SEGMENT
??_C@_04OLICEBLN@zlib?$AA@ DB 'zlib', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_decompress_func
_TEXT	SEGMENT
get_decompress_func PROC				; COMDAT

; 1009 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1010 :     static int importing_zlib = 0;
; 1011 :     PyObject *zlib;
; 1012 :     PyObject *decompress;
; 1013 :     _Py_IDENTIFIER(decompress);
; 1014 : 
; 1015 :     if (importing_zlib != 0)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?importing_zlib@?1??get_decompress_func@@9@9, 0
  0000b	74 07		 je	 SHORT $LN4@get_decomp

; 1016 :         /* Someone has a zlib.py[co] in their Zip file;
; 1017 :            let's avoid a stack overflow. */
; 1018 :         return NULL;

  0000d	33 c0		 xor	 eax, eax

; 1035 : }

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00013	c3		 ret	 0
$LN4@get_decomp:

; 1019 :     importing_zlib = 1;
; 1020 :     zlib = PyImport_ImportModuleNoBlock("zlib");

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OLICEBLN@zlib?$AA@
  0001b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00020	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?importing_zlib@?1??get_decompress_func@@9@9, 1
  0002a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0002f	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock

; 1021 :     importing_zlib = 0;

  00034	33 db		 xor	 ebx, ebx
  00036	48 8b f8	 mov	 rdi, rax
  00039	89 1d 00 00 00
	00		 mov	 DWORD PTR ?importing_zlib@?1??get_decompress_func@@9@9, ebx

; 1022 :     if (zlib != NULL) {

  0003f	48 85 c0	 test	 rax, rax
  00042	74 2e		 je	 SHORT $LN3@get_decomp

; 1023 :         decompress = _PyObject_GetAttrId(zlib,
; 1024 :                                          &PyId_decompress);

  00044	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  0004b	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  00054	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_decompress@?1??get_decompress_func@@9@9
  00059	4a 03 14 c1	 add	 rdx, QWORD PTR [rcx+r8*8]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 1025 :         Py_DECREF(zlib);

  00065	48 8b cf	 mov	 rcx, rdi
  00068	48 8b d8	 mov	 rbx, rax
  0006b	e8 00 00 00 00	 call	 _Py_DecRef

; 1026 :     }
; 1027 :     else {

  00070	eb 05		 jmp	 SHORT $LN2@get_decomp
$LN3@get_decomp:

; 1028 :         PyErr_Clear();

  00072	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@get_decomp:

; 1029 :         decompress = NULL;
; 1030 :     }
; 1031 :     if (Py_VerboseFlag)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  0007e	74 21		 je	 SHORT $LN1@get_decomp

; 1032 :         PySys_WriteStderr("# zipimport: zlib %s\n",
; 1033 :             zlib != NULL ? "available": "UNAVAILABLE");

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09LAIKOIHJ@available?$AA@
  00087	48 85 ff	 test	 rdi, rdi
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DIMCGEGC@UNAVAILABLE?$AA@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FABGLHMK@?$CD?5zipimport?3?5zlib?5?$CFs?6?$AA@
  00098	48 0f 45 d0	 cmovne	 rdx, rax
  0009c	e8 00 00 00 00	 call	 PySys_WriteStderr
$LN1@get_decomp:

; 1034 :     return decompress;

  000a1	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000a6	48 8b c3	 mov	 rax, rbx
  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1035 : }

  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	c3		 ret	 0
get_decompress_func ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@JLFLPJLA@zipimport?3?5can?8t?5read?5data?$AA@ ; `string'
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0CK@CJGFPDKD@can?8t?5decompress?5data?$DL?5zlib?5not?5@ ; `string'
PUBLIC	??_C@_0BM@NKCFKAJN@bad?5local?5file?5header?5in?5?$CFU?$AA@ ; `string'
PUBLIC	??_C@_0CA@GMBDHGEN@zipimport?3?5can?5not?5open?5file?5?$CFU?$AA@ ; `string'
PUBLIC	??_C@_08JAOLPNL@Olllllll?$AA@			; `string'
EXTRN	PyObject_CallFunction:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyExc_IOError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_data DD imagerel get_data
	DD	imagerel get_data+120
	DD	imagerel $unwind$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$get_data DD imagerel get_data+120
	DD	imagerel get_data+188
	DD	imagerel $chain$0$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_data DD imagerel get_data+188
	DD	imagerel get_data+276
	DD	imagerel $chain$2$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$get_data DD imagerel get_data+276
	DD	imagerel get_data+352
	DD	imagerel $chain$4$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$get_data DD imagerel get_data+352
	DD	imagerel get_data+457
	DD	imagerel $chain$8$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$get_data DD imagerel get_data+457
	DD	imagerel get_data+789
	DD	imagerel $chain$9$get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$get_data DD imagerel get_data+789
	DD	imagerel get_data+821
	DD	imagerel $chain$10$get_data
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$get_data DD 021H
	DD	imagerel get_data+352
	DD	imagerel get_data+457
	DD	imagerel $chain$8$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$get_data DD 020521H
	DD	0ec405H
	DD	imagerel get_data+352
	DD	imagerel get_data+457
	DD	imagerel $chain$8$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$get_data DD 061021H
	DD	0105410H
	DD	0143408H
	DD	0f7400H
	DD	imagerel get_data
	DD	imagerel get_data+120
	DD	imagerel $unwind$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$get_data DD 020021H
	DD	0f7400H
	DD	imagerel get_data
	DD	imagerel get_data+120
	DD	imagerel $unwind$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_data DD 020021H
	DD	0f7400H
	DD	imagerel get_data
	DD	imagerel get_data+120
	DD	imagerel $unwind$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$get_data DD 020521H
	DD	0f7405H
	DD	imagerel get_data
	DD	imagerel get_data+120
	DD	imagerel $unwind$get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_data DD 040d01H
	DD	011010dH
	DD	06004d006H
xdata	ENDS
;	COMDAT ??_C@_0BL@JLFLPJLA@zipimport?3?5can?8t?5read?5data?$AA@
CONST	SEGMENT
??_C@_0BL@JLFLPJLA@zipimport?3?5can?8t?5read?5data?$AA@ DB 'zipimport: ca'
	DB	'n''t read data', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CJGFPDKD@can?8t?5decompress?5data?$DL?5zlib?5not?5@
CONST	SEGMENT
??_C@_0CK@CJGFPDKD@can?8t?5decompress?5data?$DL?5zlib?5not?5@ DB 'can''t '
	DB	'decompress data; zlib not available', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NKCFKAJN@bad?5local?5file?5header?5in?5?$CFU?$AA@
CONST	SEGMENT
??_C@_0BM@NKCFKAJN@bad?5local?5file?5header?5in?5?$CFU?$AA@ DB 'bad local'
	DB	' file header in %U', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GMBDHGEN@zipimport?3?5can?5not?5open?5file?5?$CFU?$AA@
CONST	SEGMENT
??_C@_0CA@GMBDHGEN@zipimport?3?5can?5not?5open?5file?5?$CFU?$AA@ DB 'zipi'
	DB	'mport: can not open file %U', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAOLPNL@Olllllll?$AA@
CONST	SEGMENT
??_C@_08JAOLPNL@Olllllll?$AA@ DB 'Olllllll', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_data
_TEXT	SEGMENT
compress$ = 80
archive$ = 160
toc_entry$ = 168
data_size$ = 176
file_offset$ = 184
get_data PROC						; COMDAT

; 1041 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	56		 push	 rsi
  00004	41 55		 push	 r13
  00006	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000d	48 8b f1	 mov	 rsi, rcx

; 1042 :     PyObject *raw_data, *data = NULL, *decompress;
; 1043 :     char *buf;
; 1044 :     FILE *fp;
; 1045 :     int err;
; 1046 :     Py_ssize_t bytes_read = 0;
; 1047 :     long l;
; 1048 :     PyObject *datapath;
; 1049 :     long compress, data_size, file_size, file_offset, bytes_size;
; 1050 :     long time, date, crc;
; 1051 : 
; 1052 :     if (!PyArg_ParseTuple(toc_entry, "Olllllll", &datapath, &compress,
; 1053 :                           &data_size, &file_size, &file_offset, &time,
; 1054 :                           &date, &crc)) {

  00010	49 8d 4b bc	 lea	 rcx, QWORD PTR [r11-68]
  00014	48 8b c2	 mov	 rax, rdx
  00017	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001b	49 8d 4b c0	 lea	 rcx, QWORD PTR [r11-64]
  0001f	4d 8d 4b b8	 lea	 r9, QWORD PTR [r11-72]
  00023	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00027	49 8d 4b c4	 lea	 rcx, QWORD PTR [r11-60]
  0002b	4d 8d 43 d0	 lea	 r8, QWORD PTR [r11-48]
  0002f	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  00033	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JAOLPNL@Olllllll?$AA@
  0003e	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00042	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  00046	45 33 ed	 xor	 r13d, r13d
  00049	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  0004d	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00051	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0005d	85 c0		 test	 eax, eax
  0005f	75 0d		 jne	 SHORT $LN15@get_data

; 1055 :         return NULL;

  00061	33 c0		 xor	 eax, eax

; 1144 : }

  00063	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0006a	41 5d		 pop	 r13
  0006c	5e		 pop	 rsi
  0006d	c3		 ret	 0
$LN15@get_data:

; 1056 :     }
; 1057 : 
; 1058 :     fp = _Py_fopen(archive, "rb");

  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  00075	48 8b ce	 mov	 rcx, rsi
  00078	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  0007d	e8 00 00 00 00	 call	 _Py_fopen
  00082	48 8b f8	 mov	 rdi, rax

; 1059 :     if (!fp) {

  00085	48 85 c0	 test	 rax, rax
  00088	75 32		 jne	 SHORT $LN14@get_data

; 1060 :         if (!PyErr_Occurred())

  0008a	e8 00 00 00 00	 call	 PyErr_Occurred
  0008f	48 85 c0	 test	 rax, rax
  00092	75 16		 jne	 SHORT $LN13@get_data

; 1061 :             PyErr_Format(PyExc_IOError,
; 1062 :                "zipimport: can not open file %U", archive);

  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GMBDHGEN@zipimport?3?5can?5not?5open?5file?5?$CFU?$AA@
  000a2	4c 8b c6	 mov	 r8, rsi
  000a5	e8 00 00 00 00	 call	 PyErr_Format
$LN13@get_data:

; 1063 :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 1144 : }

  000b1	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000b8	41 5d		 pop	 r13
  000ba	5e		 pop	 rsi
  000bb	c3		 ret	 0
$LN14@get_data:

; 1064 :     }
; 1065 : 
; 1066 :     /* Check to make sure the local file header is correct */
; 1067 :     if (fseek(fp, file_offset, 0) == -1) {

  000bc	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR file_offset$[rsp]
  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1068 :         fclose(fp);

  000cf	48 8b cf	 mov	 rcx, rdi
  000d2	83 f8 ff	 cmp	 eax, -1

; 1069 :         PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);
; 1070 :         return NULL;

  000d5	74 5b		 je	 SHORT $LN25@get_data

; 1071 :     }
; 1072 : 
; 1073 :     l = PyMarshal_ReadLongFromFile(fp);

  000d7	e8 00 00 00 00	 call	 PyMarshal_ReadLongFromFile

; 1074 :     if (l != 0x04034B50) {

  000dc	3d 50 4b 03 04	 cmp	 eax, 67324752		; 04034b50H
  000e1	74 31		 je	 SHORT $LN11@get_data

; 1075 :         /* Bad: Local File Header */
; 1076 :         PyErr_Format(ZipImportError,
; 1077 :                      "bad local file header in %U",
; 1078 :                      archive);

  000e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@NKCFKAJN@bad?5local?5file?5header?5in?5?$CFU?$AA@
  000f1	4c 8b c6	 mov	 r8, rsi
  000f4	e8 00 00 00 00	 call	 PyErr_Format

; 1079 :         fclose(fp);

  000f9	48 8b cf	 mov	 rcx, rdi
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00102	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 1080 :         return NULL;

  00107	33 c0		 xor	 eax, eax

; 1144 : }

  00109	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00110	41 5d		 pop	 r13
  00112	5e		 pop	 rsi
  00113	c3		 ret	 0
$LN11@get_data:

; 1081 :     }
; 1082 :     if (fseek(fp, file_offset + 26, 0) == -1) {

  00114	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR file_offset$[rsp]
  0011b	45 33 c0	 xor	 r8d, r8d
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	83 c2 1a	 add	 edx, 26
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1083 :         fclose(fp);

  0012a	48 8b cf	 mov	 rcx, rdi
  0012d	83 f8 ff	 cmp	 eax, -1
  00130	75 2e		 jne	 SHORT $LN10@get_data
$LN25@get_data:
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1084 :         PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);

  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
  00146	4c 8b c6	 mov	 r8, rsi
  00149	e8 00 00 00 00	 call	 PyErr_Format
  0014e	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 1085 :         return NULL;

  00153	33 c0		 xor	 eax, eax

; 1144 : }

  00155	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0015c	41 5d		 pop	 r13
  0015e	5e		 pop	 rsi
  0015f	c3		 ret	 0
$LN10@get_data:
  00160	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  00168	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp

; 1086 :     }
; 1087 : 
; 1088 :     l = 30 + PyMarshal_ReadShortFromFile(fp) +
; 1089 :         PyMarshal_ReadShortFromFile(fp);        /* local header size */

  00170	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile
  00175	48 8b cf	 mov	 rcx, rdi
  00178	8b d8		 mov	 ebx, eax
  0017a	e8 00 00 00 00	 call	 PyMarshal_ReadShortFromFile
  0017f	8d 4c 03 1e	 lea	 ecx, DWORD PTR [rbx+rax+30]

; 1090 :     file_offset += l;           /* Start of file data */
; 1091 : 
; 1092 :     bytes_size = compress == 0 ? data_size : data_size + 1;

  00183	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR data_size$[rsp]
  0018a	01 8c 24 b8 00
	00 00		 add	 DWORD PTR file_offset$[rsp], ecx
  00191	44 39 6c 24 50	 cmp	 DWORD PTR compress$[rsp], r13d
  00196	74 02		 je	 SHORT $LN19@get_data
  00198	ff c0		 inc	 eax
$LN19@get_data:

; 1093 :     if (bytes_size == 0)

  0019a	85 c0		 test	 eax, eax
  0019c	bb 01 00 00 00	 mov	 ebx, 1
  001a1	0f 44 c3	 cmove	 eax, ebx

; 1094 :         bytes_size++;
; 1095 :     raw_data = PyBytes_FromStringAndSize((char *)NULL, bytes_size);

  001a4	33 c9		 xor	 ecx, ecx
  001a6	48 63 d0	 movsxd	 rdx, eax
  001a9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001ae	48 8b e8	 mov	 rbp, rax

; 1096 : 
; 1097 :     if (raw_data == NULL) {

  001b1	48 85 c0	 test	 rax, rax
  001b4	75 10		 jne	 SHORT $LN8@get_data

; 1098 :         fclose(fp);

  001b6	48 8b cf	 mov	 rcx, rdi
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1099 :         return NULL;

  001bf	33 c0		 xor	 eax, eax
  001c1	e9 4f 01 00 00	 jmp	 $LN22@get_data
$LN8@get_data:

; 1100 :     }
; 1101 :     buf = PyBytes_AsString(raw_data);

  001c6	48 8b c8	 mov	 rcx, rax
  001c9	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  001ce	e8 00 00 00 00	 call	 PyBytes_AsString

; 1102 : 
; 1103 :     err = fseek(fp, file_offset, 0);

  001d3	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR file_offset$[rsp]
  001da	45 33 c0	 xor	 r8d, r8d
  001dd	48 8b cf	 mov	 rcx, rdi
  001e0	4c 8b e0	 mov	 r12, rax
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 1104 :     if (err == 0) {

  001e9	85 c0		 test	 eax, eax
  001eb	0f 85 fe 00 00
	00		 jne	 $LN7@get_data

; 1105 :         bytes_read = fread(buf, 1, data_size, fp);

  001f1	4c 63 84 24 b0
	00 00 00	 movsxd	 r8, DWORD PTR data_size$[rsp]
  001f9	4c 8b cf	 mov	 r9, rdi
  001fc	48 8b d3	 mov	 rdx, rbx
  001ff	49 8b cc	 mov	 rcx, r12
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 1110 :     }
; 1111 :     fclose(fp);

  00208	48 8b cf	 mov	 rcx, rdi
  0020b	48 8b d8	 mov	 rbx, rax
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1112 :     if (err || bytes_read != data_size) {

  00214	4c 63 9c 24 b0
	00 00 00	 movsxd	 r11, DWORD PTR data_size$[rsp]
  0021c	49 3b db	 cmp	 rbx, r11
  0021f	0f 85 ad 00 00
	00		 jne	 $LN4@get_data

; 1117 :     }
; 1118 : 
; 1119 :     if (compress != 0) {

  00225	44 39 6c 24 50	 cmp	 DWORD PTR compress$[rsp], r13d
  0022a	74 18		 je	 SHORT $LN3@get_data

; 1120 :         buf[data_size] = 'Z';  /* saw this in zipfile.py */

  0022c	43 c6 04 23 5a	 mov	 BYTE PTR [r11+r12], 90	; 0000005aH

; 1121 :         data_size++;

  00231	44 8b 9c 24 b0
	00 00 00	 mov	 r11d, DWORD PTR data_size$[rsp]
  00239	41 ff c3	 inc	 r11d
  0023c	44 89 9c 24 b0
	00 00 00	 mov	 DWORD PTR data_size$[rsp], r11d
$LN3@get_data:

; 1122 :     }
; 1123 :     buf[data_size] = '\0';

  00244	49 63 c3	 movsxd	 rax, r11d
  00247	46 88 2c 20	 mov	 BYTE PTR [rax+r12], r13b

; 1124 : 
; 1125 :     if (compress == 0) {  /* data is not compressed */

  0024b	44 39 6c 24 50	 cmp	 DWORD PTR compress$[rsp], r13d
  00250	75 23		 jne	 SHORT $LN2@get_data

; 1126 :         data = PyBytes_FromStringAndSize(buf, data_size);

  00252	48 63 94 24 b0
	00 00 00	 movsxd	 rdx, DWORD PTR data_size$[rsp]
  0025a	49 8b cc	 mov	 rcx, r12
  0025d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1127 :         Py_DECREF(raw_data);

  00262	48 8b cd	 mov	 rcx, rbp
  00265	48 8b d8	 mov	 rbx, rax
  00268	e8 00 00 00 00	 call	 _Py_DecRef

; 1128 :         return data;

  0026d	48 8b c3	 mov	 rax, rbx
  00270	e9 9b 00 00 00	 jmp	 $LN23@get_data
$LN2@get_data:

; 1129 :     }
; 1130 : 
; 1131 :     /* Decompress with zlib */
; 1132 :     decompress = get_decompress_func();

  00275	e8 00 00 00 00	 call	 get_decompress_func
  0027a	48 8b d8	 mov	 rbx, rax

; 1133 :     if (decompress == NULL) {

  0027d	48 85 c0	 test	 rax, rax
  00280	75 20		 jne	 SHORT $LN1@get_data

; 1134 :         PyErr_SetString(ZipImportError,
; 1135 :                         "can't decompress data; "
; 1136 :                         "zlib not available");

  00282	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CJGFPDKD@can?8t?5decompress?5data?$DL?5zlib?5not?5@
  00290	e8 00 00 00 00	 call	 PyErr_SetString

; 1141 : error:
; 1142 :     Py_DECREF(raw_data);

  00295	48 8b cd	 mov	 rcx, rbp
  00298	e8 00 00 00 00	 call	 _Py_DecRef

; 1143 :     return data;

  0029d	49 8b c5	 mov	 rax, r13
  002a0	eb 6e		 jmp	 SHORT $LN23@get_data
$LN1@get_data:

; 1137 :         goto error;
; 1138 :     }
; 1139 :     data = PyObject_CallFunction(decompress, "Oi", raw_data, -15);

  002a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  002a9	41 b9 f1 ff ff
	ff		 mov	 r9d, -15
  002af	4c 8b c5	 mov	 r8, rbp
  002b2	48 8b c8	 mov	 rcx, rax
  002b5	e8 00 00 00 00	 call	 PyObject_CallFunction

; 1140 :     Py_DECREF(decompress);

  002ba	48 8b cb	 mov	 rcx, rbx
  002bd	4c 8b e8	 mov	 r13, rax
  002c0	e8 00 00 00 00	 call	 _Py_DecRef

; 1141 : error:
; 1142 :     Py_DECREF(raw_data);

  002c5	48 8b cd	 mov	 rcx, rbp
$error$21190:
  002c8	e8 00 00 00 00	 call	 _Py_DecRef

; 1143 :     return data;

  002cd	49 8b c5	 mov	 rax, r13
  002d0	eb 3e		 jmp	 SHORT $LN23@get_data
$LN4@get_data:

; 1113 :         PyErr_SetString(PyExc_IOError,
; 1114 :                         "zipimport: can't read data");

  002d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JLFLPJLA@zipimport?3?5can?8t?5read?5data?$AA@
  002e0	e8 00 00 00 00	 call	 PyErr_SetString

; 1115 :         Py_DECREF(raw_data);

  002e5	48 8b cd	 mov	 rcx, rbp
  002e8	e8 00 00 00 00	 call	 _Py_DecRef

; 1116 :         return NULL;

  002ed	eb 1f		 jmp	 SHORT $LN24@get_data
$LN7@get_data:

; 1106 :     } else {
; 1107 :         fclose(fp);

  002ef	48 8b cf	 mov	 rcx, rdi
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1108 :         PyErr_Format(ZipImportError, "can't read Zip file: %R", archive);

  002f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  002ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HHGCNGNN@can?8t?5read?5Zip?5file?3?5?$CFR?$AA@
  00306	4c 8b c6	 mov	 r8, rsi
  00309	e8 00 00 00 00	 call	 PyErr_Format
$LN24@get_data:

; 1109 :         return NULL;

  0030e	33 c0		 xor	 eax, eax
$LN23@get_data:
  00310	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
$LN22@get_data:
  00315	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  0031d	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00325	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 1144 : }

  0032a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00331	41 5d		 pop	 r13
  00333	5e		 pop	 rsi
  00334	c3		 ret	 0
get_data ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT eq_mtime
_TEXT	SEGMENT
t1$ = 8
t2$ = 16
eq_mtime PROC						; COMDAT

; 1152 :     time_t d = t1 - t2;

  00000	48 2b ca	 sub	 rcx, rdx

; 1153 :     if (d < 0)

  00003	79 03		 jns	 SHORT $LN1@eq_mtime

; 1154 :         d = -d;

  00005	48 f7 d9	 neg	 rcx
$LN1@eq_mtime:

; 1155 :     /* dostime only stores even seconds, so be lenient */
; 1156 :     return d <= 1;

  00008	33 c0		 xor	 eax, eax
  0000a	48 83 f9 01	 cmp	 rcx, 1
  0000e	0f 9e c0	 setle	 al

; 1157 : }

  00011	c3		 ret	 0
eq_mtime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HJHIEEDA@compiled?5module?5?$CFR?5is?5not?5a?5code@ ; `string'
PUBLIC	??_C@_0BE@INBCKGNC@?$CD?5?$CFR?5has?5bad?5mtime?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@OKNGGAHO@?$CD?5?$CFR?5has?5bad?5magic?6?$AA@ ; `string'
PUBLIC	??_C@_0N@LMPLNBME@bad?5pyc?5data?$AA@		; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyCode_Type:BYTE
EXTRN	PyMarshal_ReadObjectFromString:PROC
EXTRN	PyImport_GetMagicNumber:PROC
EXTRN	PyBytes_Size:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unmarshal_code DD imagerel unmarshal_code
	DD	imagerel unmarshal_code+375
	DD	imagerel $unwind$unmarshal_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unmarshal_code DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CI@HJHIEEDA@compiled?5module?5?$CFR?5is?5not?5a?5code@
CONST	SEGMENT
??_C@_0CI@HJHIEEDA@compiled?5module?5?$CFR?5is?5not?5a?5code@ DB 'compile'
	DB	'd module %R is not a code object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@INBCKGNC@?$CD?5?$CFR?5has?5bad?5mtime?6?$AA@
CONST	SEGMENT
??_C@_0BE@INBCKGNC@?$CD?5?$CFR?5has?5bad?5mtime?6?$AA@ DB '# %R has bad m'
	DB	'time', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OKNGGAHO@?$CD?5?$CFR?5has?5bad?5magic?6?$AA@
CONST	SEGMENT
??_C@_0BE@OKNGGAHO@?$CD?5?$CFR?5has?5bad?5magic?6?$AA@ DB '# %R has bad m'
	DB	'agic', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LMPLNBME@bad?5pyc?5data?$AA@
CONST	SEGMENT
??_C@_0N@LMPLNBME@bad?5pyc?5data?$AA@ DB 'bad pyc data', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
CONST	ENDS
;	COMDAT unmarshal_code
_TEXT	SEGMENT
pathname$ = 64
data$ = 72
mtime$ = 80
unmarshal_code PROC					; COMDAT

; 1166 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f9	 mov	 rdi, rcx

; 1167 :     PyObject *code;
; 1168 :     char *buf = PyBytes_AsString(data);

  0001d	48 8b ca	 mov	 rcx, rdx
  00020	49 8b e8	 mov	 rbp, r8
  00023	48 8b da	 mov	 rbx, rdx
  00026	e8 00 00 00 00	 call	 PyBytes_AsString

; 1169 :     Py_ssize_t size = PyBytes_Size(data);

  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	48 8b f0	 mov	 rsi, rax
  00031	e8 00 00 00 00	 call	 PyBytes_Size
  00036	4c 8b e0	 mov	 r12, rax

; 1170 : 
; 1171 :     if (size <= 9) {

  00039	48 83 f8 09	 cmp	 rax, 9
  0003d	7f 18		 jg	 SHORT $LN7@unmarshal_

; 1172 :         PyErr_SetString(ZipImportError,
; 1173 :                         "bad pyc data");

  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LMPLNBME@bad?5pyc?5data?$AA@
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 1174 :         return NULL;

  00052	e9 03 01 00 00	 jmp	 $LN14@unmarshal_
$LN7@unmarshal_:

; 1175 :     }
; 1176 : 
; 1177 :     if (get_long((unsigned char *)buf) != PyImport_GetMagicNumber()) {

  00057	48 8b ce	 mov	 rcx, rsi
  0005a	e8 00 00 00 00	 call	 get_long
  0005f	8b d8		 mov	 ebx, eax
  00061	e8 00 00 00 00	 call	 PyImport_GetMagicNumber
  00066	3b d8		 cmp	 ebx, eax
  00068	74 69		 je	 SHORT $LN6@unmarshal_

; 1178 :         if (Py_VerboseFlag)

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  00071	74 0f		 je	 SHORT $LN5@unmarshal_

; 1179 :             PySys_FormatStderr("# %R has bad magic\n",
; 1180 :                                pathname);

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@OKNGGAHO@?$CD?5?$CFR?5has?5bad?5magic?6?$AA@
  0007a	48 8b d7	 mov	 rdx, rdi
  0007d	e8 00 00 00 00	 call	 PySys_FormatStderr
$LN5@unmarshal_:

; 1181 :         Py_INCREF(Py_None);

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	85 c0		 test	 eax, eax
  00089	75 3c		 jne	 SHORT $LN11@unmarshal_
  0008b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ae	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b3	85 c0		 test	 eax, eax
  000b5	75 09		 jne	 SHORT $LN10@unmarshal_
  000b7	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000be	74 07		 je	 SHORT $LN11@unmarshal_
$LN10@unmarshal_:
  000c0	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@unmarshal_:

; 1182 :         return Py_None;  /* signal caller to try alternative */

  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ce	e9 89 00 00 00	 jmp	 $LN1@unmarshal_
$LN6@unmarshal_:

; 1183 :     }
; 1184 : 
; 1185 :     if (mtime != 0 && !eq_mtime(get_long((unsigned char *)buf + 4),
; 1186 :                                 mtime)) {

  000d3	48 85 ed	 test	 rbp, rbp
  000d6	74 44		 je	 SHORT $LN4@unmarshal_
  000d8	48 8d 4e 04	 lea	 rcx, QWORD PTR [rsi+4]
  000dc	e8 00 00 00 00	 call	 get_long
  000e1	48 8b d5	 mov	 rdx, rbp
  000e4	48 63 c8	 movsxd	 rcx, eax
  000e7	e8 00 00 00 00	 call	 eq_mtime
  000ec	85 c0		 test	 eax, eax
  000ee	75 2c		 jne	 SHORT $LN4@unmarshal_

; 1187 :         if (Py_VerboseFlag)

  000f0	39 05 00 00 00
	00		 cmp	 DWORD PTR Py_VerboseFlag, eax
  000f6	74 0f		 je	 SHORT $LN3@unmarshal_

; 1188 :             PySys_FormatStderr("# %R has bad mtime\n",
; 1189 :                                pathname);

  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@INBCKGNC@?$CD?5?$CFR?5has?5bad?5mtime?6?$AA@
  000ff	48 8b d7	 mov	 rdx, rdi
  00102	e8 00 00 00 00	 call	 PySys_FormatStderr
$LN3@unmarshal_:

; 1190 :         Py_INCREF(Py_None);

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0010e	e8 00 00 00 00	 call	 _Py_IncRef

; 1191 :         return Py_None;  /* signal caller to try alternative */

  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0011a	eb 40		 jmp	 SHORT $LN1@unmarshal_
$LN4@unmarshal_:

; 1192 :     }
; 1193 : 
; 1194 :     /* XXX the pyc's size field is ignored; timestamp collisions are probably
; 1195 :        unimportant with zip files. */
; 1196 :     code = PyMarshal_ReadObjectFromString(buf + 12, size - 12);

  0011c	49 8d 54 24 f4	 lea	 rdx, QWORD PTR [r12-12]
  00121	48 8d 4e 0c	 lea	 rcx, QWORD PTR [rsi+12]
  00125	e8 00 00 00 00	 call	 PyMarshal_ReadObjectFromString

; 1197 :     if (code == NULL)

  0012a	48 85 c0	 test	 rax, rax

; 1198 :         return NULL;

  0012d	74 2b		 je	 SHORT $LN14@unmarshal_

; 1199 :     if (!PyCode_Check(code)) {

  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyCode_Type
  00136	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  0013a	74 20		 je	 SHORT $LN1@unmarshal_

; 1200 :         Py_DECREF(code);

  0013c	48 8b c8	 mov	 rcx, rax
  0013f	e8 00 00 00 00	 call	 _Py_DecRef

; 1201 :         PyErr_Format(PyExc_TypeError,
; 1202 :              "compiled module %R is not a code object",
; 1203 :              pathname);

  00144	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HJHIEEDA@compiled?5module?5?$CFR?5is?5not?5a?5code@
  00152	4c 8b c7	 mov	 r8, rdi
  00155	e8 00 00 00 00	 call	 PyErr_Format
$LN14@unmarshal_:

; 1204 :         return NULL;

  0015a	33 c0		 xor	 eax, eax
$LN1@unmarshal_:

; 1205 :     }
; 1206 :     return code;
; 1207 : }

  0015c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00161	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00166	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0016b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00170	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00174	41 5c		 pop	 r12
  00176	c3		 ret	 0
unmarshal_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@FBBALAI@zipimport?3?5no?5memory?5to?5allocate@ ; `string'
PUBLIC	??_C@_02NCJKDDL@?6?$AA?$AA@			; `string'
EXTRN	PyExc_MemoryError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_line_endings DD imagerel normalize_line_endings
	DD	imagerel normalize_line_endings+224
	DD	imagerel $unwind$normalize_line_endings
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_line_endings DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CP@FBBALAI@zipimport?3?5no?5memory?5to?5allocate@
CONST	SEGMENT
??_C@_0CP@FBBALAI@zipimport?3?5no?5memory?5to?5allocate@ DB 'zipimport: n'
	DB	'o memory to allocate source buffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCJKDDL@?6?$AA?$AA@
CONST	SEGMENT
??_C@_02NCJKDDL@?6?$AA?$AA@ DB 0aH, 00H, 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT normalize_line_endings
_TEXT	SEGMENT
source$ = 48
normalize_line_endings PROC				; COMDAT

; 1215 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 1216 :     char *buf, *q, *p;
; 1217 :     PyObject *fixed_source;
; 1218 :     int len = 0;

  00012	33 ff		 xor	 edi, edi

; 1219 : 
; 1220 :     p = PyBytes_AsString(source);

  00014	e8 00 00 00 00	 call	 PyBytes_AsString
  00019	48 8b d8	 mov	 rbx, rax

; 1221 :     if (p == NULL) {

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 1e		 jne	 SHORT $LN8@normalize_

; 1222 :         return PyBytes_FromStringAndSize("\n\0", 2);

  00021	8d 57 02	 lea	 edx, QWORD PTR [rdi+2]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02NCJKDDL@?6?$AA?$AA@

; 1248 :     return fixed_source;
; 1249 : }

  0002b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00030	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN8@normalize_:

; 1223 :     }
; 1224 : 
; 1225 :     /* one char extra for trailing \n and one for terminating \0 */
; 1226 :     buf = (char *)PyMem_Malloc(PyBytes_Size(source) + 2);

  0003f	48 8b ce	 mov	 rcx, rsi
  00042	e8 00 00 00 00	 call	 PyBytes_Size
  00047	48 8d 48 02	 lea	 rcx, QWORD PTR [rax+2]
  0004b	e8 00 00 00 00	 call	 PyMem_Malloc
  00050	48 8b f0	 mov	 rsi, rax

; 1227 :     if (buf == NULL) {

  00053	48 85 c0	 test	 rax, rax
  00056	75 25		 jne	 SHORT $LN7@normalize_

; 1228 :         PyErr_SetString(PyExc_MemoryError,
; 1229 :                         "zipimport: no memory to allocate "
; 1230 :                         "source buffer");

  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@FBBALAI@zipimport?3?5no?5memory?5to?5allocate@
  00066	e8 00 00 00 00	 call	 PyErr_SetString

; 1231 :         return NULL;

  0006b	33 c0		 xor	 eax, eax

; 1248 :     return fixed_source;
; 1249 : }

  0006d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00072	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN7@normalize_:

; 1232 :     }
; 1233 :     /* replace "\r\n?" by "\n" */
; 1234 :     for (q = buf; *p != '\0'; p++) {

  0007d	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00080	84 c9		 test	 cl, cl
  00082	74 2b		 je	 SHORT $LN4@normalize_
$LL6@normalize_:

; 1235 :         if (*p == '\r') {

  00084	80 f9 0d	 cmp	 cl, 13
  00087	75 14		 jne	 SHORT $LN3@normalize_

; 1236 :             *q++ = '\n';

  00089	c6 00 0a	 mov	 BYTE PTR [rax], 10
  0008c	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  00090	48 ff c0	 inc	 rax

; 1237 :             if (*(p + 1) == '\n')

  00093	80 39 0a	 cmp	 BYTE PTR [rcx], 10
  00096	75 0a		 jne	 SHORT $LN1@normalize_

; 1238 :                 p++;

  00098	48 8b d9	 mov	 rbx, rcx

; 1239 :         }
; 1240 :         else

  0009b	eb 05		 jmp	 SHORT $LN1@normalize_
$LN3@normalize_:

; 1241 :             *q++ = *p;

  0009d	88 08		 mov	 BYTE PTR [rax], cl
  0009f	48 ff c0	 inc	 rax
$LN1@normalize_:

; 1232 :     }
; 1233 :     /* replace "\r\n?" by "\n" */
; 1234 :     for (q = buf; *p != '\0'; p++) {

  000a2	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]
  000a6	48 ff c3	 inc	 rbx

; 1242 :         len++;

  000a9	ff c7		 inc	 edi
  000ab	84 c9		 test	 cl, cl
  000ad	75 d5		 jne	 SHORT $LL6@normalize_
$LN4@normalize_:

; 1243 :     }
; 1244 :     *q++ = '\n';  /* add trailing \n */

  000af	66 c7 00 0a 00	 mov	 WORD PTR [rax], 10

; 1245 :     *q = '\0';
; 1246 :     fixed_source = PyBytes_FromStringAndSize(buf, len + 2);

  000b4	8d 47 02	 lea	 eax, DWORD PTR [rdi+2]
  000b7	48 8b ce	 mov	 rcx, rsi
  000ba	48 63 d0	 movsxd	 rdx, eax
  000bd	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1247 :     PyMem_Free(buf);

  000c2	48 8b ce	 mov	 rcx, rsi
  000c5	48 8b d8	 mov	 rbx, rax
  000c8	e8 00 00 00 00	 call	 PyMem_Free

; 1248 :     return fixed_source;
; 1249 : }

  000cd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d2	48 8b c3	 mov	 rax, rbx
  000d5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
normalize_line_endings ENDP
_TEXT	ENDS
EXTRN	Py_CompileStringExFlags:PROC
EXTRN	PyUnicode_EncodeFSDefault:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$compile_source DD imagerel compile_source
	DD	imagerel compile_source+40
	DD	imagerel $unwind$compile_source
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$compile_source DD imagerel compile_source+40
	DD	imagerel compile_source+84
	DD	imagerel $chain$0$compile_source
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$compile_source DD imagerel compile_source+84
	DD	imagerel compile_source+166
	DD	imagerel $chain$2$compile_source
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$compile_source DD 020021H
	DD	086400H
	DD	imagerel compile_source
	DD	imagerel compile_source+40
	DD	imagerel $unwind$compile_source
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$compile_source DD 020521H
	DD	086405H
	DD	imagerel compile_source
	DD	imagerel compile_source+40
	DD	imagerel $unwind$compile_source
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compile_source DD 040a01H
	DD	09340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT compile_source
_TEXT	SEGMENT
pathname$ = 64
source$ = 72
compile_source PROC					; COMDAT

; 1255 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx

; 1256 :     PyObject *code, *fixed_source, *pathbytes;
; 1257 : 
; 1258 :     pathbytes = PyUnicode_EncodeFSDefault(pathname);

  0000d	e8 00 00 00 00	 call	 PyUnicode_EncodeFSDefault
  00012	48 8b f8	 mov	 rdi, rax

; 1259 :     if (pathbytes == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN2@compile_so

; 1274 : }

  0001a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN2@compile_so:

; 1260 :         return NULL;
; 1261 : 
; 1262 :     fixed_source = normalize_line_endings(source);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0002d	e8 00 00 00 00	 call	 normalize_line_endings

; 1263 :     if (fixed_source == NULL) {
; 1264 :         Py_DECREF(pathbytes);

  00032	48 8b cf	 mov	 rcx, rdi
  00035	48 8b f0	 mov	 rsi, rax
  00038	48 85 c0	 test	 rax, rax
  0003b	75 17		 jne	 SHORT $LN1@compile_so
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
  00042	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1265 :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 1274 : }

  00049	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN1@compile_so:

; 1266 :     }
; 1267 : 
; 1268 :     code = Py_CompileString(PyBytes_AsString(fixed_source),
; 1269 :                             PyBytes_AsString(pathbytes),
; 1270 :                             Py_file_input);

  00054	e8 00 00 00 00	 call	 PyBytes_AsString
  00059	48 8b ce	 mov	 rcx, rsi
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	e8 00 00 00 00	 call	 PyBytes_AsString
  00064	45 33 c9	 xor	 r9d, r9d
  00067	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  0006d	48 8b d3	 mov	 rdx, rbx
  00070	48 8b c8	 mov	 rcx, rax
  00073	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0007b	e8 00 00 00 00	 call	 Py_CompileStringExFlags

; 1271 :     Py_DECREF(pathbytes);

  00080	48 8b cf	 mov	 rcx, rdi
  00083	48 8b d8	 mov	 rbx, rax
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 1272 :     Py_DECREF(fixed_source);

  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 _Py_DecRef
  00093	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1273 :     return code;

  00098	48 8b c3	 mov	 rax, rbx

; 1274 : }

  0009b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
compile_source ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$parse_dostime DD imagerel parse_dostime
	DD	imagerel parse_dostime+123
	DD	imagerel $unwind$parse_dostime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_dostime DD 010401H
	DD	0a204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
xdata	ENDS
;	COMDAT parse_dostime
_TEXT	SEGMENT
stm$ = 32
dostime$ = 96
dosdate$ = 104
parse_dostime PROC					; COMDAT

; 1280 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1281 :     struct tm stm;
; 1282 : 
; 1283 :     memset((void *) &stm, '\0', sizeof(stm));

  00004	33 c0		 xor	 eax, eax
  00006	48 89 44 24 20	 mov	 QWORD PTR stm$[rsp], rax
  0000b	48 89 44 24 28	 mov	 QWORD PTR stm$[rsp+8], rax
  00010	48 89 44 24 30	 mov	 QWORD PTR stm$[rsp+16], rax
  00015	89 44 24 40	 mov	 DWORD PTR stm$[rsp+32], eax
  00019	48 89 44 24 38	 mov	 QWORD PTR stm$[rsp+24], rax

; 1284 : 
; 1285 :     stm.tm_sec   =  (dostime        & 0x1f) * 2;

  0001e	8b c1		 mov	 eax, ecx
  00020	83 e0 1f	 and	 eax, 31

; 1286 :     stm.tm_min   =  (dostime >> 5)  & 0x3f;
; 1287 :     stm.tm_hour  =  (dostime >> 11) & 0x1f;
; 1288 :     stm.tm_mday  =   dosdate        & 0x1f;
; 1289 :     stm.tm_mon   = ((dosdate >> 5)  & 0x0f) - 1;
; 1290 :     stm.tm_year  = ((dosdate >> 9)  & 0x7f) + 80;
; 1291 :     stm.tm_isdst =   -1; /* wday/yday is ignored */

  00023	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR stm$[rsp+32], -1
  0002b	03 c0		 add	 eax, eax
  0002d	89 44 24 20	 mov	 DWORD PTR stm$[rsp], eax
  00031	8b c1		 mov	 eax, ecx
  00033	c1 f9 0b	 sar	 ecx, 11
  00036	c1 f8 05	 sar	 eax, 5
  00039	83 e1 1f	 and	 ecx, 31
  0003c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003f	89 4c 24 28	 mov	 DWORD PTR stm$[rsp+8], ecx

; 1292 : 
; 1293 :     return mktime(&stm);

  00043	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stm$[rsp]
  00048	89 44 24 24	 mov	 DWORD PTR stm$[rsp+4], eax
  0004c	8b c2		 mov	 eax, edx
  0004e	83 e0 1f	 and	 eax, 31
  00051	89 44 24 2c	 mov	 DWORD PTR stm$[rsp+12], eax
  00055	8b c2		 mov	 eax, edx
  00057	c1 fa 09	 sar	 edx, 9
  0005a	c1 f8 05	 sar	 eax, 5
  0005d	83 e2 7f	 and	 edx, 127		; 0000007fH
  00060	83 e0 0f	 and	 eax, 15
  00063	83 c2 50	 add	 edx, 80			; 00000050H
  00066	ff c8		 dec	 eax
  00068	89 54 24 34	 mov	 DWORD PTR stm$[rsp+20], edx
  0006c	89 44 24 30	 mov	 DWORD PTR stm$[rsp+16], eax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mktime64

; 1294 : }

  00076	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007a	c3		 ret	 0
parse_dostime ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_mtime_of_source DD imagerel get_mtime_of_source
	DD	imagerel get_mtime_of_source+246
	DD	imagerel $unwind$get_mtime_of_source
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_mtime_of_source DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_mtime_of_source
_TEXT	SEGMENT
self$ = 48
path$ = 56
get_mtime_of_source PROC				; COMDAT

; 1301 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1302 :     PyObject *toc_entry, *stripped;
; 1303 :     time_t mtime;
; 1304 : 
; 1305 :     /* strip 'c' or 'o' from *.py[co] */
; 1306 :     if (PyUnicode_READY(path) == -1)

  0000a	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b f9	 mov	 rdi, rcx
  00014	75 1c		 jne	 SHORT $LN4@get_mtime_
  00016	48 8b ca	 mov	 rcx, rdx
  00019	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	75 0f		 jne	 SHORT $LN4@get_mtime_
$LN13@get_mtime_:

; 1307 :         return (time_t)-1;

  00023	48 83 c8 ff	 or	 rax, -1

; 1326 :     return mtime;
; 1327 : }

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN4@get_mtime_:

; 1308 :     stripped = PyUnicode_FromKindAndData(PyUnicode_KIND(path),
; 1309 :                                          PyUnicode_DATA(path),
; 1310 :                                          PyUnicode_GET_LENGTH(path) - 1);

  00032	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]
  00035	f6 c1 20	 test	 cl, 32			; 00000020H
  00038	74 17		 je	 SHORT $LN11@get_mtime_
  0003a	f6 c1 40	 test	 cl, 64			; 00000040H
  0003d	74 09		 je	 SHORT $LN9@get_mtime_
  0003f	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  00046	eb 10		 jmp	 SHORT $LN12@get_mtime_
$LN9@get_mtime_:
  00048	48 8d 93 a0 00
	00 00		 lea	 rdx, QWORD PTR [rbx+160]
  0004f	eb 07		 jmp	 SHORT $LN12@get_mtime_
$LN11@get_mtime_:
  00051	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
$LN12@get_mtime_:
  00058	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0005c	c1 e9 02	 shr	 ecx, 2
  0005f	49 ff c8	 dec	 r8
  00062	83 e1 07	 and	 ecx, 7
  00065	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  0006a	48 8b d8	 mov	 rbx, rax

; 1311 :     if (stripped == NULL)

  0006d	48 85 c0	 test	 rax, rax

; 1312 :         return (time_t)-1;

  00070	74 b1		 je	 SHORT $LN13@get_mtime_

; 1313 : 
; 1314 :     toc_entry = PyDict_GetItem(self->files, stripped);

  00072	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00076	48 8b d0	 mov	 rdx, rax
  00079	e8 00 00 00 00	 call	 PyDict_GetItem

; 1315 :     Py_DECREF(stripped);

  0007e	48 8b cb	 mov	 rcx, rbx
  00081	48 8b f8	 mov	 rdi, rax
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 1316 :     if (toc_entry != NULL && PyTuple_Check(toc_entry) &&
; 1317 :         PyTuple_Size(toc_entry) == 8) {

  00089	48 85 ff	 test	 rdi, rdi
  0008c	74 5b		 je	 SHORT $LN2@get_mtime_
  0008e	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00092	f7 81 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rcx+256], 67108864 ; 04000000H
  0009c	74 4b		 je	 SHORT $LN2@get_mtime_
  0009e	48 8b cf	 mov	 rcx, rdi
  000a1	e8 00 00 00 00	 call	 PyTuple_Size
  000a6	48 83 f8 08	 cmp	 rax, 8
  000aa	75 3d		 jne	 SHORT $LN2@get_mtime_

; 1318 :         /* fetch the time stamp of the .py file for comparison
; 1319 :            with an embedded pyc time stamp */
; 1320 :         int time, date;
; 1321 :         time = PyLong_AsLong(PyTuple_GetItem(toc_entry, 5));

  000ac	8d 50 fd	 lea	 edx, QWORD PTR [rax-3]
  000af	48 8b cf	 mov	 rcx, rdi
  000b2	e8 00 00 00 00	 call	 PyTuple_GetItem
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 PyLong_AsLong

; 1322 :         date = PyLong_AsLong(PyTuple_GetItem(toc_entry, 6));

  000bf	ba 06 00 00 00	 mov	 edx, 6
  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	8b d8		 mov	 ebx, eax
  000c9	e8 00 00 00 00	 call	 PyTuple_GetItem
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	e8 00 00 00 00	 call	 PyLong_AsLong

; 1323 :         mtime = parse_dostime(time, date);

  000d6	8b cb		 mov	 ecx, ebx
  000d8	8b d0		 mov	 edx, eax

; 1326 :     return mtime;
; 1327 : }

  000da	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000df	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e3	5f		 pop	 rdi
  000e4	e9 00 00 00 00	 jmp	 parse_dostime
$LN2@get_mtime_:

; 1324 :     } else
; 1325 :         mtime = 0;

  000e9	33 c0		 xor	 eax, eax

; 1326 :     return mtime;
; 1327 : }

  000eb	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
get_mtime_of_source ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_code_from_data DD imagerel get_code_from_data
	DD	imagerel get_code_from_data+118
	DD	imagerel $unwind$get_code_from_data
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_code_from_data DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_code_from_data
_TEXT	SEGMENT
self$ = 48
isbytecode$ = 56
mtime$ = 64
toc_entry$ = 72
get_code_from_data PROC					; COMDAT

; 1334 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1335 :     PyObject *data, *modpath, *code;
; 1336 : 
; 1337 :     data = get_data(self->archive, toc_entry);

  00014	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00018	8b f2		 mov	 esi, edx
  0001a	49 8b d1	 mov	 rdx, r9
  0001d	49 8b f9	 mov	 rdi, r9
  00020	49 8b e8	 mov	 rbp, r8
  00023	e8 00 00 00 00	 call	 get_data
  00028	48 8b d8	 mov	 rbx, rax

; 1338 :     if (data == NULL)

  0002b	48 85 c0	 test	 rax, rax
  0002e	74 31		 je	 SHORT $LN4@get_code_f
$LN3@get_code_f:

; 1339 :         return NULL;
; 1340 : 
; 1341 :     modpath = PyTuple_GetItem(toc_entry, 0);

  00030	33 d2		 xor	 edx, edx
  00032	48 8b cf	 mov	 rcx, rdi
  00035	e8 00 00 00 00	 call	 PyTuple_GetItem

; 1342 :     if (isbytecode)
; 1343 :         code = unmarshal_code(modpath, data, mtime);

  0003a	48 8b d3	 mov	 rdx, rbx
  0003d	48 8b c8	 mov	 rcx, rax
  00040	85 f6		 test	 esi, esi
  00042	74 0a		 je	 SHORT $LN2@get_code_f
  00044	4c 8b c5	 mov	 r8, rbp
  00047	e8 00 00 00 00	 call	 unmarshal_code

; 1344 :     else

  0004c	eb 05		 jmp	 SHORT $LN6@get_code_f
$LN2@get_code_f:

; 1345 :         code = compile_source(modpath, data);

  0004e	e8 00 00 00 00	 call	 compile_source
$LN6@get_code_f:

; 1346 :     Py_DECREF(data);

  00053	48 8b cb	 mov	 rcx, rbx
  00056	48 8b f8	 mov	 rdi, rax
  00059	e8 00 00 00 00	 call	 _Py_DecRef

; 1347 :     return code;

  0005e	48 8b c7	 mov	 rax, rdi
$LN4@get_code_f:

; 1348 : }

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
get_code_from_data ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CFAELDOA@get_module_code?$AA@		; `string'
PUBLIC	??_C@_0BB@KODJLMOA@?$CD?5trying?5?$CFU?$CFc?$CFU?6?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_module_code DD imagerel get_module_code
	DD	imagerel get_module_code+111
	DD	imagerel $unwind$get_module_code
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$get_module_code DD imagerel get_module_code+111
	DD	imagerel get_module_code+525
	DD	imagerel $chain$3$get_module_code
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$get_module_code DD imagerel get_module_code+525
	DD	imagerel get_module_code+610
	DD	imagerel $chain$4$get_module_code
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$get_module_code DD imagerel get_module_code+610
	DD	imagerel get_module_code+658
	DD	imagerel $chain$5$get_module_code
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$get_module_code DD imagerel get_module_code+658
	DD	imagerel get_module_code+699
	DD	imagerel $chain$6$get_module_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$get_module_code DD 021H
	DD	imagerel get_module_code
	DD	imagerel get_module_code+111
	DD	imagerel $unwind$get_module_code
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$get_module_code DD 060021H
	DD	08e400H
	DD	09d400H
	DD	0ac400H
	DD	imagerel get_module_code
	DD	imagerel get_module_code+111
	DD	imagerel $unwind$get_module_code
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$get_module_code DD 021H
	DD	imagerel get_module_code
	DD	imagerel get_module_code+111
	DD	imagerel $unwind$get_module_code
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$get_module_code DD 060f21H
	DD	08e40fH
	DD	09d40aH
	DD	0ac405H
	DD	imagerel get_module_code
	DD	imagerel get_module_code+111
	DD	imagerel $unwind$get_module_code
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_module_code DD 074801H
	DD	0105448H
	DD	0f014a218H
	DD	060117012H
	DD	03010H
xdata	ENDS
;	COMDAT ??_C@_0BA@CFAELDOA@get_module_code?$AA@
CONST	SEGMENT
??_C@_0BA@CFAELDOA@get_module_code?$AA@ DB 'get_module_code', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KODJLMOA@?$CD?5trying?5?$CFU?$CFc?$CFU?6?$AA@
CONST	SEGMENT
??_C@_0BB@KODJLMOA@?$CD?5trying?5?$CFU?$CFc?$CFU?6?$AA@ DB '# trying %U%c'
	DB	'%U', 0aH, 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
CONST	ENDS
;	COMDAT get_module_code
_TEXT	SEGMENT
path$1$ = 48
self$ = 128
fullname$ = 136
p_ispackage$ = 144
p_modpath$ = 152
get_module_code PROC					; COMDAT

; 1355 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 57		 push	 r15
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00018	4c 8b f9	 mov	 r15, rcx

; 1356 :     PyObject *code = NULL, *toc_entry, *subname;
; 1357 :     PyObject *path, *fullpath = NULL;
; 1358 :     struct st_zip_searchorder *zso;
; 1359 : 
; 1360 :     subname = get_subname(fullname);

  0001b	48 8b ca	 mov	 rcx, rdx
  0001e	33 f6		 xor	 esi, esi
  00020	33 db		 xor	 ebx, ebx
  00022	e8 00 00 00 00	 call	 get_subname
  00027	48 8b f8	 mov	 rdi, rax

; 1361 :     if (subname == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 0a		 jne	 SHORT $LN26@get_module@2

; 1417 : }

  0002f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00033	41 5f		 pop	 r15
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
$LN26@get_module@2:

; 1362 :         return NULL;
; 1363 : 
; 1364 :     path = make_filename(self->prefix, subname);

  00039	49 8b 4f 68	 mov	 rcx, QWORD PTR [r15+104]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00048	e8 00 00 00 00	 call	 make_filename

; 1365 :     Py_DECREF(subname);

  0004d	48 8b cf	 mov	 rcx, rdi
  00050	48 8b e8	 mov	 rbp, rax
  00053	48 89 44 24 30	 mov	 QWORD PTR path$1$[rsp], rax
  00058	e8 00 00 00 00	 call	 _Py_DecRef

; 1366 :     if (path == NULL)

  0005d	48 85 ed	 test	 rbp, rbp
  00060	75 07		 jne	 SHORT $LN25@get_module@2

; 1367 :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 40 02 00 00	 jmp	 $LN45@get_module@2
$LN25@get_module@2:

; 1368 : 
; 1369 :     for (zso = zip_searchorder; *zso->suffix; zso++) {

  00069	38 1d 00 00 00
	00		 cmp	 BYTE PTR zip_searchorder, bl
  0006f	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00074	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  00079	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0007e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:zip_searchorder
  00085	0f 84 45 01 00
	00		 je	 $LN44@get_module@2
  0008b	0f 1f 44 00 00	 npad	 5
$LL24@get_module@2:

; 1370 :         code = NULL;
; 1371 : 
; 1372 :         fullpath = PyUnicode_FromFormat("%U%s", path, zso->suffix);

  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04PGLLPJDI@?$CFU?$CFs?$AA@
  00097	4c 8b c7	 mov	 r8, rdi
  0009a	48 8b d5	 mov	 rdx, rbp
  0009d	33 f6		 xor	 esi, esi
  0009f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000a4	48 8b d8	 mov	 rbx, rax

; 1373 :         if (fullpath == NULL)

  000a7	48 85 c0	 test	 rax, rax
  000aa	0f 84 3b 01 00
	00		 je	 $exit$21376

; 1374 :             goto exit;
; 1375 : 
; 1376 :         if (Py_VerboseFlag > 1)

  000b0	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR Py_VerboseFlag, 1
  000b7	7e 17		 jle	 SHORT $LN20@get_module@2

; 1377 :             PySys_FormatStderr("# trying %U%c%U\n",
; 1378 :                                self->archive, (int)SEP, fullpath);

  000b9	49 8b 57 60	 mov	 rdx, QWORD PTR [r15+96]
  000bd	44 8d 46 5c	 lea	 r8d, QWORD PTR [rsi+92]
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KODJLMOA@?$CD?5trying?5?$CFU?$CFc?$CFU?6?$AA@
  000c8	4c 8b c8	 mov	 r9, rax
  000cb	e8 00 00 00 00	 call	 PySys_FormatStderr
$LN20@get_module@2:

; 1379 :         toc_entry = PyDict_GetItem(self->files, fullpath);

  000d0	49 8b 4f 70	 mov	 rcx, QWORD PTR [r15+112]
  000d4	48 8b d3	 mov	 rdx, rbx
  000d7	e8 00 00 00 00	 call	 PyDict_GetItem
  000dc	4c 8b e0	 mov	 r12, rax

; 1380 :         if (toc_entry != NULL) {

  000df	48 85 c0	 test	 rax, rax
  000e2	0f 84 a9 00 00
	00		 je	 $LN8@get_module@2

; 1381 :             time_t mtime = 0;
; 1382 :             int ispackage = zso->type & IS_PACKAGE;

  000e8	44 8b 77 10	 mov	 r14d, DWORD PTR [rdi+16]
  000ec	45 33 ed	 xor	 r13d, r13d
  000ef	41 8b ee	 mov	 ebp, r14d
  000f2	83 e5 02	 and	 ebp, 2

; 1383 :             int isbytecode = zso->type & IS_BYTECODE;

  000f5	41 83 e6 01	 and	 r14d, 1

; 1384 : 
; 1385 :             if (isbytecode) {

  000f9	74 22		 je	 SHORT $LN16@get_module@2

; 1386 :                 mtime = get_mtime_of_source(self, fullpath);

  000fb	48 8b d3	 mov	 rdx, rbx
  000fe	49 8b cf	 mov	 rcx, r15
  00101	e8 00 00 00 00	 call	 get_mtime_of_source
  00106	4c 8b e8	 mov	 r13, rax

; 1387 :                 if (mtime == (time_t)-1 && PyErr_Occurred()) {

  00109	48 83 f8 ff	 cmp	 rax, -1
  0010d	75 0e		 jne	 SHORT $LN16@get_module@2
  0010f	e8 00 00 00 00	 call	 PyErr_Occurred
  00114	48 85 c0	 test	 rax, rax
  00117	0f 85 ce 00 00
	00		 jne	 $exit$21376
$LN16@get_module@2:

; 1388 :                     goto exit;
; 1389 :                 }
; 1390 :             }
; 1391 :             Py_CLEAR(fullpath);

  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CFAELDOA@get_module_code?$AA@
  0012b	4c 8b cb	 mov	 r9, rbx
  0012e	41 b8 6f 05 00
	00		 mov	 r8d, 1391		; 0000056fH
  00134	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00141	85 c0		 test	 eax, eax
  00143	75 0a		 jne	 SHORT $LN15@get_module@2
  00145	48 8b cb	 mov	 rcx, rbx
  00148	33 db		 xor	 ebx, ebx
  0014a	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@get_module@2:

; 1392 :             if (p_ispackage != NULL)

  0014f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_ispackage$[rsp]
  00157	48 85 c0	 test	 rax, rax
  0015a	74 02		 je	 SHORT $LN12@get_module@2

; 1393 :                 *p_ispackage = ispackage;

  0015c	89 28		 mov	 DWORD PTR [rax], ebp
$LN12@get_module@2:

; 1394 :             code = get_code_from_data(self, ispackage,
; 1395 :                                       isbytecode, mtime,
; 1396 :                                       toc_entry);

  0015e	4d 8b cc	 mov	 r9, r12
  00161	4d 8b c5	 mov	 r8, r13
  00164	41 8b d6	 mov	 edx, r14d
  00167	49 8b cf	 mov	 rcx, r15
  0016a	e8 00 00 00 00	 call	 get_code_from_data
  0016f	48 8b f0	 mov	 rsi, rax

; 1397 :             if (code == Py_None) {

  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00179	48 3b f0	 cmp	 rsi, rax
  0017c	0f 85 e0 00 00
	00		 jne	 $LN11@get_module@2

; 1398 :                 /* bad magic number or non-matching mtime
; 1399 :                    in byte code, try next */
; 1400 :                 Py_DECREF(code);

  00182	48 8b ce	 mov	 rcx, rsi
  00185	e8 00 00 00 00	 call	 _Py_DecRef

; 1401 :                 continue;

  0018a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR path$1$[rsp]
  0018f	eb 32		 jmp	 SHORT $LN23@get_module@2
$LN8@get_module@2:

; 1408 :         }
; 1409 :         else
; 1410 :             Py_CLEAR(fullpath);

  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CFAELDOA@get_module_code?$AA@
  0019f	4c 8b cb	 mov	 r9, rbx
  001a2	41 b8 82 05 00
	00		 mov	 r8d, 1410		; 00000582H
  001a8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  001b5	85 c0		 test	 eax, eax
  001b7	75 0a		 jne	 SHORT $LN23@get_module@2
  001b9	48 8b cb	 mov	 rcx, rbx
  001bc	33 db		 xor	 ebx, ebx
  001be	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@get_module@2:

; 1368 : 
; 1369 :     for (zso = zip_searchorder; *zso->suffix; zso++) {

  001c3	48 83 c7 14	 add	 rdi, 20
  001c7	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  001ca	0f 85 c0 fe ff
	ff		 jne	 $LL24@get_module@2
$LN44@get_module@2:

; 1411 :     }
; 1412 :     PyErr_Format(ZipImportError, "can't find module %R", fullname);

  001d0	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR fullname$[rsp]
  001d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@
  001e6	e8 00 00 00 00	 call	 PyErr_Format
$exit$21376:

; 1413 : exit:
; 1414 :     Py_DECREF(path);

  001eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$1$[rsp]
  001f0	e8 00 00 00 00	 call	 _Py_DecRef
  001f5	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
  001fa	4c 8b 6c 24 48	 mov	 r13, QWORD PTR [rsp+72]
  001ff	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 1415 :     Py_XDECREF(fullpath);

  00204	48 85 db	 test	 rbx, rbx
  00207	0f 84 99 00 00
	00		 je	 $LN3@get_module@2
  0020d	e8 00 00 00 00	 call	 _Py_PXCTX
  00212	85 c0		 test	 eax, eax
  00214	0f 85 8c 00 00
	00		 jne	 $LN3@get_module@2
  0021a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0021e	a8 20		 test	 al, 32			; 00000020H
  00220	75 7c		 jne	 SHORT $LN33@get_module@2
  00222	84 c0		 test	 al, al
  00224	78 78		 js	 SHORT $LN33@get_module@2
  00226	a8 02		 test	 al, 2
  00228	75 7c		 jne	 SHORT $LN3@get_module@2
  0022a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0022e	75 76		 jne	 SHORT $LN3@get_module@2
  00230	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0023e	4c 8b cb	 mov	 r9, rbx
  00241	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00247	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0024f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00254	48 8b cb	 mov	 rcx, rbx
  00257	85 c0		 test	 eax, eax
  00259	74 37		 je	 SHORT $LN38@get_module@2
  0025b	e8 00 00 00 00	 call	 _Px_Dealloc
  00260	eb 44		 jmp	 SHORT $LN3@get_module@2
$LN11@get_module@2:

; 1402 :             }
; 1403 :             if (code != NULL && p_modpath != NULL) {

  00262	48 85 f6	 test	 rsi, rsi
  00265	74 84		 je	 SHORT $exit$21376
  00267	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR p_modpath$[rsp]
  0026f	48 85 ff	 test	 rdi, rdi
  00272	0f 84 73 ff ff
	ff		 je	 $exit$21376

; 1404 :                 *p_modpath = PyTuple_GetItem(toc_entry, 0);

  00278	33 d2		 xor	 edx, edx
  0027a	49 8b cc	 mov	 rcx, r12
  0027d	e8 00 00 00 00	 call	 PyTuple_GetItem

; 1405 :                 Py_INCREF(*p_modpath);

  00282	48 8b c8	 mov	 rcx, rax
  00285	48 89 07	 mov	 QWORD PTR [rdi], rax
  00288	e8 00 00 00 00	 call	 _Py_IncRef

; 1406 :             }
; 1407 :             goto exit;

  0028d	e9 59 ff ff ff	 jmp	 $exit$21376

; 1415 :     Py_XDECREF(fullpath);

$LN38@get_module@2:
  00292	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00296	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0029c	eb 08		 jmp	 SHORT $LN3@get_module@2
$LN33@get_module@2:
  0029e	48 8b cb	 mov	 rcx, rbx
  002a1	e8 00 00 00 00	 call	 Px_DecRef
$LN3@get_module@2:

; 1416 :     return code;

  002a6	48 8b c6	 mov	 rax, rsi
$LN45@get_module@2:
  002a9	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]

; 1417 : }

  002b1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b5	41 5f		 pop	 r15
  002b7	5f		 pop	 rdi
  002b8	5e		 pop	 rsi
  002b9	5b		 pop	 rbx
  002ba	c3		 ret	 0
get_module_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@DAAMIGMB@_zip_directory_cache?$AA@	; `string'
PUBLIC	??_C@_0M@NDJAEMK@zipimporter?$AA@		; `string'
PUBLIC	??_C@_0P@KPLNEBLJ@ZipImportError?$AA@		; `string'
PUBLIC	??_C@_0BJ@NPIJBMBH@zipimport?4ZipImportError?$AA@ ; `string'
PUBLIC	PyInit_zipimport
EXTRN	PyModule_AddObject:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyModule_Create2:PROC
EXTRN	Py_OptimizeFlag:DWORD
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit_zipimport DD imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$PyInit_zipimport
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit_zipimport DD imagerel $LN17+34
	DD	imagerel $LN17+471
	DD	imagerel $chain$0$PyInit_zipimport
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit_zipimport DD imagerel $LN17+471
	DD	imagerel $LN17+522
	DD	imagerel $chain$2$PyInit_zipimport
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit_zipimport DD 020021H
	DD	0a3400H
	DD	imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$PyInit_zipimport
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit_zipimport DD 020521H
	DD	0a3405H
	DD	imagerel $LN17
	DD	imagerel $LN17+34
	DD	imagerel $unwind$PyInit_zipimport
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_zipimport DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BF@DAAMIGMB@_zip_directory_cache?$AA@
CONST	SEGMENT
??_C@_0BF@DAAMIGMB@_zip_directory_cache?$AA@ DB '_zip_directory_cache', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDJAEMK@zipimporter?$AA@
CONST	SEGMENT
??_C@_0M@NDJAEMK@zipimporter?$AA@ DB 'zipimporter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KPLNEBLJ@ZipImportError?$AA@
CONST	SEGMENT
??_C@_0P@KPLNEBLJ@ZipImportError?$AA@ DB 'ZipImportError', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NPIJBMBH@zipimport?4ZipImportError?$AA@
CONST	SEGMENT
??_C@_0BJ@NPIJBMBH@zipimport?4ZipImportError?$AA@ DB 'zipimport.ZipImport'
	DB	'Error', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\zipimport.c
CONST	ENDS
;	COMDAT PyInit_zipimport
_TEXT	SEGMENT
tmp$21450 = 48
PyInit_zipimport PROC					; COMDAT

; 1450 : {

$LN17:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1451 :     PyObject *mod;
; 1452 : 
; 1453 :     if (PyType_Ready(&ZipImporter_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ZipImporter_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	79 07		 jns	 SHORT $LN8@PyInit_zip

; 1454 :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 1496 :         return NULL;
; 1497 :     return mod;
; 1498 : }

  00016	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0001a	c3		 ret	 0
$LN8@PyInit_zip:

; 1455 : 
; 1456 :     /* Correct directory separator */
; 1457 :     zip_searchorder[0].suffix[0] = SEP;
; 1458 :     zip_searchorder[1].suffix[0] = SEP;
; 1459 :     zip_searchorder[2].suffix[0] = SEP;
; 1460 :     if (Py_OptimizeFlag) {

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_OptimizeFlag, 0
  00022	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00027	c6 05 00 00 00
	00 5c		 mov	 BYTE PTR zip_searchorder, 92 ; 0000005cH
  0002e	c6 05 14 00 00
	00 5c		 mov	 BYTE PTR zip_searchorder+20, 92 ; 0000005cH
  00035	c6 05 28 00 00
	00 5c		 mov	 BYTE PTR zip_searchorder+40, 92 ; 0000005cH
  0003c	0f 84 b4 00 00
	00		 je	 $LN7@PyInit_zip

; 1461 :         /* Reverse *.pyc and *.pyo */
; 1462 :         struct st_zip_searchorder tmp;
; 1463 :         tmp = zip_searchorder[0];

  00042	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR zip_searchorder

; 1464 :         zip_searchorder[0] = zip_searchorder[1];

  00049	8b 05 24 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+36
  0004f	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR zip_searchorder+16
  00055	89 05 10 00 00
	00		 mov	 DWORD PTR zip_searchorder+16, eax

; 1465 :         zip_searchorder[1] = tmp;

  0005b	89 0d 24 00 00
	00		 mov	 DWORD PTR zip_searchorder+36, ecx

; 1466 :         tmp = zip_searchorder[3];

  00061	8b 0d 4c 00 00
	00		 mov	 ecx, DWORD PTR zip_searchorder+76
  00067	0f 11 44 24 30	 movups	 XMMWORD PTR tmp$21450[rsp], xmm0
  0006c	0f 10 05 14 00
	00 00		 movups	 xmm0, XMMWORD PTR zip_searchorder+20
  00073	0f 29 05 00 00
	00 00		 movaps	 XMMWORD PTR zip_searchorder, xmm0

; 1467 :         zip_searchorder[3] = zip_searchorder[4];

  0007a	0f 28 05 50 00
	00 00		 movaps	 xmm0, XMMWORD PTR zip_searchorder+80
  00081	8b 44 24 30	 mov	 eax, DWORD PTR tmp$21450[rsp]
  00085	89 05 14 00 00
	00		 mov	 DWORD PTR zip_searchorder+20, eax
  0008b	8b 44 24 34	 mov	 eax, DWORD PTR tmp$21450[rsp+4]
  0008f	89 05 18 00 00
	00		 mov	 DWORD PTR zip_searchorder+24, eax
  00095	8b 44 24 38	 mov	 eax, DWORD PTR tmp$21450[rsp+8]
  00099	89 05 1c 00 00
	00		 mov	 DWORD PTR zip_searchorder+28, eax
  0009f	8b 44 24 3c	 mov	 eax, DWORD PTR tmp$21450[rsp+12]
  000a3	89 05 20 00 00
	00		 mov	 DWORD PTR zip_searchorder+32, eax
  000a9	8b 05 3c 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+60
  000af	89 44 24 30	 mov	 DWORD PTR tmp$21450[rsp], eax
  000b3	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+64
  000b9	89 44 24 34	 mov	 DWORD PTR tmp$21450[rsp+4], eax
  000bd	8b 05 44 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+68
  000c3	89 44 24 38	 mov	 DWORD PTR tmp$21450[rsp+8], eax
  000c7	8b 05 48 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+72
  000cd	89 44 24 3c	 mov	 DWORD PTR tmp$21450[rsp+12], eax
  000d1	8b 05 60 00 00
	00		 mov	 eax, DWORD PTR zip_searchorder+96
  000d7	0f 11 05 3c 00
	00 00		 movups	 XMMWORD PTR zip_searchorder+60, xmm0

; 1468 :         zip_searchorder[4] = tmp;

  000de	0f 10 44 24 30	 movups	 xmm0, XMMWORD PTR tmp$21450[rsp]
  000e3	89 05 4c 00 00
	00		 mov	 DWORD PTR zip_searchorder+76, eax
  000e9	89 0d 60 00 00
	00		 mov	 DWORD PTR zip_searchorder+96, ecx
  000ef	0f 29 05 50 00
	00 00		 movaps	 XMMWORD PTR zip_searchorder+80, xmm0
$LN7@PyInit_zip:

; 1469 :     }
; 1470 : 
; 1471 :     mod = PyModule_Create(&zipimportmodule);

  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zipimportmodule
  000fd	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00102	e8 00 00 00 00	 call	 PyModule_Create2
  00107	48 8b d8	 mov	 rbx, rax

; 1472 :     if (mod == NULL)

  0010a	48 85 c0	 test	 rax, rax

; 1473 :         return NULL;

  0010d	0f 84 b8 00 00
	00		 je	 $LN16@PyInit_zip

; 1474 : 
; 1475 :     ZipImportError = PyErr_NewException("zipimport.ZipImportError",
; 1476 :                                         PyExc_ImportError, NULL);

  00113	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ImportError
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@NPIJBMBH@zipimport?4ZipImportError?$AA@
  00121	45 33 c0	 xor	 r8d, r8d
  00124	e8 00 00 00 00	 call	 PyErr_NewException
  00129	48 89 05 00 00
	00 00		 mov	 QWORD PTR ZipImportError, rax

; 1477 :     if (ZipImportError == NULL)

  00130	48 85 c0	 test	 rax, rax

; 1478 :         return NULL;

  00133	0f 84 92 00 00
	00		 je	 $LN16@PyInit_zip

; 1479 : 
; 1480 :     Py_INCREF(ZipImportError);

  00139	48 8b c8	 mov	 rcx, rax
  0013c	e8 00 00 00 00	 call	 _Py_IncRef

; 1481 :     if (PyModule_AddObject(mod, "ZipImportError",
; 1482 :                            ZipImportError) < 0)

  00141	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ZipImportError
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@KPLNEBLJ@ZipImportError?$AA@
  0014f	48 8b cb	 mov	 rcx, rbx
  00152	e8 00 00 00 00	 call	 PyModule_AddObject
  00157	85 c0		 test	 eax, eax

; 1483 :         return NULL;

  00159	78 70		 js	 SHORT $LN16@PyInit_zip

; 1484 : 
; 1485 :     Py_INCREF(&ZipImporter_Type);

  0015b	e8 00 00 00 00	 call	 _Py_PXCTX
  00160	85 c0		 test	 eax, eax
  00162	75 3c		 jne	 SHORT $LN12@PyInit_zip
  00164	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:ZipImporter_Type
  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00179	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0017f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00187	e8 00 00 00 00	 call	 _PyParallel_Guard
  0018c	85 c0		 test	 eax, eax
  0018e	75 09		 jne	 SHORT $LN11@PyInit_zip
  00190	f6 05 20 00 00
	00 20		 test	 BYTE PTR ZipImporter_Type+32, 32 ; 00000020H
  00197	74 07		 je	 SHORT $LN12@PyInit_zip
$LN11@PyInit_zip:
  00199	48 ff 05 50 00
	00 00		 inc	 QWORD PTR ZipImporter_Type+80
$LN12@PyInit_zip:

; 1486 :     if (PyModule_AddObject(mod, "zipimporter",
; 1487 :                            (PyObject *)&ZipImporter_Type) < 0)

  001a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ZipImporter_Type
  001a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NDJAEMK@zipimporter?$AA@
  001ae	48 8b cb	 mov	 rcx, rbx
  001b1	e8 00 00 00 00	 call	 PyModule_AddObject
  001b6	85 c0		 test	 eax, eax

; 1488 :         return NULL;

  001b8	78 11		 js	 SHORT $LN16@PyInit_zip

; 1489 : 
; 1490 :     zip_directory_cache = PyDict_New();

  001ba	e8 00 00 00 00	 call	 PyDict_New
  001bf	48 89 05 00 00
	00 00		 mov	 QWORD PTR zip_directory_cache, rax

; 1491 :     if (zip_directory_cache == NULL)

  001c6	48 85 c0	 test	 rax, rax
  001c9	75 0c		 jne	 SHORT $LN2@PyInit_zip
$LN16@PyInit_zip:

; 1492 :         return NULL;

  001cb	33 c0		 xor	 eax, eax
  001cd	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1496 :         return NULL;
; 1497 :     return mod;
; 1498 : }

  001d2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d6	c3		 ret	 0
$LN2@PyInit_zip:

; 1493 :     Py_INCREF(zip_directory_cache);

  001d7	48 8b c8	 mov	 rcx, rax
  001da	e8 00 00 00 00	 call	 _Py_IncRef

; 1494 :     if (PyModule_AddObject(mod, "_zip_directory_cache",
; 1495 :                            zip_directory_cache) < 0)

  001df	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR zip_directory_cache
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@DAAMIGMB@_zip_directory_cache?$AA@
  001ed	48 8b cb	 mov	 rcx, rbx
  001f0	e8 00 00 00 00	 call	 PyModule_AddObject
  001f5	33 c9		 xor	 ecx, ecx
  001f7	85 c0		 test	 eax, eax
  001f9	48 0f 48 d9	 cmovs	 rbx, rcx
  001fd	48 8b c3	 mov	 rax, rbx
  00200	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1496 :         return NULL;
; 1497 :     return mod;
; 1498 : }

  00205	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00209	c3		 ret	 0
PyInit_zipimport ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LMHJOLGJ@?$CFU?$CFc?$AA@		; `string'
PUBLIC	??_C@_0P@CLFECPDE@not?5a?5Zip?5file?$AA@	; `string'
PUBLIC	??_C@_0BB@MIFKEAM@zipimporter_init?$AA@		; `string'
PUBLIC	??_C@_02KJDGAJLC@CC?$AA@			; `string'
PUBLIC	??_C@_0BG@GCDMHENG@archive?5path?5is?5empty?$AA@ ; `string'
PUBLIC	??_C@_0P@DHMMMBMF@O?$CG?3zipimporter?$AA@	; `string'
PUBLIC	??_C@_0O@EEGAHOFH@zipimporter?$CI?$CJ?$AA@	; `string'
EXTRN	PyUnicode_New:PROC
EXTRN	_Py_stat:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyUnicode_FSDecoder:PROC
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_init DD imagerel zipimporter_init
	DD	imagerel zipimporter_init+118
	DD	imagerel $unwind$zipimporter_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$zipimporter_init DD imagerel zipimporter_init+118
	DD	imagerel zipimporter_init+216
	DD	imagerel $chain$1$zipimporter_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$zipimporter_init DD imagerel zipimporter_init+216
	DD	imagerel zipimporter_init+1046
	DD	imagerel $chain$3$zipimporter_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$zipimporter_init DD 040021H
	DD	0116400H
	DD	0105400H
	DD	imagerel zipimporter_init
	DD	imagerel zipimporter_init+118
	DD	imagerel $unwind$zipimporter_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$zipimporter_init DD 041421H
	DD	0116414H
	DD	0105408H
	DD	imagerel zipimporter_init
	DD	imagerel zipimporter_init+118
	DD	imagerel $unwind$zipimporter_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_init DD 040901H
	DD	0c005b209H
	DD	030027003H
xdata	ENDS
;	COMDAT ??_C@_04LMHJOLGJ@?$CFU?$CFc?$AA@
CONST	SEGMENT
??_C@_04LMHJOLGJ@?$CFU?$CFc?$AA@ DB '%U%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CLFECPDE@not?5a?5Zip?5file?$AA@
CONST	SEGMENT
??_C@_0P@CLFECPDE@not?5a?5Zip?5file?$AA@ DB 'not a Zip file', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIFKEAM@zipimporter_init?$AA@
CONST	SEGMENT
??_C@_0BB@MIFKEAM@zipimporter_init?$AA@ DB 'zipimporter_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJDGAJLC@CC?$AA@
CONST	SEGMENT
??_C@_02KJDGAJLC@CC?$AA@ DB 'CC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GCDMHENG@archive?5path?5is?5empty?$AA@
CONST	SEGMENT
??_C@_0BG@GCDMHENG@archive?5path?5is?5empty?$AA@ DB 'archive path is empt'
	DB	'y', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHMMMBMF@O?$CG?3zipimporter?$AA@
CONST	SEGMENT
??_C@_0P@DHMMMBMF@O?$CG?3zipimporter?$AA@ DB 'O&:zipimporter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EEGAHOFH@zipimporter?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@EEGAHOFH@zipimporter?$CI?$CJ?$AA@ DB 'zipimporter()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_init
_TEXT	SEGMENT
statbuf$20321 = 48
self$ = 128
args$ = 136
kwds$ = 144
path$ = 152
zipimporter_init PROC					; COMDAT

; 65   : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00009	4c 8b e1	 mov	 r12, rcx
  0000c	48 8b fa	 mov	 rdi, rdx

; 66   :     PyObject *path, *files, *tmp;
; 67   :     PyObject *filename = NULL;
; 68   :     Py_ssize_t len, flen;
; 69   : #ifdef ALTSEP
; 70   :     _Py_IDENTIFIER(replace);
; 71   : #endif
; 72   : 
; 73   :     if (!_PyArg_NoKeywords("zipimporter()", kwds))

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EEGAHOFH@zipimporter?$CI?$CJ?$AA@
  00016	49 8b d0	 mov	 rdx, r8
  00019	33 db		 xor	 ebx, ebx
  0001b	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00020	85 c0		 test	 eax, eax
  00022	75 0c		 jne	 SHORT $LN34@zipimporte@7
$LN70@zipimporte@7:

; 74   :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 170  : }

  00027	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0002b	41 5c		 pop	 r12
  0002d	5f		 pop	 rdi
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN34@zipimporte@7:

; 75   : 
; 76   :     if (!PyArg_ParseTuple(args, "O&:zipimporter",
; 77   :                           PyUnicode_FSDecoder, &path))

  00030	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR path$[rsp]
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_FSDecoder
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DHMMMBMF@O?$CG?3zipimporter?$AA@
  00046	48 8b cf	 mov	 rcx, rdi
  00049	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0004e	85 c0		 test	 eax, eax

; 78   :         return -1;

  00050	74 d2		 je	 SHORT $LN70@zipimporte@7

; 79   : 
; 80   :     if (PyUnicode_READY(path) == -1)

  00052	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR path$[rsp]
  0005a	41 f6 42 70 80	 test	 BYTE PTR [r10+112], 128	; 00000080H
  0005f	75 15		 jne	 SHORT $LN32@zipimporte@7
  00061	49 8b ca	 mov	 rcx, r10
  00064	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00069	83 f8 ff	 cmp	 eax, -1

; 81   :         return -1;

  0006c	74 b6		 je	 SHORT $LN70@zipimporte@7
  0006e	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR path$[rsp]
$LN32@zipimporte@7:
  00076	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp

; 82   : 
; 83   :     len = PyUnicode_GET_LENGTH(path);

  0007e	49 8b 6a 60	 mov	 rbp, QWORD PTR [r10+96]
  00082	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi

; 84   :     if (len == 0) {

  0008a	48 85 ed	 test	 rbp, rbp
  0008d	75 49		 jne	 SHORT $LN31@zipimporte@7

; 85   :         PyErr_SetString(ZipImportError, "archive path is empty");

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@GCDMHENG@archive?5path?5is?5empty?$AA@
$LN69@zipimporte@7:

; 122  :         PyErr_SetString(ZipImportError, "not a Zip file");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  0009d	e8 00 00 00 00	 call	 PyErr_SetString
$error$20313:

; 165  : 
; 166  : error:
; 167  :     Py_DECREF(path);

  000a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_DecRef

; 168  :     Py_XDECREF(filename);

  000af	48 85 db	 test	 rbx, rbx
  000b2	74 08		 je	 SHORT $LN3@zipimporte@7
  000b4	48 8b cb	 mov	 rcx, rbx
  000b7	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@zipimporte@7:

; 169  :     return -1;

  000bc	83 c8 ff	 or	 eax, -1
$LN67@zipimporte@7:
  000bf	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  000c7	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]

; 170  : }

  000cf	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000d3	41 5c		 pop	 r12
  000d5	5f		 pop	 rdi
  000d6	5b		 pop	 rbx
  000d7	c3		 ret	 0
$LN31@zipimporte@7:

; 86   :         goto error;
; 87   :     }
; 88   : 
; 89   : #ifdef ALTSEP
; 90   :     tmp = _PyObject_CallMethodId(path, &PyId_replace, "CC", ALTSEP, SEP);

  000d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000de	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000e7	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_replace@?1??zipimporter_init@@9@9
  000ec	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02KJDGAJLC@CC?$AA@
  000f7	41 b9 2f 00 00
	00		 mov	 r9d, 47			; 0000002fH
  000fd	49 8b ca	 mov	 rcx, r10
  00100	c7 44 24 20 5c
	00 00 00	 mov	 DWORD PTR [rsp+32], 92	; 0000005cH
  00108	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0010d	48 8b f8	 mov	 rdi, rax

; 91   :     if (!tmp)

  00110	48 85 c0	 test	 rax, rax
  00113	74 8d		 je	 SHORT $error$20313

; 92   :         goto error;
; 93   :     Py_DECREF(path);

  00115	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0011d	e8 00 00 00 00	 call	 _Py_DecRef

; 94   :     path = tmp;
; 95   : #endif
; 96   : 
; 97   :     filename = path;
; 98   :     Py_INCREF(filename);

  00122	48 8b cf	 mov	 rcx, rdi
  00125	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR path$[rsp], rdi
  0012d	48 8b df	 mov	 rbx, rdi
  00130	e8 00 00 00 00	 call	 _Py_IncRef

; 99   :     flen = len;
; 100  :     for (;;) {
; 101  :         struct stat statbuf;
; 102  :         int rv;
; 103  : 
; 104  :         rv = _Py_stat(filename, &statbuf);

  00135	48 8d 54 24 30	 lea	 rdx, QWORD PTR statbuf$20321[rsp]
  0013a	48 8b cf	 mov	 rcx, rdi
  0013d	48 8b f5	 mov	 rsi, rbp
  00140	e8 00 00 00 00	 call	 _Py_stat

; 105  :         if (rv == -2)

  00145	83 f8 fe	 cmp	 eax, -2
  00148	0f 84 54 ff ff
	ff		 je	 $error$20313
  0014e	66 90		 npad	 2
$LL29@zipimporte@7:

; 107  :         if (rv == 0) {

  00150	85 c0		 test	 eax, eax
  00152	0f 84 93 00 00
	00		 je	 $LN60@zipimporte@7

; 112  :             break;
; 113  :         }
; 114  :         Py_CLEAR(filename);

  00158	48 85 db	 test	 rbx, rbx
  0015b	74 32		 je	 SHORT $LN19@zipimporte@7
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MIFKEAM@zipimporter_init?$AA@
  0016b	4c 8b cb	 mov	 r9, rbx
  0016e	41 b8 72 00 00
	00		 mov	 r8d, 114		; 00000072H
  00174	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00181	85 c0		 test	 eax, eax
  00183	75 0a		 jne	 SHORT $LN19@zipimporte@7
  00185	48 8b cb	 mov	 rcx, rbx
  00188	33 db		 xor	 ebx, ebx
  0018a	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@zipimporte@7:

; 115  :         /* back up one path element */
; 116  :         flen = PyUnicode_FindChar(path, SEP, 0, flen, -1);

  0018f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00197	45 33 c0	 xor	 r8d, r8d
  0019a	4c 8b ce	 mov	 r9, rsi
  0019d	41 8d 50 5c	 lea	 edx, QWORD PTR [r8+92]
  001a1	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  001a9	e8 00 00 00 00	 call	 PyUnicode_FindChar
  001ae	48 8b f0	 mov	 rsi, rax

; 117  :         if (flen == -1)

  001b1	48 83 f8 ff	 cmp	 rax, -1
  001b5	0f 84 8e 00 00
	00		 je	 $LN22@zipimporte@7

; 118  :             break;
; 119  :         filename = PyUnicode_Substring(path, 0, flen);

  001bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  001c3	4c 8b c0	 mov	 r8, rax
  001c6	33 d2		 xor	 edx, edx
  001c8	e8 00 00 00 00	 call	 PyUnicode_Substring
  001cd	48 8d 54 24 30	 lea	 rdx, QWORD PTR statbuf$20321[rsp]
  001d2	48 8b c8	 mov	 rcx, rax
  001d5	48 8b d8	 mov	 rbx, rax
  001d8	e8 00 00 00 00	 call	 _Py_stat
  001dd	83 f8 fe	 cmp	 eax, -2
  001e0	0f 85 6a ff ff
	ff		 jne	 $LL29@zipimporte@7

; 106  :             goto error;

  001e6	e9 b7 fe ff ff	 jmp	 $error$20313
$LN60@zipimporte@7:

; 108  :             /* it exists */
; 109  :             if (!S_ISREG(statbuf.st_mode))

  001eb	0f b7 44 24 36	 movzx	 eax, WORD PTR statbuf$20321[rsp+6]
  001f0	41 b8 00 f0 00
	00		 mov	 r8d, 61440		; 0000f000H
  001f6	66 41 23 c0	 and	 ax, r8w
  001fa	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00200	66 41 3b c0	 cmp	 ax, r8w
  00204	74 43		 je	 SHORT $LN22@zipimporte@7

; 110  :                 /* it's a not file */
; 111  :                 Py_CLEAR(filename);

  00206	48 85 db	 test	 rbx, rbx
  00209	74 43		 je	 SHORT $LN63@zipimporte@7
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MIFKEAM@zipimporter_init?$AA@
  00219	4c 8b cb	 mov	 r9, rbx
  0021c	41 b8 6f 00 00
	00		 mov	 r8d, 111		; 0000006fH
  00222	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0022a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0022f	85 c0		 test	 eax, eax
  00231	75 16		 jne	 SHORT $LN22@zipimporte@7
  00233	48 8b cb	 mov	 rcx, rbx
  00236	33 db		 xor	 ebx, ebx
  00238	e8 00 00 00 00	 call	 _Py_DecRef

; 122  :         PyErr_SetString(ZipImportError, "not a Zip file");

  0023d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CLFECPDE@not?5a?5Zip?5file?$AA@

; 123  :         goto error;

  00244	e9 4d fe ff ff	 jmp	 $LN69@zipimporte@7
$LN22@zipimporte@7:

; 120  :     }
; 121  :     if (filename == NULL) {

  00249	48 85 db	 test	 rbx, rbx
  0024c	75 0c		 jne	 SHORT $LN15@zipimporte@7
$LN63@zipimporte@7:

; 122  :         PyErr_SetString(ZipImportError, "not a Zip file");

  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@CLFECPDE@not?5a?5Zip?5file?$AA@

; 123  :         goto error;

  00255	e9 3c fe ff ff	 jmp	 $LN69@zipimporte@7
$LN15@zipimporte@7:

; 124  :     }
; 125  : 
; 126  :     if (PyUnicode_READY(filename) < 0)

  0025a	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0025e	75 10		 jne	 SHORT $LN64@zipimporte@7
  00260	48 8b cb	 mov	 rcx, rbx
  00263	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00268	85 c0		 test	 eax, eax
  0026a	0f 88 32 fe ff
	ff		 js	 $error$20313
$LN64@zipimporte@7:

; 127  :         goto error;
; 128  : 
; 129  :     files = PyDict_GetItem(zip_directory_cache, filename);

  00270	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR zip_directory_cache
  00277	48 8b d3	 mov	 rdx, rbx
  0027a	e8 00 00 00 00	 call	 PyDict_GetItem
  0027f	48 8b f8	 mov	 rdi, rax

; 130  :     if (files == NULL) {

  00282	48 85 c0	 test	 rax, rax
  00285	75 30		 jne	 SHORT $LN13@zipimporte@7

; 131  :         files = read_directory(filename);

  00287	48 8b cb	 mov	 rcx, rbx
  0028a	e8 00 00 00 00	 call	 read_directory
  0028f	48 8b f8	 mov	 rdi, rax

; 132  :         if (files == NULL)

  00292	48 85 c0	 test	 rax, rax
  00295	0f 84 07 fe ff
	ff		 je	 $error$20313

; 133  :             goto error;
; 134  :         if (PyDict_SetItem(zip_directory_cache, filename, files) != 0)

  0029b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR zip_directory_cache
  002a2	4c 8b c0	 mov	 r8, rax
  002a5	48 8b d3	 mov	 rdx, rbx
  002a8	e8 00 00 00 00	 call	 PyDict_SetItem
  002ad	85 c0		 test	 eax, eax
  002af	0f 85 ed fd ff
	ff		 jne	 $error$20313

; 135  :             goto error;
; 136  :     }
; 137  :     else

  002b5	eb 08		 jmp	 SHORT $LN10@zipimporte@7
$LN13@zipimporte@7:

; 138  :         Py_INCREF(files);

  002b7	48 8b c8	 mov	 rcx, rax
  002ba	e8 00 00 00 00	 call	 _Py_IncRef
$LN10@zipimporte@7:

; 139  :     self->files = files;
; 140  : 
; 141  :     /* Transfer reference */
; 142  :     self->archive = filename;

  002bf	49 89 5c 24 60	 mov	 QWORD PTR [r12+96], rbx

; 143  :     filename = NULL;

  002c4	33 db		 xor	 ebx, ebx
  002c6	49 89 7c 24 70	 mov	 QWORD PTR [r12+112], rdi

; 144  : 
; 145  :     /* Check if there is a prefix directory following the filename. */
; 146  :     if (flen != len) {

  002cb	48 3b f5	 cmp	 rsi, rbp
  002ce	0f 84 20 01 00
	00		 je	 $LN9@zipimporte@7

; 147  :         tmp = PyUnicode_Substring(path, flen+1,
; 148  :                                   PyUnicode_GET_LENGTH(path));

  002d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  002dc	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
  002e0	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  002e4	e8 00 00 00 00	 call	 PyUnicode_Substring
  002e9	4c 8b d8	 mov	 r11, rax

; 149  :         if (tmp == NULL)

  002ec	48 85 c0	 test	 rax, rax
  002ef	0f 84 ad fd ff
	ff		 je	 $error$20313

; 150  :             goto error;
; 151  :         self->prefix = tmp;
; 152  :         if (PyUnicode_READ_CHAR(path, len-1) != SEP) {

  002f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  002fd	49 89 44 24 68	 mov	 QWORD PTR [r12+104], rax
  00302	8b 51 70	 mov	 edx, DWORD PTR [rcx+112]
  00305	44 8b c2	 mov	 r8d, edx
  00308	41 c1 e8 02	 shr	 r8d, 2
  0030c	41 83 e0 07	 and	 r8d, 7
  00310	41 83 f8 01	 cmp	 r8d, 1
  00314	75 34		 jne	 SHORT $LN55@zipimporte@7
  00316	f6 c2 20	 test	 dl, 32			; 00000020H
  00319	74 21		 je	 SHORT $LN43@zipimporte@7
  0031b	f6 c2 40	 test	 dl, 64			; 00000040H
  0031e	74 0e		 je	 SHORT $LN41@zipimporte@7
  00320	0f b6 54 29 7f	 movzx	 edx, BYTE PTR [rcx+rbp+127]
  00325	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  0032c	eb 7d		 jmp	 SHORT $LN54@zipimporte@7
$LN41@zipimporte@7:
  0032e	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00335	0f b6 54 28 ff	 movzx	 edx, BYTE PTR [rax+rbp-1]
  0033a	eb 6f		 jmp	 SHORT $LN54@zipimporte@7
$LN43@zipimporte@7:
  0033c	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00343	0f b6 54 28 ff	 movzx	 edx, BYTE PTR [rax+rbp-1]
  00348	eb 61		 jmp	 SHORT $LN54@zipimporte@7
$LN55@zipimporte@7:
  0034a	41 83 f8 02	 cmp	 r8d, 2
  0034e	75 34		 jne	 SHORT $LN53@zipimporte@7
  00350	f6 c2 20	 test	 dl, 32			; 00000020H
  00353	74 21		 je	 SHORT $LN47@zipimporte@7
  00355	f6 c2 40	 test	 dl, 64			; 00000040H
  00358	74 0e		 je	 SHORT $LN45@zipimporte@7
  0035a	0f b7 54 69 7e	 movzx	 edx, WORD PTR [rcx+rbp*2+126]
  0035f	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00366	eb 43		 jmp	 SHORT $LN54@zipimporte@7
$LN45@zipimporte@7:
  00368	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0036f	0f b7 54 68 fe	 movzx	 edx, WORD PTR [rax+rbp*2-2]
  00374	eb 35		 jmp	 SHORT $LN54@zipimporte@7
$LN47@zipimporte@7:
  00376	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  0037d	0f b7 54 68 fe	 movzx	 edx, WORD PTR [rax+rbp*2-2]
  00382	eb 27		 jmp	 SHORT $LN54@zipimporte@7
$LN53@zipimporte@7:
  00384	f6 c2 20	 test	 dl, 32			; 00000020H
  00387	74 17		 je	 SHORT $LN51@zipimporte@7
  00389	f6 c2 40	 test	 dl, 64			; 00000040H
  0038c	74 09		 je	 SHORT $LN49@zipimporte@7
  0038e	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  00395	eb 10		 jmp	 SHORT $LN52@zipimporte@7
$LN49@zipimporte@7:
  00397	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0039e	eb 07		 jmp	 SHORT $LN52@zipimporte@7
$LN51@zipimporte@7:
  003a0	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN52@zipimporte@7:
  003a7	8b 54 a8 fc	 mov	 edx, DWORD PTR [rax+rbp*4-4]
$LN54@zipimporte@7:
  003ab	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  003ae	74 5a		 je	 SHORT $LN5@zipimporte@7

; 153  :             /* add trailing SEP */
; 154  :             tmp = PyUnicode_FromFormat("%U%c", self->prefix, SEP);

  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LMHJOLGJ@?$CFU?$CFc?$AA@
  003b7	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  003bd	49 8b d3	 mov	 rdx, r11
  003c0	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  003c5	48 8b f8	 mov	 rdi, rax

; 155  :             if (tmp == NULL)

  003c8	48 85 c0	 test	 rax, rax
  003cb	0f 84 d1 fc ff
	ff		 je	 $error$20313

; 156  :                 goto error;
; 157  :             Py_DECREF(self->prefix);

  003d1	49 8b 4c 24 68	 mov	 rcx, QWORD PTR [r12+104]
  003d6	e8 00 00 00 00	 call	 _Py_DecRef

; 158  :             self->prefix = tmp;
; 159  :         }
; 160  :     }
; 161  :     else
; 162  :         self->prefix = PyUnicode_New(0, 0);

  003db	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  003e3	49 89 7c 24 68	 mov	 QWORD PTR [r12+104], rdi

; 163  :     Py_DECREF(path);

  003e8	e8 00 00 00 00	 call	 _Py_DecRef

; 164  :     return 0;

  003ed	33 c0		 xor	 eax, eax
  003ef	e9 cb fc ff ff	 jmp	 $LN67@zipimporte@7
$LN9@zipimporte@7:

; 158  :             self->prefix = tmp;
; 159  :         }
; 160  :     }
; 161  :     else
; 162  :         self->prefix = PyUnicode_New(0, 0);

  003f4	33 d2		 xor	 edx, edx
  003f6	33 c9		 xor	 ecx, ecx
  003f8	e8 00 00 00 00	 call	 PyUnicode_New
  003fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00405	49 89 44 24 68	 mov	 QWORD PTR [r12+104], rax
$LN5@zipimporte@7:

; 163  :     Py_DECREF(path);

  0040a	e8 00 00 00 00	 call	 _Py_DecRef

; 164  :     return 0;

  0040f	33 c0		 xor	 eax, eax
  00411	e9 a9 fc ff ff	 jmp	 $LN67@zipimporte@7
zipimporter_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@JMKOBLEO@import?5?$CFU?5?$CD?5loaded?5from?5Zip?5?$CFU?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@GGBGEOMG@zipimporter_load_module?$AA@	; `string'
PUBLIC	??_C@_08LPNIDJLN@__path__?$AA@			; `string'
PUBLIC	??_C@_03LHKGCLJD@?$FLN?$FN?$AA@			; `string'
PUBLIC	??_C@_0L@PADOMILC@__loader__?$AA@		; `string'
PUBLIC	??_C@_0BK@PKAMEPJP@U?3zipimporter?4load_module?$AA@ ; `string'
EXTRN	PyImport_ExecCodeModuleObject:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyImport_AddModuleObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_load_module DD imagerel zipimporter_load_module
	DD	imagerel zipimporter_load_module+495
	DD	imagerel $unwind$zipimporter_load_module
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_load_module DD 0a7301H
	DD	06c473H
	DD	07746eH
	DD	08645cH
	DD	093457H
	DD	050029206H
xdata	ENDS
;	COMDAT ??_C@_0CA@JMKOBLEO@import?5?$CFU?5?$CD?5loaded?5from?5Zip?5?$CFU?6?$AA@
CONST	SEGMENT
??_C@_0CA@JMKOBLEO@import?5?$CFU?5?$CD?5loaded?5from?5Zip?5?$CFU?6?$AA@ DB 'i'
	DB	'mport %U # loaded from Zip %U', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GGBGEOMG@zipimporter_load_module?$AA@
CONST	SEGMENT
??_C@_0BI@GGBGEOMG@zipimporter_load_module?$AA@ DB 'zipimporter_load_modu'
	DB	'le', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08LPNIDJLN@__path__?$AA@
CONST	SEGMENT
??_C@_08LPNIDJLN@__path__?$AA@ DB '__path__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LHKGCLJD@?$FLN?$FN?$AA@
CONST	SEGMENT
??_C@_03LHKGCLJD@?$FLN?$FN?$AA@ DB '[N]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PADOMILC@__loader__?$AA@
CONST	SEGMENT
??_C@_0L@PADOMILC@__loader__?$AA@ DB '__loader__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PKAMEPJP@U?3zipimporter?4load_module?$AA@
CONST	SEGMENT
??_C@_0BK@PKAMEPJP@U?3zipimporter?4load_module?$AA@ DB 'U:zipimporter.loa'
	DB	'd_module', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_load_module
_TEXT	SEGMENT
ispackage$ = 96
obj$ = 96
args$ = 104
fullname$ = 112
modpath$ = 120
zipimporter_load_module PROC				; COMDAT

; 443  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b e9	 mov	 rbp, rcx

; 444  :     ZipImporter *self = (ZipImporter *)obj;
; 445  :     PyObject *code = NULL, *mod, *dict;
; 446  :     PyObject *fullname;
; 447  :     PyObject *modpath = NULL;
; 448  :     int ispackage;
; 449  : 
; 450  :     if (!PyArg_ParseTuple(args, "U:zipimporter.load_module",
; 451  :                           &fullname))

  0000c	4c 8d 44 24 70	 lea	 r8, QWORD PTR fullname$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PKAMEPJP@U?3zipimporter?4load_module?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR modpath$[rsp], 0
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 08		 jne	 SHORT $LN23@zipimporte@8
$LN33@zipimporte@8:

; 452  :         return NULL;

  0002d	33 c0		 xor	 eax, eax

; 505  : }

  0002f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00033	5d		 pop	 rbp
  00034	c3		 ret	 0
$LN23@zipimporte@8:

; 453  :     if (PyUnicode_READY(fullname) == -1)

  00035	48 8b 54 24 70	 mov	 rdx, QWORD PTR fullname$[rsp]
  0003a	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0003e	75 12		 jne	 SHORT $LN22@zipimporte@8
  00040	48 8b ca	 mov	 rcx, rdx
  00043	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00048	83 f8 ff	 cmp	 eax, -1

; 454  :         return NULL;

  0004b	74 e0		 je	 SHORT $LN33@zipimporte@8
  0004d	48 8b 54 24 70	 mov	 rdx, QWORD PTR fullname$[rsp]
$LN22@zipimporte@8:
  00052	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00057	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 455  : 
; 456  :     code = get_module_code(self, fullname, &ispackage, &modpath);

  0005c	4c 8d 4c 24 78	 lea	 r9, QWORD PTR modpath$[rsp]
  00061	4c 8d 44 24 60	 lea	 r8, QWORD PTR ispackage$[rsp]
  00066	48 8b cd	 mov	 rcx, rbp
  00069	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0006e	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00073	e8 00 00 00 00	 call	 get_module_code

; 457  :     if (code == NULL)

  00078	48 8b 7c 24 78	 mov	 rdi, QWORD PTR modpath$[rsp]
  0007d	48 8b f0	 mov	 rsi, rax
  00080	48 85 c0	 test	 rax, rax
  00083	0f 84 3d 01 00
	00		 je	 $LN7@zipimporte@8

; 458  :         goto error;
; 459  : 
; 460  :     mod = PyImport_AddModuleObject(fullname);

  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fullname$[rsp]
  0008e	e8 00 00 00 00	 call	 PyImport_AddModuleObject

; 461  :     if (mod == NULL)

  00093	48 85 c0	 test	 rax, rax
  00096	0f 84 1d 01 00
	00		 je	 $error$20689

; 462  :         goto error;
; 463  :     dict = PyModule_GetDict(mod);

  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 PyModule_GetDict

; 464  : 
; 465  :     /* mod.__loader__ = self */
; 466  :     if (PyDict_SetItemString(dict, "__loader__", (PyObject *)self) != 0)

  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@PADOMILC@__loader__?$AA@
  000ab	4c 8b c5	 mov	 r8, rbp
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	4c 8b e0	 mov	 r12, rax
  000b4	e8 00 00 00 00	 call	 PyDict_SetItemString
  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 f8 00 00
	00		 jne	 $error$20689

; 467  :         goto error;
; 468  : 
; 469  :     if (ispackage) {

  000c1	39 44 24 60	 cmp	 DWORD PTR ispackage$[rsp], eax
  000c5	74 7b		 je	 SHORT $LN15@zipimporte@8

; 470  :         /* add __path__ to the module *before* the code gets
; 471  :            executed */
; 472  :         PyObject *pkgpath, *fullpath;
; 473  :         PyObject *subname = get_subname(fullname);

  000c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fullname$[rsp]
  000cc	e8 00 00 00 00	 call	 get_subname

; 474  :         int err;
; 475  : 
; 476  :         fullpath = PyUnicode_FromFormat("%U%c%U%U",
; 477  :                                 self->archive, SEP,
; 478  :                                 self->prefix, subname);

  000d1	4c 8b 4d 68	 mov	 r9, QWORD PTR [rbp+104]
  000d5	48 8b 55 60	 mov	 rdx, QWORD PTR [rbp+96]
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NDALMICO@?$CFU?$CFc?$CFU?$CFU?$AA@
  000e0	41 b8 5c 00 00
	00		 mov	 r8d, 92			; 0000005cH
  000e6	48 8b d8	 mov	 rbx, rax
  000e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ee	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 479  :         Py_DECREF(subname);

  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	48 8b e8	 mov	 rbp, rax
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 480  :         if (fullpath == NULL)

  000fe	48 85 ed	 test	 rbp, rbp
  00101	0f 84 b2 00 00
	00		 je	 $error$20689

; 481  :             goto error;
; 482  : 
; 483  :         pkgpath = Py_BuildValue("[N]", fullpath);

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LHKGCLJD@?$FLN?$FN?$AA@
  0010e	48 8b d5	 mov	 rdx, rbp
  00111	e8 00 00 00 00	 call	 Py_BuildValue
  00116	48 8b e8	 mov	 rbp, rax

; 484  :         if (pkgpath == NULL)

  00119	48 85 c0	 test	 rax, rax
  0011c	0f 84 97 00 00
	00		 je	 $error$20689

; 485  :             goto error;
; 486  :         err = PyDict_SetItemString(dict, "__path__", pkgpath);

  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LPNIDJLN@__path__?$AA@
  00129	4c 8b c0	 mov	 r8, rax
  0012c	49 8b cc	 mov	 rcx, r12
  0012f	e8 00 00 00 00	 call	 PyDict_SetItemString

; 487  :         Py_DECREF(pkgpath);

  00134	48 8b cd	 mov	 rcx, rbp
  00137	8b d8		 mov	 ebx, eax
  00139	e8 00 00 00 00	 call	 _Py_DecRef

; 488  :         if (err != 0)

  0013e	85 db		 test	 ebx, ebx
  00140	75 77		 jne	 SHORT $error$20689
$LN15@zipimporte@8:

; 489  :             goto error;
; 490  :     }
; 491  :     mod = PyImport_ExecCodeModuleObject(fullname, code, modpath, NULL);

  00142	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fullname$[rsp]
  00147	45 33 c9	 xor	 r9d, r9d
  0014a	4c 8b c7	 mov	 r8, rdi
  0014d	48 8b d6	 mov	 rdx, rsi
  00150	e8 00 00 00 00	 call	 PyImport_ExecCodeModuleObject

; 492  :     Py_CLEAR(code);

  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@DCMIAMFE@?4?4?2Modules?2zipimport?4c?$AA@
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@GGBGEOMG@zipimporter_load_module?$AA@
  00163	4c 8b ce	 mov	 r9, rsi
  00166	41 b8 ec 01 00
	00		 mov	 r8d, 492		; 000001ecH
  0016c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00174	48 8b d8	 mov	 rbx, rax
  00177	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017c	85 c0		 test	 eax, eax
  0017e	75 0a		 jne	 SHORT $LN13@zipimporte@8
  00180	48 8b ce	 mov	 rcx, rsi
  00183	33 f6		 xor	 esi, esi
  00185	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@zipimporte@8:

; 493  :     if (mod == NULL)

  0018a	48 85 db	 test	 rbx, rbx
  0018d	74 2a		 je	 SHORT $error$20689

; 494  :         goto error;
; 495  : 
; 496  :     if (Py_VerboseFlag)

  0018f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_VerboseFlag, 0
  00196	74 14		 je	 SHORT $LN9@zipimporte@8

; 497  :         PySys_FormatStderr("import %U # loaded from Zip %U\n",
; 498  :                            fullname, modpath);

  00198	48 8b 54 24 70	 mov	 rdx, QWORD PTR fullname$[rsp]
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JMKOBLEO@import?5?$CFU?5?$CD?5loaded?5from?5Zip?5?$CFU?6?$AA@
  001a4	4c 8b c7	 mov	 r8, rdi
  001a7	e8 00 00 00 00	 call	 PySys_FormatStderr
$LN9@zipimporte@8:

; 499  :     Py_DECREF(modpath);

  001ac	48 8b cf	 mov	 rcx, rdi
  001af	e8 00 00 00 00	 call	 _Py_DecRef

; 500  :     return mod;

  001b4	48 8b c3	 mov	 rax, rbx
  001b7	eb 1c		 jmp	 SHORT $LN32@zipimporte@8
$error$20689:

; 501  : error:
; 502  :     Py_XDECREF(code);

  001b9	48 85 f6	 test	 rsi, rsi
  001bc	74 08		 je	 SHORT $LN7@zipimporte@8
  001be	48 8b ce	 mov	 rcx, rsi
  001c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@zipimporte@8:

; 503  :     Py_XDECREF(modpath);

  001c6	48 85 ff	 test	 rdi, rdi
  001c9	74 08		 je	 SHORT $LN3@zipimporte@8
  001cb	48 8b cf	 mov	 rcx, rdi
  001ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@zipimporte@8:

; 504  :     return NULL;

  001d3	33 c0		 xor	 eax, eax
$LN32@zipimporte@8:
  001d5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  001da	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001df	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001e4	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 505  : }

  001e9	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ed	5d		 pop	 rbp
  001ee	c3		 ret	 0
zipimporter_load_module ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@CNKJMFEB@U?3zipimporter?4get_filename?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_get_filename DD imagerel zipimporter_get_filename
	DD	imagerel zipimporter_get_filename+91
	DD	imagerel $unwind$zipimporter_get_filename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_get_filename DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BL@CNKJMFEB@U?3zipimporter?4get_filename?$AA@
CONST	SEGMENT
??_C@_0BL@CNKJMFEB@U?3zipimporter?4get_filename?$AA@ DB 'U:zipimporter.ge'
	DB	't_filename', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_get_filename
_TEXT	SEGMENT
ispackage$ = 48
obj$ = 48
args$ = 56
fullname$ = 64
modpath$ = 72
zipimporter_get_filename PROC				; COMDAT

; 510  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 511  :     ZipImporter *self = (ZipImporter *)obj;
; 512  :     PyObject *fullname, *code, *modpath;
; 513  :     int ispackage;
; 514  : 
; 515  :     if (!PyArg_ParseTuple(args, "U:zipimporter.get_filename",
; 516  :                           &fullname))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR fullname$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@CNKJMFEB@U?3zipimporter?4get_filename?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN2@zipimporte@9
$LN5@zipimporte@9:

; 517  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 527  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN2@zipimporte@9:

; 518  : 
; 519  :     /* Deciding the filename requires working out where the code
; 520  :        would come from if the module was actually loaded */
; 521  :     code = get_module_code(self, fullname, &ispackage, &modpath);

  0002c	48 8b 54 24 40	 mov	 rdx, QWORD PTR fullname$[rsp]
  00031	4c 8d 4c 24 48	 lea	 r9, QWORD PTR modpath$[rsp]
  00036	4c 8d 44 24 30	 lea	 r8, QWORD PTR ispackage$[rsp]
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 get_module_code

; 522  :     if (code == NULL)

  00043	48 85 c0	 test	 rax, rax

; 523  :         return NULL;

  00046	74 dc		 je	 SHORT $LN5@zipimporte@9

; 524  :     Py_DECREF(code); /* Only need the path info */

  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 _Py_DecRef

; 525  : 
; 526  :     return modpath;

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR modpath$[rsp]

; 527  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
zipimporter_get_filename ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@OGNKJCMP@U?3zipimporter?4get_data?$AA@ ; `string'
EXTRN	PyErr_SetFromErrnoWithFilenameObject:PROC
EXTRN	PyUnicode_Tailmatch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_get_data DD imagerel zipimporter_get_data
	DD	imagerel zipimporter_get_data+113
	DD	imagerel $unwind$zipimporter_get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$zipimporter_get_data DD imagerel zipimporter_get_data+113
	DD	imagerel zipimporter_get_data+161
	DD	imagerel $chain$1$zipimporter_get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$zipimporter_get_data DD imagerel zipimporter_get_data+161
	DD	imagerel zipimporter_get_data+386
	DD	imagerel $chain$2$zipimporter_get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$zipimporter_get_data DD imagerel zipimporter_get_data+386
	DD	imagerel zipimporter_get_data+457
	DD	imagerel $chain$3$zipimporter_get_data
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$zipimporter_get_data DD imagerel zipimporter_get_data+457
	DD	imagerel zipimporter_get_data+503
	DD	imagerel $chain$5$zipimporter_get_data
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$zipimporter_get_data DD 040021H
	DD	0b7400H
	DD	093400H
	DD	imagerel zipimporter_get_data
	DD	imagerel zipimporter_get_data+113
	DD	imagerel $unwind$zipimporter_get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$zipimporter_get_data DD 021H
	DD	imagerel zipimporter_get_data+113
	DD	imagerel zipimporter_get_data+161
	DD	imagerel $chain$1$zipimporter_get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$zipimporter_get_data DD 020521H
	DD	0a5405H
	DD	imagerel zipimporter_get_data+113
	DD	imagerel zipimporter_get_data+161
	DD	imagerel $chain$1$zipimporter_get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$zipimporter_get_data DD 040a21H
	DD	0b740aH
	DD	093405H
	DD	imagerel zipimporter_get_data
	DD	imagerel zipimporter_get_data+113
	DD	imagerel $unwind$zipimporter_get_data
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_get_data DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BH@OGNKJCMP@U?3zipimporter?4get_data?$AA@
CONST	SEGMENT
??_C@_0BH@OGNKJCMP@U?3zipimporter?4get_data?$AA@ DB 'U:zipimporter.get_da'
	DB	'ta', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_get_data
_TEXT	SEGMENT
path$ = 64
obj$ = 64
args$ = 72
zipimporter_get_data PROC				; COMDAT

; 554  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b f1	 mov	 rsi, rcx

; 555  :     ZipImporter *self = (ZipImporter *)obj;
; 556  :     PyObject *path, *key;
; 557  : #ifdef ALTSEP
; 558  :     _Py_IDENTIFIER(replace);
; 559  : #endif
; 560  :     PyObject *toc_entry;
; 561  :     Py_ssize_t path_start, path_len, len;
; 562  : 
; 563  :     if (!PyArg_ParseTuple(args, "U:zipimporter.get_data", &path))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR path$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@OGNKJCMP@U?3zipimporter?4get_data?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN6@zipimporte@10
$LN30@zipimporte@10:

; 564  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 600  : }

  00026	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002a	5e		 pop	 rsi
  0002b	c3		 ret	 0
$LN6@zipimporte@10:

; 565  : 
; 566  : #ifdef ALTSEP
; 567  :     path = _PyObject_CallMethodId(path, &PyId_replace, "CC", ALTSEP, SEP);

  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0003b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_replace@?1??zipimporter_get_data@@9@9
  00040	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00049	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02KJDGAJLC@CC?$AA@
  00050	41 b9 2f 00 00
	00		 mov	 r9d, 47			; 0000002fH
  00056	c7 44 24 20 5c
	00 00 00	 mov	 DWORD PTR [rsp+32], 92	; 0000005cH
  0005e	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00063	48 89 44 24 40	 mov	 QWORD PTR path$[rsp], rax

; 568  :     if (!path)

  00068	48 85 c0	 test	 rax, rax

; 569  :         return NULL;

  0006b	74 b7		 je	 SHORT $LN30@zipimporte@10

; 570  : #else
; 571  :     Py_INCREF(path);
; 572  : #endif
; 573  :     if (PyUnicode_READY(path) == -1)

  0006d	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00071	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00076	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  0007b	75 16		 jne	 SHORT $LN27@zipimporte@10
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00085	83 f8 ff	 cmp	 eax, -1
  00088	0f 84 1f 01 00
	00		 je	 $error$20797
  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR path$[rsp]
$LN27@zipimporte@10:

; 574  :         goto error;
; 575  : 
; 576  :     path_len = PyUnicode_GET_LENGTH(path);
; 577  : 
; 578  :     len = PyUnicode_GET_LENGTH(self->archive);

  00093	48 8b 56 60	 mov	 rdx, QWORD PTR [rsi+96]

; 579  :     path_start = 0;
; 580  :     if (PyUnicode_Tailmatch(path, self->archive, 0, len, -1)
; 581  :         && PyUnicode_READ_CHAR(path, len) == SEP) {

  00097	45 33 c0	 xor	 r8d, r8d
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	48 8b 5a 60	 mov	 rbx, QWORD PTR [rdx+96]
  000a1	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  000a6	48 8b 68 60	 mov	 rbp, QWORD PTR [rax+96]
  000aa	4c 8b cb	 mov	 r9, rbx
  000ad	33 ff		 xor	 edi, edi
  000af	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  000b7	e8 00 00 00 00	 call	 PyUnicode_Tailmatch
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  000c1	48 85 c0	 test	 rax, rax
  000c4	0f 84 a0 00 00
	00		 je	 $LN3@zipimporte@10
  000ca	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  000cd	8b d0		 mov	 edx, eax
  000cf	c1 ea 02	 shr	 edx, 2
  000d2	83 e2 07	 and	 edx, 7
  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 2f		 jne	 SHORT $LN25@zipimporte@10
  000da	a8 20		 test	 al, 32			; 00000020H
  000dc	74 1e		 je	 SHORT $LN13@zipimporte@10
  000de	a8 40		 test	 al, 64			; 00000040H
  000e0	74 0d		 je	 SHORT $LN11@zipimporte@10
  000e2	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  000e9	0f b6 14 18	 movzx	 edx, BYTE PTR [rax+rbx]
  000ed	eb 72		 jmp	 SHORT $LN24@zipimporte@10
$LN11@zipimporte@10:
  000ef	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  000f6	0f b6 14 18	 movzx	 edx, BYTE PTR [rax+rbx]
  000fa	eb 65		 jmp	 SHORT $LN24@zipimporte@10
$LN13@zipimporte@10:
  000fc	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00103	0f b6 14 18	 movzx	 edx, BYTE PTR [rax+rbx]
  00107	eb 58		 jmp	 SHORT $LN24@zipimporte@10
$LN25@zipimporte@10:
  00109	83 fa 02	 cmp	 edx, 2
  0010c	75 2f		 jne	 SHORT $LN23@zipimporte@10
  0010e	a8 20		 test	 al, 32			; 00000020H
  00110	74 1e		 je	 SHORT $LN17@zipimporte@10
  00112	a8 40		 test	 al, 64			; 00000040H
  00114	74 0d		 je	 SHORT $LN15@zipimporte@10
  00116	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  0011d	0f b7 14 58	 movzx	 edx, WORD PTR [rax+rbx*2]
  00121	eb 3e		 jmp	 SHORT $LN24@zipimporte@10
$LN15@zipimporte@10:
  00123	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  0012a	0f b7 14 58	 movzx	 edx, WORD PTR [rax+rbx*2]
  0012e	eb 31		 jmp	 SHORT $LN24@zipimporte@10
$LN17@zipimporte@10:
  00130	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
  00137	0f b7 14 58	 movzx	 edx, WORD PTR [rax+rbx*2]
  0013b	eb 24		 jmp	 SHORT $LN24@zipimporte@10
$LN23@zipimporte@10:
  0013d	a8 20		 test	 al, 32			; 00000020H
  0013f	74 16		 je	 SHORT $LN21@zipimporte@10
  00141	a8 40		 test	 al, 64			; 00000040H
  00143	74 09		 je	 SHORT $LN19@zipimporte@10
  00145	48 8d 81 80 00
	00 00		 lea	 rax, QWORD PTR [rcx+128]
  0014c	eb 10		 jmp	 SHORT $LN22@zipimporte@10
$LN19@zipimporte@10:
  0014e	48 8d 81 a0 00
	00 00		 lea	 rax, QWORD PTR [rcx+160]
  00155	eb 07		 jmp	 SHORT $LN22@zipimporte@10
$LN21@zipimporte@10:
  00157	48 8b 81 a0 00
	00 00		 mov	 rax, QWORD PTR [rcx+160]
$LN22@zipimporte@10:
  0015e	8b 14 98	 mov	 edx, DWORD PTR [rax+rbx*4]
$LN24@zipimporte@10:
  00161	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  00164	75 04		 jne	 SHORT $LN3@zipimporte@10

; 582  :         path_start = len + 1;

  00166	48 8d 7b 01	 lea	 rdi, QWORD PTR [rbx+1]
$LN3@zipimporte@10:

; 583  :     }
; 584  : 
; 585  :     key = PyUnicode_Substring(path, path_start, path_len);

  0016a	4c 8b c5	 mov	 r8, rbp
  0016d	48 8b d7	 mov	 rdx, rdi
  00170	e8 00 00 00 00	 call	 PyUnicode_Substring
  00175	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0017a	48 8b d8	 mov	 rbx, rax

; 586  :     if (key == NULL)

  0017d	48 85 c0	 test	 rax, rax
  00180	74 2b		 je	 SHORT $error$20797

; 587  :         goto error;
; 588  :     toc_entry = PyDict_GetItem(self->files, key);

  00182	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00186	48 8b d0	 mov	 rdx, rax
  00189	e8 00 00 00 00	 call	 PyDict_GetItem
  0018e	48 8b f8	 mov	 rdi, rax

; 589  :     if (toc_entry == NULL) {

  00191	48 85 c0	 test	 rax, rax
  00194	75 33		 jne	 SHORT $LN1@zipimporte@10

; 590  :         PyErr_SetFromErrnoWithFilenameObject(PyExc_IOError, key);

  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0019d	48 8b d3	 mov	 rdx, rbx
  001a0	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilenameObject

; 591  :         Py_DECREF(key);

  001a5	48 8b cb	 mov	 rcx, rbx
  001a8	e8 00 00 00 00	 call	 _Py_DecRef
$error$20797:

; 597  :   error:
; 598  :     Py_DECREF(path);

  001ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  001b2	e8 00 00 00 00	 call	 _Py_DecRef
  001b7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001bc	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 599  :     return NULL;

  001c1	33 c0		 xor	 eax, eax

; 600  : }

  001c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c7	5e		 pop	 rsi
  001c8	c3		 ret	 0
$LN1@zipimporte@10:

; 592  :         goto error;
; 593  :     }
; 594  :     Py_DECREF(key);

  001c9	48 8b cb	 mov	 rcx, rbx
  001cc	e8 00 00 00 00	 call	 _Py_DecRef

; 595  :     Py_DECREF(path);

  001d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  001d6	e8 00 00 00 00	 call	 _Py_DecRef

; 596  :     return get_data(self->archive, toc_entry);

  001db	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]
  001df	48 8b d7	 mov	 rdx, rdi
  001e2	e8 00 00 00 00	 call	 get_data
  001e7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001ec	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 600  : }

  001f1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f5	5e		 pop	 rsi
  001f6	c3		 ret	 0
zipimporter_get_data ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@MMGPFPJI@U?3zipimporter?4get_code?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_get_code DD imagerel zipimporter_get_code
	DD	imagerel zipimporter_get_code+69
	DD	imagerel $unwind$zipimporter_get_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_get_code DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BH@MMGPFPJI@U?3zipimporter?4get_code?$AA@
CONST	SEGMENT
??_C@_0BH@MMGPFPJI@U?3zipimporter?4get_code?$AA@ DB 'U:zipimporter.get_co'
	DB	'de', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_get_code
_TEXT	SEGMENT
fullname$ = 48
obj$ = 48
args$ = 56
zipimporter_get_code PROC				; COMDAT

; 604  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 605  :     ZipImporter *self = (ZipImporter *)obj;
; 606  :     PyObject *fullname;
; 607  : 
; 608  :     if (!PyArg_ParseTuple(args, "U:zipimporter.get_code", &fullname))

  0000c	4c 8d 44 24 30	 lea	 r8, QWORD PTR fullname$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MMGPFPJI@U?3zipimporter?4get_code?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN1@zipimporte@11

; 609  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 612  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN1@zipimporte@11:

; 610  : 
; 611  :     return get_module_code(self, fullname, NULL, NULL);

  0002c	48 8b 54 24 30	 mov	 rdx, QWORD PTR fullname$[rsp]
  00031	45 33 c9	 xor	 r9d, r9d
  00034	45 33 c0	 xor	 r8d, r8d
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 get_module_code

; 612  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
zipimporter_get_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DEOPIIA@?$CFU?4py?$AA@			; `string'
PUBLIC	??_C@_0BA@FPMBKODM@?$CFU?$CFc__init__?4py?$AA@	; `string'
PUBLIC	??_C@_0BJ@OHMHCHFJ@U?3zipimporter?4get_source?$AA@ ; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zipimporter_get_source DD imagerel zipimporter_get_source
	DD	imagerel zipimporter_get_source+52
	DD	imagerel $unwind$zipimporter_get_source
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$zipimporter_get_source DD imagerel zipimporter_get_source+52
	DD	imagerel zipimporter_get_source+110
	DD	imagerel $chain$0$zipimporter_get_source
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$zipimporter_get_source DD imagerel zipimporter_get_source+110
	DD	imagerel zipimporter_get_source+149
	DD	imagerel $chain$3$zipimporter_get_source
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$zipimporter_get_source DD imagerel zipimporter_get_source+149
	DD	imagerel zipimporter_get_source+357
	DD	imagerel $chain$6$zipimporter_get_source
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$zipimporter_get_source DD 060c21H
	DD	09740cH
	DD	086400H
	DD	073400H
	DD	imagerel zipimporter_get_source
	DD	imagerel zipimporter_get_source+52
	DD	imagerel $unwind$zipimporter_get_source
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$zipimporter_get_source DD 040a21H
	DD	08640aH
	DD	073400H
	DD	imagerel zipimporter_get_source
	DD	imagerel zipimporter_get_source+52
	DD	imagerel $unwind$zipimporter_get_source
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$zipimporter_get_source DD 020521H
	DD	073405H
	DD	imagerel zipimporter_get_source
	DD	imagerel zipimporter_get_source+52
	DD	imagerel $unwind$zipimporter_get_source
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zipimporter_get_source DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT ??_C@_05DEOPIIA@?$CFU?4py?$AA@
CONST	SEGMENT
??_C@_05DEOPIIA@?$CFU?4py?$AA@ DB '%U.py', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FPMBKODM@?$CFU?$CFc__init__?4py?$AA@
CONST	SEGMENT
??_C@_0BA@FPMBKODM@?$CFU?$CFc__init__?4py?$AA@ DB '%U%c__init__.py', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHMHCHFJ@U?3zipimporter?4get_source?$AA@
CONST	SEGMENT
??_C@_0BJ@OHMHCHFJ@U?3zipimporter?4get_source?$AA@ DB 'U:zipimporter.get_'
	DB	'source', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT zipimporter_get_source
_TEXT	SEGMENT
fullname$ = 48
obj$ = 48
args$ = 56
zipimporter_get_source PROC				; COMDAT

; 616  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b e9	 mov	 rbp, rcx

; 617  :     ZipImporter *self = (ZipImporter *)obj;
; 618  :     PyObject *toc_entry;
; 619  :     PyObject *fullname, *subname, *path, *fullpath;
; 620  :     enum zi_module_info mi;
; 621  : 
; 622  :     if (!PyArg_ParseTuple(args, "U:zipimporter.get_source", &fullname))

  0000c	4c 8d 44 24 30	 lea	 r8, QWORD PTR fullname$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OHMHCHFJ@U?3zipimporter?4get_source?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN10@zipimporte@12

; 623  :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 666  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5d		 pop	 rbp
  0002b	c3		 ret	 0
$LN10@zipimporte@12:

; 624  : 
; 625  :     mi = get_module_info(self, fullname);

  0002c	48 8b 54 24 30	 mov	 rdx, QWORD PTR fullname$[rsp]
  00031	48 8b cd	 mov	 rcx, rbp
  00034	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00039	e8 00 00 00 00	 call	 get_module_info
  0003e	8b d8		 mov	 ebx, eax

; 626  :     if (mi == MI_ERROR)

  00040	85 c0		 test	 eax, eax

; 627  :         return NULL;

  00042	74 1d		 je	 SHORT $LN18@zipimporte@12

; 628  :     if (mi == MI_NOT_FOUND) {

  00044	83 f8 01	 cmp	 eax, 1
  00047	75 25		 jne	 SHORT $LN8@zipimporte@12

; 629  :         PyErr_Format(ZipImportError, "can't find module %R", fullname);

  00049	4c 8b 44 24 30	 mov	 r8, QWORD PTR fullname$[rsp]
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ZipImportError
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MBMIOLGL@can?8t?5find?5module?5?$CFR?$AA@
  0005c	e8 00 00 00 00	 call	 PyErr_Format
$LN18@zipimporte@12:

; 630  :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 666  : }

  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5d		 pop	 rbp
  0006d	c3		 ret	 0
$LN8@zipimporte@12:

; 631  :     }
; 632  : 
; 633  :     subname = get_subname(fullname);

  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR fullname$[rsp]
  00073	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00078	e8 00 00 00 00	 call	 get_subname
  0007d	48 8b f0	 mov	 rsi, rax

; 634  :     if (subname == NULL)

  00080	48 85 c0	 test	 rax, rax
  00083	75 10		 jne	 SHORT $LN7@zipimporte@12
  00085	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 666  : }

  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5d		 pop	 rbp
  00094	c3		 ret	 0
$LN7@zipimporte@12:

; 635  :         return NULL;
; 636  : 
; 637  :     path = make_filename(self->prefix, subname);

  00095	48 8b 4d 68	 mov	 rcx, QWORD PTR [rbp+104]
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  000a1	e8 00 00 00 00	 call	 make_filename

; 638  :     Py_DECREF(subname);

  000a6	48 8b ce	 mov	 rcx, rsi
  000a9	48 8b f8	 mov	 rdi, rax
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 639  :     if (path == NULL)

  000b1	48 85 ff	 test	 rdi, rdi

; 640  :         return NULL;

  000b4	74 66		 je	 SHORT $LN17@zipimporte@12

; 641  : 
; 642  :     if (mi == MI_PACKAGE)
; 643  :         fullpath = PyUnicode_FromFormat("%U%c__init__.py", path, SEP);

  000b6	48 8b d7	 mov	 rdx, rdi
  000b9	83 fb 03	 cmp	 ebx, 3
  000bc	75 12		 jne	 SHORT $LN5@zipimporte@12
  000be	44 8d 43 59	 lea	 r8d, QWORD PTR [rbx+89]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FPMBKODM@?$CFU?$CFc__init__?4py?$AA@
  000c9	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 644  :     else

  000ce	eb 0c		 jmp	 SHORT $LN16@zipimporte@12
$LN5@zipimporte@12:

; 645  :         fullpath = PyUnicode_FromFormat("%U.py", path);

  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05DEOPIIA@?$CFU?4py?$AA@
  000d7	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN16@zipimporte@12:

; 646  :     Py_DECREF(path);

  000dc	48 8b cf	 mov	 rcx, rdi
  000df	48 8b d8	 mov	 rbx, rax
  000e2	e8 00 00 00 00	 call	 _Py_DecRef

; 647  :     if (fullpath == NULL)

  000e7	48 85 db	 test	 rbx, rbx

; 648  :         return NULL;

  000ea	74 30		 je	 SHORT $LN17@zipimporte@12

; 649  : 
; 650  :     toc_entry = PyDict_GetItem(self->files, fullpath);

  000ec	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000f0	48 8b d3	 mov	 rdx, rbx
  000f3	e8 00 00 00 00	 call	 PyDict_GetItem

; 651  :     Py_DECREF(fullpath);

  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	48 8b f8	 mov	 rdi, rax
  000fe	e8 00 00 00 00	 call	 _Py_DecRef

; 652  :     if (toc_entry != NULL) {

  00103	48 85 ff	 test	 rdi, rdi
  00106	74 35		 je	 SHORT $LN2@zipimporte@12

; 653  :         PyObject *res, *bytes;
; 654  :         bytes = get_data(self->archive, toc_entry);

  00108	48 8b 4d 60	 mov	 rcx, QWORD PTR [rbp+96]
  0010c	48 8b d7	 mov	 rdx, rdi
  0010f	e8 00 00 00 00	 call	 get_data
  00114	48 8b f8	 mov	 rdi, rax

; 655  :         if (bytes == NULL)

  00117	48 85 c0	 test	 rax, rax
  0011a	75 04		 jne	 SHORT $LN1@zipimporte@12
$LN17@zipimporte@12:

; 656  :             return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	eb 30		 jmp	 SHORT $LN15@zipimporte@12
$LN1@zipimporte@12:

; 657  :         res = PyUnicode_FromStringAndSize(PyBytes_AS_STRING(bytes),
; 658  :                                           PyBytes_GET_SIZE(bytes));

  00120	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00124	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00128	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize

; 659  :         Py_DECREF(bytes);

  0012d	48 8b cf	 mov	 rcx, rdi
  00130	48 8b d8	 mov	 rbx, rax
  00133	e8 00 00 00 00	 call	 _Py_DecRef

; 660  :         return res;

  00138	48 8b c3	 mov	 rax, rbx
  0013b	eb 13		 jmp	 SHORT $LN15@zipimporte@12
$LN2@zipimporte@12:

; 661  :     }
; 662  : 
; 663  :     /* we have the module, but no source */
; 664  :     Py_INCREF(Py_None);

  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00144	e8 00 00 00 00	 call	 _Py_IncRef

; 665  :     return Py_None;

  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN15@zipimporte@12:
  00150	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00155	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0015a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 666  : }

  0015f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00163	5d		 pop	 rbp
  00164	c3		 ret	 0
zipimporter_get_source ENDP
_TEXT	ENDS
END
