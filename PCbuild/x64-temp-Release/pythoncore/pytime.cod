; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	??_C@_0BK@PNAGOKKE@GetSystemTimeAsFileTime?$CI?$CJ?$AA@ ; `string'
EXTRN	__imp_GetSystemTimeAdjustment:PROC
EXTRN	__imp_GetSystemTimeAsFileTime:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\pytime.c
pdata	SEGMENT
$pdata$pygettimeofday DD imagerel pygettimeofday
	DD	imagerel pygettimeofday+194
	DD	imagerel $unwind$pygettimeofday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pygettimeofday DD 030701H
	DD	070034207H
	DD	03002H
xdata	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT ??_C@_0BK@PNAGOKKE@GetSystemTimeAsFileTime?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BK@PNAGOKKE@GetSystemTimeAsFileTime?$CI?$CJ?$AA@ DB 'GetSystemTime'
	DB	'AsFileTime()', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pygettimeofday
_TEXT	SEGMENT
timeIncrement$120299 = 64
large$ = 64
tp$ = 64
isTimeAdjustmentDisabled$120300 = 72
info$ = 72
timeAdjustment$120298 = 80
system_time$ = 88
pygettimeofday PROC					; COMDAT

; 23   : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b d9	 mov	 rbx, rcx

; 24   : #ifdef MS_WINDOWS
; 25   :     FILETIME system_time;
; 26   :     ULARGE_INTEGER large;
; 27   :     ULONGLONG microseconds;
; 28   : 
; 29   :     GetSystemTimeAsFileTime(&system_time);

  0000a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR system_time$[rsp]
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTimeAsFileTime

; 30   :     large.u.LowPart = system_time.dwLowDateTime;
; 31   :     large.u.HighPart = system_time.dwHighDateTime;

  00018	8b 44 24 5c	 mov	 eax, DWORD PTR system_time$[rsp+4]
  0001c	44 8b 5c 24 58	 mov	 r11d, DWORD PTR system_time$[rsp]
  00021	89 44 24 44	 mov	 DWORD PTR large$[rsp+4], eax

; 32   :     /* 11,644,473,600,000,000: number of microseconds between
; 33   :        the 1st january 1601 and the 1st january 1970 (369 years + 89 leap
; 34   :        days). */
; 35   :     microseconds = large.QuadPart / 10 - 11644473600000000;

  00025	48 b8 cd cc cc
	cc cc cc cc cc	 mov	 rax, -3689348814741910323 ; cccccccccccccccdH
  0002f	44 89 5c 24 40	 mov	 DWORD PTR large$[rsp], r11d
  00034	48 f7 64 24 40	 mul	 QWORD PTR large$[rsp]
  00039	48 b8 00 40 86
	48 96 5e 29 00	 mov	 rax, 11644473600000000	; 00295e9648864000H
  00043	4c 8b c2	 mov	 r8, rdx
  00046	49 c1 e8 03	 shr	 r8, 3
  0004a	4c 2b c0	 sub	 r8, rax

; 36   :     tp->tv_sec = microseconds / 1000000;

  0004d	48 b8 db 34 b6
	d7 82 de 1b 43	 mov	 rax, 4835703278458516699 ; 431bde82d7b634dbH
  00057	49 f7 e0	 mul	 r8
  0005a	48 c1 ea 12	 shr	 rdx, 18
  0005e	48 89 13	 mov	 QWORD PTR [rbx], rdx

; 37   :     tp->tv_usec = microseconds % 1000000;

  00061	69 d2 40 42 0f
	00		 imul	 edx, 1000000		; 000f4240H
  00067	44 2b c2	 sub	 r8d, edx
  0006a	44 89 43 08	 mov	 DWORD PTR [rbx+8], r8d

; 38   :     if (info) {

  0006e	48 85 ff	 test	 rdi, rdi
  00071	74 48		 je	 SHORT $LN1@pygettimeo

; 39   :         DWORD timeAdjustment, timeIncrement;
; 40   :         BOOL isTimeAdjustmentDisabled;
; 41   : 
; 42   :         info->implementation = "GetSystemTimeAsFileTime()";

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@PNAGOKKE@GetSystemTimeAsFileTime?$CI?$CJ?$AA@

; 43   :         info->monotonic = 0;
; 44   :         (void) GetSystemTimeAdjustment(&timeAdjustment, &timeIncrement,
; 45   :                                        &isTimeAdjustmentDisabled);

  0007a	4c 8d 44 24 48	 lea	 r8, QWORD PTR isTimeAdjustmentDisabled$120300[rsp]
  0007f	48 8d 54 24 40	 lea	 rdx, QWORD PTR timeIncrement$120299[rsp]
  00084	48 8d 4c 24 50	 lea	 rcx, QWORD PTR timeAdjustment$120298[rsp]
  00089	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [rdi+8], 0
  00090	48 89 07	 mov	 QWORD PTR [rdi], rax
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTimeAdjustment

; 46   :         info->resolution = timeIncrement * 1e-7;

  00099	44 8b 5c 24 40	 mov	 r11d, DWORD PTR timeIncrement$120299[rsp]

; 47   :         info->adjustable = 1;

  0009e	c7 47 0c 01 00
	00 00		 mov	 DWORD PTR [rdi+12], 1
  000a5	66 0f ef c0	 pxor	 xmm0, xmm0
  000a9	f2 49 0f 2a c3	 cvtsi2sd xmm0, r11
  000ae	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3e7ad7f29abcaf48
  000b6	f2 0f 11 47 10	 movsdx	 QWORD PTR [rdi+16], xmm0
$LN1@pygettimeo:

; 48   :     }
; 49   : #else
; 50   :     /* There are three ways to get the time:
; 51   :       (1) gettimeofday() -- resolution in microseconds
; 52   :       (2) ftime() -- resolution in milliseconds
; 53   :       (3) time() -- resolution in seconds
; 54   :       In all cases the return value in a timeval struct.
; 55   :       Since on some systems (e.g. SCO ODT 3.0) gettimeofday() may
; 56   :       fail, so we fall back on ftime() or time().
; 57   :       Note: clock resolution does not imply clock accuracy! */
; 58   : 
; 59   : #ifdef HAVE_GETTIMEOFDAY
; 60   :     int err;
; 61   : #ifdef GETTIMEOFDAY_NO_TZ
; 62   :     err = gettimeofday(tp);
; 63   : #else
; 64   :     err = gettimeofday(tp, (struct timezone *)NULL);
; 65   : #endif
; 66   :     if (err == 0) {
; 67   :         if (info) {
; 68   :             info->implementation = "gettimeofday()";
; 69   :             info->resolution = 1e-6;
; 70   :             info->monotonic = 0;
; 71   :             info->adjustable = 1;
; 72   :         }
; 73   :         return;
; 74   :     }
; 75   : #endif   /* HAVE_GETTIMEOFDAY */
; 76   : 
; 77   : #if defined(HAVE_FTIME)
; 78   :     {
; 79   :         struct timeb t;
; 80   :         ftime(&t);
; 81   :         tp->tv_sec = t.time;
; 82   :         tp->tv_usec = t.millitm * 1000;
; 83   :         if (info) {
; 84   :             info->implementation = "ftime()";
; 85   :             info->resolution = 1e-3;
; 86   :             info->monotonic = 0;
; 87   :             info->adjustable = 1;
; 88   :         }
; 89   :     }
; 90   : #else /* !HAVE_FTIME */
; 91   :     tp->tv_sec = time(NULL);
; 92   :     tp->tv_usec = 0;
; 93   :     if (info) {
; 94   :         info->implementation = "time()";
; 95   :         info->resolution = 1.0;
; 96   :         info->monotonic = 0;
; 97   :         info->adjustable = 1;
; 98   :     }
; 99   : #endif /* !HAVE_FTIME */
; 100  : 
; 101  : #endif /* MS_WINDOWS */
; 102  : }

  000bb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bf	5f		 pop	 rdi
  000c0	5b		 pop	 rbx
  000c1	c3		 ret	 0
pygettimeofday ENDP
_TEXT	ENDS
PUBLIC	_PyTime_gettimeofday
; Function compile flags: /Ogtpy
;	COMDAT _PyTime_gettimeofday
_TEXT	SEGMENT
tp$ = 8
_PyTime_gettimeofday PROC				; COMDAT

; 107  :     pygettimeofday(tp, NULL);

  00000	33 d2		 xor	 edx, edx

; 108  : }

  00002	e9 00 00 00 00	 jmp	 pygettimeofday
_PyTime_gettimeofday ENDP
_TEXT	ENDS
PUBLIC	_PyTime_gettimeofday_info
; Function compile flags: /Ogtpy
;	COMDAT _PyTime_gettimeofday_info
_TEXT	SEGMENT
tp$ = 8
info$ = 16
_PyTime_gettimeofday_info PROC				; COMDAT

; 113  :     pygettimeofday(tp, info);
; 114  : }

  00000	e9 00 00 00 00	 jmp	 pygettimeofday
_PyTime_gettimeofday_info ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@IDPHOICO@timestamp?5out?5of?5range?5for?5platf@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT ??_C@_0CL@IDPHOICO@timestamp?5out?5of?5range?5for?5platf@
CONST	SEGMENT
??_C@_0CL@IDPHOICO@timestamp?5out?5of?5range?5for?5platf@ DB 'timestamp o'
	DB	'ut of range for platform time_t', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT error_time_t_overflow
_TEXT	SEGMENT
error_time_t_overflow PROC				; COMDAT

; 119  :     PyErr_SetString(PyExc_OverflowError,
; 120  :                     "timestamp out of range for platform time_t");

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@IDPHOICO@timestamp?5out?5of?5range?5for?5platf@

; 121  : }

  0000e	e9 00 00 00 00	 jmp	 PyErr_SetString
error_time_t_overflow ENDP
_TEXT	ENDS
PUBLIC	_PyLong_AsTime_t
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyLong_AsTime_t DD imagerel $LN5
	DD	imagerel $LN5+70
	DD	imagerel $unwind$_PyLong_AsTime_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyLong_AsTime_t DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyLong_AsTime_t
_TEXT	SEGMENT
obj$ = 48
_PyLong_AsTime_t PROC					; COMDAT

; 125  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 126  : #if defined(HAVE_LONG_LONG) && SIZEOF_TIME_T == SIZEOF_LONG_LONG
; 127  :     PY_LONG_LONG val;
; 128  :     val = PyLong_AsLongLong(obj);

  00006	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0000b	48 8b d8	 mov	 rbx, rax

; 129  : #else
; 130  :     long val;
; 131  :     assert(sizeof(time_t) <= sizeof(long));
; 132  :     val = PyLong_AsLong(obj);
; 133  : #endif
; 134  :     if (val == -1 && PyErr_Occurred()) {

  0000e	48 83 f8 ff	 cmp	 rax, -1
  00012	75 29		 jne	 SHORT $LN2@PyLong_AsT
  00014	e8 00 00 00 00	 call	 PyErr_Occurred
  00019	48 85 c0	 test	 rax, rax
  0001c	74 1f		 je	 SHORT $LN2@PyLong_AsT

; 135  :         if (PyErr_ExceptionMatches(PyExc_OverflowError))

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00025	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0002a	85 c0		 test	 eax, eax
  0002c	74 05		 je	 SHORT $LN1@PyLong_AsT

; 136  :             error_time_t_overflow();

  0002e	e8 00 00 00 00	 call	 error_time_t_overflow
$LN1@PyLong_AsT:

; 137  :         return -1;

  00033	48 83 c8 ff	 or	 rax, -1

; 140  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN2@PyLong_AsT:

; 138  :     }
; 139  :     return (time_t)val;

  0003d	48 8b c3	 mov	 rax, rbx

; 140  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
_PyLong_AsTime_t ENDP
_TEXT	ENDS
PUBLIC	_PyLong_FromTime_t
EXTRN	PyLong_FromLongLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT _PyLong_FromTime_t
_TEXT	SEGMENT
t$ = 8
_PyLong_FromTime_t PROC					; COMDAT

; 145  : #if defined(HAVE_LONG_LONG) && SIZEOF_TIME_T == SIZEOF_LONG_LONG
; 146  :     return PyLong_FromLongLong((PY_LONG_LONG)t);
; 147  : #else
; 148  :     assert(sizeof(time_t) <= sizeof(long));
; 149  :     return PyLong_FromLong((long)t);
; 150  : #endif
; 151  : }

  00000	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
_PyLong_FromTime_t ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@3ff0000000000000
EXTRN	__imp_modf:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyTime_ObjectToDenominator DD imagerel _PyTime_ObjectToDenominator
	DD	imagerel _PyTime_ObjectToDenominator+289
	DD	imagerel $unwind$_PyTime_ObjectToDenominator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyTime_ObjectToDenominator DD 082501H
	DD	036825H
	DD	0c640fH
	DD	0b340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyTime_ObjectToDenominator
_TEXT	SEGMENT
intpart$120343 = 32
floatpart$120345 = 80
obj$ = 80
sec$ = 88
numerator$ = 96
denominator$ = 104
_PyTime_ObjectToDenominator PROC			; COMDAT

; 156  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b f9	 mov	 rdi, rcx

; 157  :     assert(denominator <= LONG_MAX);
; 158  :     if (PyFloat_Check(obj)) {

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00020	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  00025	49 8b d8	 mov	 rbx, r8
  00028	66 0f 28 f3	 movapd	 xmm6, xmm3
  0002c	48 3b ca	 cmp	 rcx, rdx
  0002f	74 35		 je	 SHORT $LN6@PyTime_Obj
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 2c		 jne	 SHORT $LN6@PyTime_Obj

; 180  :     }
; 181  :     else {
; 182  :         *sec = _PyLong_AsTime_t(obj);

  0003a	48 8b cf	 mov	 rcx, rdi
  0003d	e8 00 00 00 00	 call	 _PyLong_AsTime_t
  00042	48 89 06	 mov	 QWORD PTR [rsi], rax

; 183  :         if (*sec == (time_t)-1 && PyErr_Occurred())

  00045	48 83 f8 ff	 cmp	 rax, -1
  00049	75 0e		 jne	 SHORT $LN1@PyTime_Obj
  0004b	e8 00 00 00 00	 call	 PyErr_Occurred
  00050	48 85 c0	 test	 rax, rax

; 184  :             return -1;

  00053	0f 85 b0 00 00
	00		 jne	 $LN11@PyTime_Obj
$LN1@PyTime_Obj:

; 185  :         *numerator = 0;

  00059	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0

; 186  :         return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 a6 00 00 00	 jmp	 $LN2@PyTime_Obj
$LN6@PyTime_Obj:

; 159  :         double d, intpart, err;
; 160  :         /* volatile avoids unsafe optimization on float enabled by gcc -O3 */
; 161  :         volatile double floatpart;
; 162  : 
; 163  :         d = PyFloat_AsDouble(obj);

  00066	48 8b cf	 mov	 rcx, rdi
  00069	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 164  :         floatpart = modf(d, &intpart);

  0006e	48 8d 54 24 20	 lea	 rdx, QWORD PTR intpart$120343[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 165  :         if (floatpart < 0) {

  00079	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3ff0000000000000
  00081	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR floatpart$120345[rsp], xmm0
  00087	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0008b	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR floatpart$120345[rsp]
  00091	66 0f 2f c1	 comisd	 xmm0, xmm1
  00095	76 22		 jbe	 SHORT $LN10@PyTime_Obj

; 166  :             floatpart = 1.0 + floatpart;

  00097	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR floatpart$120345[rsp]

; 167  :             intpart -= 1.0;

  0009d	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR intpart$120343[rsp]
  000a3	f2 0f 5c ca	 subsd	 xmm1, xmm2
  000a7	f2 0f 58 c2	 addsd	 xmm0, xmm2
  000ab	f2 0f 11 4c 24
	20		 movsdx	 QWORD PTR intpart$120343[rsp], xmm1
  000b1	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR floatpart$120345[rsp], xmm0
  000b7	eb 06		 jmp	 SHORT $LN5@PyTime_Obj
$LN10@PyTime_Obj:
  000b9	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR intpart$120343[rsp]
$LN5@PyTime_Obj:

; 168  :         }
; 169  : 
; 170  :         *sec = (time_t)intpart;

  000bf	f2 48 0f 2c c1	 cvttsd2si rax, xmm1

; 171  :         err = intpart - (double)*sec;

  000c4	66 0f ef c0	 pxor	 xmm0, xmm0
  000c8	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000cd	48 89 06	 mov	 QWORD PTR [rsi], rax
  000d0	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 172  :         if (err <= -1.0 || err >= 1.0) {

  000d4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  000dc	66 0f 2f c1	 comisd	 xmm0, xmm1
  000e0	73 22		 jae	 SHORT $LN3@PyTime_Obj
  000e2	66 0f 2f ca	 comisd	 xmm1, xmm2
  000e6	73 1c		 jae	 SHORT $LN3@PyTime_Obj

; 175  :         }
; 176  : 
; 177  :         floatpart *= denominator;

  000e8	f2 0f 59 74 24
	50		 mulsd	 xmm6, QWORD PTR floatpart$120345[rsp]
  000ee	f2 0f 11 74 24
	50		 movsdx	 QWORD PTR floatpart$120345[rsp], xmm6

; 178  :         *numerator = (long)floatpart;

  000f4	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR floatpart$120345[rsp]
  000fa	f2 0f 2c c0	 cvttsd2si eax, xmm0
  000fe	89 03		 mov	 DWORD PTR [rbx], eax

; 179  :         return 0;

  00100	33 c0		 xor	 eax, eax
  00102	eb 08		 jmp	 SHORT $LN2@PyTime_Obj
$LN3@PyTime_Obj:

; 173  :             error_time_t_overflow();

  00104	e8 00 00 00 00	 call	 error_time_t_overflow
$LN11@PyTime_Obj:

; 174  :             return -1;

  00109	83 c8 ff	 or	 eax, -1
$LN2@PyTime_Obj:

; 187  :     }
; 188  : }

  0010c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00111	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00116	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0011b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0011f	5f		 pop	 rdi
  00120	c3		 ret	 0
_PyTime_ObjectToDenominator ENDP
_TEXT	ENDS
PUBLIC	_PyTime_ObjectToTime_t
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyTime_ObjectToTime_t DD imagerel $LN10
	DD	imagerel $LN10+170
	DD	imagerel $unwind$_PyTime_ObjectToTime_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyTime_ObjectToTime_t DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyTime_ObjectToTime_t
_TEXT	SEGMENT
intpart$120365 = 48
obj$ = 48
sec$ = 56
_PyTime_ObjectToTime_t PROC				; COMDAT

; 192  : {

$LN10:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 193  :     if (PyFloat_Check(obj)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 31		 je	 SHORT $LN5@PyTime_Obj@2
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 28		 jne	 SHORT $LN5@PyTime_Obj@2

; 206  :     }
; 207  :     else {
; 208  :         *sec = _PyLong_AsTime_t(obj);

  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 _PyLong_AsTime_t
  00031	48 89 07	 mov	 QWORD PTR [rdi], rax

; 209  :         if (*sec == (time_t)-1 && PyErr_Occurred())

  00034	48 83 f8 ff	 cmp	 rax, -1
  00038	75 0a		 jne	 SHORT $LN1@PyTime_Obj@2
  0003a	e8 00 00 00 00	 call	 PyErr_Occurred
  0003f	48 85 c0	 test	 rax, rax

; 210  :             return -1;

  00042	75 58		 jne	 SHORT $LN9@PyTime_Obj@2
$LN1@PyTime_Obj@2:

; 211  :         return 0;

  00044	33 c0		 xor	 eax, eax

; 212  :     }
; 213  : }

  00046	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN5@PyTime_Obj@2:

; 194  :         double d, intpart, err;
; 195  : 
; 196  :         d = PyFloat_AsDouble(obj);

  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 197  :         (void)modf(d, &intpart);

  00059	48 8d 54 24 30	 lea	 rdx, QWORD PTR intpart$120365[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 198  : 
; 199  :         *sec = (time_t)intpart;

  00064	f2 0f 10 6c 24
	30		 movsdx	 xmm5, QWORD PTR intpart$120365[rsp]
  0006a	f2 48 0f 2c c5	 cvttsd2si rax, xmm5

; 200  :         err = intpart - (double)*sec;

  0006f	66 0f ef c0	 pxor	 xmm0, xmm0
  00073	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00078	48 89 07	 mov	 QWORD PTR [rdi], rax
  0007b	f2 0f 5c e8	 subsd	 xmm5, xmm0

; 201  :         if (err <= -1.0 || err >= 1.0) {

  0007f	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00087	66 0f 2f c5	 comisd	 xmm0, xmm5
  0008b	73 0a		 jae	 SHORT $LN3@PyTime_Obj@2
  0008d	66 0f 2f 2d 00
	00 00 00	 comisd	 xmm5, QWORD PTR __real@3ff0000000000000

; 204  :         }
; 205  :         return 0;

  00095	72 ad		 jb	 SHORT $LN1@PyTime_Obj@2
$LN3@PyTime_Obj@2:

; 202  :             error_time_t_overflow();

  00097	e8 00 00 00 00	 call	 error_time_t_overflow
$LN9@PyTime_Obj@2:

; 203  :             return -1;

  0009c	83 c8 ff	 or	 eax, -1

; 212  :     }
; 213  : }

  0009f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
_PyTime_ObjectToTime_t ENDP
_TEXT	ENDS
PUBLIC	__real@41cdcd6500000000
PUBLIC	_PyTime_ObjectToTimespec
;	COMDAT __real@41cdcd6500000000
CONST	SEGMENT
__real@41cdcd6500000000 DQ 041cdcd6500000000r	; 1e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyTime_ObjectToTimespec
_TEXT	SEGMENT
obj$ = 8
sec$ = 16
nsec$ = 24
_PyTime_ObjectToTimespec PROC				; COMDAT

; 218  :     return _PyTime_ObjectToDenominator(obj, sec, nsec, 1e9);

  00000	f2 0f 10 1d 00
	00 00 00	 movsdx	 xmm3, QWORD PTR __real@41cdcd6500000000

; 219  : }

  00008	e9 00 00 00 00	 jmp	 _PyTime_ObjectToDenominator
_PyTime_ObjectToTimespec ENDP
_TEXT	ENDS
PUBLIC	__real@412e848000000000
PUBLIC	_PyTime_ObjectToTimeval
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyTime_ObjectToTimeval
_TEXT	SEGMENT
obj$ = 8
sec$ = 16
usec$ = 24
_PyTime_ObjectToTimeval PROC				; COMDAT

; 224  :     return _PyTime_ObjectToDenominator(obj, sec, usec, 1e6);

  00000	f2 0f 10 1d 00
	00 00 00	 movsdx	 xmm3, QWORD PTR __real@412e848000000000

; 225  : }

  00008	e9 00 00 00 00	 jmp	 _PyTime_ObjectToDenominator
_PyTime_ObjectToTimeval ENDP
_TEXT	ENDS
PUBLIC	_PyTime_Init
; Function compile flags: /Ogtpy
;	COMDAT _PyTime_Init
_TEXT	SEGMENT
_PyTime_Init PROC					; COMDAT

; 230  :     /* Do nothing.  Needed to force linking. */
; 231  : }

  00000	c2 00 00	 ret	 0
_PyTime_Init ENDP
_TEXT	ENDS
END
