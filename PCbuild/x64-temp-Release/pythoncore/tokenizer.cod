; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@		; `string'
PUBLIC	??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@	; `string'
PUBLIC	??_C@_02MBMDLBEE@OP?$AA@			; `string'
PUBLIC	??_C@_08FHELOJEN@ELLIPSIS?$AA@			; `string'
PUBLIC	??_C@_06LPDGFLDK@RARROW?$AA@			; `string'
PUBLIC	??_C@_02KPDBFJEK@AT?$AA@			; `string'
PUBLIC	??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@	; `string'
PUBLIC	??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@		; `string'
PUBLIC	??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@		; `string'
PUBLIC	??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@		; `string'
PUBLIC	??_C@_09ICMHBFCA@VBAREQUAL?$AA@			; `string'
PUBLIC	??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@		; `string'
PUBLIC	??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@		; `string'
PUBLIC	??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@		; `string'
PUBLIC	??_C@_09LLDEOFJP@STAREQUAL?$AA@			; `string'
PUBLIC	??_C@_08JPGMLNCJ@MINEQUAL?$AA@			; `string'
PUBLIC	??_C@_09BJJNIKJA@PLUSEQUAL?$AA@			; `string'
PUBLIC	??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@		; `string'
PUBLIC	??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@		; `string'
PUBLIC	??_C@_09JKNLCHGF@LEFTSHIFT?$AA@			; `string'
PUBLIC	??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@		; `string'
PUBLIC	??_C@_05KHJOFHFM@TILDE?$AA@			; `string'
PUBLIC	??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@		; `string'
PUBLIC	??_C@_09EOMDFECK@LESSEQUAL?$AA@			; `string'
PUBLIC	??_C@_08KDCAELOL@NOTEQUAL?$AA@			; `string'
PUBLIC	??_C@_07PFKDGLNG@EQEQUAL?$AA@			; `string'
PUBLIC	??_C@_06KOAFIFC@RBRACE?$AA@			; `string'
PUBLIC	??_C@_06DNABLPMB@LBRACE?$AA@			; `string'
PUBLIC	??_C@_07IPMEJCHO@PERCENT?$AA@			; `string'
PUBLIC	??_C@_03GPNMLNCE@DOT?$AA@			; `string'
PUBLIC	??_C@_05MFJMDLJG@EQUAL?$AA@			; `string'
PUBLIC	??_C@_07INHKBBNC@GREATER?$AA@			; `string'
PUBLIC	??_C@_04PHHIILNL@LESS?$AA@			; `string'
PUBLIC	??_C@_05BPILGEDC@AMPER?$AA@			; `string'
PUBLIC	??_C@_04EGEGHKBO@VBAR?$AA@			; `string'
PUBLIC	??_C@_05CMNGPLPB@SLASH?$AA@			; `string'
PUBLIC	??_C@_04PLNEPNCN@STAR?$AA@			; `string'
PUBLIC	??_C@_05CIDCLABE@MINUS?$AA@			; `string'
PUBLIC	??_C@_04CLONMCGA@PLUS?$AA@			; `string'
PUBLIC	??_C@_04LDFNPPCJ@SEMI?$AA@			; `string'
PUBLIC	??_C@_05OFAMAJDB@COMMA?$AA@			; `string'
PUBLIC	??_C@_05NJKMKGPF@COLON?$AA@			; `string'
PUBLIC	??_C@_04NIHFNAF@RSQB?$AA@			; `string'
PUBLIC	??_C@_04NCFHHEOG@LSQB?$AA@			; `string'
PUBLIC	??_C@_04EJNGEDMK@RPAR?$AA@			; `string'
PUBLIC	??_C@_04JGAGGKCJ@LPAR?$AA@			; `string'
PUBLIC	??_C@_06CICIIECI@DEDENT?$AA@			; `string'
PUBLIC	??_C@_06CDDIBFCL@INDENT?$AA@			; `string'
PUBLIC	??_C@_07CNGHCLKN@NEWLINE?$AA@			; `string'
PUBLIC	??_C@_06IGECGLFO@STRING?$AA@			; `string'
PUBLIC	??_C@_06EFEGMLFC@NUMBER?$AA@			; `string'
PUBLIC	??_C@_04IPKHEEB@NAME?$AA@			; `string'
PUBLIC	??_C@_09MOKDLBPF@ENDMARKER?$AA@			; `string'
PUBLIC	_PyParser_TokenNames
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_readline@?1??fp_setreadl@@9@9 DQ 0000000000000000H ; `fp_setreadl'::`2'::PyId_readline
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	0000000000000000H
?PyId_open@?1??fp_setreadl@@9@9 DQ 0000000000000000H	; `fp_setreadl'::`2'::PyId_open
	DQ	FLAT:??_C@_04PMOCAHAA@open?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_PyParser_TokenNames DQ FLAT:??_C@_09MOKDLBPF@ENDMARKER?$AA@
	DQ	FLAT:??_C@_04IPKHEEB@NAME?$AA@
	DQ	FLAT:??_C@_06EFEGMLFC@NUMBER?$AA@
	DQ	FLAT:??_C@_06IGECGLFO@STRING?$AA@
	DQ	FLAT:??_C@_07CNGHCLKN@NEWLINE?$AA@
	DQ	FLAT:??_C@_06CDDIBFCL@INDENT?$AA@
	DQ	FLAT:??_C@_06CICIIECI@DEDENT?$AA@
	DQ	FLAT:??_C@_04JGAGGKCJ@LPAR?$AA@
	DQ	FLAT:??_C@_04EJNGEDMK@RPAR?$AA@
	DQ	FLAT:??_C@_04NCFHHEOG@LSQB?$AA@
	DQ	FLAT:??_C@_04NIHFNAF@RSQB?$AA@
	DQ	FLAT:??_C@_05NJKMKGPF@COLON?$AA@
	DQ	FLAT:??_C@_05OFAMAJDB@COMMA?$AA@
	DQ	FLAT:??_C@_04LDFNPPCJ@SEMI?$AA@
	DQ	FLAT:??_C@_04CLONMCGA@PLUS?$AA@
	DQ	FLAT:??_C@_05CIDCLABE@MINUS?$AA@
	DQ	FLAT:??_C@_04PLNEPNCN@STAR?$AA@
	DQ	FLAT:??_C@_05CMNGPLPB@SLASH?$AA@
	DQ	FLAT:??_C@_04EGEGHKBO@VBAR?$AA@
	DQ	FLAT:??_C@_05BPILGEDC@AMPER?$AA@
	DQ	FLAT:??_C@_04PHHIILNL@LESS?$AA@
	DQ	FLAT:??_C@_07INHKBBNC@GREATER?$AA@
	DQ	FLAT:??_C@_05MFJMDLJG@EQUAL?$AA@
	DQ	FLAT:??_C@_03GPNMLNCE@DOT?$AA@
	DQ	FLAT:??_C@_07IPMEJCHO@PERCENT?$AA@
	DQ	FLAT:??_C@_06DNABLPMB@LBRACE?$AA@
	DQ	FLAT:??_C@_06KOAFIFC@RBRACE?$AA@
	DQ	FLAT:??_C@_07PFKDGLNG@EQEQUAL?$AA@
	DQ	FLAT:??_C@_08KDCAELOL@NOTEQUAL?$AA@
	DQ	FLAT:??_C@_09EOMDFECK@LESSEQUAL?$AA@
	DQ	FLAT:??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@
	DQ	FLAT:??_C@_05KHJOFHFM@TILDE?$AA@
	DQ	FLAT:??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@
	DQ	FLAT:??_C@_09JKNLCHGF@LEFTSHIFT?$AA@
	DQ	FLAT:??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@
	DQ	FLAT:??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@
	DQ	FLAT:??_C@_09BJJNIKJA@PLUSEQUAL?$AA@
	DQ	FLAT:??_C@_08JPGMLNCJ@MINEQUAL?$AA@
	DQ	FLAT:??_C@_09LLDEOFJP@STAREQUAL?$AA@
	DQ	FLAT:??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@
	DQ	FLAT:??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@
	DQ	FLAT:??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@
	DQ	FLAT:??_C@_09ICMHBFCA@VBAREQUAL?$AA@
	DQ	FLAT:??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@
	DQ	FLAT:??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@
	DQ	FLAT:??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@
	DQ	FLAT:??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@
	DQ	FLAT:??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@
	DQ	FLAT:??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@
	DQ	FLAT:??_C@_02KPDBFJEK@AT?$AA@
	DQ	FLAT:??_C@_06LPDGFLDK@RARROW?$AA@
	DQ	FLAT:??_C@_08FHELOJEN@ELLIPSIS?$AA@
	DQ	FLAT:??_C@_02MBMDLBEE@OP?$AA@
	DQ	FLAT:??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@
	DQ	FLAT:??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@
CONST	SEGMENT
??_C@_0L@FJMHFPNM@?$DMN_TOKENS?$DO?$AA@ DB '<N_TOKENS>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@
CONST	SEGMENT
??_C@_0N@NPCPCIEJ@?$DMERRORTOKEN?$DO?$AA@ DB '<ERRORTOKEN>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBMDLBEE@OP?$AA@
CONST	SEGMENT
??_C@_02MBMDLBEE@OP?$AA@ DB 'OP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08FHELOJEN@ELLIPSIS?$AA@
CONST	SEGMENT
??_C@_08FHELOJEN@ELLIPSIS?$AA@ DB 'ELLIPSIS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LPDGFLDK@RARROW?$AA@
CONST	SEGMENT
??_C@_06LPDGFLDK@RARROW?$AA@ DB 'RARROW', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPDBFJEK@AT?$AA@
CONST	SEGMENT
??_C@_02KPDBFJEK@AT?$AA@ DB 'AT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@
CONST	SEGMENT
??_C@_0BB@KBCLLNFC@DOUBLESLASHEQUAL?$AA@ DB 'DOUBLESLASHEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@
CONST	SEGMENT
??_C@_0M@FHEMBGGK@DOUBLESLASH?$AA@ DB 'DOUBLESLASH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@DMDGAKON@DOUBLESTAREQUAL?$AA@ DB 'DOUBLESTAREQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@LBHKGBBC@RIGHTSHIFTEQUAL?$AA@ DB 'RIGHTSHIFTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@
CONST	SEGMENT
??_C@_0P@ONOELCDB@LEFTSHIFTEQUAL?$AA@ DB 'LEFTSHIFTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@
CONST	SEGMENT
??_C@_0BA@IGLJJIHG@CIRCUMFLEXEQUAL?$AA@ DB 'CIRCUMFLEXEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICMHBFCA@VBAREQUAL?$AA@
CONST	SEGMENT
??_C@_09ICMHBFCA@VBAREQUAL?$AA@ DB 'VBAREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@
CONST	SEGMENT
??_C@_0L@MEDOBEIH@AMPEREQUAL?$AA@ DB 'AMPEREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@
CONST	SEGMENT
??_C@_0N@PALHKIFD@PERCENTEQUAL?$AA@ DB 'PERCENTEQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@
CONST	SEGMENT
??_C@_0L@BPKHKPKN@SLASHEQUAL?$AA@ DB 'SLASHEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LLDEOFJP@STAREQUAL?$AA@
CONST	SEGMENT
??_C@_09LLDEOFJP@STAREQUAL?$AA@ DB 'STAREQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPGMLNCJ@MINEQUAL?$AA@
CONST	SEGMENT
??_C@_08JPGMLNCJ@MINEQUAL?$AA@ DB 'MINEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BJJNIKJA@PLUSEQUAL?$AA@
CONST	SEGMENT
??_C@_09BJJNIKJA@PLUSEQUAL?$AA@ DB 'PLUSEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@
CONST	SEGMENT
??_C@_0L@NABCMIOH@DOUBLESTAR?$AA@ DB 'DOUBLESTAR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@
CONST	SEGMENT
??_C@_0L@OPFBGLOK@RIGHTSHIFT?$AA@ DB 'RIGHTSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKNLCHGF@LEFTSHIFT?$AA@
CONST	SEGMENT
??_C@_09JKNLCHGF@LEFTSHIFT?$AA@ DB 'LEFTSHIFT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@
CONST	SEGMENT
??_C@_0L@ICKCLMNA@CIRCUMFLEX?$AA@ DB 'CIRCUMFLEX', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KHJOFHFM@TILDE?$AA@
CONST	SEGMENT
??_C@_05KHJOFHFM@TILDE?$AA@ DB 'TILDE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@
CONST	SEGMENT
??_C@_0N@EHHKHCIJ@GREATEREQUAL?$AA@ DB 'GREATEREQUAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EOMDFECK@LESSEQUAL?$AA@
CONST	SEGMENT
??_C@_09EOMDFECK@LESSEQUAL?$AA@ DB 'LESSEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KDCAELOL@NOTEQUAL?$AA@
CONST	SEGMENT
??_C@_08KDCAELOL@NOTEQUAL?$AA@ DB 'NOTEQUAL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFKDGLNG@EQEQUAL?$AA@
CONST	SEGMENT
??_C@_07PFKDGLNG@EQEQUAL?$AA@ DB 'EQEQUAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KOAFIFC@RBRACE?$AA@
CONST	SEGMENT
??_C@_06KOAFIFC@RBRACE?$AA@ DB 'RBRACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNABLPMB@LBRACE?$AA@
CONST	SEGMENT
??_C@_06DNABLPMB@LBRACE?$AA@ DB 'LBRACE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IPMEJCHO@PERCENT?$AA@
CONST	SEGMENT
??_C@_07IPMEJCHO@PERCENT?$AA@ DB 'PERCENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GPNMLNCE@DOT?$AA@
CONST	SEGMENT
??_C@_03GPNMLNCE@DOT?$AA@ DB 'DOT', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MFJMDLJG@EQUAL?$AA@
CONST	SEGMENT
??_C@_05MFJMDLJG@EQUAL?$AA@ DB 'EQUAL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07INHKBBNC@GREATER?$AA@
CONST	SEGMENT
??_C@_07INHKBBNC@GREATER?$AA@ DB 'GREATER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHHIILNL@LESS?$AA@
CONST	SEGMENT
??_C@_04PHHIILNL@LESS?$AA@ DB 'LESS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BPILGEDC@AMPER?$AA@
CONST	SEGMENT
??_C@_05BPILGEDC@AMPER?$AA@ DB 'AMPER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EGEGHKBO@VBAR?$AA@
CONST	SEGMENT
??_C@_04EGEGHKBO@VBAR?$AA@ DB 'VBAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMNGPLPB@SLASH?$AA@
CONST	SEGMENT
??_C@_05CMNGPLPB@SLASH?$AA@ DB 'SLASH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLNEPNCN@STAR?$AA@
CONST	SEGMENT
??_C@_04PLNEPNCN@STAR?$AA@ DB 'STAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CIDCLABE@MINUS?$AA@
CONST	SEGMENT
??_C@_05CIDCLABE@MINUS?$AA@ DB 'MINUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLONMCGA@PLUS?$AA@
CONST	SEGMENT
??_C@_04CLONMCGA@PLUS?$AA@ DB 'PLUS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LDFNPPCJ@SEMI?$AA@
CONST	SEGMENT
??_C@_04LDFNPPCJ@SEMI?$AA@ DB 'SEMI', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OFAMAJDB@COMMA?$AA@
CONST	SEGMENT
??_C@_05OFAMAJDB@COMMA?$AA@ DB 'COMMA', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NJKMKGPF@COLON?$AA@
CONST	SEGMENT
??_C@_05NJKMKGPF@COLON?$AA@ DB 'COLON', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NIHFNAF@RSQB?$AA@
CONST	SEGMENT
??_C@_04NIHFNAF@RSQB?$AA@ DB 'RSQB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NCFHHEOG@LSQB?$AA@
CONST	SEGMENT
??_C@_04NCFHHEOG@LSQB?$AA@ DB 'LSQB', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EJNGEDMK@RPAR?$AA@
CONST	SEGMENT
??_C@_04EJNGEDMK@RPAR?$AA@ DB 'RPAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JGAGGKCJ@LPAR?$AA@
CONST	SEGMENT
??_C@_04JGAGGKCJ@LPAR?$AA@ DB 'LPAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CICIIECI@DEDENT?$AA@
CONST	SEGMENT
??_C@_06CICIIECI@DEDENT?$AA@ DB 'DEDENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CDDIBFCL@INDENT?$AA@
CONST	SEGMENT
??_C@_06CDDIBFCL@INDENT?$AA@ DB 'INDENT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNGHCLKN@NEWLINE?$AA@
CONST	SEGMENT
??_C@_07CNGHCLKN@NEWLINE?$AA@ DB 'NEWLINE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IGECGLFO@STRING?$AA@
CONST	SEGMENT
??_C@_06IGECGLFO@STRING?$AA@ DB 'STRING', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EFEGMLFC@NUMBER?$AA@
CONST	SEGMENT
??_C@_06EFEGMLFC@NUMBER?$AA@ DB 'NUMBER', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKHEEB@NAME?$AA@
CONST	SEGMENT
??_C@_04IPKHEEB@NAME?$AA@ DB 'NAME', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MOKDLBPF@ENDMARKER?$AA@
CONST	SEGMENT
??_C@_09MOKDLBPF@ENDMARKER?$AA@ DB 'ENDMARKER', 00H	; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\tokenizer.c
pdata	SEGMENT
$pdata$tok_new DD imagerel tok_new
	DD	imagerel tok_new+213
	DD	imagerel $unwind$tok_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_new DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT tok_new
_TEXT	SEGMENT
tok_new	PROC						; COMDAT

; 114  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 115  :     struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(
; 116  :                                             sizeof(struct tok_state));

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	b9 e0 03 00 00	 mov	 ecx, 992		; 000003e0H
  0000e	85 c0		 test	 eax, eax
  00010	74 07		 je	 SHORT $LN4@tok_new
  00012	e8 00 00 00 00	 call	 _PxMem_Malloc
  00017	eb 06		 jmp	 SHORT $LN5@tok_new
$LN4@tok_new:
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN5@tok_new:

; 117  :     if (tok == NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	75 05		 jne	 SHORT $LN1@tok_new

; 145  : #endif
; 146  :     return tok;
; 147  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN1@tok_new:

; 118  :         return NULL;
; 119  :     tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;

  00029	33 c9		 xor	 ecx, ecx

; 120  :     tok->done = E_OK;

  0002b	c7 40 28 0a 00
	00 00		 mov	 DWORD PTR [rax+40], 10

; 121  :     tok->fp = NULL;
; 122  :     tok->input = NULL;
; 123  :     tok->tabsize = TABSIZE;

  00032	48 c7 40 38 08
	00 00 00	 mov	 QWORD PTR [rax+56], 8

; 124  :     tok->indent = 0;
; 125  :     tok->indstack[0] = 0;
; 126  :     tok->atbol = 1;

  0003a	48 c7 80 d0 01
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+464], 1

; 127  :     tok->pendin = 0;
; 128  :     tok->prompt = tok->nextprompt = NULL;
; 129  :     tok->lineno = 0;
; 130  :     tok->level = 0;
; 131  :     tok->altwarning = 1;

  00045	c7 80 f8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+504], 1

; 132  :     tok->alterror = 1;

  0004f	c7 80 fc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+508], 1
  00059	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  0005d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00061	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  00065	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00069	48 89 08	 mov	 QWORD PTR [rax], rcx
  0006c	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  00070	48 89 88 d8 03
	00 00		 mov	 QWORD PTR [rax+984], rcx
  00077	89 48 40	 mov	 DWORD PTR [rax+64], ecx
  0007a	48 89 88 e0 01
	00 00		 mov	 QWORD PTR [rax+480], rcx
  00081	48 89 88 d8 01
	00 00		 mov	 QWORD PTR [rax+472], rcx
  00088	48 89 88 e8 01
	00 00		 mov	 QWORD PTR [rax+488], rcx

; 133  :     tok->alttabsize = 1;
; 134  :     tok->altindstack[0] = 0;
; 135  :     tok->decoding_state = STATE_INIT;

  0008f	48 89 88 94 03
	00 00		 mov	 QWORD PTR [rax+916], rcx

; 136  :     tok->decoding_erred = 0;
; 137  :     tok->read_coding_spec = 0;

  00096	89 88 9c 03 00
	00		 mov	 DWORD PTR [rax+924], ecx

; 138  :     tok->enc = NULL;

  0009c	48 89 88 c8 03
	00 00		 mov	 QWORD PTR [rax+968], rcx

; 139  :     tok->encoding = NULL;

  000a3	48 89 88 a0 03
	00 00		 mov	 QWORD PTR [rax+928], rcx

; 140  :     tok->cont_line = 0;

  000aa	89 88 a8 03 00
	00		 mov	 DWORD PTR [rax+936], ecx

; 141  : #ifndef PGEN
; 142  :     tok->filename = NULL;

  000b0	48 89 88 f0 01
	00 00		 mov	 QWORD PTR [rax+496], rcx

; 143  :     tok->decoding_readline = NULL;

  000b7	48 89 88 b8 03
	00 00		 mov	 QWORD PTR [rax+952], rcx

; 144  :     tok->decoding_buffer = NULL;

  000be	48 89 88 c0 03
	00 00		 mov	 QWORD PTR [rax+960], rcx
  000c5	48 c7 80 00 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+512], 1

; 145  : #endif
; 146  :     return tok;
; 147  : }

  000d0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d4	c3		 ret	 0
tok_new	ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_string DD imagerel new_string
	DD	imagerel new_string+147
	DD	imagerel $unwind$new_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_string DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT new_string
_TEXT	SEGMENT
s$ = 48
len$ = 56
tok$ = 64
new_string PROC						; COMDAT

; 151  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b f0	 mov	 rsi, r8
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 152  :     char* result = (char *)PyMem_MALLOC(len + 1);

  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	74 0b		 je	 SHORT $LN8@new_string
  00026	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  0002a	e8 00 00 00 00	 call	 _PxMem_Malloc
  0002f	eb 25		 jmp	 SHORT $LN11@new_string
$LN8@new_string:
  00031	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  00035	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0003f	48 3b c1	 cmp	 rax, rcx
  00042	77 31		 ja	 SHORT $LN10@new_string
  00044	48 85 c0	 test	 rax, rax
  00047	b9 01 00 00 00	 mov	 ecx, 1
  0004c	48 0f 45 c8	 cmovne	 rcx, rax
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN11@new_string:
  00056	48 8b d8	 mov	 rbx, rax

; 153  :     if (!result) {

  00059	48 85 c0	 test	 rax, rax
  0005c	74 17		 je	 SHORT $LN10@new_string

; 156  :     }
; 157  :     memcpy(result, s, len);

  0005e	4c 8b c7	 mov	 r8, rdi
  00061	48 8b d5	 mov	 rdx, rbp
  00064	48 8b c8	 mov	 rcx, rax
  00067	e8 00 00 00 00	 call	 memcpy

; 158  :     result[len] = '\0';

  0006c	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0

; 159  :     return result;

  00070	48 8b c3	 mov	 rax, rbx
  00073	eb 09		 jmp	 SHORT $LN2@new_string
$LN10@new_string:

; 154  :         tok->done = E_NOMEM;

  00075	c7 46 28 0f 00
	00 00		 mov	 DWORD PTR [rsi+40], 15

; 155  :         return NULL;

  0007c	33 c0		 xor	 eax, eax
$LN2@new_string:

; 160  : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00088	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
new_string ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$error_ret DD imagerel error_ret
	DD	imagerel error_ret+100
	DD	imagerel $unwind$error_ret
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$error_ret DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT error_ret
_TEXT	SEGMENT
tok$ = 48
error_ret PROC						; COMDAT

; 186  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 187  :     tok->decoding_erred = 1;
; 188  :     if (tok->fp != NULL && tok->buf != NULL) /* see PyTokenizer_Free */

  00006	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	c7 81 98 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rcx+920], 1
  00018	74 3b		 je	 SHORT $LN6@error_ret
  0001a	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0001e	74 35		 je	 SHORT $LN6@error_ret

; 189  :         PyMem_FREE(tok->buf);

  00020	e8 00 00 00 00	 call	 _Py_PXCTX
  00025	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00028	85 c0		 test	 eax, eax
  0002a	74 14		 je	 SHORT $LN4@error_ret
  0002c	e8 00 00 00 00	 call	 _PxMem_Free

; 190  :     tok->buf = NULL;

  00031	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 191  :     return NULL;                /* as if it were EOF */

  00038	33 c0		 xor	 eax, eax

; 192  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN4@error_ret:

; 189  :         PyMem_FREE(tok->buf);

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 190  :     tok->buf = NULL;

  00046	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 191  :     return NULL;                /* as if it were EOF */

  0004d	33 c0		 xor	 eax, eax

; 192  : }

  0004f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN6@error_ret:

; 190  :     tok->buf = NULL;

  00055	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 191  :     return NULL;                /* as if it were EOF */

  0005c	33 c0		 xor	 eax, eax

; 192  : }

  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
error_ret ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@		; `string'
PUBLIC	??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@		; `string'
PUBLIC	??_C@_08PJOFPIOJ@latin?91?9?$AA@		; `string'
PUBLIC	??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@		; `string'
PUBLIC	??_C@_0L@CCLJNNOO@iso?98859?91?$AA@		; `string'
PUBLIC	??_C@_07BJPINKOJ@latin?91?$AA@			; `string'
PUBLIC	??_C@_06CAIILBD@utf?98?9?$AA@			; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_tolower:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_normal_name DD imagerel get_normal_name
	DD	imagerel get_normal_name+354
	DD	imagerel $unwind$get_normal_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_normal_name DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@
CONST	SEGMENT
??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@ DB 'iso-latin-1-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@
CONST	SEGMENT
??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@ DB 'iso-8859-1-', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PJOFPIOJ@latin?91?9?$AA@
CONST	SEGMENT
??_C@_08PJOFPIOJ@latin?91?9?$AA@ DB 'latin-1-', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@
CONST	SEGMENT
??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@ DB 'iso-latin-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
CONST	SEGMENT
??_C@_0L@CCLJNNOO@iso?98859?91?$AA@ DB 'iso-8859-1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJPINKOJ@latin?91?$AA@
CONST	SEGMENT
??_C@_07BJPINKOJ@latin?91?$AA@ DB 'latin-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CAIILBD@utf?98?9?$AA@
CONST	SEGMENT
??_C@_06CAIILBD@utf?98?9?$AA@ DB 'utf-8-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_normal_name
_TEXT	SEGMENT
buf$ = 32
s$ = 64
get_normal_name PROC					; COMDAT

; 197  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 198  :     char buf[13];
; 199  :     int i;
; 200  :     for (i = 0; i < 12; i++) {

  0001a	33 db		 xor	 ebx, ebx
  0001c	48 8d 44 24 20	 lea	 rax, QWORD PTR buf$[rsp]
  00021	48 8b e9	 mov	 rbp, rcx
  00024	48 2b e8	 sub	 rbp, rax
  00027	4c 8b e1	 mov	 r12, rcx
  0002a	8b fb		 mov	 edi, ebx
  0002c	0f 1f 40 00	 npad	 4
$LL13@get_normal:

; 201  :         int c = s[i];

  00030	48 8d 74 3c 20	 lea	 rsi, QWORD PTR buf$[rsp+rdi]
  00035	0f be 0c 2e	 movsx	 ecx, BYTE PTR [rsi+rbp]

; 202  :         if (c == '\0')

  00039	85 c9		 test	 ecx, ecx
  0003b	74 1d		 je	 SHORT $LN17@get_normal

; 203  :             break;
; 204  :         else if (c == '_')

  0003d	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  00040	75 05		 jne	 SHORT $LN8@get_normal

; 205  :             buf[i] = '-';

  00042	c6 06 2d	 mov	 BYTE PTR [rsi], 45	; 0000002dH

; 206  :         else

  00045	eb 08		 jmp	 SHORT $LN12@get_normal
$LN8@get_normal:

; 207  :             buf[i] = tolower(c);

  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  0004d	88 06		 mov	 BYTE PTR [rsi], al
$LN12@get_normal:

; 198  :     char buf[13];
; 199  :     int i;
; 200  :     for (i = 0; i < 12; i++) {

  0004f	48 ff c7	 inc	 rdi
  00052	ff c3		 inc	 ebx
  00054	48 83 ff 0c	 cmp	 rdi, 12
  00058	7c d6		 jl	 SHORT $LL13@get_normal
$LN17@get_normal:

; 208  :     }
; 209  :     buf[i] = '\0';

  0005a	48 63 c3	 movsxd	 rax, ebx

; 210  :     if (strcmp(buf, "utf-8") == 0 ||
; 211  :         strncmp(buf, "utf-8-", 6) == 0)

  0005d	48 8d 74 24 20	 lea	 rsi, QWORD PTR buf$[rsp]
  00062	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00069	b9 06 00 00 00	 mov	 ecx, 6
  0006e	c6 44 04 20 00	 mov	 BYTE PTR buf$[rsp+rax], 0
  00073	f3 a6		 repe cmpsb
  00075	0f 84 c5 00 00
	00		 je	 $LN5@get_normal
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CAIILBD@utf?98?9?$AA@
  00082	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00087	41 b8 06 00 00
	00		 mov	 r8d, 6
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00093	85 c0		 test	 eax, eax
  00095	0f 84 a5 00 00
	00		 je	 $LN5@get_normal

; 213  :     else if (strcmp(buf, "latin-1") == 0 ||
; 214  :              strcmp(buf, "iso-8859-1") == 0 ||
; 215  :              strcmp(buf, "iso-latin-1") == 0 ||
; 216  :              strncmp(buf, "latin-1-", 8) == 0 ||
; 217  :              strncmp(buf, "iso-8859-1-", 11) == 0 ||
; 218  :              strncmp(buf, "iso-latin-1-", 12) == 0)

  0009b	48 8d 74 24 20	 lea	 rsi, QWORD PTR buf$[rsp]
  000a0	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07BJPINKOJ@latin?91?$AA@
  000a7	b9 08 00 00 00	 mov	 ecx, 8
  000ac	f3 a6		 repe cmpsb
  000ae	0f 84 83 00 00
	00		 je	 $LN2@get_normal
  000b4	48 8d 74 24 20	 lea	 rsi, QWORD PTR buf$[rsp]
  000b9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  000c0	b9 0b 00 00 00	 mov	 ecx, 11
  000c5	f3 a6		 repe cmpsb
  000c7	74 6e		 je	 SHORT $LN2@get_normal
  000c9	48 8d 74 24 20	 lea	 rsi, QWORD PTR buf$[rsp]
  000ce	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0M@IGGGJLIN@iso?9latin?91?$AA@
  000d5	b9 0c 00 00 00	 mov	 ecx, 12
  000da	f3 a6		 repe cmpsb
  000dc	74 59		 je	 SHORT $LN2@get_normal
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PJOFPIOJ@latin?91?9?$AA@
  000e5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000ea	41 b8 08 00 00
	00		 mov	 r8d, 8
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000f6	85 c0		 test	 eax, eax
  000f8	74 3d		 je	 SHORT $LN2@get_normal
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GHLKCMEN@iso?98859?91?9?$AA@
  00101	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00106	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00112	85 c0		 test	 eax, eax
  00114	74 21		 je	 SHORT $LN2@get_normal
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LDKFMDOJ@iso?9latin?91?9?$AA@
  0011d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00122	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0012e	85 c0		 test	 eax, eax
  00130	74 05		 je	 SHORT $LN2@get_normal

; 220  :     else
; 221  :         return s;

  00132	49 8b c4	 mov	 rax, r12
  00135	eb 10		 jmp	 SHORT $LN1@get_normal
$LN2@get_normal:

; 219  :         return "iso-8859-1";

  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@CCLJNNOO@iso?98859?91?$AA@
  0013e	eb 07		 jmp	 SHORT $LN1@get_normal
$LN5@get_normal:

; 212  :         return "utf-8";

  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
$LN1@get_normal:

; 222  : }

  00147	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0014c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00151	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00156	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0015b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015f	41 5c		 pop	 r12
  00161	c3		 ret	 0
get_normal_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_06GDAGLJDI@coding?$AA@			; `string'
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_coding_spec DD imagerel get_coding_spec
	DD	imagerel get_coding_spec+66
	DD	imagerel $unwind$get_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$get_coding_spec DD imagerel get_coding_spec+66
	DD	imagerel get_coding_spec+222
	DD	imagerel $chain$4$get_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$get_coding_spec DD imagerel get_coding_spec+222
	DD	imagerel get_coding_spec+237
	DD	imagerel $chain$5$get_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$get_coding_spec DD imagerel get_coding_spec+237
	DD	imagerel get_coding_spec+403
	DD	imagerel $chain$6$get_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$get_coding_spec DD imagerel get_coding_spec+403
	DD	imagerel get_coding_spec+407
	DD	imagerel $chain$8$get_coding_spec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$get_coding_spec DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	0c7400H
	DD	0b6400H
	DD	0a3400H
	DD	imagerel get_coding_spec
	DD	imagerel get_coding_spec+66
	DD	imagerel $unwind$get_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$get_coding_spec DD 0a0021H
	DD	04f400H
	DD	05c400H
	DD	0c7400H
	DD	0b6400H
	DD	0a3400H
	DD	imagerel get_coding_spec
	DD	imagerel get_coding_spec+66
	DD	imagerel $unwind$get_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$get_coding_spec DD 021H
	DD	imagerel get_coding_spec
	DD	imagerel get_coding_spec+66
	DD	imagerel $unwind$get_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$get_coding_spec DD 0a1921H
	DD	04f419H
	DD	05c414H
	DD	0c740fH
	DD	0b640aH
	DD	0a3405H
	DD	imagerel get_coding_spec
	DD	imagerel get_coding_spec+66
	DD	imagerel $unwind$get_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_coding_spec DD 040a01H
	DD	0e006520aH
	DD	05002d004H
xdata	ENDS
;	COMDAT ??_C@_06GDAGLJDI@coding?$AA@
CONST	SEGMENT
??_C@_06GDAGLJDI@coding?$AA@ DB 'coding', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_coding_spec
_TEXT	SEGMENT
s$ = 80
spec$ = 88
size$ = 96
tok$ = 104
get_coding_spec PROC					; COMDAT

; 228  : {

  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	4c 8b ea	 mov	 r13, rdx

; 229  :     Py_ssize_t i;
; 230  :     *spec = NULL;
; 231  :     /* Coding spec must be in a comment, and that comment must be
; 232  :      * the only statement on the source code line. */
; 233  :     for (i = 0; i < size - 6; i++) {

  0000d	49 8d 68 fa	 lea	 rbp, QWORD PTR [r8-6]
  00011	48 8b d1	 mov	 rdx, rcx
  00014	33 c9		 xor	 ecx, ecx
  00016	4d 8b f1	 mov	 r14, r9
  00019	49 89 4d 00	 mov	 QWORD PTR [r13], rcx
  0001d	48 85 ed	 test	 rbp, rbp
  00020	7e 20		 jle	 SHORT $LN40@get_coding
$LL20@get_coding:

; 234  :         if (s[i] == '#')

  00022	0f b6 04 11	 movzx	 eax, BYTE PTR [rcx+rdx]
  00026	3c 23		 cmp	 al, 35			; 00000023H
  00028	74 18		 je	 SHORT $LN40@get_coding

; 235  :             break;
; 236  :         if (s[i] != ' ' && s[i] != '\t' && s[i] != '\014')

  0002a	3c 20		 cmp	 al, 32			; 00000020H
  0002c	74 0c		 je	 SHORT $LN19@get_coding
  0002e	3c 09		 cmp	 al, 9
  00030	74 08		 je	 SHORT $LN19@get_coding
  00032	3c 0c		 cmp	 al, 12
  00034	0f 85 a4 00 00
	00		 jne	 $LN31@get_coding
$LN19@get_coding:

; 229  :     Py_ssize_t i;
; 230  :     *spec = NULL;
; 231  :     /* Coding spec must be in a comment, and that comment must be
; 232  :      * the only statement on the source code line. */
; 233  :     for (i = 0; i < size - 6; i++) {

  0003a	48 ff c1	 inc	 rcx
  0003d	48 3b cd	 cmp	 rcx, rbp
  00040	7c e0		 jl	 SHORT $LL20@get_coding
$LN40@get_coding:
  00042	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00047	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0004c	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00051	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00056	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 238  :     }
; 239  :     for (; i < size - 6; i++) { /* XXX inefficient search */

  0005b	48 3b cd	 cmp	 rcx, rbp
  0005e	0f 8d 07 01 00
	00		 jge	 $LN41@get_coding
  00064	49 c7 c4 fa ff
	ff ff		 mov	 r12, -6
  0006b	48 8d 74 11 06	 lea	 rsi, QWORD PTR [rcx+rdx+6]
  00070	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:_Py_ctype_table
  00077	4c 2b e2	 sub	 r12, rdx
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL15@get_coding:

; 240  :         const char* t = s + i;
; 241  :         if (strncmp(t, "coding", 6) == 0) {

  00080	48 8d 4e fa	 lea	 rcx, QWORD PTR [rsi-6]
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GDAGLJDI@coding?$AA@
  0008b	41 b8 06 00 00
	00		 mov	 r8d, 6
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00097	85 c0		 test	 eax, eax
  00099	0f 85 bc 00 00
	00		 jne	 $LN14@get_coding

; 242  :             const char* begin = NULL;
; 243  :             t += 6;
; 244  :             if (t[0] != ':' && t[0] != '=')

  0009f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000a2	48 8b d6	 mov	 rdx, rsi
  000a5	3c 3a		 cmp	 al, 58			; 0000003aH
  000a7	74 08		 je	 SHORT $LL10@get_coding
  000a9	3c 3d		 cmp	 al, 61			; 0000003dH
  000ab	0f 85 aa 00 00
	00		 jne	 $LN14@get_coding
$LL10@get_coding:

; 245  :                 continue;
; 246  :             do {
; 247  :                 t++;
; 248  :             } while (t[0] == '\x20' || t[0] == '\t');

  000b1	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  000b5	48 ff c2	 inc	 rdx
  000b8	3c 20		 cmp	 al, 32			; 00000020H
  000ba	74 f5		 je	 SHORT $LL10@get_coding
  000bc	3c 09		 cmp	 al, 9
  000be	74 f1		 je	 SHORT $LL10@get_coding

; 249  : 
; 250  :             begin = t;

  000c0	48 8b ca	 mov	 rcx, rdx
$LL7@get_coding:

; 251  :             while (Py_ISALNUM(t[0]) ||
; 252  :                    t[0] == '-' || t[0] == '_' || t[0] == '.')

  000c3	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000c6	41 f6 04 87 07	 test	 BYTE PTR [r15+rax*4], 7
  000cb	75 0c		 jne	 SHORT $LN5@get_coding
  000cd	3c 2d		 cmp	 al, 45			; 0000002dH
  000cf	74 08		 je	 SHORT $LN5@get_coding
  000d1	3c 5f		 cmp	 al, 95			; 0000005fH
  000d3	74 04		 je	 SHORT $LN5@get_coding
  000d5	3c 2e		 cmp	 al, 46			; 0000002eH
  000d7	75 14		 jne	 SHORT $LN6@get_coding
$LN5@get_coding:

; 253  :                 t++;

  000d9	48 ff c2	 inc	 rdx
  000dc	eb e5		 jmp	 SHORT $LL7@get_coding
$LN31@get_coding:

; 237  :             return 1;

  000de	b8 01 00 00 00	 mov	 eax, 1

; 272  : }

  000e3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e7	41 5e		 pop	 r14
  000e9	41 5d		 pop	 r13
  000eb	5d		 pop	 rbp
  000ec	c3		 ret	 0
$LN6@get_coding:

; 254  : 
; 255  :             if (begin < t) {

  000ed	48 3b ca	 cmp	 rcx, rdx
  000f0	73 69		 jae	 SHORT $LN14@get_coding

; 256  :                 char* r = new_string(begin, t - begin, tok);

  000f2	48 2b d1	 sub	 rdx, rcx
  000f5	4d 8b c6	 mov	 r8, r14
  000f8	e8 00 00 00 00	 call	 new_string
  000fd	48 8b f8	 mov	 rdi, rax

; 257  :                 char* q;
; 258  :                 if (!r)

  00100	48 85 c0	 test	 rax, rax
  00103	0f 84 8a 00 00
	00		 je	 $LN32@get_coding

; 260  :                 q = get_normal_name(r);

  00109	48 8b c8	 mov	 rcx, rax
  0010c	e8 00 00 00 00	 call	 get_normal_name
  00111	48 8b d8	 mov	 rbx, rax

; 261  :                 if (r != q) {

  00114	48 3b f8	 cmp	 rdi, rax
  00117	74 3e		 je	 SHORT $LN1@get_coding

; 262  :                     PyMem_FREE(r);

  00119	e8 00 00 00 00	 call	 _Py_PXCTX
  0011e	48 8b cf	 mov	 rcx, rdi
  00121	85 c0		 test	 eax, eax
  00123	74 07		 je	 SHORT $LN23@get_coding
  00125	e8 00 00 00 00	 call	 _PxMem_Free
  0012a	eb 06		 jmp	 SHORT $LN24@get_coding
$LN23@get_coding:
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@get_coding:

; 263  :                     r = new_string(q, strlen(q), tok);

  00132	48 83 c9 ff	 or	 rcx, -1
  00136	33 c0		 xor	 eax, eax
  00138	48 8b fb	 mov	 rdi, rbx
  0013b	f2 ae		 repne scasb
  0013d	4d 8b c6	 mov	 r8, r14
  00140	48 f7 d1	 not	 rcx
  00143	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00147	48 8b cb	 mov	 rcx, rbx
  0014a	e8 00 00 00 00	 call	 new_string
  0014f	48 8b f8	 mov	 rdi, rax

; 264  :                     if (!r)

  00152	48 85 c0	 test	 rax, rax
  00155	74 3c		 je	 SHORT $LN32@get_coding
$LN1@get_coding:

; 265  :                         return 0;
; 266  :                 }
; 267  :                 *spec = r;

  00157	49 89 7d 00	 mov	 QWORD PTR [r13], rdi
$LN14@get_coding:

; 238  :     }
; 239  :     for (; i < size - 6; i++) { /* XXX inefficient search */

  0015b	48 ff c6	 inc	 rsi
  0015e	49 8d 04 34	 lea	 rax, QWORD PTR [r12+rsi]
  00162	48 3b c5	 cmp	 rax, rbp
  00165	0f 8c 15 ff ff
	ff		 jl	 $LL15@get_coding
$LN41@get_coding:

; 268  :             }
; 269  :         }
; 270  :     }
; 271  :     return 1;

  0016b	b8 01 00 00 00	 mov	 eax, 1
$LN48@get_coding:
  00170	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  00175	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  0017a	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0017f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00184	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]

; 272  : }

  00189	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018d	41 5e		 pop	 r14
  0018f	41 5d		 pop	 r13
  00191	5d		 pop	 rbp
  00192	c3		 ret	 0
$LN32@get_coding:

; 259  :                     return 0;

  00193	33 c0		 xor	 eax, eax
  00195	eb d9		 jmp	 SHORT $LN48@get_coding
get_coding_spec ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@ ; `string'
PUBLIC	??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_SyntaxError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_coding_spec DD imagerel check_coding_spec
	DD	imagerel check_coding_spec+82
	DD	imagerel $unwind$check_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$check_coding_spec DD imagerel check_coding_spec+82
	DD	imagerel check_coding_spec+402
	DD	imagerel $chain$0$check_coding_spec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$check_coding_spec DD imagerel check_coding_spec+402
	DD	imagerel check_coding_spec+424
	DD	imagerel $chain$1$check_coding_spec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$check_coding_spec DD 021H
	DD	imagerel check_coding_spec
	DD	imagerel check_coding_spec+82
	DD	imagerel $unwind$check_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$check_coding_spec DD 020521H
	DD	083405H
	DD	imagerel check_coding_spec
	DD	imagerel check_coding_spec+82
	DD	imagerel $unwind$check_coding_spec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_coding_spec DD 081301H
	DD	0b6413H
	DD	095413H
	DD	0d00f3213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT ??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@
CONST	SEGMENT
??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@ DB 'encodin'
	DB	'g problem: %s with BOM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@ DB 'encoding problem: '
	DB	'%s', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_coding_spec
_TEXT	SEGMENT
line$ = 64
size$ = 72
cs$ = 80
tok$ = 80
set_readline$ = 88
check_coding_spec PROC					; COMDAT

; 282  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 283  :     char *cs;
; 284  :     int r = 1;
; 285  : 
; 286  :     if (tok->cont_line) {

  00013	41 83 b8 a8 03
	00 00 00	 cmp	 DWORD PTR [r8+936], 0
  0001b	4d 8b e9	 mov	 r13, r9
  0001e	4d 8b e0	 mov	 r12, r8
  00021	48 8b f2	 mov	 rsi, rdx
  00024	48 8b f9	 mov	 rdi, rcx
  00027	bd 01 00 00 00	 mov	 ebp, 1
  0002c	74 0c		 je	 SHORT $LN16@check_codi

; 287  :         /* It's a continuation line, so it can't be a coding spec. */
; 288  :         tok->read_coding_spec = 1;

  0002e	41 89 a8 9c 03
	00 00		 mov	 DWORD PTR [r8+924], ebp

; 289  :         return 1;

  00035	e9 58 01 00 00	 jmp	 $LN31@check_codi
$LN16@check_codi:

; 290  :     }
; 291  :     if (!get_coding_spec(line, &cs, size, tok))

  0003a	4d 8b c8	 mov	 r9, r8
  0003d	4c 8b c2	 mov	 r8, rdx
  00040	48 8d 54 24 50	 lea	 rdx, QWORD PTR cs$[rsp]
  00045	e8 00 00 00 00	 call	 get_coding_spec
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 42 01 00
	00		 je	 $LN17@check_codi
$LN15@check_codi:
  00052	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 292  :         return 0;
; 293  :     if (!cs) {

  00057	48 8b 5c 24 50	 mov	 rbx, QWORD PTR cs$[rsp]
  0005c	48 85 db	 test	 rbx, rbx
  0005f	75 54		 jne	 SHORT $LN14@check_codi

; 294  :         Py_ssize_t i;
; 295  :         for (i = 0; i < size; i++) {

  00061	48 85 f6	 test	 rsi, rsi
  00064	0f 8e 23 01 00
	00		 jle	 $LN22@check_codi
  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	48 f7 d9	 neg	 rcx
$LL13@check_codi:

; 296  :             if (line[i] == '#' || line[i] == '\n' || line[i] == '\r')

  00070	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00073	3c 23		 cmp	 al, 35			; 00000023H
  00075	0f 84 12 01 00
	00		 je	 $LN22@check_codi
  0007b	3c 0a		 cmp	 al, 10
  0007d	0f 84 0a 01 00
	00		 je	 $LN22@check_codi
  00083	3c 0d		 cmp	 al, 13
  00085	0f 84 02 01 00
	00		 je	 $LN22@check_codi

; 297  :                 break;
; 298  :             if (line[i] != ' ' && line[i] != '\t' && line[i] != '\014') {

  0008b	3c 20		 cmp	 al, 32			; 00000020H
  0008d	74 08		 je	 SHORT $LN12@check_codi
  0008f	3c 09		 cmp	 al, 9
  00091	74 04		 je	 SHORT $LN12@check_codi
  00093	3c 0c		 cmp	 al, 12
  00095	75 11		 jne	 SHORT $LN25@check_codi
$LN12@check_codi:

; 294  :         Py_ssize_t i;
; 295  :         for (i = 0; i < size; i++) {

  00097	48 ff c7	 inc	 rdi
  0009a	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]
  0009e	48 3b c6	 cmp	 rax, rsi
  000a1	7c cd		 jl	 SHORT $LL13@check_codi
  000a3	e9 e5 00 00 00	 jmp	 $LN22@check_codi
$LN25@check_codi:

; 299  :                 /* Stop checking coding spec after a line containing
; 300  :                  * anything except a comment. */
; 301  :                 tok->read_coding_spec = 1;

  000a8	41 89 ac 24 9c
	03 00 00	 mov	 DWORD PTR [r12+924], ebp

; 302  :                 break;
; 303  :             }
; 304  :         }
; 305  :         return 1;

  000b0	e9 d8 00 00 00	 jmp	 $LN22@check_codi
$LN14@check_codi:

; 306  :     }
; 307  :     tok->read_coding_spec = 1;
; 308  :     if (tok->encoding == NULL) {

  000b5	49 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR [r12+928]
  000bd	41 89 ac 24 9c
	03 00 00	 mov	 DWORD PTR [r12+924], ebp
  000c5	48 85 c0	 test	 rax, rax
  000c8	75 6e		 jne	 SHORT $LN7@check_codi

; 309  :         assert(tok->decoding_state == STATE_RAW);
; 310  :         if (strcmp(cs, "utf-8") == 0) {

  000ca	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  000d1	48 8b f3	 mov	 rsi, rbx
  000d4	b9 06 00 00 00	 mov	 ecx, 6
  000d9	f3 a6		 repe cmpsb
  000db	75 0d		 jne	 SHORT $LN6@check_codi

; 311  :             tok->encoding = cs;

  000dd	49 89 9c 24 a0
	03 00 00	 mov	 QWORD PTR [r12+928], rbx

; 312  :         } else {

  000e5	e9 a3 00 00 00	 jmp	 $LN22@check_codi
$LN6@check_codi:

; 313  :             r = set_readline(tok, cs);

  000ea	48 8b d3	 mov	 rdx, rbx
  000ed	49 8b cc	 mov	 rcx, r12
  000f0	41 ff d5	 call	 r13
  000f3	8b e8		 mov	 ebp, eax

; 314  :             if (r) {

  000f5	85 c0		 test	 eax, eax
  000f7	74 16		 je	 SHORT $LN4@check_codi

; 315  :                 tok->encoding = cs;

  000f9	49 89 9c 24 a0
	03 00 00	 mov	 QWORD PTR [r12+928], rbx

; 316  :                 tok->decoding_state = STATE_NORMAL;

  00101	41 c7 84 24 94
	03 00 00 02 00
	00 00		 mov	 DWORD PTR [r12+916], 2

; 317  :             }
; 318  :             else {

  0010d	eb 7e		 jmp	 SHORT $LN22@check_codi
$LN4@check_codi:

; 319  :                 PyErr_Format(PyExc_SyntaxError,
; 320  :                              "encoding problem: %s", cs);

  0010f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@OFHNCJLB@encoding?5problem?3?5?$CFs?$AA@
  0011d	4c 8b c3	 mov	 r8, rbx
  00120	e8 00 00 00 00	 call	 PyErr_Format

; 321  :                 PyMem_FREE(cs);

  00125	e8 00 00 00 00	 call	 _Py_PXCTX
  0012a	48 8b cb	 mov	 rcx, rbx
  0012d	85 c0		 test	 eax, eax
  0012f	74 56		 je	 SHORT $LN19@check_codi
  00131	e8 00 00 00 00	 call	 _PxMem_Free
  00136	eb 55		 jmp	 SHORT $LN22@check_codi
$LN7@check_codi:

; 322  :             }
; 323  :         }
; 324  :     } else {                /* then, compare cs with BOM */
; 325  :         r = (strcmp(tok->encoding, cs) == 0);

  00138	48 8b fb	 mov	 rdi, rbx
  0013b	48 2b f8	 sub	 rdi, rax
  0013e	66 90		 npad	 2
$LL27@check_codi:
  00140	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00143	0f b6 0c 38	 movzx	 ecx, BYTE PTR [rax+rdi]
  00147	2b d1		 sub	 edx, ecx
  00149	75 07		 jne	 SHORT $LN28@check_codi
  0014b	48 ff c0	 inc	 rax
  0014e	85 c9		 test	 ecx, ecx
  00150	75 ee		 jne	 SHORT $LL27@check_codi
$LN28@check_codi:
  00152	33 ed		 xor	 ebp, ebp
  00154	85 d2		 test	 edx, edx
  00156	40 0f 94 c5	 sete	 bpl

; 326  :         if (!r)

  0015a	85 ed		 test	 ebp, ebp
  0015c	75 16		 jne	 SHORT $LN1@check_codi

; 327  :             PyErr_Format(PyExc_SyntaxError,
; 328  :                          "encoding problem: %s with BOM", cs);

  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@FEGGLNCN@encoding?5problem?3?5?$CFs?5with?5BOM?$AA@
  0016c	4c 8b c3	 mov	 r8, rbx
  0016f	e8 00 00 00 00	 call	 PyErr_Format
$LN1@check_codi:

; 329  :         PyMem_FREE(cs);

  00174	e8 00 00 00 00	 call	 _Py_PXCTX
  00179	48 8b cb	 mov	 rcx, rbx
  0017c	85 c0		 test	 eax, eax
  0017e	74 07		 je	 SHORT $LN19@check_codi
  00180	e8 00 00 00 00	 call	 _PxMem_Free
  00185	eb 06		 jmp	 SHORT $LN22@check_codi
$LN19@check_codi:
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@check_codi:
  0018d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN31@check_codi:

; 330  :     }
; 331  :     return r;

  00192	8b c5		 mov	 eax, ebp
$LN17@check_codi:

; 332  : }

  00194	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00199	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0019e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a2	41 5d		 pop	 r13
  001a4	41 5c		 pop	 r12
  001a6	5f		 pop	 rdi
  001a7	c3		 ret	 0
check_coding_spec ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_bom DD imagerel check_bom
	DD	imagerel check_bom+244
	DD	imagerel $unwind$check_bom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_bom DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT check_bom
_TEXT	SEGMENT
get_char$ = 48
unget_char$ = 56
tok$ = 64
check_bom PROC						; COMDAT

; 343  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 344  :     int ch1, ch2, ch3;
; 345  :     ch1 = get_char(tok);

  00012	49 8b c8	 mov	 rcx, r8
  00015	49 8b d8	 mov	 rbx, r8
  00018	48 8b fa	 mov	 rdi, rdx
  0001b	ff d6		 call	 rsi

; 346  :     tok->decoding_state = STATE_RAW;

  0001d	c7 83 94 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+916], 1

; 347  :     if (ch1 == EOF) {

  00027	83 f8 ff	 cmp	 eax, -1

; 348  :         return 1;

  0002a	0f 84 af 00 00
	00		 je	 $LN13@check_bom

; 349  :     } else if (ch1 == 0xEF) {

  00030	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  00035	0f 85 9d 00 00
	00		 jne	 $LN6@check_bom

; 350  :         ch2 = get_char(tok);

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	ff d6		 call	 rsi

; 351  :         if (ch2 != 0xBB) {

  00040	3d bb 00 00 00	 cmp	 eax, 187		; 000000bbH
  00045	74 11		 je	 SHORT $LN5@check_bom

; 352  :             unget_char(ch2, tok);

  00047	48 8b d3	 mov	 rdx, rbx
  0004a	8b c8		 mov	 ecx, eax
  0004c	ff d7		 call	 rdi

; 353  :             unget_char(ch1, tok);

  0004e	b9 ef 00 00 00	 mov	 ecx, 239		; 000000efH

; 354  :             return 1;

  00053	e9 82 00 00 00	 jmp	 $LN14@check_bom
$LN5@check_bom:

; 355  :         }
; 356  :         ch3 = get_char(tok);

  00058	48 8b cb	 mov	 rcx, rbx
  0005b	ff d6		 call	 rsi

; 357  :         if (ch3 != 0xBF) {

  0005d	3d bf 00 00 00	 cmp	 eax, 191		; 000000bfH
  00062	74 18		 je	 SHORT $LN4@check_bom

; 358  :             unget_char(ch3, tok);

  00064	48 8b d3	 mov	 rdx, rbx
  00067	8b c8		 mov	 ecx, eax
  00069	ff d7		 call	 rdi

; 359  :             unget_char(ch2, tok);

  0006b	48 8b d3	 mov	 rdx, rbx
  0006e	b9 bb 00 00 00	 mov	 ecx, 187		; 000000bbH
  00073	ff d7		 call	 rdi

; 360  :             unget_char(ch1, tok);

  00075	b9 ef 00 00 00	 mov	 ecx, 239		; 000000efH

; 361  :             return 1;

  0007a	eb 5e		 jmp	 SHORT $LN14@check_bom
$LN4@check_bom:

; 389  :         return 1;
; 390  :     }
; 391  :     if (tok->encoding != NULL)

  0007c	48 83 bb a0 03
	00 00 00	 cmp	 QWORD PTR [rbx+928], 0
  00084	74 1d		 je	 SHORT $LN12@check_bom

; 392  :         PyMem_FREE(tok->encoding);

  00086	e8 00 00 00 00	 call	 _Py_PXCTX
  0008b	48 8b 8b a0 03
	00 00		 mov	 rcx, QWORD PTR [rbx+928]
  00092	85 c0		 test	 eax, eax
  00094	74 07		 je	 SHORT $LN11@check_bom
  00096	e8 00 00 00 00	 call	 _PxMem_Free
  0009b	eb 06		 jmp	 SHORT $LN12@check_bom
$LN11@check_bom:
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@check_bom:

; 393  :     tok->encoding = new_string("utf-8", 5, tok);

  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  000aa	4c 8b c3	 mov	 r8, rbx
  000ad	ba 05 00 00 00	 mov	 edx, 5
  000b2	e8 00 00 00 00	 call	 new_string

; 394  :     if (!tok->encoding)

  000b7	33 c9		 xor	 ecx, ecx
  000b9	48 85 c0	 test	 rax, rax
  000bc	48 89 83 a0 03
	00 00		 mov	 QWORD PTR [rbx+928], rax
  000c3	0f 95 c1	 setne	 cl
  000c6	8b c1		 mov	 eax, ecx

; 395  :         return 0;
; 396  :     /* No need to set_readline: input is already utf-8 */
; 397  :     return 1;
; 398  : }

  000c8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
$LN6@check_bom:

; 362  :         }
; 363  : #if 0
; 364  :     /* Disable support for UTF-16 BOMs until a decision
; 365  :        is made whether this needs to be supported.  */
; 366  :     } else if (ch1 == 0xFE) {
; 367  :         ch2 = get_char(tok);
; 368  :         if (ch2 != 0xFF) {
; 369  :             unget_char(ch2, tok);
; 370  :             unget_char(ch1, tok);
; 371  :             return 1;
; 372  :         }
; 373  :         if (!set_readline(tok, "utf-16-be"))
; 374  :             return 0;
; 375  :         tok->decoding_state = STATE_NORMAL;
; 376  :     } else if (ch1 == 0xFF) {
; 377  :         ch2 = get_char(tok);
; 378  :         if (ch2 != 0xFE) {
; 379  :             unget_char(ch2, tok);
; 380  :             unget_char(ch1, tok);
; 381  :             return 1;
; 382  :         }
; 383  :         if (!set_readline(tok, "utf-16-le"))
; 384  :             return 0;
; 385  :         tok->decoding_state = STATE_NORMAL;
; 386  : #endif
; 387  :     } else {
; 388  :         unget_char(ch1, tok);

  000d8	8b c8		 mov	 ecx, eax
$LN14@check_bom:
  000da	48 8b d3	 mov	 rdx, rbx
  000dd	ff d7		 call	 rdi
$LN13@check_bom:

; 395  :         return 0;
; 396  :     /* No need to set_readline: input is already utf-8 */
; 397  :     return 1;
; 398  : }

  000df	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
check_bom ENDP
_TEXT	ENDS
EXTRN	PyByteArray_FromStringAndSize:PROC
EXTRN	PyByteArray_AsString:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fp_readl DD imagerel fp_readl
	DD	imagerel fp_readl+446
	DD	imagerel $unwind$fp_readl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_readl DD 0a1601H
	DD	0d5416H
	DD	0c3416H
	DD	0e0125216H
	DD	0c00ed010H
	DD	0600b700cH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\tokenizer.c
xdata	ENDS
;	COMDAT fp_readl
_TEXT	SEGMENT
s$ = 96
size$ = 104
buflen$ = 112
tok$ = 112
fp_readl PROC						; COMDAT

; 417  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 418  :     PyObject* bufobj;
; 419  :     const char *buf;
; 420  :     Py_ssize_t buflen;
; 421  : 
; 422  :     /* Ask for one less byte so we can terminate it */
; 423  :     assert(size > 0);
; 424  :     size--;
; 425  : 
; 426  :     if (tok->decoding_buffer) {

  00016	49 8b 98 c0 03
	00 00		 mov	 rbx, QWORD PTR [r8+960]
  0001d	49 8b f0	 mov	 rsi, r8
  00020	4c 8b e9	 mov	 r13, rcx
  00023	8d 6a ff	 lea	 ebp, DWORD PTR [rdx-1]
  00026	48 85 db	 test	 rbx, rbx
  00029	74 3d		 je	 SHORT $LN19@fp_readl

; 427  :         bufobj = tok->decoding_buffer;
; 428  :         Py_INCREF(bufobj);

  0002b	e8 00 00 00 00	 call	 _Py_PXCTX
  00030	85 c0		 test	 eax, eax
  00032	75 4e		 jne	 SHORT $LN17@fp_readl
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00042	4c 8b cb	 mov	 r9, rbx
  00045	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00053	e8 00 00 00 00	 call	 _PyParallel_Guard
  00058	85 c0		 test	 eax, eax
  0005a	75 06		 jne	 SHORT $LN22@fp_readl
  0005c	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00060	74 20		 je	 SHORT $LN17@fp_readl
$LN22@fp_readl:
  00062	48 ff 43 50	 inc	 QWORD PTR [rbx+80]

; 429  :     }
; 430  :     else

  00066	eb 1a		 jmp	 SHORT $LN17@fp_readl
$LN19@fp_readl:

; 431  :     {
; 432  :         bufobj = PyObject_CallObject(tok->decoding_readline, NULL);

  00068	49 8b 88 b8 03
	00 00		 mov	 rcx, QWORD PTR [r8+952]
  0006f	33 d2		 xor	 edx, edx
  00071	e8 00 00 00 00	 call	 PyObject_CallObject
  00076	48 8b d8	 mov	 rbx, rax

; 433  :         if (bufobj == NULL)

  00079	48 85 c0	 test	 rax, rax
  0007c	0f 84 1d 01 00
	00		 je	 $LN3@fp_readl
$LN17@fp_readl:

; 434  :             goto error;
; 435  :     }
; 436  :     if (PyUnicode_CheckExact(bufobj))

  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type

; 437  :     {
; 438  :         buf = _PyUnicode_AsStringAndSize(bufobj, &buflen);

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00090	75 1d		 jne	 SHORT $LN16@fp_readl
  00092	48 8d 54 24 70	 lea	 rdx, QWORD PTR buflen$[rsp]
  00097	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  0009c	4c 8b e0	 mov	 r12, rax

; 439  :         if (buf == NULL) {

  0009f	48 85 c0	 test	 rax, rax
  000a2	0f 84 92 00 00
	00		 je	 $error$20639

; 440  :             goto error;
; 441  :         }
; 442  :     }
; 443  :     else

  000a8	48 8b 7c 24 70	 mov	 rdi, QWORD PTR buflen$[rsp]
  000ad	eb 16		 jmp	 SHORT $LN12@fp_readl
$LN16@fp_readl:

; 444  :     {
; 445  :         buf = PyByteArray_AsString(bufobj);

  000af	e8 00 00 00 00	 call	 PyByteArray_AsString
  000b4	4c 8b e0	 mov	 r12, rax

; 446  :         if (buf == NULL) {

  000b7	48 85 c0	 test	 rax, rax
  000ba	74 7e		 je	 SHORT $error$20639

; 447  :             goto error;
; 448  :         }
; 449  :         buflen = PyByteArray_GET_SIZE(bufobj);

  000bc	48 8b 7b 60	 mov	 rdi, QWORD PTR [rbx+96]
  000c0	48 89 7c 24 70	 mov	 QWORD PTR buflen$[rsp], rdi
$LN12@fp_readl:

; 450  :     }
; 451  : 
; 452  :     Py_XDECREF(tok->decoding_buffer);

  000c5	48 8b 8e c0 03
	00 00		 mov	 rcx, QWORD PTR [rsi+960]
  000cc	48 85 c9	 test	 rcx, rcx
  000cf	74 0a		 je	 SHORT $LN11@fp_readl
  000d1	e8 00 00 00 00	 call	 _Py_DecRef
  000d6	48 8b 7c 24 70	 mov	 rdi, QWORD PTR buflen$[rsp]
$LN11@fp_readl:

; 453  :     if (buflen > size) {

  000db	48 63 ed	 movsxd	 rbp, ebp
  000de	45 33 f6	 xor	 r14d, r14d
  000e1	48 3b fd	 cmp	 rdi, rbp
  000e4	7e 25		 jle	 SHORT $LN8@fp_readl

; 454  :         /* Too many chars, the rest goes into tok->decoding_buffer */
; 455  :         tok->decoding_buffer = PyByteArray_FromStringAndSize(buf+size,
; 456  :                                                          buflen-size);

  000e6	48 2b fd	 sub	 rdi, rbp
  000e9	49 8d 0c 2c	 lea	 rcx, QWORD PTR [r12+rbp]
  000ed	48 8b d7	 mov	 rdx, rdi
  000f0	e8 00 00 00 00	 call	 PyByteArray_FromStringAndSize
  000f5	48 89 86 c0 03
	00 00		 mov	 QWORD PTR [rsi+960], rax

; 457  :         if (tok->decoding_buffer == NULL)

  000fc	48 85 c0	 test	 rax, rax
  000ff	74 39		 je	 SHORT $error$20639

; 458  :             goto error;
; 459  :         buflen = size;

  00101	48 8b fd	 mov	 rdi, rbp
  00104	48 89 6c 24 70	 mov	 QWORD PTR buflen$[rsp], rbp

; 460  :     }
; 461  :     else

  00109	eb 07		 jmp	 SHORT $LN6@fp_readl
$LN8@fp_readl:

; 462  :         tok->decoding_buffer = NULL;

  0010b	4c 89 b6 c0 03
	00 00		 mov	 QWORD PTR [rsi+960], r14
$LN6@fp_readl:

; 463  : 
; 464  :     memcpy(s, buf, buflen);

  00112	4c 8b c7	 mov	 r8, rdi
  00115	49 8b d4	 mov	 rdx, r12
  00118	49 8b cd	 mov	 rcx, r13
  0011b	e8 00 00 00 00	 call	 memcpy

; 465  :     s[buflen] = '\0';

  00120	46 88 34 2f	 mov	 BYTE PTR [rdi+r13], r14b

; 466  :     if (buflen == 0) /* EOF */

  00124	4c 39 74 24 70	 cmp	 QWORD PTR buflen$[rsp], r14

; 467  :         s = NULL;
; 468  :     Py_DECREF(bufobj);

  00129	48 8b cb	 mov	 rcx, rbx
  0012c	4d 0f 44 ee	 cmove	 r13, r14
  00130	e8 00 00 00 00	 call	 _Py_DecRef

; 469  :     return s;

  00135	49 8b c5	 mov	 rax, r13
  00138	eb 6d		 jmp	 SHORT $LN20@fp_readl
$error$20639:

; 470  : 
; 471  : error:
; 472  :     Py_XDECREF(bufobj);

  0013a	e8 00 00 00 00	 call	 _Py_PXCTX
  0013f	85 c0		 test	 eax, eax
  00141	75 5c		 jne	 SHORT $LN3@fp_readl
  00143	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00147	a8 20		 test	 al, 32			; 00000020H
  00149	75 4c		 jne	 SHORT $LN30@fp_readl
  0014b	84 c0		 test	 al, al
  0014d	78 48		 js	 SHORT $LN30@fp_readl
  0014f	a8 02		 test	 al, 2
  00151	75 4c		 jne	 SHORT $LN3@fp_readl
  00153	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00157	75 46		 jne	 SHORT $LN3@fp_readl
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00167	4c 8b cb	 mov	 r9, rbx
  0016a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00170	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00178	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017d	48 8b cb	 mov	 rcx, rbx
  00180	85 c0		 test	 eax, eax
  00182	74 07		 je	 SHORT $LN35@fp_readl
  00184	e8 00 00 00 00	 call	 _Px_Dealloc
  00189	eb 14		 jmp	 SHORT $LN3@fp_readl
$LN35@fp_readl:
  0018b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00195	eb 08		 jmp	 SHORT $LN3@fp_readl
$LN30@fp_readl:
  00197	48 8b cb	 mov	 rcx, rbx
  0019a	e8 00 00 00 00	 call	 Px_DecRef
$LN3@fp_readl:

; 473  :     return error_ret(tok);

  0019f	48 8b ce	 mov	 rcx, rsi
  001a2	e8 00 00 00 00	 call	 error_ret
$LN20@fp_readl:

; 474  : }

  001a7	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001ac	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b5	41 5e		 pop	 r14
  001b7	41 5d		 pop	 r13
  001b9	41 5c		 pop	 r12
  001bb	5f		 pop	 rdi
  001bc	5e		 pop	 rsi
  001bd	c3		 ret	 0
fp_readl ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_07NGCAEEGB@isisOOO?$AA@			; `string'
PUBLIC	??_C@_02KFNNKBCK@io?$AA@			; `string'
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	__imp_lseek:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_fileno:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fp_setreadl DD imagerel fp_setreadl
	DD	imagerel fp_setreadl+53
	DD	imagerel $unwind$fp_setreadl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fp_setreadl DD imagerel fp_setreadl+53
	DD	imagerel fp_setreadl+461
	DD	imagerel $chain$2$fp_setreadl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fp_setreadl DD imagerel fp_setreadl+461
	DD	imagerel fp_setreadl+576
	DD	imagerel $chain$3$fp_setreadl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fp_setreadl DD 021H
	DD	imagerel fp_setreadl
	DD	imagerel fp_setreadl+53
	DD	imagerel $unwind$fp_setreadl
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fp_setreadl DD 061821H
	DD	012e418H
	DD	0117410H
	DD	0106408H
	DD	imagerel fp_setreadl
	DD	imagerel fp_setreadl+53
	DD	imagerel $unwind$fp_setreadl
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fp_setreadl DD 060d01H
	DD	0f009920dH
	DD	0c005d007H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NGCAEEGB@isisOOO?$AA@
CONST	SEGMENT
??_C@_07NGCAEEGB@isisOOO?$AA@ DB 'isisOOO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFNNKBCK@io?$AA@
CONST	SEGMENT
??_C@_02KFNNKBCK@io?$AA@ DB 'io', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\tokenizer.c
CONST	ENDS
;	COMDAT fp_setreadl
_TEXT	SEGMENT
tok$ = 128
enc$ = 136
fp_setreadl PROC					; COMDAT

; 488  : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 57		 push	 r15
  00009	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000d	4c 8b e9	 mov	 r13, rcx

; 489  :     PyObject *readline = NULL, *stream = NULL, *io = NULL;
; 490  :     _Py_IDENTIFIER(open);
; 491  :     _Py_IDENTIFIER(readline);
; 492  :     int fd;
; 493  :     long pos;
; 494  : 
; 495  :     io = PyImport_ImportModuleNoBlock("io");

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KFNNKBCK@io?$AA@
  00017	45 33 e4	 xor	 r12d, r12d
  0001a	4c 8b fa	 mov	 r15, rdx
  0001d	41 8b ec	 mov	 ebp, r12d
  00020	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00025	48 8b d8	 mov	 rbx, rax

; 496  :     if (io == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	0f 84 f8 01 00
	00		 je	 $LN3@fp_setread

; 497  :         goto cleanup;
; 498  : 
; 499  :     fd = fileno(tok->fp);

  00031	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  00035	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  0003d	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00045	4c 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r14
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno

; 500  :     /* Due to buffering the file offset for fd can be different from the file
; 501  :      * position of tok->fp.  If tok->fp was opened in text mode on Windows,
; 502  :      * its file position counts CRLF as one char and can't be directly mapped
; 503  :      * to the file offset for fd.  Instead we step back one byte and read to
; 504  :      * the end of line.*/
; 505  :     pos = ftell(tok->fp);

  00053	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  00057	8b f8		 mov	 edi, eax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  0005f	8b f0		 mov	 esi, eax

; 506  :     if (pos == -1 ||
; 507  :         lseek(fd, (off_t)(pos > 0 ? pos - 1 : pos), SEEK_SET) == (off_t)-1) {

  00061	83 f8 ff	 cmp	 eax, -1
  00064	0f 84 34 01 00
	00		 je	 $LN16@fp_setread
  0006a	8d 50 ff	 lea	 edx, DWORD PTR [rax-1]
  0006d	85 c0		 test	 eax, eax
  0006f	7f 02		 jg	 SHORT $LN22@fp_setread
  00071	8b d0		 mov	 edx, eax
$LN22@fp_setread:
  00073	45 33 c0	 xor	 r8d, r8d
  00076	8b cf		 mov	 ecx, edi
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	0f 84 17 01 00
	00		 je	 $LN16@fp_setread

; 509  :         goto cleanup;
; 510  :     }
; 511  : 
; 512  :     stream = _PyObject_CallMethodId(io, &PyId_open, "isisOOO",
; 513  :                     fd, "r", -1, enc, Py_None, Py_None, Py_False);

  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0008d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00096	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_open@?1??fp_setreadl@@9@9
  0009b	4c 8b 34 c8	 mov	 r14, QWORD PTR [rax+rcx*8]
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07NGCAEEGB@isisOOO?$AA@
  000ad	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b9	44 8b cf	 mov	 r9d, edi
  000bc	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000c1	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  000cd	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  000d2	49 03 d6	 add	 rdx, r14
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR [rsp+40], -1
  000e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e5	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000ea	48 8b f8	 mov	 rdi, rax

; 514  :     if (stream == NULL)

  000ed	48 85 c0	 test	 rax, rax
  000f0	0f 84 b6 00 00
	00		 je	 $LN7@fp_setread

; 515  :         goto cleanup;
; 516  : 
; 517  :     Py_XDECREF(tok->decoding_readline);

  000f6	49 8b 8d b8 03
	00 00		 mov	 rcx, QWORD PTR [r13+952]
  000fd	48 85 c9	 test	 rcx, rcx
  00100	74 05		 je	 SHORT $LN13@fp_setread
  00102	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@fp_setread:

; 518  :     readline = _PyObject_GetAttrId(stream, &PyId_readline);

  00107	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_readline@?1??fp_setreadl@@9@9
  0010c	48 8b cf	 mov	 rcx, rdi
  0010f	49 03 d6	 add	 rdx, r14
  00112	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00117	48 8b e8	 mov	 rbp, rax

; 519  :     tok->decoding_readline = readline;

  0011a	49 89 85 b8 03
	00 00		 mov	 QWORD PTR [r13+952], rax

; 520  :     if (pos > 0) {

  00121	85 f6		 test	 esi, esi
  00123	7e 12		 jle	 SHORT $cleanup$20690

; 521  :         if (PyObject_CallObject(readline, NULL) == NULL) {

  00125	33 d2		 xor	 edx, edx
  00127	48 8b c8	 mov	 rcx, rax
  0012a	e8 00 00 00 00	 call	 PyObject_CallObject
  0012f	48 85 c0	 test	 rax, rax
  00132	75 03		 jne	 SHORT $cleanup$20690

; 522  :             readline = NULL;

  00134	49 8b ec	 mov	 rbp, r12
$cleanup$20690:

; 523  :             goto cleanup;
; 524  :         }
; 525  :     }
; 526  : 
; 527  :   cleanup:
; 528  :     Py_XDECREF(stream);

  00137	e8 00 00 00 00	 call	 _Py_PXCTX
  0013c	85 c0		 test	 eax, eax
  0013e	75 6c		 jne	 SHORT $LN7@fp_setread
  00140	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00144	a8 20		 test	 al, 32			; 00000020H
  00146	75 4c		 jne	 SHORT $LN27@fp_setread
  00148	84 c0		 test	 al, al
  0014a	78 48		 js	 SHORT $LN27@fp_setread
  0014c	a8 02		 test	 al, 2
  0014e	75 5c		 jne	 SHORT $LN7@fp_setread
  00150	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00154	75 56		 jne	 SHORT $LN7@fp_setread
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00164	4c 8b cf	 mov	 r9, rdi
  00167	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0016d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00175	e8 00 00 00 00	 call	 _PyParallel_Guard
  0017a	48 8b cf	 mov	 rcx, rdi
  0017d	85 c0		 test	 eax, eax
  0017f	74 07		 je	 SHORT $LN32@fp_setread
  00181	e8 00 00 00 00	 call	 _Px_Dealloc
  00186	eb 24		 jmp	 SHORT $LN7@fp_setread
$LN32@fp_setread:
  00188	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0018c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00192	eb 18		 jmp	 SHORT $LN7@fp_setread
$LN27@fp_setread:
  00194	48 8b cf	 mov	 rcx, rdi
  00197	e8 00 00 00 00	 call	 Px_DecRef
  0019c	eb 0e		 jmp	 SHORT $LN7@fp_setread
$LN16@fp_setread:

; 508  :         PyErr_SetFromErrnoWithFilename(PyExc_OSError, NULL);

  0019e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  001a5	33 d2		 xor	 edx, edx
  001a7	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename
$LN7@fp_setread:

; 529  :     Py_XDECREF(io);

  001ac	e8 00 00 00 00	 call	 _Py_PXCTX
  001b1	4c 8b b4 24 90
	00 00 00	 mov	 r14, QWORD PTR [rsp+144]
  001b9	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]
  001c1	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001c9	85 c0		 test	 eax, eax
  001cb	75 5c		 jne	 SHORT $LN3@fp_setread
  001cd	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001d1	a8 20		 test	 al, 32			; 00000020H
  001d3	75 4c		 jne	 SHORT $LN38@fp_setread
  001d5	84 c0		 test	 al, al
  001d7	78 48		 js	 SHORT $LN38@fp_setread
  001d9	a8 02		 test	 al, 2
  001db	75 4c		 jne	 SHORT $LN3@fp_setread
  001dd	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001e1	75 46		 jne	 SHORT $LN3@fp_setread
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001f1	4c 8b cb	 mov	 r9, rbx
  001f4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001fa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00202	e8 00 00 00 00	 call	 _PyParallel_Guard
  00207	48 8b cb	 mov	 rcx, rbx
  0020a	85 c0		 test	 eax, eax
  0020c	74 07		 je	 SHORT $LN43@fp_setread
  0020e	e8 00 00 00 00	 call	 _Px_Dealloc
  00213	eb 14		 jmp	 SHORT $LN3@fp_setread
$LN43@fp_setread:
  00215	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00219	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0021f	eb 08		 jmp	 SHORT $LN3@fp_setread
$LN38@fp_setread:
  00221	48 8b cb	 mov	 rcx, rbx
  00224	e8 00 00 00 00	 call	 Px_DecRef
$LN3@fp_setread:

; 530  :     return readline != NULL;

  00229	48 85 ed	 test	 rbp, rbp
  0022c	41 0f 95 c4	 setne	 r12b
  00230	41 8b c4	 mov	 eax, r12d

; 531  : }

  00233	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00237	41 5f		 pop	 r15
  00239	41 5d		 pop	 r13
  0023b	41 5c		 pop	 r12
  0023d	5d		 pop	 rbp
  0023e	5b		 pop	 rbx
  0023f	c3		 ret	 0
fp_setreadl ENDP
_TEXT	ENDS
EXTRN	__imp_getc:PROC
; Function compile flags: /Ogtpy
;	COMDAT fp_getc
_TEXT	SEGMENT
tok$ = 8
fp_getc	PROC						; COMDAT

; 536  :     return getc(tok->fp);

  00000	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]

; 537  : }

  00004	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_getc
fp_getc	ENDP
_TEXT	ENDS
EXTRN	__imp_ungetc:PROC
; Function compile flags: /Ogtpy
;	COMDAT fp_ungetc
_TEXT	SEGMENT
c$ = 8
tok$ = 16
fp_ungetc PROC						; COMDAT

; 542  :     ungetc(c, tok->fp);

  00000	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]

; 543  : }

  00004	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_ungetc
fp_ungetc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT valid_utf8
_TEXT	SEGMENT
s$ = 8
valid_utf8 PROC						; COMDAT

; 550  :     int expected = 0;
; 551  :     int length;
; 552  :     if (*s < 0x80)

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	48 8b d1	 mov	 rdx, rcx
  00006	3c 80		 cmp	 al, 128			; 00000080H
  00008	73 06		 jae	 SHORT $LN13@valid_utf8

; 553  :         /* single-byte code */
; 554  :         return 1;

  0000a	b8 01 00 00 00	 mov	 eax, 1

; 571  : }

  0000f	c3		 ret	 0
$LN13@valid_utf8:

; 555  :     if (*s < 0xc0)

  00010	3c c0		 cmp	 al, 192			; 000000c0H

; 556  :         /* following byte */
; 557  :         return 0;

  00012	72 43		 jb	 SHORT $LN7@valid_utf8

; 558  :     if (*s < 0xE0)

  00014	3c e0		 cmp	 al, 224			; 000000e0H
  00016	73 07		 jae	 SHORT $LN11@valid_utf8

; 559  :         expected = 1;

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	eb 14		 jmp	 SHORT $LN6@valid_utf8
$LN11@valid_utf8:

; 560  :     else if (*s < 0xF0)

  0001f	3c f0		 cmp	 al, 240			; 000000f0H
  00021	73 07		 jae	 SHORT $LN9@valid_utf8

; 561  :         expected = 2;

  00023	b8 02 00 00 00	 mov	 eax, 2
  00028	eb 09		 jmp	 SHORT $LN6@valid_utf8
$LN9@valid_utf8:

; 562  :     else if (*s < 0xF8)

  0002a	3c f8		 cmp	 al, 248			; 000000f8H
  0002c	73 29		 jae	 SHORT $LN7@valid_utf8

; 563  :         expected = 3;

  0002e	b8 03 00 00 00	 mov	 eax, 3
$LN6@valid_utf8:

; 566  :     length = expected + 1;

  00033	44 8d 40 01	 lea	 r8d, DWORD PTR [rax+1]
  00037	48 98		 cdqe

; 567  :     for (; expected; expected--)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 15		 je	 SHORT $LN3@valid_utf8
  0003e	66 90		 npad	 2
$LL5@valid_utf8:

; 568  :         if (s[expected] < 0x80 || s[expected] >= 0xC0)

  00040	0f b6 0c 10	 movzx	 ecx, BYTE PTR [rax+rdx]
  00044	80 f9 80	 cmp	 cl, 128			; 00000080H
  00047	72 0e		 jb	 SHORT $LN7@valid_utf8
  00049	80 f9 c0	 cmp	 cl, 192			; 000000c0H
  0004c	73 09		 jae	 SHORT $LN7@valid_utf8

; 567  :     for (; expected; expected--)

  0004e	48 ff c8	 dec	 rax
  00051	75 ed		 jne	 SHORT $LL5@valid_utf8
$LN3@valid_utf8:

; 569  :             return 0;
; 570  :     return length;

  00053	41 8b c0	 mov	 eax, r8d

; 571  : }

  00056	c3		 ret	 0
$LN7@valid_utf8:

; 564  :     else
; 565  :         return 0;

  00057	33 c0		 xor	 eax, eax

; 571  : }

  00059	c3		 ret	 0
valid_utf8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@ ; `string'
EXTRN	Py_UniversalNewlineFgets:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decoding_fgets DD imagerel decoding_fgets
	DD	imagerel decoding_fgets+325
	DD	imagerel $unwind$decoding_fgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decoding_fgets DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@
CONST	SEGMENT
??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@ DB 'Non-UTF-'
	DB	'8 code starting with ''\x%.2x'' in file %U on line %i, but no'
	DB	' encoding declared; see http://python.org/dev/peps/pep-0263/ '
	DB	'for details', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT decoding_fgets
_TEXT	SEGMENT
s$ = 64
size$ = 72
tok$ = 80
decoding_fgets PROC					; COMDAT

; 578  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 579  :     char *line = NULL;
; 580  :     int badchar = 0;
; 581  :     for (;;) {
; 582  :         if (tok->decoding_state == STATE_NORMAL) {

  0000f	41 8b 80 94 03
	00 00		 mov	 eax, DWORD PTR [r8+916]
  00016	49 8b d8	 mov	 rbx, r8
  00019	8b fa		 mov	 edi, edx
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	83 f8 02	 cmp	 eax, 2
  00021	74 32		 je	 SHORT $LN21@decoding_f
$LL15@decoding_f:

; 586  :             break;
; 587  :         } else if (tok->decoding_state == STATE_RAW) {

  00023	83 f8 01	 cmp	 eax, 1
  00026	0f 84 bd 00 00
	00		 je	 $LN22@decoding_f

; 591  :             break;
; 592  :         } else {
; 593  :             /* We have not yet determined the encoding.
; 594  :                If an encoding is found, use the file-pointer
; 595  :                reader functions from now on. */
; 596  :             if (!check_bom(fp_getc, fp_ungetc, fp_setreadl, tok))

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fp_ungetc
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fp_getc
  0003a	4c 8b c3	 mov	 r8, rbx
  0003d	e8 00 00 00 00	 call	 check_bom
  00042	85 c0		 test	 eax, eax
  00044	0f 84 e4 00 00
	00		 je	 $LN27@decoding_f

; 579  :     char *line = NULL;
; 580  :     int badchar = 0;
; 581  :     for (;;) {
; 582  :         if (tok->decoding_state == STATE_NORMAL) {

  0004a	8b 83 94 03 00
	00		 mov	 eax, DWORD PTR [rbx+916]
  00050	83 f8 02	 cmp	 eax, 2
  00053	75 ce		 jne	 SHORT $LL15@decoding_f
$LN21@decoding_f:

; 583  :             /* We already have a codec associated with
; 584  :                this input. */
; 585  :             line = fp_readl(s, size, tok);

  00055	4c 8b c3	 mov	 r8, rbx
  00058	8b d7		 mov	 edx, edi
  0005a	48 8b ce	 mov	 rcx, rsi
  0005d	e8 00 00 00 00	 call	 fp_readl
$LN26@decoding_f:
  00062	48 8b f0	 mov	 rsi, rax

; 597  :                 return error_ret(tok);
; 598  :             assert(tok->decoding_state != STATE_INIT);
; 599  :         }
; 600  :     }
; 601  :     if (line != NULL && tok->lineno < 2 && !tok->read_coding_spec) {

  00065	48 85 c0	 test	 rax, rax
  00068	74 6c		 je	 SHORT $LN1@decoding_f
  0006a	83 bb e8 01 00
	00 02		 cmp	 DWORD PTR [rbx+488], 2
  00071	7d 35		 jge	 SHORT $LN7@decoding_f
  00073	83 bb 9c 03 00
	00 00		 cmp	 DWORD PTR [rbx+924], 0
  0007a	75 2c		 jne	 SHORT $LN7@decoding_f

; 602  :         if (!check_coding_spec(line, strlen(line), tok, fp_setreadl)) {

  0007c	48 83 c9 ff	 or	 rcx, -1
  00080	33 c0		 xor	 eax, eax
  00082	48 8b fe	 mov	 rdi, rsi
  00085	f2 ae		 repne scasb
  00087	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:fp_setreadl
  0008e	4c 8b c3	 mov	 r8, rbx
  00091	48 f7 d1	 not	 rcx
  00094	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00098	48 8b ce	 mov	 rcx, rsi
  0009b	e8 00 00 00 00	 call	 check_coding_spec
  000a0	85 c0		 test	 eax, eax

; 603  :             return error_ret(tok);

  000a2	0f 84 86 00 00
	00		 je	 $LN27@decoding_f
$LN7@decoding_f:

; 604  :         }
; 605  :     }
; 606  : #ifndef PGEN
; 607  :     /* The default encoding is UTF-8, so make sure we don't have any
; 608  :        non-UTF-8 sequences in it. */
; 609  :     if (line && !tok->encoding) {

  000a8	48 83 bb a0 03
	00 00 00	 cmp	 QWORD PTR [rbx+928], 0
  000b0	75 24		 jne	 SHORT $LN1@decoding_f

; 610  :         unsigned char *c;
; 611  :         int length;
; 612  :         for (c = (unsigned char *)line; *c; c += length)

  000b2	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  000b5	48 8b fe	 mov	 rdi, rsi
  000b8	74 1c		 je	 SHORT $LN1@decoding_f
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL5@decoding_f:

; 613  :             if (!(length = valid_utf8(c))) {

  000c0	48 8b cf	 mov	 rcx, rdi
  000c3	e8 00 00 00 00	 call	 valid_utf8
  000c8	85 c0		 test	 eax, eax
  000ca	74 33		 je	 SHORT $LN24@decoding_f

; 610  :         unsigned char *c;
; 611  :         int length;
; 612  :         for (c = (unsigned char *)line; *c; c += length)

  000cc	48 98		 cdqe
  000ce	48 03 f8	 add	 rdi, rax
  000d1	80 3f 00	 cmp	 BYTE PTR [rdi], 0
  000d4	75 ea		 jne	 SHORT $LL5@decoding_f
$LN1@decoding_f:

; 628  :     }
; 629  : #endif
; 630  :     return line;

  000d6	48 8b c6	 mov	 rax, rsi

; 631  : }

  000d9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000de	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000e3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
$LN22@decoding_f:

; 588  :             /* We want a 'raw' read. */
; 589  :             line = Py_UniversalNewlineFgets(s, size,
; 590  :                                             tok->fp, NULL);

  000e9	4c 8b 43 30	 mov	 r8, QWORD PTR [rbx+48]
  000ed	45 33 c9	 xor	 r9d, r9d
  000f0	8b d7		 mov	 edx, edi
  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	e8 00 00 00 00	 call	 Py_UniversalNewlineFgets
  000fa	e9 63 ff ff ff	 jmp	 $LN26@decoding_f
$LN24@decoding_f:

; 614  :                 badchar = *c;

  000ff	44 0f b6 07	 movzx	 r8d, BYTE PTR [rdi]

; 615  :                 break;
; 616  :             }
; 617  :     }
; 618  :     if (badchar) {

  00103	45 85 c0	 test	 r8d, r8d
  00106	74 ce		 je	 SHORT $LN1@decoding_f

; 619  :         /* Need to add 1 to the line number, since this line
; 620  :            has not been counted, yet.  */
; 621  :         PyErr_Format(PyExc_SyntaxError,
; 622  :                 "Non-UTF-8 code starting with '\\x%.2x' "
; 623  :                 "in file %U on line %i, "
; 624  :                 "but no encoding declared; "
; 625  :                 "see http://python.org/dev/peps/pep-0263/ for details",
; 626  :                 badchar, tok->filename, tok->lineno + 1);

  00108	8b 83 e8 01 00
	00		 mov	 eax, DWORD PTR [rbx+488]
  0010e	4c 8b 8b f0 01
	00 00		 mov	 r9, QWORD PTR [rbx+496]
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  0011c	ff c0		 inc	 eax
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IM@NOLDAGNK@Non?9UTF?98?5code?5starting?5with?5?8?2x@
  00125	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00129	e8 00 00 00 00	 call	 PyErr_Format
$LN27@decoding_f:

; 627  :         return error_ret(tok);

  0012e	48 8b cb	 mov	 rcx, rbx

; 631  : }

  00131	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00136	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0013b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013f	5f		 pop	 rdi
  00140	e9 00 00 00 00	 jmp	 error_ret
decoding_fgets ENDP
_TEXT	ENDS
EXTRN	PyObject_Size:PROC
EXTRN	__imp_feof:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decoding_feof DD imagerel decoding_feof
	DD	imagerel decoding_feof+115
	DD	imagerel $unwind$decoding_feof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decoding_feof DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT decoding_feof
_TEXT	SEGMENT
tok$ = 48
decoding_feof PROC					; COMDAT

; 635  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 636  :     if (tok->decoding_state != STATE_NORMAL) {

  00006	83 b9 94 03 00
	00 02		 cmp	 DWORD PTR [rcx+916], 2
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	74 10		 je	 SHORT $LN5@decoding_f@2

; 637  :         return feof(tok->fp);

  00012	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]

; 650  :     }
; 651  : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_feof
$LN5@decoding_f@2:

; 638  :     } else {
; 639  :         PyObject* buf = tok->decoding_buffer;

  00022	48 8b 81 c0 03
	00 00		 mov	 rax, QWORD PTR [rcx+960]

; 640  :         if (buf == NULL) {

  00029	48 85 c0	 test	 rax, rax
  0002c	75 2d		 jne	 SHORT $LN1@decoding_f@2

; 641  :             buf = PyObject_CallObject(tok->decoding_readline, NULL);

  0002e	48 8b 89 b8 03
	00 00		 mov	 rcx, QWORD PTR [rcx+952]
  00035	33 d2		 xor	 edx, edx
  00037	e8 00 00 00 00	 call	 PyObject_CallObject

; 642  :             if (buf == NULL) {

  0003c	48 85 c0	 test	 rax, rax
  0003f	75 13		 jne	 SHORT $LN2@decoding_f@2

; 643  :                 error_ret(tok);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 error_ret

; 644  :                 return 1;

  00049	b8 01 00 00 00	 mov	 eax, 1

; 650  :     }
; 651  : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN2@decoding_f@2:

; 645  :             } else {
; 646  :                 tok->decoding_buffer = buf;

  00054	48 89 83 c0 03
	00 00		 mov	 QWORD PTR [rbx+960], rax
$LN1@decoding_f@2:

; 647  :             }
; 648  :         }
; 649  :         return PyObject_Length(buf) == 0;

  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 PyObject_Size
  00063	33 c9		 xor	 ecx, ecx
  00065	48 85 c0	 test	 rax, rax
  00068	0f 94 c1	 sete	 cl
  0006b	8b c1		 mov	 eax, ecx

; 650  :     }
; 651  : }

  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5b		 pop	 rbx
  00072	c3		 ret	 0
decoding_feof ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT buf_getc
_TEXT	SEGMENT
tok$ = 8
buf_getc PROC						; COMDAT

; 657  :     return Py_CHARMASK(*tok->str++);

  00000	48 8b 81 d0 03
	00 00		 mov	 rax, QWORD PTR [rcx+976]
  00007	48 ff c0	 inc	 rax
  0000a	0f b6 50 ff	 movzx	 edx, BYTE PTR [rax-1]
  0000e	48 89 81 d0 03
	00 00		 mov	 QWORD PTR [rcx+976], rax
  00015	8b c2		 mov	 eax, edx

; 658  : }

  00017	c3		 ret	 0
buf_getc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT buf_ungetc
_TEXT	SEGMENT
c$ = 8
tok$ = 16
buf_ungetc PROC						; COMDAT

; 664  :     tok->str--;

  00000	48 ff 8a d0 03
	00 00		 dec	 QWORD PTR [rdx+976]

; 665  :     assert(Py_CHARMASK(*tok->str) == c);        /* tok->cur may point to read-only segment */
; 666  : }

  00007	c3		 ret	 0
buf_ungetc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT buf_setreadl
_TEXT	SEGMENT
tok$ = 8
enc$ = 16
buf_setreadl PROC					; COMDAT

; 673  :     tok->enc = enc;

  00000	48 89 91 c8 03
	00 00		 mov	 QWORD PTR [rcx+968], rdx

; 674  :     return 1;

  00007	b8 01 00 00 00	 mov	 eax, 1

; 675  : }

  0000c	c3		 ret	 0
buf_setreadl ENDP
_TEXT	ENDS
EXTRN	PyUnicode_AsUTF8String:PROC
EXTRN	PyUnicode_Decode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$translate_into_utf8 DD imagerel translate_into_utf8
	DD	imagerel translate_into_utf8+97
	DD	imagerel $unwind$translate_into_utf8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translate_into_utf8 DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT translate_into_utf8
_TEXT	SEGMENT
str$ = 48
enc$ = 56
translate_into_utf8 PROC				; COMDAT

; 681  : translate_into_utf8(const char* str, const char* enc) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4c 8b d1	 mov	 r10, rcx

; 682  :     PyObject *utf8;
; 683  :     PyObject* buf = PyUnicode_Decode(str, strlen(str), enc, NULL);

  0000d	48 83 c9 ff	 or	 rcx, -1
  00011	33 c0		 xor	 eax, eax
  00013	49 8b fa	 mov	 rdi, r10
  00016	4c 8b c2	 mov	 r8, rdx
  00019	45 33 c9	 xor	 r9d, r9d
  0001c	f2 ae		 repne scasb
  0001e	48 f7 d1	 not	 rcx
  00021	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00025	49 8b ca	 mov	 rcx, r10
  00028	e8 00 00 00 00	 call	 PyUnicode_Decode
  0002d	48 8b d8	 mov	 rbx, rax

; 684  :     if (buf == NULL)

  00030	48 85 c0	 test	 rax, rax
  00033	75 0b		 jne	 SHORT $LN1@translate_

; 688  :     return utf8;
; 689  : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN1@translate_:

; 685  :         return NULL;
; 686  :     utf8 = PyUnicode_AsUTF8String(buf);

  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 PyUnicode_AsUTF8String

; 687  :     Py_DECREF(buf);

  00048	48 8b cb	 mov	 rcx, rbx
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	e8 00 00 00 00	 call	 _Py_DecRef

; 688  :     return utf8;
; 689  : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b c7	 mov	 rax, rdi
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
translate_into_utf8 ENDP
_TEXT	ENDS
EXTRN	__imp_realloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$translate_newlines DD imagerel translate_newlines
	DD	imagerel translate_newlines+326
	DD	imagerel $unwind$translate_newlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$translate_newlines DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT translate_newlines
_TEXT	SEGMENT
s$ = 80
exec_input$ = 88
tok$ = 96
translate_newlines PROC					; COMDAT

; 693  : translate_newlines(const char *s, int exec_input, struct tok_state *tok) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001c	48 8b f1	 mov	 rsi, rcx

; 694  :     int skip_next_lf = 0, needed_length = strlen(s) + 2, final_length;

  0001f	48 83 c9 ff	 or	 rcx, -1
  00023	33 c0		 xor	 eax, eax
  00025	48 8b fe	 mov	 rdi, rsi
  00028	49 8b d8	 mov	 rbx, r8
  0002b	44 8b f2	 mov	 r14d, edx
  0002e	f2 ae		 repne scasb
  00030	45 33 e4	 xor	 r12d, r12d

; 695  :     char *buf, *current;
; 696  :     char c = '\0';

  00033	40 32 ff	 xor	 dil, dil
  00036	48 f7 d1	 not	 rcx
  00039	4c 8d 69 01	 lea	 r13d, QWORD PTR [rcx+1]

; 697  :     buf = PyMem_MALLOC(needed_length);

  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	49 bf ff ff ff
	ff ff ff ff 7f	 mov	 r15, 9223372036854775807 ; 7fffffffffffffffH
  0004c	85 c0		 test	 eax, eax
  0004e	74 0a		 je	 SHORT $LN17@translate_@2
  00050	49 63 cd	 movsxd	 rcx, r13d
  00053	e8 00 00 00 00	 call	 _PxMem_Malloc
  00058	eb 1e		 jmp	 SHORT $LN28@translate_@2
$LN17@translate_@2:
  0005a	49 63 c5	 movsxd	 rax, r13d
  0005d	49 3b c7	 cmp	 rax, r15
  00060	0f 87 ba 00 00
	00		 ja	 $LN26@translate_@2
  00066	45 85 ed	 test	 r13d, r13d
  00069	b9 01 00 00 00	 mov	 ecx, 1
  0006e	48 0f 45 c8	 cmovne	 rcx, rax
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN28@translate_@2:
  00078	48 8b e8	 mov	 rbp, rax

; 698  :     if (buf == NULL) {

  0007b	48 85 c0	 test	 rax, rax
  0007e	0f 84 9c 00 00
	00		 je	 $LN26@translate_@2

; 701  :     }
; 702  :     for (current = buf; *s; s++, current++) {

  00084	48 8b d8	 mov	 rbx, rax
  00087	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0008a	84 c0		 test	 al, al
  0008c	74 3c		 je	 SHORT $LN27@translate_@2
  0008e	66 90		 npad	 2
$LL9@translate_@2:

; 703  :         c = *s;

  00090	0f b6 f8	 movzx	 edi, al

; 704  :         if (skip_next_lf) {

  00093	45 85 e4	 test	 r12d, r12d
  00096	74 13		 je	 SHORT $LN4@translate_@2

; 705  :             skip_next_lf = 0;

  00098	45 33 e4	 xor	 r12d, r12d

; 706  :             if (c == '\n') {

  0009b	3c 0a		 cmp	 al, 10
  0009d	75 0c		 jne	 SHORT $LN4@translate_@2

; 707  :                 c = *++s;

  0009f	0f b6 7e 01	 movzx	 edi, BYTE PTR [rsi+1]
  000a3	48 ff c6	 inc	 rsi

; 708  :                 if (!c)

  000a6	40 84 ff	 test	 dil, dil
  000a9	74 1f		 je	 SHORT $LN27@translate_@2
$LN4@translate_@2:

; 709  :                     break;
; 710  :             }
; 711  :         }
; 712  :         if (c == '\r') {

  000ab	40 80 ff 0d	 cmp	 dil, 13
  000af	75 09		 jne	 SHORT $LN3@translate_@2

; 713  :             skip_next_lf = 1;

  000b1	41 bc 01 00 00
	00		 mov	 r12d, 1

; 714  :             c = '\n';

  000b7	40 b7 0a	 mov	 dil, 10
$LN3@translate_@2:

; 715  :         }
; 716  :         *current = c;

  000ba	48 ff c6	 inc	 rsi
  000bd	40 88 3b	 mov	 BYTE PTR [rbx], dil
  000c0	48 ff c3	 inc	 rbx
  000c3	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000c6	84 c0		 test	 al, al
  000c8	75 c6		 jne	 SHORT $LL9@translate_@2
$LN27@translate_@2:

; 717  :     }
; 718  :     /* If this is exec input, add a newline to the end of the string if
; 719  :        there isn't one already. */
; 720  :     if (exec_input && c != '\n') {

  000ca	45 85 f6	 test	 r14d, r14d
  000cd	74 0c		 je	 SHORT $LN2@translate_@2
  000cf	40 80 ff 0a	 cmp	 dil, 10
  000d3	74 06		 je	 SHORT $LN2@translate_@2

; 721  :         *current = '\n';

  000d5	c6 03 0a	 mov	 BYTE PTR [rbx], 10

; 722  :         current++;

  000d8	48 ff c3	 inc	 rbx
$LN2@translate_@2:

; 723  :     }
; 724  :     *current = '\0';

  000db	c6 03 00	 mov	 BYTE PTR [rbx], 0

; 725  :     final_length = current - buf + 1;

  000de	2b dd		 sub	 ebx, ebp
  000e0	ff c3		 inc	 ebx

; 726  :     if (final_length < needed_length && final_length)

  000e2	41 3b dd	 cmp	 ebx, r13d
  000e5	7d 34		 jge	 SHORT $LN20@translate_@2
  000e7	85 db		 test	 ebx, ebx
  000e9	74 30		 je	 SHORT $LN20@translate_@2

; 727  :         /* should never fail */
; 728  :         buf = PyMem_REALLOC(buf, final_length);

  000eb	e8 00 00 00 00	 call	 _Py_PXCTX
  000f0	48 63 d3	 movsxd	 rdx, ebx
  000f3	85 c0		 test	 eax, eax
  000f5	74 0d		 je	 SHORT $LN21@translate_@2
  000f7	48 8b cd	 mov	 rcx, rbp
  000fa	e8 00 00 00 00	 call	 _PxMem_Realloc
  000ff	48 8b e8	 mov	 rbp, rax

; 729  :     return buf;

  00102	eb 25		 jmp	 SHORT $LN11@translate_@2
$LN21@translate_@2:

; 727  :         /* should never fail */
; 728  :         buf = PyMem_REALLOC(buf, final_length);

  00104	49 3b d7	 cmp	 rdx, r15
  00107	76 06		 jbe	 SHORT $LN19@translate_@2
  00109	33 ed		 xor	 ebp, ebp

; 729  :     return buf;

  0010b	8b c5		 mov	 eax, ebp
  0010d	eb 1a		 jmp	 SHORT $LN11@translate_@2
$LN19@translate_@2:

; 727  :         /* should never fail */
; 728  :         buf = PyMem_REALLOC(buf, final_length);

  0010f	48 8b cd	 mov	 rcx, rbp
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00118	48 8b e8	 mov	 rbp, rax
$LN20@translate_@2:

; 729  :     return buf;

  0011b	48 8b c5	 mov	 rax, rbp
  0011e	eb 09		 jmp	 SHORT $LN11@translate_@2
$LN26@translate_@2:

; 699  :         tok->done = E_NOMEM;

  00120	c7 43 28 0f 00
	00 00		 mov	 DWORD PTR [rbx+40], 15

; 700  :         return NULL;

  00127	33 c0		 xor	 eax, eax
$LN11@translate_@2:

; 730  : }

  00129	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0012e	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00133	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	41 5f		 pop	 r15
  0013e	41 5e		 pop	 r14
  00140	41 5d		 pop	 r13
  00142	41 5c		 pop	 r12
  00144	5f		 pop	 rdi
  00145	c3		 ret	 0
translate_newlines ENDP
_TEXT	ENDS
EXTRN	PyBytes_AsString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_str DD imagerel decode_str
	DD	imagerel decode_str+122
	DD	imagerel $unwind$decode_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$decode_str DD imagerel decode_str+122
	DD	imagerel decode_str+376
	DD	imagerel $chain$0$decode_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$decode_str DD imagerel decode_str+376
	DD	imagerel decode_str+398
	DD	imagerel $chain$1$decode_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$decode_str DD 021H
	DD	imagerel decode_str
	DD	imagerel decode_str+122
	DD	imagerel $unwind$decode_str
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$decode_str DD 020521H
	DD	087405H
	DD	imagerel decode_str
	DD	imagerel decode_str+122
	DD	imagerel $unwind$decode_str
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_str DD 081501H
	DD	0b6415H
	DD	0a5415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT decode_str
_TEXT	SEGMENT
newl$ = 32
input$ = 64
single$ = 72
tok$ = 80
decode_str PROC						; COMDAT

; 738  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 739  :     PyObject* utf8 = NULL;
; 740  :     const char *str;
; 741  :     const char *s;
; 742  :     const char *newl[2] = {NULL, NULL};

  00015	33 ed		 xor	 ebp, ebp
  00017	45 33 e4	 xor	 r12d, r12d
  0001a	49 8b d8	 mov	 rbx, r8
  0001d	48 89 6c 24 20	 mov	 QWORD PTR newl$[rsp], rbp
  00022	4c 89 64 24 28	 mov	 QWORD PTR newl$[rsp+8], r12
  00027	33 f6		 xor	 esi, esi

; 743  :     int lineno = 0;
; 744  :     tok->input = str = translate_newlines(input, single, tok);

  00029	e8 00 00 00 00	 call	 translate_newlines
  0002e	48 89 83 d8 03
	00 00		 mov	 QWORD PTR [rbx+984], rax

; 745  :     if (str == NULL)

  00035	48 85 c0	 test	 rax, rax
  00038	0f 84 3a 01 00
	00		 je	 $LN18@decode_str
$LN17@decode_str:

; 746  :         return NULL;
; 747  :     tok->enc = NULL;
; 748  :     tok->str = str;
; 749  :     if (!check_bom(buf_getc, buf_ungetc, buf_setreadl, tok))

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:buf_ungetc
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:buf_getc
  0004c	4c 8b c3	 mov	 r8, rbx
  0004f	48 89 b3 c8 03
	00 00		 mov	 QWORD PTR [rbx+968], rsi
  00056	48 89 83 d0 03
	00 00		 mov	 QWORD PTR [rbx+976], rax
  0005d	e8 00 00 00 00	 call	 check_bom
  00062	85 c0		 test	 eax, eax
  00064	75 0d		 jne	 SHORT $LN16@decode_str

; 750  :         return error_ret(tok);

  00066	48 8b cb	 mov	 rcx, rbx
  00069	e8 00 00 00 00	 call	 error_ret
  0006e	e9 05 01 00 00	 jmp	 $LN18@decode_str
$LN16@decode_str:

; 751  :     str = tok->str;             /* string after BOM if any */
; 752  :     assert(str);
; 753  :     if (tok->enc != NULL) {

  00073	48 8b 93 c8 03
	00 00		 mov	 rdx, QWORD PTR [rbx+968]
  0007a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0007f	48 8b bb d0 03
	00 00		 mov	 rdi, QWORD PTR [rbx+976]
  00086	48 85 d2	 test	 rdx, rdx
  00089	74 1f		 je	 SHORT $LN15@decode_str

; 754  :         utf8 = translate_into_utf8(str, tok->enc);

  0008b	48 8b cf	 mov	 rcx, rdi
  0008e	e8 00 00 00 00	 call	 translate_into_utf8
  00093	48 8b f0	 mov	 rsi, rax

; 755  :         if (utf8 == NULL)

  00096	48 85 c0	 test	 rax, rax

; 756  :             return error_ret(tok);

  00099	0f 84 bc 00 00
	00		 je	 $LN27@decode_str

; 757  :         str = PyBytes_AsString(utf8);

  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 PyBytes_AsString
  000a7	48 8b f8	 mov	 rdi, rax
$LN15@decode_str:

; 758  :     }
; 759  :     for (s = str;; s++) {
; 760  :         if (*s == '\0') break;

  000aa	0f b6 17	 movzx	 edx, BYTE PTR [rdi]
  000ad	33 c0		 xor	 eax, eax
  000af	48 8b cf	 mov	 rcx, rdi
  000b2	84 d2		 test	 dl, dl
  000b4	74 28		 je	 SHORT $LN22@decode_str
$LL13@decode_str:

; 761  :         else if (*s == '\n') {

  000b6	80 fa 0a	 cmp	 dl, 10
  000b9	75 0e		 jne	 SHORT $LN12@decode_str

; 762  :             assert(lineno < 2);
; 763  :             newl[lineno] = s;

  000bb	48 89 4c c4 20	 mov	 QWORD PTR newl$[rsp+rax*8], rcx

; 764  :             lineno++;

  000c0	48 ff c0	 inc	 rax

; 765  :             if (lineno == 2) break;

  000c3	48 83 f8 02	 cmp	 rax, 2
  000c7	74 0b		 je	 SHORT $LN25@decode_str
$LN12@decode_str:

; 758  :     }
; 759  :     for (s = str;; s++) {
; 760  :         if (*s == '\0') break;

  000c9	0f b6 51 01	 movzx	 edx, BYTE PTR [rcx+1]
  000cd	48 ff c1	 inc	 rcx
  000d0	84 d2		 test	 dl, dl
  000d2	75 e2		 jne	 SHORT $LL13@decode_str
$LN25@decode_str:
  000d4	4c 8b 64 24 28	 mov	 r12, QWORD PTR newl$[rsp+8]
  000d9	48 8b 6c 24 20	 mov	 rbp, QWORD PTR newl$[rsp]
$LN22@decode_str:

; 766  :         }
; 767  :     }
; 768  :     tok->enc = NULL;

  000de	48 c7 83 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+968], 0

; 769  :     /* need to check line 1 and 2 separately since check_coding_spec
; 770  :        assumes a single line as input */
; 771  :     if (newl[0]) {

  000e9	48 85 ed	 test	 rbp, rbp
  000ec	74 51		 je	 SHORT $LN3@decode_str

; 772  :         if (!check_coding_spec(str, newl[0] - str, tok, buf_setreadl))

  000ee	48 8b d5	 mov	 rdx, rbp
  000f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:buf_setreadl
  000f8	4c 8b c3	 mov	 r8, rbx
  000fb	48 2b d7	 sub	 rdx, rdi
  000fe	48 8b cf	 mov	 rcx, rdi
  00101	e8 00 00 00 00	 call	 check_coding_spec
  00106	85 c0		 test	 eax, eax

; 773  :             return error_ret(tok);

  00108	74 51		 je	 SHORT $LN27@decode_str

; 774  :         if (tok->enc == NULL && !tok->read_coding_spec && newl[1]) {

  0010a	48 83 bb c8 03
	00 00 00	 cmp	 QWORD PTR [rbx+968], 0
  00112	75 2b		 jne	 SHORT $LN3@decode_str
  00114	83 bb 9c 03 00
	00 00		 cmp	 DWORD PTR [rbx+924], 0
  0011b	75 22		 jne	 SHORT $LN3@decode_str
  0011d	4d 85 e4	 test	 r12, r12
  00120	74 1d		 je	 SHORT $LN3@decode_str

; 775  :             if (!check_coding_spec(newl[0]+1, newl[1] - newl[0],
; 776  :                                    tok, buf_setreadl))

  00122	4c 2b e5	 sub	 r12, rbp
  00125	48 8d 4d 01	 lea	 rcx, QWORD PTR [rbp+1]
  00129	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:buf_setreadl
  00130	49 8b d4	 mov	 rdx, r12
  00133	4c 8b c3	 mov	 r8, rbx
  00136	e8 00 00 00 00	 call	 check_coding_spec
  0013b	85 c0		 test	 eax, eax

; 777  :                 return error_ret(tok);

  0013d	74 1c		 je	 SHORT $LN27@decode_str
$LN3@decode_str:

; 778  :         }
; 779  :     }
; 780  :     if (tok->enc != NULL) {

  0013f	48 8b 93 c8 03
	00 00		 mov	 rdx, QWORD PTR [rbx+968]
  00146	48 85 d2	 test	 rdx, rdx
  00149	74 1e		 je	 SHORT $LN2@decode_str

; 781  :         assert(utf8 == NULL);
; 782  :         utf8 = translate_into_utf8(str, tok->enc);

  0014b	48 8b cf	 mov	 rcx, rdi
  0014e	e8 00 00 00 00	 call	 translate_into_utf8
  00153	48 8b f0	 mov	 rsi, rax

; 783  :         if (utf8 == NULL)

  00156	48 85 c0	 test	 rax, rax
  00159	75 0a		 jne	 SHORT $LN1@decode_str
$LN27@decode_str:

; 784  :             return error_ret(tok);

  0015b	48 8b cb	 mov	 rcx, rbx
  0015e	e8 00 00 00 00	 call	 error_ret
  00163	eb 0e		 jmp	 SHORT $LN26@decode_str
$LN1@decode_str:

; 785  :         str = PyBytes_AS_STRING(utf8);

  00165	48 8d 78 78	 lea	 rdi, QWORD PTR [rax+120]
$LN2@decode_str:

; 786  :     }
; 787  :     assert(tok->decoding_buffer == NULL);
; 788  :     tok->decoding_buffer = utf8; /* CAUTION */

  00169	48 89 b3 c0 03
	00 00		 mov	 QWORD PTR [rbx+960], rsi

; 789  :     return str;

  00170	48 8b c7	 mov	 rax, rdi
$LN26@decode_str:
  00173	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN18@decode_str:

; 790  : }

  00178	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0017d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00182	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00187	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018b	41 5c		 pop	 r12
  0018d	c3		 ret	 0
decode_str ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_Free
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyTokenizer_Free DD imagerel $LN59
	DD	imagerel $LN59+512
	DD	imagerel $unwind$PyTokenizer_Free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_Free DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\parser\tokenizer.c
xdata	ENDS
;	COMDAT PyTokenizer_Free
_TEXT	SEGMENT
tok$ = 64
PyTokenizer_Free PROC					; COMDAT

; 878  : {

$LN59:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 879  :     if (tok->encoding != NULL)

  0000a	48 83 b9 a0 03
	00 00 00	 cmp	 QWORD PTR [rcx+928], 0
  00012	48 8b d9	 mov	 rbx, rcx
  00015	74 1d		 je	 SHORT $LN14@PyTokenize

; 880  :         PyMem_FREE(tok->encoding);

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	48 8b 8b a0 03
	00 00		 mov	 rcx, QWORD PTR [rbx+928]
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN18@PyTokenize
  00027	e8 00 00 00 00	 call	 _PxMem_Free
  0002c	eb 06		 jmp	 SHORT $LN14@PyTokenize
$LN18@PyTokenize:
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN14@PyTokenize:

; 881  : #ifndef PGEN
; 882  :     Py_XDECREF(tok->decoding_readline);

  00034	48 8b bb b8 03
	00 00		 mov	 rdi, QWORD PTR [rbx+952]
  0003b	48 85 ff	 test	 rdi, rdi
  0003e	74 65		 je	 SHORT $LN13@PyTokenize
  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	85 c0		 test	 eax, eax
  00047	75 5c		 jne	 SHORT $LN13@PyTokenize
  00049	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0004d	a8 20		 test	 al, 32			; 00000020H
  0004f	75 4c		 jne	 SHORT $LN30@PyTokenize
  00051	84 c0		 test	 al, al
  00053	78 48		 js	 SHORT $LN30@PyTokenize
  00055	a8 02		 test	 al, 2
  00057	75 4c		 jne	 SHORT $LN13@PyTokenize
  00059	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0005d	75 46		 jne	 SHORT $LN13@PyTokenize
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0006d	4c 8b cf	 mov	 r9, rdi
  00070	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00076	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00083	48 8b cf	 mov	 rcx, rdi
  00086	85 c0		 test	 eax, eax
  00088	74 07		 je	 SHORT $LN35@PyTokenize
  0008a	e8 00 00 00 00	 call	 _Px_Dealloc
  0008f	eb 14		 jmp	 SHORT $LN13@PyTokenize
$LN35@PyTokenize:
  00091	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00095	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0009b	eb 08		 jmp	 SHORT $LN13@PyTokenize
$LN30@PyTokenize:
  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	e8 00 00 00 00	 call	 Px_DecRef
$LN13@PyTokenize:

; 883  :     Py_XDECREF(tok->decoding_buffer);

  000a5	48 8b bb c0 03
	00 00		 mov	 rdi, QWORD PTR [rbx+960]
  000ac	48 85 ff	 test	 rdi, rdi
  000af	74 65		 je	 SHORT $LN9@PyTokenize
  000b1	e8 00 00 00 00	 call	 _Py_PXCTX
  000b6	85 c0		 test	 eax, eax
  000b8	75 5c		 jne	 SHORT $LN9@PyTokenize
  000ba	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000be	a8 20		 test	 al, 32			; 00000020H
  000c0	75 4c		 jne	 SHORT $LN41@PyTokenize
  000c2	84 c0		 test	 al, al
  000c4	78 48		 js	 SHORT $LN41@PyTokenize
  000c6	a8 02		 test	 al, 2
  000c8	75 4c		 jne	 SHORT $LN9@PyTokenize
  000ca	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000ce	75 46		 jne	 SHORT $LN9@PyTokenize
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000de	4c 8b cf	 mov	 r9, rdi
  000e1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	85 c0		 test	 eax, eax
  000f9	74 07		 je	 SHORT $LN46@PyTokenize
  000fb	e8 00 00 00 00	 call	 _Px_Dealloc
  00100	eb 14		 jmp	 SHORT $LN9@PyTokenize
$LN46@PyTokenize:
  00102	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00106	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0010c	eb 08		 jmp	 SHORT $LN9@PyTokenize
$LN41@PyTokenize:
  0010e	48 8b cf	 mov	 rcx, rdi
  00111	e8 00 00 00 00	 call	 Px_DecRef
$LN9@PyTokenize:

; 884  :     Py_XDECREF(tok->filename);

  00116	48 8b bb f0 01
	00 00		 mov	 rdi, QWORD PTR [rbx+496]
  0011d	48 85 ff	 test	 rdi, rdi
  00120	74 65		 je	 SHORT $LN5@PyTokenize
  00122	e8 00 00 00 00	 call	 _Py_PXCTX
  00127	85 c0		 test	 eax, eax
  00129	75 5c		 jne	 SHORT $LN5@PyTokenize
  0012b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0012f	a8 20		 test	 al, 32			; 00000020H
  00131	75 4c		 jne	 SHORT $LN52@PyTokenize
  00133	84 c0		 test	 al, al
  00135	78 48		 js	 SHORT $LN52@PyTokenize
  00137	a8 02		 test	 al, 2
  00139	75 4c		 jne	 SHORT $LN5@PyTokenize
  0013b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0013f	75 46		 jne	 SHORT $LN5@PyTokenize
  00141	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0014f	4c 8b cf	 mov	 r9, rdi
  00152	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00158	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00160	e8 00 00 00 00	 call	 _PyParallel_Guard
  00165	48 8b cf	 mov	 rcx, rdi
  00168	85 c0		 test	 eax, eax
  0016a	74 07		 je	 SHORT $LN57@PyTokenize
  0016c	e8 00 00 00 00	 call	 _Px_Dealloc
  00171	eb 14		 jmp	 SHORT $LN5@PyTokenize
$LN57@PyTokenize:
  00173	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00177	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0017d	eb 08		 jmp	 SHORT $LN5@PyTokenize
$LN52@PyTokenize:
  0017f	48 8b cf	 mov	 rcx, rdi
  00182	e8 00 00 00 00	 call	 Px_DecRef
$LN5@PyTokenize:

; 885  : #endif
; 886  :     if (tok->fp != NULL && tok->buf != NULL)

  00187	48 83 7b 30 00	 cmp	 QWORD PTR [rbx+48], 0
  0018c	74 1f		 je	 SHORT $LN21@PyTokenize
  0018e	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00192	74 19		 je	 SHORT $LN21@PyTokenize

; 887  :         PyMem_FREE(tok->buf);

  00194	e8 00 00 00 00	 call	 _Py_PXCTX
  00199	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0019c	85 c0		 test	 eax, eax
  0019e	74 07		 je	 SHORT $LN20@PyTokenize
  001a0	e8 00 00 00 00	 call	 _PxMem_Free
  001a5	eb 06		 jmp	 SHORT $LN21@PyTokenize
$LN20@PyTokenize:
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN21@PyTokenize:

; 888  :     if (tok->input)

  001ad	48 83 bb d8 03
	00 00 00	 cmp	 QWORD PTR [rbx+984], 0
  001b5	74 1d		 je	 SHORT $LN23@PyTokenize

; 889  :         PyMem_FREE((char *)tok->input);

  001b7	e8 00 00 00 00	 call	 _Py_PXCTX
  001bc	48 8b 8b d8 03
	00 00		 mov	 rcx, QWORD PTR [rbx+984]
  001c3	85 c0		 test	 eax, eax
  001c5	74 07		 je	 SHORT $LN22@PyTokenize
  001c7	e8 00 00 00 00	 call	 _PxMem_Free
  001cc	eb 06		 jmp	 SHORT $LN23@PyTokenize
$LN22@PyTokenize:
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@PyTokenize:

; 890  :     PyMem_FREE(tok);

  001d4	e8 00 00 00 00	 call	 _Py_PXCTX
  001d9	48 8b cb	 mov	 rcx, rbx
  001dc	85 c0		 test	 eax, eax
  001de	74 0f		 je	 SHORT $LN24@PyTokenize

; 891  : }

  001e0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e9	5f		 pop	 rdi
  001ea	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN24@PyTokenize:
  001ef	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f8	5f		 pop	 rdi
  001f9	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
PyTokenizer_Free ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
EXTRN	PySys_WriteStderr:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyOS_Readline:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_nextc DD imagerel tok_nextc
	DD	imagerel tok_nextc+1509
	DD	imagerel $unwind$tok_nextc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_nextc DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tok_nextc
_TEXT	SEGMENT
tok$ = 80
tok_nextc PROC						; COMDAT

; 897  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 898  :     for (;;) {
; 899  :         if (tok->cur != tok->inp) {

  0001c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00020	48 8b d9	 mov	 rbx, rcx
  00023	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00027	0f 85 5e 04 00
	00		 jne	 $LN90@tok_nextc
  0002d	49 bf ff ff ff
	ff ff ff ff 7f	 mov	 r15, 9223372036854775807 ; 7fffffffffffffffH
  00037	41 be 0a 00 00
	00		 mov	 r14d, 10
  0003d	0f 1f 00	 npad	 3
$LL42@tok_nextc:

; 901  :         }
; 902  :         if (tok->done != E_OK)

  00040	44 39 73 28	 cmp	 DWORD PTR [rbx+40], r14d
  00044	0f 85 93 05 00
	00		 jne	 $LN91@tok_nextc

; 903  :             return EOF;
; 904  :         if (tok->fp == NULL) {

  0004a	48 83 7b 30 00	 cmp	 QWORD PTR [rbx+48], 0
  0004f	0f 84 2c 05 00
	00		 je	 $LN92@tok_nextc

; 921  :         }
; 922  :         if (tok->prompt != NULL) {

  00055	48 8b b3 d8 01
	00 00		 mov	 rsi, QWORD PTR [rbx+472]
  0005c	48 85 f6	 test	 rsi, rsi
  0005f	0f 84 5f 02 00
	00		 je	 $LN33@tok_nextc

; 923  :             char *newtok = PyOS_Readline(stdin, stdout, tok->prompt);

  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0006b	48 8b f8	 mov	 rdi, rax
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00074	48 8d 57 30	 lea	 rdx, QWORD PTR [rdi+48]
  00078	48 8b c8	 mov	 rcx, rax
  0007b	4c 8b c6	 mov	 r8, rsi
  0007e	e8 00 00 00 00	 call	 PyOS_Readline
  00083	48 8b f0	 mov	 rsi, rax

; 924  : #ifndef PGEN
; 925  :             if (newtok != NULL) {

  00086	48 85 c0	 test	 rax, rax
  00089	74 35		 je	 SHORT $LN32@tok_nextc

; 926  :                 char *translated = translate_newlines(newtok, 0, tok);

  0008b	4c 8b c3	 mov	 r8, rbx
  0008e	33 d2		 xor	 edx, edx
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 translate_newlines
  00098	48 8b f8	 mov	 rdi, rax

; 927  :                 PyMem_FREE(newtok);

  0009b	e8 00 00 00 00	 call	 _Py_PXCTX
  000a0	48 8b ce	 mov	 rcx, rsi
  000a3	85 c0		 test	 eax, eax
  000a5	74 07		 je	 SHORT $LN45@tok_nextc
  000a7	e8 00 00 00 00	 call	 _PxMem_Free
  000ac	eb 06		 jmp	 SHORT $LN46@tok_nextc
$LN45@tok_nextc:
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN46@tok_nextc:

; 928  :                 if (translated == NULL)

  000b4	48 85 ff	 test	 rdi, rdi
  000b7	0f 84 20 05 00
	00		 je	 $LN91@tok_nextc

; 929  :                     return EOF;
; 930  :                 newtok = translated;

  000bd	48 8b f7	 mov	 rsi, rdi
$LN32@tok_nextc:

; 931  :             }
; 932  :             if (tok->encoding && newtok && *newtok) {

  000c0	48 8b 93 a0 03
	00 00		 mov	 rdx, QWORD PTR [rbx+928]
  000c7	48 85 d2	 test	 rdx, rdx
  000ca	0f 84 a6 00 00
	00		 je	 $LN30@tok_nextc
  000d0	48 85 f6	 test	 rsi, rsi
  000d3	0f 84 9d 00 00
	00		 je	 $LN30@tok_nextc
  000d9	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  000dc	0f 84 94 00 00
	00		 je	 $LN30@tok_nextc

; 933  :                 /* Recode to UTF-8 */
; 934  :                 Py_ssize_t buflen;
; 935  :                 const char* buf;
; 936  :                 PyObject *u = translate_into_utf8(newtok, tok->encoding);

  000e2	48 8b ce	 mov	 rcx, rsi
  000e5	e8 00 00 00 00	 call	 translate_into_utf8
  000ea	48 8b e8	 mov	 rbp, rax

; 937  :                 PyMem_FREE(newtok);

  000ed	e8 00 00 00 00	 call	 _Py_PXCTX
  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	85 c0		 test	 eax, eax
  000f7	74 07		 je	 SHORT $LN47@tok_nextc
  000f9	e8 00 00 00 00	 call	 _PxMem_Free
  000fe	eb 06		 jmp	 SHORT $LN48@tok_nextc
$LN47@tok_nextc:
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN48@tok_nextc:

; 938  :                 if (!u) {

  00106	48 85 ed	 test	 rbp, rbp
  00109	0f 84 b1 03 00
	00		 je	 $LN94@tok_nextc

; 939  :                     tok->done = E_DECODE;
; 940  :                     return EOF;
; 941  :                 }
; 942  :                 buflen = PyBytes_GET_SIZE(u);

  0010f	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]

; 943  :                 buf = PyBytes_AS_STRING(u);

  00113	48 8d 7d 78	 lea	 rdi, QWORD PTR [rbp+120]

; 944  :                 if (!buf) {

  00117	48 85 ff	 test	 rdi, rdi
  0011a	0f 84 98 03 00
	00		 je	 $LN95@tok_nextc

; 948  :                 }
; 949  :                 newtok = PyMem_MALLOC(buflen+1);

  00120	e8 00 00 00 00	 call	 _Py_PXCTX
  00125	85 c0		 test	 eax, eax
  00127	74 0b		 je	 SHORT $LN53@tok_nextc
  00129	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  0012d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00132	eb 1f		 jmp	 SHORT $LN104@tok_nextc
$LN53@tok_nextc:
  00134	48 8d 46 01	 lea	 rax, QWORD PTR [rsi+1]
  00138	49 3b c7	 cmp	 rax, r15
  0013b	76 04		 jbe	 SHORT $LN51@tok_nextc
  0013d	33 f6		 xor	 esi, esi
  0013f	eb 15		 jmp	 SHORT $LN52@tok_nextc
$LN51@tok_nextc:
  00141	48 85 c0	 test	 rax, rax
  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	48 0f 45 c8	 cmovne	 rcx, rax
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN104@tok_nextc:
  00153	48 8b f0	 mov	 rsi, rax
$LN52@tok_nextc:

; 950  :                 strcpy(newtok, buf);

  00156	48 8b ce	 mov	 rcx, rsi
  00159	48 2b cf	 sub	 rcx, rdi
  0015c	0f 1f 40 00	 npad	 4
$LL55@tok_nextc:
  00160	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00163	48 ff c7	 inc	 rdi
  00166	88 44 39 ff	 mov	 BYTE PTR [rcx+rdi-1], al
  0016a	84 c0		 test	 al, al
  0016c	75 f2		 jne	 SHORT $LL55@tok_nextc

; 951  :                 Py_DECREF(u);

  0016e	48 8b cd	 mov	 rcx, rbp
  00171	e8 00 00 00 00	 call	 _Py_DecRef
$LN30@tok_nextc:

; 952  :             }
; 953  : #endif
; 954  :             if (tok->nextprompt != NULL)

  00176	48 8b 83 e0 01
	00 00		 mov	 rax, QWORD PTR [rbx+480]
  0017d	48 85 c0	 test	 rax, rax
  00180	74 07		 je	 SHORT $LN27@tok_nextc

; 955  :                 tok->prompt = tok->nextprompt;

  00182	48 89 83 d8 01
	00 00		 mov	 QWORD PTR [rbx+472], rax
$LN27@tok_nextc:

; 956  :             if (newtok == NULL)

  00189	48 85 f6	 test	 rsi, rsi
  0018c	0f 84 cf 03 00
	00		 je	 $LN101@tok_nextc

; 958  :             else if (*newtok == '\0') {

  00192	80 3e 00	 cmp	 BYTE PTR [rsi], 0
  00195	0f 84 80 03 00
	00		 je	 $LN102@tok_nextc

; 961  :             }
; 962  :             else if (tok->start != NULL) {

  0019b	4c 8b 63 20	 mov	 r12, QWORD PTR [rbx+32]
  0019f	4d 85 e4	 test	 r12, r12
  001a2	0f 84 ce 00 00
	00		 je	 $LN22@tok_nextc

; 963  :                 size_t start = tok->start - tok->buf;

  001a8	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]

; 964  :                 size_t oldlen = tok->cur - tok->buf;

  001ab	4c 8b 6b 08	 mov	 r13, QWORD PTR [rbx+8]

; 965  :                 size_t newlen = oldlen + strlen(newtok);

  001af	48 83 c9 ff	 or	 rcx, -1
  001b3	33 c0		 xor	 eax, eax
  001b5	48 8b fe	 mov	 rdi, rsi
  001b8	4c 2b ed	 sub	 r13, rbp
  001bb	f2 ae		 repne scasb
  001bd	4c 2b e5	 sub	 r12, rbp
  001c0	48 f7 d1	 not	 rcx
  001c3	49 8d 7c 0d ff	 lea	 rdi, QWORD PTR [r13+rcx-1]

; 966  :                 char *buf = tok->buf;
; 967  :                 buf = (char *)PyMem_REALLOC(buf, newlen+1);

  001c8	e8 00 00 00 00	 call	 _Py_PXCTX
  001cd	85 c0		 test	 eax, eax
  001cf	74 0e		 je	 SHORT $LN62@tok_nextc
  001d1	48 8d 57 01	 lea	 rdx, QWORD PTR [rdi+1]
  001d5	48 8b cd	 mov	 rcx, rbp
  001d8	e8 00 00 00 00	 call	 _PxMem_Realloc
  001dd	eb 22		 jmp	 SHORT $LN105@tok_nextc
$LN62@tok_nextc:
  001df	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  001e3	49 3b c7	 cmp	 rax, r15
  001e6	76 04		 jbe	 SHORT $LN60@tok_nextc
  001e8	33 d2		 xor	 edx, edx
  001ea	eb 18		 jmp	 SHORT $LN61@tok_nextc
$LN60@tok_nextc:
  001ec	48 85 c0	 test	 rax, rax
  001ef	ba 01 00 00 00	 mov	 edx, 1
  001f4	48 8b cd	 mov	 rcx, rbp
  001f7	48 0f 45 d0	 cmovne	 rdx, rax
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN105@tok_nextc:
  00201	48 8b d0	 mov	 rdx, rax
$LN61@tok_nextc:

; 968  :                 tok->lineno++;

  00204	ff 83 e8 01 00
	00		 inc	 DWORD PTR [rbx+488]

; 969  :                 if (buf == NULL) {

  0020a	48 85 d2	 test	 rdx, rdx
  0020d	0f 84 b9 02 00
	00		 je	 $LN96@tok_nextc

; 975  :                 }
; 976  :                 tok->buf = buf;
; 977  :                 tok->cur = tok->buf + oldlen;

  00213	4a 8d 04 2a	 lea	 rax, QWORD PTR [rdx+r13]
  00217	48 89 13	 mov	 QWORD PTR [rbx], rdx

; 978  :                 tok->line_start = tok->cur;
; 979  :                 strcpy(tok->buf + oldlen, newtok);

  0021a	48 2b d6	 sub	 rdx, rsi
  0021d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00221	48 89 83 b0 03
	00 00		 mov	 QWORD PTR [rbx+944], rax
  00228	48 8b ce	 mov	 rcx, rsi
  0022b	49 03 d5	 add	 rdx, r13
  0022e	66 90		 npad	 2
$LL68@tok_nextc:
  00230	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00233	48 ff c1	 inc	 rcx
  00236	88 44 0a ff	 mov	 BYTE PTR [rdx+rcx-1], al
  0023a	84 c0		 test	 al, al
  0023c	75 f2		 jne	 SHORT $LL68@tok_nextc

; 980  :                 PyMem_FREE(newtok);

  0023e	e8 00 00 00 00	 call	 _Py_PXCTX
  00243	48 8b ce	 mov	 rcx, rsi
  00246	85 c0		 test	 eax, eax
  00248	74 07		 je	 SHORT $LN69@tok_nextc
  0024a	e8 00 00 00 00	 call	 _PxMem_Free
  0024f	eb 06		 jmp	 SHORT $LN70@tok_nextc
$LN69@tok_nextc:
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN70@tok_nextc:

; 981  :                 tok->inp = tok->buf + newlen;

  00257	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0025a	48 8d 04 39	 lea	 rax, QWORD PTR [rcx+rdi]
  0025e	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 982  :                 tok->end = tok->inp + 1;

  00262	48 ff c0	 inc	 rax
  00265	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 983  :                 tok->start = tok->buf + start;

  00269	4a 8d 04 21	 lea	 rax, QWORD PTR [rcx+r12]
  0026d	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 984  :             }
; 985  :             else {

  00271	e9 fd 01 00 00	 jmp	 $LN3@tok_nextc
$LN22@tok_nextc:

; 986  :                 tok->lineno++;

  00276	ff 83 e8 01 00
	00		 inc	 DWORD PTR [rbx+488]

; 987  :                 if (tok->buf != NULL)

  0027c	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00280	74 19		 je	 SHORT $LN72@tok_nextc

; 988  :                     PyMem_FREE(tok->buf);

  00282	e8 00 00 00 00	 call	 _Py_PXCTX
  00287	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0028a	85 c0		 test	 eax, eax
  0028c	74 07		 je	 SHORT $LN71@tok_nextc
  0028e	e8 00 00 00 00	 call	 _PxMem_Free
  00293	eb 06		 jmp	 SHORT $LN72@tok_nextc
$LN71@tok_nextc:
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN72@tok_nextc:

; 989  :                 tok->buf = newtok;
; 990  :                 tok->line_start = tok->buf;
; 991  :                 tok->cur = tok->buf;
; 992  :                 tok->line_start = tok->buf;
; 993  :                 tok->inp = strchr(tok->buf, '\0');

  0029b	33 d2		 xor	 edx, edx
  0029d	48 8b ce	 mov	 rcx, rsi
  002a0	48 89 33	 mov	 QWORD PTR [rbx], rsi
  002a3	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  002a7	48 89 b3 b0 03
	00 00		 mov	 QWORD PTR [rbx+944], rsi
  002ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  002b4	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 994  :                 tok->end = tok->inp + 1;

  002b8	48 ff c0	 inc	 rax
  002bb	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 995  :             }
; 996  :         }
; 997  :         else {

  002bf	e9 af 01 00 00	 jmp	 $LN3@tok_nextc
$LN33@tok_nextc:

; 998  :             int done = 0;

  002c4	33 ff		 xor	 edi, edi

; 999  :             Py_ssize_t cur = 0;

  002c6	45 33 ed	 xor	 r13d, r13d

; 1000 :             char *pt;
; 1001 :             if (tok->start == NULL) {

  002c9	48 39 7b 20	 cmp	 QWORD PTR [rbx+32], rdi
  002cd	75 74		 jne	 SHORT $LN17@tok_nextc

; 1002 :                 if (tok->buf == NULL) {

  002cf	48 39 3b	 cmp	 QWORD PTR [rbx], rdi
  002d2	75 31		 jne	 SHORT $LN16@tok_nextc

; 1003 :                     tok->buf = (char *)
; 1004 :                         PyMem_MALLOC(BUFSIZ);

  002d4	e8 00 00 00 00	 call	 _Py_PXCTX
  002d9	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002de	85 c0		 test	 eax, eax
  002e0	74 07		 je	 SHORT $LN73@tok_nextc
  002e2	e8 00 00 00 00	 call	 _PxMem_Malloc
  002e7	eb 06		 jmp	 SHORT $LN74@tok_nextc
$LN73@tok_nextc:
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN74@tok_nextc:
  002ef	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1005 :                     if (tok->buf == NULL) {

  002f2	48 85 c0	 test	 rax, rax
  002f5	0f 84 14 02 00
	00		 je	 $LN67@tok_nextc

; 1006 :                         tok->done = E_NOMEM;
; 1007 :                         return EOF;
; 1008 :                     }
; 1009 :                     tok->end = tok->buf + BUFSIZ;

  002fb	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  00301	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
$LN16@tok_nextc:

; 1010 :                 }
; 1011 :                 if (decoding_fgets(tok->buf, (int)(tok->end - tok->buf),
; 1012 :                           tok) == NULL) {

  00305	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  00308	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0030b	4c 8b c3	 mov	 r8, rbx
  0030e	2b 13		 sub	 edx, DWORD PTR [rbx]
  00310	e8 00 00 00 00	 call	 decoding_fgets
  00315	48 85 c0	 test	 rax, rax
  00318	75 0c		 jne	 SHORT $LN14@tok_nextc

; 1013 :                     tok->done = E_EOF;

  0031a	c7 43 28 0b 00
	00 00		 mov	 DWORD PTR [rbx+40], 11

; 1014 :                     done = 1;

  00321	8d 78 01	 lea	 edi, QWORD PTR [rax+1]

; 1015 :                 }
; 1016 :                 else {

  00324	eb 42		 jmp	 SHORT $LN10@tok_nextc
$LN14@tok_nextc:

; 1017 :                     tok->done = E_OK;
; 1018 :                     tok->inp = strchr(tok->buf, '\0');

  00326	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00329	33 d2		 xor	 edx, edx
  0032b	44 89 73 28	 mov	 DWORD PTR [rbx+40], r14d
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00335	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1019 :                     done = tok->inp[-1] == '\n';

  00339	44 38 70 ff	 cmp	 BYTE PTR [rax-1], r14b
  0033d	40 0f 94 c7	 sete	 dil

; 1020 :                 }
; 1021 :             }
; 1022 :             else {

  00341	eb 25		 jmp	 SHORT $LN10@tok_nextc
$LN17@tok_nextc:

; 1023 :                 cur = tok->cur - tok->buf;

  00343	4c 8b 6b 08	 mov	 r13, QWORD PTR [rbx+8]

; 1024 :                 if (decoding_feof(tok)) {

  00347	48 8b cb	 mov	 rcx, rbx
  0034a	4c 2b 2b	 sub	 r13, QWORD PTR [rbx]
  0034d	e8 00 00 00 00	 call	 decoding_feof
  00352	85 c0		 test	 eax, eax
  00354	74 0e		 je	 SHORT $LN11@tok_nextc

; 1025 :                     tok->done = E_EOF;

  00356	c7 43 28 0b 00
	00 00		 mov	 DWORD PTR [rbx+40], 11

; 1026 :                     done = 1;

  0035d	bf 01 00 00 00	 mov	 edi, 1

; 1027 :                 }
; 1028 :                 else

  00362	eb 04		 jmp	 SHORT $LN10@tok_nextc
$LN11@tok_nextc:

; 1029 :                     tok->done = E_OK;

  00364	44 89 73 28	 mov	 DWORD PTR [rbx+40], r14d
$LN10@tok_nextc:

; 1030 :             }
; 1031 :             tok->lineno++;

  00368	ff 83 e8 01 00
	00		 inc	 DWORD PTR [rbx+488]

; 1032 :             /* Read until '\n' or EOF */
; 1033 :             while (!done) {

  0036e	85 ff		 test	 edi, edi
  00370	0f 85 c7 00 00
	00		 jne	 $LN103@tok_nextc
$LL9@tok_nextc:

; 1034 :                 Py_ssize_t curstart = tok->start == NULL ? -1 :
; 1035 :                           tok->start - tok->buf;

  00376	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]
  0037a	48 85 ff	 test	 rdi, rdi
  0037d	75 06		 jne	 SHORT $LN75@tok_nextc
  0037f	48 83 cf ff	 or	 rdi, -1
  00383	eb 03		 jmp	 SHORT $LN76@tok_nextc
$LN75@tok_nextc:
  00385	48 2b 3b	 sub	 rdi, QWORD PTR [rbx]
$LN76@tok_nextc:

; 1036 :                 Py_ssize_t curvalid = tok->inp - tok->buf;

  00388	4c 8b 23	 mov	 r12, QWORD PTR [rbx]
  0038b	48 8b 6b 10	 mov	 rbp, QWORD PTR [rbx+16]
  0038f	49 2b ec	 sub	 rbp, r12

; 1037 :                 Py_ssize_t newsize = curvalid + BUFSIZ;

  00392	48 8d b5 00 02
	00 00		 lea	 rsi, QWORD PTR [rbp+512]

; 1038 :                 char *newbuf = tok->buf;
; 1039 :                 newbuf = (char *)PyMem_REALLOC(newbuf,
; 1040 :                                                newsize);

  00399	e8 00 00 00 00	 call	 _Py_PXCTX
  0039e	85 c0		 test	 eax, eax
  003a0	74 0d		 je	 SHORT $LN79@tok_nextc
  003a2	48 8b d6	 mov	 rdx, rsi
  003a5	49 8b cc	 mov	 rcx, r12
  003a8	e8 00 00 00 00	 call	 _PxMem_Realloc
  003ad	eb 1e		 jmp	 SHORT $LN106@tok_nextc
$LN79@tok_nextc:
  003af	49 3b f7	 cmp	 rsi, r15
  003b2	0f 87 b2 01 00
	00		 ja	 $LN88@tok_nextc
  003b8	48 85 f6	 test	 rsi, rsi
  003bb	ba 01 00 00 00	 mov	 edx, 1
  003c0	49 8b cc	 mov	 rcx, r12
  003c3	48 0f 45 d6	 cmovne	 rdx, rsi
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN106@tok_nextc:
  003cd	4c 8b d8	 mov	 r11, rax

; 1041 :                 if (newbuf == NULL) {

  003d0	48 85 c0	 test	 rax, rax
  003d3	0f 84 91 01 00
	00		 je	 $LN88@tok_nextc

; 1045 :                 }
; 1046 :                 tok->buf = newbuf;
; 1047 :                 tok->inp = tok->buf + curvalid;

  003d9	48 8d 0c 28	 lea	 rcx, QWORD PTR [rax+rbp]
  003dd	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1048 :                 tok->end = tok->buf + newsize;

  003e0	48 8d 04 30	 lea	 rax, QWORD PTR [rax+rsi]
  003e4	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  003e8	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1049 :                 tok->start = curstart < 0 ? NULL :
; 1050 :                          tok->buf + curstart;

  003ec	48 85 ff	 test	 rdi, rdi
  003ef	79 04		 jns	 SHORT $LN81@tok_nextc
  003f1	33 c0		 xor	 eax, eax
  003f3	eb 04		 jmp	 SHORT $LN82@tok_nextc
$LN81@tok_nextc:
  003f5	49 8d 04 3b	 lea	 rax, QWORD PTR [r11+rdi]
$LN82@tok_nextc:

; 1051 :                 if (decoding_fgets(tok->inp,
; 1052 :                                (int)(tok->end - tok->inp),
; 1053 :                                tok) == NULL) {

  003f9	8b 53 18	 mov	 edx, DWORD PTR [rbx+24]
  003fc	4c 8b c3	 mov	 r8, rbx
  003ff	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00403	2b d1		 sub	 edx, ecx
  00405	e8 00 00 00 00	 call	 decoding_fgets
  0040a	48 85 c0	 test	 rax, rax
  0040d	75 14		 jne	 SHORT $LN6@tok_nextc

; 1054 :                     /* Break out early on decoding
; 1055 :                        errors, as tok->buf will be NULL
; 1056 :                      */
; 1057 :                     if (tok->decoding_erred)

  0040f	39 83 98 03 00
	00		 cmp	 DWORD PTR [rbx+920], eax
  00415	0f 85 c2 01 00
	00		 jne	 $LN91@tok_nextc

; 1058 :                         return EOF;
; 1059 :                     /* Last line does not end in \n,
; 1060 :                        fake one */
; 1061 :                     strcpy(tok->inp, "\n");

  0041b	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0041f	66 44 89 30	 mov	 WORD PTR [rax], r14w
$LN6@tok_nextc:

; 1062 :                 }
; 1063 :                 tok->inp = strchr(tok->inp, '\0');

  00423	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00427	33 d2		 xor	 edx, edx
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0042f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1064 :                 done = tok->inp[-1] == '\n';

  00433	44 38 70 ff	 cmp	 BYTE PTR [rax-1], r14b
  00437	0f 85 39 ff ff
	ff		 jne	 $LL9@tok_nextc
$LN103@tok_nextc:

; 1065 :             }
; 1066 :             if (tok->buf != NULL) {

  0043d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00440	48 85 c9	 test	 rcx, rcx
  00443	74 2e		 je	 SHORT $LN3@tok_nextc

; 1067 :                 tok->cur = tok->buf + cur;

  00445	4a 8d 04 29	 lea	 rax, QWORD PTR [rcx+r13]
  00449	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1068 :                 tok->line_start = tok->cur;

  0044d	48 89 83 b0 03
	00 00		 mov	 QWORD PTR [rbx+944], rax

; 1069 :                 /* replace "\r\n" with "\n" */
; 1070 :                 /* For Mac leave the \r, giving a syntax error */
; 1071 :                 pt = tok->inp - 2;

  00454	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00458	48 83 e8 02	 sub	 rax, 2

; 1072 :                 if (pt >= tok->buf && *pt == '\r') {

  0045c	48 3b c1	 cmp	 rax, rcx
  0045f	72 12		 jb	 SHORT $LN3@tok_nextc
  00461	80 38 0d	 cmp	 BYTE PTR [rax], 13
  00464	75 0d		 jne	 SHORT $LN3@tok_nextc

; 1073 :                     *pt++ = '\n';

  00466	44 88 30	 mov	 BYTE PTR [rax], r14b
  00469	48 ff c0	 inc	 rax

; 1074 :                     *pt = '\0';

  0046c	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1075 :                     tok->inp = pt;

  0046f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN3@tok_nextc:

; 1076 :                 }
; 1077 :             }
; 1078 :         }
; 1079 :         if (tok->done != E_OK) {

  00473	44 39 73 28	 cmp	 DWORD PTR [rbx+40], r14d
  00477	0f 85 be 00 00
	00		 jne	 $LN98@tok_nextc

; 898  :     for (;;) {
; 899  :         if (tok->cur != tok->inp) {

  0047d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00481	48 39 43 08	 cmp	 QWORD PTR [rbx+8], rax
  00485	0f 84 b5 fb ff
	ff		 je	 $LL42@tok_nextc
$LN90@tok_nextc:

; 900  :             return Py_CHARMASK(*tok->cur++); /* Fast path */

  0048b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
$LN107@tok_nextc:
  0048f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00492	48 ff c0	 inc	 rax
  00495	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  00499	8b c1		 mov	 eax, ecx
$LN41@tok_nextc:

; 1084 :         }
; 1085 :     }
; 1086 :     /*NOTREACHED*/
; 1087 : }

  0049b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  004a0	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  004a5	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  004aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  004ae	41 5f		 pop	 r15
  004b0	41 5e		 pop	 r14
  004b2	41 5d		 pop	 r13
  004b4	41 5c		 pop	 r12
  004b6	5f		 pop	 rdi
  004b7	c3		 ret	 0
$LN95@tok_nextc:

; 945  :                     Py_DECREF(u);

  004b8	48 8b cd	 mov	 rcx, rbp
  004bb	e8 00 00 00 00	 call	 _Py_DecRef
$LN94@tok_nextc:

; 946  :                     tok->done = E_DECODE;

  004c0	c7 43 28 16 00
	00 00		 mov	 DWORD PTR [rbx+40], 22

; 947  :                     return EOF;

  004c7	83 c8 ff	 or	 eax, -1
  004ca	eb cf		 jmp	 SHORT $LN41@tok_nextc
$LN96@tok_nextc:

; 970  :                     PyMem_FREE(tok->buf);

  004cc	e8 00 00 00 00	 call	 _Py_PXCTX
  004d1	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  004d4	85 c0		 test	 eax, eax
  004d6	74 07		 je	 SHORT $LN64@tok_nextc
  004d8	e8 00 00 00 00	 call	 _PxMem_Free
  004dd	eb 06		 jmp	 SHORT $LN65@tok_nextc
$LN64@tok_nextc:
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN65@tok_nextc:

; 971  :                     tok->buf = NULL;

  004e5	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 972  :                     PyMem_FREE(newtok);

  004ec	e8 00 00 00 00	 call	 _Py_PXCTX
  004f1	48 8b ce	 mov	 rcx, rsi
  004f4	85 c0		 test	 eax, eax
  004f6	74 11		 je	 SHORT $LN66@tok_nextc
  004f8	e8 00 00 00 00	 call	 _PxMem_Free

; 973  :                     tok->done = E_NOMEM;

  004fd	c7 43 28 0f 00
	00 00		 mov	 DWORD PTR [rbx+40], 15

; 974  :                     return EOF;

  00504	83 c8 ff	 or	 eax, -1
  00507	eb 92		 jmp	 SHORT $LN41@tok_nextc
$LN66@tok_nextc:

; 972  :                     PyMem_FREE(newtok);

  00509	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN67@tok_nextc:

; 973  :                     tok->done = E_NOMEM;

  0050f	c7 43 28 0f 00
	00 00		 mov	 DWORD PTR [rbx+40], 15

; 974  :                     return EOF;

  00516	83 c8 ff	 or	 eax, -1
  00519	eb 80		 jmp	 SHORT $LN41@tok_nextc
$LN102@tok_nextc:

; 959  :                 PyMem_FREE(newtok);

  0051b	e8 00 00 00 00	 call	 _Py_PXCTX
  00520	48 8b ce	 mov	 rcx, rsi
  00523	85 c0		 test	 eax, eax
  00525	74 07		 je	 SHORT $LN56@tok_nextc
  00527	e8 00 00 00 00	 call	 _PxMem_Free
  0052c	eb 06		 jmp	 SHORT $LN57@tok_nextc
$LN56@tok_nextc:
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN57@tok_nextc:

; 960  :                 tok->done = E_EOF;

  00534	c7 43 28 0b 00
	00 00		 mov	 DWORD PTR [rbx+40], 11
$LN98@tok_nextc:

; 1080 :             if (tok->prompt != NULL)

  0053b	48 83 bb d8 01
	00 00 00	 cmp	 QWORD PTR [rbx+472], 0
  00543	74 0c		 je	 SHORT $LN1@tok_nextc

; 1081 :                 PySys_WriteStderr("\n");

  00545	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0054c	e8 00 00 00 00	 call	 PySys_WriteStderr
$LN1@tok_nextc:

; 1082 :             tok->cur = tok->inp;

  00551	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00555	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1083 :             return EOF;

  00559	83 c8 ff	 or	 eax, -1
  0055c	e9 3a ff ff ff	 jmp	 $LN41@tok_nextc
$LN101@tok_nextc:

; 957  :                 tok->done = E_INTR;

  00561	c7 43 28 0c 00
	00 00		 mov	 DWORD PTR [rbx+40], 12
  00568	eb d1		 jmp	 SHORT $LN98@tok_nextc
$LN88@tok_nextc:

; 1042 :                     tok->done = E_NOMEM;
; 1043 :                     tok->cur = tok->inp;

  0056a	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0056e	c7 43 28 0f 00
	00 00		 mov	 DWORD PTR [rbx+40], 15
  00575	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1044 :                     return EOF;

  00579	83 c8 ff	 or	 eax, -1
  0057c	e9 1a ff ff ff	 jmp	 $LN41@tok_nextc
$LN92@tok_nextc:

; 905  :             char *end = strchr(tok->inp, '\n');

  00581	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00585	41 8b d6	 mov	 edx, r14d
  00588	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  0058e	48 8b d0	 mov	 rdx, rax

; 906  :             if (end != NULL)

  00591	48 85 c0	 test	 rax, rax
  00594	74 2b		 je	 SHORT $LN37@tok_nextc

; 907  :                 end++;

  00596	48 ff c2	 inc	 rdx
$LN35@tok_nextc:

; 913  :                 }
; 914  :             }
; 915  :             if (tok->start == NULL)

  00599	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  0059e	75 07		 jne	 SHORT $LN34@tok_nextc

; 916  :                 tok->buf = tok->cur;

  005a0	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  005a4	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN34@tok_nextc:

; 917  :             tok->line_start = tok->cur;

  005a7	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]

; 918  :             tok->lineno++;

  005ab	ff 83 e8 01 00
	00		 inc	 DWORD PTR [rbx+488]

; 919  :             tok->inp = end;

  005b1	48 89 53 10	 mov	 QWORD PTR [rbx+16], rdx
  005b5	48 89 83 b0 03
	00 00		 mov	 QWORD PTR [rbx+944], rax

; 920  :             return Py_CHARMASK(*tok->cur++);

  005bc	e9 ce fe ff ff	 jmp	 $LN107@tok_nextc
$LN37@tok_nextc:

; 908  :             else {
; 909  :                 end = strchr(tok->inp, '\0');

  005c1	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  005c5	33 d2		 xor	 edx, edx
  005c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  005cd	48 8b d0	 mov	 rdx, rax

; 910  :                 if (end == tok->inp) {

  005d0	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  005d4	75 c3		 jne	 SHORT $LN35@tok_nextc

; 911  :                     tok->done = E_EOF;

  005d6	c7 43 28 0b 00
	00 00		 mov	 DWORD PTR [rbx+40], 11
$LN91@tok_nextc:

; 912  :                     return EOF;

  005dd	83 c8 ff	 or	 eax, -1
  005e0	e9 b6 fe ff ff	 jmp	 $LN41@tok_nextc
tok_nextc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_backup DD imagerel tok_backup
	DD	imagerel tok_backup+71
	DD	imagerel $unwind$tok_backup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_backup DD 040f01H
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@
CONST	SEGMENT
??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@ DB 'tok_backu'
	DB	'p: beginning of buffer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tok_backup
_TEXT	SEGMENT
tok$ = 48
c$ = 56
tok_backup PROC						; COMDAT

; 1095 :     if (c != EOF) {

  00000	83 fa ff	 cmp	 edx, -1
  00003	74 40		 je	 SHORT $LN6@tok_backup
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1096 :         if (--tok->cur < tok->buf)

  0000f	48 ff 49 08	 dec	 QWORD PTR [rcx+8]
  00013	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00017	8b fa		 mov	 edi, edx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0001f	73 0c		 jae	 SHORT $LN2@tok_backup

; 1097 :             Py_FatalError("tok_backup: beginning of buffer");

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@KEKPIPHC@tok_backup?3?5beginning?5of?5buffer?$AA@
  00028	e8 00 00 00 00	 call	 Py_FatalError
$LN2@tok_backup:

; 1098 :         if (*tok->cur != c)

  0002d	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00031	0f be 01	 movsx	 eax, BYTE PTR [rcx]
  00034	3b c7		 cmp	 eax, edi
  00036	74 03		 je	 SHORT $LN1@tok_backup

; 1099 :             *tok->cur = c;

  00038	40 88 39	 mov	 BYTE PTR [rcx], dil
$LN1@tok_backup:

; 1100 :     }
; 1101 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5f		 pop	 rdi
$LN6@tok_backup:
  00045	f3 c3		 fatret	 0
tok_backup ENDP
_TEXT	ENDS
PUBLIC	PyToken_OneChar
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
;	COMDAT PyToken_OneChar
_TEXT	SEGMENT
c$ = 8
PyToken_OneChar PROC					; COMDAT

; 1109 :     switch (c) {

  00000	83 c1 db	 add	 ecx, -37		; ffffffffffffffdbH
  00003	83 f9 59	 cmp	 ecx, 89			; 00000059H
  00006	0f 87 a8 00 00
	00		 ja	 $LN1@PyToken_On
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00013	48 63 c1	 movsxd	 rax, ecx
  00016	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN29@PyToken_On[rdx+rax]
  0001e	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN30@PyToken_On[rdx+rax*4]
  00025	48 03 ca	 add	 rcx, rdx
  00028	ff e1		 jmp	 rcx
$LN24@PyToken_On:

; 1110 :     case '(':           return LPAR;

  0002a	b8 07 00 00 00	 mov	 eax, 7

; 1134 :     }
; 1135 : }

  0002f	c3		 ret	 0
$LN23@PyToken_On:

; 1111 :     case ')':           return RPAR;

  00030	b8 08 00 00 00	 mov	 eax, 8

; 1134 :     }
; 1135 : }

  00035	c3		 ret	 0
$LN22@PyToken_On:

; 1112 :     case '[':           return LSQB;

  00036	b8 09 00 00 00	 mov	 eax, 9

; 1134 :     }
; 1135 : }

  0003b	c3		 ret	 0
$LN21@PyToken_On:

; 1113 :     case ']':           return RSQB;

  0003c	b8 0a 00 00 00	 mov	 eax, 10

; 1134 :     }
; 1135 : }

  00041	c3		 ret	 0
$LN20@PyToken_On:

; 1114 :     case ':':           return COLON;

  00042	b8 0b 00 00 00	 mov	 eax, 11

; 1134 :     }
; 1135 : }

  00047	c3		 ret	 0
$LN19@PyToken_On:

; 1115 :     case ',':           return COMMA;

  00048	b8 0c 00 00 00	 mov	 eax, 12

; 1134 :     }
; 1135 : }

  0004d	c3		 ret	 0
$LN18@PyToken_On:

; 1116 :     case ';':           return SEMI;

  0004e	b8 0d 00 00 00	 mov	 eax, 13

; 1134 :     }
; 1135 : }

  00053	c3		 ret	 0
$LN17@PyToken_On:

; 1117 :     case '+':           return PLUS;

  00054	b8 0e 00 00 00	 mov	 eax, 14

; 1134 :     }
; 1135 : }

  00059	c3		 ret	 0
$LN16@PyToken_On:

; 1118 :     case '-':           return MINUS;

  0005a	b8 0f 00 00 00	 mov	 eax, 15

; 1134 :     }
; 1135 : }

  0005f	c3		 ret	 0
$LN15@PyToken_On:

; 1119 :     case '*':           return STAR;

  00060	b8 10 00 00 00	 mov	 eax, 16

; 1134 :     }
; 1135 : }

  00065	c3		 ret	 0
$LN14@PyToken_On:

; 1120 :     case '/':           return SLASH;

  00066	b8 11 00 00 00	 mov	 eax, 17

; 1134 :     }
; 1135 : }

  0006b	c3		 ret	 0
$LN13@PyToken_On:

; 1121 :     case '|':           return VBAR;

  0006c	b8 12 00 00 00	 mov	 eax, 18

; 1134 :     }
; 1135 : }

  00071	c3		 ret	 0
$LN12@PyToken_On:

; 1122 :     case '&':           return AMPER;

  00072	b8 13 00 00 00	 mov	 eax, 19

; 1134 :     }
; 1135 : }

  00077	c3		 ret	 0
$LN11@PyToken_On:

; 1123 :     case '<':           return LESS;

  00078	b8 14 00 00 00	 mov	 eax, 20

; 1134 :     }
; 1135 : }

  0007d	c3		 ret	 0
$LN10@PyToken_On:

; 1124 :     case '>':           return GREATER;

  0007e	b8 15 00 00 00	 mov	 eax, 21

; 1134 :     }
; 1135 : }

  00083	c3		 ret	 0
$LN9@PyToken_On:

; 1125 :     case '=':           return EQUAL;

  00084	b8 16 00 00 00	 mov	 eax, 22

; 1134 :     }
; 1135 : }

  00089	c3		 ret	 0
$LN8@PyToken_On:

; 1126 :     case '.':           return DOT;

  0008a	b8 17 00 00 00	 mov	 eax, 23

; 1134 :     }
; 1135 : }

  0008f	c3		 ret	 0
$LN7@PyToken_On:

; 1127 :     case '%':           return PERCENT;

  00090	b8 18 00 00 00	 mov	 eax, 24

; 1134 :     }
; 1135 : }

  00095	c3		 ret	 0
$LN6@PyToken_On:

; 1128 :     case '{':           return LBRACE;

  00096	b8 19 00 00 00	 mov	 eax, 25

; 1134 :     }
; 1135 : }

  0009b	c3		 ret	 0
$LN5@PyToken_On:

; 1129 :     case '}':           return RBRACE;

  0009c	b8 1a 00 00 00	 mov	 eax, 26

; 1134 :     }
; 1135 : }

  000a1	c3		 ret	 0
$LN4@PyToken_On:

; 1130 :     case '^':           return CIRCUMFLEX;

  000a2	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 1134 :     }
; 1135 : }

  000a7	c3		 ret	 0
$LN3@PyToken_On:

; 1131 :     case '~':           return TILDE;

  000a8	b8 1f 00 00 00	 mov	 eax, 31

; 1134 :     }
; 1135 : }

  000ad	c3		 ret	 0
$LN2@PyToken_On:

; 1132 :     case '@':       return AT;

  000ae	b8 31 00 00 00	 mov	 eax, 49			; 00000031H

; 1134 :     }
; 1135 : }

  000b3	c3		 ret	 0
$LN1@PyToken_On:

; 1133 :     default:            return OP;

  000b4	b8 34 00 00 00	 mov	 eax, 52			; 00000034H

; 1134 :     }
; 1135 : }

  000b9	c3		 ret	 0
  000ba	66 90		 npad	 2
$LN30@PyToken_On:
  000bc	00 00 00 00	 DD	 $LN7@PyToken_On
  000c0	00 00 00 00	 DD	 $LN12@PyToken_On
  000c4	00 00 00 00	 DD	 $LN24@PyToken_On
  000c8	00 00 00 00	 DD	 $LN23@PyToken_On
  000cc	00 00 00 00	 DD	 $LN15@PyToken_On
  000d0	00 00 00 00	 DD	 $LN17@PyToken_On
  000d4	00 00 00 00	 DD	 $LN19@PyToken_On
  000d8	00 00 00 00	 DD	 $LN16@PyToken_On
  000dc	00 00 00 00	 DD	 $LN8@PyToken_On
  000e0	00 00 00 00	 DD	 $LN14@PyToken_On
  000e4	00 00 00 00	 DD	 $LN20@PyToken_On
  000e8	00 00 00 00	 DD	 $LN18@PyToken_On
  000ec	00 00 00 00	 DD	 $LN11@PyToken_On
  000f0	00 00 00 00	 DD	 $LN9@PyToken_On
  000f4	00 00 00 00	 DD	 $LN10@PyToken_On
  000f8	00 00 00 00	 DD	 $LN2@PyToken_On
  000fc	00 00 00 00	 DD	 $LN22@PyToken_On
  00100	00 00 00 00	 DD	 $LN21@PyToken_On
  00104	00 00 00 00	 DD	 $LN4@PyToken_On
  00108	00 00 00 00	 DD	 $LN6@PyToken_On
  0010c	00 00 00 00	 DD	 $LN13@PyToken_On
  00110	00 00 00 00	 DD	 $LN5@PyToken_On
  00114	00 00 00 00	 DD	 $LN3@PyToken_On
  00118	00 00 00 00	 DD	 $LN1@PyToken_On
$LN29@PyToken_On:
  0011c	00		 DB	 0
  0011d	01		 DB	 1
  0011e	17		 DB	 23
  0011f	02		 DB	 2
  00120	03		 DB	 3
  00121	04		 DB	 4
  00122	05		 DB	 5
  00123	06		 DB	 6
  00124	07		 DB	 7
  00125	08		 DB	 8
  00126	09		 DB	 9
  00127	17		 DB	 23
  00128	17		 DB	 23
  00129	17		 DB	 23
  0012a	17		 DB	 23
  0012b	17		 DB	 23
  0012c	17		 DB	 23
  0012d	17		 DB	 23
  0012e	17		 DB	 23
  0012f	17		 DB	 23
  00130	17		 DB	 23
  00131	0a		 DB	 10
  00132	0b		 DB	 11
  00133	0c		 DB	 12
  00134	0d		 DB	 13
  00135	0e		 DB	 14
  00136	17		 DB	 23
  00137	0f		 DB	 15
  00138	17		 DB	 23
  00139	17		 DB	 23
  0013a	17		 DB	 23
  0013b	17		 DB	 23
  0013c	17		 DB	 23
  0013d	17		 DB	 23
  0013e	17		 DB	 23
  0013f	17		 DB	 23
  00140	17		 DB	 23
  00141	17		 DB	 23
  00142	17		 DB	 23
  00143	17		 DB	 23
  00144	17		 DB	 23
  00145	17		 DB	 23
  00146	17		 DB	 23
  00147	17		 DB	 23
  00148	17		 DB	 23
  00149	17		 DB	 23
  0014a	17		 DB	 23
  0014b	17		 DB	 23
  0014c	17		 DB	 23
  0014d	17		 DB	 23
  0014e	17		 DB	 23
  0014f	17		 DB	 23
  00150	17		 DB	 23
  00151	17		 DB	 23
  00152	10		 DB	 16
  00153	17		 DB	 23
  00154	11		 DB	 17
  00155	12		 DB	 18
  00156	17		 DB	 23
  00157	17		 DB	 23
  00158	17		 DB	 23
  00159	17		 DB	 23
  0015a	17		 DB	 23
  0015b	17		 DB	 23
  0015c	17		 DB	 23
  0015d	17		 DB	 23
  0015e	17		 DB	 23
  0015f	17		 DB	 23
  00160	17		 DB	 23
  00161	17		 DB	 23
  00162	17		 DB	 23
  00163	17		 DB	 23
  00164	17		 DB	 23
  00165	17		 DB	 23
  00166	17		 DB	 23
  00167	17		 DB	 23
  00168	17		 DB	 23
  00169	17		 DB	 23
  0016a	17		 DB	 23
  0016b	17		 DB	 23
  0016c	17		 DB	 23
  0016d	17		 DB	 23
  0016e	17		 DB	 23
  0016f	17		 DB	 23
  00170	17		 DB	 23
  00171	17		 DB	 23
  00172	13		 DB	 19
  00173	14		 DB	 20
  00174	15		 DB	 21
  00175	16		 DB	 22
PyToken_OneChar ENDP
_TEXT	ENDS
PUBLIC	PyToken_TwoChars
; Function compile flags: /Ogtpy
;	COMDAT PyToken_TwoChars
_TEXT	SEGMENT
c1$ = 8
c2$ = 16
PyToken_TwoChars PROC					; COMDAT

; 1141 :     switch (c1) {

  00000	83 c1 df	 add	 ecx, -33		; ffffffffffffffdfH
  00003	83 f9 5b	 cmp	 ecx, 91			; 0000005bH
  00006	0f 87 d7 00 00
	00		 ja	 $LN55@PyToken_Tw
  0000c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00013	48 63 c1	 movsxd	 rax, ecx
  00016	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN59@PyToken_Tw[r8+rax]
  0001f	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN60@PyToken_Tw[r8+rax*4]
  00027	49 03 c8	 add	 rcx, r8
  0002a	ff e1		 jmp	 rcx
$LN54@PyToken_Tw:

; 1142 :     case '=':
; 1143 :         switch (c2) {

  0002c	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0002f	0f 85 ae 00 00
	00		 jne	 $LN55@PyToken_Tw

; 1144 :         case '=':               return EQEQUAL;

  00035	8d 42 de	 lea	 eax, QWORD PTR [rdx-34]

; 1210 : }

  00038	c3		 ret	 0
$LN50@PyToken_Tw:

; 1145 :         }
; 1146 :         break;
; 1147 :     case '!':
; 1148 :         switch (c2) {

  00039	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0003c	0f 85 a1 00 00
	00		 jne	 $LN55@PyToken_Tw

; 1149 :         case '=':               return NOTEQUAL;

  00042	8d 42 df	 lea	 eax, QWORD PTR [rdx-33]

; 1210 : }

  00045	c3		 ret	 0
$LN46@PyToken_Tw:

; 1150 :         }
; 1151 :         break;
; 1152 :     case '<':
; 1153 :         switch (c2) {

  00046	83 ea 3c	 sub	 edx, 60			; 0000003cH
  00049	74 16		 je	 SHORT $LN41@PyToken_Tw
  0004b	ff ca		 dec	 edx
  0004d	74 0c		 je	 SHORT $LN42@PyToken_Tw
  0004f	ff ca		 dec	 edx
  00051	0f 85 8c 00 00
	00		 jne	 $LN55@PyToken_Tw

; 1154 :         case '>':               return NOTEQUAL;

  00057	8d 42 1c	 lea	 eax, QWORD PTR [rdx+28]

; 1210 : }

  0005a	c3		 ret	 0
$LN42@PyToken_Tw:

; 1155 :         case '=':               return LESSEQUAL;

  0005b	b8 1d 00 00 00	 mov	 eax, 29

; 1210 : }

  00060	c3		 ret	 0
$LN41@PyToken_Tw:

; 1156 :         case '<':               return LEFTSHIFT;

  00061	b8 21 00 00 00	 mov	 eax, 33			; 00000021H

; 1210 : }

  00066	c3		 ret	 0
$LN40@PyToken_Tw:

; 1157 :         }
; 1158 :         break;
; 1159 :     case '>':
; 1160 :         switch (c2) {

  00067	83 ea 3d	 sub	 edx, 61			; 0000003dH
  0006a	74 08		 je	 SHORT $LN37@PyToken_Tw
  0006c	ff ca		 dec	 edx
  0006e	75 73		 jne	 SHORT $LN55@PyToken_Tw

; 1162 :         case '>':               return RIGHTSHIFT;

  00070	8d 42 22	 lea	 eax, QWORD PTR [rdx+34]

; 1210 : }

  00073	c3		 ret	 0
$LN37@PyToken_Tw:

; 1161 :         case '=':               return GREATEREQUAL;

  00074	b8 1e 00 00 00	 mov	 eax, 30

; 1210 : }

  00079	c3		 ret	 0
$LN35@PyToken_Tw:

; 1163 :         }
; 1164 :         break;
; 1165 :     case '+':
; 1166 :         switch (c2) {

  0007a	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0007d	75 64		 jne	 SHORT $LN55@PyToken_Tw

; 1167 :         case '=':               return PLUSEQUAL;

  0007f	8d 42 e7	 lea	 eax, QWORD PTR [rdx-25]

; 1210 : }

  00082	c3		 ret	 0
$LN31@PyToken_Tw:

; 1168 :         }
; 1169 :         break;
; 1170 :     case '-':
; 1171 :         switch (c2) {

  00083	83 ea 3d	 sub	 edx, 61			; 0000003dH
  00086	74 08		 je	 SHORT $LN28@PyToken_Tw
  00088	ff ca		 dec	 edx
  0008a	75 57		 jne	 SHORT $LN55@PyToken_Tw

; 1173 :         case '>':               return RARROW;

  0008c	8d 42 32	 lea	 eax, QWORD PTR [rdx+50]

; 1210 : }

  0008f	c3		 ret	 0
$LN28@PyToken_Tw:

; 1172 :         case '=':               return MINEQUAL;

  00090	b8 25 00 00 00	 mov	 eax, 37			; 00000025H

; 1210 : }

  00095	c3		 ret	 0
$LN26@PyToken_Tw:

; 1174 :         }
; 1175 :         break;
; 1176 :     case '*':
; 1177 :         switch (c2) {

  00096	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00099	74 09		 je	 SHORT $LN23@PyToken_Tw
  0009b	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  0009e	75 43		 jne	 SHORT $LN55@PyToken_Tw

; 1179 :         case '=':               return STAREQUAL;

  000a0	8d 42 e9	 lea	 eax, QWORD PTR [rdx-23]

; 1210 : }

  000a3	c3		 ret	 0
$LN23@PyToken_Tw:

; 1178 :         case '*':               return DOUBLESTAR;

  000a4	b8 23 00 00 00	 mov	 eax, 35			; 00000023H

; 1210 : }

  000a9	c3		 ret	 0
$LN21@PyToken_Tw:

; 1180 :         }
; 1181 :         break;
; 1182 :     case '/':
; 1183 :         switch (c2) {

  000aa	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  000ad	74 09		 je	 SHORT $LN18@PyToken_Tw
  000af	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  000b2	75 2f		 jne	 SHORT $LN55@PyToken_Tw

; 1185 :         case '=':               return SLASHEQUAL;

  000b4	8d 42 ea	 lea	 eax, QWORD PTR [rdx-22]

; 1210 : }

  000b7	c3		 ret	 0
$LN18@PyToken_Tw:

; 1184 :         case '/':               return DOUBLESLASH;

  000b8	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH

; 1210 : }

  000bd	c3		 ret	 0
$LN16@PyToken_Tw:

; 1186 :         }
; 1187 :         break;
; 1188 :     case '|':
; 1189 :         switch (c2) {

  000be	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  000c1	75 20		 jne	 SHORT $LN55@PyToken_Tw

; 1190 :         case '=':               return VBAREQUAL;

  000c3	8d 42 ed	 lea	 eax, QWORD PTR [rdx-19]

; 1210 : }

  000c6	c3		 ret	 0
$LN12@PyToken_Tw:

; 1191 :         }
; 1192 :         break;
; 1193 :     case '%':
; 1194 :         switch (c2) {

  000c7	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  000ca	75 17		 jne	 SHORT $LN55@PyToken_Tw

; 1195 :         case '=':               return PERCENTEQUAL;

  000cc	8d 42 eb	 lea	 eax, QWORD PTR [rdx-21]

; 1210 : }

  000cf	c3		 ret	 0
$LN8@PyToken_Tw:

; 1196 :         }
; 1197 :         break;
; 1198 :     case '&':
; 1199 :         switch (c2) {

  000d0	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  000d3	75 0e		 jne	 SHORT $LN55@PyToken_Tw

; 1200 :         case '=':               return AMPEREQUAL;

  000d5	8d 42 ec	 lea	 eax, QWORD PTR [rdx-20]

; 1210 : }

  000d8	c3		 ret	 0
$LN4@PyToken_Tw:

; 1201 :         }
; 1202 :         break;
; 1203 :     case '^':
; 1204 :         switch (c2) {
; 1205 :         case '=':               return CIRCUMFLEXEQUAL;

  000d9	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  000de	83 fa 3d	 cmp	 edx, 61			; 0000003dH
  000e1	74 05		 je	 SHORT $LN57@PyToken_Tw
$LN55@PyToken_Tw:

; 1206 :         }
; 1207 :         break;
; 1208 :     }
; 1209 :     return OP;

  000e3	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN57@PyToken_Tw:

; 1210 : }

  000e8	f3 c3		 fatret	 0
  000ea	66 90		 npad	 2
$LN60@PyToken_Tw:
  000ec	00 00 00 00	 DD	 $LN50@PyToken_Tw
  000f0	00 00 00 00	 DD	 $LN12@PyToken_Tw
  000f4	00 00 00 00	 DD	 $LN8@PyToken_Tw
  000f8	00 00 00 00	 DD	 $LN26@PyToken_Tw
  000fc	00 00 00 00	 DD	 $LN35@PyToken_Tw
  00100	00 00 00 00	 DD	 $LN31@PyToken_Tw
  00104	00 00 00 00	 DD	 $LN21@PyToken_Tw
  00108	00 00 00 00	 DD	 $LN46@PyToken_Tw
  0010c	00 00 00 00	 DD	 $LN54@PyToken_Tw
  00110	00 00 00 00	 DD	 $LN40@PyToken_Tw
  00114	00 00 00 00	 DD	 $LN4@PyToken_Tw
  00118	00 00 00 00	 DD	 $LN16@PyToken_Tw
  0011c	00 00 00 00	 DD	 $LN55@PyToken_Tw
$LN59@PyToken_Tw:
  00120	00		 DB	 0
  00121	0c		 DB	 12
  00122	0c		 DB	 12
  00123	0c		 DB	 12
  00124	01		 DB	 1
  00125	02		 DB	 2
  00126	0c		 DB	 12
  00127	0c		 DB	 12
  00128	0c		 DB	 12
  00129	03		 DB	 3
  0012a	04		 DB	 4
  0012b	0c		 DB	 12
  0012c	05		 DB	 5
  0012d	0c		 DB	 12
  0012e	06		 DB	 6
  0012f	0c		 DB	 12
  00130	0c		 DB	 12
  00131	0c		 DB	 12
  00132	0c		 DB	 12
  00133	0c		 DB	 12
  00134	0c		 DB	 12
  00135	0c		 DB	 12
  00136	0c		 DB	 12
  00137	0c		 DB	 12
  00138	0c		 DB	 12
  00139	0c		 DB	 12
  0013a	0c		 DB	 12
  0013b	07		 DB	 7
  0013c	08		 DB	 8
  0013d	09		 DB	 9
  0013e	0c		 DB	 12
  0013f	0c		 DB	 12
  00140	0c		 DB	 12
  00141	0c		 DB	 12
  00142	0c		 DB	 12
  00143	0c		 DB	 12
  00144	0c		 DB	 12
  00145	0c		 DB	 12
  00146	0c		 DB	 12
  00147	0c		 DB	 12
  00148	0c		 DB	 12
  00149	0c		 DB	 12
  0014a	0c		 DB	 12
  0014b	0c		 DB	 12
  0014c	0c		 DB	 12
  0014d	0c		 DB	 12
  0014e	0c		 DB	 12
  0014f	0c		 DB	 12
  00150	0c		 DB	 12
  00151	0c		 DB	 12
  00152	0c		 DB	 12
  00153	0c		 DB	 12
  00154	0c		 DB	 12
  00155	0c		 DB	 12
  00156	0c		 DB	 12
  00157	0c		 DB	 12
  00158	0c		 DB	 12
  00159	0c		 DB	 12
  0015a	0c		 DB	 12
  0015b	0c		 DB	 12
  0015c	0c		 DB	 12
  0015d	0a		 DB	 10
  0015e	0c		 DB	 12
  0015f	0c		 DB	 12
  00160	0c		 DB	 12
  00161	0c		 DB	 12
  00162	0c		 DB	 12
  00163	0c		 DB	 12
  00164	0c		 DB	 12
  00165	0c		 DB	 12
  00166	0c		 DB	 12
  00167	0c		 DB	 12
  00168	0c		 DB	 12
  00169	0c		 DB	 12
  0016a	0c		 DB	 12
  0016b	0c		 DB	 12
  0016c	0c		 DB	 12
  0016d	0c		 DB	 12
  0016e	0c		 DB	 12
  0016f	0c		 DB	 12
  00170	0c		 DB	 12
  00171	0c		 DB	 12
  00172	0c		 DB	 12
  00173	0c		 DB	 12
  00174	0c		 DB	 12
  00175	0c		 DB	 12
  00176	0c		 DB	 12
  00177	0c		 DB	 12
  00178	0c		 DB	 12
  00179	0c		 DB	 12
  0017a	0c		 DB	 12
  0017b	0b		 DB	 11
PyToken_TwoChars ENDP
_TEXT	ENDS
PUBLIC	PyToken_ThreeChars
; Function compile flags: /Ogtpy
;	COMDAT PyToken_ThreeChars
_TEXT	SEGMENT
c1$ = 8
c2$ = 16
c3$ = 24
PyToken_ThreeChars PROC					; COMDAT

; 1215 :     switch (c1) {

  00000	83 e9 2a	 sub	 ecx, 42			; 0000002aH
  00003	74 4e		 je	 SHORT $LN21@PyToken_Th
  00005	83 e9 04	 sub	 ecx, 4
  00008	74 3b		 je	 SHORT $LN7@PyToken_Th
  0000a	ff c9		 dec	 ecx
  0000c	74 28		 je	 SHORT $LN14@PyToken_Th
  0000e	83 e9 0d	 sub	 ecx, 13
  00011	74 14		 je	 SHORT $LN35@PyToken_Th
  00013	83 f9 02	 cmp	 ecx, 2
  00016	75 49		 jne	 SHORT $LN16@PyToken_Th

; 1226 :     case '>':
; 1227 :         switch (c2) {

  00018	83 fa 3e	 cmp	 edx, 62			; 0000003eH
  0001b	75 44		 jne	 SHORT $LN16@PyToken_Th

; 1228 :         case '>':
; 1229 :             switch (c3) {

  0001d	41 83 f8 3d	 cmp	 r8d, 61			; 0000003dH

; 1232 :             }
; 1233 :             break;
; 1234 :         }
; 1235 :         break;

  00021	75 3e		 jne	 SHORT $LN16@PyToken_Th

; 1230 :             case '=':
; 1231 :                 return RIGHTSHIFTEQUAL;

  00023	8d 41 2b	 lea	 eax, QWORD PTR [rcx+43]

; 1268 : }

  00026	c3		 ret	 0
$LN35@PyToken_Th:

; 1216 :     case '<':
; 1217 :         switch (c2) {

  00027	83 fa 3c	 cmp	 edx, 60			; 0000003cH
  0002a	75 35		 jne	 SHORT $LN16@PyToken_Th

; 1218 :         case '<':
; 1219 :             switch (c3) {

  0002c	41 83 f8 3d	 cmp	 r8d, 61			; 0000003dH

; 1222 :             }
; 1223 :             break;
; 1224 :         }
; 1225 :         break;

  00030	75 2f		 jne	 SHORT $LN16@PyToken_Th

; 1220 :             case '=':
; 1221 :                 return LEFTSHIFTEQUAL;

  00032	8d 42 f0	 lea	 eax, QWORD PTR [rdx-16]

; 1268 : }

  00035	c3		 ret	 0
$LN14@PyToken_Th:

; 1242 :             }
; 1243 :             break;
; 1244 :         }
; 1245 :         break;
; 1246 :     case '/':
; 1247 :         switch (c2) {

  00036	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  00039	75 26		 jne	 SHORT $LN16@PyToken_Th

; 1248 :         case '/':
; 1249 :             switch (c3) {

  0003b	41 83 f8 3d	 cmp	 r8d, 61			; 0000003dH

; 1252 :             }
; 1253 :             break;
; 1254 :         }
; 1255 :         break;

  0003f	75 20		 jne	 SHORT $LN16@PyToken_Th

; 1250 :             case '=':
; 1251 :                 return DOUBLESLASHEQUAL;

  00041	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 1268 : }

  00044	c3		 ret	 0
$LN7@PyToken_Th:

; 1256 :     case '.':
; 1257 :         switch (c2) {

  00045	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00048	75 17		 jne	 SHORT $LN16@PyToken_Th

; 1258 :         case '.':
; 1259 :             switch (c3) {

  0004a	44 3b c2	 cmp	 r8d, edx

; 1262 :             }
; 1263 :             break;
; 1264 :         }
; 1265 :         break;

  0004d	75 12		 jne	 SHORT $LN16@PyToken_Th

; 1260 :             case '.':
; 1261 :                 return ELLIPSIS;

  0004f	8d 42 05	 lea	 eax, QWORD PTR [rdx+5]

; 1268 : }

  00052	c3		 ret	 0
$LN21@PyToken_Th:

; 1236 :     case '*':
; 1237 :         switch (c2) {

  00053	83 fa 2a	 cmp	 edx, 42			; 0000002aH
  00056	75 09		 jne	 SHORT $LN16@PyToken_Th

; 1238 :         case '*':
; 1239 :             switch (c3) {
; 1240 :             case '=':
; 1241 :                 return DOUBLESTAREQUAL;

  00058	8d 42 04	 lea	 eax, QWORD PTR [rdx+4]
  0005b	41 83 f8 3d	 cmp	 r8d, 61			; 0000003dH
  0005f	74 05		 je	 SHORT $LN38@PyToken_Th
$LN16@PyToken_Th:

; 1266 :     }
; 1267 :     return OP;

  00061	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
$LN38@PyToken_Th:

; 1268 : }

  00066	f3 c3		 fatret	 0
PyToken_ThreeChars ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@ ; `string'
EXTRN	PySys_FormatStderr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$indenterror DD imagerel indenterror
	DD	imagerel indenterror+90
	DD	imagerel $unwind$indenterror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$indenterror DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@
CONST	SEGMENT
??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@ DB '%U: inc'
	DB	'onsistent use of tabs and spaces in indentation', 0aH, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT indenterror
_TEXT	SEGMENT
tok$ = 48
indenterror PROC					; COMDAT

; 1272 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1273 :     if (tok->alterror) {

  00006	83 b9 fc 01 00
	00 00		 cmp	 DWORD PTR [rcx+508], 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	74 1a		 je	 SHORT $LN2@indenterro

; 1274 :         tok->done = E_TABSPACE;
; 1275 :         tok->cur = tok->inp;

  00012	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00016	c7 41 28 12 00
	00 00		 mov	 DWORD PTR [rcx+40], 18
  0001d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1276 :         return 1;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 1289 : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN2@indenterro:

; 1277 :     }
; 1278 :     if (tok->altwarning) {

  0002c	83 b9 f8 01 00
	00 00		 cmp	 DWORD PTR [rcx+504], 0
  00033	74 1d		 je	 SHORT $LN1@indenterro

; 1279 : #ifdef PGEN
; 1280 :         PySys_WriteStderr("inconsistent use of tabs and spaces "
; 1281 :                           "in indentation\n");
; 1282 : #else
; 1283 :         PySys_FormatStderr("%U: inconsistent use of tabs and spaces "
; 1284 :                           "in indentation\n", tok->filename);

  00035	48 8b 91 f0 01
	00 00		 mov	 rdx, QWORD PTR [rcx+496]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@ILPEKIPF@?$CFU?3?5inconsistent?5use?5of?5tabs?5and@
  00043	e8 00 00 00 00	 call	 PySys_FormatStderr

; 1285 : #endif
; 1286 :         tok->altwarning = 0;

  00048	c7 83 f8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rbx+504], 0
$LN1@indenterro:

; 1287 :     }
; 1288 :     return 0;

  00052	33 c0		 xor	 eax, eax

; 1289 : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
indenterror ENDP
_TEXT	ENDS
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeDecodeError:QWORD
EXTRN	PyUnicode_IsIdentifier:PROC
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$verify_identifier DD imagerel verify_identifier
	DD	imagerel verify_identifier+62
	DD	imagerel $unwind$verify_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$verify_identifier DD imagerel verify_identifier+62
	DD	imagerel verify_identifier+111
	DD	imagerel $chain$0$verify_identifier
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$verify_identifier DD imagerel verify_identifier+111
	DD	imagerel verify_identifier+172
	DD	imagerel $chain$1$verify_identifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$verify_identifier DD 021H
	DD	imagerel verify_identifier
	DD	imagerel verify_identifier+62
	DD	imagerel $unwind$verify_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$verify_identifier DD 020521H
	DD	066405H
	DD	imagerel verify_identifier
	DD	imagerel verify_identifier+62
	DD	imagerel $unwind$verify_identifier
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$verify_identifier DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT verify_identifier
_TEXT	SEGMENT
tok$ = 48
verify_identifier PROC					; COMDAT

; 1299 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1300 :     PyObject *s;
; 1301 :     int result;
; 1302 :     s = PyUnicode_DecodeUTF8(tok->start, tok->cur - tok->start, NULL);

  0000d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00011	45 33 c0	 xor	 r8d, r8d
  00014	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00018	48 2b d1	 sub	 rdx, rcx
  0001b	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00020	48 8b f8	 mov	 rdi, rax

; 1303 :     if (s == NULL || PyUnicode_READY(s) == -1) {

  00023	48 85 c0	 test	 rax, rax
  00026	74 47		 je	 SHORT $LN4@verify_ide
  00028	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0002c	75 0d		 jne	 SHORT $LN10@verify_ide
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00036	83 f8 ff	 cmp	 eax, -1
  00039	74 34		 je	 SHORT $LN4@verify_ide
$LN10@verify_ide:

; 1311 :     }
; 1312 :     result = PyUnicode_IsIdentifier(s);

  0003b	48 8b cf	 mov	 rcx, rdi
  0003e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00043	e8 00 00 00 00	 call	 PyUnicode_IsIdentifier

; 1313 :     Py_DECREF(s);

  00048	48 8b cf	 mov	 rcx, rdi
  0004b	8b f0		 mov	 esi, eax
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 1314 :     if (result == 0)

  00052	85 f6		 test	 esi, esi
  00054	75 07		 jne	 SHORT $LN1@verify_ide

; 1315 :         tok->done = E_IDENTIFIER;

  00056	c7 43 28 1a 00
	00 00		 mov	 DWORD PTR [rbx+40], 26
$LN1@verify_ide:

; 1316 :     return result;

  0005d	8b c6		 mov	 eax, esi
  0005f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1317 : }

  00064	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN4@verify_ide:

; 1304 :         if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {

  0006f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeDecodeError
  00076	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0007b	85 c0		 test	 eax, eax
  0007d	74 19		 je	 SHORT $LN3@verify_ide

; 1305 :             PyErr_Clear();

  0007f	e8 00 00 00 00	 call	 PyErr_Clear

; 1306 :             tok->done = E_IDENTIFIER;

  00084	c7 43 28 1a 00
	00 00		 mov	 DWORD PTR [rbx+40], 26

; 1309 :         }
; 1310 :         return 0;

  0008b	33 c0		 xor	 eax, eax

; 1317 : }

  0008d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN3@verify_ide:

; 1307 :         } else {
; 1308 :             tok->done = E_ERROR;

  00098	c7 43 28 11 00
	00 00		 mov	 DWORD PTR [rbx+40], 17

; 1317 : }

  0009f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000a4	33 c0		 xor	 eax, eax
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
verify_identifier ENDP
_TEXT	ENDS
EXTRN	__imp_isxdigit:PROC
EXTRN	__imp_isdigit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tok_get DD imagerel tok_get
	DD	imagerel tok_get+2362
	DD	imagerel $unwind$tok_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tok_get DD 0a1e01H
	DD	0c341eH
	DD	0f01a321eH
	DD	0d016e018H
	DD	07012c014H
	DD	050106011H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT tok_get
_TEXT	SEGMENT
tok$ = 96
p_start$ = 104
p_end$ = 112
tok_get	PROC						; COMDAT

; 1324 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	55		 push	 rbp
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	41 57		 push	 r15
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1325 :     register int c;
; 1326 :     int blankline, nonascii;
; 1327 : 
; 1328 :     *p_start = *p_end = NULL;

  0001e	4c 8b 6c 24 68	 mov	 r13, QWORD PTR p_start$[rsp]
  00023	45 33 f6	 xor	 r14d, r14d
  00026	48 8b f9	 mov	 rdi, rcx
  00029	4d 89 30	 mov	 QWORD PTR [r8], r14
  0002c	4d 89 75 00	 mov	 QWORD PTR [r13], r14
  00030	45 8d 66 01	 lea	 r12d, QWORD PTR [r14+1]
  00034	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$nextline$21379:

; 1329 :   nextline:
; 1330 :     tok->start = NULL;

  00040	4c 89 77 20	 mov	 QWORD PTR [rdi+32], r14

; 1331 :     blankline = 0;

  00044	45 8b fe	 mov	 r15d, r14d

; 1332 : 
; 1333 :     /* Get indentation level */
; 1334 :     if (tok->atbol) {

  00047	44 39 b7 d0 01
	00 00		 cmp	 DWORD PTR [rdi+464], r14d
  0004e	0f 84 50 01 00
	00		 je	 $LN129@tok_get

; 1337 :         tok->atbol = 0;

  00054	44 89 b7 d0 01
	00 00		 mov	 DWORD PTR [rdi+464], r14d
$LN255@tok_get:

; 1335 :         register int col = 0;
; 1336 :         register int altcol = 0;

  0005b	41 8b ee	 mov	 ebp, r14d
  0005e	41 8b de	 mov	 ebx, r14d
$LL155@tok_get:

; 1338 :         for (;;) {
; 1339 :             c = tok_nextc(tok);

  00061	48 8b cf	 mov	 rcx, rdi
  00064	e8 00 00 00 00	 call	 tok_nextc
  00069	8b f0		 mov	 esi, eax

; 1340 :             if (c == ' ')

  0006b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0006e	75 06		 jne	 SHORT $LN153@tok_get

; 1341 :                 col++, altcol++;

  00070	ff c3		 inc	 ebx
  00072	ff c5		 inc	 ebp
  00074	eb eb		 jmp	 SHORT $LL155@tok_get
$LN153@tok_get:

; 1342 :             else if (c == '\t') {

  00076	83 f8 09	 cmp	 eax, 9
  00079	75 21		 jne	 SHORT $LN151@tok_get

; 1343 :                 col = (col/tok->tabsize + 1) * tok->tabsize;

  0007b	8b 4f 38	 mov	 ecx, DWORD PTR [rdi+56]
  0007e	8b c3		 mov	 eax, ebx
  00080	99		 cdq
  00081	f7 f9		 idiv	 ecx
  00083	8d 58 01	 lea	 ebx, DWORD PTR [rax+1]

; 1344 :                 altcol = (altcol/tok->alttabsize + 1)
; 1345 :                     * tok->alttabsize;

  00086	8b c5		 mov	 eax, ebp
  00088	99		 cdq
  00089	0f af d9	 imul	 ebx, ecx
  0008c	8b 8f 00 02 00
	00		 mov	 ecx, DWORD PTR [rdi+512]
  00092	f7 f9		 idiv	 ecx
  00094	8d 68 01	 lea	 ebp, DWORD PTR [rax+1]
  00097	0f af e9	 imul	 ebp, ecx
  0009a	eb c5		 jmp	 SHORT $LL155@tok_get
$LN151@tok_get:

; 1346 :             }
; 1347 :             else if (c == '\014') /* Control-L (formfeed) */

  0009c	83 f8 0c	 cmp	 eax, 12

; 1348 :                 col = altcol = 0; /* For Emacs users */
; 1349 :             else
; 1350 :                 break;
; 1351 :         }

  0009f	74 ba		 je	 SHORT $LN255@tok_get

; 1352 :         tok_backup(tok, c);

  000a1	8b d0		 mov	 edx, eax
  000a3	48 8b cf	 mov	 rcx, rdi
  000a6	e8 00 00 00 00	 call	 tok_backup

; 1353 :         if (c == '#' || c == '\n') {

  000ab	83 fe 23	 cmp	 esi, 35			; 00000023H
  000ae	74 05		 je	 SHORT $LN146@tok_get
  000b0	83 fe 0a	 cmp	 esi, 10
  000b3	75 1e		 jne	 SHORT $LN212@tok_get
$LN146@tok_get:

; 1354 :             /* Lines with only whitespace and/or comments
; 1355 :                shouldn't affect the indentation and are
; 1356 :                not passed to the parser as NEWLINE tokens,
; 1357 :                except *totally* empty lines in interactive
; 1358 :                mode, which signal the end of a command group. */
; 1359 :             if (col == 0 && c == '\n' && tok->prompt != NULL)

  000b5	85 db		 test	 ebx, ebx
  000b7	0f 85 e4 00 00
	00		 jne	 $LN145@tok_get
  000bd	83 fe 0a	 cmp	 esi, 10
  000c0	0f 85 db 00 00
	00		 jne	 $LN145@tok_get
  000c6	4c 39 b7 d8 01
	00 00		 cmp	 QWORD PTR [rdi+472], r14
  000cd	0f 84 ce 00 00
	00		 je	 $LN145@tok_get
$LN212@tok_get:

; 1363 :             /* We can't jump back right here since we still
; 1364 :                may need to skip to the end of a comment */
; 1365 :         }
; 1366 :         if (!blankline && tok->level == 0) {

  000d3	44 39 b7 ec 01
	00 00		 cmp	 DWORD PTR [rdi+492], r14d
  000da	0f 85 c4 00 00
	00		 jne	 $LN129@tok_get

; 1367 :             if (col == tok->indstack[tok->indent]) {

  000e0	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  000e4	48 8b c8	 mov	 rcx, rax
  000e7	8b 54 87 40	 mov	 edx, DWORD PTR [rdi+rax*4+64]
  000eb	3b da		 cmp	 ebx, edx
  000ed	75 22		 jne	 SHORT $LN256@tok_get
$LN259@tok_get:

; 1368 :                 /* No change */
; 1369 :                 if (altcol != tok->altindstack[tok->indent]) {

  000ef	3b ac 87 04 02
	00 00		 cmp	 ebp, DWORD PTR [rdi+rax*4+516]
  000f6	0f 84 a8 00 00
	00		 je	 $LN129@tok_get

; 1370 :                     if (indenterror(tok))

  000fc	48 8b cf	 mov	 rcx, rdi
  000ff	e8 00 00 00 00	 call	 indenterror
  00104	85 c0		 test	 eax, eax
  00106	0f 85 81 02 00
	00		 jne	 $LN188@tok_get

; 1371 :                         return ERRORTOKEN;
; 1372 :                 }

  0010c	e9 93 00 00 00	 jmp	 $LN129@tok_get
$LN256@tok_get:

; 1373 :             }
; 1374 :             else if (col > tok->indstack[tok->indent]) {

  00111	7e 42		 jle	 SHORT $LN165@tok_get

; 1375 :                 /* Indent -- always one */
; 1376 :                 if (tok->indent+1 >= MAXINDENT) {

  00113	ff c0		 inc	 eax
  00115	83 f8 64	 cmp	 eax, 100		; 00000064H
  00118	0f 8d 60 02 00
	00		 jge	 $LN189@tok_get

; 1380 :                 }
; 1381 :                 if (altcol <= tok->altindstack[tok->indent]) {

  0011e	3b ac 8f 04 02
	00 00		 cmp	 ebp, DWORD PTR [rdi+rcx*4+516]
  00125	7f 10		 jg	 SHORT $LN135@tok_get

; 1382 :                     if (indenterror(tok))

  00127	48 8b cf	 mov	 rcx, rdi
  0012a	e8 00 00 00 00	 call	 indenterror
  0012f	85 c0		 test	 eax, eax
  00131	0f 85 56 02 00
	00		 jne	 $LN188@tok_get
$LN135@tok_get:

; 1383 :                         return ERRORTOKEN;
; 1384 :                 }
; 1385 :                 tok->pendin++;

  00137	ff 87 d4 01 00
	00		 inc	 DWORD PTR [rdi+468]

; 1386 :                 tok->indstack[++tok->indent] = col;

  0013d	ff 47 3c	 inc	 DWORD PTR [rdi+60]
  00140	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00144	89 5c 87 40	 mov	 DWORD PTR [rdi+rax*4+64], ebx

; 1387 :                 tok->altindstack[tok->indent] = altcol;

  00148	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  0014c	89 ac 87 04 02
	00 00		 mov	 DWORD PTR [rdi+rax*4+516], ebp

; 1388 :             }
; 1389 :             else /* col < tok->indstack[tok->indent] */ {

  00153	eb 4f		 jmp	 SHORT $LN129@tok_get
$LN165@tok_get:

; 1390 :                 /* Dedent -- any number, must be consistent */
; 1391 :                 while (tok->indent > 0 &&
; 1392 :                     col < tok->indstack[tok->indent]) {

  00155	85 c0		 test	 eax, eax
  00157	7e 21		 jle	 SHORT $LN246@tok_get
  00159	0f 1f 80 00 00
	00 00		 npad	 7
$LL133@tok_get:
  00160	48 63 4f 3c	 movsxd	 rcx, DWORD PTR [rdi+60]
  00164	3b 5c 8f 40	 cmp	 ebx, DWORD PTR [rdi+rcx*4+64]
  00168	7d 10		 jge	 SHORT $LN246@tok_get

; 1393 :                     tok->pendin--;

  0016a	ff 8f d4 01 00
	00		 dec	 DWORD PTR [rdi+468]

; 1394 :                     tok->indent--;

  00170	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00173	89 47 3c	 mov	 DWORD PTR [rdi+60], eax
  00176	85 c0		 test	 eax, eax
  00178	7f e6		 jg	 SHORT $LL133@tok_get
$LN246@tok_get:

; 1395 :                 }
; 1396 :                 if (col != tok->indstack[tok->indent]) {

  0017a	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  0017e	3b 5c 87 40	 cmp	 ebx, DWORD PTR [rdi+rax*4+64]
  00182	0f 84 67 ff ff
	ff		 je	 $LN259@tok_get

; 1397 :                     tok->done = E_DEDENT;
; 1398 :                     tok->cur = tok->inp;

  00188	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0018c	c7 47 28 15 00
	00 00		 mov	 DWORD PTR [rdi+40], 21
  00193	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1399 :                     return ERRORTOKEN;

  00197	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  0019c	e9 1f 07 00 00	 jmp	 $LN157@tok_get
$LN145@tok_get:

; 1360 :                 blankline = 0; /* Let it through */
; 1361 :             else
; 1362 :                 blankline = 1; /* Ignore completely */

  001a1	45 8b fc	 mov	 r15d, r12d
$LN129@tok_get:

; 1400 :                 }
; 1401 :                 if (altcol != tok->altindstack[tok->indent]) {
; 1402 :                     if (indenterror(tok))
; 1403 :                         return ERRORTOKEN;
; 1404 :                 }
; 1405 :             }
; 1406 :         }
; 1407 :     }
; 1408 : 
; 1409 :     tok->start = tok->cur;

  001a4	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  001a8	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1410 : 
; 1411 :     /* Return pending indents/dedents */
; 1412 :     if (tok->pendin != 0) {

  001ac	44 39 b7 d4 01
	00 00		 cmp	 DWORD PTR [rdi+468], r14d
  001b3	0f 85 e1 06 00
	00		 jne	 $LN193@tok_get
  001b9	0f 1f 80 00 00
	00 00		 npad	 7
$again$21417:

; 1420 :         }
; 1421 :     }
; 1422 : 
; 1423 :  again:
; 1424 :     tok->start = NULL;

  001c0	4c 89 77 20	 mov	 QWORD PTR [rdi+32], r14
$LL125@tok_get:

; 1425 :     /* Skip spaces */
; 1426 :     do {
; 1427 :         c = tok_nextc(tok);

  001c4	48 8b cf	 mov	 rcx, rdi
  001c7	e8 00 00 00 00	 call	 tok_nextc
  001cc	8b d8		 mov	 ebx, eax

; 1428 :     } while (c == ' ' || c == '\t' || c == '\014');

  001ce	83 f8 20	 cmp	 eax, 32			; 00000020H
  001d1	74 f1		 je	 SHORT $LL125@tok_get
  001d3	83 f8 09	 cmp	 eax, 9
  001d6	74 ec		 je	 SHORT $LL125@tok_get
  001d8	83 f8 0c	 cmp	 eax, 12
  001db	74 e7		 je	 SHORT $LL125@tok_get

; 1429 : 
; 1430 :     /* Set start of current token */
; 1431 :     tok->start = tok->cur - 1;

  001dd	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  001e1	48 ff c9	 dec	 rcx
  001e4	48 89 4f 20	 mov	 QWORD PTR [rdi+32], rcx

; 1432 : 
; 1433 :     /* Skip comment */
; 1434 :     if (c == '#')

  001e8	83 f8 23	 cmp	 eax, 35			; 00000023H
  001eb	75 29		 jne	 SHORT $LN120@tok_get
  001ed	0f 1f 00	 npad	 3
$LL121@tok_get:

; 1435 :         while (c != EOF && c != '\n')

  001f0	83 fb 0a	 cmp	 ebx, 10
  001f3	74 21		 je	 SHORT $LN120@tok_get

; 1436 :             c = tok_nextc(tok);

  001f5	48 8b cf	 mov	 rcx, rdi
  001f8	e8 00 00 00 00	 call	 tok_nextc
  001fd	8b d8		 mov	 ebx, eax
  001ff	83 f8 ff	 cmp	 eax, -1
  00202	75 ec		 jne	 SHORT $LL121@tok_get
$LN182@tok_get:

; 1440 :         return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;

  00204	83 7f 28 0b	 cmp	 DWORD PTR [rdi+40], 11
  00208	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  0020d	41 0f 44 c6	 cmove	 eax, r14d
  00211	e9 aa 06 00 00	 jmp	 $LN157@tok_get
$LN120@tok_get:

; 1437 : 
; 1438 :     /* Check for EOF and errors now */
; 1439 :     if (c == EOF) {

  00216	83 fb ff	 cmp	 ebx, -1
  00219	74 e9		 je	 SHORT $LN182@tok_get

; 1441 :     }
; 1442 : 
; 1443 :     /* Identifier (most frequent token!) */
; 1444 :     nonascii = 0;
; 1445 :     if (is_potential_identifier_start(c)) {

  0021b	83 fb 61	 cmp	 ebx, 97			; 00000061H
  0021e	7c 05		 jl	 SHORT $LN116@tok_get
  00220	83 fb 7a	 cmp	 ebx, 122		; 0000007aH
  00223	7e 71		 jle	 SHORT $LN117@tok_get
$LN116@tok_get:
  00225	83 fb 41	 cmp	 ebx, 65			; 00000041H
  00228	7c 05		 jl	 SHORT $LN115@tok_get
  0022a	83 fb 5a	 cmp	 ebx, 90			; 0000005aH
  0022d	7e 67		 jle	 SHORT $LN117@tok_get
$LN115@tok_get:
  0022f	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00232	74 62		 je	 SHORT $LN117@tok_get
  00234	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0023a	7d 5a		 jge	 SHORT $LN117@tok_get

; 1478 :     }
; 1479 : 
; 1480 :     /* Newline */
; 1481 :     if (c == '\n') {

  0023c	83 fb 0a	 cmp	 ebx, 10
  0023f	0f 84 f1 00 00
	00		 je	 $LN183@tok_get

; 1489 :     }
; 1490 : 
; 1491 :     /* Period or number starting with period? */
; 1492 :     if (c == '.') {

  00245	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00248	0f 84 b8 03 00
	00		 je	 $LN184@tok_get

; 1512 :     }
; 1513 : 
; 1514 :     /* Number */
; 1515 :     if (isdigit(c)) {

  0024e	8b cb		 mov	 ecx, ebx
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00256	85 c0		 test	 eax, eax
  00258	0f 85 39 01 00
	00		 jne	 $LN185@tok_get
$letter_quote$21448:

; 1622 :     }
; 1623 : 
; 1624 :   letter_quote:
; 1625 :     /* String */
; 1626 :     if (c == '\'' || c == '"') {

  0025e	83 fb 27	 cmp	 ebx, 39			; 00000027H
  00261	0f 84 a1 00 00
	00		 je	 $LN23@tok_get
  00267	83 fb 22	 cmp	 ebx, 34			; 00000022H
  0026a	0f 84 98 00 00
	00		 je	 $LN23@tok_get

; 1671 :     }
; 1672 : 
; 1673 :     /* Line continuation */
; 1674 :     if (c == '\\') {
; 1675 :         c = tok_nextc(tok);

  00270	48 8b cf	 mov	 rcx, rdi
  00273	e8 00 00 00 00	 call	 tok_nextc
  00278	83 fb 5c	 cmp	 ebx, 92			; 0000005cH
  0027b	0f 85 26 04 00
	00		 jne	 $LN9@tok_get

; 1676 :         if (c != '\n') {

  00281	83 f8 0a	 cmp	 eax, 10
  00284	0f 85 04 04 00
	00		 jne	 $LN187@tok_get

; 1680 :         }
; 1681 :         tok->cont_line = 1;

  0028a	44 89 a7 a8 03
	00 00		 mov	 DWORD PTR [rdi+936], r12d

; 1682 :         goto again; /* Read next line */

  00291	e9 2a ff ff ff	 jmp	 $again$21417
$LN117@tok_get:

; 1446 :         /* Process b"", r"", u"", br"" and rb"" */
; 1447 :         int saw_b = 0, saw_r = 0, saw_u = 0;

  00296	45 8b ee	 mov	 r13d, r14d
  00299	41 8b f6	 mov	 esi, r14d
  0029c	41 8b ee	 mov	 ebp, r14d
  0029f	90		 npad	 1
$LL114@tok_get:

; 1448 :         while (1) {
; 1449 :             if (!(saw_b || saw_u) && (c == 'b' || c == 'B'))

  002a0	45 85 ed	 test	 r13d, r13d
  002a3	75 2a		 jne	 SHORT $LN109@tok_get
  002a5	85 ed		 test	 ebp, ebp
  002a7	75 26		 jne	 SHORT $LN109@tok_get
  002a9	83 fb 62	 cmp	 ebx, 98			; 00000062H
  002ac	74 1c		 je	 SHORT $LN111@tok_get
  002ae	83 fb 42	 cmp	 ebx, 66			; 00000042H
  002b1	74 17		 je	 SHORT $LN111@tok_get

; 1451 :             /* Since this is a backwards compatibility support literal we don't
; 1452 :                want to support it in arbitrary order like byte literals. */
; 1453 :             else if (!(saw_b || saw_u || saw_r) && (c == 'u' || c == 'U'))

  002b3	85 f6		 test	 esi, esi
  002b5	0f 85 57 05 00
	00		 jne	 $LL101@tok_get
  002bb	83 fb 75	 cmp	 ebx, 117		; 00000075H
  002be	74 05		 je	 SHORT $LN108@tok_get
  002c0	83 fb 55	 cmp	 ebx, 85			; 00000055H
  002c3	75 1a		 jne	 SHORT $LN216@tok_get
$LN108@tok_get:

; 1454 :                 saw_u = 1;

  002c5	41 8b ec	 mov	 ebp, r12d
  002c8	eb 26		 jmp	 SHORT $LN104@tok_get
$LN111@tok_get:

; 1450 :                 saw_b = 1;

  002ca	45 8b ec	 mov	 r13d, r12d
  002cd	eb 21		 jmp	 SHORT $LN104@tok_get
$LN109@tok_get:

; 1455 :             /* ur"" and ru"" are not supported */
; 1456 :             else if (!(saw_r || saw_u) && (c == 'r' || c == 'R'))

  002cf	85 f6		 test	 esi, esi
  002d1	0f 85 3b 05 00
	00		 jne	 $LL101@tok_get
  002d7	85 ed		 test	 ebp, ebp
  002d9	0f 85 33 05 00
	00		 jne	 $LL101@tok_get
$LN216@tok_get:
  002df	83 fb 72	 cmp	 ebx, 114		; 00000072H
  002e2	74 09		 je	 SHORT $LN105@tok_get
  002e4	83 fb 52	 cmp	 ebx, 82			; 00000052H
  002e7	0f 85 25 05 00
	00		 jne	 $LL101@tok_get
$LN105@tok_get:

; 1457 :                 saw_r = 1;

  002ed	41 8b f4	 mov	 esi, r12d
$LN104@tok_get:

; 1458 :             else
; 1459 :                 break;
; 1460 :             c = tok_nextc(tok);

  002f0	48 8b cf	 mov	 rcx, rdi
  002f3	e8 00 00 00 00	 call	 tok_nextc
  002f8	8b d8		 mov	 ebx, eax

; 1461 :             if (c == '"' || c == '\'')

  002fa	83 f8 22	 cmp	 eax, 34			; 00000022H
  002fd	0f 84 5b ff ff
	ff		 je	 $letter_quote$21448
  00303	83 f8 27	 cmp	 eax, 39			; 00000027H
  00306	75 98		 jne	 SHORT $LL114@tok_get
$LN23@tok_get:

; 1627 :         int quote = c;
; 1628 :         int quote_size = 1;             /* 1 or 3 */
; 1629 :         int end_quote_size = 0;
; 1630 : 
; 1631 :         /* Find the quote size and start of string */
; 1632 :         c = tok_nextc(tok);

  00308	48 8b cf	 mov	 rcx, rdi
  0030b	41 8b f6	 mov	 esi, r14d
  0030e	e8 00 00 00 00	 call	 tok_nextc

; 1633 :         if (c == quote) {

  00313	3b c3		 cmp	 eax, ebx
  00315	0f 85 4d 04 00
	00		 jne	 $LN201@tok_get

; 1634 :             c = tok_nextc(tok);

  0031b	48 8b cf	 mov	 rcx, rdi
  0031e	e8 00 00 00 00	 call	 tok_nextc

; 1635 :             if (c == quote)

  00323	3b c3		 cmp	 eax, ebx
  00325	0f 85 36 04 00
	00		 jne	 $LN21@tok_get

; 1636 :                 quote_size = 3;

  0032b	41 bc 03 00 00
	00		 mov	 r12d, 3

; 1637 :             else

  00331	e9 2e 04 00 00	 jmp	 $LN20@tok_get
$LN183@tok_get:

; 1482 :         tok->atbol = 1;

  00336	44 89 a7 d0 01
	00 00		 mov	 DWORD PTR [rdi+464], r12d

; 1483 :         if (blankline || tok->level > 0)

  0033d	45 85 ff	 test	 r15d, r15d
  00340	0f 85 fa fc ff
	ff		 jne	 $nextline$21379
  00346	44 39 b7 ec 01
	00 00		 cmp	 DWORD PTR [rdi+492], r14d
  0034d	0f 8f ed fc ff
	ff		 jg	 $nextline$21379

; 1484 :             goto nextline;
; 1485 :         *p_start = tok->start;

  00353	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00357	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]
  0035c	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1486 :         *p_end = tok->cur - 1; /* Leave '\n' out of the string */

  0035f	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00363	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  00368	48 ff c8	 dec	 rax
  0036b	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1487 :         tok->cont_line = 0;

  0036e	44 89 b7 a8 03
	00 00		 mov	 DWORD PTR [rdi+936], r14d

; 1488 :         return NEWLINE;

  00375	41 8d 47 04	 lea	 eax, QWORD PTR [r15+4]
  00379	e9 42 05 00 00	 jmp	 $LN157@tok_get
$LN189@tok_get:

; 1377 :                     tok->done = E_TOODEEP;
; 1378 :                     tok->cur = tok->inp;

  0037e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00382	c7 47 28 14 00
	00 00		 mov	 DWORD PTR [rdi+40], 20
  00389	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN188@tok_get:

; 1379 :                     return ERRORTOKEN;

  0038d	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00392	e9 29 05 00 00	 jmp	 $LN157@tok_get
$LN185@tok_get:

; 1516 :         if (c == '0') {

  00397	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0039a	0f 85 a0 01 00
	00		 jne	 $LL41@tok_get

; 1517 :             /* Hex, octal or binary -- maybe. */
; 1518 :             c = tok_nextc(tok);

  003a0	48 8b cf	 mov	 rcx, rdi
  003a3	e8 00 00 00 00	 call	 tok_nextc
  003a8	8b d8		 mov	 ebx, eax

; 1519 :             if (c == '.')

  003aa	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  003ad	0f 84 ad 01 00
	00		 je	 $fraction$21463

; 1520 :                 goto fraction;
; 1521 :             if (c == 'j' || c == 'J')

  003b3	83 f8 6a	 cmp	 eax, 106		; 0000006aH
  003b6	0f 84 14 02 00
	00		 je	 $imaginary$21474
  003bc	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  003bf	0f 84 0b 02 00
	00		 je	 $imaginary$21474

; 1522 :                 goto imaginary;
; 1523 :             if (c == 'x' || c == 'X') {

  003c5	83 f8 78	 cmp	 eax, 120		; 00000078H
  003c8	0f 84 3a 01 00
	00		 je	 $LN77@tok_get
  003ce	83 f8 58	 cmp	 eax, 88			; 00000058H
  003d1	0f 84 31 01 00
	00		 je	 $LN77@tok_get

; 1535 :             }
; 1536 :             else if (c == 'o' || c == 'O') {

  003d7	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  003da	0f 84 d9 00 00
	00		 je	 $LN70@tok_get
  003e0	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  003e3	0f 84 d0 00 00
	00		 je	 $LN70@tok_get

; 1547 :             }
; 1548 :             else if (c == 'b' || c == 'B') {

  003e9	83 f8 62	 cmp	 eax, 98			; 00000062H
  003ec	0f 84 95 00 00
	00		 je	 $LN61@tok_get
  003f2	83 f8 42	 cmp	 eax, 66			; 00000042H
  003f5	0f 84 8c 00 00
	00		 je	 $LN61@tok_get

; 1561 :                 int nonzero = 0;
; 1562 :                 /* maybe old-style octal; c is first char of it */
; 1563 :                 /* in any case, allow '0' as a literal */
; 1564 :                 while (c == '0')

  003fb	83 f8 30	 cmp	 eax, 48			; 00000030H
  003fe	75 0f		 jne	 SHORT $LN170@tok_get
$LL55@tok_get:

; 1565 :                     c = tok_nextc(tok);

  00400	48 8b cf	 mov	 rcx, rdi
  00403	e8 00 00 00 00	 call	 tok_nextc
  00408	8b d8		 mov	 ebx, eax
  0040a	83 f8 30	 cmp	 eax, 48			; 00000030H
  0040d	74 f1		 je	 SHORT $LL55@tok_get
$LN170@tok_get:

; 1566 :                 while (isdigit(c)) {

  0040f	8b cb		 mov	 ecx, ebx
  00411	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00417	85 c0		 test	 eax, eax
  00419	74 1b		 je	 SHORT $LN52@tok_get

; 1567 :                     nonzero = 1;

  0041b	45 8b f4	 mov	 r14d, r12d
  0041e	66 90		 npad	 2
$LL53@tok_get:

; 1568 :                     c = tok_nextc(tok);

  00420	48 8b cf	 mov	 rcx, rdi
  00423	e8 00 00 00 00	 call	 tok_nextc
  00428	8b c8		 mov	 ecx, eax
  0042a	8b d8		 mov	 ebx, eax
  0042c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00432	85 c0		 test	 eax, eax
  00434	75 ea		 jne	 SHORT $LL53@tok_get
$LN52@tok_get:

; 1569 :                 }
; 1570 :                 if (c == '.')

  00436	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00439	0f 84 21 01 00
	00		 je	 $fraction$21463

; 1571 :                     goto fraction;
; 1572 :                 else if (c == 'e' || c == 'E')

  0043f	83 fb 65	 cmp	 ebx, 101		; 00000065H
  00442	0f 84 38 01 00
	00		 je	 $exponent$21509
  00448	83 fb 45	 cmp	 ebx, 69			; 00000045H
  0044b	0f 84 2f 01 00
	00		 je	 $exponent$21509

; 1573 :                     goto exponent;
; 1574 :                 else if (c == 'j' || c == 'J')

  00451	83 fb 6a	 cmp	 ebx, 106		; 0000006aH
  00454	0f 84 76 01 00
	00		 je	 $imaginary$21474
  0045a	83 fb 4a	 cmp	 ebx, 74			; 0000004aH
  0045d	0f 84 6d 01 00
	00		 je	 $imaginary$21474

; 1575 :                     goto imaginary;
; 1576 :                 else if (nonzero) {

  00463	45 85 f6	 test	 r14d, r14d
  00466	0f 84 6e 01 00
	00		 je	 $LN26@tok_get
$LN258@tok_get:

; 1577 :                     tok->done = E_TOKEN;
; 1578 :                     tok_backup(tok, c);

  0046c	8b d3		 mov	 edx, ebx
  0046e	48 8b cf	 mov	 rcx, rdi
  00471	c7 47 28 0d 00
	00 00		 mov	 DWORD PTR [rdi+40], 13
  00478	e8 00 00 00 00	 call	 tok_backup

; 1579 :                     return ERRORTOKEN;

  0047d	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00482	e9 39 04 00 00	 jmp	 $LN157@tok_get
$LN61@tok_get:

; 1549 :                 /* Binary */
; 1550 :                 c = tok_nextc(tok);

  00487	48 8b cf	 mov	 rcx, rdi
  0048a	e8 00 00 00 00	 call	 tok_nextc

; 1551 :                 if (c != '0' && c != '1') {

  0048f	83 f8 30	 cmp	 eax, 48			; 00000030H
  00492	74 0c		 je	 SHORT $LL59@tok_get
  00494	83 f8 31	 cmp	 eax, 49			; 00000031H

; 1552 :                     tok->done = E_TOKEN;
; 1553 :                     tok_backup(tok, c);
; 1554 :                     return ERRORTOKEN;

  00497	75 54		 jne	 SHORT $LN68@tok_get
  00499	0f 1f 80 00 00
	00 00		 npad	 7
$LL59@tok_get:

; 1555 :                 }
; 1556 :                 do {
; 1557 :                     c = tok_nextc(tok);

  004a0	48 8b cf	 mov	 rcx, rdi
  004a3	e8 00 00 00 00	 call	 tok_nextc
  004a8	8b d8		 mov	 ebx, eax

; 1558 :                 } while (c == '0' || c == '1');

  004aa	83 f8 30	 cmp	 eax, 48			; 00000030H
  004ad	74 f1		 je	 SHORT $LL59@tok_get
  004af	83 f8 31	 cmp	 eax, 49			; 00000031H
  004b2	74 ec		 je	 SHORT $LL59@tok_get

; 1559 :             }
; 1560 :             else {

  004b4	e9 21 01 00 00	 jmp	 $LN26@tok_get
$LN70@tok_get:

; 1537 :                 /* Octal */
; 1538 :                 c = tok_nextc(tok);

  004b9	48 8b cf	 mov	 rcx, rdi
  004bc	e8 00 00 00 00	 call	 tok_nextc

; 1539 :                 if (c < '0' || c >= '8') {

  004c1	8d 48 d0	 lea	 ecx, DWORD PTR [rax-48]
  004c4	83 f9 07	 cmp	 ecx, 7
  004c7	77 24		 ja	 SHORT $LN68@tok_get
  004c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL67@tok_get:

; 1543 :                 }
; 1544 :                 do {
; 1545 :                     c = tok_nextc(tok);

  004d0	48 8b cf	 mov	 rcx, rdi
  004d3	e8 00 00 00 00	 call	 tok_nextc
  004d8	8b d8		 mov	 ebx, eax

; 1546 :                 } while ('0' <= c && c < '8');

  004da	83 f8 30	 cmp	 eax, 48			; 00000030H
  004dd	0f 8c f7 00 00
	00		 jl	 $LN26@tok_get
  004e3	83 f8 38	 cmp	 eax, 56			; 00000038H
  004e6	7c e8		 jl	 SHORT $LL67@tok_get

; 1547 :             }
; 1548 :             else if (c == 'b' || c == 'B') {

  004e8	e9 ed 00 00 00	 jmp	 $LN26@tok_get
$LN68@tok_get:

; 1540 :                     tok->done = E_TOKEN;
; 1541 :                     tok_backup(tok, c);

  004ed	8b d0		 mov	 edx, eax
  004ef	48 8b cf	 mov	 rcx, rdi
  004f2	c7 47 28 0d 00
	00 00		 mov	 DWORD PTR [rdi+40], 13
  004f9	e8 00 00 00 00	 call	 tok_backup

; 1542 :                     return ERRORTOKEN;

  004fe	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00503	e9 b8 03 00 00	 jmp	 $LN157@tok_get
$LN77@tok_get:

; 1524 : 
; 1525 :                 /* Hex */
; 1526 :                 c = tok_nextc(tok);

  00508	48 8b cf	 mov	 rcx, rdi
  0050b	e8 00 00 00 00	 call	 tok_nextc

; 1527 :                 if (!isxdigit(c)) {

  00510	8b c8		 mov	 ecx, eax
  00512	8b d8		 mov	 ebx, eax
  00514	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  0051a	85 c0		 test	 eax, eax

; 1528 :                     tok->done = E_TOKEN;
; 1529 :                     tok_backup(tok, c);
; 1530 :                     return ERRORTOKEN;

  0051c	0f 84 4a ff ff
	ff		 je	 $LN258@tok_get
$LL75@tok_get:

; 1531 :                 }
; 1532 :                 do {
; 1533 :                     c = tok_nextc(tok);

  00522	48 8b cf	 mov	 rcx, rdi
  00525	e8 00 00 00 00	 call	 tok_nextc

; 1534 :                 } while (isxdigit(c));

  0052a	8b c8		 mov	 ecx, eax
  0052c	8b d8		 mov	 ebx, eax
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  00534	85 c0		 test	 eax, eax
  00536	75 ea		 jne	 SHORT $LL75@tok_get

; 1580 :                 }
; 1581 :             }
; 1582 :         }
; 1583 :         else {

  00538	e9 9d 00 00 00	 jmp	 $LN26@tok_get
  0053d	0f 1f 00	 npad	 3
$LL41@tok_get:

; 1584 :             /* Decimal */
; 1585 :             do {
; 1586 :                 c = tok_nextc(tok);

  00540	48 8b cf	 mov	 rcx, rdi
  00543	e8 00 00 00 00	 call	 tok_nextc

; 1587 :             } while (isdigit(c));

  00548	8b c8		 mov	 ecx, eax
  0054a	8b d8		 mov	 ebx, eax
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00552	85 c0		 test	 eax, eax
  00554	75 ea		 jne	 SHORT $LL41@tok_get

; 1588 :             {
; 1589 :                 /* Accept floating point numbers. */
; 1590 :                 if (c == '.') {

  00556	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00559	75 1b		 jne	 SHORT $LN35@tok_get
  0055b	0f 1f 44 00 00	 npad	 5
$fraction$21463:

; 1591 :         fraction:
; 1592 :                     /* Fraction */
; 1593 :                     do {
; 1594 :                         c = tok_nextc(tok);

  00560	48 8b cf	 mov	 rcx, rdi
  00563	e8 00 00 00 00	 call	 tok_nextc

; 1595 :                     } while (isdigit(c));

  00568	8b c8		 mov	 ecx, eax
  0056a	8b d8		 mov	 ebx, eax
  0056c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00572	85 c0		 test	 eax, eax
  00574	75 ea		 jne	 SHORT $fraction$21463
$LN35@tok_get:

; 1596 :                 }
; 1597 :                 if (c == 'e' || c == 'E') {

  00576	83 fb 65	 cmp	 ebx, 101		; 00000065H
  00579	74 05		 je	 SHORT $exponent$21509
  0057b	83 fb 45	 cmp	 ebx, 69			; 00000045H
  0057e	75 46		 jne	 SHORT $LN27@tok_get
$exponent$21509:

; 1598 :         exponent:
; 1599 :                     /* Exponent part */
; 1600 :                     c = tok_nextc(tok);

  00580	48 8b cf	 mov	 rcx, rdi
  00583	e8 00 00 00 00	 call	 tok_nextc
  00588	8b d8		 mov	 ebx, eax

; 1601 :                     if (c == '+' || c == '-')

  0058a	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0058d	74 05		 je	 SHORT $LN31@tok_get
  0058f	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00592	75 0a		 jne	 SHORT $LN32@tok_get
$LN31@tok_get:

; 1602 :                         c = tok_nextc(tok);

  00594	48 8b cf	 mov	 rcx, rdi
  00597	e8 00 00 00 00	 call	 tok_nextc
  0059c	8b d8		 mov	 ebx, eax
$LN32@tok_get:

; 1603 :                     if (!isdigit(c)) {

  0059e	8b cb		 mov	 ecx, ebx
  005a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  005a6	85 c0		 test	 eax, eax

; 1604 :                         tok->done = E_TOKEN;
; 1605 :                         tok_backup(tok, c);
; 1606 :                         return ERRORTOKEN;

  005a8	0f 84 be fe ff
	ff		 je	 $LN258@tok_get
  005ae	66 90		 npad	 2
$LL29@tok_get:

; 1607 :                     }
; 1608 :                     do {
; 1609 :                         c = tok_nextc(tok);

  005b0	48 8b cf	 mov	 rcx, rdi
  005b3	e8 00 00 00 00	 call	 tok_nextc

; 1610 :                     } while (isdigit(c));

  005b8	8b c8		 mov	 ecx, eax
  005ba	8b d8		 mov	 ebx, eax
  005bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  005c2	85 c0		 test	 eax, eax
  005c4	75 ea		 jne	 SHORT $LL29@tok_get
$LN27@tok_get:

; 1611 :                 }
; 1612 :                 if (c == 'j' || c == 'J')

  005c6	83 fb 6a	 cmp	 ebx, 106		; 0000006aH
  005c9	74 05		 je	 SHORT $imaginary$21474
  005cb	83 fb 4a	 cmp	 ebx, 74			; 0000004aH
  005ce	75 0a		 jne	 SHORT $LN26@tok_get
$imaginary$21474:

; 1613 :                     /* Imaginary part */
; 1614 :         imaginary:
; 1615 :                     c = tok_nextc(tok);

  005d0	48 8b cf	 mov	 rcx, rdi
  005d3	e8 00 00 00 00	 call	 tok_nextc
  005d8	8b d8		 mov	 ebx, eax
$LN26@tok_get:

; 1616 :             }
; 1617 :         }
; 1618 :         tok_backup(tok, c);

  005da	8b d3		 mov	 edx, ebx
  005dc	48 8b cf	 mov	 rcx, rdi
  005df	e8 00 00 00 00	 call	 tok_backup

; 1619 :         *p_start = tok->start;

  005e4	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]
  005e9	4c 8b 5f 20	 mov	 r11, QWORD PTR [rdi+32]
  005ed	4c 89 1a	 mov	 QWORD PTR [rdx], r11

; 1620 :         *p_end = tok->cur;

  005f0	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  005f4	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  005f9	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1621 :         return NUMBER;

  005fc	b8 02 00 00 00	 mov	 eax, 2
  00601	e9 ba 02 00 00	 jmp	 $LN157@tok_get
$LN184@tok_get:

; 1493 :         c = tok_nextc(tok);

  00606	48 8b cf	 mov	 rcx, rdi
  00609	e8 00 00 00 00	 call	 tok_nextc

; 1494 :         if (isdigit(c)) {

  0060e	8b c8		 mov	 ecx, eax
  00610	8b d8		 mov	 ebx, eax
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00618	85 c0		 test	 eax, eax
  0061a	0f 85 40 ff ff
	ff		 jne	 $fraction$21463

; 1495 :             goto fraction;
; 1496 :         } else if (c == '.') {
; 1497 :             c = tok_nextc(tok);

  00620	48 8b cf	 mov	 rcx, rdi
  00623	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00626	75 3d		 jne	 SHORT $LN87@tok_get
  00628	e8 00 00 00 00	 call	 tok_nextc

; 1498 :             if (c == '.') {

  0062d	3b c3		 cmp	 eax, ebx
  0062f	75 20		 jne	 SHORT $LN86@tok_get

; 1499 :                 *p_start = tok->start;

  00631	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00635	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]
  0063a	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1500 :                 *p_end = tok->cur;

  0063d	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00641	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  00646	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1501 :                 return ELLIPSIS;

  00649	8d 43 05	 lea	 eax, QWORD PTR [rbx+5]
  0064c	e9 6f 02 00 00	 jmp	 $LN157@tok_get
$LN86@tok_get:

; 1502 :             } else {
; 1503 :                 tok_backup(tok, c);

  00651	8b d0		 mov	 edx, eax
  00653	48 8b cf	 mov	 rcx, rdi
  00656	e8 00 00 00 00	 call	 tok_backup

; 1504 :             }
; 1505 :             tok_backup(tok, '.');

  0065b	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00660	48 8b cf	 mov	 rcx, rdi

; 1506 :         } else {

  00663	eb 02		 jmp	 SHORT $LN257@tok_get
$LN87@tok_get:

; 1507 :             tok_backup(tok, c);

  00665	8b d3		 mov	 edx, ebx
$LN257@tok_get:
  00667	e8 00 00 00 00	 call	 tok_backup

; 1508 :         }
; 1509 :         *p_start = tok->start;

  0066c	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00670	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]
  00675	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1510 :         *p_end = tok->cur;

  00678	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0067c	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  00681	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1511 :         return DOT;

  00684	b8 17 00 00 00	 mov	 eax, 23
  00689	e9 32 02 00 00	 jmp	 $LN157@tok_get
$LN187@tok_get:

; 1677 :             tok->done = E_LINECONT;
; 1678 :             tok->cur = tok->inp;

  0068e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00692	c7 47 28 19 00
	00 00		 mov	 DWORD PTR [rdi+40], 25
  00699	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1679 :             return ERRORTOKEN;

  0069d	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  006a2	e9 19 02 00 00	 jmp	 $LN157@tok_get
$LN9@tok_get:

; 1683 :     }
; 1684 : 
; 1685 :     /* Check for two-character token */
; 1686 :     {
; 1687 :         int c2 = tok_nextc(tok);
; 1688 :         int token = PyToken_TwoChars(c, c2);

  006a7	8b d0		 mov	 edx, eax
  006a9	8b cb		 mov	 ecx, ebx
  006ab	8b e8		 mov	 ebp, eax
  006ad	e8 00 00 00 00	 call	 PyToken_TwoChars

; 1689 :         if (token != OP) {
; 1690 :             int c3 = tok_nextc(tok);

  006b2	48 8b cf	 mov	 rcx, rdi
  006b5	8b f0		 mov	 esi, eax
  006b7	83 f8 34	 cmp	 eax, 52			; 00000034H
  006ba	74 44		 je	 SHORT $LN7@tok_get
  006bc	e8 00 00 00 00	 call	 tok_nextc

; 1691 :             int token3 = PyToken_ThreeChars(c, c2, c3);

  006c1	8b d5		 mov	 edx, ebp
  006c3	8b cb		 mov	 ecx, ebx
  006c5	44 8b c0	 mov	 r8d, eax
  006c8	e8 00 00 00 00	 call	 PyToken_ThreeChars

; 1692 :             if (token3 != OP) {

  006cd	83 f8 34	 cmp	 eax, 52			; 00000034H
  006d0	74 04		 je	 SHORT $LN6@tok_get

; 1693 :                 token = token3;

  006d2	8b f0		 mov	 esi, eax

; 1694 :             } else {

  006d4	eb 0b		 jmp	 SHORT $LN5@tok_get
$LN6@tok_get:

; 1695 :                 tok_backup(tok, c3);

  006d6	41 8b d0	 mov	 edx, r8d
  006d9	48 8b cf	 mov	 rcx, rdi
  006dc	e8 00 00 00 00	 call	 tok_backup
$LN5@tok_get:

; 1696 :             }
; 1697 :             *p_start = tok->start;

  006e1	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  006e5	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]
  006ea	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1698 :             *p_end = tok->cur;

  006ed	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  006f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  006f6	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1699 :             return token;

  006f9	8b c6		 mov	 eax, esi
  006fb	e9 c0 01 00 00	 jmp	 $LN157@tok_get
$LN7@tok_get:

; 1700 :         }
; 1701 :         tok_backup(tok, c2);

  00700	8b d5		 mov	 edx, ebp
  00702	e8 00 00 00 00	 call	 tok_backup

; 1702 :     }
; 1703 : 
; 1704 :     /* Keep track of parentheses nesting level */
; 1705 :     switch (c) {

  00707	44 8d 5b d8	 lea	 r11d, DWORD PTR [rbx-40]
  0070b	41 83 fb 55	 cmp	 r11d, 85		; 00000055H
  0070f	77 2c		 ja	 SHORT $LN3@tok_get
  00711	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00718	49 63 c3	 movsxd	 rax, r11d
  0071b	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN225@tok_get[rdx+rax]
  00723	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN226@tok_get[rdx+rax*4]
  0072a	48 03 ca	 add	 rcx, rdx
  0072d	ff e1		 jmp	 rcx
$LN2@tok_get:

; 1706 :     case '(':
; 1707 :     case '[':
; 1708 :     case '{':
; 1709 :         tok->level++;

  0072f	ff 87 ec 01 00
	00		 inc	 DWORD PTR [rdi+492]

; 1710 :         break;

  00735	eb 06		 jmp	 SHORT $LN3@tok_get
$LN1@tok_get:

; 1711 :     case ')':
; 1712 :     case ']':
; 1713 :     case '}':
; 1714 :         tok->level--;

  00737	ff 8f ec 01 00
	00		 dec	 DWORD PTR [rdi+492]
$LN3@tok_get:

; 1715 :         break;
; 1716 :     }
; 1717 : 
; 1718 :     /* Punctuation character */
; 1719 :     *p_start = tok->start;

  0073d	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00741	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]

; 1720 :     *p_end = tok->cur;
; 1721 :     return PyToken_OneChar(c);

  00746	8b cb		 mov	 ecx, ebx
  00748	48 89 02	 mov	 QWORD PTR [rdx], rax
  0074b	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  00750	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00754	48 89 02	 mov	 QWORD PTR [rdx], rax
  00757	e8 00 00 00 00	 call	 PyToken_OneChar
  0075c	e9 5f 01 00 00	 jmp	 $LN157@tok_get
$LN21@tok_get:

; 1638 :                 end_quote_size = 1;     /* empty string found */

  00761	41 8b f4	 mov	 esi, r12d
$LN20@tok_get:

; 1639 :         }
; 1640 :         if (c != quote)

  00764	3b c3		 cmp	 eax, ebx
  00766	74 0a		 je	 SHORT $LN178@tok_get
$LN201@tok_get:

; 1641 :             tok_backup(tok, c);

  00768	8b d0		 mov	 edx, eax
  0076a	48 8b cf	 mov	 rcx, rdi
  0076d	e8 00 00 00 00	 call	 tok_backup
$LN178@tok_get:

; 1653 :             }
; 1654 :             if (quote_size == 1 && c == '\n') {

  00772	49 63 ec	 movsxd	 rbp, r12d
  00775	41 3b f4	 cmp	 esi, r12d
  00778	74 3b		 je	 SHORT $LN17@tok_get
  0077a	66 0f 1f 44 00
	00		 npad	 6
$LL18@tok_get:

; 1645 :             c = tok_nextc(tok);

  00780	48 8b cf	 mov	 rcx, rdi
  00783	e8 00 00 00 00	 call	 tok_nextc

; 1646 :             if (c == EOF) {

  00788	83 f8 ff	 cmp	 eax, -1
  0078b	74 63		 je	 SHORT $LN194@tok_get

; 1653 :             }
; 1654 :             if (quote_size == 1 && c == '\n') {

  0078d	48 83 fd 01	 cmp	 rbp, 1
  00791	75 05		 jne	 SHORT $LN13@tok_get
  00793	83 f8 0a	 cmp	 eax, 10
  00796	74 3f		 je	 SHORT $LN195@tok_get
$LN13@tok_get:

; 1658 :             }
; 1659 :             if (c == quote)

  00798	3b c3		 cmp	 eax, ebx
  0079a	75 04		 jne	 SHORT $LN12@tok_get

; 1660 :                 end_quote_size += 1;

  0079c	ff c6		 inc	 esi

; 1661 :             else {

  0079e	eb 10		 jmp	 SHORT $LN10@tok_get
$LN12@tok_get:

; 1662 :                 end_quote_size = 0;

  007a0	41 8b f6	 mov	 esi, r14d

; 1663 :                 if (c == '\\')

  007a3	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  007a6	75 08		 jne	 SHORT $LN10@tok_get

; 1664 :                 c = tok_nextc(tok);  /* skip escaped char */

  007a8	48 8b cf	 mov	 rcx, rdi
  007ab	e8 00 00 00 00	 call	 tok_nextc
$LN10@tok_get:

; 1642 : 
; 1643 :         /* Get rest of string */
; 1644 :         while (end_quote_size != quote_size) {

  007b0	41 3b f4	 cmp	 esi, r12d
  007b3	75 cb		 jne	 SHORT $LL18@tok_get
$LN17@tok_get:

; 1665 :             }
; 1666 :         }
; 1667 : 
; 1668 :         *p_start = tok->start;

  007b5	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  007b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]

; 1669 :         *p_end = tok->cur;
; 1670 :         return STRING;

  007be	b8 03 00 00 00	 mov	 eax, 3
  007c3	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  007c6	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  007cb	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  007cf	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  007d2	e9 e9 00 00 00	 jmp	 $LN157@tok_get
$LN195@tok_get:

; 1655 :                 tok->done = E_EOLS;
; 1656 :                 tok->cur = tok->inp;

  007d7	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  007db	c7 47 28 18 00
	00 00		 mov	 DWORD PTR [rdi+40], 24
  007e2	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1657 :                 return ERRORTOKEN;

  007e6	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  007eb	e9 d0 00 00 00	 jmp	 $LN157@tok_get
$LN194@tok_get:

; 1647 :                 if (quote_size == 3)
; 1648 :                     tok->done = E_EOFS;
; 1649 :                 else
; 1650 :                     tok->done = E_EOLS;
; 1651 :                 tok->cur = tok->inp;

  007f0	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  007f4	41 83 fc 03	 cmp	 r12d, 3
  007f8	41 0f 95 c6	 setne	 r14b
  007fc	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1652 :                 return ERRORTOKEN;

  00800	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00805	41 83 c6 17	 add	 r14d, 23
  00809	44 89 77 28	 mov	 DWORD PTR [rdi+40], r14d
  0080d	e9 ae 00 00 00	 jmp	 $LN157@tok_get
$LL101@tok_get:

; 1462 :                 goto letter_quote;
; 1463 :         }
; 1464 :         while (is_potential_identifier_char(c)) {

  00812	83 fb 61	 cmp	 ebx, 97			; 00000061H
  00815	7c 05		 jl	 SHORT $LN98@tok_get
  00817	83 fb 7a	 cmp	 ebx, 122		; 0000007aH
  0081a	7e 4a		 jle	 SHORT $LN99@tok_get
$LN98@tok_get:
  0081c	83 fb 41	 cmp	 ebx, 65			; 00000041H
  0081f	7c 05		 jl	 SHORT $LN97@tok_get
  00821	83 fb 5a	 cmp	 ebx, 90			; 0000005aH
  00824	7e 40		 jle	 SHORT $LN99@tok_get
$LN97@tok_get:
  00826	83 fb 30	 cmp	 ebx, 48			; 00000030H
  00829	7c 05		 jl	 SHORT $LN96@tok_get
  0082b	83 fb 39	 cmp	 ebx, 57			; 00000039H
  0082e	7e 36		 jle	 SHORT $LN99@tok_get
$LN96@tok_get:
  00830	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00833	74 31		 je	 SHORT $LN99@tok_get
  00835	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0083b	7d 31		 jge	 SHORT $LN200@tok_get

; 1469 :         tok_backup(tok, c);

  0083d	8b d3		 mov	 edx, ebx
  0083f	48 8b cf	 mov	 rcx, rdi
  00842	e8 00 00 00 00	 call	 tok_backup

; 1470 :         if (nonascii &&
; 1471 :             !verify_identifier(tok)) {

  00847	45 85 f6	 test	 r14d, r14d
  0084a	74 31		 je	 SHORT $LN94@tok_get
  0084c	48 8b cf	 mov	 rcx, rdi
  0084f	e8 00 00 00 00	 call	 verify_identifier
  00854	85 c0		 test	 eax, eax
  00856	75 25		 jne	 SHORT $LN94@tok_get

; 1472 :             tok->done = E_IDENTIFIER;

  00858	c7 47 28 1a 00
	00 00		 mov	 DWORD PTR [rdi+40], 26

; 1473 :             return ERRORTOKEN;

  0085f	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00864	eb 5a		 jmp	 SHORT $LN157@tok_get
$LN99@tok_get:

; 1465 :             if (c >= 128)

  00866	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0086c	7c 03		 jl	 SHORT $LN95@tok_get
$LN200@tok_get:

; 1466 :                 nonascii = 1;

  0086e	45 8b f4	 mov	 r14d, r12d
$LN95@tok_get:

; 1467 :             c = tok_nextc(tok);

  00871	48 8b cf	 mov	 rcx, rdi
  00874	e8 00 00 00 00	 call	 tok_nextc
  00879	8b d8		 mov	 ebx, eax

; 1468 :         }

  0087b	eb 95		 jmp	 SHORT $LL101@tok_get
$LN94@tok_get:

; 1474 :         }
; 1475 :         *p_start = tok->start;

  0087d	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00881	48 8b 54 24 68	 mov	 rdx, QWORD PTR p_start$[rsp]

; 1476 :         *p_end = tok->cur;
; 1477 :         return NAME;

  00886	41 8b c4	 mov	 eax, r12d
  00889	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0088c	48 8b 54 24 70	 mov	 rdx, QWORD PTR p_end$[rsp]
  00891	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00895	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00898	eb 26		 jmp	 SHORT $LN157@tok_get
$LN193@tok_get:

; 1413 :         if (tok->pendin < 0) {

  0089a	8b 87 d4 01 00
	00		 mov	 eax, DWORD PTR [rdi+468]
  008a0	85 c0		 test	 eax, eax
  008a2	79 0f		 jns	 SHORT $LN127@tok_get

; 1414 :             tok->pendin++;

  008a4	ff c0		 inc	 eax
  008a6	89 87 d4 01 00
	00		 mov	 DWORD PTR [rdi+468], eax

; 1415 :             return DEDENT;

  008ac	b8 06 00 00 00	 mov	 eax, 6
  008b1	eb 0d		 jmp	 SHORT $LN157@tok_get
$LN127@tok_get:

; 1416 :         }
; 1417 :         else {
; 1418 :             tok->pendin--;

  008b3	ff c8		 dec	 eax
  008b5	89 87 d4 01 00
	00		 mov	 DWORD PTR [rdi+468], eax

; 1419 :             return INDENT;

  008bb	b8 05 00 00 00	 mov	 eax, 5
$LN157@tok_get:

; 1722 : }

  008c0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  008c5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  008c9	41 5f		 pop	 r15
  008cb	41 5e		 pop	 r14
  008cd	41 5d		 pop	 r13
  008cf	41 5c		 pop	 r12
  008d1	5f		 pop	 rdi
  008d2	5e		 pop	 rsi
  008d3	5d		 pop	 rbp
  008d4	c3		 ret	 0
  008d5	0f 1f 00	 npad	 3
$LN226@tok_get:
  008d8	00 00 00 00	 DD	 $LN2@tok_get
  008dc	00 00 00 00	 DD	 $LN1@tok_get
  008e0	00 00 00 00	 DD	 $LN3@tok_get
$LN225@tok_get:
  008e4	00		 DB	 0
  008e5	01		 DB	 1
  008e6	02		 DB	 2
  008e7	02		 DB	 2
  008e8	02		 DB	 2
  008e9	02		 DB	 2
  008ea	02		 DB	 2
  008eb	02		 DB	 2
  008ec	02		 DB	 2
  008ed	02		 DB	 2
  008ee	02		 DB	 2
  008ef	02		 DB	 2
  008f0	02		 DB	 2
  008f1	02		 DB	 2
  008f2	02		 DB	 2
  008f3	02		 DB	 2
  008f4	02		 DB	 2
  008f5	02		 DB	 2
  008f6	02		 DB	 2
  008f7	02		 DB	 2
  008f8	02		 DB	 2
  008f9	02		 DB	 2
  008fa	02		 DB	 2
  008fb	02		 DB	 2
  008fc	02		 DB	 2
  008fd	02		 DB	 2
  008fe	02		 DB	 2
  008ff	02		 DB	 2
  00900	02		 DB	 2
  00901	02		 DB	 2
  00902	02		 DB	 2
  00903	02		 DB	 2
  00904	02		 DB	 2
  00905	02		 DB	 2
  00906	02		 DB	 2
  00907	02		 DB	 2
  00908	02		 DB	 2
  00909	02		 DB	 2
  0090a	02		 DB	 2
  0090b	02		 DB	 2
  0090c	02		 DB	 2
  0090d	02		 DB	 2
  0090e	02		 DB	 2
  0090f	02		 DB	 2
  00910	02		 DB	 2
  00911	02		 DB	 2
  00912	02		 DB	 2
  00913	02		 DB	 2
  00914	02		 DB	 2
  00915	02		 DB	 2
  00916	02		 DB	 2
  00917	00		 DB	 0
  00918	02		 DB	 2
  00919	01		 DB	 1
  0091a	02		 DB	 2
  0091b	02		 DB	 2
  0091c	02		 DB	 2
  0091d	02		 DB	 2
  0091e	02		 DB	 2
  0091f	02		 DB	 2
  00920	02		 DB	 2
  00921	02		 DB	 2
  00922	02		 DB	 2
  00923	02		 DB	 2
  00924	02		 DB	 2
  00925	02		 DB	 2
  00926	02		 DB	 2
  00927	02		 DB	 2
  00928	02		 DB	 2
  00929	02		 DB	 2
  0092a	02		 DB	 2
  0092b	02		 DB	 2
  0092c	02		 DB	 2
  0092d	02		 DB	 2
  0092e	02		 DB	 2
  0092f	02		 DB	 2
  00930	02		 DB	 2
  00931	02		 DB	 2
  00932	02		 DB	 2
  00933	02		 DB	 2
  00934	02		 DB	 2
  00935	02		 DB	 2
  00936	02		 DB	 2
  00937	00		 DB	 0
  00938	02		 DB	 2
  00939	01		 DB	 1
tok_get	ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_Get
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_Get DD imagerel $LN5
	DD	imagerel $LN5+41
	DD	imagerel $unwind$PyTokenizer_Get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_Get DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyTokenizer_Get
_TEXT	SEGMENT
tok$ = 48
p_start$ = 56
p_end$ = 64
PyTokenizer_Get PROC					; COMDAT

; 1726 : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1727 :     int result = tok_get(tok, p_start, p_end);

  00009	e8 00 00 00 00	 call	 tok_get

; 1728 :     if (tok->decoding_erred) {

  0000e	83 bb 98 03 00
	00 00		 cmp	 DWORD PTR [rbx+920], 0
  00015	74 0c		 je	 SHORT $LN4@PyTokenize@2

; 1729 :         result = ERRORTOKEN;
; 1730 :         tok->done = E_DECODE;

  00017	c7 43 28 16 00
	00 00		 mov	 DWORD PTR [rbx+40], 22

; 1731 :     }
; 1732 :     return result;

  0001e	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
$LN4@PyTokenize@2:

; 1733 : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
PyTokenizer_Get ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FromString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FromString DD imagerel $LN6
	DD	imagerel $LN6+111
	DD	imagerel $unwind$PyTokenizer_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromString DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyTokenizer_FromString
_TEXT	SEGMENT
str$ = 48
exec_input$ = 56
PyTokenizer_FromString PROC				; COMDAT

; 798  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b fa		 mov	 edi, edx
  00011	48 8b f1	 mov	 rsi, rcx

; 799  :     struct tok_state *tok = tok_new();

  00014	e8 00 00 00 00	 call	 tok_new
  00019	48 8b d8	 mov	 rbx, rax

; 800  :     if (tok == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 801  :         return NULL;

  0001f	74 1a		 je	 SHORT $LN5@PyTokenize@3

; 802  :     str = (char *)decode_str(str, exec_input, tok);

  00021	4c 8b c0	 mov	 r8, rax
  00024	8b d7		 mov	 edx, edi
  00026	48 8b ce	 mov	 rcx, rsi
  00029	e8 00 00 00 00	 call	 decode_str

; 803  :     if (str == NULL) {

  0002e	48 85 c0	 test	 rax, rax
  00031	75 1a		 jne	 SHORT $LN1@PyTokenize@3

; 804  :         PyTokenizer_Free(tok);

  00033	48 8b cb	 mov	 rcx, rbx
  00036	e8 00 00 00 00	 call	 PyTokenizer_Free
$LN5@PyTokenize@3:

; 805  :         return NULL;

  0003b	33 c0		 xor	 eax, eax

; 806  :     }
; 807  : 
; 808  :     /* XXX: constify members. */
; 809  :     tok->buf = tok->cur = tok->end = tok->inp = (char*)str;
; 810  :     return tok;
; 811  : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN1@PyTokenize@3:
  0004d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00052	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00056	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  0005a	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
  0005e	48 89 03	 mov	 QWORD PTR [rbx], rax
  00061	48 8b c3	 mov	 rax, rbx
  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
PyTokenizer_FromString ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FromUTF8
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FromUTF8 DD imagerel $LN11
	DD	imagerel $LN11+222
	DD	imagerel $unwind$PyTokenizer_FromUTF8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromUTF8 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyTokenizer_FromUTF8
_TEXT	SEGMENT
str$ = 48
exec_input$ = 56
PyTokenizer_FromUTF8 PROC				; COMDAT

; 815  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b fa		 mov	 edi, edx
  00011	48 8b f1	 mov	 rsi, rcx

; 816  :     struct tok_state *tok = tok_new();

  00014	e8 00 00 00 00	 call	 tok_new
  00019	48 8b d8	 mov	 rbx, rax

; 817  :     if (tok == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 818  :         return NULL;

  0001f	74 24		 je	 SHORT $LN9@PyTokenize@4

; 819  : #ifndef PGEN
; 820  :     tok->input = str = translate_newlines(str, exec_input, tok);

  00021	4c 8b c0	 mov	 r8, rax
  00024	8b d7		 mov	 edx, edi
  00026	48 8b ce	 mov	 rcx, rsi
  00029	e8 00 00 00 00	 call	 translate_newlines
  0002e	48 8b f8	 mov	 rdi, rax
  00031	48 89 83 d8 03
	00 00		 mov	 QWORD PTR [rbx+984], rax

; 821  : #endif
; 822  :     if (str == NULL) {

  00038	48 85 c0	 test	 rax, rax
  0003b	75 1a		 jne	 SHORT $LN2@PyTokenize@4
$LN10@PyTokenize@4:

; 823  :         PyTokenizer_Free(tok);

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	e8 00 00 00 00	 call	 PyTokenizer_Free
$LN9@PyTokenize@4:

; 824  :         return NULL;

  00045	33 c0		 xor	 eax, eax

; 836  : 
; 837  :     /* XXX: constify members. */
; 838  :     tok->buf = tok->cur = tok->end = tok->inp = (char*)str;
; 839  :     return tok;
; 840  : }

  00047	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN2@PyTokenize@4:

; 825  :     }
; 826  :     tok->decoding_state = STATE_RAW;

  00057	c7 83 94 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+916], 1

; 827  :     tok->read_coding_spec = 1;

  00061	c7 83 9c 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rbx+924], 1

; 828  :     tok->enc = NULL;

  0006b	48 c7 83 c8 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+968], 0

; 829  :     tok->str = str;

  00076	48 89 83 d0 03
	00 00		 mov	 QWORD PTR [rbx+976], rax

; 830  :     tok->encoding = (char *)PyMem_MALLOC(6);

  0007d	e8 00 00 00 00	 call	 _Py_PXCTX
  00082	b9 06 00 00 00	 mov	 ecx, 6
  00087	85 c0		 test	 eax, eax
  00089	74 07		 je	 SHORT $LN6@PyTokenize@4
  0008b	e8 00 00 00 00	 call	 _PxMem_Malloc
  00090	eb 06		 jmp	 SHORT $LN8@PyTokenize@4
$LN6@PyTokenize@4:
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN8@PyTokenize@4:
  00098	4c 8b d8	 mov	 r11, rax
  0009b	48 89 83 a0 03
	00 00		 mov	 QWORD PTR [rbx+928], rax

; 831  :     if (!tok->encoding) {

  000a2	48 85 c0	 test	 rax, rax

; 832  :         PyTokenizer_Free(tok);
; 833  :         return NULL;

  000a5	74 96		 je	 SHORT $LN10@PyTokenize@4

; 834  :     }
; 835  :     strcpy(tok->encoding, "utf-8");

  000a7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_05CAMHEFLG@utf?98?$AA@

; 836  : 
; 837  :     /* XXX: constify members. */
; 838  :     tok->buf = tok->cur = tok->end = tok->inp = (char*)str;
; 839  :     return tok;
; 840  : }

  000ad	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b2	41 89 03	 mov	 DWORD PTR [r11], eax
  000b5	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_05CAMHEFLG@utf?98?$AA@+4
  000bc	66 41 89 43 04	 mov	 WORD PTR [r11+4], ax
  000c1	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi
  000c5	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi
  000c9	48 89 7b 08	 mov	 QWORD PTR [rbx+8], rdi
  000cd	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  000d0	48 8b c3	 mov	 rax, rbx
  000d3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
PyTokenizer_FromUTF8 ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FromFile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FromFile DD imagerel $LN21
	DD	imagerel $LN21+328
	DD	imagerel $unwind$PyTokenizer_FromFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FromFile DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyTokenizer_FromFile
_TEXT	SEGMENT
fp$ = 48
enc$ = 56
ps1$ = 64
ps2$ = 72
PyTokenizer_FromFile PROC				; COMDAT

; 846  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	49 8b f9	 mov	 rdi, r9
  0001d	49 8b e8	 mov	 rbp, r8
  00020	48 8b da	 mov	 rbx, rdx
  00023	4c 8b e1	 mov	 r12, rcx

; 847  :     struct tok_state *tok = tok_new();

  00026	e8 00 00 00 00	 call	 tok_new
  0002b	48 8b f0	 mov	 rsi, rax

; 848  :     if (tok == NULL)

  0002e	48 85 c0	 test	 rax, rax

; 849  :         return NULL;

  00031	74 2b		 je	 SHORT $LN19@PyTokenize@5

; 850  :     if ((tok->buf = (char *)PyMem_MALLOC(BUFSIZ)) == NULL) {

  00033	e8 00 00 00 00	 call	 _Py_PXCTX
  00038	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0003d	85 c0		 test	 eax, eax
  0003f	74 07		 je	 SHORT $LN7@PyTokenize@5
  00041	e8 00 00 00 00	 call	 _PxMem_Malloc
  00046	eb 06		 jmp	 SHORT $LN8@PyTokenize@5
$LN7@PyTokenize@5:
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN8@PyTokenize@5:
  0004e	48 89 06	 mov	 QWORD PTR [rsi], rax
  00051	48 85 c0	 test	 rax, rax
  00054	75 0f		 jne	 SHORT $LN3@PyTokenize@5
$LN20@PyTokenize@5:

; 851  :         PyTokenizer_Free(tok);

  00056	48 8b ce	 mov	 rcx, rsi
  00059	e8 00 00 00 00	 call	 PyTokenizer_Free
$LN19@PyTokenize@5:

; 852  :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 c8 00 00 00	 jmp	 $LN5@PyTokenize@5
$LN3@PyTokenize@5:

; 853  :     }
; 854  :     tok->cur = tok->inp = tok->buf;

  00065	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  00069	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 855  :     tok->end = tok->buf + BUFSIZ;

  0006d	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H

; 856  :     tok->fp = fp;

  00073	4c 89 66 30	 mov	 QWORD PTR [rsi+48], r12

; 857  :     tok->prompt = ps1;

  00077	48 89 ae d8 01
	00 00		 mov	 QWORD PTR [rsi+472], rbp

; 858  :     tok->nextprompt = ps2;

  0007e	48 89 be e0 01
	00 00		 mov	 QWORD PTR [rsi+480], rdi
  00085	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax

; 859  :     if (enc != NULL) {

  00089	48 85 db	 test	 rbx, rbx
  0008c	0f 84 98 00 00
	00		 je	 $LN2@PyTokenize@5

; 860  :         /* Must copy encoding declaration since it
; 861  :            gets copied into the parse tree. */
; 862  :         tok->encoding = PyMem_MALLOC(strlen(enc)+1);

  00092	e8 00 00 00 00	 call	 _Py_PXCTX
  00097	48 83 c9 ff	 or	 rcx, -1
  0009b	48 8b fb	 mov	 rdi, rbx
  0009e	85 c0		 test	 eax, eax
  000a0	74 0e		 je	 SHORT $LN13@PyTokenize@5
  000a2	33 c0		 xor	 eax, eax
  000a4	f2 ae		 repne scasb
  000a6	48 f7 d1	 not	 rcx
  000a9	e8 00 00 00 00	 call	 _PxMem_Malloc
  000ae	eb 49		 jmp	 SHORT $LN18@PyTokenize@5
$LN13@PyTokenize@5:
  000b0	33 c0		 xor	 eax, eax
  000b2	f2 ae		 repne scasb
  000b4	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000be	48 f7 d1	 not	 rcx
  000c1	48 3b c8	 cmp	 rcx, rax
  000c4	76 04		 jbe	 SHORT $LN11@PyTokenize@5
  000c6	33 d2		 xor	 edx, edx
  000c8	eb 32		 jmp	 SHORT $LN12@PyTokenize@5
$LN11@PyTokenize@5:
  000ca	48 83 c9 ff	 or	 rcx, -1
  000ce	33 c0		 xor	 eax, eax
  000d0	48 8b fb	 mov	 rdi, rbx
  000d3	f2 ae		 repne scasb
  000d5	48 f7 d1	 not	 rcx
  000d8	48 ff c9	 dec	 rcx
  000db	48 ff c1	 inc	 rcx
  000de	74 0e		 je	 SHORT $LN9@PyTokenize@5
  000e0	48 83 c9 ff	 or	 rcx, -1
  000e4	48 8b fb	 mov	 rdi, rbx
  000e7	f2 ae		 repne scasb
  000e9	48 f7 d1	 not	 rcx
  000ec	eb 05		 jmp	 SHORT $LN10@PyTokenize@5
$LN9@PyTokenize@5:
  000ee	b9 01 00 00 00	 mov	 ecx, 1
$LN10@PyTokenize@5:
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN18@PyTokenize@5:
  000f9	48 8b d0	 mov	 rdx, rax
$LN12@PyTokenize@5:
  000fc	48 89 96 a0 03
	00 00		 mov	 QWORD PTR [rsi+928], rdx

; 863  :         if (!tok->encoding) {

  00103	48 85 d2	 test	 rdx, rdx

; 864  :             PyTokenizer_Free(tok);
; 865  :             return NULL;

  00106	0f 84 4a ff ff
	ff		 je	 $LN20@PyTokenize@5
  0010c	0f 1f 40 00	 npad	 4
$LL1@PyTokenize@5:

; 866  :         }
; 867  :         strcpy(tok->encoding, enc);

  00110	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00113	48 ff c2	 inc	 rdx
  00116	48 ff c3	 inc	 rbx
  00119	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  0011c	84 c0		 test	 al, al
  0011e	75 f0		 jne	 SHORT $LL1@PyTokenize@5

; 868  :         tok->decoding_state = STATE_NORMAL;

  00120	c7 86 94 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rsi+916], 2
$LN2@PyTokenize@5:

; 869  :     }
; 870  :     return tok;

  0012a	48 8b c6	 mov	 rax, rsi
$LN5@PyTokenize@5:

; 871  : }

  0012d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00132	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00137	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0013c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00141	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00145	41 5c		 pop	 r12
  00147	c3		 ret	 0
PyTokenizer_FromFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@		; `string'
PUBLIC	PyTokenizer_FindEncodingFilename
EXTRN	PyUnicode_FromString:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fdopen:PROC
EXTRN	__imp_dup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyTokenizer_FindEncodingFilename DD imagerel $LN27
	DD	imagerel $LN27+40
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyTokenizer_FindEncodingFilename DD imagerel $LN27+40
	DD	imagerel $LN27+71
	DD	imagerel $chain$0$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyTokenizer_FindEncodingFilename DD imagerel $LN27+71
	DD	imagerel $LN27+128
	DD	imagerel $chain$3$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyTokenizer_FindEncodingFilename DD imagerel $LN27+128
	DD	imagerel $LN27+312
	DD	imagerel $chain$5$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyTokenizer_FindEncodingFilename DD imagerel $LN27+312
	DD	imagerel $LN27+460
	DD	imagerel $chain$7$PyTokenizer_FindEncodingFilename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyTokenizer_FindEncodingFilename DD 040021H
	DD	045400H
	DD	083400H
	DD	imagerel $LN27
	DD	imagerel $LN27+40
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyTokenizer_FindEncodingFilename DD 040021H
	DD	045400H
	DD	083400H
	DD	imagerel $LN27
	DD	imagerel $LN27+40
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyTokenizer_FindEncodingFilename DD 041021H
	DD	083410H
	DD	045400H
	DD	imagerel $LN27
	DD	imagerel $LN27+40
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyTokenizer_FindEncodingFilename DD 020521H
	DD	045405H
	DD	imagerel $LN27
	DD	imagerel $LN27+40
	DD	imagerel $unwind$PyTokenizer_FindEncodingFilename
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyTokenizer_FindEncodingFilename DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
CONST	SEGMENT
??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@ DB '<string>', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyTokenizer_FindEncodingFilename
_TEXT	SEGMENT
fd$ = 64
filename$ = 72
p_end$ = 80
p_start$ = 88
PyTokenizer_FindEncodingFilename PROC			; COMDAT

; 1747 : {

$LN27:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b fa	 mov	 rdi, rdx

; 1748 :     struct tok_state *tok;
; 1749 :     FILE *fp;
; 1750 :     char *p_start =NULL , *p_end =NULL , *encoding = NULL;

  0000a	33 f6		 xor	 esi, esi

; 1751 : 
; 1752 :     fd = dup(fd);

  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup

; 1753 :     if (fd < 0) {

  00012	85 c0		 test	 eax, eax
  00014	79 09		 jns	 SHORT $LN10@PyTokenize@6

; 1754 :         return NULL;

  00016	33 c0		 xor	 eax, eax

; 1790 : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	5f		 pop	 rdi
  0001d	5e		 pop	 rsi
  0001e	c3		 ret	 0
$LN10@PyTokenize@6:

; 1755 :     }
; 1756 :     fp = fdopen(fd, "r");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  00026	8b c8		 mov	 ecx, eax
  00028	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fdopen
  00033	48 8b e8	 mov	 rbp, rax

; 1757 :     if (fp == NULL) {

  00036	48 85 c0	 test	 rax, rax
  00039	75 0c		 jne	 SHORT $LN9@PyTokenize@6
  0003b	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 1790 : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	5f		 pop	 rdi
  00045	5e		 pop	 rsi
  00046	c3		 ret	 0
$LN9@PyTokenize@6:

; 1758 :         return NULL;
; 1759 :     }
; 1760 :     tok = PyTokenizer_FromFile(fp, NULL, NULL, NULL);

  00047	45 33 c9	 xor	 r9d, r9d
  0004a	45 33 c0	 xor	 r8d, r8d
  0004d	33 d2		 xor	 edx, edx
  0004f	48 8b c8	 mov	 rcx, rax
  00052	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00057	e8 00 00 00 00	 call	 PyTokenizer_FromFile
  0005c	48 8b d8	 mov	 rbx, rax

; 1761 :     if (tok == NULL) {

  0005f	48 85 c0	 test	 rax, rax
  00062	75 1c		 jne	 SHORT $LN8@PyTokenize@6

; 1762 :         fclose(fp);

  00064	48 8b cd	 mov	 rcx, rbp
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0006d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00072	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 1763 :         return NULL;

  00077	33 c0		 xor	 eax, eax

; 1790 : }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	5f		 pop	 rdi
  0007e	5e		 pop	 rsi
  0007f	c3		 ret	 0
$LN8@PyTokenize@6:

; 1764 :     }
; 1765 : #ifndef PGEN
; 1766 :     if (filename != NULL) {

  00080	48 85 ff	 test	 rdi, rdi
  00083	74 77		 je	 SHORT $LN7@PyTokenize@6

; 1767 :         Py_INCREF(filename);

  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 _Py_IncRef

; 1768 :         tok->filename = filename;

  0008d	48 89 bb f0 01
	00 00		 mov	 QWORD PTR [rbx+496], rdi
$LN20@PyTokenize@6:

; 1776 :         }
; 1777 :     }
; 1778 : #endif
; 1779 :     while (tok->lineno < 2 && tok->done == E_OK) {

  00094	83 bb e8 01 00
	00 02		 cmp	 DWORD PTR [rbx+488], 2
  0009b	7d 24		 jge	 SHORT $LN23@PyTokenize@6
  0009d	0f 1f 00	 npad	 3
$LL4@PyTokenize@6:
  000a0	83 7b 28 0a	 cmp	 DWORD PTR [rbx+40], 10
  000a4	75 1b		 jne	 SHORT $LN23@PyTokenize@6

; 1780 :         PyTokenizer_Get(tok, &p_start, &p_end);

  000a6	4c 8d 44 24 50	 lea	 r8, QWORD PTR p_end$[rsp]
  000ab	48 8d 54 24 58	 lea	 rdx, QWORD PTR p_start$[rsp]
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 PyTokenizer_Get
  000b8	83 bb e8 01 00
	00 02		 cmp	 DWORD PTR [rbx+488], 2
  000bf	7c df		 jl	 SHORT $LL4@PyTokenize@6
$LN23@PyTokenize@6:

; 1781 :     }
; 1782 :     fclose(fp);

  000c1	48 8b cd	 mov	 rcx, rbp
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1783 :     if (tok->encoding) {

  000ca	48 39 b3 a0 03
	00 00		 cmp	 QWORD PTR [rbx+928], rsi
  000d1	0f 84 d9 00 00
	00		 je	 $LN1@PyTokenize@6

; 1784 :         encoding = (char *)PyMem_MALLOC(strlen(tok->encoding) + 1);

  000d7	e8 00 00 00 00	 call	 _Py_PXCTX
  000dc	48 83 c9 ff	 or	 rcx, -1
  000e0	85 c0		 test	 eax, eax
  000e2	74 54		 je	 SHORT $LN17@PyTokenize@6
  000e4	48 8b bb a0 03
	00 00		 mov	 rdi, QWORD PTR [rbx+928]
  000eb	33 c0		 xor	 eax, eax
  000ed	f2 ae		 repne scasb
  000ef	48 f7 d1	 not	 rcx
  000f2	e8 00 00 00 00	 call	 _PxMem_Malloc
  000f7	e9 8b 00 00 00	 jmp	 $LN26@PyTokenize@6
$LN7@PyTokenize@6:

; 1769 :     }
; 1770 :     else {
; 1771 :         tok->filename = PyUnicode_FromString("<string>");

  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
  00103	e8 00 00 00 00	 call	 PyUnicode_FromString
  00108	48 89 83 f0 01
	00 00		 mov	 QWORD PTR [rbx+496], rax

; 1772 :         if (tok->filename == NULL) {

  0010f	48 85 c0	 test	 rax, rax
  00112	75 80		 jne	 SHORT $LN20@PyTokenize@6

; 1773 :             fclose(fp);

  00114	48 8b cd	 mov	 rcx, rbp
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 1774 :             PyTokenizer_Free(tok);

  0011d	48 8b cb	 mov	 rcx, rbx
  00120	e8 00 00 00 00	 call	 PyTokenizer_Free
  00125	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0012a	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 1775 :             return encoding;

  0012f	33 c0		 xor	 eax, eax

; 1790 : }

  00131	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00135	5f		 pop	 rdi
  00136	5e		 pop	 rsi
  00137	c3		 ret	 0
$LN17@PyTokenize@6:

; 1784 :         encoding = (char *)PyMem_MALLOC(strlen(tok->encoding) + 1);

  00138	48 8b 93 a0 03
	00 00		 mov	 rdx, QWORD PTR [rbx+928]
  0013f	33 c0		 xor	 eax, eax
  00141	48 8b fa	 mov	 rdi, rdx
  00144	f2 ae		 repne scasb
  00146	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00150	48 f7 d1	 not	 rcx
  00153	48 3b c8	 cmp	 rcx, rax
  00156	77 58		 ja	 SHORT $LN1@PyTokenize@6
  00158	48 83 c9 ff	 or	 rcx, -1
  0015c	33 c0		 xor	 eax, eax
  0015e	48 8b fa	 mov	 rdi, rdx
  00161	f2 ae		 repne scasb
  00163	48 f7 d1	 not	 rcx
  00166	48 ff c9	 dec	 rcx
  00169	48 ff c1	 inc	 rcx
  0016c	74 0e		 je	 SHORT $LN13@PyTokenize@6
  0016e	48 83 c9 ff	 or	 rcx, -1
  00172	48 8b fa	 mov	 rdi, rdx
  00175	f2 ae		 repne scasb
  00177	48 f7 d1	 not	 rcx
  0017a	eb 05		 jmp	 SHORT $LN14@PyTokenize@6
$LN13@PyTokenize@6:
  0017c	b9 01 00 00 00	 mov	 ecx, 1
$LN14@PyTokenize@6:
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN26@PyTokenize@6:
  00187	48 8b f0	 mov	 rsi, rax

; 1785 :         if (encoding)

  0018a	48 85 c0	 test	 rax, rax
  0018d	74 21		 je	 SHORT $LN1@PyTokenize@6

; 1786 :         strcpy(encoding, tok->encoding);

  0018f	48 8b 8b a0 03
	00 00		 mov	 rcx, QWORD PTR [rbx+928]
  00196	48 8b d0	 mov	 rdx, rax
  00199	0f 1f 80 00 00
	00 00		 npad	 7
$LL19@PyTokenize@6:
  001a0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001a3	48 ff c2	 inc	 rdx
  001a6	48 ff c1	 inc	 rcx
  001a9	88 42 ff	 mov	 BYTE PTR [rdx-1], al
  001ac	84 c0		 test	 al, al
  001ae	75 f0		 jne	 SHORT $LL19@PyTokenize@6
$LN1@PyTokenize@6:

; 1787 :     }
; 1788 :     PyTokenizer_Free(tok);

  001b0	48 8b cb	 mov	 rcx, rbx
  001b3	e8 00 00 00 00	 call	 PyTokenizer_Free
  001b8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001bd	48 8b 6c 24 20	 mov	 rbp, QWORD PTR [rsp+32]

; 1789 :     return encoding;

  001c2	48 8b c6	 mov	 rax, rsi

; 1790 : }

  001c5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c9	5f		 pop	 rdi
  001ca	5e		 pop	 rsi
  001cb	c3		 ret	 0
PyTokenizer_FindEncodingFilename ENDP
_TEXT	ENDS
PUBLIC	PyTokenizer_FindEncoding
; Function compile flags: /Ogtpy
;	COMDAT PyTokenizer_FindEncoding
_TEXT	SEGMENT
fd$ = 8
PyTokenizer_FindEncoding PROC				; COMDAT

; 1795 :     return PyTokenizer_FindEncodingFilename(fd, NULL);

  00000	33 d2		 xor	 edx, edx

; 1796 : }

  00002	e9 00 00 00 00	 jmp	 PyTokenizer_FindEncodingFilename
PyTokenizer_FindEncoding ENDP
_TEXT	ENDS
END
