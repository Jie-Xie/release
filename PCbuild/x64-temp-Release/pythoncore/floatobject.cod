; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05KNFBNCOH@float?$AA@			; `string'
PUBLIC	??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ ; `string'
PUBLIC	??_C@_04HBKGOHH@imag?$AA@			; `string'
PUBLIC	??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ ; `string'
PUBLIC	??_C@_04DGGKDJMA@real?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0O@PDHIBBE@__setformat__?$AA@		; `string'
PUBLIC	??_C@_0O@CJFHJH@__getformat__?$AA@		; `string'
PUBLIC	??_C@_0P@BCBHENLA@__getnewargs__?$AA@		; `string'
PUBLIC	??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@ ; `string'
PUBLIC	??_C@_0L@CPNMLAFF@is_integer?$AA@		; `string'
PUBLIC	??_C@_03IJNDAFDK@hex?$AA@			; `string'
PUBLIC	??_C@_07DIMGGDAC@fromhex?$AA@			; `string'
PUBLIC	??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@	; `string'
PUBLIC	??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@ ; `string'
PUBLIC	??_C@_09PJGAHDBG@__round__?$AA@			; `string'
PUBLIC	??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@ ; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@ ; `string'
PUBLIC	??_C@_09PHMNDPIK@conjugate?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_0P@GFDAFFFN@sys?4float_info?$AA@		; `string'
PUBLIC	??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@ ; `string'
PUBLIC	??_C@_06EBMBPKEK@rounds?$AA@			; `string'
PUBLIC	??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@ ; `string'
PUBLIC	??_C@_05LICBMPGO@radix?$AA@			; `string'
PUBLIC	??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@ ; `string'
PUBLIC	??_C@_07DOCPLGLO@epsilon?$AA@			; `string'
PUBLIC	??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@ ; `string'
PUBLIC	??_C@_08IABMGAGJ@mant_dig?$AA@			; `string'
PUBLIC	??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@	; `string'
PUBLIC	??_C@_03HEFENHI@dig?$AA@			; `string'
PUBLIC	??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@ ; `string'
PUBLIC	??_C@_0L@PDGFLHLE@min_10_exp?$AA@		; `string'
PUBLIC	??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@ ; `string'
PUBLIC	??_C@_07DOIFONNF@min_exp?$AA@			; `string'
PUBLIC	??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@ ; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@ ; `string'
PUBLIC	??_C@_0L@DPGIMMLL@max_10_exp?$AA@		; `string'
PUBLIC	??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@ ; `string'
PUBLIC	??_C@_07NIOFECDE@max_exp?$AA@			; `string'
PUBLIC	??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@ ; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	PyFloat_Type
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
_BSS	SEGMENT
numfree	DD	01H DUP (?)
	ALIGN	8

free_list DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_05KNFBNCOH@float?$AA@
CONST	SEGMENT
??_C@_05KNFBNCOH@float?$AA@ DB 'float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
CONST	SEGMENT
??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@ DB 'the imagin'
	DB	'ary part of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HBKGOHH@imag?$AA@
CONST	SEGMENT
??_C@_04HBKGOHH@imag?$AA@ DB 'imag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
CONST	SEGMENT
??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@ DB 'the real pa'
	DB	'rt of a complex number', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DGGKDJMA@real?$AA@
CONST	SEGMENT
??_C@_04DGGKDJMA@real?$AA@ DB 'real', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDHIBBE@__setformat__?$AA@
CONST	SEGMENT
??_C@_0O@PDHIBBE@__setformat__?$AA@ DB '__setformat__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CJFHJH@__getformat__?$AA@
CONST	SEGMENT
??_C@_0O@CJFHJH@__getformat__?$AA@ DB '__getformat__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BCBHENLA@__getnewargs__?$AA@
CONST	SEGMENT
??_C@_0P@BCBHENLA@__getnewargs__?$AA@ DB '__getnewargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@
CONST	SEGMENT
??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@ DB 'Return Tr'
	DB	'ue if the float is an integer.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CPNMLAFF@is_integer?$AA@
CONST	SEGMENT
??_C@_0L@CPNMLAFF@is_integer?$AA@ DB 'is_integer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03IJNDAFDK@hex?$AA@
CONST	SEGMENT
??_C@_03IJNDAFDK@hex?$AA@ DB 'hex', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07DIMGGDAC@fromhex?$AA@
CONST	SEGMENT
??_C@_07DIMGGDAC@fromhex?$AA@ DB 'fromhex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
CONST	SEGMENT
??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@ DB 'as_integer_ratio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@
CONST	SEGMENT
??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@ DB 'Return the '
	DB	'Integral closest to x, rounding half toward even.', 0aH, 'Whe'
	DB	'n an argument is passed, work like built-in round(x, ndigits)'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJGAHDBG@__round__?$AA@
CONST	SEGMENT
??_C@_09PJGAHDBG@__round__?$AA@ DB '__round__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@
CONST	SEGMENT
??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@ DB 'Return the '
	DB	'Integral closest to x between 0 and x.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@
CONST	SEGMENT
??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@ DB 'Return self'
	DB	', the complex conjugate of any float.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PHMNDPIK@conjugate?$AA@
CONST	SEGMENT
??_C@_09PHMNDPIK@conjugate?$AA@ DB 'conjugate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GFDAFFFN@sys?4float_info?$AA@
CONST	SEGMENT
??_C@_0P@GFDAFFFN@sys?4float_info?$AA@ DB 'sys.float_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@
CONST	SEGMENT
??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@ DB 'FLT_ROUNDS'
	DB	' -- addition rounds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBMBPKEK@rounds?$AA@
CONST	SEGMENT
??_C@_06EBMBPKEK@rounds?$AA@ DB 'rounds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@
CONST	SEGMENT
??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@ DB 'FLT_RADI'
	DB	'X -- radix of exponent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LICBMPGO@radix?$AA@
CONST	SEGMENT
??_C@_05LICBMPGO@radix?$AA@ DB 'radix', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@
CONST	SEGMENT
??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@ DB 'DBL_EPSILON'
	DB	' -- Difference between 1 and the next representable float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOCPLGLO@epsilon?$AA@
CONST	SEGMENT
??_C@_07DOCPLGLO@epsilon?$AA@ DB 'epsilon', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@
CONST	SEGMENT
??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@ DB 'DBL_MANT'
	DB	'_DIG -- mantissa digits', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IABMGAGJ@mant_dig?$AA@
CONST	SEGMENT
??_C@_08IABMGAGJ@mant_dig?$AA@ DB 'mant_dig', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@
CONST	SEGMENT
??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@ DB 'DBL_DIG -- digits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HEFENHI@dig?$AA@
CONST	SEGMENT
??_C@_03HEFENHI@dig?$AA@ DB 'dig', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@
CONST	SEGMENT
??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@ DB 'DBL_MIN_1'
	DB	'0_EXP -- minimum int e such that 10**e is a normalized', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDGFLHLE@min_10_exp?$AA@
CONST	SEGMENT
??_C@_0L@PDGFLHLE@min_10_exp?$AA@ DB 'min_10_exp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@
CONST	SEGMENT
??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@ DB 'DBL_MIN_E'
	DB	'XP -- minimum int e such that radix**(e-1) is a normalized fl'
	DB	'oat', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07DOIFONNF@min_exp?$AA@
CONST	SEGMENT
??_C@_07DOIFONNF@min_exp?$AA@ DB 'min_exp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@
CONST	SEGMENT
??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@ DB 'DBL_MIN --'
	DB	' Minimum positive normalizer float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@
CONST	SEGMENT
??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@ DB 'DBL_MAX_1'
	DB	'0_EXP -- maximum int e such that 10**e is representable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DPGIMMLL@max_10_exp?$AA@
CONST	SEGMENT
??_C@_0L@DPGIMMLL@max_10_exp?$AA@ DB 'max_10_exp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@
CONST	SEGMENT
??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@ DB 'DBL_MAX_EX'
	DB	'P -- maximum int e such that radix**(e-1) is representable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NIOFECDE@max_exp?$AA@
CONST	SEGMENT
??_C@_07NIOFECDE@max_exp?$AA@ DB 'max_exp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@
CONST	SEGMENT
??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@ DB 'DBL_MAX -- '
	DB	'maximum representable finite float', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
floatinfo__doc__ DB 'sys.float_info', 0aH, 0aH, 'A structseq holding info'
	DB	'rmation about the float type. It contains low level', 0aH, 'i'
	DB	'nformation about the precision and internal representation. P'
	DB	'lease study', 0aH, 'your system''s :file:`float.h` for more i'
	DB	'nformation.', 00H
	ORG $+6
floatinfo_fields DQ FLAT:??_C@_03LJAEFNNE@max?$AA@
	DQ	FLAT:??_C@_0CO@DNMBKDDN@DBL_MAX?5?9?9?5maximum?5representable@
	DQ	FLAT:??_C@_07NIOFECDE@max_exp?$AA@
	DQ	FLAT:??_C@_0EF@ICFFOOL@DBL_MAX_EXP?5?9?9?5maximum?5int?5e?5suc@
	DQ	FLAT:??_C@_0L@DPGIMMLL@max_10_exp?$AA@
	DQ	FLAT:??_C@_0EB@OLMLCLAI@DBL_MAX_10_EXP?5?9?9?5maximum?5int?5e?5@
	DQ	FLAT:??_C@_03KLIPLJLL@min?$AA@
	DQ	FLAT:??_C@_0CN@LLOJMAEG@DBL_MIN?5?9?9?5Minimum?5positive?5norm@
	DQ	FLAT:??_C@_07DOIFONNF@min_exp?$AA@
	DQ	FLAT:??_C@_0EK@DEEKODGB@DBL_MIN_EXP?5?9?9?5minimum?5int?5e?5suc@
	DQ	FLAT:??_C@_0L@PDGFLHLE@min_10_exp?$AA@
	DQ	FLAT:??_C@_0EA@HMMAHPHF@DBL_MIN_10_EXP?5?9?9?5minimum?5int?5e?5@
	DQ	FLAT:??_C@_03HEFENHI@dig?$AA@
	DQ	FLAT:??_C@_0BC@JCDBCLA@DBL_DIG?5?9?9?5digits?$AA@
	DQ	FLAT:??_C@_08IABMGAGJ@mant_dig?$AA@
	DQ	FLAT:??_C@_0CA@LMDNBIKF@DBL_MANT_DIG?5?9?9?5mantissa?5digits?$AA@
	DQ	FLAT:??_C@_07DOCPLGLO@epsilon?$AA@
	DQ	FLAT:??_C@_0EF@DGCBBCHJ@DBL_EPSILON?5?9?9?5Difference?5betwee@
	DQ	FLAT:??_C@_05LICBMPGO@radix?$AA@
	DQ	FLAT:??_C@_0BP@MBMDGMCC@FLT_RADIX?5?9?9?5radix?5of?5exponent?$AA@
	DQ	FLAT:??_C@_06EBMBPKEK@rounds?$AA@
	DQ	FLAT:??_C@_0BO@POLMBODL@FLT_ROUNDS?5?9?9?5addition?5rounds?$AA@
	DQ	0000000000000000H
	ORG $+8
floatinfo_desc DQ FLAT:??_C@_0P@GFDAFFFN@sys?4float_info?$AA@
	DQ	FLAT:floatinfo__doc__
	DQ	FLAT:floatinfo_fields
	DD	0bH
	ORG $+4
float_hex_doc DB 'float.hex() -> string', 0aH, 0aH, 'Return a hexadecimal'
	DB	' representation of a floating-point number.', 0aH, '>>> (-0.1'
	DB	').hex()', 0aH, '''-0x1.999999999999ap-4''', 0aH, '>>> 3.14159'
	DB	'.hex()', 0aH, '''0x1.921f9f01b866ep+1''', 00H
	ORG $+7
float_fromhex_doc DB 'float.fromhex(string) -> float', 0aH, 0aH, 'Create '
	DB	'a floating-point number from a hexadecimal string.', 0aH, '>>'
	DB	'> float.fromhex(''0x1.ffffp10'')', 0aH, '2047.984375', 0aH, '>'
	DB	'>> float.fromhex(''-0x1p-1074'')', 0aH, '-4.9406564584124654e'
	DB	'-324', 00H
float_as_integer_ratio_doc DB 'float.as_integer_ratio() -> (int, int)', 0aH
	DB	0aH, 'Return a pair of integers, whose ratio is exactly equal '
	DB	'to the original', 0aH, 'float and with a positive denominator'
	DB	'.', 0aH, 'Raise OverflowError on infinities and a ValueError '
	DB	'on NaNs.', 0aH, 0aH, '>>> (10.0).as_integer_ratio()', 0aH, '('
	DB	'10, 1)', 0aH, '>>> (0.0).as_integer_ratio()', 0aH, '(0, 1)', 0aH
	DB	'>>> (-.25).as_integer_ratio()', 0aH, '(-1, 4)', 00H
	ORG $+4
?kwlist@?1??float_new@@9@9 DQ FLAT:??_C@_01FJMABOPO@x?$AA@ ; `float_new'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
float_getformat_doc DB 'float.__getformat__(typestr) -> string', 0aH, 0aH
	DB	'You probably don''t want to use this function.  It exists mai'
	DB	'nly to be', 0aH, 'used in Python''s test suite.', 0aH, 0aH, 't'
	DB	'ypestr must be ''double'' or ''float''.  This function return'
	DB	's whichever of', 0aH, '''unknown'', ''IEEE, big-endian'' or '''
	DB	'IEEE, little-endian'' best describes the', 0aH, 'format of fl'
	DB	'oating point numbers used by the C type named by typestr.', 00H
	ORG $+11
float_setformat_doc DB 'float.__setformat__(typestr, fmt) -> None', 0aH, 0aH
	DB	'You probably don''t want to use this function.  It exists mai'
	DB	'nly to be', 0aH, 'used in Python''s test suite.', 0aH, 0aH, 't'
	DB	'ypestr must be ''double'' or ''float''.  fmt must be one of '''
	DB	'unknown'',', 0aH, '''IEEE, big-endian'' or ''IEEE, little-end'
	DB	'ian'', and in addition can only be', 0aH, 'one of the latter '
	DB	'two if it appears to match the underlying C reality.', 0aH, 0aH
	DB	'Override the automatic determination of C-level floating poin'
	DB	't type.', 0aH, 'This affects how floats are converted to and '
	DB	'from binary strings.', 00H
	ORG $+5
float__format__doc DB 'float.__format__(format_spec) -> string', 0aH, 0aH
	DB	'Formats the float according to format_spec.', 00H
	ORG $+11
float_methods DQ FLAT:??_C@_09PHMNDPIK@conjugate?$AA@
	DQ	FLAT:float_float
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DB@PIKJGALP@Return?5self?0?5the?5complex?5conjuga@
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	FLAT:float_trunc
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@GGJOGKMD@Return?5the?5Integral?5closest?5to?5x@
	DQ	FLAT:??_C@_09PJGAHDBG@__round__?$AA@
	DQ	FLAT:float_round
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0HP@PDOBDLCN@Return?5the?5Integral?5closest?5to?5x@
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	FLAT:float_as_integer_ratio
	DD	04H
	ORG $+4
	DQ	FLAT:float_as_integer_ratio_doc
	DQ	FLAT:??_C@_07DIMGGDAC@fromhex?$AA@
	DQ	FLAT:float_fromhex
	DD	018H
	ORG $+4
	DQ	FLAT:float_fromhex_doc
	DQ	FLAT:??_C@_03IJNDAFDK@hex?$AA@
	DQ	FLAT:float_hex
	DD	04H
	ORG $+4
	DQ	FLAT:float_hex_doc
	DQ	FLAT:??_C@_0L@CPNMLAFF@is_integer?$AA@
	DQ	FLAT:float_is_integer
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CI@BKHKHHHJ@Return?5True?5if?5the?5float?5is?5an?5i@
	DQ	FLAT:??_C@_0P@BCBHENLA@__getnewargs__?$AA@
	DQ	FLAT:float_getnewargs
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0O@CJFHJH@__getformat__?$AA@
	DQ	FLAT:float_getformat
	DD	018H
	ORG $+4
	DQ	FLAT:float_getformat_doc
	DQ	FLAT:??_C@_0O@PDHIBBE@__setformat__?$AA@
	DQ	FLAT:float_setformat
	DD	011H
	ORG $+4
	DQ	FLAT:float_setformat_doc
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:float__format__
	DD	01H
	ORG $+4
	DQ	FLAT:float__format__doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
float_getset DQ	FLAT:??_C@_04DGGKDJMA@real?$AA@
	DQ	FLAT:float_float
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@GEFHKKP@the?5real?5part?5of?5a?5complex?5numbe@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04HBKGOHH@imag?$AA@
	DQ	FLAT:float_getzero
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CH@FCKKLBGM@the?5imaginary?5part?5of?5a?5complex?5@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
float_doc DB	'float(x) -> floating point number', 0aH, 0aH, 'Convert a'
	DB	' string or number to a floating point number, if possible.', 00H
	ORG $+9
float_as_number DQ FLAT:float_add
	DQ	FLAT:float_sub
	DQ	FLAT:float_mul
	DQ	FLAT:float_rem
	DQ	FLAT:float_divmod
	DQ	FLAT:float_pow
	DQ	FLAT:float_neg
	DQ	FLAT:float_float
	DQ	FLAT:float_abs
	DQ	FLAT:float_bool
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_trunc
	DQ	0000000000000000H
	DQ	FLAT:float_float
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_floor_div
	DQ	FLAT:float_div
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
PyFloat_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05KNFBNCOH@float?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:float_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_repr
	DQ	FLAT:float_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_hash
	DQ	0000000000000000H
	DQ	FLAT:float_repr
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:float_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_methods
	DQ	0000000000000000H
	DQ	FLAT:float_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:float_new
	ORG $+72
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	__real@7fefffffffffffff
PUBLIC	PyFloat_GetMax
EXTRN	_fltused:DWORD
;	COMDAT __real@7fefffffffffffff
; File c:\src\pyparallel\objects\floatobject.c
CONST	SEGMENT
__real@7fefffffffffffff DQ 07fefffffffffffffr	; 1.79769e+308
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyFloat_GetMax
_TEXT	SEGMENT
PyFloat_GetMax PROC					; COMDAT

; 32   :     return DBL_MAX;

  00000	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@7fefffffffffffff

; 33   : }

  00008	c3		 ret	 0
PyFloat_GetMax ENDP
_TEXT	ENDS
PUBLIC	__real@0010000000000000
PUBLIC	PyFloat_GetMin
;	COMDAT __real@0010000000000000
CONST	SEGMENT
__real@0010000000000000 DQ 00010000000000000r	; 2.22507e-308
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyFloat_GetMin
_TEXT	SEGMENT
PyFloat_GetMin PROC					; COMDAT

; 38   :     return DBL_MIN;

  00000	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@0010000000000000

; 39   : }

  00008	c3		 ret	 0
PyFloat_GetMin ENDP
_TEXT	ENDS
PUBLIC	PyFloat_FromDouble
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_FromDouble DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$PyFloat_FromDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_FromDouble DD 040b01H
	DD	02680bH
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyFloat_FromDouble
_TEXT	SEGMENT
fval$ = 64
PyFloat_FromDouble PROC					; COMDAT

; 116  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000b	66 0f 28 f0	 movapd	 xmm6, xmm0

; 117  :     register PyFloatObject *op = (Py_PXCTX ? 0 : free_list);

  0000f	e8 00 00 00 00	 call	 _Py_PXCTX
  00014	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR free_list
  0001b	33 c9		 xor	 ecx, ecx
  0001d	85 c0		 test	 eax, eax
  0001f	48 0f 45 d9	 cmovne	 rbx, rcx

; 118  :     if (op != NULL) {

  00023	48 85 db	 test	 rbx, rbx
  00026	74 33		 je	 SHORT $LN3@PyFloat_Fr

; 119  :         free_list = (PyFloatObject *) Py_TYPE(op);

  00028	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 120  :         numfree--;

  0002c	ff 0d 00 00 00
	00		 dec	 DWORD PTR numfree
  00032	48 89 05 00 00
	00 00		 mov	 QWORD PTR free_list, rax
$LN1@PyFloat_Fr:

; 124  :             return PyErr_NoMemory();
; 125  :     }
; 126  :     /* Inline PyObject_New */
; 127  :     PyObject_INIT(op, &PyFloat_Type);

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 PyObject_INIT

; 128  :     op->ob_fval = fval;
; 129  :     return (PyObject *) op;

  00048	48 8b c3	 mov	 rax, rbx
  0004b	f2 0f 11 73 60	 movsdx	 QWORD PTR [rbx+96], xmm6

; 130  : }

  00050	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
$LN3@PyFloat_Fr:

; 121  :     } else {
; 122  :         op = (PyFloatObject*) PyObject_MALLOC(sizeof(PyFloatObject));

  0005b	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00060	e8 00 00 00 00	 call	 PyObject_Malloc
  00065	48 8b d8	 mov	 rbx, rax

; 123  :         if (!op)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 cc		 jne	 SHORT $LN1@PyFloat_Fr

; 130  : }

  0006d	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5b		 pop	 rbx
  00077	e9 00 00 00 00	 jmp	 PyErr_NoMemory
PyFloat_FromDouble ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@ ; `string'
PUBLIC	??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@ ; `string'
PUBLIC	PyFloat_FromString
EXTRN	PyErr_Occurred:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyOS_string_to_double:PROC
EXTRN	_Py_ctype_table:BYTE
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_AsCharBuffer:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	_PyUnicode_TransformDecimalAndSpaceToASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_FromString DD imagerel $LN28
	DD	imagerel $LN28+141
	DD	imagerel $unwind$PyFloat_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyFloat_FromString DD imagerel $LN28+141
	DD	imagerel $LN28+258
	DD	imagerel $chain$1$PyFloat_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyFloat_FromString DD imagerel $LN28+258
	DD	imagerel $LN28+326
	DD	imagerel $chain$2$PyFloat_FromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyFloat_FromString DD imagerel $LN28+326
	DD	imagerel $LN28+345
	DD	imagerel $chain$3$PyFloat_FromString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyFloat_FromString DD 021H
	DD	imagerel $LN28
	DD	imagerel $LN28+141
	DD	imagerel $unwind$PyFloat_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyFloat_FromString DD 020021H
	DD	026800H
	DD	imagerel $LN28
	DD	imagerel $LN28+141
	DD	imagerel $unwind$PyFloat_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyFloat_FromString DD 041621H
	DD	026816H
	DD	0d3405H
	DD	imagerel $LN28
	DD	imagerel $LN28+141
	DD	imagerel $unwind$PyFloat_FromString
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_FromString DD 040801H
	DD	070045208H
	DD	050026003H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@
CONST	SEGMENT
??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@ DB 'could not c'
	DB	'onvert string to float: %R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@
CONST	SEGMENT
??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@ DB 'float'
	DB	'() argument must be a string or a number', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyFloat_FromString
_TEXT	SEGMENT
s$ = 80
v$ = 80
len$ = 88
end$ = 96
PyFloat_FromString PROC					; COMDAT

; 134  : {

$LN28:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 135  :     const char *s, *last, *end;
; 136  :     double x;
; 137  :     PyObject *s_buffer = NULL;
; 138  :     Py_ssize_t len;
; 139  :     PyObject *result = NULL;
; 140  : 
; 141  :     if (PyUnicode_Check(v)) {

  00008	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000c	33 f6		 xor	 esi, esi
  0000e	48 8b e9	 mov	 rbp, rcx
  00011	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0001b	8b fe		 mov	 edi, esi
  0001d	74 39		 je	 SHORT $LN17@PyFloat_Fr@2

; 142  :         s_buffer = _PyUnicode_TransformDecimalAndSpaceToASCII(v);

  0001f	e8 00 00 00 00	 call	 _PyUnicode_TransformDecimalAndSpaceToASCII
  00024	48 8b f8	 mov	 rdi, rax

; 143  :         if (s_buffer == NULL)

  00027	48 85 c0	 test	 rax, rax

; 144  :             return NULL;

  0002a	74 22		 je	 SHORT $LN27@PyFloat_Fr@2

; 145  :         s = PyUnicode_AsUTF8AndSize(s_buffer, &len);

  0002c	48 8d 54 24 58	 lea	 rdx, QWORD PTR len$[rsp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00039	48 8b c8	 mov	 rcx, rax
  0003c	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 146  :         if (s == NULL) {

  00041	48 85 c0	 test	 rax, rax
  00044	75 47		 jne	 SHORT $LN13@PyFloat_Fr@2

; 147  :             Py_DECREF(s_buffer);

  00046	48 8b cf	 mov	 rcx, rdi
  00049	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@PyFloat_Fr@2:

; 148  :             return NULL;

  0004e	33 c0		 xor	 eax, eax

; 179  : }

  00050	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00054	5f		 pop	 rdi
  00055	5e		 pop	 rsi
  00056	5d		 pop	 rbp
  00057	c3		 ret	 0
$LN17@PyFloat_Fr@2:

; 149  :         }
; 150  :     }
; 151  :     else if (PyObject_AsCharBuffer(v, &s, &len)) {

  00058	4c 8d 44 24 58	 lea	 r8, QWORD PTR len$[rsp]
  0005d	48 8d 54 24 50	 lea	 rdx, QWORD PTR s$[rsp]
  00062	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00067	85 c0		 test	 eax, eax
  00069	74 1d		 je	 SHORT $LN24@PyFloat_Fr@2

; 152  :         PyErr_SetString(PyExc_TypeError,
; 153  :             "float() argument must be a string or a number");

  0006b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KCGIELOE@float?$CI?$CJ?5argument?5must?5be?5a?5strin@
  00079	e8 00 00 00 00	 call	 PyErr_SetString

; 154  :         return NULL;

  0007e	33 c0		 xor	 eax, eax

; 179  : }

  00080	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00084	5f		 pop	 rdi
  00085	5e		 pop	 rsi
  00086	5d		 pop	 rbp
  00087	c3		 ret	 0
$LN24@PyFloat_Fr@2:

; 154  :         return NULL;

  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
$LN13@PyFloat_Fr@2:
  0008d	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx

; 155  :     }
; 156  :     last = s + len;

  00092	48 8b 5c 24 58	 mov	 rbx, QWORD PTR len$[rsp]

; 157  :     /* strip space */
; 158  :     while (s < last && Py_ISSPACE(*s))

  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_ctype_table
  0009e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  000a3	48 03 d9	 add	 rbx, rcx
  000a6	48 3b cb	 cmp	 rcx, rbx
  000a9	73 1c		 jae	 SHORT $LN25@PyFloat_Fr@2
  000ab	0f 1f 44 00 00	 npad	 5
$LL12@PyFloat_Fr@2:
  000b0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000b3	41 f6 04 80 08	 test	 BYTE PTR [r8+rax*4], 8
  000b8	74 0d		 je	 SHORT $LN25@PyFloat_Fr@2

; 159  :         s++;

  000ba	48 ff c1	 inc	 rcx
  000bd	48 89 4c 24 50	 mov	 QWORD PTR s$[rsp], rcx
  000c2	48 3b cb	 cmp	 rcx, rbx
  000c5	72 e9		 jb	 SHORT $LL12@PyFloat_Fr@2
$LN25@PyFloat_Fr@2:

; 160  :     while (s < last - 1 && Py_ISSPACE(last[-1]))

  000c7	48 8d 53 ff	 lea	 rdx, QWORD PTR [rbx-1]
  000cb	48 3b ca	 cmp	 rcx, rdx
  000ce	73 15		 jae	 SHORT $LN26@PyFloat_Fr@2
$LL10@PyFloat_Fr@2:
  000d0	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000d3	41 f6 04 80 08	 test	 BYTE PTR [r8+rax*4], 8
  000d8	74 0b		 je	 SHORT $LN26@PyFloat_Fr@2

; 161  :         last--;

  000da	48 ff ca	 dec	 rdx
  000dd	48 ff cb	 dec	 rbx
  000e0	48 3b ca	 cmp	 rcx, rdx
  000e3	72 eb		 jb	 SHORT $LL10@PyFloat_Fr@2
$LN26@PyFloat_Fr@2:

; 162  :     /* We don't care about overflow or underflow.  If the platform
; 163  :      * supports them, infinities and signed zeroes (on underflow) are
; 164  :      * fine. */
; 165  :     x = PyOS_string_to_double(s, (char **)&end, NULL);

  000e5	48 8d 54 24 60	 lea	 rdx, QWORD PTR end$[rsp]
  000ea	45 33 c0	 xor	 r8d, r8d
  000ed	e8 00 00 00 00	 call	 PyOS_string_to_double

; 166  :     if (end != last) {

  000f2	48 39 5c 24 60	 cmp	 QWORD PTR end$[rsp], rbx
  000f7	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000fc	66 0f 28 f0	 movapd	 xmm6, xmm0
  00100	74 18		 je	 SHORT $LN8@PyFloat_Fr@2

; 167  :         PyErr_Format(PyExc_ValueError,
; 168  :                      "could not convert string to float: "
; 169  :                      "%R", v);

  00102	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CENPHJMO@could?5not?5convert?5string?5to?5floa@
  00110	4c 8b c5	 mov	 r8, rbp
  00113	e8 00 00 00 00	 call	 PyErr_Format

; 170  :         result = NULL;

  00118	eb 22		 jmp	 SHORT $LN4@PyFloat_Fr@2
$LN8@PyFloat_Fr@2:

; 171  :     }
; 172  :     else if (x == -1.0 && PyErr_Occurred())

  0011a	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00122	7a 0c		 jp	 SHORT $LN6@PyFloat_Fr@2
  00124	75 0a		 jne	 SHORT $LN6@PyFloat_Fr@2
  00126	e8 00 00 00 00	 call	 PyErr_Occurred
  0012b	48 85 c0	 test	 rax, rax

; 173  :         result = NULL;
; 174  :     else

  0012e	75 0c		 jne	 SHORT $LN4@PyFloat_Fr@2
$LN6@PyFloat_Fr@2:

; 175  :         result = PyFloat_FromDouble(x);

  00130	66 0f 28 c6	 movapd	 xmm0, xmm6
  00134	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00139	48 8b f0	 mov	 rsi, rax
$LN4@PyFloat_Fr@2:

; 176  : 
; 177  :     Py_XDECREF(s_buffer);

  0013c	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00141	48 85 ff	 test	 rdi, rdi
  00144	74 08		 je	 SHORT $LN3@PyFloat_Fr@2
  00146	48 8b cf	 mov	 rcx, rdi
  00149	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyFloat_Fr@2:

; 178  :     return result;

  0014e	48 8b c6	 mov	 rax, rsi

; 179  : }

  00151	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00155	5f		 pop	 rdi
  00156	5e		 pop	 rsi
  00157	5d		 pop	 rbp
  00158	c3		 ret	 0
PyFloat_FromString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@DJCJEHLE@float_dealloc?$AA@		; `string'
PUBLIC	??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@ ; `string'
EXTRN	PyObject_Free:PROC
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_dealloc DD imagerel float_dealloc
	DD	imagerel float_dealloc+133
	DD	imagerel $unwind$float_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_dealloc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0O@DJCJEHLE@float_dealloc?$AA@
CONST	SEGMENT
??_C@_0O@DJCJEHLE@float_dealloc?$AA@ DB 'float_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@ DB '..\Objects\floa'
	DB	'tobject.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_dealloc
_TEXT	SEGMENT
op$ = 48
float_dealloc PROC					; COMDAT

; 183  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 184  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN4@float_deal
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DJCJEHLE@float_dealloc?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 b8 00 00
	00		 mov	 r8d, 184		; 000000b8H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@float_deal:

; 185  :     if (PyFloat_CheckExact(op)) {

  0002e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFloat_Type
  00039	48 3b c1	 cmp	 rax, rcx
  0003c	75 38		 jne	 SHORT $LN3@float_deal

; 186  :         if (numfree >= PyFloat_MAXFREELIST)  {

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numfree
  00044	83 f8 64	 cmp	 eax, 100		; 00000064H
  00047	7c 0d		 jl	 SHORT $LN2@float_deal

; 187  :             PyObject_FREE(op);

  00049	48 8b cb	 mov	 rcx, rbx

; 196  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	e9 00 00 00 00	 jmp	 PyObject_Free
$LN2@float_deal:

; 188  :             return;
; 189  :         }
; 190  :         numfree++;

  00056	ff c0		 inc	 eax
  00058	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 191  :         Py_TYPE(op) = (struct _typeobject *)free_list;

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR free_list

; 192  :         free_list = op;

  00065	48 89 1d 00 00
	00 00		 mov	 QWORD PTR free_list, rbx
  0006c	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax

; 196  : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
$LN3@float_deal:

; 193  :     }
; 194  :     else
; 195  :         Py_TYPE(op)->tp_free((PyObject *)op);

  00076	48 8b cb	 mov	 rcx, rbx

; 196  : }

  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5b		 pop	 rbx
  0007e	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
float_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@	; `string'
PUBLIC	??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@ ; `string'
PUBLIC	PyFloat_AsDouble
EXTRN	PyErr_BadArgument:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_AsDouble DD imagerel $LN14
	DD	imagerel $LN14+22
	DD	imagerel $unwind$PyFloat_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyFloat_AsDouble DD imagerel $LN14+22
	DD	imagerel $LN14+159
	DD	imagerel $chain$0$PyFloat_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyFloat_AsDouble DD imagerel $LN14+159
	DD	imagerel $LN14+197
	DD	imagerel $chain$3$PyFloat_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyFloat_AsDouble DD imagerel $LN14+197
	DD	imagerel $LN14+222
	DD	imagerel $chain$5$PyFloat_AsDouble
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyFloat_AsDouble DD imagerel $LN14+222
	DD	imagerel $LN14+241
	DD	imagerel $chain$6$PyFloat_AsDouble
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyFloat_AsDouble DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+22
	DD	imagerel $unwind$PyFloat_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyFloat_AsDouble DD 020021H
	DD	087400H
	DD	imagerel $LN14
	DD	imagerel $LN14+22
	DD	imagerel $unwind$PyFloat_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyFloat_AsDouble DD 040821H
	DD	026808H
	DD	087400H
	DD	imagerel $LN14
	DD	imagerel $LN14+22
	DD	imagerel $unwind$PyFloat_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyFloat_AsDouble DD 020521H
	DD	087405H
	DD	imagerel $LN14
	DD	imagerel $LN14+22
	DD	imagerel $unwind$PyFloat_AsDouble
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_AsDouble DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@ DB 'a float is required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@
CONST	SEGMENT
??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@ DB 'nb_float sho'
	DB	'uld return float object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyFloat_AsDouble
_TEXT	SEGMENT
op$ = 64
PyFloat_AsDouble PROC					; COMDAT

; 200  : {

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 201  :     PyNumberMethods *nb;
; 202  :     PyFloatObject *fo;
; 203  :     double val;
; 204  : 
; 205  :     if (op && PyFloat_Check(op))

  00009	48 85 c9	 test	 rcx, rcx
  0000c	0f 84 cc 00 00
	00		 je	 $LN10@PyFloat_As
  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0001b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:PyFloat_Type
  00022	48 3b cf	 cmp	 rcx, rdi
  00025	0f 84 a3 00 00
	00		 je	 $LN6@PyFloat_As
  0002b	48 8b d7	 mov	 rdx, rdi
  0002e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00033	85 c0		 test	 eax, eax
  00035	0f 85 93 00 00
	00		 jne	 $LN6@PyFloat_As

; 211  :     }
; 212  : 
; 213  :     if ((nb = Py_TYPE(op)->tp_as_number) == NULL || nb->nb_float == NULL) {

  0003b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0003f	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  00046	48 85 c9	 test	 rcx, rcx
  00049	74 7a		 je	 SHORT $LN3@PyFloat_As
  0004b	48 8b 81 90 00
	00 00		 mov	 rax, QWORD PTR [rcx+144]
  00052	48 85 c0	 test	 rax, rax
  00055	74 6e		 je	 SHORT $LN3@PyFloat_As

; 216  :     }
; 217  : 
; 218  :     fo = (PyFloatObject*) (*nb->nb_float) (op);

  00057	48 8b cb	 mov	 rcx, rbx
  0005a	ff d0		 call	 rax
  0005c	48 8b d8	 mov	 rbx, rax

; 219  :     if (fo == NULL)

  0005f	48 85 c0	 test	 rax, rax

; 220  :         return -1;

  00062	74 28		 je	 SHORT $LN12@PyFloat_As

; 221  :     if (!PyFloat_Check(fo)) {

  00064	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00068	48 3b cf	 cmp	 rcx, rdi
  0006b	74 32		 je	 SHORT $LN1@PyFloat_As
  0006d	48 8b d7	 mov	 rdx, rdi
  00070	e8 00 00 00 00	 call	 PyType_IsSubtype
  00075	85 c0		 test	 eax, eax
  00077	75 26		 jne	 SHORT $LN1@PyFloat_As

; 222  :         PyErr_SetString(PyExc_TypeError,
; 223  :                         "nb_float should return float object");

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@LMCDCGIG@nb_float?5should?5return?5float?5obj@
$LN13@PyFloat_As:
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00087	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@PyFloat_As:

; 224  :         return -1;

  0008c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  00094	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 231  : }

  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
$LN1@PyFloat_As:

; 225  :     }
; 226  : 
; 227  :     val = PyFloat_AS_DOUBLE(fo);
; 228  :     Py_DECREF(fo);

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  000a7	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef
  000b1	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 229  : 
; 230  :     return val;

  000b6	66 0f 28 c6	 movapd	 xmm0, xmm6
  000ba	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]

; 231  : }

  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	5b		 pop	 rbx
  000c4	c3		 ret	 0
$LN3@PyFloat_As:

; 214  :         PyErr_SetString(PyExc_TypeError, "a float is required");

  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EPAFCIDD@a?5float?5is?5required?$AA@

; 215  :         return -1;

  000cc	eb b2		 jmp	 SHORT $LN13@PyFloat_As
$LN6@PyFloat_As:

; 206  :         return PyFloat_AS_DOUBLE((PyFloatObject*) op);

  000ce	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]
  000d3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 231  : }

  000d8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dc	5b		 pop	 rbx
  000dd	c3		 ret	 0
$LN10@PyFloat_As:

; 207  : 
; 208  :     if (op == NULL) {
; 209  :         PyErr_BadArgument();

  000de	e8 00 00 00 00	 call	 PyErr_BadArgument

; 210  :         return -1;

  000e3	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000

; 231  : }

  000eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ef	5b		 pop	 rbx
  000f0	c3		 ret	 0
PyFloat_AsDouble ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyLong_AsDouble:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$convert_to_double DD imagerel convert_to_double
	DD	imagerel convert_to_double+189
	DD	imagerel $unwind$convert_to_double
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convert_to_double DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
xdata	ENDS
;	COMDAT convert_to_double
_TEXT	SEGMENT
v$ = 64
dbl$ = 72
convert_to_double PROC					; COMDAT

; 249  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 250  :     register PyObject *obj = *v;

  0000d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00010	48 8b fa	 mov	 rdi, rdx

; 251  : 
; 252  :     if (PyLong_Check(obj)) {

  00013	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00017	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00021	74 41		 je	 SHORT $LN3@convert_to

; 253  :         *dbl = PyLong_AsDouble(obj);

  00023	e8 00 00 00 00	 call	 PyLong_AsDouble

; 254  :         if (*dbl == -1.0 && PyErr_Occurred()) {

  00028	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00030	f2 0f 11 07	 movsdx	 QWORD PTR [rdi], xmm0
  00034	7a 21		 jp	 SHORT $LN2@convert_to
  00036	75 1f		 jne	 SHORT $LN2@convert_to
  00038	e8 00 00 00 00	 call	 PyErr_Occurred
  0003d	48 85 c0	 test	 rax, rax
  00040	74 15		 je	 SHORT $LN2@convert_to

; 255  :             *v = NULL;

  00042	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0

; 262  :         return -1;

  00049	83 c8 ff	 or	 eax, -1

; 265  : }

  0004c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN2@convert_to:

; 263  :     }
; 264  :     return 0;

  00057	33 c0		 xor	 eax, eax

; 265  : }

  00059	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
$LN3@convert_to:

; 256  :             return -1;
; 257  :         }
; 258  :     }
; 259  :     else {
; 260  :         Py_INCREF(Py_NotImplemented);

  00064	e8 00 00 00 00	 call	 _Py_PXCTX
  00069	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NotImplementedStruct
  00070	85 c0		 test	 eax, eax
  00072	75 38		 jne	 SHORT $LN7@convert_to
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00082	4c 8b cf	 mov	 r9, rdi
  00085	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 09		 jne	 SHORT $LN6@convert_to
  0009c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  000a3	74 07		 je	 SHORT $LN7@convert_to
$LN6@convert_to:
  000a5	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@convert_to:

; 261  :         *v = Py_NotImplemented;

  000ac	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 265  : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	83 c8 ff	 or	 eax, -1
  000b7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
convert_to_double ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
EXTRN	_PyUnicode_FromASCII:PROC
EXTRN	PyOS_double_to_string:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_repr DD imagerel float_repr
	DD	imagerel float_repr+110
	DD	imagerel $unwind$float_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_repr DD 043f01H
	DD	08743fH
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT float_repr
_TEXT	SEGMENT
v$ = 64
float_repr PROC						; COMDAT

; 269  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 270  :     PyObject *result;
; 271  :     char *buf;
; 272  : 
; 273  :     buf = PyOS_double_to_string(PyFloat_AS_DOUBLE(v),
; 274  :                                 'r', 0,
; 275  :                                 Py_DTSF_ADD_DOT_0,
; 276  :                                 NULL);

  00006	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  0000b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00011	45 33 c0	 xor	 r8d, r8d
  00014	b2 72		 mov	 dl, 114			; 00000072H
  00016	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0001f	e8 00 00 00 00	 call	 PyOS_double_to_string
  00024	48 8b d8	 mov	 rbx, rax

; 277  :     if (!buf)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 0a		 jne	 SHORT $LN1@float_repr

; 282  : }

  0002c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00030	5b		 pop	 rbx
  00031	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN1@float_repr:

; 278  :         return PyErr_NoMemory();
; 279  :     result = _PyUnicode_FromASCII(buf, strlen(buf));

  00036	48 83 c9 ff	 or	 rcx, -1
  0003a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003f	33 c0		 xor	 eax, eax
  00041	48 8b fb	 mov	 rdi, rbx
  00044	f2 ae		 repne scasb
  00046	48 f7 d1	 not	 rcx
  00049	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 _PyUnicode_FromASCII

; 280  :     PyMem_Free(buf);

  00055	48 8b cb	 mov	 rcx, rbx
  00058	48 8b f8	 mov	 rdi, rax
  0005b	e8 00 00 00 00	 call	 PyMem_Free

; 281  :     return result;

  00060	48 8b c7	 mov	 rax, rdi
  00063	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 282  : }

  00068	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
float_repr ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__mask@@NegDouble@
PUBLIC	__real@4000000000000000
EXTRN	PyBool_FromLong:PROC
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyNumber_Or:PROC
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyLong_FromDouble:PROC
EXTRN	__imp_modf:PROC
EXTRN	PyNumber_Negative:PROC
EXTRN	__imp_frexp:PROC
EXTRN	_Py_SwappedOp:BYTE
EXTRN	PyErr_Clear:PROC
EXTRN	_PyLong_NumBits:PROC
EXTRN	_PyLong_Sign:PROC
EXTRN	__imp__finite:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_richcompare DD imagerel float_richcompare
	DD	imagerel float_richcompare+900
	DD	imagerel $unwind$float_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_richcompare DD 0e3501H
	DD	037835H
	DD	04681bH
	DD	0135416H
	DD	0123416H
	DD	0e0129216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
CONST	ENDS
;	COMDAT float_richcompare
_TEXT	SEGMENT
exponent$20403 = 128
v$ = 128
intpart$20425 = 136
w$ = 136
op$ = 144
float_richcompare PROC					; COMDAT

; 301  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00016	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6

; 302  :     double i, j;
; 303  :     int r = 0;
; 304  : 
; 305  :     assert(PyFloat_Check(v));
; 306  :     i = PyFloat_AS_DOUBLE(v);

  0001b	f2 0f 10 71 60	 movsdx	 xmm6, QWORD PTR [rcx+96]

; 307  : 
; 308  :     /* Switch on the type of w.  Set i and j to doubles to be compared,
; 309  :      * and op to the richcomp to use.
; 310  :      */
; 311  :     if (PyFloat_Check(w))

  00020	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0002e	33 db		 xor	 ebx, ebx
  00030	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  00035	4d 63 e8	 movsxd	 r13, r8d
  00038	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
  0003f	48 3b ca	 cmp	 rcx, rdx
  00042	0f 84 a7 02 00
	00		 je	 $LN45@float_rich
  00048	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004d	85 c0		 test	 eax, eax
  0004f	0f 85 9a 02 00
	00		 jne	 $LN45@float_rich

; 313  : 
; 314  :     else if (!Py_IS_FINITE(i)) {

  00055	66 0f 28 c6	 movapd	 xmm0, xmm6
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0005f	85 c0		 test	 eax, eax

; 315  :         if (PyLong_Check(w))

  00061	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00065	75 19		 jne	 SHORT $LN43@float_rich
  00067	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00071	0f 84 2a 02 00
	00		 je	 $Unimplemented$20396

; 316  :             /* If i is an infinity, its magnitude exceeds any
; 317  :              * finite integer, so it doesn't matter which int we
; 318  :              * compare i with.  If i is a NaN, similarly.
; 319  :              */
; 320  :             j = 0.0;

  00077	66 0f 57 c0	 xorpd	 xmm0, xmm0

; 321  :         else
; 322  :             goto Unimplemented;
; 323  :     }
; 324  : 
; 325  :     else if (PyLong_Check(w)) {

  0007b	e9 74 02 00 00	 jmp	 $Compare$20407
$LN43@float_rich:
  00080	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0008a	0f 84 11 02 00
	00		 je	 $Unimplemented$20396

; 326  :         int vsign = i == 0.0 ? 0 : i < 0.0 ? -1 : 1;

  00090	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00094	66 0f 2e f7	 ucomisd xmm6, xmm7
  00098	7a 06		 jp	 SHORT $LN51@float_rich
  0009a	75 04		 jne	 SHORT $LN51@float_rich
  0009c	8b f3		 mov	 esi, ebx
  0009e	eb 10		 jmp	 SHORT $LN50@float_rich
$LN51@float_rich:
  000a0	66 0f 2f fe	 comisd	 xmm7, xmm6
  000a4	76 05		 jbe	 SHORT $LN49@float_rich
  000a6	83 ce ff	 or	 esi, -1
  000a9	eb 05		 jmp	 SHORT $LN50@float_rich
$LN49@float_rich:
  000ab	be 01 00 00 00	 mov	 esi, 1
$LN50@float_rich:

; 327  :         int wsign = _PyLong_Sign(w);

  000b0	48 8b cf	 mov	 rcx, rdi
  000b3	e8 00 00 00 00	 call	 _PyLong_Sign
  000b8	44 8b e0	 mov	 r12d, eax

; 328  :         size_t nbits;
; 329  :         int exponent;
; 330  : 
; 331  :         if (vsign != wsign) {

  000bb	3b f0		 cmp	 esi, eax
  000bd	74 16		 je	 SHORT $LN38@float_rich

; 332  :             /* Magnitudes are irrelevant -- the signs alone
; 333  :              * determine the outcome.
; 334  :              */
; 335  :             i = (double)vsign;

  000bf	66 0f 6e f6	 movd	 xmm6, esi

; 336  :             j = (double)wsign;

  000c3	66 41 0f 6e c4	 movd	 xmm0, r12d
  000c8	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  000cc	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 337  :             goto Compare;

  000d0	e9 1f 02 00 00	 jmp	 $Compare$20407
$LN38@float_rich:

; 338  :         }
; 339  :         /* The signs are the same. */
; 340  :         /* Convert w to a double if it fits.  In particular, 0 fits. */
; 341  :         nbits = _PyLong_NumBits(w);

  000d5	48 8b cf	 mov	 rcx, rdi
  000d8	e8 00 00 00 00	 call	 _PyLong_NumBits
  000dd	48 8b e8	 mov	 rbp, rax

; 342  :         if (nbits == (size_t)-1 && PyErr_Occurred()) {

  000e0	48 83 f8 ff	 cmp	 rax, -1
  000e4	75 2d		 jne	 SHORT $LN37@float_rich
  000e6	e8 00 00 00 00	 call	 PyErr_Occurred
  000eb	48 85 c0	 test	 rax, rax
  000ee	74 36		 je	 SHORT $LN36@float_rich

; 343  :             /* This long is so large that size_t isn't big enough
; 344  :              * to hold the # of bits.  Replace with little doubles
; 345  :              * that give the same outcome -- w is so large that
; 346  :              * its magnitude must exceed the magnitude of any
; 347  :              * finite float.
; 348  :              */
; 349  :             PyErr_Clear();

  000f0	e8 00 00 00 00	 call	 PyErr_Clear

; 350  :             i = (double)vsign;
; 351  :             assert(wsign != 0);
; 352  :             j = wsign * 2.0;

  000f5	66 41 0f 6e c4	 movd	 xmm0, r12d
  000fa	66 0f 6e f6	 movd	 xmm6, esi
  000fe	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00102	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  00106	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000

; 353  :             goto Compare;

  0010e	e9 e1 01 00 00	 jmp	 $Compare$20407
$LN37@float_rich:

; 354  :         }
; 355  :         if (nbits <= 48) {

  00113	48 83 f8 30	 cmp	 rax, 48			; 00000030H
  00117	77 0d		 ja	 SHORT $LN36@float_rich

; 356  :             j = PyLong_AsDouble(w);

  00119	48 8b cf	 mov	 rcx, rdi
  0011c	e8 00 00 00 00	 call	 PyLong_AsDouble

; 357  :             /* It's impossible that <= 48 bits overflowed. */
; 358  :             assert(j != -1.0 || ! PyErr_Occurred());
; 359  :             goto Compare;

  00121	e9 ce 01 00 00	 jmp	 $Compare$20407
$LN36@float_rich:

; 360  :         }
; 361  :         assert(wsign != 0); /* else nbits was 0 */
; 362  :         assert(vsign != 0); /* if vsign were 0, then since wsign is
; 363  :                              * not 0, we would have taken the
; 364  :                              * vsign != wsign branch at the start */
; 365  :         /* We want to work with non-negative numbers. */
; 366  :         if (vsign < 0) {

  00126	85 f6		 test	 esi, esi
  00128	79 10		 jns	 SHORT $LN35@float_rich

; 367  :             /* "Multiply both sides" by -1; this also swaps the
; 368  :              * comparator.
; 369  :              */
; 370  :             i = -i;

  0012a	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@

; 371  :             op = _Py_SwappedOp[op];

  00132	47 8b ac ae 00
	00 00 00	 mov	 r13d, DWORD PTR _Py_SwappedOp[r14+r13*4]
$LN35@float_rich:

; 372  :         }
; 373  :         assert(i > 0.0);
; 374  :         (void) frexp(i, &exponent);

  0013a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR exponent$20403[rsp]
  00142	66 0f 28 c6	 movapd	 xmm0, xmm6
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 375  :         /* exponent is the # of bits in v before the radix point;
; 376  :          * we know that nbits (the # of bits in w) > 48 at this point
; 377  :          */
; 378  :         if (exponent < 0 || (size_t)exponent < nbits) {

  0014c	4c 63 9c 24 80
	00 00 00	 movsxd	 r11, DWORD PTR exponent$20403[rsp]
  00154	45 85 db	 test	 r11d, r11d
  00157	0f 88 32 01 00
	00		 js	 $LN33@float_rich
  0015d	4c 3b dd	 cmp	 r11, rbp
  00160	0f 82 29 01 00
	00		 jb	 $LN33@float_rich

; 382  :         }
; 383  :         if ((size_t)exponent > nbits) {

  00166	76 15		 jbe	 SHORT $LN32@float_rich

; 384  :             i = 2.0;

  00168	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@4000000000000000

; 385  :             j = 1.0;

  00170	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000

; 386  :             goto Compare;

  00178	e9 77 01 00 00	 jmp	 $Compare$20407
$LN32@float_rich:

; 387  :         }
; 388  :         /* v and w have the same number of bits before the radix
; 389  :          * point.  Construct two ints that have the same comparison
; 390  :          * outcome.
; 391  :          */
; 392  :         {
; 393  :             double fracpart;
; 394  :             double intpart;
; 395  :             PyObject *result = NULL;
; 396  :             PyObject *one = NULL;

  0017d	48 8b eb	 mov	 rbp, rbx

; 397  :             PyObject *vv = NULL;
; 398  :             PyObject *ww = w;
; 399  : 
; 400  :             if (wsign < 0) {
; 401  :                 ww = PyNumber_Negative(w);

  00180	48 8b cf	 mov	 rcx, rdi
  00183	45 85 e4	 test	 r12d, r12d
  00186	79 13		 jns	 SHORT $LN31@float_rich
  00188	e8 00 00 00 00	 call	 PyNumber_Negative
  0018d	48 8b f8	 mov	 rdi, rax

; 402  :                 if (ww == NULL)

  00190	48 85 c0	 test	 rax, rax
  00193	0f 84 ee 00 00
	00		 je	 $LN12@float_rich

; 403  :                     goto Error;
; 404  :             }
; 405  :             else

  00199	eb 05		 jmp	 SHORT $LN29@float_rich
$LN31@float_rich:

; 406  :                 Py_INCREF(ww);

  0019b	e8 00 00 00 00	 call	 _Py_IncRef
$LN29@float_rich:

; 407  : 
; 408  :             fracpart = modf(i, &intpart);

  001a0	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR intpart$20425[rsp]
  001a8	66 0f 28 c6	 movapd	 xmm0, xmm6
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  001b2	66 0f 28 f0	 movapd	 xmm6, xmm0

; 409  :             vv = PyLong_FromDouble(intpart);

  001b6	f2 0f 10 84 24
	88 00 00 00	 movsdx	 xmm0, QWORD PTR intpart$20425[rsp]
  001bf	e8 00 00 00 00	 call	 PyLong_FromDouble
  001c4	48 8b f0	 mov	 rsi, rax

; 410  :             if (vv == NULL)

  001c7	48 85 c0	 test	 rax, rax
  001ca	0f 84 9d 00 00
	00		 je	 $LN20@float_rich

; 411  :                 goto Error;
; 412  : 
; 413  :             if (fracpart != 0.0) {

  001d0	66 0f 2e f7	 ucomisd xmm6, xmm7
  001d4	7a 02		 jp	 SHORT $LN71@float_rich
  001d6	74 6c		 je	 SHORT $LN27@float_rich
$LN71@float_rich:

; 414  :                 /* Shift left, and or a 1 bit into vv
; 415  :                  * to represent the lost fraction.
; 416  :                  */
; 417  :                 PyObject *temp;
; 418  : 
; 419  :                 one = PyLong_FromLong(1);

  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	e8 00 00 00 00	 call	 PyLong_FromLong
  001e2	48 8b e8	 mov	 rbp, rax

; 420  :                 if (one == NULL)

  001e5	48 85 c0	 test	 rax, rax
  001e8	74 76		 je	 SHORT $Error$20436

; 421  :                     goto Error;
; 422  : 
; 423  :                 temp = PyNumber_Lshift(ww, one);

  001ea	48 8b d0	 mov	 rdx, rax
  001ed	48 8b cf	 mov	 rcx, rdi
  001f0	e8 00 00 00 00	 call	 PyNumber_Lshift
  001f5	4c 8b e0	 mov	 r12, rax

; 424  :                 if (temp == NULL)

  001f8	48 85 c0	 test	 rax, rax
  001fb	74 63		 je	 SHORT $Error$20436

; 425  :                     goto Error;
; 426  :                 Py_DECREF(ww);

  001fd	48 8b cf	 mov	 rcx, rdi
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 427  :                 ww = temp;
; 428  : 
; 429  :                 temp = PyNumber_Lshift(vv, one);

  00205	48 8b d5	 mov	 rdx, rbp
  00208	48 8b ce	 mov	 rcx, rsi
  0020b	49 8b fc	 mov	 rdi, r12
  0020e	e8 00 00 00 00	 call	 PyNumber_Lshift
  00213	4c 8b e0	 mov	 r12, rax

; 430  :                 if (temp == NULL)

  00216	48 85 c0	 test	 rax, rax
  00219	74 45		 je	 SHORT $Error$20436

; 431  :                     goto Error;
; 432  :                 Py_DECREF(vv);

  0021b	48 8b ce	 mov	 rcx, rsi
  0021e	e8 00 00 00 00	 call	 _Py_DecRef

; 433  :                 vv = temp;
; 434  : 
; 435  :                 temp = PyNumber_Or(vv, one);

  00223	48 8b d5	 mov	 rdx, rbp
  00226	49 8b cc	 mov	 rcx, r12
  00229	49 8b f4	 mov	 rsi, r12
  0022c	e8 00 00 00 00	 call	 PyNumber_Or
  00231	4c 8b e0	 mov	 r12, rax

; 436  :                 if (temp == NULL)

  00234	48 85 c0	 test	 rax, rax
  00237	74 27		 je	 SHORT $Error$20436

; 437  :                     goto Error;
; 438  :                 Py_DECREF(vv);

  00239	48 8b ce	 mov	 rcx, rsi
  0023c	e8 00 00 00 00	 call	 _Py_DecRef

; 439  :                 vv = temp;

  00241	49 8b f4	 mov	 rsi, r12
$LN27@float_rich:

; 440  :             }
; 441  : 
; 442  :             r = PyObject_RichCompareBool(vv, ww, op);

  00244	45 8b c5	 mov	 r8d, r13d
  00247	48 8b d7	 mov	 rdx, rdi
  0024a	48 8b ce	 mov	 rcx, rsi
  0024d	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 443  :             if (r < 0)

  00252	85 c0		 test	 eax, eax
  00254	78 0a		 js	 SHORT $Error$20436

; 444  :                 goto Error;
; 445  :             result = PyBool_FromLong(r);

  00256	8b c8		 mov	 ecx, eax
  00258	e8 00 00 00 00	 call	 PyBool_FromLong
  0025d	48 8b d8	 mov	 rbx, rax
$Error$20436:

; 446  :          Error:
; 447  :             Py_XDECREF(vv);

  00260	48 85 f6	 test	 rsi, rsi
  00263	74 08		 je	 SHORT $LN20@float_rich
  00265	48 8b ce	 mov	 rcx, rsi
  00268	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@float_rich:

; 448  :             Py_XDECREF(ww);

  0026d	48 85 ff	 test	 rdi, rdi
  00270	74 08		 je	 SHORT $LN16@float_rich
  00272	48 8b cf	 mov	 rcx, rdi
  00275	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@float_rich:

; 449  :             Py_XDECREF(one);

  0027a	48 85 ed	 test	 rbp, rbp
  0027d	74 08		 je	 SHORT $LN12@float_rich
  0027f	48 8b cd	 mov	 rcx, rbp
  00282	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@float_rich:

; 450  :             return result;

  00287	48 8b c3	 mov	 rax, rbx
  0028a	e9 b7 00 00 00	 jmp	 $LN47@float_rich
$LN33@float_rich:

; 379  :             i = 1.0;

  0028f	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3ff0000000000000

; 380  :             j = 2.0;

  00297	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000

; 381  :             goto Compare;

  0029f	eb 53		 jmp	 SHORT $Compare$20407
$Unimplemented$20396:

; 481  : 
; 482  :  Unimplemented:
; 483  :     Py_RETURN_NOTIMPLEMENTED;

  002a1	e8 00 00 00 00	 call	 _Py_PXCTX
  002a6	85 c0		 test	 eax, eax
  002a8	75 3c		 jne	 SHORT $LN66@float_rich
  002aa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  002b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002bf	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002c5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d2	85 c0		 test	 eax, eax
  002d4	75 09		 jne	 SHORT $LN65@float_rich
  002d6	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  002dd	74 07		 je	 SHORT $LN66@float_rich
$LN65@float_rich:
  002df	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN66@float_rich:
  002e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  002ed	eb 57		 jmp	 SHORT $LN47@float_rich
$LN45@float_rich:

; 312  :         j = PyFloat_AS_DOUBLE(w);

  002ef	f2 0f 10 47 60	 movsdx	 xmm0, QWORD PTR [rdi+96]
$Compare$20407:

; 451  :         }
; 452  :     } /* else if (PyLong_Check(w)) */
; 453  : 
; 454  :     else        /* w isn't float or int */
; 455  :         goto Unimplemented;
; 456  : 
; 457  :  Compare:
; 458  :     PyFPE_START_PROTECT("richcompare", return NULL)
; 459  :     switch (op) {

  002f4	41 83 fd 05	 cmp	 r13d, 5
  002f8	77 45		 ja	 SHORT $LN63@float_rich
  002fa	49 63 c5	 movsxd	 rax, r13d
  002fd	41 8b 8c 86 00
	00 00 00	 mov	 ecx, DWORD PTR $LN70@float_rich[r14+rax*4]
  00305	49 03 ce	 add	 rcx, r14
  00308	ff e1		 jmp	 rcx
$LN6@float_rich:

; 460  :     case Py_EQ:
; 461  :         r = i == j;

  0030a	66 0f 2e f0	 ucomisd xmm6, xmm0
  0030e	7a 2f		 jp	 SHORT $LN63@float_rich
  00310	75 2d		 jne	 SHORT $LN63@float_rich
  00312	eb 26		 jmp	 SHORT $LN72@float_rich
$LN5@float_rich:

; 462  :         break;
; 463  :     case Py_NE:
; 464  :         r = i != j;

  00314	66 0f 2e f0	 ucomisd xmm6, xmm0
  00318	7a 20		 jp	 SHORT $LN72@float_rich

; 465  :         break;

  0031a	74 23		 je	 SHORT $LN63@float_rich

; 462  :         break;
; 463  :     case Py_NE:
; 464  :         r = i != j;

  0031c	eb 1c		 jmp	 SHORT $LN72@float_rich
$LN4@float_rich:

; 466  :     case Py_LE:
; 467  :         r = i <= j;

  0031e	66 0f 2f c6	 comisd	 xmm0, xmm6
  00322	72 1b		 jb	 SHORT $LN63@float_rich
  00324	eb 14		 jmp	 SHORT $LN72@float_rich
$LN3@float_rich:

; 468  :         break;
; 469  :     case Py_GE:
; 470  :         r = i >= j;

  00326	66 0f 2f f0	 comisd	 xmm6, xmm0
  0032a	72 13		 jb	 SHORT $LN63@float_rich
  0032c	eb 0c		 jmp	 SHORT $LN72@float_rich
$LN2@float_rich:

; 471  :         break;
; 472  :     case Py_LT:
; 473  :         r = i < j;

  0032e	66 0f 2f c6	 comisd	 xmm0, xmm6
  00332	eb 04		 jmp	 SHORT $LN73@float_rich
$LN1@float_rich:

; 474  :         break;
; 475  :     case Py_GT:
; 476  :         r = i > j;

  00334	66 0f 2f f0	 comisd	 xmm6, xmm0
$LN73@float_rich:
  00338	76 05		 jbe	 SHORT $LN63@float_rich
$LN72@float_rich:
  0033a	bb 01 00 00 00	 mov	 ebx, 1
$LN63@float_rich:

; 477  :         break;
; 478  :     }
; 479  :     PyFPE_END_PROTECT(r)
; 480  :     return PyBool_FromLong(r);

  0033f	8b cb		 mov	 ecx, ebx
  00341	e8 00 00 00 00	 call	 PyBool_FromLong
$LN47@float_rich:

; 484  : }

  00346	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0034b	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
  00350	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00355	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00359	49 8b 6b 48	 mov	 rbp, QWORD PTR [r11+72]
  0035d	49 8b e3	 mov	 rsp, r11
  00360	41 5e		 pop	 r14
  00362	41 5d		 pop	 r13
  00364	41 5c		 pop	 r12
  00366	5f		 pop	 rdi
  00367	5e		 pop	 rsi
  00368	c3		 ret	 0
  00369	0f 1f 00	 npad	 3
$LN70@float_rich:
  0036c	00 00 00 00	 DD	 $LN2@float_rich
  00370	00 00 00 00	 DD	 $LN4@float_rich
  00374	00 00 00 00	 DD	 $LN6@float_rich
  00378	00 00 00 00	 DD	 $LN5@float_rich
  0037c	00 00 00 00	 DD	 $LN1@float_rich
  00380	00 00 00 00	 DD	 $LN3@float_rich
float_richcompare ENDP
_TEXT	ENDS
EXTRN	_Py_HashDouble:PROC
; Function compile flags: /Ogtpy
;	COMDAT float_hash
_TEXT	SEGMENT
v$ = 8
float_hash PROC						; COMDAT

; 489  :     return _Py_HashDouble(v->ob_fval);

  00000	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]

; 490  : }

  00005	e9 00 00 00 00	 jmp	 _Py_HashDouble
float_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_add DD imagerel float_add
	DD	imagerel float_add+204
	DD	imagerel $unwind$float_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_add DD 061d01H
	DD	02681dH
	DD	0700d5211H
	DD	0300b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT float_add
_TEXT	SEGMENT
b$ = 80
v$ = 80
w$ = 88
a$ = 96
float_add PROC						; COMDAT

; 494  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 495  :     double a,b;
; 496  :     CONVERT_TO_DOUBLE(v, a);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 8b f9	 mov	 rdi, rcx
  00023	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00027	74 3d		 je	 SHORT $LN7@float_add
  00029	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002d	48 8b d6	 mov	 rdx, rsi
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2d		 jne	 SHORT $LN7@float_add
  00039	48 8d 54 24 60	 lea	 rdx, QWORD PTR a$[rsp]
  0003e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR v$[rsp]
  00043	e8 00 00 00 00	 call	 convert_to_double
  00048	85 c0		 test	 eax, eax
  0004a	79 12		 jns	 SHORT $LN11@float_add
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]

; 502  : }

  00051	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	5e		 pop	 rsi
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN11@float_add:

; 495  :     double a,b;
; 496  :     CONVERT_TO_DOUBLE(v, a);

  0005e	f2 0f 10 74 24
	60		 movsdx	 xmm6, QWORD PTR a$[rsp]
  00064	eb 05		 jmp	 SHORT $LN5@float_add
$LN7@float_add:
  00066	f2 0f 10 77 60	 movsdx	 xmm6, QWORD PTR [rdi+96]
$LN5@float_add:

; 497  :     CONVERT_TO_DOUBLE(w, b);

  0006b	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006f	74 3d		 je	 SHORT $LN3@float_add
  00071	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00075	48 8b d6	 mov	 rdx, rsi
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 2d		 jne	 SHORT $LN3@float_add
  00081	48 8d 54 24 50	 lea	 rdx, QWORD PTR b$[rsp]
  00086	48 8d 4c 24 58	 lea	 rcx, QWORD PTR w$[rsp]
  0008b	e8 00 00 00 00	 call	 convert_to_double
  00090	85 c0		 test	 eax, eax
  00092	79 12		 jns	 SHORT $LN12@float_add
  00094	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]

; 502  : }

  00099	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN12@float_add:

; 497  :     CONVERT_TO_DOUBLE(w, b);

  000a6	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000ac	eb 05		 jmp	 SHORT $LN1@float_add
$LN3@float_add:
  000ae	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]
$LN1@float_add:

; 498  :     PyFPE_START_PROTECT("add", return 0)
; 499  :     a = a + b;

  000b3	f2 0f 58 f0	 addsd	 xmm6, xmm0

; 500  :     PyFPE_END_PROTECT(a)
; 501  :     return PyFloat_FromDouble(a);

  000b7	66 0f 28 c6	 movapd	 xmm0, xmm6

; 502  : }

  000bb	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	5e		 pop	 rsi
  000c6	5b		 pop	 rbx
  000c7	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_sub DD imagerel float_sub
	DD	imagerel float_sub+204
	DD	imagerel $unwind$float_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_sub DD 061d01H
	DD	02681dH
	DD	0700d5211H
	DD	0300b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT float_sub
_TEXT	SEGMENT
b$ = 80
v$ = 80
w$ = 88
a$ = 96
float_sub PROC						; COMDAT

; 506  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 507  :     double a,b;
; 508  :     CONVERT_TO_DOUBLE(v, a);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 8b f9	 mov	 rdi, rcx
  00023	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00027	74 3d		 je	 SHORT $LN7@float_sub
  00029	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002d	48 8b d6	 mov	 rdx, rsi
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2d		 jne	 SHORT $LN7@float_sub
  00039	48 8d 54 24 60	 lea	 rdx, QWORD PTR a$[rsp]
  0003e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR v$[rsp]
  00043	e8 00 00 00 00	 call	 convert_to_double
  00048	85 c0		 test	 eax, eax
  0004a	79 12		 jns	 SHORT $LN11@float_sub
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]

; 514  : }

  00051	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	5e		 pop	 rsi
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN11@float_sub:

; 507  :     double a,b;
; 508  :     CONVERT_TO_DOUBLE(v, a);

  0005e	f2 0f 10 74 24
	60		 movsdx	 xmm6, QWORD PTR a$[rsp]
  00064	eb 05		 jmp	 SHORT $LN5@float_sub
$LN7@float_sub:
  00066	f2 0f 10 77 60	 movsdx	 xmm6, QWORD PTR [rdi+96]
$LN5@float_sub:

; 509  :     CONVERT_TO_DOUBLE(w, b);

  0006b	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006f	74 3d		 je	 SHORT $LN3@float_sub
  00071	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00075	48 8b d6	 mov	 rdx, rsi
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 2d		 jne	 SHORT $LN3@float_sub
  00081	48 8d 54 24 50	 lea	 rdx, QWORD PTR b$[rsp]
  00086	48 8d 4c 24 58	 lea	 rcx, QWORD PTR w$[rsp]
  0008b	e8 00 00 00 00	 call	 convert_to_double
  00090	85 c0		 test	 eax, eax
  00092	79 12		 jns	 SHORT $LN12@float_sub
  00094	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]

; 514  : }

  00099	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN12@float_sub:

; 509  :     CONVERT_TO_DOUBLE(w, b);

  000a6	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000ac	eb 05		 jmp	 SHORT $LN1@float_sub
$LN3@float_sub:
  000ae	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]
$LN1@float_sub:

; 510  :     PyFPE_START_PROTECT("subtract", return 0)
; 511  :     a = a - b;

  000b3	f2 0f 5c f0	 subsd	 xmm6, xmm0

; 512  :     PyFPE_END_PROTECT(a)
; 513  :     return PyFloat_FromDouble(a);

  000b7	66 0f 28 c6	 movapd	 xmm0, xmm6

; 514  : }

  000bb	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	5e		 pop	 rsi
  000c6	5b		 pop	 rbx
  000c7	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_sub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_mul DD imagerel float_mul
	DD	imagerel float_mul+204
	DD	imagerel $unwind$float_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_mul DD 061d01H
	DD	02681dH
	DD	0700d5211H
	DD	0300b600cH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT float_mul
_TEXT	SEGMENT
b$ = 80
v$ = 80
w$ = 88
a$ = 96
float_mul PROC						; COMDAT

; 518  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 519  :     double a,b;
; 520  :     CONVERT_TO_DOUBLE(v, a);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 8b f9	 mov	 rdi, rcx
  00023	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00027	74 3d		 je	 SHORT $LN7@float_mul
  00029	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002d	48 8b d6	 mov	 rdx, rsi
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2d		 jne	 SHORT $LN7@float_mul
  00039	48 8d 54 24 60	 lea	 rdx, QWORD PTR a$[rsp]
  0003e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR v$[rsp]
  00043	e8 00 00 00 00	 call	 convert_to_double
  00048	85 c0		 test	 eax, eax
  0004a	79 12		 jns	 SHORT $LN11@float_mul
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]

; 526  : }

  00051	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	5e		 pop	 rsi
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN11@float_mul:

; 519  :     double a,b;
; 520  :     CONVERT_TO_DOUBLE(v, a);

  0005e	f2 0f 10 74 24
	60		 movsdx	 xmm6, QWORD PTR a$[rsp]
  00064	eb 05		 jmp	 SHORT $LN5@float_mul
$LN7@float_mul:
  00066	f2 0f 10 77 60	 movsdx	 xmm6, QWORD PTR [rdi+96]
$LN5@float_mul:

; 521  :     CONVERT_TO_DOUBLE(w, b);

  0006b	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006f	74 3d		 je	 SHORT $LN3@float_mul
  00071	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00075	48 8b d6	 mov	 rdx, rsi
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 2d		 jne	 SHORT $LN3@float_mul
  00081	48 8d 54 24 50	 lea	 rdx, QWORD PTR b$[rsp]
  00086	48 8d 4c 24 58	 lea	 rcx, QWORD PTR w$[rsp]
  0008b	e8 00 00 00 00	 call	 convert_to_double
  00090	85 c0		 test	 eax, eax
  00092	79 12		 jns	 SHORT $LN12@float_mul
  00094	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]

; 526  : }

  00099	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN12@float_mul:

; 521  :     CONVERT_TO_DOUBLE(w, b);

  000a6	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000ac	eb 05		 jmp	 SHORT $LN1@float_mul
$LN3@float_mul:
  000ae	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]
$LN1@float_mul:

; 522  :     PyFPE_START_PROTECT("multiply", return 0)
; 523  :     a = a * b;

  000b3	f2 0f 59 f0	 mulsd	 xmm6, xmm0

; 524  :     PyFPE_END_PROTECT(a)
; 525  :     return PyFloat_FromDouble(a);

  000b7	66 0f 28 c6	 movapd	 xmm0, xmm6

; 526  : }

  000bb	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c4	5f		 pop	 rdi
  000c5	5e		 pop	 rsi
  000c6	5b		 pop	 rbx
  000c7	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_mul ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@ ; `string'
PUBLIC	__real@0000000000000000
EXTRN	PyExc_ZeroDivisionError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_div DD imagerel float_div
	DD	imagerel float_div+250
	DD	imagerel $unwind$float_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_div DD 061d01H
	DD	02681dH
	DD	0700d5211H
	DD	0300b600cH
xdata	ENDS
;	COMDAT ??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@
CONST	SEGMENT
??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@ DB 'float division by z'
	DB	'ero', 00H					; `string'
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_div
_TEXT	SEGMENT
b$ = 80
v$ = 80
w$ = 88
a$ = 96
float_div PROC						; COMDAT

; 530  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 531  :     double a,b;
; 532  :     CONVERT_TO_DOUBLE(v, a);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0001d	48 8b da	 mov	 rbx, rdx
  00020	48 8b f9	 mov	 rdi, rcx
  00023	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00027	74 3d		 je	 SHORT $LN8@float_div
  00029	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002d	48 8b d6	 mov	 rdx, rsi
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2d		 jne	 SHORT $LN8@float_div
  00039	48 8d 54 24 60	 lea	 rdx, QWORD PTR a$[rsp]
  0003e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR v$[rsp]
  00043	e8 00 00 00 00	 call	 convert_to_double
  00048	85 c0		 test	 eax, eax
  0004a	79 12		 jns	 SHORT $LN12@float_div
  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]

; 543  : }

  00051	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	5e		 pop	 rsi
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN12@float_div:

; 531  :     double a,b;
; 532  :     CONVERT_TO_DOUBLE(v, a);

  0005e	f2 0f 10 74 24
	60		 movsdx	 xmm6, QWORD PTR a$[rsp]
  00064	eb 05		 jmp	 SHORT $LN6@float_div
$LN8@float_div:
  00066	f2 0f 10 77 60	 movsdx	 xmm6, QWORD PTR [rdi+96]
$LN6@float_div:

; 533  :     CONVERT_TO_DOUBLE(w, b);

  0006b	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0006f	74 3d		 je	 SHORT $LN4@float_div
  00071	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00075	48 8b d6	 mov	 rdx, rsi
  00078	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007d	85 c0		 test	 eax, eax
  0007f	75 2d		 jne	 SHORT $LN4@float_div
  00081	48 8d 54 24 50	 lea	 rdx, QWORD PTR b$[rsp]
  00086	48 8d 4c 24 58	 lea	 rcx, QWORD PTR w$[rsp]
  0008b	e8 00 00 00 00	 call	 convert_to_double
  00090	85 c0		 test	 eax, eax
  00092	79 12		 jns	 SHORT $LN13@float_div
  00094	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]

; 543  : }

  00099	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5f		 pop	 rdi
  000a3	5e		 pop	 rsi
  000a4	5b		 pop	 rbx
  000a5	c3		 ret	 0
$LN13@float_div:

; 533  :     CONVERT_TO_DOUBLE(w, b);

  000a6	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000ac	eb 05		 jmp	 SHORT $LN2@float_div
$LN4@float_div:
  000ae	f2 0f 10 43 60	 movsdx	 xmm0, QWORD PTR [rbx+96]
$LN2@float_div:

; 534  :     if (b == 0.0) {

  000b3	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000bb	7a 24		 jp	 SHORT $LN1@float_div
  000bd	75 22		 jne	 SHORT $LN1@float_div

; 535  :         PyErr_SetString(PyExc_ZeroDivisionError,
; 536  :                         "float division by zero");

  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@FBOCJMDG@float?5division?5by?5zero?$AA@
  000cd	e8 00 00 00 00	 call	 PyErr_SetString

; 537  :         return NULL;

  000d2	33 c0		 xor	 eax, eax

; 543  : }

  000d4	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	5f		 pop	 rdi
  000de	5e		 pop	 rsi
  000df	5b		 pop	 rbx
  000e0	c3		 ret	 0
$LN1@float_div:

; 538  :     }
; 539  :     PyFPE_START_PROTECT("divide", return 0)
; 540  :     a = a / b;

  000e1	f2 0f 5e f0	 divsd	 xmm6, xmm0

; 541  :     PyFPE_END_PROTECT(a)
; 542  :     return PyFloat_FromDouble(a);

  000e5	66 0f 28 c6	 movapd	 xmm0, xmm6

; 543  : }

  000e9	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000ee	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f2	5f		 pop	 rdi
  000f3	5e		 pop	 rsi
  000f4	5b		 pop	 rbx
  000f5	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_div ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FKMNDEON@float?5modulo?$AA@		; `string'
EXTRN	__imp__copysign:PROC
EXTRN	fmod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_rem DD imagerel float_rem
	DD	imagerel float_rem+186
	DD	imagerel $unwind$float_rem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_rem DD imagerel float_rem+186
	DD	imagerel float_rem+307
	DD	imagerel $chain$1$float_rem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$float_rem DD imagerel float_rem+307
	DD	imagerel float_rem+326
	DD	imagerel $chain$2$float_rem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$float_rem DD 021H
	DD	imagerel float_rem
	DD	imagerel float_rem+186
	DD	imagerel $unwind$float_rem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_rem DD 020521H
	DD	037805H
	DD	imagerel float_rem
	DD	imagerel float_rem+186
	DD	imagerel $unwind$float_rem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_rem DD 087a01H
	DD	04687aH
	DD	02881eH
	DD	0700d9211H
	DD	0300b600cH
xdata	ENDS
;	COMDAT ??_C@_0N@FKMNDEON@float?5modulo?$AA@
CONST	SEGMENT
??_C@_0N@FKMNDEON@float?5modulo?$AA@ DB 'float modulo', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_rem
_TEXT	SEGMENT
wx$ = 112
v$ = 112
w$ = 120
vx$ = 128
float_rem PROC						; COMDAT

; 547  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 548  :     double vx, wx;
; 549  :     double mod;
; 550  :     CONVERT_TO_DOUBLE(v, vx);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	44 0f 29 44 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm8
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00028	74 45		 je	 SHORT $LN11@float_rem
  0002a	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002e	48 8b d6	 mov	 rdx, rsi
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 35		 jne	 SHORT $LN11@float_rem
  0003a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR vx$[rsp]
  00042	48 8d 4c 24 70	 lea	 rcx, QWORD PTR v$[rsp]
  00047	e8 00 00 00 00	 call	 convert_to_double
  0004c	85 c0		 test	 eax, eax
  0004e	79 13		 jns	 SHORT $LN20@float_rem
  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR v$[rsp]

; 573  : }

  00055	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]
  0005b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0005f	5f		 pop	 rdi
  00060	5e		 pop	 rsi
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN20@float_rem:

; 548  :     double vx, wx;
; 549  :     double mod;
; 550  :     CONVERT_TO_DOUBLE(v, vx);

  00063	f2 44 0f 10 84
	24 80 00 00 00	 movsdx	 xmm8, QWORD PTR vx$[rsp]
  0006d	eb 06		 jmp	 SHORT $LN9@float_rem
$LN11@float_rem:
  0006f	f2 44 0f 10 47
	60		 movsdx	 xmm8, QWORD PTR [rdi+96]
$LN9@float_rem:
  00075	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6

; 551  :     CONVERT_TO_DOUBLE(w, wx);

  0007a	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  0007e	74 35		 je	 SHORT $LN7@float_rem
  00080	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00084	48 8b d6	 mov	 rdx, rsi
  00087	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008c	85 c0		 test	 eax, eax
  0008e	75 25		 jne	 SHORT $LN7@float_rem
  00090	48 8d 54 24 70	 lea	 rdx, QWORD PTR wx$[rsp]
  00095	48 8d 4c 24 78	 lea	 rcx, QWORD PTR w$[rsp]
  0009a	e8 00 00 00 00	 call	 convert_to_double
  0009f	85 c0		 test	 eax, eax
  000a1	79 0a		 jns	 SHORT $LN21@float_rem
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR w$[rsp]
  000a8	e9 86 00 00 00	 jmp	 $LN22@float_rem
$LN21@float_rem:
  000ad	f2 0f 10 74 24
	70		 movsdx	 xmm6, QWORD PTR wx$[rsp]
  000b3	eb 05		 jmp	 SHORT $LN5@float_rem
$LN7@float_rem:
  000b5	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]
$LN5@float_rem:
  000ba	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7

; 552  :     if (wx == 0.0) {

  000bf	66 0f 57 ff	 xorpd	 xmm7, xmm7
  000c3	66 0f 2e f7	 ucomisd xmm6, xmm7
  000c7	7a 19		 jp	 SHORT $LN4@float_rem
  000c9	75 17		 jne	 SHORT $LN4@float_rem

; 553  :         PyErr_SetString(PyExc_ZeroDivisionError,
; 554  :                         "float modulo");

  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@FKMNDEON@float?5modulo?$AA@
  000d9	e8 00 00 00 00	 call	 PyErr_SetString

; 555  :         return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 4c		 jmp	 SHORT $LN23@float_rem
$LN4@float_rem:

; 556  :     }
; 557  :     PyFPE_START_PROTECT("modulo", return 0)
; 558  :     mod = fmod(vx, wx);

  000e2	66 0f 28 ce	 movapd	 xmm1, xmm6
  000e6	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  000eb	e8 00 00 00 00	 call	 fmod

; 559  :     if (mod) {

  000f0	66 0f 2e c7	 ucomisd xmm0, xmm7
  000f4	7a 12		 jp	 SHORT $LN19@float_rem
  000f6	75 10		 jne	 SHORT $LN19@float_rem

; 563  :         }
; 564  :     }
; 565  :     else {
; 566  :         /* the remainder is zero, and in the presence of signed zeroes
; 567  :            fmod returns different results across platforms; ensure
; 568  :            it has the same sign as the denominator. */
; 569  :         mod = copysign(0.0, wx);

  000f8	66 0f 28 ce	 movapd	 xmm1, xmm6
  000fc	66 0f 28 c7	 movapd	 xmm0, xmm7
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00106	eb 21		 jmp	 SHORT $LN1@float_rem
$LN19@float_rem:

; 560  :         /* ensure the remainder has the same sign as the denominator */
; 561  :         if ((wx < 0) != (mod < 0)) {

  00108	66 0f 2f fe	 comisd	 xmm7, xmm6
  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	76 04		 jbe	 SHORT $LN17@float_rem
  00113	8b c8		 mov	 ecx, eax
  00115	eb 02		 jmp	 SHORT $LN18@float_rem
$LN17@float_rem:
  00117	33 c9		 xor	 ecx, ecx
$LN18@float_rem:
  00119	66 0f 2f f8	 comisd	 xmm7, xmm0
  0011d	77 02		 ja	 SHORT $LN16@float_rem
  0011f	33 c0		 xor	 eax, eax
$LN16@float_rem:
  00121	3b c8		 cmp	 ecx, eax
  00123	74 04		 je	 SHORT $LN1@float_rem

; 562  :             mod += wx;

  00125	f2 0f 58 c6	 addsd	 xmm0, xmm6
$LN1@float_rem:

; 570  :     }
; 571  :     PyFPE_END_PROTECT(mod)
; 572  :     return PyFloat_FromDouble(mod);

  00129	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN23@float_rem:
  0012e	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]
$LN22@float_rem:
  00133	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]

; 573  : }

  00138	44 0f 28 44 24
	20		 movaps	 xmm8, XMMWORD PTR [rsp+32]
  0013e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00142	5f		 pop	 rdi
  00143	5e		 pop	 rsi
  00144	5b		 pop	 rbx
  00145	c3		 ret	 0
float_rem ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@		; `string'
PUBLIC	__real@3fe0000000000000
PUBLIC	??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@	; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_divmod DD imagerel float_divmod
	DD	imagerel float_divmod+204
	DD	imagerel $unwind$float_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_divmod DD imagerel float_divmod+204
	DD	imagerel float_divmod+259
	DD	imagerel $chain$1$float_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$float_divmod DD imagerel float_divmod+259
	DD	imagerel float_divmod+473
	DD	imagerel $chain$3$float_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$float_divmod DD imagerel float_divmod+473
	DD	imagerel float_divmod+479
	DD	imagerel $chain$4$float_divmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$float_divmod DD imagerel float_divmod+479
	DD	imagerel float_divmod+498
	DD	imagerel $chain$5$float_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$float_divmod DD 021H
	DD	imagerel float_divmod
	DD	imagerel float_divmod+204
	DD	imagerel $unwind$float_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$float_divmod DD 021H
	DD	imagerel float_divmod+204
	DD	imagerel float_divmod+259
	DD	imagerel $chain$1$float_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$float_divmod DD 040b21H
	DD	02a80bH
	DD	057805H
	DD	imagerel float_divmod+204
	DD	imagerel float_divmod+259
	DD	imagerel $chain$1$float_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_divmod DD 020621H
	DD	048806H
	DD	imagerel float_divmod
	DD	imagerel float_divmod+204
	DD	imagerel $unwind$float_divmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_divmod DD 088001H
	DD	066880H
	DD	03981eH
	DD	0700dd211H
	DD	0300b600cH
xdata	ENDS
;	COMDAT ??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
CONST	SEGMENT
??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@ DB '(dd)', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT ??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@ DB 'float divmod()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_divmod
_TEXT	SEGMENT
wx$ = 144
v$ = 144
w$ = 152
vx$ = 160
float_divmod PROC					; COMDAT

; 577  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 578  :     double vx, wx;
; 579  :     double div, mod, floordiv;
; 580  :     CONVERT_TO_DOUBLE(v, vx);

  00011	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyFloat_Type
  00018	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9
  0001e	48 8b da	 mov	 rbx, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	48 39 71 58	 cmp	 QWORD PTR [rcx+88], rsi
  00028	74 4b		 je	 SHORT $LN14@float_divm
  0002a	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0002e	48 8b d6	 mov	 rdx, rsi
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 3b		 jne	 SHORT $LN14@float_divm
  0003a	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR vx$[rsp]
  00042	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  0004a	e8 00 00 00 00	 call	 convert_to_double
  0004f	85 c0		 test	 eax, eax
  00051	79 16		 jns	 SHORT $LN24@float_divm
  00053	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]

; 620  : }

  0005b	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
  00061	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00065	5f		 pop	 rdi
  00066	5e		 pop	 rsi
  00067	5b		 pop	 rbx
  00068	c3		 ret	 0
$LN24@float_divm:

; 578  :     double vx, wx;
; 579  :     double div, mod, floordiv;
; 580  :     CONVERT_TO_DOUBLE(v, vx);

  00069	f2 44 0f 10 8c
	24 a0 00 00 00	 movsdx	 xmm9, QWORD PTR vx$[rsp]
  00073	eb 06		 jmp	 SHORT $LN12@float_divm
$LN14@float_divm:
  00075	f2 44 0f 10 4f
	60		 movsdx	 xmm9, QWORD PTR [rdi+96]
$LN12@float_divm:
  0007b	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6

; 581  :     CONVERT_TO_DOUBLE(w, wx);

  00080	48 39 73 58	 cmp	 QWORD PTR [rbx+88], rsi
  00084	74 41		 je	 SHORT $LN10@float_divm
  00086	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0008a	48 8b d6	 mov	 rdx, rsi
  0008d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00092	85 c0		 test	 eax, eax
  00094	75 31		 jne	 SHORT $LN10@float_divm
  00096	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR wx$[rsp]
  0009e	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR w$[rsp]
  000a6	e8 00 00 00 00	 call	 convert_to_double
  000ab	85 c0		 test	 eax, eax
  000ad	79 0d		 jns	 SHORT $LN25@float_divm
  000af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000b7	e9 23 01 00 00	 jmp	 $LN26@float_divm
$LN25@float_divm:
  000bc	f2 0f 10 b4 24
	90 00 00 00	 movsdx	 xmm6, QWORD PTR wx$[rsp]
  000c5	eb 05		 jmp	 SHORT $LN8@float_divm
$LN10@float_divm:
  000c7	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]
$LN8@float_divm:
  000cc	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8

; 582  :     if (wx == 0.0) {

  000d2	66 45 0f 57 c0	 xorpd	 xmm8, xmm8
  000d7	66 41 0f 2e f0	 ucomisd xmm6, xmm8
  000dc	7a 1c		 jp	 SHORT $LN7@float_divm
  000de	75 1a		 jne	 SHORT $LN7@float_divm

; 583  :         PyErr_SetString(PyExc_ZeroDivisionError, "float divmod()");

  000e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FNNFOEHG@float?5divmod?$CI?$CJ?$AA@
  000ee	e8 00 00 00 00	 call	 PyErr_SetString

; 584  :         return NULL;

  000f3	33 c0		 xor	 eax, eax
  000f5	e9 df 00 00 00	 jmp	 $LN27@float_divm
$LN7@float_divm:

; 585  :     }
; 586  :     PyFPE_START_PROTECT("divmod", return 0)
; 587  :     mod = fmod(vx, wx);

  000fa	66 0f 28 ce	 movapd	 xmm1, xmm6
  000fe	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00103	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00108	44 0f 29 54 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm10
  0010e	e8 00 00 00 00	 call	 fmod

; 588  :     /* fmod is typically exact, so vx-mod is *mathematically* an
; 589  :        exact multiple of wx.  But this is fp arithmetic, and fp
; 590  :        vx - mod is an approximation; the result is that div may
; 591  :        not be an exact integral value after the division, although
; 592  :        it will always be very close to one.
; 593  :     */
; 594  :     div = (vx - mod) / wx;

  00113	66 41 0f 28 f9	 movapd	 xmm7, xmm9

; 595  :     if (mod) {

  00118	66 41 0f 2e c0	 ucomisd xmm0, xmm8
  0011d	f2 0f 5c f8	 subsd	 xmm7, xmm0
  00121	66 44 0f 28 d0	 movapd	 xmm10, xmm0
  00126	f2 0f 5e fe	 divsd	 xmm7, xmm6
  0012a	7a 18		 jp	 SHORT $LN23@float_divm
  0012c	75 16		 jne	 SHORT $LN23@float_divm

; 600  :         }
; 601  :     }
; 602  :     else {
; 603  :         /* the remainder is zero, and in the presence of signed zeroes
; 604  :            fmod returns different results across platforms; ensure
; 605  :            it has the same sign as the denominator. */
; 606  :         mod = copysign(0.0, wx);

  0012e	66 0f 28 ce	 movapd	 xmm1, xmm6
  00132	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0013d	66 44 0f 28 d0	 movapd	 xmm10, xmm0
  00142	eb 2c		 jmp	 SHORT $LN4@float_divm
$LN23@float_divm:

; 596  :         /* ensure the remainder has the same sign as the denominator */
; 597  :         if ((wx < 0) != (mod < 0)) {

  00144	66 44 0f 2f c6	 comisd	 xmm8, xmm6
  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	76 04		 jbe	 SHORT $LN20@float_divm
  00150	8b c8		 mov	 ecx, eax
  00152	eb 02		 jmp	 SHORT $LN21@float_divm
$LN20@float_divm:
  00154	33 c9		 xor	 ecx, ecx
$LN21@float_divm:
  00156	66 44 0f 2f c0	 comisd	 xmm8, xmm0
  0015b	77 02		 ja	 SHORT $LN19@float_divm
  0015d	33 c0		 xor	 eax, eax
$LN19@float_divm:
  0015f	3b c8		 cmp	 ecx, eax
  00161	74 0d		 je	 SHORT $LN4@float_divm

; 598  :             mod += wx;
; 599  :             div -= 1.0;

  00163	f2 0f 5c 3d 00
	00 00 00	 subsd	 xmm7, QWORD PTR __real@3ff0000000000000
  0016b	f2 44 0f 58 d6	 addsd	 xmm10, xmm6
$LN4@float_divm:

; 607  :     }
; 608  :     /* snap quotient to nearest integral value */
; 609  :     if (div) {

  00170	66 41 0f 2e f8	 ucomisd xmm7, xmm8
  00175	7a 19		 jp	 SHORT $LN22@float_divm
  00177	75 17		 jne	 SHORT $LN22@float_divm

; 613  :     }
; 614  :     else {
; 615  :         /* div is zero - get the same sign as the true quotient */
; 616  :         floordiv = copysign(0.0, vx / wx); /* zero w/ sign of vx/wx */

  00179	f2 44 0f 5e ce	 divsd	 xmm9, xmm6
  0017e	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00183	66 41 0f 28 c9	 movapd	 xmm1, xmm9
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0018e	eb 1f		 jmp	 SHORT $LN1@float_divm
$LN22@float_divm:

; 610  :         floordiv = floor(div);

  00190	66 0f 28 c7	 movapd	 xmm0, xmm7
  00194	e8 00 00 00 00	 call	 floor

; 611  :         if (div - floordiv > 0.5)

  00199	f2 0f 5c f8	 subsd	 xmm7, xmm0
  0019d	66 0f 2f 3d 00
	00 00 00	 comisd	 xmm7, QWORD PTR __real@3fe0000000000000
  001a5	76 08		 jbe	 SHORT $LN1@float_divm

; 612  :             floordiv += 1.0;

  001a7	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
$LN1@float_divm:

; 617  :     }
; 618  :     PyFPE_END_PROTECT(floordiv)
; 619  :     return Py_BuildValue("(dd)", floordiv, mod);

  001af	66 41 0f 28 d2	 movapd	 xmm2, xmm10
  001b4	66 0f 28 c8	 movapd	 xmm1, xmm0
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  001bf	66 49 0f 7e d0	 movd	 r8, xmm2
  001c4	66 48 0f 7e ca	 movd	 rdx, xmm1
  001c9	e8 00 00 00 00	 call	 Py_BuildValue
  001ce	44 0f 28 54 24
	20		 movaps	 xmm10, XMMWORD PTR [rsp+32]
  001d4	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
$LN27@float_divm:
  001d9	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
$LN26@float_divm:
  001df	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]

; 620  : }

  001e4	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
  001ea	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001ee	5f		 pop	 rdi
  001ef	5e		 pop	 rsi
  001f0	5b		 pop	 rbx
  001f1	c3		 ret	 0
float_divmod ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_floor_div DD imagerel float_floor_div
	DD	imagerel float_floor_div+31
	DD	imagerel $unwind$float_floor_div
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$float_floor_div DD imagerel float_floor_div+31
	DD	imagerel float_floor_div+121
	DD	imagerel $chain$0$float_floor_div
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_floor_div DD imagerel float_floor_div+121
	DD	imagerel float_floor_div+130
	DD	imagerel $chain$1$float_floor_div
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_floor_div DD 021H
	DD	imagerel float_floor_div
	DD	imagerel float_floor_div+31
	DD	imagerel $unwind$float_floor_div
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$float_floor_div DD 020521H
	DD	083405H
	DD	imagerel float_floor_div
	DD	imagerel float_floor_div+31
	DD	imagerel $unwind$float_floor_div
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_floor_div DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
xdata	ENDS
;	COMDAT float_floor_div
_TEXT	SEGMENT
v$ = 64
w$ = 72
float_floor_div PROC					; COMDAT

; 624  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 625  :     PyObject *t, *r;
; 626  : 
; 627  :     t = float_divmod(v, w);

  00006	e8 00 00 00 00	 call	 float_divmod
  0000b	48 8b f8	 mov	 rdi, rax

; 628  :     if (t == NULL || t == Py_NotImplemented)

  0000e	48 85 c0	 test	 rax, rax
  00011	74 66		 je	 SHORT $LN1@float_floo
  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0001a	48 3b f8	 cmp	 rdi, rax
  0001d	74 5a		 je	 SHORT $LN1@float_floo

; 630  :     assert(PyTuple_CheckExact(t));
; 631  :     r = PyTuple_GET_ITEM(t, 0);

  0001f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00024	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]

; 632  :     Py_INCREF(r);

  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 32		 jne	 SHORT $LN6@float_floo
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003f	4c 8b cb	 mov	 r9, rbx
  00042	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00048	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 06		 jne	 SHORT $LN5@float_floo
  00059	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005d	74 04		 je	 SHORT $LN6@float_floo
$LN5@float_floo:
  0005f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@float_floo:

; 633  :     Py_DECREF(t);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	e8 00 00 00 00	 call	 _Py_DecRef

; 634  :     return r;

  0006b	48 8b c3	 mov	 rax, rbx
  0006e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 635  : }

  00073	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
$LN1@float_floo:

; 629  :         return t;

  00079	48 8b c7	 mov	 rax, rdi

; 635  : }

  0007c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
float_floor_div ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@ ; `string'
PUBLIC	__mask@@AbsDouble@
PUBLIC	??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@ ; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp__HUGE:QWORD
EXTRN	__imp__errno:PROC
EXTRN	PyComplex_Type:BYTE
EXTRN	__imp__isnan:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	pow:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_pow DD imagerel float_pow
	DD	imagerel float_pow+172
	DD	imagerel $unwind$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$float_pow DD imagerel float_pow+172
	DD	imagerel float_pow+261
	DD	imagerel $chain$2$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$float_pow DD imagerel float_pow+261
	DD	imagerel float_pow+494
	DD	imagerel $chain$3$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$float_pow DD imagerel float_pow+494
	DD	imagerel float_pow+766
	DD	imagerel $chain$4$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$float_pow DD imagerel float_pow+766
	DD	imagerel float_pow+1086
	DD	imagerel $chain$5$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$float_pow DD imagerel float_pow+1086
	DD	imagerel float_pow+1092
	DD	imagerel $chain$6$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$float_pow DD imagerel float_pow+1092
	DD	imagerel float_pow+1098
	DD	imagerel $chain$7$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$float_pow DD imagerel float_pow+1098
	DD	imagerel float_pow+1103
	DD	imagerel $chain$8$float_pow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$float_pow DD imagerel float_pow+1103
	DD	imagerel float_pow+1122
	DD	imagerel $chain$9$float_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$float_pow DD 021H
	DD	imagerel float_pow
	DD	imagerel float_pow+172
	DD	imagerel $unwind$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$float_pow DD 021H
	DD	imagerel float_pow+172
	DD	imagerel float_pow+261
	DD	imagerel $chain$2$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$float_pow DD 021H
	DD	imagerel float_pow+261
	DD	imagerel float_pow+494
	DD	imagerel $chain$3$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$float_pow DD 021H
	DD	imagerel float_pow+494
	DD	imagerel float_pow+766
	DD	imagerel $chain$4$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$float_pow DD 020621H
	DD	02a806H
	DD	imagerel float_pow+494
	DD	imagerel float_pow+766
	DD	imagerel $chain$4$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$float_pow DD 020621H
	DD	039806H
	DD	imagerel float_pow+261
	DD	imagerel float_pow+494
	DD	imagerel $chain$3$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$float_pow DD 020621H
	DD	048806H
	DD	imagerel float_pow+172
	DD	imagerel float_pow+261
	DD	imagerel $chain$2$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$float_pow DD 020521H
	DD	057805H
	DD	imagerel float_pow
	DD	imagerel float_pow+172
	DD	imagerel $unwind$float_pow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_pow DD 095801H
	DD	066858H
	DD	0ec44cH
	DD	0700ee212H
	DD	0500c600dH
	DD	0300bH
xdata	ENDS
;	COMDAT ??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@
CONST	SEGMENT
??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@ DB '0.0 cannot'
	DB	' be raised to a negative power', 00H	; `string'
CONST	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT ??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@
CONST	SEGMENT
??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@ DB 'pow()'
	DB	' 3rd argument not allowed unless all arguments are integers', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_pow
_TEXT	SEGMENT
v$ = 160
w$ = 168
iw$ = 176
iv$ = 176
z$ = 176
float_pow PROC						; COMDAT

; 643  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 644  :     double iv, iw, ix;
; 645  :     int negate_result = 0;
; 646  : 
; 647  :     if ((PyObject *)z != Py_None) {

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00019	33 db		 xor	 ebx, ebx
  0001b	49 8b e8	 mov	 rbp, r8
  0001e	48 8b f2	 mov	 rsi, rdx
  00021	48 8b f9	 mov	 rdi, rcx
  00024	4c 3b c0	 cmp	 r8, rax
  00027	74 1e		 je	 SHORT $LN35@float_pow

; 648  :         PyErr_SetString(PyExc_TypeError, "pow() 3rd argument not "
; 649  :             "allowed unless all arguments are integers");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@NKAGDCME@pow?$CI?$CJ?53rd?5argument?5not?5allowed?5u@
  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 650  :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 761  : }

  0003e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00042	5f		 pop	 rdi
  00043	5e		 pop	 rsi
  00044	5d		 pop	 rbp
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN35@float_pow:
  00047	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12

; 651  :     }
; 652  : 
; 653  :     CONVERT_TO_DOUBLE(v, iv);

  0004c	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyFloat_Type
  00053	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00058	4c 39 61 58	 cmp	 QWORD PTR [rcx+88], r12
  0005c	74 49		 je	 SHORT $LN33@float_pow
  0005e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00062	49 8b d4	 mov	 rdx, r12
  00065	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006a	85 c0		 test	 eax, eax
  0006c	75 39		 jne	 SHORT $LN33@float_pow
  0006e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR iv$[rsp]
  00076	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  0007e	e8 00 00 00 00	 call	 convert_to_double
  00083	85 c0		 test	 eax, eax
  00085	79 0d		 jns	 SHORT $LN60@float_pow
  00087	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0008f	e9 bb 03 00 00	 jmp	 $LN63@float_pow
$LN60@float_pow:
  00094	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR v$[rsp]
  0009c	f2 0f 10 b4 24
	b0 00 00 00	 movsdx	 xmm6, QWORD PTR iv$[rsp]
  000a5	eb 05		 jmp	 SHORT $LN31@float_pow
$LN33@float_pow:
  000a7	f2 0f 10 77 60	 movsdx	 xmm6, QWORD PTR [rdi+96]
$LN31@float_pow:
  000ac	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7

; 654  :     CONVERT_TO_DOUBLE(w, iw);

  000b1	4c 39 66 58	 cmp	 QWORD PTR [rsi+88], r12
  000b5	74 49		 je	 SHORT $LN29@float_pow
  000b7	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  000bb	49 8b d4	 mov	 rdx, r12
  000be	e8 00 00 00 00	 call	 PyType_IsSubtype
  000c3	85 c0		 test	 eax, eax
  000c5	75 39		 jne	 SHORT $LN29@float_pow
  000c7	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR iw$[rsp]
  000cf	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR w$[rsp]
  000d7	e8 00 00 00 00	 call	 convert_to_double
  000dc	85 c0		 test	 eax, eax
  000de	79 0d		 jns	 SHORT $LN61@float_pow
  000e0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000e8	e9 5d 03 00 00	 jmp	 $LN64@float_pow
$LN61@float_pow:
  000ed	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR w$[rsp]
  000f5	f2 0f 10 bc 24
	b0 00 00 00	 movsdx	 xmm7, QWORD PTR iw$[rsp]
  000fe	eb 05		 jmp	 SHORT $LN27@float_pow
$LN29@float_pow:
  00100	f2 0f 10 7e 60	 movsdx	 xmm7, QWORD PTR [rsi+96]
$LN27@float_pow:
  00105	44 0f 29 44 24
	40		 movaps	 XMMWORD PTR [rsp+64], xmm8

; 655  : 
; 656  :     /* Sort out special cases here instead of relying on pow() */
; 657  :     if (iw == 0) {              /* v**0 is 1, even 0**0 */

  0010b	66 45 0f 57 c0	 xorpd	 xmm8, xmm8
  00110	66 41 0f 2e f8	 ucomisd xmm7, xmm8
  00115	7a 14		 jp	 SHORT $LN26@float_pow
  00117	75 12		 jne	 SHORT $LN26@float_pow

; 658  :         return PyFloat_FromDouble(1.0);

  00119	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00121	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00126	e9 19 03 00 00	 jmp	 $LN65@float_pow
$LN26@float_pow:

; 659  :     }
; 660  :     if (Py_IS_NAN(iv)) {        /* nan**w = nan, unless w == 0 */

  0012b	66 0f 28 c6	 movapd	 xmm0, xmm6
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00135	85 c0		 test	 eax, eax
  00137	74 0e		 je	 SHORT $LN25@float_pow

; 661  :         return PyFloat_FromDouble(iv);

  00139	66 0f 28 c6	 movapd	 xmm0, xmm6
  0013d	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00142	e9 fd 02 00 00	 jmp	 $LN65@float_pow
$LN25@float_pow:

; 662  :     }
; 663  :     if (Py_IS_NAN(iw)) {        /* v**nan = nan, unless v == 1; 1**nan = 1 */

  00147	66 0f 28 c7	 movapd	 xmm0, xmm7
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00151	85 c0		 test	 eax, eax
  00153	74 1e		 je	 SHORT $LN24@float_pow

; 664  :         return PyFloat_FromDouble(iv == 1.0 ? 1.0 : iw);

  00155	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0015d	66 0f 2e f0	 ucomisd xmm6, xmm0
  00161	7a 02		 jp	 SHORT $LN38@float_pow
  00163	74 04		 je	 SHORT $LN39@float_pow
$LN38@float_pow:
  00165	66 0f 28 c7	 movapd	 xmm0, xmm7
$LN39@float_pow:
  00169	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0016e	e9 d1 02 00 00	 jmp	 $LN65@float_pow
$LN24@float_pow:

; 665  :     }
; 666  :     if (Py_IS_INFINITY(iw)) {

  00173	66 0f 28 c7	 movapd	 xmm0, xmm7
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0017d	85 c0		 test	 eax, eax
  0017f	75 69		 jne	 SHORT $LN19@float_pow
  00181	66 0f 28 c7	 movapd	 xmm0, xmm7
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0018b	85 c0		 test	 eax, eax
  0018d	75 5b		 jne	 SHORT $LN19@float_pow

; 667  :         /* v**inf is: 0.0 if abs(v) < 1; 1.0 if abs(v) == 1; inf if
; 668  :          *     abs(v) > 1 (including case where v infinite)
; 669  :          *
; 670  :          * v**-inf is: inf if abs(v) < 1; 1.0 if abs(v) == 1; 0.0 if
; 671  :          *     abs(v) > 1 (including case where v infinite)
; 672  :          */
; 673  :         iv = fabs(iv);

  0018f	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __mask@@AbsDouble@

; 674  :         if (iv == 1.0)

  00197	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0019f	66 0f 54 f1	 andpd	 xmm6, xmm1
  001a3	66 0f 2e f0	 ucomisd xmm6, xmm0
  001a7	7a 02		 jp	 SHORT $LN22@float_pow

; 675  :             return PyFloat_FromDouble(1.0);

  001a9	74 35		 je	 SHORT $LN69@float_pow
$LN22@float_pow:

; 676  :         else if ((iw > 0.0) == (iv > 1.0))

  001ab	66 41 0f 2f f8	 comisd	 xmm7, xmm8
  001b0	bb 01 00 00 00	 mov	 ebx, 1
  001b5	76 04		 jbe	 SHORT $LN42@float_pow
  001b7	8b c3		 mov	 eax, ebx
  001b9	eb 02		 jmp	 SHORT $LN43@float_pow
$LN42@float_pow:
  001bb	33 c0		 xor	 eax, eax
$LN43@float_pow:
  001bd	66 0f 2f f0	 comisd	 xmm6, xmm0
  001c1	77 02		 ja	 SHORT $LN41@float_pow
  001c3	33 db		 xor	 ebx, ebx
$LN41@float_pow:
  001c5	3b c3		 cmp	 eax, ebx
  001c7	75 12		 jne	 SHORT $LN20@float_pow

; 677  :             return PyFloat_FromDouble(fabs(iw)); /* return inf */

  001c9	66 0f 54 f9	 andpd	 xmm7, xmm1
  001cd	66 0f 28 c7	 movapd	 xmm0, xmm7
  001d1	e8 00 00 00 00	 call	 PyFloat_FromDouble
  001d6	e9 69 02 00 00	 jmp	 $LN65@float_pow
$LN20@float_pow:

; 678  :         else
; 679  :             return PyFloat_FromDouble(0.0);

  001db	66 41 0f 28 c0	 movapd	 xmm0, xmm8
$LN69@float_pow:
  001e0	e8 00 00 00 00	 call	 PyFloat_FromDouble
  001e5	e9 5a 02 00 00	 jmp	 $LN65@float_pow
$LN19@float_pow:

; 680  :     }
; 681  :     if (Py_IS_INFINITY(iv)) {

  001ea	66 0f 28 c6	 movapd	 xmm0, xmm6
  001ee	44 0f 29 4c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm9
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001fa	85 c0		 test	 eax, eax
  001fc	0f 85 83 00 00
	00		 jne	 $LN16@float_pow
  00202	66 0f 28 c6	 movapd	 xmm0, xmm6
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0020c	85 c0		 test	 eax, eax
  0020e	75 75		 jne	 SHORT $LN16@float_pow

; 682  :         /* (+-inf)**w is: inf for w positive, 0 for w negative; in
; 683  :          *     both cases, we need to add the appropriate sign if w is
; 684  :          *     an odd integer.
; 685  :          */
; 686  :         int iw_is_odd = DOUBLE_IS_ODD_INTEGER(iw);

  00210	f2 44 0f 10 0d
	00 00 00 00	 movsdx	 xmm9, QWORD PTR __mask@@AbsDouble@
  00219	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00221	66 0f 28 c7	 movapd	 xmm0, xmm7
  00225	66 41 0f 54 c1	 andpd	 xmm0, xmm9
  0022a	e8 00 00 00 00	 call	 fmod
  0022f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  00237	7a 07		 jp	 SHORT $LN45@float_pow
  00239	75 05		 jne	 SHORT $LN45@float_pow
  0023b	bb 01 00 00 00	 mov	 ebx, 1
$LN45@float_pow:

; 687  :         if (iw > 0.0)

  00240	66 41 0f 2f f8	 comisd	 xmm7, xmm8
  00245	76 17		 jbe	 SHORT $LN17@float_pow

; 688  :             return PyFloat_FromDouble(iw_is_odd ? iv : fabs(iv));

  00247	85 db		 test	 ebx, ebx
  00249	75 05		 jne	 SHORT $LN47@float_pow
  0024b	66 41 0f 54 f1	 andpd	 xmm6, xmm9
$LN47@float_pow:
  00250	66 0f 28 c6	 movapd	 xmm0, xmm6
  00254	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00259	e9 e0 01 00 00	 jmp	 $LN66@float_pow
$LN17@float_pow:

; 689  :         else
; 690  :             return PyFloat_FromDouble(iw_is_odd ?
; 691  :                                       copysign(0.0, iv) : 0.0);

  0025e	85 db		 test	 ebx, ebx
  00260	74 14		 je	 SHORT $LN48@float_pow
  00262	66 0f 28 ce	 movapd	 xmm1, xmm6
  00266	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00271	66 44 0f 28 c0	 movapd	 xmm8, xmm0
$LN48@float_pow:
  00276	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  0027b	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00280	e9 b9 01 00 00	 jmp	 $LN66@float_pow
$LN16@float_pow:

; 692  :     }
; 693  :     if (iv == 0.0) {  /* 0**w is: 0 for w positive, 1 for w zero

  00285	66 41 0f 2e f0	 ucomisd xmm6, xmm8
  0028a	7a 64		 jp	 SHORT $LN15@float_pow
  0028c	75 62		 jne	 SHORT $LN15@float_pow

; 694  :                          (already dealt with above), and an error
; 695  :                          if w is negative. */
; 696  :         int iw_is_odd = DOUBLE_IS_ODD_INTEGER(iw);

  0028e	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00296	66 0f 28 c7	 movapd	 xmm0, xmm7
  0029a	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  002a2	e8 00 00 00 00	 call	 fmod
  002a7	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  002af	7a 07		 jp	 SHORT $LN51@float_pow
  002b1	75 05		 jne	 SHORT $LN51@float_pow
  002b3	bb 01 00 00 00	 mov	 ebx, 1
$LN51@float_pow:

; 697  :         if (iw < 0.0) {

  002b8	66 44 0f 2f c7	 comisd	 xmm8, xmm7
  002bd	76 1a		 jbe	 SHORT $LN14@float_pow

; 698  :             PyErr_SetString(PyExc_ZeroDivisionError,
; 699  :                             "0.0 cannot be raised to a "
; 700  :                             "negative power");

  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ZeroDivisionError
  002c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IINHJLK@0?40?5cannot?5be?5raised?5to?5a?5negati@
  002cd	e8 00 00 00 00	 call	 PyErr_SetString

; 701  :             return NULL;

  002d2	33 c0		 xor	 eax, eax
  002d4	e9 65 01 00 00	 jmp	 $LN66@float_pow
$LN14@float_pow:

; 702  :         }
; 703  :         /* use correct sign if iw is odd */
; 704  :         return PyFloat_FromDouble(iw_is_odd ? iv : 0.0);

  002d9	85 db		 test	 ebx, ebx
  002db	75 05		 jne	 SHORT $LN53@float_pow
  002dd	66 41 0f 28 f0	 movapd	 xmm6, xmm8
$LN53@float_pow:
  002e2	66 0f 28 c6	 movapd	 xmm0, xmm6
  002e6	e8 00 00 00 00	 call	 PyFloat_FromDouble
  002eb	e9 4e 01 00 00	 jmp	 $LN66@float_pow
$LN15@float_pow:

; 705  :     }
; 706  : 
; 707  :     if (iv < 0.0) {

  002f0	66 44 0f 2f c6	 comisd	 xmm8, xmm6
  002f5	f2 44 0f 10 0d
	00 00 00 00	 movsdx	 xmm9, QWORD PTR __real@3ff0000000000000
  002fe	44 0f 29 54 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm10
  00304	f2 44 0f 10 15
	00 00 00 00	 movsdx	 xmm10, QWORD PTR __mask@@NegDouble@
  0030d	76 3d		 jbe	 SHORT $LN55@float_pow

; 708  :         /* Whether this is an error is a mess, and bumps into libm
; 709  :          * bugs so we have to figure it out ourselves.
; 710  :          */
; 711  :         if (iw != floor(iw)) {

  0030f	66 0f 28 c7	 movapd	 xmm0, xmm7
  00313	e8 00 00 00 00	 call	 floor
  00318	66 0f 2e f8	 ucomisd xmm7, xmm0
  0031c	7a 4e		 jp	 SHORT $LN59@float_pow
  0031e	75 4c		 jne	 SHORT $LN59@float_pow

; 716  :         }
; 717  :         /* iw is an exact integer, albeit perhaps a very large
; 718  :          * one.  Replace iv by its absolute value and remember
; 719  :          * to negate the pow result if iw is odd.
; 720  :          */
; 721  :         iv = -iv;
; 722  :         negate_result = DOUBLE_IS_ODD_INTEGER(iw);

  00320	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00328	66 0f 28 c7	 movapd	 xmm0, xmm7
  0032c	66 41 0f 57 f2	 xorpd	 xmm6, xmm10
  00331	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  00339	e8 00 00 00 00	 call	 fmod
  0033e	66 41 0f 2e c1	 ucomisd xmm0, xmm9
  00343	7a 07		 jp	 SHORT $LN55@float_pow
  00345	75 05		 jne	 SHORT $LN55@float_pow
  00347	bb 01 00 00 00	 mov	 ebx, 1
$LN55@float_pow:

; 723  :     }
; 724  : 
; 725  :     if (iv == 1.0) { /* 1**w is 1, even 1**inf and 1**nan */

  0034c	66 41 0f 2e f1	 ucomisd xmm6, xmm9
  00351	7a 31		 jp	 SHORT $LN11@float_pow
  00353	75 2f		 jne	 SHORT $LN11@float_pow

; 726  :         /* (-1) ** large_integer also ends up here.  Here's an
; 727  :          * extract from the comments for the previous
; 728  :          * implementation explaining why this special case is
; 729  :          * necessary:
; 730  :          *
; 731  :          * -1 raised to an exact integer should never be exceptional.
; 732  :          * Alas, some libms (chiefly glibc as of early 2003) return
; 733  :          * NaN and set EDOM on pow(-1, large_int) if the int doesn't
; 734  :          * happen to be representable in a *C* integer.  That's a
; 735  :          * bug.
; 736  :          */
; 737  :         return PyFloat_FromDouble(negate_result ? -1.0 : 1.0);

  00355	85 db		 test	 ebx, ebx
  00357	74 09		 je	 SHORT $LN56@float_pow
  00359	f2 44 0f 10 0d
	00 00 00 00	 movsdx	 xmm9, QWORD PTR __real@bff0000000000000
$LN56@float_pow:
  00362	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00367	e9 c7 00 00 00	 jmp	 $LN68@float_pow
$LN59@float_pow:

; 712  :             /* Negative numbers raised to fractional powers
; 713  :              * become complex.
; 714  :              */
; 715  :             return PyComplex_Type.tp_as_number->nb_power(v, w, z);

  0036c	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR PyComplex_Type+184
  00373	4c 8b c5	 mov	 r8, rbp
  00376	48 8b d6	 mov	 rdx, rsi
  00379	48 8b cf	 mov	 rcx, rdi
  0037c	ff 50 28	 call	 QWORD PTR [rax+40]
  0037f	e9 b4 00 00 00	 jmp	 $LN67@float_pow
$LN11@float_pow:

; 738  :     }
; 739  : 
; 740  :     /* Now iv and iw are finite, iw is nonzero, and iv is
; 741  :      * positive and not equal to 1.0.  We finally allow
; 742  :      * the platform pow to step in and do the rest.
; 743  :      */
; 744  :     errno = 0;

  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 745  :     PyFPE_START_PROTECT("pow", return NULL)
; 746  :     ix = pow(iv, iw);

  0038a	66 0f 28 cf	 movapd	 xmm1, xmm7
  0038e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00392	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00398	e8 00 00 00 00	 call	 pow
  0039d	66 0f 28 f0	 movapd	 xmm6, xmm0

; 747  :     PyFPE_END_PROTECT(ix)
; 748  :     Py_ADJUST_ERANGE1(ix);

  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003a7	83 38 00	 cmp	 DWORD PTR [rax], 0
  003aa	75 2e		 jne	 SHORT $LN7@float_pow
  003ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  003b3	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  003b7	66 0f 2e f0	 ucomisd xmm6, xmm0
  003bb	7a 02		 jp	 SHORT $LN58@float_pow
  003bd	74 0d		 je	 SHORT $LN5@float_pow
$LN58@float_pow:
  003bf	66 41 0f 57 c2	 xorpd	 xmm0, xmm10
  003c4	66 0f 2e f0	 ucomisd xmm6, xmm0
  003c8	7a 30		 jp	 SHORT $LN9@float_pow
  003ca	75 2e		 jne	 SHORT $LN9@float_pow
$LN5@float_pow:
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003d2	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  003d8	eb 20		 jmp	 SHORT $LN9@float_pow
$LN7@float_pow:
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003e0	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  003e3	75 15		 jne	 SHORT $LN9@float_pow
  003e5	66 41 0f 2e f0	 ucomisd xmm6, xmm8
  003ea	7a 0e		 jp	 SHORT $LN9@float_pow
  003ec	75 0c		 jne	 SHORT $LN9@float_pow
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003f4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN9@float_pow:

; 749  :     if (negate_result)

  003fa	85 db		 test	 ebx, ebx
  003fc	74 05		 je	 SHORT $LN2@float_pow

; 750  :         ix = -ix;

  003fe	66 41 0f 57 f2	 xorpd	 xmm6, xmm10
$LN2@float_pow:

; 751  : 
; 752  :     if (errno != 0) {

  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00409	83 38 00	 cmp	 DWORD PTR [rax], 0
  0040c	74 21		 je	 SHORT $LN1@float_pow

; 753  :         /* We don't expect any errno value other than ERANGE, but
; 754  :          * the range of libm bugs appears unbounded.
; 755  :          */
; 756  :         PyErr_SetFromErrno(errno == ERANGE ? PyExc_OverflowError :
; 757  :                              PyExc_ValueError);

  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00414	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0041b	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  0041e	48 0f 44 0d 00
	00 00 00	 cmove	 rcx, QWORD PTR PyExc_OverflowError
  00426	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 758  :         return NULL;

  0042b	33 c0		 xor	 eax, eax
  0042d	eb 09		 jmp	 SHORT $LN67@float_pow
$LN1@float_pow:

; 759  :     }
; 760  :     return PyFloat_FromDouble(ix);

  0042f	66 0f 28 c6	 movapd	 xmm0, xmm6
$LN68@float_pow:
  00433	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN67@float_pow:
  00438	44 0f 28 54 24
	20		 movaps	 xmm10, XMMWORD PTR [rsp+32]
$LN66@float_pow:
  0043e	44 0f 28 4c 24
	30		 movaps	 xmm9, XMMWORD PTR [rsp+48]
$LN65@float_pow:
  00444	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
$LN64@float_pow:
  0044a	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
$LN63@float_pow:
  0044f	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00454	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]

; 761  : }

  00459	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0045d	5f		 pop	 rdi
  0045e	5e		 pop	 rsi
  0045f	5d		 pop	 rbp
  00460	5b		 pop	 rbx
  00461	c3		 ret	 0
float_pow ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT float_neg
_TEXT	SEGMENT
v$ = 8
float_neg PROC						; COMDAT

; 768  :     return PyFloat_FromDouble(-v->ob_fval);

  00000	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  00005	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@

; 769  : }

  0000d	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_neg ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT float_abs
_TEXT	SEGMENT
v$ = 8
float_abs PROC						; COMDAT

; 774  :     return PyFloat_FromDouble(fabs(v->ob_fval));

  00000	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  00005	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@

; 775  : }

  0000d	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_abs ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT float_bool
_TEXT	SEGMENT
v$ = 8
float_bool PROC						; COMDAT

; 780  :     return v->ob_fval != 0.0;

  00000	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]
  00005	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0000d	7a 05		 jp	 SHORT $LN5@float_bool
  0000f	75 03		 jne	 SHORT $LN5@float_bool
  00011	33 c0		 xor	 eax, eax

; 781  : }

  00013	c3		 ret	 0
$LN5@float_bool:

; 780  :     return v->ob_fval != 0.0;

  00014	b8 01 00 00 00	 mov	 eax, 1

; 781  : }

  00019	c3		 ret	 0
float_bool ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_is_integer DD imagerel float_is_integer
	DD	imagerel float_is_integer+56
	DD	imagerel $unwind$float_is_integer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$float_is_integer DD imagerel float_is_integer+56
	DD	imagerel float_is_integer+169
	DD	imagerel $chain$0$float_is_integer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$float_is_integer DD imagerel float_is_integer+169
	DD	imagerel float_is_integer+269
	DD	imagerel $chain$2$float_is_integer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$float_is_integer DD imagerel float_is_integer+269
	DD	imagerel float_is_integer+295
	DD	imagerel $chain$4$float_is_integer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$float_is_integer DD 020021H
	DD	083400H
	DD	imagerel float_is_integer
	DD	imagerel float_is_integer+56
	DD	imagerel $unwind$float_is_integer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$float_is_integer DD 020021H
	DD	083400H
	DD	imagerel float_is_integer
	DD	imagerel float_is_integer+56
	DD	imagerel $unwind$float_is_integer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$float_is_integer DD 020521H
	DD	083405H
	DD	imagerel float_is_integer
	DD	imagerel float_is_integer+56
	DD	imagerel $unwind$float_is_integer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_is_integer DD 030901H
	DD	036809H
	DD	08204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
xdata	ENDS
;	COMDAT float_is_integer
_TEXT	SEGMENT
v$ = 80
float_is_integer PROC					; COMDAT

; 785  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6

; 786  :     double x = PyFloat_AsDouble(v);

  00009	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 787  :     PyObject *o;
; 788  : 
; 789  :     if (x == -1.0 && PyErr_Occurred())

  0000e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00016	66 0f 28 f0	 movapd	 xmm6, xmm0
  0001a	7a 18		 jp	 SHORT $LN3@float_is_i
  0001c	75 16		 jne	 SHORT $LN3@float_is_i
  0001e	e8 00 00 00 00	 call	 PyErr_Occurred
  00023	48 85 c0	 test	 rax, rax
  00026	74 0c		 je	 SHORT $LN3@float_is_i

; 790  :         return NULL;

  00028	33 c0		 xor	 eax, eax

; 804  : }

  0002a	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
$LN3@float_is_i:

; 791  :     if (!Py_IS_FINITE(x))

  00034	66 0f 28 c6	 movapd	 xmm0, xmm6
  00038	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00043	85 c0		 test	 eax, eax
  00045	75 62		 jne	 SHORT $LN2@float_is_i

; 792  :         Py_RETURN_FALSE;

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00053	85 c0		 test	 eax, eax
  00055	0f 85 ba 00 00
	00		 jne	 $LN9@float_is_i
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00069	4c 8b cb	 mov	 r9, rbx
  0006c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007f	85 c0		 test	 eax, eax
  00081	75 0d		 jne	 SHORT $LN8@float_is_i
  00083	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  0008a	0f 84 85 00 00
	00		 je	 $LN9@float_is_i
$LN8@float_is_i:
  00090	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80

; 803  :     return o;

  00097	48 8b c3	 mov	 rax, rbx
  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 804  : }

  0009f	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
$LN2@float_is_i:

; 793  :     errno = 0;

  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 794  :     PyFPE_START_PROTECT("is_integer", return NULL)
; 795  :     o = (floor(x) == x) ? Py_True : Py_False;

  000af	66 0f 28 c6	 movapd	 xmm0, xmm6
  000b3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000b9	e8 00 00 00 00	 call	 floor
  000be	66 0f 2e c6	 ucomisd xmm0, xmm6
  000c2	7a 09		 jp	 SHORT $LN6@float_is_i
  000c4	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  000cb	74 07		 je	 SHORT $LN7@float_is_i
$LN6@float_is_i:
  000cd	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
$LN7@float_is_i:

; 796  :     PyFPE_END_PROTECT(x)
; 797  :     if (errno != 0) {

  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000da	83 38 00	 cmp	 DWORD PTR [rax], 0
  000dd	74 2e		 je	 SHORT $LN1@float_is_i

; 798  :         PyErr_SetFromErrno(errno == ERANGE ? PyExc_OverflowError :
; 799  :                              PyExc_ValueError);

  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ec	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000ef	48 0f 44 0d 00
	00 00 00	 cmove	 rcx, QWORD PTR PyExc_OverflowError
  000f7	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  000fc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 800  :         return NULL;

  00101	33 c0		 xor	 eax, eax

; 804  : }

  00103	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00108	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010c	c3		 ret	 0
$LN1@float_is_i:

; 801  :     }
; 802  :     Py_INCREF(o);

  0010d	48 8b cb	 mov	 rcx, rbx
  00110	e8 00 00 00 00	 call	 _Py_IncRef
$LN9@float_is_i:

; 804  : }

  00115	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  0011a	48 8b c3	 mov	 rax, rbx
  0011d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00122	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00126	c3		 ret	 0
float_is_integer ENDP
_TEXT	ENDS
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@c1e0000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_trunc DD imagerel float_trunc
	DD	imagerel float_trunc+78
	DD	imagerel $unwind$float_trunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_trunc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_trunc
_TEXT	SEGMENT
v$ = 48
wholepart$ = 56
float_trunc PROC					; COMDAT

; 837  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 838  :     double x = PyFloat_AsDouble(v);

  00004	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 839  :     double wholepart;           /* integral portion of x, rounded toward 0 */
; 840  : 
; 841  :     (void)modf(x, &wholepart);

  00009	48 8d 54 24 38	 lea	 rdx, QWORD PTR wholepart$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf

; 842  :     /* Try to get out cheap if this fits in a Python int.  The attempt
; 843  :      * to cast to long must be protected, as C doesn't define what
; 844  :      * happens if the double is too big to fit in a long.  Some rare
; 845  :      * systems raise an exception then (RISCOS was mentioned as one,
; 846  :      * and someone using a non-default option on Sun also bumped into
; 847  :      * that).  Note that checking for >= and <= LONG_{MIN,MAX} would
; 848  :      * still be vulnerable:  if a long has more bits of precision than
; 849  :      * a double, casting MIN/MAX to double may yield an approximation,
; 850  :      * and if that's rounded up, then, e.g., wholepart=LONG_MAX+1 would
; 851  :      * yield true from the C expression wholepart<=LONG_MAX, despite
; 852  :      * that wholepart is actually greater than LONG_MAX.
; 853  :      */
; 854  :     if (LONG_MIN < wholepart && wholepart < LONG_MAX) {

  00014	f2 0f 10 6c 24
	38		 movsdx	 xmm5, QWORD PTR wholepart$[rsp]
  0001a	66 0f 2f 2d 00
	00 00 00	 comisd	 xmm5, QWORD PTR __real@c1e0000000000000
  00022	76 1c		 jbe	 SHORT $LN1@float_trun
  00024	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41dfffffffc00000
  0002c	66 0f 2f c5	 comisd	 xmm0, xmm5
  00030	76 0e		 jbe	 SHORT $LN1@float_trun

; 855  :         const long aslong = (long)wholepart;

  00032	f2 0f 2c cd	 cvttsd2si ecx, xmm5

; 856  :         return PyLong_FromLong(aslong);

  00036	e8 00 00 00 00	 call	 PyLong_FromLong

; 859  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
$LN1@float_trun:

; 857  :     }
; 858  :     return PyLong_FromDouble(wholepart);

  00040	66 0f 28 c5	 movapd	 xmm0, xmm5
  00044	e8 00 00 00 00	 call	 PyLong_FromDouble

; 859  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
float_trunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@ ; `string'
PUBLIC	??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
EXTRN	_Py_dg_freedtoa:PROC
EXTRN	_Py_dg_strtod:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_Py_dg_dtoa:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$double_round DD imagerel double_round
	DD	imagerel double_round+85
	DD	imagerel $unwind$double_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$double_round DD imagerel double_round+85
	DD	imagerel double_round+160
	DD	imagerel $chain$0$double_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$double_round DD imagerel double_round+160
	DD	imagerel double_round+314
	DD	imagerel $chain$1$double_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$double_round DD imagerel double_round+314
	DD	imagerel double_round+341
	DD	imagerel $chain$2$double_round
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$double_round DD imagerel double_round+341
	DD	imagerel double_round+361
	DD	imagerel $chain$3$double_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$double_round DD 021H
	DD	imagerel double_round
	DD	imagerel double_round+85
	DD	imagerel $unwind$double_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$double_round DD 021H
	DD	imagerel double_round+85
	DD	imagerel double_round+160
	DD	imagerel $chain$0$double_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$double_round DD 020821H
	DD	0b6808H
	DD	imagerel double_round+85
	DD	imagerel double_round+160
	DD	imagerel $chain$0$double_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$double_round DD 020821H
	DD	01c7408H
	DD	imagerel double_round
	DD	imagerel double_round+85
	DD	imagerel $unwind$double_round
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$double_round DD 071201H
	DD	01d3412H
	DD	0180112H
	DD	06009c00bH
	DD	05008H
xdata	ENDS
;	COMDAT ??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@
CONST	SEGMENT
??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@ DB 'rounded val'
	DB	'ue too large to represent', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@
CONST	SEGMENT
??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@ DB '%s0%se%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT double_round
_TEXT	SEGMENT
buf_end$ = 48
shortbuf$ = 64
x$ = 224
ndigits$ = 232
decpt$ = 240
sign$ = 248
double_round PROC					; COMDAT

; 871  : double_round(double x, int ndigits) {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	41 54		 push	 r12
  0000b	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 872  : 
; 873  :     double rounded;
; 874  :     Py_ssize_t buflen, mybuflen=100;
; 875  :     char *buf, *buf_end, shortbuf[100], *mybuf=shortbuf;
; 876  :     int decpt, sign;
; 877  :     PyObject *result = NULL;
; 878  :     _Py_SET_53BIT_PRECISION_HEADER;
; 879  : 
; 880  :     /* round to a decimal string */
; 881  :     _Py_SET_53BIT_PRECISION_START;
; 882  :     buf = _Py_dg_dtoa(x, 3, ndigits, &decpt, &sign, &buf_end);

  00012	48 8d 44 24 30	 lea	 rax, QWORD PTR buf_end$[rsp]
  00017	44 8b c2	 mov	 r8d, edx
  0001a	33 ed		 xor	 ebp, ebp
  0001c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00021	49 8d 43 20	 lea	 rax, QWORD PTR [r11+32]
  00025	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00029	8d 55 03	 lea	 edx, QWORD PTR [rbp+3]
  0002c	41 bc 64 00 00
	00		 mov	 r12d, 100		; 00000064H
  00032	48 8d 5c 24 40	 lea	 rbx, QWORD PTR shortbuf$[rsp]
  00037	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003c	e8 00 00 00 00	 call	 _Py_dg_dtoa
  00041	48 8b f0	 mov	 rsi, rax

; 883  :     _Py_SET_53BIT_PRECISION_END;
; 884  :     if (buf == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	75 0c		 jne	 SHORT $LN6@double_rou

; 885  :         PyErr_NoMemory();

  00049	e8 00 00 00 00	 call	 PyErr_NoMemory

; 886  :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 00 01 00 00	 jmp	 $LN7@double_rou
$LN6@double_rou:
  00055	48 89 bc 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rdi

; 887  :     }
; 888  : 
; 889  :     /* Get new buffer if shortbuf is too small.  Space needed <= buf_end -
; 890  :     buf + 8: (1 extra for '0', 1 for sign, 5 for exp, 1 for '\0').  */
; 891  :     buflen = buf_end - buf;

  0005d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR buf_end$[rsp]
  00062	48 2b f8	 sub	 rdi, rax

; 892  :     if (buflen + 8 > mybuflen) {

  00065	48 8d 47 08	 lea	 rax, QWORD PTR [rdi+8]
  00069	49 3b c4	 cmp	 rax, r12
  0006c	7e 1d		 jle	 SHORT $LN4@double_rou

; 893  :         mybuflen = buflen+8;
; 894  :         mybuf = (char *)PyMem_Malloc(mybuflen);

  0006e	48 8b c8	 mov	 rcx, rax
  00071	4c 8b e0	 mov	 r12, rax
  00074	e8 00 00 00 00	 call	 PyMem_Malloc
  00079	48 8b d8	 mov	 rbx, rax

; 895  :         if (mybuf == NULL) {

  0007c	48 85 c0	 test	 rax, rax
  0007f	75 0a		 jne	 SHORT $LN4@double_rou

; 896  :             PyErr_NoMemory();

  00081	e8 00 00 00 00	 call	 PyErr_NoMemory

; 897  :             goto exit;

  00086	e9 b7 00 00 00	 jmp	 $exit$20781
$LN4@double_rou:

; 898  :         }
; 899  :     }
; 900  :     /* copy buf to mybuf, adding exponent, sign and leading 0 */
; 901  :     PyOS_snprintf(mybuf, mybuflen, "%s0%se%d", (sign ? "-" : ""),
; 902  :                   buf, decpt - (int)buflen);

  0008b	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR decpt$[rsp]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01JOAMLHOP@?9?$AA@
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a0	0f 29 b4 24 b0
	00 00 00	 movaps	 XMMWORD PTR [rsp+176], xmm6
  000a8	2b c7		 sub	 eax, edi
  000aa	39 ac 24 f8 00
	00 00		 cmp	 DWORD PTR sign$[rsp], ebp
  000b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08IBNADMJP@?$CFs0?$CFse?$CFd?$AA@
  000b8	4c 0f 45 c9	 cmovne	 r9, rcx
  000bc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000c0	49 8b d4	 mov	 rdx, r12
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000cb	e8 00 00 00 00	 call	 PyOS_snprintf

; 903  : 
; 904  :     /* and convert the resulting string back to a double */
; 905  :     errno = 0;

  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 906  :     _Py_SET_53BIT_PRECISION_START;
; 907  :     rounded = _Py_dg_strtod(mybuf, NULL);

  000d6	33 d2		 xor	 edx, edx
  000d8	48 8b cb	 mov	 rcx, rbx
  000db	89 28		 mov	 DWORD PTR [rax], ebp
  000dd	e8 00 00 00 00	 call	 _Py_dg_strtod
  000e2	66 0f 28 f0	 movapd	 xmm6, xmm0

; 908  :     _Py_SET_53BIT_PRECISION_END;
; 909  :     if (errno == ERANGE && fabs(rounded) >= 1.)

  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ec	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000ef	75 2b		 jne	 SHORT $LN3@double_rou
  000f1	66 0f 28 ce	 movapd	 xmm1, xmm6
  000f5	66 0f 54 0d 00
	00 00 00	 andpd	 xmm1, QWORD PTR __mask@@AbsDouble@
  000fd	66 0f 2f 0d 00
	00 00 00	 comisd	 xmm1, QWORD PTR __real@3ff0000000000000
  00105	72 15		 jb	 SHORT $LN3@double_rou

; 910  :         PyErr_SetString(PyExc_OverflowError,
; 911  :                         "rounded value too large to represent");

  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@EAFJGAOB@rounded?5value?5too?5large?5to?5repre@
  00115	e8 00 00 00 00	 call	 PyErr_SetString

; 912  :     else

  0011a	eb 0c		 jmp	 SHORT $LN2@double_rou
$LN3@double_rou:

; 913  :         result = PyFloat_FromDouble(rounded);

  0011c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00120	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00125	48 8b e8	 mov	 rbp, rax
$LN2@double_rou:

; 914  : 
; 915  :     /* done computing value;  now clean up */
; 916  :     if (mybuf != shortbuf)

  00128	0f 28 b4 24 b0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+176]
  00130	48 8d 44 24 40	 lea	 rax, QWORD PTR shortbuf$[rsp]
  00135	48 3b d8	 cmp	 rbx, rax
  00138	74 08		 je	 SHORT $exit$20781

; 917  :         PyMem_Free(mybuf);

  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	e8 00 00 00 00	 call	 PyMem_Free
$exit$20781:

; 918  :   exit:
; 919  :     _Py_dg_freedtoa(buf);

  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 _Py_dg_freedtoa
  0014a	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+224]

; 920  :     return result;

  00152	48 8b c5	 mov	 rax, rbp
$LN7@double_rou:

; 921  : }

  00155	48 8b 9c 24 e8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+232]
  0015d	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00164	41 5c		 pop	 r12
  00166	5e		 pop	 rsi
  00167	5d		 pop	 rbp
  00168	c3		 ret	 0
double_round ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	round:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_round DD imagerel float_round
	DD	imagerel float_round+265
	DD	imagerel $unwind$float_round
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_round DD 040b01H
	DD	02680bH
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_round
_TEXT	SEGMENT
v$ = 64
args$ = 72
o_ndigits$ = 80
float_round PROC					; COMDAT

; 979  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0000b	48 8b da	 mov	 rbx, rdx

; 980  :     double x, rounded;
; 981  :     PyObject *o_ndigits = NULL;

  0000e	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR o_ndigits$[rsp], 0

; 982  :     Py_ssize_t ndigits;
; 983  : 
; 984  :     x = PyFloat_AsDouble(v);

  00017	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 985  :     if (!PyArg_ParseTuple(args, "|O", &o_ndigits))

  0001c	4c 8d 44 24 50	 lea	 r8, QWORD PTR o_ndigits$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00028	48 8b cb	 mov	 rcx, rbx
  0002b	66 0f 28 f0	 movapd	 xmm6, xmm0
  0002f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00034	85 c0		 test	 eax, eax
  00036	75 0d		 jne	 SHORT $LN9@float_roun
$LN12@float_roun:

; 986  :         return NULL;

  00038	33 c0		 xor	 eax, eax

; 1019 : #undef NDIGITS_MAX
; 1020 : #undef NDIGITS_MIN
; 1021 : }

  0003a	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN9@float_roun:

; 987  :     if (o_ndigits == NULL) {

  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o_ndigits$[rsp]
  0004a	48 85 c9	 test	 rcx, rcx
  0004d	75 4e		 jne	 SHORT $LN8@float_roun

; 988  :         /* single-argument round: round to nearest integer */
; 989  :         rounded = round(x);

  0004f	66 0f 28 c6	 movapd	 xmm0, xmm6
  00053	e8 00 00 00 00	 call	 round

; 990  :         if (fabs(x-rounded) == 0.5)

  00058	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3fe0000000000000
  00060	66 0f 28 ce	 movapd	 xmm1, xmm6
  00064	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00068	66 0f 54 0d 00
	00 00 00	 andpd	 xmm1, QWORD PTR __mask@@AbsDouble@
  00070	66 0f 2e ca	 ucomisd xmm1, xmm2
  00074	7a 17		 jp	 SHORT $LN7@float_roun
  00076	75 15		 jne	 SHORT $LN7@float_roun

; 991  :             /* halfway case: round to even */
; 992  :             rounded = 2.0*round(x/2.0);

  00078	f2 0f 59 f2	 mulsd	 xmm6, xmm2
  0007c	66 0f 28 c6	 movapd	 xmm0, xmm6
  00080	e8 00 00 00 00	 call	 round
  00085	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
$LN7@float_roun:

; 993  :         return PyLong_FromDouble(rounded);

  0008d	e8 00 00 00 00	 call	 PyLong_FromDouble

; 1019 : #undef NDIGITS_MAX
; 1020 : #undef NDIGITS_MIN
; 1021 : }

  00092	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00097	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009b	5b		 pop	 rbx
  0009c	c3		 ret	 0
$LN8@float_roun:

; 994  :     }
; 995  : 
; 996  :     /* interpret second argument as a Py_ssize_t; clips on overflow */
; 997  :     ndigits = PyNumber_AsSsize_t(o_ndigits, NULL);

  0009d	33 d2		 xor	 edx, edx
  0009f	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000a4	48 8b d8	 mov	 rbx, rax

; 998  :     if (ndigits == -1 && PyErr_Occurred())

  000a7	48 83 f8 ff	 cmp	 rax, -1
  000ab	75 0a		 jne	 SHORT $LN6@float_roun
  000ad	e8 00 00 00 00	 call	 PyErr_Occurred
  000b2	48 85 c0	 test	 rax, rax

; 999  :         return NULL;

  000b5	75 81		 jne	 SHORT $LN12@float_roun
$LN6@float_roun:

; 1000 : 
; 1001 :     /* nans and infinities round to themselves */
; 1002 :     if (!Py_IS_FINITE(x))

  000b7	66 0f 28 c6	 movapd	 xmm0, xmm6
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000c1	85 c0		 test	 eax, eax

; 1003 :         return PyFloat_FromDouble(x);

  000c3	74 1a		 je	 SHORT $LN13@float_roun

; 1004 : 
; 1005 :     /* Deal with extreme values for ndigits. For ndigits > NDIGITS_MAX, x
; 1006 :        always rounds to itself.  For ndigits < NDIGITS_MIN, x always
; 1007 :        rounds to +-0.0.  Here 0.30103 is an upper bound for log10(2). */
; 1008 : #define NDIGITS_MAX ((int)((DBL_MANT_DIG-DBL_MIN_EXP) * 0.30103))
; 1009 : #define NDIGITS_MIN (-(int)((DBL_MAX_EXP + 1) * 0.30103))
; 1010 :     if (ndigits > NDIGITS_MAX)

  000c5	48 81 fb 43 01
	00 00		 cmp	 rbx, 323		; 00000143H

; 1011 :         /* return x */
; 1012 :         return PyFloat_FromDouble(x);

  000cc	7f 11		 jg	 SHORT $LN13@float_roun

; 1013 :     else if (ndigits < NDIGITS_MIN)

  000ce	48 81 fb cc fe
	ff ff		 cmp	 rbx, -308		; fffffffffffffeccH
  000d5	7d 1c		 jge	 SHORT $LN2@float_roun

; 1014 :         /* return 0.0, but with sign of x */
; 1015 :         return PyFloat_FromDouble(0.0*x);

  000d7	f2 0f 59 35 00
	00 00 00	 mulsd	 xmm6, QWORD PTR __real@0000000000000000
$LN13@float_roun:
  000df	66 0f 28 c6	 movapd	 xmm0, xmm6
  000e3	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 1019 : #undef NDIGITS_MAX
; 1020 : #undef NDIGITS_MIN
; 1021 : }

  000e8	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
$LN2@float_roun:

; 1016 :     else
; 1017 :         /* finite x, and ndigits is not unreasonably large */
; 1018 :         return double_round(x, (int)ndigits);

  000f3	66 0f 28 c6	 movapd	 xmm0, xmm6
  000f7	8b d3		 mov	 edx, ebx
  000f9	e8 00 00 00 00	 call	 double_round

; 1019 : #undef NDIGITS_MAX
; 1020 : #undef NDIGITS_MIN
; 1021 : }

  000fe	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00103	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00107	5b		 pop	 rbx
  00108	c3		 ret	 0
float_round ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_float DD imagerel float_float
	DD	imagerel float_float+105
	DD	imagerel $unwind$float_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_float DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
xdata	ENDS
;	COMDAT float_float
_TEXT	SEGMENT
v$ = 64
float_float PROC					; COMDAT

; 1025 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1026 :     if (PyFloat_CheckExact(v))

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00014	75 44		 jne	 SHORT $LN2@float_floa

; 1027 :         Py_INCREF(v);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN9@float_floa
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN5@float_floa
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H

; 1028 :     else
; 1029 :         v = PyFloat_FromDouble(((PyFloatObject *)v)->ob_fval);

  0004b	74 04		 je	 SHORT $LN9@float_floa

; 1027 :         Py_INCREF(v);

$LN5@float_floa:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@float_floa:

; 1030 :     return v;

  00051	48 8b c3	 mov	 rax, rbx

; 1031 : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN2@float_floa:

; 1028 :     else
; 1029 :         v = PyFloat_FromDouble(((PyFloatObject *)v)->ob_fval);

  0005a	f2 0f 10 41 60	 movsdx	 xmm0, QWORD PTR [rcx+96]

; 1031 : }

  0005f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00063	5b		 pop	 rbx
  00064	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_float ENDP
_TEXT	ENDS
EXTRN	Py_hexdigits:QWORD
; Function compile flags: /Ogtpy
;	COMDAT char_from_hex
_TEXT	SEGMENT
x$ = 8
char_from_hex PROC					; COMDAT

; 1038 :     assert(0 <= x && x < 16);
; 1039 :     return Py_hexdigits[x];

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00007	48 63 d1	 movsxd	 rdx, ecx
  0000a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]

; 1040 : }

  0000e	c3		 ret	 0
char_from_hex ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT hex_from_char
_TEXT	SEGMENT
c$ = 8
hex_from_char PROC					; COMDAT

; 1044 :     int x;
; 1045 :     switch(c) {

  00000	0f be c1	 movsx	 eax, cl
  00003	83 c0 d0	 add	 eax, -48		; ffffffffffffffd0H
  00006	83 f8 36	 cmp	 eax, 54			; 00000036H
  00009	77 7a		 ja	 SHORT $LN1@hex_from_c
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00012	48 98		 cdqe
  00014	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN22@hex_from_c[rdx+rax]
  0001c	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN23@hex_from_c[rdx+rax*4]
  00023	48 03 ca	 add	 rcx, rdx
  00026	ff e1		 jmp	 rcx
$LN17@hex_from_c:

; 1046 :     case '0':
; 1047 :         x = 0;

  00028	33 c0		 xor	 eax, eax

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0002a	c3		 ret	 0
$LN16@hex_from_c:

; 1048 :         break;
; 1049 :     case '1':
; 1050 :         x = 1;

  0002b	b8 01 00 00 00	 mov	 eax, 1

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00030	c3		 ret	 0
$LN15@hex_from_c:

; 1051 :         break;
; 1052 :     case '2':
; 1053 :         x = 2;

  00031	b8 02 00 00 00	 mov	 eax, 2

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00036	c3		 ret	 0
$LN14@hex_from_c:

; 1054 :         break;
; 1055 :     case '3':
; 1056 :         x = 3;

  00037	b8 03 00 00 00	 mov	 eax, 3

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0003c	c3		 ret	 0
$LN13@hex_from_c:

; 1057 :         break;
; 1058 :     case '4':
; 1059 :         x = 4;

  0003d	b8 04 00 00 00	 mov	 eax, 4

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00042	c3		 ret	 0
$LN12@hex_from_c:

; 1060 :         break;
; 1061 :     case '5':
; 1062 :         x = 5;

  00043	b8 05 00 00 00	 mov	 eax, 5

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00048	c3		 ret	 0
$LN11@hex_from_c:

; 1063 :         break;
; 1064 :     case '6':
; 1065 :         x = 6;

  00049	b8 06 00 00 00	 mov	 eax, 6

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0004e	c3		 ret	 0
$LN10@hex_from_c:

; 1066 :         break;
; 1067 :     case '7':
; 1068 :         x = 7;

  0004f	b8 07 00 00 00	 mov	 eax, 7

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00054	c3		 ret	 0
$LN9@hex_from_c:

; 1069 :         break;
; 1070 :     case '8':
; 1071 :         x = 8;

  00055	b8 08 00 00 00	 mov	 eax, 8

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0005a	c3		 ret	 0
$LN8@hex_from_c:

; 1072 :         break;
; 1073 :     case '9':
; 1074 :         x = 9;

  0005b	b8 09 00 00 00	 mov	 eax, 9

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00060	c3		 ret	 0
$LN7@hex_from_c:

; 1075 :         break;
; 1076 :     case 'a':
; 1077 :     case 'A':
; 1078 :         x = 10;

  00061	b8 0a 00 00 00	 mov	 eax, 10

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00066	c3		 ret	 0
$LN6@hex_from_c:

; 1079 :         break;
; 1080 :     case 'b':
; 1081 :     case 'B':
; 1082 :         x = 11;

  00067	b8 0b 00 00 00	 mov	 eax, 11

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0006c	c3		 ret	 0
$LN5@hex_from_c:

; 1083 :         break;
; 1084 :     case 'c':
; 1085 :     case 'C':
; 1086 :         x = 12;

  0006d	b8 0c 00 00 00	 mov	 eax, 12

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00072	c3		 ret	 0
$LN4@hex_from_c:

; 1087 :         break;
; 1088 :     case 'd':
; 1089 :     case 'D':
; 1090 :         x = 13;

  00073	b8 0d 00 00 00	 mov	 eax, 13

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00078	c3		 ret	 0
$LN3@hex_from_c:

; 1091 :         break;
; 1092 :     case 'e':
; 1093 :     case 'E':
; 1094 :         x = 14;

  00079	b8 0e 00 00 00	 mov	 eax, 14

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  0007e	c3		 ret	 0
$LN2@hex_from_c:

; 1095 :         break;
; 1096 :     case 'f':
; 1097 :     case 'F':
; 1098 :         x = 15;

  0007f	b8 0f 00 00 00	 mov	 eax, 15

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00084	c3		 ret	 0
$LN1@hex_from_c:

; 1099 :         break;
; 1100 :     default:
; 1101 :         x = -1;

  00085	83 c8 ff	 or	 eax, -1

; 1102 :         break;
; 1103 :     }
; 1104 :     return x;
; 1105 : }

  00088	c3		 ret	 0
  00089	0f 1f 00	 npad	 3
$LN23@hex_from_c:
  0008c	00 00 00 00	 DD	 $LN17@hex_from_c
  00090	00 00 00 00	 DD	 $LN16@hex_from_c
  00094	00 00 00 00	 DD	 $LN15@hex_from_c
  00098	00 00 00 00	 DD	 $LN14@hex_from_c
  0009c	00 00 00 00	 DD	 $LN13@hex_from_c
  000a0	00 00 00 00	 DD	 $LN12@hex_from_c
  000a4	00 00 00 00	 DD	 $LN11@hex_from_c
  000a8	00 00 00 00	 DD	 $LN10@hex_from_c
  000ac	00 00 00 00	 DD	 $LN9@hex_from_c
  000b0	00 00 00 00	 DD	 $LN8@hex_from_c
  000b4	00 00 00 00	 DD	 $LN7@hex_from_c
  000b8	00 00 00 00	 DD	 $LN6@hex_from_c
  000bc	00 00 00 00	 DD	 $LN5@hex_from_c
  000c0	00 00 00 00	 DD	 $LN4@hex_from_c
  000c4	00 00 00 00	 DD	 $LN3@hex_from_c
  000c8	00 00 00 00	 DD	 $LN2@hex_from_c
  000cc	00 00 00 00	 DD	 $LN1@hex_from_c
$LN22@hex_from_c:
  000d0	00		 DB	 0
  000d1	01		 DB	 1
  000d2	02		 DB	 2
  000d3	03		 DB	 3
  000d4	04		 DB	 4
  000d5	05		 DB	 5
  000d6	06		 DB	 6
  000d7	07		 DB	 7
  000d8	08		 DB	 8
  000d9	09		 DB	 9
  000da	10		 DB	 16
  000db	10		 DB	 16
  000dc	10		 DB	 16
  000dd	10		 DB	 16
  000de	10		 DB	 16
  000df	10		 DB	 16
  000e0	10		 DB	 16
  000e1	0a		 DB	 10
  000e2	0b		 DB	 11
  000e3	0c		 DB	 12
  000e4	0d		 DB	 13
  000e5	0e		 DB	 14
  000e6	0f		 DB	 15
  000e7	10		 DB	 16
  000e8	10		 DB	 16
  000e9	10		 DB	 16
  000ea	10		 DB	 16
  000eb	10		 DB	 16
  000ec	10		 DB	 16
  000ed	10		 DB	 16
  000ee	10		 DB	 16
  000ef	10		 DB	 16
  000f0	10		 DB	 16
  000f1	10		 DB	 16
  000f2	10		 DB	 16
  000f3	10		 DB	 16
  000f4	10		 DB	 16
  000f5	10		 DB	 16
  000f6	10		 DB	 16
  000f7	10		 DB	 16
  000f8	10		 DB	 16
  000f9	10		 DB	 16
  000fa	10		 DB	 16
  000fb	10		 DB	 16
  000fc	10		 DB	 16
  000fd	10		 DB	 16
  000fe	10		 DB	 16
  000ff	10		 DB	 16
  00100	10		 DB	 16
  00101	0a		 DB	 10
  00102	0b		 DB	 11
  00103	0c		 DB	 12
  00104	0d		 DB	 13
  00105	0e		 DB	 14
  00106	0f		 DB	 15
hex_from_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@	; `string'
PUBLIC	??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@	; `string'
PUBLIC	__real@4030000000000000
PUBLIC	??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@		; `string'
PUBLIC	??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@		; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_hex DD imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$float_hex DD imagerel float_hex+147
	DD	imagerel float_hex+222
	DD	imagerel $chain$0$float_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$float_hex DD imagerel float_hex+222
	DD	imagerel float_hex+250
	DD	imagerel $chain$2$float_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$float_hex DD imagerel float_hex+250
	DD	imagerel float_hex+477
	DD	imagerel $chain$4$float_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$float_hex DD imagerel float_hex+477
	DD	imagerel float_hex+486
	DD	imagerel $chain$6$float_hex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$float_hex DD imagerel float_hex+486
	DD	imagerel float_hex+505
	DD	imagerel $chain$7$float_hex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$float_hex DD 021H
	DD	imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$float_hex DD 020021H
	DD	037800H
	DD	imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$float_hex DD 020021H
	DD	037800H
	DD	imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$float_hex DD 020021H
	DD	037800H
	DD	imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$float_hex DD 020521H
	DD	037805H
	DD	imagerel float_hex
	DD	imagerel float_hex+147
	DD	imagerel $unwind$float_hex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_hex DD 041601H
	DD	046816H
	DD	03006920aH
xdata	ENDS
;	COMDAT ??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@
CONST	SEGMENT
??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@ DB '0x%sp%c%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@
CONST	SEGMENT
??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@ DB '-0x%sp%c%d', 00H ; `string'
CONST	ENDS
;	COMDAT __real@4030000000000000
CONST	SEGMENT
__real@4030000000000000 DQ 04030000000000000r	; 16
CONST	ENDS
;	COMDAT ??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@
CONST	SEGMENT
??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@ DB '0x0.0p+0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@
CONST	SEGMENT
??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@ DB '-0x0.0p+0', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_hex
_TEXT	SEGMENT
s$ = 32
v$ = 96
e$ = 104
x$ = 112
float_hex PROC						; COMDAT

; 1115 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1116 :     double x, m;
; 1117 :     int e, shift, i, si, esign;
; 1118 :     /* Space for 1+(TOHEX_NBITS-1)/4 digits, a decimal point, and the
; 1119 :        trailing NUL byte. */
; 1120 :     char s[(TOHEX_NBITS-1)/4+3];
; 1121 : 
; 1122 :     CONVERT_TO_DOUBLE(v, x);

  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00011	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 39 51 58	 cmp	 QWORD PTR [rcx+88], rdx
  0001d	74 3d		 je	 SHORT $LN15@float_hex
  0001f	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00023	e8 00 00 00 00	 call	 PyType_IsSubtype
  00028	85 c0		 test	 eax, eax
  0002a	75 30		 jne	 SHORT $LN15@float_hex
  0002c	48 8d 54 24 70	 lea	 rdx, QWORD PTR x$[rsp]
  00031	48 8d 4c 24 60	 lea	 rcx, QWORD PTR v$[rsp]
  00036	e8 00 00 00 00	 call	 convert_to_double
  0003b	85 c0		 test	 eax, eax
  0003d	79 10		 jns	 SHORT $LN23@float_hex
  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]

; 1164 : }

  00044	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00049	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN23@float_hex:

; 1116 :     double x, m;
; 1117 :     int e, shift, i, si, esign;
; 1118 :     /* Space for 1+(TOHEX_NBITS-1)/4 digits, a decimal point, and the
; 1119 :        trailing NUL byte. */
; 1120 :     char s[(TOHEX_NBITS-1)/4+3];
; 1121 : 
; 1122 :     CONVERT_TO_DOUBLE(v, x);

  0004f	48 8b 5c 24 60	 mov	 rbx, QWORD PTR v$[rsp]
  00054	f2 0f 10 74 24
	70		 movsdx	 xmm6, QWORD PTR x$[rsp]
  0005a	eb 05		 jmp	 SHORT $LN13@float_hex
$LN15@float_hex:
  0005c	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]
$LN13@float_hex:

; 1123 : 
; 1124 :     if (Py_IS_NAN(x) || Py_IS_INFINITY(x))

  00061	66 0f 28 c6	 movapd	 xmm0, xmm6
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0006b	85 c0		 test	 eax, eax
  0006d	0f 85 73 01 00
	00		 jne	 $LN11@float_hex
  00073	66 0f 28 c6	 movapd	 xmm0, xmm6
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0007d	85 c0		 test	 eax, eax
  0007f	75 12		 jne	 SHORT $LN12@float_hex
  00081	66 0f 28 c6	 movapd	 xmm0, xmm6
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0008b	85 c0		 test	 eax, eax
  0008d	0f 84 53 01 00
	00		 je	 $LN11@float_hex
$LN12@float_hex:
  00093	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7

; 1126 : 
; 1127 :     if (x == 0.0) {

  00098	66 0f 57 ff	 xorpd	 xmm7, xmm7
  0009c	66 0f 2e f7	 ucomisd xmm6, xmm7
  000a0	7a 58		 jp	 SHORT $LN8@float_hex
  000a2	75 56		 jne	 SHORT $LN8@float_hex

; 1128 :         if (copysign(1.0, x) == -1.0)

  000a4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000ac	66 0f 28 ce	 movapd	 xmm1, xmm6
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000b6	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000be	7a 1e		 jp	 SHORT $LN9@float_hex
  000c0	75 1c		 jne	 SHORT $LN9@float_hex

; 1129 :             return PyUnicode_FromString("-0x0.0p+0");

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EDNHBDOC@?90x0?40p?$CL0?$AA@
  000c9	e8 00 00 00 00	 call	 PyUnicode_FromString
  000ce	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]

; 1164 : }

  000d3	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000d8	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000dc	5b		 pop	 rbx
  000dd	c3		 ret	 0
$LN9@float_hex:

; 1130 :         else
; 1131 :             return PyUnicode_FromString("0x0.0p+0");

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08PMPHOHFK@0x0?40p?$CL0?$AA@
  000e5	e8 00 00 00 00	 call	 PyUnicode_FromString
  000ea	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]

; 1164 : }

  000ef	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000f4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f8	5b		 pop	 rbx
  000f9	c3		 ret	 0
$LN8@float_hex:

; 1132 :     }
; 1133 : 
; 1134 :     m = frexp(fabs(x), &e);

  000fa	66 0f 28 c6	 movapd	 xmm0, xmm6
  000fe	48 8d 54 24 68	 lea	 rdx, QWORD PTR e$[rsp]
  00103	66 0f 54 05 00
	00 00 00	 andpd	 xmm0, QWORD PTR __mask@@AbsDouble@
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 1135 :     shift = 1 - MAX(DBL_MIN_EXP - e, 0);

  00111	b8 03 fc ff ff	 mov	 eax, -1021		; fffffffffffffc03H
  00116	b9 00 00 00 00	 mov	 ecx, 0
  0011b	2b 44 24 68	 sub	 eax, DWORD PTR e$[rsp]
  0011f	bb 01 00 00 00	 mov	 ebx, 1
  00124	0f 48 c1	 cmovs	 eax, ecx
  00127	2b d8		 sub	 ebx, eax

; 1136 :     m = ldexp(m, shift);

  00129	8b d3		 mov	 edx, ebx
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 1137 :     e -= shift;

  00131	44 8b 4c 24 68	 mov	 r9d, DWORD PTR e$[rsp]
  00136	44 2b cb	 sub	 r9d, ebx
  00139	44 89 4c 24 68	 mov	 DWORD PTR e$[rsp], r9d

; 1138 : 
; 1139 :     si = 0;
; 1140 :     s[si] = char_from_hex((int)m);

  0013e	f2 0f 2c c8	 cvttsd2si ecx, xmm0
  00142	66 0f 28 e8	 movapd	 xmm5, xmm0
  00146	e8 00 00 00 00	 call	 char_from_hex

; 1141 :     si++;
; 1142 :     m -= (int)m;
; 1143 :     s[si] = '.';

  0014b	c6 44 24 21 2e	 mov	 BYTE PTR s$[rsp+1], 46	; 0000002eH
  00150	4c 8d 44 24 22	 lea	 r8, QWORD PTR s$[rsp+2]
  00155	66 0f 6e c9	 movd	 xmm1, ecx
  00159	88 44 24 20	 mov	 BYTE PTR s$[rsp], al
  0015d	41 ba 0d 00 00
	00		 mov	 r10d, 13
  00163	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00167	f2 0f 5c e9	 subsd	 xmm5, xmm1
  0016b	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4030000000000000
$LL7@float_hex:

; 1144 :     si++;
; 1145 :     for (i=0; i < (TOHEX_NBITS-1)/4; i++) {
; 1146 :         m *= 16.0;

  00173	f2 0f 59 e9	 mulsd	 xmm5, xmm1

; 1147 :         s[si] = char_from_hex((int)m);

  00177	f2 0f 2c cd	 cvttsd2si ecx, xmm5
  0017b	e8 00 00 00 00	 call	 char_from_hex

; 1148 :         si++;
; 1149 :         m -= (int)m;

  00180	66 0f 6e c1	 movd	 xmm0, ecx
  00184	49 ff c0	 inc	 r8
  00187	49 ff ca	 dec	 r10
  0018a	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  0018e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00192	f2 0f 5c e8	 subsd	 xmm5, xmm0
  00196	75 db		 jne	 SHORT $LL7@float_hex

; 1150 :     }
; 1151 :     s[si] = '\0';

  00198	44 88 54 24 2f	 mov	 BYTE PTR s$[rsp+15], r10b

; 1152 : 
; 1153 :     if (e < 0) {

  0019d	45 85 c9	 test	 r9d, r9d
  001a0	79 0e		 jns	 SHORT $LN4@float_hex

; 1154 :         esign = (int)'-';
; 1155 :         e = -e;

  001a2	41 f7 d9	 neg	 r9d
  001a5	45 8d 42 2d	 lea	 r8d, QWORD PTR [r10+45]
  001a9	44 89 4c 24 68	 mov	 DWORD PTR e$[rsp], r9d

; 1156 :     }
; 1157 :     else

  001ae	eb 06		 jmp	 SHORT $LN3@float_hex
$LN4@float_hex:

; 1158 :         esign = (int)'+';

  001b0	41 b8 2b 00 00
	00		 mov	 r8d, 43			; 0000002bH
$LN3@float_hex:

; 1159 : 
; 1160 :     if (x < 0.0)

  001b6	66 0f 2f fe	 comisd	 xmm7, xmm6

; 1161 :         return PyUnicode_FromFormat("-0x%sp%c%d", s, esign, e);

  001ba	48 8d 54 24 20	 lea	 rdx, QWORD PTR s$[rsp]
  001bf	76 1c		 jbe	 SHORT $LN2@float_hex
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@ICGJBGEC@?90x?$CFsp?$CFc?$CFd?$AA@
$LN25@float_hex:
  001c8	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  001cd	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]

; 1164 : }

  001d2	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  001d7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001db	5b		 pop	 rbx
  001dc	c3		 ret	 0
$LN2@float_hex:

; 1162 :     else
; 1163 :         return PyUnicode_FromFormat("0x%sp%c%d", s, esign, e);

  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EHGMANAI@0x?$CFsp?$CFc?$CFd?$AA@
  001e4	eb e2		 jmp	 SHORT $LN25@float_hex
$LN11@float_hex:

; 1125 :         return float_repr((PyFloatObject *)v);

  001e6	48 8b cb	 mov	 rcx, rbx
  001e9	e8 00 00 00 00	 call	 float_repr

; 1164 : }

  001ee	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  001f3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001f7	5b		 pop	 rbx
  001f8	c3		 ret	 0
float_hex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@ ; `string'
PUBLIC	??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@ ; `string'
PUBLIC	??_C@_03LAKFFLCF@?$CId?$CJ?$AA@			; `string'
PUBLIC	??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@ ; `string'
EXTRN	PyObject_CallObject:PROC
EXTRN	__imp_strtol:PROC
EXTRN	_Py_parse_inf_or_nan:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_fromhex DD imagerel float_fromhex
	DD	imagerel float_fromhex+1265
	DD	imagerel $unwind$float_fromhex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_fromhex DD 0f8901H
	DD	026889H
	DD	07d484H
	DD	0f7474H
	DD	06f445H
	DD	08c440H
	DD	0e00a820eH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT ??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@
CONST	SEGMENT
??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@ DB 'invalid hexad'
	DB	'ecimal floating-point string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@
CONST	SEGMENT
??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@ DB 'hexadecimal'
	DB	' value too large to represent as a float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
CONST	SEGMENT
??_C@_03LAKFFLCF@?$CId?$CJ?$AA@ DB '(d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@
CONST	SEGMENT
??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@ DB 'hexadecimal'
	DB	' string too long to convert', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_fromhex
_TEXT	SEGMENT
cls$ = 112
arg$ = 120
coeff_end$ = 128
length$ = 136
float_fromhex PROC					; COMDAT

; 1179 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	41 56		 push	 r14
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b f1	 mov	 rsi, rcx

; 1180 :     PyObject *result_as_float, *result;
; 1181 :     double x;
; 1182 :     long exp, top_exp, lsb, key_digit;
; 1183 :     char *s, *coeff_start, *s_store, *coeff_end, *exp_start, *s_end;
; 1184 :     int half_eps, digit, round_up, negate=0;
; 1185 :     Py_ssize_t length, ndigits, fdigits, i;
; 1186 : 
; 1187 :     /*
; 1188 :      * For the sake of simplicity and correctness, we impose an artificial
; 1189 :      * limit on ndigits, the total number of hex digits in the coefficient
; 1190 :      * The limit is chosen to ensure that, writing exp for the exponent,
; 1191 :      *
; 1192 :      *   (1) if exp > LONG_MAX/2 then the value of the hex string is
; 1193 :      *   guaranteed to overflow (provided it's nonzero)
; 1194 :      *
; 1195 :      *   (2) if exp < LONG_MIN/2 then the value of the hex string is
; 1196 :      *   guaranteed to underflow to 0.
; 1197 :      *
; 1198 :      *   (3) if LONG_MIN/2 <= exp <= LONG_MAX/2 then there's no danger of
; 1199 :      *   overflow in the calculation of exp and top_exp below.
; 1200 :      *
; 1201 :      * More specifically, ndigits is assumed to satisfy the following
; 1202 :      * inequalities:
; 1203 :      *
; 1204 :      *   4*ndigits <= DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2
; 1205 :      *   4*ndigits <= LONG_MAX/2 + 1 - DBL_MAX_EXP
; 1206 :      *
; 1207 :      * If either of these inequalities is not satisfied, a ValueError is
; 1208 :      * raised.  Otherwise, write x for the value of the hex string, and
; 1209 :      * assume x is nonzero.  Then
; 1210 :      *
; 1211 :      *   2**(exp-4*ndigits) <= |x| < 2**(exp+4*ndigits).
; 1212 :      *
; 1213 :      * Now if exp > LONG_MAX/2 then:
; 1214 :      *
; 1215 :      *   exp - 4*ndigits >= LONG_MAX/2 + 1 - (LONG_MAX/2 + 1 - DBL_MAX_EXP)
; 1216 :      *                    = DBL_MAX_EXP
; 1217 :      *
; 1218 :      * so |x| >= 2**DBL_MAX_EXP, which is too large to be stored in C
; 1219 :      * double, so overflows.  If exp < LONG_MIN/2, then
; 1220 :      *
; 1221 :      *   exp + 4*ndigits <= LONG_MIN/2 - 1 + (
; 1222 :      *                      DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2)
; 1223 :      *                    = DBL_MIN_EXP - DBL_MANT_DIG - 1
; 1224 :      *
; 1225 :      * and so |x| < 2**(DBL_MIN_EXP-DBL_MANT_DIG-1), hence underflows to 0
; 1226 :      * when converted to a C double.
; 1227 :      *
; 1228 :      * It's easy to show that if LONG_MIN/2 <= exp <= LONG_MAX/2 then both
; 1229 :      * exp+4*ndigits and exp-4*ndigits are within the range of a long.
; 1230 :      */
; 1231 : 
; 1232 :     s = _PyUnicode_AsStringAndSize(arg, &length);

  00014	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR length$[rsp]
  0001c	33 ed		 xor	 ebp, ebp
  0001e	48 8b c8	 mov	 rcx, rax
  00021	44 8b f5	 mov	 r14d, ebp
  00024	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00029	48 8b d8	 mov	 rbx, rax

; 1233 :     if (s == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 0a		 jne	 SHORT $LN59@float_from

; 1416 : }

  00031	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00035	41 5e		 pop	 r14
  00037	5e		 pop	 rsi
  00038	5d		 pop	 rbp
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN59@float_from:
  0003b	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  00040	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 1234 :         return NULL;
; 1235 :     s_end = s + length;

  00045	4c 8b bc 24 88
	00 00 00	 mov	 r15, QWORD PTR length$[rsp]
  0004d	4c 03 f8	 add	 r15, rax

; 1236 : 
; 1237 :     /********************
; 1238 :      * Parse the string *
; 1239 :      ********************/
; 1240 : 
; 1241 :     /* leading whitespace */
; 1242 :     while (Py_ISSPACE(*s))

  00050	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00053	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ctype_table
  0005a	41 f6 04 84 08	 test	 BYTE PTR [r12+rax*4], 8
  0005f	74 0e		 je	 SHORT $LN57@float_from
$LL58@float_from:
  00061	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]

; 1243 :         s++;

  00065	48 ff c3	 inc	 rbx
  00068	41 f6 04 84 08	 test	 BYTE PTR [r12+rax*4], 8
  0006d	75 f2		 jne	 SHORT $LL58@float_from
$LN57@float_from:
  0006f	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi

; 1244 : 
; 1245 :     /* infinities and nans */
; 1246 :     x = _Py_parse_inf_or_nan(s, &coeff_end);

  00074	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR coeff_end$[rsp]
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00084	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00089	e8 00 00 00 00	 call	 _Py_parse_inf_or_nan

; 1247 :     if (coeff_end != s) {

  0008e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR coeff_end$[rsp]
  00096	48 3b c3	 cmp	 rax, rbx
  00099	74 08		 je	 SHORT $LN56@float_from

; 1248 :         s = coeff_end;

  0009b	48 8b d8	 mov	 rbx, rax

; 1249 :         goto finished;

  0009e	e9 c4 01 00 00	 jmp	 $finished$20940
$LN56@float_from:

; 1250 :     }
; 1251 : 
; 1252 :     /* optional sign */
; 1253 :     if (*s == '-') {

  000a3	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000a6	41 bd 01 00 00
	00		 mov	 r13d, 1
  000ac	3c 2d		 cmp	 al, 45			; 0000002dH
  000ae	75 05		 jne	 SHORT $LN55@float_from

; 1254 :         s++;
; 1255 :         negate = 1;

  000b0	45 8b f5	 mov	 r14d, r13d
  000b3	eb 04		 jmp	 SHORT $LN107@float_from
$LN55@float_from:

; 1256 :     }
; 1257 :     else if (*s == '+')

  000b5	3c 2b		 cmp	 al, 43			; 0000002bH
  000b7	75 03		 jne	 SHORT $LN53@float_from
$LN107@float_from:

; 1258 :         s++;

  000b9	48 ff c3	 inc	 rbx
$LN53@float_from:

; 1259 : 
; 1260 :     /* [0x] */
; 1261 :     s_store = s;
; 1262 :     if (*s == '0') {

  000bc	80 3b 30	 cmp	 BYTE PTR [rbx], 48	; 00000030H
  000bf	75 10		 jne	 SHORT $LN49@float_from

; 1263 :         s++;
; 1264 :         if (*s == 'x' || *s == 'X')

  000c1	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  000c5	3c 78		 cmp	 al, 120			; 00000078H
  000c7	74 04		 je	 SHORT $LN50@float_from
  000c9	3c 58		 cmp	 al, 88			; 00000058H

; 1266 :         else
; 1267 :             s = s_store;

  000cb	75 04		 jne	 SHORT $LN49@float_from
$LN50@float_from:

; 1265 :             s++;

  000cd	48 83 c3 02	 add	 rbx, 2
$LN49@float_from:

; 1268 :     }
; 1269 : 
; 1270 :     /* coefficient: <integer> [. <fraction>] */
; 1271 :     coeff_start = s;
; 1272 :     while (hex_from_char(*s) >= 0)

  000d1	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  000d4	4c 8b d3	 mov	 r10, rbx
  000d7	e8 00 00 00 00	 call	 hex_from_char
  000dc	85 c0		 test	 eax, eax
  000de	78 10		 js	 SHORT $LN47@float_from
$LL48@float_from:
  000e0	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]

; 1273 :         s++;

  000e4	48 ff c3	 inc	 rbx
  000e7	e8 00 00 00 00	 call	 hex_from_char
  000ec	85 c0		 test	 eax, eax
  000ee	79 f0		 jns	 SHORT $LL48@float_from
$LN47@float_from:

; 1274 :     s_store = s;
; 1275 :     if (*s == '.') {

  000f0	80 3b 2e	 cmp	 BYTE PTR [rbx], 46	; 0000002eH
  000f3	4c 8b cb	 mov	 r9, rbx
  000f6	75 36		 jne	 SHORT $LN46@float_from

; 1276 :         s++;
; 1277 :         while (hex_from_char(*s) >= 0)

  000f8	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]
  000fc	48 ff c3	 inc	 rbx
  000ff	e8 00 00 00 00	 call	 hex_from_char
  00104	85 c0		 test	 eax, eax
  00106	78 18		 js	 SHORT $LN44@float_from
  00108	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL45@float_from:
  00110	0f b6 4b 01	 movzx	 ecx, BYTE PTR [rbx+1]

; 1278 :             s++;

  00114	48 ff c3	 inc	 rbx
  00117	e8 00 00 00 00	 call	 hex_from_char
  0011c	85 c0		 test	 eax, eax
  0011e	79 f0		 jns	 SHORT $LL45@float_from
$LN44@float_from:

; 1279 :         coeff_end = s-1;

  00120	4c 8d 43 ff	 lea	 r8, QWORD PTR [rbx-1]
  00124	4c 89 84 24 80
	00 00 00	 mov	 QWORD PTR coeff_end$[rsp], r8

; 1280 :     }
; 1281 :     else

  0012c	eb 0b		 jmp	 SHORT $LN43@float_from
$LN46@float_from:

; 1282 :         coeff_end = s;

  0012e	4c 8b c3	 mov	 r8, rbx
  00131	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR coeff_end$[rsp], rbx
$LN43@float_from:

; 1283 : 
; 1284 :     /* ndigits = total # of hex digits; fdigits = # after point */
; 1285 :     ndigits = coeff_end - coeff_start;
; 1286 :     fdigits = coeff_end - s_store;

  00139	49 8b f0	 mov	 rsi, r8
  0013c	49 8b f8	 mov	 rdi, r8
  0013f	49 2b f1	 sub	 rsi, r9
  00142	49 2b fa	 sub	 rdi, r10

; 1287 :     if (ndigits == 0)

  00145	0f 84 6e 03 00
	00		 je	 $parse_error$20957

; 1288 :         goto parse_error;
; 1289 :     if (ndigits > MIN(DBL_MIN_EXP - DBL_MANT_DIG - LONG_MIN/2,
; 1290 :                       LONG_MAX/2 + 1 - DBL_MAX_EXP)/4)

  0014b	48 81 ff f3 fe
	ff 0f		 cmp	 rdi, 268435187		; 0ffffef3H
  00152	7e 0c		 jle	 SHORT $LN41@float_from
$insane_length_error$20959:

; 1411 : 
; 1412 :   insane_length_error:
; 1413 :     PyErr_SetString(PyExc_ValueError,
; 1414 :                     "hexadecimal string too long to convert");

  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@MAGDKHAN@hexadecimal?5string?5too?5long?5to?5c@

; 1415 :     return NULL;

  0015b	e9 60 03 00 00	 jmp	 $LN108@float_from
$LN41@float_from:

; 1291 :         goto insane_length_error;
; 1292 : 
; 1293 :     /* [p <exponent>] */
; 1294 :     if (*s == 'p' || *s == 'P') {

  00160	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00163	3c 70		 cmp	 al, 112			; 00000070H
  00165	74 04		 je	 SHORT $LN39@float_from
  00167	3c 50		 cmp	 al, 80			; 00000050H
  00169	75 5a		 jne	 SHORT $LN82@float_from
$LN39@float_from:

; 1295 :         s++;
; 1296 :         exp_start = s;
; 1297 :         if (*s == '-' || *s == '+')

  0016b	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  0016f	48 ff c3	 inc	 rbx
  00172	48 8b cb	 mov	 rcx, rbx
  00175	3c 2d		 cmp	 al, 45			; 0000002dH
  00177	74 04		 je	 SHORT $LN37@float_from
  00179	3c 2b		 cmp	 al, 43			; 0000002bH
  0017b	75 03		 jne	 SHORT $LN38@float_from
$LN37@float_from:

; 1298 :             s++;

  0017d	48 ff c3	 inc	 rbx
$LN38@float_from:

; 1299 :         if (!('0' <= *s && *s <= '9'))

  00180	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00183	3c 30		 cmp	 al, 48			; 00000030H
  00185	0f 8c 2e 03 00
	00		 jl	 $parse_error$20957
  0018b	3c 39		 cmp	 al, 57			; 00000039H
  0018d	0f 8f 26 03 00
	00		 jg	 $parse_error$20957

; 1300 :             goto parse_error;
; 1301 :         s++;
; 1302 :         while ('0' <= *s && *s <= '9')

  00193	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  00197	48 ff c3	 inc	 rbx
  0019a	3c 30		 cmp	 al, 48			; 00000030H
  0019c	7c 11		 jl	 SHORT $LN100@float_from
  0019e	66 90		 npad	 2
$LL34@float_from:
  001a0	3c 39		 cmp	 al, 57			; 00000039H
  001a2	7f 0b		 jg	 SHORT $LN100@float_from
  001a4	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]

; 1303 :             s++;

  001a8	48 ff c3	 inc	 rbx
  001ab	3c 30		 cmp	 al, 48			; 00000030H
  001ad	7d f1		 jge	 SHORT $LL34@float_from
$LN100@float_from:

; 1304 :         exp = strtol(exp_start, NULL, 10);

  001af	33 d2		 xor	 edx, edx
  001b1	44 8d 42 0a	 lea	 r8d, QWORD PTR [rdx+10]
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol
  001bb	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR coeff_end$[rsp]
  001c3	8b e8		 mov	 ebp, eax
$LN82@float_from:

; 1305 :     }
; 1306 :     else
; 1307 :         exp = 0;
; 1308 : 
; 1309 : /* for 0 <= j < ndigits, HEX_DIGIT(j) gives the jth most significant digit */
; 1310 : #define HEX_DIGIT(j) hex_from_char(*((j) < fdigits ?            \
; 1311 :                      coeff_end-(j) :                                    \
; 1312 :                      coeff_end-1-(j)))
; 1313 : 
; 1314 :     /*******************************************
; 1315 :      * Compute rounded value of the hex string *
; 1316 :      *******************************************/
; 1317 : 
; 1318 :     /* Discard leading zeros, and catch extreme overflow and underflow */
; 1319 :     while (ndigits > 0 && HEX_DIGIT(ndigits-1) == 0)

  001c5	48 85 ff	 test	 rdi, rdi
  001c8	7e 30		 jle	 SHORT $LN109@float_from
  001ca	4d 8b c8	 mov	 r9, r8
  001cd	4c 2b cf	 sub	 r9, rdi
$LL31@float_from:
  001d0	4c 8d 57 ff	 lea	 r10, QWORD PTR [rdi-1]
  001d4	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
  001d8	4c 3b d6	 cmp	 r10, rsi
  001db	7c 03		 jl	 SHORT $LN63@float_from
  001dd	49 8b c1	 mov	 rax, r9
$LN63@float_from:
  001e0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001e3	e8 00 00 00 00	 call	 hex_from_char
  001e8	85 c0		 test	 eax, eax
  001ea	75 0b		 jne	 SHORT $LN101@float_from

; 1320 :         ndigits--;

  001ec	49 ff c1	 inc	 r9
  001ef	49 8b fa	 mov	 rdi, r10
  001f2	4d 85 d2	 test	 r10, r10
  001f5	7f d9		 jg	 SHORT $LL31@float_from
$LN101@float_from:

; 1321 :     if (ndigits == 0 || exp < LONG_MIN/2) {

  001f7	48 85 ff	 test	 rdi, rdi
$LN109@float_from:
  001fa	74 62		 je	 SHORT $LN28@float_from
  001fc	81 fd 00 00 00
	c0		 cmp	 ebp, -1073741824	; ffffffffc0000000H
  00202	7c 5a		 jl	 SHORT $LN28@float_from

; 1323 :         goto finished;
; 1324 :     }
; 1325 :     if (exp > LONG_MAX/2)

  00204	81 fd ff ff ff
	3f		 cmp	 ebp, 1073741823		; 3fffffffH
  0020a	0f 8f 99 02 00
	00		 jg	 $overflow_error$20978

; 1326 :         goto overflow_error;
; 1327 : 
; 1328 :     /* Adjust exponent for fractional part. */
; 1329 :     exp = exp - 4*((long)fdigits);

  00210	8b c6		 mov	 eax, esi

; 1330 : 
; 1331 :     /* top_exp = 1 more than exponent of most sig. bit of coefficient */
; 1332 :     top_exp = exp + 4*((long)ndigits - 1);
; 1333 :     for (digit = HEX_DIGIT(ndigits-1); digit != 0; digit /= 2)

  00212	4c 8d 4f ff	 lea	 r9, QWORD PTR [rdi-1]
  00216	f7 d8		 neg	 eax
  00218	44 8d 64 85 00	 lea	 r12d, DWORD PTR [rbp+rax*4]
  0021d	49 8b c0	 mov	 rax, r8
  00220	48 2b c7	 sub	 rax, rdi
  00223	45 8d 5c bc fc	 lea	 r11d, DWORD PTR [r12+rdi*4-4]
  00228	4c 3b ce	 cmp	 r9, rsi
  0022b	7d 03		 jge	 SHORT $LN65@float_from
  0022d	48 ff c0	 inc	 rax
$LN65@float_from:
  00230	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00233	e8 00 00 00 00	 call	 hex_from_char
  00238	85 c0		 test	 eax, eax
  0023a	74 0e		 je	 SHORT $LN24@float_from
  0023c	0f 1f 40 00	 npad	 4
$LL26@float_from:
  00240	99		 cdq

; 1334 :         top_exp++;

  00241	41 ff c3	 inc	 r11d
  00244	2b c2		 sub	 eax, edx
  00246	d1 f8		 sar	 eax, 1
  00248	75 f6		 jne	 SHORT $LL26@float_from
$LN24@float_from:

; 1335 : 
; 1336 :     /* catch almost all nonextreme cases of overflow and underflow here */
; 1337 :     if (top_exp < DBL_MIN_EXP - DBL_MANT_DIG) {

  0024a	41 81 fb ce fb
	ff ff		 cmp	 r11d, -1074		; fffffffffffffbceH
  00251	0f 8d 7d 00 00
	00		 jge	 $LN23@float_from

; 1338 :         x = 0.0;
; 1339 :         goto finished;

  00257	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ctype_table
$LN28@float_from:

; 1322 :         x = 0.0;

  0025e	66 0f 57 c0	 xorpd	 xmm0, xmm0
$LN110@float_from:
  00262	48 8b 74 24 70	 mov	 rsi, QWORD PTR cls$[rsp]
$finished$20940:

; 1388 : 
; 1389 :   finished:
; 1390 :     /* optional trailing whitespace leading to the end of the string */
; 1391 :     while (Py_ISSPACE(*s))

  00267	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0026a	41 f6 04 84 08	 test	 BYTE PTR [r12+rax*4], 8
  0026f	74 0e		 je	 SHORT $LN3@float_from
$LL4@float_from:
  00271	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]

; 1392 :         s++;

  00275	48 ff c3	 inc	 rbx
  00278	41 f6 04 84 08	 test	 BYTE PTR [r12+rax*4], 8
  0027d	75 f2		 jne	 SHORT $LL4@float_from
$LN3@float_from:

; 1393 :     if (s != s_end)

  0027f	49 3b df	 cmp	 rbx, r15
  00282	0f 85 31 02 00
	00		 jne	 $parse_error$20957

; 1394 :         goto parse_error;
; 1395 :     result_as_float = Py_BuildValue("(d)", negate ? -x : x);

  00288	45 85 f6	 test	 r14d, r14d
  0028b	74 08		 je	 SHORT $LN76@float_from
  0028d	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
$LN76@float_from:
  00295	66 0f 28 c8	 movapd	 xmm1, xmm0
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
  002a0	66 48 0f 7e ca	 movd	 rdx, xmm1
  002a5	e8 00 00 00 00	 call	 Py_BuildValue
  002aa	48 8b f8	 mov	 rdi, rax

; 1396 :     if (result_as_float == NULL)

  002ad	48 85 c0	 test	 rax, rax

; 1397 :         return NULL;

  002b0	0f 84 16 02 00
	00		 je	 $LN112@float_from

; 1398 :     result = PyObject_CallObject(cls, result_as_float);

  002b6	48 8b d0	 mov	 rdx, rax
  002b9	48 8b ce	 mov	 rcx, rsi
  002bc	e8 00 00 00 00	 call	 PyObject_CallObject

; 1399 :     Py_DECREF(result_as_float);

  002c1	48 8b cf	 mov	 rcx, rdi
  002c4	48 8b d8	 mov	 rbx, rax
  002c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1400 :     return result;

  002cc	48 8b c3	 mov	 rax, rbx
  002cf	e9 fa 01 00 00	 jmp	 $LN106@float_from
$LN23@float_from:

; 1340 :     }
; 1341 :     if (top_exp > DBL_MAX_EXP)

  002d4	41 81 fb 00 04
	00 00		 cmp	 r11d, 1024		; 00000400H
  002db	0f 8f c8 01 00
	00		 jg	 $overflow_error$20978

; 1342 :         goto overflow_error;
; 1343 : 
; 1344 :     /* lsb = exponent of least significant bit of the *rounded* value.
; 1345 :        This is top_exp - DBL_MANT_DIG unless result is subnormal. */
; 1346 :     lsb = MAX(top_exp, (long)DBL_MIN_EXP) - DBL_MANT_DIG;
; 1347 : 
; 1348 :     x = 0.0;

  002e1	66 0f 57 d2	 xorpd	 xmm2, xmm2
  002e5	b9 03 fc ff ff	 mov	 ecx, -1021		; fffffffffffffc03H
  002ea	41 8b c3	 mov	 eax, r11d
  002ed	44 3b d9	 cmp	 r11d, ecx
  002f0	0f 4c c1	 cmovl	 eax, ecx
  002f3	83 e8 35	 sub	 eax, 53			; 00000035H

; 1349 :     if (exp >= lsb) {

  002f6	44 3b e0	 cmp	 r12d, eax
  002f9	7c 5e		 jl	 SHORT $LN21@float_from

; 1350 :         /* no rounding required */
; 1351 :         for (i = ndigits-1; i >= 0; i--)

  002fb	4d 85 c9	 test	 r9, r9
  002fe	78 40		 js	 SHORT $LN18@float_from
  00300	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4030000000000000
  00308	4d 2b c1	 sub	 r8, r9
  0030b	0f 1f 44 00 00	 npad	 5
$LL20@float_from:

; 1352 :             x = 16.0*x + HEX_DIGIT(i);

  00310	49 8b c0	 mov	 rax, r8
  00313	4c 3b ce	 cmp	 r9, rsi
  00316	7c 04		 jl	 SHORT $LN67@float_from
  00318	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
$LN67@float_from:
  0031c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0031f	e8 00 00 00 00	 call	 hex_from_char
  00324	49 ff c0	 inc	 r8
  00327	49 ff c9	 dec	 r9
  0032a	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  0032e	66 0f 6e c8	 movd	 xmm1, eax
  00332	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00336	f2 0f 58 ca	 addsd	 xmm1, xmm2
  0033a	66 0f 28 d1	 movapd	 xmm2, xmm1
  0033e	79 d0		 jns	 SHORT $LL20@float_from
$LN18@float_from:

; 1353 :         x = ldexp(x, (int)(exp));

  00340	66 0f 28 c2	 movapd	 xmm0, xmm2
  00344	41 8b d4	 mov	 edx, r12d
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 1354 :         goto finished;

  0034d	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ctype_table
  00354	e9 09 ff ff ff	 jmp	 $LN110@float_from
$LN21@float_from:

; 1359 :     key_digit = (lsb - exp - 1) / 4;
; 1360 :     for (i = ndigits-1; i > key_digit; i--)

  00359	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4030000000000000
  00361	41 2b c4	 sub	 eax, r12d
  00364	ff c8		 dec	 eax
  00366	99		 cdq
  00367	83 e2 03	 and	 edx, 3
  0036a	03 c2		 add	 eax, edx
  0036c	8b e8		 mov	 ebp, eax
  0036e	83 e0 03	 and	 eax, 3
  00371	2b c2		 sub	 eax, edx
  00373	c1 fd 02	 sar	 ebp, 2
  00376	8b c8		 mov	 ecx, eax
  00378	48 63 fd	 movsxd	 rdi, ebp
  0037b	41 d3 e5	 shl	 r13d, cl
  0037e	4c 3b cf	 cmp	 r9, rdi
  00381	7e 40		 jle	 SHORT $LN15@float_from

; 1355 :     }
; 1356 :     /* rounding required.  key_digit is the index of the hex digit
; 1357 :        containing the first bit to be rounded away. */
; 1358 :     half_eps = 1 << (int)((lsb - exp - 1) % 4);

  00383	4d 8b d0	 mov	 r10, r8
  00386	4d 2b d1	 sub	 r10, r9
  00389	0f 1f 80 00 00
	00 00		 npad	 7
$LL17@float_from:

; 1361 :         x = 16.0*x + HEX_DIGIT(i);

  00390	49 8b c2	 mov	 rax, r10
  00393	4c 3b ce	 cmp	 r9, rsi
  00396	7c 04		 jl	 SHORT $LN69@float_from
  00398	49 8d 42 ff	 lea	 rax, QWORD PTR [r10-1]
$LN69@float_from:
  0039c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0039f	e8 00 00 00 00	 call	 hex_from_char
  003a4	49 ff c9	 dec	 r9
  003a7	49 ff c2	 inc	 r10
  003aa	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  003ae	66 0f 6e c0	 movd	 xmm0, eax
  003b2	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  003b6	f2 0f 58 c2	 addsd	 xmm0, xmm2
  003ba	66 0f 28 d0	 movapd	 xmm2, xmm0
  003be	4c 3b cf	 cmp	 r9, rdi
  003c1	7f cd		 jg	 SHORT $LL17@float_from
$LN15@float_from:

; 1362 :     digit = HEX_DIGIT(key_digit);

  003c3	49 8b c0	 mov	 rax, r8
  003c6	48 2b c7	 sub	 rax, rdi
  003c9	48 3b fe	 cmp	 rdi, rsi
  003cc	7c 03		 jl	 SHORT $LN71@float_from
  003ce	48 ff c8	 dec	 rax
$LN71@float_from:
  003d1	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003d4	e8 00 00 00 00	 call	 hex_from_char

; 1363 :     x = 16.0*x + (double)(digit & (16-2*half_eps));

  003d9	b9 08 00 00 00	 mov	 ecx, 8
  003de	41 2b cd	 sub	 ecx, r13d
  003e1	44 8b c8	 mov	 r9d, eax
  003e4	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  003e8	03 c9		 add	 ecx, ecx
  003ea	23 c8		 and	 ecx, eax
  003ec	66 0f 6e f1	 movd	 xmm6, ecx
  003f0	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  003f4	f2 0f 58 f2	 addsd	 xmm6, xmm2

; 1364 : 
; 1365 :     /* round-half-even: round up if bit lsb-1 is 1 and at least one of
; 1366 :        bits lsb, lsb-2, lsb-3, lsb-4, ... is 1. */
; 1367 :     if ((digit & half_eps) != 0) {

  003f8	44 85 e8	 test	 r13d, eax
  003fb	0f 84 8e 00 00
	00		 je	 $LN5@float_from

; 1368 :         round_up = 0;
; 1369 :         if ((digit & (3*half_eps-1)) != 0 ||
; 1370 :             (half_eps == 8 && (HEX_DIGIT(key_digit+1) & 1) != 0))

  00401	43 8d 44 6d ff	 lea	 eax, DWORD PTR [r13+r13*2-1]
  00406	41 85 c1	 test	 eax, r9d
  00409	75 57		 jne	 SHORT $LN88@float_from
  0040b	41 83 fd 08	 cmp	 r13d, 8
  0040f	75 20		 jne	 SHORT $LN13@float_from
  00411	8d 45 01	 lea	 eax, DWORD PTR [rbp+1]
  00414	48 63 c8	 movsxd	 rcx, eax
  00417	49 8b c0	 mov	 rax, r8
  0041a	48 2b c1	 sub	 rax, rcx
  0041d	48 3b ce	 cmp	 rcx, rsi
  00420	7c 03		 jl	 SHORT $LN73@float_from
  00422	48 ff c8	 dec	 rax
$LN73@float_from:
  00425	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00428	e8 00 00 00 00	 call	 hex_from_char
  0042d	a8 01		 test	 al, 1
  0042f	75 31		 jne	 SHORT $LN88@float_from
$LN13@float_from:

; 1371 :             round_up = 1;
; 1372 :         else
; 1373 :             for (i = key_digit-1; i >= 0; i--)

  00431	8d 45 ff	 lea	 eax, DWORD PTR [rbp-1]
  00434	4c 63 c8	 movsxd	 r9, eax
  00437	85 c0		 test	 eax, eax
  00439	78 54		 js	 SHORT $LN5@float_from
  0043b	4d 2b c1	 sub	 r8, r9
  0043e	66 90		 npad	 2
$LL10@float_from:

; 1374 :                 if (HEX_DIGIT(i) != 0) {

  00440	49 8b c0	 mov	 rax, r8
  00443	4c 3b ce	 cmp	 r9, rsi
  00446	7c 04		 jl	 SHORT $LN75@float_from
  00448	49 8d 40 ff	 lea	 rax, QWORD PTR [r8-1]
$LN75@float_from:
  0044c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0044f	e8 00 00 00 00	 call	 hex_from_char
  00454	85 c0		 test	 eax, eax
  00456	75 0a		 jne	 SHORT $LN88@float_from

; 1371 :             round_up = 1;
; 1372 :         else
; 1373 :             for (i = key_digit-1; i >= 0; i--)

  00458	49 ff c0	 inc	 r8
  0045b	49 ff c9	 dec	 r9
  0045e	79 e0		 jns	 SHORT $LL10@float_from

; 1374 :                 if (HEX_DIGIT(i) != 0) {

  00460	eb 2d		 jmp	 SHORT $LN5@float_from
$LN88@float_from:

; 1375 :                     round_up = 1;
; 1376 :                     break;
; 1377 :                 }
; 1378 :         if (round_up) {
; 1379 :             x += 2*half_eps;

  00462	43 8d 44 2d 00	 lea	 eax, DWORD PTR [r13+r13]
  00467	66 0f 6e c0	 movd	 xmm0, eax
  0046b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0046f	f2 0f 58 f0	 addsd	 xmm6, xmm0

; 1380 :             if (top_exp == DBL_MAX_EXP &&
; 1381 :                 x == ldexp((double)(2*half_eps), DBL_MANT_DIG))

  00473	41 81 fb 00 04
	00 00		 cmp	 r11d, 1024		; 00000400H
  0047a	75 13		 jne	 SHORT $LN5@float_from
  0047c	ba 35 00 00 00	 mov	 edx, 53			; 00000035H
  00481	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00487	66 0f 2e f0	 ucomisd xmm6, xmm0
  0048b	7a 02		 jp	 SHORT $LN5@float_from
  0048d	74 1a		 je	 SHORT $overflow_error$20978
$LN5@float_from:

; 1382 :                 /* overflow corner case: pre-rounded value <
; 1383 :                    2**DBL_MAX_EXP; rounded=2**DBL_MAX_EXP. */
; 1384 :                 goto overflow_error;
; 1385 :         }
; 1386 :     }
; 1387 :     x = ldexp(x, (int)(exp+4*key_digit));

  0048f	41 8d 14 ac	 lea	 edx, DWORD PTR [r12+rbp*4]
  00493	66 0f 28 c6	 movapd	 xmm0, xmm6
  00497	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0049d	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_ctype_table
  004a4	e9 b9 fd ff ff	 jmp	 $LN110@float_from
$overflow_error$20978:

; 1401 : 
; 1402 :   overflow_error:
; 1403 :     PyErr_SetString(PyExc_OverflowError,
; 1404 :                     "hexadecimal value too large to represent as a float");

  004a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  004b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JIJECJKD@hexadecimal?5value?5too?5large?5to?5r@

; 1405 :     return NULL;

  004b7	eb 0e		 jmp	 SHORT $LN111@float_from
$parse_error$20957:

; 1406 : 
; 1407 :   parse_error:
; 1408 :     PyErr_SetString(PyExc_ValueError,
; 1409 :                     "invalid hexadecimal floating-point string");

  004b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KHPMGGCN@invalid?5hexadecimal?5floating?9poi@
$LN108@float_from:
  004c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
$LN111@float_from:
  004c7	e8 00 00 00 00	 call	 PyErr_SetString
$LN112@float_from:

; 1410 :     return NULL;

  004cc	33 c0		 xor	 eax, eax
$LN106@float_from:
  004ce	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  004d3	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  004d8	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  004dd	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  004e2	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 1416 : }

  004e7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  004eb	41 5e		 pop	 r14
  004ed	5e		 pop	 rsi
  004ee	5d		 pop	 rbp
  004ef	5b		 pop	 rbx
  004f0	c3		 ret	 0
float_fromhex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@ ; `string'
PUBLIC	??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@ ; `string'
EXTRN	PyTuple_Pack:PROC
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_as_integer_ratio DD imagerel float_as_integer_ratio
	DD	imagerel float_as_integer_ratio+253
	DD	imagerel $unwind$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_as_integer_ratio DD imagerel float_as_integer_ratio+253
	DD	imagerel float_as_integer_ratio+354
	DD	imagerel $chain$1$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$float_as_integer_ratio DD imagerel float_as_integer_ratio+354
	DD	imagerel float_as_integer_ratio+359
	DD	imagerel $chain$2$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$float_as_integer_ratio DD imagerel float_as_integer_ratio+359
	DD	imagerel float_as_integer_ratio+412
	DD	imagerel $chain$3$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$float_as_integer_ratio DD imagerel float_as_integer_ratio+412
	DD	imagerel float_as_integer_ratio+628
	DD	imagerel $chain$4$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$float_as_integer_ratio DD imagerel float_as_integer_ratio+628
	DD	imagerel float_as_integer_ratio+747
	DD	imagerel $chain$5$float_as_integer_ratio
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$float_as_integer_ratio DD imagerel float_as_integer_ratio+747
	DD	imagerel float_as_integer_ratio+871
	DD	imagerel $chain$6$float_as_integer_ratio
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$float_as_integer_ratio DD 021H
	DD	imagerel float_as_integer_ratio+354
	DD	imagerel float_as_integer_ratio+359
	DD	imagerel $chain$2$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$float_as_integer_ratio DD 021H
	DD	imagerel float_as_integer_ratio+359
	DD	imagerel float_as_integer_ratio+412
	DD	imagerel $chain$3$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$float_as_integer_ratio DD 020521H
	DD	0b6405H
	DD	imagerel float_as_integer_ratio+359
	DD	imagerel float_as_integer_ratio+412
	DD	imagerel $chain$3$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$float_as_integer_ratio DD 020821H
	DD	0115408H
	DD	imagerel float_as_integer_ratio+354
	DD	imagerel float_as_integer_ratio+359
	DD	imagerel $chain$2$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$float_as_integer_ratio DD 021H
	DD	imagerel float_as_integer_ratio
	DD	imagerel float_as_integer_ratio+253
	DD	imagerel $unwind$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_as_integer_ratio DD 020521H
	DD	037805H
	DD	imagerel float_as_integer_ratio
	DD	imagerel float_as_integer_ratio+253
	DD	imagerel $unwind$float_as_integer_ratio
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_as_integer_ratio DD 08fd01H
	DD	0a74fdH
	DD	046824H
	DD	0d00ab20eH
	DD	03006c008H
xdata	ENDS
;	COMDAT ??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@
CONST	SEGMENT
??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@ DB 'Cannot pass'
	DB	' NaN to float.as_integer_ratio.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@
CONST	SEGMENT
??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@ DB 'Cannot pass'
	DB	' infinity to float.as_integer_ratio.', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
CONST	ENDS
;	COMDAT float_as_integer_ratio
_TEXT	SEGMENT
v$ = 128
unused$ = 136
exponent$ = 144
self$ = 152
float_as_integer_ratio PROC				; COMDAT

; 1430 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1431 :     double self;
; 1432 :     double float_part;
; 1433 :     int exponent;
; 1434 :     int i;
; 1435 : 
; 1436 :     PyObject *prev;
; 1437 :     PyObject *py_exponent = NULL;
; 1438 :     PyObject *numerator = NULL;
; 1439 :     PyObject *denominator = NULL;
; 1440 :     PyObject *result_pair = NULL;
; 1441 :     PyNumberMethods *long_methods = PyLong_Type.tp_as_number;

  0000e	4c 8b 2d b8 00
	00 00		 mov	 r13, QWORD PTR PyLong_Type+184

; 1442 : 
; 1443 : #define INPLACE_UPDATE(obj, call) \
; 1444 :     prev = obj; \
; 1445 :     obj = call; \
; 1446 :     Py_DECREF(prev); \
; 1447 : 
; 1448 :     CONVERT_TO_DOUBLE(v, self);

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0001c	45 33 e4	 xor	 r12d, r12d
  0001f	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  00024	48 8b d9	 mov	 rbx, rcx
  00027	48 39 51 58	 cmp	 QWORD PTR [rcx+88], rdx
  0002b	74 48		 je	 SHORT $LN26@float_as_i
  0002d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00031	e8 00 00 00 00	 call	 PyType_IsSubtype
  00036	85 c0		 test	 eax, eax
  00038	75 3b		 jne	 SHORT $LN26@float_as_i
  0003a	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR self$[rsp]
  00042	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR v$[rsp]
  0004a	e8 00 00 00 00	 call	 convert_to_double
  0004f	85 c0		 test	 eax, eax
  00051	79 17		 jns	 SHORT $LN66@float_as_i
  00053	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]

; 1501 :     return result_pair;
; 1502 : }

  0005b	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  00060	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00064	41 5d		 pop	 r13
  00066	41 5c		 pop	 r12
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN66@float_as_i:

; 1442 : 
; 1443 : #define INPLACE_UPDATE(obj, call) \
; 1444 :     prev = obj; \
; 1445 :     obj = call; \
; 1446 :     Py_DECREF(prev); \
; 1447 : 
; 1448 :     CONVERT_TO_DOUBLE(v, self);

  0006a	f2 0f 10 b4 24
	98 00 00 00	 movsdx	 xmm6, QWORD PTR self$[rsp]
  00073	eb 05		 jmp	 SHORT $LN24@float_as_i
$LN26@float_as_i:
  00075	f2 0f 10 73 60	 movsdx	 xmm6, QWORD PTR [rbx+96]
$LN24@float_as_i:

; 1449 : 
; 1450 :     if (Py_IS_INFINITY(self)) {

  0007a	66 0f 28 c6	 movapd	 xmm0, xmm6
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00084	85 c0		 test	 eax, eax
  00086	75 32		 jne	 SHORT $LN23@float_as_i
  00088	66 0f 28 c6	 movapd	 xmm0, xmm6
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00092	85 c0		 test	 eax, eax
  00094	75 24		 jne	 SHORT $LN23@float_as_i

; 1451 :       PyErr_SetString(PyExc_OverflowError,
; 1452 :                       "Cannot pass infinity to float.as_integer_ratio.");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BPJCIOGG@Cannot?5pass?5infinity?5to?5float?4as@
  000a4	e8 00 00 00 00	 call	 PyErr_SetString

; 1453 :       return NULL;

  000a9	33 c0		 xor	 eax, eax

; 1501 :     return result_pair;
; 1502 : }

  000ab	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000b0	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b4	41 5d		 pop	 r13
  000b6	41 5c		 pop	 r12
  000b8	5b		 pop	 rbx
  000b9	c3		 ret	 0
$LN23@float_as_i:

; 1454 :     }
; 1455 :     if (Py_IS_NAN(self)) {

  000ba	66 0f 28 c6	 movapd	 xmm0, xmm6
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000c4	85 c0		 test	 eax, eax
  000c6	74 24		 je	 SHORT $LN22@float_as_i

; 1456 :       PyErr_SetString(PyExc_ValueError,
; 1457 :                       "Cannot pass NaN to float.as_integer_ratio.");

  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@CODLHJPJ@Cannot?5pass?5NaN?5to?5float?4as_inte@
  000d6	e8 00 00 00 00	 call	 PyErr_SetString

; 1458 :       return NULL;

  000db	33 c0		 xor	 eax, eax

; 1501 :     return result_pair;
; 1502 : }

  000dd	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000e2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000e6	41 5d		 pop	 r13
  000e8	41 5c		 pop	 r12
  000ea	5b		 pop	 rbx
  000eb	c3		 ret	 0
$LN22@float_as_i:

; 1459 :     }
; 1460 : 
; 1461 :     PyFPE_START_PROTECT("as_integer_ratio", goto error);
; 1462 :     float_part = frexp(self, &exponent);        /* self == float_part * 2**exponent exactly */

  000ec	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR exponent$[rsp]
  000f4	66 0f 28 c6	 movapd	 xmm0, xmm6
  000f8	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  000fd	0f 29 7c 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm7
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 1463 :     PyFPE_END_PROTECT(float_part);
; 1464 : 
; 1465 :     for (i=0; i<300 && float_part != floor(float_part) ; i++) {

  00108	8b bc 24 90 00
	00 00		 mov	 edi, DWORD PTR exponent$[rsp]
  0010f	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@4000000000000000
  00117	41 8b dc	 mov	 ebx, r12d
  0011a	66 0f 28 f0	 movapd	 xmm6, xmm0
  0011e	66 90		 npad	 2
$LL21@float_as_i:
  00120	66 0f 28 c6	 movapd	 xmm0, xmm6
  00124	e8 00 00 00 00	 call	 floor
  00129	66 0f 2e f0	 ucomisd xmm6, xmm0
  0012d	7a 02		 jp	 SHORT $LN65@float_as_i
  0012f	74 10		 je	 SHORT $LN19@float_as_i
$LN65@float_as_i:
  00131	ff c3		 inc	 ebx

; 1466 :         float_part *= 2.0;
; 1467 :         exponent--;

  00133	ff cf		 dec	 edi
  00135	f2 0f 59 f7	 mulsd	 xmm6, xmm7
  00139	81 fb 2c 01 00
	00		 cmp	 ebx, 300		; 0000012cH
  0013f	7c df		 jl	 SHORT $LL21@float_as_i
$LN19@float_as_i:

; 1468 :     }
; 1469 :     /* self == float_part * 2**exponent exactly and float_part is integral.
; 1470 :        If FLT_RADIX != 2, the 300 steps may leave a tiny fractional part
; 1471 :        to be truncated by PyLong_FromDouble(). */
; 1472 : 
; 1473 :     numerator = PyLong_FromDouble(float_part);

  00141	66 0f 28 c6	 movapd	 xmm0, xmm6
  00145	89 bc 24 90 00
	00 00		 mov	 DWORD PTR exponent$[rsp], edi
  0014c	e8 00 00 00 00	 call	 PyLong_FromDouble
  00151	48 8b f8	 mov	 rdi, rax
  00154	0f 28 7c 24 30	 movaps	 xmm7, XMMWORD PTR [rsp+48]

; 1474 :     if (numerator == NULL) goto error;

  00159	48 85 c0	 test	 rax, rax
  0015c	0f 84 ee 01 00
	00		 je	 $LN3@float_as_i

; 1475 : 
; 1476 :     /* fold in 2**exponent */
; 1477 :     denominator = PyLong_FromLong(1);

  00162	b9 01 00 00 00	 mov	 ecx, 1
  00167	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  0016f	e8 00 00 00 00	 call	 PyLong_FromLong
  00174	48 8b e8	 mov	 rbp, rax

; 1478 :     py_exponent = PyLong_FromLong(labs((long)exponent));

  00177	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR exponent$[rsp]
  0017e	99		 cdq
  0017f	33 c2		 xor	 eax, edx
  00181	2b c2		 sub	 eax, edx
  00183	8b c8		 mov	 ecx, eax
  00185	e8 00 00 00 00	 call	 PyLong_FromLong
  0018a	48 8b d8	 mov	 rbx, rax

; 1479 :     if (py_exponent == NULL) goto error;

  0018d	48 85 c0	 test	 rax, rax
  00190	0f 84 de 00 00
	00		 je	 $LN11@float_as_i

; 1480 :     INPLACE_UPDATE(py_exponent,
; 1481 :                    long_methods->nb_lshift(denominator, py_exponent));

  00196	48 8b d0	 mov	 rdx, rax
  00199	48 8b cd	 mov	 rcx, rbp
  0019c	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  001a1	41 ff 55 58	 call	 QWORD PTR [r13+88]
  001a5	48 8b cb	 mov	 rcx, rbx
  001a8	48 8b f0	 mov	 rsi, rax
  001ab	e8 00 00 00 00	 call	 _Py_DecRef

; 1482 :     if (py_exponent == NULL) goto error;

  001b0	48 85 f6	 test	 rsi, rsi
  001b3	0f 84 b6 00 00
	00		 je	 $LN67@float_as_i

; 1483 :     if (exponent > 0) {

  001b9	44 39 a4 24 90
	00 00 00	 cmp	 DWORD PTR exponent$[rsp], r12d
  001c1	7e 1f		 jle	 SHORT $LN15@float_as_i

; 1484 :         INPLACE_UPDATE(numerator,
; 1485 :                        long_methods->nb_multiply(numerator, py_exponent));

  001c3	48 8b d6	 mov	 rdx, rsi
  001c6	48 8b cf	 mov	 rcx, rdi
  001c9	48 8b df	 mov	 rbx, rdi
  001cc	41 ff 55 10	 call	 QWORD PTR [r13+16]
  001d0	48 8b cb	 mov	 rcx, rbx
  001d3	48 8b f8	 mov	 rdi, rax
  001d6	e8 00 00 00 00	 call	 _Py_DecRef

; 1486 :         if (numerator == NULL) goto error;

  001db	48 85 ff	 test	 rdi, rdi
  001de	74 23		 je	 SHORT $error$21066

; 1487 :     }
; 1488 :     else {

  001e0	eb 0e		 jmp	 SHORT $LN13@float_as_i
$LN15@float_as_i:

; 1489 :         Py_DECREF(denominator);

  001e2	48 8b cd	 mov	 rcx, rbp
  001e5	e8 00 00 00 00	 call	 _Py_DecRef

; 1490 :         denominator = py_exponent;

  001ea	48 8b ee	 mov	 rbp, rsi

; 1491 :         py_exponent = NULL;

  001ed	49 8b f4	 mov	 rsi, r12
$LN13@float_as_i:

; 1492 :     }
; 1493 : 
; 1494 :     result_pair = PyTuple_Pack(2, numerator, denominator);

  001f0	4c 8b c5	 mov	 r8, rbp
  001f3	48 8b d7	 mov	 rdx, rdi
  001f6	b9 02 00 00 00	 mov	 ecx, 2
  001fb	e8 00 00 00 00	 call	 PyTuple_Pack
  00200	4c 8b e0	 mov	 r12, rax
$error$21066:

; 1495 : 
; 1496 : #undef INPLACE_UPDATE
; 1497 : error:
; 1498 :     Py_XDECREF(py_exponent);

  00203	48 85 f6	 test	 rsi, rsi
  00206	74 67		 je	 SHORT $LN67@float_as_i
  00208	e8 00 00 00 00	 call	 _Py_PXCTX
  0020d	85 c0		 test	 eax, eax
  0020f	75 5e		 jne	 SHORT $LN67@float_as_i
  00211	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00215	f6 c1 20	 test	 cl, 32			; 00000020H
  00218	75 4d		 jne	 SHORT $LN34@float_as_i
  0021a	84 c9		 test	 cl, cl
  0021c	78 49		 js	 SHORT $LN34@float_as_i
  0021e	f6 c1 02	 test	 cl, 2
  00221	75 4c		 jne	 SHORT $LN67@float_as_i
  00223	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00227	75 46		 jne	 SHORT $LN67@float_as_i
  00229	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00237	4c 8b ce	 mov	 r9, rsi
  0023a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00240	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00248	e8 00 00 00 00	 call	 _PyParallel_Guard
  0024d	48 8b ce	 mov	 rcx, rsi
  00250	85 c0		 test	 eax, eax
  00252	74 07		 je	 SHORT $LN39@float_as_i
  00254	e8 00 00 00 00	 call	 _Px_Dealloc
  00259	eb 14		 jmp	 SHORT $LN67@float_as_i
$LN39@float_as_i:
  0025b	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0025f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00265	eb 08		 jmp	 SHORT $LN67@float_as_i
$LN34@float_as_i:
  00267	48 8b ce	 mov	 rcx, rsi
  0026a	e8 00 00 00 00	 call	 Px_DecRef
$LN67@float_as_i:
  0026f	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN11@float_as_i:

; 1499 :     Py_XDECREF(denominator);

  00274	48 85 ed	 test	 rbp, rbp
  00277	74 65		 je	 SHORT $LN7@float_as_i
  00279	e8 00 00 00 00	 call	 _Py_PXCTX
  0027e	85 c0		 test	 eax, eax
  00280	75 5c		 jne	 SHORT $LN7@float_as_i
  00282	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00286	a8 20		 test	 al, 32			; 00000020H
  00288	75 4c		 jne	 SHORT $LN45@float_as_i
  0028a	84 c0		 test	 al, al
  0028c	78 48		 js	 SHORT $LN45@float_as_i
  0028e	a8 02		 test	 al, 2
  00290	75 4c		 jne	 SHORT $LN7@float_as_i
  00292	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00296	75 46		 jne	 SHORT $LN7@float_as_i
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002a6	4c 8b cd	 mov	 r9, rbp
  002a9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002af	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002b7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002bc	48 8b cd	 mov	 rcx, rbp
  002bf	85 c0		 test	 eax, eax
  002c1	74 07		 je	 SHORT $LN50@float_as_i
  002c3	e8 00 00 00 00	 call	 _Px_Dealloc
  002c8	eb 14		 jmp	 SHORT $LN7@float_as_i
$LN50@float_as_i:
  002ca	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  002ce	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002d4	eb 08		 jmp	 SHORT $LN7@float_as_i
$LN45@float_as_i:
  002d6	48 8b cd	 mov	 rcx, rbp
  002d9	e8 00 00 00 00	 call	 Px_DecRef
$LN7@float_as_i:

; 1500 :     Py_XDECREF(numerator);

  002de	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]
  002e6	48 85 ff	 test	 rdi, rdi
  002e9	74 65		 je	 SHORT $LN3@float_as_i
  002eb	e8 00 00 00 00	 call	 _Py_PXCTX
  002f0	85 c0		 test	 eax, eax
  002f2	75 5c		 jne	 SHORT $LN3@float_as_i
  002f4	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  002f8	a8 20		 test	 al, 32			; 00000020H
  002fa	75 4c		 jne	 SHORT $LN56@float_as_i
  002fc	84 c0		 test	 al, al
  002fe	78 48		 js	 SHORT $LN56@float_as_i
  00300	a8 02		 test	 al, 2
  00302	75 4c		 jne	 SHORT $LN3@float_as_i
  00304	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00308	75 46		 jne	 SHORT $LN3@float_as_i
  0030a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00318	4c 8b cf	 mov	 r9, rdi
  0031b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00321	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00329	e8 00 00 00 00	 call	 _PyParallel_Guard
  0032e	48 8b cf	 mov	 rcx, rdi
  00331	85 c0		 test	 eax, eax
  00333	74 07		 je	 SHORT $LN61@float_as_i
  00335	e8 00 00 00 00	 call	 _Px_Dealloc
  0033a	eb 14		 jmp	 SHORT $LN3@float_as_i
$LN61@float_as_i:
  0033c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00340	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00346	eb 08		 jmp	 SHORT $LN3@float_as_i
$LN56@float_as_i:
  00348	48 8b cf	 mov	 rcx, rdi
  0034b	e8 00 00 00 00	 call	 Px_DecRef
$LN3@float_as_i:

; 1501 :     return result_pair;
; 1502 : }

  00350	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00355	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0035a	49 8b c4	 mov	 rax, r12
  0035d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00361	41 5d		 pop	 r13
  00363	41 5c		 pop	 r12
  00365	5b		 pop	 rbx
  00366	c3		 ret	 0
float_as_integer_ratio ENDP
_TEXT	ENDS
PUBLIC	??_C@_08BAKDHNHG@?$HMO?3float?$AA@		; `string'
EXTRN	PyNumber_Float:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_new DD imagerel float_new
	DD	imagerel float_new+131
	DD	imagerel $unwind$float_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_new DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_08BAKDHNHG@?$HMO?3float?$AA@
CONST	SEGMENT
??_C@_08BAKDHNHG@?$HMO?3float?$AA@ DB '|O:float', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_new
_TEXT	SEGMENT
x$ = 64
type$ = 64
args$ = 72
kwds$ = 80
float_new PROC						; COMDAT

; 1524 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b d2	 mov	 r10, rdx

; 1525 :     PyObject *x = Py_False; /* Integer zero */

  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
  0000e	49 8b c0	 mov	 rax, r8
  00011	48 89 54 24 40	 mov	 QWORD PTR x$[rsp], rdx

; 1526 :     static char *kwlist[] = {"x", 0};
; 1527 : 
; 1528 :     if (type != &PyFloat_Type)

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0001d	48 3b ca	 cmp	 rcx, rdx
  00020	74 0d		 je	 SHORT $LN3@float_new

; 1529 :         return float_subtype_new(type, args, kwds); /* Wimp out */

  00022	49 8b d2	 mov	 rdx, r10
  00025	e8 00 00 00 00	 call	 float_subtype_new

; 1537 : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
$LN3@float_new:

; 1530 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:float", kwlist, &x))

  0002f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x$[rsp]
  00034	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??float_new@@9@9
  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BAKDHNHG@?$HMO?3float?$AA@
  00042	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00047	49 8b ca	 mov	 rcx, r10
  0004a	48 8b d0	 mov	 rdx, rax
  0004d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00052	85 c0		 test	 eax, eax
  00054	75 07		 jne	 SHORT $LN2@float_new

; 1531 :         return NULL;

  00056	33 c0		 xor	 eax, eax

; 1537 : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
$LN2@float_new:

; 1532 :     /* If it's a string, but not a string subclass, use
; 1533 :        PyFloat_FromString. */
; 1534 :     if (PyUnicode_CheckExact(x))

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00069	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006d	75 0a		 jne	 SHORT $LN1@float_new

; 1535 :         return PyFloat_FromString(x);

  0006f	e8 00 00 00 00	 call	 PyFloat_FromString

; 1537 : }

  00074	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00078	c3		 ret	 0
$LN1@float_new:

; 1536 :     return PyNumber_Float(x);

  00079	e8 00 00 00 00	 call	 PyNumber_Float

; 1537 : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
float_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_subtype_new DD imagerel float_subtype_new
	DD	imagerel float_subtype_new+100
	DD	imagerel $unwind$float_subtype_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_subtype_new DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT float_subtype_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
float_subtype_new PROC					; COMDAT

; 1546 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 1547 :     PyObject *tmp, *newobj;
; 1548 : 
; 1549 :     assert(PyType_IsSubtype(type, &PyFloat_Type));
; 1550 :     tmp = float_new(&PyFloat_Type, args, kwds);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFloat_Type
  00014	e8 00 00 00 00	 call	 float_new
  00019	48 8b f8	 mov	 rdi, rax

; 1551 :     if (tmp == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 1552 :         return NULL;

  0001f	74 1b		 je	 SHORT $LN5@float_subt

; 1553 :     assert(PyFloat_CheckExact(tmp));
; 1554 :     newobj = type->tp_alloc(type, 0);

  00021	33 d2		 xor	 edx, edx
  00023	48 8b cb	 mov	 rcx, rbx
  00026	ff 93 88 01 00
	00		 call	 QWORD PTR [rbx+392]

; 1555 :     if (newobj == NULL) {
; 1556 :         Py_DECREF(tmp);

  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	48 8b d8	 mov	 rbx, rax
  00032	48 85 c0	 test	 rax, rax
  00035	75 12		 jne	 SHORT $LN1@float_subt
  00037	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@float_subt:

; 1557 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 1562 : }

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN1@float_subt:

; 1558 :     }
; 1559 :     ((PyFloatObject *)newobj)->ob_fval = ((PyFloatObject *)tmp)->ob_fval;

  00049	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0004d	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1560 :     Py_DECREF(tmp);

  00051	e8 00 00 00 00	 call	 _Py_DecRef

; 1561 :     return newobj;

  00056	48 8b c3	 mov	 rax, rbx

; 1562 : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
float_subtype_new ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT float_getnewargs
_TEXT	SEGMENT
v$ = 8
float_getnewargs PROC					; COMDAT

; 1567 :     return Py_BuildValue("(d)", v->ob_fval);

  00000	f2 0f 10 49 60	 movsdx	 xmm1, QWORD PTR [rcx+96]
  00005	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03LAKFFLCF@?$CId?$CJ?$AA@
  0000c	66 48 0f 7e ca	 movd	 rdx, xmm1

; 1568 : }

  00011	e9 00 00 00 00	 jmp	 Py_BuildValue
float_getnewargs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@ ; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@	; `string'
PUBLIC	??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@	; `string'
PUBLIC	??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@ ; `string'
PUBLIC	??_C@_06BNJCAIGJ@double?$AA@			; `string'
PUBLIC	??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	PyUnicode_AsUTF8:PROC
_BSS	SEGMENT
float_format DD	01H DUP (?)
double_format DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$float_getformat DD imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_getformat DD imagerel float_getformat+64
	DD	imagerel float_getformat+167
	DD	imagerel $chain$1$float_getformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$float_getformat DD imagerel float_getformat+167
	DD	imagerel float_getformat+193
	DD	imagerel $chain$3$float_getformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$float_getformat DD imagerel float_getformat+193
	DD	imagerel float_getformat+219
	DD	imagerel $chain$5$float_getformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$float_getformat DD imagerel float_getformat+219
	DD	imagerel float_getformat+245
	DD	imagerel $chain$7$float_getformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$float_getformat DD imagerel float_getformat+245
	DD	imagerel float_getformat+281
	DD	imagerel $chain$9$float_getformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$float_getformat DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$float_getformat DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$float_getformat DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$float_getformat DD 040021H
	DD	047400H
	DD	066400H
	DD	imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_getformat DD 040a21H
	DD	04740aH
	DD	066405H
	DD	imagerel float_getformat
	DD	imagerel float_getformat+64
	DD	imagerel $unwind$float_getformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_getformat DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@
CONST	SEGMENT
??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@ DB '__getf'
	DB	'ormat__() argument 1 must be ''double'' or ''float''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
CONST	SEGMENT
??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@ DB 'IEEE, big-endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
CONST	SEGMENT
??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@ DB 'IEEE, little-endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@
CONST	SEGMENT
??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@ DB 'insane float_'
	DB	'format or double_format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BNJCAIGJ@double?$AA@
CONST	SEGMENT
??_C@_06BNJCAIGJ@double?$AA@ DB 'double', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@
CONST	SEGMENT
??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@ DB '__getfo'
	DB	'rmat__() argument must be string, not %.500s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float_getformat
_TEXT	SEGMENT
v$ = 48
arg$ = 56
float_getformat PROC					; COMDAT

; 1581 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1582 :     char* s;
; 1583 :     float_format_type r;
; 1584 : 
; 1585 :     if (!PyUnicode_Check(arg)) {

  00004	4c 8b 42 58	 mov	 r8, QWORD PTR [rdx+88]
  00008	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00013	75 1e		 jne	 SHORT $LN12@float_getf

; 1586 :         PyErr_Format(PyExc_TypeError,
; 1587 :          "__getformat__() argument must be string, not %.500s",
; 1588 :                          Py_TYPE(arg)->tp_name);

  00015	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@CBKIPEFG@__getformat__?$CI?$CJ?5argument?5must?5be@
  00027	e8 00 00 00 00	 call	 PyErr_Format
$LN18@float_getf:

; 1589 :         return NULL;

  0002c	33 c0		 xor	 eax, eax

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
$LN12@float_getf:

; 1590 :     }
; 1591 :     s = _PyUnicode_AsString(arg);

  00033	48 8b ca	 mov	 rcx, rdx
  00036	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 1592 :     if (s == NULL)

  0003b	48 85 c0	 test	 rax, rax

; 1593 :         return NULL;

  0003e	74 ec		 je	 SHORT $LN18@float_getf

; 1594 :     if (strcmp(s, "double") == 0) {

  00040	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00045	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0004a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06BNJCAIGJ@double?$AA@
  00051	48 8b f0	 mov	 rsi, rax
  00054	b9 07 00 00 00	 mov	 ecx, 7
  00059	f3 a6		 repe cmpsb
  0005b	75 08		 jne	 SHORT $LN10@float_getf

; 1595 :         r = double_format;

  0005d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR double_format
  00063	eb 19		 jmp	 SHORT $LN7@float_getf
$LN10@float_getf:

; 1596 :     }
; 1597 :     else if (strcmp(s, "float") == 0) {

  00065	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05KNFBNCOH@float?$AA@
  0006c	48 8b f0	 mov	 rsi, rax
  0006f	b9 06 00 00 00	 mov	 ecx, 6
  00074	f3 a6		 repe cmpsb
  00076	75 7d		 jne	 SHORT $LN8@float_getf

; 1598 :         r = float_format;

  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR float_format
$LN7@float_getf:

; 1605 :     }
; 1606 : 
; 1607 :     switch (r) {

  0007e	85 c9		 test	 ecx, ecx
  00080	74 59		 je	 SHORT $LN4@float_getf
  00082	ff c9		 dec	 ecx
  00084	74 3b		 je	 SHORT $LN2@float_getf
  00086	ff c9		 dec	 ecx
  00088	74 1d		 je	 SHORT $LN3@float_getf

; 1614 :     default:
; 1615 :         Py_FatalError("insane float_format or double_format");

  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@FLPIAOEG@insane?5float_format?5or?5double_fo@
  00091	e8 00 00 00 00	 call	 Py_FatalError
  00096	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0009b	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000a0	33 c0		 xor	 eax, eax

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  000a2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a6	c3		 ret	 0
$LN3@float_getf:

; 1610 :     case ieee_little_endian_format:
; 1611 :         return PyUnicode_FromString("IEEE, little-endian");

  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
  000ae	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000b3	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  000b8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bc	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN2@float_getf:

; 1612 :     case ieee_big_endian_format:
; 1613 :         return PyUnicode_FromString("IEEE, big-endian");

  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
  000c8	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000cd	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  000d2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d6	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN4@float_getf:

; 1608 :     case unknown_format:
; 1609 :         return PyUnicode_FromString("unknown");

  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CIFAGBMG@unknown?$AA@
  000e2	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000e7	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  000ec	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f0	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN8@float_getf:

; 1599 :     }
; 1600 :     else {
; 1601 :         PyErr_SetString(PyExc_ValueError,
; 1602 :                         "__getformat__() argument 1 must be "
; 1603 :                         "'double' or 'float'");

  000f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@KIONBECL@__getformat__?$CI?$CJ?5argument?51?5must?5@
  00103	e8 00 00 00 00	 call	 PyErr_SetString
  00108	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0010d	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 1604 :         return NULL;

  00112	33 c0		 xor	 eax, eax

; 1616 :         return NULL;
; 1617 :     }
; 1618 : }

  00114	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00118	c3		 ret	 0
float_getformat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@ ; `string'
PUBLIC	??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@ ; `string'
PUBLIC	??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@ ; `string'
PUBLIC	??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@	; `string'
_BSS	SEGMENT
detected_float_format DD 01H DUP (?)
detected_double_format DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$float_setformat DD imagerel float_setformat
	DD	imagerel float_setformat+45
	DD	imagerel $unwind$float_setformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$float_setformat DD imagerel float_setformat+45
	DD	imagerel float_setformat+245
	DD	imagerel $chain$1$float_setformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$float_setformat DD imagerel float_setformat+245
	DD	imagerel float_setformat+339
	DD	imagerel $chain$3$float_setformat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$float_setformat DD imagerel float_setformat+339
	DD	imagerel float_setformat+384
	DD	imagerel $chain$5$float_setformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$float_setformat DD 040021H
	DD	067400H
	DD	086400H
	DD	imagerel float_setformat
	DD	imagerel float_setformat+45
	DD	imagerel $unwind$float_setformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$float_setformat DD 040021H
	DD	067400H
	DD	086400H
	DD	imagerel float_setformat
	DD	imagerel float_setformat+45
	DD	imagerel $unwind$float_setformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$float_setformat DD 040a21H
	DD	06740aH
	DD	086405H
	DD	imagerel float_setformat
	DD	imagerel float_setformat+45
	DD	imagerel $unwind$float_setformat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float_setformat DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@
CONST	SEGMENT
??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@ DB '__setfo'
	DB	'rmat__() argument 1 must be ''double'' or ''float''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@
CONST	SEGMENT
??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@ DB '__setf'
	DB	'ormat__() argument 2 must be ''unknown'', ''IEEE, little-endi'
	DB	'an'' or ''IEEE, big-endian''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@
CONST	SEGMENT
??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@ DB 'can on'
	DB	'ly set %s format to ''unknown'' or the detected platform valu'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@
CONST	SEGMENT
??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@ DB 'ss:__setformat__', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\floatobject.c
CONST	ENDS
;	COMDAT float_setformat
_TEXT	SEGMENT
v$ = 64
args$ = 72
typestr$ = 80
format$ = 88
float_setformat PROC					; COMDAT

; 1632 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1633 :     char* typestr;
; 1634 :     char* format;
; 1635 :     float_format_type f;
; 1636 :     float_format_type detected;
; 1637 :     float_format_type *p;
; 1638 : 
; 1639 :     if (!PyArg_ParseTuple(args, "ss:__setformat__", &typestr, &format))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 58	 lea	 r9, QWORD PTR format$[rsp]
  0000c	4c 8d 44 24 50	 lea	 r8, QWORD PTR typestr$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@HNELEHLF@ss?3__setformat__?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN12@float_setf

; 1640 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 1684 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN12@float_setf:

; 1641 : 
; 1642 :     if (strcmp(typestr, "double") == 0) {

  00028	4c 8b 44 24 50	 mov	 r8, QWORD PTR typestr$[rsp]
  0002d	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00032	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00037	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06BNJCAIGJ@double?$AA@
  0003e	b9 07 00 00 00	 mov	 ecx, 7
  00043	49 8b f0	 mov	 rsi, r8
  00046	f3 a6		 repe cmpsb
  00048	75 0f		 jne	 SHORT $LN11@float_setf

; 1643 :         p = &double_format;
; 1644 :         detected = detected_double_format;

  0004a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR detected_double_format
  00050	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:double_format
  00057	eb 24		 jmp	 SHORT $LN8@float_setf
$LN11@float_setf:

; 1645 :     }
; 1646 :     else if (strcmp(typestr, "float") == 0) {

  00059	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_05KNFBNCOH@float?$AA@
  00060	49 8b f0	 mov	 rsi, r8
  00063	b9 06 00 00 00	 mov	 ecx, 6
  00068	f3 a6		 repe cmpsb
  0006a	0f 85 ec 00 00
	00		 jne	 $LN9@float_setf

; 1647 :         p = &float_format;
; 1648 :         detected = detected_float_format;

  00070	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR detected_float_format
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:float_format
$LN8@float_setf:

; 1655 :     }
; 1656 : 
; 1657 :     if (strcmp(format, "unknown") == 0) {

  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR format$[rsp]
  00082	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_07CIFAGBMG@unknown?$AA@
  00089	b9 08 00 00 00	 mov	 ecx, 8
  0008e	48 8b f0	 mov	 rsi, rax
  00091	f3 a6		 repe cmpsb
  00093	75 60		 jne	 SHORT $LN7@float_setf

; 1658 :         f = unknown_format;

  00095	33 c0		 xor	 eax, eax
$LN1@float_setf:

; 1679 :         return NULL;
; 1680 :     }
; 1681 : 
; 1682 :     *p = f;

  00097	41 89 01	 mov	 DWORD PTR [r9], eax

; 1683 :     Py_RETURN_NONE;

  0009a	e8 00 00 00 00	 call	 _Py_PXCTX
  0009f	85 c0		 test	 eax, eax
  000a1	75 3c		 jne	 SHORT $LN16@float_setf
  000a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000be	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cb	85 c0		 test	 eax, eax
  000cd	75 09		 jne	 SHORT $LN15@float_setf
  000cf	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000d6	74 07		 je	 SHORT $LN16@float_setf
$LN15@float_setf:
  000d8	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN16@float_setf:
  000df	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e4	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1684 : }

  000f0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f4	c3		 ret	 0
$LN7@float_setf:

; 1659 :     }
; 1660 :     else if (strcmp(format, "IEEE, little-endian") == 0) {

  000f5	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BE@LIJMHFO@IEEE?0?5little?9endian?$AA@
  000fc	48 8b f0	 mov	 rsi, rax
  000ff	b9 14 00 00 00	 mov	 ecx, 20
  00104	f3 a6		 repe cmpsb
  00106	75 07		 jne	 SHORT $LN5@float_setf

; 1661 :         f = ieee_little_endian_format;

  00108	b8 02 00 00 00	 mov	 eax, 2
  0010d	eb 18		 jmp	 SHORT $LN19@float_setf
$LN5@float_setf:

; 1662 :     }
; 1663 :     else if (strcmp(format, "IEEE, big-endian") == 0) {

  0010f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BB@FPOIKJOA@IEEE?0?5big?9endian?$AA@
  00116	48 8b f0	 mov	 rsi, rax
  00119	b9 11 00 00 00	 mov	 ecx, 17
  0011e	f3 a6		 repe cmpsb
  00120	75 31		 jne	 SHORT $LN3@float_setf

; 1664 :         f = ieee_big_endian_format;

  00122	b8 01 00 00 00	 mov	 eax, 1
$LN19@float_setf:

; 1672 : 
; 1673 :     }
; 1674 : 
; 1675 :     if (f != unknown_format && f != detected) {

  00127	3b c2		 cmp	 eax, edx
  00129	0f 84 68 ff ff
	ff		 je	 $LN1@float_setf

; 1676 :         PyErr_Format(PyExc_ValueError,
; 1677 :                      "can only set %s format to 'unknown' or the "
; 1678 :                      "detected platform value", typestr);

  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@KOPFAODE@can?5only?5set?5?$CFs?5format?5to?5?8unkno@
  0013d	e8 00 00 00 00	 call	 PyErr_Format
  00142	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00147	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0014c	33 c0		 xor	 eax, eax

; 1684 : }

  0014e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00152	c3		 ret	 0
$LN3@float_setf:

; 1665 :     }
; 1666 :     else {
; 1667 :         PyErr_SetString(PyExc_ValueError,
; 1668 :                         "__setformat__() argument 2 must be "
; 1669 :                         "'unknown', 'IEEE, little-endian' or "
; 1670 :                         "'IEEE, big-endian'");

  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FK@HCEKLDKI@__setformat__?$CI?$CJ?5argument?52?5must?5@

; 1671 :         return NULL;

  0015a	eb 07		 jmp	 SHORT $LN23@float_setf
$LN9@float_setf:

; 1649 :     }
; 1650 :     else {
; 1651 :         PyErr_SetString(PyExc_ValueError,
; 1652 :                         "__setformat__() argument 1 must "
; 1653 :                         "be 'double' or 'float'");

  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@ILBMOHK@__setformat__?$CI?$CJ?5argument?51?5must?5@
$LN23@float_setf:
  00163	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0016a	e8 00 00 00 00	 call	 PyErr_SetString
  0016f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00174	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1654 :         return NULL;

  00179	33 c0		 xor	 eax, eax

; 1684 : }

  0017b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017f	c3		 ret	 0
float_setformat ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT float_getzero
_TEXT	SEGMENT
v$ = 8
closure$ = 16
float_getzero PROC					; COMDAT

; 1702 :     return PyFloat_FromDouble(0.0);

  00000	66 0f 57 c0	 xorpd	 xmm0, xmm0

; 1703 : }

  00004	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
float_getzero ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	_PyUnicodeWriter_Finish:PROC
EXTRN	_PyUnicodeWriter_Dealloc:PROC
EXTRN	_PyFloat_FormatAdvancedWriter:PROC
EXTRN	_PyUnicodeWriter_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$float__format__ DD imagerel float__format__
	DD	imagerel float__format__+118
	DD	imagerel $unwind$float__format__
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$float__format__ DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT float__format__
_TEXT	SEGMENT
writer$ = 48
self$ = 128
args$ = 136
format_spec$ = 144
float__format__ PROC					; COMDAT

; 1707 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 1708 :     PyObject *format_spec;
; 1709 :     _PyUnicodeWriter writer;
; 1710 :     int ret;
; 1711 : 
; 1712 :     if (!PyArg_ParseTuple(args, "U:__format__", &format_spec))

  0000c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR format_spec$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00023	85 c0		 test	 eax, eax

; 1713 :         return NULL;

  00025	74 3c		 je	 SHORT $LN5@float__for

; 1714 : 
; 1715 :     _PyUnicodeWriter_Init(&writer, 0);

  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Init

; 1716 :     ret = _PyFloat_FormatAdvancedWriter(
; 1717 :         &writer,
; 1718 :         self,
; 1719 :         format_spec, 0, PyUnicode_GET_LENGTH(format_spec));

  00033	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR format_spec$[rsp]
  0003b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00040	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  00044	45 33 c9	 xor	 r9d, r9d
  00047	48 8b d3	 mov	 rdx, rbx
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	e8 00 00 00 00	 call	 _PyFloat_FormatAdvancedWriter

; 1720 :     if (ret == -1) {
; 1721 :         _PyUnicodeWriter_Dealloc(&writer);

  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR writer$[rsp]
  00059	83 f8 ff	 cmp	 eax, -1
  0005c	75 0d		 jne	 SHORT $LN1@float__for
  0005e	e8 00 00 00 00	 call	 _PyUnicodeWriter_Dealloc
$LN5@float__for:

; 1722 :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 1725 : }

  00065	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN1@float__for:

; 1723 :     }
; 1724 :     return _PyUnicodeWriter_Finish(&writer);

  0006b	e8 00 00 00 00	 call	 _PyUnicodeWriter_Finish

; 1725 : }

  00070	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
float__format__ ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@		; `string'
PUBLIC	??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@		; `string'
PUBLIC	__real@4b7f0102
PUBLIC	??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ ; `string'
PUBLIC	??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ ; `string'
PUBLIC	__real@433fff0102030405
PUBLIC	_PyFloat_Init
EXTRN	PyStructSequence_InitType:PROC
_BSS	SEGMENT
FloatInfoType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Init DD imagerel $LN13
	DD	imagerel $LN13+169
	DD	imagerel $unwind$_PyFloat_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
CONST	SEGMENT
??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@ DB 02H, 01H, 07fH, 'K', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
CONST	SEGMENT
??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@ DB 'K', 07fH, 01H, 02H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4b7f0102
CONST	SEGMENT
__real@4b7f0102 DD 04b7f0102r			; 1.67119e+007
CONST	ENDS
;	COMDAT ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
CONST	SEGMENT
??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ DB 05H, 04H, 03H, 02H
	DB	01H, 0ffH, '?C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
CONST	SEGMENT
??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ DB 'C?', 0ffH, 01H, 02H
	DB	03H, 04H, 05H, 00H				; `string'
CONST	ENDS
;	COMDAT __real@433fff0102030405
CONST	SEGMENT
__real@433fff0102030405 DQ 0433fff0102030405r	; 9.0061e+015
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_Init
_TEXT	SEGMENT
y$21326 = 48
x$21319 = 48
_PyFloat_Init PROC					; COMDAT

; 1864 : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1865 :     /* We attempt to determine if this machine is using IEEE
; 1866 :        floating point formats by peering at the bits of some
; 1867 :        carefully chosen values.  If it looks like we are on an
; 1868 :        IEEE platform, the float packing/unpacking routines can
; 1869 :        just copy bits, if not they resort to arithmetic & shifts
; 1870 :        and masks.  The shifts & masks approach works on all finite
; 1871 :        values, but what happens to infinities, NaNs and signed
; 1872 :        zeroes on packing is an accident, and attempting to unpack
; 1873 :        a NaN or an infinity will raise an exception.
; 1874 : 
; 1875 :        Note that if we're on some whacked-out platform which uses
; 1876 :        IEEE formats but isn't strictly little-endian or big-
; 1877 :        endian, we will fall back to the portable shifts & masks
; 1878 :        method. */
; 1879 : 
; 1880 : #if SIZEOF_DOUBLE == 8
; 1881 :     {
; 1882 :         double x = 9006104071832581.0;

  00004	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@433fff0102030405

; 1883 :         if (memcmp(&x, "\x43\x3f\xff\x01\x02\x03\x04\x05", 8) == 0)

  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR x$21319[rsp], xmm0
  00017	44 8d 49 01	 lea	 r9d, QWORD PTR [rcx+1]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR x$21319[rsp]
  00020	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
  00027	75 0a		 jne	 SHORT $LN9@PyFloat_In

; 1884 :             detected_double_format = ieee_big_endian_format;

  00029	8b d1		 mov	 edx, ecx
  0002b	89 0d 00 00 00
	00		 mov	 DWORD PTR detected_double_format, ecx
  00031	eb 16		 jmp	 SHORT $LN7@PyFloat_In
$LN9@PyFloat_In:

; 1885 :         else if (memcmp(&x, "\x05\x04\x03\x02\x01\xff\x3f\x43", 8) == 0)

  00033	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
  0003a	ba 00 00 00 00	 mov	 edx, 0
  0003f	41 0f 44 d1	 cmove	 edx, r9d
  00043	89 15 00 00 00
	00		 mov	 DWORD PTR detected_double_format, edx
$LN7@PyFloat_In:

; 1886 :             detected_double_format = ieee_little_endian_format;
; 1887 :         else
; 1888 :             detected_double_format = unknown_format;
; 1889 :     }
; 1890 : #else
; 1891 :     detected_double_format = unknown_format;
; 1892 : #endif
; 1893 : 
; 1894 : #if SIZEOF_FLOAT == 4
; 1895 :     {
; 1896 :         float y = 16711938.0;

  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4b7f0102
  00051	f3 0f 11 44 24
	30		 movss	 DWORD PTR y$21326[rsp], xmm0

; 1897 :         if (memcmp(&y, "\x4b\x7f\x01\x02", 4) == 0)

  00057	44 8b 44 24 30	 mov	 r8d, DWORD PTR y$21326[rsp]
  0005c	44 3b 05 00 00
	00 00		 cmp	 r8d, DWORD PTR ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@

; 1898 :             detected_float_format = ieee_big_endian_format;

  00063	74 10		 je	 SHORT $LN12@PyFloat_In

; 1899 :         else if (memcmp(&y, "\x02\x01\x7f\x4b", 4) == 0)

  00065	44 3b 05 00 00
	00 00		 cmp	 r8d, DWORD PTR ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
  0006c	b9 00 00 00 00	 mov	 ecx, 0
  00071	41 0f 44 c9	 cmove	 ecx, r9d
$LN12@PyFloat_In:

; 1900 :             detected_float_format = ieee_little_endian_format;
; 1901 :         else
; 1902 :             detected_float_format = unknown_format;
; 1903 :     }
; 1904 : #else
; 1905 :     detected_float_format = unknown_format;
; 1906 : #endif
; 1907 : 
; 1908 :     double_format = detected_double_format;
; 1909 :     float_format = detected_float_format;
; 1910 : 
; 1911 :     /* Init float info */
; 1912 :     if (FloatInfoType.tp_name == 0)

  00075	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR FloatInfoType+112, 0
  0007d	89 0d 00 00 00
	00		 mov	 DWORD PTR detected_float_format, ecx
  00083	89 15 00 00 00
	00		 mov	 DWORD PTR double_format, edx
  00089	89 0d 00 00 00
	00		 mov	 DWORD PTR float_format, ecx
  0008f	75 13		 jne	 SHORT $LN1@PyFloat_In

; 1913 :         PyStructSequence_InitType(&FloatInfoType, &floatinfo_desc);

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:floatinfo_desc
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:FloatInfoType
  0009f	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN1@PyFloat_In:

; 1914 : }

  000a4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a8	c3		 ret	 0
_PyFloat_Init ENDP
_TEXT	ENDS
PUBLIC	PyFloat_ClearFreeList
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_ClearFreeList DD imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$PyFloat_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyFloat_ClearFreeList DD imagerel $LN8+50
	DD	imagerel $LN8+89
	DD	imagerel $chain$0$PyFloat_ClearFreeList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyFloat_ClearFreeList DD imagerel $LN8+89
	DD	imagerel $LN8+117
	DD	imagerel $chain$1$PyFloat_ClearFreeList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyFloat_ClearFreeList DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$PyFloat_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyFloat_ClearFreeList DD 020521H
	DD	063405H
	DD	imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$PyFloat_ClearFreeList
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_ClearFreeList DD 040a01H
	DD	07640aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyFloat_ClearFreeList
_TEXT	SEGMENT
PyFloat_ClearFreeList PROC				; COMDAT

; 1918 : {

$LN8:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1919 :     PyFloatObject *f = free_list, *next;

  0000a	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR free_list

; 1920 :     int i = numfree;

  00011	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR numfree

; 1921 :     if (Py_PXCTX)

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	74 0d		 je	 SHORT $LN6@PyFloat_Cl

; 1922 :         return 0;

  00020	33 c0		 xor	 eax, eax

; 1931 : }

  00022	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
$LN6@PyFloat_Cl:

; 1923 :     while (f) {

  0002d	48 85 ff	 test	 rdi, rdi
  00030	74 27		 je	 SHORT $LN1@PyFloat_Cl
  00032	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00037	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@PyFloat_Cl:

; 1924 :         next = (PyFloatObject*) Py_TYPE(f);

  00040	48 8b 5f 58	 mov	 rbx, QWORD PTR [rdi+88]

; 1925 :         PyObject_FREE(f);

  00044	48 8b cf	 mov	 rcx, rdi
  00047	e8 00 00 00 00	 call	 PyObject_Free

; 1926 :         f = next;

  0004c	48 8b fb	 mov	 rdi, rbx
  0004f	48 85 db	 test	 rbx, rbx
  00052	75 ec		 jne	 SHORT $LL2@PyFloat_Cl
  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@PyFloat_Cl:

; 1927 :     }
; 1928 :     free_list = NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	48 89 05 00 00
	00 00		 mov	 QWORD PTR free_list, rax

; 1929 :     numfree = 0;

  00062	89 05 00 00 00
	00		 mov	 DWORD PTR numfree, eax

; 1930 :     return i;

  00068	8b c6		 mov	 eax, esi

; 1931 : }

  0006a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
PyFloat_ClearFreeList ENDP
_TEXT	ENDS
PUBLIC	PyFloat_Fini
; Function compile flags: /Ogtpy
;	COMDAT PyFloat_Fini
_TEXT	SEGMENT
PyFloat_Fini PROC					; COMDAT

; 1936 :     (void)PyFloat_ClearFreeList();
; 1937 : }

  00000	e9 00 00 00 00	 jmp	 PyFloat_ClearFreeList
PyFloat_Fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@	; `string'
PUBLIC	_PyFloat_DebugMallocStats
EXTRN	_PyDebugAllocatorStats:PROC
;	COMDAT ??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@
CONST	SEGMENT
??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@ DB 'free PyFloatObject', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_DebugMallocStats
_TEXT	SEGMENT
out$ = 8
_PyFloat_DebugMallocStats PROC				; COMDAT

; 1943 :     _PyDebugAllocatorStats(out,
; 1944 :                            "free PyFloatObject",
; 1945 :                            numfree, sizeof(PyFloatObject));

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR numfree
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KGFOHJAA@free?5PyFloatObject?$AA@
  0000e	41 b9 70 00 00
	00		 mov	 r9d, 112		; 00000070H

; 1946 : }

  00014	e9 00 00 00 00	 jmp	 _PyDebugAllocatorStats
_PyFloat_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@ ; `string'
PUBLIC	??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@ ; `string'
PUBLIC	__real@4160000000000000
PUBLIC	_PyFloat_Pack4
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Pack4 DD imagerel $LN39
	DD	imagerel $LN39+529
	DD	imagerel $unwind$_PyFloat_Pack4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Pack4 DD 0a2301H
	DD	027823H
	DD	03681bH
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT ??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@
CONST	SEGMENT
??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@ DB 'float too'
	DB	' large to pack with f format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@ DB 'frexp()'
	DB	' result out of range', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4160000000000000
CONST	SEGMENT
__real@4160000000000000 DQ 04160000000000000r	; 8.38861e+006
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_Pack4
_TEXT	SEGMENT
x$ = 80
p$ = 88
le$ = 96
y$21388 = 104
e$21363 = 104
_PyFloat_Pack4 PROC					; COMDAT

; 1954 : {

$LN39:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1955 :     if (float_format == unknown_format) {

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR float_format, 0
  00016	0f 29 74 24 30	 movaps	 XMMWORD PTR [rsp+48], xmm6
  0001b	41 8b f8	 mov	 edi, r8d
  0001e	0f 29 7c 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm7
  00023	66 0f 28 f0	 movapd	 xmm6, xmm0
  00027	48 8b da	 mov	 rbx, rdx

; 1956 :         unsigned char sign;
; 1957 :         int e;
; 1958 :         double f;
; 1959 :         unsigned int fbits;
; 1960 :         int incr = 1;

  0002a	be 01 00 00 00	 mov	 esi, 1
  0002f	0f 85 1a 01 00
	00		 jne	 $LN25@PyFloat_Pa

; 1961 : 
; 1962 :         if (le) {

  00035	45 85 c0	 test	 r8d, r8d
  00038	74 07		 je	 SHORT $LN24@PyFloat_Pa

; 1963 :             p += 3;

  0003a	48 83 c3 03	 add	 rbx, 3

; 1964 :             incr = -1;

  0003e	83 ce ff	 or	 esi, -1
$LN24@PyFloat_Pa:

; 1965 :         }
; 1966 : 
; 1967 :         if (x < 0) {

  00041	66 0f 57 ff	 xorpd	 xmm7, xmm7
  00045	66 0f 2f f8	 comisd	 xmm7, xmm0
  00049	76 0d		 jbe	 SHORT $LN23@PyFloat_Pa

; 1968 :             sign = 1;
; 1969 :             x = -x;

  0004b	66 0f 57 35 00
	00 00 00	 xorpd	 xmm6, QWORD PTR __mask@@NegDouble@
  00053	40 b7 01	 mov	 dil, 1

; 1970 :         }
; 1971 :         else

  00056	eb 03		 jmp	 SHORT $LN22@PyFloat_Pa
$LN23@PyFloat_Pa:

; 1972 :             sign = 0;

  00058	40 32 ff	 xor	 dil, dil
$LN22@PyFloat_Pa:

; 1973 : 
; 1974 :         f = frexp(x, &e);

  0005b	48 8d 54 24 68	 lea	 rdx, QWORD PTR e$21363[rsp]
  00060	66 0f 28 c6	 movapd	 xmm0, xmm6
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp

; 1975 : 
; 1976 :         /* Normalize f to be in the range [1.0, 2.0) */
; 1977 :         if (0.5 <= f && f < 1.0) {

  0006a	f2 0f 10 35 00
	00 00 00	 movsdx	 xmm6, QWORD PTR __real@3fe0000000000000
  00072	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3ff0000000000000
  0007a	66 0f 2f c6	 comisd	 xmm0, xmm6
  0007e	72 3c		 jb	 SHORT $LN21@PyFloat_Pa
  00080	66 0f 2f c8	 comisd	 xmm1, xmm0
  00084	76 36		 jbe	 SHORT $LN21@PyFloat_Pa

; 1978 :             f *= 2.0;
; 1979 :             e--;

  00086	8b 54 24 68	 mov	 edx, DWORD PTR e$21363[rsp]
  0008a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  00092	ff ca		 dec	 edx
  00094	89 54 24 68	 mov	 DWORD PTR e$21363[rsp], edx

; 1987 :         }
; 1988 : 
; 1989 :         if (e >= 128)

  00098	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  0009e	0f 8d f3 00 00
	00		 jge	 $Overflow$21376

; 1990 :             goto Overflow;
; 1991 :         else if (e < -126) {

  000a4	83 fa 82	 cmp	 edx, -126		; ffffffffffffff82H
  000a7	7d 0d		 jge	 SHORT $LN15@PyFloat_Pa

; 1992 :             /* Gradual underflow */
; 1993 :             f = ldexp(f, 126 + e);

  000a9	83 c2 7e	 add	 edx, 126		; 0000007eH
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 1994 :             e = 0;

  000b2	33 d2		 xor	 edx, edx
  000b4	eb 1f		 jmp	 SHORT $LN13@PyFloat_Pa
$LN15@PyFloat_Pa:

; 1995 :         }
; 1996 :         else if (!(e == 0 && f == 0.0)) {

  000b6	85 d2		 test	 edx, edx
  000b8	75 14		 jne	 SHORT $LN37@PyFloat_Pa
  000ba	eb 0a		 jmp	 SHORT $LN36@PyFloat_Pa
$LN21@PyFloat_Pa:

; 1980 :         }
; 1981 :         else if (f == 0.0)

  000bc	66 0f 2e c7	 ucomisd xmm0, xmm7
  000c0	7a 72		 jp	 SHORT $LN19@PyFloat_Pa
  000c2	75 70		 jne	 SHORT $LN19@PyFloat_Pa

; 1982 :             e = 0;

  000c4	33 d2		 xor	 edx, edx
$LN36@PyFloat_Pa:

; 1995 :         }
; 1996 :         else if (!(e == 0 && f == 0.0)) {

  000c6	66 0f 2e c7	 ucomisd xmm0, xmm7
  000ca	7a 02		 jp	 SHORT $LN37@PyFloat_Pa
  000cc	74 07		 je	 SHORT $LN13@PyFloat_Pa
$LN37@PyFloat_Pa:

; 1997 :             e += 127;

  000ce	83 c2 7f	 add	 edx, 127		; 0000007fH

; 1998 :             f -= 1.0; /* Get rid of leading 1 */

  000d1	f2 0f 5c c1	 subsd	 xmm0, xmm1
$LN13@PyFloat_Pa:

; 1999 :         }
; 2000 : 
; 2001 :         f *= 8388608.0; /* 2**23 */

  000d5	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4160000000000000

; 2002 :         fbits = (unsigned int)(f + 0.5); /* Round */

  000dd	f2 0f 58 c6	 addsd	 xmm0, xmm6
  000e1	f2 4c 0f 2c c0	 cvttsd2si r8, xmm0

; 2003 :         assert(fbits <= 8388608);
; 2004 :         if (fbits >> 23) {

  000e6	41 f7 c0 00 00
	80 ff		 test	 r8d, -8388608		; ff800000H
  000ed	74 11		 je	 SHORT $LN10@PyFloat_Pa

; 2005 :             /* The carry propagated out of a string of 23 1 bits. */
; 2006 :             fbits = 0;
; 2007 :             ++e;

  000ef	ff c2		 inc	 edx
  000f1	45 33 c0	 xor	 r8d, r8d

; 2008 :             if (e >= 255)

  000f4	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  000fa	0f 8d 97 00 00
	00		 jge	 $Overflow$21376
$LN10@PyFloat_Pa:

; 2009 :                 goto Overflow;
; 2010 :         }
; 2011 : 
; 2012 :         /* First byte */
; 2013 :         *p = (sign << 7) | (e >> 1);
; 2014 :         p += incr;

  00100	48 63 ce	 movsxd	 rcx, esi
  00103	8b c2		 mov	 eax, edx
  00105	40 c0 e7 07	 shl	 dil, 7
  00109	d1 f8		 sar	 eax, 1

; 2015 : 
; 2016 :         /* Second byte */
; 2017 :         *p = (char) (((e & 1) << 7) | (fbits >> 16));

  0010b	c0 e2 07	 shl	 dl, 7
  0010e	40 0a c7	 or	 al, dil
  00111	88 03		 mov	 BYTE PTR [rbx], al
  00113	48 03 d9	 add	 rbx, rcx
  00116	41 8b c0	 mov	 eax, r8d
  00119	c1 e8 10	 shr	 eax, 16
  0011c	0a c2		 or	 al, dl
  0011e	88 03		 mov	 BYTE PTR [rbx], al

; 2018 :         p += incr;

  00120	48 03 d9	 add	 rbx, rcx

; 2019 : 
; 2020 :         /* Third byte */
; 2021 :         *p = (fbits >> 8) & 0xFF;

  00123	41 8b c0	 mov	 eax, r8d
  00126	c1 e8 08	 shr	 eax, 8
  00129	88 03		 mov	 BYTE PTR [rbx], al

; 2022 :         p += incr;
; 2023 : 
; 2024 :         /* Fourth byte */
; 2025 :         *p = fbits & 0xFF;

  0012b	44 88 04 19	 mov	 BYTE PTR [rcx+rbx], r8b

; 2026 : 
; 2027 :         /* Done */
; 2028 :         return 0;

  0012f	e9 c1 00 00 00	 jmp	 $LN38@PyFloat_Pa
$LN19@PyFloat_Pa:

; 1983 :         else {
; 1984 :             PyErr_SetString(PyExc_SystemError,
; 1985 :                             "frexp() result out of range");

  00134	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0013b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@
  00142	e8 00 00 00 00	 call	 PyErr_SetString

; 1986 :             return -1;

  00147	83 c8 ff	 or	 eax, -1
  0014a	e9 a8 00 00 00	 jmp	 $LN26@PyFloat_Pa
$LN25@PyFloat_Pa:

; 2029 : 
; 2030 :     }
; 2031 :     else {
; 2032 :         float y = (float)x;

  0014f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00153	f3 0f 11 44 24
	68		 movss	 DWORD PTR y$21388[rsp], xmm0

; 2033 :         const char *s = (char*)&y;
; 2034 :         int i, incr = 1;
; 2035 : 
; 2036 :         if (Py_IS_INFINITY(y) && !Py_IS_INFINITY(x))

  00159	0f 14 c0	 unpcklps xmm0, xmm0
  0015c	0f 5a f8	 cvtps2pd xmm7, xmm0
  0015f	66 0f 28 c7	 movapd	 xmm0, xmm7
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00169	85 c0		 test	 eax, eax
  0016b	75 42		 jne	 SHORT $LN8@PyFloat_Pa
  0016d	66 0f 28 c7	 movapd	 xmm0, xmm7
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00177	85 c0		 test	 eax, eax
  00179	75 34		 jne	 SHORT $LN8@PyFloat_Pa
  0017b	66 0f 28 c6	 movapd	 xmm0, xmm6
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00185	85 c0		 test	 eax, eax
  00187	75 0e		 jne	 SHORT $Overflow$21376
  00189	66 0f 28 c6	 movapd	 xmm0, xmm6
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00193	85 c0		 test	 eax, eax
  00195	74 18		 je	 SHORT $LN8@PyFloat_Pa
$Overflow$21376:

; 2050 :     }
; 2051 :   Overflow:
; 2052 :     PyErr_SetString(PyExc_OverflowError,
; 2053 :                     "float too large to pack with f format");

  00197	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0019e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@KFOPKBPB@float?5too?5large?5to?5pack?5with?5f?5f@
  001a5	e8 00 00 00 00	 call	 PyErr_SetString

; 2054 :     return -1;

  001aa	83 c8 ff	 or	 eax, -1
  001ad	eb 48		 jmp	 SHORT $LN26@PyFloat_Pa
$LN8@PyFloat_Pa:

; 2037 :             goto Overflow;
; 2038 : 
; 2039 :         if ((float_format == ieee_little_endian_format && !le)
; 2040 :             || (float_format == ieee_big_endian_format && le)) {

  001af	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float_format
  001b5	83 f8 02	 cmp	 eax, 2
  001b8	75 06		 jne	 SHORT $LN4@PyFloat_Pa
  001ba	85 ff		 test	 edi, edi
  001bc	74 0a		 je	 SHORT $LN5@PyFloat_Pa
  001be	eb 0f		 jmp	 SHORT $LN6@PyFloat_Pa
$LN4@PyFloat_Pa:
  001c0	3b c6		 cmp	 eax, esi
  001c2	75 0b		 jne	 SHORT $LN6@PyFloat_Pa
  001c4	85 ff		 test	 edi, edi
  001c6	74 07		 je	 SHORT $LN6@PyFloat_Pa
$LN5@PyFloat_Pa:

; 2041 :             p += 3;

  001c8	48 83 c3 03	 add	 rbx, 3

; 2042 :             incr = -1;

  001cc	83 ce ff	 or	 esi, -1
$LN6@PyFloat_Pa:

; 2043 :         }
; 2044 : 
; 2045 :         for (i = 0; i < 4; i++) {
; 2046 :             *p = *s++;

  001cf	0f b6 44 24 68	 movzx	 eax, BYTE PTR y$21388[rsp]

; 2047 :             p += incr;

  001d4	48 63 ce	 movsxd	 rcx, esi
  001d7	88 03		 mov	 BYTE PTR [rbx], al
  001d9	0f b6 44 24 69	 movzx	 eax, BYTE PTR y$21388[rsp+1]
  001de	48 03 d9	 add	 rbx, rcx
  001e1	88 03		 mov	 BYTE PTR [rbx], al
  001e3	0f b6 44 24 6a	 movzx	 eax, BYTE PTR y$21388[rsp+2]
  001e8	48 03 d9	 add	 rbx, rcx
  001eb	88 03		 mov	 BYTE PTR [rbx], al
  001ed	0f b6 44 24 6b	 movzx	 eax, BYTE PTR y$21388[rsp+3]
  001f2	88 04 19	 mov	 BYTE PTR [rcx+rbx], al
$LN38@PyFloat_Pa:

; 2048 :         }
; 2049 :         return 0;

  001f5	33 c0		 xor	 eax, eax
$LN26@PyFloat_Pa:

; 2055 : }

  001f7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001fc	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00201	0f 28 74 24 30	 movaps	 xmm6, XMMWORD PTR [rsp+48]
  00206	0f 28 7c 24 20	 movaps	 xmm7, XMMWORD PTR [rsp+32]
  0020b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0020f	5f		 pop	 rdi
  00210	c3		 ret	 0
_PyFloat_Pack4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@ ; `string'
PUBLIC	__real@4170000000000000
PUBLIC	__real@41b0000000000000
PUBLIC	_PyFloat_Pack8
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Pack8 DD imagerel $LN44
	DD	imagerel $LN44+38
	DD	imagerel $unwind$_PyFloat_Pack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyFloat_Pack8 DD imagerel $LN44+38
	DD	imagerel $LN44+363
	DD	imagerel $chain$1$_PyFloat_Pack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyFloat_Pack8 DD imagerel $LN44+363
	DD	imagerel $LN44+473
	DD	imagerel $chain$3$_PyFloat_Pack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyFloat_Pack8 DD imagerel $LN44+473
	DD	imagerel $LN44+592
	DD	imagerel $chain$4$_PyFloat_Pack8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyFloat_Pack8 DD 021H
	DD	imagerel $LN44
	DD	imagerel $LN44+38
	DD	imagerel $unwind$_PyFloat_Pack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyFloat_Pack8 DD 040021H
	DD	026800H
	DD	096400H
	DD	imagerel $LN44
	DD	imagerel $LN44+38
	DD	imagerel $unwind$_PyFloat_Pack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyFloat_Pack8 DD 041a21H
	DD	09641aH
	DD	026805H
	DD	imagerel $LN44
	DD	imagerel $LN44+38
	DD	imagerel $unwind$_PyFloat_Pack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Pack8 DD 041001H
	DD	0a3410H
	DD	0700c5210H
xdata	ENDS
;	COMDAT ??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@
CONST	SEGMENT
??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@ DB 'float too'
	DB	' large to pack with d format', 00H		; `string'
CONST	ENDS
;	COMDAT __real@4170000000000000
CONST	SEGMENT
__real@4170000000000000 DQ 04170000000000000r	; 1.67772e+007
CONST	ENDS
;	COMDAT __real@41b0000000000000
CONST	SEGMENT
__real@41b0000000000000 DQ 041b0000000000000r	; 2.68435e+008
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_Pack8
_TEXT	SEGMENT
x$ = 64
p$ = 72
le$ = 80
e$21412 = 88
_PyFloat_Pack8 PROC					; COMDAT

; 2059 : {

$LN44:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  0000b	57		 push	 rdi
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2060 :     if (double_format == unknown_format) {

  00010	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR double_format
  00016	48 8b da	 mov	 rbx, rdx

; 2061 :         unsigned char sign;
; 2062 :         int e;
; 2063 :         double f;
; 2064 :         unsigned int fhi, flo;
; 2065 :         int incr = 1;

  00019	bf 01 00 00 00	 mov	 edi, 1
  0001e	85 c0		 test	 eax, eax
  00020	0f 85 b3 01 00
	00		 jne	 $LN24@PyFloat_Pa@2

; 2066 : 
; 2067 :         if (le) {

  00026	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  0002b	45 85 c0	 test	 r8d, r8d
  0002e	74 07		 je	 SHORT $LN23@PyFloat_Pa@2

; 2068 :             p += 7;

  00030	48 83 c3 07	 add	 rbx, 7

; 2069 :             incr = -1;

  00034	83 cf ff	 or	 edi, -1
$LN23@PyFloat_Pa@2:

; 2070 :         }
; 2071 : 
; 2072 :         if (x < 0) {

  00037	66 0f 57 f6	 xorpd	 xmm6, xmm6
  0003b	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00040	66 0f 2f f0	 comisd	 xmm6, xmm0
  00044	76 0d		 jbe	 SHORT $LN22@PyFloat_Pa@2

; 2073 :             sign = 1;
; 2074 :             x = -x;

  00046	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0004e	40 b6 01	 mov	 sil, 1

; 2075 :         }
; 2076 :         else

  00051	eb 03		 jmp	 SHORT $LN21@PyFloat_Pa@2
$LN22@PyFloat_Pa@2:

; 2077 :             sign = 0;

  00053	40 32 f6	 xor	 sil, sil
$LN21@PyFloat_Pa@2:

; 2078 : 
; 2079 :         f = frexp(x, &e);

  00056	48 8d 54 24 58	 lea	 rdx, QWORD PTR e$21412[rsp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  00061	66 0f 28 e8	 movapd	 xmm5, xmm0

; 2080 : 
; 2081 :         /* Normalize f to be in the range [1.0, 2.0) */
; 2082 :         if (0.5 <= f && f < 1.0) {

  00065	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0006d	66 0f 2f 2d 00
	00 00 00	 comisd	 xmm5, QWORD PTR __real@3fe0000000000000
  00075	72 4a		 jb	 SHORT $LN20@PyFloat_Pa@2
  00077	66 0f 2f c5	 comisd	 xmm0, xmm5
  0007b	76 44		 jbe	 SHORT $LN20@PyFloat_Pa@2

; 2083 :             f *= 2.0;
; 2084 :             e--;

  0007d	8b 54 24 58	 mov	 edx, DWORD PTR e$21412[rsp]
  00081	f2 0f 59 2d 00
	00 00 00	 mulsd	 xmm5, QWORD PTR __real@4000000000000000
  00089	ff ca		 dec	 edx
  0008b	89 54 24 58	 mov	 DWORD PTR e$21412[rsp], edx

; 2092 :         }
; 2093 : 
; 2094 :         if (e >= 1024)

  0008f	81 fa 00 04 00
	00		 cmp	 edx, 1024		; 00000400H
  00095	0f 8d a5 00 00
	00		 jge	 $Overflow$21425

; 2095 :             goto Overflow;
; 2096 :         else if (e < -1022) {

  0009b	81 fa 02 fc ff
	ff		 cmp	 edx, -1022		; fffffffffffffc02H
  000a1	7d 18		 jge	 SHORT $LN14@PyFloat_Pa@2

; 2097 :             /* Gradual underflow */
; 2098 :             f = ldexp(f, 1022 + e);

  000a3	66 0f 28 c5	 movapd	 xmm0, xmm5
  000a7	81 c2 fe 03 00
	00		 add	 edx, 1022		; 000003feH
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 2099 :             e = 0;

  000b3	33 d2		 xor	 edx, edx
  000b5	66 0f 28 e8	 movapd	 xmm5, xmm0
  000b9	eb 2a		 jmp	 SHORT $LN12@PyFloat_Pa@2
$LN14@PyFloat_Pa@2:

; 2100 :         }
; 2101 :         else if (!(e == 0 && f == 0.0)) {

  000bb	85 d2		 test	 edx, edx
  000bd	75 1c		 jne	 SHORT $LN40@PyFloat_Pa@2
  000bf	eb 12		 jmp	 SHORT $LN39@PyFloat_Pa@2
$LN20@PyFloat_Pa@2:

; 2085 :         }
; 2086 :         else if (f == 0.0)

  000c1	66 0f 2e ee	 ucomisd xmm5, xmm6
  000c5	0f 8a fb 00 00
	00		 jp	 $LN18@PyFloat_Pa@2
  000cb	0f 85 f5 00 00
	00		 jne	 $LN18@PyFloat_Pa@2

; 2087 :             e = 0;

  000d1	33 d2		 xor	 edx, edx
$LN39@PyFloat_Pa@2:

; 2100 :         }
; 2101 :         else if (!(e == 0 && f == 0.0)) {

  000d3	66 0f 2e ee	 ucomisd xmm5, xmm6
  000d7	7a 02		 jp	 SHORT $LN40@PyFloat_Pa@2
  000d9	74 0a		 je	 SHORT $LN12@PyFloat_Pa@2
$LN40@PyFloat_Pa@2:

; 2102 :             e += 1023;

  000db	81 c2 ff 03 00
	00		 add	 edx, 1023		; 000003ffH

; 2103 :             f -= 1.0; /* Get rid of leading 1 */

  000e1	f2 0f 5c e8	 subsd	 xmm5, xmm0
$LN12@PyFloat_Pa@2:

; 2104 :         }
; 2105 : 
; 2106 :         /* fhi receives the high 28 bits; flo the low 24 bits (== 52 bits) */
; 2107 :         f *= 268435456.0; /* 2**28 */

  000e5	f2 0f 59 2d 00
	00 00 00	 mulsd	 xmm5, QWORD PTR __real@41b0000000000000

; 2108 :         fhi = (unsigned int)f; /* Truncate */
; 2109 :         assert(fhi < 268435456);
; 2110 : 
; 2111 :         f -= (double)fhi;
; 2112 :         f *= 16777216.0; /* 2**24 */
; 2113 :         flo = (unsigned int)(f + 0.5); /* Round */

  000ed	66 0f ef c0	 pxor	 xmm0, xmm0
  000f1	f2 4c 0f 2c c5	 cvttsd2si r8, xmm5
  000f6	41 8b c0	 mov	 eax, r8d
  000f9	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000fe	f2 0f 5c e8	 subsd	 xmm5, xmm0
  00102	f2 0f 59 2d 00
	00 00 00	 mulsd	 xmm5, QWORD PTR __real@4170000000000000
  0010a	f2 0f 58 2d 00
	00 00 00	 addsd	 xmm5, QWORD PTR __real@3fe0000000000000
  00112	f2 4c 0f 2c cd	 cvttsd2si r9, xmm5

; 2114 :         assert(flo <= 16777216);
; 2115 :         if (flo >> 24) {

  00117	41 f7 c1 00 00
	00 ff		 test	 r9d, -16777216		; ff000000H
  0011e	74 4b		 je	 SHORT $LN8@PyFloat_Pa@2

; 2116 :             /* The carry propagated out of a string of 24 1 bits. */
; 2117 :             flo = 0;
; 2118 :             ++fhi;

  00120	41 ff c0	 inc	 r8d
  00123	45 33 c9	 xor	 r9d, r9d

; 2119 :             if (fhi >> 28) {

  00126	41 f7 c0 00 00
	00 f0		 test	 r8d, -268435456		; f0000000H
  0012d	74 3c		 je	 SHORT $LN8@PyFloat_Pa@2

; 2120 :                 /* And it also progagated out of the next 28 bits. */
; 2121 :                 fhi = 0;
; 2122 :                 ++e;

  0012f	ff c2		 inc	 edx
  00131	45 33 c0	 xor	 r8d, r8d
  00134	89 54 24 58	 mov	 DWORD PTR e$21412[rsp], edx

; 2123 :                 if (e >= 2047)

  00138	81 fa ff 07 00
	00		 cmp	 edx, 2047		; 000007ffH
  0013e	7c 2b		 jl	 SHORT $LN8@PyFloat_Pa@2
$Overflow$21425:

; 2162 : 
; 2163 :       Overflow:
; 2164 :         PyErr_SetString(PyExc_OverflowError,
; 2165 :                         "float too large to pack with d format");

  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@ILBJIJHH@float?5too?5large?5to?5pack?5with?5d?5f@
$LN43@PyFloat_Pa@2:
  0014e	e8 00 00 00 00	 call	 PyErr_SetString

; 2166 :         return -1;

  00153	83 c8 ff	 or	 eax, -1
$LN42@PyFloat_Pa@2:
  00156	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0015b	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]

; 2181 :         }
; 2182 :         return 0;
; 2183 :     }
; 2184 : }

  00160	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00165	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00169	5f		 pop	 rdi
  0016a	c3		 ret	 0
$LN8@PyFloat_Pa@2:

; 2124 :                     goto Overflow;
; 2125 :             }
; 2126 :         }
; 2127 : 
; 2128 :         /* First byte */
; 2129 :         *p = (sign << 7) | (e >> 4);
; 2130 :         p += incr;

  0016b	48 63 cf	 movsxd	 rcx, edi
  0016e	8b c2		 mov	 eax, edx
  00170	40 c0 e6 07	 shl	 sil, 7
  00174	c1 f8 04	 sar	 eax, 4

; 2131 : 
; 2132 :         /* Second byte */
; 2133 :         *p = (unsigned char) (((e & 0xF) << 4) | (fhi >> 24));

  00177	c0 e2 04	 shl	 dl, 4
  0017a	40 0a c6	 or	 al, sil
  0017d	88 03		 mov	 BYTE PTR [rbx], al
  0017f	48 03 d9	 add	 rbx, rcx
  00182	41 8b c0	 mov	 eax, r8d
  00185	c1 e8 18	 shr	 eax, 24
  00188	0a c2		 or	 al, dl
  0018a	88 03		 mov	 BYTE PTR [rbx], al

; 2134 :         p += incr;

  0018c	48 03 d9	 add	 rbx, rcx

; 2135 : 
; 2136 :         /* Third byte */
; 2137 :         *p = (fhi >> 16) & 0xFF;

  0018f	41 8b c0	 mov	 eax, r8d
  00192	c1 e8 10	 shr	 eax, 16
  00195	88 03		 mov	 BYTE PTR [rbx], al

; 2138 :         p += incr;

  00197	48 03 d9	 add	 rbx, rcx

; 2139 : 
; 2140 :         /* Fourth byte */
; 2141 :         *p = (fhi >> 8) & 0xFF;

  0019a	41 8b c0	 mov	 eax, r8d
  0019d	c1 e8 08	 shr	 eax, 8
  001a0	88 03		 mov	 BYTE PTR [rbx], al

; 2142 :         p += incr;

  001a2	48 03 d9	 add	 rbx, rcx

; 2143 : 
; 2144 :         /* Fifth byte */
; 2145 :         *p = fhi & 0xFF;
; 2146 :         p += incr;
; 2147 : 
; 2148 :         /* Sixth byte */
; 2149 :         *p = (flo >> 16) & 0xFF;

  001a5	41 8b c1	 mov	 eax, r9d
  001a8	44 88 03	 mov	 BYTE PTR [rbx], r8b
  001ab	c1 e8 10	 shr	 eax, 16
  001ae	48 03 d9	 add	 rbx, rcx
  001b1	88 03		 mov	 BYTE PTR [rbx], al

; 2150 :         p += incr;

  001b3	48 03 d9	 add	 rbx, rcx

; 2151 : 
; 2152 :         /* Seventh byte */
; 2153 :         *p = (flo >> 8) & 0xFF;

  001b6	41 8b c1	 mov	 eax, r9d
  001b9	c1 e8 08	 shr	 eax, 8
  001bc	88 03		 mov	 BYTE PTR [rbx], al

; 2154 :         p += incr;
; 2155 : 
; 2156 :         /* Eighth byte */
; 2157 :         *p = flo & 0xFF;

  001be	44 88 0c 19	 mov	 BYTE PTR [rcx+rbx], r9b

; 2158 :         /* p += incr; */
; 2159 : 
; 2160 :         /* Done */
; 2161 :         return 0;

  001c2	33 c0		 xor	 eax, eax
  001c4	eb 90		 jmp	 SHORT $LN42@PyFloat_Pa@2
$LN18@PyFloat_Pa@2:

; 2088 :         else {
; 2089 :             PyErr_SetString(PyExc_SystemError,
; 2090 :                             "frexp() result out of range");

  001c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MPOILIGE@frexp?$CI?$CJ?5result?5out?5of?5range?$AA@

; 2091 :             return -1;

  001d4	e9 75 ff ff ff	 jmp	 $LN43@PyFloat_Pa@2
$LN24@PyFloat_Pa@2:

; 2167 :     }
; 2168 :     else {
; 2169 :         const char *s = (char*)&x;
; 2170 :         int i, incr = 1;
; 2171 : 
; 2172 :         if ((double_format == ieee_little_endian_format && !le)
; 2173 :             || (double_format == ieee_big_endian_format && le)) {

  001d9	83 f8 02	 cmp	 eax, 2
  001dc	75 07		 jne	 SHORT $LN4@PyFloat_Pa@2
  001de	45 85 c0	 test	 r8d, r8d
  001e1	74 0b		 je	 SHORT $LN5@PyFloat_Pa@2
  001e3	eb 10		 jmp	 SHORT $LN6@PyFloat_Pa@2
$LN4@PyFloat_Pa@2:
  001e5	3b c7		 cmp	 eax, edi
  001e7	75 0c		 jne	 SHORT $LN6@PyFloat_Pa@2
  001e9	45 85 c0	 test	 r8d, r8d
  001ec	74 07		 je	 SHORT $LN6@PyFloat_Pa@2
$LN5@PyFloat_Pa@2:

; 2174 :             p += 7;

  001ee	48 83 c3 07	 add	 rbx, 7

; 2175 :             incr = -1;

  001f2	83 cf ff	 or	 edi, -1
$LN6@PyFloat_Pa@2:

; 2176 :         }
; 2177 : 
; 2178 :         for (i = 0; i < 8; i++) {
; 2179 :             *p = *s++;

  001f5	0f b6 44 24 40	 movzx	 eax, BYTE PTR x$[rsp]

; 2180 :             p += incr;

  001fa	48 63 cf	 movsxd	 rcx, edi
  001fd	88 03		 mov	 BYTE PTR [rbx], al
  001ff	0f b6 44 24 41	 movzx	 eax, BYTE PTR x$[rsp+1]
  00204	48 03 d9	 add	 rbx, rcx
  00207	88 03		 mov	 BYTE PTR [rbx], al
  00209	0f b6 44 24 42	 movzx	 eax, BYTE PTR x$[rsp+2]
  0020e	48 03 d9	 add	 rbx, rcx
  00211	88 03		 mov	 BYTE PTR [rbx], al
  00213	0f b6 44 24 43	 movzx	 eax, BYTE PTR x$[rsp+3]
  00218	48 03 d9	 add	 rbx, rcx
  0021b	88 03		 mov	 BYTE PTR [rbx], al
  0021d	0f b6 44 24 44	 movzx	 eax, BYTE PTR x$[rsp+4]
  00222	48 03 d9	 add	 rbx, rcx
  00225	88 03		 mov	 BYTE PTR [rbx], al
  00227	0f b6 44 24 45	 movzx	 eax, BYTE PTR x$[rsp+5]
  0022c	48 03 d9	 add	 rbx, rcx
  0022f	88 03		 mov	 BYTE PTR [rbx], al
  00231	0f b6 44 24 46	 movzx	 eax, BYTE PTR x$[rsp+6]
  00236	48 03 d9	 add	 rbx, rcx
  00239	88 03		 mov	 BYTE PTR [rbx], al
  0023b	0f b6 44 24 47	 movzx	 eax, BYTE PTR x$[rsp+7]
  00240	88 04 19	 mov	 BYTE PTR [rcx+rbx], al

; 2181 :         }
; 2182 :         return 0;
; 2183 :     }
; 2184 : }

  00243	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00248	33 c0		 xor	 eax, eax
  0024a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0024e	5f		 pop	 rdi
  0024f	c3		 ret	 0
_PyFloat_Pack8 ENDP
_TEXT	ENDS
PUBLIC	__real@3e80000000000000
PUBLIC	??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@ ; `string'
PUBLIC	_PyFloat_Unpack4
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Unpack4 DD imagerel $LN26
	DD	imagerel $LN26+21
	DD	imagerel $unwind$_PyFloat_Unpack4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyFloat_Unpack4 DD imagerel $LN26+21
	DD	imagerel $LN26+131
	DD	imagerel $chain$0$_PyFloat_Unpack4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyFloat_Unpack4 DD imagerel $LN26+131
	DD	imagerel $LN26+215
	DD	imagerel $chain$2$_PyFloat_Unpack4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyFloat_Unpack4 DD imagerel $LN26+215
	DD	imagerel $LN26+306
	DD	imagerel $chain$3$_PyFloat_Unpack4
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyFloat_Unpack4 DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+21
	DD	imagerel $unwind$_PyFloat_Unpack4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyFloat_Unpack4 DD 020021H
	DD	043400H
	DD	imagerel $LN26
	DD	imagerel $LN26+21
	DD	imagerel $unwind$_PyFloat_Unpack4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyFloat_Unpack4 DD 020521H
	DD	043405H
	DD	imagerel $LN26
	DD	imagerel $LN26+21
	DD	imagerel $unwind$_PyFloat_Unpack4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Unpack4 DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT __real@3e80000000000000
CONST	SEGMENT
__real@3e80000000000000 DQ 03e80000000000000r	; 1.19209e-007
CONST	ENDS
;	COMDAT ??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
CONST	SEGMENT
??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@ DB 'can''t unp'
	DB	'ack IEEE 754 special value on non-IEEE platform', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_Unpack4
_TEXT	SEGMENT
p$ = 48
le$ = 56
x$21471 = 64
buf$21475 = 64
_PyFloat_Unpack4 PROC					; COMDAT

; 2188 : {

$LN26:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2189 :     if (float_format == unknown_format) {

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR float_format
  0000a	4c 8b c1	 mov	 r8, rcx
  0000d	85 c0		 test	 eax, eax
  0000f	0f 85 c2 00 00
	00		 jne	 $LN14@PyFloat_Un

; 2190 :         unsigned char sign;
; 2191 :         int e;
; 2192 :         unsigned int f;
; 2193 :         double x;
; 2194 :         int incr = 1;

  00015	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001a	b8 01 00 00 00	 mov	 eax, 1

; 2195 : 
; 2196 :         if (le) {

  0001f	85 d2		 test	 edx, edx
  00021	74 07		 je	 SHORT $LN13@PyFloat_Un

; 2197 :             p += 3;

  00023	49 83 c0 03	 add	 r8, 3

; 2198 :             incr = -1;

  00027	83 c8 ff	 or	 eax, -1
$LN13@PyFloat_Un:

; 2199 :         }
; 2200 : 
; 2201 :         /* First byte */
; 2202 :         sign = (*p >> 7) & 1;

  0002a	41 0f b6 10	 movzx	 edx, BYTE PTR [r8]

; 2203 :         e = (*p & 0x7F) << 1;
; 2204 :         p += incr;

  0002e	48 63 c8	 movsxd	 rcx, eax
  00031	0f b6 da	 movzx	 ebx, dl
  00034	4c 03 c1	 add	 r8, rcx
  00037	83 e2 7f	 and	 edx, 127		; 0000007fH

; 2205 : 
; 2206 :         /* Second byte */
; 2207 :         e |= (*p >> 7) & 1;

  0003a	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]
  0003e	03 d2		 add	 edx, edx
  00040	c0 eb 07	 shr	 bl, 7
  00043	41 8b c1	 mov	 eax, r9d

; 2208 :         f = (*p & 0x7F) << 16;

  00046	41 83 e1 7f	 and	 r9d, 127		; 0000007fH

; 2209 :         p += incr;

  0004a	4c 03 c1	 add	 r8, rcx
  0004d	c1 e8 07	 shr	 eax, 7
  00050	41 c1 e1 10	 shl	 r9d, 16
  00054	0b d0		 or	 edx, eax

; 2210 : 
; 2211 :         if (e == 255) {

  00056	81 fa ff 00 00
	00		 cmp	 edx, 255		; 000000ffH
  0005c	75 25		 jne	 SHORT $LN12@PyFloat_Un

; 2212 :             PyErr_SetString(
; 2213 :                 PyExc_ValueError,
; 2214 :                 "can't unpack IEEE 754 special value "
; 2215 :                 "on non-IEEE platform");

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString

; 2216 :             return -1;

  00071	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
$LN24@PyFloat_Un:
  00079	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2261 :     }
; 2262 : }

  0007e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00082	c3		 ret	 0
$LN12@PyFloat_Un:

; 2217 :         }
; 2218 : 
; 2219 :         /* Third byte */
; 2220 :         f |= *p << 8;
; 2221 :         p += incr;
; 2222 : 
; 2223 :         /* Fourth byte */
; 2224 :         f |= *p;
; 2225 : 
; 2226 :         x = (double)f / 8388608.0;

  00083	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00087	42 0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+r8]
  0008c	66 0f ef c0	 pxor	 xmm0, xmm0
  00090	c1 e0 08	 shl	 eax, 8
  00093	0b c1		 or	 eax, ecx
  00095	41 0b c1	 or	 eax, r9d
  00098	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0009d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3e80000000000000

; 2227 : 
; 2228 :         /* XXX This sadly ignores Inf/NaN issues */
; 2229 :         if (e == 0)

  000a5	85 d2		 test	 edx, edx
  000a7	75 07		 jne	 SHORT $LN11@PyFloat_Un

; 2230 :             e = -126;

  000a9	ba 82 ff ff ff	 mov	 edx, -126		; ffffffffffffff82H

; 2231 :         else {

  000ae	eb 0b		 jmp	 SHORT $LN10@PyFloat_Un
$LN11@PyFloat_Un:

; 2232 :             x += 1.0;

  000b0	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000

; 2233 :             e -= 127;

  000b8	83 ea 7f	 sub	 edx, 127		; 0000007fH
$LN10@PyFloat_Un:

; 2234 :         }
; 2235 :         x = ldexp(x, e);

  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 2236 : 
; 2237 :         if (sign)

  000c1	84 db		 test	 bl, bl
  000c3	74 b4		 je	 SHORT $LN24@PyFloat_Un

; 2238 :             x = -x;

  000c5	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  000cd	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2261 :     }
; 2262 : }

  000d2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d6	c3		 ret	 0
$LN14@PyFloat_Un:

; 2239 : 
; 2240 :         return x;
; 2241 :     }
; 2242 :     else {
; 2243 :         float x;
; 2244 : 
; 2245 :         if ((float_format == ieee_little_endian_format && !le)
; 2246 :             || (float_format == ieee_big_endian_format && le)) {

  000d7	83 f8 02	 cmp	 eax, 2
  000da	75 18		 jne	 SHORT $LN5@PyFloat_Un
  000dc	85 d2		 test	 edx, edx
  000de	74 1d		 je	 SHORT $LN6@PyFloat_Un
$LN7@PyFloat_Un:

; 2255 :         }
; 2256 :         else {
; 2257 :             memcpy(&x, p, 4);

  000e0	8b 01		 mov	 eax, DWORD PTR [rcx]
  000e2	89 44 24 40	 mov	 DWORD PTR x$21471[rsp], eax

; 2258 :         }
; 2259 : 
; 2260 :         return x;

  000e6	66 0f 6e 44 24
	40		 movd	 xmm0, DWORD PTR x$21471[rsp]
  000ec	0f 5a c0	 cvtps2pd xmm0, xmm0

; 2261 :     }
; 2262 : }

  000ef	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f3	c3		 ret	 0
$LN5@PyFloat_Un:

; 2239 : 
; 2240 :         return x;
; 2241 :     }
; 2242 :     else {
; 2243 :         float x;
; 2244 : 
; 2245 :         if ((float_format == ieee_little_endian_format && !le)
; 2246 :             || (float_format == ieee_big_endian_format && le)) {

  000f4	83 f8 01	 cmp	 eax, 1
  000f7	75 e7		 jne	 SHORT $LN7@PyFloat_Un
  000f9	85 d2		 test	 edx, edx
  000fb	74 e3		 je	 SHORT $LN7@PyFloat_Un
$LN6@PyFloat_Un:

; 2247 :             char buf[4];
; 2248 :             char *d = &buf[3];
; 2249 :             int i;
; 2250 : 
; 2251 :             for (i = 0; i < 4; i++) {
; 2252 :                 *d-- = *p++;

  000fd	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00100	88 44 24 43	 mov	 BYTE PTR buf$21475[rsp+3], al
  00104	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00108	88 44 24 42	 mov	 BYTE PTR buf$21475[rsp+2], al
  0010c	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00110	88 44 24 41	 mov	 BYTE PTR buf$21475[rsp+1], al
  00114	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  00118	88 44 24 40	 mov	 BYTE PTR buf$21475[rsp], al

; 2253 :             }
; 2254 :             memcpy(&x, buf, 4);

  0011c	8b 44 24 40	 mov	 eax, DWORD PTR buf$21475[rsp]

; 2255 :         }
; 2256 :         else {
; 2257 :             memcpy(&x, p, 4);

  00120	89 44 24 40	 mov	 DWORD PTR x$21471[rsp], eax

; 2258 :         }
; 2259 : 
; 2260 :         return x;

  00124	66 0f 6e 44 24
	40		 movd	 xmm0, DWORD PTR x$21471[rsp]
  0012a	0f 5a c0	 cvtps2pd xmm0, xmm0

; 2261 :     }
; 2262 : }

  0012d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00131	c3		 ret	 0
_PyFloat_Unpack4 ENDP
_TEXT	ENDS
PUBLIC	__real@3e30000000000000
PUBLIC	__real@3e70000000000000
PUBLIC	_PyFloat_Unpack8
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFloat_Unpack8 DD imagerel $LN30
	DD	imagerel $LN30+21
	DD	imagerel $unwind$_PyFloat_Unpack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyFloat_Unpack8 DD imagerel $LN30+21
	DD	imagerel $LN30+137
	DD	imagerel $chain$0$_PyFloat_Unpack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyFloat_Unpack8 DD imagerel $LN30+137
	DD	imagerel $LN30+307
	DD	imagerel $chain$2$_PyFloat_Unpack8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyFloat_Unpack8 DD imagerel $LN30+307
	DD	imagerel $LN30+428
	DD	imagerel $chain$3$_PyFloat_Unpack8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyFloat_Unpack8 DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+21
	DD	imagerel $unwind$_PyFloat_Unpack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyFloat_Unpack8 DD 020021H
	DD	043400H
	DD	imagerel $LN30
	DD	imagerel $LN30+21
	DD	imagerel $unwind$_PyFloat_Unpack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyFloat_Unpack8 DD 020521H
	DD	043405H
	DD	imagerel $LN30
	DD	imagerel $LN30+21
	DD	imagerel $unwind$_PyFloat_Unpack8
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFloat_Unpack8 DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT __real@3e30000000000000
CONST	SEGMENT
__real@3e30000000000000 DQ 03e30000000000000r	; 3.72529e-009
CONST	ENDS
;	COMDAT __real@3e70000000000000
CONST	SEGMENT
__real@3e70000000000000 DQ 03e70000000000000r	; 5.96046e-008
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyFloat_Unpack8
_TEXT	SEGMENT
p$ = 48
le$ = 56
x$21502 = 64
buf$21506 = 64
_PyFloat_Unpack8 PROC					; COMDAT

; 2266 : {

$LN30:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2267 :     if (double_format == unknown_format) {

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR double_format
  0000a	4c 8b c1	 mov	 r8, rcx
  0000d	85 c0		 test	 eax, eax
  0000f	0f 85 1e 01 00
	00		 jne	 $LN14@PyFloat_Un@2

; 2268 :         unsigned char sign;
; 2269 :         int e;
; 2270 :         unsigned int fhi, flo;
; 2271 :         double x;
; 2272 :         int incr = 1;

  00015	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001a	b8 01 00 00 00	 mov	 eax, 1

; 2273 : 
; 2274 :         if (le) {

  0001f	85 d2		 test	 edx, edx
  00021	74 07		 je	 SHORT $LN13@PyFloat_Un@2

; 2275 :             p += 7;

  00023	49 83 c0 07	 add	 r8, 7

; 2276 :             incr = -1;

  00027	83 c8 ff	 or	 eax, -1
$LN13@PyFloat_Un@2:

; 2277 :         }
; 2278 : 
; 2279 :         /* First byte */
; 2280 :         sign = (*p >> 7) & 1;

  0002a	45 0f b6 08	 movzx	 r9d, BYTE PTR [r8]

; 2281 :         e = (*p & 0x7F) << 4;
; 2282 : 
; 2283 :         p += incr;

  0002e	48 63 c8	 movsxd	 rcx, eax
  00031	41 0f b6 d9	 movzx	 ebx, r9b
  00035	4c 03 c1	 add	 r8, rcx
  00038	41 83 e1 7f	 and	 r9d, 127		; 0000007fH

; 2284 : 
; 2285 :         /* Second byte */
; 2286 :         e |= (*p >> 4) & 0xF;

  0003c	45 0f b6 10	 movzx	 r10d, BYTE PTR [r8]
  00040	41 c1 e1 04	 shl	 r9d, 4
  00044	c0 eb 07	 shr	 bl, 7
  00047	41 8b c2	 mov	 eax, r10d

; 2287 :         fhi = (*p & 0xF) << 24;

  0004a	41 83 e2 0f	 and	 r10d, 15

; 2288 :         p += incr;

  0004e	4c 03 c1	 add	 r8, rcx
  00051	c1 e8 04	 shr	 eax, 4
  00054	41 c1 e2 18	 shl	 r10d, 24
  00058	44 0b c8	 or	 r9d, eax

; 2289 : 
; 2290 :         if (e == 2047) {

  0005b	41 81 f9 ff 07
	00 00		 cmp	 r9d, 2047		; 000007ffH
  00062	75 25		 jne	 SHORT $LN12@PyFloat_Un@2

; 2291 :             PyErr_SetString(
; 2292 :                 PyExc_ValueError,
; 2293 :                 "can't unpack IEEE 754 special value "
; 2294 :                 "on non-IEEE platform");

  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@IOEAIBOI@can?8t?5unpack?5IEEE?5754?5special?5va@
  00072	e8 00 00 00 00	 call	 PyErr_SetString

; 2295 :             return -1.0;

  00077	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
$LN28@PyFloat_Un@2:
  0007f	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2356 :     }
; 2357 : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
$LN12@PyFloat_Un@2:

; 2296 :         }
; 2297 : 
; 2298 :         /* Third byte */
; 2299 :         fhi |= *p << 16;

  00089	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]

; 2300 :         p += incr;

  0008d	4c 03 c1	 add	 r8, rcx

; 2301 : 
; 2302 :         /* Fourth byte */
; 2303 :         fhi |= *p  << 8;
; 2304 :         p += incr;
; 2305 : 
; 2306 :         /* Fifth byte */
; 2307 :         fhi |= *p;
; 2308 :         p += incr;
; 2309 : 
; 2310 :         /* Sixth byte */
; 2311 :         flo = *p << 16;
; 2312 :         p += incr;
; 2313 : 
; 2314 :         /* Seventh byte */
; 2315 :         flo |= *p << 8;
; 2316 :         p += incr;
; 2317 : 
; 2318 :         /* Eighth byte */
; 2319 :         flo |= *p;
; 2320 : 
; 2321 :         x = (double)fhi + (double)flo / 16777216.0; /* 2**24 */
; 2322 :         x /= 268435456.0; /* 2**28 */

  00090	66 0f ef c9	 pxor	 xmm1, xmm1
  00094	c1 e0 10	 shl	 eax, 16
  00097	66 0f ef c0	 pxor	 xmm0, xmm0
  0009b	44 0b d0	 or	 r10d, eax
  0009e	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000a2	4c 03 c1	 add	 r8, rcx
  000a5	c1 e0 08	 shl	 eax, 8
  000a8	44 0b d0	 or	 r10d, eax
  000ab	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000af	4c 03 c1	 add	 r8, rcx
  000b2	41 0f b6 10	 movzx	 edx, BYTE PTR [r8]
  000b6	44 0b d0	 or	 r10d, eax
  000b9	4c 03 c1	 add	 r8, rcx
  000bc	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000c0	42 0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+r8]
  000c5	c1 e2 10	 shl	 edx, 16
  000c8	c1 e0 08	 shl	 eax, 8
  000cb	0b c1		 or	 eax, ecx
  000cd	0b c2		 or	 eax, edx
  000cf	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000d4	41 8b c2	 mov	 eax, r10d
  000d7	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  000dc	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e70000000000000
  000e4	f2 0f 58 c8	 addsd	 xmm1, xmm0
  000e8	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e30000000000000

; 2323 : 
; 2324 :         if (e == 0)

  000f0	45 85 c9	 test	 r9d, r9d
  000f3	75 08		 jne	 SHORT $LN11@PyFloat_Un@2

; 2325 :             e = -1022;

  000f5	41 b9 02 fc ff
	ff		 mov	 r9d, -1022		; fffffffffffffc02H

; 2326 :         else {

  000fb	eb 0f		 jmp	 SHORT $LN10@PyFloat_Un@2
$LN11@PyFloat_Un@2:

; 2327 :             x += 1.0;

  000fd	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3ff0000000000000

; 2328 :             e -= 1023;

  00105	41 81 e9 ff 03
	00 00		 sub	 r9d, 1023		; 000003ffH
$LN10@PyFloat_Un@2:

; 2329 :         }
; 2330 :         x = ldexp(x, e);

  0010c	66 0f 28 c1	 movapd	 xmm0, xmm1
  00110	41 8b d1	 mov	 edx, r9d
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp

; 2331 : 
; 2332 :         if (sign)

  00119	84 db		 test	 bl, bl
  0011b	0f 84 5e ff ff
	ff		 je	 $LN28@PyFloat_Un@2

; 2333 :             x = -x;

  00121	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00129	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2356 :     }
; 2357 : }

  0012e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00132	c3		 ret	 0
$LN14@PyFloat_Un@2:

; 2334 : 
; 2335 :         return x;
; 2336 :     }
; 2337 :     else {
; 2338 :         double x;
; 2339 : 
; 2340 :         if ((double_format == ieee_little_endian_format && !le)
; 2341 :             || (double_format == ieee_big_endian_format && le)) {

  00133	83 f8 02	 cmp	 eax, 2
  00136	75 17		 jne	 SHORT $LN5@PyFloat_Un@2
  00138	85 d2		 test	 edx, edx
  0013a	74 1c		 je	 SHORT $LN6@PyFloat_Un@2
$LN7@PyFloat_Un@2:

; 2350 :         }
; 2351 :         else {
; 2352 :             memcpy(&x, p, 8);

  0013c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0013f	48 89 44 24 40	 mov	 QWORD PTR x$21502[rsp], rax

; 2353 :         }
; 2354 : 
; 2355 :         return x;

  00144	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR x$21502[rsp]

; 2356 :     }
; 2357 : }

  0014a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0014e	c3		 ret	 0
$LN5@PyFloat_Un@2:

; 2334 : 
; 2335 :         return x;
; 2336 :     }
; 2337 :     else {
; 2338 :         double x;
; 2339 : 
; 2340 :         if ((double_format == ieee_little_endian_format && !le)
; 2341 :             || (double_format == ieee_big_endian_format && le)) {

  0014f	83 f8 01	 cmp	 eax, 1
  00152	75 e8		 jne	 SHORT $LN7@PyFloat_Un@2
  00154	85 d2		 test	 edx, edx
  00156	74 e4		 je	 SHORT $LN7@PyFloat_Un@2
$LN6@PyFloat_Un@2:

; 2342 :             char buf[8];
; 2343 :             char *d = &buf[7];
; 2344 :             int i;
; 2345 : 
; 2346 :             for (i = 0; i < 8; i++) {
; 2347 :                 *d-- = *p++;

  00158	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0015b	88 44 24 47	 mov	 BYTE PTR buf$21506[rsp+7], al
  0015f	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00163	88 44 24 46	 mov	 BYTE PTR buf$21506[rsp+6], al
  00167	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0016b	88 44 24 45	 mov	 BYTE PTR buf$21506[rsp+5], al
  0016f	0f b6 41 03	 movzx	 eax, BYTE PTR [rcx+3]
  00173	88 44 24 44	 mov	 BYTE PTR buf$21506[rsp+4], al
  00177	0f b6 41 04	 movzx	 eax, BYTE PTR [rcx+4]
  0017b	88 44 24 43	 mov	 BYTE PTR buf$21506[rsp+3], al
  0017f	0f b6 41 05	 movzx	 eax, BYTE PTR [rcx+5]
  00183	88 44 24 42	 mov	 BYTE PTR buf$21506[rsp+2], al
  00187	0f b6 41 06	 movzx	 eax, BYTE PTR [rcx+6]
  0018b	88 44 24 41	 mov	 BYTE PTR buf$21506[rsp+1], al
  0018f	0f b6 41 07	 movzx	 eax, BYTE PTR [rcx+7]
  00193	88 44 24 40	 mov	 BYTE PTR buf$21506[rsp], al

; 2348 :             }
; 2349 :             memcpy(&x, buf, 8);

  00197	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$21506[rsp]

; 2350 :         }
; 2351 :         else {
; 2352 :             memcpy(&x, p, 8);

  0019c	48 89 44 24 40	 mov	 QWORD PTR x$21502[rsp], rax

; 2353 :         }
; 2354 : 
; 2355 :         return x;

  001a1	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR x$21502[rsp]

; 2356 :     }
; 2357 : }

  001a7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001ab	c3		 ret	 0
_PyFloat_Unpack8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@		; `string'
PUBLIC	__real@3cb0000000000000
PUBLIC	PyFloat_GetInfo
EXTRN	PyStructSequence_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyFloat_GetInfo DD imagerel $LN9
	DD	imagerel $LN9+295
	DD	imagerel $unwind$PyFloat_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyFloat_GetInfo DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@
CONST	SEGMENT
??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@ DB 'PyFloat_GetInfo', 00H ; `string'
CONST	ENDS
;	COMDAT __real@3cb0000000000000
CONST	SEGMENT
__real@3cb0000000000000 DQ 03cb0000000000000r	; 2.22045e-016
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyFloat_GetInfo
_TEXT	SEGMENT
PyFloat_GetInfo PROC					; COMDAT

; 79   : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 80   :     PyObject* floatinfo;
; 81   :     int pos = 0;
; 82   : 
; 83   :     floatinfo = PyStructSequence_New(&FloatInfoType);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:FloatInfoType
  0000d	e8 00 00 00 00	 call	 PyStructSequence_New
  00012	48 8b d8	 mov	 rbx, rax

; 84   :     if (floatinfo == NULL) {

  00015	48 85 c0	 test	 rax, rax

; 85   :         return NULL;

  00018	0f 84 f8 00 00
	00		 je	 $LN3@PyFloat_Ge

; 86   :     }
; 87   : 
; 88   : #define SetIntFlag(flag) \
; 89   :     PyStructSequence_SET_ITEM(floatinfo, pos++, PyLong_FromLong(flag))
; 90   : #define SetDblFlag(flag) \
; 91   :     PyStructSequence_SET_ITEM(floatinfo, pos++, PyFloat_FromDouble(flag))
; 92   : 
; 93   :     SetDblFlag(DBL_MAX);

  0001e	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@7fefffffffffffff
  00026	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 94   :     SetIntFlag(DBL_MAX_EXP);

  0002b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00030	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  00034	e8 00 00 00 00	 call	 PyLong_FromLong

; 95   :     SetIntFlag(DBL_MAX_10_EXP);

  00039	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  0003e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
  00042	e8 00 00 00 00	 call	 PyLong_FromLong

; 96   :     SetDblFlag(DBL_MIN);

  00047	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@0010000000000000
  0004f	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  00056	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 97   :     SetIntFlag(DBL_MIN_EXP);

  0005b	b9 03 fc ff ff	 mov	 ecx, -1021		; fffffffffffffc03H
  00060	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
  00067	e8 00 00 00 00	 call	 PyLong_FromLong

; 98   :     SetIntFlag(DBL_MIN_10_EXP);

  0006c	b9 cd fe ff ff	 mov	 ecx, -307		; fffffffffffffecdH
  00071	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax
  00078	e8 00 00 00 00	 call	 PyLong_FromLong

; 99   :     SetIntFlag(DBL_DIG);

  0007d	b9 0f 00 00 00	 mov	 ecx, 15
  00082	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax
  00089	e8 00 00 00 00	 call	 PyLong_FromLong

; 100  :     SetIntFlag(DBL_MANT_DIG);

  0008e	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00093	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax
  0009a	e8 00 00 00 00	 call	 PyLong_FromLong

; 101  :     SetDblFlag(DBL_EPSILON);

  0009f	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3cb0000000000000
  000a7	48 89 83 a8 00
	00 00		 mov	 QWORD PTR [rbx+168], rax
  000ae	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 102  :     SetIntFlag(FLT_RADIX);

  000b3	b9 02 00 00 00	 mov	 ecx, 2
  000b8	48 89 83 b0 00
	00 00		 mov	 QWORD PTR [rbx+176], rax
  000bf	e8 00 00 00 00	 call	 PyLong_FromLong

; 103  :     SetIntFlag(FLT_ROUNDS);

  000c4	b9 01 00 00 00	 mov	 ecx, 1
  000c9	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
  000d0	e8 00 00 00 00	 call	 PyLong_FromLong
  000d5	48 89 83 c0 00
	00 00		 mov	 QWORD PTR [rbx+192], rax

; 104  : #undef SetIntFlag
; 105  : #undef SetDblFlag
; 106  : 
; 107  :     if (PyErr_Occurred()) {

  000dc	e8 00 00 00 00	 call	 PyErr_Occurred
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 38		 je	 SHORT $LN5@PyFloat_Ge

; 108  :         Py_CLEAR(floatinfo);

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BGCHDLFF@?4?4?2Objects?2floatobject?4c?$AA@
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@FFJEOCLI@PyFloat_GetInfo?$AA@
  000f4	4c 8b cb	 mov	 r9, rbx
  000f7	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  000fd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00105	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010a	85 c0		 test	 eax, eax
  0010c	75 08		 jne	 SHORT $LN3@PyFloat_Ge
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyFloat_Ge:

; 109  :         return NULL;

  00116	33 c0		 xor	 eax, eax

; 112  : }

  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	5b		 pop	 rbx
  0011d	c3		 ret	 0
$LN5@PyFloat_Ge:

; 110  :     }
; 111  :     return floatinfo;

  0011e	48 8b c3	 mov	 rax, rbx

; 112  : }

  00121	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00125	5b		 pop	 rbx
  00126	c3		 ret	 0
PyFloat_GetInfo ENDP
_TEXT	ENDS
END
