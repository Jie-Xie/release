; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@NFBFFIOL@memoryview?$AA@		; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_04HJDBPPOC@cast?$AA@			; `string'
PUBLIC	??_C@_06IEBOCBAI@tolist?$AA@			; `string'
PUBLIC	??_C@_07NAJELLCK@tobytes?$AA@			; `string'
PUBLIC	??_C@_07EOGFDLKI@release?$AA@			; `string'
PUBLIC	??_C@_0L@MOJJBKDL@contiguous?$AA@		; `string'
PUBLIC	??_C@_0N@EKJDCNKL@f_contiguous?$AA@		; `string'
PUBLIC	??_C@_0N@FHLMJOLI@c_contiguous?$AA@		; `string'
PUBLIC	??_C@_0L@ELCNMNAH@suboffsets?$AA@		; `string'
PUBLIC	??_C@_07IMKHLIIB@strides?$AA@			; `string'
PUBLIC	??_C@_04DMMOEENP@ndim?$AA@			; `string'
PUBLIC	??_C@_08BFHIGMPA@itemsize?$AA@			; `string'
PUBLIC	??_C@_08JOKHDEJH@readonly?$AA@			; `string'
PUBLIC	??_C@_06KGLHCPOD@nbytes?$AA@			; `string'
PUBLIC	??_C@_03GJLPFLNF@obj?$AA@			; `string'
PUBLIC	??_C@_05KFCIHKGL@shape?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_06IEOJBDIK@object?$AA@			; `string'
PUBLIC	??_C@_0O@PLLNAAOP@managedbuffer?$AA@		; `string'
PUBLIC	_PyManagedBuffer_Type
PUBLIC	PyMemoryView_Type
EXTRN	PyObject_GenericGetAttr:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT ??_C@_0L@NFBFFIOL@memoryview?$AA@
CONST	SEGMENT
??_C@_0L@NFBFFIOL@memoryview?$AA@ DB 'memoryview', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HJDBPPOC@cast?$AA@
CONST	SEGMENT
??_C@_04HJDBPPOC@cast?$AA@ DB 'cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEBOCBAI@tolist?$AA@
CONST	SEGMENT
??_C@_06IEBOCBAI@tolist?$AA@ DB 'tolist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJELLCK@tobytes?$AA@
CONST	SEGMENT
??_C@_07NAJELLCK@tobytes?$AA@ DB 'tobytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGFDLKI@release?$AA@
CONST	SEGMENT
??_C@_07EOGFDLKI@release?$AA@ DB 'release', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MOJJBKDL@contiguous?$AA@
CONST	SEGMENT
??_C@_0L@MOJJBKDL@contiguous?$AA@ DB 'contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKJDCNKL@f_contiguous?$AA@
CONST	SEGMENT
??_C@_0N@EKJDCNKL@f_contiguous?$AA@ DB 'f_contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHLMJOLI@c_contiguous?$AA@
CONST	SEGMENT
??_C@_0N@FHLMJOLI@c_contiguous?$AA@ DB 'c_contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ELCNMNAH@suboffsets?$AA@
CONST	SEGMENT
??_C@_0L@ELCNMNAH@suboffsets?$AA@ DB 'suboffsets', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IMKHLIIB@strides?$AA@
CONST	SEGMENT
??_C@_07IMKHLIIB@strides?$AA@ DB 'strides', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DMMOEENP@ndim?$AA@
CONST	SEGMENT
??_C@_04DMMOEENP@ndim?$AA@ DB 'ndim', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFHIGMPA@itemsize?$AA@
CONST	SEGMENT
??_C@_08BFHIGMPA@itemsize?$AA@ DB 'itemsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JOKHDEJH@readonly?$AA@
CONST	SEGMENT
??_C@_08JOKHDEJH@readonly?$AA@ DB 'readonly', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KGLHCPOD@nbytes?$AA@
CONST	SEGMENT
??_C@_06KGLHCPOD@nbytes?$AA@ DB 'nbytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GJLPFLNF@obj?$AA@
CONST	SEGMENT
??_C@_03GJLPFLNF@obj?$AA@ DB 'obj', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCIHKGL@shape?$AA@
CONST	SEGMENT
??_C@_05KFCIHKGL@shape?$AA@ DB 'shape', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEOJBDIK@object?$AA@
CONST	SEGMENT
??_C@_06IEOJBDIK@object?$AA@ DB 'object', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_PyManagedBuffer_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@PLLNAAOP@managedbuffer?$AA@
	DQ	00000000000000c0H
	DQ	0000000000000000H
	DQ	FLAT:mbuf_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:mbuf_traverse
	DQ	FLAT:mbuf_clear
	ORG $+192
memory_doc DB	'memoryview(object)', 0aH, 0aH, 'Create a new memoryview '
	DB	'object which references the given object.', 00H
	ORG $+2
?kwlist@?1??memory_new@@9@9 DQ FLAT:??_C@_06IEOJBDIK@object?$AA@ ; `memory_new'::`2'::kwlist
	DQ	0000000000000000H
?kwlist@?1??memory_cast@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `memory_cast'::`2'::kwlist
	DQ	FLAT:??_C@_05KFCIHKGL@shape?$AA@
	DQ	0000000000000000H
memory_as_buffer DQ FLAT:memory_getbuf
	DQ	FLAT:memory_releasebuf
memory_as_mapping DQ FLAT:memory_length
	DQ	FLAT:memory_subscript
	DQ	FLAT:memory_ass_sub
	ORG $+8
memory_as_sequence DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_item
	ORG $+48
memory_obj_doc DB 'The underlying object of the memoryview.', 00H
	ORG $+7
memory_nbytes_doc DB 'The amount of space in bytes that the array would u'
	DB	'se in', 0aH, ' a contiguous representation.', 00H
	ORG $+1
memory_readonly_doc DB 'A bool indicating whether the memory is read only'
	DB	'.', 00H
	ORG $+5
memory_itemsize_doc DB 'The size in bytes of each element of the memoryvi'
	DB	'ew.', 00H
	ORG $+11
memory_format_doc DB 'A string containing the format (in struct module st'
	DB	'yle)', 0aH, ' for each element in the view.', 00H
	ORG $+9
memory_ndim_doc DB 'An integer indicating how many dimensions of a multi-'
	DB	'dimensional', 0aH, ' array the memory represents.', 00H
	ORG $+1
memory_shape_doc DB 'A tuple of ndim integers giving the shape of the mem'
	DB	'ory', 0aH, ' as an N-dimensional array.', 00H
	ORG $+12
memory_strides_doc DB 'A tuple of ndim integers giving the size in bytes '
	DB	'to access', 0aH, ' each element for each dimension of the arr'
	DB	'ay.', 00H
	ORG $+5
memory_suboffsets_doc DB 'A tuple of integers used internally for PIL-sty'
	DB	'le arrays.', 00H
	ORG $+6
memory_c_contiguous_doc DB 'A bool indicating whether the memory is C con'
	DB	'tiguous.', 00H
	ORG $+2
memory_f_contiguous_doc DB 'A bool indicating whether the memory is Fortr'
	DB	'an contiguous.', 00H
	ORG $+4
memory_contiguous_doc DB 'A bool indicating whether the memory is contigu'
	DB	'ous.', 00H
	ORG $+4
memory_getsetlist DQ FLAT:??_C@_03GJLPFLNF@obj?$AA@
	DQ	FLAT:memory_obj_get
	DQ	0000000000000000H
	DQ	FLAT:memory_obj_doc
	ORG $+8
	DQ	FLAT:??_C@_06KGLHCPOD@nbytes?$AA@
	DQ	FLAT:memory_nbytes_get
	DQ	0000000000000000H
	DQ	FLAT:memory_nbytes_doc
	ORG $+8
	DQ	FLAT:??_C@_08JOKHDEJH@readonly?$AA@
	DQ	FLAT:memory_readonly_get
	DQ	0000000000000000H
	DQ	FLAT:memory_readonly_doc
	ORG $+8
	DQ	FLAT:??_C@_08BFHIGMPA@itemsize?$AA@
	DQ	FLAT:memory_itemsize_get
	DQ	0000000000000000H
	DQ	FLAT:memory_itemsize_doc
	ORG $+8
	DQ	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DQ	FLAT:memory_format_get
	DQ	0000000000000000H
	DQ	FLAT:memory_format_doc
	ORG $+8
	DQ	FLAT:??_C@_04DMMOEENP@ndim?$AA@
	DQ	FLAT:memory_ndim_get
	DQ	0000000000000000H
	DQ	FLAT:memory_ndim_doc
	ORG $+8
	DQ	FLAT:??_C@_05KFCIHKGL@shape?$AA@
	DQ	FLAT:memory_shape_get
	DQ	0000000000000000H
	DQ	FLAT:memory_shape_doc
	ORG $+8
	DQ	FLAT:??_C@_07IMKHLIIB@strides?$AA@
	DQ	FLAT:memory_strides_get
	DQ	0000000000000000H
	DQ	FLAT:memory_strides_doc
	ORG $+8
	DQ	FLAT:??_C@_0L@ELCNMNAH@suboffsets?$AA@
	DQ	FLAT:memory_suboffsets_get
	DQ	0000000000000000H
	DQ	FLAT:memory_suboffsets_doc
	ORG $+8
	DQ	FLAT:??_C@_0N@FHLMJOLI@c_contiguous?$AA@
	DQ	FLAT:memory_c_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_c_contiguous_doc
	ORG $+8
	DQ	FLAT:??_C@_0N@EKJDCNKL@f_contiguous?$AA@
	DQ	FLAT:memory_f_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_f_contiguous_doc
	ORG $+8
	DQ	FLAT:??_C@_0L@MOJJBKDL@contiguous?$AA@
	DQ	FLAT:memory_contiguous
	DQ	0000000000000000H
	DQ	FLAT:memory_contiguous_doc
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	ORG $+8
memory_release_doc DB 'M.release() -> None', 0aH, 0aH, 'Release the under'
	DB	'lying buffer exposed by the memoryview object.', 00H
	ORG $+11
memory_tobytes_doc DB 'M.tobytes() -> bytes', 0aH, 0aH, 'Return the data '
	DB	'in the buffer as a byte string.', 00H
	ORG $+10
memory_tolist_doc DB 'M.tolist() -> list', 0aH, 0aH, 'Return the data in '
	DB	'the buffer as a list of elements.', 00H
	ORG $+7
memory_cast_doc DB 'M.cast(format[, shape]) -> memoryview', 0aH, 0aH, 'Ca'
	DB	'st a memoryview to a new format or shape.', 00H
	ORG $+13
memory_methods DQ FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:memory_release
	DD	04H
	ORG $+4
	DQ	FLAT:memory_release_doc
	DQ	FLAT:??_C@_07NAJELLCK@tobytes?$AA@
	DQ	FLAT:memory_tobytes
	DD	04H
	ORG $+4
	DQ	FLAT:memory_tobytes_doc
	DQ	FLAT:??_C@_06IEBOCBAI@tolist?$AA@
	DQ	FLAT:memory_tolist
	DD	04H
	ORG $+4
	DQ	FLAT:memory_tolist_doc
	DQ	FLAT:??_C@_04HJDBPPOC@cast?$AA@
	DQ	FLAT:memory_cast
	DD	03H
	ORG $+4
	DQ	FLAT:memory_cast_doc
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:memory_enter
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:memory_exit
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyMemoryView_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	FLAT:PyType_Type
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@NFBFFIOL@memoryview?$AA@
	DQ	00000000000000f0H
	DQ	0000000000000008H
	DQ	FLAT:memory_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_repr
	DQ	0000000000000000H
	DQ	FLAT:memory_as_sequence
	DQ	FLAT:memory_as_mapping
	DQ	FLAT:memory_hash
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:memory_as_buffer
	DD	044000H
	ORG $+4
	DQ	FLAT:memory_doc
	DQ	FLAT:memory_traverse
	DQ	FLAT:memory_clear
	DQ	FLAT:memory_richcompare
	DQ	00000000000000e8H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_methods
	DQ	0000000000000000H
	DQ	FLAT:memory_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:memory_new
	ORG $+72
_DATA	ENDS
;	COMDAT ??_C@_0O@PLLNAAOP@managedbuffer?$AA@
CONST	SEGMENT
??_C@_0O@PLLNAAOP@managedbuffer?$AA@ DB 'managedbuffer', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ ; `string'
PUBLIC	??_C@_0L@EAMGENOI@mbuf_alloc?$AA@		; `string'
PUBLIC	??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@ ; `string'
EXTRN	_PyGC_generation0:QWORD
EXTRN	Py_FatalError:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\memoryobject.c
pdata	SEGMENT
$pdata$mbuf_alloc DD imagerel mbuf_alloc
	DD	imagerel mbuf_alloc+226
	DD	imagerel $unwind$mbuf_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_alloc DD 043501H
	DD	087435H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
CONST	SEGMENT
??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@ DB 'GC object alread'
	DB	'y tracked', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
CONST	SEGMENT
??_C@_0L@EAMGENOI@mbuf_alloc?$AA@ DB 'mbuf_alloc', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
CONST	SEGMENT
??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@ DB '..\Objects\mem'
	DB	'oryobject.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mbuf_alloc
_TEXT	SEGMENT
mbuf_alloc PROC						; COMDAT

; 64   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 65   :     _PyManagedBufferObject *mbuf;
; 66   : 
; 67   :     mbuf = (_PyManagedBufferObject *)
; 68   :         PyObject_GC_New(_PyManagedBufferObject, &_PyManagedBuffer_Type);

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyManagedBuffer_Type
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN9@mbuf_alloc
  00016	e8 00 00 00 00	 call	 _PxObject_New
  0001b	eb 05		 jmp	 SHORT $LN13@mbuf_alloc
$LN9@mbuf_alloc:
  0001d	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN13@mbuf_alloc:
  00022	48 8b d8	 mov	 rbx, rax

; 69   :     if (mbuf == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 06		 jne	 SHORT $LN6@mbuf_alloc

; 77   : }

  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
$LN6@mbuf_alloc:
  00030	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 70   :         return NULL;
; 71   :     mbuf->flags = 0;

  00035	33 ff		 xor	 edi, edi

; 72   :     mbuf->exports = 0;
; 73   :     mbuf->master.obj = NULL;
; 74   :     _PyObject_GC_TRACK(mbuf);

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
  00045	44 8d 47 4a	 lea	 r8d, QWORD PTR [rdi+74]
  00049	4c 8b cb	 mov	 r9, rbx
  0004c	89 7b 60	 mov	 DWORD PTR [rbx+96], edi
  0004f	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
  00053	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
  00057	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00064	85 c0		 test	 eax, eax
  00066	75 6c		 jne	 SHORT $LN2@mbuf_alloc
  00068	44 8d 47 4a	 lea	 r8d, QWORD PTR [rdi+74]
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EAMGENOI@mbuf_alloc?$AA@
  0007a	4c 8b cb	 mov	 r9, rbx
  0007d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00085	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN12@mbuf_alloc
  0008e	48 8d 7b e8	 lea	 rdi, QWORD PTR [rbx-24]
$LN12@mbuf_alloc:
  00092	48 83 7f 10 fe	 cmp	 QWORD PTR [rdi+16], -2
  00097	74 0c		 je	 SHORT $LN1@mbuf_alloc
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  000a0	e8 00 00 00 00	 call	 Py_FatalError
$LN1@mbuf_alloc:
  000a5	48 c7 47 10 fd
	ff ff ff	 mov	 QWORD PTR [rdi+16], -3
  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  000b4	48 89 07	 mov	 QWORD PTR [rdi], rax
  000b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  000be	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c2	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  000c6	48 89 39	 mov	 QWORD PTR [rcx], rdi
  000c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  000d0	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
$LN2@mbuf_alloc:

; 75   : 
; 76   :     return mbuf;

  000d4	48 8b c3	 mov	 rax, rbx
  000d7	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 77   : }

  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5b		 pop	 rbx
  000e1	c3		 ret	 0
mbuf_alloc ENDP
_TEXT	ENDS
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyManagedBuffer_FromObject DD imagerel _PyManagedBuffer_FromObject
	DD	imagerel _PyManagedBuffer_FromObject+91
	DD	imagerel $unwind$_PyManagedBuffer_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyManagedBuffer_FromObject DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyManagedBuffer_FromObject
_TEXT	SEGMENT
base$ = 48
_PyManagedBuffer_FromObject PROC			; COMDAT

; 81   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 82   :     _PyManagedBufferObject *mbuf;
; 83   : 
; 84   :     mbuf = mbuf_alloc();

  0000d	e8 00 00 00 00	 call	 mbuf_alloc
  00012	48 8b d8	 mov	 rbx, rax

; 85   :     if (mbuf == NULL)

  00015	48 85 c0	 test	 rax, rax

; 86   :         return NULL;

  00018	74 26		 je	 SHORT $LN5@PyManagedB

; 87   : 
; 88   :     if (PyObject_GetBuffer(base, &mbuf->master, PyBUF_FULL_RO) < 0) {

  0001a	48 8d 50 70	 lea	 rdx, QWORD PTR [rax+112]
  0001e	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  00024	48 8b cf	 mov	 rcx, rdi
  00027	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0002c	85 c0		 test	 eax, eax
  0002e	79 1d		 jns	 SHORT $LN1@PyManagedB

; 89   :         mbuf->master.obj = NULL;
; 90   :         Py_DECREF(mbuf);

  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 c7 43 78 00
	00 00 00	 mov	 QWORD PTR [rbx+120], 0
  0003b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyManagedB:

; 91   :         return NULL;

  00040	33 c0		 xor	 eax, eax

; 95   : }

  00042	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN1@PyManagedB:

; 92   :     }
; 93   : 
; 94   :     return (PyObject *)mbuf;

  0004d	48 8b c3	 mov	 rax, rbx

; 95   : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
_PyManagedBuffer_FromObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FHOCOONF@mbuf_release?$AA@		; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_release DD imagerel mbuf_release
	DD	imagerel mbuf_release+163
	DD	imagerel $unwind$mbuf_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_release DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0N@FHOCOONF@mbuf_release?$AA@
CONST	SEGMENT
??_C@_0N@FHOCOONF@mbuf_release?$AA@ DB 'mbuf_release', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mbuf_release
_TEXT	SEGMENT
self$ = 64
mbuf_release PROC					; COMDAT

; 99   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 100  :     if (self->flags&_Py_MANAGED_BUFFER_RELEASED)

  00006	8b 41 60	 mov	 eax, DWORD PTR [rcx+96]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	a8 01		 test	 al, 1
  0000e	0f 85 89 00 00
	00		 jne	 $LN6@mbuf_relea

; 101  :         return;
; 102  : 
; 103  :     /* NOTE: at this point self->exports can still be > 0 if this function
; 104  :        is called from mbuf_clear() to break up a reference cycle. */
; 105  :     self->flags |= _Py_MANAGED_BUFFER_RELEASED;

  00014	83 c8 01	 or	 eax, 1

; 106  : 
; 107  :     /* PyBuffer_Release() decrements master->obj and sets it to NULL. */
; 108  :     _PyObject_GC_UNTRACK(self);

  00017	4c 8b c9	 mov	 r9, rcx
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00021	89 41 60	 mov	 DWORD PTR [rcx+96], eax
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHOCOONF@mbuf_release?$AA@
  0002b	41 b8 6c 00 00
	00		 mov	 r8d, 108		; 0000006cH
  00031	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00039	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003e	85 c0		 test	 eax, eax
  00040	75 52		 jne	 SHORT $LN1@mbuf_relea
  00042	44 8d 40 6c	 lea	 r8d, QWORD PTR [rax+108]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FHOCOONF@mbuf_release?$AA@
  00054	4c 8b cb	 mov	 r9, rbx
  00057	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00064	85 c0		 test	 eax, eax
  00066	74 04		 je	 SHORT $LN8@mbuf_relea
  00068	33 d2		 xor	 edx, edx
  0006a	eb 04		 jmp	 SHORT $LN9@mbuf_relea
$LN8@mbuf_relea:
  0006c	48 8d 53 e8	 lea	 rdx, QWORD PTR [rbx-24]
$LN9@mbuf_relea:
  00070	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00073	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00077	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  0007f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00082	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00085	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00089	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0008d	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN1@mbuf_relea:

; 109  :     PyBuffer_Release(&self->master);

  00094	48 8d 4b 70	 lea	 rcx, QWORD PTR [rbx+112]
  00098	e8 00 00 00 00	 call	 PyBuffer_Release
$LN6@mbuf_relea:

; 110  : }

  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
mbuf_release ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_dealloc DD imagerel mbuf_dealloc
	DD	imagerel mbuf_dealloc+45
	DD	imagerel $unwind$mbuf_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT mbuf_dealloc
_TEXT	SEGMENT
self$ = 48
mbuf_dealloc PROC					; COMDAT

; 114  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 115  :     assert(self->exports == 0);
; 116  :     mbuf_release(self);

  00009	e8 00 00 00 00	 call	 mbuf_release

; 117  :     if (self->flags&_Py_MANAGED_BUFFER_FREE_FORMAT)

  0000e	f6 43 60 02	 test	 BYTE PTR [rbx+96], 2
  00012	74 0c		 je	 SHORT $LN1@mbuf_deall

; 118  :         PyMem_Free(self->master.format);

  00014	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  0001b	e8 00 00 00 00	 call	 PyMem_Free
$LN1@mbuf_deall:

; 119  :     PyObject_GC_Del(self);

  00020	48 8b cb	 mov	 rcx, rbx

; 120  : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	e9 00 00 00 00	 jmp	 PyObject_GC_Del
mbuf_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@FKACBFHN@mbuf_traverse?$AA@		; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_traverse DD imagerel mbuf_traverse
	DD	imagerel mbuf_traverse+95
	DD	imagerel $unwind$mbuf_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0O@FKACBFHN@mbuf_traverse?$AA@
CONST	SEGMENT
??_C@_0O@FKACBFHN@mbuf_traverse?$AA@ DB 'mbuf_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mbuf_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
mbuf_traverse PROC					; COMDAT

; 124  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 125  :     Py_VISIT(self->master.obj);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1a		 je	 SHORT $LN3@mbuf_trave
  00021	45 33 c9	 xor	 r9d, r9d
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@FKACBFHN@mbuf_traverse?$AA@
  00032	45 8d 41 7d	 lea	 r8d, QWORD PTR [r9+125]
  00036	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@mbuf_trave:
  0003b	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0003f	48 85 c9	 test	 rcx, rcx
  00042	74 09		 je	 SHORT $LN5@mbuf_trave
  00044	48 8b d7	 mov	 rdx, rdi
  00047	ff d6		 call	 rsi
  00049	85 c0		 test	 eax, eax
  0004b	75 02		 jne	 SHORT $LN7@mbuf_trave
$LN5@mbuf_trave:

; 126  :     return 0;

  0004d	33 c0		 xor	 eax, eax
$LN7@mbuf_trave:

; 127  : }

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
mbuf_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_clear DD imagerel mbuf_clear
	DD	imagerel mbuf_clear+16
	DD	imagerel $unwind$mbuf_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_clear DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT mbuf_clear
_TEXT	SEGMENT
self$ = 48
mbuf_clear PROC						; COMDAT

; 131  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 132  :     assert(self->exports >= 0);
; 133  :     mbuf_release(self);

  00004	e8 00 00 00 00	 call	 mbuf_release

; 134  :     return 0;

  00009	33 c0		 xor	 eax, eax

; 135  : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
mbuf_clear ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT last_dim_is_contiguous
_TEXT	SEGMENT
dest$ = 8
src$ = 16
last_dim_is_contiguous PROC				; COMDAT

; 250  : {

  00000	4c 8b c1	 mov	 r8, rcx

; 251  :     assert(dest->ndim > 0 && src->ndim > 0);
; 252  :     return (!HAVE_SUBOFFSETS_IN_LAST_DIM(dest) &&
; 253  :             !HAVE_SUBOFFSETS_IN_LAST_DIM(src) &&
; 254  :             dest->strides[dest->ndim-1] == dest->itemsize &&
; 255  :             src->strides[src->ndim-1] == src->itemsize);

  00003	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00007	4c 8b ca	 mov	 r9, rdx
  0000a	48 85 c9	 test	 rcx, rcx
  0000d	74 0c		 je	 SHORT $LN3@last_dim_i
  0000f	49 63 40 24	 movsxd	 rax, DWORD PTR [r8+36]
  00013	48 83 7c c1 f8
	00		 cmp	 QWORD PTR [rcx+rax*8-8], 0
  00019	7d 41		 jge	 SHORT $LN5@last_dim_i
$LN3@last_dim_i:
  0001b	48 8b 4a 40	 mov	 rcx, QWORD PTR [rdx+64]
  0001f	48 85 c9	 test	 rcx, rcx
  00022	74 0c		 je	 SHORT $LN4@last_dim_i
  00024	49 63 40 24	 movsxd	 rax, DWORD PTR [r8+36]
  00028	48 83 7c c1 f8
	00		 cmp	 QWORD PTR [rcx+rax*8-8], 0
  0002e	7d 2c		 jge	 SHORT $LN5@last_dim_i
$LN4@last_dim_i:
  00030	49 63 50 24	 movsxd	 rdx, DWORD PTR [r8+36]
  00034	49 8b 48 38	 mov	 rcx, QWORD PTR [r8+56]
  00038	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  0003c	48 39 44 d1 f8	 cmp	 QWORD PTR [rcx+rdx*8-8], rax
  00041	75 19		 jne	 SHORT $LN5@last_dim_i
  00043	49 63 51 24	 movsxd	 rdx, DWORD PTR [r9+36]
  00047	49 8b 49 38	 mov	 rcx, QWORD PTR [r9+56]
  0004b	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0004f	48 39 44 d1 f8	 cmp	 QWORD PTR [rcx+rdx*8-8], rax
  00054	75 06		 jne	 SHORT $LN5@last_dim_i
  00056	b8 01 00 00 00	 mov	 eax, 1

; 256  : }

  0005b	c3		 ret	 0
$LN5@last_dim_i:

; 251  :     assert(dest->ndim > 0 && src->ndim > 0);
; 252  :     return (!HAVE_SUBOFFSETS_IN_LAST_DIM(dest) &&
; 253  :             !HAVE_SUBOFFSETS_IN_LAST_DIM(src) &&
; 254  :             dest->strides[dest->ndim-1] == dest->itemsize &&
; 255  :             src->strides[src->ndim-1] == src->itemsize);

  0005c	33 c0		 xor	 eax, eax

; 256  : }

  0005e	c3		 ret	 0
last_dim_is_contiguous ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT equiv_format
_TEXT	SEGMENT
dest$ = 8
src$ = 16
equiv_format PROC					; COMDAT

; 267  :     const char *dfmt, *sfmt;
; 268  : 
; 269  :     assert(dest->format && src->format);
; 270  :     dfmt = dest->format[0] == '@' ? dest->format+1 : dest->format;

  00000	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00004	4c 8b ca	 mov	 r9, rdx
  00007	4c 8b d1	 mov	 r10, rcx
  0000a	80 38 40	 cmp	 BYTE PTR [rax], 64	; 00000040H
  0000d	75 03		 jne	 SHORT $LN6@equiv_form
  0000f	48 ff c0	 inc	 rax
$LN6@equiv_form:

; 271  :     sfmt = src->format[0] == '@' ? src->format+1 : src->format;

  00012	4c 8b 42 28	 mov	 r8, QWORD PTR [rdx+40]
  00016	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0001a	75 03		 jne	 SHORT $LN8@equiv_form
  0001c	49 ff c0	 inc	 r8
$LN8@equiv_form:

; 272  : 
; 273  :     if (strcmp(dfmt, sfmt) != 0 ||
; 274  :         dest->itemsize != src->itemsize) {

  0001f	4c 2b c0	 sub	 r8, rax
$LL9@equiv_form:
  00022	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00025	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  0002a	2b d1		 sub	 edx, ecx
  0002c	75 07		 jne	 SHORT $LN10@equiv_form
  0002e	48 ff c0	 inc	 rax
  00031	85 c9		 test	 ecx, ecx
  00033	75 ed		 jne	 SHORT $LL9@equiv_form
$LN10@equiv_form:
  00035	85 d2		 test	 edx, edx
  00037	75 10		 jne	 SHORT $LN1@equiv_form
  00039	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0003d	49 39 42 18	 cmp	 QWORD PTR [r10+24], rax
  00041	75 06		 jne	 SHORT $LN1@equiv_form

; 276  :     }
; 277  : 
; 278  :     return 1;

  00043	b8 01 00 00 00	 mov	 eax, 1

; 279  : }

  00048	c3		 ret	 0
$LN1@equiv_form:

; 275  :         return 0;

  00049	33 c0		 xor	 eax, eax

; 279  : }

  0004b	c3		 ret	 0
equiv_format ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT equiv_shape
_TEXT	SEGMENT
dest$ = 8
src$ = 16
equiv_shape PROC					; COMDAT

; 287  :     int i;
; 288  : 
; 289  :     if (dest->ndim != src->ndim)

  00000	44 8b 41 24	 mov	 r8d, DWORD PTR [rcx+36]
  00004	48 8b c1	 mov	 rax, rcx
  00007	44 3b 42 24	 cmp	 r8d, DWORD PTR [rdx+36]
  0000b	74 03		 je	 SHORT $LN6@equiv_shap
$LN10@equiv_shap:

; 290  :         return 0;

  0000d	33 c0		 xor	 eax, eax

; 300  : }

  0000f	c3		 ret	 0
$LN6@equiv_shap:

; 291  : 
; 292  :     for (i = 0; i < dest->ndim; i++) {

  00010	33 c9		 xor	 ecx, ecx
  00012	45 85 c0	 test	 r8d, r8d
  00015	7e 24		 jle	 SHORT $LN11@equiv_shap
  00017	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0001b	4c 8b 4a 30	 mov	 r9, QWORD PTR [rdx+48]
  0001f	4c 2b c8	 sub	 r9, rax
$LL5@equiv_shap:

; 293  :         if (dest->shape[i] != src->shape[i])

  00022	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00025	49 3b 14 01	 cmp	 rdx, QWORD PTR [r9+rax]
  00029	75 e2		 jne	 SHORT $LN10@equiv_shap

; 294  :             return 0;
; 295  :         if (dest->shape[i] == 0)

  0002b	48 85 d2	 test	 rdx, rdx
  0002e	74 0b		 je	 SHORT $LN11@equiv_shap

; 291  : 
; 292  :     for (i = 0; i < dest->ndim; i++) {

  00030	ff c1		 inc	 ecx
  00032	48 83 c0 08	 add	 rax, 8
  00036	41 3b c8	 cmp	 ecx, r8d
  00039	7c e7		 jl	 SHORT $LL5@equiv_shap
$LN11@equiv_shap:

; 296  :             break;
; 297  :     }
; 298  : 
; 299  :     return 1;

  0003b	b8 01 00 00 00	 mov	 eax, 1

; 300  : }

  00040	c3		 ret	 0
equiv_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$equiv_structure DD imagerel equiv_structure
	DD	imagerel equiv_structure+173
	DD	imagerel $unwind$equiv_structure
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$equiv_structure DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@
CONST	SEGMENT
??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@ DB 'memoryview a'
	DB	'ssignment: lvalue and rvalue have different structures', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT equiv_structure
_TEXT	SEGMENT
dest$ = 48
src$ = 56
equiv_structure PROC					; COMDAT

; 306  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 307  :     if (!equiv_format(dest, src) ||
; 308  :         !equiv_shape(dest, src)) {

  00004	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00008	4c 8b ca	 mov	 r9, rdx
  0000b	4c 8b d1	 mov	 r10, rcx
  0000e	80 38 40	 cmp	 BYTE PTR [rax], 64	; 00000040H
  00011	75 03		 jne	 SHORT $LN10@equiv_stru
  00013	48 ff c0	 inc	 rax
$LN10@equiv_stru:
  00016	4c 8b 42 28	 mov	 r8, QWORD PTR [rdx+40]
  0001a	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0001e	75 03		 jne	 SHORT $LN12@equiv_stru
  00020	49 ff c0	 inc	 r8
$LN12@equiv_stru:
  00023	4c 2b c0	 sub	 r8, rax
  00026	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL27@equiv_stru:
  00030	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00033	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  00038	2b d1		 sub	 edx, ecx
  0003a	75 07		 jne	 SHORT $LN28@equiv_stru
  0003c	48 ff c0	 inc	 rax
  0003f	85 c9		 test	 ecx, ecx
  00041	75 ed		 jne	 SHORT $LL27@equiv_stru
$LN28@equiv_stru:
  00043	85 d2		 test	 edx, edx
  00045	75 4c		 jne	 SHORT $LN1@equiv_stru
  00047	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  0004b	49 39 42 18	 cmp	 QWORD PTR [r10+24], rax
  0004f	75 42		 jne	 SHORT $LN1@equiv_stru
  00051	45 8b 42 24	 mov	 r8d, DWORD PTR [r10+36]
  00055	45 3b 41 24	 cmp	 r8d, DWORD PTR [r9+36]
  00059	75 38		 jne	 SHORT $LN1@equiv_stru
  0005b	33 c9		 xor	 ecx, ecx
  0005d	45 85 c0	 test	 r8d, r8d
  00060	7e 27		 jle	 SHORT $LN23@equiv_stru
  00062	49 8b 42 30	 mov	 rax, QWORD PTR [r10+48]
  00066	4d 8b 49 30	 mov	 r9, QWORD PTR [r9+48]
  0006a	4c 2b c8	 sub	 r9, rax
  0006d	0f 1f 00	 npad	 3
$LL17@equiv_stru:
  00070	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00073	49 3b 14 01	 cmp	 rdx, QWORD PTR [r9+rax]
  00077	75 1a		 jne	 SHORT $LN1@equiv_stru
  00079	48 85 d2	 test	 rdx, rdx
  0007c	74 0b		 je	 SHORT $LN23@equiv_stru
  0007e	ff c1		 inc	 ecx
  00080	48 83 c0 08	 add	 rax, 8
  00084	41 3b c8	 cmp	 ecx, r8d
  00087	7c e7		 jl	 SHORT $LL17@equiv_stru
$LN23@equiv_stru:

; 313  :     }
; 314  : 
; 315  :     return 1;

  00089	b8 01 00 00 00	 mov	 eax, 1

; 316  : }

  0008e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00092	c3		 ret	 0
$LN1@equiv_stru:

; 309  :         PyErr_SetString(PyExc_ValueError,
; 310  :             "memoryview assignment: lvalue and rvalue have different "
; 311  :             "structures");

  00093	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@PKOGHNKL@memoryview?5assignment?3?5lvalue?5an@
  000a1	e8 00 00 00 00	 call	 PyErr_SetString

; 312  :         return 0;

  000a6	33 c0		 xor	 eax, eax

; 316  : }

  000a8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ac	c3		 ret	 0
equiv_structure ENDP
_TEXT	ENDS
EXTRN	__imp_memmove:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_base DD imagerel copy_base
	DD	imagerel copy_base+129
	DD	imagerel $unwind$copy_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$copy_base DD imagerel copy_base+129
	DD	imagerel copy_base+242
	DD	imagerel $chain$2$copy_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$copy_base DD imagerel copy_base+242
	DD	imagerel copy_base+326
	DD	imagerel $chain$3$copy_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$copy_base DD 021H
	DD	imagerel copy_base
	DD	imagerel copy_base+129
	DD	imagerel $unwind$copy_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$copy_base DD 020521H
	DD	0ef405H
	DD	imagerel copy_base
	DD	imagerel copy_base+129
	DD	imagerel $unwind$copy_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_base DD 0a8101H
	DD	0d7481H
	DD	0c547aH
	DD	0e00d5211H
	DD	0c009d00bH
	DD	030066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT copy_base
_TEXT	SEGMENT
shape$ = 96
itemsize$ = 104
dptr$ = 112
dstrides$ = 120
dsuboffsets$ = 128
sptr$ = 136
sstrides$ = 144
ssuboffsets$ = 152
mem$ = 160
copy_base PROC						; COMDAT

; 326  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 327  :     if (mem == NULL) { /* contiguous */

  00011	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR mem$[rsp]
  00019	4d 8b e1	 mov	 r12, r9
  0001c	49 8b d8	 mov	 rbx, r8
  0001f	4c 8b ea	 mov	 r13, rdx
  00022	4c 8b f1	 mov	 r14, rcx
  00025	48 85 f6	 test	 rsi, rsi
  00028	75 4b		 jne	 SHORT $LN11@copy_base

; 328  :         Py_ssize_t size = shape[0] * itemsize;

  0002a	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 329  :         if (dptr + size < sptr || sptr + size < dptr)

  0002d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR sptr$[rsp]
  00035	4d 0f af c5	 imul	 r8, r13
  00039	49 8d 04 18	 lea	 rax, QWORD PTR [r8+rbx]
  0003d	48 3b c2	 cmp	 rax, rdx
  00040	72 1f		 jb	 SHORT $LN9@copy_base
  00042	49 8d 04 10	 lea	 rax, QWORD PTR [r8+rdx]
  00046	48 3b c3	 cmp	 rax, rbx
  00049	72 16		 jb	 SHORT $LN9@copy_base

; 331  :         else
; 332  :             memmove(dptr, sptr, size);

  0004b	48 8b cb	 mov	 rcx, rbx

; 344  :         }
; 345  :     }
; 346  : 
; 347  : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	41 5e		 pop	 r14
  00054	41 5d		 pop	 r13
  00056	41 5c		 pop	 r12
  00058	5e		 pop	 rsi
  00059	5b		 pop	 rbx
  0005a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memmove
$LN9@copy_base:

; 330  :             memcpy(dptr, sptr, size); /* no overlapping */

  00061	48 8b cb	 mov	 rcx, rbx

; 344  :         }
; 345  :     }
; 346  : 
; 347  : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	41 5e		 pop	 r14
  0006a	41 5d		 pop	 r13
  0006c	41 5c		 pop	 r12
  0006e	5e		 pop	 rsi
  0006f	5b		 pop	 rbx
  00070	e9 00 00 00 00	 jmp	 memcpy
$LN11@copy_base:
  00075	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp

; 333  :     }
; 334  :     else {
; 335  :         char *p;
; 336  :         Py_ssize_t i;
; 337  :         for (i=0, p=mem; i < shape[0]; p+=itemsize, sptr+=sstrides[0], i++) {

  0007a	33 ed		 xor	 ebp, ebp
  0007c	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00081	4c 89 7c 24 70	 mov	 QWORD PTR [rsp+112], r15
  00086	44 8b fd	 mov	 r15d, ebp
  00089	48 39 29	 cmp	 QWORD PTR [rcx], rbp
  0008c	7e 5a		 jle	 SHORT $LN4@copy_base
  0008e	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR ssuboffsets$[rsp]
  00096	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR sptr$[rsp]
  0009e	66 90		 npad	 2
$LL6@copy_base:

; 338  :             char *xsptr = ADJUST_PTR(sptr, ssuboffsets);

  000a0	4d 85 e4	 test	 r12, r12
  000a3	74 12		 je	 SHORT $LN14@copy_base
  000a5	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  000a9	48 85 c9	 test	 rcx, rcx
  000ac	78 09		 js	 SHORT $LN14@copy_base
  000ae	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000b1	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  000b5	eb 03		 jmp	 SHORT $LN15@copy_base
$LN14@copy_base:
  000b7	48 8b d7	 mov	 rdx, rdi
$LN15@copy_base:

; 339  :             memcpy(p, xsptr, itemsize);

  000ba	4d 8b c5	 mov	 r8, r13
  000bd	48 8b ce	 mov	 rcx, rsi
  000c0	e8 00 00 00 00	 call	 memcpy
  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  000cd	49 ff c7	 inc	 r15
  000d0	48 03 38	 add	 rdi, QWORD PTR [rax]
  000d3	49 03 f5	 add	 rsi, r13
  000d6	4d 3b 3e	 cmp	 r15, QWORD PTR [r14]
  000d9	7c c5		 jl	 SHORT $LL6@copy_base
  000db	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR mem$[rsp]
  000e3	4c 8b 64 24 78	 mov	 r12, QWORD PTR dstrides$[rsp]
$LN4@copy_base:
  000e8	4c 8b 7c 24 70	 mov	 r15, QWORD PTR [rsp+112]

; 340  :         }
; 341  :         for (i=0, p=mem; i < shape[0]; p+=itemsize, dptr+=dstrides[0], i++) {

  000ed	49 39 2e	 cmp	 QWORD PTR [r14], rbp
  000f0	7e 3d		 jle	 SHORT $LN23@copy_base
  000f2	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR dsuboffsets$[rsp]
  000fa	66 0f 1f 44 00
	00		 npad	 6
$LL3@copy_base:

; 342  :             char *xdptr = ADJUST_PTR(dptr, dsuboffsets);

  00100	48 85 ff	 test	 rdi, rdi
  00103	74 0d		 je	 SHORT $LN16@copy_base
  00105	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00108	48 85 c9	 test	 rcx, rcx
  0010b	78 05		 js	 SHORT $LN16@copy_base
  0010d	48 03 0b	 add	 rcx, QWORD PTR [rbx]
  00110	eb 03		 jmp	 SHORT $LN17@copy_base
$LN16@copy_base:
  00112	48 8b cb	 mov	 rcx, rbx
$LN17@copy_base:

; 343  :             memcpy(xdptr, p, itemsize);

  00115	4d 8b c5	 mov	 r8, r13
  00118	48 8b d6	 mov	 rdx, rsi
  0011b	e8 00 00 00 00	 call	 memcpy
  00120	49 03 1c 24	 add	 rbx, QWORD PTR [r12]
  00124	48 ff c5	 inc	 rbp
  00127	49 03 f5	 add	 rsi, r13
  0012a	49 3b 2e	 cmp	 rbp, QWORD PTR [r14]
  0012d	7c d1		 jl	 SHORT $LL3@copy_base
$LN23@copy_base:
  0012f	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00134	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 344  :         }
; 345  :     }
; 346  : 
; 347  : }

  00139	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013d	41 5e		 pop	 r14
  0013f	41 5d		 pop	 r13
  00141	41 5c		 pop	 r12
  00143	5e		 pop	 rsi
  00144	5b		 pop	 rbx
  00145	c3		 ret	 0
copy_base ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_rec DD imagerel copy_rec
	DD	imagerel copy_rec+157
	DD	imagerel $unwind$copy_rec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$copy_rec DD imagerel copy_rec+157
	DD	imagerel copy_rec+464
	DD	imagerel $chain$2$copy_rec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$copy_rec DD imagerel copy_rec+464
	DD	imagerel copy_rec+473
	DD	imagerel $chain$3$copy_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$copy_rec DD 021H
	DD	imagerel copy_rec
	DD	imagerel copy_rec+157
	DD	imagerel $unwind$copy_rec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$copy_rec DD 063721H
	DD	0e7437H
	DD	0f541dH
	DD	0153408H
	DD	imagerel copy_rec
	DD	imagerel copy_rec+157
	DD	imagerel $unwind$copy_rec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_rec DD 021301H
	DD	0600cf213H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT copy_rec
_TEXT	SEGMENT
tv199 = 80
tv198 = 88
tv201 = 96
tv200 = 104
shape$ = 144
i$1$ = 152
ndim$ = 152
itemsize$ = 160
dptr$ = 168
dstrides$ = 176
dsuboffsets$ = 184
sptr$ = 192
sstrides$ = 200
ssuboffsets$ = 208
mem$ = 216
copy_rec PROC						; COMDAT

; 356  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8
  00007	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
  0000b	56		 push	 rsi
  0000c	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00013	49 8b f1	 mov	 rsi, r9
  00016	4d 8b d0	 mov	 r10, r8

; 357  :     Py_ssize_t i;
; 358  : 
; 359  :     assert(ndim >= 1);
; 360  : 
; 361  :     if (ndim == 1) {

  00019	48 83 fa 01	 cmp	 rdx, 1
  0001d	75 58		 jne	 SHORT $LN4@copy_rec

; 362  :         copy_base(shape, itemsize,
; 363  :                   dptr, dstrides, dsuboffsets,
; 364  :                   sptr, sstrides, ssuboffsets,
; 365  :                   mem);

  0001f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR mem$[rsp]
  00027	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dstrides$[rsp]
  0002f	4c 8b c6	 mov	 r8, rsi
  00032	49 89 43 b8	 mov	 QWORD PTR [r11-72], rax
  00036	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR ssuboffsets$[rsp]
  0003e	49 8b d2	 mov	 rdx, r10
  00041	49 89 43 b0	 mov	 QWORD PTR [r11-80], rax
  00045	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  0004d	49 89 43 a8	 mov	 QWORD PTR [r11-88], rax
  00051	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sptr$[rsp]
  00059	49 89 43 a0	 mov	 QWORD PTR [r11-96], rax
  0005d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR dsuboffsets$[rsp]
  00065	49 89 43 98	 mov	 QWORD PTR [r11-104], rax
  00069	e8 00 00 00 00	 call	 copy_base

; 377  :     }
; 378  : }

  0006e	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00075	5e		 pop	 rsi
  00076	c3		 ret	 0
$LN4@copy_rec:

; 366  :         return;
; 367  :     }
; 368  : 
; 369  :     for (i = 0; i < shape[0]; dptr+=dstrides[0], sptr+=sstrides[0], i++) {

  00077	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0007b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$1$[rsp], 0
  00087	0f 8e 43 01 00
	00		 jle	 $LN1@copy_rec
  0008d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR sstrides$[rsp]
  00095	4c 8b 9c 24 b0
	00 00 00	 mov	 r11, QWORD PTR dstrides$[rsp]
  0009d	48 89 9c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbx
  000a5	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR ssuboffsets$[rsp]
  000ad	48 8d 42 ff	 lea	 rax, QWORD PTR [rdx-1]
  000b1	49 83 c0 08	 add	 r8, 8
  000b5	48 89 6c 24 78	 mov	 QWORD PTR [rsp+120], rbp
  000ba	48 8b ac 24 c0
	00 00 00	 mov	 rbp, QWORD PTR sptr$[rsp]
  000c2	48 89 44 24 50	 mov	 QWORD PTR tv199[rsp], rax
  000c7	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
  000cb	49 83 c3 08	 add	 r11, 8
  000cf	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  000d4	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR dsuboffsets$[rsp]
  000dc	4c 89 44 24 60	 mov	 QWORD PTR tv201[rsp], r8
  000e1	48 89 44 24 58	 mov	 QWORD PTR tv198[rsp], rax
  000e6	4c 89 5c 24 68	 mov	 QWORD PTR tv200[rsp], r11
  000eb	0f 1f 44 00 00	 npad	 5
$LL3@copy_rec:

; 370  :         char *xdptr = ADJUST_PTR(dptr, dsuboffsets);

  000f0	48 85 ff	 test	 rdi, rdi
  000f3	74 11		 je	 SHORT $LN7@copy_rec
  000f5	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000f8	48 85 c9	 test	 rcx, rcx
  000fb	78 09		 js	 SHORT $LN7@copy_rec
  000fd	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00100	4c 8d 0c 01	 lea	 r9, QWORD PTR [rcx+rax]
  00104	eb 03		 jmp	 SHORT $LN8@copy_rec
$LN7@copy_rec:
  00106	4c 8b ce	 mov	 r9, rsi
$LN8@copy_rec:

; 371  :         char *xsptr = ADJUST_PTR(sptr, ssuboffsets);

  00109	48 85 db	 test	 rbx, rbx
  0010c	74 12		 je	 SHORT $LN9@copy_rec
  0010e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00111	48 85 c9	 test	 rcx, rcx
  00114	78 0a		 js	 SHORT $LN9@copy_rec
  00116	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  0011a	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0011e	eb 03		 jmp	 SHORT $LN10@copy_rec
$LN9@copy_rec:
  00120	48 8b d5	 mov	 rdx, rbp
$LN10@copy_rec:

; 372  : 
; 373  :         copy_rec(shape+1, ndim-1, itemsize,
; 374  :                  xdptr, dstrides+1, dsuboffsets ? dsuboffsets+1 : NULL,
; 375  :                  xsptr, sstrides+1, ssuboffsets ? ssuboffsets+1 : NULL,
; 376  :                  mem);

  00123	48 85 db	 test	 rbx, rbx
  00126	74 06		 je	 SHORT $LN11@copy_rec
  00128	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  0012c	eb 02		 jmp	 SHORT $LN12@copy_rec
$LN11@copy_rec:
  0012e	33 c9		 xor	 ecx, ecx
$LN12@copy_rec:
  00130	48 85 ff	 test	 rdi, rdi
  00133	74 06		 je	 SHORT $LN13@copy_rec
  00135	48 8d 47 08	 lea	 rax, QWORD PTR [rdi+8]
  00139	eb 02		 jmp	 SHORT $LN14@copy_rec
$LN13@copy_rec:
  0013b	33 c0		 xor	 eax, eax
$LN14@copy_rec:
  0013d	4c 8b 94 24 d8
	00 00 00	 mov	 r10, QWORD PTR mem$[rsp]
  00145	4c 89 54 24 48	 mov	 QWORD PTR [rsp+72], r10
  0014a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0014f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv198[rsp]
  00154	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  00159	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR itemsize$[rsp]
  00161	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  00166	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv199[rsp]
  0016b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00170	4c 89 5c 24 20	 mov	 QWORD PTR [rsp+32], r11
  00175	e8 00 00 00 00	 call	 copy_rec
  0017a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dstrides$[rsp]
  00182	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR shape$[rsp]
  0018a	48 03 30	 add	 rsi, QWORD PTR [rax]
  0018d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR sstrides$[rsp]
  00195	4c 8b 44 24 60	 mov	 r8, QWORD PTR tv201[rsp]
  0019a	48 03 28	 add	 rbp, QWORD PTR [rax]
  0019d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR i$1$[rsp]
  001a5	4c 8b 5c 24 68	 mov	 r11, QWORD PTR tv200[rsp]
  001aa	48 ff c0	 inc	 rax
  001ad	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR i$1$[rsp], rax
  001b5	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  001b8	0f 8c 32 ff ff
	ff		 jl	 $LL3@copy_rec
  001be	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  001c3	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001c8	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
$LN1@copy_rec:

; 377  :     }
; 378  : }

  001d0	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  001d7	5e		 pop	 rsi
  001d8	c3		 ret	 0
copy_rec ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_single DD imagerel copy_single
	DD	imagerel copy_single+250
	DD	imagerel $unwind$copy_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_single DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT copy_single
_TEXT	SEGMENT
dest$ = 96
src$ = 104
copy_single PROC					; COMDAT

; 383  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 384  :     char *mem = NULL;

  00015	33 f6		 xor	 esi, esi

; 385  : 
; 386  :     assert(dest->ndim == 1);
; 387  : 
; 388  :     if (!equiv_structure(dest, src))

  00017	e8 00 00 00 00	 call	 equiv_structure
  0001c	85 c0		 test	 eax, eax

; 389  :         return -1;

  0001e	74 6c		 je	 SHORT $LN14@copy_singl

; 390  : 
; 391  :     if (!last_dim_is_contiguous(dest, src)) {

  00020	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00024	48 85 c9	 test	 rcx, rcx
  00027	74 0b		 je	 SHORT $LN9@copy_singl
  00029	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  0002d	48 39 74 c1 f8	 cmp	 QWORD PTR [rcx+rax*8-8], rsi
  00032	7d 3a		 jge	 SHORT $LN11@copy_singl
$LN9@copy_singl:
  00034	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00038	48 85 c9	 test	 rcx, rcx
  0003b	74 0b		 je	 SHORT $LN10@copy_singl
  0003d	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  00041	48 39 74 c1 f8	 cmp	 QWORD PTR [rcx+rax*8-8], rsi
  00046	7d 26		 jge	 SHORT $LN11@copy_singl
$LN10@copy_singl:
  00048	48 63 53 24	 movsxd	 rdx, DWORD PTR [rbx+36]
  0004c	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00050	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00054	48 39 44 d1 f8	 cmp	 QWORD PTR [rcx+rdx*8-8], rax
  00059	75 13		 jne	 SHORT $LN11@copy_singl
  0005b	48 63 57 24	 movsxd	 rdx, DWORD PTR [rdi+36]
  0005f	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00063	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00067	48 39 44 d1 f8	 cmp	 QWORD PTR [rcx+rdx*8-8], rax
  0006c	74 31		 je	 SHORT $LN2@copy_singl
$LN11@copy_singl:

; 392  :         mem = PyMem_Malloc(dest->shape[0] * dest->itemsize);

  0006e	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00072	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00075	48 0f af 4b 18	 imul	 rcx, QWORD PTR [rbx+24]
  0007a	e8 00 00 00 00	 call	 PyMem_Malloc
  0007f	48 8b f0	 mov	 rsi, rax

; 393  :         if (mem == NULL) {

  00082	48 85 c0	 test	 rax, rax
  00085	75 18		 jne	 SHORT $LN2@copy_singl

; 394  :             PyErr_NoMemory();

  00087	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN14@copy_singl:

; 395  :             return -1;

  0008c	83 c8 ff	 or	 eax, -1

; 406  : 
; 407  :     return 0;
; 408  : }

  0008f	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00094	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00099	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
$LN2@copy_singl:

; 396  :         }
; 397  :     }
; 398  : 
; 399  :     copy_base(dest->shape, dest->itemsize,
; 400  :               dest->buf, dest->strides, dest->suboffsets,
; 401  :               src->buf, src->strides, src->suboffsets,
; 402  :               mem);

  0009f	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  000a3	4c 8b 4b 38	 mov	 r9, QWORD PTR [rbx+56]
  000a7	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  000aa	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  000ae	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000b2	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000b7	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000bc	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000c0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c5	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cd	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	e8 00 00 00 00	 call	 copy_base

; 403  : 
; 404  :     if (mem)

  000db	48 85 f6	 test	 rsi, rsi
  000de	74 08		 je	 SHORT $LN1@copy_singl

; 405  :         PyMem_Free(mem);

  000e0	48 8b ce	 mov	 rcx, rsi
  000e3	e8 00 00 00 00	 call	 PyMem_Free
$LN1@copy_singl:

; 406  : 
; 407  :     return 0;
; 408  : }

  000e8	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ed	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000f2	33 c0		 xor	 eax, eax
  000f4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
copy_single ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_buffer DD imagerel copy_buffer
	DD	imagerel copy_buffer+286
	DD	imagerel $unwind$copy_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_buffer DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT copy_buffer
_TEXT	SEGMENT
dest$ = 96
src$ = 104
copy_buffer PROC					; COMDAT

; 415  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 416  :     char *mem = NULL;

  00015	33 f6		 xor	 esi, esi

; 417  : 
; 418  :     assert(dest->ndim > 0);
; 419  : 
; 420  :     if (!equiv_structure(dest, src))

  00017	e8 00 00 00 00	 call	 equiv_structure
  0001c	85 c0		 test	 eax, eax

; 421  :         return -1;

  0001e	0f 84 83 00 00
	00		 je	 $LN14@copy_buffe

; 422  : 
; 423  :     if (!last_dim_is_contiguous(dest, src)) {

  00024	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00028	48 85 c9	 test	 rcx, rcx
  0002b	74 12		 je	 SHORT $LN9@copy_buffe
  0002d	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  00031	4c 8d 04 c5 f8
	ff ff ff	 lea	 r8, QWORD PTR [rax*8-8]
  00039	49 39 34 08	 cmp	 QWORD PTR [r8+rcx], rsi
  0003d	7d 49		 jge	 SHORT $LN11@copy_buffe
$LN9@copy_buffe:
  0003f	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00043	48 85 c9	 test	 rcx, rcx
  00046	74 13		 je	 SHORT $LN10@copy_buffe
  00048	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  0004c	48 39 74 c1 f8	 cmp	 QWORD PTR [rcx+rax*8-8], rsi
  00051	4c 8d 04 c5 f8
	ff ff ff	 lea	 r8, QWORD PTR [rax*8-8]
  00059	7d 2d		 jge	 SHORT $LN11@copy_buffe
$LN10@copy_buffe:
  0005b	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  0005f	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00063	4c 8d 04 c5 f8
	ff ff ff	 lea	 r8, QWORD PTR [rax*8-8]
  0006b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0006f	49 39 04 08	 cmp	 QWORD PTR [r8+rcx], rax
  00073	75 13		 jne	 SHORT $LN11@copy_buffe
  00075	48 63 57 24	 movsxd	 rdx, DWORD PTR [rdi+36]
  00079	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0007d	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00081	48 39 44 d1 f8	 cmp	 QWORD PTR [rcx+rdx*8-8], rax
  00086	74 32		 je	 SHORT $LN2@copy_buffe
$LN11@copy_buffe:

; 424  :         mem = PyMem_Malloc(dest->shape[dest->ndim-1] * dest->itemsize);

  00088	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  0008c	4a 8b 0c 00	 mov	 rcx, QWORD PTR [rax+r8]
  00090	48 0f af 4b 18	 imul	 rcx, QWORD PTR [rbx+24]
  00095	e8 00 00 00 00	 call	 PyMem_Malloc
  0009a	48 8b f0	 mov	 rsi, rax

; 425  :         if (mem == NULL) {

  0009d	48 85 c0	 test	 rax, rax
  000a0	75 18		 jne	 SHORT $LN2@copy_buffe

; 426  :             PyErr_NoMemory();

  000a2	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN14@copy_buffe:

; 427  :             return -1;

  000a7	83 c8 ff	 or	 eax, -1

; 438  : 
; 439  :     return 0;
; 440  : }

  000aa	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000af	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000b4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN2@copy_buffe:

; 428  :         }
; 429  :     }
; 430  : 
; 431  :     copy_rec(dest->shape, dest->ndim, dest->itemsize,
; 432  :              dest->buf, dest->strides, dest->suboffsets,
; 433  :              src->buf, src->strides, src->suboffsets,
; 434  :              mem);

  000ba	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  000be	48 63 53 24	 movsxd	 rdx, DWORD PTR [rbx+36]
  000c2	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  000c5	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  000c9	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  000cd	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000d2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000d7	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  000db	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000e0	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000e3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000e8	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	e8 00 00 00 00	 call	 copy_rec

; 435  : 
; 436  :     if (mem)

  000ff	48 85 f6	 test	 rsi, rsi
  00102	74 08		 je	 SHORT $LN1@copy_buffe

; 437  :         PyMem_Free(mem);

  00104	48 8b ce	 mov	 rcx, rsi
  00107	e8 00 00 00 00	 call	 PyMem_Free
$LN1@copy_buffe:

; 438  : 
; 439  :     return 0;
; 440  : }

  0010c	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00111	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00116	33 c0		 xor	 eax, eax
  00118	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
copy_buffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_strides_from_shape
_TEXT	SEGMENT
view$ = 8
init_strides_from_shape PROC				; COMDAT

; 446  :     Py_ssize_t i;
; 447  : 
; 448  :     assert(view->ndim > 0);
; 449  : 
; 450  :     view->strides[view->ndim-1] = view->itemsize;

  00000	4c 63 41 24	 movsxd	 r8, DWORD PTR [rcx+36]
  00004	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00008	48 8b 51 38	 mov	 rdx, QWORD PTR [rcx+56]
  0000c	4a 89 44 c2 f8	 mov	 QWORD PTR [rdx+r8*8-8], rax

; 451  :     for (i = view->ndim-2; i >= 0; i--)

  00011	8b 41 24	 mov	 eax, DWORD PTR [rcx+36]
  00014	4c 8b c9	 mov	 r9, rcx
  00017	83 e8 02	 sub	 eax, 2
  0001a	4c 63 c0	 movsxd	 r8, eax
  0001d	78 1e		 js	 SHORT $LN1@init_strid
  0001f	90		 npad	 1
$LL3@init_strid:

; 452  :         view->strides[i] = view->strides[i+1] * view->shape[i+1];

  00020	49 8b 41 30	 mov	 rax, QWORD PTR [r9+48]
  00024	49 8b 51 38	 mov	 rdx, QWORD PTR [r9+56]
  00028	4a 8b 4c c0 08	 mov	 rcx, QWORD PTR [rax+r8*8+8]
  0002d	4a 0f af 4c c2
	08		 imul	 rcx, QWORD PTR [rdx+r8*8+8]
  00033	49 ff c8	 dec	 r8
  00036	4a 89 4c c2 08	 mov	 QWORD PTR [rdx+r8*8+8], rcx
  0003b	79 e3		 jns	 SHORT $LL3@init_strid
$LN1@init_strid:

; 453  : }

  0003d	f3 c3		 fatret	 0
init_strides_from_shape ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_fortran_strides_from_shape
_TEXT	SEGMENT
view$ = 8
init_fortran_strides_from_shape PROC			; COMDAT

; 459  :     Py_ssize_t i;
; 460  : 
; 461  :     assert(view->ndim > 0);
; 462  : 
; 463  :     view->strides[0] = view->itemsize;

  00000	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00004	48 8b 51 38	 mov	 rdx, QWORD PTR [rcx+56]

; 464  :     for (i = 1; i < view->ndim; i++)

  00008	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000e	48 89 02	 mov	 QWORD PTR [rdx], rax
  00011	48 63 41 24	 movsxd	 rax, DWORD PTR [rcx+36]
  00015	4c 8b c9	 mov	 r9, rcx
  00018	4c 3b c0	 cmp	 r8, rax
  0001b	7d 27		 jge	 SHORT $LN1@init_fortr
  0001d	0f 1f 00	 npad	 3
$LL3@init_fortr:

; 465  :         view->strides[i] = view->strides[i-1] * view->shape[i-1];

  00020	49 8b 41 30	 mov	 rax, QWORD PTR [r9+48]
  00024	49 8b 51 38	 mov	 rdx, QWORD PTR [r9+56]
  00028	49 ff c0	 inc	 r8
  0002b	4a 8b 4c c0 f0	 mov	 rcx, QWORD PTR [rax+r8*8-16]
  00030	4a 0f af 4c c2
	f0		 imul	 rcx, QWORD PTR [rdx+r8*8-16]
  00036	4a 89 4c c2 f8	 mov	 QWORD PTR [rdx+r8*8-8], rcx
  0003b	49 63 41 24	 movsxd	 rax, DWORD PTR [r9+36]
  0003f	4c 3b c0	 cmp	 r8, rax
  00042	7c dc		 jl	 SHORT $LL3@init_fortr
$LN1@init_fortr:

; 466  : }

  00044	f3 c3		 fatret	 0
init_fortran_strides_from_shape ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$buffer_to_contiguous DD imagerel buffer_to_contiguous
	DD	imagerel buffer_to_contiguous+317
	DD	imagerel $unwind$buffer_to_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$buffer_to_contiguous DD 081401H
	DD	0126414H
	DD	0115414H
	DD	0103414H
	DD	07010d214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT buffer_to_contiguous
_TEXT	SEGMENT
dest$ = 32
mem$ = 128
src$ = 136
order$ = 144
buffer_to_contiguous PROC				; COMDAT

; 473  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b f1	 mov	 rsi, rcx

; 474  :     Py_buffer dest;
; 475  :     Py_ssize_t *strides;
; 476  :     int ret;
; 477  : 
; 478  :     assert(src->ndim >= 1);
; 479  :     assert(src->shape != NULL);
; 480  :     assert(src->strides != NULL);
; 481  : 
; 482  :     strides = PyMem_Malloc(src->ndim * (sizeof *src->strides));

  00017	48 63 4a 24	 movsxd	 rcx, DWORD PTR [rdx+36]
  0001b	41 0f b6 d8	 movzx	 ebx, r8b
  0001f	48 c1 e1 03	 shl	 rcx, 3
  00023	48 8b ea	 mov	 rbp, rdx
  00026	e8 00 00 00 00	 call	 PyMem_Malloc
  0002b	48 8b f8	 mov	 rdi, rax

; 483  :     if (strides == NULL) {

  0002e	48 85 c0	 test	 rax, rax
  00031	75 0d		 jne	 SHORT $LN4@buffer_to_

; 484  :         PyErr_NoMemory();

  00033	e8 00 00 00 00	 call	 PyErr_NoMemory

; 485  :         return -1;

  00038	83 c8 ff	 or	 eax, -1
  0003b	e9 e7 00 00 00	 jmp	 $LN5@buffer_to_
$LN4@buffer_to_:

; 486  :     }
; 487  : 
; 488  :     /* initialize dest */
; 489  :     dest = *src;

  00040	0f 10 45 00	 movups	 xmm0, XMMWORD PTR [rbp]
  00044	0f 10 4d 10	 movups	 xmm1, XMMWORD PTR [rbp+16]
  00048	0f 29 44 24 20	 movaps	 XMMWORD PTR dest$[rsp], xmm0
  0004d	0f 29 4c 24 30	 movaps	 XMMWORD PTR dest$[rsp+16], xmm1

; 490  :     dest.buf = mem;

  00052	48 89 74 24 20	 mov	 QWORD PTR dest$[rsp], rsi
  00057	0f 10 45 20	 movups	 xmm0, XMMWORD PTR [rbp+32]
  0005b	0f 10 4d 30	 movups	 xmm1, XMMWORD PTR [rbp+48]
  0005f	0f 29 44 24 40	 movaps	 XMMWORD PTR dest$[rsp+32], xmm0
  00064	0f 29 4c 24 50	 movaps	 XMMWORD PTR dest$[rsp+48], xmm1

; 491  :     /* shape is constant and shared: the logical representation of the
; 492  :        array is unaltered. */
; 493  : 
; 494  :     /* The physical representation determined by strides (and possibly
; 495  :        suboffsets) may change. */
; 496  :     dest.strides = strides;

  00069	48 89 44 24 58	 mov	 QWORD PTR dest$[rsp+56], rax
  0006e	0f 10 45 40	 movups	 xmm0, XMMWORD PTR [rbp+64]
  00072	0f 29 44 24 60	 movaps	 XMMWORD PTR dest$[rsp+64], xmm0

; 497  :     if (order == 'C' || order == 'A') {

  00077	80 fb 43	 cmp	 bl, 67			; 00000043H
  0007a	74 4b		 je	 SHORT $LN2@buffer_to_
  0007c	80 fb 41	 cmp	 bl, 65			; 00000041H
  0007f	74 46		 je	 SHORT $LN2@buffer_to_

; 499  :     }
; 500  :     else {
; 501  :         init_fortran_strides_from_shape(&dest);

  00081	4c 63 44 24 44	 movsxd	 r8, DWORD PTR dest$[rsp+36]
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$[rsp+24]
  0008b	48 89 07	 mov	 QWORD PTR [rdi], rax
  0008e	49 83 f8 01	 cmp	 r8, 1
  00092	7e 71		 jle	 SHORT $LN7@buffer_to_
  00094	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dest$[rsp+48]
  00099	48 8b d7	 mov	 rdx, rdi
  0009c	4c 2b cf	 sub	 r9, rdi
  0009f	49 ff c8	 dec	 r8
  000a2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL14@buffer_to_:
  000b0	49 8b 04 11	 mov	 rax, QWORD PTR [r9+rdx]
  000b4	48 83 c2 08	 add	 rdx, 8
  000b8	48 0f af 42 f8	 imul	 rax, QWORD PTR [rdx-8]
  000bd	49 ff c8	 dec	 r8
  000c0	48 89 02	 mov	 QWORD PTR [rdx], rax
  000c3	75 eb		 jne	 SHORT $LL14@buffer_to_

; 497  :     if (order == 'C' || order == 'A') {

  000c5	eb 3e		 jmp	 SHORT $LN7@buffer_to_
$LN2@buffer_to_:

; 498  :         init_strides_from_shape(&dest);

  000c7	48 63 54 24 44	 movsxd	 rdx, DWORD PTR dest$[rsp+36]
  000cc	48 8b 44 24 38	 mov	 rax, QWORD PTR dest$[rsp+24]
  000d1	48 89 44 d7 f8	 mov	 QWORD PTR [rdi+rdx*8-8], rax
  000d6	8d 42 fe	 lea	 eax, DWORD PTR [rdx-2]
  000d9	48 63 d0	 movsxd	 rdx, eax
  000dc	85 c0		 test	 eax, eax
  000de	78 25		 js	 SHORT $LN7@buffer_to_
  000e0	4c 8b 44 24 50	 mov	 r8, QWORD PTR dest$[rsp+48]
  000e5	48 8d 4c d7 08	 lea	 rcx, QWORD PTR [rdi+rdx*8+8]
  000ea	4c 2b c7	 sub	 r8, rdi
  000ed	0f 1f 00	 npad	 3
$LL9@buffer_to_:
  000f0	4a 8b 04 01	 mov	 rax, QWORD PTR [rcx+r8]
  000f4	48 83 e9 08	 sub	 rcx, 8
  000f8	48 0f af 41 08	 imul	 rax, QWORD PTR [rcx+8]
  000fd	48 ff ca	 dec	 rdx
  00100	48 89 01	 mov	 QWORD PTR [rcx], rax
  00103	79 eb		 jns	 SHORT $LL9@buffer_to_
$LN7@buffer_to_:

; 502  :     }
; 503  : 
; 504  :     dest.suboffsets = NULL;
; 505  : 
; 506  :     ret = copy_buffer(&dest, src);

  00105	48 8d 4c 24 20	 lea	 rcx, QWORD PTR dest$[rsp]
  0010a	48 8b d5	 mov	 rdx, rbp
  0010d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR dest$[rsp+64], 0
  00116	e8 00 00 00 00	 call	 copy_buffer

; 507  : 
; 508  :     PyMem_Free(strides);

  0011b	48 8b cf	 mov	 rcx, rdi
  0011e	8b d8		 mov	 ebx, eax
  00120	e8 00 00 00 00	 call	 PyMem_Free

; 509  :     return ret;

  00125	8b c3		 mov	 eax, ebx
$LN5@buffer_to_:

; 510  : }

  00127	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  0012c	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00130	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  00134	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00138	49 8b e3	 mov	 rsp, r11
  0013b	5f		 pop	 rdi
  0013c	c3		 ret	 0
buffer_to_contiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT init_shared_values
_TEXT	SEGMENT
dest$ = 8
src$ = 16
init_shared_values PROC					; COMDAT

; 521  :     dest->obj = src->obj;

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]

; 522  :     dest->buf = src->buf;
; 523  :     dest->len = src->len;
; 524  :     dest->itemsize = src->itemsize;
; 525  :     dest->readonly = src->readonly;
; 526  :     dest->format = src->format ? src->format : "B";

  00004	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  0000b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0000f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00019	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0001d	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  00021	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00025	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  00028	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0002b	48 8b 42 28	 mov	 rax, QWORD PTR [rdx+40]
  0002f	48 85 c0	 test	 rax, rax
  00032	4c 0f 45 c0	 cmovne	 r8, rax
  00036	4c 89 41 28	 mov	 QWORD PTR [rcx+40], r8

; 527  :     dest->internal = src->internal;

  0003a	48 8b 42 48	 mov	 rax, QWORD PTR [rdx+72]
  0003e	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 528  : }

  00042	c3		 ret	 0
init_shared_values ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_shape_strides
_TEXT	SEGMENT
dest$ = 8
src$ = 16
init_shape_strides PROC					; COMDAT

; 534  :     Py_ssize_t i;
; 535  : 
; 536  :     if (src->ndim == 0) {

  00000	8b 42 24	 mov	 eax, DWORD PTR [rdx+36]
  00003	4c 8b ca	 mov	 r9, rdx
  00006	4c 8b c1	 mov	 r8, rcx
  00009	85 c0		 test	 eax, eax
  0000b	75 0b		 jne	 SHORT $LN10@init_shape

; 537  :         dest->shape = NULL;

  0000d	33 d2		 xor	 edx, edx
  0000f	48 89 51 30	 mov	 QWORD PTR [rcx+48], rdx

; 538  :         dest->strides = NULL;

  00013	48 89 51 38	 mov	 QWORD PTR [rcx+56], rdx

; 555  :     }
; 556  : }

  00017	c3		 ret	 0
$LN10@init_shape:

; 539  :         return;
; 540  :     }
; 541  :     if (src->ndim == 1) {

  00018	83 f8 01	 cmp	 eax, 1
  0001b	75 3f		 jne	 SHORT $LN9@init_shape

; 542  :         dest->shape[0] = src->shape ? src->shape[0] : src->len / src->itemsize;

  0001d	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00021	48 85 c0	 test	 rax, rax
  00024	74 05		 je	 SHORT $LN13@init_shape
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	eb 0a		 jmp	 SHORT $LN14@init_shape
$LN13@init_shape:
  0002b	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0002f	48 99		 cdq
  00031	49 f7 79 18	 idiv	 QWORD PTR [r9+24]
$LN14@init_shape:
  00035	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 543  :         dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;

  0003c	49 8b 49 38	 mov	 rcx, QWORD PTR [r9+56]
  00040	48 85 c9	 test	 rcx, rcx
  00043	74 0b		 je	 SHORT $LN15@init_shape
  00045	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 555  :     }
; 556  : }

  0004f	c3		 ret	 0
$LN15@init_shape:

; 543  :         dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;

  00050	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00054	49 8b 49 18	 mov	 rcx, QWORD PTR [r9+24]
  00058	48 89 08	 mov	 QWORD PTR [rax], rcx

; 555  :     }
; 556  : }

  0005b	c3		 ret	 0
$LN9@init_shape:

; 544  :         return;
; 545  :     }
; 546  : 
; 547  :     for (i = 0; i < src->ndim; i++)

  0005c	33 d2		 xor	 edx, edx
  0005e	44 8b d2	 mov	 r10d, edx
  00061	85 c0		 test	 eax, eax
  00063	7e 29		 jle	 SHORT $LN6@init_shape
  00065	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@init_shape:

; 548  :         dest->shape[i] = src->shape[i];

  00070	49 8b 41 30	 mov	 rax, QWORD PTR [r9+48]
  00074	49 8b 48 30	 mov	 rcx, QWORD PTR [r8+48]
  00078	49 ff c2	 inc	 r10
  0007b	4a 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+r10*8-8]
  00080	4a 89 44 d1 f8	 mov	 QWORD PTR [rcx+r10*8-8], rax
  00085	49 63 41 24	 movsxd	 rax, DWORD PTR [r9+36]
  00089	4c 3b d0	 cmp	 r10, rax
  0008c	7c e2		 jl	 SHORT $LL8@init_shape
$LN6@init_shape:

; 549  :     if (src->strides) {

  0008e	49 39 51 38	 cmp	 QWORD PTR [r9+56], rdx
  00092	74 2c		 je	 SHORT $LN5@init_shape

; 550  :         for (i = 0; i < src->ndim; i++)

  00094	41 39 51 24	 cmp	 DWORD PTR [r9+36], edx
  00098	7e 63		 jle	 SHORT $LN17@init_shape
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@init_shape:

; 551  :             dest->strides[i] = src->strides[i];

  000a0	49 8b 41 38	 mov	 rax, QWORD PTR [r9+56]
  000a4	49 8b 48 38	 mov	 rcx, QWORD PTR [r8+56]
  000a8	48 ff c2	 inc	 rdx
  000ab	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  000b0	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  000b5	49 63 41 24	 movsxd	 rax, DWORD PTR [r9+36]
  000b9	48 3b d0	 cmp	 rdx, rax
  000bc	7c e2		 jl	 SHORT $LL4@init_shape

; 555  :     }
; 556  : }

  000be	f3 c3		 fatret	 0
$LN5@init_shape:

; 552  :     }
; 553  :     else {
; 554  :         init_strides_from_shape(dest);

  000c0	49 8b 40 18	 mov	 rax, QWORD PTR [r8+24]
  000c4	49 63 50 24	 movsxd	 rdx, DWORD PTR [r8+36]
  000c8	49 8b 48 38	 mov	 rcx, QWORD PTR [r8+56]
  000cc	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  000d1	41 8b 40 24	 mov	 eax, DWORD PTR [r8+36]
  000d5	83 e8 02	 sub	 eax, 2
  000d8	4c 63 c8	 movsxd	 r9, eax
  000db	78 20		 js	 SHORT $LN17@init_shape
  000dd	0f 1f 00	 npad	 3
$LL19@init_shape:
  000e0	49 8b 40 30	 mov	 rax, QWORD PTR [r8+48]
  000e4	49 8b 50 38	 mov	 rdx, QWORD PTR [r8+56]
  000e8	4a 8b 4c c8 08	 mov	 rcx, QWORD PTR [rax+r9*8+8]
  000ed	4a 0f af 4c ca
	08		 imul	 rcx, QWORD PTR [rdx+r9*8+8]
  000f3	49 ff c9	 dec	 r9
  000f6	4a 89 4c ca 08	 mov	 QWORD PTR [rdx+r9*8+8], rcx
  000fb	79 e3		 jns	 SHORT $LL19@init_shape
$LN17@init_shape:

; 555  :     }
; 556  : }

  000fd	f3 c3		 fatret	 0
init_shape_strides ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_suboffsets
_TEXT	SEGMENT
dest$ = 8
src$ = 16
init_suboffsets PROC					; COMDAT

; 561  :     Py_ssize_t i;
; 562  : 
; 563  :     if (src->suboffsets == NULL) {

  00000	48 83 7a 40 00	 cmp	 QWORD PTR [rdx+64], 0
  00005	4c 8b c2	 mov	 r8, rdx
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	75 07		 jne	 SHORT $LN4@init_subof

; 564  :         dest->suboffsets = NULL;

  0000d	33 d2		 xor	 edx, edx
  0000f	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 569  : }

  00013	c3		 ret	 0
$LN4@init_subof:

; 565  :         return;
; 566  :     }
; 567  :     for (i = 0; i < src->ndim; i++)

  00014	33 d2		 xor	 edx, edx
  00016	41 39 50 24	 cmp	 DWORD PTR [r8+36], edx
  0001a	7e 22		 jle	 SHORT $LN1@init_subof
  0001c	0f 1f 40 00	 npad	 4
$LL3@init_subof:

; 568  :         dest->suboffsets[i] = src->suboffsets[i];

  00020	49 8b 40 40	 mov	 rax, QWORD PTR [r8+64]
  00024	49 8b 49 40	 mov	 rcx, QWORD PTR [r9+64]
  00028	48 ff c2	 inc	 rdx
  0002b	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  00030	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  00035	49 63 40 24	 movsxd	 rax, DWORD PTR [r8+36]
  00039	48 3b d0	 cmp	 rdx, rax
  0003c	7c e2		 jl	 SHORT $LL3@init_subof
$LN1@init_subof:

; 569  : }

  0003e	f3 c3		 fatret	 0
init_suboffsets ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT init_len
_TEXT	SEGMENT
view$ = 8
init_len PROC						; COMDAT

; 578  :     for (i = 0; i < view->ndim; i++)

  00000	83 79 24 00	 cmp	 DWORD PTR [rcx+36], 0
  00004	ba 01 00 00 00	 mov	 edx, 1
  00009	7e 15		 jle	 SHORT $LN1@init_len

; 575  :     Py_ssize_t i, len;
; 576  : 
; 577  :     len = 1;

  0000b	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  0000f	4c 63 41 24	 movsxd	 r8, DWORD PTR [rcx+36]
$LL3@init_len:

; 579  :         len *= view->shape[i];

  00013	48 0f af 10	 imul	 rdx, QWORD PTR [rax]
  00017	48 83 c0 08	 add	 rax, 8
  0001b	49 ff c8	 dec	 r8
  0001e	75 f3		 jne	 SHORT $LL3@init_len
$LN1@init_len:

; 580  :     len *= view->itemsize;

  00020	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00024	48 0f af c2	 imul	 rax, rdx

; 581  : 
; 582  :     view->len = len;

  00028	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 583  : }

  0002c	c3		 ret	 0
init_len ENDP
_TEXT	ENDS
EXTRN	PyBuffer_IsContiguous:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_flags DD imagerel init_flags
	DD	imagerel init_flags+163
	DD	imagerel $unwind$init_flags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_flags DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT init_flags
_TEXT	SEGMENT
mv$ = 48
init_flags PROC						; COMDAT

; 588  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 589  :     const Py_buffer *view = &mv->view;
; 590  :     int flags = 0;
; 591  : 
; 592  :     switch (view->ndim) {

  0000f	8b 91 b4 00 00
	00		 mov	 edx, DWORD PTR [rcx+180]
  00015	33 db		 xor	 ebx, ebx
  00017	48 8b f1	 mov	 rsi, rcx
  0001a	85 d2		 test	 edx, edx
  0001c	74 5a		 je	 SHORT $LN8@init_flags
  0001e	ff ca		 dec	 edx
  00020	74 2f		 je	 SHORT $LN7@init_flags

; 601  :     default:
; 602  :         if (PyBuffer_IsContiguous(view, 'C'))

  00022	b2 43		 mov	 dl, 67			; 00000043H
  00024	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  0002b	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00030	b9 02 00 00 00	 mov	 ecx, 2

; 603  :             flags |= _Py_MEMORYVIEW_C;
; 604  :         if (PyBuffer_IsContiguous(view, 'F'))

  00035	b2 46		 mov	 dl, 70			; 00000046H
  00037	85 c0		 test	 eax, eax
  00039	0f 45 d9	 cmovne	 ebx, ecx
  0003c	48 8d 8e 90 00
	00 00		 lea	 rcx, QWORD PTR [rsi+144]
  00043	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00048	85 c0		 test	 eax, eax
  0004a	74 31		 je	 SHORT $LN9@init_flags

; 605  :             flags |= _Py_MEMORYVIEW_FORTRAN;

  0004c	83 cb 04	 or	 ebx, 4

; 606  :         break;

  0004f	eb 2c		 jmp	 SHORT $LN9@init_flags
$LN7@init_flags:

; 596  :         break;
; 597  :     case 1:
; 598  :         if (MV_CONTIGUOUS_NDIM1(view))

  00051	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00058	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  0005c	74 13		 je	 SHORT $LN5@init_flags
  0005e	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00065	48 8b 86 a8 00
	00 00		 mov	 rax, QWORD PTR [rsi+168]
  0006c	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0006f	75 0c		 jne	 SHORT $LN9@init_flags
$LN5@init_flags:

; 599  :             flags |= (_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);

  00071	bb 06 00 00 00	 mov	 ebx, 6

; 600  :         break;

  00076	eb 05		 jmp	 SHORT $LN9@init_flags
$LN8@init_flags:

; 593  :     case 0:
; 594  :         flags |= (_Py_MEMORYVIEW_SCALAR|_Py_MEMORYVIEW_C|
; 595  :                   _Py_MEMORYVIEW_FORTRAN);

  00078	bb 0e 00 00 00	 mov	 ebx, 14
$LN9@init_flags:

; 607  :     }
; 608  : 
; 609  :     if (view->suboffsets) {

  0007d	48 83 be d0 00
	00 00 00	 cmp	 QWORD PTR [rsi+208], 0
  00085	74 06		 je	 SHORT $LN13@init_flags

; 610  :         flags |= _Py_MEMORYVIEW_PIL;
; 611  :         flags &= ~(_Py_MEMORYVIEW_C|_Py_MEMORYVIEW_FORTRAN);

  00087	83 e3 f9	 and	 ebx, -7
  0008a	83 cb 10	 or	 ebx, 16
$LN13@init_flags:

; 612  :     }
; 613  : 
; 614  :     mv->flags = flags;

  0008d	89 9e 80 00 00
	00		 mov	 DWORD PTR [rsi+128], ebx

; 615  : }

  00093	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00098	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
init_flags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@OJBPNOEA@memory_alloc?$AA@		; `string'
EXTRN	_PyObject_GC_NewVar:PROC
EXTRN	_PxObject_NewVar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_alloc DD imagerel memory_alloc
	DD	imagerel memory_alloc+330
	DD	imagerel $unwind$memory_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_alloc DD 065601H
	DD	083456H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@OJBPNOEA@memory_alloc?$AA@
CONST	SEGMENT
??_C@_0N@OJBPNOEA@memory_alloc?$AA@ DB 'memory_alloc', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_alloc
_TEXT	SEGMENT
ndim$ = 64
memory_alloc PROC					; COMDAT

; 621  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 63 f1	 movsxd	 rsi, ecx

; 622  :     PyMemoryViewObject *mv;
; 623  : 
; 624  :     mv = (PyMemoryViewObject *)
; 625  :         PyObject_GC_NewVar(PyMemoryViewObject, &PyMemoryView_Type, 3*ndim);

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMemoryView_Type
  00019	85 c0		 test	 eax, eax
  0001b	8d 04 76	 lea	 eax, DWORD PTR [rsi+rsi*2]
  0001e	48 63 d0	 movsxd	 rdx, eax
  00021	74 07		 je	 SHORT $LN9@memory_all
  00023	e8 00 00 00 00	 call	 _PxObject_NewVar
  00028	eb 05		 jmp	 SHORT $LN13@memory_all
$LN9@memory_all:
  0002a	e8 00 00 00 00	 call	 _PyObject_GC_NewVar
$LN13@memory_all:
  0002f	48 8b f8	 mov	 rdi, rax

; 626  :     if (mv == NULL)

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN6@memory_all

; 640  :     return mv;
; 641  : }

  00037	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00040	5f		 pop	 rdi
  00041	c3		 ret	 0
$LN6@memory_all:

; 627  :         return NULL;
; 628  : 
; 629  :     mv->mbuf = NULL;
; 630  :     mv->hash = -1;
; 631  :     mv->flags = 0;
; 632  :     mv->exports = 0;
; 633  :     mv->view.ndim = ndim;
; 634  :     mv->view.shape = mv->ob_array;

  00042	48 8d 87 f0 00
	00 00		 lea	 rax, QWORD PTR [rdi+240]

; 635  :     mv->view.strides = mv->ob_array + ndim;

  00049	48 8d 8c f7 f0
	00 00 00	 lea	 rcx, QWORD PTR [rdi+rsi*8+240]
  00051	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00056	33 db		 xor	 ebx, ebx
  00058	48 89 87 c0 00
	00 00		 mov	 QWORD PTR [rdi+192], rax
  0005f	48 89 8f c8 00
	00 00		 mov	 QWORD PTR [rdi+200], rcx

; 636  :     mv->view.suboffsets = mv->ob_array + 2 * ndim;

  00066	8d 04 36	 lea	 eax, DWORD PTR [rsi+rsi]

; 637  :     mv->weakreflist = NULL;
; 638  : 
; 639  :     _PyObject_GC_TRACK(mv);

  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00070	4c 8b cf	 mov	 r9, rdi
  00073	48 63 c8	 movsxd	 rcx, eax
  00076	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  0007c	48 89 5f 70	 mov	 QWORD PTR [rdi+112], rbx
  00080	48 8d 84 cf f0
	00 00 00	 lea	 rax, QWORD PTR [rdi+rcx*8+240]
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@OJBPNOEA@memory_alloc?$AA@
  0008f	48 c7 47 78 ff
	ff ff ff	 mov	 QWORD PTR [rdi+120], -1
  00097	89 9f 80 00 00
	00		 mov	 DWORD PTR [rdi+128], ebx
  0009d	48 89 9f 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rbx
  000a4	89 b7 b4 00 00
	00		 mov	 DWORD PTR [rdi+180], esi
  000aa	48 89 87 d0 00
	00 00		 mov	 QWORD PTR [rdi+208], rax
  000b1	48 89 9f e8 00
	00 00		 mov	 QWORD PTR [rdi+232], rbx
  000b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c5	85 c0		 test	 eax, eax
  000c7	75 6e		 jne	 SHORT $LN2@memory_all
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@OJBPNOEA@memory_alloc?$AA@
  000d7	4c 8b cf	 mov	 r9, rdi
  000da	41 b8 7f 02 00
	00		 mov	 r8d, 639		; 0000027fH
  000e0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ed	85 c0		 test	 eax, eax
  000ef	75 04		 jne	 SHORT $LN12@memory_all
  000f1	48 8d 5f e8	 lea	 rbx, QWORD PTR [rdi-24]
$LN12@memory_all:
  000f5	48 83 7b 10 fe	 cmp	 QWORD PTR [rbx+16], -2
  000fa	74 0c		 je	 SHORT $LN1@memory_all
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BNIPEKEF@GC?5object?5already?5tracked?$AA@
  00103	e8 00 00 00 00	 call	 Py_FatalError
$LN1@memory_all:
  00108	48 c7 43 10 fd
	ff ff ff	 mov	 QWORD PTR [rbx+16], -3
  00110	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00117	48 89 03	 mov	 QWORD PTR [rbx], rax
  0011a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00121	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00125	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00129	48 89 19	 mov	 QWORD PTR [rcx], rbx
  0012c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyGC_generation0
  00133	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
$LN2@memory_all:

; 640  :     return mv;
; 641  : }

  00137	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00141	48 8b c7	 mov	 rax, rdi
  00144	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00148	5f		 pop	 rdi
  00149	c3		 ret	 0
memory_alloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$mbuf_add_view DD imagerel mbuf_add_view
	DD	imagerel mbuf_add_view+65
	DD	imagerel $unwind$mbuf_add_view
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$mbuf_add_view DD imagerel mbuf_add_view+65
	DD	imagerel mbuf_add_view+99
	DD	imagerel $chain$0$mbuf_add_view
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$mbuf_add_view DD imagerel mbuf_add_view+99
	DD	imagerel mbuf_add_view+351
	DD	imagerel $chain$2$mbuf_add_view
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$mbuf_add_view DD 020021H
	DD	086400H
	DD	imagerel mbuf_add_view
	DD	imagerel mbuf_add_view+65
	DD	imagerel $unwind$mbuf_add_view
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$mbuf_add_view DD 020521H
	DD	086405H
	DD	imagerel mbuf_add_view
	DD	imagerel mbuf_add_view+65
	DD	imagerel $unwind$mbuf_add_view
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_add_view DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@
CONST	SEGMENT
??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@ DB 'memoryview: '
	DB	'number of dimensions must not exceed 64', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
CONST	ENDS
;	COMDAT mbuf_add_view
_TEXT	SEGMENT
mbuf$ = 64
src$ = 72
mbuf_add_view PROC					; COMDAT

; 653  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f9	 mov	 rdi, rcx

; 654  :     PyMemoryViewObject *mv;
; 655  :     Py_buffer *dest;
; 656  : 
; 657  :     if (src == NULL)

  00010	48 85 d2	 test	 rdx, rdx
  00013	75 04		 jne	 SHORT $LN3@mbuf_add_v

; 658  :         src = &mbuf->master;

  00015	48 8d 59 70	 lea	 rbx, QWORD PTR [rcx+112]
$LN3@mbuf_add_v:

; 659  : 
; 660  :     if (src->ndim > PyBUF_MAX_NDIM) {

  00019	8b 4b 24	 mov	 ecx, DWORD PTR [rbx+36]
  0001c	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0001f	7e 20		 jle	 SHORT $LN2@mbuf_add_v

; 661  :         PyErr_SetString(PyExc_ValueError,
; 662  :             "memoryview: number of dimensions must not exceed "
; 663  :             STRINGIZE(PyBUF_MAX_NDIM));

  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@
  0002f	e8 00 00 00 00	 call	 PyErr_SetString

; 664  :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 680  : 
; 681  :     return (PyObject *)mv;
; 682  : }

  00036	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN2@mbuf_add_v:
  00041	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 665  :     }
; 666  : 
; 667  :     mv = memory_alloc(src->ndim);

  00046	e8 00 00 00 00	 call	 memory_alloc
  0004b	48 8b f0	 mov	 rsi, rax

; 668  :     if (mv == NULL)

  0004e	48 85 c0	 test	 rax, rax
  00051	75 10		 jne	 SHORT $LN1@mbuf_add_v
  00053	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 680  : 
; 681  :     return (PyObject *)mv;
; 682  : }

  00058	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN1@mbuf_add_v:

; 669  :         return NULL;
; 670  : 
; 671  :     dest = &mv->view;
; 672  :     init_shared_values(dest, src);

  00063	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@

; 673  :     init_shape_strides(dest, src);

  0006e	48 8b d3	 mov	 rdx, rbx
  00071	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax
  00078	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007b	48 89 86 90 00
	00 00		 mov	 QWORD PTR [rsi+144], rax
  00082	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00086	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax
  0008d	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00091	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax
  00098	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  0009b	89 86 b0 00 00
	00		 mov	 DWORD PTR [rsi+176], eax
  000a1	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000a5	48 85 c0	 test	 rax, rax
  000a8	48 0f 45 c8	 cmovne	 rcx, rax
  000ac	48 89 8e b8 00
	00 00		 mov	 QWORD PTR [rsi+184], rcx
  000b3	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000b7	48 8d 8e 90 00
	00 00		 lea	 rcx, QWORD PTR [rsi+144]
  000be	48 89 86 d8 00
	00 00		 mov	 QWORD PTR [rsi+216], rax
  000c5	e8 00 00 00 00	 call	 init_shape_strides

; 674  :     init_suboffsets(dest, src);

  000ca	33 d2		 xor	 edx, edx
  000cc	48 39 53 40	 cmp	 QWORD PTR [rbx+64], rdx
  000d0	75 09		 jne	 SHORT $LN13@mbuf_add_v
  000d2	48 89 96 d0 00
	00 00		 mov	 QWORD PTR [rsi+208], rdx
  000d9	eb 26		 jmp	 SHORT $LN10@mbuf_add_v
$LN13@mbuf_add_v:
  000db	39 53 24	 cmp	 DWORD PTR [rbx+36], edx
  000de	7e 21		 jle	 SHORT $LN10@mbuf_add_v
$LL12@mbuf_add_v:
  000e0	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  000e4	48 8b 8e d0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+208]
  000eb	48 ff c2	 inc	 rdx
  000ee	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  000f3	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  000f8	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  000fc	48 3b d0	 cmp	 rdx, rax
  000ff	7c df		 jl	 SHORT $LL12@mbuf_add_v
$LN10@mbuf_add_v:

; 675  :     init_flags(mv);

  00101	48 8b ce	 mov	 rcx, rsi
  00104	e8 00 00 00 00	 call	 init_flags

; 676  : 
; 677  :     mv->mbuf = mbuf;

  00109	48 89 7e 70	 mov	 QWORD PTR [rsi+112], rdi

; 678  :     Py_INCREF(mbuf);

  0010d	e8 00 00 00 00	 call	 _Py_PXCTX
  00112	85 c0		 test	 eax, eax
  00114	75 32		 jne	 SHORT $LN17@mbuf_add_v
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00124	4c 8b cf	 mov	 r9, rdi
  00127	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0012d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00135	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013a	85 c0		 test	 eax, eax
  0013c	75 06		 jne	 SHORT $LN16@mbuf_add_v
  0013e	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00142	74 04		 je	 SHORT $LN17@mbuf_add_v
$LN16@mbuf_add_v:
  00144	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN17@mbuf_add_v:

; 679  :     mbuf->exports++;

  00148	48 ff 47 68	 inc	 QWORD PTR [rdi+104]

; 680  : 
; 681  :     return (PyObject *)mv;
; 682  : }

  0014c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00151	48 8b c6	 mov	 rax, rsi
  00154	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00159	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0015d	5f		 pop	 rdi
  0015e	c3		 ret	 0
mbuf_add_view ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$mbuf_add_incomplete_view DD imagerel mbuf_add_incomplete_view
	DD	imagerel mbuf_add_incomplete_view+236
	DD	imagerel $unwind$mbuf_add_incomplete_view
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_add_incomplete_view DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT mbuf_add_incomplete_view
_TEXT	SEGMENT
mbuf$ = 64
src$ = 72
ndim$ = 80
mbuf_add_incomplete_view PROC				; COMDAT

; 692  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 693  :     PyMemoryViewObject *mv;
; 694  :     Py_buffer *dest;
; 695  : 
; 696  :     if (src == NULL)

  00015	48 85 d2	 test	 rdx, rdx
  00018	75 04		 jne	 SHORT $LN2@mbuf_add_i

; 697  :         src = &mbuf->master;

  0001a	48 8d 79 70	 lea	 rdi, QWORD PTR [rcx+112]
$LN2@mbuf_add_i:

; 698  : 
; 699  :     assert(ndim <= PyBUF_MAX_NDIM);
; 700  : 
; 701  :     mv = memory_alloc(ndim);

  0001e	41 8b c8	 mov	 ecx, r8d
  00021	e8 00 00 00 00	 call	 memory_alloc
  00026	48 8b f0	 mov	 rsi, rax

; 702  :     if (mv == NULL)

  00029	48 85 c0	 test	 rax, rax
  0002c	75 10		 jne	 SHORT $LN1@mbuf_add_i

; 711  : 
; 712  :     return (PyObject *)mv;
; 713  : }

  0002e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00033	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN1@mbuf_add_i:

; 703  :         return NULL;
; 704  : 
; 705  :     dest = &mv->view;
; 706  :     init_shared_values(dest, src);

  0003e	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  00049	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax
  00050	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00053	48 89 86 90 00
	00 00		 mov	 QWORD PTR [rsi+144], rax
  0005a	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0005e	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax
  00065	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00069	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax
  00070	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00073	89 86 b0 00 00
	00		 mov	 DWORD PTR [rsi+176], eax
  00079	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  0007d	48 85 c0	 test	 rax, rax
  00080	48 0f 45 c8	 cmovne	 rcx, rax
  00084	48 89 8e b8 00
	00 00		 mov	 QWORD PTR [rsi+184], rcx
  0008b	48 8b 47 48	 mov	 rax, QWORD PTR [rdi+72]
  0008f	48 89 86 d8 00
	00 00		 mov	 QWORD PTR [rsi+216], rax

; 707  : 
; 708  :     mv->mbuf = mbuf;

  00096	48 89 5e 70	 mov	 QWORD PTR [rsi+112], rbx

; 709  :     Py_INCREF(mbuf);

  0009a	e8 00 00 00 00	 call	 _Py_PXCTX
  0009f	85 c0		 test	 eax, eax
  000a1	75 32		 jne	 SHORT $LN10@mbuf_add_i
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000b1	4c 8b cb	 mov	 r9, rbx
  000b4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ba	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c7	85 c0		 test	 eax, eax
  000c9	75 06		 jne	 SHORT $LN9@mbuf_add_i
  000cb	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000cf	74 04		 je	 SHORT $LN10@mbuf_add_i
$LN9@mbuf_add_i:
  000d1	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@mbuf_add_i:

; 710  :     mbuf->exports++;

  000d5	48 ff 43 68	 inc	 QWORD PTR [rbx+104]

; 711  : 
; 712  :     return (PyObject *)mv;
; 713  : }

  000d9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000de	48 8b c6	 mov	 rax, rsi
  000e1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
mbuf_add_incomplete_view ENDP
_TEXT	ENDS
PUBLIC	PyMemoryView_FromMemory
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromMemory DD imagerel $LN4
	DD	imagerel $LN4+127
	DD	imagerel $unwind$PyMemoryView_FromMemory
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromMemory DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMemoryView_FromMemory
_TEXT	SEGMENT
mem$ = 64
size$ = 72
flags$ = 80
PyMemoryView_FromMemory PROC				; COMDAT

; 720  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	41 8b d8	 mov	 ebx, r8d
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 721  :     _PyManagedBufferObject *mbuf;
; 722  :     PyObject *mv;
; 723  :     int readonly;
; 724  : 
; 725  :     assert(mem != NULL);
; 726  :     assert(flags == PyBUF_READ || flags == PyBUF_WRITE);
; 727  : 
; 728  :     mbuf = mbuf_alloc();

  0001d	e8 00 00 00 00	 call	 mbuf_alloc
  00022	48 8b f8	 mov	 rdi, rax

; 729  :     if (mbuf == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	74 40		 je	 SHORT $LN2@PyMemoryVi
$LN1@PyMemoryVi:

; 730  :         return NULL;
; 731  : 
; 732  :     readonly = (flags == PyBUF_WRITE) ? 0 : 1;

  0002a	33 c0		 xor	 eax, eax
  0002c	81 fb 00 02 00
	00		 cmp	 ebx, 512		; 00000200H

; 733  :     (void)PyBuffer_FillInfo(&mbuf->master, NULL, mem, size, readonly,
; 734  :                             PyBUF_FULL_RO);

  00032	48 8d 4f 70	 lea	 rcx, QWORD PTR [rdi+112]
  00036	0f 95 c0	 setne	 al
  00039	4c 8b ce	 mov	 r9, rsi
  0003c	4c 8b c5	 mov	 r8, rbp
  0003f	33 d2		 xor	 edx, edx
  00041	c7 44 24 28 1c
	01 00 00	 mov	 DWORD PTR [rsp+40], 284	; 0000011cH
  00049	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004d	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 735  : 
; 736  :     mv = mbuf_add_view(mbuf, NULL);

  00052	33 d2		 xor	 edx, edx
  00054	48 8b cf	 mov	 rcx, rdi
  00057	e8 00 00 00 00	 call	 mbuf_add_view

; 737  :     Py_DECREF(mbuf);

  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	48 8b d8	 mov	 rbx, rax
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 738  : 
; 739  :     return mv;

  00067	48 8b c3	 mov	 rax, rbx
$LN2@PyMemoryVi:

; 740  : }

  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00074	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00079	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
PyMemoryView_FromMemory ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@ ; `string'
PUBLIC	PyMemoryView_FromBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromBuffer DD imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$PyMemoryView_FromBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMemoryView_FromBuffer DD imagerel $LN6+42
	DD	imagerel $LN6+71
	DD	imagerel $chain$0$PyMemoryView_FromBuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyMemoryView_FromBuffer DD imagerel $LN6+71
	DD	imagerel $LN6+132
	DD	imagerel $chain$2$PyMemoryView_FromBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyMemoryView_FromBuffer DD 020021H
	DD	067400H
	DD	imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$PyMemoryView_FromBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMemoryView_FromBuffer DD 020521H
	DD	067405H
	DD	imagerel $LN6
	DD	imagerel $LN6+42
	DD	imagerel $unwind$PyMemoryView_FromBuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromBuffer DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@
CONST	SEGMENT
??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@ DB 'PyMemor'
	DB	'yView_FromBuffer(): info->buf must not be NULL', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMemoryView_FromBuffer
_TEXT	SEGMENT
info$ = 48
PyMemoryView_FromBuffer PROC				; COMDAT

; 749  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 750  :     _PyManagedBufferObject *mbuf;
; 751  :     PyObject *mv;
; 752  : 
; 753  :     if (info->buf == NULL) {

  00006	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 1b		 jne	 SHORT $LN2@PyMemoryVi@2

; 754  :         PyErr_SetString(PyExc_ValueError,
; 755  :             "PyMemoryView_FromBuffer(): info->buf must not be NULL");

  0000f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@KPKNPNEK@PyMemoryView_FromBuffer?$CI?$CJ?3?5info?9@
  0001d	e8 00 00 00 00	 call	 PyErr_SetString

; 756  :         return NULL;

  00022	33 c0		 xor	 eax, eax

; 772  : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$LN2@PyMemoryVi@2:
  0002a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 757  :     }
; 758  : 
; 759  :     mbuf = mbuf_alloc();

  0002f	e8 00 00 00 00	 call	 mbuf_alloc
  00034	48 8b f8	 mov	 rdi, rax

; 760  :     if (mbuf == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	75 0b		 jne	 SHORT $LN1@PyMemoryVi@2
  0003c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 772  : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN1@PyMemoryVi@2:

; 761  :         return NULL;
; 762  : 
; 763  :     /* info->obj is either NULL or a borrowed reference. This reference
; 764  :        should not be decremented in PyBuffer_Release(). */
; 765  :     mbuf->master = *info;

  00047	48 8d 48 70	 lea	 rcx, QWORD PTR [rax+112]
  0004b	48 8b d3	 mov	 rdx, rbx
  0004e	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00054	e8 00 00 00 00	 call	 memcpy

; 766  :     mbuf->master.obj = NULL;
; 767  : 
; 768  :     mv = mbuf_add_view(mbuf, NULL);

  00059	33 d2		 xor	 edx, edx
  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	48 c7 47 78 00
	00 00 00	 mov	 QWORD PTR [rdi+120], 0
  00066	e8 00 00 00 00	 call	 mbuf_add_view

; 769  :     Py_DECREF(mbuf);

  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	48 8b d8	 mov	 rbx, rax
  00071	e8 00 00 00 00	 call	 _Py_DecRef
  00076	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 770  : 
; 771  :     return mv;

  0007b	48 8b c3	 mov	 rax, rbx

; 772  : }

  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
PyMemoryView_FromBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@ ; `string'
PUBLIC	??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@ ; `string'
PUBLIC	PyMemoryView_FromObject
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_FromObject DD imagerel $LN10
	DD	imagerel $LN10+102
	DD	imagerel $unwind$PyMemoryView_FromObject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyMemoryView_FromObject DD imagerel $LN10+102
	DD	imagerel $LN10+130
	DD	imagerel $chain$0$PyMemoryView_FromObject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyMemoryView_FromObject DD imagerel $LN10+130
	DD	imagerel $LN10+174
	DD	imagerel $chain$3$PyMemoryView_FromObject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyMemoryView_FromObject DD imagerel $LN10+174
	DD	imagerel $LN10+204
	DD	imagerel $chain$4$PyMemoryView_FromObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyMemoryView_FromObject DD 021H
	DD	imagerel $LN10
	DD	imagerel $LN10+102
	DD	imagerel $unwind$PyMemoryView_FromObject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyMemoryView_FromObject DD 040a21H
	DD	06340aH
	DD	047400H
	DD	imagerel $LN10
	DD	imagerel $LN10+102
	DD	imagerel $unwind$PyMemoryView_FromObject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyMemoryView_FromObject DD 020521H
	DD	047405H
	DD	imagerel $LN10
	DD	imagerel $LN10+102
	DD	imagerel $unwind$PyMemoryView_FromObject
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_FromObject DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@
CONST	SEGMENT
??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@ DB 'memoryv'
	DB	'iew: %.200s object does not have the buffer interface', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
CONST	SEGMENT
??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@ DB 'operation fo'
	DB	'rbidden on released memoryview object', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMemoryView_FromObject
_TEXT	SEGMENT
v$ = 48
PyMemoryView_FromObject PROC				; COMDAT

; 779  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 780  :     _PyManagedBufferObject *mbuf;
; 781  : 
; 782  :     if (PyMemoryView_Check(v)) {

  00004	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00008	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMemoryView_Type
  0000f	4c 3b c0	 cmp	 r8, rax
  00012	75 40		 jne	 SHORT $LN6@PyMemoryVi@3

; 783  :         PyMemoryViewObject *mv = (PyMemoryViewObject *)v;
; 784  :         CHECK_RELEASED(mv);

  00014	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0001b	75 1d		 jne	 SHORT $LN4@PyMemoryVi@3
  0001d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00021	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00025	75 13		 jne	 SHORT $LN4@PyMemoryVi@3

; 785  :         return mbuf_add_view(mv->mbuf, &mv->view);

  00027	48 8d 91 90 00
	00 00		 lea	 rdx, QWORD PTR [rcx+144]
  0002e	48 8b c8	 mov	 rcx, rax

; 801  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	e9 00 00 00 00	 jmp	 mbuf_add_view
$LN4@PyMemoryVi@3:

; 783  :         PyMemoryViewObject *mv = (PyMemoryViewObject *)v;
; 784  :         CHECK_RELEASED(mv);

  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00048	e8 00 00 00 00	 call	 PyErr_SetString
  0004d	33 c0		 xor	 eax, eax

; 801  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
$LN6@PyMemoryVi@3:

; 786  :     }
; 787  :     else if (PyObject_CheckBuffer(v)) {

  00054	49 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [r8+248]
  0005b	48 85 c0	 test	 rax, rax
  0005e	74 4e		 je	 SHORT $LN2@PyMemoryVi@3
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	74 48		 je	 SHORT $LN2@PyMemoryVi@3

; 788  :         PyObject *ret;
; 789  :         mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(v);

  00066	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0006b	e8 00 00 00 00	 call	 _PyManagedBuffer_FromObject
  00070	48 8b f8	 mov	 rdi, rax

; 790  :         if (mbuf == NULL)

  00073	48 85 c0	 test	 rax, rax
  00076	75 0a		 jne	 SHORT $LN1@PyMemoryVi@3
  00078	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 801  : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
$LN1@PyMemoryVi@3:

; 791  :             return NULL;
; 792  :         ret = mbuf_add_view(mbuf, NULL);

  00082	33 d2		 xor	 edx, edx
  00084	48 8b c8	 mov	 rcx, rax
  00087	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0008c	e8 00 00 00 00	 call	 mbuf_add_view

; 793  :         Py_DECREF(mbuf);

  00091	48 8b cf	 mov	 rcx, rdi
  00094	48 8b d8	 mov	 rbx, rax
  00097	e8 00 00 00 00	 call	 _Py_DecRef
  0009c	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 794  :         return ret;

  000a1	48 8b c3	 mov	 rax, rbx
  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 801  : }

  000a9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ad	c3		 ret	 0
$LN2@PyMemoryVi@3:

; 795  :     }
; 796  : 
; 797  :     PyErr_Format(PyExc_TypeError,
; 798  :         "memoryview: %.200s object does not have the buffer interface",
; 799  :         Py_TYPE(v)->tp_name);

  000ae	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@CBBPDCPH@memoryview?3?5?$CF?4200s?5object?5does?5n@
  000c0	e8 00 00 00 00	 call	 PyErr_Format

; 800  :     return NULL;

  000c5	33 c0		 xor	 eax, eax

; 801  : }

  000c7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cb	c3		 ret	 0
PyMemoryView_FromObject ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mbuf_copy_format DD imagerel mbuf_copy_format
	DD	imagerel mbuf_copy_format+25
	DD	imagerel $unwind$mbuf_copy_format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$mbuf_copy_format DD imagerel mbuf_copy_format+25
	DD	imagerel mbuf_copy_format+58
	DD	imagerel $chain$0$mbuf_copy_format
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$mbuf_copy_format DD imagerel mbuf_copy_format+58
	DD	imagerel mbuf_copy_format+134
	DD	imagerel $chain$1$mbuf_copy_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$mbuf_copy_format DD 021H
	DD	imagerel mbuf_copy_format
	DD	imagerel mbuf_copy_format+25
	DD	imagerel $unwind$mbuf_copy_format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$mbuf_copy_format DD 020521H
	DD	067405H
	DD	imagerel mbuf_copy_format
	DD	imagerel mbuf_copy_format+25
	DD	imagerel $unwind$mbuf_copy_format
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mbuf_copy_format DD 040a01H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT mbuf_copy_format
_TEXT	SEGMENT
mbuf$ = 48
fmt$ = 56
mbuf_copy_format PROC					; COMDAT

; 806  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 807  :     if (fmt != NULL) {

  00010	48 85 d2	 test	 rdx, rdx
  00013	74 64		 je	 SHORT $LN2@mbuf_copy_

; 808  :         char *cp = PyMem_Malloc(strlen(fmt)+1);

  00015	48 83 c9 ff	 or	 rcx, -1
  00019	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001e	33 c0		 xor	 eax, eax
  00020	48 8b fa	 mov	 rdi, rdx
  00023	f2 ae		 repne scasb
  00025	48 f7 d1	 not	 rcx
  00028	e8 00 00 00 00	 call	 PyMem_Malloc
  0002d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00032	48 8b d0	 mov	 rdx, rax

; 809  :         if (cp == NULL) {

  00035	48 85 c0	 test	 rax, rax
  00038	75 13		 jne	 SHORT $LN1@mbuf_copy_

; 810  :             PyErr_NoMemory();

  0003a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 811  :             return -1;

  0003f	83 c8 ff	 or	 eax, -1

; 818  : }

  00042	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5e		 pop	 rsi
  0004c	c3		 ret	 0
$LN1@mbuf_copy_:

; 812  :         }
; 813  :         mbuf->master.format = strcpy(cp, fmt);

  0004d	48 8b c8	 mov	 rcx, rax
  00050	48 2b cb	 sub	 rcx, rbx
  00053	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL5@mbuf_copy_:
  00060	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00063	48 ff c3	 inc	 rbx
  00066	88 44 19 ff	 mov	 BYTE PTR [rcx+rbx-1], al
  0006a	84 c0		 test	 al, al
  0006c	75 f2		 jne	 SHORT $LL5@mbuf_copy_

; 814  :         mbuf->flags |= _Py_MANAGED_BUFFER_FREE_FORMAT;

  0006e	83 4e 60 02	 or	 DWORD PTR [rsi+96], 2
  00072	48 89 96 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rdx
$LN2@mbuf_copy_:

; 815  :     }
; 816  : 
; 817  :     return 0;

  00079	33 c0		 xor	 eax, eax

; 818  : }

  0007b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5e		 pop	 rsi
  00085	c3		 ret	 0
mbuf_copy_format ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_from_contiguous_copy DD imagerel memory_from_contiguous_copy
	DD	imagerel memory_from_contiguous_copy+397
	DD	imagerel $unwind$memory_from_contiguous_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_from_contiguous_copy DD 084001H
	DD	063440H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_from_contiguous_copy
_TEXT	SEGMENT
src$ = 48
order$ = 56
memory_from_contiguous_copy PROC			; COMDAT

; 834  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	0f b6 ea	 movzx	 ebp, dl

; 835  :     _PyManagedBufferObject *mbuf;
; 836  :     PyMemoryViewObject *mv;
; 837  :     PyObject *bytes;
; 838  :     Py_buffer *dest;
; 839  :     int i;
; 840  : 
; 841  :     assert(src->ndim > 0);
; 842  :     assert(src->shape != NULL);
; 843  : 
; 844  :     bytes = PyBytes_FromStringAndSize(NULL, src->len);

  00012	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00016	48 8b f9	 mov	 rdi, rcx
  00019	33 c9		 xor	 ecx, ecx
  0001b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00020	48 8b f0	 mov	 rsi, rax

; 845  :     if (bytes == NULL)

  00023	48 85 c0	 test	 rax, rax
  00026	75 10		 jne	 SHORT $LN11@memory_fro

; 890  : }

  00028	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0002d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN11@memory_fro:

; 846  :         return NULL;
; 847  : 
; 848  :     mbuf = (_PyManagedBufferObject *)_PyManagedBuffer_FromObject(bytes);

  00038	48 8b c8	 mov	 rcx, rax
  0003b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00040	e8 00 00 00 00	 call	 _PyManagedBuffer_FromObject

; 849  :     Py_DECREF(bytes);

  00045	48 8b ce	 mov	 rcx, rsi
  00048	48 8b d8	 mov	 rbx, rax
  0004b	e8 00 00 00 00	 call	 _Py_DecRef

; 850  :     if (mbuf == NULL)

  00050	48 85 db	 test	 rbx, rbx

; 851  :         return NULL;

  00053	0f 84 18 01 00
	00		 je	 $LN24@memory_fro

; 852  : 
; 853  :     if (mbuf_copy_format(mbuf, src->format) < 0) {

  00059	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  0005d	48 8b cb	 mov	 rcx, rbx
  00060	e8 00 00 00 00	 call	 mbuf_copy_format

; 854  :         Py_DECREF(mbuf);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	85 c0		 test	 eax, eax

; 855  :         return NULL;

  0006a	0f 88 fc 00 00
	00		 js	 $LN25@memory_fro

; 856  :     }
; 857  : 
; 858  :     mv = (PyMemoryViewObject *)mbuf_add_incomplete_view(mbuf, NULL, src->ndim);

  00070	44 8b 47 24	 mov	 r8d, DWORD PTR [rdi+36]
  00074	33 d2		 xor	 edx, edx
  00076	e8 00 00 00 00	 call	 mbuf_add_incomplete_view

; 859  :     Py_DECREF(mbuf);

  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	48 8b f0	 mov	 rsi, rax
  00081	e8 00 00 00 00	 call	 _Py_DecRef

; 860  :     if (mv == NULL)

  00086	48 85 f6	 test	 rsi, rsi

; 861  :         return NULL;

  00089	0f 84 e2 00 00
	00		 je	 $LN24@memory_fro

; 864  : 
; 865  :     /* shared values are initialized correctly except for itemsize */
; 866  :     dest->itemsize = src->itemsize;

  0008f	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]

; 867  : 
; 868  :     /* shape and strides */
; 869  :     for (i = 0; i < src->ndim; i++) {

  00093	45 33 c0	 xor	 r8d, r8d
  00096	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax
  0009d	44 39 47 24	 cmp	 DWORD PTR [rdi+36], r8d
  000a1	7e 2e		 jle	 SHORT $LN5@memory_fro

; 862  : 
; 863  :     dest = &mv->view;

  000a3	33 d2		 xor	 edx, edx
  000a5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL7@memory_fro:

; 870  :         dest->shape[i] = src->shape[i];

  000b0	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  000b4	48 8b 8e c0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+192]
  000bb	41 ff c0	 inc	 r8d
  000be	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000c2	48 83 c2 08	 add	 rdx, 8
  000c6	48 89 44 0a f8	 mov	 QWORD PTR [rdx+rcx-8], rax
  000cb	44 3b 47 24	 cmp	 r8d, DWORD PTR [rdi+36]
  000cf	7c df		 jl	 SHORT $LL7@memory_fro
$LN5@memory_fro:

; 871  :     }
; 872  :     if (order == 'C' || order == 'A') {

  000d1	40 80 fd 43	 cmp	 bpl, 67			; 00000043H
  000d5	74 14		 je	 SHORT $LN3@memory_fro
  000d7	40 80 fd 41	 cmp	 bpl, 65			; 00000041H
  000db	74 0e		 je	 SHORT $LN3@memory_fro

; 874  :     }
; 875  :     else {
; 876  :         init_fortran_strides_from_shape(dest);

  000dd	48 8d 8e 90 00
	00 00		 lea	 rcx, QWORD PTR [rsi+144]
  000e4	e8 00 00 00 00	 call	 init_fortran_strides_from_shape
  000e9	eb 58		 jmp	 SHORT $LN14@memory_fro
$LN3@memory_fro:

; 873  :         init_strides_from_shape(dest);

  000eb	48 8b 8e c8 00
	00 00		 mov	 rcx, QWORD PTR [rsi+200]
  000f2	48 8b 86 a8 00
	00 00		 mov	 rax, QWORD PTR [rsi+168]
  000f9	48 63 96 b4 00
	00 00		 movsxd	 rdx, DWORD PTR [rsi+180]
  00100	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  00105	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [rsi+180]
  0010b	83 e8 02	 sub	 eax, 2
  0010e	48 63 c8	 movsxd	 rcx, eax
  00111	78 30		 js	 SHORT $LN14@memory_fro
  00113	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@memory_fro:
  00120	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00127	4c 8b 86 c8 00
	00 00		 mov	 r8, QWORD PTR [rsi+200]
  0012e	48 8b 54 c8 08	 mov	 rdx, QWORD PTR [rax+rcx*8+8]
  00133	49 0f af 54 c8
	08		 imul	 rdx, QWORD PTR [r8+rcx*8+8]
  00139	48 ff c9	 dec	 rcx
  0013c	49 89 54 c8 08	 mov	 QWORD PTR [r8+rcx*8+8], rdx
  00141	79 dd		 jns	 SHORT $LL16@memory_fro
$LN14@memory_fro:

; 877  :     }
; 878  :     /* suboffsets */
; 879  :     dest->suboffsets = NULL;
; 880  : 
; 881  :     /* flags */
; 882  :     init_flags(mv);

  00143	48 8b ce	 mov	 rcx, rsi
  00146	48 c7 86 d0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rsi+208], 0
  00151	e8 00 00 00 00	 call	 init_flags

; 883  : 
; 884  :     if (copy_buffer(dest, src) < 0) {

  00156	48 8d 8e 90 00
	00 00		 lea	 rcx, QWORD PTR [rsi+144]
  0015d	48 8b d7	 mov	 rdx, rdi
  00160	e8 00 00 00 00	 call	 copy_buffer
  00165	85 c0		 test	 eax, eax
  00167	79 0c		 jns	 SHORT $LN1@memory_fro

; 885  :         Py_DECREF(mv);

  00169	48 8b ce	 mov	 rcx, rsi
$LN25@memory_fro:
  0016c	e8 00 00 00 00	 call	 _Py_DecRef
$LN24@memory_fro:

; 886  :         return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	eb 03		 jmp	 SHORT $LN23@memory_fro
$LN1@memory_fro:

; 887  :     }
; 888  : 
; 889  :     return (PyObject *)mv;

  00175	48 8b c6	 mov	 rax, rsi
$LN23@memory_fro:
  00178	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 890  : }

  0017d	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00182	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00187	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018b	5f		 pop	 rdi
  0018c	c3		 ret	 0
memory_from_contiguous_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@ ; `string'
PUBLIC	??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@ ; `string'
PUBLIC	PyMemoryView_GetContiguous
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMemoryView_GetContiguous DD imagerel $LN8
	DD	imagerel $LN8+218
	DD	imagerel $unwind$PyMemoryView_GetContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMemoryView_GetContiguous DD 083701H
	DD	063437H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@
CONST	SEGMENT
??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@ DB 'writable cont'
	DB	'iguous buffer requested for a non-contiguous object.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@
CONST	SEGMENT
??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@ DB 'underlying b'
	DB	'uffer is not writable', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyMemoryView_GetContiguous
_TEXT	SEGMENT
obj$ = 48
buffertype$ = 56
order$ = 64
PyMemoryView_GetContiguous PROC				; COMDAT

; 911  : {

$LN8:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 0f b6 e8	 movzx	 ebp, r8b
  00013	8b f2		 mov	 esi, edx

; 912  :     PyMemoryViewObject *mv;
; 913  :     PyObject *ret;
; 914  :     Py_buffer *view;
; 915  : 
; 916  :     assert(buffertype == PyBUF_READ || buffertype == PyBUF_WRITE);
; 917  :     assert(order == 'C' || order == 'F' || order == 'A');
; 918  : 
; 919  :     mv = (PyMemoryViewObject *)PyMemoryView_FromObject(obj);

  00015	e8 00 00 00 00	 call	 PyMemoryView_FromObject
  0001a	48 8b f8	 mov	 rdi, rax

; 920  :     if (mv == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN4@PyMemoryVi@4

; 945  : }

  00022	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00027	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN4@PyMemoryVi@4:
  00032	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 921  :         return NULL;
; 922  : 
; 923  :     view = &mv->view;
; 924  :     if (buffertype == PyBUF_WRITE && view->readonly) {

  00037	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  0003d	75 28		 jne	 SHORT $LN3@PyMemoryVi@4
  0003f	83 b8 b0 00 00
	00 00		 cmp	 DWORD PTR [rax+176], 0
  00046	74 1f		 je	 SHORT $LN3@PyMemoryVi@4

; 925  :         PyErr_SetString(PyExc_BufferError,
; 926  :             "underlying buffer is not writable");

  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@BGBIMGDI@underlying?5buffer?5is?5not?5writabl@
  00056	e8 00 00 00 00	 call	 PyErr_SetString

; 927  :         Py_DECREF(mv);

  0005b	48 8b cf	 mov	 rcx, rdi
  0005e	e8 00 00 00 00	 call	 _Py_DecRef

; 928  :         return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	eb 5e		 jmp	 SHORT $LN7@PyMemoryVi@4
$LN3@PyMemoryVi@4:

; 929  :     }
; 930  : 
; 931  :     if (PyBuffer_IsContiguous(view, order))

  00067	48 8d 88 90 00
	00 00		 lea	 rcx, QWORD PTR [rax+144]
  0006e	40 0f b6 d5	 movzx	 edx, bpl
  00072	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00077	85 c0		 test	 eax, eax
  00079	74 05		 je	 SHORT $LN2@PyMemoryVi@4

; 932  :         return (PyObject *)mv;

  0007b	48 8b c7	 mov	 rax, rdi
  0007e	eb 45		 jmp	 SHORT $LN7@PyMemoryVi@4
$LN2@PyMemoryVi@4:

; 933  : 
; 934  :     if (buffertype == PyBUF_WRITE) {

  00080	81 fe 00 02 00
	00		 cmp	 esi, 512		; 00000200H
  00086	75 1f		 jne	 SHORT $LN1@PyMemoryVi@4

; 935  :         PyErr_SetString(PyExc_BufferError,
; 936  :             "writable contiguous buffer requested "
; 937  :             "for a non-contiguous object.");

  00088	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@NKCCDMPD@writable?5contiguous?5buffer?5reque@
  00096	e8 00 00 00 00	 call	 PyErr_SetString

; 938  :         Py_DECREF(mv);

  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 939  :         return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	eb 1e		 jmp	 SHORT $LN7@PyMemoryVi@4
$LN1@PyMemoryVi@4:

; 940  :     }
; 941  : 
; 942  :     ret = memory_from_contiguous_copy(view, order);

  000a7	48 8d 8f 90 00
	00 00		 lea	 rcx, QWORD PTR [rdi+144]
  000ae	40 0f b6 d5	 movzx	 edx, bpl
  000b2	e8 00 00 00 00	 call	 memory_from_contiguous_copy

; 943  :     Py_DECREF(mv);

  000b7	48 8b cf	 mov	 rcx, rdi
  000ba	48 8b d8	 mov	 rbx, rax
  000bd	e8 00 00 00 00	 call	 _Py_DecRef

; 944  :     return ret;

  000c2	48 8b c3	 mov	 rax, rbx
$LN7@PyMemoryVi@4:

; 945  : }

  000c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ca	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000cf	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
PyMemoryView_GetContiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NFAFDFHO@O?3memoryview?$AA@		; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_new DD imagerel memory_new
	DD	imagerel memory_new+71
	DD	imagerel $unwind$memory_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_new DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0N@NFAFDFHO@O?3memoryview?$AA@
CONST	SEGMENT
??_C@_0N@NFAFDFHO@O?3memoryview?$AA@ DB 'O:memoryview', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_new
_TEXT	SEGMENT
subtype$ = 64
args$ = 72
kwds$ = 80
obj$ = 88
memory_new PROC						; COMDAT

; 950  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	4c 8b d2	 mov	 r10, rdx

; 951  :     PyObject *obj;
; 952  :     static char *kwlist[] = {"object", NULL};
; 953  : 
; 954  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:memoryview", kwlist,
; 955  :                                      &obj)) {

  0000a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR obj$[rsp]
  0000f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??memory_new@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NFAFDFHO@O?3memoryview?$AA@
  00022	49 8b ca	 mov	 rcx, r10
  00025	48 8b d0	 mov	 rdx, rax
  00028	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN1@memory_new

; 956  :         return NULL;

  00031	33 c0		 xor	 eax, eax

; 960  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
$LN1@memory_new:

; 957  :     }
; 958  : 
; 959  :     return PyMemoryView_FromObject(obj);

  00038	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obj$[rsp]
  0003d	e8 00 00 00 00	 call	 PyMemoryView_FromObject

; 960  : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
memory_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@ ; `string'
PUBLIC	PyBuffer_ToContiguous
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_ToContiguous DD imagerel $LN18
	DD	imagerel $LN18+366
	DD	imagerel $unwind$PyBuffer_ToContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_ToContiguous DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@
CONST	SEGMENT
??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@ DB 'PyBuff'
	DB	'er_ToContiguous: len != view->len', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyBuffer_ToContiguous
_TEXT	SEGMENT
buf$ = 48
src$ = 56
len$ = 64
order$ = 72
PyBuffer_ToContiguous PROC				; COMDAT

; 974  : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 0f b6 e9	 movzx	 ebp, r9b
  00018	49 8b f8	 mov	 rdi, r8
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8b f1	 mov	 rsi, rcx

; 975  :     Py_buffer_full *fb = NULL;
; 976  :     int ret;
; 977  : 
; 978  :     assert(order == 'C' || order == 'F' || order == 'A');
; 979  : 
; 980  :     if (len != src->len) {

  00021	4c 3b 42 10	 cmp	 r8, QWORD PTR [rdx+16]
  00025	74 1b		 je	 SHORT $LN3@PyBuffer_T

; 981  :         PyErr_SetString(PyExc_ValueError,
; 982  :             "PyBuffer_ToContiguous: len != view->len");

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GJDLHDMI@PyBuffer_ToContiguous?3?5len?5?$CB?$DN?5vi@
  00035	e8 00 00 00 00	 call	 PyErr_SetString

; 983  :         return -1;

  0003a	83 c8 ff	 or	 eax, -1
  0003d	e9 17 01 00 00	 jmp	 $LN4@PyBuffer_T
$LN3@PyBuffer_T:

; 984  :     }
; 985  : 
; 986  :     if (PyBuffer_IsContiguous(src, order)) {

  00042	40 0f b6 d5	 movzx	 edx, bpl
  00046	48 8b cb	 mov	 rcx, rbx
  00049	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0004e	85 c0		 test	 eax, eax
  00050	74 15		 je	 SHORT $LN2@PyBuffer_T

; 987  :         memcpy((char *)buf, src->buf, len);

  00052	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00055	4c 8b c7	 mov	 r8, rdi
  00058	48 8b ce	 mov	 rcx, rsi
  0005b	e8 00 00 00 00	 call	 memcpy

; 988  :         return 0;

  00060	33 c0		 xor	 eax, eax
  00062	e9 f2 00 00 00	 jmp	 $LN4@PyBuffer_T
$LN2@PyBuffer_T:

; 989  :     }
; 990  : 
; 991  :     /* buffer_to_contiguous() assumes PyBUF_FULL */
; 992  :     fb = PyMem_Malloc(sizeof *fb + 3 * src->ndim * (sizeof *fb->array));

  00067	8b 43 24	 mov	 eax, DWORD PTR [rbx+36]
  0006a	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]
  0006d	48 63 c9	 movsxd	 rcx, ecx
  00070	48 8d 0c cd 58
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+88]
  00078	e8 00 00 00 00	 call	 PyMem_Malloc
  0007d	48 8b f8	 mov	 rdi, rax

; 993  :     if (fb == NULL) {

  00080	48 85 c0	 test	 rax, rax
  00083	75 0d		 jne	 SHORT $LN1@PyBuffer_T

; 994  :         PyErr_NoMemory();

  00085	e8 00 00 00 00	 call	 PyErr_NoMemory

; 995  :         return -1;

  0008a	83 c8 ff	 or	 eax, -1
  0008d	e9 c7 00 00 00	 jmp	 $LN4@PyBuffer_T
$LN1@PyBuffer_T:

; 996  :     }
; 997  :     fb->view.ndim = src->ndim;

  00092	8b 43 24	 mov	 eax, DWORD PTR [rbx+36]

; 998  :     fb->view.shape = fb->array;
; 999  :     fb->view.strides = fb->array + src->ndim;
; 1000 :     fb->view.suboffsets = fb->array + 2 * src->ndim;
; 1001 : 
; 1002 :     init_shared_values(&fb->view, src);
; 1003 :     init_shape_strides(&fb->view, src);

  00095	48 8b d3	 mov	 rdx, rbx
  00098	89 47 24	 mov	 DWORD PTR [rdi+36], eax
  0009b	48 8d 47 50	 lea	 rax, QWORD PTR [rdi+80]
  0009f	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  000a3	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  000a7	48 8d 4c c7 50	 lea	 rcx, QWORD PTR [rdi+rax*8+80]
  000ac	48 89 4f 38	 mov	 QWORD PTR [rdi+56], rcx
  000b0	8b 43 24	 mov	 eax, DWORD PTR [rbx+36]
  000b3	03 c0		 add	 eax, eax
  000b5	48 98		 cdqe
  000b7	48 8d 4c c7 50	 lea	 rcx, QWORD PTR [rdi+rax*8+80]
  000bc	48 89 4f 40	 mov	 QWORD PTR [rdi+64], rcx
  000c0	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  000cb	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  000cf	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d2	48 89 07	 mov	 QWORD PTR [rdi], rax
  000d5	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000d9	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  000dd	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000e1	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  000e5	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  000e8	89 47 20	 mov	 DWORD PTR [rdi+32], eax
  000eb	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000ef	48 85 c0	 test	 rax, rax
  000f2	48 0f 45 c8	 cmovne	 rcx, rax
  000f6	48 89 4f 28	 mov	 QWORD PTR [rdi+40], rcx
  000fa	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  000fe	48 8b cf	 mov	 rcx, rdi
  00101	48 89 47 48	 mov	 QWORD PTR [rdi+72], rax
  00105	e8 00 00 00 00	 call	 init_shape_strides

; 1004 :     init_suboffsets(&fb->view, src);

  0010a	33 d2		 xor	 edx, edx
  0010c	48 39 53 40	 cmp	 QWORD PTR [rbx+64], rdx
  00110	75 06		 jne	 SHORT $LN13@PyBuffer_T
  00112	48 89 57 40	 mov	 QWORD PTR [rdi+64], rdx
  00116	eb 26		 jmp	 SHORT $LN10@PyBuffer_T
$LN13@PyBuffer_T:
  00118	39 53 24	 cmp	 DWORD PTR [rbx+36], edx
  0011b	7e 21		 jle	 SHORT $LN10@PyBuffer_T
  0011d	0f 1f 00	 npad	 3
$LL12@PyBuffer_T:
  00120	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00124	48 8b 4f 40	 mov	 rcx, QWORD PTR [rdi+64]
  00128	48 ff c2	 inc	 rdx
  0012b	48 8b 44 d0 f8	 mov	 rax, QWORD PTR [rax+rdx*8-8]
  00130	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  00135	48 63 43 24	 movsxd	 rax, DWORD PTR [rbx+36]
  00139	48 3b d0	 cmp	 rdx, rax
  0013c	7c e2		 jl	 SHORT $LL12@PyBuffer_T
$LN10@PyBuffer_T:

; 1005 : 
; 1006 :     src = &fb->view;
; 1007 : 
; 1008 :     ret = buffer_to_contiguous(buf, src, order);

  0013e	44 0f b6 c5	 movzx	 r8d, bpl
  00142	48 8b d7	 mov	 rdx, rdi
  00145	48 8b ce	 mov	 rcx, rsi
  00148	e8 00 00 00 00	 call	 buffer_to_contiguous

; 1009 :     PyMem_Free(fb);

  0014d	48 8b cf	 mov	 rcx, rdi
  00150	8b d8		 mov	 ebx, eax
  00152	e8 00 00 00 00	 call	 PyMem_Free

; 1010 :     return ret;

  00157	8b c3		 mov	 eax, ebx
$LN4@PyBuffer_T:

; 1011 : }

  00159	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0015e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00163	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
PyBuffer_ToContiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@ ; `string'
PUBLIC	??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_memory_release DD imagerel _memory_release
	DD	imagerel _memory_release+132
	DD	imagerel $unwind$_memory_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_memory_release DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@
CONST	SEGMENT
??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@ DB '_memory'
	DB	'_release(): negative export count', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@
CONST	SEGMENT
??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@ DB 'memoryvie'
	DB	'w has %zd exported buffer%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _memory_release
_TEXT	SEGMENT
self$ = 48
_memory_release PROC					; COMDAT

; 1026 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1027 :     if (self->flags & _Py_MEMORYVIEW_RELEASED)

  00004	8b 81 80 00 00
	00		 mov	 eax, DWORD PTR [rcx+128]
  0000a	a8 01		 test	 al, 1

; 1028 :         return 0;

  0000c	75 28		 jne	 SHORT $LN2@memory_rel

; 1029 : 
; 1030 :     if (self->exports == 0) {

  0000e	4c 8b 81 88 00
	00 00		 mov	 r8, QWORD PTR [rcx+136]
  00015	4d 85 c0	 test	 r8, r8
  00018	75 23		 jne	 SHORT $LN7@memory_rel

; 1031 :         self->flags |= _Py_MEMORYVIEW_RELEASED;

  0001a	83 c8 01	 or	 eax, 1
  0001d	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 1032 :         assert(self->mbuf->exports > 0);
; 1033 :         if (--self->mbuf->exports == 0)

  00023	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00027	48 ff 48 68	 dec	 QWORD PTR [rax+104]
  0002b	75 09		 jne	 SHORT $LN2@memory_rel

; 1034 :             mbuf_release(self->mbuf);

  0002d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00031	e8 00 00 00 00	 call	 mbuf_release
$LN2@memory_rel:

; 1035 :         return 0;

  00036	33 c0		 xor	 eax, eax

; 1046 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN7@memory_rel:

; 1036 :     }
; 1037 :     if (self->exports > 0) {

  0003d	7e 31		 jle	 SHORT $LN1@memory_rel

; 1038 :         PyErr_Format(PyExc_BufferError,
; 1039 :             "memoryview has %zd exported buffer%s", self->exports,
; 1040 :             self->exports==1 ? "" : "s");

  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0004d	49 83 f8 01	 cmp	 r8, 1
  00051	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@MCKFMDHA@memoryview?5has?5?$CFzd?5exported?5buff@
  0005f	4c 0f 44 c8	 cmove	 r9, rax
  00063	e8 00 00 00 00	 call	 PyErr_Format

; 1045 :     return -1;

  00068	83 c8 ff	 or	 eax, -1

; 1046 : }

  0006b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006f	c3		 ret	 0
$LN1@memory_rel:

; 1041 :         return -1;
; 1042 :     }
; 1043 : 
; 1044 :     Py_FatalError("_memory_release(): negative export count");

  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@PAJHFMGJ@_memory_release?$CI?$CJ?3?5negative?5expo@
  00077	e8 00 00 00 00	 call	 Py_FatalError

; 1045 :     return -1;

  0007c	83 c8 ff	 or	 eax, -1

; 1046 : }

  0007f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00083	c3		 ret	 0
_memory_release ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_release DD imagerel memory_release
	DD	imagerel memory_release+101
	DD	imagerel $unwind$memory_release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_release DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT memory_release
_TEXT	SEGMENT
self$ = 64
noargs$ = 72
memory_release PROC					; COMDAT

; 1050 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1051 :     if (_memory_release(self) < 0)

  00004	e8 00 00 00 00	 call	 _memory_release
  00009	85 c0		 test	 eax, eax
  0000b	79 07		 jns	 SHORT $LN1@memory_rel@2

; 1052 :         return NULL;

  0000d	33 c0		 xor	 eax, eax

; 1054 : }

  0000f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00013	c3		 ret	 0
$LN1@memory_rel@2:

; 1053 :     Py_RETURN_NONE;

  00014	e8 00 00 00 00	 call	 _Py_PXCTX
  00019	85 c0		 test	 eax, eax
  0001b	75 3c		 jne	 SHORT $LN5@memory_rel@2
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00032	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00038	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 09		 jne	 SHORT $LN4@memory_rel@2
  00049	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00050	74 07		 je	 SHORT $LN5@memory_rel@2
$LN4@memory_rel@2:
  00052	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@memory_rel@2:
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1054 : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
memory_release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OCGMNPFP@memory_dealloc?$AA@		; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_dealloc DD imagerel memory_dealloc
	DD	imagerel memory_dealloc+191
	DD	imagerel $unwind$memory_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memory_dealloc DD imagerel memory_dealloc+191
	DD	imagerel memory_dealloc+314
	DD	imagerel $chain$0$memory_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$memory_dealloc DD imagerel memory_dealloc+314
	DD	imagerel memory_dealloc+345
	DD	imagerel $chain$1$memory_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$memory_dealloc DD 021H
	DD	imagerel memory_dealloc
	DD	imagerel memory_dealloc+191
	DD	imagerel $unwind$memory_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memory_dealloc DD 020521H
	DD	083405H
	DD	imagerel memory_dealloc
	DD	imagerel memory_dealloc+191
	DD	imagerel $unwind$memory_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_dealloc DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
CONST	SEGMENT
??_C@_0P@OCGMNPFP@memory_dealloc?$AA@ DB 'memory_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
CONST	ENDS
;	COMDAT memory_dealloc
_TEXT	SEGMENT
self$ = 64
memory_dealloc PROC					; COMDAT

; 1058 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 1059 :     assert(self->exports == 0);
; 1060 :     _PyObject_GC_UNTRACK(self);

  00009	4c 8b c9	 mov	 r9, rcx
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  0001a	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00020	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00028	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002d	85 c0		 test	 eax, eax
  0002f	75 54		 jne	 SHORT $LN6@memory_dea
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  0003f	4c 8b cf	 mov	 r9, rdi
  00042	41 b8 24 04 00
	00		 mov	 r8d, 1060		; 00000424H
  00048	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	74 04		 je	 SHORT $LN12@memory_dea
  00059	33 d2		 xor	 edx, edx
  0005b	eb 04		 jmp	 SHORT $LN13@memory_dea
$LN12@memory_dea:
  0005d	48 8d 57 e8	 lea	 rdx, QWORD PTR [rdi-24]
$LN13@memory_dea:
  00061	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00064	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00068	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00070	48 89 01	 mov	 QWORD PTR [rcx], rax
  00073	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00076	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0007e	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN6@memory_dea:

; 1061 :     (void)_memory_release(self);

  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 _memory_release

; 1062 :     Py_CLEAR(self->mbuf);

  0008d	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00091	4d 85 c9	 test	 r9, r9
  00094	0f 84 a0 00 00
	00		 je	 $LN4@memory_dea
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OCGMNPFP@memory_dealloc?$AA@
  000a8	41 b8 26 04 00
	00		 mov	 r8d, 1062		; 00000426H
  000ae	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bb	85 c0		 test	 eax, eax
  000bd	75 7b		 jne	 SHORT $LN4@memory_dea
  000bf	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c4	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  000c8	48 c7 47 70 00
	00 00 00	 mov	 QWORD PTR [rdi+112], 0
  000d0	e8 00 00 00 00	 call	 _Py_PXCTX
  000d5	85 c0		 test	 eax, eax
  000d7	75 5c		 jne	 SHORT $LN25@memory_dea
  000d9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000dd	a8 20		 test	 al, 32			; 00000020H
  000df	75 4c		 jne	 SHORT $LN18@memory_dea
  000e1	84 c0		 test	 al, al
  000e3	78 48		 js	 SHORT $LN18@memory_dea
  000e5	a8 02		 test	 al, 2
  000e7	75 4c		 jne	 SHORT $LN25@memory_dea
  000e9	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ed	75 46		 jne	 SHORT $LN25@memory_dea
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000fd	4c 8b cb	 mov	 r9, rbx
  00100	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00106	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0010e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00113	48 8b cb	 mov	 rcx, rbx
  00116	85 c0		 test	 eax, eax
  00118	74 07		 je	 SHORT $LN23@memory_dea
  0011a	e8 00 00 00 00	 call	 _Px_Dealloc
  0011f	eb 14		 jmp	 SHORT $LN25@memory_dea
$LN23@memory_dea:
  00121	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00125	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0012b	eb 08		 jmp	 SHORT $LN25@memory_dea
$LN18@memory_dea:
  0012d	48 8b cb	 mov	 rcx, rbx
  00130	e8 00 00 00 00	 call	 Px_DecRef
$LN25@memory_dea:
  00135	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN4@memory_dea:

; 1063 :     if (self->weakreflist != NULL)

  0013a	48 83 bf e8 00
	00 00 00	 cmp	 QWORD PTR [rdi+232], 0
  00142	74 08		 je	 SHORT $LN1@memory_dea

; 1064 :         PyObject_ClearWeakRefs((PyObject *) self);

  00144	48 8b cf	 mov	 rcx, rdi
  00147	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN1@memory_dea:

; 1065 :     PyObject_GC_Del(self);

  0014c	48 8b cf	 mov	 rcx, rdi

; 1066 : }

  0014f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00153	5f		 pop	 rdi
  00154	e9 00 00 00 00	 jmp	 PyObject_GC_Del
memory_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CIAKKKKF@memory_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_traverse DD imagerel memory_traverse
	DD	imagerel memory_traverse+97
	DD	imagerel $unwind$memory_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BA@CIAKKKKF@memory_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@CIAKKKKF@memory_traverse?$AA@ DB 'memory_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
memory_traverse PROC					; COMDAT

; 1070 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1071 :     Py_VISIT(self->mbuf);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@memory_tra
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@CIAKKKKF@memory_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 2f 04 00
	00		 mov	 r8d, 1071		; 0000042fH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@memory_tra:
  0003d	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@memory_tra
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@memory_tra
$LN5@memory_tra:

; 1072 :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@memory_tra:

; 1073 : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
memory_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@IAJIDONL@memory_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_clear DD imagerel memory_clear
	DD	imagerel memory_clear+68
	DD	imagerel $unwind$memory_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memory_clear DD imagerel memory_clear+68
	DD	imagerel memory_clear+177
	DD	imagerel $chain$0$memory_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$memory_clear DD imagerel memory_clear+177
	DD	imagerel memory_clear+200
	DD	imagerel $chain$2$memory_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$memory_clear DD imagerel memory_clear+200
	DD	imagerel memory_clear+213
	DD	imagerel $chain$4$memory_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$memory_clear DD imagerel memory_clear+213
	DD	imagerel memory_clear+221
	DD	imagerel $chain$5$memory_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$memory_clear DD 021H
	DD	imagerel memory_clear
	DD	imagerel memory_clear+68
	DD	imagerel $unwind$memory_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$memory_clear DD 020021H
	DD	083400H
	DD	imagerel memory_clear
	DD	imagerel memory_clear+68
	DD	imagerel $unwind$memory_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$memory_clear DD 020021H
	DD	083400H
	DD	imagerel memory_clear
	DD	imagerel memory_clear+68
	DD	imagerel $unwind$memory_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memory_clear DD 020521H
	DD	083405H
	DD	imagerel memory_clear
	DD	imagerel memory_clear+68
	DD	imagerel $unwind$memory_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0N@IAJIDONL@memory_clear?$AA@
CONST	SEGMENT
??_C@_0N@IAJIDONL@memory_clear?$AA@ DB 'memory_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
CONST	ENDS
;	COMDAT memory_clear
_TEXT	SEGMENT
self$ = 64
memory_clear PROC					; COMDAT

; 1077 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 1078 :     (void)_memory_release(self);

  00009	e8 00 00 00 00	 call	 _memory_release

; 1079 :     Py_CLEAR(self->mbuf);

  0000e	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00012	4d 85 c9	 test	 r9, r9
  00015	0f 84 ba 00 00
	00		 je	 $LN21@memory_cle
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@GCIEGLPC@?4?4?2Objects?2memoryobject?4c?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@IAJIDONL@memory_clear?$AA@
  00029	41 b8 37 04 00
	00		 mov	 r8d, 1079		; 00000437H
  0002f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00037	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003c	85 c0		 test	 eax, eax
  0003e	0f 85 91 00 00
	00		 jne	 $LN21@memory_cle
  00044	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00049	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  0004d	48 c7 47 70 00
	00 00 00	 mov	 QWORD PTR [rdi+112], 0
  00055	e8 00 00 00 00	 call	 _Py_PXCTX
  0005a	85 c0		 test	 eax, eax
  0005c	75 72		 jne	 SHORT $LN22@memory_cle
  0005e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00062	a8 20		 test	 al, 32			; 00000020H
  00064	75 62		 jne	 SHORT $LN11@memory_cle
  00066	84 c0		 test	 al, al
  00068	78 5e		 js	 SHORT $LN11@memory_cle
  0006a	a8 02		 test	 al, 2
  0006c	75 62		 jne	 SHORT $LN22@memory_cle
  0006e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00072	75 5c		 jne	 SHORT $LN22@memory_cle
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00082	4c 8b cb	 mov	 r9, rbx
  00085	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	48 8b cb	 mov	 rcx, rbx
  0009b	85 c0		 test	 eax, eax
  0009d	74 12		 je	 SHORT $LN16@memory_cle
  0009f	e8 00 00 00 00	 call	 _Px_Dealloc
  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1080 :     return 0;

  000a9	33 c0		 xor	 eax, eax

; 1081 : }

  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0

; 1079 :     Py_CLEAR(self->mbuf);

$LN16@memory_cle:
  000b1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1080 :     return 0;

  000c0	33 c0		 xor	 eax, eax

; 1081 : }

  000c2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0

; 1079 :     Py_CLEAR(self->mbuf);

$LN11@memory_cle:
  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	e8 00 00 00 00	 call	 Px_DecRef
$LN22@memory_cle:
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN21@memory_cle:

; 1080 :     return 0;

  000d5	33 c0		 xor	 eax, eax

; 1081 : }

  000d7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000db	5f		 pop	 rdi
  000dc	c3		 ret	 0
memory_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_enter DD imagerel memory_enter
	DD	imagerel memory_enter+123
	DD	imagerel $unwind$memory_enter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_enter DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT memory_enter
_TEXT	SEGMENT
self$ = 64
args$ = 72
memory_enter PROC					; COMDAT

; 1085 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1086 :     CHECK_RELEASED(self);

  00006	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	75 4e		 jne	 SHORT $LN1@memory_ent
  00012	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00016	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0001a	75 44		 jne	 SHORT $LN1@memory_ent

; 1087 :     Py_INCREF(self);

  0001c	e8 00 00 00 00	 call	 _Py_PXCTX
  00021	85 c0		 test	 eax, eax
  00023	75 32		 jne	 SHORT $LN6@memory_ent
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	4c 8b cb	 mov	 r9, rbx
  00036	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00044	e8 00 00 00 00	 call	 _PyParallel_Guard
  00049	85 c0		 test	 eax, eax
  0004b	75 06		 jne	 SHORT $LN5@memory_ent
  0004d	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00051	74 04		 je	 SHORT $LN6@memory_ent
$LN5@memory_ent:
  00053	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@memory_ent:

; 1088 :     return self;

  00057	48 8b c3	 mov	 rax, rbx

; 1089 : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
$LN1@memory_ent:

; 1086 :     CHECK_RELEASED(self);

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0006e	e8 00 00 00 00	 call	 PyErr_SetString
  00073	33 c0		 xor	 eax, eax

; 1089 : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
memory_enter ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT memory_exit
_TEXT	SEGMENT
self$ = 8
args$ = 16
memory_exit PROC					; COMDAT

; 1094 :     return memory_release((PyMemoryViewObject *)self, NULL);

  00000	33 d2		 xor	 edx, edx

; 1095 : }

  00002	e9 00 00 00 00	 jmp	 memory_release
memory_exit ENDP
_TEXT	ENDS
EXTRN	__ImageBase:BYTE
; Function compile flags: /Ogtpy
;	COMDAT get_native_fmtchar
_TEXT	SEGMENT
result$ = 8
fmt$ = 16
get_native_fmtchar PROC					; COMDAT

; 1107 :     Py_ssize_t size = -1;
; 1108 : 
; 1109 :     if (fmt[0] == '@') fmt++;

  00000	80 3a 40	 cmp	 BYTE PTR [rdx], 64	; 00000040H
  00003	4c 8b c9	 mov	 r9, rcx
  00006	75 03		 jne	 SHORT $LN14@get_native
  00008	48 ff c2	 inc	 rdx
$LN14@get_native:

; 1110 : 
; 1111 :     switch (fmt[0]) {

  0000b	44 0f be 02	 movsx	 r8d, BYTE PTR [rdx]
  0000f	41 8d 40 c1	 lea	 eax, DWORD PTR [r8-63]
  00013	83 f8 32	 cmp	 eax, 50			; 00000032H
  00016	77 43		 ja	 SHORT $LN1@get_native
  00018	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
  0001f	48 98		 cdqe
  00021	41 0f b6 84 02
	00 00 00 00	 movzx	 eax, BYTE PTR $LN18@get_native[r10+rax]
  0002a	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN19@get_native[r10+rax*4]
  00032	49 03 ca	 add	 rcx, r10
  00035	ff e1		 jmp	 rcx
$LN11@get_native:

; 1112 :     case 'c': case 'b': case 'B': size = sizeof(char); break;

  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	eb 13		 jmp	 SHORT $LN17@get_native
$LN10@get_native:

; 1113 :     case 'h': case 'H': size = sizeof(short); break;

  0003e	b8 02 00 00 00	 mov	 eax, 2
  00043	eb 0c		 jmp	 SHORT $LN17@get_native
$LN9@get_native:

; 1114 :     case 'i': case 'I': size = sizeof(int); break;

  00045	b8 04 00 00 00	 mov	 eax, 4
  0004a	eb 05		 jmp	 SHORT $LN17@get_native
$LN2@get_native:

; 1115 :     case 'l': case 'L': size = sizeof(long); break;
; 1116 :     #ifdef HAVE_LONG_LONG
; 1117 :     case 'q': case 'Q': size = sizeof(PY_LONG_LONG); break;
; 1118 :     #endif
; 1119 :     case 'n': case 'N': size = sizeof(Py_ssize_t); break;
; 1120 :     case 'f': size = sizeof(float); break;
; 1121 :     case 'd': size = sizeof(double); break;
; 1122 :     #ifdef HAVE_C99_BOOL
; 1123 :     case '?': size = sizeof(_Bool); break;
; 1124 :     #else
; 1125 :     case '?': size = sizeof(char); break;
; 1126 :     #endif
; 1127 :     case 'P': size = sizeof(void *); break;

  0004c	b8 08 00 00 00	 mov	 eax, 8
$LN17@get_native:

; 1128 :     }
; 1129 : 
; 1130 :     if (size > 0 && fmt[1] == '\0') {

  00051	80 7a 01 00	 cmp	 BYTE PTR [rdx+1], 0
  00055	75 04		 jne	 SHORT $LN1@get_native

; 1131 :         *result = fmt[0];

  00057	45 88 01	 mov	 BYTE PTR [r9], r8b

; 1136 : }

  0005a	c3		 ret	 0
$LN1@get_native:

; 1132 :         return size;
; 1133 :     }
; 1134 : 
; 1135 :     return -1;

  0005b	48 83 c8 ff	 or	 rax, -1

; 1136 : }

  0005f	c3		 ret	 0
$LN19@get_native:
  00060	00 00 00 00	 DD	 $LN11@get_native
  00064	00 00 00 00	 DD	 $LN10@get_native
  00068	00 00 00 00	 DD	 $LN9@get_native
  0006c	00 00 00 00	 DD	 $LN2@get_native
  00070	00 00 00 00	 DD	 $LN1@get_native
$LN18@get_native:
  00074	00		 DB	 0
  00075	04		 DB	 4
  00076	04		 DB	 4
  00077	00		 DB	 0
  00078	04		 DB	 4
  00079	04		 DB	 4
  0007a	04		 DB	 4
  0007b	04		 DB	 4
  0007c	04		 DB	 4
  0007d	01		 DB	 1
  0007e	02		 DB	 2
  0007f	04		 DB	 4
  00080	04		 DB	 4
  00081	02		 DB	 2
  00082	04		 DB	 4
  00083	03		 DB	 3
  00084	04		 DB	 4
  00085	03		 DB	 3
  00086	03		 DB	 3
  00087	04		 DB	 4
  00088	04		 DB	 4
  00089	04		 DB	 4
  0008a	04		 DB	 4
  0008b	04		 DB	 4
  0008c	04		 DB	 4
  0008d	04		 DB	 4
  0008e	04		 DB	 4
  0008f	04		 DB	 4
  00090	04		 DB	 4
  00091	04		 DB	 4
  00092	04		 DB	 4
  00093	04		 DB	 4
  00094	04		 DB	 4
  00095	04		 DB	 4
  00096	04		 DB	 4
  00097	00		 DB	 0
  00098	00		 DB	 0
  00099	03		 DB	 3
  0009a	04		 DB	 4
  0009b	02		 DB	 2
  0009c	04		 DB	 4
  0009d	01		 DB	 1
  0009e	02		 DB	 2
  0009f	04		 DB	 4
  000a0	04		 DB	 4
  000a1	02		 DB	 2
  000a2	04		 DB	 4
  000a3	03		 DB	 3
  000a4	04		 DB	 4
  000a5	04		 DB	 4
  000a6	03		 DB	 3
get_native_fmtchar ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@ ; `string'
PUBLIC	??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@ ; `string'
PUBLIC	??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@ ; `string'
PUBLIC	??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@ ; `string'
EXTRN	__imp_strncpy:PROC
EXTRN	PyUnicode_AsASCIIString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cast_to_1D DD imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$cast_to_1D DD imagerel cast_to_1D+91
	DD	imagerel cast_to_1D+124
	DD	imagerel $chain$0$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$cast_to_1D DD imagerel cast_to_1D+124
	DD	imagerel cast_to_1D+198
	DD	imagerel $chain$3$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$cast_to_1D DD imagerel cast_to_1D+198
	DD	imagerel cast_to_1D+277
	DD	imagerel $chain$5$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$cast_to_1D DD imagerel cast_to_1D+277
	DD	imagerel cast_to_1D+341
	DD	imagerel $chain$7$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$cast_to_1D DD imagerel cast_to_1D+341
	DD	imagerel cast_to_1D+482
	DD	imagerel $chain$9$cast_to_1D
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$cast_to_1D DD imagerel cast_to_1D+482
	DD	imagerel cast_to_1D+571
	DD	imagerel $chain$10$cast_to_1D
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$cast_to_1D DD 021H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$cast_to_1D DD 040021H
	DD	0ac400H
	DD	096400H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$cast_to_1D DD 040021H
	DD	0ac400H
	DD	096400H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$cast_to_1D DD 040021H
	DD	0ac400H
	DD	096400H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$cast_to_1D DD 040e21H
	DD	0ac40eH
	DD	096400H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$cast_to_1D DD 020521H
	DD	096405H
	DD	imagerel cast_to_1D
	DD	imagerel cast_to_1D+91
	DD	imagerel $unwind$cast_to_1D
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cast_to_1D DD 040801H
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@
CONST	SEGMENT
??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@ DB 'memoryview:'
	DB	' source format must be a native single character format prefi'
	DB	'xed with an optional ''@''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@
CONST	SEGMENT
??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@ DB 'memoryview'
	DB	': length is not a multiple of itemsize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@
CONST	SEGMENT
??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@ DB 'memoryview:'
	DB	' cannot cast between two non-byte formats', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@
CONST	SEGMENT
??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@ DB 'memoryview: '
	DB	'destination format must be a native single character format p'
	DB	'refixed with an optional ''@''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT cast_to_1D
_TEXT	SEGMENT
destchar$ = 64
mv$ = 64
format$ = 72
cast_to_1D PROC						; COMDAT

; 1144 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1145 :     Py_buffer *view = &mv->view;
; 1146 :     PyObject *asciifmt;
; 1147 :     char srcchar, destchar;
; 1148 :     Py_ssize_t itemsize;
; 1149 :     int ret = -1;
; 1150 : 
; 1151 :     assert(view->ndim >= 1);
; 1152 :     assert(Py_SIZE(mv) == 3*view->ndim);
; 1153 :     assert(view->shape == mv->ob_array);
; 1154 :     assert(view->strides == mv->ob_array + view->ndim);
; 1155 :     assert(view->suboffsets == mv->ob_array + 2*view->ndim);
; 1156 : 
; 1157 :     if (get_native_fmtchar(&srcchar, view->format) < 0) {

  00008	4c 8b 81 b8 00
	00 00		 mov	 r8, QWORD PTR [rcx+184]
  0000f	83 cf ff	 or	 edi, -1
  00012	48 8b e9	 mov	 rbp, rcx
  00015	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  00019	75 03		 jne	 SHORT $LN21@cast_to_1D
  0001b	49 ff c0	 inc	 r8
$LN21@cast_to_1D:
  0001e	41 0f be 18	 movsx	 ebx, BYTE PTR [r8]
  00022	8d 43 c1	 lea	 eax, DWORD PTR [rbx-63]
  00025	83 f8 32	 cmp	 eax, 50			; 00000032H
  00028	0f 87 b4 01 00
	00		 ja	 $LN25@cast_to_1D
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00035	48 98		 cdqe
  00037	41 0f b6 84 01
	00 00 00 00	 movzx	 eax, BYTE PTR $LN26@cast_to_1D[r9+rax]
  00040	41 8b 8c 81 00
	00 00 00	 mov	 ecx, DWORD PTR $LN27@cast_to_1D[r9+rax*4]
  00048	49 03 c9	 add	 rcx, r9
  0004b	ff e1		 jmp	 rcx
$LN9@cast_to_1D:
  0004d	41 80 78 01 00	 cmp	 BYTE PTR [r8+1], 0
  00052	0f 85 8a 01 00
	00		 jne	 $LN25@cast_to_1D

; 1162 :     }
; 1163 : 
; 1164 :     asciifmt = PyUnicode_AsASCIIString(format);

  00058	48 8b ca	 mov	 rcx, rdx
  0005b	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00060	e8 00 00 00 00	 call	 PyUnicode_AsASCIIString
  00065	48 8b f0	 mov	 rsi, rax

; 1165 :     if (asciifmt == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 0f		 jne	 SHORT $LN4@cast_to_1D

; 1166 :         return ret;

  0006d	8b c7		 mov	 eax, edi
  0006f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1205 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	5d		 pop	 rbp
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
$LN4@cast_to_1D:

; 1167 : 
; 1168 :     itemsize = get_native_fmtchar(&destchar, PyBytes_AS_STRING(asciifmt));

  0007c	48 8d 50 78	 lea	 rdx, QWORD PTR [rax+120]
  00080	48 8d 4c 24 40	 lea	 rcx, QWORD PTR destchar$[rsp]
  00085	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0008a	e8 00 00 00 00	 call	 get_native_fmtchar
  0008f	4c 8b e0	 mov	 r12, rax

; 1169 :     if (itemsize < 0) {

  00092	48 85 c0	 test	 rax, rax
  00095	79 2f		 jns	 SHORT $LN3@cast_to_1D

; 1170 :         PyErr_SetString(PyExc_ValueError,
; 1171 :             "memoryview: destination format must be a native single "
; 1172 :             "character format prefixed with an optional '@'");

  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GG@FIIDFGEP@memoryview?3?5destination?5format?5m@
  000a5	e8 00 00 00 00	 call	 PyErr_SetString

; 1199 :  
; 1200 :     ret = 0;
; 1201 : 
; 1202 : out:
; 1203 :     Py_DECREF(asciifmt);

  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	e8 00 00 00 00	 call	 _Py_DecRef
  000b2	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  000b7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1204 :     return ret;

  000bc	8b c7		 mov	 eax, edi

; 1205 : }

  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	5b		 pop	 rbx
  000c5	c3		 ret	 0
$LN3@cast_to_1D:

; 1173 :         goto out;
; 1174 :     }
; 1175 : 
; 1176 :     if (!IS_BYTE_FORMAT(srcchar) && !IS_BYTE_FORMAT(destchar)) {

  000c6	80 fb 62	 cmp	 bl, 98			; 00000062H
  000c9	74 4a		 je	 SHORT $LN2@cast_to_1D
  000cb	80 fb 42	 cmp	 bl, 66			; 00000042H
  000ce	74 45		 je	 SHORT $LN2@cast_to_1D
  000d0	80 fb 63	 cmp	 bl, 99			; 00000063H
  000d3	74 40		 je	 SHORT $LN2@cast_to_1D
  000d5	0f b6 44 24 40	 movzx	 eax, BYTE PTR destchar$[rsp]
  000da	3c 62		 cmp	 al, 98			; 00000062H
  000dc	74 37		 je	 SHORT $LN2@cast_to_1D
  000de	3c 42		 cmp	 al, 66			; 00000042H
  000e0	74 33		 je	 SHORT $LN2@cast_to_1D
  000e2	3c 63		 cmp	 al, 99			; 00000063H
  000e4	74 2f		 je	 SHORT $LN2@cast_to_1D

; 1177 :         PyErr_SetString(PyExc_TypeError,
; 1178 :             "memoryview: cannot cast between two non-byte formats");

  000e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JMICJEHE@memoryview?3?5cannot?5cast?5between?5@
  000f4	e8 00 00 00 00	 call	 PyErr_SetString

; 1199 :  
; 1200 :     ret = 0;
; 1201 : 
; 1202 : out:
; 1203 :     Py_DECREF(asciifmt);

  000f9	48 8b ce	 mov	 rcx, rsi
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
  00101	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00106	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1204 :     return ret;

  0010b	8b c7		 mov	 eax, edi

; 1205 : }

  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	5f		 pop	 rdi
  00112	5d		 pop	 rbp
  00113	5b		 pop	 rbx
  00114	c3		 ret	 0
$LN2@cast_to_1D:

; 1179 :         goto out;
; 1180 :     }
; 1181 :     if (view->len % itemsize) {

  00115	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [rbp+160]
  0011c	48 99		 cdq
  0011e	49 f7 fc	 idiv	 r12
  00121	48 85 d2	 test	 rdx, rdx
  00124	74 2f		 je	 SHORT $LN1@cast_to_1D

; 1182 :         PyErr_SetString(PyExc_TypeError,
; 1183 :             "memoryview: length is not a multiple of itemsize");

  00126	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JEJCGHHM@memoryview?3?5length?5is?5not?5a?5mult@
  00134	e8 00 00 00 00	 call	 PyErr_SetString

; 1199 :  
; 1200 :     ret = 0;
; 1201 : 
; 1202 : out:
; 1203 :     Py_DECREF(asciifmt);

  00139	48 8b ce	 mov	 rcx, rsi
  0013c	e8 00 00 00 00	 call	 _Py_DecRef
  00141	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00146	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1204 :     return ret;

  0014b	8b c7		 mov	 eax, edi

; 1205 : }

  0014d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00151	5f		 pop	 rdi
  00152	5d		 pop	 rbp
  00153	5b		 pop	 rbx
  00154	c3		 ret	 0
$LN1@cast_to_1D:

; 1184 :         goto out;
; 1185 :     }
; 1186 : 
; 1187 :     strncpy(mv->format, PyBytes_AS_STRING(asciifmt),
; 1188 :             _Py_MEMORYVIEW_MAX_FORMAT);

  00155	48 8d 9d e0 00
	00 00		 lea	 rbx, QWORD PTR [rbp+224]
  0015c	48 8d 56 78	 lea	 rdx, QWORD PTR [rsi+120]
  00160	41 b8 03 00 00
	00		 mov	 r8d, 3
  00166	48 8b cb	 mov	 rcx, rbx
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 1189 :     mv->format[_Py_MEMORYVIEW_MAX_FORMAT-1] = '\0';

  0016f	c6 85 e2 00 00
	00 00		 mov	 BYTE PTR [rbp+226], 0

; 1190 :     view->format = mv->format;
; 1191 :     view->itemsize = itemsize;
; 1192 : 
; 1193 :     view->ndim = 1;
; 1194 :     view->shape[0] = view->len / view->itemsize;

  00176	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [rbp+160]
  0017d	48 8b 8d c0 00
	00 00		 mov	 rcx, QWORD PTR [rbp+192]
  00184	48 99		 cdq
  00186	4c 89 a5 a8 00
	00 00		 mov	 QWORD PTR [rbp+168], r12
  0018d	49 f7 fc	 idiv	 r12
  00190	48 89 9d b8 00
	00 00		 mov	 QWORD PTR [rbp+184], rbx
  00197	c7 85 b4 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rbp+180], 1

; 1195 :     view->strides[0] = view->itemsize;
; 1196 :     view->suboffsets = NULL;

  001a1	33 ff		 xor	 edi, edi
  001a3	48 89 01	 mov	 QWORD PTR [rcx], rax
  001a6	48 8b 8d c8 00
	00 00		 mov	 rcx, QWORD PTR [rbp+200]
  001ad	48 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR [rbp+168]
  001b4	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1197 : 
; 1198 :     init_flags(mv);

  001b7	48 8b cd	 mov	 rcx, rbp
  001ba	48 89 bd d0 00
	00 00		 mov	 QWORD PTR [rbp+208], rdi
  001c1	e8 00 00 00 00	 call	 init_flags

; 1199 :  
; 1200 :     ret = 0;
; 1201 : 
; 1202 : out:
; 1203 :     Py_DECREF(asciifmt);

  001c6	48 8b ce	 mov	 rcx, rsi
$out$20940:
  001c9	e8 00 00 00 00	 call	 _Py_DecRef
  001ce	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  001d3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 1204 :     return ret;

  001d8	8b c7		 mov	 eax, edi

; 1205 : }

  001da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001de	5f		 pop	 rdi
  001df	5d		 pop	 rbp
  001e0	5b		 pop	 rbx
  001e1	c3		 ret	 0
$LN25@cast_to_1D:

; 1158 :         PyErr_SetString(PyExc_ValueError,
; 1159 :             "memoryview: source format must be a native single character "
; 1160 :             "format prefixed with an optional '@'");

  001e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GB@NACJPCHP@memoryview?3?5source?5format?5must?5b@
  001f0	e8 00 00 00 00	 call	 PyErr_SetString

; 1161 :         return ret;

  001f5	8b c7		 mov	 eax, edi

; 1205 : }

  001f7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001fb	5f		 pop	 rdi
  001fc	5d		 pop	 rbp
  001fd	5b		 pop	 rbx
  001fe	c3		 ret	 0
  001ff	90		 npad	 1
$LN27@cast_to_1D:
  00200	00 00 00 00	 DD	 $LN9@cast_to_1D
  00204	00 00 00 00	 DD	 $LN25@cast_to_1D
$LN26@cast_to_1D:
  00208	00		 DB	 0
  00209	01		 DB	 1
  0020a	01		 DB	 1
  0020b	00		 DB	 0
  0020c	01		 DB	 1
  0020d	01		 DB	 1
  0020e	01		 DB	 1
  0020f	01		 DB	 1
  00210	01		 DB	 1
  00211	00		 DB	 0
  00212	00		 DB	 0
  00213	01		 DB	 1
  00214	01		 DB	 1
  00215	00		 DB	 0
  00216	01		 DB	 1
  00217	00		 DB	 0
  00218	01		 DB	 1
  00219	00		 DB	 0
  0021a	00		 DB	 0
  0021b	01		 DB	 1
  0021c	01		 DB	 1
  0021d	01		 DB	 1
  0021e	01		 DB	 1
  0021f	01		 DB	 1
  00220	01		 DB	 1
  00221	01		 DB	 1
  00222	01		 DB	 1
  00223	01		 DB	 1
  00224	01		 DB	 1
  00225	01		 DB	 1
  00226	01		 DB	 1
  00227	01		 DB	 1
  00228	01		 DB	 1
  00229	01		 DB	 1
  0022a	01		 DB	 1
  0022b	00		 DB	 0
  0022c	00		 DB	 0
  0022d	00		 DB	 0
  0022e	01		 DB	 1
  0022f	00		 DB	 0
  00230	01		 DB	 1
  00231	00		 DB	 0
  00232	00		 DB	 0
  00233	01		 DB	 1
  00234	01		 DB	 1
  00235	00		 DB	 0
  00236	01		 DB	 1
  00237	00		 DB	 0
  00238	01		 DB	 1
  00239	01		 DB	 1
  0023a	00		 DB	 0
cast_to_1D ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ ; `string'
PUBLIC	??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ ; `string'
PUBLIC	??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@ ; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$copy_shape DD imagerel copy_shape
	DD	imagerel copy_shape+283
	DD	imagerel $unwind$copy_shape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$copy_shape DD 0c1c01H
	DD	0c641cH
	DD	0b541cH
	DD	0a341cH
	DD	0f018321cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
CONST	SEGMENT
??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ DB 'memor'
	DB	'yview.cast(): elements of shape must be integers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
CONST	SEGMENT
??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@ DB 'memor'
	DB	'yview.cast(): elements of shape must be integers > 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@
CONST	SEGMENT
??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@ DB 'memo'
	DB	'ryview.cast(): product(shape) > SSIZE_MAX', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT copy_shape
_TEXT	SEGMENT
shape$ = 80
seq$ = 88
ndim$ = 96
itemsize$ = 104
copy_shape PROC						; COMDAT

; 1211 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1212 :     Py_ssize_t x, i;
; 1213 :     Py_ssize_t len = itemsize;
; 1214 : 
; 1215 :     for (i = 0; i < ndim; i++) {

  0001c	33 f6		 xor	 esi, esi
  0001e	49 8b f9	 mov	 rdi, r9
  00021	4d 8b e0	 mov	 r12, r8
  00024	48 8b ea	 mov	 rbp, rdx
  00027	48 8b d9	 mov	 rbx, rcx
  0002a	4d 85 c0	 test	 r8, r8
  0002d	0f 8e 83 00 00
	00		 jle	 $LN5@copy_shape
  00033	4c 8b ea	 mov	 r13, rdx
  00036	4c 8b f1	 mov	 r14, rcx
  00039	49 bf ff ff ff
	ff ff ff ff 7f	 mov	 r15, 9223372036854775807 ; 7fffffffffffffffH
  00043	4c 2b e9	 sub	 r13, rcx
  00046	49 f7 de	 neg	 r14
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@copy_shape:

; 1216 :         PyObject *tmp = PySequence_Fast_GET_ITEM(seq, i);

  00050	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00054	f7 80 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rax+256], 33554432 ; 02000000H
  0005e	74 0e		 je	 SHORT $LN10@copy_shape
  00060	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00064	49 8d 0c 06	 lea	 rcx, QWORD PTR [r14+rax]
  00068	48 8b 0c 19	 mov	 rcx, QWORD PTR [rcx+rbx]
  0006c	eb 05		 jmp	 SHORT $LN11@copy_shape
$LN10@copy_shape:
  0006e	49 8b 4c 1d 70	 mov	 rcx, QWORD PTR [r13+rbx+112]
$LN11@copy_shape:

; 1217 :         if (!PyLong_Check(tmp)) {

  00073	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00077	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00081	74 7f		 je	 SHORT $LN13@copy_shape

; 1221 :         }
; 1222 :         x = PyLong_AsSsize_t(tmp);

  00083	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00088	4c 8b d8	 mov	 r11, rax

; 1223 :         if (x == -1 && PyErr_Occurred()) {

  0008b	48 83 f8 ff	 cmp	 rax, -1
  0008f	74 4e		 je	 SHORT $LN18@copy_shape

; 1224 :             return -1;
; 1225 :         }
; 1226 :         if (x <= 0) {

  00091	48 85 c0	 test	 rax, rax
  00094	7e 53		 jle	 SHORT $LN15@copy_shape

; 1231 :         }
; 1232 :         if (x > PY_SSIZE_T_MAX / len) {

  00096	49 8b c7	 mov	 rax, r15
  00099	48 99		 cdq
  0009b	48 f7 ff	 idiv	 rdi
  0009e	4c 3b d8	 cmp	 r11, rax
  000a1	7f 33		 jg	 SHORT $LN16@copy_shape

; 1236 :         }
; 1237 :         len *= x;
; 1238 :         shape[i] = x;

  000a3	48 ff c6	 inc	 rsi
  000a6	4c 89 1b	 mov	 QWORD PTR [rbx], r11
  000a9	49 0f af fb	 imul	 rdi, r11
  000ad	48 83 c3 08	 add	 rbx, 8
  000b1	49 3b f4	 cmp	 rsi, r12
  000b4	7c 9a		 jl	 SHORT $LL7@copy_shape
$LN5@copy_shape:

; 1239 :     }
; 1240 : 
; 1241 :     return len;

  000b6	48 8b c7	 mov	 rax, rdi
$LN8@copy_shape:

; 1242 : }

  000b9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000be	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000c3	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	41 5f		 pop	 r15
  000ce	41 5e		 pop	 r14
  000d0	41 5d		 pop	 r13
  000d2	41 5c		 pop	 r12
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
$LN16@copy_shape:

; 1233 :             PyErr_Format(PyExc_ValueError,
; 1234 :                 "memoryview.cast(): product(shape) > SSIZE_MAX");

  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@DCMKEPPB@memoryview?4cast?$CI?$CJ?3?5product?$CIshape@

; 1235 :             return -1;

  000dd	eb 11		 jmp	 SHORT $LN20@copy_shape
$LN18@copy_shape:

; 1223 :         if (x == -1 && PyErr_Occurred()) {

  000df	e8 00 00 00 00	 call	 PyErr_Occurred
  000e4	48 85 c0	 test	 rax, rax
  000e7	75 2c		 jne	 SHORT $LN14@copy_shape
$LN15@copy_shape:

; 1227 :             /* In general elements of shape may be 0, but not for casting. */
; 1228 :             PyErr_Format(PyExc_ValueError,
; 1229 :                 "memoryview.cast(): elements of shape must be integers > 0");

  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@LAONIDJE@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
$LN20@copy_shape:
  000f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f7	e8 00 00 00 00	 call	 PyErr_Format

; 1230 :             return -1;

  000fc	48 83 c8 ff	 or	 rax, -1
  00100	eb b7		 jmp	 SHORT $LN8@copy_shape
$LN13@copy_shape:

; 1218 :             PyErr_SetString(PyExc_TypeError,
; 1219 :                 "memoryview.cast(): elements of shape must be integers");

  00102	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@HHOGHKMK@memoryview?4cast?$CI?$CJ?3?5elements?5of?5s@
  00110	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@copy_shape:

; 1220 :             return -1;

  00115	48 83 c8 ff	 or	 rax, -1
  00119	eb 9e		 jmp	 SHORT $LN8@copy_shape
copy_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cast_to_ND DD imagerel cast_to_ND
	DD	imagerel cast_to_ND+200
	DD	imagerel $unwind$cast_to_ND
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cast_to_ND DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@
CONST	SEGMENT
??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@ DB 'mem'
	DB	'oryview: product(shape) * itemsize != buffer size', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT cast_to_ND
_TEXT	SEGMENT
mv$ = 48
shape$ = 56
ndim$ = 64
cast_to_ND PROC						; COMDAT

; 1249 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1263 :         len = view->itemsize;

  00006	4c 8b 89 a8 00
	00 00		 mov	 r9, QWORD PTR [rcx+168]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	44 89 81 b4 00
	00 00		 mov	 DWORD PTR [rcx+180], r8d
  00017	45 85 c0	 test	 r8d, r8d
  0001a	75 12		 jne	 SHORT $LN4@cast_to_ND

; 1250 :     Py_buffer *view = &mv->view;
; 1251 :     Py_ssize_t len;
; 1252 : 
; 1253 :     assert(view->ndim == 1); /* ndim from cast_to_1D() */
; 1254 :     assert(Py_SIZE(mv) == 3*(ndim==0?1:ndim)); /* ndim of result array */
; 1255 :     assert(view->shape == mv->ob_array);
; 1256 :     assert(view->strides == mv->ob_array + (ndim==0?1:ndim));
; 1257 :     assert(view->suboffsets == NULL);
; 1258 : 
; 1259 :     view->ndim = ndim;
; 1260 :     if (view->ndim == 0) {
; 1261 :         view->shape = NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1262 :         view->strides = NULL;

  00025	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1264 :     }
; 1265 :     else {

  0002c	eb 65		 jmp	 SHORT $LN7@cast_to_ND
$LN4@cast_to_ND:

; 1266 :         len = copy_shape(view->shape, shape, ndim, view->itemsize);

  0002e	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00035	4d 63 c0	 movsxd	 r8, r8d
  00038	e8 00 00 00 00	 call	 copy_shape
  0003d	4c 8b c8	 mov	 r9, rax

; 1267 :         if (len < 0)

  00040	48 85 c0	 test	 rax, rax

; 1268 :             return -1;

  00043	78 6a		 js	 SHORT $LN14@cast_to_ND

; 1269 :         init_strides_from_shape(view);

  00045	48 8b 83 a8 00
	00 00		 mov	 rax, QWORD PTR [rbx+168]
  0004c	48 63 93 b4 00
	00 00		 movsxd	 rdx, DWORD PTR [rbx+180]
  00053	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  0005a	48 89 44 d1 f8	 mov	 QWORD PTR [rcx+rdx*8-8], rax
  0005f	8b 83 b4 00 00
	00		 mov	 eax, DWORD PTR [rbx+180]
  00065	83 e8 02	 sub	 eax, 2
  00068	4c 63 c0	 movsxd	 r8, eax
  0006b	78 26		 js	 SHORT $LN7@cast_to_ND
  0006d	0f 1f 00	 npad	 3
$LL9@cast_to_ND:
  00070	48 8b 83 c0 00
	00 00		 mov	 rax, QWORD PTR [rbx+192]
  00077	48 8b 93 c8 00
	00 00		 mov	 rdx, QWORD PTR [rbx+200]
  0007e	4a 8b 4c c0 08	 mov	 rcx, QWORD PTR [rax+r8*8+8]
  00083	4a 0f af 4c c2
	08		 imul	 rcx, QWORD PTR [rdx+r8*8+8]
  00089	49 ff c8	 dec	 r8
  0008c	4a 89 4c c2 08	 mov	 QWORD PTR [rdx+r8*8+8], rcx
  00091	79 dd		 jns	 SHORT $LL9@cast_to_ND
$LN7@cast_to_ND:

; 1270 :     }
; 1271 : 
; 1272 :     if (view->len != len) {

  00093	4c 39 8b a0 00
	00 00		 cmp	 QWORD PTR [rbx+160], r9
  0009a	74 1c		 je	 SHORT $LN1@cast_to_ND

; 1273 :         PyErr_SetString(PyExc_TypeError,
; 1274 :             "memoryview: product(shape) * itemsize != buffer size");

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GLJFEKGA@memoryview?3?5product?$CIshape?$CJ?5?$CK?5ite@
  000aa	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@cast_to_ND:

; 1275 :         return -1;

  000af	83 c8 ff	 or	 eax, -1

; 1281 : }

  000b2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b6	5b		 pop	 rbx
  000b7	c3		 ret	 0
$LN1@cast_to_ND:

; 1276 :     }
; 1277 : 
; 1278 :     init_flags(mv);

  000b8	48 8b cb	 mov	 rcx, rbx
  000bb	e8 00 00 00 00	 call	 init_flags

; 1279 : 
; 1280 :     return 0;

  000c0	33 c0		 xor	 eax, eax

; 1281 : }

  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5b		 pop	 rbx
  000c7	c3		 ret	 0
cast_to_ND ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT zero_in_shape
_TEXT	SEGMENT
mv$ = 8
zero_in_shape PROC					; COMDAT

; 1287 :     Py_ssize_t i;
; 1288 : 
; 1289 :     for (i = 0; i < view->ndim; i++)

  00000	4c 63 81 b4 00
	00 00		 movsxd	 r8, DWORD PTR [rcx+180]
  00007	33 d2		 xor	 edx, edx
  00009	4d 85 c0	 test	 r8, r8
  0000c	7e 19		 jle	 SHORT $LN2@zero_in_sh

; 1286 :     Py_buffer *view = &mv->view;

  0000e	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
$LL4@zero_in_sh:

; 1290 :         if (view->shape[i] == 0)

  00015	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00019	74 0f		 je	 SHORT $LN8@zero_in_sh

; 1287 :     Py_ssize_t i;
; 1288 : 
; 1289 :     for (i = 0; i < view->ndim; i++)

  0001b	48 ff c2	 inc	 rdx
  0001e	48 83 c0 08	 add	 rax, 8
  00022	49 3b d0	 cmp	 rdx, r8
  00025	7c ee		 jl	 SHORT $LL4@zero_in_sh
$LN2@zero_in_sh:

; 1292 : 
; 1293 :     return 0;

  00027	33 c0		 xor	 eax, eax

; 1294 : }

  00029	c3		 ret	 0
$LN8@zero_in_sh:

; 1291 :             return 1;

  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1294 : }

  0002f	c3		 ret	 0
zero_in_shape ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@ ; `string'
PUBLIC	??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@ ; `string'
PUBLIC	??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@ ; `string'
PUBLIC	??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@ ; `string'
PUBLIC	??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@ ; `string'
PUBLIC	??_C@_03DHMGKKHG@O?$HMO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_cast DD imagerel memory_cast
	DD	imagerel memory_cast+502
	DD	imagerel $unwind$memory_cast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_cast DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@
CONST	SEGMENT
??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@ DB 'memor'
	DB	'yview: cast must be 1D -> ND or ND -> 1D', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@ DB 'shape '
	DB	'must be a list or a tuple', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@
CONST	SEGMENT
??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@ DB 'memoryview:'
	DB	' cannot cast view with zeros in shape or strides', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@
CONST	SEGMENT
??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@ DB 'memoryview: '
	DB	'casts are restricted to C-contiguous views', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@
CONST	SEGMENT
??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@ DB 'memoryview: '
	DB	'format argument must be a string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DHMGKKHG@O?$HMO?$AA@
CONST	SEGMENT
??_C@_03DHMGKKHG@O?$HMO?$AA@ DB 'O|O', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_cast
_TEXT	SEGMENT
shape$ = 64
self$ = 64
args$ = 72
kwds$ = 80
format$ = 88
memory_cast PROC					; COMDAT

; 1310 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1311 :     static char *kwlist[] = {"format", "shape", NULL};
; 1312 :     PyMemoryViewObject *mv = NULL;
; 1313 :     PyObject *shape = NULL;
; 1314 :     PyObject *format;
; 1315 :     Py_ssize_t ndim = 1;

  0000f	be 01 00 00 00	 mov	 esi, 1
  00014	4d 8b d0	 mov	 r10, r8
  00017	4c 8b da	 mov	 r11, rdx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR shape$[rsp], 0
  00026	8b fe		 mov	 edi, esi

; 1316 : 
; 1317 :     CHECK_RELEASED(self);

  00028	40 84 b1 80 00
	00 00		 test	 BYTE PTR [rcx+128], sil
  0002f	0f 85 9c 01 00
	00		 jne	 $LN13@memory_cas
  00035	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00039	40 84 70 60	 test	 BYTE PTR [rax+96], sil
  0003d	0f 85 8e 01 00
	00		 jne	 $LN13@memory_cas

; 1318 : 
; 1319 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O", kwlist,
; 1320 :                                      &format, &shape)) {

  00043	48 8d 44 24 40	 lea	 rax, QWORD PTR shape$[rsp]
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??memory_cast@@9@9
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03DHMGKKHG@O?$HMO?$AA@
  00056	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005b	48 8d 44 24 58	 lea	 rax, QWORD PTR format$[rsp]
  00060	49 8b d2	 mov	 rdx, r10
  00063	49 8b cb	 mov	 rcx, r11
  00066	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00070	85 c0		 test	 eax, eax

; 1321 :         return NULL;

  00072	0f 84 6c 01 00
	00		 je	 $LN19@memory_cas

; 1322 :     }
; 1323 :     if (!PyUnicode_Check(format)) {

  00078	48 8b 44 24 58	 mov	 rax, QWORD PTR format$[rsp]
  0007d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00081	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  0008b	75 13		 jne	 SHORT $LN11@memory_cas

; 1324 :         PyErr_SetString(PyExc_TypeError,
; 1325 :             "memoryview: format argument must be a string");

  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@JOOFLLJP@memoryview?3?5format?5argument?5must@

; 1326 :         return NULL;

  0009b	e9 3f 01 00 00	 jmp	 $LN20@memory_cas
$LN11@memory_cas:

; 1327 :     }
; 1328 :     if (!MV_C_CONTIGUOUS(self->flags)) {

  000a0	f6 83 80 00 00
	00 0a		 test	 BYTE PTR [rbx+128], 10
  000a7	75 13		 jne	 SHORT $LN10@memory_cas

; 1329 :         PyErr_SetString(PyExc_TypeError,
; 1330 :             "memoryview: casts are restricted to C-contiguous views");

  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@NNCKOAHO@memoryview?3?5casts?5are?5restricted@

; 1331 :         return NULL;

  000b7	e9 23 01 00 00	 jmp	 $LN20@memory_cas
$LN10@memory_cas:

; 1332 :     }
; 1333 :     if ((shape || self->view.ndim != 1) && zero_in_shape(self)) {

  000bc	4c 8b 4c 24 40	 mov	 r9, QWORD PTR shape$[rsp]
  000c1	4d 85 c9	 test	 r9, r9
  000c4	75 0c		 jne	 SHORT $LN8@memory_cas
  000c6	39 b3 b4 00 00
	00		 cmp	 DWORD PTR [rbx+180], esi
  000cc	0f 84 86 00 00
	00		 je	 $LN4@memory_cas
$LN8@memory_cas:
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 zero_in_shape
  000da	85 c0		 test	 eax, eax
  000dc	74 13		 je	 SHORT $LN9@memory_cas

; 1334 :         PyErr_SetString(PyExc_TypeError,
; 1335 :             "memoryview: cannot cast view with zeros in shape or strides");

  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@HAJAMMBA@memoryview?3?5cannot?5cast?5view?5wit@

; 1336 :         return NULL;

  000ec	e9 ee 00 00 00	 jmp	 $LN20@memory_cas
$LN9@memory_cas:

; 1337 :     }
; 1338 :     if (shape) {

  000f1	4d 85 c9	 test	 r9, r9
  000f4	74 62		 je	 SHORT $LN4@memory_cas

; 1339 :         CHECK_LIST_OR_TUPLE(shape)

  000f6	49 8b 41 58	 mov	 rax, QWORD PTR [r9+88]
  000fa	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00100	8b c1		 mov	 eax, ecx
  00102	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00107	75 19		 jne	 SHORT $LN6@memory_cas
  00109	0f ba e1 1a	 bt	 ecx, 26
  0010d	72 13		 jb	 SHORT $LN6@memory_cas
  0010f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@IAOMAELM@shape?5must?5be?5a?5list?5or?5a?5tuple?$AA@
  0011d	e9 bd 00 00 00	 jmp	 $LN20@memory_cas
$LN6@memory_cas:

; 1340 :         ndim = PySequence_Fast_GET_SIZE(shape);

  00122	49 8b 79 60	 mov	 rdi, QWORD PTR [r9+96]

; 1341 :         if (ndim > PyBUF_MAX_NDIM) {

  00126	48 83 ff 40	 cmp	 rdi, 64			; 00000040H
  0012a	7e 0c		 jle	 SHORT $LN5@memory_cas

; 1342 :             PyErr_SetString(PyExc_ValueError,
; 1343 :                 "memoryview: number of dimensions must not exceed "
; 1344 :                 STRINGIZE(PyBUF_MAX_NDIM));

  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EHEPBPHJ@memoryview?3?5number?5of?5dimensions@

; 1345 :             return NULL;

  00133	e9 a0 00 00 00	 jmp	 $LN21@memory_cas
$LN5@memory_cas:

; 1346 :         }
; 1347 :         if (self->view.ndim != 1 && ndim != 1) {

  00138	39 b3 b4 00 00
	00		 cmp	 DWORD PTR [rbx+180], esi
  0013e	74 18		 je	 SHORT $LN4@memory_cas
  00140	48 3b fe	 cmp	 rdi, rsi
  00143	74 13		 je	 SHORT $LN4@memory_cas

; 1348 :             PyErr_SetString(PyExc_TypeError,
; 1349 :                 "memoryview: cast must be 1D -> ND or ND -> 1D");

  00145	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KMHJIFPP@memoryview?3?5cast?5must?5be?51D?5?9?$DO?5N@

; 1350 :             return NULL;

  00153	e9 87 00 00 00	 jmp	 $LN20@memory_cas
$LN4@memory_cas:

; 1351 :         }
; 1352 :     }
; 1353 : 
; 1354 :     mv = (PyMemoryViewObject *)
; 1355 :         mbuf_add_incomplete_view(self->mbuf, &self->view, ndim==0 ? 1 : (int)ndim);

  00158	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0015c	44 8b c7	 mov	 r8d, edi
  0015f	48 85 ff	 test	 rdi, rdi
  00162	48 8d 93 90 00
	00 00		 lea	 rdx, QWORD PTR [rbx+144]
  00169	44 0f 44 c6	 cmove	 r8d, esi
  0016d	e8 00 00 00 00	 call	 mbuf_add_incomplete_view
  00172	48 8b d8	 mov	 rbx, rax

; 1356 :     if (mv == NULL)

  00175	48 85 c0	 test	 rax, rax

; 1357 :         return NULL;

  00178	74 6a		 je	 SHORT $LN19@memory_cas

; 1358 : 
; 1359 :     if (cast_to_1D(mv, format) < 0)

  0017a	48 8b 54 24 58	 mov	 rdx, QWORD PTR format$[rsp]
  0017f	48 8b c8	 mov	 rcx, rax
  00182	e8 00 00 00 00	 call	 cast_to_1D
  00187	85 c0		 test	 eax, eax
  00189	78 2c		 js	 SHORT $error$21069

; 1360 :         goto error;
; 1361 :     if (shape && cast_to_ND(mv, shape, (int)ndim) < 0)

  0018b	48 8b 54 24 40	 mov	 rdx, QWORD PTR shape$[rsp]
  00190	48 85 d2	 test	 rdx, rdx
  00193	74 0f		 je	 SHORT $LN1@memory_cas
  00195	44 8b c7	 mov	 r8d, edi
  00198	48 8b cb	 mov	 rcx, rbx
  0019b	e8 00 00 00 00	 call	 cast_to_ND
  001a0	85 c0		 test	 eax, eax
  001a2	78 13		 js	 SHORT $error$21069
$LN1@memory_cas:

; 1362 :         goto error;
; 1363 : 
; 1364 :     return (PyObject *)mv;

  001a4	48 8b c3	 mov	 rax, rbx

; 1368 :     return NULL;
; 1369 : }

  001a7	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001ac	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b5	5f		 pop	 rdi
  001b6	c3		 ret	 0
$error$21069:

; 1365 : 
; 1366 : error:
; 1367 :     Py_DECREF(mv);

  001b7	48 8b cb	 mov	 rcx, rbx
  001ba	e8 00 00 00 00	 call	 _Py_DecRef
  001bf	33 c0		 xor	 eax, eax

; 1368 :     return NULL;
; 1369 : }

  001c1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001c6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001cf	5f		 pop	 rdi
  001d0	c3		 ret	 0
$LN13@memory_cas:

; 1316 : 
; 1317 :     CHECK_RELEASED(self);

  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
$LN21@memory_cas:
  001d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
$LN20@memory_cas:
  001df	e8 00 00 00 00	 call	 PyErr_SetString
$LN19@memory_cas:

; 1368 :     return NULL;
; 1369 : }

  001e4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001e9	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001ee	33 c0		 xor	 eax, eax
  001f0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f4	5f		 pop	 rdi
  001f5	c3		 ret	 0
memory_cast ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@ ; `string'
PUBLIC	??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@ ; `string'
PUBLIC	??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@ ; `string'
PUBLIC	??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_getbuf DD imagerel memory_getbuf
	DD	imagerel memory_getbuf+414
	DD	imagerel $unwind$memory_getbuf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_getbuf DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@
CONST	SEGMENT
??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@ DB 'memoryview:'
	DB	' cannot cast to unsigned bytes if the format flag is present', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@
CONST	SEGMENT
??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@ DB 'memoryview: un'
	DB	'derlying buffer requires suboffsets', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not Fortran contiguous', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not C-contiguous', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@
CONST	SEGMENT
??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@ DB 'memoryview: '
	DB	'underlying buffer is not writable', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_getbuf
_TEXT	SEGMENT
self$ = 48
view$ = 56
flags$ = 64
memory_getbuf PROC					; COMDAT

; 1378 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1379 :     Py_buffer *base = &self->view;
; 1380 :     int baseflags = self->flags;

  0001a	8b a9 80 00 00
	00		 mov	 ebp, DWORD PTR [rcx+128]
  00020	41 8b f8	 mov	 edi, r8d
  00023	48 8b da	 mov	 rbx, rdx
  00026	48 8b f1	 mov	 rsi, rcx

; 1381 : 
; 1382 :     CHECK_RELEASED_INT(self);

  00029	40 f6 c5 01	 test	 bpl, 1
  0002d	0f 85 3a 01 00
	00		 jne	 $LN11@memory_get
  00033	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00037	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0003b	0f 85 2c 01 00
	00		 jne	 $LN11@memory_get

; 1383 : 
; 1384 :     /* start with complete information */
; 1385 :     *view = *base;

  00041	48 8b ca	 mov	 rcx, rdx
  00044	48 8d 96 90 00
	00 00		 lea	 rdx, QWORD PTR [rsi+144]
  0004b	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00051	e8 00 00 00 00	 call	 memcpy

; 1386 :     view->obj = NULL;

  00056	33 c9		 xor	 ecx, ecx
  00058	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 1387 : 
; 1388 :     if (REQ_WRITABLE(flags) && base->readonly) {

  0005c	40 f6 c7 01	 test	 dil, 1
  00060	74 1b		 je	 SHORT $LN10@memory_get
  00062	39 8e b0 00 00
	00		 cmp	 DWORD PTR [rsi+176], ecx
  00068	74 13		 je	 SHORT $LN10@memory_get

; 1389 :         PyErr_SetString(PyExc_BufferError,
; 1390 :             "memoryview: underlying buffer is not writable");

  0006a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@BMACNGDB@memoryview?3?5underlying?5buffer?5is@

; 1391 :         return -1;

  00078	e9 fe 00 00 00	 jmp	 $LN15@memory_get
$LN10@memory_get:

; 1392 :     }
; 1393 :     if (!REQ_FORMAT(flags)) {

  0007d	40 f6 c7 04	 test	 dil, 4
  00081	75 04		 jne	 SHORT $LN9@memory_get

; 1394 :         /* NULL indicates that the buffer's data type has been cast to 'B'.
; 1395 :            view->itemsize is the _previous_ itemsize. If shape is present,
; 1396 :            the equality product(shape) * itemsize = len still holds at this
; 1397 :            point. The equality calcsize(format) = itemsize does _not_ hold
; 1398 :            from here on! */
; 1399 :         view->format = NULL;

  00083	48 89 4b 28	 mov	 QWORD PTR [rbx+40], rcx
$LN9@memory_get:

; 1400 :     }
; 1401 : 
; 1402 :     if (REQ_C_CONTIGUOUS(flags) && !MV_C_CONTIGUOUS(baseflags)) {

  00087	8b c7		 mov	 eax, edi
  00089	83 e0 38	 and	 eax, 56			; 00000038H
  0008c	3c 38		 cmp	 al, 56			; 00000038H
  0008e	75 19		 jne	 SHORT $LN8@memory_get
  00090	40 f6 c5 0a	 test	 bpl, 10
  00094	75 13		 jne	 SHORT $LN8@memory_get
$LN17@memory_get:

; 1403 :         PyErr_SetString(PyExc_BufferError,
; 1404 :             "memoryview: underlying buffer is not C-contiguous");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@CNKIPJGB@memoryview?3?5underlying?5buffer?5is@

; 1405 :         return -1;

  000a4	e9 d2 00 00 00	 jmp	 $LN15@memory_get
$LN8@memory_get:

; 1406 :     }
; 1407 :     if (REQ_F_CONTIGUOUS(flags) && !MV_F_CONTIGUOUS(baseflags)) {

  000a9	8b c7		 mov	 eax, edi
  000ab	83 e0 58	 and	 eax, 88			; 00000058H
  000ae	3c 58		 cmp	 al, 88			; 00000058H
  000b0	75 19		 jne	 SHORT $LN7@memory_get
  000b2	40 f6 c5 0c	 test	 bpl, 12
  000b6	75 13		 jne	 SHORT $LN7@memory_get

; 1408 :         PyErr_SetString(PyExc_BufferError,
; 1409 :             "memoryview: underlying buffer is not Fortran contiguous");

  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@CEIDACMO@memoryview?3?5underlying?5buffer?5is@

; 1410 :         return -1;

  000c6	e9 b0 00 00 00	 jmp	 $LN15@memory_get
$LN7@memory_get:

; 1411 :     }
; 1412 :     if (REQ_ANY_CONTIGUOUS(flags) && !MV_ANY_CONTIGUOUS(baseflags)) {

  000cb	8b c7		 mov	 eax, edi
  000cd	25 98 00 00 00	 and	 eax, 152		; 00000098H
  000d2	3c 98		 cmp	 al, -104		; ffffffffffffff98H
  000d4	75 19		 jne	 SHORT $LN6@memory_get
  000d6	40 f6 c5 0e	 test	 bpl, 14
  000da	75 13		 jne	 SHORT $LN6@memory_get

; 1413 :         PyErr_SetString(PyExc_BufferError,
; 1414 :             "memoryview: underlying buffer is not contiguous");

  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@DGLEPGEE@memoryview?3?5underlying?5buffer?5is@

; 1415 :         return -1;

  000ea	e9 8c 00 00 00	 jmp	 $LN15@memory_get
$LN6@memory_get:

; 1416 :     }
; 1417 :     if (!REQ_INDIRECT(flags) && (baseflags & _Py_MEMORYVIEW_PIL)) {

  000ef	8b c7		 mov	 eax, edi
  000f1	25 18 01 00 00	 and	 eax, 280		; 00000118H
  000f6	3d 18 01 00 00	 cmp	 eax, 280		; 00000118H
  000fb	74 16		 je	 SHORT $LN5@memory_get
  000fd	40 f6 c5 10	 test	 bpl, 16
  00101	74 10		 je	 SHORT $LN5@memory_get

; 1418 :         PyErr_SetString(PyExc_BufferError,
; 1419 :             "memoryview: underlying buffer requires suboffsets");

  00103	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DGPBKM@memoryview?3?5underlying?5buffer?5re@

; 1420 :         return -1;

  00111	eb 68		 jmp	 SHORT $LN15@memory_get
$LN5@memory_get:

; 1421 :     }
; 1422 :     if (!REQ_STRIDES(flags)) {

  00113	8b c7		 mov	 eax, edi
  00115	83 e0 18	 and	 eax, 24
  00118	3c 18		 cmp	 al, 24
  0011a	74 0e		 je	 SHORT $LN4@memory_get

; 1423 :         if (!MV_C_CONTIGUOUS(baseflags)) {

  0011c	40 f6 c5 0a	 test	 bpl, 10

; 1424 :             PyErr_SetString(PyExc_BufferError,
; 1425 :                 "memoryview: underlying buffer is not C-contiguous");
; 1426 :             return -1;

  00120	0f 84 70 ff ff
	ff		 je	 $LN17@memory_get

; 1427 :         }
; 1428 :         view->strides = NULL;

  00126	48 89 4b 38	 mov	 QWORD PTR [rbx+56], rcx
$LN4@memory_get:

; 1429 :     }
; 1430 :     if (!REQ_SHAPE(flags)) {

  0012a	40 f6 c7 08	 test	 dil, 8
  0012e	75 26		 jne	 SHORT $LN2@memory_get

; 1431 :         /* PyBUF_SIMPLE or PyBUF_WRITABLE: at this point buf is C-contiguous,
; 1432 :            so base->buf = ndbuf->data. */
; 1433 :         if (view->format != NULL) {

  00130	48 39 4b 28	 cmp	 QWORD PTR [rbx+40], rcx
  00134	74 15		 je	 SHORT $LN1@memory_get

; 1434 :             /* PyBUF_SIMPLE|PyBUF_FORMAT and PyBUF_WRITABLE|PyBUF_FORMAT do
; 1435 :                not make sense. */
; 1436 :             PyErr_Format(PyExc_BufferError,
; 1437 :                 "memoryview: cannot cast to unsigned bytes if the format flag "
; 1438 :                 "is present");

  00136	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EI@IFFNMBMI@memoryview?3?5cannot?5cast?5to?5unsig@
  00144	e8 00 00 00 00	 call	 PyErr_Format

; 1439 :             return -1;

  00149	eb 35		 jmp	 SHORT $LN16@memory_get
$LN1@memory_get:

; 1440 :         }
; 1441 :         /* product(shape) * itemsize = len and calcsize(format) = itemsize
; 1442 :            do _not_ hold from here on! */
; 1443 :         view->ndim = 1;

  0014b	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1

; 1444 :         view->shape = NULL;

  00152	48 89 4b 30	 mov	 QWORD PTR [rbx+48], rcx
$LN2@memory_get:

; 1445 :     }
; 1446 : 
; 1447 : 
; 1448 :     view->obj = (PyObject *)self;
; 1449 :     Py_INCREF(view->obj);

  00156	48 8b ce	 mov	 rcx, rsi
  00159	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi
  0015d	e8 00 00 00 00	 call	 _Py_IncRef

; 1450 :     self->exports++;

  00162	48 ff 86 88 00
	00 00		 inc	 QWORD PTR [rsi+136]

; 1451 : 
; 1452 :     return 0;

  00169	33 c0		 xor	 eax, eax
  0016b	eb 16		 jmp	 SHORT $LN13@memory_get
$LN11@memory_get:

; 1381 : 
; 1382 :     CHECK_RELEASED_INT(self);

  0016d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
$LN15@memory_get:
  0017b	e8 00 00 00 00	 call	 PyErr_SetString
$LN16@memory_get:
  00180	83 c8 ff	 or	 eax, -1
$LN13@memory_get:

; 1453 : }

  00183	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00188	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0018d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00192	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00197	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019b	41 5c		 pop	 r12
  0019d	c3		 ret	 0
memory_getbuf ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT memory_releasebuf
_TEXT	SEGMENT
self$ = 8
view$ = 16
memory_releasebuf PROC					; COMDAT

; 1458 :     self->exports--;

  00000	48 ff 89 88 00
	00 00		 dec	 QWORD PTR [rcx+136]

; 1459 :     return;
; 1460 :     /* PyBuffer_Release() decrements view->obj after this function returns. */
; 1461 : }

  00007	c3		 ret	 0
memory_releasebuf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_error_int DD imagerel type_error_int
	DD	imagerel type_error_int+34
	DD	imagerel $unwind$type_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_error_int DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@
CONST	SEGMENT
??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@ DB 'memoryview:'
	DB	' invalid type for format ''%s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT type_error_int
_TEXT	SEGMENT
fmt$ = 48
type_error_int PROC					; COMDAT

; 1482 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1483 :     PyErr_Format(PyExc_TypeError,
; 1484 :         "memoryview: invalid type for format '%s'", fmt);

  00004	4c 8b c1	 mov	 r8, rcx
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@ODBNDFBK@memoryview?3?5invalid?5type?5for?5for@
  00015	e8 00 00 00 00	 call	 PyErr_Format

; 1485 :     return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1486 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
type_error_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$value_error_int DD imagerel value_error_int
	DD	imagerel value_error_int+34
	DD	imagerel $unwind$value_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$value_error_int DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@
CONST	SEGMENT
??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@ DB 'memoryview:'
	DB	' invalid value for format ''%s''', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT value_error_int
_TEXT	SEGMENT
fmt$ = 48
value_error_int PROC					; COMDAT

; 1490 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1491 :     PyErr_Format(PyExc_ValueError,
; 1492 :         "memoryview: invalid value for format '%s'", fmt);

  00004	4c 8b c1	 mov	 r8, rcx
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JECCJFFJ@memoryview?3?5invalid?5value?5for?5fo@
  00015	e8 00 00 00 00	 call	 PyErr_Format

; 1493 :     return -1;

  0001a	83 c8 ff	 or	 eax, -1

; 1494 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
value_error_int ENDP
_TEXT	ENDS
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fix_error_int DD imagerel fix_error_int
	DD	imagerel fix_error_int+102
	DD	imagerel $unwind$fix_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fix_error_int DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fix_error_int
_TEXT	SEGMENT
fmt$ = 48
fix_error_int PROC					; COMDAT

; 1498 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1499 :     assert(PyErr_Occurred());
; 1500 :     if (PyErr_ExceptionMatches(PyExc_TypeError)) {

  00009	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00010	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN4@fix_error_

; 1501 :         PyErr_Clear();

  00019	e8 00 00 00 00	 call	 PyErr_Clear

; 1502 :         return type_error_int(fmt);

  0001e	48 8b cb	 mov	 rcx, rbx

; 1511 : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	e9 00 00 00 00	 jmp	 type_error_int
$LN4@fix_error_:

; 1503 :     }
; 1504 :     else if (PyErr_ExceptionMatches(PyExc_OverflowError) ||
; 1505 :              PyErr_ExceptionMatches(PyExc_ValueError)) {

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00032	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00037	85 c0		 test	 eax, eax
  00039	75 19		 jne	 SHORT $LN1@fix_error_
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00042	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00047	85 c0		 test	 eax, eax
  00049	75 09		 jne	 SHORT $LN1@fix_error_

; 1508 :     }
; 1509 : 
; 1510 :     return -1;

  0004b	83 c8 ff	 or	 eax, -1

; 1511 : }

  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN1@fix_error_:

; 1506 :         PyErr_Clear();

  00054	e8 00 00 00 00	 call	 PyErr_Clear

; 1507 :         return value_error_int(fmt);

  00059	48 8b cb	 mov	 rcx, rbx

; 1511 : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	e9 00 00 00 00	 jmp	 value_error_int
fix_error_int ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	PyNumber_Index:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_ld DD imagerel pylong_as_ld
	DD	imagerel pylong_as_ld+64
	DD	imagerel $unwind$pylong_as_ld
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_ld DD 042401H
	DD	063424H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_ld
_TEXT	SEGMENT
item$ = 48
pylong_as_ld PROC					; COMDAT

; 1516 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1517 :     PyObject *tmp;
; 1518 :     long ld;
; 1519 : 
; 1520 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1521 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 09		 jne	 SHORT $LN1@pylong_as_

; 1522 :         return -1;

  00013	83 c8 ff	 or	 eax, -1

; 1527 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
$LN1@pylong_as_:

; 1523 : 
; 1524 :     ld = PyLong_AsLong(tmp);

  0001c	48 8b c8	 mov	 rcx, rax
  0001f	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00024	e8 00 00 00 00	 call	 PyLong_AsLong

; 1525 :     Py_DECREF(tmp);

  00029	48 8b cf	 mov	 rcx, rdi
  0002c	8b d8		 mov	 ebx, eax
  0002e	e8 00 00 00 00	 call	 _Py_DecRef

; 1526 :     return ld;

  00033	8b c3		 mov	 eax, ebx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1527 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
pylong_as_ld ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_lu DD imagerel pylong_as_lu
	DD	imagerel pylong_as_lu+64
	DD	imagerel $unwind$pylong_as_lu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_lu DD 042401H
	DD	063424H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_lu
_TEXT	SEGMENT
item$ = 48
pylong_as_lu PROC					; COMDAT

; 1531 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1532 :     PyObject *tmp;
; 1533 :     unsigned long lu;
; 1534 : 
; 1535 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1536 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 09		 jne	 SHORT $LN1@pylong_as_@2

; 1537 :         return (unsigned long)-1;

  00013	83 c8 ff	 or	 eax, -1			; ffffffffH

; 1542 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5f		 pop	 rdi
  0001b	c3		 ret	 0
$LN1@pylong_as_@2:

; 1538 : 
; 1539 :     lu = PyLong_AsUnsignedLong(tmp);

  0001c	48 8b c8	 mov	 rcx, rax
  0001f	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00024	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong

; 1540 :     Py_DECREF(tmp);

  00029	48 8b cf	 mov	 rcx, rdi
  0002c	8b d8		 mov	 ebx, eax
  0002e	e8 00 00 00 00	 call	 _Py_DecRef

; 1541 :     return lu;

  00033	8b c3		 mov	 eax, ebx
  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1542 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
pylong_as_lu ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_lld DD imagerel pylong_as_lld
	DD	imagerel pylong_as_lld+67
	DD	imagerel $unwind$pylong_as_lld
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_lld DD 042501H
	DD	063425H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_lld
_TEXT	SEGMENT
item$ = 48
pylong_as_lld PROC					; COMDAT

; 1547 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1548 :     PyObject *tmp;
; 1549 :     PY_LONG_LONG lld;
; 1550 : 
; 1551 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1552 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0a		 jne	 SHORT $LN1@pylong_as_@3

; 1553 :         return -1;

  00013	48 83 c8 ff	 or	 rax, -1

; 1558 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN1@pylong_as_@3:

; 1554 : 
; 1555 :     lld = PyLong_AsLongLong(tmp);

  0001d	48 8b c8	 mov	 rcx, rax
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	e8 00 00 00 00	 call	 PyLong_AsLongLong

; 1556 :     Py_DECREF(tmp);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	48 8b d8	 mov	 rbx, rax
  00030	e8 00 00 00 00	 call	 _Py_DecRef

; 1557 :     return lld;

  00035	48 8b c3	 mov	 rax, rbx
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1558 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
pylong_as_lld ENDP
_TEXT	ENDS
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_llu DD imagerel pylong_as_llu
	DD	imagerel pylong_as_llu+67
	DD	imagerel $unwind$pylong_as_llu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_llu DD 042501H
	DD	063425H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_llu
_TEXT	SEGMENT
item$ = 48
pylong_as_llu PROC					; COMDAT

; 1562 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1563 :     PyObject *tmp;
; 1564 :     unsigned PY_LONG_LONG llu;
; 1565 : 
; 1566 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1567 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0a		 jne	 SHORT $LN1@pylong_as_@4

; 1568 :         return (unsigned PY_LONG_LONG)-1;

  00013	48 83 c8 ff	 or	 rax, -1

; 1573 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN1@pylong_as_@4:

; 1569 : 
; 1570 :     llu = PyLong_AsUnsignedLongLong(tmp);

  0001d	48 8b c8	 mov	 rcx, rax
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong

; 1571 :     Py_DECREF(tmp);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	48 8b d8	 mov	 rbx, rax
  00030	e8 00 00 00 00	 call	 _Py_DecRef

; 1572 :     return llu;

  00035	48 8b c3	 mov	 rax, rbx
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1573 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
pylong_as_llu ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_zd DD imagerel pylong_as_zd
	DD	imagerel pylong_as_zd+67
	DD	imagerel $unwind$pylong_as_zd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_zd DD 042501H
	DD	063425H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_zd
_TEXT	SEGMENT
item$ = 48
pylong_as_zd PROC					; COMDAT

; 1578 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1579 :     PyObject *tmp;
; 1580 :     Py_ssize_t zd;
; 1581 : 
; 1582 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1583 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0a		 jne	 SHORT $LN1@pylong_as_@5

; 1584 :         return -1;

  00013	48 83 c8 ff	 or	 rax, -1

; 1589 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN1@pylong_as_@5:

; 1585 : 
; 1586 :     zd = PyLong_AsSsize_t(tmp);

  0001d	48 8b c8	 mov	 rcx, rax
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 1587 :     Py_DECREF(tmp);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	48 8b d8	 mov	 rbx, rax
  00030	e8 00 00 00 00	 call	 _Py_DecRef

; 1588 :     return zd;

  00035	48 8b c3	 mov	 rax, rbx
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1589 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
pylong_as_zd ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pylong_as_zu DD imagerel pylong_as_zu
	DD	imagerel pylong_as_zu+67
	DD	imagerel $unwind$pylong_as_zu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pylong_as_zu DD 042501H
	DD	063425H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pylong_as_zu
_TEXT	SEGMENT
item$ = 48
pylong_as_zu PROC					; COMDAT

; 1593 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1594 :     PyObject *tmp;
; 1595 :     size_t zu;
; 1596 : 
; 1597 :     tmp = PyNumber_Index(item);

  00006	e8 00 00 00 00	 call	 PyNumber_Index
  0000b	48 8b f8	 mov	 rdi, rax

; 1598 :     if (tmp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0a		 jne	 SHORT $LN1@pylong_as_@6

; 1599 :         return (size_t)-1;

  00013	48 83 c8 ff	 or	 rax, -1

; 1604 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN1@pylong_as_@6:

; 1600 : 
; 1601 :     zu = PyLong_AsSize_t(tmp);

  0001d	48 8b c8	 mov	 rcx, rax
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	e8 00 00 00 00	 call	 PyLong_AsSize_t

; 1602 :     Py_DECREF(tmp);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	48 8b d8	 mov	 rbx, rax
  00030	e8 00 00 00 00	 call	 _Py_DecRef

; 1603 :     return zu;

  00035	48 8b c3	 mov	 rax, rbx
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1604 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
pylong_as_zu ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyLong_FromSize_t:PROC
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyLong_FromUnsignedLongLong:PROC
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyBool_FromLong:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_single DD imagerel unpack_single
	DD	imagerel unpack_single+399
	DD	imagerel $unwind$unpack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_single DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
CONST	SEGMENT
??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@ DB 'memoryvi'
	DB	'ew: format %s not supported', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unpack_single
_TEXT	SEGMENT
ptr$ = 48
d$ = 56
x$21299 = 56
fmt$ = 56
unpack_single PROC					; COMDAT

; 1621 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1622 :     unsigned PY_LONG_LONG llu;
; 1623 :     unsigned long lu;
; 1624 :     size_t zu;
; 1625 :     PY_LONG_LONG lld;
; 1626 :     long ld;
; 1627 :     Py_ssize_t zd;
; 1628 :     double d;
; 1629 :     unsigned char uc;
; 1630 :     void *p;
; 1631 : 
; 1632 :     switch (fmt[0]) {

  00004	0f be 02	 movsx	 eax, BYTE PTR [rdx]
  00007	83 c0 c1	 add	 eax, -63		; ffffffffffffffc1H
  0000a	83 f8 32	 cmp	 eax, 50			; 00000032H
  0000d	0f 87 eb 00 00
	00		 ja	 $err_format$21318
  00013	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  0001a	48 98		 cdqe
  0001c	41 0f b6 84 01
	00 00 00 00	 movzx	 eax, BYTE PTR $LN65@unpack_sin[r9+rax]
  00025	45 8b 84 81 00
	00 00 00	 mov	 r8d, DWORD PTR $LN66@unpack_sin[r9+rax*4]
  0002d	4d 03 c1	 add	 r8, r9
  00030	41 ff e0	 jmp	 r8
$LN60@unpack_sin:
$convert_uc$21219:

; 1666 : 
; 1667 :     /* bytes object */
; 1668 :     case 'c': goto convert_bytes;
; 1669 : 
; 1670 :     /* pointer */
; 1671 :     case 'P': UNPACK_SINGLE(p, ptr, void *); goto convert_pointer;
; 1672 : 
; 1673 :     /* default */
; 1674 :     default: goto err_format;
; 1675 :     }
; 1676 : 
; 1677 : convert_uc:
; 1678 :     /* PyLong_FromUnsignedLong() is slower */
; 1679 :     return PyLong_FromLong(uc);

  00033	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]

; 1704 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN59@unpack_sin:

; 1633 : 
; 1634 :     /* signed integers and fast path for 'B' */
; 1635 :     case 'B': uc = *((unsigned char *)ptr); goto convert_uc;
; 1636 :     case 'b': ld =   *((signed char *)ptr); goto convert_ld;

  0003f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]

; 1704 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN57@unpack_sin:

; 1637 :     case 'h': UNPACK_SINGLE(ld, ptr, short); goto convert_ld;

  0004b	0f bf 09	 movsx	 ecx, WORD PTR [rcx]

; 1704 : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN49@unpack_sin:

; 1638 :     case 'i': UNPACK_SINGLE(ld, ptr, int); goto convert_ld;
; 1639 :     case 'l': UNPACK_SINGLE(ld, ptr, long); goto convert_ld;

  00057	8b 09		 mov	 ecx, DWORD PTR [rcx]
$convert_ld$21222:

; 1704 : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN45@unpack_sin:
$convert_bool$21247:

; 1692 : convert_double:
; 1693 :     return PyFloat_FromDouble(d);
; 1694 : convert_bool:
; 1695 :     return PyBool_FromLong(ld);

  00062	0f be 09	 movsx	 ecx, BYTE PTR [rcx]

; 1704 : }

  00065	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00069	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN41@unpack_sin:

; 1640 : 
; 1641 :     /* boolean */
; 1642 :     #ifdef HAVE_C99_BOOL
; 1643 :     case '?': UNPACK_SINGLE(ld, ptr, _Bool); goto convert_bool;
; 1644 :     #else
; 1645 :     case '?': UNPACK_SINGLE(ld, ptr, char); goto convert_bool;
; 1646 :     #endif
; 1647 : 
; 1648 :     /* unsigned integers */
; 1649 :     case 'H': UNPACK_SINGLE(lu, ptr, unsigned short); goto convert_lu;

  0006e	0f b7 09	 movzx	 ecx, WORD PTR [rcx]

; 1704 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
$LN33@unpack_sin:

; 1650 :     case 'I': UNPACK_SINGLE(lu, ptr, unsigned int); goto convert_lu;
; 1651 :     case 'L': UNPACK_SINGLE(lu, ptr, unsigned long); goto convert_lu;

  0007a	8b 09		 mov	 ecx, DWORD PTR [rcx]
$convert_lu$21254:

; 1704 : }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLong
$LN29@unpack_sin:
$convert_lld$21273:

; 1680 : convert_ld:
; 1681 :     return PyLong_FromLong(ld);
; 1682 : convert_lu:
; 1683 :     return PyLong_FromUnsignedLong(lu);
; 1684 : convert_lld:
; 1685 :     return PyLong_FromLongLong(lld);

  00085	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1704 : }

  00088	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008c	e9 00 00 00 00	 jmp	 PyLong_FromLongLong
$LN25@unpack_sin:
$convert_llu$21280:

; 1686 : convert_llu:
; 1687 :     return PyLong_FromUnsignedLongLong(llu);

  00091	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1704 : }

  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	e9 00 00 00 00	 jmp	 PyLong_FromUnsignedLongLong
$LN21@unpack_sin:
$convert_zd$21287:

; 1688 : convert_zd:
; 1689 :     return PyLong_FromSsize_t(zd);

  0009d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1704 : }

  000a0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a4	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN17@unpack_sin:
$convert_zu$21294:

; 1690 : convert_zu:
; 1691 :     return PyLong_FromSize_t(zu);

  000a9	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1704 : }

  000ac	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b0	e9 00 00 00 00	 jmp	 PyLong_FromSize_t
$LN13@unpack_sin:

; 1652 : 
; 1653 :     /* native 64-bit */
; 1654 :     #ifdef HAVE_LONG_LONG
; 1655 :     case 'q': UNPACK_SINGLE(lld, ptr, PY_LONG_LONG); goto convert_lld;
; 1656 :     case 'Q': UNPACK_SINGLE(llu, ptr, unsigned PY_LONG_LONG); goto convert_llu;
; 1657 :     #endif
; 1658 : 
; 1659 :     /* ssize_t and size_t */
; 1660 :     case 'n': UNPACK_SINGLE(zd, ptr, Py_ssize_t); goto convert_zd;
; 1661 :     case 'N': UNPACK_SINGLE(zu, ptr, size_t); goto convert_zu;
; 1662 : 
; 1663 :     /* floats */
; 1664 :     case 'f': UNPACK_SINGLE(d, ptr, float); goto convert_double;

  000b5	8b 01		 mov	 eax, DWORD PTR [rcx]
  000b7	89 44 24 38	 mov	 DWORD PTR x$21299[rsp], eax
  000bb	66 0f 6e 44 24
	38		 movd	 xmm0, DWORD PTR x$21299[rsp]
  000c1	0f 5a c0	 cvtps2pd xmm0, xmm0

; 1704 : }

  000c4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c8	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
$LN9@unpack_sin:

; 1665 :     case 'd': UNPACK_SINGLE(d, ptr, double); goto convert_double;

  000cd	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$convert_double$21301:
  000d0	48 89 44 24 38	 mov	 QWORD PTR d$[rsp], rax
  000d5	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR d$[rsp]

; 1704 : }

  000db	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000df	e9 00 00 00 00	 jmp	 PyFloat_FromDouble
$convert_bytes$21309:

; 1696 : convert_bytes:
; 1697 :     return PyBytes_FromStringAndSize(ptr, 1);

  000e4	ba 01 00 00 00	 mov	 edx, 1

; 1704 : }

  000e9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ed	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN4@unpack_sin:
$convert_pointer$21316:

; 1698 : convert_pointer:
; 1699 :     return PyLong_FromVoidPtr(p);

  000f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 1704 : }

  000f5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f9	e9 00 00 00 00	 jmp	 PyLong_FromVoidPtr
$err_format$21318:

; 1700 : err_format:
; 1701 :     PyErr_Format(PyExc_NotImplementedError,
; 1702 :         "memoryview: format %s not supported", fmt);

  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00105	4c 8b c2	 mov	 r8, rdx
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
  0010f	e8 00 00 00 00	 call	 PyErr_Format

; 1703 :     return NULL;

  00114	33 c0		 xor	 eax, eax

; 1704 : }

  00116	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011a	c3		 ret	 0
  0011b	90		 npad	 1
$LN66@unpack_sin:
  0011c	00 00 00 00	 DD	 $LN45@unpack_sin
  00120	00 00 00 00	 DD	 $LN60@unpack_sin
  00124	00 00 00 00	 DD	 $LN41@unpack_sin
  00128	00 00 00 00	 DD	 $LN33@unpack_sin
  0012c	00 00 00 00	 DD	 $LN17@unpack_sin
  00130	00 00 00 00	 DD	 $LN4@unpack_sin
  00134	00 00 00 00	 DD	 $LN25@unpack_sin
  00138	00 00 00 00	 DD	 $LN59@unpack_sin
  0013c	00 00 00 00	 DD	 $convert_bytes$21309
  00140	00 00 00 00	 DD	 $LN9@unpack_sin
  00144	00 00 00 00	 DD	 $LN13@unpack_sin
  00148	00 00 00 00	 DD	 $LN57@unpack_sin
  0014c	00 00 00 00	 DD	 $LN49@unpack_sin
  00150	00 00 00 00	 DD	 $LN21@unpack_sin
  00154	00 00 00 00	 DD	 $LN29@unpack_sin
  00158	00 00 00 00	 DD	 $err_format$21318
$LN65@unpack_sin:
  0015c	00		 DB	 0
  0015d	0f		 DB	 15
  0015e	0f		 DB	 15
  0015f	01		 DB	 1
  00160	0f		 DB	 15
  00161	0f		 DB	 15
  00162	0f		 DB	 15
  00163	0f		 DB	 15
  00164	0f		 DB	 15
  00165	02		 DB	 2
  00166	03		 DB	 3
  00167	0f		 DB	 15
  00168	0f		 DB	 15
  00169	03		 DB	 3
  0016a	0f		 DB	 15
  0016b	04		 DB	 4
  0016c	0f		 DB	 15
  0016d	05		 DB	 5
  0016e	06		 DB	 6
  0016f	0f		 DB	 15
  00170	0f		 DB	 15
  00171	0f		 DB	 15
  00172	0f		 DB	 15
  00173	0f		 DB	 15
  00174	0f		 DB	 15
  00175	0f		 DB	 15
  00176	0f		 DB	 15
  00177	0f		 DB	 15
  00178	0f		 DB	 15
  00179	0f		 DB	 15
  0017a	0f		 DB	 15
  0017b	0f		 DB	 15
  0017c	0f		 DB	 15
  0017d	0f		 DB	 15
  0017e	0f		 DB	 15
  0017f	07		 DB	 7
  00180	08		 DB	 8
  00181	09		 DB	 9
  00182	0f		 DB	 15
  00183	0a		 DB	 10
  00184	0f		 DB	 15
  00185	0b		 DB	 11
  00186	0c		 DB	 12
  00187	0f		 DB	 15
  00188	0f		 DB	 15
  00189	0c		 DB	 12
  0018a	0f		 DB	 15
  0018b	0d		 DB	 13
  0018c	0f		 DB	 15
  0018d	0f		 DB	 15
  0018e	0e		 DB	 14
unpack_single ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
EXTRN	PyLong_AsVoidPtr:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pack_single DD imagerel pack_single
	DD	imagerel pack_single+683
	DD	imagerel $unwind$pack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pack_single DD 081801H
	DD	026818H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT pack_single
_TEXT	SEGMENT
ptr$ = 64
item$ = 72
fmt$ = 80
pack_single PROC					; COMDAT

; 1717 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1718 :     unsigned PY_LONG_LONG llu;
; 1719 :     unsigned long lu;
; 1720 :     size_t zu;
; 1721 :     PY_LONG_LONG lld;
; 1722 :     long ld;
; 1723 :     Py_ssize_t zd;
; 1724 :     double d;
; 1725 :     void *p;
; 1726 : 
; 1727 :     switch (fmt[0]) {

  0000f	41 0f be 00	 movsx	 eax, BYTE PTR [r8]
  00013	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  00018	49 8b f0	 mov	 rsi, r8
  0001b	83 c0 c1	 add	 eax, -63		; ffffffffffffffc1H
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	83 f8 32	 cmp	 eax, 50			; 00000032H
  00024	0f 87 f4 01 00
	00		 ja	 $err_format$21490
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00031	48 98		 cdqe
  00033	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN92@pack_singl[rcx+rax]
  0003b	44 8b 8c 81 00
	00 00 00	 mov	 r9d, DWORD PTR $LN93@pack_singl[rcx+rax*4]
  00043	4c 03 c9	 add	 r9, rcx
  00046	41 ff e1	 jmp	 r9
$LN87@pack_singl:

; 1728 :     /* signed integers */
; 1729 :     case 'b': case 'h': case 'i': case 'l':
; 1730 :         ld = pylong_as_ld(item);

  00049	48 8b ca	 mov	 rcx, rdx
  0004c	e8 00 00 00 00	 call	 pylong_as_ld
  00051	8b f8		 mov	 edi, eax

; 1731 :         if (ld == -1 && PyErr_Occurred())

  00053	83 f8 ff	 cmp	 eax, -1
  00056	75 0e		 jne	 SHORT $LN86@pack_singl
  00058	e8 00 00 00 00	 call	 PyErr_Occurred
  0005d	48 85 c0	 test	 rax, rax
  00060	0f 85 ae 01 00
	00		 jne	 $err_occurred$21344
$LN86@pack_singl:

; 1732 :             goto err_occurred;
; 1733 :         switch (fmt[0]) {

  00066	0f be 06	 movsx	 eax, BYTE PTR [rsi]
  00069	83 e8 62	 sub	 eax, 98			; 00000062H
  0006c	74 39		 je	 SHORT $LN83@pack_singl
  0006e	83 e8 06	 sub	 eax, 6
  00071	74 1d		 je	 SHORT $LN80@pack_singl
  00073	ff c8		 dec	 eax

; 1743 :         default: /* 'l' */
; 1744 :             PACK_SINGLE(ptr, ld, long); break;

  00075	75 10		 jne	 SHORT $LN96@pack_singl

; 1740 :         case 'i':
; 1741 :             if (ld < INT_MIN || ld > INT_MAX) goto err_range;

  00077	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0007c	03 c7		 add	 eax, edi
  0007e	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00081	0f 87 8b 00 00
	00		 ja	 $err_range$21352
$LN96@pack_singl:

; 1742 :             PACK_SINGLE(ptr, ld, int); break;

  00087	89 3b		 mov	 DWORD PTR [rbx], edi

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 a4 01 00 00	 jmp	 $LN90@pack_singl
$LN80@pack_singl:

; 1737 :         case 'h':
; 1738 :             if (ld < SHRT_MIN || ld > SHRT_MAX) goto err_range;

  00090	8d 87 00 80 00
	00		 lea	 eax, DWORD PTR [rdi+32768]
  00096	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0009b	77 75		 ja	 SHORT $err_range$21352

; 1739 :             PACK_SINGLE(ptr, ld, short); break;

  0009d	66 89 3b	 mov	 WORD PTR [rbx], di

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	e9 8d 01 00 00	 jmp	 $LN90@pack_singl
$LN83@pack_singl:

; 1734 :         case 'b':
; 1735 :             if (ld < SCHAR_MIN || ld > SCHAR_MAX) goto err_range;

  000a7	8d 87 80 00 00
	00		 lea	 eax, DWORD PTR [rdi+128]
  000ad	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000b2	77 5e		 ja	 SHORT $err_range$21352
$LN59@pack_singl:

; 1736 :             *((signed char *)ptr) = (signed char)ld; break;

  000b4	40 88 3b	 mov	 BYTE PTR [rbx], dil

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 76 01 00 00	 jmp	 $LN90@pack_singl
$LN64@pack_singl:

; 1745 :         }
; 1746 :         break;
; 1747 : 
; 1748 :     /* unsigned integers */
; 1749 :     case 'B': case 'H': case 'I': case 'L':
; 1750 :         lu = pylong_as_lu(item);

  000be	48 8b ca	 mov	 rcx, rdx
  000c1	e8 00 00 00 00	 call	 pylong_as_lu
  000c6	8b f8		 mov	 edi, eax

; 1751 :         if (lu == (unsigned long)-1 && PyErr_Occurred())

  000c8	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  000cb	75 0e		 jne	 SHORT $LN63@pack_singl
  000cd	e8 00 00 00 00	 call	 PyErr_Occurred
  000d2	48 85 c0	 test	 rax, rax
  000d5	0f 85 39 01 00
	00		 jne	 $err_occurred$21344
$LN63@pack_singl:

; 1752 :             goto err_occurred;
; 1753 :         switch (fmt[0]) {

  000db	0f be 06	 movsx	 eax, BYTE PTR [rsi]
  000de	83 e8 42	 sub	 eax, 66			; 00000042H
  000e1	74 27		 je	 SHORT $LN60@pack_singl
  000e3	83 e8 06	 sub	 eax, 6
  000e6	74 10		 je	 SHORT $LN58@pack_singl
  000e8	ff c8		 dec	 eax

; 1763 :         default: /* 'L' */
; 1764 :             PACK_SINGLE(ptr, lu, unsigned long); break;

  000ea	75 9b		 jne	 SHORT $LN96@pack_singl

; 1760 :         case 'I':
; 1761 :             if (lu > UINT_MAX) goto err_range;

  000ec	83 ff ff	 cmp	 edi, -1			; ffffffffH
  000ef	77 21		 ja	 SHORT $err_range$21352

; 1762 :             PACK_SINGLE(ptr, lu, unsigned int); break;

  000f1	89 3b		 mov	 DWORD PTR [rbx], edi

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  000f3	e9 3c 01 00 00	 jmp	 $LN90@pack_singl
$LN58@pack_singl:

; 1756 :             *((unsigned char *)ptr) = (unsigned char)lu; break;
; 1757 :         case 'H':
; 1758 :             if (lu > USHRT_MAX) goto err_range;

  000f8	81 ff ff ff 00
	00		 cmp	 edi, 65535		; 0000ffffH
  000fe	77 12		 ja	 SHORT $err_range$21352

; 1759 :             PACK_SINGLE(ptr, lu, unsigned short); break;

  00100	66 89 3b	 mov	 WORD PTR [rbx], di

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  00103	33 c0		 xor	 eax, eax
  00105	e9 2a 01 00 00	 jmp	 $LN90@pack_singl
$LN60@pack_singl:

; 1754 :         case 'B':
; 1755 :             if (lu > UCHAR_MAX) goto err_range;

  0010a	81 ff ff 00 00
	00		 cmp	 edi, 255		; 000000ffH
  00110	76 a2		 jbe	 SHORT $LN59@pack_singl
$err_range$21352:

; 1848 : err_range:
; 1849 :     return value_error_int(fmt);

  00112	48 8b ce	 mov	 rcx, rsi
  00115	e8 00 00 00 00	 call	 value_error_int
  0011a	e9 15 01 00 00	 jmp	 $LN90@pack_singl
$LN44@pack_singl:

; 1765 :         }
; 1766 :         break;
; 1767 : 
; 1768 :     /* native 64-bit */
; 1769 :     #ifdef HAVE_LONG_LONG
; 1770 :     case 'q':
; 1771 :         lld = pylong_as_lld(item);

  0011f	48 8b ca	 mov	 rcx, rdx
  00122	e8 00 00 00 00	 call	 pylong_as_lld
$LN95@pack_singl:
  00127	48 8b f8	 mov	 rdi, rax

; 1772 :         if (lld == -1 && PyErr_Occurred())

  0012a	48 83 f8 ff	 cmp	 rax, -1
  0012e	75 0e		 jne	 SHORT $LN4@pack_singl
  00130	e8 00 00 00 00	 call	 PyErr_Occurred
  00135	48 85 c0	 test	 rax, rax
  00138	0f 85 d6 00 00
	00		 jne	 $err_occurred$21344
$LN4@pack_singl:

; 1836 :             goto err_occurred;
; 1837 :         PACK_SINGLE(ptr, p, void *);

  0013e	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  00141	33 c0		 xor	 eax, eax
  00143	e9 ec 00 00 00	 jmp	 $LN90@pack_singl
$LN39@pack_singl:

; 1773 :             goto err_occurred;
; 1774 :         PACK_SINGLE(ptr, lld, PY_LONG_LONG);
; 1775 :         break;
; 1776 :     case 'Q':
; 1777 :         llu = pylong_as_llu(item);

  00148	48 8b ca	 mov	 rcx, rdx
  0014b	e8 00 00 00 00	 call	 pylong_as_llu

; 1778 :         if (llu == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())
; 1779 :             goto err_occurred;
; 1780 :         PACK_SINGLE(ptr, llu, unsigned PY_LONG_LONG);
; 1781 :         break;

  00150	eb d5		 jmp	 SHORT $LN95@pack_singl
$LN34@pack_singl:

; 1782 :     #endif
; 1783 : 
; 1784 :     /* ssize_t and size_t */
; 1785 :     case 'n':
; 1786 :         zd = pylong_as_zd(item);

  00152	48 8b ca	 mov	 rcx, rdx
  00155	e8 00 00 00 00	 call	 pylong_as_zd

; 1787 :         if (zd == -1 && PyErr_Occurred())
; 1788 :             goto err_occurred;
; 1789 :         PACK_SINGLE(ptr, zd, Py_ssize_t);
; 1790 :         break;

  0015a	eb cb		 jmp	 SHORT $LN95@pack_singl
$LN29@pack_singl:

; 1791 :     case 'N':
; 1792 :         zu = pylong_as_zu(item);

  0015c	48 8b ca	 mov	 rcx, rdx
  0015f	e8 00 00 00 00	 call	 pylong_as_zu

; 1793 :         if (zu == (size_t)-1 && PyErr_Occurred())
; 1794 :             goto err_occurred;
; 1795 :         PACK_SINGLE(ptr, zu, size_t);
; 1796 :         break;

  00164	eb c1		 jmp	 SHORT $LN95@pack_singl
$LN24@pack_singl:

; 1797 : 
; 1798 :     /* floats */
; 1799 :     case 'f': case 'd':
; 1800 :         d = PyFloat_AsDouble(item);

  00166	48 8b ca	 mov	 rcx, rdx
  00169	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 1801 :         if (d == -1.0 && PyErr_Occurred())

  0016e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00176	66 0f 28 f0	 movapd	 xmm6, xmm0
  0017a	7a 10		 jp	 SHORT $LN23@pack_singl
  0017c	75 0e		 jne	 SHORT $LN23@pack_singl
  0017e	e8 00 00 00 00	 call	 PyErr_Occurred
  00183	48 85 c0	 test	 rax, rax
  00186	0f 85 88 00 00
	00		 jne	 $err_occurred$21344
$LN23@pack_singl:

; 1802 :             goto err_occurred;
; 1803 :         if (fmt[0] == 'f') {

  0018c	80 3e 66	 cmp	 BYTE PTR [rsi], 102	; 00000066H
  0018f	75 0f		 jne	 SHORT $LN17@pack_singl

; 1804 :             PACK_SINGLE(ptr, d, float);

  00191	f2 0f 5a c6	 cvtsd2ss xmm0, xmm6

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  00195	33 c0		 xor	 eax, eax
  00197	f3 0f 11 03	 movss	 DWORD PTR [rbx], xmm0
  0019b	e9 94 00 00 00	 jmp	 $LN90@pack_singl
$LN17@pack_singl:

; 1805 :         }
; 1806 :         else {
; 1807 :             PACK_SINGLE(ptr, d, double);

  001a0	f2 0f 11 33	 movsdx	 QWORD PTR [rbx], xmm6

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  001a4	33 c0		 xor	 eax, eax
  001a6	e9 89 00 00 00	 jmp	 $LN90@pack_singl
$LN14@pack_singl:

; 1808 :         }
; 1809 :         break;
; 1810 : 
; 1811 :     /* bool */
; 1812 :     case '?':
; 1813 :         ld = PyObject_IsTrue(item);

  001ab	48 8b ca	 mov	 rcx, rdx
  001ae	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1814 :         if (ld < 0)

  001b3	85 c0		 test	 eax, eax

; 1815 :             return -1; /* preserve original error */

  001b5	78 7a		 js	 SHORT $LN94@pack_singl

; 1816 :     #ifdef HAVE_C99_BOOL
; 1817 :         PACK_SINGLE(ptr, ld, _Bool);
; 1818 :     #else
; 1819 :         PACK_SINGLE(ptr, ld, char);

  001b7	88 03		 mov	 BYTE PTR [rbx], al

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  001b9	33 c0		 xor	 eax, eax
  001bb	eb 77		 jmp	 SHORT $LN90@pack_singl
$LN9@pack_singl:

; 1820 :     #endif
; 1821 :          break;
; 1822 : 
; 1823 :     /* bytes object */
; 1824 :     case 'c':
; 1825 :         if (!PyBytes_Check(item))

  001bd	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  001c1	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  001cb	75 0a		 jne	 SHORT $LN8@pack_singl

; 1826 :             return type_error_int(fmt);

  001cd	49 8b c8	 mov	 rcx, r8
  001d0	e8 00 00 00 00	 call	 type_error_int
  001d5	eb 5d		 jmp	 SHORT $LN90@pack_singl
$LN8@pack_singl:

; 1827 :         if (PyBytes_GET_SIZE(item) != 1)

  001d7	48 83 7a 60 01	 cmp	 QWORD PTR [rdx+96], 1
  001dc	74 0a		 je	 SHORT $LN7@pack_singl

; 1828 :             return value_error_int(fmt);

  001de	49 8b c8	 mov	 rcx, r8
  001e1	e8 00 00 00 00	 call	 value_error_int
  001e6	eb 4c		 jmp	 SHORT $LN90@pack_singl
$LN7@pack_singl:

; 1829 :         *ptr = PyBytes_AS_STRING(item)[0];

  001e8	0f b6 42 78	 movzx	 eax, BYTE PTR [rdx+120]
  001ec	88 03		 mov	 BYTE PTR [rbx], al

; 1838 :         break;
; 1839 : 
; 1840 :     /* default */
; 1841 :     default: goto err_format;
; 1842 :     }
; 1843 : 
; 1844 :     return 0;

  001ee	33 c0		 xor	 eax, eax
  001f0	eb 42		 jmp	 SHORT $LN90@pack_singl
$LN6@pack_singl:

; 1830 :         break;
; 1831 : 
; 1832 :     /* pointer */
; 1833 :     case 'P':
; 1834 :         p = PyLong_AsVoidPtr(item);

  001f2	48 8b ca	 mov	 rcx, rdx
  001f5	e8 00 00 00 00	 call	 PyLong_AsVoidPtr
  001fa	48 8b f8	 mov	 rdi, rax

; 1835 :         if (p == NULL && PyErr_Occurred())

  001fd	48 85 c0	 test	 rax, rax
  00200	0f 85 38 ff ff
	ff		 jne	 $LN4@pack_singl
  00206	e8 00 00 00 00	 call	 PyErr_Occurred
  0020b	48 85 c0	 test	 rax, rax
  0020e	0f 84 2a ff ff
	ff		 je	 $LN4@pack_singl
$err_occurred$21344:

; 1845 : 
; 1846 : err_occurred:
; 1847 :     return fix_error_int(fmt);

  00214	48 8b ce	 mov	 rcx, rsi
  00217	e8 00 00 00 00	 call	 fix_error_int
  0021c	eb 16		 jmp	 SHORT $LN90@pack_singl
$err_format$21490:

; 1850 : err_format:
; 1851 :     PyErr_Format(PyExc_NotImplementedError,
; 1852 :         "memoryview: format %s not supported", fmt);

  0021e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00225	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NAELFKBL@memoryview?3?5format?5?$CFs?5not?5suppor@
  0022c	e8 00 00 00 00	 call	 PyErr_Format
$LN94@pack_singl:

; 1853 :     return -1;

  00231	83 c8 ff	 or	 eax, -1
$LN90@pack_singl:

; 1854 : }

  00234	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00239	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0023e	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
  00243	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00247	5f		 pop	 rdi
  00248	c3		 ret	 0
  00249	0f 1f 00	 npad	 3
$LN93@pack_singl:
  0024c	00 00 00 00	 DD	 $LN14@pack_singl
  00250	00 00 00 00	 DD	 $LN64@pack_singl
  00254	00 00 00 00	 DD	 $LN29@pack_singl
  00258	00 00 00 00	 DD	 $LN6@pack_singl
  0025c	00 00 00 00	 DD	 $LN39@pack_singl
  00260	00 00 00 00	 DD	 $LN87@pack_singl
  00264	00 00 00 00	 DD	 $LN9@pack_singl
  00268	00 00 00 00	 DD	 $LN24@pack_singl
  0026c	00 00 00 00	 DD	 $LN34@pack_singl
  00270	00 00 00 00	 DD	 $LN44@pack_singl
  00274	00 00 00 00	 DD	 $err_format$21490
$LN92@pack_singl:
  00278	00		 DB	 0
  00279	0a		 DB	 10
  0027a	0a		 DB	 10
  0027b	01		 DB	 1
  0027c	0a		 DB	 10
  0027d	0a		 DB	 10
  0027e	0a		 DB	 10
  0027f	0a		 DB	 10
  00280	0a		 DB	 10
  00281	01		 DB	 1
  00282	01		 DB	 1
  00283	0a		 DB	 10
  00284	0a		 DB	 10
  00285	01		 DB	 1
  00286	0a		 DB	 10
  00287	02		 DB	 2
  00288	0a		 DB	 10
  00289	03		 DB	 3
  0028a	04		 DB	 4
  0028b	0a		 DB	 10
  0028c	0a		 DB	 10
  0028d	0a		 DB	 10
  0028e	0a		 DB	 10
  0028f	0a		 DB	 10
  00290	0a		 DB	 10
  00291	0a		 DB	 10
  00292	0a		 DB	 10
  00293	0a		 DB	 10
  00294	0a		 DB	 10
  00295	0a		 DB	 10
  00296	0a		 DB	 10
  00297	0a		 DB	 10
  00298	0a		 DB	 10
  00299	0a		 DB	 10
  0029a	0a		 DB	 10
  0029b	05		 DB	 5
  0029c	06		 DB	 6
  0029d	07		 DB	 7
  0029e	0a		 DB	 10
  0029f	07		 DB	 7
  002a0	0a		 DB	 10
  002a1	05		 DB	 5
  002a2	05		 DB	 5
  002a3	0a		 DB	 10
  002a4	0a		 DB	 10
  002a5	05		 DB	 5
  002a6	0a		 DB	 10
  002a7	08		 DB	 8
  002a8	0a		 DB	 10
  002a9	0a		 DB	 10
  002aa	09		 DB	 9
pack_single ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpacker_new DD imagerel unpacker_new
	DD	imagerel unpacker_new+53
	DD	imagerel $unwind$unpacker_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpacker_new DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT unpacker_new
_TEXT	SEGMENT
unpacker_new PROC					; COMDAT

; 1874 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1875 :     struct unpacker *x = PyMem_Malloc(sizeof *x);

  00004	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00009	e8 00 00 00 00	 call	 PyMem_Malloc

; 1876 : 
; 1877 :     if (x == NULL) {

  0000e	48 85 c0	 test	 rax, rax
  00011	75 0c		 jne	 SHORT $LN1@unpacker_n

; 1878 :         PyErr_NoMemory();

  00013	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1879 :         return NULL;

  00018	33 c0		 xor	 eax, eax

; 1886 : 
; 1887 :     return x;
; 1888 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
$LN1@unpacker_n:

; 1880 :     }
; 1881 : 
; 1882 :     x->unpack_from = NULL;

  0001f	33 c9		 xor	 ecx, ecx
  00021	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1883 :     x->mview = NULL;

  00024	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1884 :     x->item = NULL;

  00028	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1885 :     x->itemsize = 0;

  0002c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1886 : 
; 1887 :     return x;
; 1888 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
unpacker_new ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unpacker_free DD imagerel unpacker_free
	DD	imagerel unpacker_free+14
	DD	imagerel $unwind$unpacker_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unpacker_free DD imagerel unpacker_free+14
	DD	imagerel unpacker_free+268
	DD	imagerel $chain$0$unpacker_free
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unpacker_free DD imagerel unpacker_free+268
	DD	imagerel unpacker_free+270
	DD	imagerel $chain$1$unpacker_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unpacker_free DD 021H
	DD	imagerel unpacker_free
	DD	imagerel unpacker_free+14
	DD	imagerel $unwind$unpacker_free
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unpacker_free DD 020521H
	DD	083405H
	DD	imagerel unpacker_free
	DD	imagerel unpacker_free+14
	DD	imagerel $unwind$unpacker_free
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpacker_free DD 020e01H
	DD	0700a520eH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT unpacker_free
_TEXT	SEGMENT
x$ = 64
unpacker_free PROC					; COMDAT

; 1893 :     if (x) {

  00000	48 85 c9	 test	 rcx, rcx
  00003	0f 84 03 01 00
	00		 je	 $LN34@unpacker_f
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 1894 :         Py_XDECREF(x->unpack_from);

  00013	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  00016	48 8b f9	 mov	 rdi, rcx
  00019	48 85 db	 test	 rbx, rbx
  0001c	74 65		 je	 SHORT $LN7@unpacker_f
  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	85 c0		 test	 eax, eax
  00025	75 5c		 jne	 SHORT $LN7@unpacker_f
  00027	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002b	a8 20		 test	 al, 32			; 00000020H
  0002d	75 4c		 jne	 SHORT $LN16@unpacker_f
  0002f	84 c0		 test	 al, al
  00031	78 48		 js	 SHORT $LN16@unpacker_f
  00033	a8 02		 test	 al, 2
  00035	75 4c		 jne	 SHORT $LN7@unpacker_f
  00037	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003b	75 46		 jne	 SHORT $LN7@unpacker_f
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004b	4c 8b cb	 mov	 r9, rbx
  0004e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00054	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00061	48 8b cb	 mov	 rcx, rbx
  00064	85 c0		 test	 eax, eax
  00066	74 07		 je	 SHORT $LN21@unpacker_f
  00068	e8 00 00 00 00	 call	 _Px_Dealloc
  0006d	eb 14		 jmp	 SHORT $LN7@unpacker_f
$LN21@unpacker_f:
  0006f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00073	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00079	eb 08		 jmp	 SHORT $LN7@unpacker_f
$LN16@unpacker_f:
  0007b	48 8b cb	 mov	 rcx, rbx
  0007e	e8 00 00 00 00	 call	 Px_DecRef
$LN7@unpacker_f:

; 1895 :         Py_XDECREF(x->mview);

  00083	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00087	48 85 db	 test	 rbx, rbx
  0008a	74 65		 je	 SHORT $LN3@unpacker_f
  0008c	e8 00 00 00 00	 call	 _Py_PXCTX
  00091	85 c0		 test	 eax, eax
  00093	75 5c		 jne	 SHORT $LN3@unpacker_f
  00095	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00099	a8 20		 test	 al, 32			; 00000020H
  0009b	75 4c		 jne	 SHORT $LN27@unpacker_f
  0009d	84 c0		 test	 al, al
  0009f	78 48		 js	 SHORT $LN27@unpacker_f
  000a1	a8 02		 test	 al, 2
  000a3	75 4c		 jne	 SHORT $LN3@unpacker_f
  000a5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a9	75 46		 jne	 SHORT $LN3@unpacker_f
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b9	4c 8b cb	 mov	 r9, rbx
  000bc	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ca	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	85 c0		 test	 eax, eax
  000d4	74 07		 je	 SHORT $LN32@unpacker_f
  000d6	e8 00 00 00 00	 call	 _Px_Dealloc
  000db	eb 14		 jmp	 SHORT $LN3@unpacker_f
$LN32@unpacker_f:
  000dd	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e7	eb 08		 jmp	 SHORT $LN3@unpacker_f
$LN27@unpacker_f:
  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	e8 00 00 00 00	 call	 Px_DecRef
$LN3@unpacker_f:

; 1896 :         PyMem_Free(x->item);

  000f1	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000f5	e8 00 00 00 00	 call	 PyMem_Free

; 1897 :         PyMem_Free(x);

  000fa	48 8b cf	 mov	 rcx, rdi
  000fd	e8 00 00 00 00	 call	 PyMem_Free
  00102	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1898 :     }
; 1899 : }

  00107	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010b	5f		 pop	 rdi
$LN34@unpacker_f:
  0010c	f3 c3		 fatret	 0
unpacker_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@OJKBBEFN@unpack_from?$AA@		; `string'
PUBLIC	??_C@_06DOCMLGPG@Struct?$AA@			; `string'
PUBLIC	??_C@_06PBJBIPGK@struct?$AA@			; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$struct_get_unpacker DD imagerel struct_get_unpacker
	DD	imagerel struct_get_unpacker+63
	DD	imagerel $unwind$struct_get_unpacker
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$struct_get_unpacker DD imagerel struct_get_unpacker+63
	DD	imagerel struct_get_unpacker+276
	DD	imagerel $chain$0$struct_get_unpacker
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$struct_get_unpacker DD imagerel struct_get_unpacker+276
	DD	imagerel struct_get_unpacker+296
	DD	imagerel $chain$1$struct_get_unpacker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$struct_get_unpacker DD 021H
	DD	imagerel struct_get_unpacker
	DD	imagerel struct_get_unpacker+63
	DD	imagerel $unwind$struct_get_unpacker
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$struct_get_unpacker DD 020521H
	DD	085405H
	DD	imagerel struct_get_unpacker
	DD	imagerel struct_get_unpacker+63
	DD	imagerel $unwind$struct_get_unpacker
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_get_unpacker DD 081301H
	DD	0a6413H
	DD	093413H
	DD	0d00f3213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT ??_C@_0M@OJKBBEFN@unpack_from?$AA@
CONST	SEGMENT
??_C@_0M@OJKBBEFN@unpack_from?$AA@ DB 'unpack_from', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DOCMLGPG@Struct?$AA@
CONST	SEGMENT
??_C@_06DOCMLGPG@Struct?$AA@ DB 'Struct', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PBJBIPGK@struct?$AA@
CONST	SEGMENT
??_C@_06PBJBIPGK@struct?$AA@ DB 'struct', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT struct_get_unpacker
_TEXT	SEGMENT
fmt$ = 64
itemsize$ = 72
struct_get_unpacker PROC				; COMDAT

; 1904 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	4c 8b e1	 mov	 r12, rcx

; 1905 :     PyObject *structmodule;     /* XXX cache these two */
; 1906 :     PyObject *Struct = NULL;    /* XXX in globals?     */
; 1907 :     PyObject *structobj = NULL;
; 1908 :     PyObject *format = NULL;
; 1909 :     struct unpacker *x = NULL;
; 1910 : 
; 1911 :     structmodule = PyImport_ImportModule("struct");

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06PBJBIPGK@struct?$AA@
  0001d	4c 8b ea	 mov	 r13, rdx
  00020	33 ff		 xor	 edi, edi
  00022	33 f6		 xor	 esi, esi
  00024	e8 00 00 00 00	 call	 PyImport_ImportModule
  00029	48 8b d8	 mov	 rbx, rax

; 1912 :     if (structmodule == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	0f 84 df 00 00
	00		 je	 $LN21@struct_get
$LN20@struct_get:

; 1913 :         return NULL;
; 1914 : 
; 1915 :     Struct = PyObject_GetAttrString(structmodule, "Struct");

  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DOCMLGPG@Struct?$AA@
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00044	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 1916 :     Py_DECREF(structmodule);

  00049	48 8b cb	 mov	 rcx, rbx
  0004c	48 8b e8	 mov	 rbp, rax
  0004f	e8 00 00 00 00	 call	 _Py_DecRef

; 1917 :     if (Struct == NULL)

  00054	48 85 ed	 test	 rbp, rbp
  00057	75 07		 jne	 SHORT $LN19@struct_get

; 1918 :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 af 00 00 00	 jmp	 $LN23@struct_get
$LN19@struct_get:

; 1919 : 
; 1920 :     x = unpacker_new();

  00060	e8 00 00 00 00	 call	 unpacker_new
  00065	48 8b d8	 mov	 rbx, rax

; 1921 :     if (x == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	74 73		 je	 SHORT $error$21547

; 1922 :         goto error;
; 1923 : 
; 1924 :     format = PyBytes_FromString(fmt);

  0006d	49 8b cc	 mov	 rcx, r12
  00070	e8 00 00 00 00	 call	 PyBytes_FromString
  00075	48 8b f0	 mov	 rsi, rax

; 1925 :     if (format == NULL)

  00078	48 85 c0	 test	 rax, rax
  0007b	74 63		 je	 SHORT $error$21547

; 1926 :         goto error;
; 1927 : 
; 1928 :     structobj = PyObject_CallFunctionObjArgs(Struct, format, NULL);

  0007d	45 33 c0	 xor	 r8d, r8d
  00080	48 8b d0	 mov	 rdx, rax
  00083	48 8b cd	 mov	 rcx, rbp
  00086	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  0008b	48 8b f8	 mov	 rdi, rax

; 1929 :     if (structobj == NULL)

  0008e	48 85 c0	 test	 rax, rax
  00091	74 4d		 je	 SHORT $error$21547

; 1930 :         goto error;
; 1931 : 
; 1932 :     x->unpack_from = PyObject_GetAttrString(structobj, "unpack_from");

  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OJKBBEFN@unpack_from?$AA@
  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 PyObject_GetAttrString
  000a2	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1933 :     if (x->unpack_from == NULL)

  000a5	48 85 c0	 test	 rax, rax
  000a8	74 36		 je	 SHORT $error$21547

; 1934 :         goto error;
; 1935 : 
; 1936 :     x->item = PyMem_Malloc(itemsize);

  000aa	49 8b cd	 mov	 rcx, r13
  000ad	e8 00 00 00 00	 call	 PyMem_Malloc
  000b2	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1937 :     if (x->item == NULL) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	75 07		 jne	 SHORT $LN14@struct_get

; 1938 :         PyErr_NoMemory();

  000bb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1939 :         goto error;

  000c0	eb 1e		 jmp	 SHORT $error$21547
$LN14@struct_get:

; 1940 :     }
; 1941 :     x->itemsize = itemsize;
; 1942 : 
; 1943 :     x->mview = PyMemoryView_FromMemory(x->item, itemsize, PyBUF_WRITE);

  000c2	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  000c8	49 8b d5	 mov	 rdx, r13
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	4c 89 6b 18	 mov	 QWORD PTR [rbx+24], r13
  000d2	e8 00 00 00 00	 call	 PyMemoryView_FromMemory
  000d7	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1944 :     if (x->mview == NULL)

  000db	48 85 c0	 test	 rax, rax
  000de	75 0a		 jne	 SHORT $out$21560
$error$21547:

; 1953 : 
; 1954 : error:
; 1955 :     unpacker_free(x);

  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	e8 00 00 00 00	 call	 unpacker_free

; 1956 :     x = NULL;

  000e8	33 db		 xor	 ebx, ebx
$out$21560:

; 1945 :         goto error;
; 1946 : 
; 1947 : 
; 1948 : out:
; 1949 :     Py_XDECREF(Struct);

  000ea	48 8b cd	 mov	 rcx, rbp
  000ed	e8 00 00 00 00	 call	 _Py_DecRef

; 1950 :     Py_XDECREF(format);

  000f2	48 85 f6	 test	 rsi, rsi
  000f5	74 08		 je	 SHORT $LN7@struct_get
  000f7	48 8b ce	 mov	 rcx, rsi
  000fa	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@struct_get:

; 1951 :     Py_XDECREF(structobj);

  000ff	48 85 ff	 test	 rdi, rdi
  00102	74 08		 je	 SHORT $LN3@struct_get
  00104	48 8b cf	 mov	 rcx, rdi
  00107	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@struct_get:

; 1952 :     return x;

  0010c	48 8b c3	 mov	 rax, rbx
$LN23@struct_get:
  0010f	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN21@struct_get:

; 1957 :     goto out;
; 1958 : }

  00114	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00119	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0011e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00122	41 5d		 pop	 r13
  00124	41 5c		 pop	 r12
  00126	5f		 pop	 rdi
  00127	c3		 ret	 0
struct_get_unpacker ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$struct_unpack_single DD imagerel struct_unpack_single
	DD	imagerel struct_unpack_single+155
	DD	imagerel $unwind$struct_unpack_single
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_unpack_single DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT struct_unpack_single
_TEXT	SEGMENT
ptr$ = 64
x$ = 72
struct_unpack_single PROC				; COMDAT

; 1963 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1964 :     PyObject *v;
; 1965 : 
; 1966 :     memcpy(x->item, ptr, x->itemsize);

  0000a	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]
  0000e	48 8b da	 mov	 rbx, rdx
  00011	48 8b d1	 mov	 rdx, rcx
  00014	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00018	e8 00 00 00 00	 call	 memcpy

; 1967 :     v = PyObject_CallFunctionObjArgs(x->unpack_from, x->mview, NULL);

  0001d	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00021	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00024	45 33 c0	 xor	 r8d, r8d
  00027	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  0002c	48 8b f8	 mov	 rdi, rax

; 1968 :     if (v == NULL)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 0b		 jne	 SHORT $LN2@struct_unp

; 1976 :     }
; 1977 : 
; 1978 :     return v;
; 1979 : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN2@struct_unp:

; 1969 :         return NULL;
; 1970 : 
; 1971 :     if (PyTuple_GET_SIZE(v) == 1) {

  0003f	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00044	75 4a		 jne	 SHORT $LN3@struct_unp

; 1972 :         PyObject *tmp = PyTuple_GET_ITEM(v, 0);

  00046	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]

; 1973 :         Py_INCREF(tmp);

  0004a	e8 00 00 00 00	 call	 _Py_PXCTX
  0004f	85 c0		 test	 eax, eax
  00051	75 32		 jne	 SHORT $LN6@struct_unp
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00061	4c 8b cb	 mov	 r9, rbx
  00064	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00072	e8 00 00 00 00	 call	 _PyParallel_Guard
  00077	85 c0		 test	 eax, eax
  00079	75 06		 jne	 SHORT $LN5@struct_unp
  0007b	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0007f	74 04		 je	 SHORT $LN6@struct_unp
$LN5@struct_unp:
  00081	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@struct_unp:

; 1974 :         Py_DECREF(v);

  00085	48 8b cf	 mov	 rcx, rdi
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 1975 :         return tmp;

  0008d	48 8b c3	 mov	 rax, rbx
$LN3@struct_unp:

; 1976 :     }
; 1977 : 
; 1978 :     return v;
; 1979 : }

  00090	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00095	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
struct_unpack_single ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$adjust_fmt DD imagerel adjust_fmt
	DD	imagerel adjust_fmt+58
	DD	imagerel $unwind$adjust_fmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adjust_fmt DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
CONST	SEGMENT
??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@ DB 'memoryvie'
	DB	'w: unsupported format %s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT adjust_fmt
_TEXT	SEGMENT
view$ = 48
adjust_fmt PROC						; COMDAT

; 1989 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1990 :     const char *fmt;
; 1991 : 
; 1992 :     fmt = (view->format[0] == '@') ? view->format+1 : view->format;

  00004	4c 8b 41 28	 mov	 r8, QWORD PTR [rcx+40]
  00008	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0000c	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00010	74 03		 je	 SHORT $LN5@adjust_fmt
  00012	49 8b c0	 mov	 rax, r8
$LN5@adjust_fmt:

; 1993 :     if (fmt[0] && fmt[1] == '\0')

  00015	80 38 00	 cmp	 BYTE PTR [rax], 0
  00018	74 06		 je	 SHORT $LN1@adjust_fmt
  0001a	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0

; 1994 :         return fmt;

  0001e	74 15		 je	 SHORT $LN2@adjust_fmt
$LN1@adjust_fmt:

; 1995 : 
; 1996 :     PyErr_Format(PyExc_NotImplementedError,
; 1997 :         "memoryview: unsupported format %s", view->format);

  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
  0002e	e8 00 00 00 00	 call	 PyErr_Format

; 1998 :     return NULL;

  00033	33 c0		 xor	 eax, eax
$LN2@adjust_fmt:

; 1999 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
adjust_fmt ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tolist_base DD imagerel tolist_base
	DD	imagerel tolist_base+47
	DD	imagerel $unwind$tolist_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$tolist_base DD imagerel tolist_base+47
	DD	imagerel tolist_base+139
	DD	imagerel $chain$1$tolist_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$tolist_base DD imagerel tolist_base+139
	DD	imagerel tolist_base+159
	DD	imagerel $chain$2$tolist_base
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$tolist_base DD imagerel tolist_base+159
	DD	imagerel tolist_base+171
	DD	imagerel $chain$3$tolist_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$tolist_base DD 040021H
	DD	09e400H
	DD	087400H
	DD	imagerel tolist_base
	DD	imagerel tolist_base+47
	DD	imagerel $unwind$tolist_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$tolist_base DD 021H
	DD	imagerel tolist_base
	DD	imagerel tolist_base+47
	DD	imagerel $unwind$tolist_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$tolist_base DD 040c21H
	DD	09e40cH
	DD	087405H
	DD	imagerel tolist_base
	DD	imagerel tolist_base+47
	DD	imagerel $unwind$tolist_base
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tolist_base DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0d00f3213H
	DD	0600bc00dH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT tolist_base
_TEXT	SEGMENT
ptr$ = 64
shape$ = 72
strides$ = 80
suboffsets$ = 88
fmt$ = 96
tolist_base PROC					; COMDAT

; 2006 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00013	48 8b d9	 mov	 rbx, rcx

; 2007 :     PyObject *lst, *item;
; 2008 :     Py_ssize_t i;
; 2009 : 
; 2010 :     lst = PyList_New(shape[0]);

  00016	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00019	49 8b f1	 mov	 rsi, r9
  0001c	4d 8b e8	 mov	 r13, r8
  0001f	4c 8b e2	 mov	 r12, rdx
  00022	e8 00 00 00 00	 call	 PyList_New
  00027	48 8b e8	 mov	 rbp, rax

; 2011 :     if (lst == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	74 5c		 je	 SHORT $LN6@tolist_bas
$LN5@tolist_bas:
  0002f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 2012 :         return NULL;
; 2013 : 
; 2014 :     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {

  00034	33 ff		 xor	 edi, edi
  00036	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14
  0003b	49 39 3c 24	 cmp	 QWORD PTR [r12], rdi
  0003f	7e 3d		 jle	 SHORT $LN2@tolist_bas
  00041	4c 8b 74 24 60	 mov	 r14, QWORD PTR fmt$[rsp]
$LL4@tolist_bas:

; 2015 :         const char *xptr = ADJUST_PTR(ptr, suboffsets);

  00046	48 85 f6	 test	 rsi, rsi
  00049	74 0d		 je	 SHORT $LN8@tolist_bas
  0004b	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0004e	48 85 c9	 test	 rcx, rcx
  00051	78 05		 js	 SHORT $LN8@tolist_bas
  00053	48 03 0b	 add	 rcx, QWORD PTR [rbx]
  00056	eb 03		 jmp	 SHORT $LN9@tolist_bas
$LN8@tolist_bas:
  00058	48 8b cb	 mov	 rcx, rbx
$LN9@tolist_bas:

; 2016 :         item = unpack_single(xptr, fmt);

  0005b	49 8b d6	 mov	 rdx, r14
  0005e	e8 00 00 00 00	 call	 unpack_single

; 2017 :         if (item == NULL) {

  00063	48 85 c0	 test	 rax, rax
  00066	74 37		 je	 SHORT $LN11@tolist_bas

; 2020 :         }
; 2021 :         PyList_SET_ITEM(lst, i, item);

  00068	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  0006c	48 ff c7	 inc	 rdi
  0006f	48 89 44 f9 f8	 mov	 QWORD PTR [rcx+rdi*8-8], rax
  00074	49 03 5d 00	 add	 rbx, QWORD PTR [r13]
  00078	49 3b 3c 24	 cmp	 rdi, QWORD PTR [r12]
  0007c	7c c8		 jl	 SHORT $LL4@tolist_bas
$LN2@tolist_bas:

; 2022 :     }
; 2023 : 
; 2024 :     return lst;

  0007e	48 8b c5	 mov	 rax, rbp
$LN14@tolist_bas:
  00081	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00086	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
$LN6@tolist_bas:

; 2025 : }

  0008b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00090	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	41 5d		 pop	 r13
  0009b	41 5c		 pop	 r12
  0009d	5e		 pop	 rsi
  0009e	c3		 ret	 0
$LN11@tolist_bas:

; 2018 :             Py_DECREF(lst);

  0009f	48 8b cd	 mov	 rcx, rbp
  000a2	e8 00 00 00 00	 call	 _Py_DecRef

; 2019 :             return NULL;

  000a7	33 c0		 xor	 eax, eax
  000a9	eb d6		 jmp	 SHORT $LN14@tolist_bas
tolist_base ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tolist_rec DD imagerel tolist_rec
	DD	imagerel tolist_rec+76
	DD	imagerel $unwind$tolist_rec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$tolist_rec DD imagerel tolist_rec+76
	DD	imagerel tolist_rec+106
	DD	imagerel $chain$0$tolist_rec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$tolist_rec DD imagerel tolist_rec+106
	DD	imagerel tolist_rec+293
	DD	imagerel $chain$3$tolist_rec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$tolist_rec DD imagerel tolist_rec+293
	DD	imagerel tolist_rec+320
	DD	imagerel $chain$5$tolist_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$tolist_rec DD 040021H
	DD	086400H
	DD	0c5400H
	DD	imagerel tolist_rec
	DD	imagerel tolist_rec+76
	DD	imagerel $unwind$tolist_rec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$tolist_rec DD 040a21H
	DD	08640aH
	DD	0c5400H
	DD	imagerel tolist_rec
	DD	imagerel tolist_rec+76
	DD	imagerel $unwind$tolist_rec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$tolist_rec DD 020521H
	DD	0c5405H
	DD	imagerel tolist_rec
	DD	imagerel tolist_rec+76
	DD	imagerel $unwind$tolist_rec
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tolist_rec DD 031001H
	DD	0700c8210H
	DD	0300bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT tolist_rec
_TEXT	SEGMENT
tv203 = 48
ptr$ = 96
tv205 = 104
ndim$ = 104
shape$ = 112
strides$ = 120
suboffsets$ = 128
fmt$ = 136
tolist_rec PROC						; COMDAT

; 2033 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	53		 push	 rbx
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00010	4d 8b d9	 mov	 r11, r9
  00013	4d 8b d0	 mov	 r10, r8
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f9	 mov	 rdi, rcx

; 2034 :     PyObject *lst, *item;
; 2035 :     Py_ssize_t i;
; 2036 : 
; 2037 :     assert(ndim >= 1);
; 2038 :     assert(shape != NULL);
; 2039 :     assert(strides != NULL);
; 2040 : 
; 2041 :     if (ndim == 1)

  0001c	48 83 fa 01	 cmp	 rdx, 1
  00020	75 27		 jne	 SHORT $LN6@tolist_rec

; 2042 :         return tolist_base(ptr, shape, strides, suboffsets, fmt);

  00022	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fmt$[rsp]
  0002a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR suboffsets$[rsp]
  00032	4d 8b c3	 mov	 r8, r11
  00035	49 8b d2	 mov	 rdx, r10
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	e8 00 00 00 00	 call	 tolist_base

; 2061 : }

  00042	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00046	5f		 pop	 rdi
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN6@tolist_rec:

; 2043 : 
; 2044 :     lst = PyList_New(shape[0]);

  00049	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  0004c	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00051	e8 00 00 00 00	 call	 PyList_New
  00056	48 8b e8	 mov	 rbp, rax

; 2045 :     if (lst == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 0c		 jne	 SHORT $LN5@tolist_rec
  0005e	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 2061 : }

  00063	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00067	5f		 pop	 rdi
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN5@tolist_rec:

; 2046 :         return NULL;
; 2047 : 
; 2048 :     for (i = 0; i < shape[0]; ptr+=strides[0], i++) {

  0006a	48 8b 44 24 70	 mov	 rax, QWORD PTR shape$[rsp]
  0006f	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00074	33 f6		 xor	 esi, esi
  00076	48 39 30	 cmp	 QWORD PTR [rax], rsi
  00079	0f 8e 92 00 00
	00		 jle	 $LN2@tolist_rec
  0007f	48 8b 54 24 78	 mov	 rdx, QWORD PTR strides$[rsp]
  00084	4c 8d 53 ff	 lea	 r10, QWORD PTR [rbx-1]
  00088	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR suboffsets$[rsp]
  00090	48 83 c2 08	 add	 rdx, 8
  00094	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00098	4c 89 54 24 30	 mov	 QWORD PTR tv203[rsp], r10
  0009d	48 89 54 24 68	 mov	 QWORD PTR tv205[rsp], rdx
$LL4@tolist_rec:

; 2049 :         const char *xptr = ADJUST_PTR(ptr, suboffsets);

  000a2	48 85 db	 test	 rbx, rbx
  000a5	74 0d		 je	 SHORT $LN9@tolist_rec
  000a7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000aa	48 85 c9	 test	 rcx, rcx
  000ad	78 05		 js	 SHORT $LN9@tolist_rec
  000af	48 03 0f	 add	 rcx, QWORD PTR [rdi]
  000b2	eb 03		 jmp	 SHORT $LN10@tolist_rec
$LN9@tolist_rec:
  000b4	48 8b cf	 mov	 rcx, rdi
$LN10@tolist_rec:

; 2050 :         item = tolist_rec(xptr, ndim-1, shape+1,
; 2051 :                           strides+1, suboffsets ? suboffsets+1 : NULL,
; 2052 :                           fmt);

  000b7	48 85 db	 test	 rbx, rbx
  000ba	74 06		 je	 SHORT $LN11@tolist_rec
  000bc	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
  000c0	eb 02		 jmp	 SHORT $LN12@tolist_rec
$LN11@tolist_rec:
  000c2	33 c0		 xor	 eax, eax
$LN12@tolist_rec:
  000c4	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR fmt$[rsp]
  000cc	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  000d1	4c 8b ca	 mov	 r9, rdx
  000d4	49 8b d2	 mov	 rdx, r10
  000d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dc	e8 00 00 00 00	 call	 tolist_rec

; 2053 :         if (item == NULL) {

  000e1	48 85 c0	 test	 rax, rax
  000e4	74 3f		 je	 SHORT $LN14@tolist_rec

; 2056 :         }
; 2057 :         PyList_SET_ITEM(lst, i, item);

  000e6	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  000ea	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv205[rsp]
  000ef	4c 8b 54 24 30	 mov	 r10, QWORD PTR tv203[rsp]
  000f4	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000f8	48 8b 44 24 78	 mov	 rax, QWORD PTR strides$[rsp]
  000fd	48 ff c6	 inc	 rsi
  00100	48 03 38	 add	 rdi, QWORD PTR [rax]
  00103	48 8b 44 24 70	 mov	 rax, QWORD PTR shape$[rsp]
  00108	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  0010c	48 3b 30	 cmp	 rsi, QWORD PTR [rax]
  0010f	7c 91		 jl	 SHORT $LL4@tolist_rec
$LN2@tolist_rec:
  00111	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2058 :     }
; 2059 : 
; 2060 :     return lst;

  00116	48 8b c5	 mov	 rax, rbp
  00119	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 2061 : }

  0011e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00122	5f		 pop	 rdi
  00123	5b		 pop	 rbx
  00124	c3		 ret	 0
$LN14@tolist_rec:

; 2054 :             Py_DECREF(lst);

  00125	48 8b cd	 mov	 rcx, rbp
  00128	e8 00 00 00 00	 call	 _Py_DecRef
  0012d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00132	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 2055 :             return NULL;

  00137	33 c0		 xor	 eax, eax

; 2061 : }

  00139	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013d	5f		 pop	 rdi
  0013e	5b		 pop	 rbx
  0013f	c3		 ret	 0
tolist_rec ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_tolist DD imagerel memory_tolist
	DD	imagerel memory_tolist+244
	DD	imagerel $unwind$memory_tolist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_tolist DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_tolist
_TEXT	SEGMENT
mv$ = 64
noargs$ = 72
memory_tolist PROC					; COMDAT

; 2067 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2068 :     const Py_buffer *view = &(mv->view);
; 2069 :     const char *fmt;
; 2070 : 
; 2071 :     CHECK_RELEASED(mv);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	0f 85 c9 00 00
	00		 jne	 $LN6@memory_tol
  00011	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00015	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00019	0f 85 bb 00 00
	00		 jne	 $LN6@memory_tol

; 2072 : 
; 2073 :     fmt = adjust_fmt(view);

  0001f	4c 8b 81 b8 00
	00 00		 mov	 r8, QWORD PTR [rcx+184]
  00026	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0002a	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  0002e	74 03		 je	 SHORT $LN14@memory_tol
  00030	49 8b c0	 mov	 rax, r8
$LN14@memory_tol:
  00033	80 38 00	 cmp	 BYTE PTR [rax], 0
  00036	0f 84 84 00 00
	00		 je	 $LN10@memory_tol
  0003c	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0
  00040	75 7e		 jne	 SHORT $LN10@memory_tol

; 2074 :     if (fmt == NULL)
; 2075 :         return NULL;
; 2076 :     if (view->ndim == 0) {

  00042	48 63 91 b4 00
	00 00		 movsxd	 rdx, DWORD PTR [rcx+180]
  00049	85 d2		 test	 edx, edx
  0004b	75 13		 jne	 SHORT $LN4@memory_tol

; 2077 :         return unpack_single(view->buf, fmt);

  0004d	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00054	48 8b d0	 mov	 rdx, rax

; 2088 :     }
; 2089 : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	e9 00 00 00 00	 jmp	 unpack_single
$LN4@memory_tol:

; 2078 :     }
; 2079 :     else if (view->ndim == 1) {

  00060	83 fa 01	 cmp	 edx, 1
  00063	75 2b		 jne	 SHORT $LN2@memory_tol

; 2080 :         return tolist_base(view->buf, view->shape,
; 2081 :                            view->strides, view->suboffsets,
; 2082 :                            fmt);

  00065	4c 8b 89 d0 00
	00 00		 mov	 r9, QWORD PTR [rcx+208]
  0006c	4c 8b 81 c8 00
	00 00		 mov	 r8, QWORD PTR [rcx+200]
  00073	48 8b 91 c0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+192]
  0007a	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00081	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00086	e8 00 00 00 00	 call	 tolist_base

; 2088 :     }
; 2089 : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
$LN2@memory_tol:

; 2083 :     }
; 2084 :     else {
; 2085 :         return tolist_rec(view->buf, view->ndim, view->shape,
; 2086 :                           view->strides, view->suboffsets,
; 2087 :                           fmt);

  00090	4c 8b 89 c8 00
	00 00		 mov	 r9, QWORD PTR [rcx+200]
  00097	4c 8b 81 c0 00
	00 00		 mov	 r8, QWORD PTR [rcx+192]
  0009e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a3	48 8b 81 d0 00
	00 00		 mov	 rax, QWORD PTR [rcx+208]
  000aa	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  000b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b6	e8 00 00 00 00	 call	 tolist_rec

; 2088 :     }
; 2089 : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0

; 2072 : 
; 2073 :     fmt = adjust_fmt(view);

$LN10@memory_tol:
  000c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
  000ce	e8 00 00 00 00	 call	 PyErr_Format
  000d3	33 c0		 xor	 eax, eax

; 2088 :     }
; 2089 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
$LN6@memory_tol:

; 2068 :     const Py_buffer *view = &(mv->view);
; 2069 :     const char *fmt;
; 2070 : 
; 2071 :     CHECK_RELEASED(mv);

  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  000e8	e8 00 00 00 00	 call	 PyErr_SetString
  000ed	33 c0		 xor	 eax, eax

; 2088 :     }
; 2089 : }

  000ef	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f3	c3		 ret	 0
memory_tolist ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_tobytes DD imagerel memory_tobytes
	DD	imagerel memory_tobytes+58
	DD	imagerel $unwind$memory_tobytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memory_tobytes DD imagerel memory_tobytes+58
	DD	imagerel memory_tobytes+116
	DD	imagerel $chain$0$memory_tobytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$memory_tobytes DD imagerel memory_tobytes+116
	DD	imagerel memory_tobytes+130
	DD	imagerel $chain$2$memory_tobytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$memory_tobytes DD imagerel memory_tobytes+130
	DD	imagerel memory_tobytes+157
	DD	imagerel $chain$3$memory_tobytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$memory_tobytes DD 021H
	DD	imagerel memory_tobytes
	DD	imagerel memory_tobytes+58
	DD	imagerel $unwind$memory_tobytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$memory_tobytes DD 020021H
	DD	063400H
	DD	imagerel memory_tobytes
	DD	imagerel memory_tobytes+58
	DD	imagerel $unwind$memory_tobytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memory_tobytes DD 020521H
	DD	063405H
	DD	imagerel memory_tobytes
	DD	imagerel memory_tobytes+58
	DD	imagerel $unwind$memory_tobytes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_tobytes DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_tobytes
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_tobytes PROC					; COMDAT

; 2093 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2094 :     Py_buffer *src = VIEW_ADDR(self);
; 2095 :     PyObject *bytes = NULL;
; 2096 : 
; 2097 :     CHECK_RELEASED(self);

  00006	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [rcx+128]
  0000c	48 8d b9 90 00
	00 00		 lea	 rdi, QWORD PTR [rcx+144]
  00013	f6 c2 01	 test	 dl, 1
  00016	75 6a		 jne	 SHORT $LN4@memory_tob
  00018	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0001c	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00020	75 60		 jne	 SHORT $LN4@memory_tob

; 2098 : 
; 2099 :     if (MV_C_CONTIGUOUS(self->flags)) {

  00022	f6 c2 0a	 test	 dl, 10

; 2100 :         return PyBytes_FromStringAndSize(src->buf, src->len);

  00025	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00029	74 0d		 je	 SHORT $LN3@memory_tob
  0002b	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]

; 2113 : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
$LN3@memory_tob:

; 2101 :     }
; 2102 : 
; 2103 :     bytes = PyBytes_FromStringAndSize(NULL, src->len);

  00038	33 c9		 xor	 ecx, ecx
  0003a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00044	48 8b d8	 mov	 rbx, rax

; 2104 :     if (bytes == NULL)

  00047	48 85 c0	 test	 rax, rax

; 2105 :         return NULL;

  0004a	74 1b		 je	 SHORT $LN9@memory_tob

; 2106 : 
; 2107 :     if (buffer_to_contiguous(PyBytes_AS_STRING(bytes), src, 'C') < 0) {

  0004c	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00050	41 b0 43	 mov	 r8b, 67			; 00000043H
  00053	48 8b d7	 mov	 rdx, rdi
  00056	e8 00 00 00 00	 call	 buffer_to_contiguous
  0005b	85 c0		 test	 eax, eax
  0005d	79 15		 jns	 SHORT $LN1@memory_tob

; 2108 :         Py_DECREF(bytes);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@memory_tob:

; 2109 :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2113 : }

  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN1@memory_tob:

; 2110 :     }
; 2111 : 
; 2112 :     return bytes;

  00074	48 8b c3	 mov	 rax, rbx
  00077	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2113 : }

  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN4@memory_tob:

; 2094 :     Py_buffer *src = VIEW_ADDR(self);
; 2095 :     PyObject *bytes = NULL;
; 2096 : 
; 2097 :     CHECK_RELEASED(self);

  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00090	e8 00 00 00 00	 call	 PyErr_SetString
  00095	33 c0		 xor	 eax, eax

; 2113 : }

  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
memory_tobytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT ??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@ DB '<memory at %p>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@
CONST	SEGMENT
??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@ DB '<released'
	DB	' memory at %p>', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_repr
_TEXT	SEGMENT
self$ = 8
memory_repr PROC					; COMDAT

; 2118 :     if (self->flags & _Py_MEMORYVIEW_RELEASED)

  00000	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1

; 2119 :         return PyUnicode_FromFormat("<released memory at %p>", self);

  00007	48 8b d1	 mov	 rdx, rcx
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@FNECJCPN@?$DMreleased?5memory?5at?5?$CFp?$DO?$AA@
  00011	75 07		 jne	 SHORT $LN5@memory_rep

; 2120 :     else
; 2121 :         return PyUnicode_FromFormat("<memory at %p>", self);

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FFPFCENE@?$DMmemory?5at?5?$CFp?$DO?$AA@
$LN5@memory_rep:

; 2122 : }

  0001a	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
memory_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@	; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ptr_from_index DD imagerel ptr_from_index
	DD	imagerel ptr_from_index+92
	DD	imagerel $unwind$ptr_from_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ptr_from_index DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@
CONST	SEGMENT
??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@ DB 'index out of bounds', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ptr_from_index
_TEXT	SEGMENT
view$ = 48
index$ = 56
ptr_from_index PROC					; COMDAT

; 2132 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2133 :     char *ptr;
; 2134 :     Py_ssize_t nitems; /* items in the first dimension */
; 2135 : 
; 2136 :     assert(view->shape);
; 2137 :     assert(view->strides);
; 2138 : 
; 2139 :     nitems = view->shape[0];

  00004	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00008	4c 8b 00	 mov	 r8, QWORD PTR [rax]

; 2140 :     if (index < 0) {

  0000b	48 85 d2	 test	 rdx, rdx
  0000e	79 05		 jns	 SHORT $LN8@ptr_from_i

; 2141 :         index += nitems;

  00010	49 03 d0	 add	 rdx, r8

; 2142 :     }
; 2143 :     if (index < 0 || index >= nitems) {

  00013	78 2d		 js	 SHORT $LN1@ptr_from_i
$LN8@ptr_from_i:
  00015	49 3b d0	 cmp	 rdx, r8
  00018	7d 28		 jge	 SHORT $LN1@ptr_from_i

; 2146 :     }
; 2147 : 
; 2148 :     ptr = (char *)view->buf;
; 2149 :     ptr += view->strides[0] * index;

  0001a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 0f af c2	 imul	 rax, rdx
  00025	48 03 01	 add	 rax, QWORD PTR [rcx]

; 2150 : 
; 2151 :     ptr = ADJUST_PTR(ptr, view->suboffsets);

  00028	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002c	48 85 c9	 test	 rcx, rcx
  0002f	74 26		 je	 SHORT $LN4@ptr_from_i
  00031	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00035	7c 20		 jl	 SHORT $LN4@ptr_from_i
  00037	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003a	48 03 01	 add	 rax, QWORD PTR [rcx]

; 2152 : 
; 2153 :     return ptr;
; 2154 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN1@ptr_from_i:

; 2144 :         PyErr_SetString(PyExc_IndexError, "index out of bounds");

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@PJNGABLJ@index?5out?5of?5bounds?$AA@
  00050	e8 00 00 00 00	 call	 PyErr_SetString

; 2145 :         return NULL;

  00055	33 c0		 xor	 eax, eax
$LN4@ptr_from_i:

; 2152 : 
; 2153 :     return ptr;
; 2154 : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
ptr_from_index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@ ; `string'
PUBLIC	??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_item DD imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$memory_item DD imagerel memory_item+38
	DD	imagerel memory_item+108
	DD	imagerel $chain$0$memory_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$memory_item DD imagerel memory_item+108
	DD	imagerel memory_item+150
	DD	imagerel $chain$2$memory_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$memory_item DD imagerel memory_item+150
	DD	imagerel memory_item+181
	DD	imagerel $chain$4$memory_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$memory_item DD imagerel memory_item+181
	DD	imagerel memory_item+212
	DD	imagerel $chain$6$memory_item
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$memory_item DD imagerel memory_item+212
	DD	imagerel memory_item+238
	DD	imagerel $chain$7$memory_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$memory_item DD 021H
	DD	imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$memory_item DD 020021H
	DD	043400H
	DD	imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$memory_item DD 020021H
	DD	043400H
	DD	imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$memory_item DD 020021H
	DD	043400H
	DD	imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$memory_item DD 020521H
	DD	043405H
	DD	imagerel memory_item
	DD	imagerel memory_item+38
	DD	imagerel $unwind$memory_item
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_item DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@
CONST	SEGMENT
??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@ DB 'multi-dimen'
	DB	'sional sub-views are not implemented', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
CONST	SEGMENT
??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@ DB 'invalid ind'
	DB	'exing of 0-dim memory', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_item
_TEXT	SEGMENT
self$ = 48
index$ = 56
memory_item PROC					; COMDAT

; 2161 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2162 :     Py_buffer *view = &(self->view);
; 2163 :     const char *fmt;
; 2164 : 
; 2165 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	0f 85 c3 00 00
	00		 jne	 $LN5@memory_ite
  00011	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00015	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00019	0f 85 b5 00 00
	00		 jne	 $LN5@memory_ite

; 2166 : 
; 2167 :     fmt = adjust_fmt(view);

  0001f	4c 8b 81 b8 00
	00 00		 mov	 r8, QWORD PTR [rcx+184]
  00026	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002b	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0002f	49 8d 58 01	 lea	 rbx, QWORD PTR [r8+1]
  00033	74 03		 je	 SHORT $LN13@memory_ite
  00035	49 8b d8	 mov	 rbx, r8
$LN13@memory_ite:
  00038	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  0003b	74 78		 je	 SHORT $LN9@memory_ite
  0003d	80 7b 01 00	 cmp	 BYTE PTR [rbx+1], 0
  00041	75 72		 jne	 SHORT $LN9@memory_ite

; 2168 :     if (fmt == NULL)
; 2169 :         return NULL;
; 2170 : 
; 2171 :     if (view->ndim == 0) {

  00043	8b 81 b4 00 00
	00		 mov	 eax, DWORD PTR [rcx+180]
  00049	85 c0		 test	 eax, eax
  0004b	75 1f		 jne	 SHORT $LN3@memory_ite

; 2172 :         PyErr_SetString(PyExc_TypeError, "invalid indexing of 0-dim memory");

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@
  0005b	e8 00 00 00 00	 call	 PyErr_SetString
$LN16@memory_ite:

; 2184 :     return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2185 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
$LN3@memory_ite:

; 2173 :         return NULL;
; 2174 :     }
; 2175 :     if (view->ndim == 1) {

  0006c	83 f8 01	 cmp	 eax, 1
  0006f	75 25		 jne	 SHORT $LN2@memory_ite

; 2176 :         char *ptr = ptr_from_index(view, index);

  00071	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  00078	e8 00 00 00 00	 call	 ptr_from_index

; 2177 :         if (ptr == NULL)

  0007d	48 85 c0	 test	 rax, rax

; 2178 :             return NULL;

  00080	74 de		 je	 SHORT $LN16@memory_ite

; 2179 :         return unpack_single(ptr, fmt);

  00082	48 8b d3	 mov	 rdx, rbx
  00085	48 8b c8	 mov	 rcx, rax
  00088	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2185 : }

  0008d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00091	e9 00 00 00 00	 jmp	 unpack_single
$LN2@memory_ite:

; 2180 :     }
; 2181 : 
; 2182 :     PyErr_SetString(PyExc_NotImplementedError,
; 2183 :         "multi-dimensional sub-views are not implemented");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@HBCJDDJF@multi?9dimensional?5sub?9views?5are?5@
  000a4	e8 00 00 00 00	 call	 PyErr_SetString
  000a9	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2184 :     return NULL;

  000ae	33 c0		 xor	 eax, eax

; 2185 : }

  000b0	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b4	c3		 ret	 0

; 2166 : 
; 2167 :     fmt = adjust_fmt(view);

$LN9@memory_ite:
  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
  000c3	e8 00 00 00 00	 call	 PyErr_Format
  000c8	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2184 :     return NULL;

  000cd	33 c0		 xor	 eax, eax

; 2185 : }

  000cf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d3	c3		 ret	 0
$LN5@memory_ite:

; 2162 :     Py_buffer *view = &(self->view);
; 2163 :     const char *fmt;
; 2164 : 
; 2165 :     CHECK_RELEASED(self);

  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  000e2	e8 00 00 00 00	 call	 PyErr_SetString
  000e7	33 c0		 xor	 eax, eax

; 2185 : }

  000e9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ed	c3		 ret	 0
memory_item ENDP
_TEXT	ENDS
EXTRN	PySlice_GetIndicesEx:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_slice DD imagerel init_slice
	DD	imagerel init_slice+221
	DD	imagerel $unwind$init_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_slice DD 061001H
	DD	0c6410H
	DD	0b3410H
	DD	0700c7210H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT init_slice
_TEXT	SEGMENT
step$ = 48
start$ = 80
base$ = 80
key$ = 88
dim$ = 96
slicelength$ = 104
init_slice PROC						; COMDAT

; 2189 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00007	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00010	48 8b c2	 mov	 rax, rdx

; 2190 :     Py_ssize_t start, stop, step, slicelength;
; 2191 : 
; 2192 :     if (PySlice_GetIndicesEx(key, base->shape[dim],
; 2193 :                              &start, &stop, &step, &slicelength) < 0) {

  00013	48 8b 51 30	 mov	 rdx, QWORD PTR [rcx+48]
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001e	49 63 f0	 movsxd	 rsi, r8d
  00021	4d 8d 4b f0	 lea	 r9, QWORD PTR [r11-16]
  00025	48 8b 14 f2	 mov	 rdx, QWORD PTR [rdx+rsi*8]
  00029	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  0002d	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  00031	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00035	4d 8d 43 08	 lea	 r8, QWORD PTR [r11+8]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00041	85 c0		 test	 eax, eax
  00043	79 13		 jns	 SHORT $LN7@init_slice

; 2194 :         return -1;

  00045	83 c8 ff	 or	 eax, -1

; 2212 : 
; 2213 :     return 0;
; 2214 : }

  00048	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0004d	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00052	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
$LN7@init_slice:

; 2195 :     }
; 2196 : 
; 2197 : 
; 2198 :     if (base->suboffsets == NULL || dim == 0) {

  00058	4c 8b 43 40	 mov	 r8, QWORD PTR [rbx+64]
  0005c	4d 85 c0	 test	 r8, r8
  0005f	74 21		 je	 SHORT $adjust_buf$21777
  00061	85 f6		 test	 esi, esi
  00063	74 1d		 je	 SHORT $adjust_buf$21777

; 2201 :     }
; 2202 :     else {
; 2203 :         Py_ssize_t n = dim-1;

  00065	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00068	48 63 d0	 movsxd	 rdx, eax

; 2204 :         while (n >= 0 && base->suboffsets[n] < 0)

  0006b	85 c0		 test	 eax, eax
  0006d	78 13		 js	 SHORT $adjust_buf$21777

; 2201 :     }
; 2202 :     else {
; 2203 :         Py_ssize_t n = dim-1;

  0006f	49 8d 04 d0	 lea	 rax, QWORD PTR [r8+rdx*8]
$LL3@init_slice:

; 2204 :         while (n >= 0 && base->suboffsets[n] < 0)

  00073	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00077	7d 4b		 jge	 SHORT $LN2@init_slice

; 2205 :             n--;

  00079	48 83 e8 08	 sub	 rax, 8
  0007d	48 ff ca	 dec	 rdx
  00080	79 f1		 jns	 SHORT $LL3@init_slice
$adjust_buf$21777:

; 2199 :     adjust_buf:
; 2200 :         base->buf = (char *)base->buf + base->strides[dim] * start;

  00082	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00086	48 8b 0c f0	 mov	 rcx, QWORD PTR [rax+rsi*8]
  0008a	48 0f af 4c 24
	50		 imul	 rcx, QWORD PTR start$[rsp]
  00090	48 01 0b	 add	 QWORD PTR [rbx], rcx
$LN4@init_slice:

; 2209 :     }
; 2210 :     base->shape[dim] = slicelength;

  00093	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00097	48 8b 44 24 68	 mov	 rax, QWORD PTR slicelength$[rsp]
  0009c	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax

; 2211 :     base->strides[dim] = base->strides[dim] * step;

  000a0	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]

; 2212 : 
; 2213 :     return 0;
; 2214 : }

  000a4	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000a9	48 8b 04 f1	 mov	 rax, QWORD PTR [rcx+rsi*8]
  000ad	48 0f af 44 24
	30		 imul	 rax, QWORD PTR step$[rsp]
  000b3	48 89 04 f1	 mov	 QWORD PTR [rcx+rsi*8], rax
  000b7	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000bc	33 c0		 xor	 eax, eax
  000be	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
$LN2@init_slice:

; 2206 :         if (n < 0)

  000c4	48 85 d2	 test	 rdx, rdx
  000c7	78 b9		 js	 SHORT $adjust_buf$21777

; 2207 :             goto adjust_buf; /* all suboffsets are negative */
; 2208 :         base->suboffsets[n] = base->suboffsets[n] + base->strides[dim] * start;

  000c9	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000cd	48 8b 0c f0	 mov	 rcx, QWORD PTR [rax+rsi*8]
  000d1	48 0f af 4c 24
	50		 imul	 rcx, QWORD PTR start$[rsp]
  000d7	49 01 0c d0	 add	 QWORD PTR [r8+rdx*8], rcx
  000db	eb b6		 jmp	 SHORT $LN4@init_slice
init_slice ENDP
_TEXT	ENDS
EXTRN	PySlice_Type:BYTE
; Function compile flags: /Ogtpy
;	COMDAT is_multislice
_TEXT	SEGMENT
key$ = 8
is_multislice PROC					; COMDAT

; 2219 :     Py_ssize_t size, i;
; 2220 : 
; 2221 :     if (!PyTuple_Check(key))

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 8b d1	 mov	 rdx, rcx
  00007	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00011	75 03		 jne	 SHORT $LN6@is_multisl
$LN12@is_multisl:

; 2222 :         return 0;

  00013	33 c0		 xor	 eax, eax

; 2233 : }

  00015	c3		 ret	 0
$LN6@is_multisl:

; 2223 :     size = PyTuple_GET_SIZE(key);

  00016	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]

; 2224 :     if (size == 0)

  0001a	4d 85 c0	 test	 r8, r8

; 2225 :         return 0;

  0001d	74 f4		 je	 SHORT $LN12@is_multisl

; 2226 : 
; 2227 :     for (i = 0; i < size; i++) {

  0001f	33 c9		 xor	 ecx, ecx
  00021	4d 85 c0	 test	 r8, r8
  00024	7e 20		 jle	 SHORT $LN2@is_multisl
  00026	48 83 c2 70	 add	 rdx, 112		; 00000070H
  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PySlice_Type
$LL4@is_multisl:

; 2228 :         PyObject *x = PyTuple_GET_ITEM(key, i);
; 2229 :         if (!PySlice_Check(x))

  00031	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00034	4c 39 48 58	 cmp	 QWORD PTR [rax+88], r9
  00038	75 d9		 jne	 SHORT $LN12@is_multisl

; 2226 : 
; 2227 :     for (i = 0; i < size; i++) {

  0003a	48 ff c1	 inc	 rcx
  0003d	48 83 c2 08	 add	 rdx, 8
  00041	49 3b c8	 cmp	 rcx, r8
  00044	7c eb		 jl	 SHORT $LL4@is_multisl
$LN2@is_multisl:

; 2230 :             return 0;
; 2231 :     }
; 2232 :     return 1;

  00046	b8 01 00 00 00	 mov	 eax, 1

; 2233 : }

  0004b	c3		 ret	 0
is_multislice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@ ; `string'
PUBLIC	??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@ ; `string'
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	_Py_EllipsisObject:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_subscript DD imagerel memory_subscript
	DD	imagerel memory_subscript+539
	DD	imagerel $unwind$memory_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_subscript DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@
CONST	SEGMENT
??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@ DB 'memoryview:'
	DB	' invalid slice key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@
CONST	SEGMENT
??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@ DB 'multi-dimens'
	DB	'ional slicing is not implemented', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_subscript
_TEXT	SEGMENT
self$ = 48
key$ = 56
memory_subscript PROC					; COMDAT

; 2243 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2244 :     Py_buffer *view;
; 2245 :     view = &(self->view);
; 2246 :     
; 2247 :     CHECK_RELEASED(self);

  0000f	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	0f 85 d4 01 00
	00		 jne	 $LN15@memory_sub
  00022	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00026	41 f6 40 60 01	 test	 BYTE PTR [r8+96], 1
  0002b	0f 85 c5 01 00
	00		 jne	 $LN15@memory_sub

; 2248 : 
; 2249 :     if (view->ndim == 0) {

  00031	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [rcx+180], 0

; 2250 :         if (PyTuple_Check(key) && PyTuple_GET_SIZE(key) == 0) {

  00038	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0003c	75 7d		 jne	 SHORT $LN9@memory_sub
  0003e	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00048	74 3a		 je	 SHORT $LN13@memory_sub
  0004a	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  0004f	75 33		 jne	 SHORT $LN13@memory_sub

; 2251 :             const char *fmt = adjust_fmt(view);

  00051	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  00058	e8 00 00 00 00	 call	 adjust_fmt

; 2252 :             if (fmt == NULL)

  0005d	48 85 c0	 test	 rax, rax

; 2253 :                 return NULL;

  00060	0f 84 a3 01 00
	00		 je	 $LN26@memory_sub

; 2254 :             return unpack_single(view->buf, fmt);

  00066	48 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [rdi+144]
  0006d	48 8b d0	 mov	 rdx, rax

; 2298 : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	e9 00 00 00 00	 jmp	 unpack_single
$LN13@memory_sub:

; 2255 :         }
; 2256 :         else if (key == Py_Ellipsis) {

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  0008b	48 3b d0	 cmp	 rdx, rax
  0008e	75 18		 jne	 SHORT $LN10@memory_sub

; 2257 :             Py_INCREF(self);

  00090	e8 00 00 00 00	 call	 _Py_IncRef

; 2258 :             return (PyObject *)self;

  00095	48 8b c7	 mov	 rax, rdi

; 2298 : }

  00098	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
$LN10@memory_sub:

; 2259 :         }
; 2260 :         else {
; 2261 :             PyErr_SetString(PyExc_TypeError,
; 2262 :                 "invalid indexing of 0-dim memory");

  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@

; 2263 :             return NULL;

  000b6	e9 49 01 00 00	 jmp	 $LN27@memory_sub
$LN9@memory_sub:

; 2264 :         }
; 2265 :     }
; 2266 : 
; 2267 :     if (PyIndex_Check(key)) {

  000bb	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  000c2	48 85 c9	 test	 rcx, rcx
  000c5	74 4a		 je	 SHORT $LN8@memory_sub
  000c7	48 83 b9 08 01
	00 00 00	 cmp	 QWORD PTR [rcx+264], 0
  000cf	74 40		 je	 SHORT $LN8@memory_sub

; 2268 :         Py_ssize_t index;
; 2269 :         index = PyNumber_AsSsize_t(key, PyExc_IndexError);

  000d1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000d8	48 8b cb	 mov	 rcx, rbx
  000db	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000e0	48 8b d8	 mov	 rbx, rax

; 2270 :         if (index == -1 && PyErr_Occurred())

  000e3	48 83 f8 ff	 cmp	 rax, -1
  000e7	75 0e		 jne	 SHORT $LN7@memory_sub
  000e9	e8 00 00 00 00	 call	 PyErr_Occurred
  000ee	48 85 c0	 test	 rax, rax

; 2271 :             return NULL;

  000f1	0f 85 12 01 00
	00		 jne	 $LN26@memory_sub
$LN7@memory_sub:

; 2272 :         return memory_item(self, index);

  000f7	48 8b d3	 mov	 rdx, rbx
  000fa	48 8b cf	 mov	 rcx, rdi

; 2298 : }

  000fd	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00102	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5f		 pop	 rdi
  0010c	e9 00 00 00 00	 jmp	 memory_item
$LN8@memory_sub:

; 2273 :     }
; 2274 :     else if (PySlice_Check(key)) {

  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySlice_Type
  00118	48 3b c1	 cmp	 rax, rcx
  0011b	0f 85 a9 00 00
	00		 jne	 $LN5@memory_sub

; 2275 :         PyMemoryViewObject *sliced;
; 2276 : 
; 2277 :         sliced = (PyMemoryViewObject *)mbuf_add_view(self->mbuf, view);

  00121	48 8d 97 90 00
	00 00		 lea	 rdx, QWORD PTR [rdi+144]
  00128	49 8b c8	 mov	 rcx, r8
  0012b	e8 00 00 00 00	 call	 mbuf_add_view
  00130	48 8b f0	 mov	 rsi, rax

; 2278 :         if (sliced == NULL)

  00133	48 85 c0	 test	 rax, rax

; 2279 :             return NULL;

  00136	0f 84 cd 00 00
	00		 je	 $LN26@memory_sub

; 2280 : 
; 2281 :         if (init_slice(&sliced->view, key, 0) < 0) {

  0013c	48 8d 88 90 00
	00 00		 lea	 rcx, QWORD PTR [rax+144]
  00143	45 33 c0	 xor	 r8d, r8d
  00146	48 8b d3	 mov	 rdx, rbx
  00149	e8 00 00 00 00	 call	 init_slice
  0014e	85 c0		 test	 eax, eax
  00150	79 1a		 jns	 SHORT $LN3@memory_sub

; 2282 :             Py_DECREF(sliced);

  00152	48 8b ce	 mov	 rcx, rsi
  00155	e8 00 00 00 00	 call	 _Py_DecRef
  0015a	33 c0		 xor	 eax, eax

; 2298 : }

  0015c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00161	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00166	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016a	5f		 pop	 rdi
  0016b	c3		 ret	 0
$LN3@memory_sub:

; 2283 :             return NULL;
; 2284 :         }
; 2285 :         init_len(&sliced->view);

  0016c	83 be b4 00 00
	00 00		 cmp	 DWORD PTR [rsi+180], 0
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	7e 23		 jle	 SHORT $LN19@memory_sub
  0017a	48 8b 86 c0 00
	00 00		 mov	 rax, QWORD PTR [rsi+192]
  00181	48 63 96 b4 00
	00 00		 movsxd	 rdx, DWORD PTR [rsi+180]
  00188	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@memory_sub:
  00190	48 0f af 08	 imul	 rcx, QWORD PTR [rax]
  00194	48 83 c0 08	 add	 rax, 8
  00198	48 ff ca	 dec	 rdx
  0019b	75 f3		 jne	 SHORT $LL21@memory_sub
$LN19@memory_sub:
  0019d	48 8b 86 a8 00
	00 00		 mov	 rax, QWORD PTR [rsi+168]
  001a4	48 0f af c1	 imul	 rax, rcx

; 2286 :         init_flags(sliced);

  001a8	48 8b ce	 mov	 rcx, rsi
  001ab	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax
  001b2	e8 00 00 00 00	 call	 init_flags

; 2287 : 
; 2288 :         return (PyObject *)sliced;

  001b7	48 8b c6	 mov	 rax, rsi

; 2298 : }

  001ba	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001bf	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  001c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c8	5f		 pop	 rdi
  001c9	c3		 ret	 0
$LN5@memory_sub:

; 2289 :     }
; 2290 :     else if (is_multislice(key)) {

  001ca	48 8b ca	 mov	 rcx, rdx
  001cd	e8 00 00 00 00	 call	 is_multislice
  001d2	85 c0		 test	 eax, eax
  001d4	74 10		 je	 SHORT $LN1@memory_sub

; 2291 :         PyErr_SetString(PyExc_NotImplementedError,
; 2292 :             "multi-dimensional slicing is not implemented");

  001d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@IJFACBLG@multi?9dimensional?5slicing?5is?5not@

; 2293 :         return NULL;

  001e4	eb 1e		 jmp	 SHORT $LN27@memory_sub
$LN1@memory_sub:

; 2294 :     }
; 2295 : 
; 2296 :     PyErr_SetString(PyExc_TypeError, "memoryview: invalid slice key");

  001e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@

; 2297 :     return NULL;

  001f4	eb 0e		 jmp	 SHORT $LN27@memory_sub
$LN15@memory_sub:

; 2244 :     Py_buffer *view;
; 2245 :     view = &(self->view);
; 2246 :     
; 2247 :     CHECK_RELEASED(self);

  001f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
$LN27@memory_sub:
  00204	e8 00 00 00 00	 call	 PyErr_SetString
$LN26@memory_sub:

; 2298 : }

  00209	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0020e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00213	33 c0		 xor	 eax, eax
  00215	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00219	5f		 pop	 rdi
  0021a	c3		 ret	 0
memory_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@ ; `string'
PUBLIC	??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@ ; `string'
PUBLIC	??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@	; `string'
PUBLIC	??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_ass_sub DD imagerel memory_ass_sub
	DD	imagerel memory_ass_sub+730
	DD	imagerel $unwind$memory_ass_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_ass_sub DD 091a01H
	DD	026641aH
	DD	025341aH
	DD	020011aH
	DD	0700cc00eH
	DD	0500bH
xdata	ENDS
;	COMDAT ??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@
CONST	SEGMENT
??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@ DB 'memoryview sl'
	DB	'ice assignments are currently restricted to ndim = 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@
CONST	SEGMENT
??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@ DB 'memoryview as'
	DB	'signments are currently restricted to ndim = 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@
CONST	SEGMENT
??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@ DB 'cannot delete memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@
CONST	SEGMENT
??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@ DB 'cannot mod'
	DB	'ify read-only memory', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_ass_sub
_TEXT	SEGMENT
arrays$21894 = 48
step$24437 = 72
dest$21893 = 80
stop$24436 = 160
src$ = 176
start$24435 = 288
self$ = 288
key$ = 296
value$ = 304
slicelength$24438 = 312
memory_ass_sub PROC					; COMDAT

; 2302 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  00013	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 2303 :     Py_buffer *view = &(self->view);
; 2304 :     Py_buffer src;
; 2305 :     const char *fmt;
; 2306 :     char *ptr;
; 2307 : 
; 2308 :     CHECK_RELEASED_INT(self);

  0001a	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  00021	4d 8b e0	 mov	 r12, r8
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8d b1 90 00
	00 00		 lea	 rsi, QWORD PTR [rcx+144]
  0002e	0f 85 78 02 00
	00		 jne	 $LN19@memory_ass
  00034	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00038	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0003c	0f 85 6a 02 00
	00		 jne	 $LN19@memory_ass

; 2309 : 
; 2310 :     fmt = adjust_fmt(view);

  00042	4c 8b 46 28	 mov	 r8, QWORD PTR [rsi+40]
  00046	41 80 38 40	 cmp	 BYTE PTR [r8], 64	; 00000040H
  0004a	49 8d 58 01	 lea	 rbx, QWORD PTR [r8+1]
  0004e	74 03		 je	 SHORT $LN27@memory_ass
  00050	49 8b d8	 mov	 rbx, r8
$LN27@memory_ass:
  00053	80 3b 00	 cmp	 BYTE PTR [rbx], 0
  00056	0f 84 3b 02 00
	00		 je	 $LN23@memory_ass
  0005c	80 7b 01 00	 cmp	 BYTE PTR [rbx+1], 0
  00060	0f 85 31 02 00
	00		 jne	 $LN23@memory_ass

; 2313 : 
; 2314 :     if (view->readonly) {

  00066	83 7e 20 00	 cmp	 DWORD PTR [rsi+32], 0
  0006a	74 13		 je	 SHORT $LN17@memory_ass

; 2315 :         PyErr_SetString(PyExc_TypeError, "cannot modify read-only memory");

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@LDOIJEIN@cannot?5modify?5read?9only?5memory?$AA@

; 2316 :         return -1;

  0007a	e9 3b 02 00 00	 jmp	 $LN39@memory_ass
$LN17@memory_ass:

; 2317 :     }
; 2318 :     if (value == NULL) {

  0007f	4d 85 e4	 test	 r12, r12
  00082	75 13		 jne	 SHORT $LN16@memory_ass

; 2319 :         PyErr_SetString(PyExc_TypeError, "cannot delete memory");

  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FICMIAHK@cannot?5delete?5memory?$AA@

; 2320 :         return -1;

  00092	e9 23 02 00 00	 jmp	 $LN39@memory_ass
$LN16@memory_ass:

; 2321 :     }
; 2322 :     if (view->ndim == 0) {

  00097	8b 46 24	 mov	 eax, DWORD PTR [rsi+36]
  0009a	85 c0		 test	 eax, eax
  0009c	75 49		 jne	 SHORT $LN12@memory_ass

; 2323 :         if (key == Py_Ellipsis ||
; 2324 :             (PyTuple_Check(key) && PyTuple_GET_SIZE(key)==0)) {

  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_EllipsisObject
  000a5	48 3b d0	 cmp	 rdx, rax
  000a8	74 2a		 je	 SHORT $LN13@memory_ass
  000aa	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  000ae	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  000b8	74 07		 je	 SHORT $LN14@memory_ass
  000ba	48 83 7a 60 00	 cmp	 QWORD PTR [rdx+96], 0
  000bf	74 13		 je	 SHORT $LN13@memory_ass
$LN14@memory_ass:

; 2327 :         }
; 2328 :         else {
; 2329 :             PyErr_SetString(PyExc_TypeError,
; 2330 :                 "invalid indexing of 0-dim memory");

  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FIMJEJPL@invalid?5indexing?5of?50?9dim?5memory@

; 2331 :             return -1;

  000cf	e9 e6 01 00 00	 jmp	 $LN39@memory_ass
$LN13@memory_ass:

; 2325 :             ptr = (char *)view->buf;
; 2326 :             return pack_single(ptr, value, fmt);

  000d4	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000d7	4c 8b c3	 mov	 r8, rbx
  000da	49 8b d4	 mov	 rdx, r12
  000dd	e8 00 00 00 00	 call	 pack_single
  000e2	e9 db 01 00 00	 jmp	 $LN21@memory_ass
$LN12@memory_ass:

; 2332 :         }
; 2333 :     }
; 2334 :     if (view->ndim != 1) {

  000e7	83 f8 01	 cmp	 eax, 1
  000ea	74 13		 je	 SHORT $LN11@memory_ass

; 2335 :         PyErr_SetString(PyExc_NotImplementedError,
; 2336 :             "memoryview assignments are currently restricted to ndim = 1");

  000ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@HEIJLNGM@memoryview?5assignments?5are?5curre@

; 2337 :         return -1;

  000fa	e9 bb 01 00 00	 jmp	 $LN39@memory_ass
$LN11@memory_ass:

; 2338 :     }
; 2339 : 
; 2340 :     if (PyIndex_Check(key)) {

  000ff	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00103	48 8b 88 b8 00
	00 00		 mov	 rcx, QWORD PTR [rax+184]
  0010a	48 85 c9	 test	 rcx, rcx
  0010d	74 57		 je	 SHORT $LN10@memory_ass
  0010f	48 83 b9 08 01
	00 00 00	 cmp	 QWORD PTR [rcx+264], 0
  00117	74 4d		 je	 SHORT $LN10@memory_ass

; 2341 :         Py_ssize_t index = PyNumber_AsSsize_t(key, PyExc_IndexError);

  00119	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00120	48 8b cf	 mov	 rcx, rdi
  00123	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00128	48 8b f8	 mov	 rdi, rax

; 2342 :         if (index == -1 && PyErr_Occurred())

  0012b	48 83 f8 ff	 cmp	 rax, -1
  0012f	75 0e		 jne	 SHORT $LN9@memory_ass
  00131	e8 00 00 00 00	 call	 PyErr_Occurred
  00136	48 85 c0	 test	 rax, rax

; 2343 :             return -1;

  00139	0f 85 80 01 00
	00		 jne	 $LN40@memory_ass
$LN9@memory_ass:

; 2344 :         ptr = ptr_from_index(view, index);

  0013f	48 8b d7	 mov	 rdx, rdi
  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 ptr_from_index

; 2345 :         if (ptr == NULL)

  0014a	48 85 c0	 test	 rax, rax

; 2346 :             return -1;

  0014d	0f 84 6c 01 00
	00		 je	 $LN40@memory_ass

; 2347 :         return pack_single(ptr, value, fmt);

  00153	4c 8b c3	 mov	 r8, rbx
  00156	49 8b d4	 mov	 rdx, r12
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 pack_single
  00161	e9 5c 01 00 00	 jmp	 $LN21@memory_ass
$LN10@memory_ass:

; 2348 :     }
; 2349 :     /* one-dimensional: fast path */
; 2350 :     if (PySlice_Check(key) && view->ndim == 1) {

  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PySlice_Type
  0016d	48 3b c1	 cmp	 rax, rcx
  00170	0f 85 f5 00 00
	00		 jne	 $LN42@memory_ass

; 2351 :         Py_buffer dest; /* sliced view */
; 2352 :         Py_ssize_t arrays[3];
; 2353 :         int ret = -1;
; 2354 : 
; 2355 :         /* rvalue must be an exporter */
; 2356 :         if (PyObject_GetBuffer(value, &src, PyBUF_FULL_RO) < 0)

  00176	48 8d 55 f7	 lea	 rdx, QWORD PTR src$[rbp-185]
  0017a	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  00180	49 8b cc	 mov	 rcx, r12
  00183	83 cb ff	 or	 ebx, -1
  00186	e8 00 00 00 00	 call	 PyObject_GetBuffer
  0018b	85 c0		 test	 eax, eax

; 2357 :             return ret;

  0018d	0f 88 d4 00 00
	00		 js	 $LN43@memory_ass

; 2358 : 
; 2359 :         dest = *view;

  00193	0f 10 4e 10	 movups	 xmm1, XMMWORD PTR [rsi+16]
  00197	0f 10 06	 movups	 xmm0, XMMWORD PTR [rsi]

; 2360 :         dest.shape = &arrays[0]; dest.shape[0] = view->shape[0];

  0019a	48 8d 44 24 30	 lea	 rax, QWORD PTR arrays$21894[rsp]
  0019f	0f 29 45 97	 movaps	 XMMWORD PTR dest$21893[rbp-185], xmm0
  001a3	0f 29 4d a7	 movaps	 XMMWORD PTR dest$21893[rbp-169], xmm1
  001a7	0f 10 46 20	 movups	 xmm0, XMMWORD PTR [rsi+32]
  001ab	0f 10 4e 30	 movups	 xmm1, XMMWORD PTR [rsi+48]
  001af	0f 29 4d c7	 movaps	 XMMWORD PTR dest$21893[rbp-137], xmm1
  001b3	48 89 45 c7	 mov	 QWORD PTR dest$21893[rbp-137], rax
  001b7	48 8b 46 30	 mov	 rax, QWORD PTR [rsi+48]
  001bb	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 2361 :         dest.strides = &arrays[1]; dest.strides[0] = view->strides[0];

  001be	48 8d 44 24 38	 lea	 rax, QWORD PTR arrays$21894[rsp+8]
  001c3	0f 29 45 b7	 movaps	 XMMWORD PTR dest$21893[rbp-153], xmm0
  001c7	0f 10 46 40	 movups	 xmm0, XMMWORD PTR [rsi+64]
  001cb	48 89 45 cf	 mov	 QWORD PTR dest$21893[rbp-129], rax
  001cf	48 8b 46 38	 mov	 rax, QWORD PTR [rsi+56]
  001d3	48 89 54 24 30	 mov	 QWORD PTR arrays$21894[rsp], rdx
  001d8	0f 29 45 d7	 movaps	 XMMWORD PTR dest$21893[rbp-121], xmm0
  001dc	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 2362 :         if (view->suboffsets) {

  001df	48 8b 46 40	 mov	 rax, QWORD PTR [rsi+64]
  001e3	48 89 4c 24 38	 mov	 QWORD PTR arrays$21894[rsp+8], rcx
  001e8	48 85 c0	 test	 rax, rax
  001eb	74 0f		 je	 SHORT $LN5@memory_ass

; 2363 :             dest.suboffsets = &arrays[2]; dest.suboffsets[0] = view->suboffsets[0];

  001ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f0	48 8d 4d 87	 lea	 rcx, QWORD PTR arrays$21894[rbp-169]
  001f4	48 89 45 87	 mov	 QWORD PTR arrays$21894[rbp-169], rax
  001f8	48 89 4d d7	 mov	 QWORD PTR dest$21893[rbp-121], rcx
$LN5@memory_ass:

; 2364 :         }
; 2365 : 
; 2366 :         if (init_slice(&dest, key, 0) < 0)

  001fc	48 8d 45 7f	 lea	 rax, QWORD PTR slicelength$24438[rbp-185]
  00200	4c 8d 4d e7	 lea	 r9, QWORD PTR stop$24436[rbp-185]
  00204	4c 8d 45 67	 lea	 r8, QWORD PTR start$24435[rbp-185]
  00208	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020d	48 8d 45 8f	 lea	 rax, QWORD PTR step$24437[rbp-185]
  00211	48 8b cf	 mov	 rcx, rdi
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  0021e	85 c0		 test	 eax, eax
  00220	78 3c		 js	 SHORT $end_block$21899
  00222	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arrays$21894[rsp+8]

; 2367 :             goto end_block;
; 2368 :         dest.len = dest.shape[0] * dest.itemsize;
; 2369 : 
; 2370 :         ret = copy_single(&dest, &src);

  00227	48 8d 55 f7	 lea	 rdx, QWORD PTR src$[rbp-185]
$adjust_buf$24442:
  0022b	48 8b c1	 mov	 rax, rcx
  0022e	48 0f af 4d 8f	 imul	 rcx, QWORD PTR step$24437[rbp-185]
  00233	48 0f af 45 67	 imul	 rax, QWORD PTR start$24435[rbp-185]
  00238	48 89 4c 24 38	 mov	 QWORD PTR arrays$21894[rsp+8], rcx
  0023d	48 8d 4d 97	 lea	 rcx, QWORD PTR dest$21893[rbp-185]
  00241	48 01 45 97	 add	 QWORD PTR dest$21893[rbp-185], rax
  00245	48 8b 45 7f	 mov	 rax, QWORD PTR slicelength$24438[rbp-185]
  00249	48 89 44 24 30	 mov	 QWORD PTR arrays$21894[rsp], rax
  0024e	48 0f af 45 af	 imul	 rax, QWORD PTR dest$21893[rbp-161]
  00253	48 89 45 a7	 mov	 QWORD PTR dest$21893[rbp-169], rax
  00257	e8 00 00 00 00	 call	 copy_single
  0025c	8b d8		 mov	 ebx, eax
$end_block$21899:

; 2371 : 
; 2372 :     end_block:
; 2373 :         PyBuffer_Release(&src);

  0025e	48 8d 4d f7	 lea	 rcx, QWORD PTR src$[rbp-185]
  00262	e8 00 00 00 00	 call	 PyBuffer_Release
$LN43@memory_ass:

; 2374 :         return ret;

  00267	8b c3		 mov	 eax, ebx
  00269	eb 57		 jmp	 SHORT $LN21@memory_ass
$LN42@memory_ass:

; 2375 :     }
; 2376 :     else if (PySlice_Check(key) || is_multislice(key)) {

  0026b	48 8b ca	 mov	 rcx, rdx
  0026e	e8 00 00 00 00	 call	 is_multislice
  00273	85 c0		 test	 eax, eax
  00275	75 10		 jne	 SHORT $LN1@memory_ass

; 2383 :     }
; 2384 : 
; 2385 :     PyErr_SetString(PyExc_TypeError, "memoryview: invalid slice key");

  00277	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JBOMHNNO@memoryview?3?5invalid?5slice?5key?$AA@

; 2386 :     return -1;

  00285	eb 33		 jmp	 SHORT $LN39@memory_ass
$LN1@memory_ass:

; 2377 :         /* Call memory_subscript() to produce a sliced lvalue, then copy
; 2378 :            rvalue into lvalue. This is already implemented in _testbuffer.c. */
; 2379 :         PyErr_SetString(PyExc_NotImplementedError,
; 2380 :             "memoryview slice assignments are currently restricted "
; 2381 :             "to ndim = 1");

  00287	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@FKBBMJOI@memoryview?5slice?5assignments?5are@

; 2382 :         return -1;

  00295	eb 23		 jmp	 SHORT $LN39@memory_ass

; 2309 : 
; 2310 :     fmt = adjust_fmt(view);

$LN23@memory_ass:
  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@LKIGHPOC@memoryview?3?5unsupported?5format?5?$CF@
  002a5	e8 00 00 00 00	 call	 PyErr_Format

; 2311 :     if (fmt == NULL)
; 2312 :         return -1;

  002aa	eb 13		 jmp	 SHORT $LN40@memory_ass
$LN19@memory_ass:

; 2303 :     Py_buffer *view = &(self->view);
; 2304 :     Py_buffer src;
; 2305 :     const char *fmt;
; 2306 :     char *ptr;
; 2307 : 
; 2308 :     CHECK_RELEASED_INT(self);

  002ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
$LN39@memory_ass:
  002ba	e8 00 00 00 00	 call	 PyErr_SetString
$LN40@memory_ass:
  002bf	83 c8 ff	 or	 eax, -1
$LN21@memory_ass:

; 2387 : }

  002c2	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  002ca	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  002ce	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  002d2	49 8b e3	 mov	 rsp, r11
  002d5	41 5c		 pop	 r12
  002d7	5f		 pop	 rdi
  002d8	5d		 pop	 rbp
  002d9	c3		 ret	 0
memory_ass_sub ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_length DD imagerel memory_length
	DD	imagerel memory_length+85
	DD	imagerel $unwind$memory_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_length DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_length
_TEXT	SEGMENT
self$ = 48
memory_length PROC					; COMDAT

; 2391 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2392 :     CHECK_RELEASED_INT(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 2c		 jne	 SHORT $LN1@memory_len
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 22		 jne	 SHORT $LN1@memory_len

; 2393 :     return self->view.ndim == 0 ? 1 : self->view.shape[0];

  00017	83 b9 b4 00 00
	00 00		 cmp	 DWORD PTR [rcx+180], 0
  0001e	75 0a		 jne	 SHORT $LN5@memory_len
  00020	b8 01 00 00 00	 mov	 eax, 1

; 2394 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN5@memory_len:

; 2393 :     return self->view.ndim == 0 ? 1 : self->view.shape[0];

  0002a	48 8b 81 c0 00
	00 00		 mov	 rax, QWORD PTR [rcx+192]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 2394 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN1@memory_len:

; 2392 :     CHECK_RELEASED_INT(self);

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00047	e8 00 00 00 00	 call	 PyErr_SetString
  0004c	48 83 c8 ff	 or	 rax, -1

; 2394 : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
memory_length ENDP
_TEXT	ENDS
EXTRN	PyExc_MemoryError:QWORD
EXTRN	PyExc_ImportError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fix_struct_error_int DD imagerel fix_struct_error_int
	DD	imagerel fix_struct_error_int+56
	DD	imagerel $unwind$fix_struct_error_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fix_struct_error_int DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fix_struct_error_int
_TEXT	SEGMENT
fix_struct_error_int PROC				; COMDAT

; 2422 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2423 :     assert(PyErr_Occurred());
; 2424 :     /* XXX Cannot get at StructError directly? */
; 2425 :     if (PyErr_ExceptionMatches(PyExc_ImportError) ||
; 2426 :         PyErr_ExceptionMatches(PyExc_MemoryError)) {

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  0000b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00010	85 c0		 test	 eax, eax
  00012	75 1c		 jne	 SHORT $LN1@fix_struct
  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0001b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00020	85 c0		 test	 eax, eax
  00022	75 0c		 jne	 SHORT $LN1@fix_struct

; 2428 :     }
; 2429 :     /* StructError: invalid or unknown format -> not equal */
; 2430 :     PyErr_Clear();

  00024	e8 00 00 00 00	 call	 PyErr_Clear

; 2431 :     return 0;

  00029	33 c0		 xor	 eax, eax

; 2432 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN1@fix_struct:

; 2427 :         return MV_COMPARE_EX;

  00030	83 c8 ff	 or	 eax, -1

; 2432 : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
fix_struct_error_int ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$struct_unpack_cmp DD imagerel struct_unpack_cmp
	DD	imagerel struct_unpack_cmp+133
	DD	imagerel $unwind$struct_unpack_cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$struct_unpack_cmp DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT struct_unpack_cmp
_TEXT	SEGMENT
p$ = 48
q$ = 56
unpack_p$ = 64
unpack_q$ = 72
struct_unpack_cmp PROC					; COMDAT

; 2438 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx

; 2439 :     PyObject *v, *w;
; 2440 :     int ret;
; 2441 : 
; 2442 :     /* At this point any exception from the struct module should not be
; 2443 :        StructError, since both formats have been accepted already. */
; 2444 :     v = struct_unpack_single(p, unpack_p);

  00012	49 8b d0	 mov	 rdx, r8
  00015	49 8b d9	 mov	 rbx, r9
  00018	e8 00 00 00 00	 call	 struct_unpack_single
  0001d	48 8b f0	 mov	 rsi, rax

; 2445 :     if (v == NULL)

  00020	48 85 c0	 test	 rax, rax

; 2446 :         return MV_COMPARE_EX;

  00023	74 1b		 je	 SHORT $LN5@struct_unp@2

; 2447 : 
; 2448 :     w = struct_unpack_single(q, unpack_q);

  00025	48 8b d3	 mov	 rdx, rbx
  00028	48 8b cf	 mov	 rcx, rdi
  0002b	e8 00 00 00 00	 call	 struct_unpack_single

; 2449 :     if (w == NULL) {
; 2450 :         Py_DECREF(v);

  00030	48 8b ce	 mov	 rcx, rsi
  00033	48 8b f8	 mov	 rdi, rax
  00036	48 85 c0	 test	 rax, rax
  00039	75 18		 jne	 SHORT $LN1@struct_unp@2
  0003b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@struct_unp@2:

; 2451 :         return MV_COMPARE_EX;

  00040	83 c8 ff	 or	 eax, -1

; 2458 : 
; 2459 :     return ret;
; 2460 : }

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN1@struct_unp@2:

; 2452 :     }
; 2453 : 
; 2454 :     /* MV_COMPARE_EX == -1: exceptions are preserved */
; 2455 :     ret = PyObject_RichCompareBool(v, w, Py_EQ);

  00053	41 b8 02 00 00
	00		 mov	 r8d, 2
  00059	48 8b d0	 mov	 rdx, rax
  0005c	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2456 :     Py_DECREF(v);

  00061	48 8b ce	 mov	 rcx, rsi
  00064	8b d8		 mov	 ebx, eax
  00066	e8 00 00 00 00	 call	 _Py_DecRef

; 2457 :     Py_DECREF(w);

  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	e8 00 00 00 00	 call	 _Py_DecRef

; 2458 : 
; 2459 :     return ret;
; 2460 : }

  00073	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00078	8b c3		 mov	 eax, ebx
  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
struct_unpack_cmp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_cmp DD imagerel unpack_cmp
	DD	imagerel unpack_cmp+363
	DD	imagerel $unwind$unpack_cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_cmp DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@
CONST	SEGMENT
??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@ DB 'memoryview:'
	DB	' internal error in richcompare', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT unpack_cmp
_TEXT	SEGMENT
x$22071 = 32
y$22064 = 32
y$22072 = 40
p$ = 64
q$ = 72
x$22063 = 80
fmt$ = 80
unpack_p$ = 88
unpack_q$ = 96
unpack_cmp PROC						; COMDAT

; 2480 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2481 :     int equal;
; 2482 : 
; 2483 :     switch (fmt) {

  00004	41 0f be c0	 movsx	 eax, r8b
  00008	4d 8b d9	 mov	 r11, r9
  0000b	4c 8b d1	 mov	 r10, rcx
  0000e	83 c0 c1	 add	 eax, -63		; ffffffffffffffc1H
  00011	83 f8 32	 cmp	 eax, 50			; 00000032H
  00014	0f 87 dc 00 00
	00		 ja	 $LN61@unpack_cmp
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00021	48 98		 cdqe
  00023	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN69@unpack_cmp[rcx+rax]
  0002b	44 8b 84 81 00
	00 00 00	 mov	 r8d, DWORD PTR $LN70@unpack_cmp[rcx+rax*4]
  00033	4c 03 c1	 add	 r8, rcx
  00036	41 ff e0	 jmp	 r8
$LN60@unpack_cmp:

; 2484 : 
; 2485 :     /* signed integers and fast path for 'B' */
; 2486 :     case 'B': return *((unsigned char *)p) == *((unsigned char *)q);

  00039	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	41 38 02	 cmp	 BYTE PTR [r10], al
  00041	0f 94 c1	 sete	 cl
  00044	8b c1		 mov	 eax, ecx

; 2536 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
$LN57@unpack_cmp:

; 2487 :     case 'b': return *((signed char *)p) == *((signed char *)q);
; 2488 :     case 'h': CMP_SINGLE(p, q, short); return equal;

  0004b	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  0004f	33 c9		 xor	 ecx, ecx
  00051	66 3b 02	 cmp	 ax, WORD PTR [rdx]
  00054	0f 94 c1	 sete	 cl
  00057	8b c1		 mov	 eax, ecx

; 2536 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
$LN53@unpack_cmp:

; 2489 :     case 'i': CMP_SINGLE(p, q, int); return equal;

  0005e	41 8b 02	 mov	 eax, DWORD PTR [r10]
  00061	33 c9		 xor	 ecx, ecx
  00063	3b 02		 cmp	 eax, DWORD PTR [rdx]
  00065	0f 94 c1	 sete	 cl
  00068	8b c1		 mov	 eax, ecx

; 2536 : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
$LN45@unpack_cmp:

; 2490 :     case 'l': CMP_SINGLE(p, q, long); return equal;
; 2491 : 
; 2492 :     /* boolean */
; 2493 :     #ifdef HAVE_C99_BOOL
; 2494 :     case '?': CMP_SINGLE(p, q, _Bool); return equal;
; 2495 :     #else
; 2496 :     case '?': CMP_SINGLE(p, q, char); return equal;

  0006f	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00073	33 c9		 xor	 ecx, ecx
  00075	3a 02		 cmp	 al, BYTE PTR [rdx]
  00077	0f 94 c1	 sete	 cl
  0007a	8b c1		 mov	 eax, ecx

; 2536 : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
$LN29@unpack_cmp:

; 2497 :     #endif
; 2498 : 
; 2499 :     /* unsigned integers */
; 2500 :     case 'H': CMP_SINGLE(p, q, unsigned short); return equal;
; 2501 :     case 'I': CMP_SINGLE(p, q, unsigned int); return equal;
; 2502 :     case 'L': CMP_SINGLE(p, q, unsigned long); return equal;
; 2503 : 
; 2504 :     /* native 64-bit */
; 2505 :     #ifdef HAVE_LONG_LONG
; 2506 :     case 'q': CMP_SINGLE(p, q, PY_LONG_LONG); return equal;

  00081	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00084	33 c9		 xor	 ecx, ecx
  00086	48 3b 02	 cmp	 rax, QWORD PTR [rdx]
  00089	0f 94 c1	 sete	 cl
  0008c	8b c1		 mov	 eax, ecx

; 2536 : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
$LN13@unpack_cmp:

; 2507 :     case 'Q': CMP_SINGLE(p, q, unsigned PY_LONG_LONG); return equal;
; 2508 :     #endif
; 2509 : 
; 2510 :     /* ssize_t and size_t */
; 2511 :     case 'n': CMP_SINGLE(p, q, Py_ssize_t); return equal;
; 2512 :     case 'N': CMP_SINGLE(p, q, size_t); return equal;
; 2513 : 
; 2514 :     /* floats */
; 2515 :     /* XXX DBL_EPSILON? */
; 2516 :     case 'f': CMP_SINGLE(p, q, float); return equal;

  00093	41 8b 02	 mov	 eax, DWORD PTR [r10]
  00096	89 44 24 50	 mov	 DWORD PTR x$22063[rsp], eax
  0009a	8b 02		 mov	 eax, DWORD PTR [rdx]
  0009c	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR x$22063[rsp]
  000a2	89 44 24 20	 mov	 DWORD PTR y$22064[rsp], eax
  000a6	0f 2e 44 24 20	 ucomiss xmm0, DWORD PTR y$22064[rsp]
$LN71@unpack_cmp:
  000ab	7a 0e		 jp	 SHORT $LN65@unpack_cmp
  000ad	75 0c		 jne	 SHORT $LN65@unpack_cmp
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	8b c1		 mov	 eax, ecx

; 2536 : }

  000b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ba	c3		 ret	 0
$LN65@unpack_cmp:

; 2507 :     case 'Q': CMP_SINGLE(p, q, unsigned PY_LONG_LONG); return equal;
; 2508 :     #endif
; 2509 : 
; 2510 :     /* ssize_t and size_t */
; 2511 :     case 'n': CMP_SINGLE(p, q, Py_ssize_t); return equal;
; 2512 :     case 'N': CMP_SINGLE(p, q, size_t); return equal;
; 2513 : 
; 2514 :     /* floats */
; 2515 :     /* XXX DBL_EPSILON? */
; 2516 :     case 'f': CMP_SINGLE(p, q, float); return equal;

  000bb	33 c9		 xor	 ecx, ecx
  000bd	8b c1		 mov	 eax, ecx

; 2536 : }

  000bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c3	c3		 ret	 0
$LN9@unpack_cmp:

; 2517 :     case 'd': CMP_SINGLE(p, q, double); return equal;

  000c4	49 8b 02	 mov	 rax, QWORD PTR [r10]
  000c7	48 89 44 24 20	 mov	 QWORD PTR x$22071[rsp], rax
  000cc	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  000cf	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$22071[rsp]
  000d5	48 89 44 24 28	 mov	 QWORD PTR y$22072[rsp], rax
  000da	66 0f 2e 44 24
	28		 ucomisd xmm0, QWORD PTR y$22072[rsp]
  000e0	eb c9		 jmp	 SHORT $LN71@unpack_cmp
$LN1@unpack_cmp:

; 2518 : 
; 2519 :     /* bytes object */
; 2520 :     case 'c': return *p == *q;
; 2521 : 
; 2522 :     /* pointer */
; 2523 :     case 'P': CMP_SINGLE(p, q, void *); return equal;
; 2524 : 
; 2525 :     /* use the struct module */
; 2526 :     case '_':
; 2527 :         assert(unpack_p);
; 2528 :         assert(unpack_q);
; 2529 :         return struct_unpack_cmp(p, q, unpack_p, unpack_q);

  000e2	4c 8b 4c 24 60	 mov	 r9, QWORD PTR unpack_q$[rsp]
  000e7	4d 8b c3	 mov	 r8, r11
  000ea	49 8b ca	 mov	 rcx, r10

; 2536 : }

  000ed	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f1	e9 00 00 00 00	 jmp	 struct_unpack_cmp
$LN61@unpack_cmp:

; 2530 :     }
; 2531 : 
; 2532 :     /* NOT REACHED */
; 2533 :     PyErr_SetString(PyExc_RuntimeError,
; 2534 :         "memoryview: internal error in richcompare");

  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@
  00104	e8 00 00 00 00	 call	 PyErr_SetString

; 2535 :     return MV_COMPARE_EX;

  00109	83 c8 ff	 or	 eax, -1

; 2536 : }

  0010c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00110	c3		 ret	 0
  00111	0f 1f 00	 npad	 3
$LN70@unpack_cmp:
  00114	00 00 00 00	 DD	 $LN45@unpack_cmp
  00118	00 00 00 00	 DD	 $LN60@unpack_cmp
  0011c	00 00 00 00	 DD	 $LN57@unpack_cmp
  00120	00 00 00 00	 DD	 $LN53@unpack_cmp
  00124	00 00 00 00	 DD	 $LN29@unpack_cmp
  00128	00 00 00 00	 DD	 $LN1@unpack_cmp
  0012c	00 00 00 00	 DD	 $LN9@unpack_cmp
  00130	00 00 00 00	 DD	 $LN13@unpack_cmp
  00134	00 00 00 00	 DD	 $LN61@unpack_cmp
$LN69@unpack_cmp:
  00138	00		 DB	 0
  00139	08		 DB	 8
  0013a	08		 DB	 8
  0013b	01		 DB	 1
  0013c	08		 DB	 8
  0013d	08		 DB	 8
  0013e	08		 DB	 8
  0013f	08		 DB	 8
  00140	08		 DB	 8
  00141	02		 DB	 2
  00142	03		 DB	 3
  00143	08		 DB	 8
  00144	08		 DB	 8
  00145	03		 DB	 3
  00146	08		 DB	 8
  00147	04		 DB	 4
  00148	08		 DB	 8
  00149	04		 DB	 4
  0014a	04		 DB	 4
  0014b	08		 DB	 8
  0014c	08		 DB	 8
  0014d	08		 DB	 8
  0014e	08		 DB	 8
  0014f	08		 DB	 8
  00150	08		 DB	 8
  00151	08		 DB	 8
  00152	08		 DB	 8
  00153	08		 DB	 8
  00154	08		 DB	 8
  00155	08		 DB	 8
  00156	08		 DB	 8
  00157	08		 DB	 8
  00158	05		 DB	 5
  00159	08		 DB	 8
  0015a	08		 DB	 8
  0015b	01		 DB	 1
  0015c	01		 DB	 1
  0015d	06		 DB	 6
  0015e	08		 DB	 8
  0015f	07		 DB	 7
  00160	08		 DB	 8
  00161	02		 DB	 2
  00162	03		 DB	 3
  00163	08		 DB	 8
  00164	08		 DB	 8
  00165	03		 DB	 3
  00166	08		 DB	 8
  00167	04		 DB	 4
  00168	08		 DB	 8
  00169	08		 DB	 8
  0016a	04		 DB	 4
unpack_cmp ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp_base DD imagerel cmp_base
	DD	imagerel cmp_base+539
	DD	imagerel $unwind$cmp_base
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_base DD 0c1c01H
	DD	011641cH
	DD	0f541cH
	DD	0e341cH
	DD	0f018721cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT cmp_base
_TEXT	SEGMENT
y$24641 = 32
x$24646 = 40
y$24647 = 48
p$ = 112
q$ = 120
x$24640 = 128
shape$ = 128
pstrides$ = 136
psuboffsets$ = 144
qstrides$ = 152
qsuboffsets$ = 160
fmt$ = 168
unpack_p$ = 176
unpack_q$ = 184
cmp_base PROC						; COMDAT

; 2544 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2545 :     Py_ssize_t i;
; 2546 :     int equal;
; 2547 : 
; 2548 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  0001c	45 33 ed	 xor	 r13d, r13d
  0001f	4d 8b f9	 mov	 r15, r9
  00022	4d 8b f0	 mov	 r14, r8
  00025	48 8b fa	 mov	 rdi, rdx
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	4d 39 28	 cmp	 QWORD PTR [r8], r13
  0002e	0f 8e 4e 01 00
	00		 jle	 $LN2@cmp_base
  00034	44 0f be a4 24
	a8 00 00 00	 movsx	 r12d, BYTE PTR fmt$[rsp]
  0003d	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR qsuboffsets$[rsp]
  00045	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR psuboffsets$[rsp]
  0004d	41 83 c4 c1	 add	 r12d, -63		; ffffffffffffffc1H
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
$LL4@cmp_base:

; 2549 :         const char *xp = ADJUST_PTR(p, psuboffsets);

  00058	48 85 f6	 test	 rsi, rsi
  0005b	74 11		 je	 SHORT $LN7@cmp_base
  0005d	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00060	48 85 c9	 test	 rcx, rcx
  00063	78 09		 js	 SHORT $LN7@cmp_base
  00065	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00068	4c 8d 14 01	 lea	 r10, QWORD PTR [rcx+rax]
  0006c	eb 03		 jmp	 SHORT $LN8@cmp_base
$LN7@cmp_base:
  0006e	4c 8b d3	 mov	 r10, rbx
$LN8@cmp_base:

; 2550 :         const char *xq = ADJUST_PTR(q, qsuboffsets);

  00071	48 85 ed	 test	 rbp, rbp
  00074	74 12		 je	 SHORT $LN9@cmp_base
  00076	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  0007a	48 85 c9	 test	 rcx, rcx
  0007d	78 09		 js	 SHORT $LN9@cmp_base
  0007f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00082	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00086	eb 03		 jmp	 SHORT $LN10@cmp_base
$LN9@cmp_base:
  00088	48 8b d7	 mov	 rdx, rdi
$LN10@cmp_base:

; 2551 :         equal = unpack_cmp(xp, xq, fmt, unpack_p, unpack_q);

  0008b	41 83 fc 32	 cmp	 r12d, 50		; 00000032H
  0008f	0f 87 12 01 00
	00		 ja	 $LN71@cmp_base
  00095	49 63 c4	 movsxd	 rax, r12d
  00098	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN83@cmp_base[r8+rax]
  000a1	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN84@cmp_base[r8+rax*4]
  000a9	49 03 c8	 add	 rcx, r8
  000ac	ff e1		 jmp	 rcx
$LN70@cmp_base:
  000ae	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000b1	33 c9		 xor	 ecx, ecx
  000b3	41 38 02	 cmp	 BYTE PTR [r10], al
  000b6	0f 94 c1	 sete	 cl
  000b9	e9 a6 00 00 00	 jmp	 $LN73@cmp_base
$LN67@cmp_base:
  000be	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  000c2	33 c9		 xor	 ecx, ecx
  000c4	66 3b 02	 cmp	 ax, WORD PTR [rdx]
  000c7	0f 94 c1	 sete	 cl
  000ca	e9 95 00 00 00	 jmp	 $LN73@cmp_base
$LN63@cmp_base:
  000cf	41 8b 02	 mov	 eax, DWORD PTR [r10]
  000d2	33 c9		 xor	 ecx, ecx
  000d4	3b 02		 cmp	 eax, DWORD PTR [rdx]
  000d6	0f 94 c1	 sete	 cl
  000d9	e9 86 00 00 00	 jmp	 $LN73@cmp_base
$LN55@cmp_base:
  000de	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  000e2	33 c9		 xor	 ecx, ecx
  000e4	3a 02		 cmp	 al, BYTE PTR [rdx]
  000e6	0f 94 c1	 sete	 cl
  000e9	eb 79		 jmp	 SHORT $LN73@cmp_base
$LN39@cmp_base:
  000eb	49 8b 02	 mov	 rax, QWORD PTR [r10]
  000ee	33 c9		 xor	 ecx, ecx
  000f0	48 3b 02	 cmp	 rax, QWORD PTR [rdx]
  000f3	0f 94 c1	 sete	 cl
  000f6	eb 6c		 jmp	 SHORT $LN73@cmp_base
$LN23@cmp_base:
  000f8	41 8b 02	 mov	 eax, DWORD PTR [r10]
  000fb	89 84 24 80 00
	00 00		 mov	 DWORD PTR x$24640[rsp], eax
  00102	8b 02		 mov	 eax, DWORD PTR [rdx]
  00104	f3 0f 10 84 24
	80 00 00 00	 movss	 xmm0, DWORD PTR x$24640[rsp]
  0010d	89 44 24 20	 mov	 DWORD PTR y$24641[rsp], eax
  00111	0f 2e 44 24 20	 ucomiss xmm0, DWORD PTR y$24641[rsp]
$LN85@cmp_base:
  00116	7a 09		 jp	 SHORT $LN75@cmp_base
  00118	75 07		 jne	 SHORT $LN75@cmp_base
  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	eb 43		 jmp	 SHORT $LN73@cmp_base
$LN75@cmp_base:
  00121	33 c9		 xor	 ecx, ecx
  00123	eb 3f		 jmp	 SHORT $LN73@cmp_base
$LN19@cmp_base:
  00125	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00128	48 89 44 24 28	 mov	 QWORD PTR x$24646[rsp], rax
  0012d	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00130	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR x$24646[rsp]
  00136	48 89 44 24 30	 mov	 QWORD PTR y$24647[rsp], rax
  0013b	66 0f 2e 44 24
	30		 ucomisd xmm0, QWORD PTR y$24647[rsp]
  00141	eb d3		 jmp	 SHORT $LN85@cmp_base
$LN11@cmp_base:
  00143	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR unpack_q$[rsp]
  0014b	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR unpack_p$[rsp]
  00153	49 8b ca	 mov	 rcx, r10
  00156	e8 00 00 00 00	 call	 struct_unpack_cmp
  0015b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00162	8b c8		 mov	 ecx, eax
$LN73@cmp_base:

; 2552 :         if (equal <= 0)

  00164	85 c9		 test	 ecx, ecx
  00166	7e 55		 jle	 SHORT $LN80@cmp_base

; 2545 :     Py_ssize_t i;
; 2546 :     int equal;
; 2547 : 
; 2548 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  00168	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  00170	49 03 1f	 add	 rbx, QWORD PTR [r15]
  00173	49 ff c5	 inc	 r13
  00176	48 03 38	 add	 rdi, QWORD PTR [rax]
  00179	4d 3b 2e	 cmp	 r13, QWORD PTR [r14]
  0017c	0f 8c d6 fe ff
	ff		 jl	 $LL4@cmp_base
$LN2@cmp_base:

; 2554 :     }
; 2555 : 
; 2556 :     return 1;

  00182	b8 01 00 00 00	 mov	 eax, 1
$LN5@cmp_base:

; 2557 : }

  00187	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0018c	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00191	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  00199	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0019d	41 5f		 pop	 r15
  0019f	41 5e		 pop	 r14
  001a1	41 5d		 pop	 r13
  001a3	41 5c		 pop	 r12
  001a5	5f		 pop	 rdi
  001a6	c3		 ret	 0

; 2551 :         equal = unpack_cmp(xp, xq, fmt, unpack_p, unpack_q);

$LN71@cmp_base:
  001a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@JGBOLOHN@memoryview?3?5internal?5error?5in?5ri@
  001b5	e8 00 00 00 00	 call	 PyErr_SetString
  001ba	83 c9 ff	 or	 ecx, -1
$LN80@cmp_base:

; 2553 :             return equal;

  001bd	8b c1		 mov	 eax, ecx
  001bf	eb c6		 jmp	 SHORT $LN5@cmp_base
  001c1	0f 1f 00	 npad	 3
$LN84@cmp_base:

; 2557 : }

  001c4	00 00 00 00	 DD	 $LN55@cmp_base
  001c8	00 00 00 00	 DD	 $LN70@cmp_base
  001cc	00 00 00 00	 DD	 $LN67@cmp_base
  001d0	00 00 00 00	 DD	 $LN63@cmp_base
  001d4	00 00 00 00	 DD	 $LN39@cmp_base
  001d8	00 00 00 00	 DD	 $LN11@cmp_base
  001dc	00 00 00 00	 DD	 $LN19@cmp_base
  001e0	00 00 00 00	 DD	 $LN23@cmp_base
  001e4	00 00 00 00	 DD	 $LN71@cmp_base
$LN83@cmp_base:
  001e8	00		 DB	 0
  001e9	08		 DB	 8
  001ea	08		 DB	 8
  001eb	01		 DB	 1
  001ec	08		 DB	 8
  001ed	08		 DB	 8
  001ee	08		 DB	 8
  001ef	08		 DB	 8
  001f0	08		 DB	 8
  001f1	02		 DB	 2
  001f2	03		 DB	 3
  001f3	08		 DB	 8
  001f4	08		 DB	 8
  001f5	03		 DB	 3
  001f6	08		 DB	 8
  001f7	04		 DB	 4
  001f8	08		 DB	 8
  001f9	04		 DB	 4
  001fa	04		 DB	 4
  001fb	08		 DB	 8
  001fc	08		 DB	 8
  001fd	08		 DB	 8
  001fe	08		 DB	 8
  001ff	08		 DB	 8
  00200	08		 DB	 8
  00201	08		 DB	 8
  00202	08		 DB	 8
  00203	08		 DB	 8
  00204	08		 DB	 8
  00205	08		 DB	 8
  00206	08		 DB	 8
  00207	08		 DB	 8
  00208	05		 DB	 5
  00209	08		 DB	 8
  0020a	08		 DB	 8
  0020b	01		 DB	 1
  0020c	01		 DB	 1
  0020d	06		 DB	 6
  0020e	08		 DB	 8
  0020f	07		 DB	 7
  00210	08		 DB	 8
  00211	02		 DB	 2
  00212	03		 DB	 3
  00213	08		 DB	 8
  00214	08		 DB	 8
  00215	03		 DB	 3
  00216	08		 DB	 8
  00217	04		 DB	 4
  00218	08		 DB	 8
  00219	08		 DB	 8
  0021a	04		 DB	 4
cmp_base ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp_rec DD imagerel cmp_rec
	DD	imagerel cmp_rec+498
	DD	imagerel $unwind$cmp_rec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_rec DD 08a401H
	DD	01064a4H
	DD	0145490H
	DD	011010eH
	DD	030067007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT cmp_rec
_TEXT	SEGMENT
tv199 = 96
tv197 = 104
tv198 = 112
tv196 = 120
p$ = 160
q$ = 168
i$1$ = 176
ndim$ = 176
shape$ = 184
pstrides$ = 192
psuboffsets$ = 200
qstrides$ = 208
qsuboffsets$ = 216
fmt$ = 224
unpack_p$ = 232
unpack_q$ = 240
cmp_rec	PROC						; COMDAT

; 2567 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	53		 push	 rbx
  00006	57		 push	 rdi
  00007	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000e	4d 8b d1	 mov	 r10, r9
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx

; 2568 :     Py_ssize_t i;
; 2569 :     int equal;
; 2570 : 
; 2571 :     assert(ndim >= 1);
; 2572 :     assert(shape != NULL);
; 2573 :     assert(pstrides != NULL);
; 2574 :     assert(qstrides != NULL);
; 2575 : 
; 2576 :     if (ndim == 1) {

  00017	49 83 f8 01	 cmp	 r8, 1
  0001b	75 67		 jne	 SHORT $LN5@cmp_rec

; 2577 :         return cmp_base(p, q, shape,
; 2578 :                         pstrides, psuboffsets,
; 2579 :                         qstrides, qsuboffsets,
; 2580 :                         fmt, unpack_p, unpack_q);

  0001d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR unpack_q$[rsp]
  00025	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR pstrides$[rsp]
  0002d	4d 8b c2	 mov	 r8, r10
  00030	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00035	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR unpack_p$[rsp]
  0003d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00042	0f b6 84 24 e0
	00 00 00	 movzx	 eax, BYTE PTR fmt$[rsp]
  0004a	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  0004e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR qsuboffsets$[rsp]
  00056	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  00063	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00068	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR psuboffsets$[rsp]
  00070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00075	e8 00 00 00 00	 call	 cmp_base

; 2595 : }

  0007a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00081	5f		 pop	 rdi
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
$LN5@cmp_rec:

; 2581 :     }
; 2582 : 
; 2583 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  00084	49 83 39 00	 cmp	 QWORD PTR [r9], 0
  00088	48 89 ac 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbp
  00090	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$1$[rsp], 0
  0009c	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  000a4	0f 8e 29 01 00
	00		 jle	 $LN2@cmp_rec
  000aa	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR qstrides$[rsp]
  000b2	4c 8b 9c 24 c0
	00 00 00	 mov	 r11, QWORD PTR pstrides$[rsp]
  000ba	48 8b b4 24 d8
	00 00 00	 mov	 rsi, QWORD PTR qsuboffsets$[rsp]
  000c2	48 8b ac 24 c8
	00 00 00	 mov	 rbp, QWORD PTR psuboffsets$[rsp]
  000ca	49 83 c1 08	 add	 r9, 8
  000ce	49 83 c3 08	 add	 r11, 8
  000d2	49 8d 42 08	 lea	 rax, QWORD PTR [r10+8]
  000d6	49 ff c8	 dec	 r8
  000d9	4c 89 4c 24 60	 mov	 QWORD PTR tv199[rsp], r9
  000de	4c 89 44 24 78	 mov	 QWORD PTR tv196[rsp], r8
  000e3	4c 89 5c 24 70	 mov	 QWORD PTR tv198[rsp], r11
  000e8	48 89 44 24 68	 mov	 QWORD PTR tv197[rsp], rax
  000ed	0f 1f 00	 npad	 3
$LL4@cmp_rec:

; 2584 :         const char *xp = ADJUST_PTR(p, psuboffsets);

  000f0	48 85 ed	 test	 rbp, rbp
  000f3	74 12		 je	 SHORT $LN8@cmp_rec
  000f5	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  000f9	48 85 c9	 test	 rcx, rcx
  000fc	78 09		 js	 SHORT $LN8@cmp_rec
  000fe	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00101	4c 8d 14 01	 lea	 r10, QWORD PTR [rcx+rax]
  00105	eb 03		 jmp	 SHORT $LN9@cmp_rec
$LN8@cmp_rec:
  00107	4c 8b d3	 mov	 r10, rbx
$LN9@cmp_rec:

; 2585 :         const char *xq = ADJUST_PTR(q, qsuboffsets);

  0010a	48 85 f6	 test	 rsi, rsi
  0010d	74 11		 je	 SHORT $LN10@cmp_rec
  0010f	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00112	48 85 c9	 test	 rcx, rcx
  00115	78 09		 js	 SHORT $LN10@cmp_rec
  00117	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0011a	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0011e	eb 03		 jmp	 SHORT $LN11@cmp_rec
$LN10@cmp_rec:
  00120	48 8b d7	 mov	 rdx, rdi
$LN11@cmp_rec:

; 2586 :         equal = cmp_rec(xp, xq, ndim-1, shape+1,
; 2587 :                         pstrides+1, psuboffsets ? psuboffsets+1 : NULL,
; 2588 :                         qstrides+1, qsuboffsets ? qsuboffsets+1 : NULL,
; 2589 :                         fmt, unpack_p, unpack_q);

  00123	48 85 f6	 test	 rsi, rsi
  00126	74 06		 je	 SHORT $LN12@cmp_rec
  00128	48 8d 4e 08	 lea	 rcx, QWORD PTR [rsi+8]
  0012c	eb 02		 jmp	 SHORT $LN13@cmp_rec
$LN12@cmp_rec:
  0012e	33 c9		 xor	 ecx, ecx
$LN13@cmp_rec:
  00130	48 85 ed	 test	 rbp, rbp
  00133	74 06		 je	 SHORT $LN14@cmp_rec
  00135	48 8d 45 08	 lea	 rax, QWORD PTR [rbp+8]
  00139	eb 02		 jmp	 SHORT $LN15@cmp_rec
$LN14@cmp_rec:
  0013b	33 c0		 xor	 eax, eax
$LN15@cmp_rec:
  0013d	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR unpack_q$[rsp]
  00145	4c 89 4c 24 50	 mov	 QWORD PTR [rsp+80], r9
  0014a	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR unpack_p$[rsp]
  00152	4c 89 4c 24 48	 mov	 QWORD PTR [rsp+72], r9
  00157	44 0f b6 8c 24
	e0 00 00 00	 movzx	 r9d, BYTE PTR fmt$[rsp]
  00160	44 88 4c 24 40	 mov	 BYTE PTR [rsp+64], r9b
  00165	4c 8b 4c 24 60	 mov	 r9, QWORD PTR tv199[rsp]
  0016a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016f	4c 89 4c 24 30	 mov	 QWORD PTR [rsp+48], r9
  00174	4c 8b 4c 24 68	 mov	 r9, QWORD PTR tv197[rsp]
  00179	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017e	49 8b ca	 mov	 rcx, r10
  00181	4c 89 5c 24 20	 mov	 QWORD PTR [rsp+32], r11
  00186	e8 00 00 00 00	 call	 cmp_rec

; 2590 :         if (equal <= 0)

  0018b	85 c0		 test	 eax, eax
  0018d	7e 49		 jle	 SHORT $LN20@cmp_rec

; 2581 :     }
; 2582 : 
; 2583 :     for (i = 0; i < shape[0]; p+=pstrides[0], q+=qstrides[0], i++) {

  0018f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pstrides$[rsp]
  00197	4c 8b 94 24 b8
	00 00 00	 mov	 r10, QWORD PTR shape$[rsp]
  0019f	4c 8b 5c 24 70	 mov	 r11, QWORD PTR tv198[rsp]
  001a4	48 03 18	 add	 rbx, QWORD PTR [rax]
  001a7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR qstrides$[rsp]
  001af	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv196[rsp]
  001b4	48 03 38	 add	 rdi, QWORD PTR [rax]
  001b7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i$1$[rsp]
  001bf	48 ff c0	 inc	 rax
  001c2	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i$1$[rsp], rax
  001ca	49 3b 02	 cmp	 rax, QWORD PTR [r10]
  001cd	0f 8c 1d ff ff
	ff		 jl	 $LL4@cmp_rec
$LN2@cmp_rec:

; 2591 :             return equal;
; 2592 :     }
; 2593 : 
; 2594 :     return 1;

  001d3	b8 01 00 00 00	 mov	 eax, 1
$LN20@cmp_rec:
  001d8	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  001e0	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]

; 2595 : }

  001e8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ef	5f		 pop	 rdi
  001f0	5b		 pop	 rbx
  001f1	c3		 ret	 0
cmp_rec	ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_richcompare DD imagerel memory_richcompare
	DD	imagerel memory_richcompare+11
	DD	imagerel $unwind$memory_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$memory_richcompare DD imagerel memory_richcompare+11
	DD	imagerel memory_richcompare+248
	DD	imagerel $chain$5$memory_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$memory_richcompare DD imagerel memory_richcompare+248
	DD	imagerel memory_richcompare+332
	DD	imagerel $chain$6$memory_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$memory_richcompare DD imagerel memory_richcompare+332
	DD	imagerel memory_richcompare+651
	DD	imagerel $chain$7$memory_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$memory_richcompare DD imagerel memory_richcompare+651
	DD	imagerel memory_richcompare+704
	DD	imagerel $chain$8$memory_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$memory_richcompare DD imagerel memory_richcompare+704
	DD	imagerel memory_richcompare+775
	DD	imagerel $chain$9$memory_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$memory_richcompare DD 021H
	DD	imagerel memory_richcompare
	DD	imagerel memory_richcompare+11
	DD	imagerel $unwind$memory_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$memory_richcompare DD 060021H
	DD	018d400H
	DD	019c400H
	DD	01f7400H
	DD	imagerel memory_richcompare
	DD	imagerel memory_richcompare+11
	DD	imagerel $unwind$memory_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$memory_richcompare DD 021H
	DD	imagerel memory_richcompare+11
	DD	imagerel memory_richcompare+248
	DD	imagerel $chain$5$memory_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$memory_richcompare DD 020821H
	DD	016f408H
	DD	imagerel memory_richcompare+11
	DD	imagerel memory_richcompare+248
	DD	imagerel $chain$5$memory_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$memory_richcompare DD 0c1a21H
	DD	017e41aH
	DD	018d416H
	DD	019c412H
	DD	01f740eH
	DD	01d6408H
	DD	01c5404H
	DD	imagerel memory_richcompare
	DD	imagerel memory_richcompare+11
	DD	imagerel $unwind$memory_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_richcompare DD 030b01H
	DD	01a010bH
	DD	03004H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT memory_richcompare
_TEXT	SEGMENT
wbuf$ = 96
v$ = 224
w$ = 232
wfmt$ = 240
vfmt$ = 240
op$ = 240
memory_richcompare PROC					; COMDAT

; 2599 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	53		 push	 rbx
  00004	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0000b	48 89 68 08	 mov	 QWORD PTR [rax+8], rbp
  0000f	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi

; 2600 :     PyObject *res;
; 2601 :     Py_buffer wbuf, *vv;
; 2602 :     Py_buffer *ww = NULL;

  00013	33 db		 xor	 ebx, ebx
  00015	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00019	4c 89 60 f0	 mov	 QWORD PTR [rax-16], r12
  0001d	4c 89 68 e8	 mov	 QWORD PTR [rax-24], r13
  00021	4c 89 70 e0	 mov	 QWORD PTR [rax-32], r14

; 2603 :     struct unpacker *unpack_v = NULL;

  00025	44 8b eb	 mov	 r13d, ebx
  00028	41 8b e8	 mov	 ebp, r8d
  0002b	4c 8b ca	 mov	 r9, rdx
  0002e	8b fb		 mov	 edi, ebx

; 2604 :     struct unpacker *unpack_w = NULL;

  00030	44 8b e3	 mov	 r12d, ebx

; 2605 :     char vfmt, wfmt;
; 2606 :     int equal = MV_COMPARE_NOT_IMPL;
; 2607 : 
; 2608 :     if (op != Py_EQ && op != Py_NE)

  00033	41 83 f8 02	 cmp	 r8d, 2
  00037	74 0a		 je	 SHORT $LN32@memory_ric
  00039	41 83 f8 03	 cmp	 r8d, 3
  0003d	0f 85 07 02 00
	00		 jne	 $LN41@memory_ric
$LN32@memory_ric:

; 2609 :         goto result; /* Py_NotImplemented */
; 2610 : 
; 2611 :     assert(PyMemoryView_Check(v));
; 2612 :     if (BASE_INACCESSIBLE(v)) {

  00043	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0004a	0f 85 e9 01 00
	00		 jne	 $LN30@memory_ric
  00050	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00054	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00058	0f 85 db 01 00
	00		 jne	 $LN30@memory_ric

; 2614 :         goto result;
; 2615 :     }
; 2616 :     vv = VIEW_ADDR(v);
; 2617 : 
; 2618 :     if (PyMemoryView_Check(w)) {

  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMemoryView_Type
  00065	48 8d b1 90 00
	00 00		 lea	 rsi, QWORD PTR [rcx+144]
  0006c	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  00070	75 24		 jne	 SHORT $LN29@memory_ric

; 2619 :         if (BASE_INACCESSIBLE(w)) {

  00072	f6 82 80 00 00
	00 01		 test	 BYTE PTR [rdx+128], 1
  00079	0f 85 ba 01 00
	00		 jne	 $LN30@memory_ric
  0007f	48 8b 42 70	 mov	 rax, QWORD PTR [rdx+112]
  00083	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00087	0f 85 ac 01 00
	00		 jne	 $LN30@memory_ric

; 2620 :             equal = (v == w);
; 2621 :             goto result;
; 2622 :         }
; 2623 :         ww = VIEW_ADDR(w);

  0008d	48 8d ba 90 00
	00 00		 lea	 rdi, QWORD PTR [rdx+144]

; 2624 :     }
; 2625 :     else {

  00094	eb 2d		 jmp	 SHORT $LN26@memory_ric
$LN29@memory_ric:

; 2626 :         if (PyObject_GetBuffer(w, &wbuf, PyBUF_FULL_RO) < 0) {

  00096	48 8d 54 24 60	 lea	 rdx, QWORD PTR wbuf$[rsp]
  0009b	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  000a1	49 8b c9	 mov	 rcx, r9
  000a4	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000a9	85 c0		 test	 eax, eax
  000ab	79 11		 jns	 SHORT $LN25@memory_ric

; 2627 :             PyErr_Clear();

  000ad	e8 00 00 00 00	 call	 PyErr_Clear

; 2682 :             res = Py_NotImplemented;

  000b2	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NotImplementedStruct

; 2683 :         else /* exception */

  000b9	e9 ab 01 00 00	 jmp	 $LN6@memory_ric
$LN25@memory_ric:

; 2628 :             goto result; /* Py_NotImplemented */
; 2629 :         }
; 2630 :         ww = &wbuf;

  000be	48 8d 7c 24 60	 lea	 rdi, QWORD PTR wbuf$[rsp]
$LN26@memory_ric:

; 2631 :     }
; 2632 : 
; 2633 :     if (!equiv_shape(vv, ww)) {

  000c3	48 8b d7	 mov	 rdx, rdi
  000c6	48 8b ce	 mov	 rcx, rsi
  000c9	e8 00 00 00 00	 call	 equiv_shape
  000ce	85 c0		 test	 eax, eax
  000d0	75 1a		 jne	 SHORT $LN24@memory_ric

; 2634 :         PyErr_Clear();

  000d2	e8 00 00 00 00	 call	 PyErr_Clear
$LN39@memory_ric:

; 2684 :             res = NULL;
; 2685 :     }
; 2686 :     else if ((equal && op == Py_EQ) || (!equal && op == Py_NE))

  000d7	83 fd 03	 cmp	 ebp, 3
  000da	0f 85 82 01 00
	00		 jne	 $LN9@memory_ric
$LN8@memory_ric:

; 2687 :         res = Py_True;

  000e0	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct

; 2688 :     else

  000e7	e9 7d 01 00 00	 jmp	 $LN6@memory_ric
$LN24@memory_ric:

; 2635 :         equal = 0;
; 2636 :         goto result;
; 2637 :     }
; 2638 : 
; 2639 :     /* Use fast unpacking for identical primitive C type formats. */
; 2640 :     if (get_native_fmtchar(&vfmt, vv->format) < 0)

  000ec	4c 8b 5e 28	 mov	 r11, QWORD PTR [rsi+40]
  000f0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR vfmt$[rsp]
  000f8	4c 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r15
  00100	49 8b d3	 mov	 rdx, r11
  00103	e8 00 00 00 00	 call	 get_native_fmtchar
  00108	44 0f b6 b4 24
	f0 00 00 00	 movzx	 r14d, BYTE PTR vfmt$[rsp]

; 2641 :         vfmt = '_';
; 2642 :     if (get_native_fmtchar(&wfmt, ww->format) < 0)

  00111	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  00115	48 85 c0	 test	 rax, rax
  00118	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR wfmt$[rsp]
  00120	41 bf 5f 00 00
	00		 mov	 r15d, 95		; 0000005fH
  00126	45 0f 48 f7	 cmovs	 r14d, r15d
  0012a	e8 00 00 00 00	 call	 get_native_fmtchar
  0012f	0f b6 94 24 f0
	00 00 00	 movzx	 edx, BYTE PTR wfmt$[rsp]
  00137	48 85 c0	 test	 rax, rax
  0013a	41 0f 48 d7	 cmovs	 edx, r15d
  0013e	4c 8b bc 24 b0
	00 00 00	 mov	 r15, QWORD PTR [rsp+176]

; 2643 :         wfmt = '_';
; 2644 :     if (vfmt == '_' || wfmt == '_' || vfmt != wfmt) {

  00146	41 80 fe 5f	 cmp	 r14b, 95		; 0000005fH
  0014a	74 0a		 je	 SHORT $LN20@memory_ric
  0014c	80 fa 5f	 cmp	 dl, 95			; 0000005fH
  0014f	74 05		 je	 SHORT $LN20@memory_ric
  00151	44 3a f2	 cmp	 r14b, dl
  00154	74 40		 je	 SHORT $LN18@memory_ric
$LN20@memory_ric:

; 2645 :         /* Use struct module unpacking. NOTE: Even for equal format strings,
; 2646 :            memcmp() cannot be used for item comparison since it would give
; 2647 :            incorrect results in the case of NaNs or uninitialized padding
; 2648 :            bytes. */
; 2649 :         vfmt = '_';
; 2650 :         unpack_v = struct_get_unpacker(vv->format, vv->itemsize);

  00156	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  0015a	49 8b cb	 mov	 rcx, r11
  0015d	41 b6 5f	 mov	 r14b, 95		; 0000005fH
  00160	e8 00 00 00 00	 call	 struct_get_unpacker
  00165	4c 8b e8	 mov	 r13, rax

; 2651 :         if (unpack_v == NULL) {

  00168	48 85 c0	 test	 rax, rax
  0016b	75 0a		 jne	 SHORT $LN19@memory_ric

; 2652 :             equal = fix_struct_error_int();

  0016d	e8 00 00 00 00	 call	 fix_struct_error_int

; 2653 :             goto result;

  00172	e9 ca 00 00 00	 jmp	 $result$22182
$LN19@memory_ric:

; 2654 :         }
; 2655 :         unpack_w = struct_get_unpacker(ww->format, ww->itemsize);

  00177	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  0017b	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0017f	e8 00 00 00 00	 call	 struct_get_unpacker
  00184	4c 8b e0	 mov	 r12, rax

; 2656 :         if (unpack_w == NULL) {

  00187	48 85 c0	 test	 rax, rax
  0018a	75 0a		 jne	 SHORT $LN18@memory_ric

; 2657 :             equal = fix_struct_error_int();

  0018c	e8 00 00 00 00	 call	 fix_struct_error_int

; 2658 :             goto result;

  00191	e9 ab 00 00 00	 jmp	 $result$22182
$LN18@memory_ric:

; 2659 :         }
; 2660 :     }
; 2661 : 
; 2662 :     if (vv->ndim == 0) {

  00196	48 63 46 24	 movsxd	 rax, DWORD PTR [rsi+36]

; 2663 :         equal = unpack_cmp(vv->buf, ww->buf,
; 2664 :                            vfmt, unpack_v, unpack_w);

  0019a	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  0019d	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  001a0	85 c0		 test	 eax, eax
  001a2	75 16		 jne	 SHORT $LN17@memory_ric
  001a4	4d 8b cd	 mov	 r9, r13
  001a7	45 0f b6 c6	 movzx	 r8d, r14b
  001ab	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001b0	e8 00 00 00 00	 call	 unpack_cmp
  001b5	e9 87 00 00 00	 jmp	 $result$22182
$LN17@memory_ric:

; 2665 :     }
; 2666 :     else if (vv->ndim == 1) {

  001ba	83 f8 01	 cmp	 eax, 1
  001bd	75 39		 jne	 SHORT $LN15@memory_ric

; 2667 :         equal = cmp_base(vv->buf, ww->buf, vv->shape,
; 2668 :                          vv->strides, vv->suboffsets,
; 2669 :                          ww->strides, ww->suboffsets,
; 2670 :                          vfmt, unpack_v, unpack_w);

  001bf	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  001c3	4c 8b 4e 38	 mov	 r9, QWORD PTR [rsi+56]
  001c7	4c 8b 46 30	 mov	 r8, QWORD PTR [rsi+48]
  001cb	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  001d0	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  001d5	44 88 74 24 38	 mov	 BYTE PTR [rsp+56], r14b
  001da	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001df	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  001e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e8	48 8b 46 40	 mov	 rax, QWORD PTR [rsi+64]
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	e8 00 00 00 00	 call	 cmp_base

; 2671 :     }
; 2672 :     else {

  001f6	eb 49		 jmp	 SHORT $result$22182
$LN15@memory_ric:

; 2673 :         equal = cmp_rec(vv->buf, ww->buf, vv->ndim, vv->shape,
; 2674 :                         vv->strides, vv->suboffsets,
; 2675 :                         ww->strides, ww->suboffsets,
; 2676 :                         vfmt, unpack_v, unpack_w);

  001f8	4c 8b 4e 30	 mov	 r9, QWORD PTR [rsi+48]
  001fc	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00201	4c 8b c0	 mov	 r8, rax
  00204	48 8b 47 40	 mov	 rax, QWORD PTR [rdi+64]
  00208	4c 89 6c 24 48	 mov	 QWORD PTR [rsp+72], r13
  0020d	44 88 74 24 40	 mov	 BYTE PTR [rsp+64], r14b
  00212	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00217	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0021b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00220	48 8b 46 40	 mov	 rax, QWORD PTR [rsi+64]
  00224	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00229	48 8b 46 38	 mov	 rax, QWORD PTR [rsi+56]
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	e8 00 00 00 00	 call	 cmp_rec
  00237	eb 08		 jmp	 SHORT $result$22182
$LN30@memory_ric:

; 2613 :         equal = (v == w);

  00239	48 3b ca	 cmp	 rcx, rdx
  0023c	8b c3		 mov	 eax, ebx
  0023e	0f 94 c0	 sete	 al
$result$22182:

; 2677 :     }
; 2678 : 
; 2679 : result:
; 2680 :     if (equal < 0) {

  00241	85 c0		 test	 eax, eax
  00243	79 0e		 jns	 SHORT $LN45@memory_ric

; 2681 :         if (equal == MV_COMPARE_NOT_IMPL)

  00245	83 f8 fe	 cmp	 eax, -2
  00248	75 1f		 jne	 SHORT $LN6@memory_ric
$LN41@memory_ric:

; 2682 :             res = Py_NotImplemented;

  0024a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NotImplementedStruct

; 2683 :         else /* exception */

  00251	eb 16		 jmp	 SHORT $LN6@memory_ric
$LN45@memory_ric:

; 2684 :             res = NULL;
; 2685 :     }
; 2686 :     else if ((equal && op == Py_EQ) || (!equal && op == Py_NE))

  00253	0f 84 7e fe ff
	ff		 je	 $LN39@memory_ric
  00259	83 fd 02	 cmp	 ebp, 2
  0025c	0f 84 7e fe ff
	ff		 je	 $LN8@memory_ric
$LN9@memory_ric:

; 2689 :         res = Py_False;

  00262	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
$LN6@memory_ric:
  00269	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR [rsp+184]
  00271	48 8b b4 24 e8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+232]
  00279	48 8b ac 24 e0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+224]

; 2690 : 
; 2691 :     if (ww == &wbuf)

  00281	48 8d 44 24 60	 lea	 rax, QWORD PTR wbuf$[rsp]
  00286	48 3b f8	 cmp	 rdi, rax
  00289	75 08		 jne	 SHORT $LN5@memory_ric

; 2692 :         PyBuffer_Release(ww);

  0028b	48 8b cf	 mov	 rcx, rdi
  0028e	e8 00 00 00 00	 call	 PyBuffer_Release
$LN5@memory_ric:

; 2693 : 
; 2694 :     unpacker_free(unpack_v);

  00293	49 8b cd	 mov	 rcx, r13
  00296	e8 00 00 00 00	 call	 unpacker_free

; 2695 :     unpacker_free(unpack_w);

  0029b	49 8b cc	 mov	 rcx, r12
  0029e	e8 00 00 00 00	 call	 unpacker_free
  002a3	4c 8b ac 24 c0
	00 00 00	 mov	 r13, QWORD PTR [rsp+192]
  002ab	4c 8b a4 24 c8
	00 00 00	 mov	 r12, QWORD PTR [rsp+200]
  002b3	48 8b bc 24 f8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+248]

; 2696 : 
; 2697 :     Py_XINCREF(res);

  002bb	48 85 db	 test	 rbx, rbx
  002be	74 3b		 je	 SHORT $LN44@memory_ric
  002c0	e8 00 00 00 00	 call	 _Py_PXCTX
  002c5	85 c0		 test	 eax, eax
  002c7	75 32		 jne	 SHORT $LN44@memory_ric
  002c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002d7	4c 8b cb	 mov	 r9, rbx
  002da	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002e0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002e8	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ed	85 c0		 test	 eax, eax
  002ef	75 06		 jne	 SHORT $LN35@memory_ric
  002f1	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  002f5	74 04		 je	 SHORT $LN44@memory_ric
$LN35@memory_ric:
  002f7	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN44@memory_ric:

; 2698 :     return res;

  002fb	48 8b c3	 mov	 rax, rbx

; 2699 : }

  002fe	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00305	5b		 pop	 rbx
  00306	c3		 ret	 0
memory_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@ ; `string'
PUBLIC	??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@ ; `string'
EXTRN	_Py_HashBytes:PROC
EXTRN	PyObject_Hash:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_hash DD imagerel memory_hash
	DD	imagerel memory_hash+366
	DD	imagerel $unwind$memory_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_hash DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@
CONST	SEGMENT
??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@ DB 'memoryview: '
	DB	'hashing is restricted to formats ''B'', ''b'' or ''c''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@
CONST	SEGMENT
??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@ DB 'cannot hash '
	DB	'writable memoryview object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT memory_hash
_TEXT	SEGMENT
fmt$22236 = 48
self$ = 48
memory_hash PROC					; COMDAT

; 2707 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2708 :     if (self->hash == -1) {

  0000f	48 83 79 78 ff	 cmp	 QWORD PTR [rcx+120], -1
  00014	48 8b d9	 mov	 rbx, rcx
  00017	0f 85 0d 01 00
	00		 jne	 $LN1@memory_has

; 2709 :         Py_buffer *view = &self->view;
; 2710 :         char *mem = view->buf;
; 2711 :         Py_ssize_t ret;
; 2712 :         char fmt;
; 2713 : 
; 2714 :         CHECK_RELEASED_INT(self);

  0001d	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  00024	48 8b b9 90 00
	00 00		 mov	 rdi, QWORD PTR [rcx+144]
  0002b	0f 85 16 01 00
	00		 jne	 $LN9@memory_has
  00031	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00035	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00039	0f 85 08 01 00
	00		 jne	 $LN9@memory_has

; 2715 : 
; 2716 :         if (!view->readonly) {

  0003f	83 b9 b0 00 00
	00 00		 cmp	 DWORD PTR [rcx+176], 0
  00046	75 0c		 jne	 SHORT $LN8@memory_has

; 2717 :             PyErr_SetString(PyExc_ValueError,
; 2718 :                 "cannot hash writable memoryview object");

  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HDKCDPKN@cannot?5hash?5writable?5memoryview?5@

; 2719 :             return -1;

  0004f	e9 fa 00 00 00	 jmp	 $LN14@memory_has
$LN8@memory_has:

; 2720 :         }
; 2721 :         ret = get_native_fmtchar(&fmt, view->format);

  00054	48 8b 91 b8 00
	00 00		 mov	 rdx, QWORD PTR [rcx+184]
  0005b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR fmt$22236[rsp]
  00060	e8 00 00 00 00	 call	 get_native_fmtchar

; 2722 :         if (ret < 0 || !IS_BYTE_FORMAT(fmt)) {

  00065	48 85 c0	 test	 rax, rax
  00068	0f 88 d0 00 00
	00		 js	 $LN6@memory_has
  0006e	0f b6 44 24 30	 movzx	 eax, BYTE PTR fmt$22236[rsp]
  00073	3c 62		 cmp	 al, 98			; 00000062H
  00075	74 0c		 je	 SHORT $LN7@memory_has
  00077	3c 42		 cmp	 al, 66			; 00000042H
  00079	74 08		 je	 SHORT $LN7@memory_has
  0007b	3c 63		 cmp	 al, 99			; 00000063H
  0007d	0f 85 bb 00 00
	00		 jne	 $LN6@memory_has
$LN7@memory_has:

; 2726 :         }
; 2727 :         if (view->obj != NULL && PyObject_Hash(view->obj) == -1) {

  00083	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  0008a	48 85 c9	 test	 rcx, rcx
  0008d	74 0f		 je	 SHORT $LN5@memory_has
  0008f	e8 00 00 00 00	 call	 PyObject_Hash
  00094	48 83 f8 ff	 cmp	 rax, -1

; 2728 :             /* Keep the original error message */
; 2729 :             return -1;

  00098	0f 84 bc 00 00
	00		 je	 $LN15@memory_has
$LN5@memory_has:

; 2730 :         }
; 2731 : 
; 2732 :         if (!MV_C_CONTIGUOUS(self->flags)) {

  0009e	f6 83 80 00 00
	00 0a		 test	 BYTE PTR [rbx+128], 10
  000a5	75 5f		 jne	 SHORT $LN2@memory_has

; 2733 :             mem = PyMem_Malloc(view->len);

  000a7	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
  000ae	e8 00 00 00 00	 call	 PyMem_Malloc
  000b3	48 8b f8	 mov	 rdi, rax

; 2734 :             if (mem == NULL) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	75 19		 jne	 SHORT $LN3@memory_has

; 2735 :                 PyErr_NoMemory();

  000bb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2709 :         Py_buffer *view = &self->view;
; 2710 :         char *mem = view->buf;
; 2711 :         Py_ssize_t ret;
; 2712 :         char fmt;
; 2713 : 
; 2714 :         CHECK_RELEASED_INT(self);

  000c0	48 83 c8 ff	 or	 rax, -1

; 2752 : }

  000c4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
$LN3@memory_has:

; 2736 :                 return -1;
; 2737 :             }
; 2738 :             if (buffer_to_contiguous(mem, view, 'C') < 0) {

  000d4	48 8d 93 90 00
	00 00		 lea	 rdx, QWORD PTR [rbx+144]
  000db	41 b0 43	 mov	 r8b, 67			; 00000043H
  000de	48 8b c8	 mov	 rcx, rax
  000e1	e8 00 00 00 00	 call	 buffer_to_contiguous
  000e6	85 c0		 test	 eax, eax
  000e8	79 1c		 jns	 SHORT $LN2@memory_has

; 2739 :                 PyMem_Free(mem);

  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	e8 00 00 00 00	 call	 PyMem_Free
  000f2	48 83 c8 ff	 or	 rax, -1

; 2752 : }

  000f6	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000fb	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00100	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
$LN2@memory_has:

; 2740 :                 return -1;
; 2741 :             }
; 2742 :         }
; 2743 : 
; 2744 :         /* Can't fail */
; 2745 :         self->hash = _Py_HashBytes((unsigned char *)mem, view->len);

  00106	48 8b 93 a0 00
	00 00		 mov	 rdx, QWORD PTR [rbx+160]
  0010d	48 8b cf	 mov	 rcx, rdi
  00110	e8 00 00 00 00	 call	 _Py_HashBytes
  00115	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 2746 : 
; 2747 :         if (mem != view->buf)

  00119	48 3b bb 90 00
	00 00		 cmp	 rdi, QWORD PTR [rbx+144]
  00120	74 08		 je	 SHORT $LN1@memory_has

; 2748 :             PyMem_Free(mem);

  00122	48 8b cf	 mov	 rcx, rdi
  00125	e8 00 00 00 00	 call	 PyMem_Free
$LN1@memory_has:

; 2749 :     }
; 2750 : 
; 2751 :     return self->hash;

  0012a	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 2752 : }

  0012e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00133	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5f		 pop	 rdi
  0013d	c3		 ret	 0
$LN6@memory_has:

; 2723 :             PyErr_SetString(PyExc_ValueError,
; 2724 :                 "memoryview: hashing is restricted to formats 'B', 'b' or 'c'");

  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@FBHGAFDH@memoryview?3?5hashing?5is?5restricte@

; 2725 :             return -1;

  00145	eb 07		 jmp	 SHORT $LN14@memory_has
$LN9@memory_has:

; 2709 :         Py_buffer *view = &self->view;
; 2710 :         char *mem = view->buf;
; 2711 :         Py_ssize_t ret;
; 2712 :         char fmt;
; 2713 : 
; 2714 :         CHECK_RELEASED_INT(self);

  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
$LN14@memory_has:
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00155	e8 00 00 00 00	 call	 PyErr_SetString
$LN15@memory_has:

; 2752 : }

  0015a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0015f	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00164	48 83 c8 ff	 or	 rax, -1
  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
memory_hash ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_IntTupleFromSsizet DD imagerel _IntTupleFromSsizet
	DD	imagerel _IntTupleFromSsizet+26
	DD	imagerel $unwind$_IntTupleFromSsizet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_IntTupleFromSsizet DD imagerel _IntTupleFromSsizet+26
	DD	imagerel _IntTupleFromSsizet+71
	DD	imagerel $chain$1$_IntTupleFromSsizet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_IntTupleFromSsizet DD imagerel _IntTupleFromSsizet+71
	DD	imagerel _IntTupleFromSsizet+155
	DD	imagerel $chain$5$_IntTupleFromSsizet
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_IntTupleFromSsizet DD imagerel _IntTupleFromSsizet+155
	DD	imagerel _IntTupleFromSsizet+167
	DD	imagerel $chain$7$_IntTupleFromSsizet
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_IntTupleFromSsizet DD 080021H
	DD	09c400H
	DD	087400H
	DD	076400H
	DD	065400H
	DD	imagerel _IntTupleFromSsizet
	DD	imagerel _IntTupleFromSsizet+26
	DD	imagerel $unwind$_IntTupleFromSsizet
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_IntTupleFromSsizet DD 080c21H
	DD	09c40cH
	DD	087405H
	DD	076400H
	DD	065400H
	DD	imagerel _IntTupleFromSsizet
	DD	imagerel _IntTupleFromSsizet+26
	DD	imagerel $unwind$_IntTupleFromSsizet
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_IntTupleFromSsizet DD 040a21H
	DD	07640aH
	DD	065405H
	DD	imagerel _IntTupleFromSsizet
	DD	imagerel _IntTupleFromSsizet+26
	DD	imagerel $unwind$_IntTupleFromSsizet
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_IntTupleFromSsizet DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _IntTupleFromSsizet
_TEXT	SEGMENT
len$ = 48
vals$ = 56
_IntTupleFromSsizet PROC				; COMDAT

; 2761 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 2762 :     int i;
; 2763 :     PyObject *o;
; 2764 :     PyObject *intTuple;
; 2765 : 
; 2766 :     if (vals == NULL)

  00009	48 85 d2	 test	 rdx, rdx
  0000c	75 0c		 jne	 SHORT $LN6@IntTupleFr

; 2767 :         return PyTuple_New(0);

  0000e	33 c9		 xor	 ecx, ecx

; 2781 : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	e9 00 00 00 00	 jmp	 PyTuple_New
$LN6@IntTupleFr:
  0001a	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0001f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi

; 2768 : 
; 2769 :     intTuple = PyTuple_New(len);

  00024	48 63 f1	 movsxd	 rsi, ecx
  00027	48 8b ce	 mov	 rcx, rsi
  0002a	e8 00 00 00 00	 call	 PyTuple_New
  0002f	48 8b e8	 mov	 rbp, rax

; 2770 :     if (!intTuple)

  00032	48 85 c0	 test	 rax, rax
  00035	75 10		 jne	 SHORT $LN5@IntTupleFr
  00037	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0003c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2781 : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN5@IntTupleFr:
  00047	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 2771 :         return NULL;
; 2772 :     for (i=0; i<len; i++) {

  0004c	33 ff		 xor	 edi, edi
  0004e	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  00053	48 85 f6	 test	 rsi, rsi
  00056	7e 26		 jle	 SHORT $LN2@IntTupleFr
  00058	4c 8b e0	 mov	 r12, rax
  0005b	4c 2b e3	 sub	 r12, rbx
  0005e	66 90		 npad	 2
$LL4@IntTupleFr:

; 2773 :         o = PyLong_FromSsize_t(vals[i]);

  00060	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00063	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 2774 :         if (!o) {

  00068	48 85 c0	 test	 rax, rax
  0006b	74 2e		 je	 SHORT $LN10@IntTupleFr

; 2777 :         }
; 2778 :         PyTuple_SET_ITEM(intTuple, i, o);

  0006d	48 ff c7	 inc	 rdi
  00070	49 89 44 1c 70	 mov	 QWORD PTR [r12+rbx+112], rax
  00075	48 83 c3 08	 add	 rbx, 8
  00079	48 3b fe	 cmp	 rdi, rsi
  0007c	7c e2		 jl	 SHORT $LL4@IntTupleFr
$LN2@IntTupleFr:

; 2779 :     }
; 2780 :     return intTuple;

  0007e	48 8b c5	 mov	 rax, rbp
$LN15@IntTupleFr:
  00081	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00086	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0008b	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00090	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2781 : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5b		 pop	 rbx
  0009a	c3		 ret	 0
$LN10@IntTupleFr:

; 2775 :             Py_DECREF(intTuple);

  0009b	48 8b cd	 mov	 rcx, rbp
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 2776 :             return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	eb da		 jmp	 SHORT $LN15@IntTupleFr
_IntTupleFromSsizet ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$memory_obj_get DD imagerel memory_obj_get
	DD	imagerel memory_obj_get+167
	DD	imagerel $unwind$memory_obj_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_obj_get DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\objects\memoryobject.c
xdata	ENDS
;	COMDAT memory_obj_get
_TEXT	SEGMENT
self$ = 64
memory_obj_get PROC					; COMDAT

; 2785 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2786 :     Py_buffer *view = &self->view;
; 2787 : 
; 2788 :     CHECK_RELEASED(self);

  00006	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	75 7a		 jne	 SHORT $LN2@memory_obj
  00012	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00016	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0001a	75 70		 jne	 SHORT $LN2@memory_obj

; 2789 :     if (view->obj == NULL) {

  0001c	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00023	48 85 c9	 test	 rcx, rcx
  00026	75 52		 jne	 SHORT $LN1@memory_obj

; 2790 :         Py_RETURN_NONE;

  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	75 3c		 jne	 SHORT $LN7@memory_obj
  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00046	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	85 c0		 test	 eax, eax
  0005b	75 09		 jne	 SHORT $LN6@memory_obj
  0005d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00064	74 07		 je	 SHORT $LN7@memory_obj
$LN6@memory_obj:
  00066	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@memory_obj:
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2794 : }

  00074	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
$LN1@memory_obj:

; 2791 :     }
; 2792 :     Py_INCREF(view->obj);

  0007a	e8 00 00 00 00	 call	 _Py_IncRef

; 2793 :     return view->obj;

  0007f	48 8b 83 98 00
	00 00		 mov	 rax, QWORD PTR [rbx+152]

; 2794 : }

  00086	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
$LN2@memory_obj:

; 2786 :     Py_buffer *view = &self->view;
; 2787 : 
; 2788 :     CHECK_RELEASED(self);

  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0009a	e8 00 00 00 00	 call	 PyErr_SetString
  0009f	33 c0		 xor	 eax, eax

; 2794 : }

  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0
memory_obj_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_nbytes_get DD imagerel memory_nbytes_get
	DD	imagerel memory_nbytes_get+65
	DD	imagerel $unwind$memory_nbytes_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_nbytes_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_nbytes_get
_TEXT	SEGMENT
self$ = 48
memory_nbytes_get PROC					; COMDAT

; 2798 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2799 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 1a		 jne	 SHORT $LN1@memory_nby
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 10		 jne	 SHORT $LN1@memory_nby

; 2800 :     return PyLong_FromSsize_t(self->view.len);

  00017	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]

; 2801 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN1@memory_nby:

; 2799 :     CHECK_RELEASED(self);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	e8 00 00 00 00	 call	 PyErr_SetString
  0003a	33 c0		 xor	 eax, eax

; 2801 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
memory_nbytes_get ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_format_get DD imagerel memory_format_get
	DD	imagerel memory_format_get+65
	DD	imagerel $unwind$memory_format_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_format_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_format_get
_TEXT	SEGMENT
self$ = 48
memory_format_get PROC					; COMDAT

; 2805 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2806 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 1a		 jne	 SHORT $LN1@memory_for@2
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 10		 jne	 SHORT $LN1@memory_for@2

; 2807 :     return PyUnicode_FromString(self->view.format);

  00017	48 8b 89 b8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+184]

; 2808 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN1@memory_for@2:

; 2806 :     CHECK_RELEASED(self);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	e8 00 00 00 00	 call	 PyErr_SetString
  0003a	33 c0		 xor	 eax, eax

; 2808 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
memory_format_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_itemsize_get DD imagerel memory_itemsize_get
	DD	imagerel memory_itemsize_get+65
	DD	imagerel $unwind$memory_itemsize_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_itemsize_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_itemsize_get
_TEXT	SEGMENT
self$ = 48
memory_itemsize_get PROC				; COMDAT

; 2812 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2813 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 1a		 jne	 SHORT $LN1@memory_ite@2
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 10		 jne	 SHORT $LN1@memory_ite@2

; 2814 :     return PyLong_FromSsize_t(self->view.itemsize);

  00017	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]

; 2815 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN1@memory_ite@2:

; 2813 :     CHECK_RELEASED(self);

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00035	e8 00 00 00 00	 call	 PyErr_SetString
  0003a	33 c0		 xor	 eax, eax

; 2815 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
memory_itemsize_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_shape_get DD imagerel memory_shape_get
	DD	imagerel memory_shape_get+71
	DD	imagerel $unwind$memory_shape_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_shape_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_shape_get
_TEXT	SEGMENT
self$ = 48
memory_shape_get PROC					; COMDAT

; 2819 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2820 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 20		 jne	 SHORT $LN1@memory_sha
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 16		 jne	 SHORT $LN1@memory_sha

; 2821 :     return _IntTupleFromSsizet(self->view.ndim, self->view.shape);

  00017	48 8b 91 c0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+192]
  0001e	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]

; 2822 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	e9 00 00 00 00	 jmp	 _IntTupleFromSsizet
$LN1@memory_sha:

; 2820 :     CHECK_RELEASED(self);

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003b	e8 00 00 00 00	 call	 PyErr_SetString
  00040	33 c0		 xor	 eax, eax

; 2822 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
memory_shape_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_strides_get DD imagerel memory_strides_get
	DD	imagerel memory_strides_get+71
	DD	imagerel $unwind$memory_strides_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_strides_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_strides_get
_TEXT	SEGMENT
self$ = 48
memory_strides_get PROC					; COMDAT

; 2826 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2827 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 20		 jne	 SHORT $LN1@memory_str
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 16		 jne	 SHORT $LN1@memory_str

; 2828 :     return _IntTupleFromSsizet(self->view.ndim, self->view.strides);

  00017	48 8b 91 c8 00
	00 00		 mov	 rdx, QWORD PTR [rcx+200]
  0001e	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]

; 2829 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	e9 00 00 00 00	 jmp	 _IntTupleFromSsizet
$LN1@memory_str:

; 2827 :     CHECK_RELEASED(self);

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003b	e8 00 00 00 00	 call	 PyErr_SetString
  00040	33 c0		 xor	 eax, eax

; 2829 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
memory_strides_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_suboffsets_get DD imagerel memory_suboffsets_get
	DD	imagerel memory_suboffsets_get+71
	DD	imagerel $unwind$memory_suboffsets_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_suboffsets_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_suboffsets_get
_TEXT	SEGMENT
self$ = 48
memory_suboffsets_get PROC				; COMDAT

; 2833 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2834 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 20		 jne	 SHORT $LN1@memory_sub@2
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 16		 jne	 SHORT $LN1@memory_sub@2

; 2835 :     return _IntTupleFromSsizet(self->view.ndim, self->view.suboffsets);

  00017	48 8b 91 d0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+208]
  0001e	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]

; 2836 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	e9 00 00 00 00	 jmp	 _IntTupleFromSsizet
$LN1@memory_sub@2:

; 2834 :     CHECK_RELEASED(self);

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  0003b	e8 00 00 00 00	 call	 PyErr_SetString
  00040	33 c0		 xor	 eax, eax

; 2836 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
memory_suboffsets_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_readonly_get DD imagerel memory_readonly_get
	DD	imagerel memory_readonly_get+64
	DD	imagerel $unwind$memory_readonly_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_readonly_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_readonly_get
_TEXT	SEGMENT
self$ = 48
memory_readonly_get PROC				; COMDAT

; 2840 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2841 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 19		 jne	 SHORT $LN1@memory_rea
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 0f		 jne	 SHORT $LN1@memory_rea

; 2842 :     return PyBool_FromLong(self->view.readonly);

  00017	8b 89 b0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+176]

; 2843 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN1@memory_rea:

; 2841 :     CHECK_RELEASED(self);

  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax

; 2843 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
memory_readonly_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_ndim_get DD imagerel memory_ndim_get
	DD	imagerel memory_ndim_get+64
	DD	imagerel $unwind$memory_ndim_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_ndim_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_ndim_get
_TEXT	SEGMENT
self$ = 48
memory_ndim_get PROC					; COMDAT

; 2847 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2848 :     CHECK_RELEASED(self);

  00004	f6 81 80 00 00
	00 01		 test	 BYTE PTR [rcx+128], 1
  0000b	75 19		 jne	 SHORT $LN1@memory_ndi
  0000d	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00011	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  00015	75 0f		 jne	 SHORT $LN1@memory_ndi

; 2849 :     return PyLong_FromLong(self->view.ndim);

  00017	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]

; 2850 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	e9 00 00 00 00	 jmp	 PyLong_FromLong
$LN1@memory_ndi:

; 2848 :     CHECK_RELEASED(self);

  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax

; 2850 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
memory_ndim_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_c_contiguous DD imagerel memory_c_contiguous
	DD	imagerel memory_c_contiguous+66
	DD	imagerel $unwind$memory_c_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_c_contiguous DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_c_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_c_contiguous PROC				; COMDAT

; 2854 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 2855 :     CHECK_RELEASED(self);

  00007	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  0000d	f6 c1 01	 test	 cl, 1
  00010	75 16		 jne	 SHORT $LN1@memory_c_c
  00012	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00016	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0001a	75 0c		 jne	 SHORT $LN1@memory_c_c

; 2856 :     return PyBool_FromLong(MV_C_CONTIGUOUS(self->flags));

  0001c	83 e1 0a	 and	 ecx, 10

; 2857 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN1@memory_c_c:

; 2855 :     CHECK_RELEASED(self);

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00036	e8 00 00 00 00	 call	 PyErr_SetString
  0003b	33 c0		 xor	 eax, eax

; 2857 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
memory_c_contiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_f_contiguous DD imagerel memory_f_contiguous
	DD	imagerel memory_f_contiguous+66
	DD	imagerel $unwind$memory_f_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_f_contiguous DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_f_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_f_contiguous PROC				; COMDAT

; 2861 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 2862 :     CHECK_RELEASED(self);

  00007	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  0000d	f6 c1 01	 test	 cl, 1
  00010	75 16		 jne	 SHORT $LN1@memory_f_c
  00012	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00016	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0001a	75 0c		 jne	 SHORT $LN1@memory_f_c

; 2863 :     return PyBool_FromLong(MV_F_CONTIGUOUS(self->flags));

  0001c	83 e1 0c	 and	 ecx, 12

; 2864 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN1@memory_f_c:

; 2862 :     CHECK_RELEASED(self);

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00036	e8 00 00 00 00	 call	 PyErr_SetString
  0003b	33 c0		 xor	 eax, eax

; 2864 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
memory_f_contiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memory_contiguous DD imagerel memory_contiguous
	DD	imagerel memory_contiguous+66
	DD	imagerel $unwind$memory_contiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memory_contiguous DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT memory_contiguous
_TEXT	SEGMENT
self$ = 48
dummy$ = 56
memory_contiguous PROC					; COMDAT

; 2868 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 2869 :     CHECK_RELEASED(self);

  00007	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  0000d	f6 c1 01	 test	 cl, 1
  00010	75 16		 jne	 SHORT $LN1@memory_con
  00012	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00016	f6 40 60 01	 test	 BYTE PTR [rax+96], 1
  0001a	75 0c		 jne	 SHORT $LN1@memory_con

; 2870 :     return PyBool_FromLong(MV_ANY_CONTIGUOUS(self->flags));

  0001c	83 e1 0e	 and	 ecx, 14

; 2871 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 PyBool_FromLong
$LN1@memory_con:

; 2869 :     CHECK_RELEASED(self);

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@LMBENOGI@operation?5forbidden?5on?5released?5@
  00036	e8 00 00 00 00	 call	 PyErr_SetString
  0003b	33 c0		 xor	 eax, eax

; 2871 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
memory_contiguous ENDP
_TEXT	ENDS
END
