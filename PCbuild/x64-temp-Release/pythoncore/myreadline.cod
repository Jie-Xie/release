; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	PyOS_InputHook
_DATA	SEGMENT
COMM	PyOS_ReadlineFunctionPointer:QWORD
COMM	_PyOS_ReadlineTState:QWORD
_DATA	ENDS
_BSS	SEGMENT
_PyOS_ReadlineLock DQ 01H DUP (?)
PyOS_InputHook DQ 01H DUP (?)
_BSS	ENDS
EXTRN	PyOS_InterruptOccurred:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyErr_CheckSignals:PROC
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	_PyOS_SigintEvent:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_fgets:PROC
EXTRN	_PyVerify_fd:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp_clearerr:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\myreadline.c
pdata	SEGMENT
$pdata$my_fgets DD imagerel my_fgets
	DD	imagerel my_fgets+305
	DD	imagerel $unwind$my_fgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$my_fgets DD 0a1d01H
	DD	09741dH
	DD	083413H
	DD	0a540eH
	DD	0d00a320eH
	DD	06006c008H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT my_fgets
_TEXT	SEGMENT
buf$ = 64
len$ = 72
fp$ = 80
my_fgets PROC						; COMDAT

; 37   : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00013	49 8b f0	 mov	 rsi, r8
  00016	8b ea		 mov	 ebp, edx
  00018	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0001d	4c 8b e1	 mov	 r12, rcx
  00020	45 33 ed	 xor	 r13d, r13d
$LL15@my_fgets:

; 38   : #ifdef MS_WINDOWS
; 39   :     HANDLE hInterruptEvent;
; 40   : #endif
; 41   :     char *p;
; 42   :     int err;
; 43   :     while (1) {
; 44   :         if (PyOS_InputHook != NULL)

  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyOS_InputHook
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 02		 je	 SHORT $LN13@my_fgets

; 45   :             (void)(PyOS_InputHook)();

  0002f	ff d0		 call	 rax
$LN13@my_fgets:

; 46   :         errno = 0;

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 47   :         clearerr(fp);

  00037	48 8b ce	 mov	 rcx, rsi
  0003a	44 89 28	 mov	 DWORD PTR [rax], r13d
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clearerr

; 48   :         if (_PyVerify_fd(fileno(fp)))

  00043	48 8b ce	 mov	 rcx, rsi
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 _PyVerify_fd
  00053	85 c0		 test	 eax, eax
  00055	74 13		 je	 SHORT $LN22@my_fgets

; 49   :             p = fgets(buf, len, fp);

  00057	4c 8b c6	 mov	 r8, rsi
  0005a	8b d5		 mov	 edx, ebp
  0005c	49 8b cc	 mov	 rcx, r12
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets

; 50   :         else
; 51   :             p = NULL;
; 52   :         if (p != NULL)

  00065	48 85 c0	 test	 rax, rax
  00068	75 6d		 jne	 SHORT $LN19@my_fgets
$LN22@my_fgets:

; 54   :         err = errno;

  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00070	8b 18		 mov	 ebx, DWORD PTR [rax]

; 55   : #ifdef MS_WINDOWS
; 56   :         /* Ctrl-C anywhere on the line or Ctrl-Z if the only character
; 57   :            on a line will set ERROR_OPERATION_ABORTED. Under normal
; 58   :            circumstances Ctrl-C will also have caused the SIGINT handler
; 59   :            to fire which will have set the event object returned by
; 60   :            _PyOS_SigintEvent. This signal fires in another thread and
; 61   :            is not guaranteed to have occurred before this point in the
; 62   :            code.
; 63   : 
; 64   :            Therefore: check whether the event is set with a small timeout.
; 65   :            If it is, assume this is a Ctrl-C and reset the event. If it
; 66   :            isn't set assume that this is a Ctrl-Z on its own and drop
; 67   :            through to check for EOF.
; 68   :         */
; 69   :         if (GetLastError()==ERROR_OPERATION_ABORTED) {

  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00078	3d e3 03 00 00	 cmp	 eax, 995		; 000003e3H
  0007d	75 1f		 jne	 SHORT $LN7@my_fgets

; 70   :             hInterruptEvent = _PyOS_SigintEvent();

  0007f	e8 00 00 00 00	 call	 _PyOS_SigintEvent

; 71   :             switch (WaitForSingleObject(hInterruptEvent, 10)) {

  00084	ba 0a 00 00 00	 mov	 edx, 10
  00089	48 8b c8	 mov	 rcx, rax
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00095	85 c0		 test	 eax, eax
  00097	74 49		 je	 SHORT $LN6@my_fgets
  00099	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0009c	74 3d		 je	 SHORT $LN5@my_fgets
$LN7@my_fgets:

; 77   :             }
; 78   :         }
; 79   : #endif /* MS_WINDOWS */
; 80   :         if (feof(fp)) {

  0009e	48 8b ce	 mov	 rcx, rsi
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  000a7	85 c0		 test	 eax, eax
  000a9	75 61		 jne	 SHORT $LN20@my_fgets

; 83   :         }
; 84   : #ifdef EINTR
; 85   :         if (err == EINTR) {

  000ab	83 fb 04	 cmp	 ebx, 4
  000ae	75 42		 jne	 SHORT $LN3@my_fgets

; 86   :             int s;
; 87   : #ifdef WITH_THREAD
; 88   :             PyEval_RestoreThread(_PyOS_ReadlineTState);

  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineTState
  000b7	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 89   : #endif
; 90   :             s = PyErr_CheckSignals();

  000bc	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000c1	8b d8		 mov	 ebx, eax

; 91   : #ifdef WITH_THREAD
; 92   :             PyEval_SaveThread();

  000c3	e8 00 00 00 00	 call	 PyEval_SaveThread

; 93   : #endif
; 94   :             if (s < 0)

  000c8	85 db		 test	 ebx, ebx
  000ca	0f 89 53 ff ff
	ff		 jns	 $LL15@my_fgets

; 74   :                 return 1; /* Interrupt */

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	eb 41		 jmp	 SHORT $LN1@my_fgets
$LN19@my_fgets:

; 53   :             return 0; /* No error */

  000d7	33 c0		 xor	 eax, eax
  000d9	eb 3d		 jmp	 SHORT $LN1@my_fgets
$LN5@my_fgets:

; 75   :             case WAIT_FAILED:
; 76   :                 return -2; /* Error */

  000db	b8 fe ff ff ff	 mov	 eax, -2
  000e0	eb 36		 jmp	 SHORT $LN1@my_fgets
$LN6@my_fgets:

; 72   :             case WAIT_OBJECT_0:
; 73   :                 ResetEvent(hInterruptEvent);

  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 74   :                 return 1; /* Interrupt */

  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	eb 26		 jmp	 SHORT $LN1@my_fgets
$LN3@my_fgets:

; 95   :                     return 1;
; 96   :         /* try again */
; 97   :             continue;
; 98   :         }
; 99   : #endif
; 100  :         if (PyOS_InterruptOccurred()) {

  000f2	e8 00 00 00 00	 call	 PyOS_InterruptOccurred
  000f7	b9 fe ff ff ff	 mov	 ecx, -2
  000fc	41 bb 01 00 00
	00		 mov	 r11d, 1
  00102	85 c0		 test	 eax, eax
  00104	41 0f 45 cb	 cmovne	 ecx, r11d
  00108	8b c1		 mov	 eax, ecx
  0010a	eb 0c		 jmp	 SHORT $LN1@my_fgets
$LN20@my_fgets:

; 81   :             clearerr(fp);

  0010c	48 8b ce	 mov	 rcx, rsi
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clearerr

; 82   :             return -1; /* EOF */

  00115	83 c8 ff	 or	 eax, -1
$LN1@my_fgets:

; 101  :             return 1; /* Interrupt */
; 102  :         }
; 103  :         return -2; /* Error */
; 104  :     }
; 105  :     /* NOTREACHED */
; 106  : }

  00118	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0011d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00122	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00127	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012b	41 5d		 pop	 r13
  0012d	41 5c		 pop	 r12
  0012f	5e		 pop	 rsi
  00130	c3		 ret	 0
my_fgets ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	PyOS_StdioReadline
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp_realloc:PROC
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_StdioReadline DD imagerel $LN53
	DD	imagerel $LN53+150
	DD	imagerel $unwind$PyOS_StdioReadline
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyOS_StdioReadline DD imagerel $LN53+150
	DD	imagerel $LN53+259
	DD	imagerel $chain$2$PyOS_StdioReadline
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyOS_StdioReadline DD imagerel $LN53+259
	DD	imagerel $LN53+314
	DD	imagerel $chain$3$PyOS_StdioReadline
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyOS_StdioReadline DD imagerel $LN53+314
	DD	imagerel $LN53+562
	DD	imagerel $chain$4$PyOS_StdioReadline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyOS_StdioReadline DD 060021H
	DD	0ae400H
	DD	09c400H
	DD	085400H
	DD	imagerel $LN53
	DD	imagerel $LN53+150
	DD	imagerel $unwind$PyOS_StdioReadline
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyOS_StdioReadline DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+150
	DD	imagerel $unwind$PyOS_StdioReadline
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyOS_StdioReadline DD 061221H
	DD	0ae412H
	DD	09c40aH
	DD	085405H
	DD	imagerel $LN53
	DD	imagerel $LN53+150
	DD	imagerel $unwind$PyOS_StdioReadline
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_StdioReadline DD 060d01H
	DD	0b340dH
	DD	0d009320dH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@ DB 'input line too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyOS_StdioReadline
_TEXT	SEGMENT
sys_stdin$ = 64
sys_stdout$ = 72
prompt$ = 80
PyOS_StdioReadline PROC					; COMDAT

; 113  : {

$LN53:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000d	49 8b f8	 mov	 rdi, r8
  00010	48 8b f2	 mov	 rsi, rdx
  00013	4c 8b e9	 mov	 r13, rcx

; 114  :     size_t n;
; 115  :     char *p, *pr;
; 116  :     n = 100;
; 117  :     if ((p = (char *)PyMem_MALLOC(n)) == NULL)

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00020	85 c0		 test	 eax, eax
  00022	74 07		 je	 SHORT $LN16@PyOS_Stdio
  00024	e8 00 00 00 00	 call	 _PxMem_Malloc
  00029	eb 06		 jmp	 SHORT $LN51@PyOS_Stdio
$LN16@PyOS_Stdio:
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN51@PyOS_Stdio:
  00031	48 8b d8	 mov	 rbx, rax
  00034	48 85 c0	 test	 rax, rax

; 118  :         return NULL;

  00037	0f 84 ed 00 00
	00		 je	 $LN21@PyOS_Stdio

; 119  :     fflush(sys_stdout);

  0003d	48 8b ce	 mov	 rcx, rsi
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 120  :     if (prompt)

  00046	48 85 ff	 test	 rdi, rdi
  00049	74 1a		 je	 SHORT $LN12@PyOS_Stdio

; 121  :         fprintf(stderr, "%s", prompt);

  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00058	4c 8b c7	 mov	 r8, rdi
  0005b	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN12@PyOS_Stdio:

; 122  :     fflush(stderr);

  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0006b	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 123  :     switch (my_fgets(p, (int)n, sys_stdin)) {

  00075	4d 8b c5	 mov	 r8, r13
  00078	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0007d	48 8b cb	 mov	 rcx, rbx
  00080	e8 00 00 00 00	 call	 my_fgets
  00085	85 c0		 test	 eax, eax
  00087	74 07		 je	 SHORT $LN9@PyOS_Stdio
  00089	ff c8		 dec	 eax
  0008b	74 76		 je	 SHORT $LN8@PyOS_Stdio

; 129  :     case -1: /* EOF */
; 130  :     case -2: /* Error */
; 131  :     default: /* Shouldn't happen */
; 132  :         *p = '\0';

  0008d	c6 03 00	 mov	 BYTE PTR [rbx], 0
$LN9@PyOS_Stdio:

; 133  :         break;
; 134  :     }
; 135  :     n = strlen(p);

  00090	33 c0		 xor	 eax, eax
  00092	48 83 c9 ff	 or	 rcx, -1
  00096	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0009b	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  000a0	48 8b fb	 mov	 rdi, rbx
  000a3	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  000a8	f2 ae		 repne scasb
  000aa	49 be ff ff ff
	ff ff ff ff 7f	 mov	 r14, 9223372036854775807 ; 7fffffffffffffffH
  000b4	44 8d 60 01	 lea	 r12d, QWORD PTR [rax+1]
  000b8	48 f7 d1	 not	 rcx
  000bb	48 ff c9	 dec	 rcx
  000be	48 8b f1	 mov	 rsi, rcx

; 136  :     while (n > 0 && p[n-1] != '\n') {

  000c1	0f 84 ce 00 00
	00		 je	 $LN43@PyOS_Stdio
  000c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@PyOS_Stdio:
  000d0	80 7c 33 ff 0a	 cmp	 BYTE PTR [rbx+rsi-1], 10
  000d5	0f 84 ba 00 00
	00		 je	 $LN43@PyOS_Stdio

; 137  :         size_t incr = n+2;

  000db	48 8d 7e 02	 lea	 rdi, QWORD PTR [rsi+2]

; 142  :         }
; 143  :         pr = (char *)PyMem_REALLOC(p, n + incr);

  000df	e8 00 00 00 00	 call	 _Py_PXCTX
  000e4	48 81 ff ff ff
	ff 7f		 cmp	 rdi, 2147483647		; 7fffffffH
  000eb	0f 87 bb 00 00
	00		 ja	 $LN41@PyOS_Stdio
  000f1	85 c0		 test	 eax, eax
  000f3	74 45		 je	 SHORT $LN28@PyOS_Stdio
  000f5	48 8d 14 37	 lea	 rdx, QWORD PTR [rdi+rsi]
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 _PxMem_Realloc
  00101	eb 57		 jmp	 SHORT $LN27@PyOS_Stdio
$LN8@PyOS_Stdio:

; 124  :     case 0: /* Normal case */
; 125  :         break;
; 126  :     case 1: /* Interrupt */
; 127  :         PyMem_FREE(p);

  00103	e8 00 00 00 00	 call	 _Py_PXCTX
  00108	48 8b cb	 mov	 rcx, rbx
  0010b	85 c0		 test	 eax, eax
  0010d	74 15		 je	 SHORT $LN20@PyOS_Stdio
  0010f	e8 00 00 00 00	 call	 _PxMem_Free

; 128  :         return NULL;

  00114	33 c0		 xor	 eax, eax

; 161  : }

  00116	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0011b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011f	41 5d		 pop	 r13
  00121	5f		 pop	 rdi
  00122	5e		 pop	 rsi
  00123	c3		 ret	 0
$LN20@PyOS_Stdio:

; 124  :     case 0: /* Normal case */
; 125  :         break;
; 126  :     case 1: /* Interrupt */
; 127  :         PyMem_FREE(p);

  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN21@PyOS_Stdio:

; 128  :         return NULL;

  0012a	33 c0		 xor	 eax, eax

; 161  : }

  0012c	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00131	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00135	41 5d		 pop	 r13
  00137	5f		 pop	 rdi
  00138	5e		 pop	 rsi
  00139	c3		 ret	 0
$LN28@PyOS_Stdio:

; 142  :         }
; 143  :         pr = (char *)PyMem_REALLOC(p, n + incr);

  0013a	48 8d 04 37	 lea	 rax, QWORD PTR [rdi+rsi]
  0013e	49 3b c6	 cmp	 rax, r14
  00141	0f 87 ae 00 00
	00		 ja	 $LN45@PyOS_Stdio
  00147	48 85 c0	 test	 rax, rax
  0014a	49 8b d4	 mov	 rdx, r12
  0014d	48 8b cb	 mov	 rcx, rbx
  00150	48 0f 45 d0	 cmovne	 rdx, rax
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN27@PyOS_Stdio:

; 144  :         if (pr == NULL) {

  0015a	48 85 c0	 test	 rax, rax
  0015d	0f 84 92 00 00
	00		 je	 $LN45@PyOS_Stdio

; 145  :             PyMem_FREE(p);
; 146  :             PyErr_NoMemory();
; 147  :             return NULL;
; 148  :         }
; 149  :         p = pr;
; 150  :         if (my_fgets(p+n, (int)incr, sys_stdin) != 0)

  00163	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
  00167	4d 8b c5	 mov	 r8, r13
  0016a	8b d7		 mov	 edx, edi
  0016c	48 8b cd	 mov	 rcx, rbp
  0016f	48 8b d8	 mov	 rbx, rax
  00172	e8 00 00 00 00	 call	 my_fgets
  00177	85 c0		 test	 eax, eax
  00179	75 1a		 jne	 SHORT $LN43@PyOS_Stdio

; 151  :             break;
; 152  :         n += strlen(p+n);

  0017b	48 83 c9 ff	 or	 rcx, -1
  0017f	33 c0		 xor	 eax, eax
  00181	48 8b fd	 mov	 rdi, rbp
  00184	f2 ae		 repne scasb
  00186	48 f7 d1	 not	 rcx
  00189	48 ff c9	 dec	 rcx
  0018c	48 03 f1	 add	 rsi, rcx
  0018f	0f 85 3b ff ff
	ff		 jne	 $LL6@PyOS_Stdio
$LN43@PyOS_Stdio:

; 153  :     }
; 154  :     pr = (char *)PyMem_REALLOC(p, n+1);

  00195	e8 00 00 00 00	 call	 _Py_PXCTX
  0019a	85 c0		 test	 eax, eax
  0019c	74 37		 je	 SHORT $LN36@PyOS_Stdio
  0019e	48 8d 56 01	 lea	 rdx, QWORD PTR [rsi+1]
  001a2	48 8b cb	 mov	 rcx, rbx
  001a5	e8 00 00 00 00	 call	 _PxMem_Realloc
  001aa	eb 44		 jmp	 SHORT $LN35@PyOS_Stdio
$LN41@PyOS_Stdio:

; 138  :         if (incr > INT_MAX) {
; 139  :             PyMem_FREE(p);

  001ac	48 8b cb	 mov	 rcx, rbx
  001af	85 c0		 test	 eax, eax
  001b1	74 07		 je	 SHORT $LN22@PyOS_Stdio
  001b3	e8 00 00 00 00	 call	 _PxMem_Free
  001b8	eb 06		 jmp	 SHORT $LN23@PyOS_Stdio
$LN22@PyOS_Stdio:
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@PyOS_Stdio:

; 140  :             PyErr_SetString(PyExc_OverflowError, "input line too long");

  001c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@
  001ce	e8 00 00 00 00	 call	 PyErr_SetString

; 141  :             return NULL;

  001d3	eb 3e		 jmp	 SHORT $LN52@PyOS_Stdio
$LN36@PyOS_Stdio:

; 153  :     }
; 154  :     pr = (char *)PyMem_REALLOC(p, n+1);

  001d5	48 ff c6	 inc	 rsi
  001d8	49 3b f6	 cmp	 rsi, r14
  001db	77 18		 ja	 SHORT $LN45@PyOS_Stdio
  001dd	48 85 f6	 test	 rsi, rsi
  001e0	48 8b cb	 mov	 rcx, rbx
  001e3	4c 0f 45 e6	 cmovne	 r12, rsi
  001e7	49 8b d4	 mov	 rdx, r12
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
$LN35@PyOS_Stdio:

; 155  :     if (pr == NULL) {

  001f0	48 85 c0	 test	 rax, rax

; 159  :     }
; 160  :     return pr;

  001f3	75 20		 jne	 SHORT $LN50@PyOS_Stdio
$LN45@PyOS_Stdio:

; 156  :         PyMem_FREE(p);

  001f5	e8 00 00 00 00	 call	 _Py_PXCTX
  001fa	48 8b cb	 mov	 rcx, rbx
  001fd	85 c0		 test	 eax, eax
  001ff	74 07		 je	 SHORT $LN30@PyOS_Stdio
  00201	e8 00 00 00 00	 call	 _PxMem_Free
  00206	eb 06		 jmp	 SHORT $LN39@PyOS_Stdio
$LN30@PyOS_Stdio:
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN39@PyOS_Stdio:

; 157  :         PyErr_NoMemory();

  0020e	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN52@PyOS_Stdio:

; 158  :         return NULL;

  00213	33 c0		 xor	 eax, eax
$LN50@PyOS_Stdio:
  00215	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  0021a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0021f	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]

; 161  : }

  00224	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00229	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0022d	41 5d		 pop	 r13
  0022f	5f		 pop	 rdi
  00230	5e		 pop	 rsi
  00231	c3		 ret	 0
PyOS_StdioReadline ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@ ; `string'
PUBLIC	PyOS_Readline
EXTRN	PyThread_release_lock:PROC
EXTRN	__imp_isatty:PROC
EXTRN	PyThread_acquire_lock:PROC
EXTRN	PyThread_allocate_lock:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_Readline DD imagerel $LN15
	DD	imagerel $LN15+308
	DD	imagerel $unwind$PyOS_Readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_Readline DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@
CONST	SEGMENT
??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@ DB 'can''t re-enter r'
	DB	'eadline', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyOS_Readline
_TEXT	SEGMENT
sys_stdin$ = 48
sys_stdout$ = 56
prompt$ = 64
PyOS_Readline PROC					; COMDAT

; 176  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	48 8b da	 mov	 rbx, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 177  :     char *rv;
; 178  : 
; 179  :     if (_PyOS_ReadlineTState == PyThreadState_GET()) {

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 07		 je	 SHORT $LN9@PyOS_Readl
  00021	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00026	eb 07		 jmp	 SHORT $LN10@PyOS_Readl
$LN9@PyOS_Readl:
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN10@PyOS_Readl:
  0002f	48 39 05 00 00
	00 00		 cmp	 QWORD PTR _PyOS_ReadlineTState, rax
  00036	75 25		 jne	 SHORT $LN6@PyOS_Readl

; 180  :         PyErr_SetString(PyExc_RuntimeError,
; 181  :                         "can't re-enter readline");

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@
  00046	e8 00 00 00 00	 call	 PyErr_SetString

; 182  :         return NULL;

  0004b	33 c0		 xor	 eax, eax

; 224  : #endif
; 225  : 
; 226  :     _PyOS_ReadlineTState = NULL;
; 227  : 
; 228  :     return rv;
; 229  : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
$LN6@PyOS_Readl:

; 183  :     }
; 184  : 
; 185  : 
; 186  :     if (PyOS_ReadlineFunctionPointer == NULL) {

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyOS_ReadlineFunctionPointer
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyOS_StdioReadline
  0006b	48 85 c0	 test	 rax, rax
  0006e	48 0f 44 c1	 cmove	 rax, rcx

; 187  : #ifdef __VMS
; 188  :         PyOS_ReadlineFunctionPointer = vms__StdioReadline;
; 189  : #else
; 190  :         PyOS_ReadlineFunctionPointer = PyOS_StdioReadline;
; 191  : #endif
; 192  :     }
; 193  : 
; 194  : #ifdef WITH_THREAD
; 195  :     if (_PyOS_ReadlineLock == NULL) {

  00072	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyOS_ReadlineLock, 0
  0007a	48 89 05 00 00
	00 00		 mov	 QWORD PTR PyOS_ReadlineFunctionPointer, rax
  00081	75 0c		 jne	 SHORT $LN4@PyOS_Readl

; 196  :         _PyOS_ReadlineLock = PyThread_allocate_lock();

  00083	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00088	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyOS_ReadlineLock, rax
$LN4@PyOS_Readl:

; 197  :     }
; 198  : #endif
; 199  : 
; 200  :     _PyOS_ReadlineTState = PyThreadState_GET();

  0008f	e8 00 00 00 00	 call	 _Py_PXCTX
  00094	85 c0		 test	 eax, eax
  00096	74 07		 je	 SHORT $LN11@PyOS_Readl
  00098	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0009d	eb 07		 jmp	 SHORT $LN13@PyOS_Readl
$LN11@PyOS_Readl:
  0009f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN13@PyOS_Readl:

; 201  :     /*
; 202  :     Py_BEGIN_ALLOW_THREADS
; 203  :     */
; 204  : #ifdef WITH_THREAD
; 205  :     PyThread_acquire_lock(_PyOS_ReadlineLock, 1);

  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineLock
  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyOS_ReadlineTState, rax
  000b9	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 206  : #endif
; 207  : 
; 208  :     /* This is needed to handle the unlikely case that the
; 209  :      * interpreter is in interactive mode *and* stdin/out are not
; 210  :      * a tty.  This can happen, for example if python is run like
; 211  :      * this: python -i < test1.py
; 212  :      */
; 213  :     if (!isatty (fileno (sys_stdin)) || !isatty (fileno (sys_stdout)))

  000be	48 8b cf	 mov	 rcx, rdi
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000c7	8b c8		 mov	 ecx, eax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  000cf	85 c0		 test	 eax, eax
  000d1	74 26		 je	 SHORT $LN2@PyOS_Readl
  000d3	48 8b cb	 mov	 rcx, rbx
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000dc	8b c8		 mov	 ecx, eax
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  000e4	85 c0		 test	 eax, eax
  000e6	74 11		 je	 SHORT $LN2@PyOS_Readl

; 215  :     else
; 216  :         rv = (*PyOS_ReadlineFunctionPointer)(sys_stdin, sys_stdout,
; 217  :                                              prompt);

  000e8	4c 8b c6	 mov	 r8, rsi
  000eb	48 8b d3	 mov	 rdx, rbx
  000ee	48 8b cf	 mov	 rcx, rdi
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR PyOS_ReadlineFunctionPointer
  000f7	eb 0e		 jmp	 SHORT $LN14@PyOS_Readl
$LN2@PyOS_Readl:

; 214  :         rv = PyOS_StdioReadline (sys_stdin, sys_stdout, prompt);

  000f9	4c 8b c6	 mov	 r8, rsi
  000fc	48 8b d3	 mov	 rdx, rbx
  000ff	48 8b cf	 mov	 rcx, rdi
  00102	e8 00 00 00 00	 call	 PyOS_StdioReadline
$LN14@PyOS_Readl:

; 218  :     /*
; 219  :     Py_END_ALLOW_THREADS
; 220  :     */
; 221  : 
; 222  : #ifdef WITH_THREAD
; 223  :     PyThread_release_lock(_PyOS_ReadlineLock);

  00107	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineLock
  0010e	48 8b d8	 mov	 rbx, rax
  00111	e8 00 00 00 00	 call	 PyThread_release_lock

; 224  : #endif
; 225  : 
; 226  :     _PyOS_ReadlineTState = NULL;
; 227  : 
; 228  :     return rv;
; 229  : }

  00116	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0011b	48 8b c3	 mov	 rax, rbx
  0011e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00123	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR _PyOS_ReadlineTState, 0
  0012e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
PyOS_Readline ENDP
_TEXT	ENDS
END
