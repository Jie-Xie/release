; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BE@BBIKIFCE@default_int_handler?$AA@	; `string'
PUBLIC	??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@		; `string'
PUBLIC	??_C@_09JDGNOJPE@getsignal?$AA@			; `string'
PUBLIC	??_C@_06OAFOBKHE@signal?$AA@			; `string'
_BSS	SEGMENT
is_tripped DD	01H DUP (?)
	ALIGN	8

old_siginthandler DQ 01H DUP (?)
sigint_event DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
CONST	SEGMENT
??_C@_0BE@BBIKIFCE@default_int_handler?$AA@ DB 'default_int_handler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@
CONST	SEGMENT
??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@ DB 'set_wakeup_fd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09JDGNOJPE@getsignal?$AA@
CONST	SEGMENT
??_C@_09JDGNOJPE@getsignal?$AA@ DB 'getsignal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAFOBKHE@signal?$AA@
CONST	SEGMENT
??_C@_06OAFOBKHE@signal?$AA@ DB 'signal', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
wakeup_fd DD	0ffffffffH
	ORG $+12
default_int_handler_doc DB 'default_int_handler(...)', 0aH, 0aH, 'The def'
	DB	'ault handler for SIGINT installed by Python.', 0aH, 'It raise'
	DB	's KeyboardInterrupt.', 00H
	ORG $+5
signal_doc DB	'signal(sig, action) -> action', 0aH, 0aH, 'Set the actio'
	DB	'n for the given signal.  The action can be SIG_DFL,', 0aH, 'S'
	DB	'IG_IGN, or a callable Python object.  The previous action is', 0aH
	DB	'returned.  See getsignal() for possible return values.', 0aH, 0aH
	DB	'*** IMPORTANT NOTICE ***', 0aH, 'A signal handler function is'
	DB	' called with two arguments:', 0aH, 'the first is the signal n'
	DB	'umber, the second is the interrupted stack frame.', 00H
	ORG $+14
getsignal_doc DB 'getsignal(sig) -> action', 0aH, 0aH, 'Return the curren'
	DB	't action for the given signal.  The return value can be:', 0aH
	DB	'SIG_IGN -- if the signal is being ignored', 0aH, 'SIG_DFL -- '
	DB	'if the default action for the signal is in effect', 0aH, 'Non'
	DB	'e -- if an unknown handler is in effect', 0aH, 'anything else'
	DB	' -- the callable Python object used as a handler', 00H
	ORG $+12
set_wakeup_fd_doc DB 'set_wakeup_fd(fd) -> fd', 0aH, 0aH, 'Sets the fd to'
	DB	' be written to (with ''\0'') when a signal', 0aH, 'comes in. '
	DB	' A library can use this to wakeup select or poll.', 0aH, 'The'
	DB	' previous fd is returned.', 0aH, 0aH, 'The fd must be non-blo'
	DB	'cking.', 00H
	ORG $+9
signal_methods DQ FLAT:??_C@_06OAFOBKHE@signal?$AA@
	DQ	FLAT:signal_signal
	DD	01H
	ORG $+4
	DQ	FLAT:signal_doc
	DQ	FLAT:??_C@_09JDGNOJPE@getsignal?$AA@
	DQ	FLAT:signal_getsignal
	DD	01H
	ORG $+4
	DQ	FLAT:getsignal_doc
	DQ	FLAT:??_C@_0O@BAIGEEFD@set_wakeup_fd?$AA@
	DQ	FLAT:signal_set_wakeup_fd
	DD	01H
	ORG $+4
	DQ	FLAT:set_wakeup_fd_doc
	DQ	FLAT:??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
	DQ	FLAT:signal_default_int_handler
	DD	01H
	ORG $+4
	DQ	FLAT:default_int_handler_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'This module provides mechanisms to use signal handlers i'
	DB	'n Python.', 0aH, 0aH, 'Functions:', 0aH, 0aH, 'alarm() -- cau'
	DB	'se SIGALRM after a specified time [Unix only]', 0aH, 'setitim'
	DB	'er() -- cause a signal (described below) after a specified', 0aH
	DB	'               float time and the timer may restart then [Uni'
	DB	'x only]', 0aH, 'getitimer() -- get current value of timer [Un'
	DB	'ix only]', 0aH, 'signal() -- set the action for a given signa'
	DB	'l', 0aH, 'getsignal() -- get the signal action for a given si'
	DB	'gnal', 0aH, 'pause() -- wait until a signal arrives [Unix onl'
	DB	'y]', 0aH, 'default_int_handler() -- default SIGINT handler', 0aH
	DB	0aH, 'signal constants:', 0aH, 'SIG_DFL -- used to refer to th'
	DB	'e system default handler', 0aH, 'SIG_IGN -- used to ignore th'
	DB	'e signal', 0aH, 'NSIG -- number of defined signals', 0aH, 'SI'
	DB	'GINT, SIGTERM, etc. -- signal numbers', 0aH, 0aH, 'itimer con'
	DB	'stants:', 0aH, 'ITIMER_REAL -- decrements in real time, and d'
	DB	'elivers SIGALRM upon', 0aH, '               expiration', 0aH, 'I'
	DB	'TIMER_VIRTUAL -- decrements only when the process is executin'
	DB	'g,', 0aH, '               and delivers SIGVTALRM upon expirat'
	DB	'ion', 0aH, 'ITIMER_PROF -- decrements both when the process i'
	DB	's executing and', 0aH, '               when the system is exe'
	DB	'cuting on behalf of the process.', 0aH, '               Coupl'
	DB	'ed with ITIMER_VIRTUAL, this timer is usually', 0aH, '       '
	DB	'        used to profile the time spent by the application', 0aH
	DB	'               in user and kernel space. SIGPROF is delivered'
	DB	' upon', 0aH, '               expiration.', 0aH, 0aH, 0aH, '**'
	DB	'* IMPORTANT NOTICE ***', 0aH, 'A signal handler function is c'
	DB	'alled with two arguments:', 0aH, 'the first is the signal num'
	DB	'ber, the second is the interrupted stack frame.', 00H
	ORG $+10
signalmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06OAFOBKHE@signal?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:signal_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	__imp__fstat64i32:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 8
_Stat$ = 16
fstat	PROC						; COMDAT

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
; 55   : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__fstat64i32
fstat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyErr_SetNone:PROC
EXTRN	PyExc_KeyboardInterrupt:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\signalmodule.c
pdata	SEGMENT
$pdata$signal_default_int_handler DD imagerel signal_default_int_handler
	DD	imagerel signal_default_int_handler+23
	DD	imagerel $unwind$signal_default_int_handler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_default_int_handler DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT signal_default_int_handler
_TEXT	SEGMENT
self$ = 48
args$ = 56
signal_default_int_handler PROC				; COMDAT

; 165  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 166  :     PyErr_SetNone(PyExc_KeyboardInterrupt);

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyboardInterrupt
  0000b	e8 00 00 00 00	 call	 PyErr_SetNone

; 167  :     return NULL;

  00010	33 c0		 xor	 eax, eax

; 168  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
signal_default_int_handler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0M@HEAMACOM@i?3getsignal?$AA@		; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyArg_ParseTuple:PROC
_BSS	SEGMENT
Handlers DB	0170H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_getsignal DD imagerel signal_getsignal
	DD	imagerel signal_getsignal+41
	DD	imagerel $unwind$signal_getsignal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$signal_getsignal DD imagerel signal_getsignal+41
	DD	imagerel signal_getsignal+89
	DD	imagerel $chain$0$signal_getsignal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$signal_getsignal DD imagerel signal_getsignal+89
	DD	imagerel signal_getsignal+118
	DD	imagerel $chain$2$signal_getsignal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$signal_getsignal DD imagerel signal_getsignal+118
	DD	imagerel signal_getsignal+144
	DD	imagerel $chain$3$signal_getsignal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$signal_getsignal DD 021H
	DD	imagerel signal_getsignal
	DD	imagerel signal_getsignal+41
	DD	imagerel $unwind$signal_getsignal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$signal_getsignal DD 020021H
	DD	043400H
	DD	imagerel signal_getsignal
	DD	imagerel signal_getsignal+41
	DD	imagerel $unwind$signal_getsignal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$signal_getsignal DD 020521H
	DD	043405H
	DD	imagerel signal_getsignal
	DD	imagerel signal_getsignal+41
	DD	imagerel $unwind$signal_getsignal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_getsignal DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@ DB 'signal number '
	DB	'out of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HEAMACOM@i?3getsignal?$AA@
CONST	SEGMENT
??_C@_0M@HEAMACOM@i?3getsignal?$AA@ DB 'i:getsignal', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT signal_getsignal
_TEXT	SEGMENT
self$ = 48
args$ = 56
sig_num$ = 64
signal_getsignal PROC					; COMDAT

; 367  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 368  :     int sig_num;
; 369  :     PyObject *old_handler;
; 370  :     if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR sig_num$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@HEAMACOM@i?3getsignal?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax

; 371  :         return NULL;

  0001a	74 6d		 je	 SHORT $LN9@signal_get

; 372  :     if (sig_num < 1 || sig_num >= NSIG) {

  0001c	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sig_num$[rsp]
  00021	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00024	83 f8 15	 cmp	 eax, 21
  00027	77 4d		 ja	 SHORT $LN3@signal_get

; 376  :     }
; 377  :     old_handler = Handlers[sig_num].func;

  00029	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002e	48 8b c1	 mov	 rax, rcx
  00031	48 8d 1d 08 00
	00 00		 lea	 rbx, OFFSET FLAT:Handlers+8
  00038	48 03 c0	 add	 rax, rax
  0003b	48 8b 1c c3	 mov	 rbx, QWORD PTR [rbx+rax*8]

; 378  :     if (old_handler != NULL) {

  0003f	48 85 db	 test	 rbx, rbx
  00042	74 15		 je	 SHORT $LN2@signal_get

; 379  :         Py_INCREF(old_handler);

  00044	48 8b cb	 mov	 rcx, rbx
  00047	e8 00 00 00 00	 call	 _Py_IncRef

; 380  :         return old_handler;

  0004c	48 8b c3	 mov	 rax, rbx
  0004f	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 384  :     }
; 385  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
$LN2@signal_get:

; 381  :     }
; 382  :     else {
; 383  :         Py_RETURN_NONE;

  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00060	e8 00 00 00 00	 call	 _Py_IncRef
  00065	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 384  :     }
; 385  : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
$LN3@signal_get:

; 373  :         PyErr_SetString(PyExc_ValueError,
; 374  :                         "signal number out of range");

  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
  00084	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@signal_get:

; 375  :         return NULL;

  00089	33 c0		 xor	 eax, eax

; 384  :     }
; 385  : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
signal_getsignal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NJBNHJG@invalid?5fd?$AA@		; `string'
PUBLIC	??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@ ; `string'
PUBLIC	??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	_PyVerify_fd:PROC
EXTRN	PyThread_get_thread_ident:PROC
_BSS	SEGMENT
main_thread DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$signal_set_wakeup_fd DD imagerel signal_set_wakeup_fd
	DD	imagerel signal_set_wakeup_fd+156
	DD	imagerel $unwind$signal_set_wakeup_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_set_wakeup_fd DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0L@NJBNHJG@invalid?5fd?$AA@
CONST	SEGMENT
??_C@_0L@NJBNHJG@invalid?5fd?$AA@ DB 'invalid fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@
CONST	SEGMENT
??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@ DB 'set_wakeup_f'
	DB	'd only works in main thread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@
CONST	SEGMENT
??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@ DB 'i:set_wakeup_fd', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\signalmodule.c
CONST	ENDS
;	COMDAT signal_set_wakeup_fd
_TEXT	SEGMENT
buf$ = 32
self$ = 96
args$ = 104
fd$ = 112
signal_set_wakeup_fd PROC				; COMDAT

; 429  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 430  :     struct stat buf;
; 431  :     int fd, old_fd;
; 432  :     if (!PyArg_ParseTuple(args, "i:set_wakeup_fd", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 70	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GCBECJFP@i?3set_wakeup_fd?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax

; 433  :         return NULL;

  0001a	74 20		 je	 SHORT $LN9@signal_set

; 434  : #ifdef WITH_THREAD
; 435  :     if (PyThread_get_thread_ident() != main_thread) {

  0001c	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00021	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00027	74 1a		 je	 SHORT $LN3@signal_set

; 436  :         PyErr_SetString(PyExc_ValueError,
; 437  :                         "set_wakeup_fd only works in main thread");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NILBGOFJ@set_wakeup_fd?5only?5works?5in?5main@
  00037	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@signal_set:

; 438  :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 448  : }

  0003e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00042	c3		 ret	 0
$LN3@signal_set:

; 439  :     }
; 440  : #endif
; 441  :     if (fd != -1 && (!_PyVerify_fd(fd) || fstat(fd, &buf) != 0)) {

  00043	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00047	83 f9 ff	 cmp	 ecx, -1
  0004a	74 36		 je	 SHORT $LN2@signal_set
  0004c	e8 00 00 00 00	 call	 _PyVerify_fd
  00051	85 c0		 test	 eax, eax
  00053	74 13		 je	 SHORT $LN1@signal_set
  00055	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00059	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32
  00064	85 c0		 test	 eax, eax
  00066	74 1a		 je	 SHORT $LN2@signal_set
$LN1@signal_set:

; 442  :         PyErr_SetString(PyExc_ValueError, "invalid fd");

  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NJBNHJG@invalid?5fd?$AA@
  00076	e8 00 00 00 00	 call	 PyErr_SetString

; 443  :         return NULL;

  0007b	33 c0		 xor	 eax, eax

; 448  : }

  0007d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00081	c3		 ret	 0
$LN2@signal_set:

; 444  :     }
; 445  :     old_fd = wakeup_fd;

  00082	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR wakeup_fd

; 446  :     wakeup_fd = fd;

  00088	8b 44 24 70	 mov	 eax, DWORD PTR fd$[rsp]
  0008c	89 05 00 00 00
	00		 mov	 DWORD PTR wakeup_fd, eax

; 447  :     return PyLong_FromLong(old_fd);

  00092	e8 00 00 00 00	 call	 PyLong_FromLong

; 448  : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
signal_set_wakeup_fd ENDP
_TEXT	ENDS
PUBLIC	PySignal_SetWakeupFd
; Function compile flags: /Ogtpy
;	COMDAT PySignal_SetWakeupFd
_TEXT	SEGMENT
fd$ = 8
PySignal_SetWakeupFd PROC				; COMDAT

; 463  :     int old_fd = wakeup_fd;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR wakeup_fd

; 464  :     if (fd < 0)

  00006	83 ca ff	 or	 edx, -1
  00009	85 c9		 test	 ecx, ecx
  0000b	0f 48 ca	 cmovs	 ecx, edx

; 465  :         fd = -1;
; 466  :     wakeup_fd = fd;

  0000e	89 0d 00 00 00
	00		 mov	 DWORD PTR wakeup_fd, ecx

; 467  :     return old_fd;
; 468  : }

  00014	c3		 ret	 0
PySignal_SetWakeupFd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NICDOGIB@finisignal?$AA@		; `string'
PUBLIC	??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@ ; `string'
EXTRN	PyOS_setsig:PROC
_BSS	SEGMENT
	ALIGN	8

IntHandler DQ	01H DUP (?)
IgnoreHandler DQ 01H DUP (?)
DefaultHandler DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$finisignal DD imagerel finisignal
	DD	imagerel finisignal+791
	DD	imagerel $unwind$finisignal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$finisignal DD 0a1801H
	DD	0c6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0L@NICDOGIB@finisignal?$AA@
CONST	SEGMENT
??_C@_0L@NICDOGIB@finisignal?$AA@ DB 'finisignal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@ DB '..\Modules\sig'
	DB	'nalmodule.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\signalmodule.c
CONST	ENDS
;	COMDAT finisignal
_TEXT	SEGMENT
finisignal PROC						; COMDAT

; 1291 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1292 :     int i;
; 1293 :     PyObject *func;
; 1294 : 
; 1295 :     PyOS_setsig(SIGINT, old_siginthandler);

  00018	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR old_siginthandler
  0001f	b9 02 00 00 00	 mov	 ecx, 2
  00024	e8 00 00 00 00	 call	 PyOS_setsig

; 1296 :     old_siginthandler = SIG_DFL;

  00029	45 33 e4	 xor	 r12d, r12d
  0002c	48 8d 2d 18 00
	00 00		 lea	 rbp, OFFSET FLAT:Handlers+24
  00033	4c 89 25 00 00
	00 00		 mov	 QWORD PTR old_siginthandler, r12
  0003a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00041	48 8b f5	 mov	 rsi, rbp

; 1297 : 
; 1298 :     for (i = 1; i < NSIG; i++) {

  00044	41 8d 7c 24 01	 lea	 edi, QWORD PTR [r12+1]
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@finisignal:

; 1299 :         func = Handlers[i].func;

  00050	48 8b 5d 00	 mov	 rbx, QWORD PTR [rbp]

; 1300 :         Handlers[i].tripped = 0;

  00054	44 89 66 f8	 mov	 DWORD PTR [rsi-8], r12d

; 1301 :         Handlers[i].func = NULL;

  00058	4c 89 26	 mov	 QWORD PTR [rsi], r12

; 1302 :         if (i != SIGINT && func != NULL && func != Py_None &&
; 1303 :             func != DefaultHandler && func != IgnoreHandler)

  0005b	83 ff 02	 cmp	 edi, 2
  0005e	74 29		 je	 SHORT $LN16@finisignal
  00060	48 85 db	 test	 rbx, rbx
  00063	0f 84 8a 00 00
	00		 je	 $LN15@finisignal
  00069	49 3b dd	 cmp	 rbx, r13
  0006c	74 1b		 je	 SHORT $LN16@finisignal
  0006e	48 3b 1d 00 00
	00 00		 cmp	 rbx, QWORD PTR DefaultHandler
  00075	74 12		 je	 SHORT $LN16@finisignal
  00077	48 3b 1d 00 00
	00 00		 cmp	 rbx, QWORD PTR IgnoreHandler
  0007e	74 09		 je	 SHORT $LN16@finisignal

; 1304 :             PyOS_setsig(i, SIG_DFL);

  00080	33 d2		 xor	 edx, edx
  00082	8b cf		 mov	 ecx, edi
  00084	e8 00 00 00 00	 call	 PyOS_setsig
$LN16@finisignal:

; 1305 :         Py_XDECREF(func);

  00089	48 85 db	 test	 rbx, rbx
  0008c	74 65		 je	 SHORT $LN15@finisignal
  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	75 5c		 jne	 SHORT $LN15@finisignal
  00097	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009b	a8 20		 test	 al, 32			; 00000020H
  0009d	75 4c		 jne	 SHORT $LN27@finisignal
  0009f	84 c0		 test	 al, al
  000a1	78 48		 js	 SHORT $LN27@finisignal
  000a3	a8 02		 test	 al, 2
  000a5	75 4c		 jne	 SHORT $LN15@finisignal
  000a7	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000ab	75 46		 jne	 SHORT $LN15@finisignal
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000bb	4c 8b cb	 mov	 r9, rbx
  000be	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000c4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d1	48 8b cb	 mov	 rcx, rbx
  000d4	85 c0		 test	 eax, eax
  000d6	74 07		 je	 SHORT $LN32@finisignal
  000d8	e8 00 00 00 00	 call	 _Px_Dealloc
  000dd	eb 14		 jmp	 SHORT $LN15@finisignal
$LN32@finisignal:
  000df	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e9	eb 08		 jmp	 SHORT $LN15@finisignal
$LN27@finisignal:
  000eb	48 8b cb	 mov	 rcx, rbx
  000ee	e8 00 00 00 00	 call	 Px_DecRef
$LN15@finisignal:

; 1297 : 
; 1298 :     for (i = 1; i < NSIG; i++) {

  000f3	ff c7		 inc	 edi
  000f5	48 83 c6 10	 add	 rsi, 16
  000f9	48 83 c5 10	 add	 rbp, 16
  000fd	83 ff 17	 cmp	 edi, 23
  00100	0f 8c 4a ff ff
	ff		 jl	 $LL20@finisignal

; 1306 :     }
; 1307 : 
; 1308 :     Py_CLEAR(IntHandler);

  00106	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR IntHandler
  0010d	4d 85 c9	 test	 r9, r9
  00110	0f 84 98 00 00
	00		 je	 $LN11@finisignal
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  00124	41 b8 1c 05 00
	00		 mov	 r8d, 1308		; 0000051cH
  0012a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00132	e8 00 00 00 00	 call	 _PyParallel_Guard
  00137	85 c0		 test	 eax, eax
  00139	75 73		 jne	 SHORT $LN11@finisignal
  0013b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR IntHandler
  00142	4c 89 25 00 00
	00 00		 mov	 QWORD PTR IntHandler, r12
  00149	e8 00 00 00 00	 call	 _Py_PXCTX
  0014e	85 c0		 test	 eax, eax
  00150	75 5c		 jne	 SHORT $LN11@finisignal
  00152	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00156	a8 20		 test	 al, 32			; 00000020H
  00158	75 4c		 jne	 SHORT $LN38@finisignal
  0015a	84 c0		 test	 al, al
  0015c	78 48		 js	 SHORT $LN38@finisignal
  0015e	a8 02		 test	 al, 2
  00160	75 4c		 jne	 SHORT $LN11@finisignal
  00162	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00166	75 46		 jne	 SHORT $LN11@finisignal
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00176	4c 8b cb	 mov	 r9, rbx
  00179	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0017f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00187	e8 00 00 00 00	 call	 _PyParallel_Guard
  0018c	48 8b cb	 mov	 rcx, rbx
  0018f	85 c0		 test	 eax, eax
  00191	74 07		 je	 SHORT $LN43@finisignal
  00193	e8 00 00 00 00	 call	 _Px_Dealloc
  00198	eb 14		 jmp	 SHORT $LN11@finisignal
$LN43@finisignal:
  0019a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0019e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001a4	eb 08		 jmp	 SHORT $LN11@finisignal
$LN38@finisignal:
  001a6	48 8b cb	 mov	 rcx, rbx
  001a9	e8 00 00 00 00	 call	 Px_DecRef
$LN11@finisignal:

; 1309 :     Py_CLEAR(DefaultHandler);

  001ae	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR DefaultHandler
  001b5	4d 85 c9	 test	 r9, r9
  001b8	0f 84 98 00 00
	00		 je	 $LN7@finisignal
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  001cc	41 b8 1d 05 00
	00		 mov	 r8d, 1309		; 0000051dH
  001d2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001da	e8 00 00 00 00	 call	 _PyParallel_Guard
  001df	85 c0		 test	 eax, eax
  001e1	75 73		 jne	 SHORT $LN7@finisignal
  001e3	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR DefaultHandler
  001ea	4c 89 25 00 00
	00 00		 mov	 QWORD PTR DefaultHandler, r12
  001f1	e8 00 00 00 00	 call	 _Py_PXCTX
  001f6	85 c0		 test	 eax, eax
  001f8	75 5c		 jne	 SHORT $LN7@finisignal
  001fa	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001fe	a8 20		 test	 al, 32			; 00000020H
  00200	75 4c		 jne	 SHORT $LN49@finisignal
  00202	84 c0		 test	 al, al
  00204	78 48		 js	 SHORT $LN49@finisignal
  00206	a8 02		 test	 al, 2
  00208	75 4c		 jne	 SHORT $LN7@finisignal
  0020a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0020e	75 46		 jne	 SHORT $LN7@finisignal
  00210	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0021e	4c 8b cb	 mov	 r9, rbx
  00221	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00227	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0022f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00234	48 8b cb	 mov	 rcx, rbx
  00237	85 c0		 test	 eax, eax
  00239	74 07		 je	 SHORT $LN54@finisignal
  0023b	e8 00 00 00 00	 call	 _Px_Dealloc
  00240	eb 14		 jmp	 SHORT $LN7@finisignal
$LN54@finisignal:
  00242	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00246	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0024c	eb 08		 jmp	 SHORT $LN7@finisignal
$LN49@finisignal:
  0024e	48 8b cb	 mov	 rcx, rbx
  00251	e8 00 00 00 00	 call	 Px_DecRef
$LN7@finisignal:

; 1310 :     Py_CLEAR(IgnoreHandler);

  00256	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR IgnoreHandler
  0025d	4d 85 c9	 test	 r9, r9
  00260	0f 84 98 00 00
	00		 je	 $LN3@finisignal
  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JENNIFPL@?4?4?2Modules?2signalmodule?4c?$AA@
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@NICDOGIB@finisignal?$AA@
  00274	41 b8 1e 05 00
	00		 mov	 r8d, 1310		; 0000051eH
  0027a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00282	e8 00 00 00 00	 call	 _PyParallel_Guard
  00287	85 c0		 test	 eax, eax
  00289	75 73		 jne	 SHORT $LN3@finisignal
  0028b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR IgnoreHandler
  00292	4c 89 25 00 00
	00 00		 mov	 QWORD PTR IgnoreHandler, r12
  00299	e8 00 00 00 00	 call	 _Py_PXCTX
  0029e	85 c0		 test	 eax, eax
  002a0	75 5c		 jne	 SHORT $LN3@finisignal
  002a2	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002a6	a8 20		 test	 al, 32			; 00000020H
  002a8	75 4c		 jne	 SHORT $LN60@finisignal
  002aa	84 c0		 test	 al, al
  002ac	78 48		 js	 SHORT $LN60@finisignal
  002ae	a8 02		 test	 al, 2
  002b0	75 4c		 jne	 SHORT $LN3@finisignal
  002b2	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002b6	75 46		 jne	 SHORT $LN3@finisignal
  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002c6	4c 8b cb	 mov	 r9, rbx
  002c9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002cf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002d7	e8 00 00 00 00	 call	 _PyParallel_Guard
  002dc	48 8b cb	 mov	 rcx, rbx
  002df	85 c0		 test	 eax, eax
  002e1	74 07		 je	 SHORT $LN65@finisignal
  002e3	e8 00 00 00 00	 call	 _Px_Dealloc
  002e8	eb 14		 jmp	 SHORT $LN3@finisignal
$LN65@finisignal:
  002ea	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002ee	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002f4	eb 08		 jmp	 SHORT $LN3@finisignal
$LN60@finisignal:
  002f6	48 8b cb	 mov	 rcx, rbx
  002f9	e8 00 00 00 00	 call	 Px_DecRef
$LN3@finisignal:

; 1311 : }

  002fe	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00303	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00308	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0030d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00311	41 5d		 pop	 r13
  00313	41 5c		 pop	 r12
  00315	5f		 pop	 rdi
  00316	c3		 ret	 0
finisignal ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@		; `string'
PUBLIC	PyErr_CheckSignals
EXTRN	PyEval_CallObjectWithKeywords:PROC
EXTRN	Py_BuildValue:PROC
EXTRN	PyEval_GetFrame:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyErr_CheckSignals DD imagerel $LN25
	DD	imagerel $LN25+43
	DD	imagerel $unwind$PyErr_CheckSignals
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyErr_CheckSignals DD imagerel $LN25+43
	DD	imagerel $LN25+261
	DD	imagerel $chain$6$PyErr_CheckSignals
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyErr_CheckSignals DD imagerel $LN25+261
	DD	imagerel $LN25+266
	DD	imagerel $chain$8$PyErr_CheckSignals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyErr_CheckSignals DD 0e0021H
	DD	04e400H
	DD	05d400H
	DD	06c400H
	DD	0b7400H
	DD	0a6400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN25
	DD	imagerel $LN25+43
	DD	imagerel $unwind$PyErr_CheckSignals
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyErr_CheckSignals DD 0e4e21H
	DD	0a644eH
	DD	095437H
	DD	04e41cH
	DD	05d414H
	DD	06c40fH
	DD	0b740aH
	DD	083405H
	DD	imagerel $LN25
	DD	imagerel $LN25+43
	DD	imagerel $unwind$PyErr_CheckSignals
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyErr_CheckSignals DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@ DB '(iO)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyErr_CheckSignals
_TEXT	SEGMENT
PyErr_CheckSignals PROC					; COMDAT

; 1317 : {

$LN25:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1318 :     int i;
; 1319 :     PyObject *f;
; 1320 : 
; 1321 : #ifdef WITH_PARALLEL
; 1322 :     if (Py_PXCTX)

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 07		 je	 SHORT $LN10@PyErr_Chec
$LN24@PyErr_Chec:

; 1323 :         return 0;

  0000d	33 c0		 xor	 eax, eax

; 1372 : }

  0000f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00013	c3		 ret	 0
$LN10@PyErr_Chec:

; 1324 : #endif
; 1325 : 
; 1326 :     if (!is_tripped)

  00014	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  0001a	85 c0		 test	 eax, eax

; 1327 :         return 0;

  0001c	74 ef		 je	 SHORT $LN24@PyErr_Chec

; 1328 : 
; 1329 : #ifdef WITH_THREAD
; 1330 :     if (PyThread_get_thread_ident() != main_thread)

  0001e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00023	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread

; 1331 :         return 0;

  00029	75 e2		 jne	 SHORT $LN24@PyErr_Chec

; 1332 : #endif
; 1333 : 
; 1334 :     /*
; 1335 :      * The is_tripped variable is meant to speed up the calls to
; 1336 :      * PyErr_CheckSignals (both directly or via pending calls) when no
; 1337 :      * signal has arrived. This variable is set to 1 when a signal arrives
; 1338 :      * and it is set to 0 here, when we know some signals arrived. This way
; 1339 :      * we can run the registered handlers with no signals blocked.
; 1340 :      *
; 1341 :      * NOTE: with this approach we can have a situation where is_tripped is
; 1342 :      *       1 but we have no more signals to handle (Handlers[i].tripped
; 1343 :      *       is 0 for every signal i). This won't do us any harm (except
; 1344 :      *       we're gonna spent some cycles for nothing). This happens when
; 1345 :      *       we receive a signal i after we zero is_tripped and before we
; 1346 :      *       check Handlers[i].tripped.
; 1347 :      */
; 1348 :     is_tripped = 0;

  0002b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00030	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00035	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  0003a	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  0003f	45 33 ed	 xor	 r13d, r13d
  00042	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00047	44 89 2d 00 00
	00 00		 mov	 DWORD PTR is_tripped, r13d

; 1349 : 
; 1350 :     if (!(f = (PyObject *)PyEval_GetFrame()))

  0004e	e8 00 00 00 00	 call	 PyEval_GetFrame
  00053	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  0005a	48 85 c0	 test	 rax, rax
  0005d	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp

; 1351 :         f = Py_None;
; 1352 : 
; 1353 :     for (i = 1; i < NSIG; i++) {

  00062	41 8d 5d 01	 lea	 ebx, QWORD PTR [r13+1]
  00066	48 8d 3d 18 00
	00 00		 lea	 rdi, OFFSET FLAT:Handlers+24
  0006d	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:Handlers
  00074	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00079	4c 0f 45 e0	 cmovne	 r12, rax
  0007d	0f 1f 00	 npad	 3
$LL6@PyErr_Chec:

; 1354 :         if (Handlers[i].tripped) {

  00080	8b 47 f8	 mov	 eax, DWORD PTR [rdi-8]
  00083	85 c0		 test	 eax, eax
  00085	74 49		 je	 SHORT $LN5@PyErr_Chec

; 1355 :             PyObject *result = NULL;
; 1356 :             PyObject *arglist = Py_BuildValue("(iO)", i, f);

  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
  0008e	4d 8b c4	 mov	 r8, r12
  00091	8b d3		 mov	 edx, ebx
  00093	e8 00 00 00 00	 call	 Py_BuildValue

; 1357 :             Handlers[i].tripped = 0;

  00098	48 63 cb	 movsxd	 rcx, ebx
  0009b	48 03 c9	 add	 rcx, rcx
  0009e	48 8b e8	 mov	 rbp, rax
  000a1	45 89 2c ce	 mov	 DWORD PTR [r14+rcx*8], r13d

; 1358 : 
; 1359 :             if (arglist) {

  000a5	48 85 c0	 test	 rax, rax
  000a8	74 5b		 je	 SHORT $LN14@PyErr_Chec

; 1360 :                 result = PyEval_CallObject(Handlers[i].func,
; 1361 :                                            arglist);

  000aa	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000ad	45 33 c0	 xor	 r8d, r8d
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 1362 :                 Py_DECREF(arglist);

  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	48 8b f0	 mov	 rsi, rax
  000be	e8 00 00 00 00	 call	 _Py_DecRef

; 1363 :             }
; 1364 :             if (!result)

  000c3	48 85 f6	 test	 rsi, rsi
  000c6	74 3d		 je	 SHORT $LN14@PyErr_Chec

; 1366 : 
; 1367 :             Py_DECREF(result);

  000c8	48 8b ce	 mov	 rcx, rsi
  000cb	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@PyErr_Chec:

; 1351 :         f = Py_None;
; 1352 : 
; 1353 :     for (i = 1; i < NSIG; i++) {

  000d0	ff c3		 inc	 ebx
  000d2	48 83 c7 10	 add	 rdi, 16
  000d6	83 fb 17	 cmp	 ebx, 23
  000d9	7c a5		 jl	 SHORT $LL6@PyErr_Chec

; 1368 :         }
; 1369 :     }
; 1370 : 
; 1371 :     return 0;

  000db	33 c0		 xor	 eax, eax
$LN23@PyErr_Chec:
  000dd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e7	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000ec	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
  000f1	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]

; 1372 : }

  00100	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00104	c3		 ret	 0
$LN14@PyErr_Chec:

; 1365 :                 return -1;

  00105	83 c8 ff	 or	 eax, -1
  00108	eb d3		 jmp	 SHORT $LN23@PyErr_Chec
PyErr_CheckSignals ENDP
_TEXT	ENDS
PUBLIC	PyOS_InitInterrupts
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_InitInterrupts DD imagerel $LN4
	DD	imagerel $LN4+34
	DD	imagerel $unwind$PyOS_InitInterrupts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_InitInterrupts DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_InitInterrupts
_TEXT	SEGMENT
PyOS_InitInterrupts PROC				; COMDAT

; 1386 : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1387 :     PyObject *m = PyImport_ImportModule("signal");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06OAFOBKHE@signal?$AA@
  0000b	e8 00 00 00 00	 call	 PyImport_ImportModule

; 1388 :     if (m) {

  00010	48 85 c0	 test	 rax, rax
  00013	74 08		 je	 SHORT $LN1@PyOS_InitI

; 1389 :         Py_DECREF(m);

  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyOS_InitI:

; 1390 :     }
; 1391 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
PyOS_InitInterrupts ENDP
_TEXT	ENDS
PUBLIC	PyOS_FiniInterrupts
; Function compile flags: /Ogtpy
;	COMDAT PyOS_FiniInterrupts
_TEXT	SEGMENT
PyOS_FiniInterrupts PROC				; COMDAT

; 1396 :     finisignal();
; 1397 : }

  00000	e9 00 00 00 00	 jmp	 finisignal
PyOS_FiniInterrupts ENDP
_TEXT	ENDS
PUBLIC	PyOS_InterruptOccurred
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_InterruptOccurred DD imagerel $LN5
	DD	imagerel $LN5+54
	DD	imagerel $unwind$PyOS_InterruptOccurred
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_InterruptOccurred DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_InterruptOccurred
_TEXT	SEGMENT
PyOS_InterruptOccurred PROC				; COMDAT

; 1401 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1402 :     if (Handlers[SIGINT].tripped) {

  00004	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR Handlers+32
  0000a	85 c0		 test	 eax, eax
  0000c	74 21		 je	 SHORT $LN2@PyOS_Inter

; 1403 : #ifdef WITH_THREAD
; 1404 :         if (PyThread_get_thread_ident() != main_thread)

  0000e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00013	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread

; 1405 :             return 0;

  00019	75 14		 jne	 SHORT $LN2@PyOS_Inter

; 1406 : #endif
; 1407 :         Handlers[SIGINT].tripped = 0;

  0001b	c7 05 20 00 00
	00 00 00 00 00	 mov	 DWORD PTR Handlers+32, 0

; 1408 :         return 1;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 1411 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
$LN2@PyOS_Inter:

; 1409 :     }
; 1410 :     return 0;

  0002f	33 c0		 xor	 eax, eax

; 1411 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
PyOS_InterruptOccurred ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _clear_pending_signals
_TEXT	SEGMENT
_clear_pending_signals PROC				; COMDAT

; 1416 :     int i;
; 1417 :     if (!is_tripped)

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  00006	85 c0		 test	 eax, eax
  00008	74 21		 je	 SHORT $LN1@clear_pend

; 1418 :         return;
; 1419 :     is_tripped = 0;

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:Handlers+16
  00013	b9 16 00 00 00	 mov	 ecx, 22
  00018	89 15 00 00 00
	00		 mov	 DWORD PTR is_tripped, edx
  0001e	66 90		 npad	 2
$LL3@clear_pend:

; 1420 :     for (i = 1; i < NSIG; ++i) {
; 1421 :         Handlers[i].tripped = 0;

  00020	89 10		 mov	 DWORD PTR [rax], edx
  00022	48 83 c0 10	 add	 rax, 16
  00026	48 ff c9	 dec	 rcx
  00029	75 f5		 jne	 SHORT $LL3@clear_pend
$LN1@clear_pend:

; 1422 :     }
; 1423 : }

  0002b	f3 c3		 fatret	 0
_clear_pending_signals ENDP
_TEXT	ENDS
PUBLIC	PyOS_AfterFork
EXTRN	_PyImport_ReInitLock:PROC
EXTRN	__imp_getpid:PROC
EXTRN	PyEval_ReInitThreads:PROC
EXTRN	_PyGILState_Reinit:PROC
EXTRN	PyThread_ReInitTLS:PROC
_BSS	SEGMENT
main_pid DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_AfterFork DD imagerel $LN3
	DD	imagerel $LN3+56
	DD	imagerel $unwind$PyOS_AfterFork
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_AfterFork DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyOS_AfterFork
_TEXT	SEGMENT
PyOS_AfterFork PROC					; COMDAT

; 1427 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1428 :     /* Clear the signal flags after forking so that they aren't handled
; 1429 :      * in both processes if they came in just before the fork() but before
; 1430 :      * the interpreter had an opportunity to call the handlers.  issue9535. */
; 1431 :     _clear_pending_signals();

  00004	e8 00 00 00 00	 call	 _clear_pending_signals

; 1432 : #ifdef WITH_THREAD
; 1433 :     /* PyThread_ReInitTLS() must be called early, to make sure that the TLS API
; 1434 :      * can be called safely. */
; 1435 :     PyThread_ReInitTLS();

  00009	e8 00 00 00 00	 call	 PyThread_ReInitTLS

; 1436 :     _PyGILState_Reinit();

  0000e	e8 00 00 00 00	 call	 _PyGILState_Reinit

; 1437 :     PyEval_ReInitThreads();

  00013	e8 00 00 00 00	 call	 PyEval_ReInitThreads

; 1438 :     main_thread = PyThread_get_thread_ident();

  00018	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0001d	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 1439 :     main_pid = getpid();

  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00029	89 05 00 00 00
	00		 mov	 DWORD PTR main_pid, eax

; 1440 :     _PyImport_ReInitLock();
; 1441 : #endif
; 1442 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	e9 00 00 00 00	 jmp	 _PyImport_ReInitLock
PyOS_AfterFork ENDP
_TEXT	ENDS
PUBLIC	_PyOS_IsMainThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyOS_IsMainThread DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$_PyOS_IsMainThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_IsMainThread DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyOS_IsMainThread
_TEXT	SEGMENT
_PyOS_IsMainThread PROC					; COMDAT

; 1446 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1447 : #ifdef WITH_THREAD
; 1448 :     return PyThread_get_thread_ident() == main_thread;

  00004	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00009	33 c9		 xor	 ecx, ecx
  0000b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00011	0f 94 c1	 sete	 cl
  00014	8b c1		 mov	 eax, ecx

; 1449 : #else
; 1450 :     return 1;
; 1451 : #endif
; 1452 : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
_PyOS_IsMainThread ENDP
_TEXT	ENDS
PUBLIC	_PyOS_SigintEvent
; Function compile flags: /Ogtpy
;	COMDAT _PyOS_SigintEvent
_TEXT	SEGMENT
_PyOS_SigintEvent PROC					; COMDAT

; 1457 :     /* Returns a manual-reset event which gets tripped whenever
; 1458 :        SIGINT is received.
; 1459 : 
; 1460 :        Python.h does not include windows.h so we do cannot use HANDLE
; 1461 :        as the return type of this function.  We use void* instead. */
; 1462 :     return sigint_event;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR sigint_event

; 1463 : }

  00007	c3		 ret	 0
_PyOS_SigintEvent ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT checksignals_witharg
_TEXT	SEGMENT
unused$ = 8
checksignals_witharg PROC				; COMDAT

; 180  :     return PyErr_CheckSignals();
; 181  : }

  00000	e9 00 00 00 00	 jmp	 PyErr_CheckSignals
checksignals_witharg ENDP
_TEXT	ENDS
EXTRN	Py_AddPendingCall:PROC
EXTRN	__imp_write:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$trip_signal DD imagerel trip_signal
	DD	imagerel trip_signal+101
	DD	imagerel $unwind$trip_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$trip_signal DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT trip_signal
_TEXT	SEGMENT
byte$ = 48
sig_num$ = 48
trip_signal PROC					; COMDAT

; 185  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 186  :     unsigned char byte;
; 187  : 
; 188  :     Handlers[sig_num].tripped = 1;

  00004	48 63 c1	 movsxd	 rax, ecx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Handlers
  0000e	48 03 c0	 add	 rax, rax
  00011	c7 04 c2 01 00
	00 00		 mov	 DWORD PTR [rdx+rax*8], 1

; 189  :     if (wakeup_fd != -1) {

  00018	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR wakeup_fd
  0001e	83 f8 ff	 cmp	 eax, -1
  00021	74 1b		 je	 SHORT $LN2@trip_signa

; 190  :         byte = (unsigned char)sig_num;

  00023	88 4c 24 30	 mov	 BYTE PTR byte$[rsp], cl

; 191  :         write(wakeup_fd, &byte, 1);

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR wakeup_fd
  0002d	48 8d 54 24 30	 lea	 rdx, QWORD PTR byte$[rsp]
  00032	41 b8 01 00 00
	00		 mov	 r8d, 1
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
$LN2@trip_signa:

; 192  :     }
; 193  :     if (is_tripped)

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR is_tripped
  00044	85 c0		 test	 eax, eax
  00046	75 18		 jne	 SHORT $LN3@trip_signa

; 194  :         return;
; 195  :     /* Set is_tripped after setting .tripped, as it gets
; 196  :        cleared in PyErr_CheckSignals() before .tripped. */
; 197  :     is_tripped = 1;
; 198  :     Py_AddPendingCall(checksignals_witharg, NULL);

  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:checksignals_witharg
  0004f	33 d2		 xor	 edx, edx
  00051	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR is_tripped, 1
  0005b	e8 00 00 00 00	 call	 Py_AddPendingCall
$LN3@trip_signa:

; 199  : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
trip_signal ENDP
_TEXT	ENDS
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_handler DD imagerel signal_handler
	DD	imagerel signal_handler+92
	DD	imagerel $unwind$signal_handler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_handler DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT signal_handler
_TEXT	SEGMENT
sig_num$ = 48
signal_handler PROC					; COMDAT

; 203  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b d9		 mov	 ebx, ecx

; 204  :     int save_errno = errno;

  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00012	8b 38		 mov	 edi, DWORD PTR [rax]

; 205  : 
; 206  : #if defined(WITH_THREAD) && defined(WITH_PTH)
; 207  :     if (PyThread_get_thread_ident() != main_thread) {
; 208  :         pth_raise(*(pth_t *) main_thread, sig_num);
; 209  :     }
; 210  :     else
; 211  : #endif
; 212  :     {
; 213  : #ifdef WITH_THREAD
; 214  :     /* See NOTES section above */
; 215  :     if (getpid() == main_pid)

  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  0001a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_pid
  00020	75 07		 jne	 SHORT $LN2@signal_han

; 216  : #endif
; 217  :     {
; 218  :         trip_signal(sig_num);

  00022	8b cb		 mov	 ecx, ebx
  00024	e8 00 00 00 00	 call	 trip_signal
$LN2@signal_han:

; 219  :     }
; 220  : 
; 221  : #ifndef HAVE_SIGACTION
; 222  : #ifdef SIGCHLD
; 223  :     /* To avoid infinite recursion, this signal remains
; 224  :        reset until explicit re-instated.
; 225  :        Don't clear the 'func' field as it is our pointer
; 226  :        to the Python handler... */
; 227  :     if (sig_num != SIGCHLD)
; 228  : #endif
; 229  :     /* If the handler was not set up with sigaction, reinstall it.  See
; 230  :      * Python/pythonrun.c for the implementation of PyOS_setsig which
; 231  :      * makes this true.  See also issue8354. */
; 232  :     PyOS_setsig(sig_num, signal_handler);

  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:signal_handler
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 PyOS_setsig

; 233  : #endif
; 234  :     }
; 235  : 
; 236  :     /* Issue #10311: asynchronously executing signal handlers should not
; 237  :        mutate errno under the feet of unsuspecting C code. */
; 238  :     errno = save_errno;

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003d	89 38		 mov	 DWORD PTR [rax], edi

; 239  : 
; 240  : #ifdef MS_WINDOWS
; 241  :     if (sig_num == SIGINT)

  0003f	83 fb 02	 cmp	 ebx, 2
  00042	75 0d		 jne	 SHORT $LN1@signal_han

; 242  :         SetEvent(sigint_event);

  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sigint_event
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent
$LN1@signal_han:

; 243  : #endif
; 244  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
signal_handler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@	; `string'
PUBLIC	??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@ ; `string'
PUBLIC	??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@ ; `string'
PUBLIC	??_C@_09KGGMABKF@iO?3signal?$AA@		; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyCallable_Check:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$signal_signal DD imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$signal_signal DD imagerel signal_signal+44
	DD	imagerel signal_signal+134
	DD	imagerel $chain$0$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$signal_signal DD imagerel signal_signal+134
	DD	imagerel signal_signal+226
	DD	imagerel $chain$2$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$signal_signal DD imagerel signal_signal+226
	DD	imagerel signal_signal+276
	DD	imagerel $chain$4$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$signal_signal DD imagerel signal_signal+276
	DD	imagerel signal_signal+362
	DD	imagerel $chain$7$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$signal_signal DD imagerel signal_signal+362
	DD	imagerel signal_signal+396
	DD	imagerel $chain$9$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$signal_signal DD imagerel signal_signal+396
	DD	imagerel signal_signal+427
	DD	imagerel $chain$11$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$signal_signal DD imagerel signal_signal+427
	DD	imagerel signal_signal+460
	DD	imagerel $chain$13$signal_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$signal_signal DD imagerel signal_signal+460
	DD	imagerel signal_signal+489
	DD	imagerel $chain$15$signal_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$signal_signal DD 020021H
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$signal_signal DD 020021H
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$signal_signal DD 020021H
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$signal_signal DD 040021H
	DD	047400H
	DD	063400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$signal_signal DD 040a21H
	DD	06340aH
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$signal_signal DD 020021H
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$signal_signal DD 020021H
	DD	047400H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$signal_signal DD 020521H
	DD	047405H
	DD	imagerel signal_signal
	DD	imagerel signal_signal+44
	DD	imagerel $unwind$signal_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$signal_signal DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@
CONST	SEGMENT
??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@ DB 'invalid signal value', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@
CONST	SEGMENT
??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@ DB 'signal hand'
	DB	'ler must be signal.SIG_IGN, signal.SIG_DFL, or a callable obj'
	DB	'ect', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@
CONST	SEGMENT
??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@ DB 'signal only'
	DB	' works in main thread', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09KGGMABKF@iO?3signal?$AA@
CONST	SEGMENT
??_C@_09KGGMABKF@iO?3signal?$AA@ DB 'iO:signal', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT signal_signal
_TEXT	SEGMENT
self$ = 48
args$ = 56
sig_num$ = 64
obj$ = 72
signal_signal PROC					; COMDAT

; 290  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  :     PyObject *obj;
; 292  :     int sig_num;
; 293  :     PyObject *old_handler;
; 294  :     void (*func)(int);
; 295  :     if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 48	 lea	 r9, QWORD PTR obj$[rsp]
  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR sig_num$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09KGGMABKF@iO?3signal?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN23@signal_sig

; 296  :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 351  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN23@signal_sig:

; 297  : #ifdef MS_WINDOWS
; 298  :     /* Validate that sig_num is one of the allowable signals */
; 299  :     switch (sig_num) {

  00028	8b 44 24 40	 mov	 eax, DWORD PTR sig_num$[rsp]
  0002c	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00031	83 c0 fe	 add	 eax, -2
  00034	83 f8 14	 cmp	 eax, 20
  00037	0f 87 6e 01 00
	00		 ja	 $LN13@signal_sig
  0003d	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:__ImageBase
  00044	48 98		 cdqe
  00046	0f b6 84 07 00
	00 00 00	 movzx	 eax, BYTE PTR $LN26@signal_sig[rdi+rax]
  0004e	8b 8c 87 00 00
	00 00		 mov	 ecx, DWORD PTR $LN27@signal_sig[rdi+rax*4]
  00055	48 03 cf	 add	 rcx, rdi
  00058	ff e1		 jmp	 rcx
$LN20@signal_sig:

; 314  :     }
; 315  : #endif
; 316  : #ifdef WITH_THREAD
; 317  :     if (PyThread_get_thread_ident() != main_thread) {

  0005a	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0005f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00065	74 1f		 je	 SHORT $LN12@signal_sig

; 318  :         PyErr_SetString(PyExc_ValueError,
; 319  :                         "signal only works in main thread");

  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@OAIHALJA@signal?5only?5works?5in?5main?5thread@
  00075	e8 00 00 00 00	 call	 PyErr_SetString
  0007a	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 320  :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 351  : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
$LN12@signal_sig:

; 321  :     }
; 322  : #endif
; 323  :     if (sig_num < 1 || sig_num >= NSIG) {

  00086	44 8b 44 24 40	 mov	 r8d, DWORD PTR sig_num$[rsp]
  0008b	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  0008f	83 f8 15	 cmp	 eax, 21
  00092	0f 87 f4 00 00
	00		 ja	 $LN10@signal_sig

; 327  :     }
; 328  :     if (obj == IgnoreHandler)

  00098	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  0009d	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR IgnoreHandler
  000a4	75 07		 jne	 SHORT $LN9@signal_sig

; 329  :         func = SIG_IGN;

  000a6	ba 01 00 00 00	 mov	 edx, 1
  000ab	eb 41		 jmp	 SHORT $LN4@signal_sig
$LN9@signal_sig:

; 330  :     else if (obj == DefaultHandler)

  000ad	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR DefaultHandler
  000b4	75 04		 jne	 SHORT $LN7@signal_sig

; 331  :         func = SIG_DFL;

  000b6	33 d2		 xor	 edx, edx
  000b8	eb 34		 jmp	 SHORT $LN4@signal_sig
$LN7@signal_sig:

; 332  :     else if (!PyCallable_Check(obj)) {

  000ba	e8 00 00 00 00	 call	 PyCallable_Check
  000bf	85 c0		 test	 eax, eax
  000c1	75 1f		 jne	 SHORT $LN5@signal_sig

; 333  :         PyErr_SetString(PyExc_TypeError,
; 334  : "signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");

  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EM@JOAANLII@signal?5handler?5must?5be?5signal?4SI@
  000d1	e8 00 00 00 00	 call	 PyErr_SetString
  000d6	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 335  :                 return NULL;

  000db	33 c0		 xor	 eax, eax

; 351  : }

  000dd	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e1	c3		 ret	 0
$LN5@signal_sig:

; 336  :     }
; 337  :     else
; 338  :         func = signal_handler;

  000e2	44 8b 44 24 40	 mov	 r8d, DWORD PTR sig_num$[rsp]
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:signal_handler
$LN4@signal_sig:

; 339  :     if (PyOS_setsig(sig_num, func) == SIG_ERR) {

  000ee	41 8b c8	 mov	 ecx, r8d
  000f1	e8 00 00 00 00	 call	 PyOS_setsig
  000f6	48 83 f8 ff	 cmp	 rax, -1
  000fa	75 18		 jne	 SHORT $LN3@signal_sig

; 340  :         PyErr_SetFromErrno(PyExc_OSError);

  000fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00103	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00108	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 341  :         return NULL;

  0010d	33 c0		 xor	 eax, eax

; 351  : }

  0010f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00113	c3		 ret	 0
$LN3@signal_sig:

; 342  :     }
; 343  :     old_handler = Handlers[sig_num].func;

  00114	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sig_num$[rsp]
  00119	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0011e	48 03 c9	 add	 rcx, rcx
  00121	48 8b 9c cf 08
	00 00 00	 mov	 rbx, QWORD PTR Handlers[rdi+rcx*8+8]

; 344  :     Handlers[sig_num].tripped = 0;

  00129	c7 84 cf 00 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Handlers[rdi+rcx*8], 0

; 345  :     Py_INCREF(obj);

  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  00139	e8 00 00 00 00	 call	 _Py_IncRef

; 346  :     Handlers[sig_num].func = obj;

  0013e	4c 63 5c 24 40	 movsxd	 r11, DWORD PTR sig_num$[rsp]
  00143	48 8b 4c 24 48	 mov	 rcx, QWORD PTR obj$[rsp]
  00148	4d 03 db	 add	 r11, r11
  0014b	4a 89 8c df 08
	00 00 00	 mov	 QWORD PTR Handlers[rdi+r11*8+8], rcx

; 347  :     if (old_handler != NULL)

  00153	48 85 db	 test	 rbx, rbx
  00156	74 12		 je	 SHORT $LN2@signal_sig

; 348  :         return old_handler;

  00158	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  0015d	48 8b c3	 mov	 rax, rbx
  00160	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 351  : }

  00165	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00169	c3		 ret	 0
$LN2@signal_sig:

; 349  :     else
; 350  :         Py_RETURN_NONE;

  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00171	e8 00 00 00 00	 call	 _Py_IncRef
  00176	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0017b	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 351  : }

  00187	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0018b	c3		 ret	 0
$LN10@signal_sig:

; 324  :         PyErr_SetString(PyExc_ValueError,
; 325  :                         "signal number out of range");

  0018c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HNABDGJL@signal?5number?5out?5of?5range?$AA@
  0019a	e8 00 00 00 00	 call	 PyErr_SetString
  0019f	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 326  :         return NULL;

  001a4	33 c0		 xor	 eax, eax

; 351  : }

  001a6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001aa	c3		 ret	 0
$LN13@signal_sig:

; 300  :         case SIGABRT: break;
; 301  : #ifdef SIGBREAK
; 302  :         /* Issue #10003: SIGBREAK is not documented as permitted, but works
; 303  :            and corresponds to CTRL_BREAK_EVENT. */
; 304  :         case SIGBREAK: break;
; 305  : #endif
; 306  :         case SIGFPE: break;
; 307  :         case SIGILL: break;
; 308  :         case SIGINT: break;
; 309  :         case SIGSEGV: break;
; 310  :         case SIGTERM: break;
; 311  :         default:
; 312  :             PyErr_SetString(PyExc_ValueError, "invalid signal value");

  001ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@POOAHGOC@invalid?5signal?5value?$AA@
  001b9	e8 00 00 00 00	 call	 PyErr_SetString
  001be	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 313  :             return NULL;

  001c3	33 c0		 xor	 eax, eax

; 351  : }

  001c5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c9	c3		 ret	 0
  001ca	66 90		 npad	 2
$LN27@signal_sig:
  001cc	00 00 00 00	 DD	 $LN20@signal_sig
  001d0	00 00 00 00	 DD	 $LN13@signal_sig
$LN26@signal_sig:
  001d4	00		 DB	 0
  001d5	01		 DB	 1
  001d6	00		 DB	 0
  001d7	01		 DB	 1
  001d8	01		 DB	 1
  001d9	01		 DB	 1
  001da	00		 DB	 0
  001db	01		 DB	 1
  001dc	01		 DB	 1
  001dd	00		 DB	 0
  001de	01		 DB	 1
  001df	01		 DB	 1
  001e0	01		 DB	 1
  001e1	00		 DB	 0
  001e2	01		 DB	 1
  001e3	01		 DB	 1
  001e4	01		 DB	 1
  001e5	01		 DB	 1
  001e6	01		 DB	 1
  001e7	00		 DB	 0
  001e8	00		 DB	 0
signal_signal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@	; `string'
PUBLIC	??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@		; `string'
PUBLIC	??_C@_07MJAMNEFP@SIGTERM?$AA@			; `string'
PUBLIC	??_C@_07MIPHKCEO@SIGSEGV?$AA@			; `string'
PUBLIC	??_C@_06ONOHJOEH@SIGFPE?$AA@			; `string'
PUBLIC	??_C@_07GHNLFNAM@SIGABRT?$AA@			; `string'
PUBLIC	??_C@_06HBHKGPEM@SIGILL?$AA@			; `string'
PUBLIC	??_C@_08CLALOKCJ@SIGBREAK?$AA@			; `string'
PUBLIC	??_C@_06PAOFCDHL@SIGINT?$AA@			; `string'
PUBLIC	??_C@_04MHNFCBAL@NSIG?$AA@			; `string'
PUBLIC	??_C@_07MFMKGIKO@SIG_IGN?$AA@			; `string'
PUBLIC	??_C@_07EFELIMG@SIG_DFL?$AA@			; `string'
PUBLIC	PyInit_signal
EXTRN	PyErr_Occurred:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	PyOS_getsig:PROC
EXTRN	PyDict_GetItemString:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_signal DD imagerel $LN53
	DD	imagerel $LN53+183
	DD	imagerel $unwind$PyInit_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyInit_signal DD imagerel $LN53+183
	DD	imagerel $LN53+270
	DD	imagerel $chain$1$PyInit_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyInit_signal DD imagerel $LN53+270
	DD	imagerel $LN53+436
	DD	imagerel $chain$5$PyInit_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyInit_signal DD imagerel $LN53+436
	DD	imagerel $LN53+932
	DD	imagerel $chain$6$PyInit_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyInit_signal DD imagerel $LN53+932
	DD	imagerel $LN53+937
	DD	imagerel $chain$7$PyInit_signal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyInit_signal DD imagerel $LN53+937
	DD	imagerel $LN53+952
	DD	imagerel $chain$8$PyInit_signal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyInit_signal DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+183
	DD	imagerel $unwind$PyInit_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyInit_signal DD 021H
	DD	imagerel $LN53+183
	DD	imagerel $LN53+270
	DD	imagerel $chain$1$PyInit_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyInit_signal DD 020021H
	DD	05d400H
	DD	imagerel $LN53+183
	DD	imagerel $LN53+270
	DD	imagerel $chain$1$PyInit_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyInit_signal DD 081721H
	DD	04e417H
	DD	05d412H
	DD	0b740aH
	DD	0a6405H
	DD	imagerel $LN53+183
	DD	imagerel $LN53+270
	DD	imagerel $chain$1$PyInit_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyInit_signal DD 020521H
	DD	083405H
	DD	imagerel $LN53
	DD	imagerel $LN53+183
	DD	imagerel $unwind$PyInit_signal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_signal DD 044501H
	DD	095445H
	DD	0c0025206H
xdata	ENDS
;	COMDAT ??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@
CONST	SEGMENT
??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@ DB 'CTRL_BREAK_EVENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@
CONST	SEGMENT
??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@ DB 'CTRL_C_EVENT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MJAMNEFP@SIGTERM?$AA@
CONST	SEGMENT
??_C@_07MJAMNEFP@SIGTERM?$AA@ DB 'SIGTERM', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIPHKCEO@SIGSEGV?$AA@
CONST	SEGMENT
??_C@_07MIPHKCEO@SIGSEGV?$AA@ DB 'SIGSEGV', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ONOHJOEH@SIGFPE?$AA@
CONST	SEGMENT
??_C@_06ONOHJOEH@SIGFPE?$AA@ DB 'SIGFPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GHNLFNAM@SIGABRT?$AA@
CONST	SEGMENT
??_C@_07GHNLFNAM@SIGABRT?$AA@ DB 'SIGABRT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HBHKGPEM@SIGILL?$AA@
CONST	SEGMENT
??_C@_06HBHKGPEM@SIGILL?$AA@ DB 'SIGILL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CLALOKCJ@SIGBREAK?$AA@
CONST	SEGMENT
??_C@_08CLALOKCJ@SIGBREAK?$AA@ DB 'SIGBREAK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06PAOFCDHL@SIGINT?$AA@
CONST	SEGMENT
??_C@_06PAOFCDHL@SIGINT?$AA@ DB 'SIGINT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHNFCBAL@NSIG?$AA@
CONST	SEGMENT
??_C@_04MHNFCBAL@NSIG?$AA@ DB 'NSIG', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MFMKGIKO@SIG_IGN?$AA@
CONST	SEGMENT
??_C@_07MFMKGIKO@SIG_IGN?$AA@ DB 'SIG_IGN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EFELIMG@SIG_DFL?$AA@
CONST	SEGMENT
??_C@_07EFELIMG@SIG_DFL?$AA@ DB 'SIG_DFL', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_signal
_TEXT	SEGMENT
PyInit_signal PROC					; COMDAT

; 971  : {

$LN53:
  00000	41 54		 push	 r12
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 972  :     PyObject *m, *d, *x;
; 973  :     int i;
; 974  : 
; 975  : #ifdef WITH_THREAD
; 976  :     main_thread = PyThread_get_thread_ident();

  00006	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0000b	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 977  :     main_pid = getpid();

  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid

; 978  : #endif
; 979  : 
; 980  :     /* Create the module and add the functions */
; 981  :     m = PyModule_Create(&signalmodule);

  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:signalmodule
  0001e	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00023	89 05 00 00 00
	00		 mov	 DWORD PTR main_pid, eax
  00029	e8 00 00 00 00	 call	 PyModule_Create2
  0002e	4c 8b e0	 mov	 r12, rax

; 982  :     if (m == NULL)

  00031	48 85 c0	 test	 rax, rax
  00034	75 07		 jne	 SHORT $LN45@PyInit_sig

; 1287 : }

  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	41 5c		 pop	 r12
  0003c	c3		 ret	 0
$LN45@PyInit_sig:

; 983  :         return NULL;
; 984  : 
; 985  : #if defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT)
; 986  :     if (!initialized)
; 987  :         PyStructSequence_InitType(&SiginfoType, &struct_siginfo_desc);
; 988  : 
; 989  :     Py_INCREF((PyObject*) &SiginfoType);
; 990  :     PyModule_AddObject(m, "struct_siginfo", (PyObject*) &SiginfoType);
; 991  :     initialized = 1;
; 992  : #endif
; 993  : 
; 994  :     /* Add some symbolic constants to the module */
; 995  :     d = PyModule_GetDict(m);

  0003d	48 8b c8	 mov	 rcx, rax
  00040	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00045	e8 00 00 00 00	 call	 PyModule_GetDict

; 996  : 
; 997  :     x = DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);

  0004a	33 c9		 xor	 ecx, ecx
  0004c	48 8b e8	 mov	 rbp, rax
  0004f	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00054	48 89 05 00 00
	00 00		 mov	 QWORD PTR DefaultHandler, rax

; 998  :     if (!x || PyDict_SetItemString(d, "SIG_DFL", x) < 0)

  0005b	48 85 c0	 test	 rax, rax
  0005e	0f 84 45 03 00
	00		 je	 $finally$120859
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EFELIMG@SIG_DFL?$AA@
  0006b	4c 8b c0	 mov	 r8, rax
  0006e	48 8b cd	 mov	 rcx, rbp
  00071	e8 00 00 00 00	 call	 PyDict_SetItemString
  00076	85 c0		 test	 eax, eax
  00078	0f 88 2b 03 00
	00		 js	 $finally$120859

; 999  :         goto finally;
; 1000 : 
; 1001 :     x = IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);

  0007e	b9 01 00 00 00	 mov	 ecx, 1
  00083	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00088	48 89 05 00 00
	00 00		 mov	 QWORD PTR IgnoreHandler, rax

; 1002 :     if (!x || PyDict_SetItemString(d, "SIG_IGN", x) < 0)

  0008f	48 85 c0	 test	 rax, rax
  00092	0f 84 11 03 00
	00		 je	 $finally$120859
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MFMKGIKO@SIG_IGN?$AA@
  0009f	4c 8b c0	 mov	 r8, rax
  000a2	48 8b cd	 mov	 rcx, rbp
  000a5	e8 00 00 00 00	 call	 PyDict_SetItemString
  000aa	85 c0		 test	 eax, eax
  000ac	0f 88 f7 02 00
	00		 js	 $finally$120859

; 1003 :         goto finally;
; 1004 : 
; 1005 :     x = PyLong_FromLong((long)NSIG);

  000b2	b9 17 00 00 00	 mov	 ecx, 23
  000b7	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000bc	e8 00 00 00 00	 call	 PyLong_FromLong
  000c1	48 8b d8	 mov	 rbx, rax

; 1006 :     if (!x || PyDict_SetItemString(d, "NSIG", x) < 0)

  000c4	48 85 c0	 test	 rax, rax
  000c7	0f 84 d7 02 00
	00		 je	 $LN50@PyInit_sig
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MHNFCBAL@NSIG?$AA@
  000d4	4c 8b c0	 mov	 r8, rax
  000d7	48 8b cd	 mov	 rcx, rbp
  000da	e8 00 00 00 00	 call	 PyDict_SetItemString
  000df	85 c0		 test	 eax, eax
  000e1	0f 88 bd 02 00
	00		 js	 $LN50@PyInit_sig

; 1007 :         goto finally;
; 1008 :     Py_DECREF(x);

  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 _Py_DecRef

; 1009 : 
; 1010 : #ifdef SIG_BLOCK
; 1011 :     if (PyModule_AddIntMacro(m, SIG_BLOCK))
; 1012 :          goto finally;
; 1013 : #endif
; 1014 : #ifdef SIG_UNBLOCK
; 1015 :     if (PyModule_AddIntMacro(m, SIG_UNBLOCK))
; 1016 :          goto finally;
; 1017 : #endif
; 1018 : #ifdef SIG_SETMASK
; 1019 :     if (PyModule_AddIntMacro(m, SIG_SETMASK))
; 1020 :          goto finally;
; 1021 : #endif
; 1022 : 
; 1023 :     x = IntHandler = PyDict_GetItemString(d, "default_int_handler");

  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@BBIKIFCE@default_int_handler?$AA@
  000f6	48 8b cd	 mov	 rcx, rbp
  000f9	e8 00 00 00 00	 call	 PyDict_GetItemString
  000fe	48 89 05 00 00
	00 00		 mov	 QWORD PTR IntHandler, rax

; 1024 :     if (!x)

  00105	48 85 c0	 test	 rax, rax
  00108	0f 84 96 02 00
	00		 je	 $LN50@PyInit_sig

; 1025 :         goto finally;
; 1026 :     Py_INCREF(IntHandler);

  0010e	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00113	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00118	48 8b c8	 mov	 rcx, rax
  0011b	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13
  00120	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00125	e8 00 00 00 00	 call	 _Py_IncRef
  0012a	48 8d 35 18 00
	00 00		 lea	 rsi, OFFSET FLAT:Handlers+24

; 1027 : 
; 1028 :     Handlers[0].tripped = 0;

  00131	45 33 ed	 xor	 r13d, r13d

; 1029 :     for (i = 1; i < NSIG; i++) {

  00134	bf 01 00 00 00	 mov	 edi, 1
  00139	48 8b de	 mov	 rbx, rsi
  0013c	44 89 2d 00 00
	00 00		 mov	 DWORD PTR Handlers, r13d
  00143	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL37@PyInit_sig:

; 1030 :         void (*t)(int);
; 1031 :         t = PyOS_getsig(i);

  00150	8b cf		 mov	 ecx, edi
  00152	e8 00 00 00 00	 call	 PyOS_getsig

; 1032 :         Handlers[i].tripped = 0;

  00157	44 89 6b f8	 mov	 DWORD PTR [rbx-8], r13d
  0015b	4c 8b d8	 mov	 r11, rax

; 1033 :         if (t == SIG_DFL)

  0015e	48 85 c0	 test	 rax, rax
  00161	75 09		 jne	 SHORT $LN34@PyInit_sig

; 1034 :             Handlers[i].func = DefaultHandler;

  00163	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DefaultHandler
  0016a	eb 0f		 jmp	 SHORT $LN52@PyInit_sig
$LN34@PyInit_sig:

; 1035 :         else if (t == SIG_IGN)

  0016c	49 8b c6	 mov	 rax, r14
  0016f	49 83 fb 01	 cmp	 r11, 1
  00173	48 0f 44 05 00
	00 00 00	 cmove	 rax, QWORD PTR IgnoreHandler
$LN52@PyInit_sig:
  0017b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1036 :             Handlers[i].func = IgnoreHandler;
; 1037 :         else
; 1038 :             Handlers[i].func = Py_None; /* None of our business */
; 1039 :         Py_INCREF(Handlers[i].func);

  0017e	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00181	e8 00 00 00 00	 call	 _Py_IncRef
  00186	ff c7		 inc	 edi
  00188	48 83 c3 10	 add	 rbx, 16
  0018c	48 83 c6 10	 add	 rsi, 16
  00190	83 ff 17	 cmp	 edi, 23
  00193	7c bb		 jl	 SHORT $LL37@PyInit_sig

; 1040 :     }
; 1041 :     if (Handlers[SIGINT].func == DefaultHandler) {

  00195	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR Handlers+40
  0019c	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  001a1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  001a6	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR DefaultHandler
  001ad	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001b2	75 3e		 jne	 SHORT $LN30@PyInit_sig

; 1042 :         /* Install default int handler */
; 1043 :         Py_INCREF(IntHandler);

  001b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IntHandler
  001bb	e8 00 00 00 00	 call	 _Py_IncRef

; 1044 :         Py_DECREF(Handlers[SIGINT].func);

  001c0	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR Handlers+40
  001c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1045 :         Handlers[SIGINT].func = IntHandler;

  001cc	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR IntHandler

; 1046 :         old_siginthandler = PyOS_setsig(SIGINT, signal_handler);

  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:signal_handler
  001da	b9 02 00 00 00	 mov	 ecx, 2
  001df	4c 89 1d 28 00
	00 00		 mov	 QWORD PTR Handlers+40, r11
  001e6	e8 00 00 00 00	 call	 PyOS_setsig
  001eb	48 89 05 00 00
	00 00		 mov	 QWORD PTR old_siginthandler, rax
$LN30@PyInit_sig:

; 1047 :     }
; 1048 : 
; 1049 : #ifdef SIGHUP
; 1050 :     x = PyLong_FromLong(SIGHUP);
; 1051 :     PyDict_SetItemString(d, "SIGHUP", x);
; 1052 :     Py_XDECREF(x);
; 1053 : #endif
; 1054 : #ifdef SIGINT
; 1055 :     x = PyLong_FromLong(SIGINT);

  001f2	b9 02 00 00 00	 mov	 ecx, 2
  001f7	e8 00 00 00 00	 call	 PyLong_FromLong

; 1056 :     PyDict_SetItemString(d, "SIGINT", x);

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PAOFCDHL@SIGINT?$AA@
  00203	48 8b cd	 mov	 rcx, rbp
  00206	4c 8b c0	 mov	 r8, rax
  00209	48 8b d8	 mov	 rbx, rax
  0020c	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1057 :     Py_XDECREF(x);

  00211	48 85 db	 test	 rbx, rbx
  00214	74 08		 je	 SHORT $LN28@PyInit_sig
  00216	48 8b cb	 mov	 rcx, rbx
  00219	e8 00 00 00 00	 call	 _Py_DecRef
$LN28@PyInit_sig:

; 1058 : #endif
; 1059 : #ifdef SIGBREAK
; 1060 :     x = PyLong_FromLong(SIGBREAK);

  0021e	b9 15 00 00 00	 mov	 ecx, 21
  00223	e8 00 00 00 00	 call	 PyLong_FromLong

; 1061 :     PyDict_SetItemString(d, "SIGBREAK", x);

  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CLALOKCJ@SIGBREAK?$AA@
  0022f	48 8b cd	 mov	 rcx, rbp
  00232	4c 8b c0	 mov	 r8, rax
  00235	48 8b d8	 mov	 rbx, rax
  00238	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1062 :     Py_XDECREF(x);

  0023d	48 85 db	 test	 rbx, rbx
  00240	74 08		 je	 SHORT $LN24@PyInit_sig
  00242	48 8b cb	 mov	 rcx, rbx
  00245	e8 00 00 00 00	 call	 _Py_DecRef
$LN24@PyInit_sig:

; 1063 : #endif
; 1064 : #ifdef SIGQUIT
; 1065 :     x = PyLong_FromLong(SIGQUIT);
; 1066 :     PyDict_SetItemString(d, "SIGQUIT", x);
; 1067 :     Py_XDECREF(x);
; 1068 : #endif
; 1069 : #ifdef SIGILL
; 1070 :     x = PyLong_FromLong(SIGILL);

  0024a	b9 04 00 00 00	 mov	 ecx, 4
  0024f	e8 00 00 00 00	 call	 PyLong_FromLong

; 1071 :     PyDict_SetItemString(d, "SIGILL", x);

  00254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06HBHKGPEM@SIGILL?$AA@
  0025b	48 8b cd	 mov	 rcx, rbp
  0025e	4c 8b c0	 mov	 r8, rax
  00261	48 8b d8	 mov	 rbx, rax
  00264	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1072 :     Py_XDECREF(x);

  00269	48 85 db	 test	 rbx, rbx
  0026c	74 08		 je	 SHORT $LN20@PyInit_sig
  0026e	48 8b cb	 mov	 rcx, rbx
  00271	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@PyInit_sig:

; 1073 : #endif
; 1074 : #ifdef SIGTRAP
; 1075 :     x = PyLong_FromLong(SIGTRAP);
; 1076 :     PyDict_SetItemString(d, "SIGTRAP", x);
; 1077 :     Py_XDECREF(x);
; 1078 : #endif
; 1079 : #ifdef SIGIOT
; 1080 :     x = PyLong_FromLong(SIGIOT);
; 1081 :     PyDict_SetItemString(d, "SIGIOT", x);
; 1082 :     Py_XDECREF(x);
; 1083 : #endif
; 1084 : #ifdef SIGABRT
; 1085 :     x = PyLong_FromLong(SIGABRT);

  00276	b9 16 00 00 00	 mov	 ecx, 22
  0027b	e8 00 00 00 00	 call	 PyLong_FromLong

; 1086 :     PyDict_SetItemString(d, "SIGABRT", x);

  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GHNLFNAM@SIGABRT?$AA@
  00287	48 8b cd	 mov	 rcx, rbp
  0028a	4c 8b c0	 mov	 r8, rax
  0028d	48 8b d8	 mov	 rbx, rax
  00290	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1087 :     Py_XDECREF(x);

  00295	48 85 db	 test	 rbx, rbx
  00298	74 08		 je	 SHORT $LN16@PyInit_sig
  0029a	48 8b cb	 mov	 rcx, rbx
  0029d	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@PyInit_sig:

; 1088 : #endif
; 1089 : #ifdef SIGEMT
; 1090 :     x = PyLong_FromLong(SIGEMT);
; 1091 :     PyDict_SetItemString(d, "SIGEMT", x);
; 1092 :     Py_XDECREF(x);
; 1093 : #endif
; 1094 : #ifdef SIGFPE
; 1095 :     x = PyLong_FromLong(SIGFPE);

  002a2	b9 08 00 00 00	 mov	 ecx, 8
  002a7	e8 00 00 00 00	 call	 PyLong_FromLong

; 1096 :     PyDict_SetItemString(d, "SIGFPE", x);

  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06ONOHJOEH@SIGFPE?$AA@
  002b3	48 8b cd	 mov	 rcx, rbp
  002b6	4c 8b c0	 mov	 r8, rax
  002b9	48 8b d8	 mov	 rbx, rax
  002bc	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1097 :     Py_XDECREF(x);

  002c1	48 85 db	 test	 rbx, rbx
  002c4	74 08		 je	 SHORT $LN12@PyInit_sig
  002c6	48 8b cb	 mov	 rcx, rbx
  002c9	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@PyInit_sig:

; 1098 : #endif
; 1099 : #ifdef SIGKILL
; 1100 :     x = PyLong_FromLong(SIGKILL);
; 1101 :     PyDict_SetItemString(d, "SIGKILL", x);
; 1102 :     Py_XDECREF(x);
; 1103 : #endif
; 1104 : #ifdef SIGBUS
; 1105 :     x = PyLong_FromLong(SIGBUS);
; 1106 :     PyDict_SetItemString(d, "SIGBUS", x);
; 1107 :     Py_XDECREF(x);
; 1108 : #endif
; 1109 : #ifdef SIGSEGV
; 1110 :     x = PyLong_FromLong(SIGSEGV);

  002ce	b9 0b 00 00 00	 mov	 ecx, 11
  002d3	e8 00 00 00 00	 call	 PyLong_FromLong

; 1111 :     PyDict_SetItemString(d, "SIGSEGV", x);

  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MIPHKCEO@SIGSEGV?$AA@
  002df	48 8b cd	 mov	 rcx, rbp
  002e2	4c 8b c0	 mov	 r8, rax
  002e5	48 8b d8	 mov	 rbx, rax
  002e8	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1112 :     Py_XDECREF(x);

  002ed	48 85 db	 test	 rbx, rbx
  002f0	74 08		 je	 SHORT $LN8@PyInit_sig
  002f2	48 8b cb	 mov	 rcx, rbx
  002f5	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@PyInit_sig:

; 1113 : #endif
; 1114 : #ifdef SIGSYS
; 1115 :     x = PyLong_FromLong(SIGSYS);
; 1116 :     PyDict_SetItemString(d, "SIGSYS", x);
; 1117 :     Py_XDECREF(x);
; 1118 : #endif
; 1119 : #ifdef SIGPIPE
; 1120 :     x = PyLong_FromLong(SIGPIPE);
; 1121 :     PyDict_SetItemString(d, "SIGPIPE", x);
; 1122 :     Py_XDECREF(x);
; 1123 : #endif
; 1124 : #ifdef SIGALRM
; 1125 :     x = PyLong_FromLong(SIGALRM);
; 1126 :     PyDict_SetItemString(d, "SIGALRM", x);
; 1127 :     Py_XDECREF(x);
; 1128 : #endif
; 1129 : #ifdef SIGTERM
; 1130 :     x = PyLong_FromLong(SIGTERM);

  002fa	b9 0f 00 00 00	 mov	 ecx, 15
  002ff	e8 00 00 00 00	 call	 PyLong_FromLong

; 1131 :     PyDict_SetItemString(d, "SIGTERM", x);

  00304	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MJAMNEFP@SIGTERM?$AA@
  0030b	48 8b cd	 mov	 rcx, rbp
  0030e	4c 8b c0	 mov	 r8, rax
  00311	48 8b d8	 mov	 rbx, rax
  00314	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1132 :     Py_XDECREF(x);

  00319	48 85 db	 test	 rbx, rbx
  0031c	74 08		 je	 SHORT $LN4@PyInit_sig
  0031e	48 8b cb	 mov	 rcx, rbx
  00321	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@PyInit_sig:

; 1133 : #endif
; 1134 : #ifdef SIGUSR1
; 1135 :     x = PyLong_FromLong(SIGUSR1);
; 1136 :     PyDict_SetItemString(d, "SIGUSR1", x);
; 1137 :     Py_XDECREF(x);
; 1138 : #endif
; 1139 : #ifdef SIGUSR2
; 1140 :     x = PyLong_FromLong(SIGUSR2);
; 1141 :     PyDict_SetItemString(d, "SIGUSR2", x);
; 1142 :     Py_XDECREF(x);
; 1143 : #endif
; 1144 : #ifdef SIGCLD
; 1145 :     x = PyLong_FromLong(SIGCLD);
; 1146 :     PyDict_SetItemString(d, "SIGCLD", x);
; 1147 :     Py_XDECREF(x);
; 1148 : #endif
; 1149 : #ifdef SIGCHLD
; 1150 :     x = PyLong_FromLong(SIGCHLD);
; 1151 :     PyDict_SetItemString(d, "SIGCHLD", x);
; 1152 :     Py_XDECREF(x);
; 1153 : #endif
; 1154 : #ifdef SIGPWR
; 1155 :     x = PyLong_FromLong(SIGPWR);
; 1156 :     PyDict_SetItemString(d, "SIGPWR", x);
; 1157 :     Py_XDECREF(x);
; 1158 : #endif
; 1159 : #ifdef SIGIO
; 1160 :     x = PyLong_FromLong(SIGIO);
; 1161 :     PyDict_SetItemString(d, "SIGIO", x);
; 1162 :     Py_XDECREF(x);
; 1163 : #endif
; 1164 : #ifdef SIGURG
; 1165 :     x = PyLong_FromLong(SIGURG);
; 1166 :     PyDict_SetItemString(d, "SIGURG", x);
; 1167 :     Py_XDECREF(x);
; 1168 : #endif
; 1169 : #ifdef SIGWINCH
; 1170 :     x = PyLong_FromLong(SIGWINCH);
; 1171 :     PyDict_SetItemString(d, "SIGWINCH", x);
; 1172 :     Py_XDECREF(x);
; 1173 : #endif
; 1174 : #ifdef SIGPOLL
; 1175 :     x = PyLong_FromLong(SIGPOLL);
; 1176 :     PyDict_SetItemString(d, "SIGPOLL", x);
; 1177 :     Py_XDECREF(x);
; 1178 : #endif
; 1179 : #ifdef SIGSTOP
; 1180 :     x = PyLong_FromLong(SIGSTOP);
; 1181 :     PyDict_SetItemString(d, "SIGSTOP", x);
; 1182 :     Py_XDECREF(x);
; 1183 : #endif
; 1184 : #ifdef SIGTSTP
; 1185 :     x = PyLong_FromLong(SIGTSTP);
; 1186 :     PyDict_SetItemString(d, "SIGTSTP", x);
; 1187 :     Py_XDECREF(x);
; 1188 : #endif
; 1189 : #ifdef SIGCONT
; 1190 :     x = PyLong_FromLong(SIGCONT);
; 1191 :     PyDict_SetItemString(d, "SIGCONT", x);
; 1192 :     Py_XDECREF(x);
; 1193 : #endif
; 1194 : #ifdef SIGTTIN
; 1195 :     x = PyLong_FromLong(SIGTTIN);
; 1196 :     PyDict_SetItemString(d, "SIGTTIN", x);
; 1197 :     Py_XDECREF(x);
; 1198 : #endif
; 1199 : #ifdef SIGTTOU
; 1200 :     x = PyLong_FromLong(SIGTTOU);
; 1201 :     PyDict_SetItemString(d, "SIGTTOU", x);
; 1202 :     Py_XDECREF(x);
; 1203 : #endif
; 1204 : #ifdef SIGVTALRM
; 1205 :     x = PyLong_FromLong(SIGVTALRM);
; 1206 :     PyDict_SetItemString(d, "SIGVTALRM", x);
; 1207 :     Py_XDECREF(x);
; 1208 : #endif
; 1209 : #ifdef SIGPROF
; 1210 :     x = PyLong_FromLong(SIGPROF);
; 1211 :     PyDict_SetItemString(d, "SIGPROF", x);
; 1212 :     Py_XDECREF(x);
; 1213 : #endif
; 1214 : #ifdef SIGXCPU
; 1215 :     x = PyLong_FromLong(SIGXCPU);
; 1216 :     PyDict_SetItemString(d, "SIGXCPU", x);
; 1217 :     Py_XDECREF(x);
; 1218 : #endif
; 1219 : #ifdef SIGXFSZ
; 1220 :     x = PyLong_FromLong(SIGXFSZ);
; 1221 :     PyDict_SetItemString(d, "SIGXFSZ", x);
; 1222 :     Py_XDECREF(x);
; 1223 : #endif
; 1224 : #ifdef SIGRTMIN
; 1225 :     x = PyLong_FromLong(SIGRTMIN);
; 1226 :     PyDict_SetItemString(d, "SIGRTMIN", x);
; 1227 :     Py_XDECREF(x);
; 1228 : #endif
; 1229 : #ifdef SIGRTMAX
; 1230 :     x = PyLong_FromLong(SIGRTMAX);
; 1231 :     PyDict_SetItemString(d, "SIGRTMAX", x);
; 1232 :     Py_XDECREF(x);
; 1233 : #endif
; 1234 : #ifdef SIGINFO
; 1235 :     x = PyLong_FromLong(SIGINFO);
; 1236 :     PyDict_SetItemString(d, "SIGINFO", x);
; 1237 :     Py_XDECREF(x);
; 1238 : #endif
; 1239 : 
; 1240 : #ifdef ITIMER_REAL
; 1241 :     x = PyLong_FromLong(ITIMER_REAL);
; 1242 :     PyDict_SetItemString(d, "ITIMER_REAL", x);
; 1243 :     Py_DECREF(x);
; 1244 : #endif
; 1245 : #ifdef ITIMER_VIRTUAL
; 1246 :     x = PyLong_FromLong(ITIMER_VIRTUAL);
; 1247 :     PyDict_SetItemString(d, "ITIMER_VIRTUAL", x);
; 1248 :     Py_DECREF(x);
; 1249 : #endif
; 1250 : #ifdef ITIMER_PROF
; 1251 :     x = PyLong_FromLong(ITIMER_PROF);
; 1252 :     PyDict_SetItemString(d, "ITIMER_PROF", x);
; 1253 :     Py_DECREF(x);
; 1254 : #endif
; 1255 : 
; 1256 : #if defined (HAVE_SETITIMER) || defined (HAVE_GETITIMER)
; 1257 :     ItimerError = PyErr_NewException("signal.ItimerError",
; 1258 :      PyExc_IOError, NULL);
; 1259 :     if (ItimerError != NULL)
; 1260 :     PyDict_SetItemString(d, "ItimerError", ItimerError);
; 1261 : #endif
; 1262 : 
; 1263 : #ifdef CTRL_C_EVENT
; 1264 :     x = PyLong_FromLong(CTRL_C_EVENT);

  00326	33 c9		 xor	 ecx, ecx
  00328	e8 00 00 00 00	 call	 PyLong_FromLong

; 1265 :     PyDict_SetItemString(d, "CTRL_C_EVENT", x);

  0032d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@FEFOEFHG@CTRL_C_EVENT?$AA@
  00334	48 8b cd	 mov	 rcx, rbp
  00337	4c 8b c0	 mov	 r8, rax
  0033a	48 8b d8	 mov	 rbx, rax
  0033d	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1266 :     Py_DECREF(x);

  00342	48 8b cb	 mov	 rcx, rbx
  00345	e8 00 00 00 00	 call	 _Py_DecRef

; 1267 : #endif
; 1268 : 
; 1269 : #ifdef CTRL_BREAK_EVENT
; 1270 :     x = PyLong_FromLong(CTRL_BREAK_EVENT);

  0034a	b9 01 00 00 00	 mov	 ecx, 1
  0034f	e8 00 00 00 00	 call	 PyLong_FromLong

; 1271 :     PyDict_SetItemString(d, "CTRL_BREAK_EVENT", x);

  00354	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@ELEIIFAE@CTRL_BREAK_EVENT?$AA@
  0035b	48 8b cd	 mov	 rcx, rbp
  0035e	4c 8b c0	 mov	 r8, rax
  00361	48 8b d8	 mov	 rbx, rax
  00364	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1272 :     Py_DECREF(x);

  00369	48 8b cb	 mov	 rcx, rbx
  0036c	e8 00 00 00 00	 call	 _Py_DecRef

; 1273 : #endif
; 1274 : 
; 1275 : #ifdef MS_WINDOWS
; 1276 :     /* Create manual-reset event, initially unset */
; 1277 :     sigint_event = CreateEvent(NULL, TRUE, FALSE, FALSE);

  00371	45 33 c9	 xor	 r9d, r9d
  00374	45 33 c0	 xor	 r8d, r8d
  00377	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0037b	33 c9		 xor	 ecx, ecx
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  00383	48 89 05 00 00
	00 00		 mov	 QWORD PTR sigint_event, rax

; 1278 : #endif
; 1279 : 
; 1280 :     if (PyErr_Occurred()) {

  0038a	e8 00 00 00 00	 call	 PyErr_Occurred
  0038f	48 85 c0	 test	 rax, rax
  00392	74 0b		 je	 SHORT $LN51@PyInit_sig

; 1281 :         Py_DECREF(m);

  00394	49 8b cc	 mov	 rcx, r12
  00397	e8 00 00 00 00	 call	 _Py_DecRef

; 1282 :         m = NULL;

  0039c	4d 8b e5	 mov	 r12, r13
$LN51@PyInit_sig:
  0039f	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
$LN50@PyInit_sig:
  003a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$finally$120859:

; 1283 :     }
; 1284 : 
; 1285 :   finally:
; 1286 :     return m;

  003a9	49 8b c4	 mov	 rax, r12
  003ac	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1287 : }

  003b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003b5	41 5c		 pop	 r12
  003b7	c3		 ret	 0
PyInit_signal ENDP
_TEXT	ENDS
PUBLIC	PyErr_SetInterrupt
; Function compile flags: /Ogtpy
;	COMDAT PyErr_SetInterrupt
_TEXT	SEGMENT
PyErr_SetInterrupt PROC					; COMDAT

; 1381 :     trip_signal(SIGINT);

  00000	b9 02 00 00 00	 mov	 ecx, 2

; 1382 : }

  00005	e9 00 00 00 00	 jmp	 trip_signal
PyErr_SetInterrupt ENDP
_TEXT	ENDS
END
