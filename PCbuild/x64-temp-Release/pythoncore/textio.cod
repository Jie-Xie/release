; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@DOPNAJOF@_io?4TextIOWrapper?$AA@	; `string'
PUBLIC	??_C@_0M@MCIODJJK@_CHUNK_SIZE?$AA@		; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_0P@MGPKIIND@line_buffering?$AA@		; `string'
PUBLIC	??_C@_06HOHPNJLC@buffer?$AA@			; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_06MDAHGKGM@utf?932?$AA@			; `string'
PUBLIC	??_C@_09ELKEPOEM@utf?932?9le?$AA@		; `string'
PUBLIC	??_C@_09EBDKNDEG@utf?932?9be?$AA@		; `string'
PUBLIC	??_C@_06KEOPHLAG@utf?916?$AA@			; `string'
PUBLIC	??_C@_09PDOMPJIH@utf?916?9le?$AA@		; `string'
PUBLIC	??_C@_09PJHCNEIN@utf?916?9be?$AA@		; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	??_C@_09JAONMJBN@iso8859?91?$AA@		; `string'
PUBLIC	??_C@_05OJENGABA@ascii?$AA@			; `string'
PUBLIC	??_C@_0BO@BGOBMHEI@_io?4IncrementalNewlineDecoder?$AA@ ; `string'
PUBLIC	??_C@_08OINEKLLD@getstate?$AA@			; `string'
PUBLIC	??_C@_0BA@OAEEDFBN@_io?4_TextIOBase?$AA@	; `string'
PUBLIC	??_C@_06EOMHCNPI@errors?$AA@			; `string'
PUBLIC	??_C@_08EGHAIIMO@newlines?$AA@			; `string'
PUBLIC	??_C@_08MLPGAEIK@encoding?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_06CNCOJECB@detach?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_08BJPILIMO@setstate?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_05CFMALAOA@reset?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_05FDBMPOID@read1?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_03DGOGAGNC@raw?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_0BF@EKAJBFOE@getpreferredencoding?$AA@	; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_06KPNAMAEI@decode?$AA@			; `string'
PUBLIC	??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@		; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	PyTextIOBase_Type
PUBLIC	PyIncrementalNewlineDecoder_Type
PUBLIC	PyTextIOWrapper_Type
EXTRN	PyType_GenericNew:PROC
EXTRN	PyIOBase_Type:BYTE
;	COMDAT ??_C@_0BC@DOPNAJOF@_io?4TextIOWrapper?$AA@
CONST	SEGMENT
??_C@_0BC@DOPNAJOF@_io?4TextIOWrapper?$AA@ DB '_io.TextIOWrapper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MCIODJJK@_CHUNK_SIZE?$AA@
CONST	SEGMENT
??_C@_0M@MCIODJJK@_CHUNK_SIZE?$AA@ DB '_CHUNK_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MGPKIIND@line_buffering?$AA@
CONST	SEGMENT
??_C@_0P@MGPKIIND@line_buffering?$AA@ DB 'line_buffering', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HOHPNJLC@buffer?$AA@
CONST	SEGMENT
??_C@_06HOHPNJLC@buffer?$AA@ DB 'buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MDAHGKGM@utf?932?$AA@
CONST	SEGMENT
??_C@_06MDAHGKGM@utf?932?$AA@ DB 'utf-32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ELKEPOEM@utf?932?9le?$AA@
CONST	SEGMENT
??_C@_09ELKEPOEM@utf?932?9le?$AA@ DB 'utf-32-le', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09EBDKNDEG@utf?932?9be?$AA@
CONST	SEGMENT
??_C@_09EBDKNDEG@utf?932?9be?$AA@ DB 'utf-32-be', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KEOPHLAG@utf?916?$AA@
CONST	SEGMENT
??_C@_06KEOPHLAG@utf?916?$AA@ DB 'utf-16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PDOMPJIH@utf?916?9le?$AA@
CONST	SEGMENT
??_C@_09PDOMPJIH@utf?916?9le?$AA@ DB 'utf-16-le', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PJHCNEIN@utf?916?9be?$AA@
CONST	SEGMENT
??_C@_09PJHCNEIN@utf?916?9be?$AA@ DB 'utf-16-be', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JAONMJBN@iso8859?91?$AA@
CONST	SEGMENT
??_C@_09JAONMJBN@iso8859?91?$AA@ DB 'iso8859-1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJENGABA@ascii?$AA@
CONST	SEGMENT
??_C@_05OJENGABA@ascii?$AA@ DB 'ascii', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BGOBMHEI@_io?4IncrementalNewlineDecoder?$AA@
CONST	SEGMENT
??_C@_0BO@BGOBMHEI@_io?4IncrementalNewlineDecoder?$AA@ DB '_io.Incrementa'
	DB	'lNewlineDecoder', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OINEKLLD@getstate?$AA@
CONST	SEGMENT
??_C@_08OINEKLLD@getstate?$AA@ DB 'getstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OAEEDFBN@_io?4_TextIOBase?$AA@
CONST	SEGMENT
??_C@_0BA@OAEEDFBN@_io?4_TextIOBase?$AA@ DB '_io._TextIOBase', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06EOMHCNPI@errors?$AA@
CONST	SEGMENT
??_C@_06EOMHCNPI@errors?$AA@ DB 'errors', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EGHAIIMO@newlines?$AA@
CONST	SEGMENT
??_C@_08EGHAIIMO@newlines?$AA@ DB 'newlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MLPGAEIK@encoding?$AA@
CONST	SEGMENT
??_C@_08MLPGAEIK@encoding?$AA@ DB 'encoding', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CNCOJECB@detach?$AA@
CONST	SEGMENT
??_C@_06CNCOJECB@detach?$AA@ DB 'detach', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
textiobase_doc DB 'Base class for text I/O.', 0aH, 0aH, 'This class provi'
	DB	'des a character and line based interface to stream', 0aH, 'I/'
	DB	'O. There is no readinto method because Python''s character st'
	DB	'rings', 0aH, 'are immutable. There is no public constructor.', 0aH
	DB	00H
	ORG $+15
textiobase_detach_doc DB 'Separate the underlying buffer from the TextIOB'
	DB	'ase and return it.', 0aH, 0aH, 'After the underlying buffer h'
	DB	'as been detached, the TextIO is in an', 0aH, 'unusable state.'
	DB	0aH, 00H
	ORG $+9
textiobase_read_doc DB 'Read at most n characters from stream.', 0aH, 0aH
	DB	'Read from underlying buffer until we have n characters or we '
	DB	'hit EOF.', 0aH, 'If n is negative or omitted, read until EOF.'
	DB	0aH, 00H
	ORG $+4
textiobase_readline_doc DB 'Read until newline or EOF.', 0aH, 0aH, 'Retur'
	DB	'ns an empty string if EOF is hit immediately.', 0aH, 00H
textiobase_write_doc DB 'Write string to stream.', 0aH, 'Returns the numb'
	DB	'er of characters written (which is always equal to', 0aH, 'th'
	DB	'e length of the string).', 0aH, 00H
	ORG $+1
textiobase_encoding_doc DB 'Encoding of the text stream.', 0aH, 0aH, 'Sub'
	DB	'classes should override.', 0aH, 00H
	ORG $+13
textiobase_newlines_doc DB 'Line endings translated so far.', 0aH, 0aH, 'O'
	DB	'nly line endings translated during reading are considered.', 0aH
	DB	0aH, 'Subclasses should override.', 0aH, 00H
	ORG $+5
textiobase_errors_doc DB 'The error setting of the decoder or encoder.', 0aH
	DB	0aH, 'Subclasses should override.', 0aH, 00H
	ORG $+5
textiobase_methods DQ FLAT:??_C@_06CNCOJECB@detach?$AA@
	DQ	FLAT:textiobase_detach
	DD	04H
	ORG $+4
	DQ	FLAT:textiobase_detach_doc
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:textiobase_read
	DD	01H
	ORG $+4
	DQ	FLAT:textiobase_read_doc
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	FLAT:textiobase_readline
	DD	01H
	ORG $+4
	DQ	FLAT:textiobase_readline_doc
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:textiobase_write
	DD	01H
	ORG $+4
	DQ	FLAT:textiobase_write_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
textiobase_getset DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DQ	FLAT:textiobase_encoding_get
	DQ	0000000000000000H
	DQ	FLAT:textiobase_encoding_doc
	ORG $+8
	DQ	FLAT:??_C@_08EGHAIIMO@newlines?$AA@
	DQ	FLAT:textiobase_newlines_get
	DQ	0000000000000000H
	DQ	FLAT:textiobase_newlines_doc
	ORG $+8
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	FLAT:textiobase_errors_get
	DQ	0000000000000000H
	DQ	FLAT:textiobase_errors_doc
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyTextIOBase_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@OAEEDFBN@_io?4_TextIOBase?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:textiobase_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:textiobase_methods
	DQ	0000000000000000H
	DQ	FLAT:textiobase_getset
	DQ	FLAT:PyIOBase_Type
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+72
incrementalnewlinedecoder_doc DB 'Codec used when reading a file in unive'
	DB	'rsal newlines mode.  It wraps', 0aH, 'another incremental dec'
	DB	'oder, translating \r\n and \r into \n.  It also', 0aH, 'recor'
	DB	'ds the types of newlines encountered.  When used with', 0aH, 't'
	DB	'ranslate=False, it ensures that the newline sequence is retur'
	DB	'ned in', 0aH, 'one piece. When used with decoder=None, it exp'
	DB	'ects unicode strings as', 0aH, 'decode input and translates n'
	DB	'ewlines without first invoking an external', 0aH, 'decoder.', 0aH
	DB	00H
	ORG $+12
incrementalnewlinedecoder_methods DQ FLAT:??_C@_06KPNAMAEI@decode?$AA@
	DQ	FLAT:incrementalnewlinedecoder_decode
	DD	03H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08OINEKLLD@getstate?$AA@
	DQ	FLAT:incrementalnewlinedecoder_getstate
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08BJPILIMO@setstate?$AA@
	DQ	FLAT:incrementalnewlinedecoder_setstate
	DD	08H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05CFMALAOA@reset?$AA@
	DQ	FLAT:incrementalnewlinedecoder_reset
	DD	04H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+24
incrementalnewlinedecoder_getset DQ FLAT:??_C@_08EGHAIIMO@newlines?$AA@
	DQ	FLAT:incrementalnewlinedecoder_newlines_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyIncrementalNewlineDecoder_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BO@BGOBMHEI@_io?4IncrementalNewlineDecoder?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:incrementalnewlinedecoder_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:incrementalnewlinedecoder_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:incrementalnewlinedecoder_methods
	DQ	0000000000000000H
	DQ	FLAT:incrementalnewlinedecoder_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:incrementalnewlinedecoder_init
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericNew
	ORG $+72
textiowrapper_doc DB 'Character and line based layer over a BufferedIOBas'
	DB	'e object, buffer.', 0aH, 0aH, 'encoding gives the name of the'
	DB	' encoding that the stream will be', 0aH, 'decoded or encoded '
	DB	'with. It defaults to locale.getpreferredencoding(False).', 0aH
	DB	0aH, 'errors determines the strictness of encoding and decodin'
	DB	'g (see', 0aH, 'help(codecs.Codec) or the documentation for co'
	DB	'decs.register) and', 0aH, 'defaults to "strict".', 0aH, 0aH, 'n'
	DB	'ewline controls how line endings are handled. It can be None,'
	DB	' '''',', 0aH, '''\n'', ''\r'', and ''\r\n''.  It works as fol'
	DB	'lows:', 0aH, 0aH, '* On input, if newline is None, universal '
	DB	'newlines mode is', 0aH, '  enabled. Lines in the input can en'
	DB	'd in ''\n'', ''\r'', or ''\r\n'', and', 0aH, '  these are tra'
	DB	'nslated into ''\n'' before being returned to the', 0aH, '  ca'
	DB	'ller. If it is '''', universal newline mode is enabled, but l'
	DB	'ine', 0aH, '  endings are returned to the caller untranslated'
	DB	'. If it has any of', 0aH, '  the other legal values, input li'
	DB	'nes are only terminated by the given', 0aH, '  string, and th'
	DB	'e line ending is returned to the caller untranslated.', 0aH, 0aH
	DB	'* On output, if newline is None, any ''\n'' characters writte'
	DB	'n are', 0aH, '  translated to the system default line separat'
	DB	'or, os.linesep. If', 0aH, '  newline is '''' or ''\n'', no tr'
	DB	'anslation takes place. If newline is any', 0aH, '  of the oth'
	DB	'er legal values, any ''\n'' characters written are translated'
	DB	0aH, '  to the given string.', 0aH, 0aH, 'If line_buffering is'
	DB	' True, a call to flush is implied when a call to', 0aH, 'writ'
	DB	'e contains a newline character.', 00H
	ORG $+15
encodefuncs DQ	FLAT:??_C@_05OJENGABA@ascii?$AA@
	DQ	FLAT:ascii_encode
	DQ	FLAT:??_C@_09JAONMJBN@iso8859?91?$AA@
	DQ	FLAT:latin1_encode
	DQ	FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
	DQ	FLAT:utf8_encode
	DQ	FLAT:??_C@_09PJHCNEIN@utf?916?9be?$AA@
	DQ	FLAT:utf16be_encode
	DQ	FLAT:??_C@_09PDOMPJIH@utf?916?9le?$AA@
	DQ	FLAT:utf16le_encode
	DQ	FLAT:??_C@_06KEOPHLAG@utf?916?$AA@
	DQ	FLAT:utf16_encode
	DQ	FLAT:??_C@_09EBDKNDEG@utf?932?9be?$AA@
	DQ	FLAT:utf32be_encode
	DQ	FLAT:??_C@_09ELKEPOEM@utf?932?9le?$AA@
	DQ	FLAT:utf32le_encode
	DQ	FLAT:??_C@_06MDAHGKGM@utf?932?$AA@
	DQ	FLAT:utf32_encode
	DQ	0000000000000000H
	DQ	0000000000000000H
textiowrapper_methods DQ FLAT:??_C@_06CNCOJECB@detach?$AA@
	DQ	FLAT:textiowrapper_detach
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:textiowrapper_write
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:textiowrapper_read
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	FLAT:textiowrapper_readline
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	FLAT:textiowrapper_flush
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:textiowrapper_close
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	FLAT:textiowrapper_fileno
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	FLAT:textiowrapper_seekable
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	FLAT:textiowrapper_readable
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	FLAT:textiowrapper_writable
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:textiowrapper_isatty
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	FLAT:textiowrapper_getstate
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:textiowrapper_seek
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:textiowrapper_tell
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MABILMFG@truncate?$AA@
	DQ	FLAT:textiowrapper_truncate
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
textiowrapper_members DQ FLAT:??_C@_08MLPGAEIK@encoding?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06HOHPNJLC@buffer?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0P@MGPKIIND@line_buffering?$AA@
	DD	0eH
	ORG $+4
	DQ	00000000000000a8H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
textiowrapper_getset DQ FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:textiowrapper_name_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:textiowrapper_closed_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_08EGHAIIMO@newlines?$AA@
	DQ	FLAT:textiowrapper_newlines_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06EOMHCNPI@errors?$AA@
	DQ	FLAT:textiowrapper_errors_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@MCIODJJK@_CHUNK_SIZE?$AA@
	DQ	FLAT:textiowrapper_chunk_size_get
	DQ	FLAT:textiowrapper_chunk_size_set
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyTextIOWrapper_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@DOPNAJOF@_io?4TextIOWrapper?$AA@
	DQ	0000000000000110H
	DQ	0000000000000000H
	DQ	FLAT:textiowrapper_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:textiowrapper_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:textiowrapper_doc
	DQ	FLAT:textiowrapper_traverse
	DQ	FLAT:textiowrapper_clear
	DQ	0000000000000000H
	DQ	0000000000000100H
	DQ	0000000000000000H
	DQ	FLAT:textiowrapper_iternext
	DQ	FLAT:textiowrapper_methods
	DQ	FLAT:textiowrapper_members
	DQ	FLAT:textiowrapper_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000108H
	DQ	FLAT:textiowrapper_init
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericNew
	ORG $+72
_DATA	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJPILIMO@setstate?$AA@
CONST	SEGMENT
??_C@_08BJPILIMO@setstate?$AA@ DB 'setstate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFMALAOA@reset?$AA@
CONST	SEGMENT
??_C@_05CFMALAOA@reset?$AA@ DB 'reset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDBMPOID@read1?$AA@
CONST	SEGMENT
??_C@_05FDBMPOID@read1?$AA@ DB 'read1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DGOGAGNC@raw?$AA@
CONST	SEGMENT
??_C@_03DGOGAGNC@raw?$AA@ DB 'raw', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EKAJBFOE@getpreferredencoding?$AA@
CONST	SEGMENT
??_C@_0BF@EKAJBFOE@getpreferredencoding?$AA@ DB 'getpreferredencoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KPNAMAEI@decode?$AA@
CONST	SEGMENT
??_C@_06KPNAMAEI@decode?$AA@ DB 'decode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
CONST	SEGMENT
??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@ DB '_dealloc_warn', 00H ; `string'
CONST	ENDS
_TLS	SEGMENT
PyId_setstate DQ 0000000000000000H
	DQ	FLAT:??_C@_08BJPILIMO@setstate?$AA@
	DQ	0000000000000000H
PyId_flush DQ	0000000000000000H
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	0000000000000000H
PyId_decode DQ	0000000000000000H
	DQ	FLAT:??_C@_06KPNAMAEI@decode?$AA@
	DQ	0000000000000000H
PyId_name DQ	0000000000000000H
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	0000000000000000H
PyId_writable DQ 0000000000000000H
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	0000000000000000H
PyId_tell DQ	0000000000000000H
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	0000000000000000H
PyId_seekable DQ 0000000000000000H
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	0000000000000000H
PyId_reset DQ	0000000000000000H
	DQ	FLAT:??_C@_05CFMALAOA@reset?$AA@
	DQ	0000000000000000H
PyId_readable DQ 0000000000000000H
	DQ	FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	0000000000000000H
PyId_read DQ	0000000000000000H
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	0000000000000000H
PyId_fileno DQ	0000000000000000H
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	0000000000000000H
PyId_seek DQ	0000000000000000H
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	0000000000000000H
PyId_replace DQ	0000000000000000H
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	0000000000000000H
PyId_read1 DQ	0000000000000000H
	DQ	FLAT:??_C@_05FDBMPOID@read1?$AA@
	DQ	0000000000000000H
PyId_raw DQ	0000000000000000H
	DQ	FLAT:??_C@_03DGOGAGNC@raw?$AA@
	DQ	0000000000000000H
PyId_mode DQ	0000000000000000H
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	0000000000000000H
PyId_isatty DQ	0000000000000000H
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	0000000000000000H
PyId_getpreferredencoding DQ 0000000000000000H
	DQ	FLAT:??_C@_0BF@EKAJBFOE@getpreferredencoding?$AA@
	DQ	0000000000000000H
PyId__dealloc_warn DQ 0000000000000000H
	DQ	FLAT:??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
	DQ	0000000000000000H
PyId_close DQ	0000000000000000H
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyErr_SetString:PROC
EXTRN	PyModule_GetState:PROC
EXTRN	PyState_FindModule:PROC
EXTRN	_PyIO_Module:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\textio.c
pdata	SEGMENT
$pdata$_unsupported DD imagerel _unsupported
	DD	imagerel _unsupported+49
	DD	imagerel $unwind$_unsupported
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_unsupported DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _unsupported
_TEXT	SEGMENT
message$ = 48
_unsupported PROC					; COMDAT

; 47   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 48   :     PyErr_SetString(IO_STATE->unsupported_operation, message);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyIO_Module
  00010	e8 00 00 00 00	 call	 PyState_FindModule
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	48 8b d3	 mov	 rdx, rbx
  00020	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 49   :     return NULL;

  00029	33 c0		 xor	 eax, eax

; 50   : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
_unsupported ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT textiobase_detach
_TEXT	SEGMENT
self$ = 8
textiobase_detach PROC					; COMDAT

; 62   :     return _unsupported("detach");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CNCOJECB@detach?$AA@

; 63   : }

  00007	e9 00 00 00 00	 jmp	 _unsupported
textiobase_detach ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT textiobase_read
_TEXT	SEGMENT
self$ = 8
args$ = 16
textiobase_read PROC					; COMDAT

; 75   :     return _unsupported("read");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04POLDLDMI@read?$AA@

; 76   : }

  00007	e9 00 00 00 00	 jmp	 _unsupported
textiobase_read ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT textiobase_readline
_TEXT	SEGMENT
self$ = 8
args$ = 16
textiobase_readline PROC				; COMDAT

; 87   :     return _unsupported("readline");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KBCDPPMN@readline?$AA@

; 88   : }

  00007	e9 00 00 00 00	 jmp	 _unsupported
textiobase_readline ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT textiobase_write
_TEXT	SEGMENT
self$ = 8
args$ = 16
textiobase_write PROC					; COMDAT

; 99   :     return _unsupported("write");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05NGFEDHGN@write?$AA@

; 100  : }

  00007	e9 00 00 00 00	 jmp	 _unsupported
textiobase_write ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiobase_encoding_get DD imagerel textiobase_encoding_get
	DD	imagerel textiobase_encoding_get+100
	DD	imagerel $unwind$textiobase_encoding_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiobase_encoding_get DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
xdata	ENDS
;	COMDAT textiobase_encoding_get
_TEXT	SEGMENT
self$ = 64
context$ = 72
textiobase_encoding_get PROC				; COMDAT

; 110  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 111  :     Py_RETURN_NONE;

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	75 48		 jne	 SHORT $LN7@textiobase
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00024	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN3@textiobase
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN9@textiobase
$LN3@textiobase:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@textiobase:
  0004e	48 8b c3	 mov	 rax, rbx

; 112  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@textiobase:

; 111  :     Py_RETURN_NONE;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 112  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
textiobase_encoding_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiobase_newlines_get DD imagerel textiobase_newlines_get
	DD	imagerel textiobase_newlines_get+100
	DD	imagerel $unwind$textiobase_newlines_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiobase_newlines_get DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
xdata	ENDS
;	COMDAT textiobase_newlines_get
_TEXT	SEGMENT
self$ = 64
context$ = 72
textiobase_newlines_get PROC				; COMDAT

; 124  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 125  :     Py_RETURN_NONE;

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	75 48		 jne	 SHORT $LN7@textiobase@2
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00024	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN3@textiobase@2
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN9@textiobase@2
$LN3@textiobase@2:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@textiobase@2:
  0004e	48 8b c3	 mov	 rax, rbx

; 126  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@textiobase@2:

; 125  :     Py_RETURN_NONE;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 126  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
textiobase_newlines_get ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiobase_errors_get DD imagerel textiobase_errors_get
	DD	imagerel textiobase_errors_get+100
	DD	imagerel $unwind$textiobase_errors_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiobase_errors_get DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
xdata	ENDS
;	COMDAT textiobase_errors_get
_TEXT	SEGMENT
self$ = 64
context$ = 72
textiobase_errors_get PROC				; COMDAT

; 136  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 137  :     Py_RETURN_NONE;

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	75 48		 jne	 SHORT $LN7@textiobase@3
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00024	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN3@textiobase@3
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN9@textiobase@3
$LN3@textiobase@3:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@textiobase@3:
  0004e	48 8b c3	 mov	 rax, rbx

; 138  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@textiobase@3:

; 137  :     Py_RETURN_NONE;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 138  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
textiobase_errors_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_0BP@IMCBOKEG@Oi?$HMO?3IncrementalNewlineDecoder?$AA@ ; `string'
PUBLIC	??_C@_09ODNGOEIO@translate?$AA@			; `string'
PUBLIC	??_C@_07GFKBACBG@decoder?$AA@			; `string'
EXTRN	PyUnicode_FromString:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_init DD imagerel incrementalnewlinedecoder_init
	DD	imagerel incrementalnewlinedecoder_init+119
	DD	imagerel $unwind$incrementalnewlinedecoder_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$incrementalnewlinedecoder_init DD imagerel incrementalnewlinedecoder_init+119
	DD	imagerel incrementalnewlinedecoder_init+243
	DD	imagerel $chain$0$incrementalnewlinedecoder_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$incrementalnewlinedecoder_init DD imagerel incrementalnewlinedecoder_init+243
	DD	imagerel incrementalnewlinedecoder_init+350
	DD	imagerel $chain$2$incrementalnewlinedecoder_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$incrementalnewlinedecoder_init DD 020021H
	DD	0103400H
	DD	imagerel incrementalnewlinedecoder_init
	DD	imagerel incrementalnewlinedecoder_init+119
	DD	imagerel $unwind$incrementalnewlinedecoder_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$incrementalnewlinedecoder_init DD 020821H
	DD	0103408H
	DD	imagerel incrementalnewlinedecoder_init
	DD	imagerel incrementalnewlinedecoder_init+119
	DD	imagerel $unwind$incrementalnewlinedecoder_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_init DD 020801H
	DD	07004d208H
xdata	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IMCBOKEG@Oi?$HMO?3IncrementalNewlineDecoder?$AA@
CONST	SEGMENT
??_C@_0BP@IMCBOKEG@Oi?$HMO?3IncrementalNewlineDecoder?$AA@ DB 'Oi|O:Incre'
	DB	'mentalNewlineDecoder', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODNGOEIO@translate?$AA@
CONST	SEGMENT
??_C@_09ODNGOEIO@translate?$AA@ DB 'translate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFKBACBG@decoder?$AA@
CONST	SEGMENT
??_C@_07GFKBACBG@decoder?$AA@ DB 'decoder', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_init
_TEXT	SEGMENT
errors$ = 64
decoder$ = 72
self$ = 128
args$ = 136
kwds$ = 144
translate$ = 152
incrementalnewlinedecoder_init PROC			; COMDAT

; 222  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00008	48 8b f9	 mov	 rdi, rcx
  0000b	4c 8b d2	 mov	 r10, rdx

; 223  :     PyObject *decoder;
; 224  :     int translate;
; 225  :     PyObject *errors = NULL;

  0000e	33 d2		 xor	 edx, edx

; 226  :     char *kwlist[] = {"decoder", "translate", "errors", NULL};

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07GFKBACBG@decoder?$AA@
  00017	49 8b c0	 mov	 rax, r8
  0001a	49 89 53 c8	 mov	 QWORD PTR [r11-56], rdx
  0001e	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09ODNGOEIO@translate?$AA@
  00029	49 89 53 f0	 mov	 QWORD PTR [r11-16], rdx
  0002d	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EOMHCNPI@errors?$AA@

; 227  : 
; 228  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi|O:IncrementalNewlineDecoder",
; 229  :                                      kwlist, &decoder, &translate, &errors))

  00038	4d 8d 4b d8	 lea	 r9, QWORD PTR [r11-40]
  0003c	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx
  00040	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IMCBOKEG@Oi?$HMO?3IncrementalNewlineDecoder?$AA@
  0004b	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0004f	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0005a	49 8d 4b d0	 lea	 rcx, QWORD PTR [r11-48]
  0005e	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00062	49 8b ca	 mov	 rcx, r10
  00065	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006a	85 c0		 test	 eax, eax
  0006c	75 09		 jne	 SHORT $LN4@incrementa

; 230  :         return -1;

  0006e	83 c8 ff	 or	 eax, -1

; 250  : }

  00071	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
$LN4@incrementa:
  00077	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx

; 231  : 
; 232  :     self->decoder = decoder;

  0007f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR decoder$[rsp]
  00084	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx

; 233  :     Py_INCREF(decoder);

  00088	e8 00 00 00 00	 call	 _Py_PXCTX
  0008d	85 c0		 test	 eax, eax
  0008f	75 32		 jne	 SHORT $LN8@incrementa
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009f	4c 8b cb	 mov	 r9, rbx
  000a2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b5	85 c0		 test	 eax, eax
  000b7	75 06		 jne	 SHORT $LN7@incrementa
  000b9	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bd	74 04		 je	 SHORT $LN8@incrementa
$LN7@incrementa:
  000bf	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@incrementa:

; 234  : 
; 235  :     if (errors == NULL) {

  000c3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR errors$[rsp]
  000c8	48 85 db	 test	 rbx, rbx
  000cb	75 26		 jne	 SHORT $LN3@incrementa

; 236  :         self->errors = PyUnicode_FromString("strict");

  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  000d4	e8 00 00 00 00	 call	 PyUnicode_FromString
  000d9	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax

; 237  :         if (self->errors == NULL)

  000dd	48 85 c0	 test	 rax, rax
  000e0	75 55		 jne	 SHORT $LN1@incrementa

; 238  :             return -1;

  000e2	83 c8 ff	 or	 eax, -1
  000e5	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 250  : }

  000ed	48 83 c4 70	 add	 rsp, 112		; 00000070H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
$LN3@incrementa:

; 239  :     }
; 240  :     else {
; 241  :         Py_INCREF(errors);

  000f3	e8 00 00 00 00	 call	 _Py_PXCTX
  000f8	85 c0		 test	 eax, eax
  000fa	75 32		 jne	 SHORT $LN12@incrementa
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010a	4c 8b cb	 mov	 r9, rbx
  0010d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00113	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0011b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00120	85 c0		 test	 eax, eax
  00122	75 06		 jne	 SHORT $LN11@incrementa
  00124	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00128	74 04		 je	 SHORT $LN12@incrementa
$LN11@incrementa:
  0012a	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@incrementa:

; 242  :         self->errors = errors;

  0012e	48 8b 44 24 40	 mov	 rax, QWORD PTR errors$[rsp]
  00133	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
$LN1@incrementa:

; 243  :     }
; 244  : 
; 245  :     self->translate = translate;
; 246  :     self->seennl = 0;
; 247  :     self->pendingcr = 0;

  00137	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0013a	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR translate$[rsp]
  00141	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00149	83 e1 01	 and	 ecx, 1
  0014c	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  0014f	03 c9		 add	 ecx, ecx
  00151	0b c8		 or	 ecx, eax

; 248  : 
; 249  :     return 0;

  00153	33 c0		 xor	 eax, eax
  00155	89 4f 70	 mov	 DWORD PTR [rdi+112], ecx

; 250  : }

  00158	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0015c	5f		 pop	 rdi
  0015d	c3		 ret	 0
incrementalnewlinedecoder_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@HOFOFKBF@incrementalnewlinedecoder_deallo@ ; `string'
PUBLIC	??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_dealloc DD imagerel incrementalnewlinedecoder_dealloc
	DD	imagerel incrementalnewlinedecoder_dealloc+363
	DD	imagerel $unwind$incrementalnewlinedecoder_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CC@HOFOFKBF@incrementalnewlinedecoder_deallo@
CONST	SEGMENT
??_C@_0CC@HOFOFKBF@incrementalnewlinedecoder_deallo@ DB 'incrementalnewli'
	DB	'nedecoder_dealloc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
CONST	SEGMENT
??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@ DB '..\Modules\_io\'
	DB	'textio.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_dealloc
_TEXT	SEGMENT
self$ = 64
incrementalnewlinedecoder_dealloc PROC			; COMDAT

; 254  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 255  :     Py_CLEAR(self->decoder);

  0000a	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	4d 85 c9	 test	 r9, r9
  00014	0f 84 96 00 00
	00		 je	 $LN7@incrementa@2
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@HOFOFKBF@incrementalnewlinedecoder_deallo@
  00028	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  0002e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 71		 jne	 SHORT $LN7@incrementa@2
  0003f	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00043	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 5c		 jne	 SHORT $LN7@incrementa@2
  00054	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00058	a8 20		 test	 al, 32			; 00000020H
  0005a	75 4c		 jne	 SHORT $LN15@incrementa@2
  0005c	84 c0		 test	 al, al
  0005e	78 48		 js	 SHORT $LN15@incrementa@2
  00060	a8 02		 test	 al, 2
  00062	75 4c		 jne	 SHORT $LN7@incrementa@2
  00064	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00068	75 46		 jne	 SHORT $LN7@incrementa@2
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00081	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	85 c0		 test	 eax, eax
  00093	74 07		 je	 SHORT $LN20@incrementa@2
  00095	e8 00 00 00 00	 call	 _Px_Dealloc
  0009a	eb 14		 jmp	 SHORT $LN7@incrementa@2
$LN20@incrementa@2:
  0009c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a6	eb 08		 jmp	 SHORT $LN7@incrementa@2
$LN15@incrementa@2:
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 Px_DecRef
$LN7@incrementa@2:

; 256  :     Py_CLEAR(self->errors);

  000b0	4c 8b 4f 68	 mov	 r9, QWORD PTR [rdi+104]
  000b4	4d 85 c9	 test	 r9, r9
  000b7	0f 84 96 00 00
	00		 je	 $LN3@incrementa@2
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@HOFOFKBF@incrementalnewlinedecoder_deallo@
  000cb	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	75 71		 jne	 SHORT $LN3@incrementa@2
  000e2	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000e6	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
  000ee	e8 00 00 00 00	 call	 _Py_PXCTX
  000f3	85 c0		 test	 eax, eax
  000f5	75 5c		 jne	 SHORT $LN3@incrementa@2
  000f7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000fb	a8 20		 test	 al, 32			; 00000020H
  000fd	75 4c		 jne	 SHORT $LN26@incrementa@2
  000ff	84 c0		 test	 al, al
  00101	78 48		 js	 SHORT $LN26@incrementa@2
  00103	a8 02		 test	 al, 2
  00105	75 4c		 jne	 SHORT $LN3@incrementa@2
  00107	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010b	75 46		 jne	 SHORT $LN3@incrementa@2
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011b	4c 8b cb	 mov	 r9, rbx
  0011e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00124	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00131	48 8b cb	 mov	 rcx, rbx
  00134	85 c0		 test	 eax, eax
  00136	74 07		 je	 SHORT $LN31@incrementa@2
  00138	e8 00 00 00 00	 call	 _Px_Dealloc
  0013d	eb 14		 jmp	 SHORT $LN3@incrementa@2
$LN31@incrementa@2:
  0013f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00143	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00149	eb 08		 jmp	 SHORT $LN3@incrementa@2
$LN26@incrementa@2:
  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@incrementa@2:

; 257  :     Py_TYPE(self)->tp_free((PyObject *)self);

  00153	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00157	48 8b cf	 mov	 rcx, rdi

; 258  : }

  0015a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0015f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00163	5f		 pop	 rdi
  00164	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
incrementalnewlinedecoder_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@IMGGMCHO@decoder?5should?5return?5a?5string?5r@ ; `string'
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_decoded DD imagerel check_decoded
	DD	imagerel check_decoded+94
	DD	imagerel $unwind$check_decoded
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_decoded DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DE@IMGGMCHO@decoder?5should?5return?5a?5string?5r@
CONST	SEGMENT
??_C@_0DE@IMGGMCHO@decoder?5should?5return?5a?5string?5r@ DB 'decoder sho'
	DB	'uld return a string result, not ''%.200s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_decoded
_TEXT	SEGMENT
decoded$ = 48
check_decoded PROC					; COMDAT

; 262  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 263  :     if (decoded == NULL)

  00009	48 85 c9	 test	 rcx, rcx

; 264  :         return -1;

  0000c	74 30		 je	 SHORT $LN8@check_deco

; 265  :     if (!PyUnicode_Check(decoded)) {

  0000e	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00012	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  0001d	75 28		 jne	 SHORT $LN2@check_deco

; 266  :         PyErr_Format(PyExc_TypeError,
; 267  :                      "decoder should return a string result, not '%.200s'",
; 268  :                      Py_TYPE(decoded)->tp_name);

  0001f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@IMGGMCHO@decoder?5should?5return?5a?5string?5r@
  00031	e8 00 00 00 00	 call	 PyErr_Format
$LN9@check_deco:

; 269  :         Py_DECREF(decoded);

  00036	48 8b cb	 mov	 rcx, rbx
  00039	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@check_deco:

; 270  :         return -1;

  0003e	83 c8 ff	 or	 eax, -1

; 277  : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN2@check_deco:

; 271  :     }
; 272  :     if (PyUnicode_READY(decoded) < 0) {

  00047	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0004b	75 09		 jne	 SHORT $LN1@check_deco
  0004d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00052	85 c0		 test	 eax, eax

; 273  :         Py_DECREF(decoded);
; 274  :         return -1;

  00054	78 e0		 js	 SHORT $LN9@check_deco
$LN1@check_deco:

; 275  :     }
; 276  :     return 0;

  00056	33 c0		 xor	 eax, eax

; 277  : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
check_decoded ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@PGPMIJF@IncrementalNewlineDecoder?4__init@ ; `string'
PUBLIC	_PyIncrementalNewlineDecoder_decode
EXTRN	PyMem_Free:PROC
EXTRN	PyUnicode_FromKindAndData:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	__imp_memchr:PROC
EXTRN	PyUnicode_Substring:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	PyObject_CallMethodObjArgs:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_PyIO_str_decode:QWORD
EXTRN	_Py_TrueStruct:BYTE
EXTRN	PyExc_ValueError:QWORD
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyIncrementalNewlineDecoder_decode DD imagerel $LN205
	DD	imagerel $LN205+66
	DD	imagerel $unwind$_PyIncrementalNewlineDecoder_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyIncrementalNewlineDecoder_decode DD imagerel $LN205+66
	DD	imagerel $LN205+213
	DD	imagerel $chain$0$_PyIncrementalNewlineDecoder_decode
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyIncrementalNewlineDecoder_decode DD imagerel $LN205+213
	DD	imagerel $LN205+1698
	DD	imagerel $chain$6$_PyIncrementalNewlineDecoder_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyIncrementalNewlineDecoder_decode DD 0a1d21H
	DD	06e41dH
	DD	07c418H
	DD	0e7413H
	DD	0d640aH
	DD	0c3400H
	DD	imagerel $LN205
	DD	imagerel $LN205+66
	DD	imagerel $unwind$_PyIncrementalNewlineDecoder_decode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyIncrementalNewlineDecoder_decode DD 020521H
	DD	0c3405H
	DD	imagerel $LN205
	DD	imagerel $LN205+66
	DD	imagerel $unwind$_PyIncrementalNewlineDecoder_decode
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyIncrementalNewlineDecoder_decode DD 040a01H
	DD	0f006720aH
	DD	05002d004H
xdata	ENDS
;	COMDAT ??_C@_0CO@PGPMIJF@IncrementalNewlineDecoder?4__init@
CONST	SEGMENT
??_C@_0CO@PGPMIJF@IncrementalNewlineDecoder?4__init@ DB 'IncrementalNewli'
	DB	'neDecoder.__init__ not called', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT _PyIncrementalNewlineDecoder_decode
_TEXT	SEGMENT
myself$ = 96
input$ = 104
final$ = 112
_PyIncrementalNewlineDecoder_decode PROC		; COMDAT

; 287  : {

$LN205:
  00000	40 55		 push	 rbp
  00002	41 55		 push	 r13
  00004	41 57		 push	 r15
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	4c 8b f9	 mov	 r15, rcx

; 288  :     PyObject *output;
; 289  :     Py_ssize_t output_len;
; 290  :     nldecoder_object *self = (nldecoder_object *) myself;
; 291  : 
; 292  :     if (self->decoder == NULL) {

  0000d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00011	41 8b e8	 mov	 ebp, r8d
  00014	4c 8b ea	 mov	 r13, rdx
  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 1f		 jne	 SHORT $LN89@PyIncremen

; 293  :         PyErr_SetString(PyExc_ValueError,
; 294  :                         "IncrementalNewlineDecoder.__init__ not called");

  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@PGPMIJF@IncrementalNewlineDecoder?4__init@
  0002a	e8 00 00 00 00	 call	 PyErr_SetString

; 295  :         return NULL;

  0002f	33 c0		 xor	 eax, eax

; 483  : }

  00031	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00035	41 5f		 pop	 r15
  00037	41 5d		 pop	 r13
  00039	5d		 pop	 rbp
  0003a	c3		 ret	 0
$LN89@PyIncremen:

; 296  :     }
; 297  : 
; 298  :     /* decode input (with the eventual \r from a previous pass) */
; 299  :     if (self->decoder != Py_None) {

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00042	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00047	33 db		 xor	 ebx, ebx
  00049	48 3b c8	 cmp	 rcx, rax
  0004c	74 2e		 je	 SHORT $LN88@PyIncremen

; 300  :         output = PyObject_CallMethodObjArgs(self->decoder,
; 301  :             _PyIO_str_decode, input, final ? Py_True : Py_False, NULL);

  0004e	45 85 c0	 test	 r8d, r8d
  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00058	4c 8b c2	 mov	 r8, rdx
  0005b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_decode
  00062	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00069	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0006e	4c 0f 45 c8	 cmovne	 r9, rax
  00072	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  00077	4c 8b e8	 mov	 r13, rax

; 302  :     }
; 303  :     else {

  0007a	eb 3c		 jmp	 SHORT $LN169@PyIncremen
$LN88@PyIncremen:

; 304  :         output = input;
; 305  :         Py_INCREF(output);

  0007c	e8 00 00 00 00	 call	 _Py_PXCTX
  00081	85 c0		 test	 eax, eax
  00083	75 33		 jne	 SHORT $LN169@PyIncremen
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00093	4d 8b cd	 mov	 r9, r13
  00096	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a9	85 c0		 test	 eax, eax
  000ab	75 07		 jne	 SHORT $LN168@PyIncremen
  000ad	41 f6 45 20 20	 test	 BYTE PTR [r13+32], 32	; 00000020H
  000b2	74 04		 je	 SHORT $LN169@PyIncremen
$LN168@PyIncremen:
  000b4	49 ff 45 50	 inc	 QWORD PTR [r13+80]
$LN169@PyIncremen:

; 306  :     }
; 307  : 
; 308  :     if (check_decoded(output) < 0)

  000b8	49 8b cd	 mov	 rcx, r13
  000bb	e8 00 00 00 00	 call	 check_decoded
  000c0	85 c0		 test	 eax, eax
  000c2	79 11		 jns	 SHORT $LN86@PyIncremen

; 309  :         return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 483  : }

  000cb	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000cf	41 5f		 pop	 r15
  000d1	41 5d		 pop	 r13
  000d3	5d		 pop	 rbp
  000d4	c3		 ret	 0
$LN86@PyIncremen:

; 310  : 
; 311  :     output_len = PyUnicode_GET_LENGTH(output);
; 312  :     if (self->pendingcr && (final || output_len > 0)) {

  000d5	41 f6 47 70 01	 test	 BYTE PTR [r15+112], 1
  000da	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  000df	49 8b 75 60	 mov	 rsi, QWORD PTR [r13+96]
  000e3	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  000e8	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  000ed	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  000f2	41 be 0d 00 00
	00		 mov	 r14d, 13
  000f8	0f 84 5c 01 00
	00		 je	 $LN85@PyIncremen
  000fe	85 ed		 test	 ebp, ebp
  00100	75 09		 jne	 SHORT $LN84@PyIncremen
  00102	48 85 f6	 test	 rsi, rsi
  00105	0f 8e 30 02 00
	00		 jle	 $LN73@PyIncremen
$LN84@PyIncremen:

; 313  :         /* Prefix output with CR */
; 314  :         int kind;
; 315  :         PyObject *modified;
; 316  :         char *out;
; 317  : 
; 318  :         modified = PyUnicode_New(output_len + 1,
; 319  :                                  PyUnicode_MAX_CHAR_VALUE(output));

  0010b	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  0010f	a8 40		 test	 al, 64			; 00000040H
  00111	74 07		 je	 SHORT $LN94@PyIncremen
  00113	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00118	eb 22		 jmp	 SHORT $LN93@PyIncremen
$LN94@PyIncremen:
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	83 e0 07	 and	 eax, 7
  00120	83 f8 01	 cmp	 eax, 1
  00123	75 07		 jne	 SHORT $LN92@PyIncremen
  00125	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0012a	eb 10		 jmp	 SHORT $LN93@PyIncremen
$LN92@PyIncremen:
  0012c	ba ff ff 10 00	 mov	 edx, 1114111		; 0010ffffH
  00131	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00136	83 f8 02	 cmp	 eax, 2
  00139	0f 44 d1	 cmove	 edx, ecx
$LN93@PyIncremen:
  0013c	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00140	e8 00 00 00 00	 call	 PyUnicode_New
  00145	48 8b f8	 mov	 rdi, rax

; 320  :         if (modified == NULL)

  00148	48 85 c0	 test	 rax, rax
  0014b	0f 84 e3 03 00
	00		 je	 $error$20588

; 321  :             goto error;
; 322  :         kind = PyUnicode_KIND(modified);

  00151	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  00154	44 8b c1	 mov	 r8d, ecx
  00157	41 c1 e8 02	 shr	 r8d, 2
  0015b	41 83 e0 07	 and	 r8d, 7

; 323  :         out = PyUnicode_DATA(modified);

  0015f	f6 c1 20	 test	 cl, 32			; 00000020H
  00162	74 17		 je	 SHORT $LN98@PyIncremen
  00164	f6 c1 40	 test	 cl, 64			; 00000040H
  00167	74 09		 je	 SHORT $LN96@PyIncremen
  00169	4c 8d 88 80 00
	00 00		 lea	 r9, QWORD PTR [rax+128]
  00170	eb 10		 jmp	 SHORT $LN99@PyIncremen
$LN96@PyIncremen:
  00172	4c 8d 88 a0 00
	00 00		 lea	 r9, QWORD PTR [rax+160]
  00179	eb 07		 jmp	 SHORT $LN99@PyIncremen
$LN98@PyIncremen:
  0017b	4c 8b 88 a0 00
	00 00		 mov	 r9, QWORD PTR [rax+160]
$LN99@PyIncremen:

; 324  :         PyUnicode_WRITE(kind, PyUnicode_DATA(modified), 0, '\r');

  00182	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00185	41 8b c8	 mov	 ecx, r8d
  00188	ff c9		 dec	 ecx
  0018a	74 5f		 je	 SHORT $LN77@PyIncremen
  0018c	ff c9		 dec	 ecx
  0018e	74 2c		 je	 SHORT $LN76@PyIncremen
  00190	a8 20		 test	 al, 32			; 00000020H
  00192	74 1c		 je	 SHORT $LN110@PyIncremen
  00194	a8 40		 test	 al, 64			; 00000040H
  00196	74 0c		 je	 SHORT $LN108@PyIncremen
  00198	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  0019f	44 89 30	 mov	 DWORD PTR [rax], r14d
  001a2	eb 6b		 jmp	 SHORT $LN81@PyIncremen
$LN108@PyIncremen:
  001a4	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  001ab	44 89 30	 mov	 DWORD PTR [rax], r14d
  001ae	eb 5f		 jmp	 SHORT $LN81@PyIncremen
$LN110@PyIncremen:
  001b0	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  001b7	44 89 30	 mov	 DWORD PTR [rax], r14d
  001ba	eb 53		 jmp	 SHORT $LN81@PyIncremen
$LN76@PyIncremen:
  001bc	a8 20		 test	 al, 32			; 00000020H
  001be	74 1e		 je	 SHORT $LN106@PyIncremen
  001c0	a8 40		 test	 al, 64			; 00000040H
  001c2	74 0d		 je	 SHORT $LN104@PyIncremen
  001c4	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  001cb	66 44 89 30	 mov	 WORD PTR [rax], r14w
  001cf	eb 3e		 jmp	 SHORT $LN81@PyIncremen
$LN104@PyIncremen:
  001d1	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  001d8	66 44 89 30	 mov	 WORD PTR [rax], r14w
  001dc	eb 31		 jmp	 SHORT $LN81@PyIncremen
$LN106@PyIncremen:
  001de	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  001e5	66 44 89 30	 mov	 WORD PTR [rax], r14w
  001e9	eb 24		 jmp	 SHORT $LN81@PyIncremen
$LN77@PyIncremen:
  001eb	a8 20		 test	 al, 32			; 00000020H
  001ed	74 16		 je	 SHORT $LN102@PyIncremen
  001ef	a8 40		 test	 al, 64			; 00000040H
  001f1	74 09		 je	 SHORT $LN100@PyIncremen
  001f3	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  001fa	eb 10		 jmp	 SHORT $LN103@PyIncremen
$LN100@PyIncremen:
  001fc	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00203	eb 07		 jmp	 SHORT $LN103@PyIncremen
$LN102@PyIncremen:
  00205	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN103@PyIncremen:
  0020c	44 88 30	 mov	 BYTE PTR [rax], r14b
$LN81@PyIncremen:

; 325  :         memcpy(out + kind, PyUnicode_DATA(output), kind * output_len);

  0020f	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00213	a8 20		 test	 al, 32			; 00000020H
  00215	74 16		 je	 SHORT $LN114@PyIncremen
  00217	a8 40		 test	 al, 64			; 00000040H
  00219	74 09		 je	 SHORT $LN112@PyIncremen
  0021b	49 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR [r13+128]
  00222	eb 10		 jmp	 SHORT $LN115@PyIncremen
$LN112@PyIncremen:
  00224	49 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR [r13+160]
  0022b	eb 07		 jmp	 SHORT $LN115@PyIncremen
$LN114@PyIncremen:
  0022d	49 8b 95 a0 00
	00 00		 mov	 rdx, QWORD PTR [r13+160]
$LN115@PyIncremen:
  00234	49 63 c0	 movsxd	 rax, r8d
  00237	4c 8b c0	 mov	 r8, rax
  0023a	4a 8d 0c 08	 lea	 rcx, QWORD PTR [rax+r9]
  0023e	4c 0f af c6	 imul	 r8, rsi
  00242	e8 00 00 00 00	 call	 memcpy

; 326  :         Py_DECREF(output);

  00247	49 8b cd	 mov	 rcx, r13
  0024a	e8 00 00 00 00	 call	 _Py_DecRef

; 327  :         output = modified; /* output remains ready */
; 328  :         self->pendingcr = 0;

  0024f	41 83 67 70 fe	 and	 DWORD PTR [r15+112], -2

; 329  :         output_len++;

  00254	48 ff c6	 inc	 rsi
  00257	4c 8b ef	 mov	 r13, rdi
$LN85@PyIncremen:

; 330  :     }
; 331  : 
; 332  :     /* retain last \r even when not translating data:
; 333  :      * then readline() is sure to get \r\n in one pass
; 334  :      */
; 335  :     if (!final) {

  0025a	85 ed		 test	 ebp, ebp
  0025c	0f 85 d9 00 00
	00		 jne	 $LN73@PyIncremen

; 336  :         if (output_len > 0
; 337  :             && PyUnicode_READ_CHAR(output, output_len - 1) == '\r')

  00262	48 85 f6	 test	 rsi, rsi
  00265	0f 8e d0 00 00
	00		 jle	 $LN73@PyIncremen
  0026b	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  0026f	8b c8		 mov	 ecx, eax
  00271	c1 e9 02	 shr	 ecx, 2
  00274	83 e1 07	 and	 ecx, 7
  00277	83 f9 01	 cmp	 ecx, 1
  0027a	75 33		 jne	 SHORT $LN130@PyIncremen
  0027c	a8 20		 test	 al, 32			; 00000020H
  0027e	74 21		 je	 SHORT $LN118@PyIncremen
  00280	a8 40		 test	 al, 64			; 00000040H
  00282	74 0f		 je	 SHORT $LN116@PyIncremen
  00284	41 0f b6 4c 35
	7f		 movzx	 ecx, BYTE PTR [r13+rsi+127]
  0028a	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  00291	eb 79		 jmp	 SHORT $LN129@PyIncremen
$LN116@PyIncremen:
  00293	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  0029a	0f b6 4c 30 ff	 movzx	 ecx, BYTE PTR [rax+rsi-1]
  0029f	eb 6b		 jmp	 SHORT $LN129@PyIncremen
$LN118@PyIncremen:
  002a1	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
  002a8	0f b6 4c 30 ff	 movzx	 ecx, BYTE PTR [rax+rsi-1]
  002ad	eb 5d		 jmp	 SHORT $LN129@PyIncremen
$LN130@PyIncremen:
  002af	83 f9 02	 cmp	 ecx, 2
  002b2	75 33		 jne	 SHORT $LN128@PyIncremen
  002b4	a8 20		 test	 al, 32			; 00000020H
  002b6	74 21		 je	 SHORT $LN122@PyIncremen
  002b8	a8 40		 test	 al, 64			; 00000040H
  002ba	74 0f		 je	 SHORT $LN120@PyIncremen
  002bc	41 0f b7 4c 75
	7e		 movzx	 ecx, WORD PTR [r13+rsi*2+126]
  002c2	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  002c9	eb 41		 jmp	 SHORT $LN129@PyIncremen
$LN120@PyIncremen:
  002cb	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  002d2	0f b7 4c 70 fe	 movzx	 ecx, WORD PTR [rax+rsi*2-2]
  002d7	eb 33		 jmp	 SHORT $LN129@PyIncremen
$LN122@PyIncremen:
  002d9	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
  002e0	0f b7 4c 70 fe	 movzx	 ecx, WORD PTR [rax+rsi*2-2]
  002e5	eb 25		 jmp	 SHORT $LN129@PyIncremen
$LN128@PyIncremen:
  002e7	a8 20		 test	 al, 32			; 00000020H
  002e9	74 16		 je	 SHORT $LN126@PyIncremen
  002eb	a8 40		 test	 al, 64			; 00000040H
  002ed	74 09		 je	 SHORT $LN124@PyIncremen
  002ef	49 8d 85 80 00
	00 00		 lea	 rax, QWORD PTR [r13+128]
  002f6	eb 10		 jmp	 SHORT $LN127@PyIncremen
$LN124@PyIncremen:
  002f8	49 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR [r13+160]
  002ff	eb 07		 jmp	 SHORT $LN127@PyIncremen
$LN126@PyIncremen:
  00301	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
$LN127@PyIncremen:
  00308	8b 4c b0 fc	 mov	 ecx, DWORD PTR [rax+rsi*4-4]
$LN129@PyIncremen:
  0030c	41 3b ce	 cmp	 ecx, r14d
  0030f	75 2a		 jne	 SHORT $LN73@PyIncremen

; 338  :         {
; 339  :             PyObject *modified = PyUnicode_Substring(output, 0, output_len -1);

  00311	4c 8d 46 ff	 lea	 r8, QWORD PTR [rsi-1]
  00315	33 d2		 xor	 edx, edx
  00317	49 8b cd	 mov	 rcx, r13
  0031a	e8 00 00 00 00	 call	 PyUnicode_Substring
  0031f	48 8b f8	 mov	 rdi, rax

; 340  :             if (modified == NULL)

  00322	48 85 c0	 test	 rax, rax
  00325	0f 84 09 02 00
	00		 je	 $error$20588

; 341  :                 goto error;
; 342  :             Py_DECREF(output);

  0032b	49 8b cd	 mov	 rcx, r13
  0032e	e8 00 00 00 00	 call	 _Py_DecRef

; 343  :             output = modified;
; 344  :             self->pendingcr = 1;

  00333	41 83 4f 70 01	 or	 DWORD PTR [r15+112], 1
  00338	4c 8b ef	 mov	 r13, rdi
$LN73@PyIncremen:

; 345  :         }
; 346  :     }
; 347  : 
; 348  :     /* Record which newlines are read and do newline translation if desired,
; 349  :        all in one pass. */
; 350  :     {
; 351  :         void *in_str;
; 352  :         Py_ssize_t len;
; 353  :         int seennl = self->seennl;

  0033b	45 8b 67 70	 mov	 r12d, DWORD PTR [r15+112]

; 354  :         int only_lf = 0;
; 355  :         int kind;
; 356  : 
; 357  :         in_str = PyUnicode_DATA(output);

  0033f	41 8b 6d 70	 mov	 ebp, DWORD PTR [r13+112]
  00343	8b cb		 mov	 ecx, ebx
  00345	41 c1 ec 02	 shr	 r12d, 2
  00349	41 83 e4 07	 and	 r12d, 7
  0034d	40 f6 c5 20	 test	 bpl, 32			; 00000020H
  00351	74 18		 je	 SHORT $LN134@PyIncremen
  00353	40 f6 c5 40	 test	 bpl, 64			; 00000040H
  00357	74 09		 je	 SHORT $LN132@PyIncremen
  00359	49 8d bd 80 00
	00 00		 lea	 rdi, QWORD PTR [r13+128]
  00360	eb 10		 jmp	 SHORT $LN135@PyIncremen
$LN132@PyIncremen:
  00362	49 8d bd a0 00
	00 00		 lea	 rdi, QWORD PTR [r13+160]
  00369	eb 07		 jmp	 SHORT $LN135@PyIncremen
$LN134@PyIncremen:
  0036b	49 8b bd a0 00
	00 00		 mov	 rdi, QWORD PTR [r13+160]
$LN135@PyIncremen:

; 358  :         len = PyUnicode_GET_LENGTH(output);

  00372	4d 8b 75 60	 mov	 r14, QWORD PTR [r13+96]

; 359  :         kind = PyUnicode_KIND(output);

  00376	c1 ed 02	 shr	 ebp, 2
  00379	83 e5 07	 and	 ebp, 7

; 360  : 
; 361  :         if (len == 0)

  0037c	4d 85 f6	 test	 r14, r14

; 362  :             return output;

  0037f	0f 84 f7 02 00
	00		 je	 $LN198@PyIncremen

; 363  : 
; 364  :         /* If, up to now, newlines are consistently \n, do a quick check
; 365  :            for the \r *byte* with the libc's optimized memchr.
; 366  :            */
; 367  :         if (seennl == SEEN_LF || seennl == 0) {

  00385	41 83 fc 02	 cmp	 r12d, 2
  00389	74 05		 je	 SHORT $LN69@PyIncremen
  0038b	45 85 e4	 test	 r12d, r12d
  0038e	75 1d		 jne	 SHORT $LN70@PyIncremen
$LN69@PyIncremen:

; 368  :             only_lf = (memchr(in_str, '\r', kind * len) == NULL);

  00390	4c 63 c5	 movsxd	 r8, ebp
  00393	ba 0d 00 00 00	 mov	 edx, 13
  00398	48 8b cf	 mov	 rcx, rdi
  0039b	4d 0f af c6	 imul	 r8, r14
  0039f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003a5	8b cb		 mov	 ecx, ebx
  003a7	48 85 c0	 test	 rax, rax
  003aa	0f 94 c1	 sete	 cl
$LN70@PyIncremen:

; 380  :                     Py_ssize_t i = 0;
; 381  :                     for (;;) {
; 382  :                         Py_UCS4 c;
; 383  :                         /* Fast loop for non-control characters */
; 384  :                         while (PyUnicode_READ(kind, in_str, i) > '\n')

  003ad	48 63 f5	 movsxd	 rsi, ebp
  003b0	85 c9		 test	 ecx, ecx
  003b2	0f 84 89 00 00
	00		 je	 $LN68@PyIncremen

; 369  :         }
; 370  : 
; 371  :         if (only_lf) {
; 372  :             /* If not already seen, quick scan for a possible "\n" character.
; 373  :                (there's nothing else to be done, even when in translation mode)
; 374  :             */
; 375  :             if (seennl == 0 &&
; 376  :                 memchr(in_str, '\n', kind * len) != NULL) {

  003b8	45 85 e4	 test	 r12d, r12d
  003bb	0f 85 a2 02 00
	00		 jne	 $LN1@PyIncremen
  003c1	4c 8b c6	 mov	 r8, rsi
  003c4	41 8d 54 24 0a	 lea	 edx, QWORD PTR [r12+10]
  003c9	48 8b cf	 mov	 rcx, rdi
  003cc	4d 0f af c6	 imul	 r8, r14
  003d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003d6	48 85 c0	 test	 rax, rax
  003d9	0f 84 84 02 00
	00		 je	 $LN1@PyIncremen

; 377  :                 if (kind == PyUnicode_1BYTE_KIND)

  003df	83 fd 01	 cmp	 ebp, 1

; 378  :                     seennl |= SEEN_LF;
; 379  :                 else {

  003e2	74 52		 je	 SHORT $LN181@PyIncremen
$LL62@PyIncremen:

; 380  :                     Py_ssize_t i = 0;
; 381  :                     for (;;) {
; 382  :                         Py_UCS4 c;
; 383  :                         /* Fast loop for non-control characters */
; 384  :                         while (PyUnicode_READ(kind, in_str, i) > '\n')

  003e4	48 83 fe 01	 cmp	 rsi, 1
  003e8	75 06		 jne	 SHORT $LN138@PyIncremen
  003ea	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  003ee	eb 0f		 jmp	 SHORT $LN137@PyIncremen
$LN138@PyIncremen:
  003f0	48 83 fe 02	 cmp	 rsi, 2
  003f4	75 06		 jne	 SHORT $LN136@PyIncremen
  003f6	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  003fa	eb 03		 jmp	 SHORT $LN137@PyIncremen
$LN136@PyIncremen:

; 385  :                             i++;

  003fc	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN137@PyIncremen:

; 380  :                     Py_ssize_t i = 0;
; 381  :                     for (;;) {
; 382  :                         Py_UCS4 c;
; 383  :                         /* Fast loop for non-control characters */
; 384  :                         while (PyUnicode_READ(kind, in_str, i) > '\n')

  003ff	83 f8 0a	 cmp	 eax, 10
  00402	76 05		 jbe	 SHORT $LN61@PyIncremen

; 385  :                             i++;

  00404	48 ff c3	 inc	 rbx
  00407	eb db		 jmp	 SHORT $LL62@PyIncremen
$LN61@PyIncremen:

; 386  :                         c = PyUnicode_READ(kind, in_str, i++);

  00409	48 83 fe 01	 cmp	 rsi, 1
  0040d	75 06		 jne	 SHORT $LN142@PyIncremen
  0040f	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00413	eb 0f		 jmp	 SHORT $LN199@PyIncremen
$LN142@PyIncremen:
  00415	48 83 fe 02	 cmp	 rsi, 2
  00419	75 06		 jne	 SHORT $LN140@PyIncremen
  0041b	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0041f	eb 03		 jmp	 SHORT $LN199@PyIncremen
$LN140@PyIncremen:
  00421	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN199@PyIncremen:
  00424	48 ff c3	 inc	 rbx

; 387  :                         if (c == '\n') {

  00427	83 f8 0a	 cmp	 eax, 10
  0042a	74 0a		 je	 SHORT $LN181@PyIncremen

; 389  :                             break;
; 390  :                         }
; 391  :                         if (i >= len)

  0042c	49 3b de	 cmp	 rbx, r14
  0042f	7c b3		 jl	 SHORT $LL62@PyIncremen

; 392  :                             break;
; 393  :                     }

  00431	e9 2d 02 00 00	 jmp	 $LN1@PyIncremen
$LN181@PyIncremen:

; 388  :                             seennl |= SEEN_LF;

  00436	41 bc 02 00 00
	00		 mov	 r12d, 2

; 394  :                 }
; 395  :             }

  0043c	e9 22 02 00 00	 jmp	 $LN1@PyIncremen
$LN68@PyIncremen:

; 396  :             /* Finished: we have scanned for newlines, and none of them
; 397  :                need translating */
; 398  :         }
; 399  :         else if (!self->translate) {

  00441	41 f6 47 70 02	 test	 BYTE PTR [r15+112], 2
  00446	0f 85 a2 00 00
	00		 jne	 $LN57@PyIncremen

; 400  :             Py_ssize_t i = 0;
; 401  :             /* We have already seen all newline types, no need to scan again */
; 402  :             if (seennl == SEEN_ALL)

  0044c	41 83 fc 07	 cmp	 r12d, 7
  00450	0f 84 0d 02 00
	00		 je	 $LN1@PyIncremen
$LL53@PyIncremen:

; 403  :                 goto endscan;
; 404  :             for (;;) {
; 405  :                 Py_UCS4 c;
; 406  :                 /* Fast loop for non-control characters */
; 407  :                 while (PyUnicode_READ(kind, in_str, i) > '\r')

  00456	48 83 fe 01	 cmp	 rsi, 1
  0045a	75 06		 jne	 SHORT $LN146@PyIncremen
  0045c	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00460	eb 0f		 jmp	 SHORT $LN145@PyIncremen
$LN146@PyIncremen:
  00462	48 83 fe 02	 cmp	 rsi, 2
  00466	75 06		 jne	 SHORT $LN144@PyIncremen
  00468	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  0046c	eb 03		 jmp	 SHORT $LN145@PyIncremen
$LN144@PyIncremen:

; 408  :                     i++;

  0046e	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN145@PyIncremen:

; 403  :                 goto endscan;
; 404  :             for (;;) {
; 405  :                 Py_UCS4 c;
; 406  :                 /* Fast loop for non-control characters */
; 407  :                 while (PyUnicode_READ(kind, in_str, i) > '\r')

  00471	83 f8 0d	 cmp	 eax, 13
  00474	76 05		 jbe	 SHORT $LN52@PyIncremen

; 408  :                     i++;

  00476	48 ff c3	 inc	 rbx
  00479	eb db		 jmp	 SHORT $LL53@PyIncremen
$LN52@PyIncremen:

; 409  :                 c = PyUnicode_READ(kind, in_str, i++);

  0047b	48 83 fe 01	 cmp	 rsi, 1
  0047f	75 06		 jne	 SHORT $LN150@PyIncremen
  00481	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  00485	eb 0f		 jmp	 SHORT $LN200@PyIncremen
$LN150@PyIncremen:
  00487	48 83 fe 02	 cmp	 rsi, 2
  0048b	75 06		 jne	 SHORT $LN148@PyIncremen
  0048d	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  00491	eb 03		 jmp	 SHORT $LN200@PyIncremen
$LN148@PyIncremen:
  00493	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN200@PyIncremen:
  00496	48 ff c3	 inc	 rbx

; 410  :                 if (c == '\n')

  00499	83 f8 0a	 cmp	 eax, 10
  0049c	75 06		 jne	 SHORT $LN51@PyIncremen

; 411  :                     seennl |= SEEN_LF;

  0049e	41 83 cc 02	 or	 r12d, 2
  004a2	eb 32		 jmp	 SHORT $LN47@PyIncremen
$LN51@PyIncremen:

; 412  :                 else if (c == '\r') {

  004a4	83 f8 0d	 cmp	 eax, 13
  004a7	75 2d		 jne	 SHORT $LN47@PyIncremen

; 413  :                     if (PyUnicode_READ(kind, in_str, i) == '\n') {

  004a9	48 83 fe 01	 cmp	 rsi, 1
  004ad	75 06		 jne	 SHORT $LN154@PyIncremen
  004af	0f b6 04 3b	 movzx	 eax, BYTE PTR [rbx+rdi]
  004b3	eb 0f		 jmp	 SHORT $LN153@PyIncremen
$LN154@PyIncremen:
  004b5	48 83 fe 02	 cmp	 rsi, 2
  004b9	75 06		 jne	 SHORT $LN152@PyIncremen
  004bb	0f b7 04 5f	 movzx	 eax, WORD PTR [rdi+rbx*2]
  004bf	eb 03		 jmp	 SHORT $LN153@PyIncremen
$LN152@PyIncremen:
  004c1	8b 04 9f	 mov	 eax, DWORD PTR [rdi+rbx*4]
$LN153@PyIncremen:
  004c4	83 f8 0a	 cmp	 eax, 10
  004c7	75 09		 jne	 SHORT $LN48@PyIncremen

; 414  :                         seennl |= SEEN_CRLF;

  004c9	41 83 cc 04	 or	 r12d, 4

; 415  :                         i++;

  004cd	48 ff c3	 inc	 rbx

; 416  :                     }
; 417  :                     else

  004d0	eb 04		 jmp	 SHORT $LN47@PyIncremen
$LN48@PyIncremen:

; 418  :                         seennl |= SEEN_CR;

  004d2	41 83 cc 01	 or	 r12d, 1
$LN47@PyIncremen:

; 419  :                 }
; 420  :                 if (i >= len)

  004d6	49 3b de	 cmp	 rbx, r14
  004d9	0f 8d 84 01 00
	00		 jge	 $LN1@PyIncremen

; 421  :                     break;
; 422  :                 if (seennl == SEEN_ALL)

  004df	41 83 fc 07	 cmp	 r12d, 7
  004e3	0f 85 6d ff ff
	ff		 jne	 $LL53@PyIncremen
$endscan$20769:

; 423  :                     break;
; 424  :             }
; 425  :         endscan:
; 426  :             ;
; 427  :         }
; 428  :         else {

  004e9	e9 75 01 00 00	 jmp	 $LN1@PyIncremen
$LN57@PyIncremen:

; 429  :             void *translated;
; 430  :             int kind = PyUnicode_KIND(output);

  004ee	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  004f2	8b f8		 mov	 edi, eax
  004f4	c1 ef 02	 shr	 edi, 2
  004f7	83 e7 07	 and	 edi, 7

; 431  :             void *in_str = PyUnicode_DATA(output);

  004fa	a8 20		 test	 al, 32			; 00000020H
  004fc	74 16		 je	 SHORT $LN158@PyIncremen
  004fe	a8 40		 test	 al, 64			; 00000040H
  00500	74 09		 je	 SHORT $LN156@PyIncremen
  00502	49 8d ad 80 00
	00 00		 lea	 rbp, QWORD PTR [r13+128]
  00509	eb 10		 jmp	 SHORT $LN159@PyIncremen
$LN156@PyIncremen:
  0050b	49 8d ad a0 00
	00 00		 lea	 rbp, QWORD PTR [r13+160]
  00512	eb 07		 jmp	 SHORT $LN159@PyIncremen
$LN158@PyIncremen:
  00514	49 8b ad a0 00
	00 00		 mov	 rbp, QWORD PTR [r13+160]
$LN159@PyIncremen:

; 432  :             Py_ssize_t in, out;
; 433  :             /* XXX: Previous in-place translation here is disabled as
; 434  :                resizing is not possible anymore */
; 435  :             /* We could try to optimize this so that we only do a copy
; 436  :                when there is something to translate. On the other hand,
; 437  :                we already know there is a \r byte, so chances are high
; 438  :                that something needs to be done. */
; 439  :             translated = PyMem_Malloc(kind * len);

  0051b	48 63 cf	 movsxd	 rcx, edi
  0051e	49 0f af ce	 imul	 rcx, r14
  00522	e8 00 00 00 00	 call	 PyMem_Malloc
  00527	48 8b f0	 mov	 rsi, rax

; 440  :             if (translated == NULL) {

  0052a	48 85 c0	 test	 rax, rax
  0052d	75 14		 jne	 SHORT $LN43@PyIncremen

; 441  :                 PyErr_NoMemory();

  0052f	e8 00 00 00 00	 call	 PyErr_NoMemory
$error$20588:

; 479  : 
; 480  :   error:
; 481  :     Py_DECREF(output);

  00534	49 8b cd	 mov	 rcx, r13
  00537	e8 00 00 00 00	 call	 _Py_DecRef
$LN204@PyIncremen:

; 482  :     return NULL;

  0053c	33 c0		 xor	 eax, eax
  0053e	e9 3c 01 00 00	 jmp	 $LN197@PyIncremen
$LN43@PyIncremen:

; 442  :                 goto error;
; 443  :             }
; 444  :             in = out = 0;

  00543	48 8b cb	 mov	 rcx, rbx
  00546	41 b9 0a 00 00
	00		 mov	 r9d, 10
  0054c	0f 1f 40 00	 npad	 4
$LL40@PyIncremen:

; 445  :             for (;;) {
; 446  :                 Py_UCS4 c;
; 447  :                 /* Fast loop for non-control characters */
; 448  :                 while ((c = PyUnicode_READ(kind, in_str, in++)) > '\r')

  00550	83 ff 01	 cmp	 edi, 1
  00553	75 06		 jne	 SHORT $LN162@PyIncremen
  00555	0f b6 14 29	 movzx	 edx, BYTE PTR [rcx+rbp]
  00559	eb 10		 jmp	 SHORT $LN202@PyIncremen
$LN162@PyIncremen:
  0055b	83 ff 02	 cmp	 edi, 2
  0055e	75 07		 jne	 SHORT $LN160@PyIncremen
  00560	0f b7 54 4d 00	 movzx	 edx, WORD PTR [rbp+rcx*2]
  00565	eb 04		 jmp	 SHORT $LN202@PyIncremen
$LN160@PyIncremen:
  00567	8b 54 8d 00	 mov	 edx, DWORD PTR [rbp+rcx*4]
$LN202@PyIncremen:
  0056b	48 ff c1	 inc	 rcx
  0056e	83 fa 0d	 cmp	 edx, 13
  00571	76 26		 jbe	 SHORT $LN39@PyIncremen
$LN201@PyIncremen:

; 449  :                     PyUnicode_WRITE(kind, translated, out++, c);

  00573	44 8b c7	 mov	 r8d, edi
  00576	41 ff c8	 dec	 r8d
  00579	74 16		 je	 SHORT $LN33@PyIncremen
  0057b	41 ff c8	 dec	 r8d
  0057e	74 08		 je	 SHORT $LN32@PyIncremen
  00580	89 14 9e	 mov	 DWORD PTR [rsi+rbx*4], edx
  00583	48 ff c3	 inc	 rbx
  00586	eb c8		 jmp	 SHORT $LL40@PyIncremen
$LN32@PyIncremen:
  00588	66 89 14 5e	 mov	 WORD PTR [rsi+rbx*2], dx
  0058c	48 ff c3	 inc	 rbx
  0058f	eb bf		 jmp	 SHORT $LL40@PyIncremen
$LN33@PyIncremen:
  00591	88 14 33	 mov	 BYTE PTR [rbx+rsi], dl
  00594	48 ff c3	 inc	 rbx
  00597	eb b7		 jmp	 SHORT $LL40@PyIncremen
$LN39@PyIncremen:

; 450  :                 if (c == '\n') {

  00599	41 3b d1	 cmp	 edx, r9d
  0059c	75 32		 jne	 SHORT $LN30@PyIncremen

; 451  :                     PyUnicode_WRITE(kind, translated, out++, c);

  0059e	8b d7		 mov	 edx, edi
  005a0	ff ca		 dec	 edx
  005a2	74 1f		 je	 SHORT $LN24@PyIncremen
  005a4	ff ca		 dec	 edx
  005a6	74 0d		 je	 SHORT $LN23@PyIncremen
  005a8	44 89 0c 9e	 mov	 DWORD PTR [rsi+rbx*4], r9d
  005ac	48 ff c3	 inc	 rbx

; 452  :                     seennl |= SEEN_LF;

  005af	41 83 cc 02	 or	 r12d, 2

; 453  :                     continue;

  005b3	eb 9b		 jmp	 SHORT $LL40@PyIncremen
$LN23@PyIncremen:

; 451  :                     PyUnicode_WRITE(kind, translated, out++, c);

  005b5	66 44 89 0c 5e	 mov	 WORD PTR [rsi+rbx*2], r9w
  005ba	48 ff c3	 inc	 rbx

; 452  :                     seennl |= SEEN_LF;

  005bd	41 83 cc 02	 or	 r12d, 2

; 453  :                     continue;

  005c1	eb 8d		 jmp	 SHORT $LL40@PyIncremen
$LN24@PyIncremen:

; 451  :                     PyUnicode_WRITE(kind, translated, out++, c);

  005c3	44 88 0c 33	 mov	 BYTE PTR [rbx+rsi], r9b
  005c7	48 ff c3	 inc	 rbx

; 452  :                     seennl |= SEEN_LF;

  005ca	41 83 cc 02	 or	 r12d, 2

; 453  :                     continue;

  005ce	eb 80		 jmp	 SHORT $LL40@PyIncremen
$LN30@PyIncremen:

; 454  :                 }
; 455  :                 if (c == '\r') {

  005d0	83 fa 0d	 cmp	 edx, 13
  005d3	75 5c		 jne	 SHORT $LN21@PyIncremen

; 456  :                     if (PyUnicode_READ(kind, in_str, in) == '\n') {

  005d5	83 ff 01	 cmp	 edi, 1
  005d8	75 06		 jne	 SHORT $LN166@PyIncremen
  005da	0f b6 04 29	 movzx	 eax, BYTE PTR [rcx+rbp]
  005de	eb 10		 jmp	 SHORT $LN165@PyIncremen
$LN166@PyIncremen:
  005e0	83 ff 02	 cmp	 edi, 2
  005e3	75 07		 jne	 SHORT $LN164@PyIncremen
  005e5	0f b7 44 4d 00	 movzx	 eax, WORD PTR [rbp+rcx*2]
  005ea	eb 04		 jmp	 SHORT $LN165@PyIncremen
$LN164@PyIncremen:
  005ec	8b 44 8d 00	 mov	 eax, DWORD PTR [rbp+rcx*4]
$LN165@PyIncremen:
  005f0	41 3b c1	 cmp	 eax, r9d
  005f3	75 09		 jne	 SHORT $LN20@PyIncremen

; 457  :                         in++;

  005f5	48 ff c1	 inc	 rcx

; 458  :                         seennl |= SEEN_CRLF;

  005f8	41 83 cc 04	 or	 r12d, 4

; 459  :                     }
; 460  :                     else

  005fc	eb 04		 jmp	 SHORT $LN18@PyIncremen
$LN20@PyIncremen:

; 461  :                         seennl |= SEEN_CR;

  005fe	41 83 cc 01	 or	 r12d, 1
$LN18@PyIncremen:

; 462  :                     PyUnicode_WRITE(kind, translated, out++, '\n');

  00602	8b d7		 mov	 edx, edi
  00604	ff ca		 dec	 edx
  00606	74 1d		 je	 SHORT $LN13@PyIncremen
  00608	ff ca		 dec	 edx
  0060a	74 0c		 je	 SHORT $LN12@PyIncremen
  0060c	44 89 0c 9e	 mov	 DWORD PTR [rsi+rbx*4], r9d
  00610	48 ff c3	 inc	 rbx
  00613	e9 38 ff ff ff	 jmp	 $LL40@PyIncremen
$LN12@PyIncremen:
  00618	66 44 89 0c 5e	 mov	 WORD PTR [rsi+rbx*2], r9w
  0061d	48 ff c3	 inc	 rbx
  00620	e9 2b ff ff ff	 jmp	 $LL40@PyIncremen
$LN13@PyIncremen:
  00625	44 88 0c 33	 mov	 BYTE PTR [rbx+rsi], r9b
  00629	48 ff c3	 inc	 rbx

; 463  :                     continue;

  0062c	e9 1f ff ff ff	 jmp	 $LL40@PyIncremen
$LN21@PyIncremen:

; 464  :                 }
; 465  :                 if (in > len)

  00631	49 3b ce	 cmp	 rcx, r14

; 466  :                     break;
; 467  :                 PyUnicode_WRITE(kind, translated, out++, c);

  00634	0f 8e 39 ff ff
	ff		 jle	 $LN201@PyIncremen

; 468  :             }
; 469  :             Py_DECREF(output);

  0063a	49 8b cd	 mov	 rcx, r13
  0063d	e8 00 00 00 00	 call	 _Py_DecRef

; 470  :             output = PyUnicode_FromKindAndData(kind, translated, out);

  00642	4c 8b c3	 mov	 r8, rbx
  00645	48 8b d6	 mov	 rdx, rsi
  00648	8b cf		 mov	 ecx, edi
  0064a	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData

; 471  :             PyMem_Free(translated);

  0064f	48 8b ce	 mov	 rcx, rsi
  00652	4c 8b e8	 mov	 r13, rax
  00655	e8 00 00 00 00	 call	 PyMem_Free

; 472  :             if (!output)

  0065a	4d 85 ed	 test	 r13, r13

; 473  :                 return NULL;

  0065d	0f 84 d9 fe ff
	ff		 je	 $LN204@PyIncremen
$LN1@PyIncremen:

; 474  :         }
; 475  :         self->seennl |= seennl;

  00663	41 8b 47 70	 mov	 eax, DWORD PTR [r15+112]
  00667	42 8d 0c a5 00
	00 00 00	 lea	 ecx, DWORD PTR [r12*4]
  0066f	0b c8		 or	 ecx, eax
  00671	33 c8		 xor	 ecx, eax
  00673	83 e1 1c	 and	 ecx, 28
  00676	33 c8		 xor	 ecx, eax
  00678	41 89 4f 70	 mov	 DWORD PTR [r15+112], ecx
$LN198@PyIncremen:

; 476  :     }
; 477  : 
; 478  :     return output;

  0067c	49 8b c5	 mov	 rax, r13
$LN197@PyIncremen:
  0067f	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  00684	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00689	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0068e	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
  00693	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 483  : }

  00698	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0069c	41 5f		 pop	 r15
  0069e	41 5d		 pop	 r13
  006a0	5d		 pop	 rbp
  006a1	c3		 ret	 0
_PyIncrementalNewlineDecoder_decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_05FPBGKCKL@final?$AA@			; `string'
PUBLIC	??_C@_0BO@OOCFADOE@O?$HMi?3IncrementalNewlineDecoder?$AA@ ; `string'
PUBLIC	??_C@_05DFJCHPDH@input?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_decode DD imagerel incrementalnewlinedecoder_decode
	DD	imagerel incrementalnewlinedecoder_decode+123
	DD	imagerel $unwind$incrementalnewlinedecoder_decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_decode DD 020801H
	DD	030049208H
xdata	ENDS
;	COMDAT ??_C@_05FPBGKCKL@final?$AA@
CONST	SEGMENT
??_C@_05FPBGKCKL@final?$AA@ DB 'final', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OOCFADOE@O?$HMi?3IncrementalNewlineDecoder?$AA@
CONST	SEGMENT
??_C@_0BO@OOCFADOE@O?$HMi?3IncrementalNewlineDecoder?$AA@ DB 'O|i:Increme'
	DB	'ntalNewlineDecoder', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFJCHPDH@input?$AA@
CONST	SEGMENT
??_C@_05DFJCHPDH@input?$AA@ DB 'input', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_decode
_TEXT	SEGMENT
input$ = 48
self$ = 96
args$ = 104
kwds$ = 112
final$ = 120
incrementalnewlinedecoder_decode PROC			; COMDAT

; 488  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	49 8b c0	 mov	 rax, r8
  0000e	4c 8b d2	 mov	 r10, rdx

; 489  :     char *kwlist[] = {"input", "final", NULL};

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05DFJCHPDH@input?$AA@

; 490  :     PyObject *input;
; 491  :     int final = 0;
; 492  : 
; 493  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|i:IncrementalNewlineDecoder",
; 494  :                                      kwlist, &input, &final))

  00018	4d 8d 4b e0	 lea	 r9, QWORD PTR [r11-32]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@OOCFADOE@O?$HMi?3IncrementalNewlineDecoder?$AA@
  00023	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05FPBGKCKL@final?$AA@
  0002e	48 8b d0	 mov	 rdx, rax
  00031	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx
  00035	33 c9		 xor	 ecx, ecx
  00037	49 89 4b f0	 mov	 QWORD PTR [r11-16], rcx
  0003b	89 4c 24 78	 mov	 DWORD PTR final$[rsp], ecx
  0003f	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00043	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00047	49 8d 4b d8	 lea	 rcx, QWORD PTR [r11-40]
  0004b	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  0004f	49 8b ca	 mov	 rcx, r10
  00052	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00057	85 c0		 test	 eax, eax
  00059	75 08		 jne	 SHORT $LN1@incrementa@3

; 495  :         return NULL;

  0005b	33 c0		 xor	 eax, eax

; 497  : }

  0005d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN1@incrementa@3:

; 496  :     return _PyIncrementalNewlineDecoder_decode((PyObject *) self, input, final);

  00063	44 8b 44 24 78	 mov	 r8d, DWORD PTR final$[rsp]
  00068	48 8b 54 24 30	 mov	 rdx, QWORD PTR input$[rsp]
  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 _PyIncrementalNewlineDecoder_decode

; 497  : }

  00075	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
incrementalnewlinedecoder_decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GJDHBAOJ@NK?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_04DDJCNJIG@?$CIOK?$CJ?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	_PyArg_Parse_SizeT:PROC
EXTRN	_PyIO_str_getstate:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_getstate DD imagerel incrementalnewlinedecoder_getstate
	DD	imagerel incrementalnewlinedecoder_getstate+201
	DD	imagerel $unwind$incrementalnewlinedecoder_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_getstate DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_02GJDHBAOJ@NK?$AA@
CONST	SEGMENT
??_C@_02GJDHBAOJ@NK?$AA@ DB 'NK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04DDJCNJIG@?$CIOK?$CJ?$AA@
CONST	SEGMENT
??_C@_04DDJCNJIG@?$CIOK?$CJ?$AA@ DB '(OK)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_getstate
_TEXT	SEGMENT
buffer$ = 48
self$ = 48
args$ = 56
flag$ = 64
incrementalnewlinedecoder_getstate PROC			; COMDAT

; 501  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 502  :     PyObject *buffer;
; 503  :     unsigned PY_LONG_LONG flag;
; 504  : 
; 505  :     if (self->decoder != Py_None) {

  0000d	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00018	48 3b c8	 cmp	 rcx, rax
  0001b	74 67		 je	 SHORT $LN5@incrementa@4

; 506  :         PyObject *state = PyObject_CallMethodObjArgs(self->decoder,
; 507  :            _PyIO_str_getstate, NULL);

  0001d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_getstate
  00024	45 33 c0	 xor	 r8d, r8d
  00027	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  0002c	48 8b d8	 mov	 rbx, rax

; 508  :         if (state == NULL)

  0002f	48 85 c0	 test	 rax, rax

; 509  :             return NULL;

  00032	74 25		 je	 SHORT $LN8@incrementa@4

; 510  :         if (!PyArg_Parse(state, "(OK)", &buffer, &flag)) {

  00034	4c 8d 4c 24 40	 lea	 r9, QWORD PTR flag$[rsp]
  00039	4c 8d 44 24 30	 lea	 r8, QWORD PTR buffer$[rsp]
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DDJCNJIG@?$CIOK?$CJ?$AA@
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0004d	85 c0		 test	 eax, eax
  0004f	75 15		 jne	 SHORT $LN3@incrementa@4

; 511  :             Py_DECREF(state);

  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@incrementa@4:

; 512  :             return NULL;

  00059	33 c0		 xor	 eax, eax

; 525  : }

  0005b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN3@incrementa@4:

; 513  :         }
; 514  :         Py_INCREF(buffer);

  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  0006b	e8 00 00 00 00	 call	 _Py_IncRef

; 515  :         Py_DECREF(state);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 516  :     }
; 517  :     else {

  00078	4c 8b 44 24 40	 mov	 r8, QWORD PTR flag$[rsp]
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer$[rsp]
  00082	eb 14		 jmp	 SHORT $LN2@incrementa@4
$LN5@incrementa@4:

; 518  :         buffer = PyBytes_FromString("");

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0008b	e8 00 00 00 00	 call	 PyBytes_FromString

; 519  :         flag = 0;

  00090	45 33 c0	 xor	 r8d, r8d
  00093	48 89 44 24 30	 mov	 QWORD PTR buffer$[rsp], rax
$LN2@incrementa@4:

; 520  :     }
; 521  :     flag <<= 1;

  00098	4d 03 c0	 add	 r8, r8

; 522  :     if (self->pendingcr)

  0009b	f6 47 70 01	 test	 BYTE PTR [rdi+112], 1
  0009f	4c 89 44 24 40	 mov	 QWORD PTR flag$[rsp], r8
  000a4	74 09		 je	 SHORT $LN1@incrementa@4

; 523  :         flag |= 1;

  000a6	49 83 c8 01	 or	 r8, 1
  000aa	4c 89 44 24 40	 mov	 QWORD PTR flag$[rsp], r8
$LN1@incrementa@4:

; 524  :     return Py_BuildValue("NK", buffer, flag);

  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02GJDHBAOJ@NK?$AA@
  000b6	48 8b d0	 mov	 rdx, rax
  000b9	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 525  : }

  000be	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
incrementalnewlinedecoder_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_06JAFCCCAB@?$CI?$CIOK?$CJ?$CJ?$AA@	; `string'
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_setstate DD imagerel incrementalnewlinedecoder_setstate
	DD	imagerel incrementalnewlinedecoder_setstate+218
	DD	imagerel $unwind$incrementalnewlinedecoder_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_setstate DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_06JAFCCCAB@?$CI?$CIOK?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_06JAFCCCAB@?$CI?$CIOK?$CJ?$CJ?$AA@ DB '((OK))', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_setstate
_TEXT	SEGMENT
self$ = 64
state$ = 72
flag$ = 80
buffer$ = 88
incrementalnewlinedecoder_setstate PROC			; COMDAT

; 529  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 530  :     PyObject *buffer;
; 531  :     unsigned PY_LONG_LONG flag;
; 532  : 
; 533  :     if (!PyArg_Parse(state, "(OK)", &buffer, &flag))

  0000c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR flag$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DDJCNJIG@?$CIOK?$CJ?$AA@
  00018	4c 8d 44 24 58	 lea	 r8, QWORD PTR buffer$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00025	85 c0		 test	 eax, eax
  00027	75 08		 jne	 SHORT $LN3@incrementa@5

; 534  :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 544  : }

  0002b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN3@incrementa@5:

; 535  : 
; 536  :     self->pendingcr = (int) flag & 1;

  00031	4c 8b 4c 24 50	 mov	 r9, QWORD PTR flag$[rsp]
  00036	83 63 70 fe	 and	 DWORD PTR [rbx+112], -2

; 537  :     flag >>= 1;
; 538  : 
; 539  :     if (self->decoder != Py_None)

  0003a	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  0003e	41 8b c1	 mov	 eax, r9d
  00041	49 d1 e9	 shr	 r9, 1
  00044	83 e0 01	 and	 eax, 1
  00047	4c 89 4c 24 50	 mov	 QWORD PTR flag$[rsp], r9
  0004c	09 43 70	 or	 DWORD PTR [rbx+112], eax
  0004f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00056	48 3b cb	 cmp	 rcx, rbx
  00059	74 35		 je	 SHORT $LN2@incrementa@5

; 540  :         return _PyObject_CallMethodId(self->decoder,
; 541  :                                       &PyId_setstate, "((OK))", buffer, flag);

  0005b	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00062	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0006b	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00070	4c 8b 4c 24 58	 mov	 r9, QWORD PTR buffer$[rsp]
  00075	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_setstate
  0007a	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06JAFCCCAB@?$CI?$CIOK?$CJ?$CJ?$AA@
  00085	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 544  : }

  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
$LN2@incrementa@5:

; 542  :     else
; 543  :         Py_RETURN_NONE;

  00090	e8 00 00 00 00	 call	 _Py_PXCTX
  00095	85 c0		 test	 eax, eax
  00097	75 38		 jne	 SHORT $LN7@incrementa@5
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a7	4c 8b cb	 mov	 r9, rbx
  000aa	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bd	85 c0		 test	 eax, eax
  000bf	75 09		 jne	 SHORT $LN6@incrementa@5
  000c1	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000c8	74 07		 je	 SHORT $LN7@incrementa@5
$LN6@incrementa@5:
  000ca	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@incrementa@5:
  000d1	48 8b c3	 mov	 rax, rbx

; 544  : }

  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5b		 pop	 rbx
  000d9	c3		 ret	 0
incrementalnewlinedecoder_setstate ENDP
_TEXT	ENDS
EXTRN	_PyIO_str_reset:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_reset DD imagerel incrementalnewlinedecoder_reset
	DD	imagerel incrementalnewlinedecoder_reset+120
	DD	imagerel $unwind$incrementalnewlinedecoder_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_reset DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
xdata	ENDS
;	COMDAT incrementalnewlinedecoder_reset
_TEXT	SEGMENT
self$ = 64
args$ = 72
incrementalnewlinedecoder_reset PROC			; COMDAT

; 548  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 549  :     self->seennl = 0;
; 550  :     self->pendingcr = 0;

  00006	83 61 70 e2	 and	 DWORD PTR [rcx+112], -30

; 551  :     if (self->decoder != Py_None)

  0000a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00015	48 3b cb	 cmp	 rcx, rbx
  00018	74 14		 je	 SHORT $LN2@incrementa@6

; 552  :         return PyObject_CallMethodObjArgs(self->decoder, _PyIO_str_reset, NULL);

  0001a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_reset
  00021	45 33 c0	 xor	 r8d, r8d

; 555  : }

  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 PyObject_CallMethodObjArgs
$LN2@incrementa@6:

; 553  :     else
; 554  :         Py_RETURN_NONE;

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	75 38		 jne	 SHORT $LN6@incrementa@6
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00045	4c 8b cb	 mov	 r9, rbx
  00048	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00056	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005b	85 c0		 test	 eax, eax
  0005d	75 09		 jne	 SHORT $LN5@incrementa@6
  0005f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00066	74 07		 je	 SHORT $LN6@incrementa@6
$LN5@incrementa@6:
  00068	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@incrementa@6:
  0006f	48 8b c3	 mov	 rax, rbx

; 555  : }

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
incrementalnewlinedecoder_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PFJENDKN@sss?$AA@			; `string'
PUBLIC	??_C@_02FCBLNKNB@ss?$AA@			; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_01LIIJDEN@?$AN?$AA@			; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$incrementalnewlinedecoder_newlines_get DD imagerel incrementalnewlinedecoder_newlines_get
	DD	imagerel incrementalnewlinedecoder_newlines_get+308
	DD	imagerel $unwind$incrementalnewlinedecoder_newlines_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$incrementalnewlinedecoder_newlines_get DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_03PFJENDKN@sss?$AA@
CONST	SEGMENT
??_C@_03PFJENDKN@sss?$AA@ DB 'sss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FCBLNKNB@ss?$AA@
CONST	SEGMENT
??_C@_02FCBLNKNB@ss?$AA@ DB 'ss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LIIJDEN@?$AN?$AA@
CONST	SEGMENT
??_C@_01LIIJDEN@?$AN?$AA@ DB 0dH, 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT incrementalnewlinedecoder_newlines_get
_TEXT	SEGMENT
self$ = 64
context$ = 72
incrementalnewlinedecoder_newlines_get PROC		; COMDAT

; 559  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 560  :     switch (self->seennl) {

  00004	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00007	c1 e8 02	 shr	 eax, 2
  0000a	83 e0 07	 and	 eax, 7
  0000d	ff c8		 dec	 eax
  0000f	83 f8 06	 cmp	 eax, 6
  00012	0f 87 ad 00 00
	00		 ja	 $LN1@incrementa@7
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0001f	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN17@incrementa@7[rdx+rax*4]
  00026	48 03 ca	 add	 rcx, rdx
  00029	ff e1		 jmp	 rcx
$LN8@incrementa@7:

; 561  :     case SEEN_CR:
; 562  :         return PyUnicode_FromString("\r");

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LIIJDEN@?$AN?$AA@

; 577  :    }
; 578  : 
; 579  : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN7@incrementa@7:

; 563  :     case SEEN_LF:
; 564  :         return PyUnicode_FromString("\n");

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@

; 577  :    }
; 578  : 
; 579  : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN6@incrementa@7:

; 565  :     case SEEN_CRLF:
; 566  :         return PyUnicode_FromString("\r\n");

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@

; 577  :    }
; 578  : 
; 579  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	e9 00 00 00 00	 jmp	 PyUnicode_FromString
$LN5@incrementa@7:

; 567  :     case SEEN_CR | SEEN_LF:
; 568  :         return Py_BuildValue("ss", "\r", "\n");

  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
$LN18@incrementa@7:
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LIIJDEN@?$AN?$AA@
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02FCBLNKNB@ss?$AA@

; 577  :    }
; 578  : 
; 579  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
$LN4@incrementa@7:

; 569  :     case SEEN_CR | SEEN_CRLF:
; 570  :         return Py_BuildValue("ss", "\r", "\r\n");

  00079	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  00080	eb e0		 jmp	 SHORT $LN18@incrementa@7
$LN3@incrementa@7:

; 571  :     case SEEN_LF | SEEN_CRLF:
; 572  :         return Py_BuildValue("ss", "\n", "\r\n");

  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02FCBLNKNB@ss?$AA@

; 577  :    }
; 578  : 
; 579  : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
$LN2@incrementa@7:

; 573  :     case SEEN_CR | SEEN_LF | SEEN_CRLF:
; 574  :         return Py_BuildValue("sss", "\r", "\n", "\r\n");

  000a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  000a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LIIJDEN@?$AN?$AA@
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03PFJENDKN@sss?$AA@

; 577  :    }
; 578  : 
; 579  : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	e9 00 00 00 00	 jmp	 _Py_BuildValue_SizeT
$LN1@incrementa@7:

; 575  :     default:
; 576  :         Py_RETURN_NONE;

  000c5	e8 00 00 00 00	 call	 _Py_PXCTX
  000ca	85 c0		 test	 eax, eax
  000cc	75 3c		 jne	 SHORT $LN14@incrementa@7
  000ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000e9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f6	85 c0		 test	 eax, eax
  000f8	75 09		 jne	 SHORT $LN13@incrementa@7
  000fa	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00101	74 07		 je	 SHORT $LN14@incrementa@7
$LN13@incrementa@7:
  00103	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN14@incrementa@7:
  0010a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 577  :    }
; 578  : 
; 579  : }

  00111	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00115	c3		 ret	 0
  00116	66 90		 npad	 2
$LN17@incrementa@7:
  00118	00 00 00 00	 DD	 $LN8@incrementa@7
  0011c	00 00 00 00	 DD	 $LN7@incrementa@7
  00120	00 00 00 00	 DD	 $LN5@incrementa@7
  00124	00 00 00 00	 DD	 $LN6@incrementa@7
  00128	00 00 00 00	 DD	 $LN4@incrementa@7
  0012c	00 00 00 00	 DD	 $LN3@incrementa@7
  00130	00 00 00 00	 DD	 $LN2@incrementa@7
incrementalnewlinedecoder_newlines_get ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_AsASCIIString:PROC
; Function compile flags: /Ogtpy
;	COMDAT ascii_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
ascii_encode PROC					; COMDAT

; 738  : {

  00000	48 8b c2	 mov	 rax, rdx

; 739  :     return _PyUnicode_AsASCIIString(text, PyBytes_AS_STRING(self->errors));

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0000e	48 8b c8	 mov	 rcx, rax

; 740  : }

  00011	e9 00 00 00 00	 jmp	 _PyUnicode_AsASCIIString
ascii_encode ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_EncodeUTF16:PROC
; Function compile flags: /Ogtpy
;	COMDAT utf16be_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf16be_encode PROC					; COMDAT

; 744  : {

  00000	48 8b c2	 mov	 rax, rdx

; 745  :     return _PyUnicode_EncodeUTF16(text,
; 746  :                                   PyBytes_AS_STRING(self->errors), 1);

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00014	48 8b c8	 mov	 rcx, rax

; 747  : }

  00017	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF16
utf16be_encode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT utf16le_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf16le_encode PROC					; COMDAT

; 751  : {

  00000	48 8b c2	 mov	 rax, rdx

; 752  :     return _PyUnicode_EncodeUTF16(text,
; 753  :                                   PyBytes_AS_STRING(self->errors), -1);

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	41 83 c8 ff	 or	 r8d, -1
  0000e	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00012	48 8b c8	 mov	 rcx, rax

; 754  : }

  00015	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF16
utf16le_encode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT utf16_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf16_encode PROC					; COMDAT

; 759  :     if (!self->encoding_start_of_stream) {

  00000	80 b9 c0 00 00
	00 00		 cmp	 BYTE PTR [rcx+192], 0
  00007	48 8b c2	 mov	 rax, rdx
  0000a	75 05		 jne	 SHORT $LN1@utf16_enco

; 769  : }

  0000c	e9 00 00 00 00	 jmp	 utf16le_encode
$LN1@utf16_enco:

; 760  :         /* Skip the BOM and use native byte ordering */
; 761  : #if defined(WORDS_BIGENDIAN)
; 762  :         return utf16be_encode(self, text);
; 763  : #else
; 764  :         return utf16le_encode(self, text);
; 765  : #endif
; 766  :     }
; 767  :     return _PyUnicode_EncodeUTF16(text,
; 768  :                                   PyBytes_AS_STRING(self->errors), 0);

  00011	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	48 83 c2 78	 add	 rdx, 120		; 00000078H

; 769  : }

  00022	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF16
utf16_encode ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_EncodeUTF32:PROC
; Function compile flags: /Ogtpy
;	COMDAT utf32be_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf32be_encode PROC					; COMDAT

; 773  : {

  00000	48 8b c2	 mov	 rax, rdx

; 774  :     return _PyUnicode_EncodeUTF32(text,
; 775  :                                   PyBytes_AS_STRING(self->errors), 1);

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00010	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00014	48 8b c8	 mov	 rcx, rax

; 776  : }

  00017	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF32
utf32be_encode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT utf32le_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf32le_encode PROC					; COMDAT

; 780  : {

  00000	48 8b c2	 mov	 rax, rdx

; 781  :     return _PyUnicode_EncodeUTF32(text,
; 782  :                                   PyBytes_AS_STRING(self->errors), -1);

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	41 83 c8 ff	 or	 r8d, -1
  0000e	48 83 c2 78	 add	 rdx, 120		; 00000078H
  00012	48 8b c8	 mov	 rcx, rax

; 783  : }

  00015	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF32
utf32le_encode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT utf32_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf32_encode PROC					; COMDAT

; 788  :     if (!self->encoding_start_of_stream) {

  00000	80 b9 c0 00 00
	00 00		 cmp	 BYTE PTR [rcx+192], 0
  00007	48 8b c2	 mov	 rax, rdx
  0000a	75 05		 jne	 SHORT $LN1@utf32_enco

; 798  : }

  0000c	e9 00 00 00 00	 jmp	 utf32le_encode
$LN1@utf32_enco:

; 789  :         /* Skip the BOM and use native byte ordering */
; 790  : #if defined(WORDS_BIGENDIAN)
; 791  :         return utf32be_encode(self, text);
; 792  : #else
; 793  :         return utf32le_encode(self, text);
; 794  : #endif
; 795  :     }
; 796  :     return _PyUnicode_EncodeUTF32(text,
; 797  :                                   PyBytes_AS_STRING(self->errors), 0);

  00011	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	48 83 c2 78	 add	 rdx, 120		; 00000078H

; 798  : }

  00022	e9 00 00 00 00	 jmp	 _PyUnicode_EncodeUTF32
utf32_encode ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_AsUTF8String:PROC
; Function compile flags: /Ogtpy
;	COMDAT utf8_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
utf8_encode PROC					; COMDAT

; 802  : {

  00000	48 8b c2	 mov	 rax, rdx

; 803  :     return _PyUnicode_AsUTF8String(text, PyBytes_AS_STRING(self->errors));

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0000e	48 8b c8	 mov	 rcx, rax

; 804  : }

  00011	e9 00 00 00 00	 jmp	 _PyUnicode_AsUTF8String
utf8_encode ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_AsLatin1String:PROC
; Function compile flags: /Ogtpy
;	COMDAT latin1_encode
_TEXT	SEGMENT
self$ = 8
text$ = 16
latin1_encode PROC					; COMDAT

; 808  : {

  00000	48 8b c2	 mov	 rax, rdx

; 809  :     return _PyUnicode_AsLatin1String(text, PyBytes_AS_STRING(self->errors));

  00003	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0000a	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0000e	48 8b c8	 mov	 rcx, rax

; 810  : }

  00011	e9 00 00 00 00	 jmp	 _PyUnicode_AsLatin1String
latin1_encode ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0O@GMEBLPNI@codecs?4open?$CI?$CJ?$AA@	; `string'
PUBLIC	??_C@_0CF@FHPGGAPJ@could?5not?5determine?5default?5enco@ ; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_06NDGIILMC@locale?$AA@			; `string'
PUBLIC	??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@	; `string'
PUBLIC	??_C@_0BK@JHIONHDL@illegal?5newline?5value?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0P@NPGFHFNH@O?$HMzzzii?3fileio?$AA@	; `string'
PUBLIC	??_C@_0O@GLPNNNBD@write_through?$AA@		; `string'
PUBLIC	??_C@_07NADKJHCJ@newline?$AA@			; `string'
EXTRN	_PyIO_str_setstate:QWORD
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	_PyIO_zero:QWORD
EXTRN	_PyIO_str_tell:QWORD
EXTRN	_PyObject_HasAttrId:PROC
EXTRN	PyFileIO_Type:BYTE
EXTRN	PyBufferedRandom_Type:BYTE
EXTRN	PyBufferedWriter_Type:BYTE
EXTRN	PyBufferedReader_Type:BYTE
EXTRN	PyUnicode_CompareWithASCIIString:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_PyCodecInfo_GetIncrementalEncoder:PROC
EXTRN	_PyObject_CallFunction_SizeT:PROC
EXTRN	_PyCodecInfo_GetIncrementalDecoder:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	_PyCodec_LookupTextEncoding:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyImport_ImportModule:PROC
EXTRN	_Py_device_encoding:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyLong_AsInt:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiowrapper_init DD imagerel textiowrapper_init
	DD	imagerel textiowrapper_init+972
	DD	imagerel $unwind$textiowrapper_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_init DD imagerel textiowrapper_init+972
	DD	imagerel textiowrapper_init+2834
	DD	imagerel $chain$0$textiowrapper_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_init DD imagerel textiowrapper_init+2834
	DD	imagerel textiowrapper_init+2857
	DD	imagerel $chain$1$textiowrapper_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_init DD 021H
	DD	imagerel textiowrapper_init
	DD	imagerel textiowrapper_init+972
	DD	imagerel $unwind$textiowrapper_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_init DD 020821H
	DD	01dc408H
	DD	imagerel textiowrapper_init
	DD	imagerel textiowrapper_init+972
	DD	imagerel $unwind$textiowrapper_init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_init DD 091801H
	DD	01e3418H
	DD	0160118H
	DD	0d00af00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GMEBLPNI@codecs?4open?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@GMEBLPNI@codecs?4open?$CI?$CJ?$AA@ DB 'codecs.open()', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FHPGGAPJ@could?5not?5determine?5default?5enco@
CONST	SEGMENT
??_C@_0CF@FHPGGAPJ@could?5not?5determine?5default?5enco@ DB 'could not de'
	DB	'termine default encoding', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06NDGIILMC@locale?$AA@
CONST	SEGMENT
??_C@_06NDGIILMC@locale?$AA@ DB 'locale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
CONST	SEGMENT
??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@ DB 'textiowrapper_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JHIONHDL@illegal?5newline?5value?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BK@JHIONHDL@illegal?5newline?5value?3?5?$CFs?$AA@ DB 'illegal newl'
	DB	'ine value: %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NPGFHFNH@O?$HMzzzii?3fileio?$AA@
CONST	SEGMENT
??_C@_0P@NPGFHFNH@O?$HMzzzii?3fileio?$AA@ DB 'O|zzzii:fileio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLPNNNBD@write_through?$AA@
CONST	SEGMENT
??_C@_0O@GLPNNNBD@write_through?$AA@ DB 'write_through', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07NADKJHCJ@newline?$AA@
CONST	SEGMENT
??_C@_07NADKJHCJ@newline?$AA@ DB 'newline', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT textiowrapper_init
_TEXT	SEGMENT
buffer$ = 80
encoding$ = 88
errors$ = 96
newline$ = 104
kwlist$ = 112
line_buffering$ = 224
self$ = 224
args$ = 232
kwds$ = 240
write_through$ = 248
textiowrapper_init PROC					; COMDAT

; 835  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 55		 push	 r13
  0000a	41 57		 push	 r15
  0000c	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  00011	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 836  :     char *kwlist[] = {"buffer", "encoding", "errors",
; 837  :                       "newline", "line_buffering", "write_through",
; 838  :                       NULL};

  00018	45 33 ff	 xor	 r15d, r15d
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06HOHPNJLC@buffer?$AA@
  00022	48 8b d9	 mov	 rbx, rcx
  00025	48 89 45 f7	 mov	 QWORD PTR kwlist$[rbp-121], rax
  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08MLPGAEIK@encoding?$AA@

; 839  :     PyObject *buffer, *raw, *codec_info = NULL;
; 840  :     char *encoding = NULL;
; 841  :     char *errors = NULL;
; 842  :     char *newline = NULL;
; 843  :     int line_buffering = 0, write_through = 0;
; 844  :     _PyIO_State *state = IO_STATE;

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyIO_Module
  00037	48 89 45 ff	 mov	 QWORD PTR kwlist$[rbp-113], rax
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EOMHCNPI@errors?$AA@
  00042	49 8b f8	 mov	 rdi, r8
  00045	48 89 45 07	 mov	 QWORD PTR kwlist$[rbp-105], rax
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07NADKJHCJ@newline?$AA@
  00050	48 8b f2	 mov	 rsi, rdx
  00053	48 89 45 0f	 mov	 QWORD PTR kwlist$[rbp-97], rax
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@MGPKIIND@line_buffering?$AA@
  0005e	4c 89 7d 27	 mov	 QWORD PTR kwlist$[rbp-73], r15
  00062	48 89 45 17	 mov	 QWORD PTR kwlist$[rbp-89], rax
  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@GLPNNNBD@write_through?$AA@
  0006d	4c 89 7d df	 mov	 QWORD PTR encoding$[rbp-121], r15
  00071	4c 89 7d e7	 mov	 QWORD PTR errors$[rbp-121], r15
  00075	4c 89 7d ef	 mov	 QWORD PTR newline$[rbp-121], r15
  00079	44 89 7d 67	 mov	 DWORD PTR line_buffering$[rbp-121], r15d
  0007d	48 89 45 1f	 mov	 QWORD PTR kwlist$[rbp-81], rax
  00081	44 89 7d 7f	 mov	 DWORD PTR write_through$[rbp-121], r15d
  00085	e8 00 00 00 00	 call	 PyState_FindModule
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 PyModule_GetState

; 845  : 
; 846  :     PyObject *res;
; 847  :     int r;
; 848  : 
; 849  :     self->ok = 0;
; 850  :     self->detached = 0;
; 851  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|zzzii:fileio",
; 852  :                                      kwlist, &buffer, &encoding, &errors,
; 853  :                                      &newline, &line_buffering, &write_through))

  00092	4c 8d 4d f7	 lea	 r9, QWORD PTR kwlist$[rbp-121]
  00096	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@NPGFHFNH@O?$HMzzzii?3fileio?$AA@
  0009d	4c 8b e8	 mov	 r13, rax
  000a0	48 8d 45 7f	 lea	 rax, QWORD PTR write_through$[rbp-121]
  000a4	48 8b d7	 mov	 rdx, rdi
  000a7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000ac	48 8d 45 67	 lea	 rax, QWORD PTR line_buffering$[rbp-121]
  000b0	48 8b ce	 mov	 rcx, rsi
  000b3	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000b8	48 8d 45 ef	 lea	 rax, QWORD PTR newline$[rbp-121]
  000bc	4c 89 7b 60	 mov	 QWORD PTR [rbx+96], r15
  000c0	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c5	48 8d 45 e7	 lea	 rax, QWORD PTR errors$[rbp-121]
  000c9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ce	48 8d 45 df	 lea	 rax, QWORD PTR encoding$[rbp-121]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	48 8d 45 d7	 lea	 rax, QWORD PTR buffer$[rbp-121]
  000db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e0	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000e5	85 c0		 test	 eax, eax

; 854  :         return -1;

  000e7	74 45		 je	 SHORT $LN161@textiowrap

; 855  : 
; 856  :     if (newline && newline[0] != '\0'
; 857  :         && !(newline[0] == '\n' && newline[1] == '\0')
; 858  :         && !(newline[0] == '\r' && newline[1] == '\0')
; 859  :         && !(newline[0] == '\r' && newline[1] == '\n' && newline[2] == '\0')) {

  000e9	4c 8b 45 ef	 mov	 r8, QWORD PTR newline$[rbp-121]
  000ed	4d 85 c0	 test	 r8, r8
  000f0	74 44		 je	 SHORT $LN132@textiowrap
  000f2	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  000f6	84 c0		 test	 al, al
  000f8	74 3c		 je	 SHORT $LN132@textiowrap
  000fa	3c 0a		 cmp	 al, 10
  000fc	75 06		 jne	 SHORT $LN135@textiowrap
  000fe	45 38 78 01	 cmp	 BYTE PTR [r8+1], r15b
  00102	74 32		 je	 SHORT $LN132@textiowrap
$LN135@textiowrap:
  00104	3c 0d		 cmp	 al, 13
  00106	75 13		 jne	 SHORT $LN133@textiowrap
  00108	41 0f b6 40 01	 movzx	 eax, BYTE PTR [r8+1]
  0010d	84 c0		 test	 al, al
  0010f	74 25		 je	 SHORT $LN132@textiowrap
  00111	3c 0a		 cmp	 al, 10
  00113	75 06		 jne	 SHORT $LN133@textiowrap
  00115	45 38 78 02	 cmp	 BYTE PTR [r8+2], r15b
  00119	74 1b		 je	 SHORT $LN132@textiowrap
$LN133@textiowrap:

; 860  :         PyErr_Format(PyExc_ValueError,
; 861  :                      "illegal newline value: %s", newline);

  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@JHIONHDL@illegal?5newline?5value?3?5?$CFs?$AA@
  00129	e8 00 00 00 00	 call	 PyErr_Format
$LN161@textiowrap:

; 862  :         return -1;

  0012e	83 c8 ff	 or	 eax, -1
  00131	e9 dc 09 00 00	 jmp	 $LN138@textiowrap
$LN132@textiowrap:

; 863  :     }
; 864  : 
; 865  :     Py_CLEAR(self->buffer);

  00136	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  0013a	4d 85 c9	 test	 r9, r9
  0013d	74 32		 je	 SHORT $LN131@textiowrap
  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  0014d	41 b8 61 03 00
	00		 mov	 r8d, 865		; 00000361H
  00153	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0015b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00160	85 c0		 test	 eax, eax
  00162	75 0d		 jne	 SHORT $LN131@textiowrap
  00164	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00168	4c 89 7b 70	 mov	 QWORD PTR [rbx+112], r15
  0016c	e8 00 00 00 00	 call	 _Py_DecRef
$LN131@textiowrap:

; 866  :     Py_CLEAR(self->encoding);

  00171	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  00175	4d 85 c9	 test	 r9, r9
  00178	74 32		 je	 SHORT $LN127@textiowrap
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  00188	41 b8 62 03 00
	00		 mov	 r8d, 866		; 00000362H
  0018e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00196	e8 00 00 00 00	 call	 _PyParallel_Guard
  0019b	85 c0		 test	 eax, eax
  0019d	75 0d		 jne	 SHORT $LN127@textiowrap
  0019f	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  001a3	4c 89 7b 78	 mov	 QWORD PTR [rbx+120], r15
  001a7	e8 00 00 00 00	 call	 _Py_DecRef
$LN127@textiowrap:

; 867  :     Py_CLEAR(self->encoder);

  001ac	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  001b3	4d 85 c9	 test	 r9, r9
  001b6	74 38		 je	 SHORT $LN123@textiowrap
  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  001c6	41 b8 63 03 00
	00		 mov	 r8d, 867		; 00000363H
  001cc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d4	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d9	85 c0		 test	 eax, eax
  001db	75 13		 jne	 SHORT $LN123@textiowrap
  001dd	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  001e4	4c 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r15
  001eb	e8 00 00 00 00	 call	 _Py_DecRef
$LN123@textiowrap:

; 868  :     Py_CLEAR(self->decoder);

  001f0	4c 8b 8b 88 00
	00 00		 mov	 r9, QWORD PTR [rbx+136]
  001f7	4d 85 c9	 test	 r9, r9
  001fa	74 38		 je	 SHORT $LN119@textiowrap
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  0020a	41 b8 64 03 00
	00		 mov	 r8d, 868		; 00000364H
  00210	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00218	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021d	85 c0		 test	 eax, eax
  0021f	75 13		 jne	 SHORT $LN119@textiowrap
  00221	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00228	4c 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r15
  0022f	e8 00 00 00 00	 call	 _Py_DecRef
$LN119@textiowrap:

; 869  :     Py_CLEAR(self->readnl);

  00234	4c 8b 8b 90 00
	00 00		 mov	 r9, QWORD PTR [rbx+144]
  0023b	4d 85 c9	 test	 r9, r9
  0023e	74 38		 je	 SHORT $LN115@textiowrap
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  0024e	41 b8 65 03 00
	00		 mov	 r8d, 869		; 00000365H
  00254	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0025c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00261	85 c0		 test	 eax, eax
  00263	75 13		 jne	 SHORT $LN115@textiowrap
  00265	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  0026c	4c 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], r15
  00273	e8 00 00 00 00	 call	 _Py_DecRef
$LN115@textiowrap:

; 870  :     Py_CLEAR(self->decoded_chars);

  00278	4c 8b 8b c8 00
	00 00		 mov	 r9, QWORD PTR [rbx+200]
  0027f	4d 85 c9	 test	 r9, r9
  00282	74 38		 je	 SHORT $LN111@textiowrap
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  00292	41 b8 66 03 00
	00		 mov	 r8d, 870		; 00000366H
  00298	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002a0	e8 00 00 00 00	 call	 _PyParallel_Guard
  002a5	85 c0		 test	 eax, eax
  002a7	75 13		 jne	 SHORT $LN111@textiowrap
  002a9	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  002b0	4c 89 bb c8 00
	00 00		 mov	 QWORD PTR [rbx+200], r15
  002b7	e8 00 00 00 00	 call	 _Py_DecRef
$LN111@textiowrap:

; 871  :     Py_CLEAR(self->pending_bytes);

  002bc	4c 8b 8b d8 00
	00 00		 mov	 r9, QWORD PTR [rbx+216]
  002c3	4d 85 c9	 test	 r9, r9
  002c6	74 38		 je	 SHORT $LN107@textiowrap
  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  002d6	41 b8 67 03 00
	00		 mov	 r8d, 871		; 00000367H
  002dc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002e4	e8 00 00 00 00	 call	 _PyParallel_Guard
  002e9	85 c0		 test	 eax, eax
  002eb	75 13		 jne	 SHORT $LN107@textiowrap
  002ed	48 8b 8b d8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+216]
  002f4	4c 89 bb d8 00
	00 00		 mov	 QWORD PTR [rbx+216], r15
  002fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN107@textiowrap:

; 872  :     Py_CLEAR(self->snapshot);

  00300	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  00307	4d 85 c9	 test	 r9, r9
  0030a	74 38		 je	 SHORT $LN103@textiowrap
  0030c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  0031a	41 b8 68 03 00
	00		 mov	 r8d, 872		; 00000368H
  00320	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00328	e8 00 00 00 00	 call	 _PyParallel_Guard
  0032d	85 c0		 test	 eax, eax
  0032f	75 13		 jne	 SHORT $LN103@textiowrap
  00331	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  00338	4c 89 bb e8 00
	00 00		 mov	 QWORD PTR [rbx+232], r15
  0033f	e8 00 00 00 00	 call	 _Py_DecRef
$LN103@textiowrap:

; 873  :     Py_CLEAR(self->errors);

  00344	4c 8b 8b 98 00
	00 00		 mov	 r9, QWORD PTR [rbx+152]
  0034b	4d 85 c9	 test	 r9, r9
  0034e	74 38		 je	 SHORT $LN99@textiowrap
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  0035e	41 b8 69 03 00
	00		 mov	 r8d, 873		; 00000369H
  00364	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0036c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00371	85 c0		 test	 eax, eax
  00373	75 13		 jne	 SHORT $LN99@textiowrap
  00375	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  0037c	4c 89 bb 98 00
	00 00		 mov	 QWORD PTR [rbx+152], r15
  00383	e8 00 00 00 00	 call	 _Py_DecRef
$LN99@textiowrap:

; 874  :     Py_CLEAR(self->raw);

  00388	4c 8b 8b f8 00
	00 00		 mov	 r9, QWORD PTR [rbx+248]
  0038f	4d 85 c9	 test	 r9, r9
  00392	74 38		 je	 SHORT $LN95@textiowrap
  00394	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  003a2	41 b8 6a 03 00
	00		 mov	 r8d, 874		; 0000036aH
  003a8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  003b5	85 c0		 test	 eax, eax
  003b7	75 13		 jne	 SHORT $LN95@textiowrap
  003b9	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  003c0	4c 89 bb f8 00
	00 00		 mov	 QWORD PTR [rbx+248], r15
  003c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN95@textiowrap:

; 875  :     self->decoded_chars_used = 0;

  003cc	4c 89 a4 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], r12
  003d4	4c 89 bb d0 00
	00 00		 mov	 QWORD PTR [rbx+208], r15

; 876  :     self->pending_bytes_count = 0;

  003db	4c 89 bb e0 00
	00 00		 mov	 QWORD PTR [rbx+224], r15

; 877  :     self->encodefunc = NULL;

  003e2	4c 89 bb b8 00
	00 00		 mov	 QWORD PTR [rbx+184], r15

; 878  :     self->b2cratio = 0.0;

  003e9	4c 89 bb f0 00
	00 00		 mov	 QWORD PTR [rbx+240], r15

; 879  : 
; 880  :     if (encoding == NULL) {

  003f0	4c 39 7d df	 cmp	 QWORD PTR encoding$[rbp-121], r15
  003f4	0f 85 9c 01 00
	00		 jne	 $LN66@textiowrap

; 881  :         /* Try os.device_encoding(fileno) */
; 882  :         PyObject *fileno;
; 883  :         fileno = _PyObject_CallMethodId(buffer, &PyId_fileno, NULL);

  003fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00400	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00409	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_fileno
  0040e	4c 8b 24 c8	 mov	 r12, QWORD PTR [rax+rcx*8]
  00412	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  00416	45 33 c0	 xor	 r8d, r8d
  00419	49 03 d4	 add	 rdx, r12
  0041c	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00421	48 8b f8	 mov	 rdi, rax

; 884  :         /* Ignore only AttributeError and UnsupportedOperation */
; 885  :         if (fileno == NULL) {

  00424	48 85 c0	 test	 rax, rax
  00427	75 28		 jne	 SHORT $LN91@textiowrap

; 886  :             if (PyErr_ExceptionMatches(PyExc_AttributeError) ||
; 887  :                 PyErr_ExceptionMatches(state->unsupported_operation)) {

  00429	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00430	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00435	85 c0		 test	 eax, eax
  00437	75 11		 jne	 SHORT $LN89@textiowrap
  00439	49 8b 4d 10	 mov	 rcx, QWORD PTR [r13+16]
  0043d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00442	85 c0		 test	 eax, eax
  00444	0f 84 bd 06 00
	00		 je	 $LN3@textiowrap
$LN89@textiowrap:

; 888  :                 PyErr_Clear();

  0044a	e8 00 00 00 00	 call	 PyErr_Clear

; 889  :             }
; 890  :             else {
; 891  :                 goto error;
; 892  :             }
; 893  :         }
; 894  :         else {

  0044f	eb 7e		 jmp	 SHORT $LN80@textiowrap
$LN91@textiowrap:

; 895  :             int fd = _PyLong_AsInt(fileno);

  00451	48 8b c8	 mov	 rcx, rax
  00454	e8 00 00 00 00	 call	 _PyLong_AsInt

; 896  :             Py_DECREF(fileno);

  00459	48 8b cf	 mov	 rcx, rdi
  0045c	8b f0		 mov	 esi, eax
  0045e	e8 00 00 00 00	 call	 _Py_DecRef

; 897  :             if (fd == -1 && PyErr_Occurred()) {

  00463	83 fe ff	 cmp	 esi, -1
  00466	75 0e		 jne	 SHORT $LN86@textiowrap
  00468	e8 00 00 00 00	 call	 PyErr_Occurred
  0046d	48 85 c0	 test	 rax, rax
  00470	0f 85 91 06 00
	00		 jne	 $LN3@textiowrap
$LN86@textiowrap:

; 898  :                 goto error;
; 899  :             }
; 900  : 
; 901  :             self->encoding = _Py_device_encoding(fd);

  00476	8b ce		 mov	 ecx, esi
  00478	e8 00 00 00 00	 call	 _Py_device_encoding
  0047d	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 902  :             if (self->encoding == NULL)

  00481	48 85 c0	 test	 rax, rax
  00484	0f 84 7d 06 00
	00		 je	 $LN3@textiowrap

; 903  :                 goto error;
; 904  :             else if (!PyUnicode_Check(self->encoding))

  0048a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0048e	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  00498	75 35		 jne	 SHORT $LN80@textiowrap

; 905  :                 Py_CLEAR(self->encoding);

  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  004a8	4c 8b c8	 mov	 r9, rax
  004ab	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  004b1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  004be	85 c0		 test	 eax, eax
  004c0	75 0d		 jne	 SHORT $LN80@textiowrap
  004c2	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  004c6	4c 89 7b 78	 mov	 QWORD PTR [rbx+120], r15
  004ca	e8 00 00 00 00	 call	 _Py_DecRef
$LN80@textiowrap:

; 906  :         }
; 907  :     }
; 908  :     if (encoding == NULL && self->encoding == NULL) {

  004cf	4c 39 7d df	 cmp	 QWORD PTR encoding$[rbp-121], r15
  004d3	0f 85 bd 00 00
	00		 jne	 $LN66@textiowrap
  004d9	4c 39 7b 78	 cmp	 QWORD PTR [rbx+120], r15
  004dd	0f 85 b3 00 00
	00		 jne	 $LN66@textiowrap

; 909  :         if (state->locale_module == NULL) {

  004e3	4d 39 7d 08	 cmp	 QWORD PTR [r13+8], r15
  004e7	75 15		 jne	 SHORT $use_locale$21323

; 910  :             state->locale_module = PyImport_ImportModule("locale");

  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06NDGIILMC@locale?$AA@
  004f0	e8 00 00 00 00	 call	 PyImport_ImportModule
  004f5	49 89 45 08	 mov	 QWORD PTR [r13+8], rax

; 911  :             if (state->locale_module == NULL)

  004f9	48 85 c0	 test	 rax, rax
  004fc	74 2b		 je	 SHORT $catch_ImportError$21321
$use_locale$21323:

; 912  :                 goto catch_ImportError;
; 913  :             else
; 914  :                 goto use_locale;
; 915  :         }
; 916  :         else {
; 917  :           use_locale:
; 918  :             self->encoding = _PyObject_CallMethodId(
; 919  :                 state->locale_module, &PyId_getpreferredencoding, "O", Py_False);

  004fe	49 8b 4d 08	 mov	 rcx, QWORD PTR [r13+8]
  00502	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_getpreferredencoding
  00507	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0050e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  00515	49 03 d4	 add	 rdx, r12
  00518	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  0051d	4c 8b c8	 mov	 r9, rax
  00520	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 920  :             if (self->encoding == NULL) {

  00524	48 85 c0	 test	 rax, rax
  00527	75 2b		 jne	 SHORT $LN73@textiowrap
$catch_ImportError$21321:

; 921  :               catch_ImportError:
; 922  :                 /*
; 923  :                  Importing locale can raise a ImportError because of
; 924  :                  _functools, and locale.getpreferredencoding can raise a
; 925  :                  ImportError if _locale is not available.  These will happen
; 926  :                  during module building.
; 927  :                 */
; 928  :                 if (PyErr_ExceptionMatches(PyExc_ImportError)) {

  00529	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00530	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00535	85 c0		 test	 eax, eax
  00537	0f 84 ca 05 00
	00		 je	 $LN3@textiowrap

; 929  :                     PyErr_Clear();

  0053d	e8 00 00 00 00	 call	 PyErr_Clear

; 930  :                     self->encoding = PyUnicode_FromString("ascii");

  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OJENGABA@ascii?$AA@
  00549	e8 00 00 00 00	 call	 PyUnicode_FromString
  0054e	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 931  :                 }
; 932  :                 else
; 933  :                     goto error;
; 934  :             }
; 935  :             else if (!PyUnicode_Check(self->encoding))

  00552	eb 42		 jmp	 SHORT $LN66@textiowrap
$LN73@textiowrap:
  00554	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00558	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00562	75 32		 jne	 SHORT $LN66@textiowrap

; 936  :                 Py_CLEAR(self->encoding);

  00564	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0056b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  00572	41 b8 a8 03 00
	00		 mov	 r8d, 936		; 000003a8H
  00578	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00580	e8 00 00 00 00	 call	 _PyParallel_Guard
  00585	85 c0		 test	 eax, eax
  00587	75 0d		 jne	 SHORT $LN66@textiowrap
  00589	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0058d	4c 89 7b 78	 mov	 QWORD PTR [rbx+120], r15
  00591	e8 00 00 00 00	 call	 _Py_DecRef
$LN66@textiowrap:

; 937  :         }
; 938  :     }
; 939  :     if (self->encoding != NULL) {

  00596	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0059a	48 85 c9	 test	 rcx, rcx
  0059d	74 14		 je	 SHORT $LN64@textiowrap

; 940  :         encoding = _PyUnicode_AsString(self->encoding);

  0059f	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  005a4	48 89 45 df	 mov	 QWORD PTR encoding$[rbp-121], rax

; 941  :         if (encoding == NULL)

  005a8	48 85 c0	 test	 rax, rax
  005ab	0f 84 56 05 00
	00		 je	 $LN3@textiowrap

; 942  :             goto error;
; 943  :     }
; 944  :     else if (encoding != NULL) {

  005b1	eb 34		 jmp	 SHORT $LN59@textiowrap
$LN64@textiowrap:
  005b3	48 8b 4d df	 mov	 rcx, QWORD PTR encoding$[rbp-121]
  005b7	48 85 c9	 test	 rcx, rcx
  005ba	74 14		 je	 SHORT $LN61@textiowrap

; 945  :         self->encoding = PyUnicode_FromString(encoding);

  005bc	e8 00 00 00 00	 call	 PyUnicode_FromString
  005c1	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 946  :         if (self->encoding == NULL)

  005c5	48 85 c0	 test	 rax, rax
  005c8	0f 84 39 05 00
	00		 je	 $LN3@textiowrap

; 947  :             goto error;
; 948  :     }
; 949  :     else {

  005ce	eb 13		 jmp	 SHORT $LN160@textiowrap
$LN61@textiowrap:

; 950  :         PyErr_SetString(PyExc_IOError,
; 951  :                         "could not determine default encoding");

  005d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  005d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FHPGGAPJ@could?5not?5determine?5default?5enco@
  005de	e8 00 00 00 00	 call	 PyErr_SetString
$LN160@textiowrap:
  005e3	48 8b 45 df	 mov	 rax, QWORD PTR encoding$[rbp-121]
$LN59@textiowrap:

; 952  :     }
; 953  : 
; 954  :     /* Check we have been asked for a real text encoding */
; 955  :     codec_info = _PyCodec_LookupTextEncoding(encoding, "codecs.open()");

  005e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@GMEBLPNI@codecs?4open?$CI?$CJ?$AA@
  005ee	48 8b c8	 mov	 rcx, rax
  005f1	e8 00 00 00 00	 call	 _PyCodec_LookupTextEncoding
  005f6	4c 8b e0	 mov	 r12, rax

; 956  :     if (codec_info == NULL) {

  005f9	48 85 c0	 test	 rax, rax
  005fc	75 48		 jne	 SHORT $LN58@textiowrap

; 957  :         Py_CLEAR(self->encoding);

  005fe	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  00602	4d 85 c9	 test	 r9, r9
  00605	0f 84 fc 04 00
	00		 je	 $LN3@textiowrap
  0060b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00612	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  00619	41 b8 bd 03 00
	00		 mov	 r8d, 957		; 000003bdH
  0061f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00627	e8 00 00 00 00	 call	 _PyParallel_Guard
  0062c	85 c0		 test	 eax, eax
  0062e	0f 85 d3 04 00
	00		 jne	 $LN3@textiowrap
  00634	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00638	4c 89 7b 78	 mov	 QWORD PTR [rbx+120], r15
  0063c	e8 00 00 00 00	 call	 _Py_DecRef

; 958  :         goto error;

  00641	e9 c1 04 00 00	 jmp	 $LN3@textiowrap
$LN58@textiowrap:

; 959  :     }
; 960  : 
; 961  :     /* XXX: Failures beyond this point have the potential to leak elements
; 962  :      * of the partially constructed object (like self->encoding)
; 963  :      */
; 964  : 
; 965  :     if (errors == NULL)

  00646	48 8b 45 e7	 mov	 rax, QWORD PTR errors$[rbp-121]
  0064a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00651	48 85 c0	 test	 rax, rax
  00654	48 0f 45 c8	 cmovne	 rcx, rax
  00658	48 89 4d e7	 mov	 QWORD PTR errors$[rbp-121], rcx

; 966  :         errors = "strict";
; 967  :     self->errors = PyBytes_FromString(errors);

  0065c	e8 00 00 00 00	 call	 PyBytes_FromString
  00661	48 89 83 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rax

; 968  :     if (self->errors == NULL)

  00668	48 85 c0	 test	 rax, rax
  0066b	0f 84 2e 04 00
	00		 je	 $error$21295

; 969  :         goto error;
; 970  : 
; 971  :     self->chunk_size = 8192;
; 972  :     self->readuniversal = (newline == NULL || newline[0] == '\0');

  00671	48 8b 4d ef	 mov	 rcx, QWORD PTR newline$[rbp-121]
  00675	48 c7 43 68 00
	20 00 00	 mov	 QWORD PTR [rbx+104], 8192 ; 00002000H
  0067d	48 85 c9	 test	 rcx, rcx
  00680	74 08		 je	 SHORT $LN140@textiowrap
  00682	41 8b c7	 mov	 eax, r15d
  00685	44 38 39	 cmp	 BYTE PTR [rcx], r15b
  00688	75 05		 jne	 SHORT $LN141@textiowrap
$LN140@textiowrap:
  0068a	b8 01 00 00 00	 mov	 eax, 1
$LN141@textiowrap:
  0068f	88 83 aa 00 00
	00		 mov	 BYTE PTR [rbx+170], al

; 973  :     self->line_buffering = line_buffering;

  00695	0f b6 45 67	 movzx	 eax, BYTE PTR line_buffering$[rbp-121]

; 974  :     self->write_through = write_through;
; 975  :     self->readtranslate = (newline == NULL);

  00699	48 85 c9	 test	 rcx, rcx
  0069c	88 83 a8 00 00
	00		 mov	 BYTE PTR [rbx+168], al
  006a2	0f b6 45 7f	 movzx	 eax, BYTE PTR write_through$[rbp-121]
  006a6	88 83 a9 00 00
	00		 mov	 BYTE PTR [rbx+169], al
  006ac	0f 94 c0	 sete	 al
  006af	88 83 ab 00 00
	00		 mov	 BYTE PTR [rbx+171], al

; 976  :     if (newline) {

  006b5	48 85 c9	 test	 rcx, rcx
  006b8	74 26		 je	 SHORT $LN142@textiowrap

; 977  :         self->readnl = PyUnicode_FromString(newline);

  006ba	e8 00 00 00 00	 call	 PyUnicode_FromString
  006bf	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax

; 978  :         if (self->readnl == NULL)

  006c6	48 85 c0	 test	 rax, rax
  006c9	0f 84 d0 03 00
	00		 je	 $error$21295

; 979  :             goto error;
; 980  :     }
; 981  :     self->writetranslate = (newline == NULL || newline[0] != '\0');

  006cf	48 8b 45 ef	 mov	 rax, QWORD PTR newline$[rbp-121]
  006d3	48 85 c0	 test	 rax, rax
  006d6	74 08		 je	 SHORT $LN142@textiowrap
  006d8	44 38 38	 cmp	 BYTE PTR [rax], r15b
  006db	41 8b c7	 mov	 eax, r15d
  006de	74 05		 je	 SHORT $LN143@textiowrap
$LN142@textiowrap:
  006e0	b8 01 00 00 00	 mov	 eax, 1
$LN143@textiowrap:
  006e5	88 83 ac 00 00
	00		 mov	 BYTE PTR [rbx+172], al

; 982  :     if (!self->readuniversal && self->readnl) {

  006eb	44 38 bb aa 00
	00 00		 cmp	 BYTE PTR [rbx+170], r15b
  006f2	75 3d		 jne	 SHORT $LN49@textiowrap
  006f4	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  006fb	48 85 c9	 test	 rcx, rcx
  006fe	74 31		 je	 SHORT $LN49@textiowrap

; 983  :         self->writenl = _PyUnicode_AsString(self->readnl);

  00700	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00705	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax

; 984  :         if (self->writenl == NULL)

  0070c	48 85 c0	 test	 rax, rax
  0070f	0f 84 8a 03 00
	00		 je	 $error$21295

; 985  :             goto error;
; 986  :         if (!strcmp(self->writenl, "\n"))

  00715	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0071c	48 8b f0	 mov	 rsi, rax
  0071f	b9 02 00 00 00	 mov	 ecx, 2
  00724	f3 a6		 repe cmpsb
  00726	75 17		 jne	 SHORT $LN46@textiowrap

; 987  :             self->writenl = NULL;

  00728	4c 89 bb a0 00
	00 00		 mov	 QWORD PTR [rbx+160], r15

; 988  :     }
; 989  : #ifdef MS_WINDOWS
; 990  :     else

  0072f	eb 0e		 jmp	 SHORT $LN46@textiowrap
$LN49@textiowrap:

; 991  :         self->writenl = "\r\n";

  00731	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  00738	48 89 83 a0 00
	00 00		 mov	 QWORD PTR [rbx+160], rax
$LN46@textiowrap:

; 992  : #endif
; 993  : 
; 994  :     /* Build the decoder object */
; 995  :     res = _PyObject_CallMethodId(buffer, &PyId_readable, NULL);

  0073f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00745	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0074e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_readable
  00753	4c 8b 2c c8	 mov	 r13, QWORD PTR [rax+rcx*8]
  00757	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  0075b	45 33 c0	 xor	 r8d, r8d
  0075e	49 03 d5	 add	 rdx, r13
  00761	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00766	48 8b f0	 mov	 rsi, rax

; 996  :     if (res == NULL)

  00769	48 85 c0	 test	 rax, rax
  0076c	0f 84 2d 03 00
	00		 je	 $error$21295

; 997  :         goto error;
; 998  :     r = PyObject_IsTrue(res);

  00772	48 8b c8	 mov	 rcx, rax
  00775	e8 00 00 00 00	 call	 PyObject_IsTrue

; 999  :     Py_DECREF(res);

  0077a	48 8b ce	 mov	 rcx, rsi
  0077d	8b f8		 mov	 edi, eax
  0077f	e8 00 00 00 00	 call	 _Py_DecRef

; 1000 :     if (r == -1)

  00784	83 ff ff	 cmp	 edi, -1
  00787	0f 84 12 03 00
	00		 je	 $error$21295

; 1001 :         goto error;
; 1002 :     if (r == 1) {

  0078d	83 ff 01	 cmp	 edi, 1
  00790	0f 85 9a 00 00
	00		 jne	 $LN41@textiowrap

; 1003 :         self->decoder = _PyCodecInfo_GetIncrementalDecoder(codec_info,
; 1004 :                                                            errors);

  00796	48 8b 55 e7	 mov	 rdx, QWORD PTR errors$[rbp-121]
  0079a	49 8b cc	 mov	 rcx, r12
  0079d	e8 00 00 00 00	 call	 _PyCodecInfo_GetIncrementalDecoder
  007a2	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax

; 1005 :         if (self->decoder == NULL)

  007a9	48 85 c0	 test	 rax, rax
  007ac	0f 84 ed 02 00
	00		 je	 $error$21295

; 1006 :             goto error;
; 1007 : 
; 1008 :         if (self->readuniversal) {

  007b2	44 38 bb aa 00
	00 00		 cmp	 BYTE PTR [rbx+170], r15b
  007b9	74 75		 je	 SHORT $LN41@textiowrap

; 1009 :             PyObject *incrementalDecoder = PyObject_CallFunction(
; 1010 :                 (PyObject *)&PyIncrementalNewlineDecoder_Type,
; 1011 :                 "Oi", self->decoder, (int)self->readtranslate);

  007bb	44 0f be 8b ab
	00 00 00	 movsx	 r9d, BYTE PTR [rbx+171]
  007c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  007ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  007d1	4c 8b c0	 mov	 r8, rax
  007d4	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  007d9	48 8b f8	 mov	 rdi, rax

; 1012 :             if (incrementalDecoder == NULL)

  007dc	48 85 c0	 test	 rax, rax
  007df	0f 84 ba 02 00
	00		 je	 $error$21295

; 1013 :                 goto error;
; 1014 :             Py_CLEAR(self->decoder);

  007e5	4c 8b 8b 88 00
	00 00		 mov	 r9, QWORD PTR [rbx+136]
  007ec	4d 85 c9	 test	 r9, r9
  007ef	74 38		 je	 SHORT $LN38@textiowrap
  007f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  007f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BFHKECHP@textiowrapper_init?$AA@
  007ff	41 b8 f6 03 00
	00		 mov	 r8d, 1014		; 000003f6H
  00805	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0080d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00812	85 c0		 test	 eax, eax
  00814	75 13		 jne	 SHORT $LN38@textiowrap
  00816	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  0081d	4c 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r15
  00824	e8 00 00 00 00	 call	 _Py_DecRef
$LN38@textiowrap:

; 1015 :             self->decoder = incrementalDecoder;

  00829	48 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rdi
$LN41@textiowrap:

; 1016 :         }
; 1017 :     }
; 1018 : 
; 1019 :     /* Build the encoder object */
; 1020 :     res = _PyObject_CallMethodId(buffer, &PyId_writable, NULL);

  00830	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  00834	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_writable
  00839	45 33 c0	 xor	 r8d, r8d
  0083c	49 03 d5	 add	 rdx, r13
  0083f	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00844	48 8b f8	 mov	 rdi, rax

; 1021 :     if (res == NULL)

  00847	48 85 c0	 test	 rax, rax
  0084a	0f 84 4f 02 00
	00		 je	 $error$21295

; 1022 :         goto error;
; 1023 :     r = PyObject_IsTrue(res);

  00850	48 8b c8	 mov	 rcx, rax
  00853	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1024 :     Py_DECREF(res);

  00858	48 8b cf	 mov	 rcx, rdi
  0085b	8b f0		 mov	 esi, eax
  0085d	e8 00 00 00 00	 call	 _Py_DecRef

; 1025 :     if (r == -1)

  00862	83 fe ff	 cmp	 esi, -1
  00865	0f 84 34 02 00
	00		 je	 $error$21295

; 1026 :         goto error;
; 1027 :     if (r == 1) {

  0086b	83 fe 01	 cmp	 esi, 1
  0086e	0f 85 9c 00 00
	00		 jne	 $LN21@textiowrap

; 1028 :         self->encoder = _PyCodecInfo_GetIncrementalEncoder(codec_info,
; 1029 :                                                            errors);

  00874	48 8b 55 e7	 mov	 rdx, QWORD PTR errors$[rbp-121]
  00878	49 8b cc	 mov	 rcx, r12
  0087b	e8 00 00 00 00	 call	 _PyCodecInfo_GetIncrementalEncoder
  00880	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 1030 :         if (self->encoder == NULL)

  00887	48 85 c0	 test	 rax, rax
  0088a	0f 84 0f 02 00
	00		 je	 $error$21295

; 1031 :             goto error;
; 1032 :         /* Get the normalized named of the codec */
; 1033 :         res = _PyObject_GetAttrId(codec_info, &PyId_name);

  00890	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_name
  00895	49 8b cc	 mov	 rcx, r12
  00898	49 03 d5	 add	 rdx, r13
  0089b	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  008a0	48 8b f0	 mov	 rsi, rax

; 1034 :         if (res == NULL) {

  008a3	48 85 c0	 test	 rax, rax
  008a6	75 1b		 jne	 SHORT $LN31@textiowrap

; 1035 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  008a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  008af	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  008b4	85 c0		 test	 eax, eax
  008b6	0f 84 e3 01 00
	00		 je	 $error$21295

; 1036 :                 PyErr_Clear();

  008bc	e8 00 00 00 00	 call	 PyErr_Clear

; 1037 :             else
; 1038 :                 goto error;
; 1039 :         }
; 1040 :         else if (PyUnicode_Check(res)) {

  008c1	eb 4d		 jmp	 SHORT $LN21@textiowrap
$LN31@textiowrap:
  008c3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008c7	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  008d1	74 35		 je	 SHORT $LN23@textiowrap

; 1041 :             encodefuncentry *e = encodefuncs;
; 1042 :             while (e->name != NULL) {

  008d3	4c 39 3d 00 00
	00 00		 cmp	 QWORD PTR encodefuncs, r15
  008da	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:encodefuncs
  008e1	74 25		 je	 SHORT $LN23@textiowrap
$LL26@textiowrap:

; 1043 :                 if (!PyUnicode_CompareWithASCIIString(res, e->name)) {

  008e3	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  008e6	48 8b ce	 mov	 rcx, rsi
  008e9	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  008ee	85 c0		 test	 eax, eax
  008f0	74 0b		 je	 SHORT $LN156@textiowrap

; 1045 :                     break;
; 1046 :                 }
; 1047 :                 e++;

  008f2	48 83 c7 10	 add	 rdi, 16
  008f6	4c 39 3f	 cmp	 QWORD PTR [rdi], r15
  008f9	75 e8		 jne	 SHORT $LL26@textiowrap

; 1043 :                 if (!PyUnicode_CompareWithASCIIString(res, e->name)) {

  008fb	eb 0b		 jmp	 SHORT $LN23@textiowrap
$LN156@textiowrap:

; 1044 :                     self->encodefunc = e->encodefunc;

  008fd	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00901	48 89 83 b8 00
	00 00		 mov	 QWORD PTR [rbx+184], rax
$LN23@textiowrap:

; 1048 :             }
; 1049 :         }
; 1050 :         Py_XDECREF(res);

  00908	48 8b ce	 mov	 rcx, rsi
  0090b	e8 00 00 00 00	 call	 _Py_DecRef
$LN21@textiowrap:

; 1051 :     }
; 1052 : 
; 1053 :     /* Finished sorting out the codec details */
; 1054 :     Py_DECREF(codec_info);

  00910	49 8b cc	 mov	 rcx, r12
  00913	e8 00 00 00 00	 call	 _Py_DecRef

; 1055 : 
; 1056 :     self->buffer = buffer;

  00918	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  0091c	48 89 4b 70	 mov	 QWORD PTR [rbx+112], rcx

; 1057 :     Py_INCREF(buffer);

  00920	e8 00 00 00 00	 call	 _Py_IncRef

; 1058 : 
; 1059 :     if (Py_TYPE(buffer) == &PyBufferedReader_Type ||
; 1060 :         Py_TYPE(buffer) == &PyBufferedWriter_Type ||
; 1061 :         Py_TYPE(buffer) == &PyBufferedRandom_Type) {

  00925	48 8b 55 d7	 mov	 rdx, QWORD PTR buffer$[rbp-121]
  00929	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0092d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedReader_Type
  00934	48 3b c1	 cmp	 rax, rcx
  00937	74 18		 je	 SHORT $LN18@textiowrap
  00939	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedWriter_Type
  00940	48 3b c1	 cmp	 rax, rcx
  00943	74 0c		 je	 SHORT $LN18@textiowrap
  00945	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyBufferedRandom_Type
  0094c	48 3b c1	 cmp	 rax, rcx
  0094f	75 4f		 jne	 SHORT $LN12@textiowrap
$LN18@textiowrap:

; 1062 :         raw = _PyObject_GetAttrId(buffer, &PyId_raw);

  00951	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  00955	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_raw
  0095a	49 03 d5	 add	 rdx, r13
  0095d	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 1063 :         /* Cache the raw FileIO object to speed up 'closed' checks */
; 1064 :         if (raw == NULL) {

  00962	48 85 c0	 test	 rax, rax
  00965	75 1b		 jne	 SHORT $LN17@textiowrap

; 1065 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00967	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0096e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00973	85 c0		 test	 eax, eax
  00975	0f 84 24 01 00
	00		 je	 $error$21295

; 1066 :                 PyErr_Clear();

  0097b	e8 00 00 00 00	 call	 PyErr_Clear

; 1067 :             else
; 1068 :                 goto error;
; 1069 :         }
; 1070 :         else if (Py_TYPE(raw) == &PyFileIO_Type)

  00980	eb 1e		 jmp	 SHORT $LN12@textiowrap
$LN17@textiowrap:
  00982	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFileIO_Type
  00989	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  0098d	75 09		 jne	 SHORT $LN13@textiowrap

; 1071 :             self->raw = raw;

  0098f	48 89 83 f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rax

; 1072 :         else

  00996	eb 08		 jmp	 SHORT $LN12@textiowrap
$LN13@textiowrap:

; 1073 :             Py_DECREF(raw);

  00998	48 8b c8	 mov	 rcx, rax
  0099b	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@textiowrap:

; 1074 :     }
; 1075 : 
; 1076 :     res = _PyObject_CallMethodId(buffer, &PyId_seekable, NULL);

  009a0	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  009a4	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_seekable
  009a9	45 33 c0	 xor	 r8d, r8d
  009ac	49 03 d5	 add	 rdx, r13
  009af	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  009b4	48 8b f8	 mov	 rdi, rax

; 1077 :     if (res == NULL)

  009b7	48 85 c0	 test	 rax, rax
  009ba	0f 84 df 00 00
	00		 je	 $error$21295

; 1078 :         goto error;
; 1079 :     r = PyObject_IsTrue(res);

  009c0	48 8b c8	 mov	 rcx, rax
  009c3	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1080 :     Py_DECREF(res);

  009c8	48 8b cf	 mov	 rcx, rdi
  009cb	8b f0		 mov	 esi, eax
  009cd	e8 00 00 00 00	 call	 _Py_DecRef

; 1081 :     if (r < 0)

  009d2	85 f6		 test	 esi, esi
  009d4	0f 88 c5 00 00
	00		 js	 $error$21295

; 1082 :         goto error;
; 1083 :     self->seekable = self->telling = r;
; 1084 : 
; 1085 :     self->has_read1 = _PyObject_HasAttrId(buffer, &PyId_read1);

  009da	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  009de	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_read1
  009e3	40 88 b3 af 00
	00 00		 mov	 BYTE PTR [rbx+175], sil
  009ea	49 03 d5	 add	 rdx, r13
  009ed	40 88 b3 ad 00
	00 00		 mov	 BYTE PTR [rbx+173], sil
  009f4	e8 00 00 00 00	 call	 _PyObject_HasAttrId

; 1086 : 
; 1087 :     self->encoding_start_of_stream = 0;

  009f9	44 88 bb c0 00
	00 00		 mov	 BYTE PTR [rbx+192], r15b
  00a00	88 83 ae 00 00
	00		 mov	 BYTE PTR [rbx+174], al

; 1088 :     if (self->seekable && self->encoder) {

  00a06	44 38 bb ad 00
	00 00		 cmp	 BYTE PTR [rbx+173], r15b
  00a0d	0f 84 81 00 00
	00		 je	 $LN6@textiowrap
  00a13	4c 39 bb 80 00
	00 00		 cmp	 QWORD PTR [rbx+128], r15
  00a1a	74 78		 je	 SHORT $LN6@textiowrap

; 1089 :         PyObject *cookieObj;
; 1090 :         int cmp;
; 1091 : 
; 1092 :         self->encoding_start_of_stream = 1;
; 1093 : 
; 1094 :         cookieObj = PyObject_CallMethodObjArgs(buffer, _PyIO_str_tell, NULL);

  00a1c	48 8b 4d d7	 mov	 rcx, QWORD PTR buffer$[rbp-121]
  00a20	c6 83 c0 00 00
	00 01		 mov	 BYTE PTR [rbx+192], 1
  00a27	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_tell
  00a2e	45 33 c0	 xor	 r8d, r8d
  00a31	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  00a36	48 8b f8	 mov	 rdi, rax

; 1095 :         if (cookieObj == NULL)

  00a39	48 85 c0	 test	 rax, rax
  00a3c	74 61		 je	 SHORT $error$21295

; 1096 :             goto error;
; 1097 : 
; 1098 :         cmp = PyObject_RichCompareBool(cookieObj, _PyIO_zero, Py_EQ);

  00a3e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_zero
  00a45	41 b8 02 00 00
	00		 mov	 r8d, 2
  00a4b	48 8b c8	 mov	 rcx, rax
  00a4e	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 1099 :         Py_DECREF(cookieObj);

  00a53	48 8b cf	 mov	 rcx, rdi
  00a56	8b f0		 mov	 esi, eax
  00a58	e8 00 00 00 00	 call	 _Py_DecRef

; 1100 :         if (cmp < 0) {

  00a5d	85 f6		 test	 esi, esi
  00a5f	78 3e		 js	 SHORT $error$21295

; 1101 :             goto error;
; 1102 :         }
; 1103 : 
; 1104 :         if (cmp == 0) {

  00a61	75 31		 jne	 SHORT $LN6@textiowrap

; 1105 :             self->encoding_start_of_stream = 0;
; 1106 :             res = PyObject_CallMethodObjArgs(self->encoder, _PyIO_str_setstate,
; 1107 :                                              _PyIO_zero, NULL);

  00a63	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00a6a	44 88 bb c0 00
	00 00		 mov	 BYTE PTR [rbx+192], r15b
  00a71	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR _PyIO_zero
  00a78	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_setstate
  00a7f	45 33 c9	 xor	 r9d, r9d
  00a82	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 1108 :             if (res == NULL)

  00a87	48 85 c0	 test	 rax, rax
  00a8a	74 13		 je	 SHORT $error$21295

; 1109 :                 goto error;
; 1110 :             Py_DECREF(res);

  00a8c	48 8b c8	 mov	 rcx, rax
  00a8f	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@textiowrap:

; 1111 :         }
; 1112 :     }
; 1113 : 
; 1114 :     self->ok = 1;

  00a94	c7 43 60 01 00
	00 00		 mov	 DWORD PTR [rbx+96], 1

; 1115 :     return 0;

  00a9b	33 c0		 xor	 eax, eax
  00a9d	eb 6b		 jmp	 SHORT $LN159@textiowrap
$error$21295:

; 1116 : 
; 1117 :   error:
; 1118 :     Py_XDECREF(codec_info);

  00a9f	e8 00 00 00 00	 call	 _Py_PXCTX
  00aa4	85 c0		 test	 eax, eax
  00aa6	75 5f		 jne	 SHORT $LN3@textiowrap
  00aa8	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  00aad	a8 20		 test	 al, 32			; 00000020H
  00aaf	75 4e		 jne	 SHORT $LN148@textiowrap
  00ab1	84 c0		 test	 al, al
  00ab3	78 4a		 js	 SHORT $LN148@textiowrap
  00ab5	a8 02		 test	 al, 2
  00ab7	75 4e		 jne	 SHORT $LN3@textiowrap
  00ab9	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  00abe	75 47		 jne	 SHORT $LN3@textiowrap
  00ac0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00ac7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00ace	4d 8b cc	 mov	 r9, r12
  00ad1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00ad7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00adf	e8 00 00 00 00	 call	 _PyParallel_Guard
  00ae4	49 8b cc	 mov	 rcx, r12
  00ae7	85 c0		 test	 eax, eax
  00ae9	74 07		 je	 SHORT $LN153@textiowrap
  00aeb	e8 00 00 00 00	 call	 _Px_Dealloc
  00af0	eb 15		 jmp	 SHORT $LN3@textiowrap
$LN153@textiowrap:
  00af2	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00af7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00afd	eb 08		 jmp	 SHORT $LN3@textiowrap
$LN148@textiowrap:
  00aff	49 8b cc	 mov	 rcx, r12
  00b02	e8 00 00 00 00	 call	 Px_DecRef
$LN3@textiowrap:

; 1119 :     return -1;

  00b07	83 c8 ff	 or	 eax, -1
$LN159@textiowrap:
  00b0a	4c 8b a4 24 e8
	00 00 00	 mov	 r12, QWORD PTR [rsp+232]
$LN138@textiowrap:

; 1120 : }

  00b12	48 8b 9c 24 f0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+240]
  00b1a	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00b21	41 5f		 pop	 r15
  00b23	41 5d		 pop	 r13
  00b25	5f		 pop	 rdi
  00b26	5e		 pop	 rsi
  00b27	5d		 pop	 rbp
  00b28	c3		 ret	 0
textiowrapper_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@	; `string'
EXTRN	_PyIOBase_finalize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_textiowrapper_clear DD imagerel _textiowrapper_clear
	DD	imagerel _textiowrapper_clear+718
	DD	imagerel $unwind$_textiowrapper_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_textiowrapper_clear DD 042a01H
	DD	08742aH
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
CONST	SEGMENT
??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@ DB '_textiowrapper_clear', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _textiowrapper_clear
_TEXT	SEGMENT
self$ = 64
_textiowrapper_clear PROC				; COMDAT

; 1124 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1125 :     if (self->ok && _PyIOBase_finalize((PyObject *) self) < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 12		 je	 SHORT $LN41@textiowrap@2
  0000f	e8 00 00 00 00	 call	 _PyIOBase_finalize
  00014	85 c0		 test	 eax, eax
  00016	79 09		 jns	 SHORT $LN41@textiowrap@2

; 1126 :         return -1;

  00018	83 c8 ff	 or	 eax, -1

; 1139 : }

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN41@textiowrap@2:

; 1127 :     self->ok = 0;
; 1128 :     Py_CLEAR(self->buffer);

  00021	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  00025	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0002a	33 ff		 xor	 edi, edi
  0002c	89 7b 60	 mov	 DWORD PTR [rbx+96], edi
  0002f	4d 85 c9	 test	 r9, r9
  00032	74 32		 je	 SHORT $LN39@textiowrap@2
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  00042	41 b8 68 04 00
	00		 mov	 r8d, 1128		; 00000468H
  00048	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 0d		 jne	 SHORT $LN39@textiowrap@2
  00059	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0005d	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi
  00061	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@textiowrap@2:

; 1129 :     Py_CLEAR(self->encoding);

  00066	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  0006a	4d 85 c9	 test	 r9, r9
  0006d	74 32		 je	 SHORT $LN35@textiowrap@2
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  0007d	41 b8 69 04 00
	00		 mov	 r8d, 1129		; 00000469H
  00083	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00090	85 c0		 test	 eax, eax
  00092	75 0d		 jne	 SHORT $LN35@textiowrap@2
  00094	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00098	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
  0009c	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@textiowrap@2:

; 1130 :     Py_CLEAR(self->encoder);

  000a1	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  000a8	4d 85 c9	 test	 r9, r9
  000ab	74 38		 je	 SHORT $LN31@textiowrap@2
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  000bb	41 b8 6a 04 00
	00		 mov	 r8d, 1130		; 0000046aH
  000c1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ce	85 c0		 test	 eax, eax
  000d0	75 13		 jne	 SHORT $LN31@textiowrap@2
  000d2	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000d9	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
  000e0	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@textiowrap@2:

; 1131 :     Py_CLEAR(self->decoder);

  000e5	4c 8b 8b 88 00
	00 00		 mov	 r9, QWORD PTR [rbx+136]
  000ec	4d 85 c9	 test	 r9, r9
  000ef	74 38		 je	 SHORT $LN27@textiowrap@2
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  000ff	41 b8 6b 04 00
	00		 mov	 r8d, 1131		; 0000046bH
  00105	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0010d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00112	85 c0		 test	 eax, eax
  00114	75 13		 jne	 SHORT $LN27@textiowrap@2
  00116	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  0011d	48 89 bb 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rdi
  00124	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@textiowrap@2:

; 1132 :     Py_CLEAR(self->readnl);

  00129	4c 8b 8b 90 00
	00 00		 mov	 r9, QWORD PTR [rbx+144]
  00130	4d 85 c9	 test	 r9, r9
  00133	74 38		 je	 SHORT $LN23@textiowrap@2
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  00143	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00149	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00151	e8 00 00 00 00	 call	 _PyParallel_Guard
  00156	85 c0		 test	 eax, eax
  00158	75 13		 jne	 SHORT $LN23@textiowrap@2
  0015a	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  00161	48 89 bb 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rdi
  00168	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@textiowrap@2:

; 1133 :     Py_CLEAR(self->decoded_chars);

  0016d	4c 8b 8b c8 00
	00 00		 mov	 r9, QWORD PTR [rbx+200]
  00174	4d 85 c9	 test	 r9, r9
  00177	74 38		 je	 SHORT $LN19@textiowrap@2
  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  00187	41 b8 6d 04 00
	00		 mov	 r8d, 1133		; 0000046dH
  0018d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00195	e8 00 00 00 00	 call	 _PyParallel_Guard
  0019a	85 c0		 test	 eax, eax
  0019c	75 13		 jne	 SHORT $LN19@textiowrap@2
  0019e	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  001a5	48 89 bb c8 00
	00 00		 mov	 QWORD PTR [rbx+200], rdi
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@textiowrap@2:

; 1134 :     Py_CLEAR(self->pending_bytes);

  001b1	4c 8b 8b d8 00
	00 00		 mov	 r9, QWORD PTR [rbx+216]
  001b8	4d 85 c9	 test	 r9, r9
  001bb	74 38		 je	 SHORT $LN15@textiowrap@2
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  001cb	41 b8 6e 04 00
	00		 mov	 r8d, 1134		; 0000046eH
  001d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  001de	85 c0		 test	 eax, eax
  001e0	75 13		 jne	 SHORT $LN15@textiowrap@2
  001e2	48 8b 8b d8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+216]
  001e9	48 89 bb d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rdi
  001f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@textiowrap@2:

; 1135 :     Py_CLEAR(self->snapshot);

  001f5	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  001fc	4d 85 c9	 test	 r9, r9
  001ff	74 38		 je	 SHORT $LN11@textiowrap@2
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  0020f	41 b8 6f 04 00
	00		 mov	 r8d, 1135		; 0000046fH
  00215	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0021d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00222	85 c0		 test	 eax, eax
  00224	75 13		 jne	 SHORT $LN11@textiowrap@2
  00226	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  0022d	48 89 bb e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rdi
  00234	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@textiowrap@2:

; 1136 :     Py_CLEAR(self->errors);

  00239	4c 8b 8b 98 00
	00 00		 mov	 r9, QWORD PTR [rbx+152]
  00240	4d 85 c9	 test	 r9, r9
  00243	74 38		 je	 SHORT $LN7@textiowrap@2
  00245	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  00253	41 b8 70 04 00
	00		 mov	 r8d, 1136		; 00000470H
  00259	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00261	e8 00 00 00 00	 call	 _PyParallel_Guard
  00266	85 c0		 test	 eax, eax
  00268	75 13		 jne	 SHORT $LN7@textiowrap@2
  0026a	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  00271	48 89 bb 98 00
	00 00		 mov	 QWORD PTR [rbx+152], rdi
  00278	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@textiowrap@2:

; 1137 :     Py_CLEAR(self->raw);

  0027d	4c 8b 8b f8 00
	00 00		 mov	 r9, QWORD PTR [rbx+248]
  00284	4d 85 c9	 test	 r9, r9
  00287	74 38		 je	 SHORT $LN3@textiowrap@2
  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OLAHCNIL@_textiowrapper_clear?$AA@
  00297	41 b8 71 04 00
	00		 mov	 r8d, 1137		; 00000471H
  0029d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002a5	e8 00 00 00 00	 call	 _PyParallel_Guard
  002aa	85 c0		 test	 eax, eax
  002ac	75 13		 jne	 SHORT $LN3@textiowrap@2
  002ae	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  002b5	48 89 bb f8 00
	00 00		 mov	 QWORD PTR [rbx+248], rdi
  002bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@2:

; 1138 :     return 0;

  002c1	33 c0		 xor	 eax, eax
  002c3	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1139 : }

  002c8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002cc	5b		 pop	 rbx
  002cd	c3		 ret	 0
_textiowrapper_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@	; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiowrapper_dealloc DD imagerel textiowrapper_dealloc
	DD	imagerel textiowrapper_dealloc+228
	DD	imagerel $unwind$textiowrapper_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_dealloc DD imagerel textiowrapper_dealloc+228
	DD	imagerel textiowrapper_dealloc+357
	DD	imagerel $chain$0$textiowrapper_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_dealloc DD imagerel textiowrapper_dealloc+357
	DD	imagerel textiowrapper_dealloc+376
	DD	imagerel $chain$1$textiowrapper_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_dealloc DD 021H
	DD	imagerel textiowrapper_dealloc
	DD	imagerel textiowrapper_dealloc+228
	DD	imagerel $unwind$textiowrapper_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_dealloc DD 020521H
	DD	087405H
	DD	imagerel textiowrapper_dealloc
	DD	imagerel textiowrapper_dealloc+228
	DD	imagerel $unwind$textiowrapper_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_dealloc DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@
CONST	SEGMENT
??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@ DB 'textiowrapper_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT textiowrapper_dealloc
_TEXT	SEGMENT
self$ = 64
textiowrapper_dealloc PROC				; COMDAT

; 1143 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 1144 :     self->deallocating = 1;

  00009	c6 81 b0 00 00
	00 01		 mov	 BYTE PTR [rcx+176], 1

; 1145 :     if (_textiowrapper_clear(self) < 0)

  00010	e8 00 00 00 00	 call	 _textiowrapper_clear
  00015	85 c0		 test	 eax, eax
  00017	0f 88 55 01 00
	00		 js	 $LN11@textiowrap@3

; 1146 :         return;
; 1147 :     _PyObject_GC_UNTRACK(self);

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@
  0002b	4c 8b cb	 mov	 r9, rbx
  0002e	41 b8 7b 04 00
	00		 mov	 r8d, 1147		; 0000047bH
  00034	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	75 54		 jne	 SHORT $LN6@textiowrap@3
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@
  00053	4c 8b cb	 mov	 r9, rbx
  00056	41 b8 7b 04 00
	00		 mov	 r8d, 1147		; 0000047bH
  0005c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	74 04		 je	 SHORT $LN13@textiowrap@3
  0006d	33 d2		 xor	 edx, edx
  0006f	eb 04		 jmp	 SHORT $LN14@textiowrap@3
$LN13@textiowrap@3:
  00071	48 8d 53 e8	 lea	 rdx, QWORD PTR [rbx-24]
$LN14@textiowrap@3:
  00075	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00078	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0007c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00084	48 89 01	 mov	 QWORD PTR [rcx], rax
  00087	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0008a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0008e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00092	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN6@textiowrap@3:

; 1148 :     if (self->weakreflist != NULL)

  00099	48 83 bb 00 01
	00 00 00	 cmp	 QWORD PTR [rbx+256], 0
  000a1	74 08		 je	 SHORT $LN4@textiowrap@3

; 1149 :         PyObject_ClearWeakRefs((PyObject *)self);

  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN4@textiowrap@3:

; 1150 :     Py_CLEAR(self->dict);

  000ab	4c 8b 8b 08 01
	00 00		 mov	 r9, QWORD PTR [rbx+264]
  000b2	4d 85 c9	 test	 r9, r9
  000b5	0f 84 aa 00 00
	00		 je	 $LN3@textiowrap@3
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@HEFIHJBK@textiowrapper_dealloc?$AA@
  000c9	41 b8 7e 04 00
	00		 mov	 r8d, 1150		; 0000047eH
  000cf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dc	85 c0		 test	 eax, eax
  000de	0f 85 81 00 00
	00		 jne	 $LN3@textiowrap@3
  000e4	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000e9	48 8b bb 08 01
	00 00		 mov	 rdi, QWORD PTR [rbx+264]
  000f0	48 c7 83 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+264], 0
  000fb	e8 00 00 00 00	 call	 _Py_PXCTX
  00100	85 c0		 test	 eax, eax
  00102	75 5c		 jne	 SHORT $LN26@textiowrap@3
  00104	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00108	a8 20		 test	 al, 32			; 00000020H
  0010a	75 4c		 jne	 SHORT $LN19@textiowrap@3
  0010c	84 c0		 test	 al, al
  0010e	78 48		 js	 SHORT $LN19@textiowrap@3
  00110	a8 02		 test	 al, 2
  00112	75 4c		 jne	 SHORT $LN26@textiowrap@3
  00114	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00118	75 46		 jne	 SHORT $LN26@textiowrap@3
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00128	4c 8b cf	 mov	 r9, rdi
  0012b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00131	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00139	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013e	48 8b cf	 mov	 rcx, rdi
  00141	85 c0		 test	 eax, eax
  00143	74 07		 je	 SHORT $LN24@textiowrap@3
  00145	e8 00 00 00 00	 call	 _Px_Dealloc
  0014a	eb 14		 jmp	 SHORT $LN26@textiowrap@3
$LN24@textiowrap@3:
  0014c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00150	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00156	eb 08		 jmp	 SHORT $LN26@textiowrap@3
$LN19@textiowrap@3:
  00158	48 8b cf	 mov	 rcx, rdi
  0015b	e8 00 00 00 00	 call	 Px_DecRef
$LN26@textiowrap@3:
  00160	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN3@textiowrap@3:

; 1151 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00165	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00169	48 8b cb	 mov	 rcx, rbx
  0016c	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN11@textiowrap@3:

; 1152 : }

  00172	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00176	5b		 pop	 rbx
  00177	c3		 ret	 0
textiowrapper_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_traverse DD imagerel textiowrapper_traverse
	DD	imagerel textiowrapper_traverse+706
	DD	imagerel $unwind$textiowrapper_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
CONST	SEGMENT
??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@ DB 'textiowrapper_traverse'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
textiowrapper_traverse PROC				; COMDAT

; 1156 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1157 :     Py_VISIT(self->buffer);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN63@textiowrap@4
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 85 04 00
	00		 mov	 r8d, 1157		; 00000485H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN63@textiowrap@4:
  0003d	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 0d		 je	 SHORT $LN65@textiowrap@4
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	0f 85 5f 02 00
	00		 jne	 $LN67@textiowrap@4
$LN65@textiowrap@4:

; 1158 :     Py_VISIT(self->encoding);

  00053	e8 00 00 00 00	 call	 _Py_PXCTX
  00058	85 c0		 test	 eax, eax
  0005a	74 1c		 je	 SHORT $LN57@textiowrap@4
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  0006a	45 33 c9	 xor	 r9d, r9d
  0006d	41 b8 86 04 00
	00		 mov	 r8d, 1158		; 00000486H
  00073	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN57@textiowrap@4:
  00078	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0007c	48 85 c9	 test	 rcx, rcx
  0007f	74 0d		 je	 SHORT $LN59@textiowrap@4
  00081	48 8b d7	 mov	 rdx, rdi
  00084	ff d6		 call	 rsi
  00086	85 c0		 test	 eax, eax
  00088	0f 85 24 02 00
	00		 jne	 $LN67@textiowrap@4
$LN59@textiowrap@4:

; 1159 :     Py_VISIT(self->encoder);

  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	74 1c		 je	 SHORT $LN51@textiowrap@4
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	41 b8 87 04 00
	00		 mov	 r8d, 1159		; 00000487H
  000ae	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN51@textiowrap@4:
  000b3	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000ba	48 85 c9	 test	 rcx, rcx
  000bd	74 0d		 je	 SHORT $LN53@textiowrap@4
  000bf	48 8b d7	 mov	 rdx, rdi
  000c2	ff d6		 call	 rsi
  000c4	85 c0		 test	 eax, eax
  000c6	0f 85 e6 01 00
	00		 jne	 $LN67@textiowrap@4
$LN53@textiowrap@4:

; 1160 :     Py_VISIT(self->decoder);

  000cc	e8 00 00 00 00	 call	 _Py_PXCTX
  000d1	85 c0		 test	 eax, eax
  000d3	74 1c		 je	 SHORT $LN45@textiowrap@4
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  000e3	45 33 c9	 xor	 r9d, r9d
  000e6	41 b8 88 04 00
	00		 mov	 r8d, 1160		; 00000488H
  000ec	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN45@textiowrap@4:
  000f1	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  000f8	48 85 c9	 test	 rcx, rcx
  000fb	74 0d		 je	 SHORT $LN47@textiowrap@4
  000fd	48 8b d7	 mov	 rdx, rdi
  00100	ff d6		 call	 rsi
  00102	85 c0		 test	 eax, eax
  00104	0f 85 a8 01 00
	00		 jne	 $LN67@textiowrap@4
$LN47@textiowrap@4:

; 1161 :     Py_VISIT(self->readnl);

  0010a	e8 00 00 00 00	 call	 _Py_PXCTX
  0010f	85 c0		 test	 eax, eax
  00111	74 1c		 je	 SHORT $LN39@textiowrap@4
  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  00121	45 33 c9	 xor	 r9d, r9d
  00124	41 b8 89 04 00
	00		 mov	 r8d, 1161		; 00000489H
  0012a	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN39@textiowrap@4:
  0012f	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  00136	48 85 c9	 test	 rcx, rcx
  00139	74 0d		 je	 SHORT $LN41@textiowrap@4
  0013b	48 8b d7	 mov	 rdx, rdi
  0013e	ff d6		 call	 rsi
  00140	85 c0		 test	 eax, eax
  00142	0f 85 6a 01 00
	00		 jne	 $LN67@textiowrap@4
$LN41@textiowrap@4:

; 1162 :     Py_VISIT(self->decoded_chars);

  00148	e8 00 00 00 00	 call	 _Py_PXCTX
  0014d	85 c0		 test	 eax, eax
  0014f	74 1c		 je	 SHORT $LN33@textiowrap@4
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  0015f	45 33 c9	 xor	 r9d, r9d
  00162	41 b8 8a 04 00
	00		 mov	 r8d, 1162		; 0000048aH
  00168	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN33@textiowrap@4:
  0016d	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  00174	48 85 c9	 test	 rcx, rcx
  00177	74 0d		 je	 SHORT $LN35@textiowrap@4
  00179	48 8b d7	 mov	 rdx, rdi
  0017c	ff d6		 call	 rsi
  0017e	85 c0		 test	 eax, eax
  00180	0f 85 2c 01 00
	00		 jne	 $LN67@textiowrap@4
$LN35@textiowrap@4:

; 1163 :     Py_VISIT(self->pending_bytes);

  00186	e8 00 00 00 00	 call	 _Py_PXCTX
  0018b	85 c0		 test	 eax, eax
  0018d	74 1c		 je	 SHORT $LN27@textiowrap@4
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  0019d	45 33 c9	 xor	 r9d, r9d
  001a0	41 b8 8b 04 00
	00		 mov	 r8d, 1163		; 0000048bH
  001a6	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@textiowrap@4:
  001ab	48 8b 8b d8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+216]
  001b2	48 85 c9	 test	 rcx, rcx
  001b5	74 0d		 je	 SHORT $LN29@textiowrap@4
  001b7	48 8b d7	 mov	 rdx, rdi
  001ba	ff d6		 call	 rsi
  001bc	85 c0		 test	 eax, eax
  001be	0f 85 ee 00 00
	00		 jne	 $LN67@textiowrap@4
$LN29@textiowrap@4:

; 1164 :     Py_VISIT(self->snapshot);

  001c4	e8 00 00 00 00	 call	 _Py_PXCTX
  001c9	85 c0		 test	 eax, eax
  001cb	74 1c		 je	 SHORT $LN21@textiowrap@4
  001cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  001db	45 33 c9	 xor	 r9d, r9d
  001de	41 b8 8c 04 00
	00		 mov	 r8d, 1164		; 0000048cH
  001e4	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@textiowrap@4:
  001e9	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  001f0	48 85 c9	 test	 rcx, rcx
  001f3	74 0d		 je	 SHORT $LN23@textiowrap@4
  001f5	48 8b d7	 mov	 rdx, rdi
  001f8	ff d6		 call	 rsi
  001fa	85 c0		 test	 eax, eax
  001fc	0f 85 b0 00 00
	00		 jne	 $LN67@textiowrap@4
$LN23@textiowrap@4:

; 1165 :     Py_VISIT(self->errors);

  00202	e8 00 00 00 00	 call	 _Py_PXCTX
  00207	85 c0		 test	 eax, eax
  00209	74 1c		 je	 SHORT $LN15@textiowrap@4
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  00219	45 33 c9	 xor	 r9d, r9d
  0021c	41 b8 8d 04 00
	00		 mov	 r8d, 1165		; 0000048dH
  00222	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@textiowrap@4:
  00227	48 8b 8b 98 00
	00 00		 mov	 rcx, QWORD PTR [rbx+152]
  0022e	48 85 c9	 test	 rcx, rcx
  00231	74 09		 je	 SHORT $LN17@textiowrap@4
  00233	48 8b d7	 mov	 rdx, rdi
  00236	ff d6		 call	 rsi
  00238	85 c0		 test	 eax, eax
  0023a	75 76		 jne	 SHORT $LN67@textiowrap@4
$LN17@textiowrap@4:

; 1166 :     Py_VISIT(self->raw);

  0023c	e8 00 00 00 00	 call	 _Py_PXCTX
  00241	85 c0		 test	 eax, eax
  00243	74 1c		 je	 SHORT $LN9@textiowrap@4
  00245	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  00253	45 33 c9	 xor	 r9d, r9d
  00256	41 b8 8e 04 00
	00		 mov	 r8d, 1166		; 0000048eH
  0025c	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@textiowrap@4:
  00261	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00268	48 85 c9	 test	 rcx, rcx
  0026b	74 09		 je	 SHORT $LN11@textiowrap@4
  0026d	48 8b d7	 mov	 rdx, rdi
  00270	ff d6		 call	 rsi
  00272	85 c0		 test	 eax, eax
  00274	75 3c		 jne	 SHORT $LN67@textiowrap@4
$LN11@textiowrap@4:

; 1167 : 
; 1168 :     Py_VISIT(self->dict);

  00276	e8 00 00 00 00	 call	 _Py_PXCTX
  0027b	85 c0		 test	 eax, eax
  0027d	74 1c		 je	 SHORT $LN3@textiowrap@4
  0027f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@COCKCLBM@textiowrapper_traverse?$AA@
  0028d	45 33 c9	 xor	 r9d, r9d
  00290	41 b8 90 04 00
	00		 mov	 r8d, 1168		; 00000490H
  00296	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@textiowrap@4:
  0029b	48 8b 8b 08 01
	00 00		 mov	 rcx, QWORD PTR [rbx+264]
  002a2	48 85 c9	 test	 rcx, rcx
  002a5	74 09		 je	 SHORT $LN5@textiowrap@4
  002a7	48 8b d7	 mov	 rdx, rdi
  002aa	ff d6		 call	 rsi
  002ac	85 c0		 test	 eax, eax
  002ae	75 02		 jne	 SHORT $LN67@textiowrap@4
$LN5@textiowrap@4:

; 1169 :     return 0;

  002b0	33 c0		 xor	 eax, eax
$LN67@textiowrap@4:

; 1170 : }

  002b2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  002b7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  002bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002c0	5f		 pop	 rdi
  002c1	c3		 ret	 0
textiowrapper_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FGMGKDLO@textiowrapper_clear?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiowrapper_clear DD imagerel textiowrapper_clear
	DD	imagerel textiowrapper_clear+84
	DD	imagerel $unwind$textiowrapper_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_clear DD imagerel textiowrapper_clear+84
	DD	imagerel textiowrapper_clear+199
	DD	imagerel $chain$0$textiowrapper_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$textiowrapper_clear DD imagerel textiowrapper_clear+199
	DD	imagerel textiowrapper_clear+222
	DD	imagerel $chain$2$textiowrapper_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$textiowrapper_clear DD imagerel textiowrapper_clear+222
	DD	imagerel textiowrapper_clear+235
	DD	imagerel $chain$4$textiowrapper_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_clear DD imagerel textiowrapper_clear+235
	DD	imagerel textiowrapper_clear+243
	DD	imagerel $chain$5$textiowrapper_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_clear DD 021H
	DD	imagerel textiowrapper_clear
	DD	imagerel textiowrapper_clear+84
	DD	imagerel $unwind$textiowrapper_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$textiowrapper_clear DD 020021H
	DD	083400H
	DD	imagerel textiowrapper_clear
	DD	imagerel textiowrapper_clear+84
	DD	imagerel $unwind$textiowrapper_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$textiowrapper_clear DD 020021H
	DD	083400H
	DD	imagerel textiowrapper_clear
	DD	imagerel textiowrapper_clear+84
	DD	imagerel $unwind$textiowrapper_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_clear DD 020521H
	DD	083405H
	DD	imagerel textiowrapper_clear
	DD	imagerel textiowrapper_clear+84
	DD	imagerel $unwind$textiowrapper_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BE@FGMGKDLO@textiowrapper_clear?$AA@
CONST	SEGMENT
??_C@_0BE@FGMGKDLO@textiowrapper_clear?$AA@ DB 'textiowrapper_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT textiowrapper_clear
_TEXT	SEGMENT
self$ = 64
textiowrapper_clear PROC				; COMDAT

; 1174 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f9	 mov	 rdi, rcx

; 1175 :     if (_textiowrapper_clear(self) < 0)

  00009	e8 00 00 00 00	 call	 _textiowrapper_clear
  0000e	85 c0		 test	 eax, eax
  00010	79 09		 jns	 SHORT $LN4@textiowrap@5

; 1176 :         return -1;

  00012	83 c8 ff	 or	 eax, -1

; 1179 : }

  00015	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
$LN4@textiowrap@5:

; 1177 :     Py_CLEAR(self->dict);

  0001b	4c 8b 8f 08 01
	00 00		 mov	 r9, QWORD PTR [rdi+264]
  00022	4d 85 c9	 test	 r9, r9
  00025	0f 84 c0 00 00
	00		 je	 $LN3@textiowrap@5
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FGMGKDLO@textiowrapper_clear?$AA@
  00039	41 b8 99 04 00
	00		 mov	 r8d, 1177		; 00000499H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	85 c0		 test	 eax, eax
  0004e	0f 85 97 00 00
	00		 jne	 $LN3@textiowrap@5
  00054	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00059	48 8b 9f 08 01
	00 00		 mov	 rbx, QWORD PTR [rdi+264]
  00060	48 c7 87 08 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+264], 0
  0006b	e8 00 00 00 00	 call	 _Py_PXCTX
  00070	85 c0		 test	 eax, eax
  00072	75 72		 jne	 SHORT $LN19@textiowrap@5
  00074	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00078	a8 20		 test	 al, 32			; 00000020H
  0007a	75 62		 jne	 SHORT $LN12@textiowrap@5
  0007c	84 c0		 test	 al, al
  0007e	78 5e		 js	 SHORT $LN12@textiowrap@5
  00080	a8 02		 test	 al, 2
  00082	75 62		 jne	 SHORT $LN19@textiowrap@5
  00084	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00088	75 5c		 jne	 SHORT $LN19@textiowrap@5
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00098	4c 8b cb	 mov	 r9, rbx
  0009b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000a1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ae	48 8b cb	 mov	 rcx, rbx
  000b1	85 c0		 test	 eax, eax
  000b3	74 12		 je	 SHORT $LN17@textiowrap@5
  000b5	e8 00 00 00 00	 call	 _Px_Dealloc
  000ba	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1178 :     return 0;

  000bf	33 c0		 xor	 eax, eax

; 1179 : }

  000c1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0

; 1177 :     Py_CLEAR(self->dict);

$LN17@textiowrap@5:
  000c7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000cb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000d1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1178 :     return 0;

  000d6	33 c0		 xor	 eax, eax

; 1179 : }

  000d8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0

; 1177 :     Py_CLEAR(self->dict);

$LN12@textiowrap@5:
  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 Px_DecRef
$LN19@textiowrap@5:
  000e6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@textiowrap@5:

; 1178 :     return 0;

  000eb	33 c0		 xor	 eax, eax

; 1179 : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5f		 pop	 rdi
  000f2	c3		 ret	 0
textiowrapper_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@ ; `string'
PUBLIC	??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@ ; `string'
EXTRN	_PyIO_str_flush:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_detach DD imagerel textiowrapper_detach
	DD	imagerel textiowrapper_detach+109
	DD	imagerel $unwind$textiowrapper_detach
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_detach DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
CONST	SEGMENT
??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@ DB 'I/O operati'
	DB	'on on uninitialized object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
CONST	SEGMENT
??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@ DB 'underlying b'
	DB	'uffer has been detached', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_detach
_TEXT	SEGMENT
self$ = 48
textiowrapper_detach PROC				; COMDAT

; 1238 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1239 :     PyObject *buffer, *res;
; 1240 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7f 28		 jg	 SHORT $LN4@textiowrap@6
  0000f	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00021	75 07		 jne	 SHORT $LN7@textiowrap@6
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN7@textiowrap@6:
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
$LN8@textiowrap@6:
  0002f	33 c0		 xor	 eax, eax

; 1249 :     return buffer;
; 1250 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN4@textiowrap@6:

; 1241 :     res = PyObject_CallMethodObjArgs((PyObject *)self, _PyIO_str_flush, NULL);

  00037	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_flush
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 1242 :     if (res == NULL)

  00046	48 85 c0	 test	 rax, rax

; 1243 :         return NULL;

  00049	74 e4		 je	 SHORT $LN8@textiowrap@6

; 1244 :     Py_DECREF(res);

  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 _Py_DecRef

; 1245 :     buffer = self->buffer;

  00053	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 1246 :     self->buffer = NULL;

  00057	33 c9		 xor	 ecx, ecx
  00059	48 89 4b 70	 mov	 QWORD PTR [rbx+112], rcx

; 1247 :     self->detached = 1;
; 1248 :     self->ok = 0;

  0005d	89 4b 60	 mov	 DWORD PTR [rbx+96], ecx
  00060	c7 43 64 01 00
	00 00		 mov	 DWORD PTR [rbx+100], 1

; 1249 :     return buffer;
; 1250 : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
textiowrapper_detach ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@FOOILDMI@_textiowrapper_writeflush?$AA@ ; `string'
EXTRN	_PyIO_trap_eintr:PROC
EXTRN	_PyIO_str_write:QWORD
EXTRN	_PyBytes_Join:PROC
EXTRN	_PyIO_empty_bytes:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_textiowrapper_writeflush DD imagerel _textiowrapper_writeflush
	DD	imagerel _textiowrapper_writeflush+38
	DD	imagerel $unwind$_textiowrapper_writeflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_textiowrapper_writeflush DD imagerel _textiowrapper_writeflush+38
	DD	imagerel _textiowrapper_writeflush+281
	DD	imagerel $chain$0$_textiowrapper_writeflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_textiowrapper_writeflush DD imagerel _textiowrapper_writeflush+281
	DD	imagerel _textiowrapper_writeflush+307
	DD	imagerel $chain$2$_textiowrapper_writeflush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_textiowrapper_writeflush DD 020021H
	DD	086400H
	DD	imagerel _textiowrapper_writeflush
	DD	imagerel _textiowrapper_writeflush+38
	DD	imagerel $unwind$_textiowrapper_writeflush
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_textiowrapper_writeflush DD 020521H
	DD	086405H
	DD	imagerel _textiowrapper_writeflush
	DD	imagerel _textiowrapper_writeflush+38
	DD	imagerel $unwind$_textiowrapper_writeflush
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_textiowrapper_writeflush DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BK@FOOILDMI@_textiowrapper_writeflush?$AA@
CONST	SEGMENT
??_C@_0BK@FOOILDMI@_textiowrapper_writeflush?$AA@ DB '_textiowrapper_writ'
	DB	'eflush', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT _textiowrapper_writeflush
_TEXT	SEGMENT
self$ = 64
_textiowrapper_writeflush PROC				; COMDAT

; 1256 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1257 :     PyObject *pending, *b, *ret;
; 1258 : 
; 1259 :     if (self->pending_bytes == NULL)

  0000a	48 8b b9 d8 00
	00 00		 mov	 rdi, QWORD PTR [rcx+216]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 85 ff	 test	 rdi, rdi
  00017	75 0d		 jne	 SHORT $LN11@textiowrap@7

; 1260 :         return 0;

  00019	33 c0		 xor	 eax, eax

; 1280 :     return 0;
; 1281 : }

  0001b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00020	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
$LN11@textiowrap@7:
  00026	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi

; 1261 : 
; 1262 :     pending = self->pending_bytes;
; 1263 :     Py_INCREF(pending);

  0002b	e8 00 00 00 00	 call	 _Py_PXCTX
  00030	85 c0		 test	 eax, eax
  00032	75 32		 jne	 SHORT $LN15@textiowrap@7
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00042	4c 8b cf	 mov	 r9, rdi
  00045	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00053	e8 00 00 00 00	 call	 _PyParallel_Guard
  00058	85 c0		 test	 eax, eax
  0005a	75 06		 jne	 SHORT $LN14@textiowrap@7
  0005c	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00060	74 04		 je	 SHORT $LN15@textiowrap@7
$LN14@textiowrap@7:
  00062	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN15@textiowrap@7:

; 1264 :     self->pending_bytes_count = 0;
; 1265 :     Py_CLEAR(self->pending_bytes);

  00066	4c 8b 8b d8 00
	00 00		 mov	 r9, QWORD PTR [rbx+216]
  0006d	33 f6		 xor	 esi, esi
  0006f	48 89 b3 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rsi
  00076	4d 85 c9	 test	 r9, r9
  00079	74 38		 je	 SHORT $LN9@textiowrap@7
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@FOOILDMI@_textiowrapper_writeflush?$AA@
  00089	41 b8 f1 04 00
	00		 mov	 r8d, 1265		; 000004f1H
  0008f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00097	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009c	85 c0		 test	 eax, eax
  0009e	75 13		 jne	 SHORT $LN9@textiowrap@7
  000a0	48 8b 8b d8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+216]
  000a7	48 89 b3 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rsi
  000ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@textiowrap@7:

; 1266 : 
; 1267 :     b = _PyBytes_Join(_PyIO_empty_bytes, pending);

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyIO_empty_bytes
  000ba	48 8b d7	 mov	 rdx, rdi
  000bd	e8 00 00 00 00	 call	 _PyBytes_Join

; 1268 :     Py_DECREF(pending);

  000c2	48 8b cf	 mov	 rcx, rdi
  000c5	48 8b f0	 mov	 rsi, rax
  000c8	e8 00 00 00 00	 call	 _Py_DecRef

; 1269 :     if (b == NULL)

  000cd	48 85 f6	 test	 rsi, rsi

; 1270 :         return -1;

  000d0	74 34		 je	 SHORT $LN22@textiowrap@7
$LL5@textiowrap@7:

; 1271 :     ret = NULL;
; 1272 :     do {
; 1273 :         ret = PyObject_CallMethodObjArgs(self->buffer,
; 1274 :                                          _PyIO_str_write, b, NULL);

  000d2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_write
  000d9	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000dd	45 33 c9	 xor	 r9d, r9d
  000e0	4c 8b c6	 mov	 r8, rsi
  000e3	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  000e8	48 8b f8	 mov	 rdi, rax

; 1275 :     } while (ret == NULL && _PyIO_trap_eintr());

  000eb	48 85 c0	 test	 rax, rax
  000ee	75 09		 jne	 SHORT $LN2@textiowrap@7
  000f0	e8 00 00 00 00	 call	 _PyIO_trap_eintr
  000f5	85 c0		 test	 eax, eax
  000f7	75 d9		 jne	 SHORT $LL5@textiowrap@7
$LN2@textiowrap@7:

; 1276 :     Py_DECREF(b);

  000f9	48 8b ce	 mov	 rcx, rsi
  000fc	e8 00 00 00 00	 call	 _Py_DecRef

; 1277 :     if (ret == NULL)

  00101	48 85 ff	 test	 rdi, rdi
  00104	75 13		 jne	 SHORT $LN1@textiowrap@7
$LN22@textiowrap@7:

; 1278 :         return -1;

  00106	83 c8 ff	 or	 eax, -1
  00109	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1280 :     return 0;
; 1281 : }

  0010e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00113	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00117	5f		 pop	 rdi
  00118	c3		 ret	 0
$LN1@textiowrap@7:

; 1279 :     Py_DECREF(ret);

  00119	48 8b cf	 mov	 rcx, rdi
  0011c	e8 00 00 00 00	 call	 _Py_DecRef
  00121	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 1280 :     return 0;
; 1281 : }

  00126	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0012b	33 c0		 xor	 eax, eax
  0012d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
_textiowrapper_writeflush ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@OHAAMLN@textiowrapper_set_decoded_chars?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiowrapper_set_decoded_chars DD imagerel textiowrapper_set_decoded_chars
	DD	imagerel textiowrapper_set_decoded_chars+73
	DD	imagerel $unwind$textiowrapper_set_decoded_chars
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_set_decoded_chars DD imagerel textiowrapper_set_decoded_chars+73
	DD	imagerel textiowrapper_set_decoded_chars+202
	DD	imagerel $chain$0$textiowrapper_set_decoded_chars
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_set_decoded_chars DD imagerel textiowrapper_set_decoded_chars+202
	DD	imagerel textiowrapper_set_decoded_chars+231
	DD	imagerel $chain$1$textiowrapper_set_decoded_chars
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_set_decoded_chars DD 021H
	DD	imagerel textiowrapper_set_decoded_chars
	DD	imagerel textiowrapper_set_decoded_chars+73
	DD	imagerel $unwind$textiowrapper_set_decoded_chars
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_set_decoded_chars DD 020521H
	DD	083405H
	DD	imagerel textiowrapper_set_decoded_chars
	DD	imagerel textiowrapper_set_decoded_chars+73
	DD	imagerel $unwind$textiowrapper_set_decoded_chars
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_set_decoded_chars DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0CA@OHAAMLN@textiowrapper_set_decoded_chars?$AA@
CONST	SEGMENT
??_C@_0CA@OHAAMLN@textiowrapper_set_decoded_chars?$AA@ DB 'textiowrapper_'
	DB	'set_decoded_chars', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT textiowrapper_set_decoded_chars
_TEXT	SEGMENT
self$ = 64
chars$ = 72
textiowrapper_set_decoded_chars PROC			; COMDAT

; 1385 : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1386 :     Py_CLEAR(self->decoded_chars);

  0000a	4c 8b 89 c8 00
	00 00		 mov	 r9, QWORD PTR [rcx+200]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 aa 00 00
	00		 je	 $LN3@textiowrap@8
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@OHAAMLN@textiowrapper_set_decoded_chars?$AA@
  0002e	41 b8 6a 05 00
	00		 mov	 r8d, 1386		; 0000056aH
  00034	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	0f 85 81 00 00
	00		 jne	 $LN3@textiowrap@8
  00049	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004e	48 8b 9f c8 00
	00 00		 mov	 rbx, QWORD PTR [rdi+200]
  00055	48 c7 87 c8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+200], 0
  00060	e8 00 00 00 00	 call	 _Py_PXCTX
  00065	85 c0		 test	 eax, eax
  00067	75 5c		 jne	 SHORT $LN18@textiowrap@8
  00069	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0006d	a8 20		 test	 al, 32			; 00000020H
  0006f	75 4c		 jne	 SHORT $LN11@textiowrap@8
  00071	84 c0		 test	 al, al
  00073	78 48		 js	 SHORT $LN11@textiowrap@8
  00075	a8 02		 test	 al, 2
  00077	75 4c		 jne	 SHORT $LN18@textiowrap@8
  00079	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0007d	75 46		 jne	 SHORT $LN18@textiowrap@8
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0008d	4c 8b cb	 mov	 r9, rbx
  00090	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00096	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0009e	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	85 c0		 test	 eax, eax
  000a8	74 07		 je	 SHORT $LN16@textiowrap@8
  000aa	e8 00 00 00 00	 call	 _Px_Dealloc
  000af	eb 14		 jmp	 SHORT $LN18@textiowrap@8
$LN16@textiowrap@8:
  000b1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000bb	eb 08		 jmp	 SHORT $LN18@textiowrap@8
$LN11@textiowrap@8:
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	e8 00 00 00 00	 call	 Px_DecRef
$LN18@textiowrap@8:
  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@textiowrap@8:

; 1387 :     self->decoded_chars = chars;

  000ca	48 89 b7 c8 00
	00 00		 mov	 QWORD PTR [rdi+200], rsi

; 1388 :     self->decoded_chars_used = 0;
; 1389 : }

  000d1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d6	48 c7 87 d0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+208], 0
  000e1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
textiowrapper_set_decoded_chars ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_get_decoded_chars DD imagerel textiowrapper_get_decoded_chars
	DD	imagerel textiowrapper_get_decoded_chars+164
	DD	imagerel $unwind$textiowrapper_get_decoded_chars
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_get_decoded_chars DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_get_decoded_chars
_TEXT	SEGMENT
self$ = 48
n$ = 56
textiowrapper_get_decoded_chars PROC			; COMDAT

; 1393 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1394 :     PyObject *chars;
; 1395 :     Py_ssize_t avail;
; 1396 : 
; 1397 :     if (self->decoded_chars == NULL)

  0000f	48 8b b9 c8 00
	00 00		 mov	 rdi, QWORD PTR [rcx+200]
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	48 85 ff	 test	 rdi, rdi
  0001f	75 18		 jne	 SHORT $LN7@textiowrap@9

; 1398 :         return PyUnicode_FromStringAndSize(NULL, 0);

  00021	33 d2		 xor	 edx, edx
  00023	33 c9		 xor	 ecx, ecx

; 1423 : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	e9 00 00 00 00	 jmp	 PyUnicode_FromStringAndSize
$LN7@textiowrap@9:

; 1399 : 
; 1400 :     /* decoded_chars is guaranteed to be "ready". */
; 1401 :     avail = (PyUnicode_GET_LENGTH(self->decoded_chars)
; 1402 :              - self->decoded_chars_used);

  00039	48 8b 91 d0 00
	00 00		 mov	 rdx, QWORD PTR [rcx+208]
  00040	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00044	48 2b c2	 sub	 rax, rdx

; 1403 : 
; 1404 :     assert(avail >= 0);
; 1405 : 
; 1406 :     if (n < 0 || n > avail)

  00047	48 85 db	 test	 rbx, rbx
  0004a	78 05		 js	 SHORT $LN5@textiowrap@9
  0004c	48 3b d8	 cmp	 rbx, rax
  0004f	7e 03		 jle	 SHORT $LN6@textiowrap@9
$LN5@textiowrap@9:

; 1407 :         n = avail;

  00051	48 8b d8	 mov	 rbx, rax
$LN6@textiowrap@9:

; 1408 : 
; 1409 :     if (self->decoded_chars_used > 0 || n < avail) {

  00054	48 85 d2	 test	 rdx, rdx
  00057	7f 27		 jg	 SHORT $LN3@textiowrap@9
  00059	48 3b d8	 cmp	 rbx, rax
  0005c	7c 22		 jl	 SHORT $LN3@textiowrap@9

; 1414 :             return NULL;
; 1415 :     }
; 1416 :     else {
; 1417 :         chars = self->decoded_chars;
; 1418 :         Py_INCREF(chars);

  0005e	48 8b cf	 mov	 rcx, rdi
  00061	e8 00 00 00 00	 call	 _Py_IncRef
$LN2@textiowrap@9:

; 1419 :     }
; 1420 : 
; 1421 :     self->decoded_chars_used += n;

  00066	48 01 9e d0 00
	00 00		 add	 QWORD PTR [rsi+208], rbx

; 1422 :     return chars;

  0006d	48 8b c7	 mov	 rax, rdi

; 1423 : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
$LN3@textiowrap@9:

; 1410 :         chars = PyUnicode_Substring(self->decoded_chars,
; 1411 :                                     self->decoded_chars_used,
; 1412 :                                     self->decoded_chars_used + n);

  00080	4c 8d 04 1a	 lea	 r8, QWORD PTR [rdx+rbx]
  00084	48 8b cf	 mov	 rcx, rdi
  00087	e8 00 00 00 00	 call	 PyUnicode_Substring
  0008c	48 8b f8	 mov	 rdi, rax

; 1413 :         if (chars == NULL)

  0008f	48 85 c0	 test	 rax, rax
  00092	75 d2		 jne	 SHORT $LN2@textiowrap@9

; 1423 : }

  00094	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00099	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
textiowrapper_get_decoded_chars ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BEEAOEKM@NN?$AA@			; `string'
PUBLIC	??_C@_0BJ@BOGCGCNL@textiowrapper_read_chunk?$AA@ ; `string'
PUBLIC	??_C@_0EF@NDBFALAO@decoder?5getstate?$CI?$CJ?5should?5have?5r@ ; `string'
PUBLIC	??_C@_0EC@ENMPEBFB@underlying?5?$CFs?$CI?$CJ?5should?5have?5retu@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@		; `string'
PUBLIC	??_C@_0N@MLDODNAJ@not?5readable?$AA@		; `string'
EXTRN	PyNumber_Add:PROC
EXTRN	PyBytes_Size:PROC
EXTRN	_PyIO_str_read1:QWORD
EXTRN	_PyIO_str_read:QWORD
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_read_chunk DD imagerel textiowrapper_read_chunk
	DD	imagerel textiowrapper_read_chunk+65
	DD	imagerel $unwind$textiowrapper_read_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_read_chunk DD imagerel textiowrapper_read_chunk+65
	DD	imagerel textiowrapper_read_chunk+156
	DD	imagerel $chain$0$textiowrapper_read_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$textiowrapper_read_chunk DD imagerel textiowrapper_read_chunk+156
	DD	imagerel textiowrapper_read_chunk+448
	DD	imagerel $chain$3$textiowrapper_read_chunk
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_read_chunk DD imagerel textiowrapper_read_chunk+448
	DD	imagerel textiowrapper_read_chunk+846
	DD	imagerel $chain$5$textiowrapper_read_chunk
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_read_chunk DD 040021H
	DD	06d400H
	DD	0dc400H
	DD	imagerel textiowrapper_read_chunk
	DD	imagerel textiowrapper_read_chunk+65
	DD	imagerel $unwind$textiowrapper_read_chunk
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$textiowrapper_read_chunk DD 045621H
	DD	06d456H
	DD	0dc400H
	DD	imagerel textiowrapper_read_chunk
	DD	imagerel textiowrapper_read_chunk+65
	DD	imagerel $unwind$textiowrapper_read_chunk
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_read_chunk DD 020521H
	DD	0dc405H
	DD	imagerel textiowrapper_read_chunk
	DD	imagerel textiowrapper_read_chunk+65
	DD	imagerel $unwind$textiowrapper_read_chunk
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_read_chunk DD 050901H
	DD	070056209H
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_02BEEAOEKM@NN?$AA@
CONST	SEGMENT
??_C@_02BEEAOEKM@NN?$AA@ DB 'NN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BOGCGCNL@textiowrapper_read_chunk?$AA@
CONST	SEGMENT
??_C@_0BJ@BOGCGCNL@textiowrapper_read_chunk?$AA@ DB 'textiowrapper_read_c'
	DB	'hunk', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NDBFALAO@decoder?5getstate?$CI?$CJ?5should?5have?5r@
CONST	SEGMENT
??_C@_0EF@NDBFALAO@decoder?5getstate?$CI?$CJ?5should?5have?5r@ DB 'decode'
	DB	'r getstate() should have returned a bytes object, not ''%.200'
	DB	's''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@ENMPEBFB@underlying?5?$CFs?$CI?$CJ?5should?5have?5retu@
CONST	SEGMENT
??_C@_0EC@ENMPEBFB@underlying?5?$CFs?$CI?$CJ?5should?5have?5retu@ DB 'und'
	DB	'erlying %s() should have returned a bytes object, not ''%.200'
	DB	's''', 00H					; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@ DB '(OO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MLDODNAJ@not?5readable?$AA@
CONST	SEGMENT
??_C@_0N@MLDODNAJ@not?5readable?$AA@ DB 'not readable', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_read_chunk
_TEXT	SEGMENT
dec_buffer$ = 96
self$ = 96
size_hint$ = 104
dec_flags$ = 112
textiowrapper_read_chunk PROC				; COMDAT

; 1429 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1430 :     PyObject *dec_buffer = NULL;

  00009	33 ff		 xor	 edi, edi
  0000b	48 8b d9	 mov	 rbx, rcx

; 1431 :     PyObject *dec_flags = NULL;
; 1432 :     PyObject *input_chunk = NULL;
; 1433 :     PyObject *decoded_chars, *chunk_size;
; 1434 :     Py_ssize_t nbytes, nchars;
; 1435 :     int eof;
; 1436 : 
; 1437 :     /* The return value is True unless EOF was reached.  The decoded string is
; 1438 :      * placed in self._decoded_chars (replacing its previous value).  The
; 1439 :      * entire input chunk is sent to the decoder, though some of it may remain
; 1440 :      * buffered in the decoder, yet to be converted.
; 1441 :      */
; 1442 : 
; 1443 :     if (self->decoder == NULL) {

  0000e	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00015	48 8b ea	 mov	 rbp, rdx
  00018	48 89 7c 24 60	 mov	 QWORD PTR dec_buffer$[rsp], rdi
  0001d	48 89 7c 24 70	 mov	 QWORD PTR dec_flags$[rsp], rdi
  00022	8b f7		 mov	 esi, edi
  00024	48 85 c9	 test	 rcx, rcx
  00027	75 18		 jne	 SHORT $LN33@textiowrap@10

; 1444 :         _unsupported("not readable");

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MLDODNAJ@not?5readable?$AA@
  00030	e8 00 00 00 00	 call	 _unsupported

; 1445 :         return -1;

  00035	83 c8 ff	 or	 eax, -1

; 1541 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	5f		 pop	 rdi
  0003d	5e		 pop	 rsi
  0003e	5d		 pop	 rbp
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN33@textiowrap@10:
  00041	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12

; 1446 :     }
; 1447 : 
; 1448 :     if (self->telling) {

  00046	40 38 b3 af 00
	00 00		 cmp	 BYTE PTR [rbx+175], sil
  0004d	74 69		 je	 SHORT $LN32@textiowrap@10

; 1449 :         /* To prepare for tell(), we need to snapshot a point in the file
; 1450 :          * where the decoder's input buffer is empty.
; 1451 :          */
; 1452 : 
; 1453 :         PyObject *state = PyObject_CallMethodObjArgs(self->decoder,
; 1454 :                                                      _PyIO_str_getstate, NULL);

  0004f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_getstate
  00056	45 33 c0	 xor	 r8d, r8d
  00059	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  0005e	4c 8b e0	 mov	 r12, rax

; 1455 :         if (state == NULL)

  00061	48 85 c0	 test	 rax, rax

; 1456 :             return -1;

  00064	74 25		 je	 SHORT $LN43@textiowrap@10

; 1457 :         /* Given this, we know there was a valid snapshot point
; 1458 :          * len(dec_buffer) bytes ago with decoder state (b'', dec_flags).
; 1459 :          */
; 1460 :         if (PyArg_Parse(state, "(OO)", &dec_buffer, &dec_flags) < 0) {

  00066	4c 8d 4c 24 70	 lea	 r9, QWORD PTR dec_flags$[rsp]
  0006b	4c 8d 44 24 60	 lea	 r8, QWORD PTR dec_buffer$[rsp]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  00077	48 8b c8	 mov	 rcx, rax
  0007a	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0007f	85 c0		 test	 eax, eax
  00081	79 19		 jns	 SHORT $LN30@textiowrap@10

; 1461 :             Py_DECREF(state);

  00083	49 8b cc	 mov	 rcx, r12
  00086	e8 00 00 00 00	 call	 _Py_DecRef
$LN43@textiowrap@10:

; 1462 :             return -1;

  0008b	83 c8 ff	 or	 eax, -1
  0008e	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]

; 1541 : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	5f		 pop	 rdi
  00098	5e		 pop	 rsi
  00099	5d		 pop	 rbp
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
$LN30@textiowrap@10:

; 1463 :         }
; 1464 :         Py_INCREF(dec_buffer);

  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dec_buffer$[rsp]
  000a1	e8 00 00 00 00	 call	 _Py_IncRef

; 1465 :         Py_INCREF(dec_flags);

  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dec_flags$[rsp]
  000ab	e8 00 00 00 00	 call	 _Py_IncRef

; 1466 :         Py_DECREF(state);

  000b0	49 8b cc	 mov	 rcx, r12
  000b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN32@textiowrap@10:

; 1467 :     }
; 1468 : 
; 1469 :     /* Read a chunk, decode it, and put the result in self._decoded_chars. */
; 1470 :     if (size_hint > 0) {

  000b8	48 85 ed	 test	 rbp, rbp
  000bb	7e 2c		 jle	 SHORT $LN29@textiowrap@10

; 1471 :         size_hint = (Py_ssize_t)(Py_MAX(self->b2cratio, 1.0) * size_hint);

  000bd	f2 0f 10 8b f0
	00 00 00	 movsdx	 xmm1, QWORD PTR [rbx+240]
  000c5	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  000cd	66 0f 2f c8	 comisd	 xmm1, xmm0
  000d1	77 04		 ja	 SHORT $LN37@textiowrap@10
  000d3	66 0f 28 c8	 movapd	 xmm1, xmm0
$LN37@textiowrap@10:
  000d7	66 0f ef c0	 pxor	 xmm0, xmm0
  000db	f2 48 0f 2a c5	 cvtsi2sd xmm0, rbp
  000e0	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  000e4	f2 48 0f 2c e8	 cvttsd2si rbp, xmm0
$LN29@textiowrap@10:

; 1472 :     }
; 1473 :     chunk_size = PyLong_FromSsize_t(Py_MAX(self->chunk_size, size_hint));

  000e9	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  000ed	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  000f2	48 3b c5	 cmp	 rax, rbp
  000f5	48 0f 4f e8	 cmovg	 rbp, rax
  000f9	48 8b cd	 mov	 rcx, rbp
  000fc	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00101	48 8b e8	 mov	 rbp, rax

; 1474 :     if (chunk_size == NULL)

  00104	48 85 c0	 test	 rax, rax
  00107	74 76		 je	 SHORT $fail$21953

; 1475 :         goto fail;
; 1476 :     input_chunk = PyObject_CallMethodObjArgs(self->buffer,
; 1477 :         (self->has_read1 ? _PyIO_str_read1: _PyIO_str_read),
; 1478 :         chunk_size, NULL);

  00109	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_read
  00110	40 38 b3 ae 00
	00 00		 cmp	 BYTE PTR [rbx+174], sil
  00117	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0011b	48 0f 45 15 00
	00 00 00	 cmovne	 rdx, QWORD PTR _PyIO_str_read1
  00123	4c 8b c0	 mov	 r8, rax
  00126	45 33 c9	 xor	 r9d, r9d
  00129	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 1479 :     Py_DECREF(chunk_size);

  0012e	48 8b cd	 mov	 rcx, rbp
  00131	48 8b f0	 mov	 rsi, rax
  00134	e8 00 00 00 00	 call	 _Py_DecRef

; 1480 :     if (input_chunk == NULL)

  00139	48 85 f6	 test	 rsi, rsi
  0013c	74 41		 je	 SHORT $fail$21953

; 1481 :         goto fail;
; 1482 :     if (!PyBytes_Check(input_chunk)) {

  0013e	4c 8b 4e 58	 mov	 r9, QWORD PTR [rsi+88]
  00142	41 f7 81 00 01
	00 00 00 00 00
	08		 test	 DWORD PTR [r9+256], 134217728 ; 08000000H
  0014d	75 71		 jne	 SHORT $LN26@textiowrap@10

; 1483 :         PyErr_Format(PyExc_TypeError,
; 1484 :                      "underlying %s() should have returned a bytes object, "
; 1485 :                      "not '%.200s'", (self->has_read1 ? "read1": "read"),
; 1486 :                      Py_TYPE(input_chunk)->tp_name);

  0014f	40 38 bb ae 00
	00 00		 cmp	 BYTE PTR [rbx+174], dil
  00156	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0015a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00161	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05FDBMPOID@read1?$AA@
  00168	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04POLDLDMI@read?$AA@
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@ENMPEBFB@underlying?5?$CFs?$CI?$CJ?5should?5have?5retu@
  00176	4c 0f 45 c0	 cmovne	 r8, rax
  0017a	e8 00 00 00 00	 call	 PyErr_Format
$fail$21953:

; 1535 : 
; 1536 :   fail:
; 1537 :     Py_XDECREF(dec_buffer);

  0017f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dec_buffer$[rsp]
  00184	48 85 c9	 test	 rcx, rcx
  00187	74 05		 je	 SHORT $LN11@textiowrap@10
  00189	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@textiowrap@10:

; 1538 :     Py_XDECREF(dec_flags);

  0018e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dec_flags$[rsp]
  00193	48 85 c9	 test	 rcx, rcx
  00196	74 05		 je	 SHORT $LN7@textiowrap@10
  00198	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@textiowrap@10:

; 1539 :     Py_XDECREF(input_chunk);

  0019d	48 85 f6	 test	 rsi, rsi
  001a0	74 08		 je	 SHORT $LN3@textiowrap@10
  001a2	48 8b ce	 mov	 rcx, rsi
  001a5	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@10:

; 1540 :     return -1;

  001aa	83 c8 ff	 or	 eax, -1
$LN41@textiowrap@10:
  001ad	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  001b2	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]

; 1541 : }

  001b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001bb	5f		 pop	 rdi
  001bc	5e		 pop	 rsi
  001bd	5d		 pop	 rbp
  001be	5b		 pop	 rbx
  001bf	c3		 ret	 0
$LN26@textiowrap@10:

; 1487 :         goto fail;
; 1488 :     }
; 1489 : 
; 1490 :     nbytes = PyBytes_Size(input_chunk);

  001c0	48 8b ce	 mov	 rcx, rsi
  001c3	e8 00 00 00 00	 call	 PyBytes_Size

; 1491 :     eof = (nbytes == 0);
; 1492 : 
; 1493 :     if (Py_TYPE(self->decoder) == &PyIncrementalNewlineDecoder_Type) {

  001c8	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  001cf	44 8b e7	 mov	 r12d, edi
  001d2	48 85 c0	 test	 rax, rax
  001d5	4c 8b e8	 mov	 r13, rax
  001d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  001df	41 0f 94 c4	 sete	 r12b
  001e3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001e7	75 0d		 jne	 SHORT $LN25@textiowrap@10

; 1494 :         decoded_chars = _PyIncrementalNewlineDecoder_decode(
; 1495 :             self->decoder, input_chunk, eof);

  001e9	45 8b c4	 mov	 r8d, r12d
  001ec	48 8b d6	 mov	 rdx, rsi
  001ef	e8 00 00 00 00	 call	 _PyIncrementalNewlineDecoder_decode

; 1496 :     }
; 1497 :     else {

  001f4	eb 29		 jmp	 SHORT $LN42@textiowrap@10
$LN25@textiowrap@10:

; 1498 :         decoded_chars = PyObject_CallMethodObjArgs(self->decoder,
; 1499 :             _PyIO_str_decode, input_chunk, eof ? Py_True : Py_False, NULL);

  001f6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_decode
  001fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00204	45 85 e4	 test	 r12d, r12d
  00207	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0020e	4c 8b c6	 mov	 r8, rsi
  00211	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00216	4c 0f 45 c8	 cmovne	 r9, rax
  0021a	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
$LN42@textiowrap@10:

; 1500 :     }
; 1501 : 
; 1502 :     if (check_decoded(decoded_chars) < 0)

  0021f	48 8b c8	 mov	 rcx, rax
  00222	48 8b e8	 mov	 rbp, rax
  00225	e8 00 00 00 00	 call	 check_decoded
  0022a	85 c0		 test	 eax, eax
  0022c	0f 88 4d ff ff
	ff		 js	 $fail$21953

; 1503 :         goto fail;
; 1504 :     textiowrapper_set_decoded_chars(self, decoded_chars);

  00232	48 8b d5	 mov	 rdx, rbp
  00235	48 8b cb	 mov	 rcx, rbx
  00238	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars

; 1505 :     nchars = PyUnicode_GET_LENGTH(decoded_chars);

  0023d	4c 8b 5d 60	 mov	 r11, QWORD PTR [rbp+96]

; 1506 :     if (nchars > 0)

  00241	4d 85 db	 test	 r11, r11
  00244	7e 20		 jle	 SHORT $LN22@textiowrap@10

; 1507 :         self->b2cratio = (double) nbytes / nchars;

  00246	66 0f ef c9	 pxor	 xmm1, xmm1
  0024a	66 0f ef c0	 pxor	 xmm0, xmm0
  0024e	f2 49 0f 2a cd	 cvtsi2sd xmm1, r13
  00253	f2 49 0f 2a c3	 cvtsi2sd xmm0, r11
  00258	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0025c	f2 0f 11 8b f0
	00 00 00	 movsdx	 QWORD PTR [rbx+240], xmm1

; 1508 :     else

  00264	eb 07		 jmp	 SHORT $LN21@textiowrap@10
$LN22@textiowrap@10:

; 1509 :         self->b2cratio = 0.0;

  00266	48 89 bb f0 00
	00 00		 mov	 QWORD PTR [rbx+240], rdi
$LN21@textiowrap@10:

; 1510 :     if (nchars > 0)

  0026d	4d 85 db	 test	 r11, r11
  00270	44 0f 4f e7	 cmovg	 r12d, edi

; 1511 :         eof = 0;
; 1512 : 
; 1513 :     if (self->telling) {

  00274	40 38 bb af 00
	00 00		 cmp	 BYTE PTR [rbx+175], dil
  0027b	0f 84 b7 00 00
	00		 je	 $LN19@textiowrap@10

; 1514 :         /* At the snapshot point, len(dec_buffer) bytes before the read, the
; 1515 :          * next input to be decoded is dec_buffer + input_chunk.
; 1516 :          */
; 1517 :         PyObject *next_input = PyNumber_Add(dec_buffer, input_chunk);

  00281	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dec_buffer$[rsp]
  00286	48 8b d6	 mov	 rdx, rsi
  00289	e8 00 00 00 00	 call	 PyNumber_Add
  0028e	48 8b e8	 mov	 rbp, rax

; 1518 :         if (next_input == NULL)

  00291	48 85 c0	 test	 rax, rax
  00294	0f 84 e5 fe ff
	ff		 je	 $fail$21953

; 1519 :             goto fail;
; 1520 :         if (!PyBytes_Check(next_input)) {

  0029a	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0029e	41 f7 80 00 01
	00 00 00 00 00
	08		 test	 DWORD PTR [r8+256], 134217728 ; 08000000H
  002a9	75 24		 jne	 SHORT $LN17@textiowrap@10

; 1521 :             PyErr_Format(PyExc_TypeError,
; 1522 :                          "decoder getstate() should have returned a bytes "
; 1523 :                          "object, not '%.200s'",
; 1524 :                          Py_TYPE(next_input)->tp_name);

  002ab	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  002af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@NDBFALAO@decoder?5getstate?$CI?$CJ?5should?5have?5r@
  002bd	e8 00 00 00 00	 call	 PyErr_Format

; 1525 :             Py_DECREF(next_input);

  002c2	48 8b cd	 mov	 rcx, rbp
  002c5	e8 00 00 00 00	 call	 _Py_DecRef
  002ca	e9 b0 fe ff ff	 jmp	 $fail$21953
$LN17@textiowrap@10:

; 1526 :             goto fail;
; 1527 :         }
; 1528 :         Py_DECREF(dec_buffer);

  002cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dec_buffer$[rsp]
  002d4	e8 00 00 00 00	 call	 _Py_DecRef

; 1529 :         Py_CLEAR(self->snapshot);

  002d9	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  002e0	4d 85 c9	 test	 r9, r9
  002e3	74 38		 je	 SHORT $LN15@textiowrap@10
  002e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@BOGCGCNL@textiowrapper_read_chunk?$AA@
  002f3	41 b8 f9 05 00
	00		 mov	 r8d, 1529		; 000005f9H
  002f9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00301	e8 00 00 00 00	 call	 _PyParallel_Guard
  00306	85 c0		 test	 eax, eax
  00308	75 13		 jne	 SHORT $LN15@textiowrap@10
  0030a	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  00311	48 89 bb e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rdi
  00318	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@textiowrap@10:

; 1530 :         self->snapshot = Py_BuildValue("NN", dec_flags, next_input);

  0031d	48 8b 54 24 70	 mov	 rdx, QWORD PTR dec_flags$[rsp]
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02BEEAOEKM@NN?$AA@
  00329	4c 8b c5	 mov	 r8, rbp
  0032c	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00331	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax
$LN19@textiowrap@10:

; 1531 :     }
; 1532 :     Py_DECREF(input_chunk);

  00338	48 8b ce	 mov	 rcx, rsi
  0033b	e8 00 00 00 00	 call	 _Py_DecRef

; 1533 : 
; 1534 :     return (eof == 0);

  00340	45 85 e4	 test	 r12d, r12d
  00343	40 0f 94 c7	 sete	 dil
  00347	8b c7		 mov	 eax, edi
  00349	e9 5f fe ff ff	 jmp	 $LN41@textiowrap@10
textiowrapper_read_chunk ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT find_control_char
_TEXT	SEGMENT
kind$ = 8
s$ = 16
end$ = 24
ch$ = 32
find_control_char PROC					; COMDAT

; 1654 : {

  00000	4c 8b d2	 mov	 r10, rdx

; 1655 :     if (kind == PyUnicode_1BYTE_KIND) {

  00003	83 f9 01	 cmp	 ecx, 1
  00006	75 18		 jne	 SHORT $LL4@find_contr

; 1656 :         assert(ch < 256);
; 1657 :         return (char *) memchr((void *) s, (char) ch, end - s);

  00008	4c 2b c2	 sub	 r8, rdx
  0000b	49 8b ca	 mov	 rcx, r10
  0000e	41 0f be d1	 movsx	 edx, r9b

; 1668 : }

  00012	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memchr
$LN29@find_contr:

; 1666 :         s += kind;

  00019	48 63 c1	 movsxd	 rax, ecx
  0001c	4c 03 d0	 add	 r10, rax
  0001f	90		 npad	 1
$LL4@find_contr:

; 1658 :     }
; 1659 :     for (;;) {
; 1660 :         while (PyUnicode_READ(kind, s, 0) > ch)

  00020	83 f9 02	 cmp	 ecx, 2
  00023	75 06		 jne	 SHORT $LN10@find_contr
  00025	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  00029	eb 03		 jmp	 SHORT $LN11@find_contr
$LN10@find_contr:
  0002b	41 8b 02	 mov	 eax, DWORD PTR [r10]
$LN11@find_contr:
  0002e	41 3b c1	 cmp	 eax, r9d

; 1661 :             s += kind;

  00031	77 e6		 ja	 SHORT $LN29@find_contr

; 1662 :         if (PyUnicode_READ(kind, s, 0) == ch)

  00033	83 f9 02	 cmp	 ecx, 2
  00036	75 06		 jne	 SHORT $LN14@find_contr
  00038	41 0f b7 02	 movzx	 eax, WORD PTR [r10]
  0003c	eb 03		 jmp	 SHORT $LN15@find_contr
$LN14@find_contr:
  0003e	41 8b 02	 mov	 eax, DWORD PTR [r10]
$LN15@find_contr:
  00041	41 3b c1	 cmp	 eax, r9d
  00044	74 08		 je	 SHORT $LN21@find_contr

; 1664 :         if (s == end)

  00046	4d 3b d0	 cmp	 r10, r8

; 1667 :     }

  00049	75 ce		 jne	 SHORT $LN29@find_contr

; 1665 :             return NULL;

  0004b	33 c0		 xor	 eax, eax

; 1668 : }

  0004d	c3		 ret	 0
$LN21@find_contr:

; 1663 :             return s;

  0004e	49 8b c2	 mov	 rax, r10

; 1668 : }

  00051	c3		 ret	 0
find_control_char ENDP
_TEXT	ENDS
PUBLIC	_PyIO_find_line_ending
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyIO_find_line_ending DD imagerel $LN71
	DD	imagerel $LN71+296
	DD	imagerel $unwind$_PyIO_find_line_ending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyIO_find_line_ending DD imagerel $LN71+296
	DD	imagerel $LN71+408
	DD	imagerel $chain$1$_PyIO_find_line_ending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyIO_find_line_ending DD imagerel $LN71+408
	DD	imagerel $LN71+645
	DD	imagerel $chain$2$_PyIO_find_line_ending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyIO_find_line_ending DD imagerel $LN71+645
	DD	imagerel $LN71+655
	DD	imagerel $chain$3$_PyIO_find_line_ending
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyIO_find_line_ending DD imagerel $LN71+655
	DD	imagerel $LN71+668
	DD	imagerel $chain$4$_PyIO_find_line_ending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyIO_find_line_ending DD 021H
	DD	imagerel $LN71
	DD	imagerel $LN71+296
	DD	imagerel $unwind$_PyIO_find_line_ending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyIO_find_line_ending DD 021H
	DD	imagerel $LN71+296
	DD	imagerel $LN71+408
	DD	imagerel $chain$1$_PyIO_find_line_ending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyIO_find_line_ending DD 020521H
	DD	0a5405H
	DD	imagerel $LN71+296
	DD	imagerel $LN71+408
	DD	imagerel $chain$1$_PyIO_find_line_ending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyIO_find_line_ending DD 040e21H
	DD	0cc40eH
	DD	0b6405H
	DD	imagerel $LN71
	DD	imagerel $LN71+296
	DD	imagerel $unwind$_PyIO_find_line_ending
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyIO_find_line_ending DD 060d01H
	DD	0f009320dH
	DD	0d005e007H
	DD	030027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyIO_find_line_ending
_TEXT	SEGMENT
translated$ = 80
universal$ = 88
readnl$ = 96
kind$ = 104
start$ = 112
end$ = 120
consumed$ = 128
_PyIO_find_line_ending PROC				; COMDAT

; 1674 : {

$LN71:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1675 :     Py_ssize_t len = ((char*)end - (char*)start)/kind;

  0000d	4c 8b 74 24 78	 mov	 r14, QWORD PTR end$[rsp]
  00012	4c 8b 6c 24 70	 mov	 r13, QWORD PTR start$[rsp]
  00017	49 63 d9	 movsxd	 rbx, r9d
  0001a	44 8b ca	 mov	 r9d, edx
  0001d	49 8b c6	 mov	 rax, r14
  00020	48 8b fb	 mov	 rdi, rbx
  00023	49 2b c5	 sub	 rax, r13
  00026	48 99		 cdq
  00028	48 f7 fb	 idiv	 rbx
  0002b	4c 8b f8	 mov	 r15, rax

; 1676 : 
; 1677 :     if (translated) {

  0002e	85 c9		 test	 ecx, ecx
  00030	74 4c		 je	 SHORT $LN30@PyIO_find_

; 1678 :         /* Newlines are already translated, only search for \n */
; 1679 :         char *pos = find_control_char(kind, start, end, '\n');

  00032	41 b9 0a 00 00
	00		 mov	 r9d, 10
  00038	4d 8b c6	 mov	 r8, r14
  0003b	49 8b d5	 mov	 rdx, r13
  0003e	8b cb		 mov	 ecx, ebx
  00040	e8 00 00 00 00	 call	 find_control_char

; 1680 :         if (pos != NULL)

  00045	48 85 c0	 test	 rax, rax
  00048	74 18		 je	 SHORT $LN29@PyIO_find_

; 1681 :             return (pos - start)/kind + 1;

  0004a	49 2b c5	 sub	 rax, r13
  0004d	48 99		 cdq
  0004f	48 f7 ff	 idiv	 rdi
  00052	48 ff c0	 inc	 rax

; 1752 :         }
; 1753 :     }
; 1754 : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	41 5f		 pop	 r15
  0005b	41 5e		 pop	 r14
  0005d	41 5d		 pop	 r13
  0005f	5f		 pop	 rdi
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
$LN29@PyIO_find_:

; 1682 :         else {
; 1683 :             *consumed = len;

  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR consumed$[rsp]
  0006a	4c 89 38	 mov	 QWORD PTR [rax], r15

; 1684 :             return -1;

  0006d	48 83 c8 ff	 or	 rax, -1

; 1752 :         }
; 1753 :     }
; 1754 : }

  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	41 5f		 pop	 r15
  00077	41 5e		 pop	 r14
  00079	41 5d		 pop	 r13
  0007b	5f		 pop	 rdi
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN30@PyIO_find_:

; 1685 :         }
; 1686 :     }
; 1687 :     else if (universal) {

  0007e	45 85 c9	 test	 r9d, r9d
  00081	0f 84 9d 00 00
	00		 je	 $LN26@PyIO_find_

; 1688 :         /* Universal newline search. Find any of \r, \r\n, \n
; 1689 :          * The decoder ensures that \r\n are not split in two pieces
; 1690 :          */
; 1691 :         char *s = start;

  00087	49 8b c5	 mov	 rax, r13
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL23@PyIO_find_:

; 1692 :         for (;;) {
; 1693 :             Py_UCS4 ch;
; 1694 :             /* Fast path for non-control chars. The loop always ends
; 1695 :                since the Unicode string is NUL-terminated. */
; 1696 :             while (PyUnicode_READ(kind, s, 0) > '\r')

  00090	83 fb 01	 cmp	 ebx, 1
  00093	75 05		 jne	 SHORT $LN35@PyIO_find_
  00095	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00098	eb 0c		 jmp	 SHORT $LN34@PyIO_find_
$LN35@PyIO_find_:
  0009a	83 fb 02	 cmp	 ebx, 2
  0009d	75 05		 jne	 SHORT $LN33@PyIO_find_
  0009f	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000a2	eb 02		 jmp	 SHORT $LN34@PyIO_find_
$LN33@PyIO_find_:
  000a4	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN34@PyIO_find_:
  000a6	83 f9 0d	 cmp	 ecx, 13
  000a9	76 05		 jbe	 SHORT $LN22@PyIO_find_

; 1697 :                 s += kind;

  000ab	48 03 c3	 add	 rax, rbx
  000ae	eb e0		 jmp	 SHORT $LL23@PyIO_find_
$LN22@PyIO_find_:

; 1698 :             if (s >= end) {

  000b0	49 3b c6	 cmp	 rax, r14
  000b3	73 ad		 jae	 SHORT $LN29@PyIO_find_

; 1699 :                 *consumed = len;
; 1700 :                 return -1;
; 1701 :             }
; 1702 :             ch = PyUnicode_READ(kind, s, 0);

  000b5	83 fb 01	 cmp	 ebx, 1
  000b8	75 05		 jne	 SHORT $LN39@PyIO_find_
  000ba	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000bd	eb 0c		 jmp	 SHORT $LN38@PyIO_find_
$LN39@PyIO_find_:
  000bf	83 fb 02	 cmp	 ebx, 2
  000c2	75 05		 jne	 SHORT $LN37@PyIO_find_
  000c4	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000c7	eb 02		 jmp	 SHORT $LN38@PyIO_find_
$LN37@PyIO_find_:
  000c9	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN38@PyIO_find_:

; 1703 :             s += kind;

  000cb	48 03 c3	 add	 rax, rbx

; 1704 :             if (ch == '\n')

  000ce	83 f9 0a	 cmp	 ecx, 10
  000d1	74 3c		 je	 SHORT $LN58@PyIO_find_

; 1706 :             if (ch == '\r') {

  000d3	83 f9 0d	 cmp	 ecx, 13
  000d6	75 b8		 jne	 SHORT $LL23@PyIO_find_

; 1707 :                 if (PyUnicode_READ(kind, s, 0) == '\n')

  000d8	83 fb 01	 cmp	 ebx, 1
  000db	75 05		 jne	 SHORT $LN43@PyIO_find_
  000dd	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000e0	eb 0c		 jmp	 SHORT $LN42@PyIO_find_
$LN43@PyIO_find_:
  000e2	83 fb 02	 cmp	 ebx, 2
  000e5	75 05		 jne	 SHORT $LN41@PyIO_find_
  000e7	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000ea	eb 02		 jmp	 SHORT $LN42@PyIO_find_
$LN41@PyIO_find_:
  000ec	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN42@PyIO_find_:

; 1708 :                     return (s - start)/kind + 1;

  000ee	49 2b c5	 sub	 rax, r13
  000f1	48 99		 cdq
  000f3	48 f7 ff	 idiv	 rdi
  000f6	83 f9 0a	 cmp	 ecx, 10
  000f9	0f 85 90 01 00
	00		 jne	 $LN13@PyIO_find_
  000ff	48 ff c0	 inc	 rax

; 1752 :         }
; 1753 :     }
; 1754 : }

  00102	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00106	41 5f		 pop	 r15
  00108	41 5e		 pop	 r14
  0010a	41 5d		 pop	 r13
  0010c	5f		 pop	 rdi
  0010d	5b		 pop	 rbx
  0010e	c3		 ret	 0
$LN58@PyIO_find_:

; 1705 :                 return (s - start)/kind;

  0010f	49 2b c5	 sub	 rax, r13
  00112	48 99		 cdq
  00114	48 f7 ff	 idiv	 rdi

; 1752 :         }
; 1753 :     }
; 1754 : }

  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	41 5f		 pop	 r15
  0011d	41 5e		 pop	 r14
  0011f	41 5d		 pop	 r13
  00121	5f		 pop	 rdi
  00122	5b		 pop	 rbx
  00123	c3		 ret	 0
$LN26@PyIO_find_:

; 1709 :                 else
; 1710 :                     return (s - start)/kind;
; 1711 :             }
; 1712 :         }
; 1713 :     }
; 1714 :     else {
; 1715 :         /* Non-universal mode. */
; 1716 :         Py_ssize_t readnl_len = PyUnicode_GET_LENGTH(readnl);
; 1717 :         char *nl = PyUnicode_DATA(readnl);

  00124	41 8b 40 70	 mov	 eax, DWORD PTR [r8+112]
  00128	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0012d	49 8b 70 60	 mov	 rsi, QWORD PTR [r8+96]
  00131	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00136	a8 20		 test	 al, 32			; 00000020H
  00138	74 16		 je	 SHORT $LN47@PyIO_find_
  0013a	a8 40		 test	 al, 64			; 00000040H
  0013c	74 09		 je	 SHORT $LN45@PyIO_find_
  0013e	4d 8d a0 80 00
	00 00		 lea	 r12, QWORD PTR [r8+128]
  00145	eb 10		 jmp	 SHORT $LN48@PyIO_find_
$LN45@PyIO_find_:
  00147	4d 8d a0 a0 00
	00 00		 lea	 r12, QWORD PTR [r8+160]
  0014e	eb 07		 jmp	 SHORT $LN48@PyIO_find_
$LN47@PyIO_find_:
  00150	4d 8b a0 a0 00
	00 00		 mov	 r12, QWORD PTR [r8+160]
$LN48@PyIO_find_:

; 1718 :         /* Assume that readnl is an ASCII character. */
; 1719 :         assert(PyUnicode_KIND(readnl) == PyUnicode_1BYTE_KIND);
; 1720 :         if (readnl_len == 1) {

  00157	48 83 fe 01	 cmp	 rsi, 1
  0015b	75 3b		 jne	 SHORT $LN15@PyIO_find_

; 1721 :             char *pos = find_control_char(kind, start, end, nl[0]);

  0015d	45 0f be 0c 24	 movsx	 r9d, BYTE PTR [r12]
  00162	4d 8b c6	 mov	 r8, r14
  00165	49 8b d5	 mov	 rdx, r13
  00168	8b cb		 mov	 ecx, ebx
  0016a	e8 00 00 00 00	 call	 find_control_char

; 1722 :             if (pos != NULL)

  0016f	48 85 c0	 test	 rax, rax
  00172	74 10		 je	 SHORT $LN14@PyIO_find_

; 1723 :                 return (pos - start)/kind + 1;

  00174	49 2b c5	 sub	 rax, r13
  00177	48 99		 cdq
  00179	48 f7 ff	 idiv	 rdi
  0017c	48 ff c0	 inc	 rax
  0017f	e9 01 01 00 00	 jmp	 $LN67@PyIO_find_
$LN14@PyIO_find_:

; 1724 :             *consumed = len;

  00184	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR consumed$[rsp]
  0018c	4c 89 38	 mov	 QWORD PTR [rax], r15

; 1725 :             return -1;

  0018f	48 83 c8 ff	 or	 rax, -1
  00193	e9 ed 00 00 00	 jmp	 $LN67@PyIO_find_
$LN15@PyIO_find_:
  00198	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp

; 1726 :         }
; 1727 :         else {
; 1728 :             char *s = start;
; 1729 :             char *e = end - (readnl_len - 1)*kind;

  0019d	48 8d 46 ff	 lea	 rax, QWORD PTR [rsi-1]
  001a1	49 8b ee	 mov	 rbp, r14
  001a4	49 8b cd	 mov	 rcx, r13
  001a7	48 0f af c7	 imul	 rax, rdi
  001ab	48 2b e8	 sub	 rbp, rax

; 1730 :             char *pos;
; 1731 :             if (e < s)

  001ae	4c 3b ed	 cmp	 r13, rbp
  001b1	76 2e		 jbe	 SHORT $LN69@PyIO_find_

; 1732 :                 e = s;

  001b3	49 8b ed	 mov	 rbp, r13
$LN8@PyIO_find_:

; 1745 :             }
; 1746 :             pos = find_control_char(kind, e, end, nl[0]);

  001b6	45 0f be 0c 24	 movsx	 r9d, BYTE PTR [r12]
  001bb	4d 8b c6	 mov	 r8, r14
  001be	48 8b d5	 mov	 rdx, rbp
  001c1	8b cb		 mov	 ecx, ebx
  001c3	e8 00 00 00 00	 call	 find_control_char

; 1747 :             if (pos == NULL)

  001c8	48 85 c0	 test	 rax, rax
  001cb	0f 85 98 00 00
	00		 jne	 $LN2@PyIO_find_

; 1748 :                 *consumed = len;

  001d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR consumed$[rsp]
  001d9	4c 89 38	 mov	 QWORD PTR [rax], r15

; 1749 :             else

  001dc	e9 9b 00 00 00	 jmp	 $LN1@PyIO_find_
$LN69@PyIO_find_:

; 1733 :             while (s < e) {

  001e1	73 d3		 jae	 SHORT $LN8@PyIO_find_
$LL11@PyIO_find_:

; 1734 :                 Py_ssize_t i;
; 1735 :                 char *pos = find_control_char(kind, s, end, nl[0]);

  001e3	45 0f be 0c 24	 movsx	 r9d, BYTE PTR [r12]
  001e8	48 8b d1	 mov	 rdx, rcx
  001eb	4d 8b c6	 mov	 r8, r14
  001ee	8b cb		 mov	 ecx, ebx
  001f0	e8 00 00 00 00	 call	 find_control_char
  001f5	4c 8b d8	 mov	 r11, rax

; 1736 :                 if (pos == NULL || pos >= e)

  001f8	48 85 c0	 test	 rax, rax
  001fb	74 b9		 je	 SHORT $LN8@PyIO_find_
  001fd	48 3b c5	 cmp	 rax, rbp
  00200	73 b4		 jae	 SHORT $LN8@PyIO_find_

; 1737 :                     break;
; 1738 :                 for (i = 1; i < readnl_len; i++) {

  00202	b9 01 00 00 00	 mov	 ecx, 1
  00207	48 3b ce	 cmp	 rcx, rsi
  0020a	7d 3d		 jge	 SHORT $LN70@PyIO_find_
  0020c	4c 8b c8	 mov	 r9, rax
  0020f	4d 8d 44 24 01	 lea	 r8, QWORD PTR [r12+1]
  00214	4d 2b cc	 sub	 r9, r12
$LL7@PyIO_find_:

; 1739 :                     if (PyUnicode_READ(kind, pos, i) != nl[i])

  00217	83 fb 01	 cmp	 ebx, 1
  0021a	75 07		 jne	 SHORT $LN51@PyIO_find_
  0021c	43 0f b6 14 01	 movzx	 edx, BYTE PTR [r9+r8]
  00221	eb 10		 jmp	 SHORT $LN50@PyIO_find_
$LN51@PyIO_find_:
  00223	83 fb 02	 cmp	 ebx, 2
  00226	75 07		 jne	 SHORT $LN49@PyIO_find_
  00228	41 0f b7 14 4b	 movzx	 edx, WORD PTR [r11+rcx*2]
  0022d	eb 04		 jmp	 SHORT $LN50@PyIO_find_
$LN49@PyIO_find_:

; 1737 :                     break;
; 1738 :                 for (i = 1; i < readnl_len; i++) {

  0022f	41 8b 14 8b	 mov	 edx, DWORD PTR [r11+rcx*4]
$LN50@PyIO_find_:

; 1739 :                     if (PyUnicode_READ(kind, pos, i) != nl[i])

  00233	41 0f be 00	 movsx	 eax, BYTE PTR [r8]
  00237	3b d0		 cmp	 edx, eax
  00239	75 0b		 jne	 SHORT $LN65@PyIO_find_

; 1737 :                     break;
; 1738 :                 for (i = 1; i < readnl_len; i++) {

  0023b	48 ff c1	 inc	 rcx
  0023e	49 ff c0	 inc	 r8
  00241	48 3b ce	 cmp	 rcx, rsi
  00244	7c d1		 jl	 SHORT $LL7@PyIO_find_
$LN65@PyIO_find_:

; 1740 :                         break;
; 1741 :                 }
; 1742 :                 if (i == readnl_len)

  00246	48 3b ce	 cmp	 rcx, rsi
$LN70@PyIO_find_:
  00249	74 0e		 je	 SHORT $LN62@PyIO_find_

; 1744 :                 s = pos + kind;

  0024b	4a 8d 0c 1b	 lea	 rcx, QWORD PTR [rbx+r11]
  0024f	48 3b cd	 cmp	 rcx, rbp
  00252	72 8f		 jb	 SHORT $LL11@PyIO_find_

; 1740 :                         break;
; 1741 :                 }
; 1742 :                 if (i == readnl_len)

  00254	e9 5d ff ff ff	 jmp	 $LN8@PyIO_find_
$LN62@PyIO_find_:

; 1743 :                     return (pos - start)/kind + readnl_len;

  00259	4d 2b dd	 sub	 r11, r13
  0025c	49 8b c3	 mov	 rax, r11
  0025f	48 99		 cdq
  00261	48 f7 ff	 idiv	 rdi
  00264	48 03 c6	 add	 rax, rsi
  00267	eb 17		 jmp	 SHORT $LN68@PyIO_find_
$LN2@PyIO_find_:

; 1750 :                 *consumed = (pos - start)/kind;

  00269	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR consumed$[rsp]
  00271	49 2b c5	 sub	 rax, r13
  00274	48 99		 cdq
  00276	48 f7 ff	 idiv	 rdi
  00279	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@PyIO_find_:

; 1751 :             return -1;

  0027c	48 83 c8 ff	 or	 rax, -1
$LN68@PyIO_find_:
  00280	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
$LN67@PyIO_find_:
  00285	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0028a	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
$LN13@PyIO_find_:

; 1752 :         }
; 1753 :     }
; 1754 : }

  0028f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00293	41 5f		 pop	 r15
  00295	41 5e		 pop	 r14
  00297	41 5d		 pop	 r13
  00299	5f		 pop	 rdi
  0029a	5b		 pop	 rbx
  0029b	c3		 ret	 0
_PyIO_find_line_ending ENDP
_TEXT	ENDS
EXTRN	_PyLong_AsByteArray:PROC
EXTRN	PyNumber_Long:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_parse_cookie DD imagerel textiowrapper_parse_cookie
	DD	imagerel textiowrapper_parse_cookie+141
	DD	imagerel $unwind$textiowrapper_parse_cookie
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_parse_cookie DD 040a01H
	DD	0c340aH
	DD	07006920aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_parse_cookie
_TEXT	SEGMENT
buffer$ = 48
cookie$ = 96
cookieObj$ = 104
textiowrapper_parse_cookie PROC				; COMDAT

; 1981 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1982 :     unsigned char buffer[COOKIE_BUF_LEN];
; 1983 :     PyLongObject *cookieLong = (PyLongObject *)PyNumber_Long(cookieObj);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyNumber_Long
  00015	48 8b d8	 mov	 rbx, rax

; 1984 :     if (cookieLong == NULL)

  00018	48 85 c0	 test	 rax, rax

; 1985 :         return -1;

  0001b	74 2b		 je	 SHORT $LN5@textiowrap@11

; 1986 : 
; 1987 :     if (_PyLong_AsByteArray(cookieLong, buffer, sizeof(buffer),
; 1988 :                             IS_LITTLE_ENDIAN, 0) < 0) {

  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00028	48 8b c8	 mov	 rcx, rax
  0002b	45 8d 41 14	 lea	 r8d, QWORD PTR [r9+20]
  0002f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00037	e8 00 00 00 00	 call	 _PyLong_AsByteArray

; 1989 :         Py_DECREF(cookieLong);

  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	85 c0		 test	 eax, eax
  00041	79 13		 jns	 SHORT $LN1@textiowrap@11
  00043	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@textiowrap@11:

; 1990 :         return -1;

  00048	83 c8 ff	 or	 eax, -1

; 1996 :     memcpy(&cookie->bytes_to_feed, buffer + OFF_BYTES_TO_FEED, sizeof(cookie->bytes_to_feed));
; 1997 :     memcpy(&cookie->chars_to_skip, buffer + OFF_CHARS_TO_SKIP, sizeof(cookie->chars_to_skip));
; 1998 :     memcpy(&cookie->need_eof, buffer + OFF_NEED_EOF, sizeof(cookie->need_eof));
; 1999 : 
; 2000 :     return 0;
; 2001 : }

  0004b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
$LN1@textiowrap@11:

; 1991 :     }
; 1992 :     Py_DECREF(cookieLong);

  00056	e8 00 00 00 00	 call	 _Py_DecRef

; 1993 : 
; 1994 :     memcpy(&cookie->start_pos, buffer + OFF_START_POS, sizeof(cookie->start_pos));
; 1995 :     memcpy(&cookie->dec_flags, buffer + OFF_DEC_FLAGS, sizeof(cookie->dec_flags));

  0005b	8b 44 24 38	 mov	 eax, DWORD PTR buffer$[rsp+8]
  0005f	4c 8b 5c 24 30	 mov	 r11, QWORD PTR buffer$[rsp]

; 1996 :     memcpy(&cookie->bytes_to_feed, buffer + OFF_BYTES_TO_FEED, sizeof(cookie->bytes_to_feed));
; 1997 :     memcpy(&cookie->chars_to_skip, buffer + OFF_CHARS_TO_SKIP, sizeof(cookie->chars_to_skip));
; 1998 :     memcpy(&cookie->need_eof, buffer + OFF_NEED_EOF, sizeof(cookie->need_eof));
; 1999 : 
; 2000 :     return 0;
; 2001 : }

  00064	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00069	89 47 08	 mov	 DWORD PTR [rdi+8], eax
  0006c	8b 44 24 3c	 mov	 eax, DWORD PTR buffer$[rsp+12]
  00070	89 47 0c	 mov	 DWORD PTR [rdi+12], eax
  00073	8b 44 24 40	 mov	 eax, DWORD PTR buffer$[rsp+16]
  00077	4c 89 1f	 mov	 QWORD PTR [rdi], r11
  0007a	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  0007d	0f b6 44 24 44	 movzx	 eax, BYTE PTR buffer$[rsp+20]
  00082	88 47 14	 mov	 BYTE PTR [rdi+20], al
  00085	33 c0		 xor	 eax, eax
  00087	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
textiowrapper_parse_cookie ENDP
_TEXT	ENDS
EXTRN	_PyLong_FromByteArray:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_build_cookie DD imagerel textiowrapper_build_cookie
	DD	imagerel textiowrapper_build_cookie+67
	DD	imagerel $unwind$textiowrapper_build_cookie
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_build_cookie DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_build_cookie
_TEXT	SEGMENT
buffer$ = 32
cookie$ = 80
textiowrapper_build_cookie PROC				; COMDAT

; 2005 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2006 :     unsigned char buffer[COOKIE_BUF_LEN];
; 2007 : 
; 2008 :     memcpy(buffer + OFF_START_POS, &cookie->start_pos, sizeof(cookie->start_pos));

  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2009 :     memcpy(buffer + OFF_DEC_FLAGS, &cookie->dec_flags, sizeof(cookie->dec_flags));
; 2010 :     memcpy(buffer + OFF_BYTES_TO_FEED, &cookie->bytes_to_feed, sizeof(cookie->bytes_to_feed));
; 2011 :     memcpy(buffer + OFF_CHARS_TO_SKIP, &cookie->chars_to_skip, sizeof(cookie->chars_to_skip));
; 2012 :     memcpy(buffer + OFF_NEED_EOF, &cookie->need_eof, sizeof(cookie->need_eof));
; 2013 : 
; 2014 :     return _PyLong_FromByteArray(buffer, sizeof(buffer), IS_LITTLE_ENDIAN, 0);

  00007	45 33 c9	 xor	 r9d, r9d
  0000a	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax
  0000f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00012	41 8d 51 15	 lea	 edx, QWORD PTR [r9+21]
  00016	89 44 24 28	 mov	 DWORD PTR buffer$[rsp+8], eax
  0001a	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  0001d	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00021	89 44 24 2c	 mov	 DWORD PTR buffer$[rsp+12], eax
  00025	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00028	89 44 24 30	 mov	 DWORD PTR buffer$[rsp+16], eax
  0002c	0f b6 41 14	 movzx	 eax, BYTE PTR [rcx+20]
  00030	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buffer$[rsp]
  00035	88 44 24 34	 mov	 BYTE PTR buffer$[rsp+20], al
  00039	e8 00 00 00 00	 call	 _PyLong_FromByteArray

; 2015 : }

  0003e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00042	c3		 ret	 0
textiowrapper_build_cookie ENDP
_TEXT	ENDS
PUBLIC	??_C@_06LEAIAIJC@?$CI?$CIyi?$CJ?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_textiowrapper_decoder_setstate DD imagerel _textiowrapper_decoder_setstate
	DD	imagerel _textiowrapper_decoder_setstate+132
	DD	imagerel $unwind$_textiowrapper_decoder_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_textiowrapper_decoder_setstate DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_06LEAIAIJC@?$CI?$CIyi?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_06LEAIAIJC@?$CI?$CIyi?$CJ?$CJ?$AA@ DB '((yi))', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _textiowrapper_decoder_setstate
_TEXT	SEGMENT
self$ = 64
cookie$ = 72
_textiowrapper_decoder_setstate PROC			; COMDAT

; 2020 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2021 :     PyObject *res;
; 2022 :     /* When seeking to the start of the stream, we call decoder.reset()
; 2023 :        rather than decoder.getstate().
; 2024 :        This is for a few decoders such as utf-16 for which the state value
; 2025 :        at start is not (b"", 0) but e.g. (b"", 2) (meaning, in the case of
; 2026 :        utf-16, that we are expecting a BOM).
; 2027 :     */
; 2028 :     if (cookie->start_pos == 0 && cookie->dec_flags == 0)

  00004	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  00008	4c 8b c2	 mov	 r8, rdx
  0000b	4c 8b d1	 mov	 r10, rcx
  0000e	75 1e		 jne	 SHORT $LN3@textiowrap@12
  00010	83 7a 08 00	 cmp	 DWORD PTR [rdx+8], 0
  00014	75 18		 jne	 SHORT $LN3@textiowrap@12

; 2029 :         res = PyObject_CallMethodObjArgs(self->decoder, _PyIO_str_reset, NULL);

  00016	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_reset
  0001d	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00024	45 33 c0	 xor	 r8d, r8d
  00027	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2030 :     else

  0002c	eb 3a		 jmp	 SHORT $LN2@textiowrap@12
$LN3@textiowrap@12:

; 2031 :         res = _PyObject_CallMethodId(self->decoder, &PyId_setstate,
; 2032 :                                      "((yi))", "", cookie->dec_flags);

  0002e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_setstate
  00042	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00046	41 8b 40 08	 mov	 eax, DWORD PTR [r8+8]
  0004a	49 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR [r10+136]
  00051	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06LEAIAIJC@?$CI?$CIyi?$CJ?$CJ?$AA@
  0005f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00063	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
$LN2@textiowrap@12:

; 2033 :     if (res == NULL)

  00068	48 85 c0	 test	 rax, rax
  0006b	75 08		 jne	 SHORT $LN1@textiowrap@12

; 2034 :         return -1;

  0006d	83 c8 ff	 or	 eax, -1

; 2037 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
$LN1@textiowrap@12:

; 2035 :     Py_DECREF(res);

  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 2036 :     return 0;

  0007d	33 c0		 xor	 eax, eax

; 2037 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_textiowrapper_decoder_setstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_textiowrapper_encoder_setstate DD imagerel _textiowrapper_encoder_setstate
	DD	imagerel _textiowrapper_encoder_setstate+118
	DD	imagerel $unwind$_textiowrapper_encoder_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_textiowrapper_encoder_setstate DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _textiowrapper_encoder_setstate
_TEXT	SEGMENT
self$ = 48
cookie$ = 56
_textiowrapper_encoder_setstate PROC			; COMDAT

; 2041 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2042 :     PyObject *res;
; 2043 :     /* Same as _textiowrapper_decoder_setstate() above. */
; 2044 :     if (cookie->start_pos == 0 && cookie->dec_flags == 0) {

  00006	48 83 3a 00	 cmp	 QWORD PTR [rdx], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 25		 jne	 SHORT $LN3@textiowrap@13
  0000f	83 7a 08 00	 cmp	 DWORD PTR [rdx+8], 0
  00013	75 1f		 jne	 SHORT $LN3@textiowrap@13

; 2045 :         res = PyObject_CallMethodObjArgs(self->encoder, _PyIO_str_reset, NULL);

  00015	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_reset
  0001c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00023	45 33 c0	 xor	 r8d, r8d
  00026	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2046 :         self->encoding_start_of_stream = 1;

  0002b	c6 83 c0 00 00
	00 01		 mov	 BYTE PTR [rbx+192], 1

; 2047 :     }
; 2048 :     else {

  00032	eb 24		 jmp	 SHORT $LN2@textiowrap@13
$LN3@textiowrap@13:

; 2049 :         res = PyObject_CallMethodObjArgs(self->encoder, _PyIO_str_setstate,
; 2050 :                                          _PyIO_zero, NULL);

  00034	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR _PyIO_zero
  0003b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_setstate
  00042	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00049	45 33 c9	 xor	 r9d, r9d
  0004c	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2051 :         self->encoding_start_of_stream = 0;

  00051	c6 83 c0 00 00
	00 00		 mov	 BYTE PTR [rbx+192], 0
$LN2@textiowrap@13:

; 2052 :     }
; 2053 :     if (res == NULL)

  00058	48 85 c0	 test	 rax, rax
  0005b	75 09		 jne	 SHORT $LN1@textiowrap@13

; 2054 :         return -1;

  0005d	83 c8 ff	 or	 eax, -1

; 2057 : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
$LN1@textiowrap@13:

; 2055 :     Py_DECREF(res);

  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 2056 :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 2057 : }

  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
_textiowrapper_encoder_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@		; `string'
EXTRN	_PyIO_str_truncate:QWORD
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_truncate DD imagerel textiowrapper_truncate
	DD	imagerel textiowrapper_truncate+155
	DD	imagerel $unwind$textiowrapper_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_truncate DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
CONST	SEGMENT
??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@ DB '|O:truncate', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_truncate
_TEXT	SEGMENT
pos$ = 48
self$ = 48
args$ = 56
textiowrapper_truncate PROC				; COMDAT

; 2447 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2448 :     PyObject *pos = Py_None;

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00010	48 8b c2	 mov	 rax, rdx

; 2449 :     PyObject *res;
; 2450 : 
; 2451 :     CHECK_INITIALIZED(self)

  00013	83 7b 60 00	 cmp	 DWORD PTR [rbx+96], 0
  00017	48 89 4c 24 30	 mov	 QWORD PTR pos$[rsp], rcx
  0001c	7f 28		 jg	 SHORT $LN5@textiowrap@14
  0001e	83 7b 64 00	 cmp	 DWORD PTR [rbx+100], 0
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00030	75 07		 jne	 SHORT $LN8@textiowrap@14
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN8@textiowrap@14:
  00039	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@textiowrap@14:
  0003e	33 c0		 xor	 eax, eax

; 2462 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
$LN5@textiowrap@14:

; 2452 :     if (!PyArg_ParseTuple(args, "|O:truncate", &pos)) {

  00046	4c 8d 44 24 30	 lea	 r8, QWORD PTR pos$[rsp]
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0005a	85 c0		 test	 eax, eax

; 2453 :         return NULL;

  0005c	74 e0		 je	 SHORT $LN9@textiowrap@14

; 2454 :     }
; 2455 : 
; 2456 :     res = PyObject_CallMethodObjArgs((PyObject *) self, _PyIO_str_flush, NULL);

  0005e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_flush
  00065	45 33 c0	 xor	 r8d, r8d
  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2457 :     if (res == NULL)

  00070	48 85 c0	 test	 rax, rax

; 2458 :         return NULL;

  00073	74 c9		 je	 SHORT $LN9@textiowrap@14

; 2459 :     Py_DECREF(res);

  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 2460 : 
; 2461 :     return PyObject_CallMethodObjArgs(self->buffer, _PyIO_str_truncate, pos, NULL);

  0007d	4c 8b 44 24 30	 mov	 r8, QWORD PTR pos$[rsp]
  00082	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_truncate
  00089	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0008d	45 33 c9	 xor	 r9d, r9d
  00090	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2462 : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5b		 pop	 rbx
  0009a	c3		 ret	 0
textiowrapper_truncate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@NFMOOIMF@?$CFU?5encoding?$DN?$CFR?$DO?$AA@ ; `string'
PUBLIC	??_C@_08NLOKMOEE@?5mode?$DN?$CFR?$AA@		; `string'
PUBLIC	??_C@_08CCFFODDC@?5name?$DN?$CFR?$AA@		; `string'
PUBLIC	??_C@_0BD@FGOBFCLO@?$DM_io?4TextIOWrapper?$AA@	; `string'
EXTRN	PyUnicode_AppendAndDel:PROC
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_repr DD imagerel textiowrapper_repr
	DD	imagerel textiowrapper_repr+400
	DD	imagerel $unwind$textiowrapper_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_repr DD 087a01H
	DD	09747aH
	DD	086475H
	DD	075461H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BA@NFMOOIMF@?$CFU?5encoding?$DN?$CFR?$DO?$AA@
CONST	SEGMENT
??_C@_0BA@NFMOOIMF@?$CFU?5encoding?$DN?$CFR?$DO?$AA@ DB '%U encoding=%R>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NLOKMOEE@?5mode?$DN?$CFR?$AA@
CONST	SEGMENT
??_C@_08NLOKMOEE@?5mode?$DN?$CFR?$AA@ DB ' mode=%R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCFFODDC@?5name?$DN?$CFR?$AA@
CONST	SEGMENT
??_C@_08CCFFODDC@?5name?$DN?$CFR?$AA@ DB ' name=%R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FGOBFCLO@?$DM_io?4TextIOWrapper?$AA@
CONST	SEGMENT
??_C@_0BD@FGOBFCLO@?$DM_io?4TextIOWrapper?$AA@ DB '<_io.TextIOWrapper', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_repr
_TEXT	SEGMENT
res$ = 48
self$ = 48
textiowrapper_repr PROC					; COMDAT

; 2466 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2467 :     PyObject *nameobj, *modeobj, *res, *s;
; 2468 : 
; 2469 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7f 28		 jg	 SHORT $LN20@textiowrap@15
  0000f	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00021	75 07		 jne	 SHORT $LN26@textiowrap@15
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN26@textiowrap@15:
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
$LN27@textiowrap@15:
  0002f	33 c0		 xor	 eax, eax

; 2513 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN20@textiowrap@15:

; 2470 : 
; 2471 :     res = PyUnicode_FromString("<_io.TextIOWrapper");

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FGOBFCLO@?$DM_io?4TextIOWrapper?$AA@
  0003e	e8 00 00 00 00	 call	 PyUnicode_FromString
  00043	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 2472 :     if (res == NULL)

  00048	48 85 c0	 test	 rax, rax

; 2473 :         return NULL;

  0004b	74 e2		 je	 SHORT $LN27@textiowrap@15

; 2474 :     nameobj = _PyObject_GetAttrId((PyObject *) self, &PyId_name);

  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00053	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0005c	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00061	48 8b 2c c8	 mov	 rbp, QWORD PTR [rax+rcx*8]
  00065	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_name
  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	48 03 d5	 add	 rdx, rbp
  00070	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00075	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0007a	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0007f	48 8b f0	 mov	 rsi, rax

; 2475 :     if (nameobj == NULL) {

  00082	48 85 c0	 test	 rax, rax
  00085	75 1b		 jne	 SHORT $LN16@textiowrap@15

; 2476 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0008e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00093	85 c0		 test	 eax, eax
  00095	0f 84 cf 00 00
	00		 je	 $error$22954

; 2477 :             PyErr_Clear();

  0009b	e8 00 00 00 00	 call	 PyErr_Clear

; 2478 :         else
; 2479 :             goto error;
; 2480 :     }
; 2481 :     else {

  000a0	eb 3c		 jmp	 SHORT $LN11@textiowrap@15
$LN16@textiowrap@15:

; 2482 :         s = PyUnicode_FromFormat(" name=%R", nameobj);

  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08CCFFODDC@?5name?$DN?$CFR?$AA@
  000a9	48 8b d0	 mov	 rdx, rax
  000ac	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2483 :         Py_DECREF(nameobj);

  000b1	48 8b ce	 mov	 rcx, rsi
  000b4	48 8b f8	 mov	 rdi, rax
  000b7	e8 00 00 00 00	 call	 _Py_DecRef

; 2484 :         if (s == NULL)

  000bc	48 85 ff	 test	 rdi, rdi
  000bf	0f 84 a5 00 00
	00		 je	 $error$22954

; 2485 :             goto error;
; 2486 :         PyUnicode_AppendAndDel(&res, s);

  000c5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR res$[rsp]
  000ca	48 8b d7	 mov	 rdx, rdi
  000cd	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 2487 :         if (res == NULL)

  000d2	48 83 7c 24 30
	00		 cmp	 QWORD PTR res$[rsp], 0

; 2488 :             return NULL;

  000d8	0f 84 9b 00 00
	00		 je	 $LN3@textiowrap@15
$LN11@textiowrap@15:

; 2489 :     }
; 2490 :     modeobj = _PyObject_GetAttrId((PyObject *) self, &PyId_mode);

  000de	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_mode
  000e3	48 8b cb	 mov	 rcx, rbx
  000e6	48 03 d5	 add	 rdx, rbp
  000e9	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000ee	48 8b f8	 mov	 rdi, rax

; 2491 :     if (modeobj == NULL) {

  000f1	48 85 c0	 test	 rax, rax
  000f4	75 1c		 jne	 SHORT $LN10@textiowrap@15

; 2492 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000fd	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00102	85 c0		 test	 eax, eax
  00104	74 64		 je	 SHORT $error$22954

; 2493 :             PyErr_Clear();

  00106	e8 00 00 00 00	 call	 PyErr_Clear

; 2494 :         else
; 2495 :             goto error;
; 2496 :     }
; 2497 :     else {

  0010b	48 8b 54 24 30	 mov	 rdx, QWORD PTR res$[rsp]
  00110	eb 36		 jmp	 SHORT $LN5@textiowrap@15
$LN10@textiowrap@15:

; 2498 :         s = PyUnicode_FromFormat(" mode=%R", modeobj);

  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NLOKMOEE@?5mode?$DN?$CFR?$AA@
  00119	48 8b d0	 mov	 rdx, rax
  0011c	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2499 :         Py_DECREF(modeobj);

  00121	48 8b cf	 mov	 rcx, rdi
  00124	48 8b f0	 mov	 rsi, rax
  00127	e8 00 00 00 00	 call	 _Py_DecRef

; 2500 :         if (s == NULL)

  0012c	48 85 f6	 test	 rsi, rsi
  0012f	74 39		 je	 SHORT $error$22954

; 2501 :             goto error;
; 2502 :         PyUnicode_AppendAndDel(&res, s);

  00131	48 8d 4c 24 30	 lea	 rcx, QWORD PTR res$[rsp]
  00136	48 8b d6	 mov	 rdx, rsi
  00139	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 2503 :         if (res == NULL)

  0013e	48 8b 54 24 30	 mov	 rdx, QWORD PTR res$[rsp]
  00143	48 85 d2	 test	 rdx, rdx

; 2504 :             return NULL;

  00146	74 31		 je	 SHORT $LN3@textiowrap@15
$LN5@textiowrap@15:

; 2505 :     }
; 2506 :     s = PyUnicode_FromFormat("%U encoding=%R>",
; 2507 :                              res, self->encoding);

  00148	4c 8b 43 78	 mov	 r8, QWORD PTR [rbx+120]
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NFMOOIMF@?$CFU?5encoding?$DN?$CFR?$DO?$AA@
  00153	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2508 :     Py_DECREF(res);

  00158	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$[rsp]
  0015d	48 8b d8	 mov	 rbx, rax
  00160	e8 00 00 00 00	 call	 _Py_DecRef

; 2509 :     return s;

  00165	48 8b c3	 mov	 rax, rbx
  00168	eb 11		 jmp	 SHORT $LN25@textiowrap@15
$error$22954:

; 2510 : error:
; 2511 :     Py_XDECREF(res);

  0016a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$[rsp]
  0016f	48 85 c9	 test	 rcx, rcx
  00172	74 05		 je	 SHORT $LN3@textiowrap@15
  00174	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@15:

; 2512 :     return NULL;

  00179	33 c0		 xor	 eax, eax
$LN25@textiowrap@15:
  0017b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00180	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00185	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 2513 : }

  0018a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018e	5b		 pop	 rbx
  0018f	c3		 ret	 0
textiowrapper_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_fileno DD imagerel textiowrapper_fileno
	DD	imagerel textiowrapper_fileno+92
	DD	imagerel $unwind$textiowrapper_fileno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_fileno DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_fileno
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_fileno PROC				; COMDAT

; 2520 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2521 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@16
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@16
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@16:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2523 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@16:

; 2522 :     return _PyObject_CallMethodId(self->buffer, &PyId_fileno, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_fileno
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 49 70	 mov	 rcx, QWORD PTR [r9+112]
  00050	45 33 c0	 xor	 r8d, r8d

; 2523 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_fileno ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_seekable DD imagerel textiowrapper_seekable
	DD	imagerel textiowrapper_seekable+92
	DD	imagerel $unwind$textiowrapper_seekable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_seekable DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_seekable
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_seekable PROC				; COMDAT

; 2527 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2528 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@17
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@17
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@17:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2530 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@17:

; 2529 :     return _PyObject_CallMethodId(self->buffer, &PyId_seekable, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_seekable
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 49 70	 mov	 rcx, QWORD PTR [r9+112]
  00050	45 33 c0	 xor	 r8d, r8d

; 2530 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_seekable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_readable DD imagerel textiowrapper_readable
	DD	imagerel textiowrapper_readable+92
	DD	imagerel $unwind$textiowrapper_readable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_readable DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_readable
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_readable PROC				; COMDAT

; 2534 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2535 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@18
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@18
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@18:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2537 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@18:

; 2536 :     return _PyObject_CallMethodId(self->buffer, &PyId_readable, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_readable
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 49 70	 mov	 rcx, QWORD PTR [r9+112]
  00050	45 33 c0	 xor	 r8d, r8d

; 2537 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_readable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_writable DD imagerel textiowrapper_writable
	DD	imagerel textiowrapper_writable+92
	DD	imagerel $unwind$textiowrapper_writable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_writable DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_writable
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_writable PROC				; COMDAT

; 2541 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2542 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@19
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@19
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@19:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2544 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@19:

; 2543 :     return _PyObject_CallMethodId(self->buffer, &PyId_writable, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_writable
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 49 70	 mov	 rcx, QWORD PTR [r9+112]
  00050	45 33 c0	 xor	 r8d, r8d

; 2544 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_writable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_isatty DD imagerel textiowrapper_isatty
	DD	imagerel textiowrapper_isatty+92
	DD	imagerel $unwind$textiowrapper_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_isatty DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_isatty
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_isatty PROC				; COMDAT

; 2548 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2549 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c9	 mov	 r9, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@20
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@20
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@20:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2551 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@20:

; 2550 :     return _PyObject_CallMethodId(self->buffer, &PyId_isatty, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_isatty
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 49 70	 mov	 rcx, QWORD PTR [r9+112]
  00050	45 33 c0	 xor	 r8d, r8d

; 2551 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_isatty ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_getstate DD imagerel textiowrapper_getstate
	DD	imagerel textiowrapper_getstate+38
	DD	imagerel $unwind$textiowrapper_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_getstate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
CONST	SEGMENT
??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ DB 'cannot s'
	DB	'erialize ''%s'' object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_getstate
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_getstate PROC				; COMDAT

; 2555 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2556 :     PyErr_Format(PyExc_TypeError,
; 2557 :                  "cannot serialize '%s' object", Py_TYPE(self)->tp_name);

  00004	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00008	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
  00016	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0001a	e8 00 00 00 00	 call	 PyErr_Format

; 2558 :     return NULL;

  0001f	33 c0		 xor	 eax, eax

; 2559 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
textiowrapper_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_name_get DD imagerel textiowrapper_name_get
	DD	imagerel textiowrapper_name_get+89
	DD	imagerel $unwind$textiowrapper_name_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_name_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_name_get
_TEXT	SEGMENT
self$ = 48
context$ = 56
textiowrapper_name_get PROC				; COMDAT

; 2665 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2666 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	4c 8b c1	 mov	 r8, rcx
  0000b	7f 27		 jg	 SHORT $LN3@textiowrap@21
  0000d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001f	75 07		 jne	 SHORT $LN6@textiowrap@21
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@21:
  00028	e8 00 00 00 00	 call	 PyErr_SetString
  0002d	33 c0		 xor	 eax, eax

; 2668 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
$LN3@textiowrap@21:

; 2667 :     return _PyObject_GetAttrId(self->buffer, &PyId_name);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_name
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	49 8b 48 70	 mov	 rcx, QWORD PTR [r8+112]

; 2668 : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	e9 00 00 00 00	 jmp	 _PyObject_GetAttrId
textiowrapper_name_get ENDP
_TEXT	ENDS
EXTRN	PyObject_GetAttr:PROC
EXTRN	_PyIO_str_closed:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_closed_get DD imagerel textiowrapper_closed_get
	DD	imagerel textiowrapper_closed_get+69
	DD	imagerel $unwind$textiowrapper_closed_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_closed_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_closed_get
_TEXT	SEGMENT
self$ = 48
context$ = 56
textiowrapper_closed_get PROC				; COMDAT

; 2672 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2673 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	7f 27		 jg	 SHORT $LN3@textiowrap@22
  0000a	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001c	75 07		 jne	 SHORT $LN6@textiowrap@22
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@22:
  00025	e8 00 00 00 00	 call	 PyErr_SetString
  0002a	33 c0		 xor	 eax, eax

; 2675 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN3@textiowrap@22:

; 2674 :     return PyObject_GetAttr(self->buffer, _PyIO_str_closed);

  00031	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_closed
  00038	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]

; 2675 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	e9 00 00 00 00	 jmp	 PyObject_GetAttr
textiowrapper_closed_get ENDP
_TEXT	ENDS
EXTRN	_PyIO_str_newlines:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$textiowrapper_newlines_get DD imagerel textiowrapper_newlines_get
	DD	imagerel textiowrapper_newlines_get+208
	DD	imagerel $unwind$textiowrapper_newlines_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_newlines_get DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
xdata	ENDS
;	COMDAT textiowrapper_newlines_get
_TEXT	SEGMENT
self$ = 64
context$ = 72
textiowrapper_newlines_get PROC				; COMDAT

; 2679 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2680 :     PyObject *res;
; 2681 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	7f 27		 jg	 SHORT $LN7@textiowrap@23
  0000a	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001c	75 07		 jne	 SHORT $LN14@textiowrap@23
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN14@textiowrap@23:
  00025	e8 00 00 00 00	 call	 PyErr_SetString
$LN2@textiowrap@23:

; 2689 :         }
; 2690 :         else {
; 2691 :             return NULL;

  0002a	33 c0		 xor	 eax, eax
$LN1@textiowrap@23:

; 2692 :         }
; 2693 :     }
; 2694 :     return res;
; 2695 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
$LN7@textiowrap@23:

; 2682 :     if (self->decoder == NULL)

  00031	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00038	48 85 c9	 test	 rcx, rcx
  0003b	75 51		 jne	 SHORT $LN4@textiowrap@23

; 2683 :         Py_RETURN_NONE;

  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	75 3c		 jne	 SHORT $LN11@textiowrap@23
  00046	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00061	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00069	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006e	85 c0		 test	 eax, eax
  00070	75 09		 jne	 SHORT $LN10@textiowrap@23
  00072	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00079	74 07		 je	 SHORT $LN11@textiowrap@23
$LN10@textiowrap@23:
  0007b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN11@textiowrap@23:
  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2692 :         }
; 2693 :     }
; 2694 :     return res;
; 2695 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
$LN4@textiowrap@23:

; 2684 :     res = PyObject_GetAttr(self->decoder, _PyIO_str_newlines);

  0008e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_newlines
  00095	e8 00 00 00 00	 call	 PyObject_GetAttr

; 2685 :     if (res == NULL) {

  0009a	48 85 c0	 test	 rax, rax
  0009d	75 8d		 jne	 SHORT $LN1@textiowrap@23

; 2686 :         if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000a6	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000ab	85 c0		 test	 eax, eax
  000ad	0f 84 77 ff ff
	ff		 je	 $LN2@textiowrap@23

; 2687 :             PyErr_Clear();

  000b3	e8 00 00 00 00	 call	 PyErr_Clear

; 2688 :             Py_RETURN_NONE;

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000bf	e8 00 00 00 00	 call	 _Py_IncRef
  000c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2692 :         }
; 2693 :     }
; 2694 :     return res;
; 2695 : }

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
textiowrapper_newlines_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_errors_get DD imagerel textiowrapper_errors_get
	DD	imagerel textiowrapper_errors_get+69
	DD	imagerel $unwind$textiowrapper_errors_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_errors_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_errors_get
_TEXT	SEGMENT
self$ = 48
context$ = 56
textiowrapper_errors_get PROC				; COMDAT

; 2699 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2700 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	7f 27		 jg	 SHORT $LN3@textiowrap@24
  0000a	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001c	75 07		 jne	 SHORT $LN6@textiowrap@24
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@24:
  00025	e8 00 00 00 00	 call	 PyErr_SetString
  0002a	33 c0		 xor	 eax, eax

; 2702 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN3@textiowrap@24:

; 2701 :     return PyUnicode_FromString(PyBytes_AS_STRING(self->errors));

  00031	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00038	48 83 c1 78	 add	 rcx, 120		; 00000078H

; 2702 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	e9 00 00 00 00	 jmp	 PyUnicode_FromString
textiowrapper_errors_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_chunk_size_get DD imagerel textiowrapper_chunk_size_get
	DD	imagerel textiowrapper_chunk_size_get+62
	DD	imagerel $unwind$textiowrapper_chunk_size_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_chunk_size_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_chunk_size_get
_TEXT	SEGMENT
self$ = 48
context$ = 56
textiowrapper_chunk_size_get PROC			; COMDAT

; 2706 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2707 :     CHECK_INITIALIZED(self);

  00004	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00008	7f 27		 jg	 SHORT $LN3@textiowrap@25
  0000a	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0001c	75 07		 jne	 SHORT $LN6@textiowrap@25
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN6@textiowrap@25:
  00025	e8 00 00 00 00	 call	 PyErr_SetString
  0002a	33 c0		 xor	 eax, eax

; 2709 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN3@textiowrap@25:

; 2708 :     return PyLong_FromSsize_t(self->chunk_size);

  00031	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]

; 2709 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
textiowrapper_chunk_size_get ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@JFLOBMAD@a?5strictly?5positive?5integer?5is?5r@ ; `string'
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_chunk_size_set DD imagerel textiowrapper_chunk_size_set
	DD	imagerel textiowrapper_chunk_size_set+144
	DD	imagerel $unwind$textiowrapper_chunk_size_set
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_chunk_size_set DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CI@JFLOBMAD@a?5strictly?5positive?5integer?5is?5r@
CONST	SEGMENT
??_C@_0CI@JFLOBMAD@a?5strictly?5positive?5integer?5is?5r@ DB 'a strictly '
	DB	'positive integer is required', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_chunk_size_set
_TEXT	SEGMENT
self$ = 48
arg$ = 56
context$ = 64
textiowrapper_chunk_size_set PROC			; COMDAT

; 2713 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2714 :     Py_ssize_t n;
; 2715 :     CHECK_INITIALIZED_INT(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	7f 29		 jg	 SHORT $LN5@textiowrap@26
  00012	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00024	75 07		 jne	 SHORT $LN9@textiowrap@26
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN9@textiowrap@26:
  0002d	e8 00 00 00 00	 call	 PyErr_SetString
  00032	83 c8 ff	 or	 eax, -1

; 2726 : }

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN5@textiowrap@26:

; 2716 :     n = PyNumber_AsSsize_t(arg, PyExc_ValueError);

  0003b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 PyNumber_AsSsize_t

; 2717 :     if (n == -1 && PyErr_Occurred())

  0004a	48 83 f8 ff	 cmp	 rax, -1
  0004e	75 13		 jne	 SHORT $LN2@textiowrap@26
  00050	e8 00 00 00 00	 call	 PyErr_Occurred
  00055	48 85 c0	 test	 rax, rax
  00058	74 0e		 je	 SHORT $LN8@textiowrap@26

; 2718 :         return -1;

  0005a	83 c8 ff	 or	 eax, -1

; 2726 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN2@textiowrap@26:

; 2719 :     if (n <= 0) {

  00063	48 85 c0	 test	 rax, rax
  00066	7f 1c		 jg	 SHORT $LN1@textiowrap@26
$LN8@textiowrap@26:

; 2720 :         PyErr_SetString(PyExc_ValueError,
; 2721 :                         "a strictly positive integer is required");

  00068	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@JFLOBMAD@a?5strictly?5positive?5integer?5is?5r@
  00076	e8 00 00 00 00	 call	 PyErr_SetString

; 2722 :         return -1;

  0007b	83 c8 ff	 or	 eax, -1

; 2726 : }

  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5b		 pop	 rbx
  00083	c3		 ret	 0
$LN1@textiowrap@26:

; 2723 :     }
; 2724 :     self->chunk_size = n;

  00084	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 2725 :     return 0;

  00088	33 c0		 xor	 eax, eax

; 2726 : }

  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5b		 pop	 rbx
  0008f	c3		 ret	 0
textiowrapper_chunk_size_set ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EEOJJAGF@textiowrapper_write?$AA@	; `string'
PUBLIC	??_C@_0N@MHOOAMII@not?5writable?$AA@		; `string'
PUBLIC	??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ ; `string'
PUBLIC	??_C@_07BDGBEOBJ@U?3write?$AA@			; `string'
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
EXTRN	_PyIO_str_encode:QWORD
EXTRN	PyUnicode_FindChar:PROC
EXTRN	_PyIOBase_check_closed:PROC
EXTRN	_PyFileIO_closed:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_write DD imagerel textiowrapper_write
	DD	imagerel textiowrapper_write+939
	DD	imagerel $unwind$textiowrapper_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_write DD 088101H
	DD	0c7481H
	DD	0b647cH
	DD	0c0055209H
	DD	030025003H
xdata	ENDS
;	COMDAT ??_C@_0BE@EEOJJAGF@textiowrapper_write?$AA@
CONST	SEGMENT
??_C@_0BE@EEOJJAGF@textiowrapper_write?$AA@ DB 'textiowrapper_write', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MHOOAMII@not?5writable?$AA@
CONST	SEGMENT
??_C@_0N@MHOOAMII@not?5writable?$AA@ DB 'not writable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
CONST	SEGMENT
??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ DB 'I/O opera'
	DB	'tion on closed file.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BDGBEOBJ@U?3write?$AA@
CONST	SEGMENT
??_C@_07BDGBEOBJ@U?3write?$AA@ DB 'U:write', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_write
_TEXT	SEGMENT
text$ = 80
self$ = 80
args$ = 88
textiowrapper_write PROC				; COMDAT

; 1285 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1286 :     PyObject *ret;
; 1287 :     PyObject *text; /* owned reference */
; 1288 :     PyObject *b;
; 1289 :     Py_ssize_t textlen;
; 1290 :     int haslf = 0;
; 1291 :     int needflush = 0;

  00009	33 ed		 xor	 ebp, ebp
  0000b	45 33 e4	 xor	 r12d, r12d
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 1292 : 
; 1293 :     CHECK_INITIALIZED(self);

  00014	39 69 60	 cmp	 DWORD PTR [rcx+96], ebp
  00017	7f 2a		 jg	 SHORT $LN44@textiowrap@27
  00019	39 69 64	 cmp	 DWORD PTR [rcx+100], ebp
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0002a	75 07		 jne	 SHORT $LN54@textiowrap@27
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN54@textiowrap@27:
  00033	e8 00 00 00 00	 call	 PyErr_SetString
$LN59@textiowrap@27:
  00038	33 c0		 xor	 eax, eax

; 1379 : }

  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	41 5c		 pop	 r12
  00040	5d		 pop	 rbp
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN44@textiowrap@27:

; 1294 : 
; 1295 :     if (!PyArg_ParseTuple(args, "U:write", &text)) {

  00043	4c 8d 44 24 50	 lea	 r8, QWORD PTR text$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BDGBEOBJ@U?3write?$AA@
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00057	85 c0		 test	 eax, eax

; 1296 :         return NULL;

  00059	74 dd		 je	 SHORT $LN59@textiowrap@27

; 1297 :     }
; 1298 : 
; 1299 :     if (PyUnicode_READY(text) == -1)

  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  00060	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00064	75 0a		 jne	 SHORT $LN39@textiowrap@27
  00066	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0006b	83 f8 ff	 cmp	 eax, -1

; 1300 :         return NULL;

  0006e	74 c8		 je	 SHORT $LN59@textiowrap@27
$LN39@textiowrap@27:

; 1301 : 
; 1302 :     CHECK_CLOSED(self);

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  00077	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0007c	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00081	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00085	75 64		 jne	 SHORT $LN36@textiowrap@27
  00087	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  0008e	48 85 c9	 test	 rcx, rcx
  00091	74 25		 je	 SHORT $LN35@textiowrap@27
  00093	e8 00 00 00 00	 call	 _PyFileIO_closed
  00098	8b f8		 mov	 edi, eax
  0009a	85 c0		 test	 eax, eax
$LN55@textiowrap@27:
  0009c	7e 65		 jle	 SHORT $LN38@textiowrap@27
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  000ac	e8 00 00 00 00	 call	 PyErr_SetString
  000b1	33 c0		 xor	 eax, eax
  000b3	e9 e0 02 00 00	 jmp	 $LN53@textiowrap@27
$LN35@textiowrap@27:
  000b8	33 d2		 xor	 edx, edx
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	e8 00 00 00 00	 call	 textiowrapper_closed_get
  000c2	48 8b f0	 mov	 rsi, rax
  000c5	48 85 c0	 test	 rax, rax
  000c8	0f 84 c3 01 00
	00		 je	 $LN57@textiowrap@27
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	e8 00 00 00 00	 call	 PyObject_IsTrue
  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	8b f8		 mov	 edi, eax
  000db	e8 00 00 00 00	 call	 _Py_DecRef
  000e0	85 ff		 test	 edi, edi
  000e2	79 b8		 jns	 SHORT $LN55@textiowrap@27
  000e4	33 c0		 xor	 eax, eax
  000e6	e9 ad 02 00 00	 jmp	 $LN53@textiowrap@27
$LN36@textiowrap@27:
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  000f2	48 8b cb	 mov	 rcx, rbx
  000f5	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  000fa	48 85 c0	 test	 rax, rax
  000fd	0f 84 8e 01 00
	00		 je	 $LN57@textiowrap@27
$LN38@textiowrap@27:

; 1303 : 
; 1304 :     if (self->encoder == NULL)

  00103	48 39 ab 80 00
	00 00		 cmp	 QWORD PTR [rbx+128], rbp
  0010a	75 11		 jne	 SHORT $LN28@textiowrap@27

; 1305 :         return _unsupported("not writable");

  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MHOOAMII@not?5writable?$AA@
  00113	e8 00 00 00 00	 call	 _unsupported
  00118	e9 7b 02 00 00	 jmp	 $LN53@textiowrap@27
$LN28@textiowrap@27:

; 1306 : 
; 1307 :     Py_INCREF(text);

  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  00122	e8 00 00 00 00	 call	 _Py_IncRef

; 1308 : 
; 1309 :     textlen = PyUnicode_GET_LENGTH(text);

  00127	48 8b 7c 24 50	 mov	 rdi, QWORD PTR text$[rsp]
  0012c	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 1310 : 
; 1311 :     if ((self->writetranslate && self->writenl != NULL) || self->line_buffering)

  00130	40 38 ab ac 00
	00 00		 cmp	 BYTE PTR [rbx+172], bpl
  00137	74 09		 je	 SHORT $LN25@textiowrap@27
  00139	48 39 ab a0 00
	00 00		 cmp	 QWORD PTR [rbx+160], rbp
  00140	75 0d		 jne	 SHORT $LN26@textiowrap@27
$LN25@textiowrap@27:
  00142	40 38 ab a8 00
	00 00		 cmp	 BYTE PTR [rbx+168], bpl
  00149	0f 84 92 00 00
	00		 je	 $LN23@textiowrap@27
$LN26@textiowrap@27:

; 1312 :         if (PyUnicode_FindChar(text, '\n', 0, PyUnicode_GET_LENGTH(text), 1) != -1)

  0014f	45 33 c0	 xor	 r8d, r8d
  00152	4c 8b ce	 mov	 r9, rsi
  00155	48 8b cf	 mov	 rcx, rdi
  00158	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  0015c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00164	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00169	48 83 f8 ff	 cmp	 rax, -1
  0016d	74 6d		 je	 SHORT $LN50@textiowrap@27

; 1313 :             haslf = 1;

  0016f	41 bc 01 00 00
	00		 mov	 r12d, 1

; 1314 : 
; 1315 :     if (haslf && self->writetranslate && self->writenl != NULL) {

  00175	40 38 ab ac 00
	00 00		 cmp	 BYTE PTR [rbx+172], bpl
  0017c	74 5e		 je	 SHORT $LN50@textiowrap@27
  0017e	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  00185	4d 85 c0	 test	 r8, r8
  00188	74 52		 je	 SHORT $LN50@textiowrap@27

; 1316 :         PyObject *newtext = _PyObject_CallMethodId(
; 1317 :             text, &PyId_replace, "ss", "\n", self->writenl);

  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00190	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00199	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0019e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_replace
  001a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  001aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FCBLNKNB@ss?$AA@
  001b1	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  001b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  001ba	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 1318 :         Py_DECREF(text);

  001bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  001c4	48 8b f8	 mov	 rdi, rax
  001c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1319 :         if (newtext == NULL)

  001cc	48 85 ff	 test	 rdi, rdi

; 1320 :             return NULL;

  001cf	0f 84 bc 00 00
	00		 je	 $LN57@textiowrap@27

; 1321 :         text = newtext;

  001d5	48 89 7c 24 50	 mov	 QWORD PTR text$[rsp], rdi
  001da	eb 05		 jmp	 SHORT $LN23@textiowrap@27
$LN50@textiowrap@27:
  001dc	48 8b 7c 24 50	 mov	 rdi, QWORD PTR text$[rsp]
$LN23@textiowrap@27:

; 1322 :     }
; 1323 : 
; 1324 :     if (self->write_through)

  001e1	40 38 ab a9 00
	00 00		 cmp	 BYTE PTR [rbx+169], bpl

; 1325 :         needflush = 1;
; 1326 :     else if (self->line_buffering &&

  001e8	75 35		 jne	 SHORT $LN18@textiowrap@27

; 1327 :         (haslf ||
; 1328 :          PyUnicode_FindChar(text, '\r', 0, PyUnicode_GET_LENGTH(text), 1) != -1))

  001ea	40 38 ab a8 00
	00 00		 cmp	 BYTE PTR [rbx+168], bpl
  001f1	74 31		 je	 SHORT $LN19@textiowrap@27
  001f3	45 85 e4	 test	 r12d, r12d
  001f6	75 27		 jne	 SHORT $LN18@textiowrap@27
  001f8	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  001fc	41 8d 54 24 0d	 lea	 edx, QWORD PTR [r12+13]
  00201	45 33 c0	 xor	 r8d, r8d
  00204	48 8b cf	 mov	 rcx, rdi
  00207	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0020f	e8 00 00 00 00	 call	 PyUnicode_FindChar
  00214	48 8b 7c 24 50	 mov	 rdi, QWORD PTR text$[rsp]
  00219	48 83 f8 ff	 cmp	 rax, -1

; 1329 :         needflush = 1;

  0021d	74 05		 je	 SHORT $LN19@textiowrap@27
$LN18@textiowrap@27:
  0021f	bd 01 00 00 00	 mov	 ebp, 1
$LN19@textiowrap@27:

; 1330 : 
; 1331 :     /* XXX What if we were just reading? */
; 1332 :     if (self->encodefunc != NULL) {

  00224	48 8b 83 b8 00
	00 00		 mov	 rax, QWORD PTR [rbx+184]
  0022b	48 85 c0	 test	 rax, rax
  0022e	74 11		 je	 SHORT $LN17@textiowrap@27

; 1333 :         b = (*self->encodefunc)((PyObject *) self, text);

  00230	48 8b d7	 mov	 rdx, rdi
  00233	48 8b cb	 mov	 rcx, rbx
  00236	ff d0		 call	 rax

; 1334 :         self->encoding_start_of_stream = 0;

  00238	c6 83 c0 00 00
	00 00		 mov	 BYTE PTR [rbx+192], 0

; 1335 :     }
; 1336 :     else

  0023f	eb 19		 jmp	 SHORT $LN56@textiowrap@27
$LN17@textiowrap@27:

; 1337 :         b = PyObject_CallMethodObjArgs(self->encoder,
; 1338 :                                        _PyIO_str_encode, text, NULL);

  00241	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_encode
  00248	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0024f	45 33 c9	 xor	 r9d, r9d
  00252	4c 8b c7	 mov	 r8, rdi
  00255	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
$LN56@textiowrap@27:

; 1339 :     Py_DECREF(text);

  0025a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR text$[rsp]
  0025f	48 8b f8	 mov	 rdi, rax
  00262	e8 00 00 00 00	 call	 _Py_DecRef

; 1340 :     if (b == NULL)

  00267	48 85 ff	 test	 rdi, rdi

; 1341 :         return NULL;

  0026a	74 25		 je	 SHORT $LN57@textiowrap@27

; 1342 : 
; 1343 :     if (self->pending_bytes == NULL) {

  0026c	48 83 bb d8 00
	00 00 00	 cmp	 QWORD PTR [rbx+216], 0
  00274	75 2d		 jne	 SHORT $LN14@textiowrap@27

; 1344 :         self->pending_bytes = PyList_New(0);

  00276	33 c9		 xor	 ecx, ecx
  00278	e8 00 00 00 00	 call	 PyList_New
  0027d	48 89 83 d8 00
	00 00		 mov	 QWORD PTR [rbx+216], rax

; 1345 :         if (self->pending_bytes == NULL) {

  00284	48 85 c0	 test	 rax, rax
  00287	75 0f		 jne	 SHORT $LN13@textiowrap@27

; 1346 :             Py_DECREF(b);

  00289	48 8b cf	 mov	 rcx, rdi
$LN58@textiowrap@27:
  0028c	e8 00 00 00 00	 call	 _Py_DecRef
$LN57@textiowrap@27:

; 1347 :             return NULL;

  00291	33 c0		 xor	 eax, eax
  00293	e9 00 01 00 00	 jmp	 $LN53@textiowrap@27
$LN13@textiowrap@27:

; 1348 :         }
; 1349 :         self->pending_bytes_count = 0;

  00298	48 c7 83 e0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+224], 0
$LN14@textiowrap@27:

; 1350 :     }
; 1351 :     if (PyList_Append(self->pending_bytes, b) < 0) {

  002a3	48 8b 8b d8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+216]
  002aa	48 8b d7	 mov	 rdx, rdi
  002ad	e8 00 00 00 00	 call	 PyList_Append

; 1352 :         Py_DECREF(b);

  002b2	48 8b cf	 mov	 rcx, rdi
  002b5	85 c0		 test	 eax, eax

; 1353 :         return NULL;

  002b7	78 d3		 js	 SHORT $LN58@textiowrap@27

; 1354 :     }
; 1355 :     self->pending_bytes_count += PyBytes_GET_SIZE(b);

  002b9	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  002bd	48 01 83 e0 00
	00 00		 add	 QWORD PTR [rbx+224], rax

; 1356 :     Py_DECREF(b);

  002c4	e8 00 00 00 00	 call	 _Py_DecRef

; 1357 :     if (self->pending_bytes_count > self->chunk_size || needflush) {

  002c9	4c 8b 5b 68	 mov	 r11, QWORD PTR [rbx+104]
  002cd	4c 39 9b e0 00
	00 00		 cmp	 QWORD PTR [rbx+224], r11
  002d4	7f 04		 jg	 SHORT $LN10@textiowrap@27
  002d6	85 ed		 test	 ebp, ebp
  002d8	74 30		 je	 SHORT $LN6@textiowrap@27
$LN10@textiowrap@27:

; 1358 :         if (_textiowrapper_writeflush(self) < 0)

  002da	48 8b cb	 mov	 rcx, rbx
  002dd	e8 00 00 00 00	 call	 _textiowrapper_writeflush
  002e2	85 c0		 test	 eax, eax

; 1359 :             return NULL;

  002e4	78 ab		 js	 SHORT $LN57@textiowrap@27

; 1360 :     }
; 1361 : 
; 1362 :     if (needflush) {

  002e6	85 ed		 test	 ebp, ebp
  002e8	74 20		 je	 SHORT $LN6@textiowrap@27

; 1363 :         ret = PyObject_CallMethodObjArgs(self->buffer, _PyIO_str_flush, NULL);

  002ea	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_flush
  002f1	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  002f5	45 33 c0	 xor	 r8d, r8d
  002f8	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 1364 :         if (ret == NULL)

  002fd	48 85 c0	 test	 rax, rax

; 1365 :             return NULL;

  00300	74 8f		 je	 SHORT $LN57@textiowrap@27

; 1366 :         Py_DECREF(ret);

  00302	48 8b c8	 mov	 rcx, rax
  00305	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@textiowrap@27:

; 1367 :     }
; 1368 : 
; 1369 :     Py_CLEAR(self->snapshot);

  0030a	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  00311	4d 85 c9	 test	 r9, r9
  00314	74 3c		 je	 SHORT $LN5@textiowrap@27
  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0031d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@EEOJJAGF@textiowrapper_write?$AA@
  00324	41 b8 59 05 00
	00		 mov	 r8d, 1369		; 00000559H
  0032a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00332	e8 00 00 00 00	 call	 _PyParallel_Guard
  00337	85 c0		 test	 eax, eax
  00339	75 17		 jne	 SHORT $LN5@textiowrap@27
  0033b	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  00342	48 c7 83 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+232], 0
  0034d	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@textiowrap@27:

; 1370 : 
; 1371 :     if (self->decoder) {

  00352	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00359	48 85 c9	 test	 rcx, rcx
  0035c	74 32		 je	 SHORT $LN2@textiowrap@27

; 1372 :         ret = _PyObject_CallMethodId(self->decoder, &PyId_reset, NULL);

  0035e	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00365	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0036e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_reset
  00373	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00377	45 33 c0	 xor	 r8d, r8d
  0037a	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 1373 :         if (ret == NULL)

  0037f	48 85 c0	 test	 rax, rax

; 1374 :             return NULL;

  00382	0f 84 09 ff ff
	ff		 je	 $LN57@textiowrap@27

; 1375 :         Py_DECREF(ret);

  00388	48 8b c8	 mov	 rcx, rax
  0038b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@textiowrap@27:

; 1376 :     }
; 1377 : 
; 1378 :     return PyLong_FromSsize_t(textlen);

  00390	48 8b ce	 mov	 rcx, rsi
  00393	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN53@textiowrap@27:
  00398	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0039d	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 1379 : }

  003a2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003a6	41 5c		 pop	 r12
  003a8	5d		 pop	 rbp
  003a9	5b		 pop	 rbx
  003aa	c3		 ret	 0
textiowrapper_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@	; `string'
PUBLIC	??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@		; `string'
EXTRN	PyUnicode_Join:PROC
EXTRN	_PyIO_empty_str:QWORD
EXTRN	_PyIO_ConvertSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_read DD imagerel textiowrapper_read
	DD	imagerel textiowrapper_read+120
	DD	imagerel $unwind$textiowrapper_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_read DD imagerel textiowrapper_read+120
	DD	imagerel textiowrapper_read+501
	DD	imagerel $chain$1$textiowrapper_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$textiowrapper_read DD imagerel textiowrapper_read+501
	DD	imagerel textiowrapper_read+1026
	DD	imagerel $chain$3$textiowrapper_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$textiowrapper_read DD 040021H
	DD	0d5400H
	DD	0b3400H
	DD	imagerel textiowrapper_read
	DD	imagerel textiowrapper_read+120
	DD	imagerel $unwind$textiowrapper_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_read DD 040a21H
	DD	0d540aH
	DD	0b3405H
	DD	imagerel textiowrapper_read
	DD	imagerel textiowrapper_read+120
	DD	imagerel $unwind$textiowrapper_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_read DD 040901H
	DD	0c0055209H
	DD	060027003H
xdata	ENDS
;	COMDAT ??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@
CONST	SEGMENT
??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@ DB 'textiowrapper_read', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@
CONST	SEGMENT
??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@ DB '|O&:read', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_read
_TEXT	SEGMENT
result$ = 80
self$ = 80
args$ = 88
n$ = 96
textiowrapper_read PROC					; COMDAT

; 1545 : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1546 :     Py_ssize_t n = -1;
; 1547 :     PyObject *result = NULL, *chunks = NULL;

  00009	45 33 e4	 xor	 r12d, r12d
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	41 8b fc	 mov	 edi, r12d
  00015	48 c7 44 24 60
	ff ff ff ff	 mov	 QWORD PTR n$[rsp], -1
  0001e	4c 89 64 24 50	 mov	 QWORD PTR result$[rsp], r12

; 1548 : 
; 1549 :     CHECK_INITIALIZED(self);

  00023	39 79 60	 cmp	 DWORD PTR [rcx+96], edi
  00026	7f 2a		 jg	 SHORT $LN59@textiowrap@28
  00028	39 79 64	 cmp	 DWORD PTR [rcx+100], edi
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00039	75 07		 jne	 SHORT $LN76@textiowrap@28
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN76@textiowrap@28:
  00042	e8 00 00 00 00	 call	 PyErr_SetString
$LN81@textiowrap@28:
  00047	33 c0		 xor	 eax, eax

; 1646 : }

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	41 5c		 pop	 r12
  0004f	5f		 pop	 rdi
  00050	5e		 pop	 rsi
  00051	c3		 ret	 0
$LN59@textiowrap@28:

; 1550 : 
; 1551 :     if (!PyArg_ParseTuple(args, "|O&:read", &_PyIO_ConvertSsize_t, &n))

  00052	4c 8d 4c 24 60	 lea	 r9, QWORD PTR n$[rsp]
  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyIO_ConvertSsize_t
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006d	85 c0		 test	 eax, eax

; 1552 :         return NULL;

  0006f	74 d6		 je	 SHORT $LN81@textiowrap@28

; 1553 : 
; 1554 :     CHECK_CLOSED(self);

  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  00078	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0007d	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00082	48 39 46 58	 cmp	 QWORD PTR [rsi+88], rax
  00086	75 60		 jne	 SHORT $LN52@textiowrap@28
  00088	48 8b 8e f8 00
	00 00		 mov	 rcx, QWORD PTR [rsi+248]
  0008f	48 85 c9	 test	 rcx, rcx
  00092	74 23		 je	 SHORT $LN51@textiowrap@28
  00094	e8 00 00 00 00	 call	 _PyFileIO_closed
  00099	8b d8		 mov	 ebx, eax
  0009b	85 c0		 test	 eax, eax
$LN77@textiowrap@28:
  0009d	7e 61		 jle	 SHORT $LN54@textiowrap@28
  0009f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  000ad	e8 00 00 00 00	 call	 PyErr_SetString
  000b2	e9 29 01 00 00	 jmp	 $LN3@textiowrap@28
$LN51@textiowrap@28:
  000b7	33 d2		 xor	 edx, edx
  000b9	48 8b ce	 mov	 rcx, rsi
  000bc	e8 00 00 00 00	 call	 textiowrapper_closed_get
  000c1	48 8b e8	 mov	 rbp, rax
  000c4	48 85 c0	 test	 rax, rax
  000c7	0f 84 13 01 00
	00		 je	 $LN3@textiowrap@28
  000cd	48 8b c8	 mov	 rcx, rax
  000d0	e8 00 00 00 00	 call	 PyObject_IsTrue
  000d5	48 8b cd	 mov	 rcx, rbp
  000d8	8b d8		 mov	 ebx, eax
  000da	e8 00 00 00 00	 call	 _Py_DecRef
  000df	85 db		 test	 ebx, ebx
  000e1	79 ba		 jns	 SHORT $LN77@textiowrap@28
  000e3	e9 f8 00 00 00	 jmp	 $LN3@textiowrap@28
$LN52@textiowrap@28:
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  000ef	48 8b ce	 mov	 rcx, rsi
  000f2	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  000f7	48 85 c0	 test	 rax, rax
  000fa	0f 84 e0 00 00
	00		 je	 $LN3@textiowrap@28
$LN54@textiowrap@28:

; 1555 : 
; 1556 :     if (self->decoder == NULL)

  00100	48 39 be 88 00
	00 00		 cmp	 QWORD PTR [rsi+136], rdi
  00107	75 11		 jne	 SHORT $LN44@textiowrap@28

; 1557 :         return _unsupported("not readable");

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MLDODNAJ@not?5readable?$AA@
  00110	e8 00 00 00 00	 call	 _unsupported
  00115	e9 c8 00 00 00	 jmp	 $LN75@textiowrap@28
$LN44@textiowrap@28:

; 1558 : 
; 1559 :     if (_textiowrapper_writeflush(self) < 0)

  0011a	48 8b ce	 mov	 rcx, rsi
  0011d	e8 00 00 00 00	 call	 _textiowrapper_writeflush
  00122	85 c0		 test	 eax, eax

; 1560 :         return NULL;

  00124	0f 88 b6 00 00
	00		 js	 $LN3@textiowrap@28

; 1561 : 
; 1562 :     if (n < 0) {

  0012a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR n$[rsp]
  0012f	48 85 db	 test	 rbx, rbx
  00132	0f 89 1c 01 00
	00		 jns	 $LN42@textiowrap@28

; 1563 :         /* Read everything */
; 1564 :         PyObject *bytes = _PyObject_CallMethodId(self->buffer, &PyId_read, NULL);

  00138	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0013e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00147	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_read
  0014c	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00150	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00154	45 33 c0	 xor	 r8d, r8d
  00157	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  0015c	48 8b e8	 mov	 rbp, rax

; 1565 :         PyObject *decoded;
; 1566 :         if (bytes == NULL)

  0015f	48 85 c0	 test	 rax, rax
  00162	0f 84 4f 02 00
	00		 je	 $fail$22065

; 1567 :             goto fail;
; 1568 : 
; 1569 :         if (Py_TYPE(self->decoder) == &PyIncrementalNewlineDecoder_Type)

  00168	48 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [rsi+136]
  0016f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyIncrementalNewlineDecoder_Type
  00176	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017a	75 10		 jne	 SHORT $LN40@textiowrap@28

; 1570 :             decoded = _PyIncrementalNewlineDecoder_decode(self->decoder,
; 1571 :                                                           bytes, 1);

  0017c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00182	48 8b d5	 mov	 rdx, rbp
  00185	e8 00 00 00 00	 call	 _PyIncrementalNewlineDecoder_decode

; 1572 :         else

  0018a	eb 1b		 jmp	 SHORT $LN78@textiowrap@28
$LN40@textiowrap@28:

; 1573 :             decoded = PyObject_CallMethodObjArgs(
; 1574 :                 self->decoder, _PyIO_str_decode, bytes, Py_True, NULL);

  0018c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_decode
  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0019a	4c 8b c5	 mov	 r8, rbp
  0019d	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001a2	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
$LN78@textiowrap@28:

; 1575 :         Py_DECREF(bytes);

  001a7	48 8b cd	 mov	 rcx, rbp
  001aa	48 8b d8	 mov	 rbx, rax
  001ad	e8 00 00 00 00	 call	 _Py_DecRef

; 1576 :         if (check_decoded(decoded) < 0)

  001b2	48 8b cb	 mov	 rcx, rbx
  001b5	e8 00 00 00 00	 call	 check_decoded
  001ba	85 c0		 test	 eax, eax
  001bc	0f 88 f5 01 00
	00		 js	 $fail$22065

; 1577 :             goto fail;
; 1578 : 
; 1579 :         result = textiowrapper_get_decoded_chars(self, -1);

  001c2	48 83 ca ff	 or	 rdx, -1
  001c6	48 8b ce	 mov	 rcx, rsi
  001c9	e8 00 00 00 00	 call	 textiowrapper_get_decoded_chars
  001ce	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1580 : 
; 1581 :         if (result == NULL) {

  001d3	48 85 c0	 test	 rax, rax
  001d6	75 1d		 jne	 SHORT $LN37@textiowrap@28

; 1582 :             Py_DECREF(decoded);

  001d8	48 8b cb	 mov	 rcx, rbx
$LN80@textiowrap@28:
  001db	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@28:

; 1645 :     return NULL;

  001e0	33 c0		 xor	 eax, eax
$LN75@textiowrap@28:
  001e2	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001e7	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]

; 1646 : }

  001ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f0	41 5c		 pop	 r12
  001f2	5f		 pop	 rdi
  001f3	5e		 pop	 rsi
  001f4	c3		 ret	 0
$LN37@textiowrap@28:

; 1583 :             return NULL;
; 1584 :         }
; 1585 : 
; 1586 :         PyUnicode_AppendAndDel(&result, decoded);

  001f5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR result$[rsp]
  001fa	48 8b d3	 mov	 rdx, rbx
  001fd	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 1587 :         if (result == NULL)

  00202	48 39 7c 24 50	 cmp	 QWORD PTR result$[rsp], rdi
  00207	74 d7		 je	 SHORT $LN3@textiowrap@28

; 1588 :             goto fail;
; 1589 : 
; 1590 :         Py_CLEAR(self->snapshot);

  00209	4c 8b 8e e8 00
	00 00		 mov	 r9, QWORD PTR [rsi+232]
  00210	4d 85 c9	 test	 r9, r9
  00213	74 38		 je	 SHORT $LN34@textiowrap@28
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@
  00223	41 b8 36 06 00
	00		 mov	 r8d, 1590		; 00000636H
  00229	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00231	e8 00 00 00 00	 call	 _PyParallel_Guard
  00236	85 c0		 test	 eax, eax
  00238	75 13		 jne	 SHORT $LN34@textiowrap@28
  0023a	48 8b 8e e8 00
	00 00		 mov	 rcx, QWORD PTR [rsi+232]
  00241	4c 89 a6 e8 00
	00 00		 mov	 QWORD PTR [rsi+232], r12
  00248	e8 00 00 00 00	 call	 _Py_DecRef
$LN34@textiowrap@28:

; 1591 :         return result;

  0024d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  00252	eb 8e		 jmp	 SHORT $LN75@textiowrap@28
$LN42@textiowrap@28:

; 1592 :     }
; 1593 :     else {
; 1594 :         int res = 1;
; 1595 :         Py_ssize_t remaining = n;
; 1596 : 
; 1597 :         result = textiowrapper_get_decoded_chars(self, n);

  00254	48 8b d3	 mov	 rdx, rbx
  00257	48 8b ce	 mov	 rcx, rsi
  0025a	e8 00 00 00 00	 call	 textiowrapper_get_decoded_chars
  0025f	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1598 :         if (result == NULL)

  00264	48 85 c0	 test	 rax, rax
  00267	0f 84 73 ff ff
	ff		 je	 $LN3@textiowrap@28

; 1599 :             goto fail;
; 1600 :         if (PyUnicode_READY(result) == -1)

  0026d	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  00271	75 16		 jne	 SHORT $LN71@textiowrap@28
  00273	48 8b c8	 mov	 rcx, rax
  00276	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0027b	83 f8 ff	 cmp	 eax, -1
  0027e	0f 84 33 01 00
	00		 je	 $fail$22065
  00284	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN71@textiowrap@28:

; 1601 :             goto fail;
; 1602 :         remaining -= PyUnicode_GET_LENGTH(result);

  00289	48 2b 58 60	 sub	 rbx, QWORD PTR [rax+96]

; 1603 : 
; 1604 :         /* Keep reading chunks until we have n characters to return */
; 1605 :         while (remaining > 0) {

  0028d	48 85 db	 test	 rbx, rbx
  00290	0f 8e 4c ff ff
	ff		 jle	 $LN75@textiowrap@28
  00296	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL28@textiowrap@28:

; 1606 :             res = textiowrapper_read_chunk(self, remaining);

  002a0	48 8b d3	 mov	 rdx, rbx
  002a3	48 8b ce	 mov	 rcx, rsi
  002a6	e8 00 00 00 00	 call	 textiowrapper_read_chunk

; 1607 :             if (res < 0) {

  002ab	85 c0		 test	 eax, eax
  002ad	79 14		 jns	 SHORT $LN79@textiowrap@28

; 1608 :                 /* NOTE: PyErr_SetFromErrno() calls PyErr_CheckSignals()
; 1609 :                    when EINTR occurs so we needn't do it ourselves. */
; 1610 :                 if (_PyIO_trap_eintr()) {

  002af	e8 00 00 00 00	 call	 _PyIO_trap_eintr
  002b4	85 c0		 test	 eax, eax
  002b6	0f 84 fb 00 00
	00		 je	 $fail$22065

; 1611 :                     continue;

  002bc	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  002c1	eb 5f		 jmp	 SHORT $LN70@textiowrap@28
$LN79@textiowrap@28:

; 1612 :                 }
; 1613 :                 goto fail;
; 1614 :             }
; 1615 :             if (res == 0)  /* EOF */

  002c3	74 68		 je	 SHORT $LN73@textiowrap@28

; 1616 :                 break;
; 1617 :             if (chunks == NULL) {

  002c5	48 85 ff	 test	 rdi, rdi
  002c8	75 13		 jne	 SHORT $LN22@textiowrap@28

; 1618 :                 chunks = PyList_New(0);

  002ca	33 c9		 xor	 ecx, ecx
  002cc	e8 00 00 00 00	 call	 PyList_New
  002d1	48 8b f8	 mov	 rdi, rax

; 1619 :                 if (chunks == NULL)

  002d4	48 85 c0	 test	 rax, rax
  002d7	0f 84 da 00 00
	00		 je	 $fail$22065
$LN22@textiowrap@28:

; 1620 :                     goto fail;
; 1621 :             }
; 1622 :             if (PyUnicode_GET_LENGTH(result) > 0 &&
; 1623 :                 PyList_Append(chunks, result) < 0)

  002dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  002e2	4c 39 61 60	 cmp	 QWORD PTR [rcx+96], r12
  002e6	7e 18		 jle	 SHORT $LN21@textiowrap@28
  002e8	48 8b d1	 mov	 rdx, rcx
  002eb	48 8b cf	 mov	 rcx, rdi
  002ee	e8 00 00 00 00	 call	 PyList_Append
  002f3	85 c0		 test	 eax, eax
  002f5	0f 88 bc 00 00
	00		 js	 $fail$22065
  002fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
$LN21@textiowrap@28:

; 1624 :                 goto fail;
; 1625 :             Py_DECREF(result);

  00300	e8 00 00 00 00	 call	 _Py_DecRef

; 1626 :             result = textiowrapper_get_decoded_chars(self, remaining);

  00305	48 8b d3	 mov	 rdx, rbx
  00308	48 8b ce	 mov	 rcx, rsi
  0030b	e8 00 00 00 00	 call	 textiowrapper_get_decoded_chars
  00310	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1627 :             if (result == NULL)

  00315	48 85 c0	 test	 rax, rax
  00318	0f 84 88 00 00
	00		 je	 $LN7@textiowrap@28

; 1628 :                 goto fail;
; 1629 :             remaining -= PyUnicode_GET_LENGTH(result);

  0031e	48 2b 58 60	 sub	 rbx, QWORD PTR [rax+96]
$LN70@textiowrap@28:

; 1603 : 
; 1604 :         /* Keep reading chunks until we have n characters to return */
; 1605 :         while (remaining > 0) {

  00322	48 85 db	 test	 rbx, rbx
  00325	0f 8f 75 ff ff
	ff		 jg	 $LL28@textiowrap@28
  0032b	eb 05		 jmp	 SHORT $LN27@textiowrap@28
$LN73@textiowrap@28:
  0032d	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN27@textiowrap@28:

; 1630 :         }
; 1631 :         if (chunks != NULL) {

  00332	48 85 ff	 test	 rdi, rdi
  00335	0f 84 a7 fe ff
	ff		 je	 $LN75@textiowrap@28

; 1632 :             if (result != NULL && PyList_Append(chunks, result) < 0)

  0033b	48 85 c0	 test	 rax, rax
  0033e	74 4d		 je	 SHORT $LN16@textiowrap@28
  00340	48 8b d0	 mov	 rdx, rax
  00343	48 8b cf	 mov	 rcx, rdi
  00346	e8 00 00 00 00	 call	 PyList_Append
  0034b	85 c0		 test	 eax, eax
  0034d	78 68		 js	 SHORT $fail$22065

; 1633 :                 goto fail;
; 1634 :             Py_CLEAR(result);

  0034f	4c 8b 4c 24 50	 mov	 r9, QWORD PTR result$[rsp]
  00354	4d 85 c9	 test	 r9, r9
  00357	74 34		 je	 SHORT $LN16@textiowrap@28
  00359	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@
  00367	41 b8 62 06 00
	00		 mov	 r8d, 1634		; 00000662H
  0036d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00375	e8 00 00 00 00	 call	 _PyParallel_Guard
  0037a	85 c0		 test	 eax, eax
  0037c	75 0f		 jne	 SHORT $LN16@textiowrap@28
  0037e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  00383	4c 89 64 24 50	 mov	 QWORD PTR result$[rsp], r12
  00388	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@textiowrap@28:

; 1635 :             result = PyUnicode_Join(_PyIO_empty_str, chunks);

  0038d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyIO_empty_str
  00394	48 8b d7	 mov	 rdx, rdi
  00397	e8 00 00 00 00	 call	 PyUnicode_Join
  0039c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1636 :             if (result == NULL)

  003a1	48 85 c0	 test	 rax, rax
  003a4	75 22		 jne	 SHORT $LN12@textiowrap@28
$LN7@textiowrap@28:

; 1644 :     Py_XDECREF(chunks);

  003a6	48 85 ff	 test	 rdi, rdi
  003a9	0f 84 31 fe ff
	ff		 je	 $LN3@textiowrap@28
  003af	48 8b cf	 mov	 rcx, rdi
  003b2	e9 24 fe ff ff	 jmp	 $LN80@textiowrap@28
$fail$22065:

; 1641 :     }
; 1642 :   fail:
; 1643 :     Py_XDECREF(result);

  003b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  003bc	48 85 c9	 test	 rcx, rcx
  003bf	74 e5		 je	 SHORT $LN7@textiowrap@28
  003c1	e8 00 00 00 00	 call	 _Py_DecRef
  003c6	eb de		 jmp	 SHORT $LN7@textiowrap@28
$LN12@textiowrap@28:

; 1637 :                 goto fail;
; 1638 :             Py_CLEAR(chunks);

  003c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JBJKCAAE@textiowrapper_read?$AA@
  003d6	4c 8b cf	 mov	 r9, rdi
  003d9	41 b8 66 06 00
	00		 mov	 r8d, 1638		; 00000666H
  003df	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  003ec	85 c0		 test	 eax, eax
  003ee	75 08		 jne	 SHORT $LN11@textiowrap@28
  003f0	48 8b cf	 mov	 rcx, rdi
  003f3	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@textiowrap@28:
  003f8	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]

; 1639 :         }
; 1640 :         return result;

  003fd	e9 e0 fd ff ff	 jmp	 $LN75@textiowrap@28
textiowrapper_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@	; `string'
EXTRN	PyUnicode_Concat:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_textiowrapper_readline DD imagerel _textiowrapper_readline
	DD	imagerel _textiowrapper_readline+289
	DD	imagerel $unwind$_textiowrapper_readline
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_textiowrapper_readline DD imagerel _textiowrapper_readline+289
	DD	imagerel _textiowrapper_readline+892
	DD	imagerel $chain$1$_textiowrapper_readline
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_textiowrapper_readline DD imagerel _textiowrapper_readline+892
	DD	imagerel _textiowrapper_readline+1545
	DD	imagerel $chain$3$_textiowrapper_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_textiowrapper_readline DD 040021H
	DD	08e400H
	DD	013c400H
	DD	imagerel _textiowrapper_readline
	DD	imagerel _textiowrapper_readline+289
	DD	imagerel $unwind$_textiowrapper_readline
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_textiowrapper_readline DD 040d21H
	DD	08e40dH
	DD	013c408H
	DD	imagerel _textiowrapper_readline
	DD	imagerel _textiowrapper_readline+289
	DD	imagerel $unwind$_textiowrapper_readline
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_textiowrapper_readline DD 071101H
	DD	0f00d8211H
	DD	07009d00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT ??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
CONST	SEGMENT
??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@ DB '_textiowrapper_readli'
	DB	'ne', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\textio.c
CONST	ENDS
;	COMDAT _textiowrapper_readline
_TEXT	SEGMENT
chunked$1$ = 128
self$ = 128
limit$ = 136
consumed$22332 = 144
_textiowrapper_readline PROC				; COMDAT

; 1758 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 55		 push	 r13
  0000b	41 57		 push	 r15
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1759 :     PyObject *line = NULL, *chunks = NULL, *remaining = NULL;
; 1760 :     Py_ssize_t start, endpos, chunked, offset_to_buffer;
; 1761 :     int res;
; 1762 : 
; 1763 :     CHECK_CLOSED(self);

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  00018	33 db		 xor	 ebx, ebx
  0001a	45 33 ff	 xor	 r15d, r15d
  0001d	45 33 ed	 xor	 r13d, r13d
  00020	48 8b f1	 mov	 rsi, rcx
  00023	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00027	0f 85 d5 00 00
	00		 jne	 $LN81@textiowrap@29
  0002d	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 31		 je	 SHORT $LN80@textiowrap@29
  00039	e8 00 00 00 00	 call	 _PyFileIO_closed
  0003e	8b e8		 mov	 ebp, eax
  00040	85 c0		 test	 eax, eax
$LN127@textiowrap@29:
  00042	0f 8e cb 00 00
	00		 jle	 $LN83@textiowrap@29
  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00056	e8 00 00 00 00	 call	 PyErr_SetString
  0005b	33 c0		 xor	 eax, eax

; 1917 : }

  0005d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00061	41 5f		 pop	 r15
  00063	41 5d		 pop	 r13
  00065	5f		 pop	 rdi
  00066	5e		 pop	 rsi
  00067	5d		 pop	 rbp
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$LN80@textiowrap@29:

; 1759 :     PyObject *line = NULL, *chunks = NULL, *remaining = NULL;
; 1760 :     Py_ssize_t start, endpos, chunked, offset_to_buffer;
; 1761 :     int res;
; 1762 : 
; 1763 :     CHECK_CLOSED(self);

  0006a	33 d2		 xor	 edx, edx
  0006c	48 8b ce	 mov	 rcx, rsi
  0006f	e8 00 00 00 00	 call	 textiowrapper_closed_get
  00074	48 8b f8	 mov	 rdi, rax
  00077	48 85 c0	 test	 rax, rax
  0007a	74 77		 je	 SHORT $LN129@textiowrap@29
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 PyObject_IsTrue
  00084	8b e8		 mov	 ebp, eax
  00086	e8 00 00 00 00	 call	 _Py_PXCTX
  0008b	85 c0		 test	 eax, eax
  0008d	75 5c		 jne	 SHORT $LN103@textiowrap@29
  0008f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00093	a8 20		 test	 al, 32			; 00000020H
  00095	75 4c		 jne	 SHORT $LN97@textiowrap@29
  00097	84 c0		 test	 al, al
  00099	78 48		 js	 SHORT $LN97@textiowrap@29
  0009b	a8 02		 test	 al, 2
  0009d	75 4c		 jne	 SHORT $LN103@textiowrap@29
  0009f	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000a3	75 46		 jne	 SHORT $LN103@textiowrap@29
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b3	4c 8b cf	 mov	 r9, rdi
  000b6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	85 c0		 test	 eax, eax
  000ce	74 07		 je	 SHORT $LN102@textiowrap@29
  000d0	e8 00 00 00 00	 call	 _Px_Dealloc
  000d5	eb 14		 jmp	 SHORT $LN103@textiowrap@29
$LN102@textiowrap@29:
  000d7	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000db	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e1	eb 08		 jmp	 SHORT $LN103@textiowrap@29
$LN97@textiowrap@29:
  000e3	48 8b cf	 mov	 rcx, rdi
  000e6	e8 00 00 00 00	 call	 Px_DecRef
$LN103@textiowrap@29:
  000eb	85 ed		 test	 ebp, ebp
  000ed	0f 89 4f ff ff
	ff		 jns	 $LN127@textiowrap@29
$LN129@textiowrap@29:
  000f3	33 c0		 xor	 eax, eax

; 1917 : }

  000f5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f9	41 5f		 pop	 r15
  000fb	41 5d		 pop	 r13
  000fd	5f		 pop	 rdi
  000fe	5e		 pop	 rsi
  000ff	5d		 pop	 rbp
  00100	5b		 pop	 rbx
  00101	c3		 ret	 0
$LN81@textiowrap@29:

; 1759 :     PyObject *line = NULL, *chunks = NULL, *remaining = NULL;
; 1760 :     Py_ssize_t start, endpos, chunked, offset_to_buffer;
; 1761 :     int res;
; 1762 : 
; 1763 :     CHECK_CLOSED(self);

  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  00109	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  0010e	48 85 c0	 test	 rax, rax
  00111	74 e0		 je	 SHORT $LN129@textiowrap@29
$LN83@textiowrap@29:

; 1764 : 
; 1765 :     if (_textiowrapper_writeflush(self) < 0)

  00113	48 8b ce	 mov	 rcx, rsi
  00116	e8 00 00 00 00	 call	 _textiowrapper_writeflush
  0011b	85 c0		 test	 eax, eax

; 1766 :         return NULL;

  0011d	78 d4		 js	 SHORT $LN129@textiowrap@29

; 1767 : 
; 1768 :     chunked = 0;

  0011f	33 ed		 xor	 ebp, ebp
  00121	4c 89 a4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r12
  00129	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  0012e	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR chunked$1$[rsp], rbp
  00136	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL72@textiowrap@29:

; 1769 : 
; 1770 :     while (1) {
; 1771 :         char *ptr;
; 1772 :         Py_ssize_t line_len;
; 1773 :         int kind;
; 1774 :         Py_ssize_t consumed = 0;

  00140	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR consumed$22332[rsp], 0

; 1775 : 
; 1776 :         /* First, get some data if necessary */
; 1777 :         res = 1;

  0014c	bf 01 00 00 00	 mov	 edi, 1
$LL70@textiowrap@29:

; 1778 :         while (!self->decoded_chars ||
; 1779 :                !PyUnicode_GET_LENGTH(self->decoded_chars)) {

  00151	48 8b 86 c8 00
	00 00		 mov	 rax, QWORD PTR [rsi+200]
  00158	48 85 c0	 test	 rax, rax
  0015b	74 0b		 je	 SHORT $LN68@textiowrap@29
  0015d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00162	0f 85 14 02 00
	00		 jne	 $LN113@textiowrap@29
$LN68@textiowrap@29:

; 1780 :             res = textiowrapper_read_chunk(self, 0);

  00168	33 d2		 xor	 edx, edx
  0016a	48 8b ce	 mov	 rcx, rsi
  0016d	e8 00 00 00 00	 call	 textiowrapper_read_chunk
  00172	8b f8		 mov	 edi, eax

; 1781 :             if (res < 0) {

  00174	85 c0		 test	 eax, eax
  00176	79 37		 jns	 SHORT $LN128@textiowrap@29

; 1782 :                 /* NOTE: PyErr_SetFromErrno() calls PyErr_CheckSignals()
; 1783 :                    when EINTR occurs so we needn't do it ourselves. */
; 1784 :                 if (_PyIO_trap_eintr()) {

  00178	e8 00 00 00 00	 call	 _PyIO_trap_eintr
  0017d	85 c0		 test	 eax, eax
  0017f	75 d0		 jne	 SHORT $LL70@textiowrap@29
$error$22342:

; 1911 : 
; 1912 :   error:
; 1913 :     Py_XDECREF(chunks);

  00181	4d 85 ff	 test	 r15, r15
  00184	74 08		 je	 SHORT $LN11@textiowrap@29
  00186	49 8b cf	 mov	 rcx, r15
  00189	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@textiowrap@29:

; 1914 :     Py_XDECREF(remaining);

  0018e	4d 85 ed	 test	 r13, r13
  00191	74 08		 je	 SHORT $LN7@textiowrap@29
  00193	49 8b cd	 mov	 rcx, r13
  00196	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@textiowrap@29:

; 1915 :     Py_XDECREF(line);

  0019b	48 85 db	 test	 rbx, rbx
  0019e	74 08		 je	 SHORT $LN3@textiowrap@29
  001a0	48 8b cb	 mov	 rcx, rbx
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@29:

; 1916 :     return NULL;

  001a8	33 c0		 xor	 eax, eax
  001aa	e9 b3 01 00 00	 jmp	 $LN126@textiowrap@29
$LN128@textiowrap@29:

; 1785 :                     continue;
; 1786 :                 }
; 1787 :                 goto error;
; 1788 :             }
; 1789 :             if (res == 0)

  001af	75 a0		 jne	 SHORT $LL70@textiowrap@29
$LN114@textiowrap@29:

; 1793 :             /* end of file */
; 1794 :             textiowrapper_set_decoded_chars(self, NULL);

  001b1	33 d2		 xor	 edx, edx
  001b3	48 8b ce	 mov	 rcx, rsi
  001b6	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars

; 1795 :             Py_CLEAR(self->snapshot);

  001bb	4c 8b 8e e8 00
	00 00		 mov	 r9, QWORD PTR [rsi+232]
  001c2	4d 85 c9	 test	 r9, r9
  001c5	74 3c		 je	 SHORT $LN62@textiowrap@29
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  001d5	41 b8 03 07 00
	00		 mov	 r8d, 1795		; 00000703H
  001db	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e8	85 c0		 test	 eax, eax
  001ea	75 17		 jne	 SHORT $LN62@textiowrap@29
  001ec	48 8b 8e e8 00
	00 00		 mov	 rcx, QWORD PTR [rsi+232]
  001f3	48 c7 86 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rsi+232], 0
  001fe	e8 00 00 00 00	 call	 _Py_DecRef
$LN62@textiowrap@29:

; 1796 :             start = endpos = offset_to_buffer = 0;

  00203	45 33 f6	 xor	 r14d, r14d
  00206	45 33 c0	 xor	 r8d, r8d
  00209	33 ff		 xor	 edi, edi
$LN71@textiowrap@29:

; 1871 :     }
; 1872 : 
; 1873 :     if (line != NULL) {

  0020b	48 85 db	 test	 rbx, rbx
  0020e	74 64		 je	 SHORT $LN36@textiowrap@29

; 1874 :         /* Our line ends in the current buffer */
; 1875 :         self->decoded_chars_used = endpos - offset_to_buffer;

  00210	49 8b c0	 mov	 rax, r8
  00213	49 2b c6	 sub	 rax, r14
  00216	48 89 86 d0 00
	00 00		 mov	 QWORD PTR [rsi+208], rax

; 1876 :         if (start > 0 || endpos < PyUnicode_GET_LENGTH(line)) {

  0021d	48 85 ff	 test	 rdi, rdi
  00220	7f 06		 jg	 SHORT $LN35@textiowrap@29
  00222	4c 3b 43 60	 cmp	 r8, QWORD PTR [rbx+96]
  00226	7d 4c		 jge	 SHORT $LN36@textiowrap@29
$LN35@textiowrap@29:

; 1877 :             PyObject *s = PyUnicode_Substring(line, start, endpos);

  00228	48 8b d7	 mov	 rdx, rdi
  0022b	48 8b cb	 mov	 rcx, rbx
  0022e	e8 00 00 00 00	 call	 PyUnicode_Substring

; 1878 :             Py_CLEAR(line);

  00233	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  00241	4c 8b cb	 mov	 r9, rbx
  00244	41 b8 56 07 00
	00		 mov	 r8d, 1878		; 00000756H
  0024a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00252	48 8b f8	 mov	 rdi, rax
  00255	e8 00 00 00 00	 call	 _PyParallel_Guard
  0025a	85 c0		 test	 eax, eax
  0025c	75 0a		 jne	 SHORT $LN33@textiowrap@29
  0025e	48 8b cb	 mov	 rcx, rbx
  00261	33 db		 xor	 ebx, ebx
  00263	e8 00 00 00 00	 call	 _Py_DecRef
$LN33@textiowrap@29:

; 1879 :             if (s == NULL)

  00268	48 85 ff	 test	 rdi, rdi
  0026b	0f 84 10 ff ff
	ff		 je	 $error$22342

; 1880 :                 goto error;
; 1881 :             line = s;

  00271	48 8b df	 mov	 rbx, rdi
$LN36@textiowrap@29:

; 1882 :         }
; 1883 :     }
; 1884 :     if (remaining != NULL) {

  00274	4d 85 ed	 test	 r13, r13
  00277	74 5e		 je	 SHORT $LN23@textiowrap@29

; 1885 :         if (chunks == NULL) {

  00279	4d 85 ff	 test	 r15, r15
  0027c	75 13		 jne	 SHORT $LN27@textiowrap@29

; 1886 :             chunks = PyList_New(0);

  0027e	33 c9		 xor	 ecx, ecx
  00280	e8 00 00 00 00	 call	 PyList_New
  00285	4c 8b f8	 mov	 r15, rax

; 1887 :             if (chunks == NULL)

  00288	48 85 c0	 test	 rax, rax
  0028b	0f 84 fd fe ff
	ff		 je	 $LN11@textiowrap@29
$LN27@textiowrap@29:

; 1888 :                 goto error;
; 1889 :         }
; 1890 :         if (PyList_Append(chunks, remaining) < 0)

  00291	49 8b d5	 mov	 rdx, r13
  00294	49 8b cf	 mov	 rcx, r15
  00297	e8 00 00 00 00	 call	 PyList_Append
  0029c	85 c0		 test	 eax, eax
  0029e	0f 88 dd fe ff
	ff		 js	 $error$22342

; 1891 :             goto error;
; 1892 :         Py_CLEAR(remaining);

  002a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  002b2	4d 8b cd	 mov	 r9, r13
  002b5	41 b8 64 07 00
	00		 mov	 r8d, 1892		; 00000764H
  002bb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  002c8	85 c0		 test	 eax, eax
  002ca	75 0b		 jne	 SHORT $LN23@textiowrap@29
  002cc	49 8b cd	 mov	 rcx, r13
  002cf	45 33 ed	 xor	 r13d, r13d
  002d2	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@textiowrap@29:

; 1893 :     }
; 1894 :     if (chunks != NULL) {

  002d7	4d 85 ff	 test	 r15, r15
  002da	74 6b		 je	 SHORT $LN15@textiowrap@29

; 1895 :         if (line != NULL) {

  002dc	48 85 db	 test	 rbx, rbx
  002df	74 1b		 je	 SHORT $LN20@textiowrap@29

; 1896 :             if (PyList_Append(chunks, line) < 0)

  002e1	48 8b d3	 mov	 rdx, rbx
  002e4	49 8b cf	 mov	 rcx, r15
  002e7	e8 00 00 00 00	 call	 PyList_Append
  002ec	85 c0		 test	 eax, eax
  002ee	0f 88 8d fe ff
	ff		 js	 $error$22342

; 1897 :                 goto error;
; 1898 :             Py_DECREF(line);

  002f4	48 8b cb	 mov	 rcx, rbx
  002f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@textiowrap@29:

; 1899 :         }
; 1900 :         line = PyUnicode_Join(_PyIO_empty_str, chunks);

  002fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyIO_empty_str
  00303	49 8b d7	 mov	 rdx, r15
  00306	e8 00 00 00 00	 call	 PyUnicode_Join
  0030b	48 8b d8	 mov	 rbx, rax

; 1901 :         if (line == NULL)

  0030e	48 85 c0	 test	 rax, rax
  00311	0f 84 6a fe ff
	ff		 je	 $error$22342

; 1902 :             goto error;
; 1903 :         Py_CLEAR(chunks);

  00317	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  00325	4d 8b cf	 mov	 r9, r15
  00328	41 b8 6f 07 00
	00		 mov	 r8d, 1903		; 0000076fH
  0032e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00336	e8 00 00 00 00	 call	 _PyParallel_Guard
  0033b	85 c0		 test	 eax, eax
  0033d	75 08		 jne	 SHORT $LN15@textiowrap@29
  0033f	49 8b cf	 mov	 rcx, r15
  00342	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@textiowrap@29:

; 1904 :     }
; 1905 :     if (line == NULL) {

  00347	48 85 db	 test	 rbx, rbx
  0034a	75 13		 jne	 SHORT $LN13@textiowrap@29

; 1906 :         Py_INCREF(_PyIO_empty_str);

  0034c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyIO_empty_str
  00353	e8 00 00 00 00	 call	 _Py_IncRef

; 1907 :         line = _PyIO_empty_str;

  00358	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyIO_empty_str
$LN13@textiowrap@29:

; 1908 :     }
; 1909 : 
; 1910 :     return line;

  0035f	48 8b c3	 mov	 rax, rbx
$LN126@textiowrap@29:
  00362	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR [rsp+152]
  0036a	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]

; 1917 : }

  0036f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00373	41 5f		 pop	 r15
  00375	41 5d		 pop	 r13
  00377	5f		 pop	 rdi
  00378	5e		 pop	 rsi
  00379	5d		 pop	 rbp
  0037a	5b		 pop	 rbx
  0037b	c3		 ret	 0
$LN113@textiowrap@29:

; 1790 :                 break;
; 1791 :         }
; 1792 :         if (res == 0) {

  0037c	85 ff		 test	 edi, edi
  0037e	0f 84 2d fe ff
	ff		 je	 $LN114@textiowrap@29

; 1797 :             break;
; 1798 :         }
; 1799 : 
; 1800 :         if (remaining == NULL) {

  00384	4d 85 ed	 test	 r13, r13
  00387	75 4e		 jne	 SHORT $LN59@textiowrap@29

; 1801 :             line = self->decoded_chars;
; 1802 :             start = self->decoded_chars_used;

  00389	48 8b be d0 00
	00 00		 mov	 rdi, QWORD PTR [rsi+208]
  00390	48 8b d8	 mov	 rbx, rax

; 1803 :             offset_to_buffer = 0;

  00393	45 33 f6	 xor	 r14d, r14d

; 1804 :             Py_INCREF(line);

  00396	e8 00 00 00 00	 call	 _Py_PXCTX
  0039b	85 c0		 test	 eax, eax
  0039d	0f 85 9b 00 00
	00		 jne	 $LN52@textiowrap@29
  003a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  003b1	4c 8b cb	 mov	 r9, rbx
  003b4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  003ba	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  003c2	e8 00 00 00 00	 call	 _PyParallel_Guard
  003c7	85 c0		 test	 eax, eax
  003c9	75 06		 jne	 SHORT $LN104@textiowrap@29
  003cb	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  003cf	74 6d		 je	 SHORT $LN52@textiowrap@29
$LN104@textiowrap@29:
  003d1	48 ff 43 50	 inc	 QWORD PTR [rbx+80]

; 1805 :         }
; 1806 :         else {

  003d5	eb 67		 jmp	 SHORT $LN52@textiowrap@29
$LN59@textiowrap@29:

; 1807 :             assert(self->decoded_chars_used == 0);
; 1808 :             line = PyUnicode_Concat(remaining, self->decoded_chars);

  003d7	48 8b d0	 mov	 rdx, rax
  003da	49 8b cd	 mov	 rcx, r13
  003dd	e8 00 00 00 00	 call	 PyUnicode_Concat

; 1809 :             start = 0;
; 1810 :             offset_to_buffer = PyUnicode_GET_LENGTH(remaining);

  003e2	4d 8b 75 60	 mov	 r14, QWORD PTR [r13+96]

; 1811 :             Py_CLEAR(remaining);

  003e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  003ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  003f4	4d 8b cd	 mov	 r9, r13
  003f7	41 b8 13 07 00
	00		 mov	 r8d, 1811		; 00000713H
  003fd	48 8b d8	 mov	 rbx, rax
  00400	33 ff		 xor	 edi, edi
  00402	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0040a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0040f	85 c0		 test	 eax, eax
  00411	75 0b		 jne	 SHORT $LN56@textiowrap@29
  00413	49 8b cd	 mov	 rcx, r13
  00416	45 33 ed	 xor	 r13d, r13d
  00419	e8 00 00 00 00	 call	 _Py_DecRef
$LN56@textiowrap@29:

; 1812 :             if (line == NULL)

  0041e	48 85 db	 test	 rbx, rbx
  00421	0f 84 5a fd ff
	ff		 je	 $error$22342

; 1813 :                 goto error;
; 1814 :             if (PyUnicode_READY(line) == -1)

  00427	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0042b	75 11		 jne	 SHORT $LN52@textiowrap@29
  0042d	48 8b cb	 mov	 rcx, rbx
  00430	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00435	83 f8 ff	 cmp	 eax, -1
  00438	0f 84 43 fd ff
	ff		 je	 $error$22342
$LN52@textiowrap@29:

; 1815 :                 goto error;
; 1816 :         }
; 1817 : 
; 1818 :         ptr = PyUnicode_DATA(line);

  0043e	44 8b 4b 70	 mov	 r9d, DWORD PTR [rbx+112]
  00442	41 f6 c1 20	 test	 r9b, 32			; 00000020H
  00446	74 18		 je	 SHORT $LN91@textiowrap@29
  00448	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  0044c	74 09		 je	 SHORT $LN89@textiowrap@29
  0044e	48 8d 8b 80 00
	00 00		 lea	 rcx, QWORD PTR [rbx+128]
  00455	eb 10		 jmp	 SHORT $LN92@textiowrap@29
$LN89@textiowrap@29:
  00457	48 8d 8b a0 00
	00 00		 lea	 rcx, QWORD PTR [rbx+160]
  0045e	eb 07		 jmp	 SHORT $LN92@textiowrap@29
$LN91@textiowrap@29:
  00460	48 8b 8b a0 00
	00 00		 mov	 rcx, QWORD PTR [rbx+160]
$LN92@textiowrap@29:

; 1819 :         line_len = PyUnicode_GET_LENGTH(line);

  00467	4c 8b 63 60	 mov	 r12, QWORD PTR [rbx+96]

; 1820 :         kind = PyUnicode_KIND(line);
; 1821 : 
; 1822 :         endpos = _PyIO_find_line_ending(
; 1823 :             self->readtranslate, self->readuniversal, self->readnl,
; 1824 :             kind,
; 1825 :             ptr + kind * start,
; 1826 :             ptr + kind * line_len,
; 1827 :             &consumed);

  0046b	0f be 96 aa 00
	00 00		 movsx	 edx, BYTE PTR [rsi+170]
  00472	41 c1 e9 02	 shr	 r9d, 2
  00476	41 83 e1 07	 and	 r9d, 7
  0047a	4c 8d 94 24 90
	00 00 00	 lea	 r10, QWORD PTR consumed$22332[rsp]
  00482	4d 63 c1	 movsxd	 r8, r9d
  00485	4c 89 54 24 30	 mov	 QWORD PTR [rsp+48], r10
  0048a	49 8b c0	 mov	 rax, r8
  0048d	4c 0f af c7	 imul	 r8, rdi
  00491	49 0f af c4	 imul	 rax, r12
  00495	4c 03 c1	 add	 r8, rcx
  00498	48 03 c1	 add	 rax, rcx
  0049b	0f be 8e ab 00
	00 00		 movsx	 ecx, BYTE PTR [rsi+171]
  004a2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004a7	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  004ac	4c 8b 86 90 00
	00 00		 mov	 r8, QWORD PTR [rsi+144]
  004b3	e8 00 00 00 00	 call	 _PyIO_find_line_ending

; 1837 :         if (limit >= 0 && (endpos - start) + chunked >= limit) {

  004b8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR limit$[rsp]
  004c0	4c 8b c0	 mov	 r8, rax
  004c3	48 85 c0	 test	 rax, rax
  004c6	0f 89 09 01 00
	00		 jns	 $LN117@textiowrap@29

; 1833 :         }
; 1834 : 
; 1835 :         /* We can put aside up to `endpos` */
; 1836 :         endpos = consumed + start;

  004cc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR consumed$22332[rsp]
  004d4	48 8d 2c 07	 lea	 rbp, QWORD PTR [rdi+rax]

; 1837 :         if (limit >= 0 && (endpos - start) + chunked >= limit) {

  004d8	48 85 d2	 test	 rdx, rdx
  004db	78 1a		 js	 SHORT $LN49@textiowrap@29
  004dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR chunked$1$[rsp]
  004e5	48 8b c5	 mov	 rax, rbp
  004e8	48 2b c7	 sub	 rax, rdi
  004eb	48 03 c1	 add	 rax, rcx
  004ee	48 3b c2	 cmp	 rax, rdx
  004f1	0f 8d c6 00 00
	00		 jge	 $LN118@textiowrap@29
$LN49@textiowrap@29:

; 1840 :             break;
; 1841 :         }
; 1842 : 
; 1843 :         if (endpos > start) {

  004f7	48 3b ef	 cmp	 rbp, rdi
  004fa	7e 61		 jle	 SHORT $LN48@textiowrap@29

; 1844 :             /* No line ending seen yet - put aside current data */
; 1845 :             PyObject *s;
; 1846 :             if (chunks == NULL) {

  004fc	4d 85 ff	 test	 r15, r15
  004ff	75 13		 jne	 SHORT $LN46@textiowrap@29

; 1847 :                 chunks = PyList_New(0);

  00501	33 c9		 xor	 ecx, ecx
  00503	e8 00 00 00 00	 call	 PyList_New
  00508	4c 8b f8	 mov	 r15, rax

; 1848 :                 if (chunks == NULL)

  0050b	48 85 c0	 test	 rax, rax
  0050e	0f 84 7a fc ff
	ff		 je	 $LN11@textiowrap@29
$LN46@textiowrap@29:

; 1849 :                     goto error;
; 1850 :             }
; 1851 :             s = PyUnicode_Substring(line, start, endpos);

  00514	4c 8b c5	 mov	 r8, rbp
  00517	48 8b d7	 mov	 rdx, rdi
  0051a	48 8b cb	 mov	 rcx, rbx
  0051d	e8 00 00 00 00	 call	 PyUnicode_Substring
  00522	48 8b f8	 mov	 rdi, rax

; 1852 :             if (s == NULL)

  00525	48 85 c0	 test	 rax, rax
  00528	0f 84 53 fc ff
	ff		 je	 $error$22342

; 1853 :                 goto error;
; 1854 :             if (PyList_Append(chunks, s) < 0) {

  0052e	48 8b d0	 mov	 rdx, rax
  00531	49 8b cf	 mov	 rcx, r15
  00534	e8 00 00 00 00	 call	 PyList_Append

; 1859 :             Py_DECREF(s);

  00539	48 8b cf	 mov	 rcx, rdi
  0053c	85 c0		 test	 eax, eax
  0053e	0f 88 87 00 00
	00		 js	 $LN121@textiowrap@29

; 1856 :                 goto error;
; 1857 :             }
; 1858 :             chunked += PyUnicode_GET_LENGTH(s);

  00544	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR chunked$1$[rsp]
  0054c	4c 03 77 60	 add	 r14, QWORD PTR [rdi+96]
  00550	4c 89 b4 24 80
	00 00 00	 mov	 QWORD PTR chunked$1$[rsp], r14

; 1859 :             Py_DECREF(s);

  00558	e8 00 00 00 00	 call	 _Py_DecRef
$LN48@textiowrap@29:

; 1860 :         }
; 1861 :         /* There may be some remaining bytes we'll have to prepend to the
; 1862 :            next chunk of data */
; 1863 :         if (endpos < line_len) {

  0055d	49 3b ec	 cmp	 rbp, r12
  00560	7d 1a		 jge	 SHORT $LN41@textiowrap@29

; 1864 :             remaining = PyUnicode_Substring(line, endpos, line_len);

  00562	4d 8b c4	 mov	 r8, r12
  00565	48 8b d5	 mov	 rdx, rbp
  00568	48 8b cb	 mov	 rcx, rbx
  0056b	e8 00 00 00 00	 call	 PyUnicode_Substring
  00570	4c 8b e8	 mov	 r13, rax

; 1865 :             if (remaining == NULL)

  00573	48 85 c0	 test	 rax, rax
  00576	0f 84 05 fc ff
	ff		 je	 $error$22342
$LN41@textiowrap@29:

; 1866 :                 goto error;
; 1867 :         }
; 1868 :         Py_CLEAR(line);

  0057c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00583	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@JAGFCLNN@_textiowrapper_readline?$AA@
  0058a	4c 8b cb	 mov	 r9, rbx
  0058d	41 b8 4c 07 00
	00		 mov	 r8d, 1868		; 0000074cH
  00593	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0059b	e8 00 00 00 00	 call	 _PyParallel_Guard
  005a0	85 c0		 test	 eax, eax
  005a2	75 0a		 jne	 SHORT $LN40@textiowrap@29
  005a4	48 8b cb	 mov	 rcx, rbx
  005a7	33 db		 xor	 ebx, ebx
  005a9	e8 00 00 00 00	 call	 _Py_DecRef
$LN40@textiowrap@29:

; 1869 :         /* We have consumed the buffer */
; 1870 :         textiowrapper_set_decoded_chars(self, NULL);

  005ae	33 d2		 xor	 edx, edx
  005b0	48 8b ce	 mov	 rcx, rsi
  005b3	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars
  005b8	e9 83 fb ff ff	 jmp	 $LL72@textiowrap@29
$LN118@textiowrap@29:

; 1838 :             /* Didn't find line ending, but reached length limit */
; 1839 :             endpos = start + limit - chunked;

  005bd	4c 8b c7	 mov	 r8, rdi
  005c0	4c 2b c1	 sub	 r8, rcx
  005c3	4c 03 c2	 add	 r8, rdx
  005c6	e9 40 fc ff ff	 jmp	 $LN71@textiowrap@29
$LN121@textiowrap@29:

; 1855 :                 Py_DECREF(s);

  005cb	e8 00 00 00 00	 call	 _Py_DecRef
  005d0	e9 ac fb ff ff	 jmp	 $error$22342
$LN117@textiowrap@29:

; 1828 :         if (endpos >= 0) {
; 1829 :             endpos += start;

  005d5	4c 03 c7	 add	 r8, rdi

; 1830 :             if (limit >= 0 && (endpos - start) + chunked >= limit)

  005d8	48 85 d2	 test	 rdx, rdx
  005db	0f 88 2a fc ff
	ff		 js	 $LN71@textiowrap@29
  005e1	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR chunked$1$[rsp]
  005e9	49 8b c0	 mov	 rax, r8
  005ec	48 2b c7	 sub	 rax, rdi
  005ef	48 03 c5	 add	 rax, rbp
  005f2	48 3b c2	 cmp	 rax, rdx
  005f5	0f 8c 10 fc ff
	ff		 jl	 $LN71@textiowrap@29

; 1831 :                 endpos = start + limit - chunked;

  005fb	4c 8b c7	 mov	 r8, rdi
  005fe	4c 2b c5	 sub	 r8, rbp
  00601	4c 03 c2	 add	 r8, rdx

; 1832 :             break;

  00604	e9 02 fc ff ff	 jmp	 $LN71@textiowrap@29
_textiowrapper_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@GAMMEOLG@?$HMn?3readline?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_readline DD imagerel textiowrapper_readline
	DD	imagerel textiowrapper_readline+110
	DD	imagerel $unwind$textiowrapper_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_readline DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0M@GAMMEOLG@?$HMn?3readline?$AA@
CONST	SEGMENT
??_C@_0M@GAMMEOLG@?$HMn?3readline?$AA@ DB '|n:readline', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_readline
_TEXT	SEGMENT
limit$ = 48
self$ = 48
args$ = 56
textiowrapper_readline PROC				; COMDAT

; 1921 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1922 :     Py_ssize_t limit = -1;
; 1923 : 
; 1924 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR limit$[rsp], -1
  00019	7f 28		 jg	 SHORT $LN4@textiowrap@30
  0001b	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0002d	75 07		 jne	 SHORT $LN7@textiowrap@30
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN7@textiowrap@30:
  00036	e8 00 00 00 00	 call	 PyErr_SetString
$LN8@textiowrap@30:
  0003b	33 c0		 xor	 eax, eax

; 1929 : }

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
$LN4@textiowrap@30:

; 1925 :     if (!PyArg_ParseTuple(args, "|n:readline", &limit)) {

  00043	4c 8d 44 24 30	 lea	 r8, QWORD PTR limit$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GAMMEOLG@?$HMn?3readline?$AA@
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00057	85 c0		 test	 eax, eax

; 1926 :         return NULL;

  00059	74 e0		 je	 SHORT $LN8@textiowrap@30

; 1927 :     }
; 1928 :     return _textiowrapper_readline(self, limit);

  0005b	48 8b 54 24 30	 mov	 rdx, QWORD PTR limit$[rsp]
  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 _textiowrapper_readline

; 1929 : }

  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5b		 pop	 rbx
  0006d	c3		 ret	 0
textiowrapper_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_02LJEFBEPN@iy?$AA@			; `string'
PUBLIC	??_C@_0CE@DAADPKGI@can?8t?5restore?5logical?5file?5posit@ ; `string'
PUBLIC	??_C@_02CJECLEMJ@iN?$AA@			; `string'
PUBLIC	??_C@_0EE@FFEGOFII@underlying?5read?$CI?$CJ?5should?5have?5re@ ; `string'
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_0BK@PMNGJLNE@negative?5seek?5position?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0CJ@JJIBNOP@invalid?5whence?5?$CI?$CFd?0?5should?5be?50?0@ ; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
PUBLIC	??_C@_0BD@CMGLLNKH@textiowrapper_seek?$AA@	; `string'
PUBLIC	??_C@_0CE@KBMHBKOP@can?8t?5do?5nonzero?5end?9relative?5se@ ; `string'
PUBLIC	??_C@_0CE@FPAKBAPP@can?8t?5do?5nonzero?5cur?9relative?5se@ ; `string'
PUBLIC	??_C@_0CC@ECIDNDGL@underlying?5stream?5is?5not?5seekabl@ ; `string'
PUBLIC	??_C@_08CCHCKICM@O?$HMi?3seek?$AA@		; `string'
EXTRN	PyUnicode_GetLength:PROC
EXTRN	_PyIO_str_seek:QWORD
EXTRN	PyLong_FromLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_seek DD imagerel textiowrapper_seek
	DD	imagerel textiowrapper_seek+104
	DD	imagerel $unwind$textiowrapper_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_seek DD imagerel textiowrapper_seek+104
	DD	imagerel textiowrapper_seek+237
	DD	imagerel $chain$1$textiowrapper_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$textiowrapper_seek DD imagerel textiowrapper_seek+237
	DD	imagerel textiowrapper_seek+289
	DD	imagerel $chain$2$textiowrapper_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$textiowrapper_seek DD imagerel textiowrapper_seek+289
	DD	imagerel textiowrapper_seek+309
	DD	imagerel $chain$3$textiowrapper_seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_seek DD imagerel textiowrapper_seek+309
	DD	imagerel textiowrapper_seek+1392
	DD	imagerel $chain$5$textiowrapper_seek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_seek DD 060021H
	DD	0ac400H
	DD	0117400H
	DD	0f6400H
	DD	imagerel textiowrapper_seek
	DD	imagerel textiowrapper_seek+104
	DD	imagerel $unwind$textiowrapper_seek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$textiowrapper_seek DD 021H
	DD	imagerel textiowrapper_seek+104
	DD	imagerel textiowrapper_seek+237
	DD	imagerel $chain$1$textiowrapper_seek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$textiowrapper_seek DD 020521H
	DD	0ac405H
	DD	imagerel textiowrapper_seek+104
	DD	imagerel textiowrapper_seek+237
	DD	imagerel $chain$1$textiowrapper_seek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_seek DD 040d21H
	DD	011740dH
	DD	0f6405H
	DD	imagerel textiowrapper_seek
	DD	imagerel textiowrapper_seek+104
	DD	imagerel $unwind$textiowrapper_seek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_seek DD 030a01H
	DD	03003a20aH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_02LJEFBEPN@iy?$AA@
CONST	SEGMENT
??_C@_02LJEFBEPN@iy?$AA@ DB 'iy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DAADPKGI@can?8t?5restore?5logical?5file?5posit@
CONST	SEGMENT
??_C@_0CE@DAADPKGI@can?8t?5restore?5logical?5file?5posit@ DB 'can''t rest'
	DB	'ore logical file position', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJECLEMJ@iN?$AA@
CONST	SEGMENT
??_C@_02CJECLEMJ@iN?$AA@ DB 'iN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@FFEGOFII@underlying?5read?$CI?$CJ?5should?5have?5re@
CONST	SEGMENT
??_C@_0EE@FFEGOFII@underlying?5read?$CI?$CJ?5should?5have?5re@ DB 'underl'
	DB	'ying read() should have returned a bytes object, not ''%.200s'
	DB	'''', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PMNGJLNE@negative?5seek?5position?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BK@PMNGJLNE@negative?5seek?5position?5?$CFR?$AA@ DB 'negative seek'
	DB	' position %R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JJIBNOP@invalid?5whence?5?$CI?$CFd?0?5should?5be?50?0@
CONST	SEGMENT
??_C@_0CJ@JJIBNOP@invalid?5whence?5?$CI?$CFd?0?5should?5be?50?0@ DB 'inva'
	DB	'lid whence (%d, should be 0, 1 or 2)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CMGLLNKH@textiowrapper_seek?$AA@
CONST	SEGMENT
??_C@_0BD@CMGLLNKH@textiowrapper_seek?$AA@ DB 'textiowrapper_seek', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KBMHBKOP@can?8t?5do?5nonzero?5end?9relative?5se@
CONST	SEGMENT
??_C@_0CE@KBMHBKOP@can?8t?5do?5nonzero?5end?9relative?5se@ DB 'can''t do '
	DB	'nonzero end-relative seeks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FPAKBAPP@can?8t?5do?5nonzero?5cur?9relative?5se@
CONST	SEGMENT
??_C@_0CE@FPAKBAPP@can?8t?5do?5nonzero?5cur?9relative?5se@ DB 'can''t do '
	DB	'nonzero cur-relative seeks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@ECIDNDGL@underlying?5stream?5is?5not?5seekabl@
CONST	SEGMENT
??_C@_0CC@ECIDNDGL@underlying?5stream?5is?5not?5seekabl@ DB 'underlying s'
	DB	'tream is not seekable', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCHCKICM@O?$HMi?3seek?$AA@
CONST	SEGMENT
??_C@_08CCHCKICM@O?$HMi?3seek?$AA@ DB 'O|i:seek', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_seek
_TEXT	SEGMENT
cookie$ = 48
whence$ = 112
self$ = 112
args$ = 120
cookieObj$ = 128
textiowrapper_seek PROC					; COMDAT

; 2061 : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	48 8b ec	 mov	 rbp, rsp
  00006	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2062 :     PyObject *cookieObj, *posobj;
; 2063 :     cookie_type cookie;
; 2064 :     int whence = 0;
; 2065 :     PyObject *res;
; 2066 :     int cmp;
; 2067 : 
; 2068 :     CHECK_INITIALIZED(self);

  0000a	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000e	48 8b c2	 mov	 rax, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	c7 45 18 00 00
	00 00		 mov	 DWORD PTR whence$[rbp-88], 0
  0001b	7f 29		 jg	 SHORT $LN63@textiowrap@31
  0001d	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  0002f	75 07		 jne	 SHORT $LN70@textiowrap@31
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN70@textiowrap@31:
  00038	e8 00 00 00 00	 call	 PyErr_SetString
$LN74@textiowrap@31:
  0003d	33 c0		 xor	 eax, eax

; 2230 : 
; 2231 : }

  0003f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00043	5b		 pop	 rbx
  00044	5d		 pop	 rbp
  00045	c3		 ret	 0
$LN63@textiowrap@31:

; 2069 : 
; 2070 :     if (!PyArg_ParseTuple(args, "O|i:seek", &cookieObj, &whence))

  00046	4c 8d 4d 18	 lea	 r9, QWORD PTR whence$[rbp-88]
  0004a	4c 8d 45 28	 lea	 r8, QWORD PTR cookieObj$[rbp-88]
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CCHCKICM@O?$HMi?3seek?$AA@
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0005d	85 c0		 test	 eax, eax

; 2071 :         return NULL;

  0005f	74 dc		 je	 SHORT $LN74@textiowrap@31

; 2072 :     CHECK_CLOSED(self);

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  00068	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  0006d	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00075	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00079	75 5a		 jne	 SHORT $LN56@textiowrap@31
  0007b	48 8b 8b f8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+248]
  00082	48 85 c9	 test	 rcx, rcx
  00085	74 22		 je	 SHORT $LN55@textiowrap@31
  00087	e8 00 00 00 00	 call	 _PyFileIO_closed
  0008c	8b f8		 mov	 edi, eax
  0008e	85 c0		 test	 eax, eax
$LN71@textiowrap@31:
  00090	7e 57		 jle	 SHORT $LN58@textiowrap@31
  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  000a0	e8 00 00 00 00	 call	 PyErr_SetString
$LN73@textiowrap@31:
  000a5	33 c0		 xor	 eax, eax
  000a7	eb 78		 jmp	 SHORT $LN68@textiowrap@31
$LN55@textiowrap@31:
  000a9	33 d2		 xor	 edx, edx
  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	e8 00 00 00 00	 call	 textiowrapper_closed_get
  000b3	48 8b f0	 mov	 rsi, rax
  000b6	48 85 c0	 test	 rax, rax
  000b9	74 ea		 je	 SHORT $LN73@textiowrap@31
  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 PyObject_IsTrue
  000c3	48 8b ce	 mov	 rcx, rsi
  000c6	8b f8		 mov	 edi, eax
  000c8	e8 00 00 00 00	 call	 _Py_DecRef
  000cd	85 ff		 test	 edi, edi
  000cf	79 bf		 jns	 SHORT $LN71@textiowrap@31
  000d1	33 c0		 xor	 eax, eax
  000d3	eb 4c		 jmp	 SHORT $LN68@textiowrap@31
$LN56@textiowrap@31:
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  000e4	48 85 c0	 test	 rax, rax
  000e7	74 bc		 je	 SHORT $LN73@textiowrap@31
$LN58@textiowrap@31:

; 2073 : 
; 2074 :     Py_INCREF(cookieObj);

  000e9	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  000ed	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000f2	e8 00 00 00 00	 call	 _Py_IncRef

; 2075 : 
; 2076 :     if (!self->seekable) {

  000f7	80 bb ad 00 00
	00 00		 cmp	 BYTE PTR [rbx+173], 0
  000fe	75 35		 jne	 SHORT $LN48@textiowrap@31

; 2077 :         _unsupported("underlying stream is not seekable");

  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@ECIDNDGL@underlying?5stream?5is?5not?5seekabl@
$LN72@textiowrap@31:

; 2088 :             _unsupported("can't do nonzero cur-relative seeks");

  00107	e8 00 00 00 00	 call	 _unsupported
$fail$22633:

; 2227 :   fail:
; 2228 :     Py_XDECREF(cookieObj);

  0010c	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  00110	48 85 c9	 test	 rcx, rcx
  00113	74 05		 je	 SHORT $LN3@textiowrap@31
  00115	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@31:

; 2229 :     return NULL;

  0011a	33 c0		 xor	 eax, eax
$LN69@textiowrap@31:
  0011c	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
$LN68@textiowrap@31:
  00121	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00126	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]

; 2230 : 
; 2231 : }

  0012e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00132	5b		 pop	 rbx
  00133	5d		 pop	 rbp
  00134	c3		 ret	 0
$LN48@textiowrap@31:

; 2078 :         goto fail;
; 2079 :     }
; 2080 : 
; 2081 :     if (whence == 1) {

  00135	44 8b 45 18	 mov	 r8d, DWORD PTR whence$[rbp-88]
  00139	44 8b 25 00 00
	00 00		 mov	 r12d, DWORD PTR _tls_index
  00140	41 83 f8 01	 cmp	 r8d, 1
  00144	75 59		 jne	 SHORT $LN47@textiowrap@31

; 2082 :         /* seek relative to current position */
; 2083 :         cmp = PyObject_RichCompareBool(cookieObj, _PyIO_zero, Py_EQ);

  00146	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_zero
  0014d	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  00151	41 b8 02 00 00
	00		 mov	 r8d, 2
  00157	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2084 :         if (cmp < 0)

  0015c	85 c0		 test	 eax, eax
  0015e	78 ac		 js	 SHORT $fail$22633

; 2085 :             goto fail;
; 2086 : 
; 2087 :         if (cmp == 0) {

  00160	75 09		 jne	 SHORT $LN45@textiowrap@31

; 2088 :             _unsupported("can't do nonzero cur-relative seeks");

  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@FPAKBAPP@can?8t?5do?5nonzero?5cur?9relative?5se@

; 2089 :             goto fail;

  00169	eb 9c		 jmp	 SHORT $LN72@textiowrap@31
$LN45@textiowrap@31:

; 2090 :         }
; 2091 : 
; 2092 :         /* Seeking to the current position should attempt to
; 2093 :          * sync the underlying buffer with the current position.
; 2094 :          */
; 2095 :         Py_DECREF(cookieObj);

  0016b	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  0016f	e8 00 00 00 00	 call	 _Py_DecRef

; 2096 :         cookieObj = _PyObject_CallMethodId((PyObject *)self, &PyId_tell, NULL);

  00174	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0017d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_tell
  00182	4a 03 14 e0	 add	 rdx, QWORD PTR [rax+r12*8]
  00186	45 33 c0	 xor	 r8d, r8d
  00189	48 8b cb	 mov	 rcx, rbx
  0018c	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00191	48 89 45 28	 mov	 QWORD PTR cookieObj$[rbp-88], rax

; 2097 :         if (cookieObj == NULL)

  00195	48 85 c0	 test	 rax, rax
  00198	74 80		 je	 SHORT $LN3@textiowrap@31

; 2098 :             goto fail;
; 2099 :     }
; 2100 :     else if (whence == 2) {

  0019a	e9 43 01 00 00	 jmp	 $LN27@textiowrap@31
$LN47@textiowrap@31:
  0019f	41 83 f8 02	 cmp	 r8d, 2
  001a3	0f 85 18 01 00
	00		 jne	 $LN42@textiowrap@31

; 2101 :         /* seek relative to end of file */
; 2102 :         cmp = PyObject_RichCompareBool(cookieObj, _PyIO_zero, Py_EQ);

  001a9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_zero
  001b0	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  001b4	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2103 :         if (cmp < 0)

  001b9	85 c0		 test	 eax, eax
  001bb	0f 88 4b ff ff
	ff		 js	 $fail$22633

; 2104 :             goto fail;
; 2105 : 
; 2106 :         if (cmp == 0) {

  001c1	75 0c		 jne	 SHORT $LN40@textiowrap@31

; 2107 :             _unsupported("can't do nonzero end-relative seeks");

  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@KBMHBKOP@can?8t?5do?5nonzero?5end?9relative?5se@

; 2108 :             goto fail;

  001ca	e9 38 ff ff ff	 jmp	 $LN72@textiowrap@31
$LN40@textiowrap@31:

; 2109 :         }
; 2110 : 
; 2111 :         res = _PyObject_CallMethodId((PyObject *)self, &PyId_flush, NULL);

  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001d5	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  001de	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_flush
  001e3	48 8b 3c c8	 mov	 rdi, QWORD PTR [rax+rcx*8]
  001e7	45 33 c0	 xor	 r8d, r8d
  001ea	48 8b cb	 mov	 rcx, rbx
  001ed	48 03 d7	 add	 rdx, rdi
  001f0	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2112 :         if (res == NULL)

  001f5	48 85 c0	 test	 rax, rax
  001f8	0f 84 0e ff ff
	ff		 je	 $fail$22633

; 2113 :             goto fail;
; 2114 :         Py_DECREF(res);

  001fe	48 8b c8	 mov	 rcx, rax
  00201	e8 00 00 00 00	 call	 _Py_DecRef

; 2115 : 
; 2116 :         textiowrapper_set_decoded_chars(self, NULL);

  00206	33 d2		 xor	 edx, edx
  00208	48 8b cb	 mov	 rcx, rbx
  0020b	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars

; 2117 :         Py_CLEAR(self->snapshot);

  00210	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  00217	4d 85 c9	 test	 r9, r9
  0021a	74 3c		 je	 SHORT $LN37@textiowrap@31
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CMGLLNKH@textiowrapper_seek?$AA@
  0022a	41 b8 45 08 00
	00		 mov	 r8d, 2117		; 00000845H
  00230	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00238	e8 00 00 00 00	 call	 _PyParallel_Guard
  0023d	85 c0		 test	 eax, eax
  0023f	75 17		 jne	 SHORT $LN37@textiowrap@31
  00241	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  00248	48 c7 83 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+232], 0
  00253	e8 00 00 00 00	 call	 _Py_DecRef
$LN37@textiowrap@31:

; 2118 :         if (self->decoder) {

  00258	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  0025f	48 85 c9	 test	 rcx, rcx
  00262	74 21		 je	 SHORT $LN34@textiowrap@31

; 2119 :             res = _PyObject_CallMethodId(self->decoder, &PyId_reset, NULL);

  00264	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_reset
  00269	45 33 c0	 xor	 r8d, r8d
  0026c	48 03 d7	 add	 rdx, rdi
  0026f	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2120 :             if (res == NULL)

  00274	48 85 c0	 test	 rax, rax
  00277	0f 84 8f fe ff
	ff		 je	 $fail$22633

; 2121 :                 goto fail;
; 2122 :             Py_DECREF(res);

  0027d	48 8b c8	 mov	 rcx, rax
  00280	e8 00 00 00 00	 call	 _Py_DecRef
$LN34@textiowrap@31:

; 2123 :         }
; 2124 : 
; 2125 :         res = _PyObject_CallMethodId(self->buffer, &PyId_seek, "ii", 0, 2);

  00285	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00289	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_seek
  0028e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  00295	48 03 d7	 add	 rdx, rdi
  00298	45 33 c9	 xor	 r9d, r9d
  0029b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002a3	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2126 :         Py_XDECREF(cookieObj);

  002a8	48 8b 4d 28	 mov	 rcx, QWORD PTR cookieObj$[rbp-88]
  002ac	48 8b d8	 mov	 rbx, rax
  002af	48 85 c9	 test	 rcx, rcx
  002b2	74 05		 je	 SHORT $LN31@textiowrap@31
  002b4	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@textiowrap@31:

; 2127 :         return res;

  002b9	48 8b c3	 mov	 rax, rbx
  002bc	e9 5b fe ff ff	 jmp	 $LN69@textiowrap@31
$LN42@textiowrap@31:

; 2128 :     }
; 2129 :     else if (whence != 0) {

  002c1	45 85 c0	 test	 r8d, r8d
  002c4	74 18		 je	 SHORT $LN66@textiowrap@31

; 2130 :         PyErr_Format(PyExc_ValueError,
; 2131 :                      "invalid whence (%d, should be 0, 1 or 2)", whence);

  002c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@JJIBNOP@invalid?5whence?5?$CI?$CFd?0?5should?5be?50?0@
  002d4	e8 00 00 00 00	 call	 PyErr_Format

; 2132 :         goto fail;

  002d9	e9 2e fe ff ff	 jmp	 $fail$22633
$LN66@textiowrap@31:
  002de	48 8b 45 28	 mov	 rax, QWORD PTR cookieObj$[rbp-88]
$LN27@textiowrap@31:

; 2133 :     }
; 2134 : 
; 2135 :     cmp = PyObject_RichCompareBool(cookieObj, _PyIO_zero, Py_LT);

  002e2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_zero
  002e9	45 33 c0	 xor	 r8d, r8d
  002ec	48 8b c8	 mov	 rcx, rax
  002ef	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 2136 :     if (cmp < 0)

  002f4	85 c0		 test	 eax, eax
  002f6	0f 88 10 fe ff
	ff		 js	 $fail$22633

; 2137 :         goto fail;
; 2138 : 
; 2139 :     if (cmp == 1) {

  002fc	83 f8 01	 cmp	 eax, 1
  002ff	75 1c		 jne	 SHORT $LN25@textiowrap@31

; 2140 :         PyErr_Format(PyExc_ValueError,
; 2141 :                      "negative seek position %R", cookieObj);

  00301	4c 8b 45 28	 mov	 r8, QWORD PTR cookieObj$[rbp-88]
  00305	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0030c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PMNGJLNE@negative?5seek?5position?5?$CFR?$AA@
  00313	e8 00 00 00 00	 call	 PyErr_Format

; 2142 :         goto fail;

  00318	e9 ef fd ff ff	 jmp	 $fail$22633
$LN25@textiowrap@31:

; 2143 :     }
; 2144 : 
; 2145 :     res = PyObject_CallMethodObjArgs((PyObject *)self, _PyIO_str_flush, NULL);

  0031d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_flush
  00324	45 33 c0	 xor	 r8d, r8d
  00327	48 8b cb	 mov	 rcx, rbx
  0032a	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2146 :     if (res == NULL)

  0032f	48 85 c0	 test	 rax, rax
  00332	0f 84 d4 fd ff
	ff		 je	 $fail$22633

; 2147 :         goto fail;
; 2148 :     Py_DECREF(res);

  00338	48 8b c8	 mov	 rcx, rax
  0033b	e8 00 00 00 00	 call	 _Py_DecRef

; 2149 : 
; 2150 :     /* The strategy of seek() is to go back to the safe start point
; 2151 :      * and replay the effect of read(chars_to_skip) from there.
; 2152 :      */
; 2153 :     if (textiowrapper_parse_cookie(&cookie, cookieObj) < 0)

  00340	48 8b 55 28	 mov	 rdx, QWORD PTR cookieObj$[rbp-88]
  00344	48 8d 4d d8	 lea	 rcx, QWORD PTR cookie$[rbp-88]
  00348	e8 00 00 00 00	 call	 textiowrapper_parse_cookie
  0034d	85 c0		 test	 eax, eax
  0034f	0f 88 b7 fd ff
	ff		 js	 $fail$22633

; 2154 :         goto fail;
; 2155 : 
; 2156 :     /* Seek back to the safe start point. */
; 2157 :     posobj = PyLong_FromOff_t(cookie.start_pos);

  00355	48 8b 4d d8	 mov	 rcx, QWORD PTR cookie$[rbp-88]
  00359	e8 00 00 00 00	 call	 PyLong_FromLongLong
  0035e	48 8b f8	 mov	 rdi, rax

; 2158 :     if (posobj == NULL)

  00361	48 85 c0	 test	 rax, rax
  00364	0f 84 a2 fd ff
	ff		 je	 $fail$22633

; 2159 :         goto fail;
; 2160 :     res = PyObject_CallMethodObjArgs(self->buffer,
; 2161 :                                      _PyIO_str_seek, posobj, NULL);

  0036a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_seek
  00371	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00375	45 33 c9	 xor	 r9d, r9d
  00378	4c 8b c0	 mov	 r8, rax
  0037b	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs

; 2162 :     Py_DECREF(posobj);

  00380	48 8b cf	 mov	 rcx, rdi
  00383	48 8b f0	 mov	 rsi, rax
  00386	e8 00 00 00 00	 call	 _Py_DecRef

; 2163 :     if (res == NULL)

  0038b	48 85 f6	 test	 rsi, rsi
  0038e	0f 84 78 fd ff
	ff		 je	 $fail$22633

; 2164 :         goto fail;
; 2165 :     Py_DECREF(res);

  00394	48 8b ce	 mov	 rcx, rsi
  00397	e8 00 00 00 00	 call	 _Py_DecRef

; 2166 : 
; 2167 :     textiowrapper_set_decoded_chars(self, NULL);

  0039c	33 d2		 xor	 edx, edx
  0039e	48 8b cb	 mov	 rcx, rbx
  003a1	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars

; 2168 :     Py_CLEAR(self->snapshot);

  003a6	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  003ad	4d 85 c9	 test	 r9, r9
  003b0	74 3c		 je	 SHORT $LN19@textiowrap@31
  003b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@CMGLLNKH@textiowrapper_seek?$AA@
  003c0	41 b8 78 08 00
	00		 mov	 r8d, 2168		; 00000878H
  003c6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003ce	e8 00 00 00 00	 call	 _PyParallel_Guard
  003d3	85 c0		 test	 eax, eax
  003d5	75 17		 jne	 SHORT $LN19@textiowrap@31
  003d7	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  003de	48 c7 83 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+232], 0
  003e9	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@textiowrap@31:

; 2169 : 
; 2170 :     /* Restore the decoder to its state from the safe start point. */
; 2171 :     if (self->decoder) {

  003ee	48 83 bb 88 00
	00 00 00	 cmp	 QWORD PTR [rbx+136], 0
  003f6	74 14		 je	 SHORT $LN15@textiowrap@31

; 2172 :         if (_textiowrapper_decoder_setstate(self, &cookie) < 0)

  003f8	48 8d 55 d8	 lea	 rdx, QWORD PTR cookie$[rbp-88]
  003fc	48 8b cb	 mov	 rcx, rbx
  003ff	e8 00 00 00 00	 call	 _textiowrapper_decoder_setstate
  00404	85 c0		 test	 eax, eax
  00406	0f 88 00 fd ff
	ff		 js	 $fail$22633
$LN15@textiowrap@31:

; 2173 :             goto fail;
; 2174 :     }
; 2175 : 
; 2176 :     if (cookie.chars_to_skip) {

  0040c	48 63 75 e8	 movsxd	 rsi, DWORD PTR cookie$[rbp-72]
  00410	85 f6		 test	 esi, esi
  00412	0f 84 0b 01 00
	00		 je	 $LN14@textiowrap@31

; 2177 :         /* Just like _read_chunk, feed the decoder and save a snapshot. */
; 2178 :         PyObject *input_chunk = _PyObject_CallMethodId(
; 2179 :             self->buffer, &PyId_read, "i", cookie.bytes_to_feed);

  00418	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00421	44 8b 4d e4	 mov	 r9d, DWORD PTR cookie$[rbp-76]
  00425	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00429	4e 8b 24 e0	 mov	 r12, QWORD PTR [rax+r12*8]
  0042d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_read
  00432	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  00439	49 03 d4	 add	 rdx, r12
  0043c	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00441	48 8b f8	 mov	 rdi, rax

; 2180 :         PyObject *decoded;
; 2181 : 
; 2182 :         if (input_chunk == NULL)

  00444	48 85 c0	 test	 rax, rax
  00447	0f 84 bf fc ff
	ff		 je	 $fail$22633

; 2183 :             goto fail;
; 2184 : 
; 2185 :         if (!PyBytes_Check(input_chunk)) {

  0044d	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00451	41 f7 80 00 01
	00 00 00 00 00
	08		 test	 DWORD PTR [r8+256], 134217728 ; 08000000H
  0045c	75 24		 jne	 SHORT $LN12@textiowrap@31

; 2186 :             PyErr_Format(PyExc_TypeError,
; 2187 :                          "underlying read() should have returned a bytes "
; 2188 :                          "object, not '%.200s'",
; 2189 :                          Py_TYPE(input_chunk)->tp_name);

  0045e	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00462	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00469	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EE@FFEGOFII@underlying?5read?$CI?$CJ?5should?5have?5re@
  00470	e8 00 00 00 00	 call	 PyErr_Format

; 2190 :             Py_DECREF(input_chunk);

  00475	48 8b cf	 mov	 rcx, rdi
  00478	e8 00 00 00 00	 call	 _Py_DecRef

; 2191 :             goto fail;

  0047d	e9 8a fc ff ff	 jmp	 $fail$22633
$LN12@textiowrap@31:

; 2192 :         }
; 2193 : 
; 2194 :         self->snapshot = Py_BuildValue("iN", cookie.dec_flags, input_chunk);

  00482	8b 55 e0	 mov	 edx, DWORD PTR cookie$[rbp-80]
  00485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02CJECLEMJ@iN?$AA@
  0048c	4c 8b c0	 mov	 r8, rax
  0048f	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00494	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax

; 2195 :         if (self->snapshot == NULL) {

  0049b	48 85 c0	 test	 rax, rax
  0049e	75 0d		 jne	 SHORT $LN11@textiowrap@31

; 2196 :             Py_DECREF(input_chunk);

  004a0	48 8b cf	 mov	 rcx, rdi
  004a3	e8 00 00 00 00	 call	 _Py_DecRef

; 2197 :             goto fail;

  004a8	e9 5f fc ff ff	 jmp	 $fail$22633
$LN11@textiowrap@31:

; 2198 :         }
; 2199 : 
; 2200 :         decoded = _PyObject_CallMethodId(self->decoder, &PyId_decode,
; 2201 :             "Oi", input_chunk, (int)cookie.need_eof);

  004ad	0f be 45 ec	 movsx	 eax, BYTE PTR cookie$[rbp-68]
  004b1	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  004b8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_decode
  004bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  004c4	49 03 d4	 add	 rdx, r12
  004c7	4c 8b cf	 mov	 r9, rdi
  004ca	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004ce	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2202 : 
; 2203 :         if (check_decoded(decoded) < 0)

  004d3	48 8b c8	 mov	 rcx, rax
  004d6	48 8b f8	 mov	 rdi, rax
  004d9	e8 00 00 00 00	 call	 check_decoded
  004de	85 c0		 test	 eax, eax
  004e0	0f 88 26 fc ff
	ff		 js	 $fail$22633

; 2204 :             goto fail;
; 2205 : 
; 2206 :         textiowrapper_set_decoded_chars(self, decoded);

  004e6	48 8b d7	 mov	 rdx, rdi
  004e9	48 8b cb	 mov	 rcx, rbx
  004ec	e8 00 00 00 00	 call	 textiowrapper_set_decoded_chars

; 2207 : 
; 2208 :         /* Skip chars_to_skip of the decoded characters. */
; 2209 :         if (PyUnicode_GetLength(self->decoded_chars) < cookie.chars_to_skip) {

  004f1	48 8b 8b c8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+200]
  004f8	e8 00 00 00 00	 call	 PyUnicode_GetLength
  004fd	48 3b c6	 cmp	 rax, rsi
  00500	7d 18		 jge	 SHORT $LN9@textiowrap@31

; 2210 :             PyErr_SetString(PyExc_IOError, "can't restore logical file position");

  00502	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00509	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DAADPKGI@can?8t?5restore?5logical?5file?5posit@
  00510	e8 00 00 00 00	 call	 PyErr_SetString

; 2211 :             goto fail;

  00515	e9 f2 fb ff ff	 jmp	 $fail$22633
$LN9@textiowrap@31:

; 2212 :         }
; 2213 :         self->decoded_chars_used = cookie.chars_to_skip;

  0051a	48 89 b3 d0 00
	00 00		 mov	 QWORD PTR [rbx+208], rsi

; 2214 :     }
; 2215 :     else {

  00521	eb 26		 jmp	 SHORT $LN7@textiowrap@31
$LN14@textiowrap@31:

; 2216 :         self->snapshot = Py_BuildValue("iy", cookie.dec_flags, "");

  00523	8b 55 e0	 mov	 edx, DWORD PTR cookie$[rbp-80]
  00526	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02LJEFBEPN@iy?$AA@
  00534	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00539	48 89 83 e8 00
	00 00		 mov	 QWORD PTR [rbx+232], rax

; 2217 :         if (self->snapshot == NULL)

  00540	48 85 c0	 test	 rax, rax
  00543	0f 84 c3 fb ff
	ff		 je	 $fail$22633
$LN7@textiowrap@31:

; 2218 :             goto fail;
; 2219 :     }
; 2220 : 
; 2221 :     /* Finally, reset the encoder (merely useful for proper BOM handling) */
; 2222 :     if (self->encoder) {

  00549	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00551	74 14		 je	 SHORT $LN5@textiowrap@31

; 2223 :         if (_textiowrapper_encoder_setstate(self, &cookie) < 0)

  00553	48 8d 55 d8	 lea	 rdx, QWORD PTR cookie$[rbp-88]
  00557	48 8b cb	 mov	 rcx, rbx
  0055a	e8 00 00 00 00	 call	 _textiowrapper_encoder_setstate
  0055f	85 c0		 test	 eax, eax
  00561	0f 88 a5 fb ff
	ff		 js	 $fail$22633
$LN5@textiowrap@31:

; 2224 :             goto fail;
; 2225 :     }
; 2226 :     return cookieObj;

  00567	48 8b 45 28	 mov	 rax, QWORD PTR cookieObj$[rbp-88]
  0056b	e9 ac fb ff ff	 jmp	 $LN69@textiowrap@31
textiowrapper_seek ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
PUBLIC	??_C@_0CI@JGPCMGMC@can?8t?5reconstruct?5logical?5file?5p@ ; `string'
PUBLIC	??_C@_02OPKBKFNM@yi?$AA@			; `string'
PUBLIC	??_C@_05OAMHDECN@?$CIy?$CDi?$CJ?$AA@		; `string'
PUBLIC	??_C@_02OFDHACFD@y?$CD?$AA@			; `string'
PUBLIC	??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@		; `string'
PUBLIC	??_C@_0CJ@IGLFECHA@telling?5position?5disabled?5by?5nex@ ; `string'
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_Fetch:PROC
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_tell DD imagerel textiowrapper_tell
	DD	imagerel textiowrapper_tell+89
	DD	imagerel $unwind$textiowrapper_tell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_tell DD imagerel textiowrapper_tell+89
	DD	imagerel textiowrapper_tell+231
	DD	imagerel $chain$1$textiowrapper_tell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_tell DD imagerel textiowrapper_tell+231
	DD	imagerel textiowrapper_tell+1394
	DD	imagerel $chain$5$textiowrapper_tell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$textiowrapper_tell DD imagerel textiowrapper_tell+1394
	DD	imagerel textiowrapper_tell+1420
	DD	imagerel $chain$6$textiowrapper_tell
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$textiowrapper_tell DD imagerel textiowrapper_tell+1420
	DD	imagerel textiowrapper_tell+1507
	DD	imagerel $chain$8$textiowrapper_tell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$textiowrapper_tell DD 0c0021H
	DD	010f400H
	DD	011e400H
	DD	012d400H
	DD	013c400H
	DD	0146400H
	DD	0193400H
	DD	imagerel textiowrapper_tell
	DD	imagerel textiowrapper_tell+89
	DD	imagerel $unwind$textiowrapper_tell
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$textiowrapper_tell DD 021H
	DD	imagerel textiowrapper_tell+89
	DD	imagerel textiowrapper_tell+231
	DD	imagerel $chain$1$textiowrapper_tell
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_tell DD 082021H
	DD	010f420H
	DD	011e418H
	DD	012d410H
	DD	013c408H
	DD	imagerel textiowrapper_tell+89
	DD	imagerel textiowrapper_tell+231
	DD	imagerel $chain$1$textiowrapper_tell
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_tell DD 041021H
	DD	0146410H
	DD	0193408H
	DD	imagerel textiowrapper_tell
	DD	imagerel textiowrapper_tell+89
	DD	imagerel $unwind$textiowrapper_tell
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_tell DD 040f01H
	DD	015010fH
	DD	050027003H
xdata	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@JGPCMGMC@can?8t?5reconstruct?5logical?5file?5p@
CONST	SEGMENT
??_C@_0CI@JGPCMGMC@can?8t?5reconstruct?5logical?5file?5p@ DB 'can''t reco'
	DB	'nstruct logical file position', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02OPKBKFNM@yi?$AA@
CONST	SEGMENT
??_C@_02OPKBKFNM@yi?$AA@ DB 'yi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAMHDECN@?$CIy?$CDi?$CJ?$AA@
CONST	SEGMENT
??_C@_05OAMHDECN@?$CIy?$CDi?$CJ?$AA@ DB '(y#i)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02OFDHACFD@y?$CD?$AA@
CONST	SEGMENT
??_C@_02OFDHACFD@y?$CD?$AA@ DB 'y#', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@ DB '(iO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IGLFECHA@telling?5position?5disabled?5by?5nex@
CONST	SEGMENT
??_C@_0CJ@IGLFECHA@telling?5position?5disabled?5by?5nex@ DB 'telling posi'
	DB	'tion disabled by next() call', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_tell
_TEXT	SEGMENT
dec_buffer_len$ = 48
saved_state$1$ = 56
dec_buffer$ = 64
tv539 = 72
traceback$22904 = 72
value$22903 = 80
type$22902 = 88
cookie$ = 96
dec_flags$ = 192
self$ = 192
args$ = 200
tv543 = 208
next_input$ = 216
textiowrapper_tell PROC					; COMDAT

; 2235 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	48 8d 6c 24 b1	 lea	 rbp, QWORD PTR [rsp-79]
  00008	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2236 :     PyObject *res;
; 2237 :     PyObject *posobj = NULL;
; 2238 :     cookie_type cookie = {0,0,0,0,0};

  0000f	33 c0		 xor	 eax, eax
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 45 07	 mov	 QWORD PTR cookie$[rbp-89], rax
  00018	48 89 45 0f	 mov	 QWORD PTR cookie$[rbp-81], rax
  0001c	89 45 17	 mov	 DWORD PTR cookie$[rbp-73], eax
  0001f	88 45 1b	 mov	 BYTE PTR cookie$[rbp-69], al

; 2239 :     PyObject *next_input;
; 2240 :     Py_ssize_t chars_to_skip, chars_decoded;
; 2241 :     Py_ssize_t skip_bytes, skip_back;
; 2242 :     PyObject *saved_state = NULL;
; 2243 :     char *input, *input_end;
; 2244 :     char *dec_buffer;
; 2245 :     Py_ssize_t dec_buffer_len;
; 2246 :     int dec_flags;
; 2247 : 
; 2248 :     CHECK_INITIALIZED(self);

  00022	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00025	7f 2b		 jg	 SHORT $LN59@textiowrap@32
  00027	39 41 64	 cmp	 DWORD PTR [rcx+100], eax
  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00038	75 07		 jne	 SHORT $LN85@textiowrap@32
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN85@textiowrap@32:
  00041	e8 00 00 00 00	 call	 PyErr_SetString
  00046	33 c0		 xor	 eax, eax

; 2443 : }

  00048	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0004f	5f		 pop	 rdi
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
$LN59@textiowrap@32:

; 2249 :     CHECK_CLOSED(self);

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  00059	48 89 9c 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rbx
  00061	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi
  00069	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006d	75 60		 jne	 SHORT $LN56@textiowrap@32
  0006f	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  00076	48 85 c9	 test	 rcx, rcx
  00079	74 25		 je	 SHORT $LN55@textiowrap@32
  0007b	e8 00 00 00 00	 call	 _PyFileIO_closed
  00080	8b d8		 mov	 ebx, eax
  00082	85 c0		 test	 eax, eax
$LN86@textiowrap@32:
  00084	7e 5a		 jle	 SHORT $LN58@textiowrap@32
  00086	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00094	e8 00 00 00 00	 call	 PyErr_SetString
$LN90@textiowrap@32:
  00099	33 c0		 xor	 eax, eax
  0009b	e9 d2 04 00 00	 jmp	 $LN80@textiowrap@32
$LN55@textiowrap@32:
  000a0	33 d2		 xor	 edx, edx
  000a2	48 8b cf	 mov	 rcx, rdi
  000a5	e8 00 00 00 00	 call	 textiowrapper_closed_get
  000aa	48 8b f0	 mov	 rsi, rax
  000ad	48 85 c0	 test	 rax, rax
  000b0	74 e7		 je	 SHORT $LN90@textiowrap@32
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 PyObject_IsTrue
  000ba	48 8b ce	 mov	 rcx, rsi
  000bd	8b d8		 mov	 ebx, eax
  000bf	e8 00 00 00 00	 call	 _Py_DecRef
  000c4	85 db		 test	 ebx, ebx
  000c6	79 bc		 jns	 SHORT $LN86@textiowrap@32
  000c8	33 c0		 xor	 eax, eax
  000ca	e9 a3 04 00 00	 jmp	 $LN80@textiowrap@32
$LN56@textiowrap@32:
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  000d6	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  000db	48 85 c0	 test	 rax, rax
  000de	74 b9		 je	 SHORT $LN90@textiowrap@32
$LN58@textiowrap@32:

; 2250 : 
; 2251 :     if (!self->seekable) {

  000e0	80 bf ad 00 00
	00 00		 cmp	 BYTE PTR [rdi+173], 0
  000e7	4c 89 a4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r12
  000ef	4c 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r13
  000f7	4c 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], r14
  000ff	4c 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r15
  00107	75 11		 jne	 SHORT $LN48@textiowrap@32

; 2252 :         _unsupported("underlying stream is not seekable");

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@ECIDNDGL@underlying?5stream?5is?5not?5seekabl@
  00110	e8 00 00 00 00	 call	 _unsupported

; 2253 :         goto fail;

  00115	e9 36 04 00 00	 jmp	 $LN2@textiowrap@32
$LN48@textiowrap@32:

; 2254 :     }
; 2255 :     if (!self->telling) {

  0011a	80 bf af 00 00
	00 00		 cmp	 BYTE PTR [rdi+175], 0
  00121	75 18		 jne	 SHORT $LN47@textiowrap@32

; 2256 :         PyErr_SetString(PyExc_IOError,
; 2257 :                         "telling position disabled by next() call");

  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IGLFECHA@telling?5position?5disabled?5by?5nex@
  00131	e8 00 00 00 00	 call	 PyErr_SetString

; 2258 :         goto fail;

  00136	e9 15 04 00 00	 jmp	 $LN2@textiowrap@32
$LN47@textiowrap@32:

; 2259 :     }
; 2260 : 
; 2261 :     if (_textiowrapper_writeflush(self) < 0)

  0013b	48 8b cf	 mov	 rcx, rdi
  0013e	e8 00 00 00 00	 call	 _textiowrapper_writeflush
  00143	85 c0		 test	 eax, eax

; 2262 :         return NULL;

  00145	0f 88 05 04 00
	00		 js	 $LN2@textiowrap@32

; 2263 :     res = _PyObject_CallMethodId((PyObject *)self, &PyId_flush, NULL);

  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00151	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0015a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_flush
  0015f	4c 8b 2c c8	 mov	 r13, QWORD PTR [rax+rcx*8]
  00163	45 33 c0	 xor	 r8d, r8d
  00166	48 8b cf	 mov	 rcx, rdi
  00169	49 03 d5	 add	 rdx, r13
  0016c	4c 89 6d 77	 mov	 QWORD PTR tv543[rbp-89], r13
  00170	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2264 :     if (res == NULL)

  00175	48 85 c0	 test	 rax, rax
  00178	0f 84 d2 03 00
	00		 je	 $LN2@textiowrap@32

; 2265 :         goto fail;
; 2266 :     Py_DECREF(res);

  0017e	48 8b c8	 mov	 rcx, rax
  00181	e8 00 00 00 00	 call	 _Py_DecRef

; 2267 : 
; 2268 :     posobj = _PyObject_CallMethodId(self->buffer, &PyId_tell, NULL);

  00186	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  0018a	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_tell
  0018f	49 03 d5	 add	 rdx, r13
  00192	45 33 c0	 xor	 r8d, r8d
  00195	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  0019a	48 8b d8	 mov	 rbx, rax

; 2269 :     if (posobj == NULL)

  0019d	48 85 c0	 test	 rax, rax
  001a0	0f 84 aa 03 00
	00		 je	 $LN2@textiowrap@32

; 2270 :         goto fail;
; 2271 : 
; 2272 :     if (self->decoder == NULL || self->snapshot == NULL) {

  001a6	48 83 bf 88 00
	00 00 00	 cmp	 QWORD PTR [rdi+136], 0
  001ae	0f 84 9e 03 00
	00		 je	 $LN84@textiowrap@32
  001b4	48 83 bf e8 00
	00 00 00	 cmp	 QWORD PTR [rdi+232], 0
  001bc	0f 84 90 03 00
	00		 je	 $LN84@textiowrap@32

; 2273 :         assert (self->decoded_chars == NULL || PyUnicode_GetLength(self->decoded_chars) == 0);
; 2274 :         return posobj;
; 2275 :     }
; 2276 : 
; 2277 : #if defined(HAVE_LARGEFILE_SUPPORT)
; 2278 :     cookie.start_pos = PyLong_AsLongLong(posobj);

  001c2	48 8b c8	 mov	 rcx, rax
  001c5	e8 00 00 00 00	 call	 PyLong_AsLongLong

; 2279 : #else
; 2280 :     cookie.start_pos = PyLong_AsLong(posobj);
; 2281 : #endif
; 2282 :     Py_DECREF(posobj);

  001ca	48 8b cb	 mov	 rcx, rbx
  001cd	48 89 45 07	 mov	 QWORD PTR cookie$[rbp-89], rax
  001d1	e8 00 00 00 00	 call	 _Py_DecRef

; 2283 :     if (PyErr_Occurred())

  001d6	e8 00 00 00 00	 call	 PyErr_Occurred
  001db	48 85 c0	 test	 rax, rax
  001de	0f 85 6c 03 00
	00		 jne	 $LN2@textiowrap@32

; 2284 :         goto fail;
; 2285 : 
; 2286 :     /* Skip backward to the snapshot point (see _read_chunk). */
; 2287 :     if (!PyArg_Parse(self->snapshot, "(iO)", &cookie.dec_flags, &next_input))

  001e4	48 8b 8f e8 00
	00 00		 mov	 rcx, QWORD PTR [rdi+232]
  001eb	4c 8d 4d 7f	 lea	 r9, QWORD PTR next_input$[rbp-89]
  001ef	4c 8d 45 0f	 lea	 r8, QWORD PTR cookie$[rbp-81]
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LBMCIBLI@?$CIiO?$CJ?$AA@
  001fa	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  001ff	85 c0		 test	 eax, eax
  00201	0f 84 49 03 00
	00		 je	 $LN2@textiowrap@32

; 2288 :         goto fail;
; 2289 : 
; 2290 :     assert (PyBytes_Check(next_input));
; 2291 : 
; 2292 :     cookie.start_pos -= PyBytes_GET_SIZE(next_input);

  00207	48 8b 45 7f	 mov	 rax, QWORD PTR next_input$[rbp-89]

; 2293 : 
; 2294 :     /* How many decoded characters have been used up since the snapshot? */
; 2295 :     if (self->decoded_chars_used == 0)  {

  0020b	4c 8b a7 d0 00
	00 00		 mov	 r12, QWORD PTR [rdi+208]
  00212	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00216	48 29 4d 07	 sub	 QWORD PTR cookie$[rbp-89], rcx
  0021a	4d 85 e4	 test	 r12, r12

; 2296 :         /* We haven't moved from the snapshot point. */
; 2297 :         return textiowrapper_build_cookie(&cookie);

  0021d	0f 84 b2 03 00
	00		 je	 $LN89@textiowrap@32

; 2298 :     }
; 2299 : 
; 2300 :     chars_to_skip = self->decoded_chars_used;
; 2301 : 
; 2302 :     /* Decoder state will be restored at the end */
; 2303 :     saved_state = PyObject_CallMethodObjArgs(self->decoder,
; 2304 :                                              _PyIO_str_getstate, NULL);

  00223	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_getstate
  0022a	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  00231	45 33 c0	 xor	 r8d, r8d
  00234	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  00239	48 89 45 df	 mov	 QWORD PTR saved_state$1$[rbp-89], rax

; 2305 :     if (saved_state == NULL)

  0023d	48 85 c0	 test	 rax, rax
  00240	0f 84 0a 03 00
	00		 je	 $LN2@textiowrap@32

; 2306 :         goto fail;
; 2307 : 
; 2308 : #define DECODER_GETSTATE() do { \
; 2309 :         PyObject *_state = PyObject_CallMethodObjArgs(self->decoder, \
; 2310 :             _PyIO_str_getstate, NULL); \
; 2311 :         if (_state == NULL) \
; 2312 :             goto fail; \
; 2313 :         if (!PyArg_Parse(_state, "(y#i)", &dec_buffer, &dec_buffer_len, &dec_flags)) { \
; 2314 :             Py_DECREF(_state); \
; 2315 :             goto fail; \
; 2316 :         } \
; 2317 :         Py_DECREF(_state); \
; 2318 :     } while (0)
; 2319 : 
; 2320 : #define DECODER_DECODE(start, len, res) do { \
; 2321 :         PyObject *_decoded = _PyObject_CallMethodId( \
; 2322 :             self->decoder, &PyId_decode, "y#", start, len); \
; 2323 :         if (check_decoded(_decoded) < 0) \
; 2324 :             goto fail; \
; 2325 :         res = PyUnicode_GET_LENGTH(_decoded); \
; 2326 :         Py_DECREF(_decoded); \
; 2327 :     } while (0)
; 2328 : 
; 2329 :     /* Fast search for an acceptable start point, close to our
; 2330 :        current pos */
; 2331 :     skip_bytes = (Py_ssize_t) (self->b2cratio * chars_to_skip);
; 2332 :     skip_back = 1;
; 2333 :     assert(skip_back <= PyBytes_GET_SIZE(next_input));
; 2334 :     input = PyBytes_AS_STRING(next_input);

  00246	4c 8b 7d 7f	 mov	 r15, QWORD PTR next_input$[rbp-89]
  0024a	66 0f ef c0	 pxor	 xmm0, xmm0
  0024e	be 01 00 00 00	 mov	 esi, 1
  00253	f2 49 0f 2a c4	 cvtsi2sd xmm0, r12

; 2335 :     while (skip_bytes > 0) {

  00258	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:PyId_decode
  0025e	f2 0f 59 87 f0
	00 00 00	 mulsd	 xmm0, QWORD PTR [rdi+240]
  00266	f2 48 0f 2c d8	 cvttsd2si rbx, xmm0
  0026b	48 85 db	 test	 rbx, rbx
  0026e	0f 8e e7 00 00
	00		 jle	 $LN78@textiowrap@32
$LL37@textiowrap@32:

; 2336 :         /* Decode up to temptative start point */
; 2337 :         if (_textiowrapper_decoder_setstate(self, &cookie) < 0)

  00274	48 8d 55 07	 lea	 rdx, QWORD PTR cookie$[rbp-89]
  00278	48 8b cf	 mov	 rcx, rdi
  0027b	e8 00 00 00 00	 call	 _textiowrapper_decoder_setstate
  00280	85 c0		 test	 eax, eax
  00282	0f 88 6b 02 00
	00		 js	 $fail$22787

; 2338 :             goto fail;
; 2339 :         DECODER_DECODE(input, skip_bytes, chars_decoded);

  00288	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  0028f	41 8b d6	 mov	 edx, r14d
  00292	4d 8d 4f 78	 lea	 r9, QWORD PTR [r15+120]
  00296	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02OFDHACFD@y?$CD?$AA@
  0029d	49 03 d5	 add	 rdx, r13
  002a0	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  002a5	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  002aa	48 8b c8	 mov	 rcx, rax
  002ad	4c 8b e8	 mov	 r13, rax
  002b0	e8 00 00 00 00	 call	 check_decoded
  002b5	85 c0		 test	 eax, eax
  002b7	0f 88 36 02 00
	00		 js	 $fail$22787
  002bd	4d 8b 75 60	 mov	 r14, QWORD PTR [r13+96]
  002c1	49 8b cd	 mov	 rcx, r13
  002c4	e8 00 00 00 00	 call	 _Py_DecRef

; 2340 :         if (chars_decoded <= chars_to_skip) {

  002c9	4d 3b f4	 cmp	 r14, r12
  002cc	7f 65		 jg	 SHORT $LN30@textiowrap@32

; 2341 :             DECODER_GETSTATE();

  002ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_getstate
  002d5	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  002dc	45 33 c0	 xor	 r8d, r8d
  002df	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  002e4	48 8b f0	 mov	 rsi, rax
  002e7	48 85 c0	 test	 rax, rax
  002ea	0f 84 03 02 00
	00		 je	 $fail$22787
  002f0	48 8d 45 67	 lea	 rax, QWORD PTR dec_flags$[rbp-89]
  002f4	4c 8d 4d d7	 lea	 r9, QWORD PTR dec_buffer_len$[rbp-89]
  002f8	4c 8d 45 e7	 lea	 r8, QWORD PTR dec_buffer$[rbp-89]
  002fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OAMHDECN@?$CIy?$CDi?$CJ?$AA@
  00303	48 8b ce	 mov	 rcx, rsi
  00306	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030b	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00310	48 8b ce	 mov	 rcx, rsi
  00313	85 c0		 test	 eax, eax
  00315	0f 84 71 02 00
	00		 je	 $LN70@textiowrap@32
  0031b	e8 00 00 00 00	 call	 _Py_DecRef

; 2342 :             if (dec_buffer_len == 0) {

  00320	4c 8b 5d d7	 mov	 r11, QWORD PTR dec_buffer_len$[rbp-89]
  00324	4d 85 db	 test	 r11, r11
  00327	74 24		 je	 SHORT $LN71@textiowrap@32

; 2346 :                 break;
; 2347 :             }
; 2348 :             /* Skip back by buffered amount and reset heuristic */
; 2349 :             skip_bytes -= dec_buffer_len;

  00329	49 2b db	 sub	 rbx, r11

; 2350 :             skip_back = 1;

  0032c	be 01 00 00 00	 mov	 esi, 1

; 2351 :         }
; 2352 :         else {

  00331	eb 06		 jmp	 SHORT $LN23@textiowrap@32
$LN30@textiowrap@32:

; 2353 :             /* We're too far ahead, skip back a bit */
; 2354 :             skip_bytes -= skip_back;

  00333	48 2b de	 sub	 rbx, rsi

; 2355 :             skip_back *= 2;

  00336	48 03 f6	 add	 rsi, rsi
$LN23@textiowrap@32:

; 2335 :     while (skip_bytes > 0) {

  00339	48 85 db	 test	 rbx, rbx
  0033c	7e 1d		 jle	 SHORT $LN78@textiowrap@32
  0033e	4c 8b 6d 77	 mov	 r13, QWORD PTR tv543[rbp-89]
  00342	41 be 00 00 00
	00		 mov	 r14d, OFFSET FLAT:PyId_decode
  00348	e9 27 ff ff ff	 jmp	 $LL37@textiowrap@32
$LN71@textiowrap@32:

; 2343 :                 /* Before pos and no bytes buffered in decoder => OK */
; 2344 :                 cookie.dec_flags = dec_flags;

  0034d	8b 45 67	 mov	 eax, DWORD PTR dec_flags$[rbp-89]

; 2345 :                 chars_to_skip -= chars_decoded;

  00350	4d 2b e6	 sub	 r12, r14
  00353	89 45 0f	 mov	 DWORD PTR cookie$[rbp-81], eax

; 2356 :         }
; 2357 :     }
; 2358 :     if (skip_bytes <= 0) {

  00356	48 85 db	 test	 rbx, rbx
  00359	7f 16		 jg	 SHORT $LN21@textiowrap@32
$LN78@textiowrap@32:

; 2359 :         skip_bytes = 0;
; 2360 :         if (_textiowrapper_decoder_setstate(self, &cookie) < 0)

  0035b	48 8d 55 07	 lea	 rdx, QWORD PTR cookie$[rbp-89]
  0035f	48 8b cf	 mov	 rcx, rdi
  00362	33 db		 xor	 ebx, ebx
  00364	e8 00 00 00 00	 call	 _textiowrapper_decoder_setstate
  00369	85 c0		 test	 eax, eax
  0036b	0f 88 82 01 00
	00		 js	 $fail$22787
$LN21@textiowrap@32:

; 2361 :             goto fail;
; 2362 :     }
; 2363 : 
; 2364 :     /* Note our initial start point. */
; 2365 :     cookie.start_pos += skip_bytes;

  00371	48 01 5d 07	 add	 QWORD PTR cookie$[rbp-89], rbx

; 2366 :     cookie.chars_to_skip = chars_to_skip;

  00375	44 89 65 17	 mov	 DWORD PTR cookie$[rbp-73], r12d

; 2367 :     if (chars_to_skip == 0)

  00379	4d 85 e4	 test	 r12, r12
  0037c	0f 84 14 02 00
	00		 je	 $finally$22853

; 2368 :         goto finally;
; 2369 : 
; 2370 :     /* We should be close to the desired position.  Now feed the decoder one
; 2371 :      * byte at a time until we reach the `chars_to_skip` target.
; 2372 :      * As we go, note the nearest "safe start point" before the current
; 2373 :      * location (a point where the decoder has nothing buffered, so seek()
; 2374 :      * can safely start from there and advance to this location).
; 2375 :      */
; 2376 :     chars_decoded = 0;
; 2377 :     input = PyBytes_AS_STRING(next_input);

  00382	48 8b 45 7f	 mov	 rax, QWORD PTR next_input$[rbp-89]
  00386	33 f6		 xor	 esi, esi
  00388	4c 8d 68 78	 lea	 r13, QWORD PTR [rax+120]

; 2378 :     input_end = input + PyBytes_GET_SIZE(next_input);

  0038c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00390	4d 8d 7c 05 00	 lea	 r15, QWORD PTR [r13+rax]

; 2379 :     input += skip_bytes;

  00395	4c 03 eb	 add	 r13, rbx

; 2380 :     while (input < input_end) {

  00398	4d 3b ef	 cmp	 r13, r15
  0039b	0f 83 e6 00 00
	00		 jae	 $LN87@textiowrap@32
  003a1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:PyId_decode
  003a6	48 03 45 77	 add	 rax, QWORD PTR tv543[rbp-89]
  003aa	48 89 45 ef	 mov	 QWORD PTR tv539[rbp-89], rax
  003ae	66 90		 npad	 2
$LL19@textiowrap@32:

; 2381 :         Py_ssize_t n;
; 2382 : 
; 2383 :         DECODER_DECODE(input, (Py_ssize_t)1, n);

  003b0	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  003b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02OFDHACFD@y?$CD?$AA@
  003be	4d 8b cd	 mov	 r9, r13
  003c1	48 8b d0	 mov	 rdx, rax
  003c4	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR [rsp+32], 1
  003cd	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  003d2	48 8b c8	 mov	 rcx, rax
  003d5	4c 8b f0	 mov	 r14, rax
  003d8	e8 00 00 00 00	 call	 check_decoded
  003dd	85 c0		 test	 eax, eax
  003df	0f 88 0e 01 00
	00		 js	 $fail$22787
  003e5	49 8b 5e 60	 mov	 rbx, QWORD PTR [r14+96]
  003e9	49 8b ce	 mov	 rcx, r14
  003ec	e8 00 00 00 00	 call	 _Py_DecRef

; 2384 :         /* We got n chars for 1 byte */
; 2385 :         chars_decoded += n;
; 2386 :         cookie.bytes_to_feed += 1;
; 2387 :         DECODER_GETSTATE();

  003f1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_getstate
  003f8	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  003ff	ff 45 13	 inc	 DWORD PTR cookie$[rbp-77]
  00402	45 33 c0	 xor	 r8d, r8d
  00405	48 03 f3	 add	 rsi, rbx
  00408	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  0040d	48 8b d8	 mov	 rbx, rax
  00410	48 85 c0	 test	 rax, rax
  00413	0f 84 da 00 00
	00		 je	 $fail$22787
  00419	48 8d 45 67	 lea	 rax, QWORD PTR dec_flags$[rbp-89]
  0041d	4c 8d 4d d7	 lea	 r9, QWORD PTR dec_buffer_len$[rbp-89]
  00421	4c 8d 45 e7	 lea	 r8, QWORD PTR dec_buffer$[rbp-89]
  00425	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OAMHDECN@?$CIy?$CDi?$CJ?$AA@
  0042c	48 8b cb	 mov	 rcx, rbx
  0042f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00434	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00439	48 8b cb	 mov	 rcx, rbx
  0043c	85 c0		 test	 eax, eax
  0043e	0f 84 48 01 00
	00		 je	 $LN70@textiowrap@32
  00444	e8 00 00 00 00	 call	 _Py_DecRef

; 2388 : 
; 2389 :         if (dec_buffer_len == 0 && chars_decoded <= chars_to_skip) {

  00449	48 83 7d d7 00	 cmp	 QWORD PTR dec_buffer_len$[rbp-89], 0
  0044e	75 1f		 jne	 SHORT $LN8@textiowrap@32
  00450	49 3b f4	 cmp	 rsi, r12
  00453	7f 2f		 jg	 SHORT $LN75@textiowrap@32

; 2390 :             /* Decoder buffer is empty, so this is a safe start point. */
; 2391 :             cookie.start_pos += cookie.bytes_to_feed;

  00455	48 63 45 13	 movsxd	 rax, DWORD PTR cookie$[rbp-77]

; 2392 :             chars_to_skip -= chars_decoded;

  00459	4c 2b e6	 sub	 r12, rsi

; 2393 :             cookie.dec_flags = dec_flags;
; 2394 :             cookie.bytes_to_feed = 0;

  0045c	c7 45 13 00 00
	00 00		 mov	 DWORD PTR cookie$[rbp-77], 0
  00463	48 01 45 07	 add	 QWORD PTR cookie$[rbp-89], rax
  00467	8b 45 67	 mov	 eax, DWORD PTR dec_flags$[rbp-89]

; 2395 :             chars_decoded = 0;

  0046a	33 f6		 xor	 esi, esi
  0046c	89 45 0f	 mov	 DWORD PTR cookie$[rbp-81], eax
$LN8@textiowrap@32:

; 2396 :         }
; 2397 :         if (chars_decoded >= chars_to_skip)

  0046f	49 3b f4	 cmp	 rsi, r12
  00472	7d 10		 jge	 SHORT $LN75@textiowrap@32

; 2398 :             break;
; 2399 :         input++;

  00474	48 8b 45 ef	 mov	 rax, QWORD PTR tv539[rbp-89]
  00478	49 ff c5	 inc	 r13
  0047b	4d 3b ef	 cmp	 r13, r15
  0047e	0f 82 2c ff ff
	ff		 jb	 $LL19@textiowrap@32
$LN75@textiowrap@32:

; 2400 :     }
; 2401 :     if (input == input_end) {

  00484	4d 3b ef	 cmp	 r13, r15
$LN87@textiowrap@32:
  00487	0f 85 09 01 00
	00		 jne	 $finally$22853

; 2402 :         /* We didn't get enough decoded data; signal EOF to get more. */
; 2403 :         PyObject *decoded = _PyObject_CallMethodId(
; 2404 :             self->decoder, &PyId_decode, "yi", "", /* final = */ 1);

  0048d	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  00494	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_decode
  00499	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  004a0	48 03 55 77	 add	 rdx, QWORD PTR tv543[rbp-89]
  004a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02OPKBKFNM@yi?$AA@
  004ab	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  004b3	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2405 :         if (check_decoded(decoded) < 0)

  004b8	48 8b c8	 mov	 rcx, rax
  004bb	48 8b d8	 mov	 rbx, rax
  004be	e8 00 00 00 00	 call	 check_decoded
  004c3	85 c0		 test	 eax, eax
  004c5	78 2c		 js	 SHORT $fail$22787

; 2406 :             goto fail;
; 2407 :         chars_decoded += PyUnicode_GET_LENGTH(decoded);

  004c7	48 03 73 60	 add	 rsi, QWORD PTR [rbx+96]

; 2408 :         Py_DECREF(decoded);

  004cb	48 8b cb	 mov	 rcx, rbx
  004ce	e8 00 00 00 00	 call	 _Py_DecRef

; 2409 :         cookie.need_eof = 1;

  004d3	c6 45 1b 01	 mov	 BYTE PTR cookie$[rbp-69], 1

; 2410 : 
; 2411 :         if (chars_decoded < chars_to_skip) {

  004d7	49 3b f4	 cmp	 rsi, r12
  004da	0f 8d b6 00 00
	00		 jge	 $finally$22853

; 2412 :             PyErr_SetString(PyExc_IOError,
; 2413 :                             "can't reconstruct logical file position");

  004e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  004e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@JGPCMGMC@can?8t?5reconstruct?5logical?5file?5p@
  004ee	e8 00 00 00 00	 call	 PyErr_SetString
$fail$22787:

; 2428 : 
; 2429 : fail:
; 2430 :     if (saved_state) {
; 2431 :         PyObject *type, *value, *traceback;
; 2432 :         PyErr_Fetch(&type, &value, &traceback);

  004f3	4c 8d 45 ef	 lea	 r8, QWORD PTR traceback$22904[rbp-89]
  004f7	48 8d 55 f7	 lea	 rdx, QWORD PTR value$22903[rbp-89]
  004fb	48 8d 4d ff	 lea	 rcx, QWORD PTR type$22902[rbp-89]
  004ff	e8 00 00 00 00	 call	 PyErr_Fetch

; 2433 : 
; 2434 :         res = _PyObject_CallMethodId(self->decoder, &PyId_setstate, "(O)", saved_state);

  00504	48 8b 75 df	 mov	 rsi, QWORD PTR saved_state$1$[rbp-89]
  00508	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  0050f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_setstate
  00514	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0051b	4c 8b ce	 mov	 r9, rsi
  0051e	48 03 55 77	 add	 rdx, QWORD PTR tv543[rbp-89]
  00522	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2435 :         Py_DECREF(saved_state);

  00527	48 8b ce	 mov	 rcx, rsi
  0052a	48 8b d8	 mov	 rbx, rax
  0052d	e8 00 00 00 00	 call	 _Py_DecRef

; 2436 :         if (res == NULL)

  00532	48 85 db	 test	 rbx, rbx

; 2437 :             return NULL;

  00535	74 19		 je	 SHORT $LN2@textiowrap@32

; 2438 :         Py_DECREF(res);

  00537	48 8b cb	 mov	 rcx, rbx
  0053a	e8 00 00 00 00	 call	 _Py_DecRef

; 2439 : 
; 2440 :         PyErr_Restore(type, value, traceback);

  0053f	4c 8b 45 ef	 mov	 r8, QWORD PTR traceback$22904[rbp-89]
  00543	48 8b 55 f7	 mov	 rdx, QWORD PTR value$22903[rbp-89]
  00547	48 8b 4d ff	 mov	 rcx, QWORD PTR type$22902[rbp-89]
  0054b	e8 00 00 00 00	 call	 PyErr_Restore
$LN2@textiowrap@32:

; 2441 :     }
; 2442 :     return NULL;

  00550	33 c0		 xor	 eax, eax
$LN84@textiowrap@32:
  00552	4c 8b b4 24 88
	00 00 00	 mov	 r14, QWORD PTR [rsp+136]
  0055a	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR [rsp+144]
  00562	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR [rsp+152]
  0056a	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR [rsp+128]
$LN80@textiowrap@32:
  00572	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+200]
  0057a	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]

; 2443 : }

  00582	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00589	5f		 pop	 rdi
  0058a	5d		 pop	 rbp
  0058b	c3		 ret	 0
$LN70@textiowrap@32:

; 2341 :             DECODER_GETSTATE();

  0058c	e8 00 00 00 00	 call	 _Py_DecRef
  00591	e9 5d ff ff ff	 jmp	 $fail$22787
$finally$22853:

; 2414 :             goto fail;
; 2415 :         }
; 2416 :     }
; 2417 : 
; 2418 : finally:
; 2419 :     res = _PyObject_CallMethodId(self->decoder, &PyId_setstate, "(O)", saved_state);

  00596	48 8b 75 df	 mov	 rsi, QWORD PTR saved_state$1$[rbp-89]
  0059a	48 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [rdi+136]
  005a1	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_setstate
  005a6	48 03 55 77	 add	 rdx, QWORD PTR tv543[rbp-89]
  005aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  005b1	4c 8b ce	 mov	 r9, rsi
  005b4	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2420 :     Py_DECREF(saved_state);

  005b9	48 8b ce	 mov	 rcx, rsi
  005bc	48 8b d8	 mov	 rbx, rax
  005bf	e8 00 00 00 00	 call	 _Py_DecRef

; 2421 :     if (res == NULL)

  005c4	48 85 db	 test	 rbx, rbx

; 2422 :         return NULL;

  005c7	74 87		 je	 SHORT $LN2@textiowrap@32

; 2423 :     Py_DECREF(res);

  005c9	48 8b cb	 mov	 rcx, rbx
  005cc	e8 00 00 00 00	 call	 _Py_DecRef

; 2424 : 
; 2425 :     /* The returned cookie corresponds to the last safe start point. */
; 2426 :     cookie.chars_to_skip = Py_SAFE_DOWNCAST(chars_to_skip, Py_ssize_t, int);

  005d1	44 89 65 17	 mov	 DWORD PTR cookie$[rbp-73], r12d
$LN89@textiowrap@32:

; 2427 :     return textiowrapper_build_cookie(&cookie);

  005d5	48 8d 4d 07	 lea	 rcx, QWORD PTR cookie$[rbp-89]
  005d9	e8 00 00 00 00	 call	 textiowrapper_build_cookie
  005de	e9 6f ff ff ff	 jmp	 $LN84@textiowrap@32
textiowrapper_tell ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_flush DD imagerel textiowrapper_flush
	DD	imagerel textiowrapper_flush+62
	DD	imagerel $unwind$textiowrapper_flush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$textiowrapper_flush DD imagerel textiowrapper_flush+62
	DD	imagerel textiowrapper_flush+138
	DD	imagerel $chain$1$textiowrapper_flush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$textiowrapper_flush DD imagerel textiowrapper_flush+138
	DD	imagerel textiowrapper_flush+196
	DD	imagerel $chain$3$textiowrapper_flush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_flush DD imagerel textiowrapper_flush+196
	DD	imagerel textiowrapper_flush+289
	DD	imagerel $chain$5$textiowrapper_flush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_flush DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel textiowrapper_flush
	DD	imagerel textiowrapper_flush+62
	DD	imagerel $unwind$textiowrapper_flush
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$textiowrapper_flush DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel textiowrapper_flush
	DD	imagerel textiowrapper_flush+62
	DD	imagerel $unwind$textiowrapper_flush
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$textiowrapper_flush DD 040a21H
	DD	07740aH
	DD	066405H
	DD	imagerel textiowrapper_flush
	DD	imagerel textiowrapper_flush+62
	DD	imagerel $unwind$textiowrapper_flush
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_flush DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT textiowrapper_flush
_TEXT	SEGMENT
self$ = 48
args$ = 56
textiowrapper_flush PROC				; COMDAT

; 2563 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2564 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7f 28		 jg	 SHORT $LN12@textiowrap@33
  0000f	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00021	75 07		 jne	 SHORT $LN20@textiowrap@33
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN20@textiowrap@33:
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
  0002f	33 c0		 xor	 eax, eax

; 2570 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN12@textiowrap@33:

; 2565 :     CHECK_CLOSED(self);

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  0003e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00043	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00048	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004c	75 76		 jne	 SHORT $LN9@textiowrap@33
  0004e	48 8b 89 f8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+248]
  00055	48 85 c9	 test	 rcx, rcx
  00058	74 30		 je	 SHORT $LN8@textiowrap@33
  0005a	e8 00 00 00 00	 call	 _PyFileIO_closed
  0005f	8b f8		 mov	 edi, eax
  00061	85 c0		 test	 eax, eax
$LN21@textiowrap@33:
  00063	7e 70		 jle	 SHORT $LN11@textiowrap@33
  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00073	e8 00 00 00 00	 call	 PyErr_SetString
$LN22@textiowrap@33:
  00078	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0007d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00082	33 c0		 xor	 eax, eax

; 2570 : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5b		 pop	 rbx
  00089	c3		 ret	 0
$LN8@textiowrap@33:

; 2565 :     CHECK_CLOSED(self);

  0008a	33 d2		 xor	 edx, edx
  0008c	48 8b cb	 mov	 rcx, rbx
  0008f	e8 00 00 00 00	 call	 textiowrapper_closed_get
  00094	48 8b f0	 mov	 rsi, rax
  00097	48 85 c0	 test	 rax, rax
  0009a	74 dc		 je	 SHORT $LN22@textiowrap@33
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 PyObject_IsTrue
  000a4	48 8b ce	 mov	 rcx, rsi
  000a7	8b f8		 mov	 edi, eax
  000a9	e8 00 00 00 00	 call	 _Py_DecRef
  000ae	85 ff		 test	 edi, edi
  000b0	79 b1		 jns	 SHORT $LN21@textiowrap@33
  000b2	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  000b7	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000bc	33 c0		 xor	 eax, eax

; 2570 : }

  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5b		 pop	 rbx
  000c3	c3		 ret	 0
$LN9@textiowrap@33:

; 2565 :     CHECK_CLOSED(self);

  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_TrueStruct
  000cb	e8 00 00 00 00	 call	 _PyIOBase_check_closed
  000d0	48 85 c0	 test	 rax, rax
  000d3	74 a3		 je	 SHORT $LN22@textiowrap@33
$LN11@textiowrap@33:

; 2566 :     self->telling = self->seekable;

  000d5	0f b6 83 ad 00
	00 00		 movzx	 eax, BYTE PTR [rbx+173]

; 2567 :     if (_textiowrapper_writeflush(self) < 0)

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	88 83 af 00 00
	00		 mov	 BYTE PTR [rbx+175], al
  000e5	e8 00 00 00 00	 call	 _textiowrapper_writeflush
  000ea	85 c0		 test	 eax, eax

; 2568 :         return NULL;

  000ec	78 8a		 js	 SHORT $LN22@textiowrap@33

; 2569 :     return _PyObject_CallMethodId(self->buffer, &PyId_flush, NULL);

  000ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000f4	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000fd	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_flush
  00102	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00106	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00112	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2570 : }

  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5b		 pop	 rbx
  0011c	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
textiowrapper_flush ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@CDFKLAFC@textiowrapper_close?$AA@	; `string'
EXTRN	PyException_SetContext:PROC
EXTRN	PyErr_NormalizeException:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_close DD imagerel textiowrapper_close
	DD	imagerel textiowrapper_close+57
	DD	imagerel $unwind$textiowrapper_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_close DD imagerel textiowrapper_close+57
	DD	imagerel textiowrapper_close+86
	DD	imagerel $chain$0$textiowrapper_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$textiowrapper_close DD imagerel textiowrapper_close+86
	DD	imagerel textiowrapper_close+131
	DD	imagerel $chain$3$textiowrapper_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$textiowrapper_close DD imagerel textiowrapper_close+131
	DD	imagerel textiowrapper_close+168
	DD	imagerel $chain$5$textiowrapper_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$textiowrapper_close DD imagerel textiowrapper_close+168
	DD	imagerel textiowrapper_close+529
	DD	imagerel $chain$7$textiowrapper_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$textiowrapper_close DD 040021H
	DD	087400H
	DD	096400H
	DD	imagerel textiowrapper_close
	DD	imagerel textiowrapper_close+57
	DD	imagerel $unwind$textiowrapper_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$textiowrapper_close DD 040021H
	DD	087400H
	DD	096400H
	DD	imagerel textiowrapper_close
	DD	imagerel textiowrapper_close+57
	DD	imagerel $unwind$textiowrapper_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$textiowrapper_close DD 040821H
	DD	096408H
	DD	087400H
	DD	imagerel textiowrapper_close
	DD	imagerel textiowrapper_close+57
	DD	imagerel $unwind$textiowrapper_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_close DD 020521H
	DD	087405H
	DD	imagerel textiowrapper_close
	DD	imagerel textiowrapper_close+57
	DD	imagerel $unwind$textiowrapper_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_close DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT ??_C@_0BE@CDFKLAFC@textiowrapper_close?$AA@
CONST	SEGMENT
??_C@_0BE@CDFKLAFC@textiowrapper_close?$AA@ DB 'textiowrapper_close', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_close
_TEXT	SEGMENT
val$23110 = 48
exc$23108 = 96
self$ = 96
args$ = 104
tb$23111 = 112
val2$23137 = 120
textiowrapper_close PROC				; COMDAT

; 2574 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2575 :     PyObject *res;
; 2576 :     int r;
; 2577 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7f 28		 jg	 SHORT $LN23@textiowrap@34
  0000f	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00021	75 07		 jne	 SHORT $LN29@textiowrap@34
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN29@textiowrap@34:
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
  0002f	33 c0		 xor	 eax, eax

; 2622 :     }
; 2623 : }

  00031	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN23@textiowrap@34:

; 2578 : 
; 2579 :     res = textiowrapper_closed_get(self, NULL);

  00037	33 d2		 xor	 edx, edx
  00039	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003e	e8 00 00 00 00	 call	 textiowrapper_closed_get
  00043	48 8b f8	 mov	 rdi, rax

; 2580 :     if (res == NULL)

  00046	48 85 c0	 test	 rax, rax
  00049	75 0b		 jne	 SHORT $LN20@textiowrap@34
  0004b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2622 :     }
; 2623 : }

  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN20@textiowrap@34:

; 2581 :         return NULL;
; 2582 :     r = PyObject_IsTrue(res);

  00056	48 8b c8	 mov	 rcx, rax
  00059	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0005e	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2583 :     Py_DECREF(res);

  00063	48 8b cf	 mov	 rcx, rdi
  00066	8b f0		 mov	 esi, eax
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 2584 :     if (r < 0)

  0006d	85 f6		 test	 esi, esi
  0006f	79 12		 jns	 SHORT $LN30@textiowrap@34

; 2585 :         return NULL;

  00071	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00076	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0007b	33 c0		 xor	 eax, eax

; 2622 :     }
; 2623 : }

  0007d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$LN30@textiowrap@34:

; 2586 : 
; 2587 :     if (r > 0) {

  00083	7e 23		 jle	 SHORT $LN18@textiowrap@34

; 2588 :         Py_RETURN_NONE; /* stream already closed */

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008c	e8 00 00 00 00	 call	 _Py_IncRef
  00091	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00096	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0009b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2622 :     }
; 2623 : }

  000a2	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a6	5b		 pop	 rbx
  000a7	c3		 ret	 0
$LN18@textiowrap@34:

; 2589 :     }
; 2590 :     else {
; 2591 :         PyObject *exc = NULL, *val, *tb;
; 2592 :         if (self->deallocating) {

  000a8	80 bb b0 00 00
	00 00		 cmp	 BYTE PTR [rbx+176], 0
  000af	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _tls_index
  000b5	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR exc$23108[rsp], 0
  000be	74 39		 je	 SHORT $LN14@textiowrap@34

; 2593 :             res = _PyObject_CallMethodId(self->buffer, &PyId__dealloc_warn, "O", self);

  000c0	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000c9	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000cd	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId__dealloc_warn
  000d2	48 03 14 f8	 add	 rdx, QWORD PTR [rax+rdi*8]
  000d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000dd	4c 8b cb	 mov	 r9, rbx
  000e0	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2594 :             if (res)

  000e5	48 85 c0	 test	 rax, rax
  000e8	74 0a		 je	 SHORT $LN15@textiowrap@34

; 2595 :                 Py_DECREF(res);

  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 _Py_DecRef

; 2596 :             else

  000f2	eb 05		 jmp	 SHORT $LN14@textiowrap@34
$LN15@textiowrap@34:

; 2597 :                 PyErr_Clear();

  000f4	e8 00 00 00 00	 call	 PyErr_Clear
$LN14@textiowrap@34:

; 2598 :         }
; 2599 :         res = _PyObject_CallMethodId((PyObject *)self, &PyId_flush, NULL);

  000f9	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00102	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_flush
  00107	45 33 c0	 xor	 r8d, r8d
  0010a	48 8b 3c f8	 mov	 rdi, QWORD PTR [rax+rdi*8]
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	48 03 d7	 add	 rdx, rdi
  00114	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2600 :         if (res == NULL)

  00119	48 85 c0	 test	 rax, rax
  0011c	75 16		 jne	 SHORT $LN13@textiowrap@34

; 2601 :             PyErr_Fetch(&exc, &val, &tb);

  0011e	4c 8d 44 24 70	 lea	 r8, QWORD PTR tb$23111[rsp]
  00123	48 8d 54 24 30	 lea	 rdx, QWORD PTR val$23110[rsp]
  00128	48 8d 4c 24 60	 lea	 rcx, QWORD PTR exc$23108[rsp]
  0012d	e8 00 00 00 00	 call	 PyErr_Fetch

; 2602 :         else

  00132	eb 08		 jmp	 SHORT $LN12@textiowrap@34
$LN13@textiowrap@34:

; 2603 :             Py_DECREF(res);

  00134	48 8b c8	 mov	 rcx, rax
  00137	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@textiowrap@34:

; 2604 : 
; 2605 :         res = _PyObject_CallMethodId(self->buffer, &PyId_close, NULL);

  0013c	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00140	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:PyId_close
  00145	45 33 c0	 xor	 r8d, r8d
  00148	48 03 d7	 add	 rdx, rdi
  0014b	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 2606 :         if (exc != NULL) {

  00150	48 8b 4c 24 60	 mov	 rcx, QWORD PTR exc$23108[rsp]
  00155	48 8b d8	 mov	 rbx, rax
  00158	48 85 c9	 test	 rcx, rcx
  0015b	0f 84 9d 00 00
	00		 je	 $LN5@textiowrap@34

; 2607 :             if (res != NULL) {

  00161	48 85 c0	 test	 rax, rax
  00164	74 39		 je	 SHORT $LN10@textiowrap@34

; 2608 :                 Py_CLEAR(res);

  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@CDFKLAFC@textiowrapper_close?$AA@
  00174	4c 8b c8	 mov	 r9, rax
  00177	41 b8 30 0a 00
	00		 mov	 r8d, 2608		; 00000a30H
  0017d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00185	e8 00 00 00 00	 call	 _PyParallel_Guard
  0018a	85 c0		 test	 eax, eax
  0018c	75 0a		 jne	 SHORT $LN8@textiowrap@34
  0018e	48 8b cb	 mov	 rcx, rbx
  00191	33 db		 xor	 ebx, ebx
  00193	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@textiowrap@34:

; 2609 :                 PyErr_Restore(exc, val, tb);

  00198	48 8b 54 24 30	 mov	 rdx, QWORD PTR val$23110[rsp]

; 2610 :             }
; 2611 :             else {

  0019d	eb 50		 jmp	 SHORT $LN31@textiowrap@34
$LN10@textiowrap@34:

; 2612 :                 PyObject *val2;
; 2613 :                 Py_DECREF(exc);

  0019f	e8 00 00 00 00	 call	 _Py_DecRef

; 2614 :                 Py_XDECREF(tb);

  001a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tb$23111[rsp]
  001a9	48 85 c9	 test	 rcx, rcx
  001ac	74 05		 je	 SHORT $LN3@textiowrap@34
  001ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@34:

; 2615 :                 PyErr_Fetch(&exc, &val2, &tb);

  001b3	4c 8d 44 24 70	 lea	 r8, QWORD PTR tb$23111[rsp]
  001b8	48 8d 54 24 78	 lea	 rdx, QWORD PTR val2$23137[rsp]
  001bd	48 8d 4c 24 60	 lea	 rcx, QWORD PTR exc$23108[rsp]
  001c2	e8 00 00 00 00	 call	 PyErr_Fetch

; 2616 :                 PyErr_NormalizeException(&exc, &val2, &tb);

  001c7	4c 8d 44 24 70	 lea	 r8, QWORD PTR tb$23111[rsp]
  001cc	48 8d 54 24 78	 lea	 rdx, QWORD PTR val2$23137[rsp]
  001d1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR exc$23108[rsp]
  001d6	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 2617 :                 PyException_SetContext(val2, val);

  001db	48 8b 54 24 30	 mov	 rdx, QWORD PTR val$23110[rsp]
  001e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR val2$23137[rsp]
  001e5	e8 00 00 00 00	 call	 PyException_SetContext

; 2618 :                 PyErr_Restore(exc, val2, tb);

  001ea	48 8b 54 24 78	 mov	 rdx, QWORD PTR val2$23137[rsp]
$LN31@textiowrap@34:
  001ef	4c 8b 44 24 70	 mov	 r8, QWORD PTR tb$23111[rsp]
  001f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR exc$23108[rsp]
  001f9	e8 00 00 00 00	 call	 PyErr_Restore
$LN5@textiowrap@34:

; 2619 :             }
; 2620 :         }
; 2621 :         return res;

  001fe	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00203	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00208	48 8b c3	 mov	 rax, rbx

; 2622 :     }
; 2623 : }

  0020b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0020f	5b		 pop	 rbx
  00210	c3		 ret	 0
textiowrapper_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DM@KEHPMFAP@readline?$CI?$CJ?5should?5have?5returned?5@ ; `string'
PUBLIC	??_C@_0BH@DPIGHDHO@textiowrapper_iternext?$AA@	; `string'
EXTRN	_PyIO_str_readline:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$textiowrapper_iternext DD imagerel textiowrapper_iternext
	DD	imagerel textiowrapper_iternext+62
	DD	imagerel $unwind$textiowrapper_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$textiowrapper_iternext DD imagerel textiowrapper_iternext+62
	DD	imagerel textiowrapper_iternext+237
	DD	imagerel $chain$0$textiowrapper_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$textiowrapper_iternext DD imagerel textiowrapper_iternext+237
	DD	imagerel textiowrapper_iternext+325
	DD	imagerel $chain$2$textiowrapper_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$textiowrapper_iternext DD imagerel textiowrapper_iternext+325
	DD	imagerel textiowrapper_iternext+339
	DD	imagerel $chain$4$textiowrapper_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$textiowrapper_iternext DD 020021H
	DD	087400H
	DD	imagerel textiowrapper_iternext
	DD	imagerel textiowrapper_iternext+62
	DD	imagerel $unwind$textiowrapper_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$textiowrapper_iternext DD 020021H
	DD	087400H
	DD	imagerel textiowrapper_iternext
	DD	imagerel textiowrapper_iternext+62
	DD	imagerel $unwind$textiowrapper_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$textiowrapper_iternext DD 020521H
	DD	087405H
	DD	imagerel textiowrapper_iternext
	DD	imagerel textiowrapper_iternext+62
	DD	imagerel $unwind$textiowrapper_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$textiowrapper_iternext DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DM@KEHPMFAP@readline?$CI?$CJ?5should?5have?5returned?5@
CONST	SEGMENT
??_C@_0DM@KEHPMFAP@readline?$CI?$CJ?5should?5have?5returned?5@ DB 'readli'
	DB	'ne() should have returned an str object, not ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@DPIGHDHO@textiowrapper_iternext?$AA@
CONST	SEGMENT
??_C@_0BH@DPIGHDHO@textiowrapper_iternext?$AA@ DB 'textiowrapper_iternext'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT textiowrapper_iternext
_TEXT	SEGMENT
self$ = 64
textiowrapper_iternext PROC				; COMDAT

; 2627 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2628 :     PyObject *line;
; 2629 : 
; 2630 :     CHECK_INITIALIZED(self);

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7f 28		 jg	 SHORT $LN13@textiowrap@35
  0000f	83 79 64 00	 cmp	 DWORD PTR [rcx+100], 0
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FMNEPBDN@underlying?5buffer?5has?5been?5detac@
  00021	75 07		 jne	 SHORT $LN20@textiowrap@35
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BGNADMFL@I?1O?5operation?5on?5uninitialized?5o@
$LN20@textiowrap@35:
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
  0002f	33 c0		 xor	 eax, eax

; 2661 : }

  00031	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN13@textiowrap@35:

; 2631 : 
; 2632 :     self->telling = 0;
; 2633 :     if (Py_TYPE(self) == &PyTextIOWrapper_Type) {

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTextIOWrapper_Type
  0003e	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00043	c6 81 af 00 00
	00 00		 mov	 BYTE PTR [rcx+175], 0
  0004a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004e	0f 85 99 00 00
	00		 jne	 $LN10@textiowrap@35

; 2634 :         /* Skip method call overhead for speed */
; 2635 :         line = _textiowrapper_readline(self, -1);

  00054	48 83 ca ff	 or	 rdx, -1
  00058	e8 00 00 00 00	 call	 _textiowrapper_readline
  0005d	48 8b f8	 mov	 rdi, rax
$LN8@textiowrap@35:

; 2645 :             return NULL;
; 2646 :         }
; 2647 :     }
; 2648 : 
; 2649 :     if (line == NULL || PyUnicode_READY(line) == -1)

  00060	48 85 ff	 test	 rdi, rdi
  00063	74 7b		 je	 SHORT $LN6@textiowrap@35
  00065	f6 47 70 80	 test	 BYTE PTR [rdi+112], 128	; 00000080H
  00069	75 0d		 jne	 SHORT $LN18@textiowrap@35
  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00073	83 f8 ff	 cmp	 eax, -1
  00076	74 68		 je	 SHORT $LN6@textiowrap@35
$LN18@textiowrap@35:

; 2651 : 
; 2652 :     if (PyUnicode_GET_LENGTH(line) == 0) {

  00078	48 83 7f 60 00	 cmp	 QWORD PTR [rdi+96], 0
  0007d	0f 85 c2 00 00
	00		 jne	 $LN5@textiowrap@35

; 2653 :         /* Reached EOF or would have blocked */
; 2654 :         Py_DECREF(line);

  00083	48 8b cf	 mov	 rcx, rdi
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 2655 :         Py_CLEAR(self->snapshot);

  0008b	4c 8b 8b e8 00
	00 00		 mov	 r9, QWORD PTR [rbx+232]
  00092	4d 85 c9	 test	 r9, r9
  00095	74 3c		 je	 SHORT $LN3@textiowrap@35
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LMODBMNC@?4?4?2Modules?2_io?2textio?4c?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@DPIGHDHO@textiowrapper_iternext?$AA@
  000a5	41 b8 5f 0a 00
	00		 mov	 r8d, 2655		; 00000a5fH
  000ab	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b3	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b8	85 c0		 test	 eax, eax
  000ba	75 17		 jne	 SHORT $LN3@textiowrap@35
  000bc	48 8b 8b e8 00
	00 00		 mov	 rcx, QWORD PTR [rbx+232]
  000c3	48 c7 83 e8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+232], 0
  000ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@textiowrap@35:

; 2656 :         self->telling = self->seekable;

  000d3	0f b6 83 ad 00
	00 00		 movzx	 eax, BYTE PTR [rbx+173]
  000da	88 83 af 00 00
	00		 mov	 BYTE PTR [rbx+175], al
$LN6@textiowrap@35:

; 2650 :         return NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2661 : }

  000e7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000eb	5b		 pop	 rbx
  000ec	c3		 ret	 0
$LN10@textiowrap@35:

; 2636 :     }
; 2637 :     else {
; 2638 :         line = PyObject_CallMethodObjArgs((PyObject *)self,
; 2639 :                                            _PyIO_str_readline, NULL);

  000ed	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR _PyIO_str_readline
  000f4	45 33 c0	 xor	 r8d, r8d
  000f7	e8 00 00 00 00	 call	 PyObject_CallMethodObjArgs
  000fc	48 8b f8	 mov	 rdi, rax

; 2640 :         if (line && !PyUnicode_Check(line)) {

  000ff	48 85 c0	 test	 rax, rax
  00102	74 dc		 je	 SHORT $LN6@textiowrap@35
  00104	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00108	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  00113	0f 85 47 ff ff
	ff		 jne	 $LN8@textiowrap@35

; 2641 :             PyErr_Format(PyExc_IOError,
; 2642 :                          "readline() should have returned an str object, "
; 2643 :                          "not '%.200s'", Py_TYPE(line)->tp_name);

  00119	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0011d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@KEHPMFAP@readline?$CI?$CJ?5should?5have?5returned?5@
  0012b	e8 00 00 00 00	 call	 PyErr_Format

; 2644 :             Py_DECREF(line);

  00130	48 8b cf	 mov	 rcx, rdi
  00133	e8 00 00 00 00	 call	 _Py_DecRef
  00138	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2650 :         return NULL;

  0013d	33 c0		 xor	 eax, eax

; 2661 : }

  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	5b		 pop	 rbx
  00144	c3		 ret	 0
$LN5@textiowrap@35:

; 2657 :         return NULL;
; 2658 :     }
; 2659 : 
; 2660 :     return line;

  00145	48 8b c7	 mov	 rax, rdi
  00148	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2661 : }

  0014d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00151	5b		 pop	 rbx
  00152	c3		 ret	 0
textiowrapper_iternext ENDP
_TEXT	ENDS
END
