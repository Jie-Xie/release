; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@		; `string'
PUBLIC	??_C@_02JKEHMDF@nt?$AA@				; `string'
PUBLIC	??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@	; `string'
PUBLIC	??_C@_07MHKMJCBA@urandom?$AA@			; `string'
PUBLIC	??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@		; `string'
PUBLIC	??_C@_06MIMMPGNN@_isdir?$AA@			; `string'
PUBLIC	??_C@_0BE@FKJDANNK@_getfileinformation?$AA@	; `string'
PUBLIC	??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@	; `string'
PUBLIC	??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@	; `string'
PUBLIC	??_C@_05BBAEEBBH@abort?$AA@			; `string'
PUBLIC	??_C@_05DEEMBJFM@fsync?$AA@			; `string'
PUBLIC	??_C@_08MHKKJIBB@strerror?$AA@			; `string'
PUBLIC	??_C@_06OOJCBFLM@putenv?$AA@			; `string'
PUBLIC	??_C@_04MKFKKHBG@pipe?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_05MIPJACCK@fstat?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_05ELJELHPE@lseek?$AA@			; `string'
PUBLIC	??_C@_04LAAPLFOA@dup2?$AA@			; `string'
PUBLIC	??_C@_03BHPKJDPK@dup?$AA@			; `string'
PUBLIC	??_C@_0BA@PABGBABL@device_encoding?$AA@		; `string'
PUBLIC	??_C@_0L@ICENNBNA@closerange?$AA@		; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_07BPIIBJED@waitpid?$AA@			; `string'
PUBLIC	??_C@_04BJJEOANI@kill?$AA@			; `string'
PUBLIC	??_C@_09FCFKICPJ@startfile?$AA@			; `string'
PUBLIC	??_C@_08NPAFALFK@getlogin?$AA@			; `string'
PUBLIC	??_C@_07NNLELLPO@getppid?$AA@			; `string'
PUBLIC	??_C@_06FFEBHEJM@getpid?$AA@			; `string'
PUBLIC	??_C@_07EPDPINNO@spawnve?$AA@			; `string'
PUBLIC	??_C@_06NNKHBJHE@spawnv?$AA@			; `string'
PUBLIC	??_C@_06GMNLOHLP@execve?$AA@			; `string'
PUBLIC	??_C@_05OAKKMHID@execv?$AA@			; `string'
PUBLIC	??_C@_05EAOJNIGN@_exit?$AA@			; `string'
PUBLIC	??_C@_05MJOOAIJH@times?$AA@			; `string'
PUBLIC	??_C@_05HCLPLDJ@utime?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_06DAJBMHKE@unlink?$AA@			; `string'
PUBLIC	??_C@_05CHFEIFNB@umask?$AA@			; `string'
PUBLIC	??_C@_07KLDEEJBK@symlink?$AA@			; `string'
PUBLIC	??_C@_0BB@KAJEHDMI@stat_float_times?$AA@	; `string'
PUBLIC	??_C@_04GBLELIND@stat?$AA@			; `string'
PUBLIC	??_C@_05IHDOMKOF@rmdir?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_06LMEAOBLB@rename?$AA@			; `string'
PUBLIC	??_C@_08DPKANCED@readlink?$AA@			; `string'
PUBLIC	??_C@_05PKPOIPAL@mkdir?$AA@			; `string'
PUBLIC	??_C@_05GJGCCBEM@lstat?$AA@			; `string'
PUBLIC	??_C@_07GMBICOLL@listdir?$AA@			; `string'
PUBLIC	??_C@_04OHHBHOGB@link?$AA@			; `string'
PUBLIC	??_C@_07DJKBFKMA@getcwdb?$AA@			; `string'
PUBLIC	??_C@_06BFFACJH@getcwd?$AA@			; `string'
PUBLIC	??_C@_05OCEJBCEE@chmod?$AA@			; `string'
PUBLIC	??_C@_05IHFEJEKL@chdir?$AA@			; `string'
PUBLIC	??_C@_06EBPNOMLE@access?$AA@			; `string'
PUBLIC	??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@	; `string'
PUBLIC	??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@ ; `string'
PUBLIC	??_C@_05DENOCHIP@lines?$AA@			; `string'
PUBLIC	??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@ ; `string'
PUBLIC	??_C@_07HIFEPIJN@columns?$AA@			; `string'
PUBLIC	??_C@_05GECEPKB@flags?$AA@			; `string'
PUBLIC	??_C@_0N@BNFIOIGL@times_result?$AA@		; `string'
PUBLIC	??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@ ; `string'
PUBLIC	??_C@_07ECLNDMPC@elapsed?$AA@			; `string'
PUBLIC	??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@ ; `string'
PUBLIC	??_C@_0BA@KPAGPIBA@children_system?$AA@		; `string'
PUBLIC	??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@ ; `string'
PUBLIC	??_C@_0O@MGJDGJPB@children_user?$AA@		; `string'
PUBLIC	??_C@_0M@IFJPBFHL@system?5time?$AA@		; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_C@_09DDJCHFLJ@user?5time?$AA@		; `string'
PUBLIC	??_C@_04CCHAHKJA@user?$AA@			; `string'
PUBLIC	??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@	; `string'
PUBLIC	??_C@_0M@PINLHHEI@environment?$AA@		; `string'
PUBLIC	??_C@_04GIEEDNNN@argv?$AA@			; `string'
PUBLIC	??_C@_0N@HCEBDBKJ@uname_result?$AA@		; `string'
PUBLIC	??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@	; `string'
PUBLIC	??_C@_07MHDNFCJE@machine?$AA@			; `string'
PUBLIC	??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@ ; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@ ; `string'
PUBLIC	??_C@_07EOGFDLKI@release?$AA@			; `string'
PUBLIC	??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@ ; `string'
PUBLIC	??_C@_08FOEBGLLE@nodename?$AA@			; `string'
PUBLIC	??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@	; `string'
PUBLIC	??_C@_07LBFJMCKJ@sysname?$AA@			; `string'
PUBLIC	??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@		; `string'
PUBLIC	??_C@_0L@OFFJPAEB@src_dir_fd?$AA@		; `string'
PUBLIC	??_C@_03HHBLCKEM@dst?$AA@			; `string'
PUBLIC	??_C@_03LOJEKLML@src?$AA@			; `string'
PUBLIC	??_C@_0O@FGNLNFPF@effective_ids?$AA@		; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@		; `string'
PUBLIC	??_C@_06GPCGKDIP@dir_fd?$AA@			; `string'
PUBLIC	??_C@_04LNEJFJGI@path?$AA@			; `string'
PUBLIC	??_C@_0P@HMGCCANC@statvfs_result?$AA@		; `string'
PUBLIC	??_C@_09HMAABEP@f_namemax?$AA@			; `string'
PUBLIC	??_C@_06HDAGHFFN@f_flag?$AA@			; `string'
PUBLIC	??_C@_08OKABAGDI@f_favail?$AA@			; `string'
PUBLIC	??_C@_07GLLIAGA@f_ffree?$AA@			; `string'
PUBLIC	??_C@_07CILFICMK@f_files?$AA@			; `string'
PUBLIC	??_C@_08BOEOCCCL@f_bavail?$AA@			; `string'
PUBLIC	??_C@_07JNCKMCHG@f_bfree?$AA@			; `string'
PUBLIC	??_C@_08KLPHNGHN@f_blocks?$AA@			; `string'
PUBLIC	??_C@_08KNLFHHPC@f_frsize?$AA@			; `string'
PUBLIC	??_C@_07KFEIOOFH@f_bsize?$AA@			; `string'
PUBLIC	??_C@_0M@ENKKEMPE@stat_result?$AA@		; `string'
PUBLIC	??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@ ; `string'
PUBLIC	??_C@_0M@LCENIKEP@st_ctime_ns?$AA@		; `string'
PUBLIC	??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@ ; `string'
PUBLIC	??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@		; `string'
PUBLIC	??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@ ; `string'
PUBLIC	??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@		; `string'
PUBLIC	??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@	; `string'
PUBLIC	??_C@_08LBMGFGJG@st_ctime?$AA@			; `string'
PUBLIC	??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@ ; `string'
PUBLIC	??_C@_08ILMMDHOG@st_mtime?$AA@			; `string'
PUBLIC	??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@	; `string'
PUBLIC	??_C@_08PMAOPHJN@st_atime?$AA@			; `string'
PUBLIC	??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@ ; `string'
PUBLIC	??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@ ; `string'
PUBLIC	??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@ ; `string'
PUBLIC	??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@ ; `string'
PUBLIC	??_C@_07OEENKIAN@st_size?$AA@			; `string'
PUBLIC	??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@	; `string'
PUBLIC	??_C@_06HFIFGMEM@st_gid?$AA@			; `string'
PUBLIC	??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@	; `string'
PUBLIC	??_C@_06IPJFPDFI@st_uid?$AA@			; `string'
PUBLIC	??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@	; `string'
PUBLIC	??_C@_08MBANAKNM@st_nlink?$AA@			; `string'
PUBLIC	??_C@_06CHPEJBOD@device?$AA@			; `string'
PUBLIC	??_C@_06BGNOEKBF@st_dev?$AA@			; `string'
PUBLIC	??_C@_05HDNFNCKJ@inode?$AA@			; `string'
PUBLIC	??_C@_06HDOBNEDB@st_ino?$AA@			; `string'
PUBLIC	??_C@_0BA@JDIBEOPL@protection?5bits?$AA@	; `string'
PUBLIC	??_C@_07IEOFAEI@st_mode?$AA@			; `string'
_BSS	SEGMENT
win32_can_symlink DD 01H DUP (?)
	ALIGN	8

?sizeof_ioinfo@?1??_PyVerify_fd@@9@9 DQ 01H DUP (?)	; `_PyVerify_fd'::`2'::sizeof_ioinfo
has_GetFinalPathNameByHandle DD 01H DUP (?)
	ALIGN	8

billion	DQ	01H DUP (?)
Py_CreateSymbolicLinkW DQ 01H DUP (?)
Py_CreateSymbolicLinkA DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@
CONST	SEGMENT
??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@ DB 'MS_WINDOWS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JKEHMDF@nt?$AA@
CONST	SEGMENT
??_C@_02JKEHMDF@nt?$AA@ DB 'nt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@
CONST	SEGMENT
??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@ DB 'get_terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHKMJCBA@urandom?$AA@
CONST	SEGMENT
??_C@_07MHKMJCBA@urandom?$AA@ DB 'urandom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@
CONST	SEGMENT
??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@ DB '_getdiskusage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIMMPGNN@_isdir?$AA@
CONST	SEGMENT
??_C@_06MIMMPGNN@_isdir?$AA@ DB '_isdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FKJDANNK@_getfileinformation?$AA@
CONST	SEGMENT
??_C@_0BE@FKJDANNK@_getfileinformation?$AA@ DB '_getfileinformation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@
CONST	SEGMENT
??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@ DB '_getfinalpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@ DB '_getfullpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BBAEEBBH@abort?$AA@
CONST	SEGMENT
??_C@_05BBAEEBBH@abort?$AA@ DB 'abort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEEMBJFM@fsync?$AA@
CONST	SEGMENT
??_C@_05DEEMBJFM@fsync?$AA@ DB 'fsync', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHKKJIBB@strerror?$AA@
CONST	SEGMENT
??_C@_08MHKKJIBB@strerror?$AA@ DB 'strerror', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOJCBFLM@putenv?$AA@
CONST	SEGMENT
??_C@_06OOJCBFLM@putenv?$AA@ DB 'putenv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKFKKHBG@pipe?$AA@
CONST	SEGMENT
??_C@_04MKFKKHBG@pipe?$AA@ DB 'pipe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIPJACCK@fstat?$AA@
CONST	SEGMENT
??_C@_05MIPJACCK@fstat?$AA@ DB 'fstat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELJELHPE@lseek?$AA@
CONST	SEGMENT
??_C@_05ELJELHPE@lseek?$AA@ DB 'lseek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LAAPLFOA@dup2?$AA@
CONST	SEGMENT
??_C@_04LAAPLFOA@dup2?$AA@ DB 'dup2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHPKJDPK@dup?$AA@
CONST	SEGMENT
??_C@_03BHPKJDPK@dup?$AA@ DB 'dup', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PABGBABL@device_encoding?$AA@
CONST	SEGMENT
??_C@_0BA@PABGBABL@device_encoding?$AA@ DB 'device_encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICENNBNA@closerange?$AA@
CONST	SEGMENT
??_C@_0L@ICENNBNA@closerange?$AA@ DB 'closerange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BPIIBJED@waitpid?$AA@
CONST	SEGMENT
??_C@_07BPIIBJED@waitpid?$AA@ DB 'waitpid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJJEOANI@kill?$AA@
CONST	SEGMENT
??_C@_04BJJEOANI@kill?$AA@ DB 'kill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCFKICPJ@startfile?$AA@
CONST	SEGMENT
??_C@_09FCFKICPJ@startfile?$AA@ DB 'startfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPAFALFK@getlogin?$AA@
CONST	SEGMENT
??_C@_08NPAFALFK@getlogin?$AA@ DB 'getlogin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNLELLPO@getppid?$AA@
CONST	SEGMENT
??_C@_07NNLELLPO@getppid?$AA@ DB 'getppid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFEBHEJM@getpid?$AA@
CONST	SEGMENT
??_C@_06FFEBHEJM@getpid?$AA@ DB 'getpid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EPDPINNO@spawnve?$AA@
CONST	SEGMENT
??_C@_07EPDPINNO@spawnve?$AA@ DB 'spawnve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNKHBJHE@spawnv?$AA@
CONST	SEGMENT
??_C@_06NNKHBJHE@spawnv?$AA@ DB 'spawnv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMNLOHLP@execve?$AA@
CONST	SEGMENT
??_C@_06GMNLOHLP@execve?$AA@ DB 'execve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAKKMHID@execv?$AA@
CONST	SEGMENT
??_C@_05OAKKMHID@execv?$AA@ DB 'execv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAOJNIGN@_exit?$AA@
CONST	SEGMENT
??_C@_05EAOJNIGN@_exit?$AA@ DB '_exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJOOAIJH@times?$AA@
CONST	SEGMENT
??_C@_05MJOOAIJH@times?$AA@ DB 'times', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HCLPLDJ@utime?$AA@
CONST	SEGMENT
??_C@_05HCLPLDJ@utime?$AA@ DB 'utime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAJBMHKE@unlink?$AA@
CONST	SEGMENT
??_C@_06DAJBMHKE@unlink?$AA@ DB 'unlink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHFEIFNB@umask?$AA@
CONST	SEGMENT
??_C@_05CHFEIFNB@umask?$AA@ DB 'umask', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLDEEJBK@symlink?$AA@
CONST	SEGMENT
??_C@_07KLDEEJBK@symlink?$AA@ DB 'symlink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KAJEHDMI@stat_float_times?$AA@
CONST	SEGMENT
??_C@_0BB@KAJEHDMI@stat_float_times?$AA@ DB 'stat_float_times', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBLELIND@stat?$AA@
CONST	SEGMENT
??_C@_04GBLELIND@stat?$AA@ DB 'stat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHDOMKOF@rmdir?$AA@
CONST	SEGMENT
??_C@_05IHDOMKOF@rmdir?$AA@ DB 'rmdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMEAOBLB@rename?$AA@
CONST	SEGMENT
??_C@_06LMEAOBLB@rename?$AA@ DB 'rename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPKANCED@readlink?$AA@
CONST	SEGMENT
??_C@_08DPKANCED@readlink?$AA@ DB 'readlink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKPOIPAL@mkdir?$AA@
CONST	SEGMENT
??_C@_05PKPOIPAL@mkdir?$AA@ DB 'mkdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJGCCBEM@lstat?$AA@
CONST	SEGMENT
??_C@_05GJGCCBEM@lstat?$AA@ DB 'lstat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMBICOLL@listdir?$AA@
CONST	SEGMENT
??_C@_07GMBICOLL@listdir?$AA@ DB 'listdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHHBHOGB@link?$AA@
CONST	SEGMENT
??_C@_04OHHBHOGB@link?$AA@ DB 'link', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DJKBFKMA@getcwdb?$AA@
CONST	SEGMENT
??_C@_07DJKBFKMA@getcwdb?$AA@ DB 'getcwdb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFFACJH@getcwd?$AA@
CONST	SEGMENT
??_C@_06BFFACJH@getcwd?$AA@ DB 'getcwd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCEJBCEE@chmod?$AA@
CONST	SEGMENT
??_C@_05OCEJBCEE@chmod?$AA@ DB 'chmod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHFEJEKL@chdir?$AA@
CONST	SEGMENT
??_C@_05IHFEJEKL@chdir?$AA@ DB 'chdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBPNOMLE@access?$AA@
CONST	SEGMENT
??_C@_06EBPNOMLE@access?$AA@ DB 'access', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@
CONST	SEGMENT
??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@ DB 'os.terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@
CONST	SEGMENT
??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@ DB 'height of t'
	DB	'he terminal window in characters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DENOCHIP@lines?$AA@
CONST	SEGMENT
??_C@_05DENOCHIP@lines?$AA@ DB 'lines', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@
CONST	SEGMENT
??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@ DB 'width of t'
	DB	'he terminal window in characters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns?$AA@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns?$AA@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GECEPKB@flags?$AA@
CONST	SEGMENT
??_C@_05GECEPKB@flags?$AA@ DB 'flags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNFIOIGL@times_result?$AA@
CONST	SEGMENT
??_C@_0N@BNFIOIGL@times_result?$AA@ DB 'times_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@
CONST	SEGMENT
??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@ DB 'elapsed tim'
	DB	'e since an arbitrary point in the past', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECLNDMPC@elapsed?$AA@
CONST	SEGMENT
??_C@_07ECLNDMPC@elapsed?$AA@ DB 'elapsed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@
CONST	SEGMENT
??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@ DB 'system time of chi'
	DB	'ldren', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPAGPIBA@children_system?$AA@
CONST	SEGMENT
??_C@_0BA@KPAGPIBA@children_system?$AA@ DB 'children_system', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@
CONST	SEGMENT
??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@ DB 'user time of childre'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGJDGJPB@children_user?$AA@
CONST	SEGMENT
??_C@_0O@MGJDGJPB@children_user?$AA@ DB 'children_user', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFJPBFHL@system?5time?$AA@
CONST	SEGMENT
??_C@_0M@IFJPBFHL@system?5time?$AA@ DB 'system time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DDJCHFLJ@user?5time?$AA@
CONST	SEGMENT
??_C@_09DDJCHFLJ@user?5time?$AA@ DB 'user time', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCHAHKJA@user?$AA@
CONST	SEGMENT
??_C@_04CCHAHKJA@user?$AA@ DB 'user', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@
CONST	SEGMENT
??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@ DB 'target_is_directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PINLHHEI@environment?$AA@
CONST	SEGMENT
??_C@_0M@PINLHHEI@environment?$AA@ DB 'environment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIEEDNNN@argv?$AA@
CONST	SEGMENT
??_C@_04GIEEDNNN@argv?$AA@ DB 'argv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HCEBDBKJ@uname_result?$AA@
CONST	SEGMENT
??_C@_0N@HCEBDBKJ@uname_result?$AA@ DB 'uname_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@
CONST	SEGMENT
??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@ DB 'hardware identifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHDNFCJE@machine?$AA@
CONST	SEGMENT
??_C@_07MHDNFCJE@machine?$AA@ DB 'machine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@
CONST	SEGMENT
??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@ DB 'operating system v'
	DB	'ersion', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@
CONST	SEGMENT
??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@ DB 'operating system r'
	DB	'elease', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGFDLKI@release?$AA@
CONST	SEGMENT
??_C@_07EOGFDLKI@release?$AA@ DB 'release', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@
CONST	SEGMENT
??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@ DB 'name of '
	DB	'machine on network (implementation-defined)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FOEBGLLE@nodename?$AA@
CONST	SEGMENT
??_C@_08FOEBGLLE@nodename?$AA@ DB 'nodename', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@
CONST	SEGMENT
??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@ DB 'operating system name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBFJMCKJ@sysname?$AA@
CONST	SEGMENT
??_C@_07LBFJMCKJ@sysname?$AA@ DB 'sysname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
CONST	SEGMENT
??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@ DB 'dst_dir_fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
CONST	SEGMENT
??_C@_0L@OFFJPAEB@src_dir_fd?$AA@ DB 'src_dir_fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHBLCKEM@dst?$AA@
CONST	SEGMENT
??_C@_03HHBLCKEM@dst?$AA@ DB 'dst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOJEKLML@src?$AA@
CONST	SEGMENT
??_C@_03LOJEKLML@src?$AA@ DB 'src', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGNLNFPF@effective_ids?$AA@
CONST	SEGMENT
??_C@_0O@FGNLNFPF@effective_ids?$AA@ DB 'effective_ids', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
CONST	SEGMENT
??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@ DB 'follow_symlinks', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GPCGKDIP@dir_fd?$AA@
CONST	SEGMENT
??_C@_06GPCGKDIP@dir_fd?$AA@ DB 'dir_fd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNEJFJGI@path?$AA@
CONST	SEGMENT
??_C@_04LNEJFJGI@path?$AA@ DB 'path', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMGCCANC@statvfs_result?$AA@
CONST	SEGMENT
??_C@_0P@HMGCCANC@statvfs_result?$AA@ DB 'statvfs_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMAABEP@f_namemax?$AA@
CONST	SEGMENT
??_C@_09HMAABEP@f_namemax?$AA@ DB 'f_namemax', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDAGHFFN@f_flag?$AA@
CONST	SEGMENT
??_C@_06HDAGHFFN@f_flag?$AA@ DB 'f_flag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OKABAGDI@f_favail?$AA@
CONST	SEGMENT
??_C@_08OKABAGDI@f_favail?$AA@ DB 'f_favail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLLIAGA@f_ffree?$AA@
CONST	SEGMENT
??_C@_07GLLIAGA@f_ffree?$AA@ DB 'f_ffree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CILFICMK@f_files?$AA@
CONST	SEGMENT
??_C@_07CILFICMK@f_files?$AA@ DB 'f_files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOEOCCCL@f_bavail?$AA@
CONST	SEGMENT
??_C@_08BOEOCCCL@f_bavail?$AA@ DB 'f_bavail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNCKMCHG@f_bfree?$AA@
CONST	SEGMENT
??_C@_07JNCKMCHG@f_bfree?$AA@ DB 'f_bfree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KLPHNGHN@f_blocks?$AA@
CONST	SEGMENT
??_C@_08KLPHNGHN@f_blocks?$AA@ DB 'f_blocks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNLFHHPC@f_frsize?$AA@
CONST	SEGMENT
??_C@_08KNLFHHPC@f_frsize?$AA@ DB 'f_frsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFEIOOFH@f_bsize?$AA@
CONST	SEGMENT
??_C@_07KFEIOOFH@f_bsize?$AA@ DB 'f_bsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENKKEMPE@stat_result?$AA@
CONST	SEGMENT
??_C@_0M@ENKKEMPE@stat_result?$AA@ DB 'stat_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@
CONST	SEGMENT
??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@ DB 'time of las'
	DB	't change in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCENIKEP@st_ctime_ns?$AA@
CONST	SEGMENT
??_C@_0M@LCENIKEP@st_ctime_ns?$AA@ DB 'st_ctime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@
CONST	SEGMENT
??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@ DB 'time of las'
	DB	't modification in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@
CONST	SEGMENT
??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@ DB 'st_mtime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@
CONST	SEGMENT
??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@ DB 'time of las'
	DB	't access in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@
CONST	SEGMENT
??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@ DB 'st_atime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@
CONST	SEGMENT
??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@ DB 'time of last change', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBMGFGJG@st_ctime?$AA@
CONST	SEGMENT
??_C@_08LBMGFGJG@st_ctime?$AA@ DB 'st_ctime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@
CONST	SEGMENT
??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@ DB 'time of last mod'
	DB	'ification', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILMMDHOG@st_mtime?$AA@
CONST	SEGMENT
??_C@_08ILMMDHOG@st_mtime?$AA@ DB 'st_mtime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@
CONST	SEGMENT
??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@ DB 'time of last access', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMAOPHJN@st_atime?$AA@
CONST	SEGMENT
??_C@_08PMAOPHJN@st_atime?$AA@ DB 'st_atime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@
CONST	SEGMENT
??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@ DB 'integer time '
	DB	'of last change', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@
CONST	SEGMENT
??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@ DB 'integer time'
	DB	' of last modification', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@
CONST	SEGMENT
??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@ DB 'integer time '
	DB	'of last access', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@
CONST	SEGMENT
??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@ DB 'total size, in bytes'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEENKIAN@st_size?$AA@
CONST	SEGMENT
??_C@_07OEENKIAN@st_size?$AA@ DB 'st_size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@
CONST	SEGMENT
??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@ DB 'group ID of owner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFIFGMEM@st_gid?$AA@
CONST	SEGMENT
??_C@_06HFIFGMEM@st_gid?$AA@ DB 'st_gid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@
CONST	SEGMENT
??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@ DB 'user ID of owner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPJFPDFI@st_uid?$AA@
CONST	SEGMENT
??_C@_06IPJFPDFI@st_uid?$AA@ DB 'st_uid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@
CONST	SEGMENT
??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@ DB 'number of hard links', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MBANAKNM@st_nlink?$AA@
CONST	SEGMENT
??_C@_08MBANAKNM@st_nlink?$AA@ DB 'st_nlink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHPEJBOD@device?$AA@
CONST	SEGMENT
??_C@_06CHPEJBOD@device?$AA@ DB 'device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGNOEKBF@st_dev?$AA@
CONST	SEGMENT
??_C@_06BGNOEKBF@st_dev?$AA@ DB 'st_dev', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDNFNCKJ@inode?$AA@
CONST	SEGMENT
??_C@_05HDNFNCKJ@inode?$AA@ DB 'inode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDOBNEDB@st_ino?$AA@
CONST	SEGMENT
??_C@_06HDOBNEDB@st_ino?$AA@ DB 'st_ino', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDIBEOPL@protection?5bits?$AA@
CONST	SEGMENT
??_C@_0BA@JDIBEOPL@protection?5bits?$AA@ DB 'protection bits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEOFAEI@st_mode?$AA@
CONST	SEGMENT
??_C@_07IEOFAEI@st_mode?$AA@ DB 'st_mode', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
posix__doc__ DB	'This module provides access to operating system function'
	DB	'ality that is', 0aH, 'standardized by the C Standard and the '
	DB	'POSIX standard (a thinly', 0aH, 'disguised Unix interface).  '
	DB	'Refer to the library manual and', 0aH, 'corresponding Unix ma'
	DB	'nual entries for more information on calls.', 00H
	ORG $+5
secs_between_epochs DQ 00000002b6109100H
stat_result__doc__ DB 'stat_result: Result from stat, fstat, or lstat.', 0aH
	DB	0aH, 'This object may be accessed either as a tuple of', 0aH, ' '
	DB	' (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)'
	DB	0aH, 'or via the attributes st_mode, st_ino, st_dev, st_nlink,'
	DB	' st_uid, and so on.', 0aH, 0aH, 'Posix/windows: If your platf'
	DB	'orm supports st_blksize, st_blocks, st_rdev,', 0aH, 'or st_fl'
	DB	'ags, they are available as attributes only.', 0aH, 0aH, 'See '
	DB	'os.stat for more information.', 00H
	ORG $+2
stat_result_fields DQ FLAT:??_C@_07IEOFAEI@st_mode?$AA@
	DQ	FLAT:??_C@_0BA@JDIBEOPL@protection?5bits?$AA@
	DQ	FLAT:??_C@_06HDOBNEDB@st_ino?$AA@
	DQ	FLAT:??_C@_05HDNFNCKJ@inode?$AA@
	DQ	FLAT:??_C@_06BGNOEKBF@st_dev?$AA@
	DQ	FLAT:??_C@_06CHPEJBOD@device?$AA@
	DQ	FLAT:??_C@_08MBANAKNM@st_nlink?$AA@
	DQ	FLAT:??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@
	DQ	FLAT:??_C@_06IPJFPDFI@st_uid?$AA@
	DQ	FLAT:??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@
	DQ	FLAT:??_C@_06HFIFGMEM@st_gid?$AA@
	DQ	FLAT:??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@
	DQ	FLAT:??_C@_07OEENKIAN@st_size?$AA@
	DQ	FLAT:??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@
	DQ	FLAT:??_C@_08PMAOPHJN@st_atime?$AA@
	DQ	FLAT:??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@
	DQ	FLAT:??_C@_08ILMMDHOG@st_mtime?$AA@
	DQ	FLAT:??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@
	DQ	FLAT:??_C@_08LBMGFGJG@st_ctime?$AA@
	DQ	FLAT:??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@
	DQ	FLAT:??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@
	DQ	FLAT:??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@
	DQ	FLAT:??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@
	DQ	FLAT:??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@
	DQ	FLAT:??_C@_0M@LCENIKEP@st_ctime_ns?$AA@
	DQ	FLAT:??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@
	DQ	0000000000000000H
	ORG $+8
stat_result_desc DQ FLAT:??_C@_0M@ENKKEMPE@stat_result?$AA@
	DQ	FLAT:stat_result__doc__
	DQ	FLAT:stat_result_fields
	DD	0aH
	ORG $+4
statvfs_result__doc__ DB 'statvfs_result: Result from statvfs or fstatvfs'
	DB	'.', 0aH, 0aH, 'This object may be accessed either as a tuple '
	DB	'of', 0aH, '  (bsize, frsize, blocks, bfree, bavail, files, ff'
	DB	'ree, favail, flag, namemax),', 0aH, 'or via the attributes f_'
	DB	'bsize, f_frsize, f_blocks, f_bfree, and so on.', 0aH, 0aH, 'S'
	DB	'ee os.statvfs for more information.', 00H
	ORG $+1
statvfs_result_fields DQ FLAT:??_C@_07KFEIOOFH@f_bsize?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08KNLFHHPC@f_frsize?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08KLPHNGHN@f_blocks?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07JNCKMCHG@f_bfree?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08BOEOCCCL@f_bavail?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07CILFICMK@f_files?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07GLLIAGA@f_ffree?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08OKABAGDI@f_favail?$AA@
	ORG $+8
	DQ	FLAT:??_C@_06HDAGHFFN@f_flag?$AA@
	ORG $+8
	DQ	FLAT:??_C@_09HMAABEP@f_namemax?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+8
statvfs_result_desc DQ FLAT:??_C@_0P@HMGCCANC@statvfs_result?$AA@
	DQ	FLAT:statvfs_result__doc__
	DQ	FLAT:statvfs_result_fields
	DD	0aH
	ORG $+4
_stat_float_times DD 01H
	ORG $+12
stat_float_times__doc__ DB 'stat_float_times([newval]) -> oldval', 0aH, 0aH
	DB	'Determine whether os.[lf]stat represents time stamps as float'
	DB	' objects.', 0aH, 'If newval is True, future calls to stat() r'
	DB	'eturn floats, if it is False,', 0aH, 'future calls return int'
	DB	's. ', 0aH, 'If newval is omitted, return the current setting.'
	DB	0aH, 00H
	ORG $+12
posix_stat__doc__ DB 'stat(path, *, dir_fd=None, follow_symlinks=True) ->'
	DB	' stat result', 0aH, 0aH, 'Perform a stat system call on the g'
	DB	'iven path.', 0aH, 0aH, 'path may be specified as either a str'
	DB	'ing or as an open file descriptor.', 0aH, 0aH, 'If dir_fd is '
	DB	'not None, it should be a file descriptor open to a directory,'
	DB	0aH, '  and path should be relative; path will then be relativ'
	DB	'e to that directory.', 0aH, '  dir_fd may not be supported on'
	DB	' your platform; if it is unavailable, using', 0aH, '  it will'
	DB	' raise a NotImplementedError.', 0aH, 'If follow_symlinks is F'
	DB	'alse, and the last element of the path is a symbolic', 0aH, ' '
	DB	' link, stat will examine the symbolic link itself instead of '
	DB	'the file the', 0aH, '  link points to.', 0aH, 'It is an error'
	DB	' to use dir_fd or follow_symlinks when specifying path as', 0aH
	DB	'  an open file descriptor.', 00H
?keywords@?1??posix_stat@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_stat'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
posix_lstat__doc__ DB 'lstat(path, *, dir_fd=None) -> stat result', 0aH, 0aH
	DB	'Like stat(), but do not follow symbolic links.', 0aH, 'Equiva'
	DB	'lent to stat(path, follow_symlinks=False).', 00H
	ORG $+4
?keywords@?1??posix_lstat@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_lstat'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_access__doc__ DB 'access(path, mode, *, dir_fd=None, effective_ids='
	DB	'False, follow_symlinks=True)', 0aH, 0aH, 'Use the real uid/gi'
	DB	'd to test for access to a path.  Returns True if granted,', 0aH
	DB	'False otherwise.', 0aH, 0aH, 'If dir_fd is not None, it shoul'
	DB	'd be a file descriptor open to a directory,', 0aH, '  and pat'
	DB	'h should be relative; path will then be relative to that dire'
	DB	'ctory.', 0aH, 'If effective_ids is True, access will use the '
	DB	'effective uid/gid instead of', 0aH, '  the real uid/gid.', 0aH
	DB	'If follow_symlinks is False, and the last element of the path'
	DB	' is a symbolic', 0aH, '  link, access will examine the symbol'
	DB	'ic link itself instead of the file the', 0aH, '  link points '
	DB	'to.', 0aH, 'dir_fd, effective_ids, and follow_symlinks may no'
	DB	't be implemented', 0aH, '  on your platform.  If they are una'
	DB	'vailable, using them will raise a', 0aH, '  NotImplementedErr'
	DB	'or.', 0aH, 0aH, 'Note that most operations will use the effec'
	DB	'tive uid/gid, therefore this', 0aH, '  routine can be used in'
	DB	' a suid/sgid environment to test if the invoking user', 0aH, ' '
	DB	' has the specified access to the path.', 0aH, 'The mode argum'
	DB	'ent can be F_OK to test existence, or the inclusive-OR', 0aH, ' '
	DB	' of R_OK, W_OK, and X_OK.', 00H
	ORG $+1
?keywords@?1??posix_access@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_access'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0O@FGNLNFPF@effective_ids?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
posix_chdir__doc__ DB 'chdir(path)', 0aH, 0aH, 'Change the current workin'
	DB	'g directory to the specified path.', 0aH, 0aH, 'path may alwa'
	DB	'ys be specified as a string.', 0aH, 'On some platforms, path '
	DB	'may also be specified as an open file descriptor.', 0aH, '  I'
	DB	'f this functionality is unavailable, using it raises an excep'
	DB	'tion.', 00H
	ORG $+4
?keywords@?1??posix_chdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_chdir'::`2'::keywords
	DQ	0000000000000000H
	ORG $+8
posix_chmod__doc__ DB 'chmod(path, mode, *, dir_fd=None, follow_symlinks='
	DB	'True)', 0aH, 0aH, 'Change the access permissions of a file.', 0aH
	DB	0aH, 'path may always be specified as a string.', 0aH, 'On som'
	DB	'e platforms, path may also be specified as an open file descr'
	DB	'iptor.', 0aH, '  If this functionality is unavailable, using '
	DB	'it raises an exception.', 0aH, 'If dir_fd is not None, it sho'
	DB	'uld be a file descriptor open to a directory,', 0aH, '  and p'
	DB	'ath should be relative; path will then be relative to that di'
	DB	'rectory.', 0aH, 'If follow_symlinks is False, and the last el'
	DB	'ement of the path is a symbolic', 0aH, '  link, chmod will mo'
	DB	'dify the symbolic link itself instead of the file the', 0aH, ' '
	DB	' link points to.', 0aH, 'It is an error to use dir_fd or foll'
	DB	'ow_symlinks when specifying path as', 0aH, '  an open file de'
	DB	'scriptor.', 0aH, 'dir_fd and follow_symlinks may not be imple'
	DB	'mented on your platform.', 0aH, '  If they are unavailable, u'
	DB	'sing them will raise a NotImplementedError.', 00H
	ORG $+3
?keywords@?1??posix_chmod@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_chmod'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_fsync__doc__ DB 'fsync(fildes)', 0aH, 0aH, 'force write of file wit'
	DB	'h filedescriptor to disk.', 00H
posix_getcwd__doc__ DB 'getcwd() -> path', 0aH, 0aH, 'Return a unicode st'
	DB	'ring representing the current working directory.', 00H
	ORG $+10
posix_getcwdb__doc__ DB 'getcwdb() -> path', 0aH, 0aH, 'Return a bytes st'
	DB	'ring representing the current working directory.', 00H
	ORG $+11
posix_link__doc__ DB 'link(src, dst, *, src_dir_fd=None, dst_dir_fd=None,'
	DB	' follow_symlinks=True)', 0aH, 0aH, 'Create a hard link to a f'
	DB	'ile.', 0aH, 0aH, 'If either src_dir_fd or dst_dir_fd is not N'
	DB	'one, it should be a file', 0aH, '  descriptor open to a direc'
	DB	'tory, and the respective path string (src or dst)', 0aH, '  s'
	DB	'hould be relative; the path will then be relative to that dir'
	DB	'ectory.', 0aH, 'If follow_symlinks is False, and the last ele'
	DB	'ment of src is a symbolic', 0aH, '  link, link will create a '
	DB	'link to the symbolic link itself instead of the', 0aH, '  fil'
	DB	'e the link points to.', 0aH, 'src_dir_fd, dst_dir_fd, and fol'
	DB	'low_symlinks may not be implemented on your', 0aH, '  platfor'
	DB	'm.  If they are unavailable, using them will raise a', 0aH, ' '
	DB	' NotImplementedError.', 00H
	ORG $+7
?keywords@?1??posix_link@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `posix_link'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
	DQ	FLAT:??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_listdir__doc__ DB 'listdir(path=''.'') -> list_of_filenames', 0aH, 0aH
	DB	'Return a list containing the names of the files in the direct'
	DB	'ory.', 0aH, 'The list is in arbitrary order.  It does not inc'
	DB	'lude the special', 0aH, 'entries ''.'' and ''..'' even if the'
	DB	'y are present in the directory.', 0aH, 0aH, 'path can be spec'
	DB	'ified as either str or bytes.  If path is bytes,', 0aH, '  th'
	DB	'e filenames returned will also be bytes; in all other circums'
	DB	'tances', 0aH, '  the filenames returned will be str.', 0aH, 'O'
	DB	'n some platforms, path may also be specified as an open file '
	DB	'descriptor;', 0aH, '  the file descriptor must refer to a dir'
	DB	'ectory.', 0aH, '  If this functionality is unavailable, using'
	DB	' it raises NotImplementedError.', 00H
	ORG $+5
?keywords@?1??posix_listdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_listdir'::`2'::keywords
	DQ	0000000000000000H
posix__isdir__doc__ DB 'Return true if the pathname refers to an existing'
	DB	' directory.', 00H
	ORG $+11
posix_mkdir__doc__ DB 'mkdir(path, mode=0o777, *, dir_fd=None)', 0aH, 0aH
	DB	'Create a directory.', 0aH, 0aH, 'If dir_fd is not None, it sh'
	DB	'ould be a file descriptor open to a directory,', 0aH, '  and '
	DB	'path should be relative; path will then be relative to that d'
	DB	'irectory.', 0aH, 'dir_fd may not be implemented on your platf'
	DB	'orm.', 0aH, '  If it is unavailable, using it will raise a No'
	DB	'tImplementedError.', 0aH, 0aH, 'The mode argument is ignored '
	DB	'on Windows.', 00H
	ORG $+5
?keywords@?1??posix_mkdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_mkdir'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
?keywords@?1??internal_rename@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `internal_rename'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
	DQ	FLAT:??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
	DQ	0000000000000000H
posix_rename__doc__ DB 'rename(src, dst, *, src_dir_fd=None, dst_dir_fd=N'
	DB	'one)', 0aH, 0aH, 'Rename a file or directory.', 0aH, 0aH, 'If'
	DB	' either src_dir_fd or dst_dir_fd is not None, it should be a '
	DB	'file', 0aH, '  descriptor open to a directory, and the respec'
	DB	'tive path string (src or dst)', 0aH, '  should be relative; t'
	DB	'he path will then be relative to that directory.', 0aH, 'src_'
	DB	'dir_fd and dst_dir_fd, may not be implemented on your platfor'
	DB	'm.', 0aH, '  If they are unavailable, using them will raise a'
	DB	' NotImplementedError.', 00H
	ORG $+6
posix_replace__doc__ DB 'replace(src, dst, *, src_dir_fd=None, dst_dir_fd'
	DB	'=None)', 0aH, 0aH, 'Rename a file or directory, overwriting t'
	DB	'he destination.', 0aH, 0aH, 'If either src_dir_fd or dst_dir_'
	DB	'fd is not None, it should be a file', 0aH, '  descriptor open'
	DB	' to a directory, and the respective path string (src or dst)', 0aH
	DB	'  should be relative; the path will then be relative to that '
	DB	'directory.', 0aH, 'src_dir_fd and dst_dir_fd, may not be impl'
	DB	'emented on your platform.', 0aH, '  If they are unavailable, '
	DB	'using them will raise a NotImplementedError.', 00H
	ORG $+8
posix_rmdir__doc__ DB 'rmdir(path, *, dir_fd=None)', 0aH, 0aH, 'Remove a '
	DB	'directory.', 0aH, 0aH, 'If dir_fd is not None, it should be a'
	DB	' file descriptor open to a directory,', 0aH, '  and path shou'
	DB	'ld be relative; path will then be relative to that directory.'
	DB	0aH, 'dir_fd may not be implemented on your platform.', 0aH, ' '
	DB	' If it is unavailable, using it will raise a NotImplementedEr'
	DB	'ror.', 00H
	ORG $+3
?keywords@?1??posix_rmdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_rmdir'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_system__doc__ DB 'system(command) -> exit_status', 0aH, 0aH, 'Execu'
	DB	'te the command (a string) in a subshell.', 00H
	ORG $+2
posix_umask__doc__ DB 'umask(new_mask) -> old_mask', 0aH, 0aH, 'Set the c'
	DB	'urrent numeric umask and return the previous umask.', 00H
	ORG $+6
posix_unlink__doc__ DB 'unlink(path, *, dir_fd=None)', 0aH, 0aH, 'Remove '
	DB	'a file (same as remove()).', 0aH, 0aH, 'If dir_fd is not None'
	DB	', it should be a file descriptor open to a directory,', 0aH, ' '
	DB	' and path should be relative; path will then be relative to t'
	DB	'hat directory.', 0aH, 'dir_fd may not be implemented on your '
	DB	'platform.', 0aH, '  If it is unavailable, using it will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+4
posix_remove__doc__ DB 'remove(path, *, dir_fd=None)', 0aH, 0aH, 'Remove '
	DB	'a file (same as unlink()).', 0aH, 0aH, 'If dir_fd is not None'
	DB	', it should be a file descriptor open to a directory,', 0aH, ' '
	DB	' and path should be relative; path will then be relative to t'
	DB	'hat directory.', 0aH, 'dir_fd may not be implemented on your '
	DB	'platform.', 0aH, '  If it is unavailable, using it will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+4
?keywords@?1??posix_unlink@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_unlink'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_uname__doc__ DB 'uname() -> uname_result', 0aH, 0aH, 'Return an obj'
	DB	'ect identifying the current operating system.', 0aH, 'The obj'
	DB	'ect behaves like a named tuple with the following fields:', 0aH
	DB	'  (sysname, nodename, release, version, machine)', 00H
	ORG $+10
uname_result_fields DQ FLAT:??_C@_07LBFJMCKJ@sysname?$AA@
	DQ	FLAT:??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@
	DQ	FLAT:??_C@_08FOEBGLLE@nodename?$AA@
	DQ	FLAT:??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@
	DQ	FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@
	DQ	FLAT:??_C@_07CPCPJPKL@version?$AA@
	DQ	FLAT:??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@
	DQ	FLAT:??_C@_07MHDNFCJE@machine?$AA@
	DQ	FLAT:??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@
	DQ	0000000000000000H
	ORG $+8
uname_result__doc__ DB 'uname_result: Result from os.uname().', 0aH, 0aH, 'T'
	DB	'his object may be accessed either as a tuple of', 0aH, '  (sy'
	DB	'sname, nodename, release, version, machine),', 0aH, 'or via t'
	DB	'he attributes sysname, nodename, release, version, and machin'
	DB	'e.', 0aH, 0aH, 'See os.uname for more information.', 00H
	ORG $+2
uname_result_desc DQ FLAT:??_C@_0N@HCEBDBKJ@uname_result?$AA@
	DQ	FLAT:uname_result__doc__
	DQ	FLAT:uname_result_fields
	DD	05H
	ORG $+4
	ORG $+8
posix_utime__doc__ DB 'utime(path, times=None, *, ns=None, dir_fd=None, f'
	DB	'ollow_symlinks=True)', 0aH, 'Set the access and modified time'
	DB	' of path.', 0aH, 0aH, 'path may always be specified as a stri'
	DB	'ng.', 0aH, 'On some platforms, path may also be specified as '
	DB	'an open file descriptor.', 0aH, '  If this functionality is u'
	DB	'navailable, using it raises an exception.', 0aH, 0aH, 'If tim'
	DB	'es is not None, it must be a tuple (atime, mtime);', 0aH, '  '
	DB	'  atime and mtime should be expressed as float seconds since '
	DB	'the epoch.', 0aH, 'If ns is not None, it must be a tuple (ati'
	DB	'me_ns, mtime_ns);', 0aH, '    atime_ns and mtime_ns should be'
	DB	' expressed as integer nanoseconds', 0aH, '    since the epoch'
	DB	'.', 0aH, 'If both times and ns are None, utime uses the curre'
	DB	'nt time.', 0aH, 'Specifying tuples for both times and ns is a'
	DB	'n error.', 0aH, 0aH, 'If dir_fd is not None, it should be a f'
	DB	'ile descriptor open to a directory,', 0aH, '  and path should'
	DB	' be relative; path will then be relative to that directory.', 0aH
	DB	'If follow_symlinks is False, and the last element of the path'
	DB	' is a symbolic', 0aH, '  link, utime will modify the symbolic'
	DB	' link itself instead of the file the', 0aH, '  link points to'
	DB	'.', 0aH, 'It is an error to use dir_fd or follow_symlinks whe'
	DB	'n specifying path', 0aH, '  as an open file descriptor.', 0aH
	DB	'dir_fd and follow_symlinks may not be available on your platf'
	DB	'orm.', 0aH, '  If they are unavailable, using them will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+10
posix__exit__doc__ DB '_exit(status)', 0aH, 0aH, 'Exit to the system with'
	DB	' specified status, without normal exit processing.', 00H
	ORG $+7
posix_execv__doc__ DB 'execv(path, args)', 0aH, 0aH, 'Execute an executab'
	DB	'le path with arguments, replacing current process.', 0aH, 0aH
	DB	'    path: path of executable file', 0aH, '    args: tuple or '
	DB	'list of strings', 00H
	ORG $+1
posix_execve__doc__ DB 'execve(path, args, env)', 0aH, 0aH, 'Execute a pa'
	DB	'th with arguments and environment, replacing current process.'
	DB	0aH, 0aH, '    path: path of executable file', 0aH, '    args:'
	DB	' tuple or list of arguments', 0aH, '    env: dictionary of st'
	DB	'rings mapping to strings', 0aH, 0aH, 'On some platforms, you '
	DB	'may specify an open file descriptor for path;', 0aH, '  execv'
	DB	'e will execute the program the file descriptor is open to.', 0aH
	DB	'  If this functionality is unavailable, using it raises NotIm'
	DB	'plementedError.', 00H
	ORG $+6
?keywords@?1??posix_execve@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_execve'::`2'::keywords
	DQ	FLAT:??_C@_04GIEEDNNN@argv?$AA@
	DQ	FLAT:??_C@_0M@PINLHHEI@environment?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_spawnv__doc__ DB 'spawnv(mode, path, args)', 0aH, 0aH, 'Execute the'
	DB	' program ''path'' in a new process.', 0aH, 0aH, '    mode: mo'
	DB	'de of process creation', 0aH, '    path: path of executable f'
	DB	'ile', 0aH, '    args: tuple or list of strings', 00H
posix_spawnve__doc__ DB 'spawnve(mode, path, args, env)', 0aH, 0aH, 'Exec'
	DB	'ute the program ''path'' in a new process.', 0aH, 0aH, '    m'
	DB	'ode: mode of process creation', 0aH, '    path: path of execu'
	DB	'table file', 0aH, '    args: tuple or list of arguments', 0aH
	DB	'    env: dictionary of strings mapping to strings', 00H
	ORG $+6
posix_getpid__doc__ DB 'getpid() -> pid', 0aH, 0aH, 'Return the current p'
	DB	'rocess id', 00H
	ORG $+1
posix_getppid__doc__ DB 'getppid() -> ppid', 0aH, 0aH, 'Return the parent'
	DB	'''s process id.  If the parent process has already exited,', 0aH
	DB	'Windows machines will still return its id; others systems wil'
	DB	'l return the id', 0aH, 'of the ''init'' process (1).', 00H
	ORG $+2
posix_getlogin__doc__ DB 'getlogin() -> string', 0aH, 0aH, 'Return the ac'
	DB	'tual login name.', 00H
	ORG $+4
win32_kill__doc__ DB 'kill(pid, sig)', 0aH, 0aH, 'Kill a process with a s'
	DB	'ignal.', 00H
	ORG $+2
posix_waitpid__doc__ DB 'waitpid(pid, options) -> (pid, status << 8)', 0aH
	DB	0aH, 'Wait for completion of a given process.  options is igno'
	DB	'red on Windows.', 00H
	ORG $+11
readlink__doc__ DB 'readlink(path, *, dir_fd=None) -> path', 0aH, 0aH, 'R'
	DB	'eturn a string representing the path to which the symbolic li'
	DB	'nk points.', 0aH, 0aH, 'If dir_fd is not None, it should be a'
	DB	' file descriptor open to a directory,', 0aH, '  and path shou'
	DB	'ld be relative; path will then be relative to that directory.'
	DB	0aH, 'dir_fd may not be implemented on your platform.', 0aH, ' '
	DB	' If it is unavailable, using it will raise a NotImplementedEr'
	DB	'ror.', 00H
	ORG $+3
posix_symlink__doc__ DB 'symlink(src, dst, target_is_directory=False, *, '
	DB	'dir_fd=None)', 0aH, 0aH, 'Create a symbolic link pointing to '
	DB	'src named dst.', 0aH, 0aH, 'target_is_directory is required o'
	DB	'n Windows if the target is to be', 0aH, '  interpreted as a d'
	DB	'irectory.  (On Windows, symlink requires', 0aH, '  Windows 6.'
	DB	'0 or greater, and raises a NotImplementedError otherwise.)', 0aH
	DB	'  target_is_directory is ignored on non-Windows platforms.', 0aH
	DB	0aH, 'If dir_fd is not None, it should be a file descriptor op'
	DB	'en to a directory,', 0aH, '  and path should be relative; pat'
	DB	'h will then be relative to that directory.', 0aH, 'dir_fd may'
	DB	' not be implemented on your platform.', 0aH, '  If it is unav'
	DB	'ailable, using it will raise a NotImplementedError.', 00H
	ORG $+2
?keywords@?1??posix_symlink@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `posix_symlink'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
?keywords@?1??win_readlink@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `win_readlink'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
times_result_fields DQ FLAT:??_C@_04CCHAHKJA@user?$AA@
	DQ	FLAT:??_C@_09DDJCHFLJ@user?5time?$AA@
	DQ	FLAT:??_C@_06FHFOAHML@system?$AA@
	DQ	FLAT:??_C@_0M@IFJPBFHL@system?5time?$AA@
	DQ	FLAT:??_C@_0O@MGJDGJPB@children_user?$AA@
	DQ	FLAT:??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@
	DQ	FLAT:??_C@_0BA@KPAGPIBA@children_system?$AA@
	DQ	FLAT:??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@
	DQ	FLAT:??_C@_07ECLNDMPC@elapsed?$AA@
	DQ	FLAT:??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@
	DQ	0000000000000000H
	ORG $+8
times_result__doc__ DB 'times_result: Result from os.times().', 0aH, 0aH, 'T'
	DB	'his object may be accessed either as a tuple of', 0aH, '  (us'
	DB	'er, system, children_user, children_system, elapsed),', 0aH, 'o'
	DB	'r via the attributes user, system, children_user, children_sy'
	DB	'stem,', 0aH, 'and elapsed.', 0aH, 0aH, 'See os.times for more'
	DB	' information.', 00H
times_result_desc DQ FLAT:??_C@_0N@BNFIOIGL@times_result?$AA@
	DQ	FLAT:times_result__doc__
	DQ	FLAT:times_result_fields
	DD	05H
	ORG $+4
	ORG $+8
posix_times__doc__ DB 'times() -> times_result', 0aH, 0aH, 'Return an obj'
	DB	'ect containing floating point numbers indicating process', 0aH
	DB	'times.  The object behaves like a named tuple with these fiel'
	DB	'ds:', 0aH, '  (utime, stime, cutime, cstime, elapsed_time)', 00H
	ORG $+1
posix_open__doc__ DB 'open(path, flags, mode=0o777, *, dir_fd=None)', 0aH
	DB	0aH, 'Open a file for low level IO.  Returns a file handle (in'
	DB	'teger).', 0aH, 0aH, 'If dir_fd is not None, it should be a fi'
	DB	'le descriptor open to a directory,', 0aH, '  and path should '
	DB	'be relative; path will then be relative to that directory.', 0aH
	DB	'dir_fd may not be implemented on your platform.', 0aH, '  If '
	DB	'it is unavailable, using it will raise a NotImplementedError.'
	DB	00H
	ORG $+5
?keywords@?1??posix_open@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_open'::`2'::keywords
	DQ	FLAT:??_C@_05GECEPKB@flags?$AA@
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
posix_close__doc__ DB 'close(fd)', 0aH, 0aH, 'Close a file descriptor (fo'
	DB	'r low level IO).', 00H
	ORG $+1
posix_closerange__doc__ DB 'closerange(fd_low, fd_high)', 0aH, 0aH, 'Clos'
	DB	'es all file descriptors in [fd_low, fd_high), ignoring errors'
	DB	'.', 00H
posix_dup__doc__ DB 'dup(fd) -> fd2', 0aH, 0aH, 'Return a duplicate of a '
	DB	'file descriptor.', 00H
	ORG $+7
posix_dup2__doc__ DB 'dup2(old_fd, new_fd)', 0aH, 0aH, 'Duplicate file de'
	DB	'scriptor.', 00H
	ORG $+15
posix_lseek__doc__ DB 'lseek(fd, pos, how) -> newpos', 0aH, 0aH, 'Set the'
	DB	' current position of a file descriptor.', 0aH, 'Return the ne'
	DB	'w cursor position in bytes, starting from the beginning.', 00H
	ORG $+4
posix_read__doc__ DB 'read(fd, buffersize) -> bytes', 0aH, 0aH, 'Read a f'
	DB	'ile descriptor.', 00H
	ORG $+1
posix_write__doc__ DB 'write(fd, data) -> byteswritten', 0aH, 0aH, 'Write'
	DB	' bytes to a file descriptor.', 00H
	ORG $+13
posix_fstat__doc__ DB 'fstat(fd) -> stat result', 0aH, 0aH, 'Like stat(),'
	DB	' but for an open file descriptor.', 0aH, 'Equivalent to stat('
	DB	'fd=fd).', 00H
	ORG $+13
posix_isatty__doc__ DB 'isatty(fd) -> bool', 0aH, 0aH, 'Return True if th'
	DB	'e file descriptor ''fd'' is an open file descriptor', 0aH, 'c'
	DB	'onnected to the slave end of a terminal.', 00H
	ORG $+7
posix_pipe__doc__ DB 'pipe() -> (read_end, write_end)', 0aH, 0aH, 'Create'
	DB	' a pipe.', 00H
posix_putenv__doc__ DB 'putenv(key, value)', 0aH, 0aH, 'Change or add an '
	DB	'environment variable.', 00H
	ORG $+13
posix_strerror__doc__ DB 'strerror(code) -> string', 0aH, 0aH, 'Translate'
	DB	' an error code to a message string.', 00H
	ORG $+9
win32__getdiskusage__doc__ DB '_getdiskusage(path) -> (total, free)', 0aH
	DB	0aH, 'Return disk usage statistics about the given path as (to'
	DB	'tal, free) tuple.', 00H
posix_abort__doc__ DB 'abort() -> does not return!', 0aH, 0aH, 'Abort the'
	DB	' interpreter immediately.  This ''dumps core'' or otherwise f'
	DB	'ails', 0aH, 'in the hardest way possible on the hosting opera'
	DB	'ting system.', 00H
	ORG $+13
win32_startfile__doc__ DB 'startfile(filepath [, operation]) - Start a fi'
	DB	'le with its associated', 0aH, 'application.', 0aH, 0aH, 'When'
	DB	' "operation" is not specified or "open", this acts like', 0aH
	DB	'double-clicking the file in Explorer, or giving the file name'
	DB	' as an', 0aH, 'argument to the DOS "start" command: the file '
	DB	'is opened with whatever', 0aH, 'application (if any) its exte'
	DB	'nsion is associated.', 0aH, 'When another "operation" is give'
	DB	'n, it specifies what should be done with', 0aH, 'the file.  A'
	DB	' typical operation is "print".', 0aH, 0aH, 'startfile returns'
	DB	' as soon as the associated application is launched.', 0aH, 'T'
	DB	'here is no option to wait for the application to close, and n'
	DB	'o way', 0aH, 'to retrieve the application''s exit status.', 0aH
	DB	0aH, 'The filepath is relative to the current directory.  If y'
	DB	'ou want to use', 0aH, 'an absolute path, make sure the first '
	DB	'character is not a slash ("/");', 0aH, 'the underlying Win32 '
	DB	'ShellExecute function doesn''t work if it is.', 00H
	ORG $+12
device_encoding__doc__ DB 'device_encoding(fd) -> str', 0aH, 0aH, 'Return'
	DB	' a string describing the encoding of the device', 0aH, 'if th'
	DB	'e output is a terminal; else return None.', 00H
	ORG $+15
posix_urandom__doc__ DB 'urandom(n) -> str', 0aH, 0aH, 'Return n random b'
	DB	'ytes suitable for cryptographic use.', 00H
	ORG $+7
TerminalSize_docstring DB 'A tuple of (columns, lines) for holding termin'
	DB	'al window size', 00H
	ORG $+3
TerminalSize_fields DQ FLAT:??_C@_07HIFEPIJN@columns?$AA@
	DQ	FLAT:??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@
	DQ	FLAT:??_C@_05DENOCHIP@lines?$AA@
	DQ	FLAT:??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@
	DQ	0000000000000000H
	DQ	0000000000000000H
TerminalSize_desc DQ FLAT:??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@
	DQ	FLAT:TerminalSize_docstring
	DQ	FLAT:TerminalSize_fields
	DD	02H
	ORG $+4
termsize__doc__ DB 'Return the size of the terminal window as (columns, l'
	DB	'ines).', 0aH, 0aH, 'The optional argument fd (default standar'
	DB	'd output) specifies', 0aH, 'which file descriptor should be q'
	DB	'ueried.', 0aH, 0aH, 'If the file descriptor is not connected '
	DB	'to a terminal, an OSError', 0aH, 'is thrown.', 0aH, 0aH, 'Thi'
	DB	's function will only be defined if an implementation is', 0aH
	DB	'available for this system.', 0aH, 0aH, 'shutil.get_terminal_s'
	DB	'ize is the high-level function which should ', 0aH, 'normally'
	DB	' be used, os.get_terminal_size is the low-level implementatio'
	DB	'n.', 00H
	ORG $+13
posix_methods DQ FLAT:??_C@_06EBPNOMLE@access?$AA@
	DQ	FLAT:posix_access
	DD	03H
	ORG $+4
	DQ	FLAT:posix_access__doc__
	DQ	FLAT:??_C@_05IHFEJEKL@chdir?$AA@
	DQ	FLAT:posix_chdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_chdir__doc__
	DQ	FLAT:??_C@_05OCEJBCEE@chmod?$AA@
	DQ	FLAT:posix_chmod
	DD	03H
	ORG $+4
	DQ	FLAT:posix_chmod__doc__
	DQ	FLAT:??_C@_06BFFACJH@getcwd?$AA@
	DQ	FLAT:posix_getcwd_unicode
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getcwd__doc__
	DQ	FLAT:??_C@_07DJKBFKMA@getcwdb?$AA@
	DQ	FLAT:posix_getcwd_bytes
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getcwdb__doc__
	DQ	FLAT:??_C@_04OHHBHOGB@link?$AA@
	DQ	FLAT:posix_link
	DD	03H
	ORG $+4
	DQ	FLAT:posix_link__doc__
	DQ	FLAT:??_C@_07GMBICOLL@listdir?$AA@
	DQ	FLAT:posix_listdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_listdir__doc__
	DQ	FLAT:??_C@_05GJGCCBEM@lstat?$AA@
	DQ	FLAT:posix_lstat
	DD	03H
	ORG $+4
	DQ	FLAT:posix_lstat__doc__
	DQ	FLAT:??_C@_05PKPOIPAL@mkdir?$AA@
	DQ	FLAT:posix_mkdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_mkdir__doc__
	DQ	FLAT:??_C@_08DPKANCED@readlink?$AA@
	DQ	FLAT:win_readlink
	DD	03H
	ORG $+4
	DQ	FLAT:readlink__doc__
	DQ	FLAT:??_C@_06LMEAOBLB@rename?$AA@
	DQ	FLAT:posix_rename
	DD	03H
	ORG $+4
	DQ	FLAT:posix_rename__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:posix_replace
	DD	03H
	ORG $+4
	DQ	FLAT:posix_replace__doc__
	DQ	FLAT:??_C@_05IHDOMKOF@rmdir?$AA@
	DQ	FLAT:posix_rmdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_rmdir__doc__
	DQ	FLAT:??_C@_04GBLELIND@stat?$AA@
	DQ	FLAT:posix_stat
	DD	03H
	ORG $+4
	DQ	FLAT:posix_stat__doc__
	DQ	FLAT:??_C@_0BB@KAJEHDMI@stat_float_times?$AA@
	DQ	FLAT:stat_float_times
	DD	01H
	ORG $+4
	DQ	FLAT:stat_float_times__doc__
	DQ	FLAT:??_C@_07KLDEEJBK@symlink?$AA@
	DQ	FLAT:posix_symlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_symlink__doc__
	DQ	FLAT:??_C@_06FHFOAHML@system?$AA@
	DQ	FLAT:posix_system
	DD	01H
	ORG $+4
	DQ	FLAT:posix_system__doc__
	DQ	FLAT:??_C@_05CHFEIFNB@umask?$AA@
	DQ	FLAT:posix_umask
	DD	01H
	ORG $+4
	DQ	FLAT:posix_umask__doc__
	DQ	FLAT:??_C@_06DAJBMHKE@unlink?$AA@
	DQ	FLAT:posix_unlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_unlink__doc__
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:posix_unlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_remove__doc__
	DQ	FLAT:??_C@_05HCLPLDJ@utime?$AA@
	DQ	FLAT:posix_utime
	DD	03H
	ORG $+4
	DQ	FLAT:posix_utime__doc__
	DQ	FLAT:??_C@_05MJOOAIJH@times?$AA@
	DQ	FLAT:posix_times
	DD	04H
	ORG $+4
	DQ	FLAT:posix_times__doc__
	DQ	FLAT:??_C@_05EAOJNIGN@_exit?$AA@
	DQ	FLAT:posix__exit
	DD	01H
	ORG $+4
	DQ	FLAT:posix__exit__doc__
	DQ	FLAT:??_C@_05OAKKMHID@execv?$AA@
	DQ	FLAT:posix_execv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_execv__doc__
	DQ	FLAT:??_C@_06GMNLOHLP@execve?$AA@
	DQ	FLAT:posix_execve
	DD	03H
	ORG $+4
	DQ	FLAT:posix_execve__doc__
	DQ	FLAT:??_C@_06NNKHBJHE@spawnv?$AA@
	DQ	FLAT:posix_spawnv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_spawnv__doc__
	DQ	FLAT:??_C@_07EPDPINNO@spawnve?$AA@
	DQ	FLAT:posix_spawnve
	DD	01H
	ORG $+4
	DQ	FLAT:posix_spawnve__doc__
	DQ	FLAT:??_C@_06FFEBHEJM@getpid?$AA@
	DQ	FLAT:posix_getpid
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getpid__doc__
	DQ	FLAT:??_C@_07NNLELLPO@getppid?$AA@
	DQ	FLAT:posix_getppid
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getppid__doc__
	DQ	FLAT:??_C@_08NPAFALFK@getlogin?$AA@
	DQ	FLAT:posix_getlogin
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getlogin__doc__
	DQ	FLAT:??_C@_09FCFKICPJ@startfile?$AA@
	DQ	FLAT:win32_startfile
	DD	01H
	ORG $+4
	DQ	FLAT:win32_startfile__doc__
	DQ	FLAT:??_C@_04BJJEOANI@kill?$AA@
	DQ	FLAT:win32_kill
	DD	01H
	ORG $+4
	DQ	FLAT:win32_kill__doc__
	DQ	FLAT:??_C@_07BPIIBJED@waitpid?$AA@
	DQ	FLAT:posix_waitpid
	DD	01H
	ORG $+4
	DQ	FLAT:posix_waitpid__doc__
	DQ	FLAT:??_C@_04PMOCAHAA@open?$AA@
	DQ	FLAT:posix_open
	DD	03H
	ORG $+4
	DQ	FLAT:posix_open__doc__
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:posix_close_
	DD	01H
	ORG $+4
	DQ	FLAT:posix_close__doc__
	DQ	FLAT:??_C@_0L@ICENNBNA@closerange?$AA@
	DQ	FLAT:posix_closerange
	DD	01H
	ORG $+4
	DQ	FLAT:posix_closerange__doc__
	DQ	FLAT:??_C@_0BA@PABGBABL@device_encoding?$AA@
	DQ	FLAT:device_encoding
	DD	01H
	ORG $+4
	DQ	FLAT:device_encoding__doc__
	DQ	FLAT:??_C@_03BHPKJDPK@dup?$AA@
	DQ	FLAT:posix_dup
	DD	01H
	ORG $+4
	DQ	FLAT:posix_dup__doc__
	DQ	FLAT:??_C@_04LAAPLFOA@dup2?$AA@
	DQ	FLAT:posix_dup2
	DD	01H
	ORG $+4
	DQ	FLAT:posix_dup2__doc__
	DQ	FLAT:??_C@_05ELJELHPE@lseek?$AA@
	DQ	FLAT:posix_lseek
	DD	01H
	ORG $+4
	DQ	FLAT:posix_lseek__doc__
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:posix_read
	DD	01H
	ORG $+4
	DQ	FLAT:posix_read__doc__
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:posix_write
	DD	01H
	ORG $+4
	DQ	FLAT:posix_write__doc__
	DQ	FLAT:??_C@_05MIPJACCK@fstat?$AA@
	DQ	FLAT:posix_fstat
	DD	01H
	ORG $+4
	DQ	FLAT:posix_fstat__doc__
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:posix_isatty
	DD	01H
	ORG $+4
	DQ	FLAT:posix_isatty__doc__
	DQ	FLAT:??_C@_04MKFKKHBG@pipe?$AA@
	DQ	FLAT:posix_pipe
	DD	04H
	ORG $+4
	DQ	FLAT:posix_pipe__doc__
	DQ	FLAT:??_C@_06OOJCBFLM@putenv?$AA@
	DQ	FLAT:posix_putenv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_putenv__doc__
	DQ	FLAT:??_C@_08MHKKJIBB@strerror?$AA@
	DQ	FLAT:posix_strerror
	DD	01H
	ORG $+4
	DQ	FLAT:posix_strerror__doc__
	DQ	FLAT:??_C@_05DEEMBJFM@fsync?$AA@
	DQ	FLAT:posix_fsync
	DD	08H
	ORG $+4
	DQ	FLAT:posix_fsync__doc__
	DQ	FLAT:??_C@_05BBAEEBBH@abort?$AA@
	DQ	FLAT:posix_abort
	DD	04H
	ORG $+4
	DQ	FLAT:posix_abort__doc__
	DQ	FLAT:??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@
	DQ	FLAT:posix__getfullpathname
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@
	DQ	FLAT:posix__getfinalpathname
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BE@FKJDANNK@_getfileinformation?$AA@
	DQ	FLAT:posix__getfileinformation
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06MIMMPGNN@_isdir?$AA@
	DQ	FLAT:posix__isdir
	DD	01H
	ORG $+4
	DQ	FLAT:posix__isdir__doc__
	DQ	FLAT:??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@
	DQ	FLAT:win32__getdiskusage
	DD	01H
	ORG $+4
	DQ	FLAT:win32__getdiskusage__doc__
	DQ	FLAT:??_C@_07MHKMJCBA@urandom?$AA@
	DQ	FLAT:posix_urandom
	DD	01H
	ORG $+4
	DQ	FLAT:posix_urandom__doc__
	DQ	FLAT:??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@
	DQ	FLAT:get_terminal_size
	DD	01H
	ORG $+4
	DQ	FLAT:termsize__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
posixmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_02JKEHMDF@nt?$AA@
	DQ	FLAT:posix__doc__
	DQ	ffffffffffffffffH
	DQ	FLAT:posix_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
have_functions DQ FLAT:??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
;	COMDAT ??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@
; File c:\src\pyparallel\modules\posixmodule.c
CONST	SEGMENT
??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@ DB 'The Window'
	DB	's bytes API has been deprecated, use Unicode filenames instea'
	DB	'd', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_warn_bytes_api
_TEXT	SEGMENT
win32_warn_bytes_api PROC				; COMDAT

; 411  :     return PyErr_WarnEx(PyExc_DeprecationWarning,
; 412  :         "The Windows bytes API has been deprecated, "
; 413  :         "use Unicode filenames instead",
; 414  :         1);

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@
  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1

; 415  : }

  00014	e9 00 00 00 00	 jmp	 PyErr_WarnEx
win32_warn_bytes_api ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@ ; `string'
PUBLIC	??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_AsLongAndOverflow:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_fd_converter DD imagerel _fd_converter
	DD	imagerel _fd_converter+226
	DD	imagerel $unwind$_fd_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_fd_converter DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@
CONST	SEGMENT
??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@ DB 'arg'
	DB	'ument should be %s, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ DB 'signed integ'
	DB	'er is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ DB 'signed inte'
	DB	'ger is less than minimum', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _fd_converter
_TEXT	SEGMENT
overflow$ = 48
o$ = 48
p$ = 56
allowed$ = 64
_fd_converter PROC					; COMDAT

; 561  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx

; 562  :     int overflow;
; 563  :     long long_value = PyLong_AsLongAndOverflow(o, &overflow);

  00017	48 8d 54 24 30	 lea	 rdx, QWORD PTR overflow$[rsp]
  0001c	49 8b e8	 mov	 rbp, r8
  0001f	48 8b f1	 mov	 rsi, rcx
  00022	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow

; 564  :     if (PyFloat_Check(o) ||
; 565  :         (long_value == -1 && !overflow && PyErr_Occurred())) {

  00027	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00032	8b d8		 mov	 ebx, eax
  00034	48 3b ca	 cmp	 rcx, rdx
  00037	74 6f		 je	 SHORT $LN5@fd_convert
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	75 66		 jne	 SHORT $LN5@fd_convert
  00042	83 fb ff	 cmp	 ebx, -1
  00045	75 12		 jne	 SHORT $LN9@fd_convert
  00047	8b 44 24 30	 mov	 eax, DWORD PTR overflow$[rsp]
  0004b	85 c0		 test	 eax, eax
  0004d	75 10		 jne	 SHORT $LN10@fd_convert
  0004f	e8 00 00 00 00	 call	 PyErr_Occurred
  00054	48 85 c0	 test	 rax, rax
  00057	75 4f		 jne	 SHORT $LN5@fd_convert
$LN9@fd_convert:
  00059	8b 44 24 30	 mov	 eax, DWORD PTR overflow$[rsp]

; 571  :     }
; 572  :     if (overflow > 0 || long_value > INT_MAX) {

  0005d	85 c0		 test	 eax, eax
$LN10@fd_convert:
  0005f	7f 32		 jg	 SHORT $LN3@fd_convert
  00061	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00067	7f 2a		 jg	 SHORT $LN3@fd_convert

; 576  :     }
; 577  :     if (overflow < 0 || long_value < INT_MIN) {

  00069	85 c0		 test	 eax, eax
  0006b	78 11		 js	 SHORT $LN1@fd_convert
  0006d	81 fb 00 00 00
	80		 cmp	 ebx, -2147483648	; ffffffff80000000H
  00073	7c 09		 jl	 SHORT $LN1@fd_convert

; 581  :     }
; 582  :     *p = (int)long_value;

  00075	89 1f		 mov	 DWORD PTR [rdi], ebx

; 583  :     return 1;

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	eb 4f		 jmp	 SHORT $LN7@fd_convert
$LN1@fd_convert:

; 578  :         PyErr_SetString(PyExc_OverflowError,
; 579  :                         "signed integer is less than minimum");

  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
  0008c	e8 00 00 00 00	 call	 PyErr_SetString

; 580  :         return 0;

  00091	eb 38		 jmp	 SHORT $LN11@fd_convert
$LN3@fd_convert:

; 573  :         PyErr_SetString(PyExc_OverflowError,
; 574  :                         "signed integer is greater than maximum");

  00093	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
  000a1	e8 00 00 00 00	 call	 PyErr_SetString

; 575  :         return 0;

  000a6	eb 23		 jmp	 SHORT $LN11@fd_convert
$LN5@fd_convert:

; 566  :         PyErr_Clear();

  000a8	e8 00 00 00 00	 call	 PyErr_Clear

; 567  :         PyErr_Format(PyExc_TypeError,
; 568  :                         "argument should be %s, not %.200s",
; 569  :                         allowed, Py_TYPE(o)->tp_name);

  000ad	4c 8b 4e 58	 mov	 r9, QWORD PTR [rsi+88]
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b8	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@
  000c3	4c 8b c5	 mov	 r8, rbp
  000c6	e8 00 00 00 00	 call	 PyErr_Format
$LN11@fd_convert:

; 570  :         return 0;

  000cb	33 c0		 xor	 eax, eax
$LN7@fd_convert:

; 584  : }

  000cd	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d2	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000d7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
_fd_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_07LKHFMGFB@integer?$AA@			; `string'
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT ??_C@_07LKHFMGFB@integer?$AA@
CONST	SEGMENT
??_C@_07LKHFMGFB@integer?$AA@ DB 'integer', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT dir_fd_converter
_TEXT	SEGMENT
o$ = 8
p$ = 16
dir_fd_converter PROC					; COMDAT

; 589  :     if (o == Py_None) {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00007	48 3b c8	 cmp	 rcx, rax
  0000a	75 0c		 jne	 SHORT $LN1@dir_fd_con

; 590  :         *(int *)p = DEFAULT_DIR_FD;

  0000c	c7 02 9c ff ff
	ff		 mov	 DWORD PTR [rdx], -100	; ffffffffffffff9cH

; 591  :         return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 594  : }

  00017	c3		 ret	 0
$LN1@dir_fd_con:

; 592  :     }
; 593  :     return _fd_converter(o, (int *)p, "integer");

  00018	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07LKHFMGFB@integer?$AA@

; 594  : }

  0001f	e9 00 00 00 00	 jmp	 _fd_converter
dir_fd_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@JAENBMGM@path_cleanup?$AA@		; `string'
PUBLIC	??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$path_cleanup DD imagerel path_cleanup
	DD	imagerel path_cleanup+63
	DD	imagerel $unwind$path_cleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$path_cleanup DD imagerel path_cleanup+63
	DD	imagerel path_cleanup+169
	DD	imagerel $chain$0$path_cleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$path_cleanup DD imagerel path_cleanup+169
	DD	imagerel path_cleanup+190
	DD	imagerel $chain$2$path_cleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$path_cleanup DD imagerel path_cleanup+190
	DD	imagerel path_cleanup+203
	DD	imagerel $chain$4$path_cleanup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$path_cleanup DD imagerel path_cleanup+203
	DD	imagerel path_cleanup+209
	DD	imagerel $chain$5$path_cleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$path_cleanup DD 021H
	DD	imagerel path_cleanup
	DD	imagerel path_cleanup+63
	DD	imagerel $unwind$path_cleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$path_cleanup DD 020021H
	DD	083400H
	DD	imagerel path_cleanup
	DD	imagerel path_cleanup+63
	DD	imagerel $unwind$path_cleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$path_cleanup DD 020021H
	DD	083400H
	DD	imagerel path_cleanup
	DD	imagerel path_cleanup+63
	DD	imagerel $unwind$path_cleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$path_cleanup DD 020521H
	DD	083405H
	DD	imagerel path_cleanup
	DD	imagerel path_cleanup+63
	DD	imagerel $unwind$path_cleanup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_cleanup DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0N@JAENBMGM@path_cleanup?$AA@
CONST	SEGMENT
??_C@_0N@JAENBMGM@path_cleanup?$AA@ DB 'path_cleanup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@ DB '..\Modules\posi'
	DB	'xmodule.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT path_cleanup
_TEXT	SEGMENT
path$ = 64
path_cleanup PROC					; COMDAT

; 694  : path_cleanup(path_t *path) {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 695  :     if (path->cleanup) {

  00006	4c 8b 49 40	 mov	 r9, QWORD PTR [rcx+64]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 b5 00 00
	00		 je	 $LN2@path_clean

; 696  :         Py_CLEAR(path->cleanup);

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JAENBMGM@path_cleanup?$AA@
  00024	41 b8 b8 02 00
	00		 mov	 r8d, 696		; 000002b8H
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	0f 85 8c 00 00
	00		 jne	 $LN2@path_clean
  0003f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00044	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]
  00048	48 c7 47 40 00
	00 00 00	 mov	 QWORD PTR [rdi+64], 0
  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	75 6d		 jne	 SHORT $LN19@path_clean
  00059	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005d	a8 20		 test	 al, 32			; 00000020H
  0005f	75 5d		 jne	 SHORT $LN12@path_clean
  00061	84 c0		 test	 al, al
  00063	78 59		 js	 SHORT $LN12@path_clean
  00065	a8 02		 test	 al, 2
  00067	75 5d		 jne	 SHORT $LN19@path_clean
  00069	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006d	75 57		 jne	 SHORT $LN19@path_clean
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007d	4c 8b cb	 mov	 r9, rbx
  00080	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	48 8b cb	 mov	 rcx, rbx
  00096	85 c0		 test	 eax, eax
  00098	74 0f		 je	 SHORT $LN17@path_clean
  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 697  :     }
; 698  : }

  0009f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a3	5f		 pop	 rdi
  000a4	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 696  :         Py_CLEAR(path->cleanup);

$LN17@path_clean:
  000a9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 697  :     }
; 698  : }

  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 696  :         Py_CLEAR(path->cleanup);

$LN12@path_clean:
  000be	48 8b cb	 mov	 rcx, rbx
  000c1	e8 00 00 00 00	 call	 Px_DecRef
$LN19@path_clean:
  000c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN2@path_clean:

; 697  :     }
; 698  : }

  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
path_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@ ; `string'
PUBLIC	??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@ ; `string'
PUBLIC	??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@ ; `string'
PUBLIC	??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@ ; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyBytes_FromObject:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	PyUnicode_FromObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_converter DD imagerel path_converter
	DD	imagerel path_converter+43
	DD	imagerel $unwind$path_converter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$path_converter DD imagerel path_converter+43
	DD	imagerel path_converter+157
	DD	imagerel $chain$0$path_converter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$path_converter DD imagerel path_converter+157
	DD	imagerel path_converter+197
	DD	imagerel $chain$2$path_converter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$path_converter DD imagerel path_converter+197
	DD	imagerel path_converter+901
	DD	imagerel $chain$6$path_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$path_converter DD 060a21H
	DD	0c740aH
	DD	0b5405H
	DD	06c400H
	DD	imagerel path_converter
	DD	imagerel path_converter+43
	DD	imagerel $unwind$path_converter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$path_converter DD 020021H
	DD	06c400H
	DD	imagerel path_converter
	DD	imagerel path_converter+43
	DD	imagerel $unwind$path_converter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$path_converter DD 020521H
	DD	06c405H
	DD	imagerel path_converter
	DD	imagerel path_converter+43
	DD	imagerel $unwind$path_converter
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_converter DD 030701H
	DD	060036207H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@
CONST	SEGMENT
??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@ DB '%s%'
	DB	'sillegal type for %s parameter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@
CONST	SEGMENT
??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@ DB 'string, bytes or'
	DB	' integer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@ DB '%s%s'
	DB	'embedded NUL character in %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
CONST	SEGMENT
??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@ DB '%s%s'
	DB	'%s too long for Windows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@
CONST	SEGMENT
??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@ DB '%'
	DB	's%scan''t specify None for %s argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT path_converter
_TEXT	SEGMENT
fd$121010 = 80
o$ = 80
p$ = 88
path_converter PROC					; COMDAT

; 701  : path_converter(PyObject *o, void *p) {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00007	48 8b da	 mov	 rbx, rdx
  0000a	48 8b f1	 mov	 rsi, rcx

; 702  :     path_t *path = (path_t *)p;
; 703  :     PyObject *unicode, *bytes;
; 704  :     Py_ssize_t length;
; 705  :     char *narrow;
; 706  : 
; 707  : #define FORMAT_EXCEPTION(exc, fmt) \
; 708  :     PyErr_Format(exc, "%s%s" fmt, \
; 709  :         path->function_name ? path->function_name : "", \
; 710  :         path->function_name ? ": "                : "", \
; 711  :         path->argument_name ? path->argument_name : "path")
; 712  : 
; 713  :     /* Py_CLEANUP_SUPPORTED support */
; 714  :     if (o == NULL) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	75 12		 jne	 SHORT $LN17@path_conve

; 715  :         path_cleanup(path);

  00012	48 8b ca	 mov	 rcx, rdx
  00015	e8 00 00 00 00	 call	 path_cleanup

; 716  :         return 1;

  0001a	8d 46 01	 lea	 eax, QWORD PTR [rsi+1]

; 827  : }

  0001d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00021	5e		 pop	 rsi
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN17@path_conve:

; 717  :     }
; 718  : 
; 719  :     /* ensure it's always safe to call path_cleanup() */
; 720  :     path->cleanup = NULL;
; 721  : 
; 722  :     if (o == Py_None) {

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002b	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00030	45 33 e4	 xor	 r12d, r12d
  00033	4c 89 62 40	 mov	 QWORD PTR [rdx+64], r12
  00037	48 3b c8	 cmp	 rcx, rax
  0003a	0f 85 85 00 00
	00		 jne	 $LN16@path_conve

; 723  :         if (!path->nullable) {

  00040	44 39 62 10	 cmp	 DWORD PTR [rdx+16], r12d
  00044	75 57		 jne	 SHORT $LN15@path_conve

; 724  :             FORMAT_EXCEPTION(PyExc_TypeError,
; 725  :                              "can't specify None for %s argument");

  00046	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00058	48 85 c0	 test	 rax, rax
  0005b	4d 8b c1	 mov	 r8, r9
  0005e	48 0f 45 c8	 cmovne	 rcx, rax
  00062	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  0006c	48 85 c0	 test	 rax, rax
  0006f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007b	4c 0f 45 ca	 cmovne	 r9, rdx
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@
  00086	4c 0f 45 c0	 cmovne	 r8, rax
  0008a	e8 00 00 00 00	 call	 PyErr_Format
  0008f	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 726  :             return 0;

  00094	33 c0		 xor	 eax, eax

; 827  : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	5e		 pop	 rsi
  0009b	5b		 pop	 rbx
  0009c	c3		 ret	 0
$LN15@path_conve:

; 727  :         }
; 728  :         path->wide = NULL;

  0009d	4c 89 62 18	 mov	 QWORD PTR [rdx+24], r12

; 729  :         path->narrow = NULL;

  000a1	4c 89 62 20	 mov	 QWORD PTR [rdx+32], r12

; 730  :         path->length = 0;

  000a5	4c 89 62 30	 mov	 QWORD PTR [rdx+48], r12
  000a9	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 731  :         path->object = o;

  000ae	48 89 4a 38	 mov	 QWORD PTR [rdx+56], rcx

; 732  :         path->fd = -1;

  000b2	c7 42 28 ff ff
	ff ff		 mov	 DWORD PTR [rdx+40], -1

; 733  :         return 1;

  000b9	b8 01 00 00 00	 mov	 eax, 1

; 827  : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	5e		 pop	 rsi
  000c3	5b		 pop	 rbx
  000c4	c3		 ret	 0
$LN16@path_conve:
  000c5	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  000ca	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 734  :     }
; 735  : 
; 736  :     unicode = PyUnicode_FromObject(o);

  000cf	e8 00 00 00 00	 call	 PyUnicode_FromObject
  000d4	48 8b f8	 mov	 rdi, rax

; 737  :     if (unicode) {

  000d7	48 85 c0	 test	 rax, rax
  000da	0f 84 c7 00 00
	00		 je	 $LN14@path_conve

; 738  : #ifdef MS_WINDOWS
; 739  :         wchar_t *wide;
; 740  :         length = PyUnicode_GET_SIZE(unicode);

  000e0	4c 39 60 78	 cmp	 QWORD PTR [rax+120], r12
  000e4	74 0b		 je	 SHORT $LN28@path_conve
  000e6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e9	a8 40		 test	 al, 64			; 00000040H
  000eb	74 22		 je	 SHORT $LN26@path_conve
  000ed	a8 20		 test	 al, 32			; 00000020H
  000ef	eb 16		 jmp	 SHORT $LN52@path_conve
$LN28@path_conve:
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  000f9	44 8b 5f 70	 mov	 r11d, DWORD PTR [rdi+112]
  000fd	41 f6 c3 40	 test	 r11b, 64		; 00000040H
  00101	74 0c		 je	 SHORT $LN26@path_conve
  00103	41 f6 c3 20	 test	 r11b, 32		; 00000020H
$LN52@path_conve:
  00107	74 06		 je	 SHORT $LN26@path_conve
  00109	48 8b 6f 60	 mov	 rbp, QWORD PTR [rdi+96]
  0010d	eb 07		 jmp	 SHORT $LN27@path_conve
$LN26@path_conve:
  0010f	48 8b af 90 00
	00 00		 mov	 rbp, QWORD PTR [rdi+144]
$LN27@path_conve:

; 741  :         if (length > 32767) {

  00116	48 81 fd ff 7f
	00 00		 cmp	 rbp, 32767		; 00007fffH
  0011d	7e 56		 jle	 SHORT $LN13@path_conve

; 742  :             FORMAT_EXCEPTION(PyExc_ValueError, "%s too long for Windows");

  0011f	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00123	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00131	48 85 c0	 test	 rax, rax
  00134	4d 8b c1	 mov	 r8, r9
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  0013e	48 0f 45 c8	 cmovne	 rcx, rax
  00142	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00145	48 85 c0	 test	 rax, rax
  00148	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00154	4c 0f 45 ca	 cmovne	 r9, rdx
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
  0015f	4c 0f 45 c0	 cmovne	 r8, rax
  00163	e8 00 00 00 00	 call	 PyErr_Format
$LN53@path_conve:

; 743  :             Py_DECREF(unicode);

  00168	48 8b cf	 mov	 rcx, rdi
  0016b	e8 00 00 00 00	 call	 _Py_DecRef

; 744  :             return 0;

  00170	e9 f8 01 00 00	 jmp	 $LN4@path_conve
$LN13@path_conve:

; 745  :         }
; 746  : 
; 747  :         wide = PyUnicode_AsUnicode(unicode);

  00175	48 8b cf	 mov	 rcx, rdi
  00178	e8 00 00 00 00	 call	 PyUnicode_AsUnicode

; 748  :         if (!wide) {

  0017d	48 85 c0	 test	 rax, rax

; 749  :             Py_DECREF(unicode);
; 750  :             return 0;

  00180	74 e6		 je	 SHORT $LN53@path_conve

; 751  :         }
; 752  : 
; 753  :         path->wide = wide;

  00182	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 754  :         path->narrow = NULL;

  00186	4c 89 63 20	 mov	 QWORD PTR [rbx+32], r12

; 755  :         path->length = length;

  0018a	48 89 6b 30	 mov	 QWORD PTR [rbx+48], rbp

; 756  :         path->object = o;
; 757  :         path->fd = -1;
; 758  :         path->cleanup = unicode;
; 759  :         return Py_CLEANUP_SUPPORTED;

  0018e	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  00193	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi
  00197	c7 43 28 ff ff
	ff ff		 mov	 DWORD PTR [rbx+40], -1
  0019e	48 89 7b 40	 mov	 QWORD PTR [rbx+64], rdi
  001a2	e9 c8 01 00 00	 jmp	 $LN50@path_conve
$LN14@path_conve:

; 760  : #else
; 761  :         int converted = PyUnicode_FSConverter(unicode, &bytes);
; 762  :         Py_DECREF(unicode);
; 763  :         if (!converted)
; 764  :             bytes = NULL;
; 765  : #endif
; 766  :     }
; 767  :     else {
; 768  :         PyErr_Clear();

  001a7	e8 00 00 00 00	 call	 PyErr_Clear

; 769  :         if (PyObject_CheckBuffer(o))

  001ac	48 8b 56 58	 mov	 rdx, QWORD PTR [rsi+88]
  001b0	48 8b 82 f8 00
	00 00		 mov	 rax, QWORD PTR [rdx+248]
  001b7	48 85 c0	 test	 rax, rax
  001ba	0f 84 1e 01 00
	00		 je	 $LN46@path_conve
  001c0	4c 39 20	 cmp	 QWORD PTR [rax], r12
  001c3	0f 84 15 01 00
	00		 je	 $LN46@path_conve

; 770  :             bytes = PyBytes_FromObject(o);

  001c9	48 8b ce	 mov	 rcx, rsi
  001cc	e8 00 00 00 00	 call	 PyBytes_FromObject
  001d1	48 8b e8	 mov	 rbp, rax

; 771  :         else
; 772  :             bytes = NULL;
; 773  :         if (!bytes) {

  001d4	48 85 c0	 test	 rax, rax
  001d7	0f 84 01 01 00
	00		 je	 $LN46@path_conve

; 795  :     }
; 796  : 
; 797  : #ifdef MS_WINDOWS
; 798  :     if (win32_warn_bytes_api()) {

  001dd	e8 00 00 00 00	 call	 win32_warn_bytes_api
  001e2	85 c0		 test	 eax, eax

; 799  :         Py_DECREF(bytes);
; 800  :         return 0;

  001e4	75 56		 jne	 SHORT $LN54@path_conve

; 801  :     }
; 802  : #endif
; 803  : 
; 804  :     length = PyBytes_GET_SIZE(bytes);

  001e6	48 8b 55 60	 mov	 rdx, QWORD PTR [rbp+96]

; 805  : #ifdef MS_WINDOWS
; 806  :     if (length > MAX_PATH) {

  001ea	48 81 fa 04 01
	00 00		 cmp	 rdx, 260		; 00000104H
  001f1	7e 56		 jle	 SHORT $LN2@path_conve

; 807  :         FORMAT_EXCEPTION(PyExc_ValueError, "%s too long for Windows");

  001f3	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  001f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00205	48 85 c0	 test	 rax, rax
  00208	4d 8b c1	 mov	 r8, r9
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00212	48 0f 45 c8	 cmovne	 rcx, rax
  00216	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00219	48 85 c0	 test	 rax, rax
  0021c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00221	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00228	4c 0f 45 ca	 cmovne	 r9, rdx
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
  00233	4c 0f 45 c0	 cmovne	 r8, rax
  00237	e8 00 00 00 00	 call	 PyErr_Format
$LN54@path_conve:

; 808  :         Py_DECREF(bytes);

  0023c	48 8b cd	 mov	 rcx, rbp
  0023f	e8 00 00 00 00	 call	 _Py_DecRef

; 809  :         return 0;

  00244	e9 24 01 00 00	 jmp	 $LN4@path_conve
$LN2@path_conve:

; 810  :     }
; 811  : #endif
; 812  : 
; 813  :     narrow = PyBytes_AS_STRING(bytes);
; 814  :     if (length != strlen(narrow)) {

  00249	48 83 c9 ff	 or	 rcx, -1
  0024d	33 c0		 xor	 eax, eax
  0024f	4c 8d 45 78	 lea	 r8, QWORD PTR [rbp+120]
  00253	49 8b f8	 mov	 rdi, r8
  00256	f2 ae		 repne scasb
  00258	48 f7 d1	 not	 rcx
  0025b	48 ff c9	 dec	 rcx
  0025e	48 3b d1	 cmp	 rdx, rcx
  00261	74 56		 je	 SHORT $LN1@path_conve

; 815  :         FORMAT_EXCEPTION(PyExc_ValueError, "embedded NUL character in %s");

  00263	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00267	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0026e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00275	48 85 c0	 test	 rax, rax
  00278	4d 8b c1	 mov	 r8, r9
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00282	48 0f 45 c8	 cmovne	 rcx, rax
  00286	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00289	48 85 c0	 test	 rax, rax
  0028c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00291	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00298	4c 0f 45 ca	 cmovne	 r9, rdx
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@
  002a3	4c 0f 45 c0	 cmovne	 r8, rax
  002a7	e8 00 00 00 00	 call	 PyErr_Format

; 816  :         Py_DECREF(bytes);

  002ac	48 8b cd	 mov	 rcx, rbp
  002af	e8 00 00 00 00	 call	 _Py_DecRef

; 817  :         return 0;

  002b4	e9 b4 00 00 00	 jmp	 $LN4@path_conve
$LN1@path_conve:

; 818  :     }
; 819  : 
; 820  :     path->wide = NULL;

  002b9	4c 89 63 18	 mov	 QWORD PTR [rbx+24], r12

; 821  :     path->narrow = narrow;

  002bd	4c 89 43 20	 mov	 QWORD PTR [rbx+32], r8

; 822  :     path->length = length;

  002c1	48 89 53 30	 mov	 QWORD PTR [rbx+48], rdx

; 823  :     path->object = o;

  002c5	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi

; 824  :     path->fd = -1;

  002c9	c7 43 28 ff ff
	ff ff		 mov	 DWORD PTR [rbx+40], -1

; 825  :     path->cleanup = bytes;

  002d0	48 89 6b 40	 mov	 QWORD PTR [rbx+64], rbp

; 826  :     return Py_CLEANUP_SUPPORTED;

  002d4	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  002d9	e9 91 00 00 00	 jmp	 $LN50@path_conve
$LN46@path_conve:

; 774  :             PyErr_Clear();

  002de	e8 00 00 00 00	 call	 PyErr_Clear

; 775  :             if (path->allow_fd) {

  002e3	44 39 63 14	 cmp	 DWORD PTR [rbx+20], r12d
  002e7	74 31		 je	 SHORT $LN47@path_conve

; 776  :                 int fd;
; 777  :                 int result = _fd_converter(o, &fd,
; 778  :                         "string, bytes or integer");

  002e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@
  002f0	48 8d 54 24 50	 lea	 rdx, QWORD PTR fd$121010[rsp]
  002f5	48 8b ce	 mov	 rcx, rsi
  002f8	e8 00 00 00 00	 call	 _fd_converter

; 779  :                 if (result) {

  002fd	85 c0		 test	 eax, eax
  002ff	74 19		 je	 SHORT $LN47@path_conve

; 780  :                     path->wide = NULL;
; 781  :                     path->narrow = NULL;
; 782  :                     path->length = 0;
; 783  :                     path->object = o;
; 784  :                     path->fd = fd;

  00301	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$121010[rsp]
  00305	4c 89 63 18	 mov	 QWORD PTR [rbx+24], r12
  00309	4c 89 63 20	 mov	 QWORD PTR [rbx+32], r12
  0030d	4c 89 63 30	 mov	 QWORD PTR [rbx+48], r12
  00311	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi
  00315	89 4b 28	 mov	 DWORD PTR [rbx+40], ecx

; 785  :                     return result;

  00318	eb 55		 jmp	 SHORT $LN50@path_conve
$LN47@path_conve:

; 786  :                 }
; 787  :             }
; 788  :         }
; 789  :     }
; 790  : 
; 791  :     if (!bytes) {
; 792  :         if (!PyErr_Occurred())

  0031a	e8 00 00 00 00	 call	 PyErr_Occurred
  0031f	48 85 c0	 test	 rax, rax
  00322	75 49		 jne	 SHORT $LN4@path_conve

; 793  :             FORMAT_EXCEPTION(PyExc_TypeError, "illegal type for %s parameter");

  00324	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00328	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00336	48 85 c0	 test	 rax, rax
  00339	4d 8b c1	 mov	 r8, r9
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00343	48 0f 45 c8	 cmovne	 rcx, rax
  00347	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0034a	48 85 c0	 test	 rax, rax
  0034d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00352	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00359	4c 0f 45 ca	 cmovne	 r9, rdx
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@
  00364	4c 0f 45 c0	 cmovne	 r8, rax
  00368	e8 00 00 00 00	 call	 PyErr_Format
$LN4@path_conve:

; 794  :         return 0;

  0036d	33 c0		 xor	 eax, eax
$LN50@path_conve:
  0036f	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00374	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00379	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]

; 827  : }

  0037e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00382	5e		 pop	 rsi
  00383	5b		 pop	 rbx
  00384	c3		 ret	 0
path_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$argument_unavailable_error DD imagerel argument_unavailable_error
	DD	imagerel argument_unavailable_error+61
	DD	imagerel $unwind$argument_unavailable_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$argument_unavailable_error DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@
CONST	SEGMENT
??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@ DB '%s%'
	DB	's%s unavailable on this platform', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT argument_unavailable_error
_TEXT	SEGMENT
function_name$ = 64
argument_name$ = 72
argument_unavailable_error PROC				; COMDAT

; 830  : argument_unavailable_error(char *function_name, char *argument_name) {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 831  :     PyErr_Format(PyExc_NotImplementedError,
; 832  :         "%s%s%s unavailable on this platform",
; 833  :         (function_name != NULL) ? function_name : "",
; 834  :         (function_name != NULL) ? ": ": "",
; 835  :         argument_name);

  00004	48 85 c9	 test	 rcx, rcx
  00007	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00015	4d 8b c8	 mov	 r9, r8
  00018	4c 0f 45 c1	 cmovne	 r8, rcx
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00023	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@
  0002f	4c 0f 45 c8	 cmovne	 r9, rax
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 836  : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
argument_unavailable_error ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_unavailable DD imagerel dir_fd_unavailable
	DD	imagerel dir_fd_unavailable+69
	DD	imagerel $unwind$dir_fd_unavailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_unavailable DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT dir_fd_unavailable
_TEXT	SEGMENT
o$ = 48
p$ = 56
dir_fd$ = 64
dir_fd_unavailable PROC					; COMDAT

; 840  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 841  :     int dir_fd;
; 842  :     if (!dir_fd_converter(o, &dir_fd))

  00009	48 8d 54 24 40	 lea	 rdx, QWORD PTR dir_fd$[rsp]
  0000e	e8 00 00 00 00	 call	 dir_fd_converter
  00013	85 c0		 test	 eax, eax

; 843  :         return 0;

  00015	74 15		 je	 SHORT $LN5@dir_fd_una

; 844  :     if (dir_fd != DEFAULT_DIR_FD) {

  00017	83 7c 24 40 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0001c	74 16		 je	 SHORT $LN1@dir_fd_una

; 845  :         argument_unavailable_error(NULL, "dir_fd");

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
  00025	33 c9		 xor	 ecx, ecx
  00027	e8 00 00 00 00	 call	 argument_unavailable_error
$LN5@dir_fd_una:

; 846  :         return 0;

  0002c	33 c0		 xor	 eax, eax

; 850  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
$LN1@dir_fd_una:

; 847  :     }
; 848  :     *(int *)p = dir_fd;

  00034	c7 03 9c ff ff
	ff		 mov	 DWORD PTR [rbx], -100	; ffffffffffffff9cH

; 849  :     return 1;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 850  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
dir_fd_unavailable ENDP
_TEXT	ENDS
PUBLIC	??_C@_02ENHFDPNM@fd?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fd_specified DD imagerel fd_specified
	DD	imagerel fd_specified+38
	DD	imagerel $unwind$fd_specified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fd_specified DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_02ENHFDPNM@fd?$AA@
CONST	SEGMENT
??_C@_02ENHFDPNM@fd?$AA@ DB 'fd', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fd_specified
_TEXT	SEGMENT
function_name$ = 48
fd$ = 56
fd_specified PROC					; COMDAT

; 853  : fd_specified(char *function_name, int fd) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 854  :     if (fd == -1)

  00004	83 fa ff	 cmp	 edx, -1
  00007	75 07		 jne	 SHORT $LN1@fd_specifi

; 855  :         return 0;

  00009	33 c0		 xor	 eax, eax

; 859  : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
$LN1@fd_specifi:

; 856  : 
; 857  :     argument_unavailable_error(function_name, "fd");

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02ENHFDPNM@fd?$AA@
  00017	e8 00 00 00 00	 call	 argument_unavailable_error

; 858  :     return 1;

  0001c	b8 01 00 00 00	 mov	 eax, 1

; 859  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
fd_specified ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$follow_symlinks_specified DD imagerel follow_symlinks_specified
	DD	imagerel follow_symlinks_specified+37
	DD	imagerel $unwind$follow_symlinks_specified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$follow_symlinks_specified DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT follow_symlinks_specified
_TEXT	SEGMENT
function_name$ = 48
follow_symlinks$ = 56
follow_symlinks_specified PROC				; COMDAT

; 862  : follow_symlinks_specified(char *function_name, int follow_symlinks) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 863  :     if (follow_symlinks)

  00004	85 d2		 test	 edx, edx
  00006	74 07		 je	 SHORT $LN1@follow_sym

; 864  :         return 0;

  00008	33 c0		 xor	 eax, eax

; 868  : }

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
$LN1@follow_sym:

; 865  : 
; 866  :     argument_unavailable_error(function_name, "follow_symlinks");

  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
  00016	e8 00 00 00 00	 call	 argument_unavailable_error

; 867  :     return 1;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 868  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
follow_symlinks_specified ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_and_dir_fd_invalid DD imagerel path_and_dir_fd_invalid
	DD	imagerel path_and_dir_fd_invalid+63
	DD	imagerel $unwind$path_and_dir_fd_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_and_dir_fd_invalid DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@
CONST	SEGMENT
??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@ DB '%s: can'
	DB	'''t specify dir_fd without matching path', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT path_and_dir_fd_invalid
_TEXT	SEGMENT
function_name$ = 48
path$ = 56
dir_fd$ = 64
path_and_dir_fd_invalid PROC				; COMDAT

; 871  : path_and_dir_fd_invalid(char *function_name, path_t *path, int dir_fd) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 872  :     if (!path->narrow && !path->wide && (dir_fd != DEFAULT_DIR_FD)) {

  00004	48 83 7a 20 00	 cmp	 QWORD PTR [rdx+32], 0
  00009	75 2d		 jne	 SHORT $LN1@path_and_d
  0000b	48 83 7a 18 00	 cmp	 QWORD PTR [rdx+24], 0
  00010	75 26		 jne	 SHORT $LN1@path_and_d
  00012	41 83 f8 9c	 cmp	 r8d, -100		; ffffffffffffff9cH
  00016	74 20		 je	 SHORT $LN1@path_and_d

; 873  :         PyErr_Format(PyExc_ValueError,
; 874  :                      "%s: can't specify dir_fd without matching path",
; 875  :                      function_name);

  00018	4c 8b c1	 mov	 r8, rcx
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@
  00029	e8 00 00 00 00	 call	 PyErr_Format

; 876  :         return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 879  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
$LN1@path_and_d:

; 877  :     }
; 878  :     return 0;

  00038	33 c0		 xor	 eax, eax

; 879  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
path_and_dir_fd_invalid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_and_fd_invalid DD imagerel dir_fd_and_fd_invalid
	DD	imagerel dir_fd_and_fd_invalid+54
	DD	imagerel $unwind$dir_fd_and_fd_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_and_fd_invalid DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@
CONST	SEGMENT
??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@ DB '%s: ca'
	DB	'n''t specify both dir_fd and fd', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT dir_fd_and_fd_invalid
_TEXT	SEGMENT
function_name$ = 48
dir_fd$ = 56
fd$ = 64
dir_fd_and_fd_invalid PROC				; COMDAT

; 882  : dir_fd_and_fd_invalid(char *function_name, int dir_fd, int fd) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 883  :     if ((dir_fd != DEFAULT_DIR_FD) && (fd != -1)) {

  00004	83 fa 9c	 cmp	 edx, -100		; ffffffffffffff9cH
  00007	74 26		 je	 SHORT $LN1@dir_fd_and
  00009	41 83 f8 ff	 cmp	 r8d, -1
  0000d	74 20		 je	 SHORT $LN1@dir_fd_and

; 884  :         PyErr_Format(PyExc_ValueError,
; 885  :                      "%s: can't specify both dir_fd and fd",
; 886  :                      function_name);

  0000f	4c 8b c1	 mov	 r8, rcx
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@
  00020	e8 00 00 00 00	 call	 PyErr_Format

; 887  :         return 1;

  00025	b8 01 00 00 00	 mov	 eax, 1

; 890  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
$LN1@dir_fd_and:

; 888  :     }
; 889  :     return 0;

  0002f	33 c0		 xor	 eax, eax

; 890  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
dir_fd_and_fd_invalid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fd_and_follow_symlinks_invalid DD imagerel fd_and_follow_symlinks_invalid
	DD	imagerel fd_and_follow_symlinks_invalid+52
	DD	imagerel $unwind$fd_and_follow_symlinks_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fd_and_follow_symlinks_invalid DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@
CONST	SEGMENT
??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@ DB '%s: can'
	DB	'not use fd and follow_symlinks together', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fd_and_follow_symlinks_invalid
_TEXT	SEGMENT
function_name$ = 48
fd$ = 56
follow_symlinks$ = 64
fd_and_follow_symlinks_invalid PROC			; COMDAT

; 894  :                                int follow_symlinks) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 895  :     if ((fd > 0) && (!follow_symlinks)) {

  00004	85 d2		 test	 edx, edx
  00006	7e 25		 jle	 SHORT $LN1@fd_and_fol
  00008	45 85 c0	 test	 r8d, r8d
  0000b	75 20		 jne	 SHORT $LN1@fd_and_fol

; 896  :         PyErr_Format(PyExc_ValueError,
; 897  :                      "%s: cannot use fd and follow_symlinks together",
; 898  :                      function_name);

  0000d	4c 8b c1	 mov	 r8, rcx
  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@
  0001e	e8 00 00 00 00	 call	 PyErr_Format

; 899  :         return 1;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 902  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@fd_and_fol:

; 900  :     }
; 901  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 902  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
fd_and_follow_symlinks_invalid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_and_follow_symlinks_invalid DD imagerel dir_fd_and_follow_symlinks_invalid
	DD	imagerel dir_fd_and_follow_symlinks_invalid+53
	DD	imagerel $unwind$dir_fd_and_follow_symlinks_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_and_follow_symlinks_invalid DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@
CONST	SEGMENT
??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@ DB '%s: can'
	DB	'not use dir_fd and follow_symlinks together', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT dir_fd_and_follow_symlinks_invalid
_TEXT	SEGMENT
function_name$ = 48
dir_fd$ = 56
follow_symlinks$ = 64
dir_fd_and_follow_symlinks_invalid PROC			; COMDAT

; 906  :                                    int follow_symlinks) {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 907  :     if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {

  00004	83 fa 9c	 cmp	 edx, -100		; ffffffffffffff9cH
  00007	74 25		 je	 SHORT $LN1@dir_fd_and@2
  00009	45 85 c0	 test	 r8d, r8d
  0000c	75 20		 jne	 SHORT $LN1@dir_fd_and@2

; 908  :         PyErr_Format(PyExc_ValueError,
; 909  :                      "%s: cannot use dir_fd and follow_symlinks together",
; 910  :                      function_name);

  0000e	4c 8b c1	 mov	 r8, rcx
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@
  0001f	e8 00 00 00 00	 call	 PyErr_Format

; 911  :         return 1;

  00024	b8 01 00 00 00	 mov	 eax, 1

; 914  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
$LN1@dir_fd_and@2:

; 912  :     }
; 913  :     return 0;

  0002e	33 c0		 xor	 eax, eax

; 914  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
dir_fd_and_follow_symlinks_invalid ENDP
_TEXT	ENDS
PUBLIC	_PyVerify_fd
EXTRN	__imp__errno:PROC
EXTRN	__imp__msize:PROC
EXTRN	__imp___pioinfo:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyVerify_fd DD imagerel $LN9
	DD	imagerel $LN9+172
	DD	imagerel $unwind$_PyVerify_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyVerify_fd DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyVerify_fd
_TEXT	SEGMENT
fd$ = 48
_PyVerify_fd PROC					; COMDAT

; 972  : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 973  :     const int i1 = fd >> IOINFO_L2E;
; 974  :     const int i2 = fd & ((1 << IOINFO_L2E) - 1);
; 975  : 
; 976  :     static size_t sizeof_ioinfo = 0;
; 977  : 
; 978  :     /* Determine the actual size of the ioinfo structure,
; 979  :      * as used by the CRT loaded in memory
; 980  :      */
; 981  :     if (sizeof_ioinfo == 0 && __pioinfo[0] != NULL) {

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9
  00016	8b d9		 mov	 ebx, ecx
  00018	8b f1		 mov	 esi, ecx
  0001a	c1 fb 05	 sar	 ebx, 5
  0001d	83 e6 1f	 and	 esi, 31
  00020	8b f9		 mov	 edi, ecx
  00022	48 85 c0	 test	 rax, rax
  00025	75 25		 jne	 SHORT $LN8@PyVerify_f
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp___pioinfo
  0002e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00031	74 5b		 je	 SHORT $fail$121129

; 982  :         sizeof_ioinfo = _msize(__pioinfo[0]) / IOINFO_ARRAY_ELTS;

  00033	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__msize
  0003c	48 c1 e8 05	 shr	 rax, 5
  00040	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9, rax

; 983  :     }
; 984  :     if (sizeof_ioinfo == 0) {

  00047	48 85 c0	 test	 rax, rax
  0004a	74 42		 je	 SHORT $fail$121129
$LN8@PyVerify_f:

; 985  :         /* This should not happen... */
; 986  :         goto fail;
; 987  :     }
; 988  : 
; 989  :     /* See that it isn't a special CLEAR fileno */
; 990  :     if (fd != _NO_CONSOLE_FILENO) {

  0004c	83 ff fe	 cmp	 edi, -2
  0004f	74 3d		 je	 SHORT $fail$121129

; 991  :         /* Microsoft CRT would check that 0<=fd<_nhandle but we can't do that.  Instead
; 992  :          * we check pointer validity and other info
; 993  :          */
; 994  :         if (0 <= i1 && i1 < IOINFO_ARRAYS && __pioinfo[i1] != NULL) {

  00051	83 fb 3f	 cmp	 ebx, 63			; 0000003fH
  00054	77 38		 ja	 SHORT $fail$121129
  00056	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp___pioinfo
  0005d	48 63 d3	 movsxd	 rdx, ebx
  00060	49 83 3c d0 00	 cmp	 QWORD PTR [r8+rdx*8], 0
  00065	74 27		 je	 SHORT $fail$121129

; 995  :             /* finally, check that the file is open */
; 996  :             my_ioinfo* info = (my_ioinfo*)(__pioinfo[i1] + i2 * sizeof_ioinfo);
; 997  :             if (info->osfile & FOPEN) {

  00067	48 63 ce	 movsxd	 rcx, esi
  0006a	48 0f af c8	 imul	 rcx, rax
  0006e	49 8b 04 d0	 mov	 rax, QWORD PTR [r8+rdx*8]
  00072	f6 44 01 08 01	 test	 BYTE PTR [rcx+rax+8], 1
  00077	74 15		 je	 SHORT $fail$121129

; 998  :                 return 1;

  00079	b8 01 00 00 00	 mov	 eax, 1

; 1004 :     return 0;
; 1005 : }

  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00083	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
$fail$121129:

; 999  :             }
; 1000 :         }
; 1001 :     }
; 1002 :   fail:
; 1003 :     errno = EBADF;

  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 1004 :     return 0;
; 1005 : }

  00094	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00099	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009e	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  000a4	33 c0		 xor	 eax, eax
  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
_PyVerify_fd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyVerify_fd_dup2 DD imagerel _PyVerify_fd_dup2
	DD	imagerel _PyVerify_fd_dup2+45
	DD	imagerel $unwind$_PyVerify_fd_dup2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyVerify_fd_dup2 DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyVerify_fd_dup2
_TEXT	SEGMENT
fd1$ = 48
fd2$ = 56
_PyVerify_fd_dup2 PROC					; COMDAT

; 1010 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b da		 mov	 ebx, edx

; 1011 :     if (!_PyVerify_fd(fd1))

  00008	e8 00 00 00 00	 call	 _PyVerify_fd
  0000d	85 c0		 test	 eax, eax
  0000f	75 06		 jne	 SHORT $LN4@PyVerify_f@2

; 1016 :         return 1;
; 1017 :     else
; 1018 :         return 0;
; 1019 : }

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
$LN4@PyVerify_f@2:

; 1012 :         return 0;
; 1013 :     if (fd2 == _NO_CONSOLE_FILENO)
; 1014 :         return 0;

  00017	33 c0		 xor	 eax, eax
  00019	83 fb fe	 cmp	 ebx, -2
  0001c	74 09		 je	 SHORT $LN2@PyVerify_f@2

; 1015 :     if ((unsigned)fd2 < _NHANDLE_)

  0001e	81 fb 00 08 00
	00		 cmp	 ebx, 2048		; 00000800H
  00024	0f 92 c0	 setb	 al
$LN2@PyVerify_f@2:

; 1016 :         return 1;
; 1017 :     else
; 1018 :         return 0;
; 1019 : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
_PyVerify_fd_dup2 ENDP
_TEXT	ENDS
EXTRN	__imp_DeviceIoControl:PROC
EXTRN	__chkstk:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_get_reparse_tag DD imagerel win32_get_reparse_tag
	DD	imagerel win32_get_reparse_tag+113
	DD	imagerel $unwind$win32_get_reparse_tag
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_get_reparse_tag DD 030f01H
	DD	0808010fH
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_get_reparse_tag
_TEXT	SEGMENT
target_buffer$ = 64
reparse_point_handle$ = 16464
reparse_tag$ = 16472
n_bytes_returned$ = 16480
win32_get_reparse_tag PROC				; COMDAT

; 1064 : {

  00000	40 53		 push	 rbx
  00002	b8 40 40 00 00	 mov	 eax, 16448		; 00004040H
  00007	e8 00 00 00 00	 call	 __chkstk
  0000c	48 2b e0	 sub	 rsp, rax

; 1065 :     char target_buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
; 1066 :     REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER *)target_buffer;
; 1067 :     DWORD n_bytes_returned;
; 1068 : 
; 1069 :     if (0 == DeviceIoControl(
; 1070 :         reparse_point_handle,
; 1071 :         FSCTL_GET_REPARSE_POINT,
; 1072 :         NULL, 0, /* in buffer */
; 1073 :         target_buffer, sizeof(target_buffer),
; 1074 :         &n_bytes_returned,
; 1075 :         NULL)) /* we're not using OVERLAPPED_IO */

  0000f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00018	48 8d 84 24 60
	40 00 00	 lea	 rax, QWORD PTR n_bytes_returned$[rsp]
  00020	48 8b da	 mov	 rbx, rdx
  00023	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00028	48 8d 44 24 40	 lea	 rax, QWORD PTR target_buffer$[rsp]
  0002d	45 33 c9	 xor	 r9d, r9d
  00030	45 33 c0	 xor	 r8d, r8d
  00033	ba a8 00 09 00	 mov	 edx, 589992		; 000900a8H
  00038	c7 44 24 28 00
	40 00 00	 mov	 DWORD PTR [rsp+40], 16384 ; 00004000H
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl
  0004b	85 c0		 test	 eax, eax
  0004d	75 09		 jne	 SHORT $LN2@win32_get_

; 1082 : }

  0004f	48 81 c4 40 40
	00 00		 add	 rsp, 16448		; 00004040H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
$LN2@win32_get_:

; 1076 :         return FALSE;
; 1077 : 
; 1078 :     if (reparse_tag)

  00058	48 85 db	 test	 rbx, rbx
  0005b	74 06		 je	 SHORT $LN1@win32_get_

; 1079 :         *reparse_tag = rdb->ReparseTag;

  0005d	8b 44 24 40	 mov	 eax, DWORD PTR target_buffer$[rsp]
  00061	89 03		 mov	 DWORD PTR [rbx], eax
$LN1@win32_get_:

; 1080 : 
; 1081 :     return TRUE;

  00063	b8 01 00 00 00	 mov	 eax, 1

; 1082 : }

  00068	48 81 c4 40 40
	00 00		 add	 rsp, 16448		; 00004040H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
win32_get_reparse_tag ENDP
_TEXT	ENDS
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	__imp_wcschr:PROC
EXTRN	__imp__wenviron:QWORD
EXTRN	__imp__wgetenv:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertenviron DD imagerel convertenviron
	DD	imagerel convertenviron+75
	DD	imagerel $unwind$convertenviron
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$convertenviron DD imagerel convertenviron+75
	DD	imagerel convertenviron+285
	DD	imagerel $chain$2$convertenviron
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$convertenviron DD imagerel convertenviron+285
	DD	imagerel convertenviron+299
	DD	imagerel $chain$3$convertenviron
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$convertenviron DD 021H
	DD	imagerel convertenviron
	DD	imagerel convertenviron+75
	DD	imagerel $unwind$convertenviron
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$convertenviron DD 040a21H
	DD	08740aH
	DD	076405H
	DD	imagerel convertenviron
	DD	imagerel convertenviron+75
	DD	imagerel $unwind$convertenviron
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertenviron DD 042501H
	DD	063425H
	DD	050023206H
xdata	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT convertenviron
_TEXT	SEGMENT
convertenviron PROC					; COMDAT

; 1100 : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1101 :     PyObject *d;
; 1102 : #ifdef MS_WINDOWS
; 1103 :     wchar_t **e;
; 1104 : #else
; 1105 :     char **e;
; 1106 : #endif
; 1107 : #if defined(PYOS_OS2)
; 1108 :     APIRET rc;
; 1109 :     char   buffer[1024]; /* OS/2 Provides a Documented Max of 1024 Chars */
; 1110 : #endif
; 1111 : 
; 1112 :     d = PyDict_New();

  00006	e8 00 00 00 00	 call	 PyDict_New
  0000b	48 8b e8	 mov	 rbp, rax

; 1113 :     if (d == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN10@convertenv

; 1194 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5d		 pop	 rbp
  00018	c3		 ret	 0
$LN10@convertenv:

; 1114 :         return NULL;
; 1115 : #if defined(WITH_NEXT_FRAMEWORK) || (defined(__APPLE__) && defined(Py_ENABLE_SHARED))
; 1116 :     if (environ == NULL)
; 1117 :         environ = *_NSGetEnviron();
; 1118 : #endif
; 1119 : #ifdef MS_WINDOWS
; 1120 :     /* _wenviron must be initialized in this way if the program is started
; 1121 :        through main() instead of wmain(). */
; 1122 :     _wgetenv(L"");

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_11LOCGONAA@?$AA?$AA@
  00020	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv

; 1123 :     if (_wenviron == NULL)

  0002b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR __imp__wenviron
  00032	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0

; 1124 :         return d;

  00036	0f 84 e1 00 00
	00		 je	 $LN6@convertenv

; 1125 :     /* This part ignores errors */
; 1126 :     for (e = _wenviron; *e != NULL; e++) {

  0003c	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 85 c0	 test	 rax, rax
  00045	0f 84 d2 00 00
	00		 je	 $LN6@convertenv
  0004b	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00050	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@convertenv:

; 1127 :         PyObject *k;
; 1128 :         PyObject *v;
; 1129 :         wchar_t *p = wcschr(*e, L'=');

  00060	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  00065	48 8b c8	 mov	 rcx, rax
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0006e	48 8b f8	 mov	 rdi, rax

; 1130 :         if (p == NULL)

  00071	48 85 c0	 test	 rax, rax
  00074	0f 84 88 00 00
	00		 je	 $LN7@convertenv

; 1131 :             continue;
; 1132 :         k = PyUnicode_FromWideChar(*e, (Py_ssize_t)(p-*e));

  0007a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0007d	48 8b d0	 mov	 rdx, rax
  00080	48 2b d1	 sub	 rdx, rcx
  00083	48 d1 fa	 sar	 rdx, 1
  00086	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0008b	48 8b f0	 mov	 rsi, rax

; 1133 :         if (k == NULL) {

  0008e	48 85 c0	 test	 rax, rax
  00091	75 07		 jne	 SHORT $LN4@convertenv

; 1134 :             PyErr_Clear();

  00093	e8 00 00 00 00	 call	 PyErr_Clear

; 1135 :             continue;

  00098	eb 68		 jmp	 SHORT $LN7@convertenv
$LN4@convertenv:

; 1136 :         }
; 1137 :         v = PyUnicode_FromWideChar(p+1, wcslen(p+1));

  0009a	4c 8d 47 02	 lea	 r8, QWORD PTR [rdi+2]
  0009e	48 83 c9 ff	 or	 rcx, -1
  000a2	33 c0		 xor	 eax, eax
  000a4	49 8b f8	 mov	 rdi, r8
  000a7	66 f2 af	 repne scasw
  000aa	48 f7 d1	 not	 rcx
  000ad	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  000b1	49 8b c8	 mov	 rcx, r8
  000b4	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000b9	48 8b f8	 mov	 rdi, rax

; 1138 :         if (v == NULL) {

  000bc	48 85 c0	 test	 rax, rax
  000bf	75 0a		 jne	 SHORT $LN3@convertenv

; 1139 :             PyErr_Clear();

  000c1	e8 00 00 00 00	 call	 PyErr_Clear

; 1140 :             Py_DECREF(k);

  000c6	48 8b ce	 mov	 rcx, rsi

; 1141 :             continue;

  000c9	eb 32		 jmp	 SHORT $LN16@convertenv
$LN3@convertenv:

; 1142 :         }
; 1143 :         if (PyDict_GetItem(d, k) == NULL) {

  000cb	48 8b d6	 mov	 rdx, rsi
  000ce	48 8b cd	 mov	 rcx, rbp
  000d1	e8 00 00 00 00	 call	 PyDict_GetItem
  000d6	48 85 c0	 test	 rax, rax
  000d9	75 17		 jne	 SHORT $LN1@convertenv

; 1144 :             if (PyDict_SetItem(d, k, v) != 0)

  000db	4c 8b c7	 mov	 r8, rdi
  000de	48 8b d6	 mov	 rdx, rsi
  000e1	48 8b cd	 mov	 rcx, rbp
  000e4	e8 00 00 00 00	 call	 PyDict_SetItem
  000e9	85 c0		 test	 eax, eax
  000eb	74 05		 je	 SHORT $LN1@convertenv

; 1145 :                 PyErr_Clear();

  000ed	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@convertenv:

; 1146 :         }
; 1147 :         Py_DECREF(k);

  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	e8 00 00 00 00	 call	 _Py_DecRef

; 1148 :         Py_DECREF(v);

  000fa	48 8b cf	 mov	 rcx, rdi
$LN16@convertenv:
  000fd	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@convertenv:

; 1125 :     /* This part ignores errors */
; 1126 :     for (e = _wenviron; *e != NULL; e++) {

  00102	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00106	48 83 c3 08	 add	 rbx, 8
  0010a	48 85 c0	 test	 rax, rax
  0010d	0f 85 4d ff ff
	ff		 jne	 $LL8@convertenv
  00113	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00118	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN6@convertenv:

; 1149 :     }
; 1150 : #else
; 1151 :     if (environ == NULL)
; 1152 :         return d;
; 1153 :     /* This part ignores errors */
; 1154 :     for (e = environ; *e != NULL; e++) {
; 1155 :         PyObject *k;
; 1156 :         PyObject *v;
; 1157 :         char *p = strchr(*e, '=');
; 1158 :         if (p == NULL)
; 1159 :             continue;
; 1160 :         k = PyBytes_FromStringAndSize(*e, (int)(p-*e));
; 1161 :         if (k == NULL) {
; 1162 :             PyErr_Clear();
; 1163 :             continue;
; 1164 :         }
; 1165 :         v = PyBytes_FromStringAndSize(p+1, strlen(p+1));
; 1166 :         if (v == NULL) {
; 1167 :             PyErr_Clear();
; 1168 :             Py_DECREF(k);
; 1169 :             continue;
; 1170 :         }
; 1171 :         if (PyDict_GetItem(d, k) == NULL) {
; 1172 :             if (PyDict_SetItem(d, k, v) != 0)
; 1173 :                 PyErr_Clear();
; 1174 :         }
; 1175 :         Py_DECREF(k);
; 1176 :         Py_DECREF(v);
; 1177 :     }
; 1178 : #endif
; 1179 : #if defined(PYOS_OS2)
; 1180 :     rc = DosQueryExtLIBPATH(buffer, BEGIN_LIBPATH);
; 1181 :     if (rc == NO_ERROR) { /* (not a type, envname is NOT 'BEGIN_LIBPATH') */
; 1182 :         PyObject *v = PyBytes_FromString(buffer);
; 1183 :         PyDict_SetItemString(d, "BEGINLIBPATH", v);
; 1184 :         Py_DECREF(v);
; 1185 :     }
; 1186 :     rc = DosQueryExtLIBPATH(buffer, END_LIBPATH);
; 1187 :     if (rc == NO_ERROR) { /* (not a typo, envname is NOT 'END_LIBPATH') */
; 1188 :         PyObject *v = PyBytes_FromString(buffer);
; 1189 :         PyDict_SetItemString(d, "ENDLIBPATH", v);
; 1190 :         Py_DECREF(v);
; 1191 :     }
; 1192 : #endif
; 1193 :     return d;

  0011d	48 8b c5	 mov	 rax, rbp
  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1194 : }

  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	5d		 pop	 rbp
  0012a	c3		 ret	 0
convertenviron ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
; Function compile flags: /Ogtpy
;	COMDAT posix_error
_TEXT	SEGMENT
posix_error PROC					; COMDAT

; 1201 :     return PyErr_SetFromErrno(PyExc_OSError);

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError

; 1202 : }

  00007	e9 00 00 00 00	 jmp	 PyErr_SetFromErrno
posix_error ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
; Function compile flags: /Ogtpy
;	COMDAT posix_error_with_filename
_TEXT	SEGMENT
name$ = 8
posix_error_with_filename PROC				; COMDAT

; 1206 :     return PyErr_SetFromErrnoWithFilename(PyExc_OSError, name);

  00000	48 8b d1	 mov	 rdx, rcx
  00003	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError

; 1207 : }

  0000a	e9 00 00 00 00	 jmp	 PyErr_SetFromErrnoWithFilename
posix_error_with_filename ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	PyErr_SetFromWindowsErrWithFilename:PROC
EXTRN	__imp_GetLastError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error DD imagerel win32_error
	DD	imagerel win32_error+76
	DD	imagerel $unwind$win32_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_error
_TEXT	SEGMENT
filename$ = 48
win32_error PROC					; COMDAT

; 1226 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1227 :     /* XXX We should pass the function name along in the future.
; 1228 :        (winreg.c also wants to pass the function name.)
; 1229 :        This would however require an additional param to the
; 1230 :        Windows error object, which is non-trivial.
; 1231 :     */
; 1232 :     errno = GetLastError();

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	48 8b d8	 mov	 rbx, rax
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0001c	89 03		 mov	 DWORD PTR [rbx], eax

; 1233 :     if (filename)
; 1234 :         return PyErr_SetFromWindowsErrWithFilename(errno, filename);

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00024	8b 08		 mov	 ecx, DWORD PTR [rax]
  00026	48 85 ff	 test	 rdi, rdi
  00029	74 12		 je	 SHORT $LN2@win32_erro
  0002b	48 8b d7	 mov	 rdx, rdi

; 1235 :     else
; 1236 :         return PyErr_SetFromWindowsErr(errno);
; 1237 : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	e9 00 00 00 00	 jmp	 PyErr_SetFromWindowsErrWithFilename
$LN2@win32_erro:
  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	e9 00 00 00 00	 jmp	 PyErr_SetFromWindowsErr
win32_error ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromWindowsErrWithUnicodeFilename:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error_unicode DD imagerel win32_error_unicode
	DD	imagerel win32_error_unicode+76
	DD	imagerel $unwind$win32_error_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error_unicode DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_error_unicode
_TEXT	SEGMENT
filename$ = 48
win32_error_unicode PROC				; COMDAT

; 1241 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1242 :     /* XXX - see win32_error for comments on 'function' */
; 1243 :     errno = GetLastError();

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	48 8b d8	 mov	 rbx, rax
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0001c	89 03		 mov	 DWORD PTR [rbx], eax

; 1244 :     if (filename)
; 1245 :         return PyErr_SetFromWindowsErrWithUnicodeFilename(errno, filename);

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00024	8b 08		 mov	 ecx, DWORD PTR [rax]
  00026	48 85 ff	 test	 rdi, rdi
  00029	74 12		 je	 SHORT $LN2@win32_erro@2
  0002b	48 8b d7	 mov	 rdx, rdi

; 1246 :     else
; 1247 :         return PyErr_SetFromWindowsErr(errno);
; 1248 : }

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	e9 00 00 00 00	 jmp	 PyErr_SetFromWindowsErrWithUnicodeFilename
$LN2@win32_erro@2:
  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	e9 00 00 00 00	 jmp	 PyErr_SetFromWindowsErr
win32_error_unicode ENDP
_TEXT	ENDS
EXTRN	PyErr_SetExcFromWindowsErrWithFilenameObject:PROC
EXTRN	PyExc_WindowsError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error_object DD imagerel win32_error_object
	DD	imagerel win32_error_object+85
	DD	imagerel $unwind$win32_error_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error_object DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_error_object
_TEXT	SEGMENT
filename$ = 48
win32_error_object PROC					; COMDAT

; 1252 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1253 :     /* XXX - see win32_error for comments on 'function' */
; 1254 :     errno = GetLastError();

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	48 8b d8	 mov	 rbx, rax
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0001c	89 03		 mov	 DWORD PTR [rbx], eax

; 1255 :     if (filename)
; 1256 :         return PyErr_SetExcFromWindowsErrWithFilenameObject(
; 1257 :                     PyExc_WindowsError,
; 1258 :                     errno,
; 1259 :                     filename);

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00024	48 85 ff	 test	 rdi, rdi
  00027	74 1b		 je	 SHORT $LN2@win32_erro@3
  00029	8b 10		 mov	 edx, DWORD PTR [rax]
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_WindowsError
  00032	4c 8b c7	 mov	 r8, rdi

; 1262 : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	e9 00 00 00 00	 jmp	 PyErr_SetExcFromWindowsErrWithFilenameObject
$LN2@win32_erro@3:

; 1260 :     else
; 1261 :         return PyErr_SetFromWindowsErr(errno);

  00044	8b 08		 mov	 ecx, DWORD PTR [rax]

; 1262 : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	e9 00 00 00 00	 jmp	 PyErr_SetFromWindowsErr
win32_error_object ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT path_posix_error
_TEXT	SEGMENT
path$ = 8
path_posix_error PROC					; COMDAT

; 1273 :     if (path->narrow)

  00000	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 05		 je	 SHORT $LN1@path_posix

; 1274 :         return posix_error_with_filename(path->narrow);
; 1275 :     return posix_error();
; 1276 : }

  00009	e9 00 00 00 00	 jmp	 posix_error_with_filename
$LN1@path_posix:
  0000e	e9 00 00 00 00	 jmp	 posix_error
path_posix_error ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT path_error
_TEXT	SEGMENT
path$ = 8
path_error PROC						; COMDAT

; 1281 : #ifdef MS_WINDOWS
; 1282 :     if (path->narrow)

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00004	48 85 c0	 test	 rax, rax
  00007	74 08		 je	 SHORT $LN2@path_error

; 1283 :         return win32_error(function_name, path->narrow);

  00009	48 8b c8	 mov	 rcx, rax

; 1285 :         return win32_error_unicode(function_name, path->wide);
; 1286 :     return win32_error(function_name, NULL);
; 1287 : #else
; 1288 :     return path_posix_error(function_name, path);
; 1289 : #endif
; 1290 : }

  0000c	e9 00 00 00 00	 jmp	 win32_error
$LN2@path_error:

; 1284 :     if (path->wide)

  00011	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00015	48 85 c9	 test	 rcx, rcx
  00018	74 05		 je	 SHORT $LN1@path_error

; 1285 :         return win32_error_unicode(function_name, path->wide);
; 1286 :     return win32_error(function_name, NULL);
; 1287 : #else
; 1288 :     return path_posix_error(function_name, path);
; 1289 : #endif
; 1290 : }

  0001a	e9 00 00 00 00	 jmp	 win32_error_unicode
$LN1@path_error:
  0001f	e9 00 00 00 00	 jmp	 win32_error
path_error ENDP
_TEXT	ENDS
EXTRN	PyEval_RestoreThread:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyObject_AsFileDescriptor:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_fildes DD imagerel posix_fildes
	DD	imagerel posix_fildes+63
	DD	imagerel $unwind$posix_fildes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_fildes DD imagerel posix_fildes+63
	DD	imagerel posix_fildes+99
	DD	imagerel $chain$0$posix_fildes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_fildes DD imagerel posix_fildes+99
	DD	imagerel posix_fildes+186
	DD	imagerel $chain$1$posix_fildes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_fildes DD 021H
	DD	imagerel posix_fildes
	DD	imagerel posix_fildes+63
	DD	imagerel $unwind$posix_fildes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_fildes DD 020521H
	DD	087405H
	DD	imagerel posix_fildes
	DD	imagerel posix_fildes+63
	DD	imagerel $unwind$posix_fildes
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_fildes DD 040a01H
	DD	09340aH
	DD	06006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
xdata	ENDS
;	COMDAT posix_fildes
_TEXT	SEGMENT
fdobj$ = 64
func$ = 72
posix_fildes PROC					; COMDAT

; 1373 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f2	 mov	 rsi, rdx

; 1374 :     int fd;
; 1375 :     int res;
; 1376 :     fd = PyObject_AsFileDescriptor(fdobj);

  0000d	e8 00 00 00 00	 call	 PyObject_AsFileDescriptor
  00012	8b d8		 mov	 ebx, eax

; 1377 :     if (fd < 0)

  00014	85 c0		 test	 eax, eax
  00016	79 0d		 jns	 SHORT $LN3@posix_fild

; 1378 :         return NULL;

  00018	33 c0		 xor	 eax, eax

; 1388 : }

  0001a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5e		 pop	 rsi
  00024	c3		 ret	 0
$LN3@posix_fild:

; 1379 :     if (!_PyVerify_fd(fd))

  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _PyVerify_fd
  0002c	85 c0		 test	 eax, eax
  0002e	75 0f		 jne	 SHORT $LN2@posix_fild
$LN10@posix_fild:

; 1388 : }

  00030	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5e		 pop	 rsi
  0003a	e9 00 00 00 00	 jmp	 posix_error
$LN2@posix_fild:
  0003f	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 1380 :         return posix_error();
; 1381 :     Py_BEGIN_ALLOW_THREADS

  00044	e8 00 00 00 00	 call	 PyEval_SaveThread

; 1382 :     res = (*func)(fd);

  00049	8b cb		 mov	 ecx, ebx
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	ff d6		 call	 rsi

; 1383 :     Py_END_ALLOW_THREADS

  00050	48 8b cf	 mov	 rcx, rdi
  00053	8b d8		 mov	 ebx, eax
  00055	e8 00 00 00 00	 call	 PyEval_RestoreThread
  0005a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 1384 :     if (res < 0)

  0005f	85 db		 test	 ebx, ebx

; 1385 :         return posix_error();

  00061	78 cd		 js	 SHORT $LN10@posix_fild

; 1386 :     Py_INCREF(Py_None);

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 3c		 jne	 SHORT $LN7@posix_fild
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 09		 jne	 SHORT $LN6@posix_fild
  00098	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0009f	74 07		 je	 SHORT $LN7@posix_fild
$LN6@posix_fild:
  000a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@posix_fild:

; 1387 :     return Py_None;

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1388 : }

  000af	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5e		 pop	 rsi
  000b9	c3		 ret	 0
posix_fildes ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
EXTRN	__imp_SetEnvironmentVariableA:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_GetCurrentDirectoryA:PROC
EXTRN	__imp_SetCurrentDirectoryA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_chdir DD imagerel win32_chdir
	DD	imagerel win32_chdir+166
	DD	imagerel $unwind$win32_chdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_chdir DD 020701H
	DD	0270107H
xdata	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_chdir
_TEXT	SEGMENT
new_path$ = 32
path$ = 320
env$ = 328
win32_chdir PROC					; COMDAT

; 1457 : {

  00000	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 1458 :     char new_path[MAX_PATH+1];
; 1459 :     int result;
; 1460 :     char env[4] = "=x:";

  00007	c7 84 24 48 01
	00 00 3d 78 3a
	00		 mov	 DWORD PTR env$[rsp], 3831869 ; 003a783dH

; 1461 : 
; 1462 :     if(!SetCurrentDirectoryA(path))

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetCurrentDirectoryA
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN4@win32_chdi
$LN7@win32_chdi:

; 1463 :         return FALSE;

  0001c	33 c0		 xor	 eax, eax

; 1476 : }

  0001e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00025	c3		 ret	 0
$LN4@win32_chdi:

; 1464 :     result = GetCurrentDirectoryA(MAX_PATH+1, new_path);

  00026	48 8d 54 24 20	 lea	 rdx, QWORD PTR new_path$[rsp]
  0002b	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryA

; 1465 :     if (!result)

  00036	85 c0		 test	 eax, eax

; 1466 :         return FALSE;

  00038	74 e2		 je	 SHORT $LN7@win32_chdi

; 1467 :     /* In the ANSI API, there should not be any paths longer
; 1468 :        than MAX_PATH. */
; 1469 :     assert(result <= MAX_PATH+1);
; 1470 :     if (strncmp(new_path, "\\\\", 2) == 0 ||
; 1471 :         strncmp(new_path, "//", 2) == 0)

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HDBGODGB@?2?2?$AA@
  00041	48 8d 4c 24 20	 lea	 rcx, QWORD PTR new_path$[rsp]
  00046	41 b8 02 00 00
	00		 mov	 r8d, 2
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00052	85 c0		 test	 eax, eax
  00054	74 43		 je	 SHORT $LN1@win32_chdi
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CBLDBPFN@?1?1?$AA@
  0005d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR new_path$[rsp]
  00062	41 b8 02 00 00
	00		 mov	 r8d, 2
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0006e	85 c0		 test	 eax, eax
  00070	74 27		 je	 SHORT $LN1@win32_chdi

; 1474 :     env[1] = new_path[0];

  00072	0f b6 44 24 20	 movzx	 eax, BYTE PTR new_path$[rsp]

; 1475 :     return SetEnvironmentVariableA(env, new_path);

  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR new_path$[rsp]
  0007c	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR env$[rsp]
  00084	88 84 24 49 01
	00 00		 mov	 BYTE PTR env$[rsp+1], al
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEnvironmentVariableA

; 1476 : }

  00091	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00098	c3		 ret	 0
$LN1@win32_chdi:

; 1472 :         /* UNC path, nothing to do. */
; 1473 :         return TRUE;

  00099	b8 01 00 00 00	 mov	 eax, 1

; 1476 : }

  0009e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000a5	c3		 ret	 0
win32_chdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@		; `string'
PUBLIC	??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@		; `string'
EXTRN	__imp_SetEnvironmentVariableW:PROC
EXTRN	__imp_wcsncmp:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_GetCurrentDirectoryW:PROC
EXTRN	__imp_SetCurrentDirectoryW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_wchdir DD imagerel win32_wchdir
	DD	imagerel win32_wchdir+61
	DD	imagerel $unwind$win32_wchdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$win32_wchdir DD imagerel win32_wchdir+61
	DD	imagerel win32_wchdir+138
	DD	imagerel $chain$0$win32_wchdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$win32_wchdir DD imagerel win32_wchdir+138
	DD	imagerel win32_wchdir+181
	DD	imagerel $chain$2$win32_wchdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$win32_wchdir DD imagerel win32_wchdir+181
	DD	imagerel win32_wchdir+301
	DD	imagerel $chain$4$win32_wchdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$win32_wchdir DD imagerel win32_wchdir+301
	DD	imagerel win32_wchdir+323
	DD	imagerel $chain$6$win32_wchdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$win32_wchdir DD 020021H
	DD	0487400H
	DD	imagerel win32_wchdir
	DD	imagerel win32_wchdir+61
	DD	imagerel $unwind$win32_wchdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$win32_wchdir DD 020021H
	DD	0487400H
	DD	imagerel win32_wchdir
	DD	imagerel win32_wchdir+61
	DD	imagerel $unwind$win32_wchdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$win32_wchdir DD 020021H
	DD	0487400H
	DD	imagerel win32_wchdir
	DD	imagerel win32_wchdir+61
	DD	imagerel $unwind$win32_wchdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$win32_wchdir DD 020821H
	DD	0487408H
	DD	imagerel win32_wchdir
	DD	imagerel win32_wchdir+61
	DD	imagerel $unwind$win32_wchdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_wchdir DD 030901H
	DD	0460109H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@ DB '/', 00H, '/', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@ DB '\', 00H, '\', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_wchdir
_TEXT	SEGMENT
_new_path$ = 32
path$ = 576
env$ = 584
win32_wchdir PROC					; COMDAT

; 1482 : {

  00000	40 53		 push	 rbx
  00002	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H

; 1483 :     wchar_t _new_path[MAX_PATH+1], *new_path = _new_path;
; 1484 :     int result;
; 1485 :     wchar_t env[4] = L"=x:";

  00009	48 b8 3d 00 78
	00 3a 00 00 00	 mov	 rax, 249115967549	; 0000003a0078003dH
  00013	48 8d 5c 24 20	 lea	 rbx, QWORD PTR _new_path$[rsp]
  00018	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR env$[rsp], rax

; 1486 : 
; 1487 :     if(!SetCurrentDirectoryW(path))

  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetCurrentDirectoryW
  00026	85 c0		 test	 eax, eax
  00028	75 09		 jne	 SHORT $LN8@win32_wchd

; 1513 : }

  0002a	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
$LN8@win32_wchd:

; 1488 :         return FALSE;
; 1489 :     result = GetCurrentDirectoryW(MAX_PATH+1, new_path);

  00033	48 8d 54 24 20	 lea	 rdx, QWORD PTR _new_path$[rsp]
  00038	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  0003d	48 89 bc 24 40
	02 00 00	 mov	 QWORD PTR [rsp+576], rdi
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  0004b	48 63 f8	 movsxd	 rdi, eax

; 1490 :     if (!result)

  0004e	85 c0		 test	 eax, eax

; 1491 :         return FALSE;

  00050	74 50		 je	 SHORT $LN12@win32_wchd

; 1492 :     if (result > MAX_PATH+1) {

  00052	81 ff 05 01 00
	00		 cmp	 edi, 261		; 00000105H
  00058	7e 5b		 jle	 SHORT $LN4@win32_wchd

; 1493 :         new_path = malloc(result * sizeof(wchar_t));

  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	48 03 c9	 add	 rcx, rcx
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00066	48 8b d8	 mov	 rbx, rax

; 1494 :         if (!new_path) {

  00069	48 85 c0	 test	 rax, rax
  0006c	75 1c		 jne	 SHORT $LN5@win32_wchd

; 1495 :             SetLastError(ERROR_OUTOFMEMORY);

  0006e	8d 48 0e	 lea	 ecx, QWORD PTR [rax+14]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
  00077	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 1496 :             return FALSE;

  0007f	33 c0		 xor	 eax, eax

; 1513 : }

  00081	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00088	5b		 pop	 rbx
  00089	c3		 ret	 0
$LN5@win32_wchd:

; 1497 :         }
; 1498 :         result = GetCurrentDirectoryW(result, new_path);

  0008a	48 8b d0	 mov	 rdx, rax
  0008d	8b cf		 mov	 ecx, edi
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW

; 1499 :         if (!result) {

  00095	85 c0		 test	 eax, eax
  00097	75 1c		 jne	 SHORT $LN4@win32_wchd

; 1500 :             free(new_path);

  00099	48 8b cb	 mov	 rcx, rbx
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@win32_wchd:

; 1501 :             return FALSE;

  000a2	33 c0		 xor	 eax, eax
  000a4	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 1513 : }

  000ac	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  000b3	5b		 pop	 rbx
  000b4	c3		 ret	 0
$LN4@win32_wchd:

; 1502 :         }
; 1503 :     }
; 1504 :     if (wcsncmp(new_path, L"\\\\", 2) == 0 ||
; 1505 :         wcsncmp(new_path, L"//", 2) == 0)

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@
  000bc	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c2	48 8b cb	 mov	 rcx, rbx
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncmp
  000cb	85 c0		 test	 eax, eax
  000cd	74 5e		 je	 SHORT $LN2@win32_wchd
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@
  000d6	41 b8 02 00 00
	00		 mov	 r8d, 2
  000dc	48 8b cb	 mov	 rcx, rbx
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncmp
  000e5	85 c0		 test	 eax, eax
  000e7	74 44		 je	 SHORT $LN2@win32_wchd

; 1508 :     env[1] = new_path[0];

  000e9	0f b7 03	 movzx	 eax, WORD PTR [rbx]

; 1509 :     result = SetEnvironmentVariableW(env, new_path);

  000ec	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR env$[rsp]
  000f4	48 8b d3	 mov	 rdx, rbx
  000f7	66 89 84 24 4a
	02 00 00	 mov	 WORD PTR env$[rsp+2], ax
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEnvironmentVariableW
  00105	8b f8		 mov	 edi, eax

; 1510 :     if (new_path != _new_path)

  00107	48 8d 44 24 20	 lea	 rax, QWORD PTR _new_path$[rsp]
  0010c	48 3b d8	 cmp	 rbx, rax
  0010f	74 09		 je	 SHORT $LN1@win32_wchd

; 1511 :         free(new_path);

  00111	48 8b cb	 mov	 rcx, rbx
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@win32_wchd:

; 1512 :     return result;

  0011a	8b c7		 mov	 eax, edi
  0011c	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 1513 : }

  00124	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  0012b	5b		 pop	 rbx
  0012c	c3		 ret	 0
$LN2@win32_wchd:

; 1506 :         /* UNC path, nothing to do. */
; 1507 :         return TRUE;

  0012d	b8 01 00 00 00	 mov	 eax, 1
  00132	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 1513 : }

  0013a	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00141	5b		 pop	 rbx
  00142	c3		 ret	 0
win32_wchdir ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT FILE_TIME_to_time_t_nsec
_TEXT	SEGMENT
in_ptr$ = 8
time_out$ = 16
nsec_out$ = 24
FILE_TIME_to_time_t_nsec PROC				; COMDAT

; 1547 :     /* XXX endianness. Shouldn't matter, as all Windows implementations are little-endian */
; 1548 :     /* Cannot simply cast and dereference in_ptr,
; 1549 :        since it might not be aligned properly */
; 1550 :     __int64 in;
; 1551 :     memcpy(&in, in_ptr, sizeof(in));

  00000	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00003	4c 8b d2	 mov	 r10, rdx

; 1552 :     *nsec_out = (int)(in % 10000000) * 100; /* FILETIME is in units of 100 nsec. */

  00006	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
  00010	49 f7 e9	 imul	 r9
  00013	49 03 d1	 add	 rdx, r9
  00016	48 c1 fa 17	 sar	 rdx, 23
  0001a	48 8b c2	 mov	 rax, rdx
  0001d	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00021	48 03 d0	 add	 rdx, rax
  00024	8b c2		 mov	 eax, edx

; 1553 :     *time_out = Py_SAFE_DOWNCAST((in / 10000000) - secs_between_epochs, __int64, time_t);

  00026	48 2b 15 00 00
	00 00		 sub	 rdx, QWORD PTR secs_between_epochs
  0002d	69 c0 80 96 98
	00		 imul	 eax, 10000000		; 00989680H
  00033	44 2b c8	 sub	 r9d, eax
  00036	45 6b c9 64	 imul	 r9d, 100		; 00000064H
  0003a	45 89 08	 mov	 DWORD PTR [r8], r9d
  0003d	49 89 12	 mov	 QWORD PTR [r10], rdx

; 1554 : }

  00040	c3		 ret	 0
FILE_TIME_to_time_t_nsec ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_t_to_FILE_TIME
_TEXT	SEGMENT
time_in$ = 8
nsec_in$ = 16
out_ptr$ = 24
time_t_to_FILE_TIME PROC				; COMDAT

; 1559 :     /* XXX endianness */
; 1560 :     __int64 out;
; 1561 :     out = time_in + secs_between_epochs;
; 1562 :     out = out * 10000000 + nsec_in / 100;
; 1563 :     memcpy(out_ptr, &out, sizeof(out));

  00000	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR secs_between_epochs
  00007	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0000c	4c 03 c9	 add	 r9, rcx
  0000f	f7 ea		 imul	 edx
  00011	c1 fa 05	 sar	 edx, 5
  00014	8b c2		 mov	 eax, edx
  00016	c1 e8 1f	 shr	 eax, 31
  00019	03 c2		 add	 eax, edx
  0001b	48 98		 cdqe
  0001d	4d 69 c9 80 96
	98 00		 imul	 r9, 10000000		; 00989680H
  00024	4c 03 c8	 add	 r9, rax
  00027	4d 89 08	 mov	 QWORD PTR [r8], r9

; 1564 : }

  0002a	c3		 ret	 0
time_t_to_FILE_TIME ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT attributes_to_mode
_TEXT	SEGMENT
attr$ = 8
attributes_to_mode PROC					; COMDAT

; 1573 :     int m = 0;
; 1574 :     if (attr & FILE_ATTRIBUTE_DIRECTORY)

  00000	f6 c1 10	 test	 cl, 16
  00003	b8 00 80 00 00	 mov	 eax, 32768		; 00008000H
  00008	ba 49 40 00 00	 mov	 edx, 16457		; 00004049H
  0000d	0f 45 c2	 cmovne	 eax, edx

; 1575 :         m |= _S_IFDIR | 0111; /* IFEXEC for user,group,other */
; 1576 :     else
; 1577 :         m |= _S_IFREG;
; 1578 :     if (attr & FILE_ATTRIBUTE_READONLY)

  00010	f6 c1 01	 test	 cl, 1
  00013	74 06		 je	 SHORT $LN2@attributes

; 1579 :         m |= 0444;

  00015	0d 24 01 00 00	 or	 eax, 292		; 00000124H

; 1582 :     return m;
; 1583 : }

  0001a	c3		 ret	 0
$LN2@attributes:

; 1580 :     else
; 1581 :         m |= 0666;

  0001b	0d b6 01 00 00	 or	 eax, 438		; 000001b6H

; 1582 :     return m;
; 1583 : }

  00020	c3		 ret	 0
attributes_to_mode ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$attribute_data_to_stat DD imagerel attribute_data_to_stat
	DD	imagerel attribute_data_to_stat+184
	DD	imagerel $unwind$attribute_data_to_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attribute_data_to_stat DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT attribute_data_to_stat
_TEXT	SEGMENT
info$ = 48
reparse_tag$ = 56
result$ = 64
attribute_data_to_stat PROC				; COMDAT

; 1587 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f0	 mov	 rsi, r8
  00012	8b fa		 mov	 edi, edx

; 1588 :     memset(result, 0, sizeof(*result));

  00014	33 d2		 xor	 edx, edx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	44 8d 42 60	 lea	 r8d, QWORD PTR [rdx+96]
  0001d	48 8b ce	 mov	 rcx, rsi
  00020	e8 00 00 00 00	 call	 memset

; 1589 :     result->st_mode = attributes_to_mode(info->dwFileAttributes);

  00025	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00027	e8 00 00 00 00	 call	 attributes_to_mode

; 1590 :     result->st_size = (((__int64)info->nFileSizeHigh)<<32) + info->nFileSizeLow;
; 1591 :     FILE_TIME_to_time_t_nsec(&info->ftCreationTime, &result->st_ctime, &result->st_ctime_nsec);

  0002c	4c 8d 46 58	 lea	 r8, QWORD PTR [rsi+88]
  00030	48 8d 56 50	 lea	 rdx, QWORD PTR [rsi+80]
  00034	66 89 46 10	 mov	 WORD PTR [rsi+16], ax
  00038	44 8b 4b 20	 mov	 r9d, DWORD PTR [rbx+32]
  0003c	8b 43 24	 mov	 eax, DWORD PTR [rbx+36]
  0003f	49 c1 e1 20	 shl	 r9, 32			; 00000020H
  00043	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00047	4c 03 c8	 add	 r9, rax
  0004a	4c 89 4e 28	 mov	 QWORD PTR [rsi+40], r9
  0004e	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1592 :     FILE_TIME_to_time_t_nsec(&info->ftLastWriteTime, &result->st_mtime, &result->st_mtime_nsec);

  00053	4c 8d 46 48	 lea	 r8, QWORD PTR [rsi+72]
  00057	48 8d 56 40	 lea	 rdx, QWORD PTR [rsi+64]
  0005b	48 8d 4b 14	 lea	 rcx, QWORD PTR [rbx+20]
  0005f	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1593 :     FILE_TIME_to_time_t_nsec(&info->ftLastAccessTime, &result->st_atime, &result->st_atime_nsec);

  00064	4c 8d 46 38	 lea	 r8, QWORD PTR [rsi+56]
  00068	48 8d 56 30	 lea	 rdx, QWORD PTR [rsi+48]
  0006c	48 8d 4b 0c	 lea	 rcx, QWORD PTR [rbx+12]
  00070	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1594 :     result->st_nlink = info->nNumberOfLinks;

  00075	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  00078	89 4e 14	 mov	 DWORD PTR [rsi+20], ecx

; 1595 :     result->st_ino = (((__int64)info->nFileIndexHigh)<<32) + info->nFileIndexLow;

  0007b	8b 4b 2c	 mov	 ecx, DWORD PTR [rbx+44]
  0007e	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  00081	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  00085	48 03 c8	 add	 rcx, rax
  00088	48 89 4e 08	 mov	 QWORD PTR [rsi+8], rcx

; 1596 :     if (reparse_tag == IO_REPARSE_TAG_SYMLINK) {

  0008c	81 ff 0c 00 00
	a0		 cmp	 edi, -1610612724	; a000000cH
  00092	75 12		 jne	 SHORT $LN4@attribute_

; 1597 :         /* first clear the S_IFMT bits */
; 1598 :         result->st_mode ^= (result->st_mode & 0170000);

  00094	b8 ff 0f 00 00	 mov	 eax, 4095		; 00000fffH
  00099	66 21 46 10	 and	 WORD PTR [rsi+16], ax

; 1599 :         /* now set the bits that make this a symlink */
; 1600 :         result->st_mode |= 0120000;

  0009d	b8 00 a0 00 00	 mov	 eax, 40960		; 0000a000H
  000a2	66 09 46 10	 or	 WORD PTR [rsi+16], ax
$LN4@attribute_:

; 1601 :     }
; 1602 : 
; 1603 :     return 0;
; 1604 : }

  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ab	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b0	33 c0		 xor	 eax, eax
  000b2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
attribute_data_to_stat ENDP
_TEXT	ENDS
EXTRN	__imp_FindClose:PROC
EXTRN	__imp_FindFirstFileA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$attributes_from_dir DD imagerel attributes_from_dir
	DD	imagerel attributes_from_dir+165
	DD	imagerel $unwind$attributes_from_dir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attributes_from_dir DD 050d01H
	DD	02e340dH
	DD	02c010dH
	DD	07006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT attributes_from_dir
_TEXT	SEGMENT
FileData$ = 32
pszFile$ = 368
info$ = 376
reparse_tag$ = 384
attributes_from_dir PROC				; COMDAT

; 1608 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  0000d	48 8b fa	 mov	 rdi, rdx

; 1609 :     HANDLE hFindFile;
; 1610 :     WIN32_FIND_DATAA FileData;
; 1611 :     hFindFile = FindFirstFileA(pszFile, &FileData);

  00010	48 8d 54 24 20	 lea	 rdx, QWORD PTR FileData$[rsp]
  00015	49 8b d8	 mov	 rbx, r8
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA

; 1612 :     if (hFindFile == INVALID_HANDLE_VALUE)

  0001e	48 83 f8 ff	 cmp	 rax, -1
  00022	75 13		 jne	 SHORT $LN2@attributes@2

; 1613 :         return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1627 : }

  00026	48 8b 9c 24 70
	01 00 00	 mov	 rbx, QWORD PTR [rsp+368]
  0002e	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN2@attributes@2:

; 1614 :     FindClose(hFindFile);

  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 1615 :     memset(info, 0, sizeof(*info));

  00040	33 d2		 xor	 edx, edx
  00042	48 8b cf	 mov	 rcx, rdi
  00045	44 8d 42 34	 lea	 r8d, QWORD PTR [rdx+52]
  00049	e8 00 00 00 00	 call	 memset

; 1616 :     *reparse_tag = 0;
; 1617 :     info->dwFileAttributes = FileData.dwFileAttributes;
; 1618 :     info->ftCreationTime   = FileData.ftCreationTime;

  0004e	48 8b 44 24 24	 mov	 rax, QWORD PTR FileData$[rsp+4]
  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR FileData$[rsp]
  00057	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  0005d	48 89 47 04	 mov	 QWORD PTR [rdi+4], rax

; 1619 :     info->ftLastAccessTime = FileData.ftLastAccessTime;

  00061	48 8b 44 24 2c	 mov	 rax, QWORD PTR FileData$[rsp+12]
  00066	48 89 47 0c	 mov	 QWORD PTR [rdi+12], rax

; 1620 :     info->ftLastWriteTime  = FileData.ftLastWriteTime;

  0006a	48 8b 44 24 34	 mov	 rax, QWORD PTR FileData$[rsp+20]
  0006f	89 0f		 mov	 DWORD PTR [rdi], ecx
  00071	48 89 47 14	 mov	 QWORD PTR [rdi+20], rax

; 1621 :     info->nFileSizeHigh    = FileData.nFileSizeHigh;

  00075	8b 44 24 3c	 mov	 eax, DWORD PTR FileData$[rsp+28]
  00079	89 47 20	 mov	 DWORD PTR [rdi+32], eax

; 1622 :     info->nFileSizeLow     = FileData.nFileSizeLow;

  0007c	8b 44 24 40	 mov	 eax, DWORD PTR FileData$[rsp+32]
  00080	89 47 24	 mov	 DWORD PTR [rdi+36], eax

; 1623 : /*  info->nNumberOfLinks   = 1; */
; 1624 :     if (FileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

  00083	0f ba e1 0a	 bt	 ecx, 10
  00087	73 06		 jae	 SHORT $LN1@attributes@2

; 1625 :         *reparse_tag = FileData.dwReserved0;

  00089	8b 44 24 44	 mov	 eax, DWORD PTR FileData$[rsp+36]
  0008d	89 03		 mov	 DWORD PTR [rbx], eax
$LN1@attributes@2:

; 1626 :     return TRUE;

  0008f	b8 01 00 00 00	 mov	 eax, 1

; 1627 : }

  00094	48 8b 9c 24 70
	01 00 00	 mov	 rbx, QWORD PTR [rsp+368]
  0009c	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
attributes_from_dir ENDP
_TEXT	ENDS
EXTRN	__imp_FindFirstFileW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$attributes_from_dir_w DD imagerel attributes_from_dir_w
	DD	imagerel attributes_from_dir_w+165
	DD	imagerel $unwind$attributes_from_dir_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attributes_from_dir_w DD 050d01H
	DD	050340dH
	DD	04e010dH
	DD	07006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT attributes_from_dir_w
_TEXT	SEGMENT
FileData$ = 32
pszFile$ = 640
info$ = 648
reparse_tag$ = 656
attributes_from_dir_w PROC				; COMDAT

; 1631 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  0000d	48 8b fa	 mov	 rdi, rdx

; 1632 :     HANDLE hFindFile;
; 1633 :     WIN32_FIND_DATAW FileData;
; 1634 :     hFindFile = FindFirstFileW(pszFile, &FileData);

  00010	48 8d 54 24 20	 lea	 rdx, QWORD PTR FileData$[rsp]
  00015	49 8b d8	 mov	 rbx, r8
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW

; 1635 :     if (hFindFile == INVALID_HANDLE_VALUE)

  0001e	48 83 f8 ff	 cmp	 rax, -1
  00022	75 13		 jne	 SHORT $LN2@attributes@3

; 1636 :         return FALSE;

  00024	33 c0		 xor	 eax, eax

; 1650 : }

  00026	48 8b 9c 24 80
	02 00 00	 mov	 rbx, QWORD PTR [rsp+640]
  0002e	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
$LN2@attributes@3:

; 1637 :     FindClose(hFindFile);

  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 1638 :     memset(info, 0, sizeof(*info));

  00040	33 d2		 xor	 edx, edx
  00042	48 8b cf	 mov	 rcx, rdi
  00045	44 8d 42 34	 lea	 r8d, QWORD PTR [rdx+52]
  00049	e8 00 00 00 00	 call	 memset

; 1639 :     *reparse_tag = 0;
; 1640 :     info->dwFileAttributes = FileData.dwFileAttributes;
; 1641 :     info->ftCreationTime   = FileData.ftCreationTime;

  0004e	48 8b 44 24 24	 mov	 rax, QWORD PTR FileData$[rsp+4]
  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR FileData$[rsp]
  00057	c7 03 00 00 00
	00		 mov	 DWORD PTR [rbx], 0
  0005d	48 89 47 04	 mov	 QWORD PTR [rdi+4], rax

; 1642 :     info->ftLastAccessTime = FileData.ftLastAccessTime;

  00061	48 8b 44 24 2c	 mov	 rax, QWORD PTR FileData$[rsp+12]
  00066	48 89 47 0c	 mov	 QWORD PTR [rdi+12], rax

; 1643 :     info->ftLastWriteTime  = FileData.ftLastWriteTime;

  0006a	48 8b 44 24 34	 mov	 rax, QWORD PTR FileData$[rsp+20]
  0006f	89 0f		 mov	 DWORD PTR [rdi], ecx
  00071	48 89 47 14	 mov	 QWORD PTR [rdi+20], rax

; 1644 :     info->nFileSizeHigh    = FileData.nFileSizeHigh;

  00075	8b 44 24 3c	 mov	 eax, DWORD PTR FileData$[rsp+28]
  00079	89 47 20	 mov	 DWORD PTR [rdi+32], eax

; 1645 :     info->nFileSizeLow     = FileData.nFileSizeLow;

  0007c	8b 44 24 40	 mov	 eax, DWORD PTR FileData$[rsp+32]
  00080	89 47 24	 mov	 DWORD PTR [rdi+36], eax

; 1646 : /*  info->nNumberOfLinks   = 1; */
; 1647 :     if (FileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

  00083	0f ba e1 0a	 bt	 ecx, 10
  00087	73 06		 jae	 SHORT $LN1@attributes@3

; 1648 :         *reparse_tag = FileData.dwReserved0;

  00089	8b 44 24 44	 mov	 eax, DWORD PTR FileData$[rsp+36]
  0008d	89 03		 mov	 DWORD PTR [rbx], eax
$LN1@attributes@3:

; 1649 :     return TRUE;

  0008f	b8 01 00 00 00	 mov	 eax, 1

; 1650 : }

  00094	48 8b 9c 24 80
	02 00 00	 mov	 rbx, QWORD PTR [rsp+640]
  0009c	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000a3	5f		 pop	 rdi
  000a4	c3		 ret	 0
attributes_from_dir_w ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@ ; `string'
PUBLIC	??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ ; `string'
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleW:PROC
_BSS	SEGMENT
Py_GetFinalPathNameByHandleW DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_GetFinalPathNameByHandle DD imagerel check_GetFinalPathNameByHandle
	DD	imagerel check_GetFinalPathNameByHandle+21
	DD	imagerel $unwind$check_GetFinalPathNameByHandle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$check_GetFinalPathNameByHandle DD imagerel check_GetFinalPathNameByHandle+21
	DD	imagerel check_GetFinalPathNameByHandle+97
	DD	imagerel $chain$1$check_GetFinalPathNameByHandle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$check_GetFinalPathNameByHandle DD imagerel check_GetFinalPathNameByHandle+97
	DD	imagerel check_GetFinalPathNameByHandle+139
	DD	imagerel $chain$2$check_GetFinalPathNameByHandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$check_GetFinalPathNameByHandle DD 021H
	DD	imagerel check_GetFinalPathNameByHandle
	DD	imagerel check_GetFinalPathNameByHandle+21
	DD	imagerel $unwind$check_GetFinalPathNameByHandle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$check_GetFinalPathNameByHandle DD 040a21H
	DD	04740aH
	DD	063405H
	DD	imagerel check_GetFinalPathNameByHandle
	DD	imagerel check_GetFinalPathNameByHandle+21
	DD	imagerel $unwind$check_GetFinalPathNameByHandle
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_GetFinalPathNameByHandle DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@
CONST	SEGMENT
??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@ DB 'GetFinalPathNameByHa'
	DB	'ndleW', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@
CONST	SEGMENT
??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@ DB 'GetFinalPathNameByH'
	DB	'andleA', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ DB 'K'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'E', 00H, 'L', 00H, '3', 00H
	DB	'2', 00H, 00H, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_GetFinalPathNameByHandle
_TEXT	SEGMENT
check_GetFinalPathNameByHandle PROC			; COMDAT

; 1658 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1659 :     HINSTANCE hKernel32;
; 1660 :     DWORD (CALLBACK *Py_GetFinalPathNameByHandleA)(HANDLE, LPSTR, DWORD,
; 1661 :                                                    DWORD);
; 1662 : 
; 1663 :     /* only recheck */
; 1664 :     if (!has_GetFinalPathNameByHandle)

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR has_GetFinalPathNameByHandle
  0000a	85 c0		 test	 eax, eax
  0000c	75 78		 jne	 SHORT $LN6@check_GetF

; 1665 :     {
; 1666 :         hKernel32 = GetModuleHandleW(L"KERNEL32");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
  00015	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW

; 1667 :         *(FARPROC*)&Py_GetFinalPathNameByHandleA = GetProcAddress(hKernel32,
; 1668 :                                                 "GetFinalPathNameByHandleA");

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	48 8b d8	 mov	 rbx, rax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress

; 1669 :         *(FARPROC*)&Py_GetFinalPathNameByHandleW = GetProcAddress(hKernel32,
; 1670 :                                                 "GetFinalPathNameByHandleW");

  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	48 8b f8	 mov	 rdi, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0004b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1671 :         has_GetFinalPathNameByHandle = Py_GetFinalPathNameByHandleA &&
; 1672 :                                        Py_GetFinalPathNameByHandleW;

  00050	48 85 ff	 test	 rdi, rdi
  00053	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00058	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_GetFinalPathNameByHandleW, rax
  0005f	74 19		 je	 SHORT $LN4@check_GetF
  00061	48 85 c0	 test	 rax, rax
  00064	74 14		 je	 SHORT $LN4@check_GetF
  00066	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR has_GetFinalPathNameByHandle, 1

; 1673 :     }
; 1674 :     return has_GetFinalPathNameByHandle;

  00070	b8 01 00 00 00	 mov	 eax, 1

; 1675 : }

  00075	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00079	c3		 ret	 0
$LN4@check_GetF:

; 1671 :         has_GetFinalPathNameByHandle = Py_GetFinalPathNameByHandleA &&
; 1672 :                                        Py_GetFinalPathNameByHandleW;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR has_GetFinalPathNameByHandle, 0

; 1673 :     }
; 1674 :     return has_GetFinalPathNameByHandle;

  00084	33 c0		 xor	 eax, eax
$LN6@check_GetF:

; 1675 : }

  00086	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008a	c3		 ret	 0
check_GetFinalPathNameByHandle ENDP
_TEXT	ENDS
EXTRN	__imp_CloseHandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_target_path DD imagerel get_target_path
	DD	imagerel get_target_path+182
	DD	imagerel $unwind$get_target_path
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_target_path DD 084001H
	DD	063440H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_target_path
_TEXT	SEGMENT
hdl$ = 48
target_path$ = 56
get_target_path PROC					; COMDAT

; 1679 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b ea	 mov	 rbp, rdx

; 1680 :     int buf_size, result_length;
; 1681 :     wchar_t *buf;
; 1682 : 
; 1683 :     /* We have a good handle to the target, use it to determine
; 1684 :        the target path name (then we'll call lstat on it). */
; 1685 :     buf_size = Py_GetFinalPathNameByHandleW(hdl, 0, 0,
; 1686 :                                             VOLUME_NAME_DOS);

  00012	45 33 c9	 xor	 r9d, r9d
  00015	45 33 c0	 xor	 r8d, r8d
  00018	33 d2		 xor	 edx, edx
  0001a	48 8b f1	 mov	 rsi, rcx
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  00023	8b f8		 mov	 edi, eax

; 1687 :     if(!buf_size)

  00025	85 c0		 test	 eax, eax
  00027	75 10		 jne	 SHORT $LN4@get_target

; 1713 : }

  00029	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0002e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN4@get_target:

; 1688 :         return FALSE;
; 1689 : 
; 1690 :     buf = (wchar_t *)malloc((buf_size+1)*sizeof(wchar_t));

  00039	ff c0		 inc	 eax
  0003b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00040	48 63 c8	 movsxd	 rcx, eax
  00043	48 03 c9	 add	 rcx, rcx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004c	48 8b d8	 mov	 rbx, rax

; 1691 :     if (!buf) {

  0004f	48 85 c0	 test	 rax, rax
  00052	75 0d		 jne	 SHORT $LN3@get_target

; 1692 :         SetLastError(ERROR_OUTOFMEMORY);

  00054	8d 48 0e	 lea	 ecx, QWORD PTR [rax+14]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1693 :         return FALSE;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 40		 jmp	 SHORT $LN7@get_target
$LN3@get_target:

; 1694 :     }
; 1695 : 
; 1696 :     result_length = Py_GetFinalPathNameByHandleW(hdl,
; 1697 :                        buf, buf_size, VOLUME_NAME_DOS);

  00061	45 33 c9	 xor	 r9d, r9d
  00064	44 8b c7	 mov	 r8d, edi
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b ce	 mov	 rcx, rsi
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  00073	48 63 f8	 movsxd	 rdi, eax

; 1698 : 
; 1699 :     if(!result_length) {

  00076	85 c0		 test	 eax, eax

; 1700 :         free(buf);
; 1701 :         return FALSE;

  00078	74 0d		 je	 SHORT $LN8@get_target

; 1702 :     }
; 1703 : 
; 1704 :     if(!CloseHandle(hdl)) {

  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00083	85 c0		 test	 eax, eax
  00085	75 0d		 jne	 SHORT $LN1@get_target
$LN8@get_target:

; 1705 :         free(buf);

  00087	48 8b cb	 mov	 rcx, rbx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1706 :         return FALSE;

  00090	33 c0		 xor	 eax, eax
  00092	eb 0d		 jmp	 SHORT $LN7@get_target
$LN1@get_target:

; 1707 :     }
; 1708 : 
; 1709 :     buf[result_length] = 0;

  00094	33 c9		 xor	 ecx, ecx
  00096	66 89 0c 7b	 mov	 WORD PTR [rbx+rdi*2], cx

; 1710 : 
; 1711 :     *target_path = buf;

  0009a	48 89 5d 00	 mov	 QWORD PTR [rbp], rbx

; 1712 :     return TRUE;

  0009e	8d 41 01	 lea	 eax, QWORD PTR [rcx+1]
$LN7@get_target:

; 1713 : }

  000a1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a6	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000ab	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
get_target_path ENDP
_TEXT	ENDS
PUBLIC	??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@	; `string'
PUBLIC	??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@	; `string'
PUBLIC	??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@	; `string'
EXTRN	__imp__wcsicmp:PROC
EXTRN	__imp_wcsrchr:PROC
EXTRN	__imp_GetFileInformationByHandle:PROC
EXTRN	__imp_CreateFileW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_impl_w DD imagerel win32_xstat_impl_w
	DD	imagerel win32_xstat_impl_w+559
	DD	imagerel $unwind$win32_xstat_impl_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_impl_w DD 061401H
	DD	0153414H
	DD	0700df214H
	DD	0500b600cH
xdata	ENDS
;	COMDAT ??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@ DB '.', 00H, 'c', 00H, 'o'
	DB	00H, 'm', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '.', 00H, 'e', 00H, 'x'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@ DB '.', 00H, 'c', 00H, 'm'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@ DB '.', 00H, 'b', 00H, 'a'
	DB	00H, 't', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_xstat_impl_w
_TEXT	SEGMENT
info$ = 64
path$ = 160
result$ = 168
traverse$ = 176
target_path$ = 184
reparse_tag$ = 184
win32_xstat_impl_w PROC					; COMDAT

; 1817 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1818 :     int code;
; 1819 :     HANDLE hFile, hFile2;
; 1820 :     BY_HANDLE_FILE_INFORMATION info;
; 1821 :     ULONG reparse_tag = 0;

  00014	33 f6		 xor	 esi, esi
  00016	41 8b e8	 mov	 ebp, r8d
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	89 b4 24 b8 00
	00 00		 mov	 DWORD PTR reparse_tag$[rsp], esi
  00023	48 8b d9	 mov	 rbx, rcx

; 1822 :     wchar_t *target_path;
; 1823 :     const wchar_t *dot;
; 1824 : 
; 1825 :     if(!check_GetFinalPathNameByHandle()) {

  00026	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  0002b	85 c0		 test	 eax, eax

; 1826 :         /* If the OS doesn't have GetFinalPathNameByHandle, don't
; 1827 :            traverse reparse point. */
; 1828 :         traverse = FALSE;
; 1829 :     }
; 1830 : 
; 1831 :     hFile = CreateFileW(
; 1832 :         path,
; 1833 :         FILE_READ_ATTRIBUTES, /* desired access */
; 1834 :         0, /* share mode */
; 1835 :         NULL, /* security attributes */
; 1836 :         OPEN_EXISTING,
; 1837 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 1838 :         /* FILE_FLAG_OPEN_REPARSE_POINT does not follow the symlink.
; 1839 :            Because of this, calls like GetFinalPathNameByHandle will return
; 1840 :            the symlink path again and not the actual final path. */
; 1841 :         FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS|
; 1842 :             FILE_FLAG_OPEN_REPARSE_POINT,
; 1843 :         NULL);

  0002d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00032	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00037	0f 44 ee	 cmove	 ebp, esi
  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	45 33 c0	 xor	 r8d, r8d
  00040	48 8b cb	 mov	 rcx, rbx
  00043	c7 44 24 28 80
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651712 ; 02200080H
  0004b	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  00059	48 8b d8	 mov	 rbx, rax

; 1844 : 
; 1845 :     if (hFile == INVALID_HANDLE_VALUE) {

  0005c	48 83 f8 ff	 cmp	 rax, -1
  00060	75 53		 jne	 SHORT $LN17@win32_xsta

; 1846 :         /* Either the target doesn't exist, or we don't have access to
; 1847 :            get a handle to it. If the former, we need to return an error.
; 1848 :            If the latter, we can use attributes_from_dir. */
; 1849 :         if (GetLastError() != ERROR_SHARING_VIOLATION)

  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00068	83 f8 20	 cmp	 eax, 32			; 00000020H

; 1850 :             return -1;

  0006b	75 40		 jne	 SHORT $LN23@win32_xsta

; 1851 :         /* Could not get attributes on open file. Fall back to
; 1852 :            reading the directory. */
; 1853 :         if (!attributes_from_dir_w(path, &info, &reparse_tag))

  0006d	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR path$[rsp]
  00075	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR reparse_tag$[rsp]
  0007d	48 8d 54 24 40	 lea	 rdx, QWORD PTR info$[rsp]
  00082	48 8b cb	 mov	 rcx, rbx
  00085	e8 00 00 00 00	 call	 attributes_from_dir_w
  0008a	85 c0		 test	 eax, eax

; 1854 :             /* Very strange. This should not fail now */
; 1855 :             return -1;

  0008c	74 1f		 je	 SHORT $LN23@win32_xsta

; 1856 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  0008e	f7 44 24 40 00
	04 00 00	 test	 DWORD PTR info$[rsp], 1024 ; 00000400H
  00096	0f 84 ed 00 00
	00		 je	 $LN21@win32_xsta

; 1857 :             if (traverse) {

  0009c	85 ed		 test	 ebp, ebp
  0009e	0f 84 e5 00 00
	00		 je	 $LN21@win32_xsta

; 1858 :                 /* Should traverse, but could not open reparse point handle */
; 1859 :                 SetLastError(ERROR_SHARING_VIOLATION);

  000a4	8d 4e 20	 lea	 ecx, QWORD PTR [rsi+32]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
$LN23@win32_xsta:

; 1860 :                 return -1;

  000ad	83 c8 ff	 or	 eax, -1
  000b0	e9 67 01 00 00	 jmp	 $LN19@win32_xsta
$LN17@win32_xsta:

; 1861 :             }
; 1862 :         }
; 1863 :     } else {
; 1864 :         if (!GetFileInformationByHandle(hFile, &info)) {

  000b5	48 8d 54 24 40	 lea	 rdx, QWORD PTR info$[rsp]
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle

; 1865 :             CloseHandle(hFile);

  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	85 c0		 test	 eax, eax
  000c8	75 0e		 jne	 SHORT $LN11@win32_xsta
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1866 :             return -1;

  000d0	83 c8 ff	 or	 eax, -1
  000d3	e9 44 01 00 00	 jmp	 $LN19@win32_xsta
$LN11@win32_xsta:

; 1867 :         }
; 1868 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  000d8	f7 44 24 40 00
	04 00 00	 test	 DWORD PTR info$[rsp], 1024 ; 00000400H
  000e0	0f 84 ac 00 00
	00		 je	 $LN10@win32_xsta

; 1869 :             if (!win32_get_reparse_tag(hFile, &reparse_tag))

  000e6	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR reparse_tag$[rsp]
  000ee	e8 00 00 00 00	 call	 win32_get_reparse_tag
  000f3	85 c0		 test	 eax, eax

; 1870 :                 return -1;

  000f5	74 b6		 je	 SHORT $LN23@win32_xsta

; 1871 : 
; 1872 :             /* Close the outer open file handle now that we're about to
; 1873 :                reopen it with different flags. */
; 1874 :             if (!CloseHandle(hFile))

  000f7	48 8b cb	 mov	 rcx, rbx
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00100	85 c0		 test	 eax, eax

; 1875 :                 return -1;

  00102	74 a9		 je	 SHORT $LN23@win32_xsta

; 1876 : 
; 1877 :             if (traverse) {

  00104	85 ed		 test	 ebp, ebp
  00106	74 79		 je	 SHORT $LN22@win32_xsta

; 1878 :                 /* In order to call GetFinalPathNameByHandle we need to open
; 1879 :                    the file without the reparse handling flag set. */
; 1880 :                 hFile2 = CreateFileW(
; 1881 :                            path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ,
; 1882 :                            NULL, OPEN_EXISTING,
; 1883 :                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
; 1884 :                            NULL);

  00108	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00110	45 33 c9	 xor	 r9d, r9d
  00113	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00118	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0011c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00121	c7 44 24 28 80
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554560 ; 02000080H
  00129	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW

; 1885 :                 if (hFile2 == INVALID_HANDLE_VALUE)

  00137	48 83 f8 ff	 cmp	 rax, -1

; 1886 :                     return -1;

  0013b	0f 84 6c ff ff
	ff		 je	 $LN23@win32_xsta

; 1887 : 
; 1888 :                 if (!get_target_path(hFile2, &target_path))

  00141	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR target_path$[rsp]
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 get_target_path
  00151	85 c0		 test	 eax, eax

; 1889 :                     return -1;

  00153	0f 84 54 ff ff
	ff		 je	 $LN23@win32_xsta

; 1890 : 
; 1891 :                 code = win32_xstat_impl_w(target_path, result, FALSE);

  00159	48 8b d7	 mov	 rdx, rdi
  0015c	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR target_path$[rsp]
  00164	45 33 c0	 xor	 r8d, r8d
  00167	48 8b cf	 mov	 rcx, rdi
  0016a	e8 00 00 00 00	 call	 win32_xstat_impl_w

; 1892 :                 free(target_path);

  0016f	48 8b cf	 mov	 rcx, rdi
  00172	8b d8		 mov	 ebx, eax
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1893 :                 return code;

  0017a	8b c3		 mov	 eax, ebx
  0017c	e9 9b 00 00 00	 jmp	 $LN19@win32_xsta
$LN22@win32_xsta:
  00181	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR path$[rsp]
$LN21@win32_xsta:

; 1894 :             }
; 1895 :         } else
; 1896 :             CloseHandle(hFile);

  00189	8b b4 24 b8 00
	00 00		 mov	 esi, DWORD PTR reparse_tag$[rsp]
  00190	eb 0e		 jmp	 SHORT $LN4@win32_xsta
$LN10@win32_xsta:
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00198	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR path$[rsp]
$LN4@win32_xsta:

; 1897 :     }
; 1898 :     attribute_data_to_stat(&info, reparse_tag, result);

  001a0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  001a5	4c 8b c7	 mov	 r8, rdi
  001a8	8b d6		 mov	 edx, esi
  001aa	e8 00 00 00 00	 call	 attribute_data_to_stat

; 1899 : 
; 1900 :     /* Set S_IEXEC if it is an .exe, .bat, ... */
; 1901 :     dot = wcsrchr(path, '.');

  001af	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  001b4	48 8b cb	 mov	 rcx, rbx
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsrchr
  001bd	48 8b d8	 mov	 rbx, rax

; 1902 :     if (dot) {

  001c0	48 85 c0	 test	 rax, rax
  001c3	74 55		 je	 SHORT $LN2@win32_xsta

; 1903 :         if (_wcsicmp(dot, L".bat") == 0 || _wcsicmp(dot, L".cmd") == 0 ||
; 1904 :             _wcsicmp(dot, L".exe") == 0 || _wcsicmp(dot, L".com") == 0)

  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@
  001cc	48 8b c8	 mov	 rcx, rax
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  001d5	85 c0		 test	 eax, eax
  001d7	74 3c		 je	 SHORT $LN1@win32_xsta
  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@
  001e0	48 8b cb	 mov	 rcx, rbx
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  001e9	85 c0		 test	 eax, eax
  001eb	74 28		 je	 SHORT $LN1@win32_xsta
  001ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  001f4	48 8b cb	 mov	 rcx, rbx
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  001fd	85 c0		 test	 eax, eax
  001ff	74 14		 je	 SHORT $LN1@win32_xsta
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@
  00208	48 8b cb	 mov	 rcx, rbx
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  00211	85 c0		 test	 eax, eax
  00213	75 05		 jne	 SHORT $LN2@win32_xsta
$LN1@win32_xsta:

; 1905 :             result->st_mode |= 0111;

  00215	66 83 4f 10 49	 or	 WORD PTR [rdi+16], 73	; 00000049H
$LN2@win32_xsta:

; 1906 :     }
; 1907 :     return 0;

  0021a	33 c0		 xor	 eax, eax
$LN19@win32_xsta:

; 1908 : }

  0021c	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+168]
  00224	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0022b	5f		 pop	 rdi
  0022c	5e		 pop	 rsi
  0022d	5d		 pop	 rbp
  0022e	c3		 ret	 0
win32_xstat_impl_w ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_w DD imagerel win32_xstat_w
	DD	imagerel win32_xstat_w+33
	DD	imagerel $unwind$win32_xstat_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_w DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_xstat_w
_TEXT	SEGMENT
path$ = 48
result$ = 56
traverse$ = 64
win32_xstat_w PROC					; COMDAT

; 1922 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1923 :     /* Protocol violation: we explicitly clear errno, instead of
; 1924 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1925 :     int code = win32_xstat_impl_w(path, result, traverse);

  00006	e8 00 00 00 00	 call	 win32_xstat_impl_w
  0000b	8b d8		 mov	 ebx, eax

; 1926 :     errno = 0;

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1927 :     return code;

  00019	8b c3		 mov	 eax, ebx

; 1928 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
win32_xstat_w ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT win32_lstat_w
_TEXT	SEGMENT
path$ = 8
result$ = 16
win32_lstat_w PROC					; COMDAT

; 1951 :     return win32_xstat_w(path, result, FALSE);

  00000	45 33 c0	 xor	 r8d, r8d

; 1952 : }

  00003	e9 00 00 00 00	 jmp	 win32_xstat_w
win32_lstat_w ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT win32_stat_w
_TEXT	SEGMENT
path$ = 8
result$ = 16
win32_stat_w PROC					; COMDAT

; 1963 :     return win32_xstat_w(path, result, TRUE);

  00000	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1964 : }

  00006	e9 00 00 00 00	 jmp	 win32_xstat_w
win32_stat_w ENDP
_TEXT	ENDS
EXTRN	__imp_GetFileType:PROC
EXTRN	__imp__get_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_fstat DD imagerel win32_fstat
	DD	imagerel win32_fstat+266
	DD	imagerel $unwind$win32_fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_fstat DD 040a01H
	DD	0e340aH
	DD	07006b20aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_fstat
_TEXT	SEGMENT
info$ = 32
file_number$ = 112
result$ = 120
win32_fstat PROC					; COMDAT

; 1968 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 1969 :     BY_HANDLE_FILE_INFORMATION info;
; 1970 :     HANDLE h;
; 1971 :     int type;
; 1972 : 
; 1973 :     if (!_PyVerify_fd(file_number))

  0000f	e8 00 00 00 00	 call	 _PyVerify_fd
  00014	85 c0		 test	 eax, eax
  00016	75 06		 jne	 SHORT $LN10@win32_fsta

; 1974 :         h = INVALID_HANDLE_VALUE;

  00018	48 83 cf ff	 or	 rdi, -1

; 1975 :     else

  0001c	eb 0b		 jmp	 SHORT $LN9@win32_fsta
$LN10@win32_fsta:

; 1976 :         h = (HANDLE)_get_osfhandle(file_number);

  0001e	8b cf		 mov	 ecx, edi
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00026	48 8b f8	 mov	 rdi, rax
$LN9@win32_fsta:

; 1977 : 
; 1978 :     /* Protocol violation: we explicitly clear errno, instead of
; 1979 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1980 :     errno = 0;

  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0002f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1981 : 
; 1982 :     if (h == INVALID_HANDLE_VALUE) {

  00035	48 83 ff ff	 cmp	 rdi, -1
  00039	75 17		 jne	 SHORT $LN8@win32_fsta

; 1983 :         /* This is really a C library error (invalid file handle).
; 1984 :            We set the Win32 error to the closes one matching. */
; 1985 :         SetLastError(ERROR_INVALID_HANDLE);

  0003b	8d 4f 07	 lea	 ecx, QWORD PTR [rdi+7]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
$LN15@win32_fsta:

; 1986 :         return -1;

  00044	83 c8 ff	 or	 eax, -1

; 2015 : }

  00047	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0004c	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN8@win32_fsta:

; 1987 :     }
; 1988 :     memset(result, 0, sizeof(*result));

  00052	33 d2		 xor	 edx, edx
  00054	48 8b cb	 mov	 rcx, rbx
  00057	44 8d 42 60	 lea	 r8d, QWORD PTR [rdx+96]
  0005b	e8 00 00 00 00	 call	 memset

; 1989 : 
; 1990 :     type = GetFileType(h);

  00060	48 8b cf	 mov	 rcx, rdi
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileType

; 1991 :     if (type == FILE_TYPE_UNKNOWN) {

  00069	85 c0		 test	 eax, eax
  0006b	75 1c		 jne	 SHORT $LN6@win32_fsta

; 1992 :         DWORD error = GetLastError();

  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 1993 :         if (error != 0) {

  00073	85 c0		 test	 eax, eax
  00075	0f 84 82 00 00
	00		 je	 $LN2@win32_fsta

; 1994 :             return -1;

  0007b	83 c8 ff	 or	 eax, -1

; 2015 : }

  0007e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00083	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN6@win32_fsta:

; 1995 :         }
; 1996 :         /* else: valid but unknown file */
; 1997 :     }
; 1998 : 
; 1999 :     if (type != FILE_TYPE_DISK) {

  00089	83 f8 01	 cmp	 eax, 1
  0008c	74 36		 je	 SHORT $LN5@win32_fsta

; 2000 :         if (type == FILE_TYPE_CHAR)

  0008e	83 f8 02	 cmp	 eax, 2
  00091	75 16		 jne	 SHORT $LN4@win32_fsta

; 2001 :             result->st_mode = _S_IFCHR;

  00093	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H

; 2003 :             result->st_mode = _S_IFIFO;

  00098	66 89 43 10	 mov	 WORD PTR [rbx+16], ax

; 2014 :     return 0;

  0009c	33 c0		 xor	 eax, eax

; 2015 : }

  0009e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000a3	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$LN4@win32_fsta:

; 2002 :         else if (type == FILE_TYPE_PIPE)

  000a9	83 f8 03	 cmp	 eax, 3
  000ac	75 4f		 jne	 SHORT $LN2@win32_fsta

; 2003 :             result->st_mode = _S_IFIFO;

  000ae	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000b3	66 89 43 10	 mov	 WORD PTR [rbx+16], ax

; 2014 :     return 0;

  000b7	33 c0		 xor	 eax, eax

; 2015 : }

  000b9	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000be	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
$LN5@win32_fsta:

; 2004 :         return 0;
; 2005 :     }
; 2006 : 
; 2007 :     if (!GetFileInformationByHandle(h, &info)) {

  000c4	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  000d2	85 c0		 test	 eax, eax

; 2008 :         return -1;

  000d4	0f 84 6a ff ff
	ff		 je	 $LN15@win32_fsta

; 2009 :     }
; 2010 : 
; 2011 :     attribute_data_to_stat(&info, 0, result);

  000da	48 8d 4c 24 20	 lea	 rcx, QWORD PTR info$[rsp]
  000df	4c 8b c3	 mov	 r8, rbx
  000e2	33 d2		 xor	 edx, edx
  000e4	e8 00 00 00 00	 call	 attribute_data_to_stat

; 2012 :     /* specific to fstat() */
; 2013 :     result->st_ino = (((__int64)info.nFileIndexHigh)<<32) + info.nFileIndexLow;

  000e9	44 8b 5c 24 4c	 mov	 r11d, DWORD PTR info$[rsp+44]
  000ee	8b 44 24 50	 mov	 eax, DWORD PTR info$[rsp+48]
  000f2	49 c1 e3 20	 shl	 r11, 32			; 00000020H
  000f6	4c 03 d8	 add	 r11, rax
  000f9	4c 89 5b 08	 mov	 QWORD PTR [rbx+8], r11
$LN2@win32_fsta:

; 2014 :     return 0;

  000fd	33 c0		 xor	 eax, eax

; 2015 : }

  000ff	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00104	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00108	5f		 pop	 rdi
  00109	c3		 ret	 0
win32_fstat ENDP
_TEXT	ENDS
_BSS	SEGMENT
structseq_new DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$statresult_new DD imagerel statresult_new
	DD	imagerel statresult_new+296
	DD	imagerel $unwind$statresult_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$statresult_new DD 0a3501H
	DD	0a7435H
	DD	0bc429H
	DD	096424H
	DD	08341fH
	DD	050025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
xdata	ENDS
;	COMDAT statresult_new
_TEXT	SEGMENT
type$ = 64
args$ = 72
kwds$ = 80
statresult_new PROC					; COMDAT

; 2178 : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 2179 :     PyStructSequence *result;
; 2180 :     int i;
; 2181 : 
; 2182 :     result = (PyStructSequence*)structseq_new(type, args, kwds);

  00006	ff 15 00 00 00
	00		 call	 QWORD PTR structseq_new
  0000c	48 8b e8	 mov	 rbp, rax

; 2183 :     if (!result)

  0000f	48 85 c0	 test	 rax, rax
  00012	75 06		 jne	 SHORT $LN5@statresult

; 2196 : }

  00014	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00018	5d		 pop	 rbp
  00019	c3		 ret	 0
$LN5@statresult:
  0001a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0001f	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00024	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 2184 :         return NULL;
; 2185 :     /* If we have been initialized from a tuple,
; 2186 :        st_?time might be set to None. Initialize it
; 2187 :        from the int slots.  */
; 2188 :     for (i = 7; i <= 9; i++) {

  00029	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  00030	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00035	48 8d 98 c0 00
	00 00		 lea	 rbx, QWORD PTR [rax+192]
  0003c	be 03 00 00 00	 mov	 esi, 3
$LL4@statresult:

; 2189 :         if (result->ob_item[i+3] == Py_None) {

  00041	4c 39 23	 cmp	 QWORD PTR [rbx], r12
  00044	0f 85 b4 00 00
	00		 jne	 $LN3@statresult

; 2190 :             Py_DECREF(Py_None);

  0004a	e8 00 00 00 00	 call	 _Py_PXCTX
  0004f	85 c0		 test	 eax, eax
  00051	75 65		 jne	 SHORT $LN18@statresult
  00053	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR _Py_NoneStruct+32
  0005a	a8 20		 test	 al, 32			; 00000020H
  0005c	75 52		 jne	 SHORT $LN12@statresult
  0005e	84 c0		 test	 al, al
  00060	78 4e		 js	 SHORT $LN12@statresult
  00062	a8 02		 test	 al, 2
  00064	75 52		 jne	 SHORT $LN18@statresult
  00066	48 ff 0d 50 00
	00 00		 dec	 QWORD PTR _Py_NoneStruct+80
  0006d	75 49		 jne	 SHORT $LN18@statresult
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007d	4d 8b cc	 mov	 r9, r12
  00080	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	49 8b cc	 mov	 rcx, r12
  00096	85 c0		 test	 eax, eax
  00098	74 07		 je	 SHORT $LN17@statresult
  0009a	e8 00 00 00 00	 call	 _Px_Dealloc
  0009f	eb 17		 jmp	 SHORT $LN18@statresult
$LN17@statresult:
  000a1	48 8b 05 58 00
	00 00		 mov	 rax, QWORD PTR _Py_NoneStruct+88
  000a8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000ae	eb 08		 jmp	 SHORT $LN18@statresult
$LN12@statresult:
  000b0	49 8b cc	 mov	 rcx, r12
  000b3	e8 00 00 00 00	 call	 Px_DecRef
$LN18@statresult:

; 2191 :             Py_INCREF(result->ob_item[i]);

  000b8	48 8b 7b e8	 mov	 rdi, QWORD PTR [rbx-24]
  000bc	e8 00 00 00 00	 call	 _Py_PXCTX
  000c1	85 c0		 test	 eax, eax
  000c3	75 32		 jne	 SHORT $LN20@statresult
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d3	4c 8b cf	 mov	 r9, rdi
  000d6	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000dc	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e9	85 c0		 test	 eax, eax
  000eb	75 06		 jne	 SHORT $LN19@statresult
  000ed	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000f1	74 04		 je	 SHORT $LN20@statresult
$LN19@statresult:
  000f3	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN20@statresult:

; 2192 :             result->ob_item[i+3] = result->ob_item[i];

  000f7	48 8b 43 e8	 mov	 rax, QWORD PTR [rbx-24]
  000fb	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN3@statresult:

; 2184 :         return NULL;
; 2185 :     /* If we have been initialized from a tuple,
; 2186 :        st_?time might be set to None. Initialize it
; 2187 :        from the int slots.  */
; 2188 :     for (i = 7; i <= 9; i++) {

  000fe	48 83 c3 08	 add	 rbx, 8
  00102	48 ff ce	 dec	 rsi
  00105	0f 85 36 ff ff
	ff		 jne	 $LL4@statresult

; 2193 :         }
; 2194 :     }
; 2195 :     return (PyObject*)result;

  0010b	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  00110	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00115	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0011f	48 8b c5	 mov	 rax, rbp

; 2196 : }

  00122	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00126	5d		 pop	 rbp
  00127	c3		 ret	 0
statresult_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@ ; `string'
PUBLIC	??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@	; `string'
EXTRN	PyBool_FromLong:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$stat_float_times DD imagerel stat_float_times
	DD	imagerel stat_float_times+184
	DD	imagerel $unwind$stat_float_times
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stat_float_times DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@
CONST	SEGMENT
??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@ DB 'stat_flo'
	DB	'at_times() is deprecated', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@
CONST	SEGMENT
??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@ DB '|i:stat_float_times', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT stat_float_times
_TEXT	SEGMENT
self$ = 64
args$ = 72
newval$ = 80
stat_float_times PROC					; COMDAT

; 2212 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2213 :     int newval = -1;
; 2214 :     if (!PyArg_ParseTuple(args, "|i:stat_float_times", &newval))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR newval$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@
  00013	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR newval$[rsp], -1
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 07		 jne	 SHORT $LN3@stat_float
$LN10@stat_float:

; 2215 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 2226 : }

  00026	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002a	c3		 ret	 0
$LN3@stat_float:

; 2216 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 2217 :                      "stat_float_times() is deprecated",
; 2218 :                      1))

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@
  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	e8 00 00 00 00	 call	 PyErr_WarnEx
  00044	85 c0		 test	 eax, eax

; 2219 :         return NULL;

  00046	75 dc		 jne	 SHORT $LN10@stat_float

; 2220 :     if (newval == -1)

  00048	8b 44 24 50	 mov	 eax, DWORD PTR newval$[rsp]
  0004c	83 f8 ff	 cmp	 eax, -1
  0004f	75 10		 jne	 SHORT $LN1@stat_float

; 2221 :         /* Return old value */
; 2222 :         return PyBool_FromLong(_stat_float_times);

  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stat_float_times
  00057	e8 00 00 00 00	 call	 PyBool_FromLong

; 2226 : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
$LN1@stat_float:

; 2223 :     _stat_float_times = newval;

  00061	89 05 00 00 00
	00		 mov	 DWORD PTR _stat_float_times, eax

; 2224 :     Py_INCREF(Py_None);

  00067	e8 00 00 00 00	 call	 _Py_PXCTX
  0006c	85 c0		 test	 eax, eax
  0006e	75 3c		 jne	 SHORT $LN7@stat_float
  00070	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00085	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00093	e8 00 00 00 00	 call	 _PyParallel_Guard
  00098	85 c0		 test	 eax, eax
  0009a	75 09		 jne	 SHORT $LN6@stat_float
  0009c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000a3	74 07		 je	 SHORT $LN7@stat_float
$LN6@stat_float:
  000a5	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@stat_float:

; 2225 :     return Py_None;

  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 2226 : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
stat_float_times ENDP
_TEXT	ENDS
PUBLIC	__real@3e112e0be826d695
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	_PyLong_FromTime_t:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fill_time DD imagerel fill_time
	DD	imagerel fill_time+784
	DD	imagerel $unwind$fill_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_time DD 0c2001H
	DD	0f6420H
	DD	0e5420H
	DD	0c3420H
	DD	0f01c5220H
	DD	0d018e01aH
	DD	07014c016H
xdata	ENDS
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-009
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT fill_time
_TEXT	SEGMENT
v$ = 96
index$ = 104
sec$ = 112
nsec$ = 120
fill_time PROC						; COMDAT

; 2232 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00013	57		 push	 rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15
  0001c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00020	4c 8b e9	 mov	 r13, rcx

; 2233 :     PyObject *s = _PyLong_FromTime_t(sec);

  00023	49 8b c8	 mov	 rcx, r8
  00026	45 8b f1	 mov	 r14d, r9d
  00029	4d 8b f8	 mov	 r15, r8
  0002c	e8 00 00 00 00	 call	 _PyLong_FromTime_t

; 2234 :     PyObject *ns_fractional = PyLong_FromUnsignedLong(nsec);

  00031	41 8b ce	 mov	 ecx, r14d
  00034	48 8b f8	 mov	 rdi, rax
  00037	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 2235 :     PyObject *s_in_ns = NULL;

  0003c	33 ed		 xor	 ebp, ebp

; 2236 :     PyObject *ns_total = NULL;

  0003e	33 f6		 xor	 esi, esi

; 2237 :     PyObject *float_s = NULL;

  00040	33 db		 xor	 ebx, ebx
  00042	4c 8b e0	 mov	 r12, rax

; 2238 : 
; 2239 :     if (!(s && ns_fractional))

  00045	48 85 ff	 test	 rdi, rdi
  00048	0f 84 fa 00 00
	00		 je	 $LN19@fill_time
  0004e	48 85 c0	 test	 rax, rax
  00051	74 61		 je	 SHORT $exit$121787

; 2240 :         goto exit;
; 2241 : 
; 2242 :     s_in_ns = PyNumber_Multiply(s, billion);

  00053	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR billion
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	e8 00 00 00 00	 call	 PyNumber_Multiply
  00062	48 8b e8	 mov	 rbp, rax

; 2243 :     if (!s_in_ns)

  00065	48 85 c0	 test	 rax, rax
  00068	74 4a		 je	 SHORT $exit$121787

; 2244 :         goto exit;
; 2245 : 
; 2246 :     ns_total = PyNumber_Add(s_in_ns, ns_fractional);

  0006a	49 8b d4	 mov	 rdx, r12
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 PyNumber_Add
  00075	48 8b f0	 mov	 rsi, rax

; 2247 :     if (!ns_total)

  00078	48 85 c0	 test	 rax, rax
  0007b	74 37		 je	 SHORT $exit$121787

; 2248 :         goto exit;
; 2249 : 
; 2250 :     if (_stat_float_times) {

  0007d	39 1d 00 00 00
	00		 cmp	 DWORD PTR _stat_float_times, ebx
  00083	0f 84 80 00 00
	00		 je	 $LN23@fill_time

; 2251 :         float_s = PyFloat_FromDouble(sec + 1e-9*nsec);

  00089	66 0f ef c0	 pxor	 xmm0, xmm0
  0008d	66 0f ef c9	 pxor	 xmm1, xmm1
  00091	f2 49 0f 2a c6	 cvtsi2sd xmm0, r14
  00096	f2 49 0f 2a cf	 cvtsi2sd xmm1, r15
  0009b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3e112e0be826d695
  000a3	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000a7	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000ac	48 8b d8	 mov	 rbx, rax

; 2252 :         if (!float_s)

  000af	48 85 c0	 test	 rax, rax
  000b2	75 60		 jne	 SHORT $LN21@fill_time
$exit$121787:

; 2266 : exit:
; 2267 :     Py_XDECREF(s);

  000b4	e8 00 00 00 00	 call	 _Py_PXCTX
  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 87 00 00
	00		 jne	 $LN19@fill_time
  000c1	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000c5	a8 20		 test	 al, 32			; 00000020H
  000c7	75 77		 jne	 SHORT $LN34@fill_time
  000c9	84 c0		 test	 al, al
  000cb	78 73		 js	 SHORT $LN34@fill_time
  000cd	a8 02		 test	 al, 2
  000cf	75 77		 jne	 SHORT $LN19@fill_time
  000d1	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000d5	75 71		 jne	 SHORT $LN19@fill_time
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000e5	4c 8b cf	 mov	 r9, rdi
  000e8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000ee	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fb	48 8b cf	 mov	 rcx, rdi
  000fe	85 c0		 test	 eax, eax
  00100	74 32		 je	 SHORT $LN39@fill_time
  00102	e8 00 00 00 00	 call	 _Px_Dealloc
  00107	eb 3f		 jmp	 SHORT $LN19@fill_time
$LN23@fill_time:

; 2253 :             goto exit;
; 2254 :     }
; 2255 :     else {
; 2256 :         float_s = s;
; 2257 :         Py_INCREF(float_s);

  00109	48 8b cf	 mov	 rcx, rdi
  0010c	48 8b df	 mov	 rbx, rdi
  0010f	e8 00 00 00 00	 call	 _Py_IncRef
$LN21@fill_time:

; 2258 :     }
; 2259 : 
; 2260 :     PyStructSequence_SET_ITEM(v, index, s);

  00114	48 63 44 24 68	 movsxd	 rax, DWORD PTR index$[rsp]

; 2261 :     PyStructSequence_SET_ITEM(v, index+3, float_s);

  00119	49 89 9c c5 88
	00 00 00	 mov	 QWORD PTR [r13+rax*8+136], rbx

; 2262 :     PyStructSequence_SET_ITEM(v, index+6, ns_total);

  00121	49 89 b4 c5 a0
	00 00 00	 mov	 QWORD PTR [r13+rax*8+160], rsi

; 2263 :     s = NULL;
; 2264 :     float_s = NULL;

  00129	33 db		 xor	 ebx, ebx

; 2265 :     ns_total = NULL;

  0012b	33 f6		 xor	 esi, esi
  0012d	49 89 7c c5 70	 mov	 QWORD PTR [r13+rax*8+112], rdi

; 2266 : exit:
; 2267 :     Py_XDECREF(s);

  00132	eb 14		 jmp	 SHORT $LN19@fill_time
$LN39@fill_time:
  00134	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00138	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0013e	eb 08		 jmp	 SHORT $LN19@fill_time
$LN34@fill_time:
  00140	48 8b cf	 mov	 rcx, rdi
  00143	e8 00 00 00 00	 call	 Px_DecRef
$LN19@fill_time:

; 2268 :     Py_XDECREF(ns_fractional);

  00148	4d 85 e4	 test	 r12, r12
  0014b	74 68		 je	 SHORT $LN15@fill_time
  0014d	e8 00 00 00 00	 call	 _Py_PXCTX
  00152	85 c0		 test	 eax, eax
  00154	75 5f		 jne	 SHORT $LN15@fill_time
  00156	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  0015b	a8 20		 test	 al, 32			; 00000020H
  0015d	75 4e		 jne	 SHORT $LN45@fill_time
  0015f	84 c0		 test	 al, al
  00161	78 4a		 js	 SHORT $LN45@fill_time
  00163	a8 02		 test	 al, 2
  00165	75 4e		 jne	 SHORT $LN15@fill_time
  00167	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  0016c	75 47		 jne	 SHORT $LN15@fill_time
  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0017c	4d 8b cc	 mov	 r9, r12
  0017f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00185	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00192	49 8b cc	 mov	 rcx, r12
  00195	85 c0		 test	 eax, eax
  00197	74 07		 je	 SHORT $LN50@fill_time
  00199	e8 00 00 00 00	 call	 _Px_Dealloc
  0019e	eb 15		 jmp	 SHORT $LN15@fill_time
$LN50@fill_time:
  001a0	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  001a5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001ab	eb 08		 jmp	 SHORT $LN15@fill_time
$LN45@fill_time:
  001ad	49 8b cc	 mov	 rcx, r12
  001b0	e8 00 00 00 00	 call	 Px_DecRef
$LN15@fill_time:

; 2269 :     Py_XDECREF(s_in_ns);

  001b5	48 85 ed	 test	 rbp, rbp
  001b8	74 65		 je	 SHORT $LN11@fill_time
  001ba	e8 00 00 00 00	 call	 _Py_PXCTX
  001bf	85 c0		 test	 eax, eax
  001c1	75 5c		 jne	 SHORT $LN11@fill_time
  001c3	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  001c7	a8 20		 test	 al, 32			; 00000020H
  001c9	75 4c		 jne	 SHORT $LN56@fill_time
  001cb	84 c0		 test	 al, al
  001cd	78 48		 js	 SHORT $LN56@fill_time
  001cf	a8 02		 test	 al, 2
  001d1	75 4c		 jne	 SHORT $LN11@fill_time
  001d3	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  001d7	75 46		 jne	 SHORT $LN11@fill_time
  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001e7	4c 8b cd	 mov	 r9, rbp
  001ea	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001f0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fd	48 8b cd	 mov	 rcx, rbp
  00200	85 c0		 test	 eax, eax
  00202	74 07		 je	 SHORT $LN61@fill_time
  00204	e8 00 00 00 00	 call	 _Px_Dealloc
  00209	eb 14		 jmp	 SHORT $LN11@fill_time
$LN61@fill_time:
  0020b	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  0020f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00215	eb 08		 jmp	 SHORT $LN11@fill_time
$LN56@fill_time:
  00217	48 8b cd	 mov	 rcx, rbp
  0021a	e8 00 00 00 00	 call	 Px_DecRef
$LN11@fill_time:

; 2270 :     Py_XDECREF(ns_total);

  0021f	48 85 f6	 test	 rsi, rsi
  00222	74 65		 je	 SHORT $LN7@fill_time
  00224	e8 00 00 00 00	 call	 _Py_PXCTX
  00229	85 c0		 test	 eax, eax
  0022b	75 5c		 jne	 SHORT $LN7@fill_time
  0022d	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00231	a8 20		 test	 al, 32			; 00000020H
  00233	75 4c		 jne	 SHORT $LN67@fill_time
  00235	84 c0		 test	 al, al
  00237	78 48		 js	 SHORT $LN67@fill_time
  00239	a8 02		 test	 al, 2
  0023b	75 4c		 jne	 SHORT $LN7@fill_time
  0023d	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00241	75 46		 jne	 SHORT $LN7@fill_time
  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00251	4c 8b ce	 mov	 r9, rsi
  00254	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0025a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00262	e8 00 00 00 00	 call	 _PyParallel_Guard
  00267	48 8b ce	 mov	 rcx, rsi
  0026a	85 c0		 test	 eax, eax
  0026c	74 07		 je	 SHORT $LN72@fill_time
  0026e	e8 00 00 00 00	 call	 _Px_Dealloc
  00273	eb 14		 jmp	 SHORT $LN7@fill_time
$LN72@fill_time:
  00275	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00279	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0027f	eb 08		 jmp	 SHORT $LN7@fill_time
$LN67@fill_time:
  00281	48 8b ce	 mov	 rcx, rsi
  00284	e8 00 00 00 00	 call	 Px_DecRef
$LN7@fill_time:

; 2271 :     Py_XDECREF(float_s);

  00289	48 85 db	 test	 rbx, rbx
  0028c	74 65		 je	 SHORT $LN3@fill_time
  0028e	e8 00 00 00 00	 call	 _Py_PXCTX
  00293	85 c0		 test	 eax, eax
  00295	75 5c		 jne	 SHORT $LN3@fill_time
  00297	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0029b	a8 20		 test	 al, 32			; 00000020H
  0029d	75 4c		 jne	 SHORT $LN78@fill_time
  0029f	84 c0		 test	 al, al
  002a1	78 48		 js	 SHORT $LN78@fill_time
  002a3	a8 02		 test	 al, 2
  002a5	75 4c		 jne	 SHORT $LN3@fill_time
  002a7	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002ab	75 46		 jne	 SHORT $LN3@fill_time
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002bb	4c 8b cb	 mov	 r9, rbx
  002be	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002c4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002cc	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d1	48 8b cb	 mov	 rcx, rbx
  002d4	85 c0		 test	 eax, eax
  002d6	74 07		 je	 SHORT $LN83@fill_time
  002d8	e8 00 00 00 00	 call	 _Px_Dealloc
  002dd	eb 14		 jmp	 SHORT $LN3@fill_time
$LN83@fill_time:
  002df	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002e9	eb 08		 jmp	 SHORT $LN3@fill_time
$LN78@fill_time:
  002eb	48 8b cb	 mov	 rcx, rbx
  002ee	e8 00 00 00 00	 call	 Px_DecRef
$LN3@fill_time:

; 2272 : }

  002f3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  002f8	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  002fd	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00302	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00306	41 5f		 pop	 r15
  00308	41 5e		 pop	 r14
  0030a	41 5d		 pop	 r13
  0030c	41 5c		 pop	 r12
  0030e	5f		 pop	 rdi
  0030f	c3		 ret	 0
fill_time ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
StatResultType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_pystat_fromstructstat DD imagerel _pystat_fromstructstat
	DD	imagerel _pystat_fromstructstat+41
	DD	imagerel $unwind$_pystat_fromstructstat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_pystat_fromstructstat DD imagerel _pystat_fromstructstat+41
	DD	imagerel _pystat_fromstructstat+234
	DD	imagerel $chain$1$_pystat_fromstructstat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_pystat_fromstructstat DD imagerel _pystat_fromstructstat+234
	DD	imagerel _pystat_fromstructstat+269
	DD	imagerel $chain$2$_pystat_fromstructstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_pystat_fromstructstat DD 021H
	DD	imagerel _pystat_fromstructstat
	DD	imagerel _pystat_fromstructstat+41
	DD	imagerel $unwind$_pystat_fromstructstat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_pystat_fromstructstat DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel _pystat_fromstructstat
	DD	imagerel _pystat_fromstructstat+41
	DD	imagerel $unwind$_pystat_fromstructstat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_pystat_fromstructstat DD 040a01H
	DD	08540aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _pystat_fromstructstat
_TEXT	SEGMENT
st$ = 48
_pystat_fromstructstat PROC				; COMDAT

; 2278 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b e9	 mov	 rbp, rcx

; 2279 :     unsigned long ansec, mnsec, cnsec;
; 2280 :     PyObject *v = PyStructSequence_New(&StatResultType);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatResultType
  00014	e8 00 00 00 00	 call	 PyStructSequence_New
  00019	48 8b f0	 mov	 rsi, rax

; 2281 :     if (v == NULL)

  0001c	48 85 c0	 test	 rax, rax

; 2282 :         return NULL;

  0001f	0f 84 cd 00 00
	00		 je	 $LN5@pystat_fro

; 2283 : 
; 2284 :     PyStructSequence_SET_ITEM(v, 0, PyLong_FromLong((long)st->st_mode));

  00025	0f b7 4d 10	 movzx	 ecx, WORD PTR [rbp+16]
  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002e	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00033	e8 00 00 00 00	 call	 PyLong_FromLong
  00038	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax

; 2285 : #ifdef HAVE_LARGEFILE_SUPPORT
; 2286 :     PyStructSequence_SET_ITEM(v, 1,
; 2287 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_ino));

  0003c	48 8b 4d 08	 mov	 rcx, QWORD PTR [rbp+8]
  00040	e8 00 00 00 00	 call	 PyLong_FromLongLong
  00045	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax

; 2288 : #else
; 2289 :     PyStructSequence_SET_ITEM(v, 1, PyLong_FromLong((long)st->st_ino));
; 2290 : #endif
; 2291 : #if defined(HAVE_LONG_LONG) && !defined(MS_WINDOWS)
; 2292 :     PyStructSequence_SET_ITEM(v, 2,
; 2293 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_dev));
; 2294 : #else
; 2295 :     PyStructSequence_SET_ITEM(v, 2, PyLong_FromLong((long)st->st_dev));

  00049	8b 4d 00	 mov	 ecx, DWORD PTR [rbp]
  0004c	e8 00 00 00 00	 call	 PyLong_FromLong
  00051	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 2296 : #endif
; 2297 :     PyStructSequence_SET_ITEM(v, 3, PyLong_FromLong((long)st->st_nlink));

  00058	8b 4d 14	 mov	 ecx, DWORD PTR [rbp+20]
  0005b	e8 00 00 00 00	 call	 PyLong_FromLong

; 2298 : #if defined(MS_WINDOWS)
; 2299 :     PyStructSequence_SET_ITEM(v, 4, PyLong_FromLong(0));

  00060	33 c9		 xor	 ecx, ecx
  00062	48 89 86 88 00
	00 00		 mov	 QWORD PTR [rsi+136], rax
  00069	e8 00 00 00 00	 call	 PyLong_FromLong

; 2300 :     PyStructSequence_SET_ITEM(v, 5, PyLong_FromLong(0));

  0006e	33 c9		 xor	 ecx, ecx
  00070	48 89 86 90 00
	00 00		 mov	 QWORD PTR [rsi+144], rax
  00077	e8 00 00 00 00	 call	 PyLong_FromLong
  0007c	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax

; 2301 : #else
; 2302 :     PyStructSequence_SET_ITEM(v, 4, _PyLong_FromUid(st->st_uid));
; 2303 :     PyStructSequence_SET_ITEM(v, 5, _PyLong_FromGid(st->st_gid));
; 2304 : #endif
; 2305 : #ifdef HAVE_LARGEFILE_SUPPORT
; 2306 :     PyStructSequence_SET_ITEM(v, 6,
; 2307 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_size));

  00083	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  00087	e8 00 00 00 00	 call	 PyLong_FromLongLong

; 2308 : #else
; 2309 :     PyStructSequence_SET_ITEM(v, 6, PyLong_FromLong(st->st_size));
; 2310 : #endif
; 2311 : 
; 2312 : #if defined(HAVE_STAT_TV_NSEC)
; 2313 :     ansec = st->st_atim.tv_nsec;
; 2314 :     mnsec = st->st_mtim.tv_nsec;
; 2315 :     cnsec = st->st_ctim.tv_nsec;
; 2316 : #elif defined(HAVE_STAT_TV_NSEC2)
; 2317 :     ansec = st->st_atimespec.tv_nsec;
; 2318 :     mnsec = st->st_mtimespec.tv_nsec;
; 2319 :     cnsec = st->st_ctimespec.tv_nsec;
; 2320 : #elif defined(HAVE_STAT_NSEC)
; 2321 :     ansec = st->st_atime_nsec;
; 2322 :     mnsec = st->st_mtime_nsec;
; 2323 :     cnsec = st->st_ctime_nsec;
; 2324 : #else
; 2325 :     ansec = mnsec = cnsec = 0;
; 2326 : #endif
; 2327 :     fill_time(v, 7, st->st_atime, ansec);

  0008c	ba 07 00 00 00	 mov	 edx, 7
  00091	48 8b ce	 mov	 rcx, rsi
  00094	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax
  0009b	44 8b 4d 38	 mov	 r9d, DWORD PTR [rbp+56]
  0009f	4c 8b 45 30	 mov	 r8, QWORD PTR [rbp+48]
  000a3	8b 5d 48	 mov	 ebx, DWORD PTR [rbp+72]
  000a6	8b 7d 58	 mov	 edi, DWORD PTR [rbp+88]
  000a9	e8 00 00 00 00	 call	 fill_time

; 2328 :     fill_time(v, 8, st->st_mtime, mnsec);

  000ae	4c 8b 45 40	 mov	 r8, QWORD PTR [rbp+64]
  000b2	44 8b cb	 mov	 r9d, ebx
  000b5	ba 08 00 00 00	 mov	 edx, 8
  000ba	48 8b ce	 mov	 rcx, rsi
  000bd	e8 00 00 00 00	 call	 fill_time

; 2329 :     fill_time(v, 9, st->st_ctime, cnsec);

  000c2	4c 8b 45 50	 mov	 r8, QWORD PTR [rbp+80]
  000c6	44 8b cf	 mov	 r9d, edi
  000c9	ba 09 00 00 00	 mov	 edx, 9
  000ce	48 8b ce	 mov	 rcx, rsi
  000d1	e8 00 00 00 00	 call	 fill_time

; 2330 : 
; 2331 : #ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
; 2332 :     PyStructSequence_SET_ITEM(v, ST_BLKSIZE_IDX,
; 2333 :                               PyLong_FromLong((long)st->st_blksize));
; 2334 : #endif
; 2335 : #ifdef HAVE_STRUCT_STAT_ST_BLOCKS
; 2336 :     PyStructSequence_SET_ITEM(v, ST_BLOCKS_IDX,
; 2337 :                               PyLong_FromLong((long)st->st_blocks));
; 2338 : #endif
; 2339 : #ifdef HAVE_STRUCT_STAT_ST_RDEV
; 2340 :     PyStructSequence_SET_ITEM(v, ST_RDEV_IDX,
; 2341 :                               PyLong_FromLong((long)st->st_rdev));
; 2342 : #endif
; 2343 : #ifdef HAVE_STRUCT_STAT_ST_GEN
; 2344 :     PyStructSequence_SET_ITEM(v, ST_GEN_IDX,
; 2345 :                               PyLong_FromLong((long)st->st_gen));
; 2346 : #endif
; 2347 : #ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
; 2348 :     {
; 2349 :       PyObject *val;
; 2350 :       unsigned long bsec,bnsec;
; 2351 :       bsec = (long)st->st_birthtime;
; 2352 : #ifdef HAVE_STAT_TV_NSEC2
; 2353 :       bnsec = st->st_birthtimespec.tv_nsec;
; 2354 : #else
; 2355 :       bnsec = 0;
; 2356 : #endif
; 2357 :       if (_stat_float_times) {
; 2358 :         val = PyFloat_FromDouble(bsec + 1e-9*bnsec);
; 2359 :       } else {
; 2360 :         val = PyLong_FromLong((long)bsec);
; 2361 :       }
; 2362 :       PyStructSequence_SET_ITEM(v, ST_BIRTHTIME_IDX,
; 2363 :                                 val);
; 2364 :     }
; 2365 : #endif
; 2366 : #ifdef HAVE_STRUCT_STAT_ST_FLAGS
; 2367 :     PyStructSequence_SET_ITEM(v, ST_FLAGS_IDX,
; 2368 :                               PyLong_FromLong((long)st->st_flags));
; 2369 : #endif
; 2370 : 
; 2371 :     if (PyErr_Occurred()) {

  000d6	e8 00 00 00 00	 call	 PyErr_Occurred
  000db	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000e0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e5	48 85 c0	 test	 rax, rax
  000e8	74 15		 je	 SHORT $LN1@pystat_fro

; 2372 :         Py_DECREF(v);

  000ea	48 8b ce	 mov	 rcx, rsi
  000ed	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@pystat_fro:

; 2373 :         return NULL;

  000f2	33 c0		 xor	 eax, eax

; 2377 : }

  000f4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fd	5e		 pop	 rsi
  000fe	c3		 ret	 0
$LN1@pystat_fro:

; 2374 :     }
; 2375 : 
; 2376 :     return v;

  000ff	48 8b c6	 mov	 rax, rsi

; 2377 : }

  00102	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5e		 pop	 rsi
  0010c	c3		 ret	 0
_pystat_fromstructstat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@ ; `string'
EXTRN	__imp_GetFileAttributesA:PROC
EXTRN	__imp_GetFileAttributesW:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_access DD imagerel posix_access
	DD	imagerel posix_access+251
	DD	imagerel $unwind$posix_access
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_access DD imagerel posix_access+251
	DD	imagerel posix_access+259
	DD	imagerel $chain$0$posix_access
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_access DD imagerel posix_access+259
	DD	imagerel posix_access+333
	DD	imagerel $chain$1$posix_access
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_access DD imagerel posix_access+333
	DD	imagerel posix_access+370
	DD	imagerel $chain$2$posix_access
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_access DD imagerel posix_access+370
	DD	imagerel posix_access+400
	DD	imagerel $chain$3$posix_access
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_access DD 021H
	DD	imagerel posix_access
	DD	imagerel posix_access+251
	DD	imagerel $unwind$posix_access
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_access DD 021H
	DD	imagerel posix_access+251
	DD	imagerel posix_access+259
	DD	imagerel $chain$0$posix_access
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_access DD 020821H
	DD	01b5408H
	DD	imagerel posix_access+251
	DD	imagerel posix_access+259
	DD	imagerel $chain$0$posix_access
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_access DD 020821H
	DD	01a3408H
	DD	imagerel posix_access
	DD	imagerel posix_access+251
	DD	imagerel $unwind$posix_access
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_access DD 050f01H
	DD	01c640fH
	DD	018010fH
	DD	07008H
xdata	ENDS
;	COMDAT ??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@
CONST	SEGMENT
??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@ DB 'O&i|$O&pp:access', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_access
_TEXT	SEGMENT
effective_ids$ = 96
dir_fd$ = 100
mode$ = 104
path$ = 112
self$ = 208
args$ = 216
kwargs$ = 224
follow_symlinks$ = 232
posix_access PROC					; COMDAT

; 2527 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00007	57		 push	 rdi
  00008	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 2528 :     static char *keywords[] = {"path", "mode", "dir_fd", "effective_ids",
; 2529 :                                 "follow_symlinks", NULL};
; 2530 :     path_t path;
; 2531 :     int mode;
; 2532 :     int dir_fd = DEFAULT_DIR_FD;
; 2533 :     int effective_ids = 0;
; 2534 :     int follow_symlinks = 1;
; 2535 :     PyObject *return_value = NULL;
; 2536 : 
; 2537 : #ifdef MS_WINDOWS
; 2538 :     DWORD attr;
; 2539 : #else
; 2540 :     int result;
; 2541 : #endif
; 2542 : 
; 2543 :     memset(&path, 0, sizeof(path));

  0000f	33 c9		 xor	 ecx, ecx
  00011	49 8b c0	 mov	 rax, r8
  00014	4c 8b d2	 mov	 r10, rdx
  00017	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  0001b	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001f	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00023	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00027	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  0002b	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002f	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00033	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00037	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 2544 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|$O&pp:access", keywords,
; 2545 :         path_converter, &path, &mode,
; 2546 : #ifdef HAVE_FACCESSAT
; 2547 :         dir_fd_converter, &dir_fd,
; 2548 : #else
; 2549 :         dir_fd_unavailable, &dir_fd,
; 2550 : #endif
; 2551 :         &effective_ids, &follow_symlinks))

  0003b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_access@@9@9
  00046	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@
  0004d	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00051	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00055	33 ff		 xor	 edi, edi
  00057	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  0005b	49 8d 4b 9c	 lea	 rcx, QWORD PTR [r11-100]
  0005f	be 01 00 00 00	 mov	 esi, 1
  00064	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00070	48 8b d0	 mov	 rdx, rax
  00073	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00078	49 8d 4b a0	 lea	 rcx, QWORD PTR [r11-96]
  0007c	c7 44 24 64 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0008d	89 7c 24 60	 mov	 DWORD PTR effective_ids$[rsp], edi
  00091	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  0009d	41 89 73 20	 mov	 DWORD PTR [r11+32], esi
  000a1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000a6	49 8b ca	 mov	 rcx, r10
  000a9	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000ae	85 c0		 test	 eax, eax
  000b0	75 13		 jne	 SHORT $LN5@posix_acce

; 2552 :         return NULL;

  000b2	33 c0		 xor	 eax, eax

; 2610 :     return return_value;
; 2611 : }

  000b4	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+224]
  000bc	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  000c3	5f		 pop	 rdi
  000c4	c3		 ret	 0
$LN5@posix_acce:

; 2553 : 
; 2554 : #ifndef HAVE_FACCESSAT
; 2555 :     if (follow_symlinks_specified("access", follow_symlinks))

  000c5	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  000d3	e8 00 00 00 00	 call	 follow_symlinks_specified
  000d8	85 c0		 test	 eax, eax
  000da	0f 85 92 00 00
	00		 jne	 $exit$121942

; 2556 :         goto exit;
; 2557 : 
; 2558 :     if (effective_ids) {

  000e0	39 7c 24 60	 cmp	 DWORD PTR effective_ids$[rsp], edi
  000e4	74 15		 je	 SHORT $LN3@posix_acce

; 2559 :         argument_unavailable_error("access", "effective_ids");

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@FGNLNFPF@effective_ids?$AA@
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  000f4	e8 00 00 00 00	 call	 argument_unavailable_error

; 2560 :         goto exit;

  000f9	eb 77		 jmp	 SHORT $exit$121942
$LN3@posix_acce:
  000fb	48 89 9c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rbx
  00103	48 89 ac 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rbp

; 2561 :     }
; 2562 : #endif
; 2563 : 
; 2564 : #ifdef MS_WINDOWS
; 2565 :     Py_BEGIN_ALLOW_THREADS

  0010b	e8 00 00 00 00	 call	 PyEval_SaveThread

; 2566 :     if (path.wide != NULL)

  00110	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  00118	48 8b e8	 mov	 rbp, rax
  0011b	48 85 c9	 test	 rcx, rcx
  0011e	74 08		 je	 SHORT $LN2@posix_acce

; 2567 :         attr = GetFileAttributesW(path.wide);

  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW

; 2568 :     else

  00126	eb 0e		 jmp	 SHORT $LN11@posix_acce
$LN2@posix_acce:

; 2569 :         attr = GetFileAttributesA(path.narrow);

  00128	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA
$LN11@posix_acce:

; 2570 :     Py_END_ALLOW_THREADS

  00136	48 8b cd	 mov	 rcx, rbp
  00139	8b d8		 mov	 ebx, eax
  0013b	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00140	48 8b ac 24 d8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+216]

; 2571 : 
; 2572 :     /*
; 2573 :      * Access is possible if
; 2574 :      *   * we didn't get a -1, and
; 2575 :      *     * write access wasn't requested,
; 2576 :      *     * or the file isn't read-only,
; 2577 :      *     * or it's a directory.
; 2578 :      * (Directories cannot be read-only on Windows.)
; 2579 :     */
; 2580 :     return_value = PyBool_FromLong(
; 2581 :         (attr != 0xFFFFFFFF) &&
; 2582 :             (!(mode & 2) ||
; 2583 :             !(attr & FILE_ATTRIBUTE_READONLY) ||
; 2584 :             (attr & FILE_ATTRIBUTE_DIRECTORY)));

  00148	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  0014b	74 11		 je	 SHORT $LN9@posix_acce
  0014d	f6 44 24 68 02	 test	 BYTE PTR mode$[rsp], 2
  00152	74 0c		 je	 SHORT $LN10@posix_acce
  00154	40 84 de	 test	 bl, sil
  00157	74 07		 je	 SHORT $LN10@posix_acce
  00159	f6 c3 10	 test	 bl, 16
  0015c	75 02		 jne	 SHORT $LN10@posix_acce
$LN9@posix_acce:
  0015e	8b f7		 mov	 esi, edi
$LN10@posix_acce:
  00160	8b ce		 mov	 ecx, esi
  00162	e8 00 00 00 00	 call	 PyBool_FromLong
  00167	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+208]
  0016f	48 8b f8	 mov	 rdi, rax
$exit$121942:

; 2585 : #else
; 2586 : 
; 2587 :     Py_BEGIN_ALLOW_THREADS
; 2588 : #ifdef HAVE_FACCESSAT
; 2589 :     if ((dir_fd != DEFAULT_DIR_FD) ||
; 2590 :         effective_ids ||
; 2591 :         !follow_symlinks) {
; 2592 :         int flags = 0;
; 2593 :         if (!follow_symlinks)
; 2594 :             flags |= AT_SYMLINK_NOFOLLOW;
; 2595 :         if (effective_ids)
; 2596 :             flags |= AT_EACCESS;
; 2597 :         result = faccessat(dir_fd, path.narrow, mode, flags);
; 2598 :     }
; 2599 :     else
; 2600 : #endif
; 2601 :         result = access(path.narrow, mode);
; 2602 :     Py_END_ALLOW_THREADS
; 2603 :     return_value = PyBool_FromLong(!result);
; 2604 : #endif
; 2605 : 
; 2606 : #ifndef HAVE_FACCESSAT
; 2607 : exit:
; 2608 : #endif
; 2609 :     path_cleanup(&path);

  00172	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  00177	e8 00 00 00 00	 call	 path_cleanup

; 2610 :     return return_value;
; 2611 : }

  0017c	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+224]
  00184	48 8b c7	 mov	 rax, rdi
  00187	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0018e	5f		 pop	 rdi
  0018f	c3		 ret	 0
posix_access ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_chdir DD imagerel posix_chdir
	DD	imagerel posix_chdir+120
	DD	imagerel $unwind$posix_chdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_chdir DD imagerel posix_chdir+120
	DD	imagerel posix_chdir+185
	DD	imagerel $chain$1$posix_chdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_chdir DD imagerel posix_chdir+185
	DD	imagerel posix_chdir+301
	DD	imagerel $chain$2$posix_chdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_chdir DD 021H
	DD	imagerel posix_chdir
	DD	imagerel posix_chdir+120
	DD	imagerel $unwind$posix_chdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_chdir DD 020821H
	DD	0107408H
	DD	imagerel posix_chdir
	DD	imagerel posix_chdir+120
	DD	imagerel $unwind$posix_chdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_chdir DD 047801H
	DD	0123478H
	DD	011010aH
xdata	ENDS
;	COMDAT ??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@
CONST	SEGMENT
??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@ DB 'O&:chdir', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_chdir
_TEXT	SEGMENT
path$ = 48
self$ = 144
args$ = 152
kwargs$ = 160
posix_chdir PROC					; COMDAT

; 2689 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2690 :     path_t path;
; 2691 :     int result;
; 2692 :     PyObject *return_value = NULL;
; 2693 :     static char *keywords[] = {"path", NULL};
; 2694 : 
; 2695 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 2696 : #ifdef HAVE_FCHDIR
; 2697 :     path.allow_fd = 1;
; 2698 : #endif
; 2699 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&:chdir", keywords,
; 2700 :         path_converter, &path
; 2701 :         ))

  00036	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_chdir@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@
  00048	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0005a	49 8b ca	 mov	 rcx, r10
  0005d	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00062	85 c0		 test	 eax, eax
  00064	75 0a		 jne	 SHORT $LN4@posix_chdi

; 2702 :         return NULL;

  00066	33 c0		 xor	 eax, eax

; 2734 : }

  00068	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0006f	c3		 ret	 0
$LN4@posix_chdi:
  00070	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00078	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi

; 2703 : 
; 2704 :     Py_BEGIN_ALLOW_THREADS

  00080	e8 00 00 00 00	 call	 PyEval_SaveThread

; 2705 : #ifdef MS_WINDOWS
; 2706 :     if (path.wide)

  00085	48 8b 4c 24 48	 mov	 rcx, QWORD PTR path$[rsp+24]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	48 85 c9	 test	 rcx, rcx
  00090	74 07		 je	 SHORT $LN3@posix_chdi

; 2707 :         result = win32_wchdir(path.wide);

  00092	e8 00 00 00 00	 call	 win32_wchdir

; 2708 :     else

  00097	eb 0a		 jmp	 SHORT $LN11@posix_chdi
$LN3@posix_chdi:

; 2709 :         result = win32_chdir(path.narrow);

  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp+32]
  0009e	e8 00 00 00 00	 call	 win32_chdir
$LN11@posix_chdi:

; 2710 :     result = !result; /* on unix, success = 0, on windows, success = !0 */
; 2711 : #elif defined(PYOS_OS2) && defined(PYCC_GCC)
; 2712 :     result = _chdir2(path.narrow);
; 2713 : #else
; 2714 : #ifdef HAVE_FCHDIR
; 2715 :     if (path.fd != -1)
; 2716 :         result = fchdir(path.fd);
; 2717 :     else
; 2718 : #endif
; 2719 :         result = chdir(path.narrow);
; 2720 : #endif
; 2721 :     Py_END_ALLOW_THREADS

  000a3	48 8b cf	 mov	 rcx, rdi
  000a6	8b d8		 mov	 ebx, eax
  000a8	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000ad	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]
  000b5	85 db		 test	 ebx, ebx

; 2722 : 
; 2723 :     if (result) {

  000b7	75 0f		 jne	 SHORT $LN1@posix_chdi

; 2724 :         return_value = path_error("chdir", &path);

  000b9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR path$[rsp]
  000be	e8 00 00 00 00	 call	 path_error
  000c3	48 8b d8	 mov	 rbx, rax

; 2725 :         goto exit;

  000c6	eb 48		 jmp	 SHORT $exit$121976
$LN1@posix_chdi:

; 2726 :     }
; 2727 : 
; 2728 :     return_value = Py_None;

  000c8	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 2729 :     Py_INCREF(Py_None);

  000cf	e8 00 00 00 00	 call	 _Py_PXCTX
  000d4	85 c0		 test	 eax, eax
  000d6	75 38		 jne	 SHORT $exit$121976
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e6	4c 8b cb	 mov	 r9, rbx
  000e9	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ef	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fc	85 c0		 test	 eax, eax
  000fe	75 09		 jne	 SHORT $LN7@posix_chdi
  00100	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00107	74 07		 je	 SHORT $exit$121976
$LN7@posix_chdi:
  00109	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$exit$121976:

; 2730 : 
; 2731 : exit:
; 2732 :     path_cleanup(&path);

  00110	48 8d 4c 24 30	 lea	 rcx, QWORD PTR path$[rsp]
  00115	e8 00 00 00 00	 call	 path_cleanup

; 2733 :     return return_value;

  0011a	48 8b c3	 mov	 rax, rbx
  0011d	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 2734 : }

  00125	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0012c	c3		 ret	 0
posix_chdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@	; `string'
EXTRN	__imp_SetFileAttributesA:PROC
EXTRN	__imp_SetFileAttributesW:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_chmod DD imagerel posix_chmod
	DD	imagerel posix_chmod+197
	DD	imagerel $unwind$posix_chmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_chmod DD imagerel posix_chmod+197
	DD	imagerel posix_chmod+321
	DD	imagerel $chain$0$posix_chmod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_chmod DD imagerel posix_chmod+321
	DD	imagerel posix_chmod+433
	DD	imagerel $chain$1$posix_chmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_chmod DD 021H
	DD	imagerel posix_chmod
	DD	imagerel posix_chmod+197
	DD	imagerel $unwind$posix_chmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_chmod DD 020821H
	DD	0187408H
	DD	imagerel posix_chmod
	DD	imagerel posix_chmod+197
	DD	imagerel $unwind$posix_chmod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_chmod DD 030b01H
	DD	016010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@
CONST	SEGMENT
??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@ DB 'O&i|$O&p:chmod', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_chmod
_TEXT	SEGMENT
dir_fd$ = 80
mode$ = 84
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
follow_symlinks$ = 216
posix_chmod PROC					; COMDAT

; 2769 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 2770 :     path_t path;
; 2771 :     int mode;
; 2772 :     int dir_fd = DEFAULT_DIR_FD;
; 2773 :     int follow_symlinks = 1;
; 2774 :     int result;
; 2775 :     PyObject *return_value = NULL;
; 2776 :     static char *keywords[] = {"path", "mode", "dir_fd",
; 2777 :                                "follow_symlinks", NULL};
; 2778 : 
; 2779 : #ifdef MS_WINDOWS
; 2780 :     DWORD attr;
; 2781 : #endif
; 2782 : 
; 2783 : #ifdef HAVE_FCHMODAT
; 2784 :     int fchmodat_nofollow_unsupported = 0;
; 2785 : #endif
; 2786 : 
; 2787 :     memset(&path, 0, sizeof(path));

  0000b	33 c9		 xor	 ecx, ecx
  0000d	49 8b c0	 mov	 rax, r8
  00010	4c 8b d2	 mov	 r10, rdx
  00013	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00017	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001b	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001f	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00023	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00027	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002b	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002f	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00033	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 2788 : #ifdef HAVE_FCHMOD
; 2789 :     path.allow_fd = 1;
; 2790 : #endif
; 2791 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|$O&p:chmod", keywords,
; 2792 :         path_converter, &path,
; 2793 :         &mode,
; 2794 : #ifdef HAVE_FCHMODAT
; 2795 :         dir_fd_converter, &dir_fd,
; 2796 : #else
; 2797 :         dir_fd_unavailable, &dir_fd,
; 2798 : #endif
; 2799 :         &follow_symlinks))

  00037	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_chmod@@9@9
  00042	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@
  00049	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  0004d	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00051	48 8b d0	 mov	 rdx, rax
  00054	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  0005f	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00067	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  0006b	49 8d 4b 9c	 lea	 rcx, QWORD PTR [r11-100]
  0006f	41 c7 43 20 01
	00 00 00	 mov	 DWORD PTR [r11+32], 1
  00077	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0007c	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  00080	33 db		 xor	 ebx, ebx
  00082	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  0008e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00093	49 8b ca	 mov	 rcx, r10
  00096	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009b	85 c0		 test	 eax, eax
  0009d	75 0b		 jne	 SHORT $LN11@posix_chmo

; 2800 :         return NULL;

  0009f	33 c0		 xor	 eax, eax

; 2892 : }

  000a1	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
$LN11@posix_chmo:

; 2801 : 
; 2802 : #if !(defined(HAVE_FCHMODAT) || defined(HAVE_LCHMOD))
; 2803 :     if (follow_symlinks_specified("chmod", follow_symlinks))

  000aa	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OCEJBCEE@chmod?$AA@
  000b8	e8 00 00 00 00	 call	 follow_symlinks_specified
  000bd	85 c0		 test	 eax, eax
  000bf	0f 85 d6 00 00
	00		 jne	 $exit$122003

; 2804 :         goto exit;
; 2805 : #endif
; 2806 : 
; 2807 : #ifdef MS_WINDOWS
; 2808 :     Py_BEGIN_ALLOW_THREADS

  000c5	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rdi
  000cd	e8 00 00 00 00	 call	 PyEval_SaveThread

; 2809 :     if (path.wide)

  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR path$[rsp+24]
  000d7	48 8b f8	 mov	 rdi, rax
  000da	48 85 c9	 test	 rcx, rcx
  000dd	74 08		 je	 SHORT $LN9@posix_chmo

; 2810 :         attr = GetFileAttributesW(path.wide);

  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW

; 2811 :     else

  000e5	eb 0e		 jmp	 SHORT $LN8@posix_chmo
$LN9@posix_chmo:

; 2812 :         attr = GetFileAttributesA(path.narrow);

  000e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA
$LN8@posix_chmo:

; 2813 :     if (attr == 0xFFFFFFFF)

  000f5	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  000f8	74 33		 je	 SHORT $LN2@posix_chmo

; 2814 :         result = 0;
; 2815 :     else {
; 2816 :         if (mode & _S_IWRITE)

  000fa	f6 44 24 54 80	 test	 BYTE PTR mode$[rsp], -128 ; ffffffffffffff80H
  000ff	74 05		 je	 SHORT $LN5@posix_chmo

; 2817 :             attr &= ~FILE_ATTRIBUTE_READONLY;

  00101	83 e0 fe	 and	 eax, -2			; fffffffeH

; 2818 :         else

  00104	eb 03		 jmp	 SHORT $LN4@posix_chmo
$LN5@posix_chmo:

; 2819 :             attr |= FILE_ATTRIBUTE_READONLY;

  00106	83 c8 01	 or	 eax, 1
$LN4@posix_chmo:

; 2820 :         if (path.wide)

  00109	48 8b 4c 24 78	 mov	 rcx, QWORD PTR path$[rsp+24]

; 2821 :             result = SetFileAttributesW(path.wide, attr);

  0010e	8b d0		 mov	 edx, eax
  00110	48 85 c9	 test	 rcx, rcx
  00113	74 08		 je	 SHORT $LN3@posix_chmo
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileAttributesW

; 2822 :         else

  0011b	eb 0e		 jmp	 SHORT $LN18@posix_chmo
$LN3@posix_chmo:

; 2823 :             result = SetFileAttributesA(path.narrow, attr);

  0011d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileAttributesA
$LN18@posix_chmo:
  0012b	8b d8		 mov	 ebx, eax
$LN2@posix_chmo:

; 2824 :     }
; 2825 :     Py_END_ALLOW_THREADS

  0012d	48 8b cf	 mov	 rcx, rdi
  00130	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00135	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]

; 2826 : 
; 2827 :     if (!result) {

  0013d	85 db		 test	 ebx, ebx
  0013f	75 12		 jne	 SHORT $LN1@posix_chmo

; 2828 :         return_value = win32_error_object("chmod", path.object);

  00141	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+56]
  00149	e8 00 00 00 00	 call	 win32_error_object
  0014e	48 8b d8	 mov	 rbx, rax

; 2829 :         goto exit;

  00151	eb 48		 jmp	 SHORT $exit$122003
$LN1@posix_chmo:

; 2830 :     }
; 2831 : #else /* MS_WINDOWS */
; 2832 :     Py_BEGIN_ALLOW_THREADS
; 2833 : #ifdef HAVE_FCHMOD
; 2834 :     if (path.fd != -1)
; 2835 :         result = fchmod(path.fd, mode);
; 2836 :     else
; 2837 : #endif
; 2838 : #ifdef HAVE_LCHMOD
; 2839 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
; 2840 :         result = lchmod(path.narrow, mode);
; 2841 :     else
; 2842 : #endif
; 2843 : #ifdef HAVE_FCHMODAT
; 2844 :     if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks) {
; 2845 :         /*
; 2846 :          * fchmodat() doesn't currently support AT_SYMLINK_NOFOLLOW!
; 2847 :          * The documentation specifically shows how to use it,
; 2848 :          * and then says it isn't implemented yet.
; 2849 :          * (true on linux with glibc 2.15, and openindiana 3.x)
; 2850 :          *
; 2851 :          * Once it is supported, os.chmod will automatically
; 2852 :          * support dir_fd and follow_symlinks=False.  (Hopefully.)
; 2853 :          * Until then, we need to be careful what exception we raise.
; 2854 :          */
; 2855 :         result = fchmodat(dir_fd, path.narrow, mode,
; 2856 :                           follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
; 2857 :         /*
; 2858 :          * But wait!  We can't throw the exception without allowing threads,
; 2859 :          * and we can't do that in this nested scope.  (Macro trickery, sigh.)
; 2860 :          */
; 2861 :         fchmodat_nofollow_unsupported =
; 2862 :                          result &&
; 2863 :                          ((errno == ENOTSUP) || (errno == EOPNOTSUPP)) &&
; 2864 :                          !follow_symlinks;
; 2865 :     }
; 2866 :     else
; 2867 : #endif
; 2868 :         result = chmod(path.narrow, mode);
; 2869 :     Py_END_ALLOW_THREADS
; 2870 : 
; 2871 :     if (result) {
; 2872 : #ifdef HAVE_FCHMODAT
; 2873 :         if (fchmodat_nofollow_unsupported) {
; 2874 :             if (dir_fd != DEFAULT_DIR_FD)
; 2875 :                 dir_fd_and_follow_symlinks_invalid("chmod",
; 2876 :                                                    dir_fd, follow_symlinks);
; 2877 :             else
; 2878 :                 follow_symlinks_specified("chmod", follow_symlinks);
; 2879 :         }
; 2880 :         else
; 2881 : #endif
; 2882 :             return_value = path_error("chmod", &path);
; 2883 :         goto exit;
; 2884 :     }
; 2885 : #endif
; 2886 : 
; 2887 :     Py_INCREF(Py_None);

  00153	e8 00 00 00 00	 call	 _Py_PXCTX
  00158	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0015f	85 c0		 test	 eax, eax
  00161	75 38		 jne	 SHORT $exit$122003
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00171	4c 8b cb	 mov	 r9, rbx
  00174	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	e8 00 00 00 00	 call	 _PyParallel_Guard
  00187	85 c0		 test	 eax, eax
  00189	75 09		 jne	 SHORT $LN14@posix_chmo
  0018b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00192	74 07		 je	 SHORT $exit$122003
$LN14@posix_chmo:
  00194	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$exit$122003:

; 2888 :     return_value = Py_None;
; 2889 : exit:
; 2890 :     path_cleanup(&path);

  0019b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  001a0	e8 00 00 00 00	 call	 path_cleanup

; 2891 :     return return_value;

  001a5	48 8b c3	 mov	 rax, rbx

; 2892 : }

  001a8	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  001af	5b		 pop	 rbx
  001b0	c3		 ret	 0
posix_chmod ENDP
_TEXT	ENDS
EXTRN	__imp__commit:PROC
; Function compile flags: /Ogtpy
;	COMDAT posix_fsync
_TEXT	SEGMENT
self$ = 8
fdobj$ = 16
posix_fsync PROC					; COMDAT

; 3049 :     return posix_fildes(fdobj, fsync);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp__commit

; 3050 : }

  0000a	e9 00 00 00 00	 jmp	 posix_fildes
posix_fsync ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp_getcwd:PROC
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getcwd DD imagerel posix_getcwd
	DD	imagerel posix_getcwd+21
	DD	imagerel $unwind$posix_getcwd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_getcwd DD imagerel posix_getcwd+21
	DD	imagerel posix_getcwd+126
	DD	imagerel $chain$0$posix_getcwd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_getcwd DD imagerel posix_getcwd+126
	DD	imagerel posix_getcwd+377
	DD	imagerel $chain$1$posix_getcwd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_getcwd DD 021H
	DD	imagerel posix_getcwd
	DD	imagerel posix_getcwd+21
	DD	imagerel $unwind$posix_getcwd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_getcwd DD 020821H
	DD	018a6408H
	DD	imagerel posix_getcwd
	DD	imagerel posix_getcwd+21
	DD	imagerel $unwind$posix_getcwd
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getcwd DD 050d01H
	DD	018b340dH
	DD	0188010dH
	DD	07006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT posix_getcwd
_TEXT	SEGMENT
buf$ = 32
wbuf$122029 = 1072
use_bytes$ = 3152
posix_getcwd PROC					; COMDAT

; 3251 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 40 0c
	00 00		 sub	 rsp, 3136		; 00000c40H

; 3252 :     char buf[1026];
; 3253 :     char *res;
; 3254 : 
; 3255 : #ifdef MS_WINDOWS
; 3256 :     if (!use_bytes) {

  0000d	85 c9		 test	 ecx, ecx
  0000f	0f 85 ea 00 00
	00		 jne	 $LN10@posix_getc

; 3257 :         wchar_t wbuf[1026];
; 3258 :         wchar_t *wbuf2 = wbuf;

  00015	48 89 b4 24 50
	0c 00 00	 mov	 QWORD PTR [rsp+3152], rsi
  0001d	48 8d bc 24 30
	04 00 00	 lea	 rdi, QWORD PTR wbuf$122029[rsp]

; 3259 :         PyObject *resobj;
; 3260 :         DWORD len;
; 3261 :         Py_BEGIN_ALLOW_THREADS

  00025	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3262 :         len = GetCurrentDirectoryW(sizeof wbuf/ sizeof wbuf[0], wbuf);

  0002a	48 8d 94 24 30
	04 00 00	 lea	 rdx, QWORD PTR wbuf$122029[rsp]
  00032	b9 02 04 00 00	 mov	 ecx, 1026		; 00000402H
  00037	48 8b f0	 mov	 rsi, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  00040	8b d8		 mov	 ebx, eax

; 3263 :         /* If the buffer is large enough, len does not include the
; 3264 :            terminating \0. If the buffer is too small, len includes
; 3265 :            the space needed for the terminator. */
; 3266 :         if (len >= sizeof wbuf/ sizeof wbuf[0]) {

  00042	3d 02 04 00 00	 cmp	 eax, 1026		; 00000402H
  00047	72 20		 jb	 SHORT $LN8@posix_getc

; 3267 :             wbuf2 = malloc(len * sizeof(wchar_t));

  00049	8b cb		 mov	 ecx, ebx
  0004b	48 03 c9	 add	 rcx, rcx
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00054	48 8b f8	 mov	 rdi, rax

; 3268 :             if (wbuf2)

  00057	48 85 c0	 test	 rax, rax
  0005a	74 0d		 je	 SHORT $LN8@posix_getc

; 3269 :                 len = GetCurrentDirectoryW(len, wbuf2);

  0005c	48 8b d0	 mov	 rdx, rax
  0005f	8b cb		 mov	 ecx, ebx
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  00067	8b d8		 mov	 ebx, eax
$LN8@posix_getc:

; 3270 :         }
; 3271 :         Py_END_ALLOW_THREADS

  00069	48 8b ce	 mov	 rcx, rsi
  0006c	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00071	48 8b b4 24 50
	0c 00 00	 mov	 rsi, QWORD PTR [rsp+3152]

; 3272 :         if (!wbuf2) {

  00079	48 85 ff	 test	 rdi, rdi
  0007c	75 18		 jne	 SHORT $LN7@posix_getc

; 3273 :             PyErr_NoMemory();

  0007e	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN13@posix_getc:

; 3274 :             return NULL;

  00083	33 c0		 xor	 eax, eax

; 3300 :     return PyUnicode_DecodeFSDefault(buf);
; 3301 : }

  00085	48 8b 9c 24 58
	0c 00 00	 mov	 rbx, QWORD PTR [rsp+3160]
  0008d	48 81 c4 40 0c
	00 00		 add	 rsp, 3136		; 00000c40H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
$LN7@posix_getc:

; 3275 :         }
; 3276 :         if (!len) {

  00096	85 db		 test	 ebx, ebx
  00098	75 2e		 jne	 SHORT $LN6@posix_getc

; 3277 :             if (wbuf2 != wbuf) free(wbuf2);

  0009a	48 8d 84 24 30
	04 00 00	 lea	 rax, QWORD PTR wbuf$122029[rsp]
  000a2	48 3b f8	 cmp	 rdi, rax
  000a5	74 09		 je	 SHORT $LN5@posix_getc
  000a7	48 8b cf	 mov	 rcx, rdi
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@posix_getc:

; 3278 :             return win32_error("getcwdu", NULL);

  000b0	33 c9		 xor	 ecx, ecx
  000b2	e8 00 00 00 00	 call	 win32_error

; 3300 :     return PyUnicode_DecodeFSDefault(buf);
; 3301 : }

  000b7	48 8b 9c 24 58
	0c 00 00	 mov	 rbx, QWORD PTR [rsp+3160]
  000bf	48 81 c4 40 0c
	00 00		 add	 rsp, 3136		; 00000c40H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
$LN6@posix_getc:

; 3279 :         }
; 3280 :         resobj = PyUnicode_FromWideChar(wbuf2, len);

  000c8	8b d3		 mov	 edx, ebx
  000ca	48 8b cf	 mov	 rcx, rdi
  000cd	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000d2	48 8b d8	 mov	 rbx, rax

; 3281 :         if (wbuf2 != wbuf) free(wbuf2);

  000d5	48 8d 84 24 30
	04 00 00	 lea	 rax, QWORD PTR wbuf$122029[rsp]
  000dd	48 3b f8	 cmp	 rdi, rax
  000e0	74 09		 je	 SHORT $LN4@posix_getc
  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@posix_getc:

; 3282 :         return resobj;

  000eb	48 8b c3	 mov	 rax, rbx

; 3300 :     return PyUnicode_DecodeFSDefault(buf);
; 3301 : }

  000ee	48 8b 9c 24 58
	0c 00 00	 mov	 rbx, QWORD PTR [rsp+3160]
  000f6	48 81 c4 40 0c
	00 00		 add	 rsp, 3136		; 00000c40H
  000fd	5f		 pop	 rdi
  000fe	c3		 ret	 0
$LN10@posix_getc:

; 3283 :     }
; 3284 : 
; 3285 :     if (win32_warn_bytes_api())

  000ff	e8 00 00 00 00	 call	 win32_warn_bytes_api
  00104	85 c0		 test	 eax, eax

; 3286 :         return NULL;

  00106	0f 85 77 ff ff
	ff		 jne	 $LN13@posix_getc

; 3287 : #endif
; 3288 : 
; 3289 :     Py_BEGIN_ALLOW_THREADS

  0010c	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3290 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 3291 :     res = _getcwd2(buf, sizeof buf);
; 3292 : #else
; 3293 :     res = getcwd(buf, sizeof buf);

  00111	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00116	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  0011b	48 8b d8	 mov	 rbx, rax
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getcwd

; 3294 : #endif
; 3295 :     Py_END_ALLOW_THREADS

  00124	48 8b cb	 mov	 rcx, rbx
  00127	48 8b f8	 mov	 rdi, rax
  0012a	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3296 :     if (res == NULL)

  0012f	48 85 ff	 test	 rdi, rdi
  00132	75 16		 jne	 SHORT $LN2@posix_getc

; 3297 :         return posix_error();

  00134	e8 00 00 00 00	 call	 posix_error

; 3300 :     return PyUnicode_DecodeFSDefault(buf);
; 3301 : }

  00139	48 8b 9c 24 58
	0c 00 00	 mov	 rbx, QWORD PTR [rsp+3160]
  00141	48 81 c4 40 0c
	00 00		 add	 rsp, 3136		; 00000c40H
  00148	5f		 pop	 rdi
  00149	c3		 ret	 0
$LN2@posix_getc:

; 3298 :     if (use_bytes)
; 3299 :         return PyBytes_FromStringAndSize(buf, strlen(buf));

  0014a	48 83 c9 ff	 or	 rcx, -1
  0014e	33 c0		 xor	 eax, eax
  00150	48 8d 7c 24 20	 lea	 rdi, QWORD PTR buf$[rsp]
  00155	f2 ae		 repne scasb
  00157	48 f7 d1	 not	 rcx
  0015a	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  0015e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00163	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 3300 :     return PyUnicode_DecodeFSDefault(buf);
; 3301 : }

  00168	48 8b 9c 24 58
	0c 00 00	 mov	 rbx, QWORD PTR [rsp+3160]
  00170	48 81 c4 40 0c
	00 00		 add	 rsp, 3136		; 00000c40H
  00177	5f		 pop	 rdi
  00178	c3		 ret	 0
posix_getcwd ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT posix_getcwd_unicode
_TEXT	SEGMENT
self$ = 8
posix_getcwd_unicode PROC				; COMDAT

; 3310 :     return posix_getcwd(0);

  00000	33 c9		 xor	 ecx, ecx

; 3311 : }

  00002	e9 00 00 00 00	 jmp	 posix_getcwd
posix_getcwd_unicode ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT posix_getcwd_bytes
_TEXT	SEGMENT
self$ = 8
posix_getcwd_bytes PROC					; COMDAT

; 3320 :     return posix_getcwd(1);

  00000	b9 01 00 00 00	 mov	 ecx, 1

; 3321 : }

  00005	e9 00 00 00 00	 jmp	 posix_getcwd
posix_getcwd_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@ ; `string'
PUBLIC	??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@ ; `string'
EXTRN	__imp_CreateHardLinkA:PROC
EXTRN	__imp_CreateHardLinkW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_link DD imagerel posix_link
	DD	imagerel posix_link+318
	DD	imagerel $unwind$posix_link
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_link DD imagerel posix_link+318
	DD	imagerel posix_link+394
	DD	imagerel $chain$0$posix_link
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_link DD imagerel posix_link+394
	DD	imagerel posix_link+482
	DD	imagerel $chain$1$posix_link
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_link DD 021H
	DD	imagerel posix_link
	DD	imagerel posix_link+318
	DD	imagerel $unwind$posix_link
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_link DD 020821H
	DD	0267408H
	DD	imagerel posix_link
	DD	imagerel posix_link+318
	DD	imagerel $unwind$posix_link
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_link DD 051201H
	DD	0273412H
	DD	0240112H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
CONST	SEGMENT
??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@ DB 'src_dir_fd and ds'
	DB	't_dir_fd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@
CONST	SEGMENT
??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@ DB 'link: sr'
	DB	'c and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@
CONST	SEGMENT
??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@ DB 'O&O&|O&O&p:li'
	DB	'nk', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_link
_TEXT	SEGMENT
dst_dir_fd$ = 112
follow_symlinks$ = 116
dst$ = 128
src$ = 208
self$ = 304
args$ = 312
kwargs$ = 320
src_dir_fd$ = 328
posix_link PROC						; COMDAT

; 3345 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	48 8d 6c 24 e0	 lea	 rbp, QWORD PTR [rsp-32]
  0000b	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 3346 :     path_t src, dst;
; 3347 :     int src_dir_fd = DEFAULT_DIR_FD;
; 3348 :     int dst_dir_fd = DEFAULT_DIR_FD;
; 3349 :     int follow_symlinks = 1;
; 3350 :     PyObject *return_value = NULL;
; 3351 :     static char *keywords[] = {"src", "dst", "src_dir_fd", "dst_dir_fd",
; 3352 :                                "follow_symlinks", NULL};
; 3353 : #ifdef MS_WINDOWS
; 3354 :     BOOL result;
; 3355 : #else
; 3356 :     int result;
; 3357 : #endif
; 3358 : 
; 3359 :     memset(&src, 0, sizeof(src));

  00012	33 c9		 xor	 ecx, ecx
  00014	4c 8b d2	 mov	 r10, rdx

; 3360 :     memset(&dst, 0, sizeof(dst));
; 3361 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&O&|O&O&p:link", keywords,
; 3362 :             path_converter, &src,
; 3363 :             path_converter, &dst,
; 3364 :             dir_fd_converter, &src_dir_fd,
; 3365 :             dir_fd_converter, &dst_dir_fd,
; 3366 :             &follow_symlinks))

  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dir_fd_converter
  0001e	48 89 4d d0	 mov	 QWORD PTR src$[rbp-256], rcx
  00022	48 89 4d d8	 mov	 QWORD PTR src$[rbp-248], rcx
  00026	48 89 4d e0	 mov	 QWORD PTR src$[rbp-240], rcx
  0002a	48 89 4d e8	 mov	 QWORD PTR src$[rbp-232], rcx
  0002e	48 89 4d f0	 mov	 QWORD PTR src$[rbp-224], rcx
  00032	48 89 4d f8	 mov	 QWORD PTR src$[rbp-216], rcx
  00036	48 89 4d 00	 mov	 QWORD PTR src$[rbp-208], rcx
  0003a	48 89 4d 08	 mov	 QWORD PTR src$[rbp-200], rcx
  0003e	48 89 4d 10	 mov	 QWORD PTR src$[rbp-192], rcx
  00042	48 89 4d 80	 mov	 QWORD PTR dst$[rbp-256], rcx
  00046	48 89 4d 88	 mov	 QWORD PTR dst$[rbp-248], rcx
  0004a	48 89 4d 90	 mov	 QWORD PTR dst$[rbp-240], rcx
  0004e	48 89 4d 98	 mov	 QWORD PTR dst$[rbp-232], rcx
  00052	48 89 4d a0	 mov	 QWORD PTR dst$[rbp-224], rcx
  00056	48 89 4d a8	 mov	 QWORD PTR dst$[rbp-216], rcx
  0005a	48 89 4d b0	 mov	 QWORD PTR dst$[rbp-208], rcx
  0005e	48 89 4d b8	 mov	 QWORD PTR dst$[rbp-200], rcx
  00062	48 89 4d c0	 mov	 QWORD PTR dst$[rbp-192], rcx
  00066	49 8b c0	 mov	 rax, r8
  00069	48 8d 4c 24 74	 lea	 rcx, QWORD PTR follow_symlinks$[rsp]
  0006e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_link@@9@9
  00075	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0007a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR dst_dir_fd$[rsp]
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@
  00086	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0008b	48 89 54 24 50	 mov	 QWORD PTR [rsp+80], rdx
  00090	48 8d 4d 48	 lea	 rcx, QWORD PTR src_dir_fd$[rbp-256]
  00094	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00099	48 89 54 24 40	 mov	 QWORD PTR [rsp+64], rdx
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:path_converter
  000a5	48 8d 4d 80	 lea	 rcx, QWORD PTR dst$[rbp-256]
  000a9	c7 45 48 9c ff
	ff ff		 mov	 DWORD PTR src_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  000b0	c7 44 24 70 9c
	ff ff ff	 mov	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  000b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bd	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  000c2	48 8d 4d d0	 lea	 rcx, QWORD PTR src$[rbp-256]
  000c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d0	48 8b d0	 mov	 rdx, rax
  000d3	49 8b ca	 mov	 rcx, r10
  000d6	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR follow_symlinks$[rsp], 1
  000de	33 db		 xor	 ebx, ebx
  000e0	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000e5	85 c0		 test	 eax, eax
  000e7	75 13		 jne	 SHORT $LN9@posix_link

; 3367 :         return NULL;

  000e9	33 c0		 xor	 eax, eax

; 3421 : }

  000eb	48 8b 9c 24 38
	01 00 00	 mov	 rbx, QWORD PTR [rsp+312]
  000f3	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
$LN9@posix_link:

; 3368 : 
; 3369 : #ifndef HAVE_LINKAT
; 3370 :     if ((src_dir_fd != DEFAULT_DIR_FD) || (dst_dir_fd != DEFAULT_DIR_FD)) {

  000fc	83 7d 48 9c	 cmp	 DWORD PTR src_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  00100	0f 85 a3 00 00
	00		 jne	 $LN7@posix_link
  00106	83 7c 24 70 9c	 cmp	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0010b	0f 85 98 00 00
	00		 jne	 $LN7@posix_link

; 3372 :         goto exit;
; 3373 :     }
; 3374 : #endif
; 3375 : 
; 3376 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  00111	48 39 5d f0	 cmp	 QWORD PTR src$[rbp-224], rbx
  00115	74 06		 je	 SHORT $LN4@posix_link
  00117	48 39 5d 98	 cmp	 QWORD PTR dst$[rbp-232], rbx
  0011b	75 0c		 jne	 SHORT $LN5@posix_link
$LN4@posix_link:
  0011d	48 39 5d e8	 cmp	 QWORD PTR src$[rbp-232], rbx
  00121	74 1b		 je	 SHORT $LN6@posix_link
  00123	48 39 5d a0	 cmp	 QWORD PTR dst$[rbp-224], rbx
  00127	74 15		 je	 SHORT $LN6@posix_link
$LN5@posix_link:

; 3377 :         PyErr_SetString(PyExc_NotImplementedError,
; 3378 :                         "link: src and dst must be the same type");

  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@
  00137	e8 00 00 00 00	 call	 PyErr_SetString

; 3379 :         goto exit;

  0013c	eb 7e		 jmp	 SHORT $exit$122092
$LN6@posix_link:
  0013e	48 89 bc 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], rdi

; 3380 :     }
; 3381 : 
; 3382 : #ifdef MS_WINDOWS
; 3383 :     Py_BEGIN_ALLOW_THREADS

  00146	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3384 :     if (src.wide)

  0014b	48 8b 55 e8	 mov	 rdx, QWORD PTR src$[rbp-232]

; 3385 :         result = CreateHardLinkW(dst.wide, src.wide, NULL);

  0014f	45 33 c0	 xor	 r8d, r8d
  00152	48 8b f8	 mov	 rdi, rax
  00155	48 85 d2	 test	 rdx, rdx
  00158	74 0c		 je	 SHORT $LN3@posix_link
  0015a	48 8b 4d 98	 mov	 rcx, QWORD PTR dst$[rbp-232]
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateHardLinkW

; 3386 :     else

  00164	eb 0e		 jmp	 SHORT $LN12@posix_link
$LN3@posix_link:

; 3387 :         result = CreateHardLinkA(dst.narrow, src.narrow, NULL);

  00166	48 8b 55 f0	 mov	 rdx, QWORD PTR src$[rbp-224]
  0016a	48 8b 4d a0	 mov	 rcx, QWORD PTR dst$[rbp-224]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateHardLinkA
$LN12@posix_link:

; 3388 :     Py_END_ALLOW_THREADS

  00174	48 8b cf	 mov	 rcx, rdi
  00177	8b d8		 mov	 ebx, eax
  00179	e8 00 00 00 00	 call	 PyEval_RestoreThread
  0017e	48 8b bc 24 30
	01 00 00	 mov	 rdi, QWORD PTR [rsp+304]

; 3389 : 
; 3390 :     if (!result) {

  00186	85 db		 test	 ebx, ebx
  00188	75 0e		 jne	 SHORT $LN1@posix_link

; 3391 :         return_value = win32_error_object("link", dst.object);

  0018a	48 8b 4d b8	 mov	 rcx, QWORD PTR dst$[rbp-200]
  0018e	e8 00 00 00 00	 call	 win32_error_object
  00193	48 8b d8	 mov	 rbx, rax

; 3392 :         goto exit;

  00196	eb 24		 jmp	 SHORT $exit$122092
$LN1@posix_link:

; 3393 :     }
; 3394 : #else
; 3395 :     Py_BEGIN_ALLOW_THREADS
; 3396 : #ifdef HAVE_LINKAT
; 3397 :     if ((src_dir_fd != DEFAULT_DIR_FD) ||
; 3398 :         (dst_dir_fd != DEFAULT_DIR_FD) ||
; 3399 :         (!follow_symlinks))
; 3400 :         result = linkat(src_dir_fd, src.narrow,
; 3401 :             dst_dir_fd, dst.narrow,
; 3402 :             follow_symlinks ? AT_SYMLINK_FOLLOW : 0);
; 3403 :     else
; 3404 : #endif
; 3405 :         result = link(src.narrow, dst.narrow);
; 3406 :     Py_END_ALLOW_THREADS
; 3407 : 
; 3408 :     if (result) {
; 3409 :         return_value = path_error("link", &dst);
; 3410 :         goto exit;
; 3411 :     }
; 3412 : #endif
; 3413 : 
; 3414 :     return_value = Py_None;

  00198	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 3415 :     Py_INCREF(Py_None);

  0019f	48 8b cb	 mov	 rcx, rbx
  001a2	e8 00 00 00 00	 call	 _Py_IncRef
  001a7	eb 13		 jmp	 SHORT $exit$122092
$LN7@posix_link:

; 3371 :         argument_unavailable_error("link", "src_dir_fd and dst_dir_fd");

  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OHHBHOGB@link?$AA@
  001b7	e8 00 00 00 00	 call	 argument_unavailable_error
$exit$122092:

; 3416 : 
; 3417 : exit:
; 3418 :     path_cleanup(&src);

  001bc	48 8d 4d d0	 lea	 rcx, QWORD PTR src$[rbp-256]
  001c0	e8 00 00 00 00	 call	 path_cleanup

; 3419 :     path_cleanup(&dst);

  001c5	48 8d 4d 80	 lea	 rcx, QWORD PTR dst$[rbp-256]
  001c9	e8 00 00 00 00	 call	 path_cleanup

; 3420 :     return return_value;

  001ce	48 8b c3	 mov	 rax, rbx

; 3421 : }

  001d1	48 8b 9c 24 38
	01 00 00	 mov	 rbx, QWORD PTR [rsp+312]
  001d9	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  001e0	5d		 pop	 rbp
  001e1	c3		 ret	 0
posix_link ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@	; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@	; `string'
EXTRN	__imp_FindNextFileA:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	__imp_FindNextFileW:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_listdir DD imagerel posix_listdir
	DD	imagerel posix_listdir+162
	DD	imagerel $unwind$posix_listdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_listdir DD imagerel posix_listdir+162
	DD	imagerel posix_listdir+1116
	DD	imagerel $chain$0$posix_listdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_listdir DD imagerel posix_listdir+1116
	DD	imagerel posix_listdir+1141
	DD	imagerel $chain$1$posix_listdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_listdir DD 021H
	DD	imagerel posix_listdir
	DD	imagerel posix_listdir+162
	DD	imagerel $unwind$posix_listdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_listdir DD 020821H
	DD	0a86408H
	DD	imagerel posix_listdir
	DD	imagerel posix_listdir+162
	DD	imagerel $unwind$posix_listdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_listdir DD 091e01H
	DD	0aa741eH
	DD	0a9341eH
	DD	0a4011eH
	DD	0c00dd00fH
	DD	0500bH
xdata	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@ DB '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@ DB '*', 00H, '.', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@ DB '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@
CONST	SEGMENT
??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@ DB '|O&:listdir', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_listdir
_TEXT	SEGMENT
path$ = 48
namebuf$ = 128
FileData$ = 400
wFileData$122136 = 720
self$ = 1344
args$ = 1352
kwargs$ = 1360
posix_listdir PROC					; COMDAT

; 3441 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000a	55		 push	 rbp
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 8d ac 24 e0
	fb ff ff	 lea	 rbp, QWORD PTR [rsp-1056]
  00017	48 81 ec 20 05
	00 00		 sub	 rsp, 1312		; 00000520H

; 3442 :     path_t path;
; 3443 :     PyObject *list = NULL;
; 3444 :     static char *keywords[] = {"path", NULL};
; 3445 : #ifdef HAVE_FDOPENDIR
; 3446 :     int fd = -1;
; 3447 : #endif /* HAVE_FDOPENDIR */
; 3448 : 
; 3449 : #if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)
; 3450 :     PyObject *v;
; 3451 :     HANDLE hFindFile = INVALID_HANDLE_VALUE;
; 3452 :     BOOL result;
; 3453 :     WIN32_FIND_DATA FileData;
; 3454 :     char namebuf[MAX_PATH+5]; /* Overallocate for \\*.*\0 */
; 3455 :     char *bufptr = namebuf;
; 3456 :     /* only claim to have space for MAX_PATH */
; 3457 :     Py_ssize_t len = sizeof(namebuf)-5;
; 3458 :     PyObject *po = NULL;
; 3459 :     wchar_t *wnamebuf = NULL;
; 3460 : #elif defined(PYOS_OS2)
; 3461 : #ifndef MAX_PATH
; 3462 : #define MAX_PATH    CCHMAXPATH
; 3463 : #endif
; 3464 :     char *pt;
; 3465 :     PyObject *v;
; 3466 :     char namebuf[MAX_PATH+5];
; 3467 :     HDIR  hdir = 1;
; 3468 :     ULONG srchcnt = 1;
; 3469 :     FILEFINDBUF3   ep;
; 3470 :     APIRET rc;
; 3471 : #else
; 3472 :     PyObject *v;
; 3473 :     DIR *dirp = NULL;
; 3474 :     struct dirent *ep;
; 3475 :     int return_str; /* if false, return bytes */
; 3476 : #endif
; 3477 : 
; 3478 :     memset(&path, 0, sizeof(path));

  0001e	33 c9		 xor	 ecx, ecx
  00020	49 8b c0	 mov	 rax, r8
  00023	48 8b fa	 mov	 rdi, rdx
  00026	48 89 4c 24 40	 mov	 QWORD PTR path$[rsp+16], rcx
  0002b	48 89 4c 24 30	 mov	 QWORD PTR path$[rsp], rcx
  00030	48 89 4c 24 38	 mov	 QWORD PTR path$[rsp+8], rcx
  00035	48 89 4c 24 48	 mov	 QWORD PTR path$[rsp+24], rcx
  0003a	48 89 4c 24 50	 mov	 QWORD PTR path$[rsp+32], rcx
  0003f	48 89 4c 24 58	 mov	 QWORD PTR path$[rsp+40], rcx
  00044	48 89 4c 24 60	 mov	 QWORD PTR path$[rsp+48], rcx
  00049	48 89 4c 24 68	 mov	 QWORD PTR path$[rsp+56], rcx
  0004e	48 89 4c 24 70	 mov	 QWORD PTR path$[rsp+64], rcx

; 3479 :     path.nullable = 1;
; 3480 : #ifdef HAVE_FDOPENDIR
; 3481 :     path.allow_fd = 1;
; 3482 :     path.fd = -1;
; 3483 : #endif
; 3484 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O&:listdir", keywords,
; 3485 :         path_converter, &path
; 3486 :         ))

  00053	48 8d 4c 24 30	 lea	 rcx, QWORD PTR path$[rsp]
  00058	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_listdir@@9@9
  0005f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@
  00066	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00072	41 bc 01 00 00
	00		 mov	 r12d, 1
  00078	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0007d	48 8b d0	 mov	 rdx, rax
  00080	48 8b cf	 mov	 rcx, rdi
  00083	33 db		 xor	 ebx, ebx
  00085	45 33 ed	 xor	 r13d, r13d
  00088	44 89 64 24 40	 mov	 DWORD PTR path$[rsp+16], r12d
  0008d	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00092	85 c0		 test	 eax, eax
  00094	75 07		 jne	 SHORT $LN33@posix_list

; 3487 :         return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	e9 bf 03 00 00	 jmp	 $LN34@posix_list
$LN33@posix_list:

; 3488 : 
; 3489 :     /* XXX Should redo this putting the (now four) versions of opendir
; 3490 :        in separate files instead of having them all here... */
; 3491 : #if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)
; 3492 :     if (!path.narrow) {

  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp+32]
  000a2	48 89 b4 24 40
	05 00 00	 mov	 QWORD PTR [rsp+1344], rsi
  000aa	48 85 c9	 test	 rcx, rcx
  000ad	0f 85 fb 01 00
	00		 jne	 $LN32@posix_list

; 3493 :         WIN32_FIND_DATAW wFileData;
; 3494 :         wchar_t *po_wchars;
; 3495 : 
; 3496 :         if (!path.wide) { /* Default arg: "." */

  000b3	48 8b 74 24 48	 mov	 rsi, QWORD PTR path$[rsp+24]
  000b8	48 85 f6	 test	 rsi, rsi
  000bb	75 09		 jne	 SHORT $LN31@posix_list

; 3497 :             po_wchars = L".";

  000bd	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@

; 3498 :             len = 1;
; 3499 :         } else {

  000c4	eb 13		 jmp	 SHORT $LN30@posix_list
$LN31@posix_list:

; 3500 :             po_wchars = path.wide;
; 3501 :             len = wcslen(path.wide);

  000c6	48 83 c9 ff	 or	 rcx, -1
  000ca	33 c0		 xor	 eax, eax
  000cc	48 8b fe	 mov	 rdi, rsi
  000cf	66 f2 af	 repne scasw
  000d2	48 f7 d1	 not	 rcx
  000d5	4c 8d 61 ff	 lea	 r12, QWORD PTR [rcx-1]
$LN30@posix_list:

; 3502 :         }
; 3503 :         /* The +5 is so we can append "\\*.*\0" */
; 3504 :         wnamebuf = malloc((len + 5) * sizeof(wchar_t));

  000d9	4b 8d 4c 24 0a	 lea	 rcx, QWORD PTR [r12+r12+10]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000e4	4c 8b e8	 mov	 r13, rax

; 3505 :         if (!wnamebuf) {

  000e7	48 85 c0	 test	 rax, rax
  000ea	75 0a		 jne	 SHORT $LN29@posix_list

; 3506 :             PyErr_NoMemory();

  000ec	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3507 :             goto exit;

  000f1	e9 51 03 00 00	 jmp	 $LN1@posix_list
$LN29@posix_list:

; 3508 :         }
; 3509 :         wcscpy(wnamebuf, po_wchars);

  000f6	48 8b c8	 mov	 rcx, rax
  000f9	48 2b ce	 sub	 rcx, rsi
  000fc	0f 1f 40 00	 npad	 4
$LL36@posix_list:
  00100	0f b7 06	 movzx	 eax, WORD PTR [rsi]
  00103	48 83 c6 02	 add	 rsi, 2
  00107	66 89 44 31 fe	 mov	 WORD PTR [rcx+rsi-2], ax
  0010c	66 85 c0	 test	 ax, ax
  0010f	75 ef		 jne	 SHORT $LL36@posix_list

; 3510 :         if (len > 0) {

  00111	4d 85 e4	 test	 r12, r12
  00114	7e 4b		 jle	 SHORT $LN28@posix_list

; 3511 :             wchar_t wch = wnamebuf[len-1];

  00116	43 0f b7 44 65
	fe		 movzx	 eax, WORD PTR [r13+r12*2-2]

; 3512 :             if (wch != L'/' && wch != L'\\' && wch != L':')

  0011c	66 83 f8 2f	 cmp	 ax, 47			; 0000002fH
  00120	74 1a		 je	 SHORT $LN27@posix_list
  00122	66 83 f8 5c	 cmp	 ax, 92			; 0000005cH
  00126	74 14		 je	 SHORT $LN27@posix_list
  00128	66 83 f8 3a	 cmp	 ax, 58			; 0000003aH
  0012c	74 0e		 je	 SHORT $LN27@posix_list

; 3513 :                 wnamebuf[len++] = L'\\';

  0012e	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  00133	49 ff c4	 inc	 r12
  00136	66 43 89 44 65
	fe		 mov	 WORD PTR [r13+r12*2-2], ax
$LN27@posix_list:

; 3514 :             wcscpy(wnamebuf + len, L"*.*");

  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@
  00143	4b 8d 14 24	 lea	 rdx, QWORD PTR [r12+r12]
  00147	48 2b d1	 sub	 rdx, rcx
  0014a	49 03 d5	 add	 rdx, r13
  0014d	0f 1f 00	 npad	 3
$LL37@posix_list:
  00150	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00153	48 83 c1 02	 add	 rcx, 2
  00157	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  0015c	66 85 c0	 test	 ax, ax
  0015f	75 ef		 jne	 SHORT $LL37@posix_list
$LN28@posix_list:

; 3515 :         }
; 3516 :         if ((list = PyList_New(0)) == NULL) {

  00161	33 c9		 xor	 ecx, ecx
  00163	e8 00 00 00 00	 call	 PyList_New
  00168	48 8b d8	 mov	 rbx, rax
  0016b	48 85 c0	 test	 rax, rax
  0016e	0f 84 c5 02 00
	00		 je	 $LN2@posix_list

; 3517 :             goto exit;
; 3518 :         }
; 3519 :         Py_BEGIN_ALLOW_THREADS

  00174	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3520 :         hFindFile = FindFirstFileW(wnamebuf, &wFileData);

  00179	48 8d 95 d0 01
	00 00		 lea	 rdx, QWORD PTR wFileData$122136[rbp-256]
  00180	49 8b cd	 mov	 rcx, r13
  00183	48 8b f8	 mov	 rdi, rax
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW

; 3521 :         Py_END_ALLOW_THREADS

  0018c	48 8b cf	 mov	 rcx, rdi
  0018f	4c 8b e0	 mov	 r12, rax
  00192	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3522 :         if (hFindFile == INVALID_HANDLE_VALUE) {

  00197	49 83 fc ff	 cmp	 r12, -1
  0019b	75 33		 jne	 SHORT $LL23@posix_list

; 3523 :             int error = GetLastError();

  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 3524 :             if (error == ERROR_FILE_NOT_FOUND)

  001a3	83 f8 02	 cmp	 eax, 2
  001a6	0f 84 8d 02 00
	00		 je	 $LN2@posix_list

; 3525 :                 goto exit;
; 3526 :             Py_DECREF(list);

  001ac	48 8b cb	 mov	 rcx, rbx
  001af	e8 00 00 00 00	 call	 _Py_DecRef

; 3527 :             list = NULL;
; 3528 :             win32_error_unicode("FindFirstFileW", wnamebuf);

  001b4	49 8b cd	 mov	 rcx, r13
  001b7	33 db		 xor	 ebx, ebx
  001b9	e8 00 00 00 00	 call	 win32_error_unicode

; 3529 :             goto exit;

  001be	e9 76 02 00 00	 jmp	 $LN2@posix_list
  001c3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL23@posix_list:

; 3530 :         }
; 3531 :         do {
; 3532 :             /* Skip over . and .. */
; 3533 :             if (wcscmp(wFileData.cFileName, L".") != 0 &&
; 3534 :                 wcscmp(wFileData.cFileName, L"..") != 0) {

  001d0	48 8d b5 fc 01
	00 00		 lea	 rsi, QWORD PTR wFileData$122136[rbp-212]
  001d7	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
  001de	b9 02 00 00 00	 mov	 ecx, 2
  001e3	66 f3 a7	 repe cmpsw
  001e6	74 5a		 je	 SHORT $LN20@posix_list
  001e8	48 8d b5 fc 01
	00 00		 lea	 rsi, QWORD PTR wFileData$122136[rbp-212]
  001ef	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
  001f6	b9 03 00 00 00	 mov	 ecx, 3
  001fb	66 f3 a7	 repe cmpsw
  001fe	74 42		 je	 SHORT $LN20@posix_list

; 3535 :                 v = PyUnicode_FromWideChar(wFileData.cFileName,
; 3536 :                                            wcslen(wFileData.cFileName));

  00200	48 83 c9 ff	 or	 rcx, -1
  00204	33 c0		 xor	 eax, eax
  00206	48 8d bd fc 01
	00 00		 lea	 rdi, QWORD PTR wFileData$122136[rbp-212]
  0020d	66 f2 af	 repne scasw
  00210	48 f7 d1	 not	 rcx
  00213	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00217	48 8d 8d fc 01
	00 00		 lea	 rcx, QWORD PTR wFileData$122136[rbp-212]
  0021e	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3537 :                 if (v == NULL) {
; 3538 :                     Py_DECREF(list);
; 3539 :                     list = NULL;
; 3540 :                     break;
; 3541 :                 }
; 3542 :                 if (PyList_Append(list, v) != 0) {

  00223	48 8b cb	 mov	 rcx, rbx
  00226	48 8b f8	 mov	 rdi, rax
  00229	48 85 c0	 test	 rax, rax
  0022c	74 50		 je	 SHORT $LN44@posix_list
  0022e	48 8b d0	 mov	 rdx, rax
  00231	e8 00 00 00 00	 call	 PyList_Append

; 3547 :                 }
; 3548 :                 Py_DECREF(v);

  00236	48 8b cf	 mov	 rcx, rdi
  00239	85 c0		 test	 eax, eax
  0023b	75 39		 jne	 SHORT $LN45@posix_list
  0023d	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@posix_list:

; 3549 :             }
; 3550 :             Py_BEGIN_ALLOW_THREADS

  00242	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3551 :             result = FindNextFileW(hFindFile, &wFileData);

  00247	48 8d 95 d0 01
	00 00		 lea	 rdx, QWORD PTR wFileData$122136[rbp-256]
  0024e	49 8b cc	 mov	 rcx, r12
  00251	48 8b f8	 mov	 rdi, rax
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileW

; 3552 :             Py_END_ALLOW_THREADS

  0025a	48 8b cf	 mov	 rcx, rdi
  0025d	8b f0		 mov	 esi, eax
  0025f	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3553 :             /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3554 :                it got to the end of the directory. */
; 3555 :             if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  00264	85 f6		 test	 esi, esi
  00266	74 22		 je	 SHORT $LN53@posix_list

; 3559 :             }
; 3560 :         } while (result == TRUE);

  00268	83 fe 01	 cmp	 esi, 1
  0026b	0f 84 5f ff ff
	ff		 je	 $LL23@posix_list
  00271	e9 9c 01 00 00	 jmp	 $exit$122143
$LN45@posix_list:

; 3543 :                     Py_DECREF(v);

  00276	e8 00 00 00 00	 call	 _Py_DecRef

; 3544 :                     Py_DECREF(list);

  0027b	48 8b cb	 mov	 rcx, rbx
$LN44@posix_list:
  0027e	e8 00 00 00 00	 call	 _Py_DecRef

; 3545 :                     list = NULL;

  00283	33 db		 xor	 ebx, ebx

; 3546 :                     break;

  00285	e9 88 01 00 00	 jmp	 $exit$122143
$LN53@posix_list:

; 3553 :             /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3554 :                it got to the end of the directory. */
; 3555 :             if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00290	83 f8 12	 cmp	 eax, 18
  00293	0f 84 79 01 00
	00		 je	 $exit$122143

; 3556 :                 Py_DECREF(list);

  00299	48 8b cb	 mov	 rcx, rbx
  0029c	e8 00 00 00 00	 call	 _Py_DecRef

; 3557 :                 list = win32_error_unicode("FindNextFileW", wnamebuf);

  002a1	49 8b cd	 mov	 rcx, r13
  002a4	e8 00 00 00 00	 call	 win32_error_unicode

; 3558 :                 goto exit;

  002a9	e9 61 01 00 00	 jmp	 $LN62@posix_list
$LN32@posix_list:

; 3561 : 
; 3562 :         goto exit;
; 3563 :     }
; 3564 :     strcpy(namebuf, path.narrow);

  002ae	48 8d 55 80	 lea	 rdx, QWORD PTR namebuf$[rbp-256]
  002b2	48 2b d1	 sub	 rdx, rcx
  002b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL38@posix_list:
  002c0	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  002c3	48 ff c1	 inc	 rcx
  002c6	88 44 0a ff	 mov	 BYTE PTR [rdx+rcx-1], al
  002ca	84 c0		 test	 al, al
  002cc	75 f2		 jne	 SHORT $LL38@posix_list

; 3565 :     len = path.length;

  002ce	48 8b 44 24 60	 mov	 rax, QWORD PTR path$[rsp+48]

; 3566 :     if (len > 0) {

  002d3	48 85 c0	 test	 rax, rax
  002d6	7e 24		 jle	 SHORT $LN16@posix_list

; 3567 :         char ch = namebuf[len-1];

  002d8	0f b6 4c 04 7f	 movzx	 ecx, BYTE PTR namebuf$[rsp+rax-1]

; 3568 :         if (ch != SEP && ch != ALTSEP && ch != ':')

  002dd	80 f9 5c	 cmp	 cl, 92			; 0000005cH
  002e0	74 12		 je	 SHORT $LN15@posix_list
  002e2	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  002e5	74 0d		 je	 SHORT $LN15@posix_list
  002e7	80 f9 3a	 cmp	 cl, 58			; 0000003aH
  002ea	74 08		 je	 SHORT $LN15@posix_list

; 3569 :             namebuf[len++] = '/';

  002ec	c6 44 05 80 2f	 mov	 BYTE PTR namebuf$[rbp+rax-256], 47 ; 0000002fH
  002f1	48 ff c0	 inc	 rax
$LN15@posix_list:

; 3570 :         strcpy(namebuf + len, "*.*");

  002f4	c7 44 05 80 2a
	2e 2a 00	 mov	 DWORD PTR namebuf$[rbp+rax-256], 2764330 ; 002a2e2aH
$LN16@posix_list:

; 3571 :     }
; 3572 : 
; 3573 :     if ((list = PyList_New(0)) == NULL)

  002fc	33 c9		 xor	 ecx, ecx
  002fe	e8 00 00 00 00	 call	 PyList_New
  00303	48 8b d8	 mov	 rbx, rax
  00306	48 85 c0	 test	 rax, rax
  00309	0f 84 45 01 00
	00		 je	 $LN61@posix_list
$LN14@posix_list:

; 3574 :         return NULL;
; 3575 : 
; 3576 :     Py_BEGIN_ALLOW_THREADS

  0030f	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3577 :     hFindFile = FindFirstFile(namebuf, &FileData);

  00314	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR FileData$[rbp-256]
  0031b	48 8d 4d 80	 lea	 rcx, QWORD PTR namebuf$[rbp-256]
  0031f	48 8b f8	 mov	 rdi, rax
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA

; 3578 :     Py_END_ALLOW_THREADS

  00328	48 8b cf	 mov	 rcx, rdi
  0032b	4c 8b e0	 mov	 r12, rax
  0032e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3579 :     if (hFindFile == INVALID_HANDLE_VALUE) {

  00333	49 83 fc ff	 cmp	 r12, -1
  00337	75 28		 jne	 SHORT $LL11@posix_list

; 3580 :         int error = GetLastError();

  00339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 3581 :         if (error == ERROR_FILE_NOT_FOUND)

  0033f	83 f8 02	 cmp	 eax, 2
  00342	0f 84 ff 00 00
	00		 je	 $LN1@posix_list

; 3582 :             goto exit;
; 3583 :         Py_DECREF(list);

  00348	48 8b cb	 mov	 rcx, rbx
  0034b	e8 00 00 00 00	 call	 _Py_DecRef

; 3584 :         list = win32_error("FindFirstFile", namebuf);

  00350	48 8d 4d 80	 lea	 rcx, QWORD PTR namebuf$[rbp-256]
  00354	e8 00 00 00 00	 call	 win32_error
  00359	48 8b d8	 mov	 rbx, rax

; 3585 :         goto exit;

  0035c	e9 e6 00 00 00	 jmp	 $LN1@posix_list
$LL11@posix_list:

; 3586 :     }
; 3587 :     do {
; 3588 :         /* Skip over . and .. */
; 3589 :         if (strcmp(FileData.cFileName, ".") != 0 &&
; 3590 :             strcmp(FileData.cFileName, "..") != 0) {

  00361	48 8d b5 bc 00
	00 00		 lea	 rsi, QWORD PTR FileData$[rbp-212]
  00368	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  0036f	b9 02 00 00 00	 mov	 ecx, 2
  00374	f3 a6		 repe cmpsb
  00376	74 4a		 je	 SHORT $LN8@posix_list
  00378	48 8d b5 bc 00
	00 00		 lea	 rsi, QWORD PTR FileData$[rbp-212]
  0037f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_02DJGKEECL@?4?4?$AA@
  00386	b9 03 00 00 00	 mov	 ecx, 3
  0038b	f3 a6		 repe cmpsb
  0038d	74 33		 je	 SHORT $LN8@posix_list

; 3591 :             v = PyBytes_FromString(FileData.cFileName);

  0038f	48 8d 8d bc 00
	00 00		 lea	 rcx, QWORD PTR FileData$[rbp-212]
  00396	e8 00 00 00 00	 call	 PyBytes_FromString

; 3592 :             if (v == NULL) {
; 3593 :                 Py_DECREF(list);
; 3594 :                 list = NULL;
; 3595 :                 break;
; 3596 :             }
; 3597 :             if (PyList_Append(list, v) != 0) {

  0039b	48 8b cb	 mov	 rcx, rbx
  0039e	48 8b f8	 mov	 rdi, rax
  003a1	48 85 c0	 test	 rax, rax
  003a4	0f 84 d4 fe ff
	ff		 je	 $LN44@posix_list
  003aa	48 8b d0	 mov	 rdx, rax
  003ad	e8 00 00 00 00	 call	 PyList_Append

; 3598 :                 Py_DECREF(v);
; 3599 :                 Py_DECREF(list);
; 3600 :                 list = NULL;
; 3601 :                 break;
; 3602 :             }
; 3603 :             Py_DECREF(v);

  003b2	48 8b cf	 mov	 rcx, rdi
  003b5	85 c0		 test	 eax, eax
  003b7	0f 85 b9 fe ff
	ff		 jne	 $LN45@posix_list
  003bd	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@posix_list:

; 3604 :         }
; 3605 :         Py_BEGIN_ALLOW_THREADS

  003c2	e8 00 00 00 00	 call	 PyEval_SaveThread

; 3606 :         result = FindNextFile(hFindFile, &FileData);

  003c7	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR FileData$[rbp-256]
  003ce	49 8b cc	 mov	 rcx, r12
  003d1	48 8b f8	 mov	 rdi, rax
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileA

; 3607 :         Py_END_ALLOW_THREADS

  003da	48 8b cf	 mov	 rcx, rdi
  003dd	8b f0		 mov	 esi, eax
  003df	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3608 :         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3609 :            it got to the end of the directory. */
; 3610 :         if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  003e4	85 f6		 test	 esi, esi
  003e6	74 0b		 je	 SHORT $LN54@posix_list

; 3613 :             goto exit;
; 3614 :         }
; 3615 :     } while (result == TRUE);

  003e8	83 fe 01	 cmp	 esi, 1
  003eb	0f 84 70 ff ff
	ff		 je	 $LL11@posix_list
  003f1	eb 1f		 jmp	 SHORT $exit$122143
$LN54@posix_list:

; 3608 :         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3609 :            it got to the end of the directory. */
; 3610 :         if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  003f9	83 f8 12	 cmp	 eax, 18
  003fc	74 14		 je	 SHORT $exit$122143

; 3611 :             Py_DECREF(list);

  003fe	48 8b cb	 mov	 rcx, rbx
  00401	e8 00 00 00 00	 call	 _Py_DecRef

; 3612 :             list = win32_error("FindNextFile", namebuf);

  00406	48 8d 4d 80	 lea	 rcx, QWORD PTR namebuf$[rbp-256]
  0040a	e8 00 00 00 00	 call	 win32_error
$LN62@posix_list:
  0040f	48 8b d8	 mov	 rbx, rax
$exit$122143:

; 3616 : 
; 3617 : exit:
; 3618 :     if (hFindFile != INVALID_HANDLE_VALUE) {
; 3619 :         if (FindClose(hFindFile) == FALSE) {

  00412	49 8b cc	 mov	 rcx, r12
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose
  0041b	85 c0		 test	 eax, eax
  0041d	75 1a		 jne	 SHORT $LN2@posix_list

; 3620 :             if (list != NULL) {

  0041f	48 85 db	 test	 rbx, rbx
  00422	74 15		 je	 SHORT $LN2@posix_list

; 3621 :                 Py_DECREF(list);

  00424	48 8b cb	 mov	 rcx, rbx
  00427	e8 00 00 00 00	 call	 _Py_DecRef

; 3622 :                 list = win32_error_object("FindClose", path.object);

  0042c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR path$[rsp+56]
  00431	e8 00 00 00 00	 call	 win32_error_object
  00436	48 8b d8	 mov	 rbx, rax
$LN2@posix_list:

; 3623 :             }
; 3624 :         }
; 3625 :     }
; 3626 :     if (wnamebuf)

  00439	4d 85 ed	 test	 r13, r13
  0043c	74 09		 je	 SHORT $LN1@posix_list

; 3627 :         free(wnamebuf);

  0043e	49 8b cd	 mov	 rcx, r13
  00441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@posix_list:

; 3628 :     path_cleanup(&path);

  00447	48 8d 4c 24 30	 lea	 rcx, QWORD PTR path$[rsp]
  0044c	e8 00 00 00 00	 call	 path_cleanup

; 3629 : 
; 3630 :     return list;

  00451	48 8b c3	 mov	 rax, rbx
$LN61@posix_list:
  00454	48 8b b4 24 40
	05 00 00	 mov	 rsi, QWORD PTR [rsp+1344]
$LN34@posix_list:

; 3631 : 
; 3632 : #elif defined(PYOS_OS2)
; 3633 :     if (path.length >= MAX_PATH) {
; 3634 :         PyErr_SetString(PyExc_ValueError, "path too long");
; 3635 :         goto exit;
; 3636 :     }
; 3637 :     strcpy(namebuf, path.narrow);
; 3638 :     for (pt = namebuf; *pt; pt++)
; 3639 :         if (*pt == ALTSEP)
; 3640 :             *pt = SEP;
; 3641 :     if (namebuf[len-1] != SEP)
; 3642 :         namebuf[len++] = SEP;
; 3643 :     strcpy(namebuf + len, "*.*");
; 3644 : 
; 3645 :     if ((list = PyList_New(0)) == NULL) {
; 3646 :         goto exit;
; 3647 :     }
; 3648 : 
; 3649 :     rc = DosFindFirst(namebuf,         /* Wildcard Pattern to Match */
; 3650 :                       &hdir,           /* Handle to Use While Search Directory */
; 3651 :                       FILE_READONLY | FILE_HIDDEN | FILE_SYSTEM | FILE_DIRECTORY,
; 3652 :                       &ep, sizeof(ep), /* Structure to Receive Directory Entry */
; 3653 :                       &srchcnt,        /* Max and Actual Count of Entries Per Iteration */
; 3654 :                       FIL_STANDARD);   /* Format of Entry (EAs or Not) */
; 3655 : 
; 3656 :     if (rc != NO_ERROR) {
; 3657 :         errno = ENOENT;
; 3658 :         Py_DECREF(list);
; 3659 :         list = posix_error_with_filename(path.narrow);
; 3660 :         goto exit;
; 3661 :     }
; 3662 : 
; 3663 :     if (srchcnt > 0) { /* If Directory is NOT Totally Empty, */
; 3664 :         do {
; 3665 :             if (ep.achName[0] == '.'
; 3666 :             && (ep.achName[1] == '\0' || (ep.achName[1] == '.' && ep.achName[2] == '\0')))
; 3667 :                 continue; /* Skip Over "." and ".." Names */
; 3668 : 
; 3669 :             strcpy(namebuf, ep.achName);
; 3670 : 
; 3671 :             /* Leave Case of Name Alone -- In Native Form */
; 3672 :             /* (Removed Forced Lowercasing Code) */
; 3673 : 
; 3674 :             v = PyBytes_FromString(namebuf);
; 3675 :             if (v == NULL) {
; 3676 :                 Py_DECREF(list);
; 3677 :                 list = NULL;
; 3678 :                 break;
; 3679 :             }
; 3680 :             if (PyList_Append(list, v) != 0) {
; 3681 :                 Py_DECREF(v);
; 3682 :                 Py_DECREF(list);
; 3683 :                 list = NULL;
; 3684 :                 break;
; 3685 :             }
; 3686 :             Py_DECREF(v);
; 3687 :         } while (DosFindNext(hdir, &ep, sizeof(ep), &srchcnt) == NO_ERROR && srchcnt > 0);
; 3688 :     }
; 3689 : 
; 3690 : exit:
; 3691 :     path_cleanup(&path);
; 3692 : 
; 3693 :     return list;
; 3694 : #else
; 3695 : 
; 3696 :     errno = 0;
; 3697 : #ifdef HAVE_FDOPENDIR
; 3698 :     if (path.fd != -1) {
; 3699 :         /* closedir() closes the FD, so we duplicate it */
; 3700 :         Py_BEGIN_ALLOW_THREADS
; 3701 :         fd = dup(path.fd);
; 3702 :         Py_END_ALLOW_THREADS
; 3703 : 
; 3704 :         if (fd == -1) {
; 3705 :             list = posix_error();
; 3706 :             goto exit;
; 3707 :         }
; 3708 : 
; 3709 :         return_str = 1;
; 3710 : 
; 3711 :         Py_BEGIN_ALLOW_THREADS
; 3712 :         dirp = fdopendir(fd);
; 3713 :         Py_END_ALLOW_THREADS
; 3714 :     }
; 3715 :     else
; 3716 : #endif
; 3717 :     {
; 3718 :         char *name;
; 3719 :         if (path.narrow) {
; 3720 :             name = path.narrow;
; 3721 :             /* only return bytes if they specified a bytes object */
; 3722 :             return_str = !(PyBytes_Check(path.object));
; 3723 :         }
; 3724 :         else {
; 3725 :             name = ".";
; 3726 :             return_str = 1;
; 3727 :         }
; 3728 : 
; 3729 :         Py_BEGIN_ALLOW_THREADS
; 3730 :         dirp = opendir(name);
; 3731 :         Py_END_ALLOW_THREADS
; 3732 :     }
; 3733 : 
; 3734 :     if (dirp == NULL) {
; 3735 :         list = path_error("listdir", &path);
; 3736 : #ifdef HAVE_FDOPENDIR
; 3737 :         if (fd != -1) {
; 3738 :             Py_BEGIN_ALLOW_THREADS
; 3739 :             close(fd);
; 3740 :             Py_END_ALLOW_THREADS
; 3741 :         }
; 3742 : #endif /* HAVE_FDOPENDIR */
; 3743 :         goto exit;
; 3744 :     }
; 3745 :     if ((list = PyList_New(0)) == NULL) {
; 3746 :         goto exit;
; 3747 :     }
; 3748 :     for (;;) {
; 3749 :         errno = 0;
; 3750 :         Py_BEGIN_ALLOW_THREADS
; 3751 :         ep = readdir(dirp);
; 3752 :         Py_END_ALLOW_THREADS
; 3753 :         if (ep == NULL) {
; 3754 :             if (errno == 0) {
; 3755 :                 break;
; 3756 :             } else {
; 3757 :                 Py_DECREF(list);
; 3758 :                 list = path_error("listdir", &path);
; 3759 :                 goto exit;
; 3760 :             }
; 3761 :         }
; 3762 :         if (ep->d_name[0] == '.' &&
; 3763 :             (NAMLEN(ep) == 1 ||
; 3764 :              (ep->d_name[1] == '.' && NAMLEN(ep) == 2)))
; 3765 :             continue;
; 3766 :         if (return_str)
; 3767 :             v = PyUnicode_DecodeFSDefaultAndSize(ep->d_name, NAMLEN(ep));
; 3768 :         else
; 3769 :             v = PyBytes_FromStringAndSize(ep->d_name, NAMLEN(ep));
; 3770 :         if (v == NULL) {
; 3771 :             Py_CLEAR(list);
; 3772 :             break;
; 3773 :         }
; 3774 :         if (PyList_Append(list, v) != 0) {
; 3775 :             Py_DECREF(v);
; 3776 :             Py_CLEAR(list);
; 3777 :             break;
; 3778 :         }
; 3779 :         Py_DECREF(v);
; 3780 :     }
; 3781 : 
; 3782 : exit:
; 3783 :     if (dirp != NULL) {
; 3784 :         Py_BEGIN_ALLOW_THREADS
; 3785 : #ifdef HAVE_FDOPENDIR
; 3786 :         if (fd > -1)
; 3787 :             rewinddir(dirp);
; 3788 : #endif /* HAVE_FDOPENDIR */
; 3789 :         closedir(dirp);
; 3790 :         Py_END_ALLOW_THREADS
; 3791 :     }
; 3792 : 
; 3793 :     path_cleanup(&path);
; 3794 : 
; 3795 :     return list;
; 3796 : 
; 3797 : #endif /* which OS */
; 3798 : }  /* end of posix_listdir */

  0045c	4c 8d 9c 24 20
	05 00 00	 lea	 r11, QWORD PTR [rsp+1312]
  00464	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  00468	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  0046c	49 8b e3	 mov	 rsp, r11
  0046f	41 5d		 pop	 r13
  00471	41 5c		 pop	 r12
  00473	5d		 pop	 rbp
  00474	c3		 ret	 0
posix_listdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@	; `string'
PUBLIC	??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@	; `string'
EXTRN	PyUnicode_Decode:PROC
EXTRN	Py_FileSystemDefaultEncoding:QWORD
EXTRN	PyTuple_GetItem:PROC
EXTRN	__imp_GetFullPathNameA:PROC
EXTRN	__imp_GetFullPathNameW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfullpathname DD imagerel posix__getfullpathname
	DD	imagerel posix__getfullpathname+51
	DD	imagerel $unwind$posix__getfullpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix__getfullpathname DD imagerel posix__getfullpathname+51
	DD	imagerel posix__getfullpathname+113
	DD	imagerel $chain$1$posix__getfullpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix__getfullpathname DD imagerel posix__getfullpathname+113
	DD	imagerel posix__getfullpathname+275
	DD	imagerel $chain$3$posix__getfullpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix__getfullpathname DD imagerel posix__getfullpathname+275
	DD	imagerel posix__getfullpathname+467
	DD	imagerel $chain$4$posix__getfullpathname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix__getfullpathname DD 021H
	DD	imagerel posix__getfullpathname
	DD	imagerel posix__getfullpathname+51
	DD	imagerel $unwind$posix__getfullpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix__getfullpathname DD 040021H
	DD	0cd6400H
	DD	0cc3400H
	DD	imagerel posix__getfullpathname
	DD	imagerel posix__getfullpathname+51
	DD	imagerel $unwind$posix__getfullpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix__getfullpathname DD 041021H
	DD	0cd6410H
	DD	0cc3408H
	DD	imagerel posix__getfullpathname
	DD	imagerel posix__getfullpathname+51
	DD	imagerel $unwind$posix__getfullpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfullpathname DD 030901H
	DD	0ca0109H
	DD	07002H
xdata	ENDS
;	COMDAT ??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@ DB 'y:_getfullpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@ DB 'U|:_getfullpathname', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix__getfullpathname
_TEXT	SEGMENT
wtemp$122235 = 32
temp$ = 40
outbuf$ = 48
woutbuf$122233 = 576
self$ = 1632
args$ = 1640
po$ = 1648
path$ = 1656
posix__getfullpathname PROC				; COMDAT

; 3804 : {

  00000	40 57		 push	 rdi
  00002	48 81 ec 50 06
	00 00		 sub	 rsp, 1616		; 00000650H
  00009	48 8b fa	 mov	 rdi, rdx

; 3805 :     const char *path;
; 3806 :     char outbuf[MAX_PATH*2];
; 3807 :     char *temp;
; 3808 :     PyObject *po;
; 3809 : 
; 3810 :     if (PyArg_ParseTuple(args, "U|:_getfullpathname", &po))

  0000c	4c 8d 84 24 70
	06 00 00	 lea	 r8, QWORD PTR po$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@
  0001b	48 8b cf	 mov	 rcx, rdi
  0001e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00023	85 c0		 test	 eax, eax
  00025	0f 84 e8 00 00
	00		 je	 $LN11@posix__get

; 3811 :     {
; 3812 :         wchar_t *wpath;
; 3813 :         wchar_t woutbuf[MAX_PATH*2], *woutbufp = woutbuf;
; 3814 :         wchar_t *wtemp;
; 3815 :         DWORD result;
; 3816 :         PyObject *v;
; 3817 : 
; 3818 :         wpath = PyUnicode_AsUnicode(po);

  0002b	48 8b 8c 24 70
	06 00 00	 mov	 rcx, QWORD PTR po$[rsp]
  00033	48 89 9c 24 60
	06 00 00	 mov	 QWORD PTR [rsp+1632], rbx
  0003b	48 89 b4 24 68
	06 00 00	 mov	 QWORD PTR [rsp+1640], rsi
  00043	48 8d 9c 24 40
	02 00 00	 lea	 rbx, QWORD PTR woutbuf$122233[rsp]
  0004b	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00050	48 8b f0	 mov	 rsi, rax

; 3819 :         if (wpath == NULL)

  00053	48 85 c0	 test	 rax, rax
  00056	75 19		 jne	 SHORT $LN10@posix__get
$LN15@posix__get:
  00058	48 8b 9c 24 60
	06 00 00	 mov	 rbx, QWORD PTR [rsp+1632]
  00060	48 8b b4 24 68
	06 00 00	 mov	 rsi, QWORD PTR [rsp+1640]

; 3857 : } /* end of posix__getfullpathname */

  00068	48 81 c4 50 06
	00 00		 add	 rsp, 1616		; 00000650H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
$LN10@posix__get:

; 3820 :             return NULL;
; 3821 :         result = GetFullPathNameW(wpath,
; 3822 :                                   Py_ARRAY_LENGTH(woutbuf),
; 3823 :                                   woutbuf, &wtemp);

  00071	4c 8d 4c 24 20	 lea	 r9, QWORD PTR wtemp$122235[rsp]
  00076	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR woutbuf$122233[rsp]
  0007e	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  00083	48 8b c8	 mov	 rcx, rax
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameW
  0008c	8b f8		 mov	 edi, eax

; 3824 :         if (result > Py_ARRAY_LENGTH(woutbuf)) {

  0008e	3d 08 02 00 00	 cmp	 eax, 520		; 00000208H
  00093	76 2f		 jbe	 SHORT $LN9@posix__get

; 3825 :             woutbufp = malloc(result * sizeof(wchar_t));

  00095	8b cf		 mov	 ecx, edi
  00097	48 03 c9	 add	 rcx, rcx
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000a0	48 8b d8	 mov	 rbx, rax

; 3826 :             if (!woutbufp)

  000a3	48 85 c0	 test	 rax, rax
  000a6	75 07		 jne	 SHORT $LN8@posix__get

; 3827 :                 return PyErr_NoMemory();

  000a8	e8 00 00 00 00	 call	 PyErr_NoMemory
  000ad	eb a9		 jmp	 SHORT $LN15@posix__get
$LN8@posix__get:

; 3828 :             result = GetFullPathNameW(wpath, result, woutbufp, &wtemp);

  000af	4c 8d 4c 24 20	 lea	 r9, QWORD PTR wtemp$122235[rsp]
  000b4	4c 8b c0	 mov	 r8, rax
  000b7	8b d7		 mov	 edx, edi
  000b9	48 8b ce	 mov	 rcx, rsi
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameW
  000c2	8b f8		 mov	 edi, eax
$LN9@posix__get:

; 3829 :         }
; 3830 :         if (result)

  000c4	85 ff		 test	 edi, edi
  000c6	74 1d		 je	 SHORT $LN7@posix__get

; 3831 :             v = PyUnicode_FromWideChar(woutbufp, wcslen(woutbufp));

  000c8	48 83 c9 ff	 or	 rcx, -1
  000cc	33 c0		 xor	 eax, eax
  000ce	48 8b fb	 mov	 rdi, rbx
  000d1	66 f2 af	 repne scasw
  000d4	48 f7 d1	 not	 rcx
  000d7	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3832 :         else

  000e3	eb 0d		 jmp	 SHORT $LN16@posix__get
$LN7@posix__get:

; 3833 :             v = win32_error_object("GetFullPathNameW", po);

  000e5	48 8b 8c 24 70
	06 00 00	 mov	 rcx, QWORD PTR po$[rsp]
  000ed	e8 00 00 00 00	 call	 win32_error_object
$LN16@posix__get:
  000f2	48 8b f8	 mov	 rdi, rax

; 3834 :         if (woutbufp != woutbuf)

  000f5	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR woutbuf$122233[rsp]
  000fd	48 3b d8	 cmp	 rbx, rax
  00100	74 09		 je	 SHORT $LN5@posix__get

; 3835 :             free(woutbufp);

  00102	48 8b cb	 mov	 rcx, rbx
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@posix__get:

; 3836 :         return v;

  0010b	48 8b c7	 mov	 rax, rdi
  0010e	e9 45 ff ff ff	 jmp	 $LN15@posix__get
$LN11@posix__get:

; 3837 :     }
; 3838 :     /* Drop the argument parsing error as narrow strings
; 3839 :        are also valid. */
; 3840 :     PyErr_Clear();

  00113	e8 00 00 00 00	 call	 PyErr_Clear

; 3841 : 
; 3842 :     if (!PyArg_ParseTuple (args, "y:_getfullpathname",
; 3843 :                            &path))

  00118	4c 8d 84 24 78
	06 00 00	 lea	 r8, QWORD PTR path$[rsp]
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@
  00127	48 8b cf	 mov	 rcx, rdi
  0012a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0012f	85 c0		 test	 eax, eax

; 3844 :         return NULL;

  00131	74 37		 je	 SHORT $LN17@posix__get

; 3845 :     if (win32_warn_bytes_api())

  00133	e8 00 00 00 00	 call	 win32_warn_bytes_api
  00138	85 c0		 test	 eax, eax

; 3846 :         return NULL;

  0013a	75 2e		 jne	 SHORT $LN17@posix__get

; 3847 :     if (!GetFullPathName(path, Py_ARRAY_LENGTH(outbuf),
; 3848 :                          outbuf, &temp)) {

  0013c	48 8b 8c 24 78
	06 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00144	4c 8d 4c 24 28	 lea	 r9, QWORD PTR temp$[rsp]
  00149	4c 8d 44 24 30	 lea	 r8, QWORD PTR outbuf$[rsp]
  0014e	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameA
  00159	85 c0		 test	 eax, eax
  0015b	75 18		 jne	 SHORT $LN2@posix__get

; 3849 :         win32_error("GetFullPathName", path);

  0015d	48 8b 8c 24 78
	06 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00165	e8 00 00 00 00	 call	 win32_error
$LN17@posix__get:

; 3850 :         return NULL;

  0016a	33 c0		 xor	 eax, eax

; 3857 : } /* end of posix__getfullpathname */

  0016c	48 81 c4 50 06
	00 00		 add	 rsp, 1616		; 00000650H
  00173	5f		 pop	 rdi
  00174	c3		 ret	 0
$LN2@posix__get:

; 3851 :     }
; 3852 :     if (PyUnicode_Check(PyTuple_GetItem(args, 0))) {

  00175	33 d2		 xor	 edx, edx
  00177	48 8b cf	 mov	 rcx, rdi
  0017a	e8 00 00 00 00	 call	 PyTuple_GetItem
  0017f	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00183	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  0018d	74 31		 je	 SHORT $LN1@posix__get

; 3853 :         return PyUnicode_Decode(outbuf, strlen(outbuf),
; 3854 :                                 Py_FileSystemDefaultEncoding, NULL);

  0018f	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR Py_FileSystemDefaultEncoding
  00196	48 83 c9 ff	 or	 rcx, -1
  0019a	33 c0		 xor	 eax, eax
  0019c	48 8d 7c 24 30	 lea	 rdi, QWORD PTR outbuf$[rsp]
  001a1	45 33 c9	 xor	 r9d, r9d
  001a4	f2 ae		 repne scasb
  001a6	48 f7 d1	 not	 rcx
  001a9	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  001ad	48 8d 4c 24 30	 lea	 rcx, QWORD PTR outbuf$[rsp]
  001b2	e8 00 00 00 00	 call	 PyUnicode_Decode

; 3857 : } /* end of posix__getfullpathname */

  001b7	48 81 c4 50 06
	00 00		 add	 rsp, 1616		; 00000650H
  001be	5f		 pop	 rdi
  001bf	c3		 ret	 0
$LN1@posix__get:

; 3855 :     }
; 3856 :     return PyBytes_FromString(outbuf);

  001c0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR outbuf$[rsp]
  001c5	e8 00 00 00 00	 call	 PyBytes_FromString

; 3857 : } /* end of posix__getfullpathname */

  001ca	48 81 c4 50 06
	00 00		 add	 rsp, 1616		; 00000650H
  001d1	5f		 pop	 rdi
  001d2	c3		 ret	 0
posix__getfullpathname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@ ; `string'
PUBLIC	??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfinalpathname DD imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix__getfinalpathname DD imagerel posix__getfinalpathname+40
	DD	imagerel posix__getfinalpathname+68
	DD	imagerel $chain$0$posix__getfinalpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix__getfinalpathname DD imagerel posix__getfinalpathname+68
	DD	imagerel posix__getfinalpathname+106
	DD	imagerel $chain$2$posix__getfinalpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix__getfinalpathname DD imagerel posix__getfinalpathname+106
	DD	imagerel posix__getfinalpathname+185
	DD	imagerel $chain$5$posix__getfinalpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$posix__getfinalpathname DD imagerel posix__getfinalpathname+185
	DD	imagerel posix__getfinalpathname+246
	DD	imagerel $chain$8$posix__getfinalpathname
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$posix__getfinalpathname DD imagerel posix__getfinalpathname+246
	DD	imagerel posix__getfinalpathname+385
	DD	imagerel $chain$11$posix__getfinalpathname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$posix__getfinalpathname DD 080721H
	DD	0d6407H
	DD	087400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$posix__getfinalpathname DD 061321H
	DD	087413H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix__getfinalpathname DD 040521H
	DD	0b5405H
	DD	0a3400H
	DD	imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix__getfinalpathname DD 020021H
	DD	0a3400H
	DD	imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix__getfinalpathname DD 020521H
	DD	0a3405H
	DD	imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+40
	DD	imagerel $unwind$posix__getfinalpathname
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfinalpathname DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@
CONST	SEGMENT
??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@ DB 'GetFinalPathNam'
	DB	'eByHandle not available on this platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@
CONST	SEGMENT
??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@ DB 'U|:_getfinalpathname'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix__getfinalpathname
_TEXT	SEGMENT
self$ = 80
args$ = 88
po$ = 96
posix__getfinalpathname PROC				; COMDAT

; 3864 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3865 :     HANDLE hFile;
; 3866 :     int buf_size;
; 3867 :     wchar_t *target_path;
; 3868 :     int result_length;
; 3869 :     PyObject *po, *result;
; 3870 :     wchar_t *path;
; 3871 : 
; 3872 :     if (!PyArg_ParseTuple(args, "U|:_getfinalpathname", &po))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 60	 lea	 r8, QWORD PTR po$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN8@posix__get@2

; 3873 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  0001e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00022	c3		 ret	 0
$LN8@posix__get@2:

; 3874 :     path = PyUnicode_AsUnicode(po);

  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR po$[rsp]
  00028	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0002d	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00032	48 8b d8	 mov	 rbx, rax

; 3875 :     if (path == NULL)

  00035	48 85 c0	 test	 rax, rax
  00038	75 0a		 jne	 SHORT $LN7@posix__get@2
  0003a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  0003f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00043	c3		 ret	 0
$LN7@posix__get@2:

; 3876 :         return NULL;
; 3877 : 
; 3878 :     if(!check_GetFinalPathNameByHandle()) {

  00044	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  00049	85 c0		 test	 eax, eax
  0004b	75 1d		 jne	 SHORT $LN6@posix__get@2

; 3879 :         /* If the OS doesn't have GetFinalPathNameByHandle, return a
; 3880 :            NotImplementedError. */
; 3881 :         return PyErr_Format(PyExc_NotImplementedError,
; 3882 :             "GetFinalPathNameByHandle not available on this platform");

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@
  0005b	e8 00 00 00 00	 call	 PyErr_Format
  00060	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  00065	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00069	c3		 ret	 0
$LN6@posix__get@2:
  0006a	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 3883 :     }
; 3884 : 
; 3885 :     hFile = CreateFileW(
; 3886 :         path,
; 3887 :         0, /* desired access */
; 3888 :         0, /* share mode */
; 3889 :         NULL, /* security attributes */
; 3890 :         OPEN_EXISTING,
; 3891 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 3892 :         FILE_FLAG_BACKUP_SEMANTICS,
; 3893 :         NULL);

  0006f	33 ed		 xor	 ebp, ebp
  00071	45 33 c9	 xor	 r9d, r9d
  00074	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	c7 44 24 28 00
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554432 ; 02000000H
  00089	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  00097	48 8b d8	 mov	 rbx, rax

; 3894 : 
; 3895 :     if(hFile == INVALID_HANDLE_VALUE)

  0009a	48 83 f8 ff	 cmp	 rax, -1
  0009e	75 19		 jne	 SHORT $LN5@posix__get@2

; 3896 :         return win32_error_object("CreateFileW", po);

  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR po$[rsp]
  000a5	e8 00 00 00 00	 call	 win32_error_object
  000aa	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000af	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
$LN5@posix__get@2:

; 3897 : 
; 3898 :     /* We have a good handle to the target, use it to determine the
; 3899 :        target path name. */
; 3900 :     buf_size = Py_GetFinalPathNameByHandleW(hFile, 0, 0, VOLUME_NAME_NT);

  000b9	41 b9 02 00 00
	00		 mov	 r9d, 2
  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	33 d2		 xor	 edx, edx
  000c4	48 8b c8	 mov	 rcx, rax
  000c7	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  000d2	8b f8		 mov	 edi, eax

; 3901 : 
; 3902 :     if(!buf_size)

  000d4	85 c0		 test	 eax, eax
  000d6	75 1e		 jne	 SHORT $LN4@posix__get@2

; 3903 :         return win32_error_object("GetFinalPathNameByHandle", po);

  000d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR po$[rsp]
  000dd	e8 00 00 00 00	 call	 win32_error_object
  000e2	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000e7	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000ec	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  000f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f5	c3		 ret	 0
$LN4@posix__get@2:

; 3904 : 
; 3905 :     target_path = (wchar_t *)malloc((buf_size+1)*sizeof(wchar_t));

  000f6	ff c0		 inc	 eax
  000f8	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  000fd	48 63 c8	 movsxd	 rcx, eax
  00100	48 03 c9	 add	 rcx, rcx
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00109	48 8b f0	 mov	 rsi, rax

; 3906 :     if(!target_path)

  0010c	48 85 c0	 test	 rax, rax
  0010f	75 07		 jne	 SHORT $LN3@posix__get@2

; 3907 :         return PyErr_NoMemory();

  00111	e8 00 00 00 00	 call	 PyErr_NoMemory
  00116	eb 50		 jmp	 SHORT $LN14@posix__get@2
$LN3@posix__get@2:

; 3908 : 
; 3909 :     result_length = Py_GetFinalPathNameByHandleW(hFile, target_path,
; 3910 :                                                  buf_size, VOLUME_NAME_DOS);

  00118	45 33 c9	 xor	 r9d, r9d
  0011b	44 8b c7	 mov	 r8d, edi
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8b cb	 mov	 rcx, rbx
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  0012a	48 63 f8	 movsxd	 rdi, eax

; 3911 :     if(!result_length)

  0012d	85 c0		 test	 eax, eax

; 3912 :         return win32_error_object("GetFinalPathNamyByHandle", po);

  0012f	74 0d		 je	 SHORT $LN15@posix__get@2

; 3913 : 
; 3914 :     if(!CloseHandle(hFile))

  00131	48 8b cb	 mov	 rcx, rbx
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0013a	85 c0		 test	 eax, eax
  0013c	75 0c		 jne	 SHORT $LN1@posix__get@2
$LN15@posix__get@2:

; 3915 :         return win32_error_object("CloseHandle", po);

  0013e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR po$[rsp]
  00143	e8 00 00 00 00	 call	 win32_error_object
  00148	eb 1e		 jmp	 SHORT $LN14@posix__get@2
$LN1@posix__get@2:

; 3916 : 
; 3917 :     target_path[result_length] = 0;

  0014a	48 8b d7	 mov	 rdx, rdi

; 3918 :     result = PyUnicode_FromWideChar(target_path, result_length);

  0014d	48 8b ce	 mov	 rcx, rsi
  00150	66 89 2c 7e	 mov	 WORD PTR [rsi+rdi*2], bp
  00154	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 3919 :     free(target_path);

  00159	48 8b ce	 mov	 rcx, rsi
  0015c	48 8b d8	 mov	 rbx, rax
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3920 :     return result;

  00165	48 8b c3	 mov	 rax, rbx
$LN14@posix__get@2:
  00168	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  0016d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00172	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00177	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  0017c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00180	c3		 ret	 0
posix__getfinalpathname ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GLKMLICL@iii?$AA@			; `string'
PUBLIC	??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@	; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfileinformation DD imagerel posix__getfileinformation
	DD	imagerel posix__getfileinformation+144
	DD	imagerel $unwind$posix__getfileinformation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfileinformation DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT ??_C@_03GLKMLICL@iii?$AA@
CONST	SEGMENT
??_C@_03GLKMLICL@iii?$AA@ DB 'iii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@
CONST	SEGMENT
??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@ DB 'i:_getfileinformation', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix__getfileinformation
_TEXT	SEGMENT
info$ = 32
self$ = 112
args$ = 120
fd$ = 128
posix__getfileinformation PROC				; COMDAT

; 3926 : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3927 :     HANDLE hFile;
; 3928 :     BY_HANDLE_FILE_INFORMATION info;
; 3929 :     int fd;
; 3930 : 
; 3931 :     if (!PyArg_ParseTuple(args, "i:_getfileinformation", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fd$[rsp]
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@
  00016	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001b	85 c0		 test	 eax, eax
  0001d	75 07		 jne	 SHORT $LN4@posix__get@3

; 3932 :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 3947 : }

  00021	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00025	c3		 ret	 0
$LN4@posix__get@3:

; 3933 : 
; 3934 :     if (!_PyVerify_fd(fd))

  00026	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0002d	e8 00 00 00 00	 call	 _PyVerify_fd
  00032	85 c0		 test	 eax, eax
  00034	75 0a		 jne	 SHORT $LN3@posix__get@3
$LN7@posix__get@3:

; 3935 :         return posix_error();

  00036	e8 00 00 00 00	 call	 posix_error

; 3947 : }

  0003b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0003f	c3		 ret	 0
$LN3@posix__get@3:

; 3936 : 
; 3937 :     hFile = (HANDLE)_get_osfhandle(fd);

  00040	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle

; 3938 :     if (hFile == INVALID_HANDLE_VALUE)

  0004d	48 83 f8 ff	 cmp	 rax, -1

; 3939 :         return posix_error();

  00051	74 e3		 je	 SHORT $LN7@posix__get@3

; 3940 : 
; 3941 :     if (!GetFileInformationByHandle(hFile, &info))

  00053	48 8d 54 24 20	 lea	 rdx, QWORD PTR info$[rsp]
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  00061	85 c0		 test	 eax, eax
  00063	75 0c		 jne	 SHORT $LN1@posix__get@3

; 3942 :         return win32_error("_getfileinformation", NULL);

  00065	33 c9		 xor	 ecx, ecx
  00067	e8 00 00 00 00	 call	 win32_error

; 3947 : }

  0006c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00070	c3		 ret	 0
$LN1@posix__get@3:

; 3943 : 
; 3944 :     return Py_BuildValue("iii", info.dwVolumeSerialNumber,
; 3945 :                                 info.nFileIndexHigh,
; 3946 :                                 info.nFileIndexLow);

  00071	44 8b 4c 24 50	 mov	 r9d, DWORD PTR info$[rsp+48]
  00076	44 8b 44 24 4c	 mov	 r8d, DWORD PTR info$[rsp+44]
  0007b	8b 54 24 3c	 mov	 edx, DWORD PTR info$[rsp+28]
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  00086	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 3947 : }

  0008b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0008f	c3		 ret	 0
posix__getfileinformation ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PLKEAHDG@y?3_isdir?$AA@			; `string'
PUBLIC	??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@		; `string'
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix__isdir DD imagerel posix__isdir
	DD	imagerel posix__isdir+333
	DD	imagerel $unwind$posix__isdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__isdir DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_08PLKEAHDG@y?3_isdir?$AA@
CONST	SEGMENT
??_C@_08PLKEAHDG@y?3_isdir?$AA@ DB 'y:_isdir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@
CONST	SEGMENT
??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@ DB 'U|:_isdir', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix__isdir
_TEXT	SEGMENT
self$ = 64
args$ = 72
po$ = 80
path$ = 88
posix__isdir PROC					; COMDAT

; 3954 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b da	 mov	 rbx, rdx

; 3955 :     const char *path;
; 3956 :     PyObject *po;
; 3957 :     DWORD attributes;
; 3958 : 
; 3959 :     if (PyArg_ParseTuple(args, "U|:_isdir", &po)) {

  00009	4c 8d 44 24 50	 lea	 r8, QWORD PTR po$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@
  00015	48 8b cb	 mov	 rcx, rbx
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	74 7b		 je	 SHORT $LN8@posix__isd

; 3960 :         wchar_t *wpath = PyUnicode_AsUnicode(po);

  00021	48 8b 4c 24 50	 mov	 rcx, QWORD PTR po$[rsp]
  00026	e8 00 00 00 00	 call	 PyUnicode_AsUnicode

; 3961 :         if (wpath == NULL)

  0002b	48 85 c0	 test	 rax, rax
  0002e	75 08		 jne	 SHORT $LN7@posix__isd
$LN26@posix__isd:

; 3962 :             return NULL;

  00030	33 c0		 xor	 eax, eax

; 3986 : }

  00032	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
$LN7@posix__isd:

; 3963 : 
; 3964 :         attributes = GetFileAttributesW(wpath);

  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW

; 3965 :         if (attributes == INVALID_FILE_ATTRIBUTES)

  00041	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00044	0f 85 a9 00 00
	00		 jne	 $check$122337
$LN2@posix__isd:

; 3984 :     else
; 3985 :         Py_RETURN_FALSE;

  0004a	e8 00 00 00 00	 call	 _Py_PXCTX
  0004f	85 c0		 test	 eax, eax
  00051	75 3c		 jne	 SHORT $LN20@posix__isd
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00068	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00076	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007b	85 c0		 test	 eax, eax
  0007d	75 09		 jne	 SHORT $LN19@posix__isd
  0007f	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00086	74 07		 je	 SHORT $LN20@posix__isd
$LN19@posix__isd:
  00088	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN20@posix__isd:
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 3986 : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
$LN8@posix__isd:

; 3966 :             Py_RETURN_FALSE;
; 3967 :         goto check;
; 3968 :     }
; 3969 :     /* Drop the argument parsing error as narrow strings
; 3970 :        are also valid. */
; 3971 :     PyErr_Clear();

  0009c	e8 00 00 00 00	 call	 PyErr_Clear

; 3972 : 
; 3973 :     if (!PyArg_ParseTuple(args, "y:_isdir", &path))

  000a1	4c 8d 44 24 58	 lea	 r8, QWORD PTR path$[rsp]
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PLKEAHDG@y?3_isdir?$AA@
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000b5	85 c0		 test	 eax, eax

; 3974 :         return NULL;

  000b7	0f 84 73 ff ff
	ff		 je	 $LN26@posix__isd

; 3975 :     if (win32_warn_bytes_api())

  000bd	e8 00 00 00 00	 call	 win32_warn_bytes_api
  000c2	85 c0		 test	 eax, eax

; 3976 :         return NULL;

  000c4	0f 85 66 ff ff
	ff		 jne	 $LN26@posix__isd

; 3977 :     attributes = GetFileAttributesA(path);

  000ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA

; 3978 :     if (attributes == INVALID_FILE_ATTRIBUTES)

  000d5	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  000d8	75 19		 jne	 SHORT $check$122337

; 3979 :         Py_RETURN_FALSE;

  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000e1	e8 00 00 00 00	 call	 _Py_IncRef

; 3984 :     else
; 3985 :         Py_RETURN_FALSE;

  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 3986 : }

  000ed	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f1	5b		 pop	 rbx
  000f2	c3		 ret	 0
$check$122337:

; 3980 : 
; 3981 : check:
; 3982 :     if (attributes & FILE_ATTRIBUTE_DIRECTORY)

  000f3	a8 10		 test	 al, 16
  000f5	0f 84 4f ff ff
	ff		 je	 $LN2@posix__isd

; 3983 :         Py_RETURN_TRUE;

  000fb	e8 00 00 00 00	 call	 _Py_PXCTX
  00100	85 c0		 test	 eax, eax
  00102	75 3c		 jne	 SHORT $LN16@posix__isd
  00104	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00119	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0011f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00127	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012c	85 c0		 test	 eax, eax
  0012e	75 09		 jne	 SHORT $LN15@posix__isd
  00130	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00137	74 07		 je	 SHORT $LN16@posix__isd
$LN15@posix__isd:
  00139	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN16@posix__isd:
  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 3986 : }

  00147	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014b	5b		 pop	 rbx
  0014c	c3		 ret	 0
posix__isdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@	; `string'
EXTRN	__imp_CreateDirectoryA:PROC
EXTRN	__imp_CreateDirectoryW:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_mkdir DD imagerel posix_mkdir
	DD	imagerel posix_mkdir+166
	DD	imagerel $unwind$posix_mkdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_mkdir DD imagerel posix_mkdir+166
	DD	imagerel posix_mkdir+238
	DD	imagerel $chain$1$posix_mkdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_mkdir DD imagerel posix_mkdir+238
	DD	imagerel posix_mkdir+357
	DD	imagerel $chain$2$posix_mkdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_mkdir DD 021H
	DD	imagerel posix_mkdir
	DD	imagerel posix_mkdir+166
	DD	imagerel $unwind$posix_mkdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_mkdir DD 020821H
	DD	0167408H
	DD	imagerel posix_mkdir
	DD	imagerel posix_mkdir+166
	DD	imagerel $unwind$posix_mkdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_mkdir DD 04a601H
	DD	01834a6H
	DD	017010aH
xdata	ENDS
;	COMDAT ??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@
CONST	SEGMENT
??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@ DB 'O&|i$O&:mkdir', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_mkdir
_TEXT	SEGMENT
mode$ = 80
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
posix_mkdir PROC					; COMDAT

; 4002 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 4003 :     path_t path;
; 4004 :     int mode = 0777;
; 4005 :     int dir_fd = DEFAULT_DIR_FD;
; 4006 :     static char *keywords[] = {"path", "mode", "dir_fd", NULL};
; 4007 :     PyObject *return_value = NULL;
; 4008 :     int result;
; 4009 : 
; 4010 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 4011 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|i$O&:mkdir", keywords,
; 4012 :         path_converter, &path, &mode,
; 4013 : #ifdef HAVE_MKDIRAT
; 4014 :         dir_fd_converter, &dir_fd
; 4015 : #else
; 4016 :         dir_fd_unavailable, &dir_fd
; 4017 : #endif
; 4018 :         ))

  00036	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_mkdir@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@
  00048	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  0005a	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  0005e	c7 44 24 50 ff
	01 00 00	 mov	 DWORD PTR mode$[rsp], 511 ; 000001ffH
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0006f	41 c7 43 20 9c
	ff ff ff	 mov	 DWORD PTR [r11+32], -100 ; ffffffffffffff9cH
  00077	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00083	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00088	49 8b ca	 mov	 rcx, r10
  0008b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00090	85 c0		 test	 eax, eax
  00092	75 0a		 jne	 SHORT $LN4@posix_mkdi

; 4019 :         return NULL;

  00094	33 c0		 xor	 eax, eax

; 4056 : }

  00096	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0009d	c3		 ret	 0
$LN4@posix_mkdi:
  0009e	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  000a6	48 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rdi

; 4020 : 
; 4021 : #ifdef MS_WINDOWS
; 4022 :     Py_BEGIN_ALLOW_THREADS

  000ae	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4023 :     if (path.wide)

  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR path$[rsp+24]

; 4024 :         result = CreateDirectoryW(path.wide, NULL);

  000b8	33 d2		 xor	 edx, edx
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	48 85 c9	 test	 rcx, rcx
  000c0	74 08		 je	 SHORT $LN3@posix_mkdi
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryW

; 4025 :     else

  000c8	eb 0e		 jmp	 SHORT $LN11@posix_mkdi
$LN3@posix_mkdi:

; 4026 :         result = CreateDirectoryA(path.narrow, NULL);

  000ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
$LN11@posix_mkdi:

; 4027 :     Py_END_ALLOW_THREADS

  000d8	48 8b cf	 mov	 rcx, rdi
  000db	8b d8		 mov	 ebx, eax
  000dd	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000e2	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+176]

; 4028 : 
; 4029 :     if (!result) {

  000ea	85 db		 test	 ebx, ebx
  000ec	75 12		 jne	 SHORT $LN1@posix_mkdi

; 4030 :         return_value = win32_error_object("mkdir", path.object);

  000ee	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+56]
  000f6	e8 00 00 00 00	 call	 win32_error_object
  000fb	48 8b d8	 mov	 rbx, rax

; 4031 :         goto exit;

  000fe	eb 48		 jmp	 SHORT $exit$122384
$LN1@posix_mkdi:

; 4032 :     }
; 4033 : #else
; 4034 :     Py_BEGIN_ALLOW_THREADS
; 4035 : #if HAVE_MKDIRAT
; 4036 :     if (dir_fd != DEFAULT_DIR_FD)
; 4037 :         result = mkdirat(dir_fd, path.narrow, mode);
; 4038 :     else
; 4039 : #endif
; 4040 : #if ( defined(__WATCOMC__) || defined(PYCC_VACPP) ) && !defined(__QNX__)
; 4041 :         result = mkdir(path.narrow);
; 4042 : #else
; 4043 :         result = mkdir(path.narrow, mode);
; 4044 : #endif
; 4045 :     Py_END_ALLOW_THREADS
; 4046 :     if (result < 0) {
; 4047 :         return_value = path_error("mkdir", &path);
; 4048 :         goto exit;
; 4049 :     }
; 4050 : #endif
; 4051 :     return_value = Py_None;

  00100	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 4052 :     Py_INCREF(Py_None);

  00107	e8 00 00 00 00	 call	 _Py_PXCTX
  0010c	85 c0		 test	 eax, eax
  0010e	75 38		 jne	 SHORT $exit$122384
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0011e	4c 8b cb	 mov	 r9, rbx
  00121	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00127	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0012f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00134	85 c0		 test	 eax, eax
  00136	75 09		 jne	 SHORT $LN7@posix_mkdi
  00138	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0013f	74 07		 je	 SHORT $exit$122384
$LN7@posix_mkdi:
  00141	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$exit$122384:

; 4053 : exit:
; 4054 :     path_cleanup(&path);

  00148	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  0014d	e8 00 00 00 00	 call	 path_cleanup

; 4055 :     return return_value;

  00152	48 8b c3	 mov	 rax, rbx
  00155	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]

; 4056 : }

  0015d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00164	c3		 ret	 0
posix_mkdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@ ; `string'
PUBLIC	??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@ ; `string'
EXTRN	__imp_MoveFileExA:PROC
EXTRN	__imp_MoveFileExW:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$internal_rename DD imagerel internal_rename
	DD	imagerel internal_rename+590
	DD	imagerel $unwind$internal_rename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_rename DD 091a01H
	DD	029641aH
	DD	028341aH
	DD	024011aH
	DD	0700cc00eH
	DD	0500bH
xdata	ENDS
;	COMDAT ??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@
CONST	SEGMENT
??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@ DB '%s: s'
	DB	'rc and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@
CONST	SEGMENT
??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@ DB 'O&O&|$O&O&:', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT internal_rename
_TEXT	SEGMENT
dst$ = 96
src$ = 176
format$ = 256
args$ = 320
kwargs$ = 328
src_dir_fd$ = 336
is_replace$ = 336
dst_dir_fd$ = 344
internal_rename PROC					; COMDAT

; 4145 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 8d 6c 24 e0	 lea	 rbp, QWORD PTR [rsp-32]
  00013	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H

; 4146 :     char *function_name = is_replace ? "replace" : "rename";

  0001a	45 85 c0	 test	 r8d, r8d
  0001d	4c 8b d1	 mov	 r10, rcx
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  00027	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_06LMEAOBLB@rename?$AA@

; 4147 :     path_t src;
; 4148 :     path_t dst;
; 4149 :     int src_dir_fd = DEFAULT_DIR_FD;
; 4150 :     int dst_dir_fd = DEFAULT_DIR_FD;
; 4151 :     int dir_fd_specified;
; 4152 :     PyObject *return_value = NULL;
; 4153 :     char format[24];
; 4154 :     static char *keywords[] = {"src", "dst", "src_dir_fd", "dst_dir_fd", NULL};
; 4155 : 
; 4156 : #ifdef MS_WINDOWS
; 4157 :     BOOL result;
; 4158 :     int flags = is_replace ? MOVEFILE_REPLACE_EXISTING : 0;
; 4159 : #else
; 4160 :     int result;
; 4161 : #endif
; 4162 : 
; 4163 :     memset(&src, 0, sizeof(src));
; 4164 :     memset(&dst, 0, sizeof(dst));
; 4165 :     strcpy(format, "O&O&|$O&O&:");
; 4166 :     strcat(format, function_name);

  0002e	48 8d 7d 00	 lea	 rdi, QWORD PTR format$[rbp-256]
  00032	c7 45 50 9c ff
	ff ff		 mov	 DWORD PTR src_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  00039	48 0f 45 d8	 cmovne	 rbx, rax
  0003d	33 f6		 xor	 esi, esi
  0003f	45 85 c0	 test	 r8d, r8d
  00042	44 8b e6	 mov	 r12d, esi
  00045	41 0f 95 c4	 setne	 r12b
  00049	33 c0		 xor	 eax, eax
  0004b	48 89 45 b0	 mov	 QWORD PTR src$[rbp-256], rax
  0004f	48 89 45 b8	 mov	 QWORD PTR src$[rbp-248], rax
  00053	48 89 45 c0	 mov	 QWORD PTR src$[rbp-240], rax
  00057	48 89 45 c8	 mov	 QWORD PTR src$[rbp-232], rax
  0005b	48 89 45 d0	 mov	 QWORD PTR src$[rbp-224], rax
  0005f	48 89 45 d8	 mov	 QWORD PTR src$[rbp-216], rax
  00063	48 89 45 e0	 mov	 QWORD PTR src$[rbp-208], rax
  00067	48 89 45 e8	 mov	 QWORD PTR src$[rbp-200], rax
  0006b	48 89 45 f0	 mov	 QWORD PTR src$[rbp-192], rax
  0006f	48 89 44 24 60	 mov	 QWORD PTR dst$[rsp], rax
  00074	48 89 44 24 68	 mov	 QWORD PTR dst$[rsp+8], rax
  00079	48 89 44 24 70	 mov	 QWORD PTR dst$[rsp+16], rax
  0007e	48 89 44 24 78	 mov	 QWORD PTR dst$[rsp+24], rax
  00083	48 89 45 80	 mov	 QWORD PTR dst$[rbp-224], rax
  00087	48 89 45 88	 mov	 QWORD PTR dst$[rbp-216], rax
  0008b	48 89 45 90	 mov	 QWORD PTR dst$[rbp-208], rax
  0008f	48 89 45 98	 mov	 QWORD PTR dst$[rbp-200], rax
  00093	48 89 45 a0	 mov	 QWORD PTR dst$[rbp-192], rax
  00097	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@
  0009e	48 83 c9 ff	 or	 rcx, -1
  000a2	c7 45 58 9c ff
	ff ff		 mov	 DWORD PTR dst_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  000a9	48 89 45 00	 mov	 QWORD PTR format$[rbp-256], rax
  000ad	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR ??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@+8
  000b3	89 45 08	 mov	 DWORD PTR format$[rbp-248], eax
  000b6	33 c0		 xor	 eax, eax
  000b8	f2 ae		 repne scasb
  000ba	33 c9		 xor	 ecx, ecx
  000bc	0f 1f 40 00	 npad	 4
$LL18@internal_r:
  000c0	0f b6 04 0b	 movzx	 eax, BYTE PTR [rbx+rcx]
  000c4	48 ff c1	 inc	 rcx
  000c7	88 44 0f fe	 mov	 BYTE PTR [rdi+rcx-2], al
  000cb	84 c0		 test	 al, al
  000cd	75 f1		 jne	 SHORT $LL18@internal_r

; 4167 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, format, keywords,
; 4168 :         path_converter, &src,
; 4169 :         path_converter, &dst,
; 4170 :         dir_fd_converter, &src_dir_fd,
; 4171 :         dir_fd_converter, &dst_dir_fd))

  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_converter
  000d6	48 8d 45 58	 lea	 rax, QWORD PTR dst_dir_fd$[rbp-256]
  000da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??internal_rename@@9@9
  000e1	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000e6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000eb	48 8d 45 50	 lea	 rax, QWORD PTR src_dir_fd$[rbp-256]
  000ef	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000f4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00100	48 8d 44 24 60	 lea	 rax, QWORD PTR dst$[rsp]
  00105	4c 8d 45 00	 lea	 r8, QWORD PTR format$[rbp-256]
  00109	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0010e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00113	48 8d 45 b0	 lea	 rax, QWORD PTR src$[rbp-256]
  00117	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00121	49 8b ca	 mov	 rcx, r10
  00124	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00129	85 c0		 test	 eax, eax
  0012b	75 07		 jne	 SHORT $LN8@internal_r

; 4172 :         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 02 01 00 00	 jmp	 $LN9@internal_r
$LN8@internal_r:

; 4173 : 
; 4174 :     dir_fd_specified = (src_dir_fd != DEFAULT_DIR_FD) ||
; 4175 :                        (dst_dir_fd != DEFAULT_DIR_FD);

  00134	83 7d 50 9c	 cmp	 DWORD PTR src_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  00138	0f 85 d3 00 00
	00		 jne	 $LN11@internal_r
  0013e	83 7d 58 9c	 cmp	 DWORD PTR dst_dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  00142	0f 85 c9 00 00
	00		 jne	 $LN11@internal_r

; 4179 :         goto exit;
; 4180 :     }
; 4181 : #endif
; 4182 : 
; 4183 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  00148	48 39 75 d0	 cmp	 QWORD PTR src$[rbp-224], rsi
  0014c	74 07		 je	 SHORT $LN4@internal_r
  0014e	48 39 74 24 78	 cmp	 QWORD PTR dst$[rsp+24], rsi
  00153	75 0c		 jne	 SHORT $LN5@internal_r
$LN4@internal_r:
  00155	48 39 75 c8	 cmp	 QWORD PTR src$[rbp-232], rsi
  00159	74 21		 je	 SHORT $LN6@internal_r
  0015b	48 39 75 80	 cmp	 QWORD PTR dst$[rbp-224], rsi
  0015f	74 1b		 je	 SHORT $LN6@internal_r
$LN5@internal_r:

; 4184 :         PyErr_Format(PyExc_ValueError,
; 4185 :                      "%s: src and dst must be the same type", function_name);

  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@
  0016f	4c 8b c3	 mov	 r8, rbx
  00172	e8 00 00 00 00	 call	 PyErr_Format

; 4186 :         goto exit;

  00177	e9 a4 00 00 00	 jmp	 $exit$122414
$LN6@internal_r:

; 4187 :     }
; 4188 : 
; 4189 : #ifdef MS_WINDOWS
; 4190 :     Py_BEGIN_ALLOW_THREADS

  0017c	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4191 :     if (src.wide)

  00181	48 8b 4d c8	 mov	 rcx, QWORD PTR src$[rbp-232]

; 4192 :         result = MoveFileExW(src.wide, dst.wide, flags);

  00185	45 8b c4	 mov	 r8d, r12d
  00188	48 8b d8	 mov	 rbx, rax
  0018b	48 85 c9	 test	 rcx, rcx
  0018e	74 0d		 je	 SHORT $LN3@internal_r
  00190	48 8b 54 24 78	 mov	 rdx, QWORD PTR dst$[rsp+24]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MoveFileExW

; 4193 :     else

  0019b	eb 0e		 jmp	 SHORT $LN19@internal_r
$LN3@internal_r:

; 4194 :         result = MoveFileExA(src.narrow, dst.narrow, flags);

  0019d	48 8b 55 80	 mov	 rdx, QWORD PTR dst$[rbp-224]
  001a1	48 8b 4d d0	 mov	 rcx, QWORD PTR src$[rbp-224]
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MoveFileExA
$LN19@internal_r:

; 4195 :     Py_END_ALLOW_THREADS

  001ab	48 8b cb	 mov	 rcx, rbx
  001ae	8b f8		 mov	 edi, eax
  001b0	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4196 : 
; 4197 :     if (!result) {

  001b5	85 ff		 test	 edi, edi
  001b7	75 0e		 jne	 SHORT $LN1@internal_r

; 4198 :         return_value = win32_error_object(function_name, dst.object);

  001b9	48 8b 4d 98	 mov	 rcx, QWORD PTR dst$[rbp-200]
  001bd	e8 00 00 00 00	 call	 win32_error_object
  001c2	48 8b f0	 mov	 rsi, rax

; 4199 :         goto exit;

  001c5	eb 59		 jmp	 SHORT $exit$122414
$LN1@internal_r:

; 4200 :     }
; 4201 : 
; 4202 : #else
; 4203 :     Py_BEGIN_ALLOW_THREADS
; 4204 : #ifdef HAVE_RENAMEAT
; 4205 :     if (dir_fd_specified)
; 4206 :         result = renameat(src_dir_fd, src.narrow, dst_dir_fd, dst.narrow);
; 4207 :     else
; 4208 : #endif
; 4209 :         result = rename(src.narrow, dst.narrow);
; 4210 :     Py_END_ALLOW_THREADS
; 4211 : 
; 4212 :     if (result) {
; 4213 :         return_value = path_error(function_name, &dst);
; 4214 :         goto exit;
; 4215 :     }
; 4216 : #endif
; 4217 : 
; 4218 :     Py_INCREF(Py_None);

  001c7	e8 00 00 00 00	 call	 _Py_PXCTX
  001cc	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  001d3	85 c0		 test	 eax, eax
  001d5	75 49		 jne	 SHORT $exit$122414
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001e5	4c 8b ce	 mov	 r9, rsi
  001e8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001ee	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fb	85 c0		 test	 eax, eax
  001fd	75 09		 jne	 SHORT $LN13@internal_r
  001ff	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00206	74 18		 je	 SHORT $exit$122414
$LN13@internal_r:
  00208	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80

; 4219 :     return_value = Py_None;

  0020f	eb 0f		 jmp	 SHORT $exit$122414
$LN11@internal_r:

; 4176 : #ifndef HAVE_RENAMEAT
; 4177 :     if (dir_fd_specified) {
; 4178 :         argument_unavailable_error(function_name, "src_dir_fd and dst_dir_fd");

  00211	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
  00218	48 8b cb	 mov	 rcx, rbx
  0021b	e8 00 00 00 00	 call	 argument_unavailable_error
$exit$122414:

; 4220 : exit:
; 4221 :     path_cleanup(&src);

  00220	48 8d 4d b0	 lea	 rcx, QWORD PTR src$[rbp-256]
  00224	e8 00 00 00 00	 call	 path_cleanup

; 4222 :     path_cleanup(&dst);

  00229	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dst$[rsp]
  0022e	e8 00 00 00 00	 call	 path_cleanup

; 4223 :     return return_value;

  00233	48 8b c6	 mov	 rax, rsi
$LN9@internal_r:

; 4224 : }

  00236	4c 8d 9c 24 20
	01 00 00	 lea	 r11, QWORD PTR [rsp+288]
  0023e	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00242	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00246	49 8b e3	 mov	 rsp, r11
  00249	41 5c		 pop	 r12
  0024b	5f		 pop	 rdi
  0024c	5d		 pop	 rbp
  0024d	c3		 ret	 0
internal_rename ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT posix_rename
_TEXT	SEGMENT
self$ = 8
args$ = 16
kwargs$ = 24
posix_rename PROC					; COMDAT

; 4238 : {

  00000	49 8b c0	 mov	 rax, r8

; 4239 :     return internal_rename(args, kwargs, 0);

  00003	48 8b ca	 mov	 rcx, rdx
  00006	45 33 c0	 xor	 r8d, r8d
  00009	48 8b d0	 mov	 rdx, rax

; 4240 : }

  0000c	e9 00 00 00 00	 jmp	 internal_rename
posix_rename ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT posix_replace
_TEXT	SEGMENT
self$ = 8
args$ = 16
kwargs$ = 24
posix_replace PROC					; COMDAT

; 4254 : {

  00000	49 8b c0	 mov	 rax, r8

; 4255 :     return internal_rename(args, kwargs, 1);

  00003	48 8b ca	 mov	 rcx, rdx
  00006	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000c	48 8b d0	 mov	 rdx, rax

; 4256 : }

  0000f	e9 00 00 00 00	 jmp	 internal_rename
posix_replace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@	; `string'
EXTRN	__imp_RemoveDirectoryA:PROC
EXTRN	__imp_RemoveDirectoryW:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_rmdir DD imagerel posix_rmdir
	DD	imagerel posix_rmdir+147
	DD	imagerel $unwind$posix_rmdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_rmdir DD imagerel posix_rmdir+147
	DD	imagerel posix_rmdir+214
	DD	imagerel $chain$1$posix_rmdir
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_rmdir DD imagerel posix_rmdir+214
	DD	imagerel posix_rmdir+330
	DD	imagerel $chain$2$posix_rmdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_rmdir DD 021H
	DD	imagerel posix_rmdir
	DD	imagerel posix_rmdir+147
	DD	imagerel $unwind$posix_rmdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_rmdir DD 020821H
	DD	0127408H
	DD	imagerel posix_rmdir
	DD	imagerel posix_rmdir+147
	DD	imagerel $unwind$posix_rmdir
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_rmdir DD 049301H
	DD	0143493H
	DD	013010aH
xdata	ENDS
;	COMDAT ??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@
CONST	SEGMENT
??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@ DB 'O&|$O&:rmdir', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_rmdir
_TEXT	SEGMENT
path$ = 64
self$ = 160
args$ = 168
kwargs$ = 176
posix_rmdir PROC					; COMDAT

; 4269 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4270 :     path_t path;
; 4271 :     int dir_fd = DEFAULT_DIR_FD;
; 4272 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 4273 :     int result;
; 4274 :     PyObject *return_value = NULL;
; 4275 : 
; 4276 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 4277 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:rmdir", keywords,
; 4278 :             path_converter, &path,
; 4279 : #ifdef HAVE_UNLINKAT
; 4280 :             dir_fd_converter, &dir_fd
; 4281 : #else
; 4282 :             dir_fd_unavailable, &dir_fd
; 4283 : #endif
; 4284 :             ))

  00036	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_rmdir@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@
  00048	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0005a	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0005e	41 c7 43 20 9c
	ff ff ff	 mov	 DWORD PTR [r11+32], -100 ; ffffffffffffff9cH
  00066	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00071	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00075	49 8b ca	 mov	 rcx, r10
  00078	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007d	85 c0		 test	 eax, eax
  0007f	75 0a		 jne	 SHORT $LN4@posix_rmdi

; 4285 :         return NULL;

  00081	33 c0		 xor	 eax, eax

; 4315 : }

  00083	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0008a	c3		 ret	 0
$LN4@posix_rmdi:
  0008b	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  00093	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi

; 4286 : 
; 4287 :     Py_BEGIN_ALLOW_THREADS

  0009b	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4288 : #ifdef MS_WINDOWS
; 4289 :     if (path.wide)

  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp+24]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	48 85 c9	 test	 rcx, rcx
  000ab	74 08		 je	 SHORT $LN3@posix_rmdi

; 4290 :         result = RemoveDirectoryW(path.wide);

  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryW

; 4291 :     else

  000b3	eb 0b		 jmp	 SHORT $LN11@posix_rmdi
$LN3@posix_rmdi:

; 4292 :         result = RemoveDirectoryA(path.narrow);

  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp+32]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryA
$LN11@posix_rmdi:

; 4293 :     result = !result; /* Windows, success=1, UNIX, success=0 */
; 4294 : #else
; 4295 : #ifdef HAVE_UNLINKAT
; 4296 :     if (dir_fd != DEFAULT_DIR_FD)
; 4297 :         result = unlinkat(dir_fd, path.narrow, AT_REMOVEDIR);
; 4298 :     else
; 4299 : #endif
; 4300 :         result = rmdir(path.narrow);
; 4301 : #endif
; 4302 :     Py_END_ALLOW_THREADS

  000c0	48 8b cf	 mov	 rcx, rdi
  000c3	8b d8		 mov	 ebx, eax
  000c5	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000ca	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]
  000d2	85 db		 test	 ebx, ebx

; 4303 : 
; 4304 :     if (result) {

  000d4	75 0f		 jne	 SHORT $LN1@posix_rmdi

; 4305 :         return_value = path_error("rmdir", &path);

  000d6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  000db	e8 00 00 00 00	 call	 path_error
  000e0	48 8b d8	 mov	 rbx, rax

; 4306 :         goto exit;

  000e3	eb 48		 jmp	 SHORT $exit$122467
$LN1@posix_rmdi:

; 4307 :     }
; 4308 : 
; 4309 :     return_value = Py_None;

  000e5	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 4310 :     Py_INCREF(Py_None);

  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 38		 jne	 SHORT $exit$122467
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00103	4c 8b cb	 mov	 r9, rbx
  00106	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00114	e8 00 00 00 00	 call	 _PyParallel_Guard
  00119	85 c0		 test	 eax, eax
  0011b	75 09		 jne	 SHORT $LN7@posix_rmdi
  0011d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00124	74 07		 je	 SHORT $exit$122467
$LN7@posix_rmdi:
  00126	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$exit$122467:

; 4311 : 
; 4312 : exit:
; 4313 :     path_cleanup(&path);

  0012d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  00132	e8 00 00 00 00	 call	 path_cleanup

; 4314 :     return return_value;

  00137	48 8b c3	 mov	 rax, rbx
  0013a	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]

; 4315 : }

  00142	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00149	c3		 ret	 0
posix_rmdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ICACAFDE@u?3system?$AA@			; `string'
EXTRN	__imp__wsystem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_system DD imagerel posix_system
	DD	imagerel posix_system+96
	DD	imagerel $unwind$posix_system
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_system DD 052d01H
	DD	04742dH
	DD	063428H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_08ICACAFDE@u?3system?$AA@
CONST	SEGMENT
??_C@_08ICACAFDE@u?3system?$AA@ DB 'u:system', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_system
_TEXT	SEGMENT
self$ = 48
args$ = 56
command$ = 64
posix_system PROC					; COMDAT

; 4325 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4326 :     long sts;
; 4327 : #ifdef MS_WINDOWS
; 4328 :     wchar_t *command;
; 4329 :     if (!PyArg_ParseTuple(args, "u:system", &command))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR command$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ICACAFDE@u?3system?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@posix_syst

; 4330 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 4349 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN1@posix_syst:
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 4331 : 
; 4332 :     Py_BEGIN_ALLOW_THREADS

  0002d	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4333 :     sts = _wsystem(command);

  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR command$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wsystem

; 4334 :     Py_END_ALLOW_THREADS

  00040	48 8b cf	 mov	 rcx, rdi
  00043	8b d8		 mov	 ebx, eax
  00045	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4335 : #else
; 4336 :     PyObject *command_obj;
; 4337 :     char *command;
; 4338 :     if (!PyArg_ParseTuple(args, "O&:system",
; 4339 :                           PyUnicode_FSConverter, &command_obj))
; 4340 :         return NULL;
; 4341 : 
; 4342 :     command = PyBytes_AsString(command_obj);
; 4343 :     Py_BEGIN_ALLOW_THREADS
; 4344 :     sts = system(command);
; 4345 :     Py_END_ALLOW_THREADS
; 4346 :     Py_DECREF(command_obj);
; 4347 : #endif
; 4348 :     return PyLong_FromLong(sts);

  0004a	8b cb		 mov	 ecx, ebx
  0004c	e8 00 00 00 00	 call	 PyLong_FromLong
  00051	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00056	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4349 : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
posix_system ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DAADLKJH@i?3umask?$AA@			; `string'
EXTRN	__imp_umask:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_umask DD imagerel posix_umask
	DD	imagerel posix_umask+75
	DD	imagerel $unwind$posix_umask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_umask DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07DAADLKJH@i?3umask?$AA@
CONST	SEGMENT
??_C@_07DAADLKJH@i?3umask?$AA@ DB 'i:umask', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_umask
_TEXT	SEGMENT
self$ = 48
args$ = 56
i$ = 64
posix_umask PROC					; COMDAT

; 4359 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4360 :     int i;
; 4361 :     if (!PyArg_ParseTuple(args, "i:umask", &i))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR i$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DAADLKJH@i?3umask?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@posix_umas

; 4362 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 4367 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN2@posix_umas:

; 4363 :     i = (int)umask(i);

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_umask
  0002d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 4364 :     if (i < 0)

  00031	85 c0		 test	 eax, eax
  00033	79 0a		 jns	 SHORT $LN1@posix_umas

; 4365 :         return posix_error();

  00035	e8 00 00 00 00	 call	 posix_error

; 4367 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
$LN1@posix_umas:

; 4366 :     return PyLong_FromLong((long)i);

  0003f	8b c8		 mov	 ecx, eax
  00041	e8 00 00 00 00	 call	 PyLong_FromLong

; 4367 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
posix_umask ENDP
_TEXT	ENDS
PUBLIC	Py_DeleteFileW
EXTRN	__imp_DeleteFileW:PROC
EXTRN	__imp_GetFileAttributesExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_DeleteFileW DD imagerel $LN7
	DD	imagerel $LN7+66
	DD	imagerel $unwind$Py_DeleteFileW
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Py_DeleteFileW DD imagerel $LN7+66
	DD	imagerel $LN7+108
	DD	imagerel $chain$0$Py_DeleteFileW
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Py_DeleteFileW DD imagerel $LN7+108
	DD	imagerel $LN7+144
	DD	imagerel $chain$1$Py_DeleteFileW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Py_DeleteFileW DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+66
	DD	imagerel $unwind$Py_DeleteFileW
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Py_DeleteFileW DD 020821H
	DD	0563408H
	DD	imagerel $LN7
	DD	imagerel $LN7+66
	DD	imagerel $unwind$Py_DeleteFileW
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_DeleteFileW DD 030901H
	DD	0540109H
	DD	07002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_DeleteFileW
_TEXT	SEGMENT
info$ = 32
find_data$ = 80
lpFileName$ = 688
Py_DeleteFileW PROC					; COMDAT

; 4375 : {

$LN7:
  00000	40 57		 push	 rdi
  00002	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H

; 4376 :     WIN32_FILE_ATTRIBUTE_DATA info;
; 4377 :     WIN32_FIND_DATAW find_data;
; 4378 :     HANDLE find_data_handle;
; 4379 :     int is_directory = 0;
; 4380 :     int is_link = 0;
; 4381 : 
; 4382 :     if (GetFileAttributesExW(lpFileName, GetFileExInfoStandard, &info)) {

  00009	4c 8d 44 24 20	 lea	 r8, QWORD PTR info$[rsp]
  0000e	33 d2		 xor	 edx, edx
  00010	48 8b f9	 mov	 rdi, rcx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExW
  00019	85 c0		 test	 eax, eax
  0001b	74 61		 je	 SHORT $LN1@Py_DeleteF

; 4383 :         is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;

  0001d	8b 54 24 20	 mov	 edx, DWORD PTR info$[rsp]
  00021	8b c2		 mov	 eax, edx
  00023	83 e0 10	 and	 eax, 16

; 4384 : 
; 4385 :         /* Get WIN32_FIND_DATA structure for the path to determine if
; 4386 :            it is a symlink */
; 4387 :         if(is_directory &&
; 4388 :            info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  00026	74 56		 je	 SHORT $LN1@Py_DeleteF
  00028	0f ba e2 0a	 bt	 edx, 10
  0002c	73 50		 jae	 SHORT $LN1@Py_DeleteF

; 4389 :             find_data_handle = FindFirstFileW(lpFileName, &find_data);

  0002e	48 8d 54 24 50	 lea	 rdx, QWORD PTR find_data$[rsp]
  00033	48 8b cf	 mov	 rcx, rdi
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW

; 4390 : 
; 4391 :             if(find_data_handle != INVALID_HANDLE_VALUE) {

  0003c	48 83 f8 ff	 cmp	 rax, -1
  00040	74 3c		 je	 SHORT $LN1@Py_DeleteF

; 4392 :                 is_link = find_data.dwReserved0 == IO_REPARSE_TAG_SYMLINK;

  00042	48 89 9c 24 b0
	02 00 00	 mov	 QWORD PTR [rsp+688], rbx
  0004a	33 db		 xor	 ebx, ebx
  0004c	81 7c 24 74 0c
	00 00 a0	 cmp	 DWORD PTR find_data$[rsp+36], -1610612724 ; a000000cH

; 4393 :                 FindClose(find_data_handle);

  00054	48 8b c8	 mov	 rcx, rax
  00057	0f 94 c3	 sete	 bl
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 4394 :             }
; 4395 :         }
; 4396 :     }
; 4397 : 
; 4398 :     if (is_directory && is_link)

  00060	85 db		 test	 ebx, ebx
  00062	48 8b 9c 24 b0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+688]
  0006a	74 12		 je	 SHORT $LN1@Py_DeleteF

; 4399 :         return RemoveDirectoryW(lpFileName);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryW

; 4402 : }

  00075	48 81 c4 a0 02
	00 00		 add	 rsp, 672		; 000002a0H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
$LN1@Py_DeleteF:

; 4400 : 
; 4401 :     return DeleteFileW(lpFileName);

  0007e	48 8b cf	 mov	 rcx, rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileW

; 4402 : }

  00087	48 81 c4 a0 02
	00 00		 add	 rsp, 672		; 000002a0H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
Py_DeleteFileW ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@	; `string'
EXTRN	__imp_DeleteFileA:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_unlink DD imagerel posix_unlink
	DD	imagerel posix_unlink+147
	DD	imagerel $unwind$posix_unlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_unlink DD imagerel posix_unlink+147
	DD	imagerel posix_unlink+213
	DD	imagerel $chain$1$posix_unlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_unlink DD imagerel posix_unlink+213
	DD	imagerel posix_unlink+329
	DD	imagerel $chain$2$posix_unlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_unlink DD 021H
	DD	imagerel posix_unlink
	DD	imagerel posix_unlink+147
	DD	imagerel $unwind$posix_unlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_unlink DD 020821H
	DD	0127408H
	DD	imagerel posix_unlink
	DD	imagerel posix_unlink+147
	DD	imagerel $unwind$posix_unlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_unlink DD 049301H
	DD	0143493H
	DD	013010aH
xdata	ENDS
;	COMDAT ??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@
CONST	SEGMENT
??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@ DB 'O&|$O&:unlink', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_unlink
_TEXT	SEGMENT
path$ = 64
self$ = 160
args$ = 168
kwargs$ = 176
posix_unlink PROC					; COMDAT

; 4425 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4426 :     path_t path;
; 4427 :     int dir_fd = DEFAULT_DIR_FD;
; 4428 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 4429 :     int result;
; 4430 :     PyObject *return_value = NULL;
; 4431 : 
; 4432 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 4433 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:unlink", keywords,
; 4434 :             path_converter, &path,
; 4435 : #ifdef HAVE_UNLINKAT
; 4436 :             dir_fd_converter, &dir_fd
; 4437 : #else
; 4438 :             dir_fd_unavailable, &dir_fd
; 4439 : #endif
; 4440 :             ))

  00036	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_unlink@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@
  00048	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0005a	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0005e	41 c7 43 20 9c
	ff ff ff	 mov	 DWORD PTR [r11+32], -100 ; ffffffffffffff9cH
  00066	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00071	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00075	49 8b ca	 mov	 rcx, r10
  00078	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007d	85 c0		 test	 eax, eax
  0007f	75 0a		 jne	 SHORT $LN4@posix_unli

; 4441 :         return NULL;

  00081	33 c0		 xor	 eax, eax

; 4471 : }

  00083	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0008a	c3		 ret	 0
$LN4@posix_unli:
  0008b	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  00093	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi

; 4442 : 
; 4443 :     Py_BEGIN_ALLOW_THREADS

  0009b	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4444 : #ifdef MS_WINDOWS
; 4445 :     if (path.wide)

  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp+24]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	48 85 c9	 test	 rcx, rcx
  000ab	74 07		 je	 SHORT $LN3@posix_unli

; 4446 :         result = Py_DeleteFileW(path.wide);

  000ad	e8 00 00 00 00	 call	 Py_DeleteFileW

; 4447 :     else

  000b2	eb 0b		 jmp	 SHORT $LN11@posix_unli
$LN3@posix_unli:

; 4448 :         result = DeleteFileA(path.narrow);

  000b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp+32]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileA
$LN11@posix_unli:

; 4449 :     result = !result; /* Windows, success=1, UNIX, success=0 */
; 4450 : #else
; 4451 : #ifdef HAVE_UNLINKAT
; 4452 :     if (dir_fd != DEFAULT_DIR_FD)
; 4453 :         result = unlinkat(dir_fd, path.narrow, 0);
; 4454 :     else
; 4455 : #endif /* HAVE_UNLINKAT */
; 4456 :         result = unlink(path.narrow);
; 4457 : #endif
; 4458 :     Py_END_ALLOW_THREADS

  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	8b d8		 mov	 ebx, eax
  000c4	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000c9	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]
  000d1	85 db		 test	 ebx, ebx

; 4459 : 
; 4460 :     if (result) {

  000d3	75 0f		 jne	 SHORT $LN1@posix_unli

; 4461 :         return_value = path_error("unlink", &path);

  000d5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  000da	e8 00 00 00 00	 call	 path_error
  000df	48 8b d8	 mov	 rbx, rax

; 4462 :         goto exit;

  000e2	eb 48		 jmp	 SHORT $exit$122537
$LN1@posix_unli:

; 4463 :     }
; 4464 : 
; 4465 :     return_value = Py_None;

  000e4	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 4466 :     Py_INCREF(Py_None);

  000eb	e8 00 00 00 00	 call	 _Py_PXCTX
  000f0	85 c0		 test	 eax, eax
  000f2	75 38		 jne	 SHORT $exit$122537
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00102	4c 8b cb	 mov	 r9, rbx
  00105	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00113	e8 00 00 00 00	 call	 _PyParallel_Guard
  00118	85 c0		 test	 eax, eax
  0011a	75 09		 jne	 SHORT $LN7@posix_unli
  0011c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00123	74 07		 je	 SHORT $exit$122537
$LN7@posix_unli:
  00125	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$exit$122537:

; 4467 : 
; 4468 : exit:
; 4469 :     path_cleanup(&path);

  0012c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  00131	e8 00 00 00 00	 call	 path_cleanup

; 4470 :     return return_value;

  00136	48 8b c3	 mov	 rax, rbx
  00139	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]

; 4471 : }

  00141	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00148	c3		 ret	 0
posix_unlink ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyLong_AsTime_t:PROC
EXTRN	PyNumber_Divmod:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$split_py_long_to_s_and_ns DD imagerel split_py_long_to_s_and_ns
	DD	imagerel split_py_long_to_s_and_ns+236
	DD	imagerel $unwind$split_py_long_to_s_and_ns
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$split_py_long_to_s_and_ns DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
xdata	ENDS
;	COMDAT split_py_long_to_s_and_ns
_TEXT	SEGMENT
py_long$ = 64
s$ = 72
ns$ = 80
split_py_long_to_s_and_ns PROC				; COMDAT

; 4722 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx

; 4723 :     int result = 0;
; 4724 :     PyObject *divmod;
; 4725 :     divmod = PyNumber_Divmod(py_long, billion);

  00017	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR billion
  0001e	49 8b e8	 mov	 rbp, r8
  00021	33 db		 xor	 ebx, ebx
  00023	e8 00 00 00 00	 call	 PyNumber_Divmod
  00028	48 8b f8	 mov	 rdi, rax

; 4726 :     if (!divmod)

  0002b	48 85 c0	 test	 rax, rax
  0002e	0f 84 a1 00 00
	00		 je	 $LN24@split_py_l

; 4727 :         goto exit;
; 4728 :     *s = _PyLong_AsTime_t(PyTuple_GET_ITEM(divmod, 0));

  00034	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00038	e8 00 00 00 00	 call	 _PyLong_AsTime_t
  0003d	48 89 06	 mov	 QWORD PTR [rsi], rax

; 4729 :     if ((*s == -1) && PyErr_Occurred())

  00040	48 83 f8 ff	 cmp	 rax, -1
  00044	75 0a		 jne	 SHORT $LN6@split_py_l
  00046	e8 00 00 00 00	 call	 PyErr_Occurred
  0004b	48 85 c0	 test	 rax, rax
  0004e	75 20		 jne	 SHORT $exit$122582
$LN6@split_py_l:

; 4730 :         goto exit;
; 4731 :     *ns = PyLong_AsLong(PyTuple_GET_ITEM(divmod, 1));

  00050	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  00054	e8 00 00 00 00	 call	 PyLong_AsLong
  00059	89 45 00	 mov	 DWORD PTR [rbp], eax

; 4732 :     if ((*ns == -1) && PyErr_Occurred())

  0005c	83 f8 ff	 cmp	 eax, -1
  0005f	75 0a		 jne	 SHORT $LN5@split_py_l
  00061	e8 00 00 00 00	 call	 PyErr_Occurred
  00066	48 85 c0	 test	 rax, rax
  00069	75 05		 jne	 SHORT $exit$122582
$LN5@split_py_l:

; 4733 :         goto exit;
; 4734 : 
; 4735 :     result = 1;

  0006b	bb 01 00 00 00	 mov	 ebx, 1
$exit$122582:

; 4736 : exit:
; 4737 :     Py_XDECREF(divmod);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	75 5c		 jne	 SHORT $LN24@split_py_l
  00079	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0007d	a8 20		 test	 al, 32			; 00000020H
  0007f	75 4c		 jne	 SHORT $LN14@split_py_l
  00081	84 c0		 test	 al, al
  00083	78 48		 js	 SHORT $LN14@split_py_l
  00085	a8 02		 test	 al, 2
  00087	75 4c		 jne	 SHORT $LN24@split_py_l
  00089	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0008d	75 46		 jne	 SHORT $LN24@split_py_l
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0009d	4c 8b cf	 mov	 r9, rdi
  000a0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000a6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ae	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b3	48 8b cf	 mov	 rcx, rdi
  000b6	85 c0		 test	 eax, eax
  000b8	74 07		 je	 SHORT $LN19@split_py_l
  000ba	e8 00 00 00 00	 call	 _Px_Dealloc
  000bf	eb 14		 jmp	 SHORT $LN24@split_py_l
$LN19@split_py_l:
  000c1	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000c5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000cb	eb 08		 jmp	 SHORT $LN24@split_py_l
$LN14@split_py_l:
  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 Px_DecRef
$LN24@split_py_l:

; 4738 :     return result;
; 4739 : }

  000d5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000da	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000df	8b c3		 mov	 eax, ebx
  000e1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ea	5f		 pop	 rdi
  000eb	c3		 ret	 0
split_py_long_to_s_and_ns ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@ ; `string'
PUBLIC	??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@ ; `string'
PUBLIC	??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@ ; `string'
PUBLIC	??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@ ; `string'
PUBLIC	??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@ ; `string'
PUBLIC	??_C@_02EGOFOKPC@ns?$AA@			; `string'
EXTRN	__imp_SetFileTime:PROC
EXTRN	__imp_SystemTimeToFileTime:PROC
EXTRN	__imp_GetSystemTime:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	_PyTime_ObjectToTimespec:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_utime DD imagerel posix_utime
	DD	imagerel posix_utime+307
	DD	imagerel $unwind$posix_utime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_utime DD imagerel posix_utime+307
	DD	imagerel posix_utime+315
	DD	imagerel $chain$0$posix_utime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_utime DD imagerel posix_utime+315
	DD	imagerel posix_utime+420
	DD	imagerel $chain$2$posix_utime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_utime DD imagerel posix_utime+420
	DD	imagerel posix_utime+456
	DD	imagerel $chain$3$posix_utime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix_utime DD imagerel posix_utime+456
	DD	imagerel posix_utime+1122
	DD	imagerel $chain$5$posix_utime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix_utime DD 060021H
	DD	032c400H
	DD	0316400H
	DD	0303400H
	DD	imagerel posix_utime
	DD	imagerel posix_utime+307
	DD	imagerel $unwind$posix_utime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_utime DD 021H
	DD	imagerel posix_utime+307
	DD	imagerel posix_utime+315
	DD	imagerel $chain$0$posix_utime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_utime DD 041021H
	DD	032c410H
	DD	0316408H
	DD	imagerel posix_utime+307
	DD	imagerel posix_utime+315
	DD	imagerel $chain$0$posix_utime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_utime DD 020821H
	DD	0303408H
	DD	imagerel posix_utime
	DD	imagerel posix_utime+307
	DD	imagerel $unwind$posix_utime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_utime DD 071501H
	DD	02a0115H
	DD	0e007f009H
	DD	07003d005H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@
CONST	SEGMENT
??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@ DB 'utime:'
	DB	' ''ns'' must be a tuple of two ints', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@
CONST	SEGMENT
??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@ DB 'utime: can'
	DB	'not use dir_fd and follow_symlinks together on this platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@
CONST	SEGMENT
??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@ DB 'utime: '
	DB	'''times'' must be either a tuple of two ints or None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@
CONST	SEGMENT
??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@ DB 'utime: yo'
	DB	'u may specify either ''times'' or ''ns'' but not both', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@
CONST	SEGMENT
??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@ DB 'O&|O$OO&p:utime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFOKPC@ns?$AA@
CONST	SEGMENT
??_C@_02EGOFOKPC@ns?$AA@ DB 'ns', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_utime
_TEXT	SEGMENT
follow_symlinks$ = 96
ns$ = 104
times$ = 112
m_nsec$122628 = 120
a_nsec$122627 = 124
_save$1$ = 128
now$122665 = 128
m_sec$122626 = 128
utime$ = 144
mtime$ = 184
atime$ = 192
a_sec$122625 = 200
path$ = 208
keywords$ = 288
self$ = 384
args$ = 392
kwargs$ = 400
hFile$ = 408
dir_fd$ = 408
posix_utime PROC					; COMDAT

; 4743 : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 8d 6c 24 b0	 lea	 rbp, QWORD PTR [rsp-80]
  0000e	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H

; 4744 :     path_t path;
; 4745 :     PyObject *times = NULL;
; 4746 :     PyObject *ns = NULL;
; 4747 :     int dir_fd = DEFAULT_DIR_FD;
; 4748 :     int follow_symlinks = 1;
; 4749 :     char *keywords[] = {"path", "times", "ns", "dir_fd",
; 4750 :                         "follow_symlinks", NULL};
; 4751 : 
; 4752 :     utime_t utime;
; 4753 : 
; 4754 : #ifdef MS_WINDOWS
; 4755 :     HANDLE hFile;
; 4756 :     FILETIME atime, mtime;
; 4757 : #else
; 4758 :     int result;
; 4759 : #endif
; 4760 : 
; 4761 :     PyObject *return_value = NULL;
; 4762 : 
; 4763 :     memset(&path, 0, sizeof(path));
; 4764 :     memset(&utime, 0, sizeof(utime_t));

  00015	45 33 ed	 xor	 r13d, r13d
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  0001f	49 8b c0	 mov	 rax, r8
  00022	48 89 4d 20	 mov	 QWORD PTR keywords$[rbp-256], rcx
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MJOOAIJH@times?$AA@
  0002d	4c 8b d2	 mov	 r10, rdx
  00030	48 89 4d 28	 mov	 QWORD PTR keywords$[rbp-248], rcx
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02EGOFOKPC@ns?$AA@
  0003b	33 ff		 xor	 edi, edi
  0003d	48 89 4d 30	 mov	 QWORD PTR keywords$[rbp-240], rcx
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@

; 4765 : #if UTIME_HAVE_FD
; 4766 :     path.allow_fd = 1;
; 4767 : #endif
; 4768 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 4769 :             "O&|O$OO&p:utime", keywords,
; 4770 :             path_converter, &path,
; 4771 :             &times, &ns,
; 4772 : #if UTIME_HAVE_DIR_FD
; 4773 :             dir_fd_converter, &dir_fd,
; 4774 : #else
; 4775 :             dir_fd_unavailable, &dir_fd,
; 4776 : #endif
; 4777 :             &follow_symlinks
; 4778 :             ))

  00048	4c 8d 4d 20	 lea	 r9, QWORD PTR keywords$[rbp-256]
  0004c	48 89 4d 38	 mov	 QWORD PTR keywords$[rbp-232], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@
  0005e	48 89 4d 40	 mov	 QWORD PTR keywords$[rbp-224], rcx
  00062	33 c9		 xor	 ecx, ecx
  00064	41 be 01 00 00
	00		 mov	 r14d, 1
  0006a	48 89 4d d0	 mov	 QWORD PTR path$[rbp-256], rcx
  0006e	48 89 4d d8	 mov	 QWORD PTR path$[rbp-248], rcx
  00072	48 89 4d e0	 mov	 QWORD PTR path$[rbp-240], rcx
  00076	48 89 4d e8	 mov	 QWORD PTR path$[rbp-232], rcx
  0007a	48 89 4d f0	 mov	 QWORD PTR path$[rbp-224], rcx
  0007e	48 89 4d f8	 mov	 QWORD PTR path$[rbp-216], rcx
  00082	48 89 4d 00	 mov	 QWORD PTR path$[rbp-208], rcx
  00086	48 89 4d 08	 mov	 QWORD PTR path$[rbp-200], rcx
  0008a	48 89 4d 10	 mov	 QWORD PTR path$[rbp-192], rcx
  0008e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR follow_symlinks$[rsp]
  00093	48 8b d0	 mov	 rdx, rax
  00096	48 89 7c 24 70	 mov	 QWORD PTR times$[rsp], rdi
  0009b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000a0	48 8d 8d 98 00
	00 00		 lea	 rcx, QWORD PTR dir_fd$[rbp-256]
  000a7	48 89 7c 24 68	 mov	 QWORD PTR ns$[rsp], rdi
  000ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  000b8	c7 85 98 00 00
	00 9c ff ff ff	 mov	 DWORD PTR dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  000c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000c7	48 8d 4c 24 68	 lea	 rcx, QWORD PTR ns$[rsp]
  000cc	44 89 74 24 60	 mov	 DWORD PTR follow_symlinks$[rsp], r14d
  000d1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR times$[rsp]
  000db	48 89 7d 48	 mov	 QWORD PTR keywords$[rbp-216], rdi
  000df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e4	48 8d 4d d0	 lea	 rcx, QWORD PTR path$[rbp-256]
  000e8	4c 89 6d 90	 mov	 QWORD PTR utime$[rbp-256], r13
  000ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  000f8	4c 89 6d 98	 mov	 QWORD PTR utime$[rbp-248], r13
  000fc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00101	49 8b ca	 mov	 rcx, r10
  00104	4c 89 6d a0	 mov	 QWORD PTR utime$[rbp-240], r13
  00108	45 8b fd	 mov	 r15d, r13d
  0010b	4c 89 6d a8	 mov	 QWORD PTR utime$[rbp-232], r13
  0010f	4c 89 6d b0	 mov	 QWORD PTR utime$[rbp-224], r13
  00113	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00118	85 c0		 test	 eax, eax
  0011a	75 12		 jne	 SHORT $LN27@posix_utim

; 4779 :         return NULL;

  0011c	33 c0		 xor	 eax, eax

; 4927 : }

  0011e	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00125	41 5f		 pop	 r15
  00127	41 5e		 pop	 r14
  00129	41 5d		 pop	 r13
  0012b	5f		 pop	 rdi
  0012c	5d		 pop	 rbp
  0012d	c3		 ret	 0
$LN27@posix_utim:

; 4780 : 
; 4781 :     if (times && (times != Py_None) && ns) {

  0012e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR times$[rsp]
  00133	48 89 9c 24 80
	01 00 00	 mov	 QWORD PTR [rsp+384], rbx
  0013b	48 89 b4 24 88
	01 00 00	 mov	 QWORD PTR [rsp+392], rsi
  00143	4c 89 a4 24 90
	01 00 00	 mov	 QWORD PTR [rsp+400], r12
  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00152	48 85 c9	 test	 rcx, rcx
  00155	0f 84 f1 00 00
	00		 je	 $LN25@posix_utim
  0015b	48 3b c8	 cmp	 rcx, rax
  0015e	0f 84 e8 00 00
	00		 je	 $LN25@posix_utim
  00164	48 39 7c 24 68	 cmp	 QWORD PTR ns$[rsp], rdi
  00169	74 5d		 je	 SHORT $LN26@posix_utim

; 4782 :         PyErr_SetString(PyExc_ValueError,
; 4783 :                      "utime: you may specify either 'times'"
; 4784 :                      " or 'ns' but not both");

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@
$LN34@posix_utim:

; 4840 :         PyErr_SetString(PyExc_ValueError,
; 4841 :                      "utime: cannot use dir_fd and follow_symlinks "
; 4842 :                      "together on this platform");

  00172	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
$LN33@posix_utim:

; 4792 :             PyErr_SetString(PyExc_TypeError,
; 4793 :                          "utime: 'times' must be either"
; 4794 :                          " a tuple of two ints or None");

  00179	e8 00 00 00 00	 call	 PyErr_SetString
$LN31@posix_utim:

; 4843 :         goto exit;

  0017e	48 8b 9d 98 00
	00 00		 mov	 rbx, QWORD PTR hFile$[rbp-256]
$exit$122623:

; 4919 : 
; 4920 : exit:
; 4921 :     path_cleanup(&path);

  00185	48 8d 4d d0	 lea	 rcx, QWORD PTR path$[rbp-256]
  00189	e8 00 00 00 00	 call	 path_cleanup
  0018e	4c 8b a4 24 90
	01 00 00	 mov	 r12, QWORD PTR [rsp+400]
  00196	48 8b b4 24 88
	01 00 00	 mov	 rsi, QWORD PTR [rsp+392]

; 4922 : #ifdef MS_WINDOWS
; 4923 :     if (hFile != INVALID_HANDLE_VALUE)

  0019e	48 83 fb ff	 cmp	 rbx, -1
  001a2	74 09		 je	 SHORT $LN1@posix_utim

; 4924 :         CloseHandle(hFile);

  001a4	48 8b cb	 mov	 rcx, rbx
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN1@posix_utim:

; 4925 : #endif
; 4926 :     return return_value;

  001ad	48 8b c7	 mov	 rax, rdi
  001b0	48 8b 9c 24 80
	01 00 00	 mov	 rbx, QWORD PTR [rsp+384]

; 4927 : }

  001b8	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  001bf	41 5f		 pop	 r15
  001c1	41 5e		 pop	 r14
  001c3	41 5d		 pop	 r13
  001c5	5f		 pop	 rdi
  001c6	5d		 pop	 rbp
  001c7	c3		 ret	 0
$LN26@posix_utim:

; 4785 :         goto exit;
; 4786 :     }
; 4787 : 
; 4788 :     if (times && (times != Py_None)) {
; 4789 :         time_t a_sec, m_sec;
; 4790 :         long a_nsec, m_nsec;
; 4791 :         if (!PyTuple_CheckExact(times) || (PyTuple_Size(times) != 2)) {

  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  001cf	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001d3	75 64		 jne	 SHORT $LN23@posix_utim
  001d5	e8 00 00 00 00	 call	 PyTuple_Size
  001da	48 83 f8 02	 cmp	 rax, 2
  001de	75 59		 jne	 SHORT $LN23@posix_utim

; 4796 :         }
; 4797 :         utime.now = 0;
; 4798 :         if (_PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 0),
; 4799 :                                      &a_sec, &a_nsec) == -1 ||
; 4800 :             _PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 1),
; 4801 :                                      &m_sec, &m_nsec) == -1) {

  001e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR times$[rsp]
  001e5	4c 8d 44 24 7c	 lea	 r8, QWORD PTR a_nsec$122627[rsp]
  001ea	48 8d 55 c8	 lea	 rdx, QWORD PTR a_sec$122625[rbp-256]
  001ee	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f2	44 8b f7	 mov	 r14d, edi
  001f5	e8 00 00 00 00	 call	 _PyTime_ObjectToTimespec
  001fa	83 f8 ff	 cmp	 eax, -1
  001fd	0f 84 7b ff ff
	ff		 je	 $LN31@posix_utim
  00203	48 8b 4c 24 70	 mov	 rcx, QWORD PTR times$[rsp]
  00208	4c 8d 44 24 78	 lea	 r8, QWORD PTR m_nsec$122628[rsp]
  0020d	48 8d 55 80	 lea	 rdx, QWORD PTR m_sec$122626[rbp-256]
  00211	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00215	e8 00 00 00 00	 call	 _PyTime_ObjectToTimespec
  0021a	83 f8 ff	 cmp	 eax, -1
  0021d	0f 84 5b ff ff
	ff		 je	 $LN31@posix_utim

; 4802 :             goto exit;
; 4803 :         }
; 4804 :         utime.atime_s = a_sec;

  00223	4c 8b 6d c8	 mov	 r13, QWORD PTR a_sec$122625[rbp-256]

; 4805 :         utime.atime_ns = a_nsec;

  00227	8b 74 24 7c	 mov	 esi, DWORD PTR a_nsec$122627[rsp]

; 4806 :         utime.mtime_s = m_sec;

  0022b	4c 8b 7d 80	 mov	 r15, QWORD PTR m_sec$122626[rbp-256]

; 4807 :         utime.mtime_ns = m_nsec;

  0022f	44 8b 64 24 78	 mov	 r12d, DWORD PTR m_nsec$122628[rsp]
  00234	e9 8f 00 00 00	 jmp	 $LN14@posix_utim
$LN23@posix_utim:

; 4792 :             PyErr_SetString(PyExc_TypeError,
; 4793 :                          "utime: 'times' must be either"
; 4794 :                          " a tuple of two ints or None");

  00239	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@

; 4795 :             goto exit;

  00247	e9 2d ff ff ff	 jmp	 $LN33@posix_utim
$LN25@posix_utim:

; 4808 :     }
; 4809 :     else if (ns) {

  0024c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ns$[rsp]
  00251	48 85 c9	 test	 rcx, rcx
  00254	74 6b		 je	 SHORT $LN19@posix_utim

; 4810 :         if (!PyTuple_CheckExact(ns) || (PyTuple_Size(ns) != 2)) {

  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  0025d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00261	0f 85 ed 00 00
	00		 jne	 $LN17@posix_utim
  00267	e8 00 00 00 00	 call	 PyTuple_Size
  0026c	48 83 f8 02	 cmp	 rax, 2
  00270	0f 85 de 00 00
	00		 jne	 $LN17@posix_utim

; 4814 :         }
; 4815 :         utime.now = 0;
; 4816 :         if (!split_py_long_to_s_and_ns(PyTuple_GET_ITEM(ns, 0),
; 4817 :                                       &utime.atime_s, &utime.atime_ns) ||
; 4818 :             !split_py_long_to_s_and_ns(PyTuple_GET_ITEM(ns, 1),
; 4819 :                                        &utime.mtime_s, &utime.mtime_ns)) {

  00276	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ns$[rsp]
  0027b	4c 8d 45 a0	 lea	 r8, QWORD PTR utime$[rbp-240]
  0027f	48 8d 55 98	 lea	 rdx, QWORD PTR utime$[rbp-248]
  00283	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00287	89 7d 90	 mov	 DWORD PTR utime$[rbp-256], edi
  0028a	e8 00 00 00 00	 call	 split_py_long_to_s_and_ns
  0028f	85 c0		 test	 eax, eax
  00291	0f 84 e7 fe ff
	ff		 je	 $LN31@posix_utim
  00297	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ns$[rsp]
  0029c	4c 8d 45 b0	 lea	 r8, QWORD PTR utime$[rbp-224]
  002a0	48 8d 55 a8	 lea	 rdx, QWORD PTR utime$[rbp-232]
  002a4	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  002a8	e8 00 00 00 00	 call	 split_py_long_to_s_and_ns
  002ad	85 c0		 test	 eax, eax

; 4820 :             goto exit;

  002af	0f 84 c9 fe ff
	ff		 je	 $LN31@posix_utim

; 4821 :         }
; 4822 :     }
; 4823 :     else {
; 4824 :         /* times and ns are both None/unspecified. use "now". */
; 4825 :         utime.now = 1;

  002b5	4c 8b 7d a8	 mov	 r15, QWORD PTR utime$[rbp-232]
  002b9	4c 8b 6d 98	 mov	 r13, QWORD PTR utime$[rbp-248]
  002bd	44 8b 75 90	 mov	 r14d, DWORD PTR utime$[rbp-256]
$LN19@posix_utim:
  002c1	8b 75 a0	 mov	 esi, DWORD PTR utime$[rbp-240]
  002c4	44 8b 65 b0	 mov	 r12d, DWORD PTR utime$[rbp-224]
$LN14@posix_utim:

; 4826 :     }
; 4827 : 
; 4828 : #if !UTIME_HAVE_NOFOLLOW_SYMLINKS
; 4829 :     if (follow_symlinks_specified("utime", follow_symlinks))

  002c8	8b 54 24 60	 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  002cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  002d3	e8 00 00 00 00	 call	 follow_symlinks_specified
  002d8	85 c0		 test	 eax, eax
  002da	0f 85 9e fe ff
	ff		 jne	 $LN31@posix_utim

; 4830 :         goto exit;
; 4831 : #endif
; 4832 : 
; 4833 :     if (path_and_dir_fd_invalid("utime", &path, dir_fd) ||
; 4834 :         dir_fd_and_fd_invalid("utime", dir_fd, path.fd) ||
; 4835 :         fd_and_follow_symlinks_invalid("utime", path.fd, follow_symlinks))

  002e0	44 8b 85 98 00
	00 00		 mov	 r8d, DWORD PTR dir_fd$[rbp-256]
  002e7	48 8d 55 d0	 lea	 rdx, QWORD PTR path$[rbp-256]
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  002f2	e8 00 00 00 00	 call	 path_and_dir_fd_invalid
  002f7	85 c0		 test	 eax, eax
  002f9	0f 85 7f fe ff
	ff		 jne	 $LN31@posix_utim
  002ff	44 8b 45 f8	 mov	 r8d, DWORD PTR path$[rbp-216]
  00303	8b 95 98 00 00
	00		 mov	 edx, DWORD PTR dir_fd$[rbp-256]
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  00310	e8 00 00 00 00	 call	 dir_fd_and_fd_invalid
  00315	85 c0		 test	 eax, eax
  00317	0f 85 61 fe ff
	ff		 jne	 $LN31@posix_utim
  0031d	44 8b 44 24 60	 mov	 r8d, DWORD PTR follow_symlinks$[rsp]
  00322	8b 55 f8	 mov	 edx, DWORD PTR path$[rbp-216]
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  0032c	e8 00 00 00 00	 call	 fd_and_follow_symlinks_invalid
  00331	85 c0		 test	 eax, eax
  00333	0f 85 45 fe ff
	ff		 jne	 $LN31@posix_utim

; 4836 :         goto exit;
; 4837 : 
; 4838 : #if !defined(HAVE_UTIMENSAT)
; 4839 :     if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {

  00339	83 bd 98 00 00
	00 9c		 cmp	 DWORD PTR dir_fd$[rbp-256], -100 ; ffffffffffffff9cH
  00340	74 25		 je	 SHORT $LN10@posix_utim
  00342	39 7c 24 60	 cmp	 DWORD PTR follow_symlinks$[rsp], edi
  00346	75 1f		 jne	 SHORT $LN10@posix_utim

; 4840 :         PyErr_SetString(PyExc_ValueError,
; 4841 :                      "utime: cannot use dir_fd and follow_symlinks "
; 4842 :                      "together on this platform");

  00348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@

; 4843 :         goto exit;

  0034f	e9 1e fe ff ff	 jmp	 $LN34@posix_utim
$LN17@posix_utim:

; 4811 :             PyErr_SetString(PyExc_TypeError,
; 4812 :                          "utime: 'ns' must be a tuple of two ints");

  00354	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0035b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@

; 4813 :             goto exit;

  00362	e9 12 fe ff ff	 jmp	 $LN33@posix_utim
$LN10@posix_utim:

; 4844 :     }
; 4845 : #endif
; 4846 : 
; 4847 : #ifdef MS_WINDOWS
; 4848 :     Py_BEGIN_ALLOW_THREADS

  00367	e8 00 00 00 00	 call	 PyEval_SaveThread

; 4849 :     if (path.wide)

  0036c	48 8b 4d e8	 mov	 rcx, QWORD PTR path$[rbp-232]

; 4850 :         hFile = CreateFileW(path.wide, FILE_WRITE_ATTRIBUTES, 0,
; 4851 :                             NULL, OPEN_EXISTING,
; 4852 :                             FILE_FLAG_BACKUP_SEMANTICS, NULL);

  00370	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00375	45 33 c9	 xor	 r9d, r9d
  00378	45 33 c0	 xor	 r8d, r8d
  0037b	c7 44 24 28 00
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554432 ; 02000000H
  00383	48 89 45 80	 mov	 QWORD PTR _save$1$[rbp-256], rax
  00387	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0038c	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00394	48 85 c9	 test	 rcx, rcx
  00397	74 08		 je	 SHORT $LN9@posix_utim
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW

; 4853 :     else

  0039f	eb 0a		 jmp	 SHORT $LN32@posix_utim
$LN9@posix_utim:

; 4854 :         hFile = CreateFileA(path.narrow, FILE_WRITE_ATTRIBUTES, 0,
; 4855 :                             NULL, OPEN_EXISTING,
; 4856 :                             FILE_FLAG_BACKUP_SEMANTICS, NULL);

  003a1	48 8b 4d f0	 mov	 rcx, QWORD PTR path$[rbp-224]
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
$LN32@posix_utim:

; 4857 :     Py_END_ALLOW_THREADS

  003ab	48 8b 4d 80	 mov	 rcx, QWORD PTR _save$1$[rbp-256]
  003af	48 8b d8	 mov	 rbx, rax
  003b2	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4858 :     if (hFile == INVALID_HANDLE_VALUE) {

  003b7	48 83 fb ff	 cmp	 rbx, -1
  003bb	75 0e		 jne	 SHORT $LN7@posix_utim

; 4859 :         win32_error_object("utime", path.object);

  003bd	48 8b 4d 08	 mov	 rcx, QWORD PTR path$[rbp-200]
  003c1	e8 00 00 00 00	 call	 win32_error_object

; 4860 :         goto exit;

  003c6	e9 ba fd ff ff	 jmp	 $exit$122623
$LN7@posix_utim:

; 4861 :     }
; 4862 : 
; 4863 :     if (utime.now) {

  003cb	45 85 f6	 test	 r14d, r14d
  003ce	74 3a		 je	 SHORT $LN6@posix_utim

; 4864 :         SYSTEMTIME now;
; 4865 :         GetSystemTime(&now);

  003d0	48 8d 4d 80	 lea	 rcx, QWORD PTR now$122665[rbp-256]
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTime

; 4866 :         if (!SystemTimeToFileTime(&now, &mtime) ||
; 4867 :             !SystemTimeToFileTime(&now, &atime)) {

  003da	48 8d 55 b8	 lea	 rdx, QWORD PTR mtime$[rbp-256]
  003de	48 8d 4d 80	 lea	 rcx, QWORD PTR now$122665[rbp-256]
  003e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SystemTimeToFileTime
  003e8	85 c0		 test	 eax, eax
  003ea	74 12		 je	 SHORT $LN4@posix_utim
  003ec	48 8d 55 c0	 lea	 rdx, QWORD PTR atime$[rbp-256]
  003f0	48 8d 4d 80	 lea	 rcx, QWORD PTR now$122665[rbp-256]
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SystemTimeToFileTime
  003fa	85 c0		 test	 eax, eax
  003fc	75 29		 jne	 SHORT $LN3@posix_utim
$LN4@posix_utim:

; 4868 :             win32_error("utime", NULL);

  003fe	33 c9		 xor	 ecx, ecx
  00400	e8 00 00 00 00	 call	 win32_error

; 4869 :             goto exit;

  00405	e9 7b fd ff ff	 jmp	 $exit$122623
$LN6@posix_utim:

; 4870 :         }
; 4871 :     }
; 4872 :     else {
; 4873 :         time_t_to_FILE_TIME(utime.atime_s, utime.atime_ns, &atime);

  0040a	4c 8d 45 c0	 lea	 r8, QWORD PTR atime$[rbp-256]
  0040e	8b d6		 mov	 edx, esi
  00410	49 8b cd	 mov	 rcx, r13
  00413	e8 00 00 00 00	 call	 time_t_to_FILE_TIME

; 4874 :         time_t_to_FILE_TIME(utime.mtime_s, utime.mtime_ns, &mtime);

  00418	4c 8d 45 b8	 lea	 r8, QWORD PTR mtime$[rbp-256]
  0041c	41 8b d4	 mov	 edx, r12d
  0041f	49 8b cf	 mov	 rcx, r15
  00422	e8 00 00 00 00	 call	 time_t_to_FILE_TIME
$LN3@posix_utim:

; 4875 :     }
; 4876 :     if (!SetFileTime(hFile, NULL, &atime, &mtime)) {

  00427	4c 8d 4d b8	 lea	 r9, QWORD PTR mtime$[rbp-256]
  0042b	4c 8d 45 c0	 lea	 r8, QWORD PTR atime$[rbp-256]
  0042f	33 d2		 xor	 edx, edx
  00431	48 8b cb	 mov	 rcx, rbx
  00434	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileTime
  0043a	85 c0		 test	 eax, eax
  0043c	75 0c		 jne	 SHORT $LN2@posix_utim

; 4877 :         /* Avoid putting the file name into the error here,
; 4878 :            as that may confuse the user into believing that
; 4879 :            something is wrong with the file, when it also
; 4880 :            could be the time stamp that gives a problem. */
; 4881 :         win32_error("utime", NULL);

  0043e	33 c9		 xor	 ecx, ecx
  00440	e8 00 00 00 00	 call	 win32_error

; 4882 :         goto exit;

  00445	e9 3b fd ff ff	 jmp	 $exit$122623
$LN2@posix_utim:

; 4883 :     }
; 4884 : #else /* MS_WINDOWS */
; 4885 :     Py_BEGIN_ALLOW_THREADS
; 4886 : 
; 4887 : #if UTIME_HAVE_NOFOLLOW_SYMLINKS
; 4888 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
; 4889 :         result = utime_nofollow_symlinks(&utime, path.narrow);
; 4890 :     else
; 4891 : #endif
; 4892 : 
; 4893 : #if UTIME_HAVE_DIR_FD
; 4894 :     if ((dir_fd != DEFAULT_DIR_FD) || (!follow_symlinks))
; 4895 :         result = utime_dir_fd(&utime, dir_fd, path.narrow, follow_symlinks);
; 4896 :     else
; 4897 : #endif
; 4898 : 
; 4899 : #if UTIME_HAVE_FD
; 4900 :     if (path.fd != -1)
; 4901 :         result = utime_fd(&utime, path.fd);
; 4902 :     else
; 4903 : #endif
; 4904 : 
; 4905 :     result = utime_default(&utime, path.narrow);
; 4906 : 
; 4907 :     Py_END_ALLOW_THREADS
; 4908 : 
; 4909 :     if (result < 0) {
; 4910 :         /* see previous comment about not putting filename in error here */
; 4911 :         return_value = posix_error();
; 4912 :         goto exit;
; 4913 :     }
; 4914 : 
; 4915 : #endif /* MS_WINDOWS */
; 4916 : 
; 4917 :     Py_INCREF(Py_None);

  0044a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00451	e8 00 00 00 00	 call	 _Py_IncRef

; 4918 :     return_value = Py_None;

  00456	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0045d	e9 23 fd ff ff	 jmp	 $exit$122623
posix_utime ENDP
_TEXT	ENDS
PUBLIC	??_C@_07FHLOOHCL@i?3_exit?$AA@			; `string'
EXTRN	__imp__exit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__exit DD imagerel posix__exit
	DD	imagerel posix__exit+46
	DD	imagerel $unwind$posix__exit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__exit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07FHLOOHCL@i?3_exit?$AA@
CONST	SEGMENT
??_C@_07FHLOOHCL@i?3_exit?$AA@ DB 'i:_exit', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix__exit
_TEXT	SEGMENT
self$ = 48
args$ = 56
sts$ = 64
posix__exit PROC					; COMDAT

; 4937 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4938 :     int sts;
; 4939 :     if (!PyArg_ParseTuple(args, "i:_exit", &sts))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR sts$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07FHLOOHCL@i?3_exit?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@posix__exi

; 4940 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 4942 :     return NULL; /* Make gcc -Wall happy */
; 4943 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN1@posix__exi:

; 4941 :     _exit(sts);

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR sts$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__exit
  0002d	cc		 int	 3
$LN4@posix__exi:
posix__exit ENDP
_TEXT	ENDS
EXTRN	_PxMem_Free:PROC
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$free_string_array DD imagerel free_string_array
	DD	imagerel free_string_array+103
	DD	imagerel $unwind$free_string_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_string_array DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT free_string_array
_TEXT	SEGMENT
array$ = 48
count$ = 56
free_string_array PROC					; COMDAT

; 4948 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4949 :     Py_ssize_t i;
; 4950 :     for (i = 0; i < count; i++)

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 85 d2	 test	 rdx, rdx
  0001a	7e 15		 jle	 SHORT $LN1@free_strin
  0001c	0f 1f 40 00	 npad	 4
$LL3@free_strin:

; 4951 :         PyMem_Free(array[i]);

  00020	48 8b 0c df	 mov	 rcx, QWORD PTR [rdi+rbx*8]
  00024	e8 00 00 00 00	 call	 PyMem_Free
  00029	48 ff c3	 inc	 rbx
  0002c	48 3b de	 cmp	 rbx, rsi
  0002f	7c ef		 jl	 SHORT $LL3@free_strin
$LN1@free_strin:

; 4952 :     PyMem_DEL(array);

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	48 8b cf	 mov	 rcx, rdi
  00039	85 c0		 test	 eax, eax
  0003b	74 14		 je	 SHORT $LN6@free_strin

; 4953 : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	e9 00 00 00 00	 jmp	 _PxMem_Free
$LN6@free_strin:
  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
free_string_array ENDP
_TEXT	ENDS
EXTRN	PyBytes_AsString:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PyUnicode_FSConverter:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fsconvert_strdup DD imagerel fsconvert_strdup
	DD	imagerel fsconvert_strdup+34
	DD	imagerel $unwind$fsconvert_strdup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fsconvert_strdup DD imagerel fsconvert_strdup+34
	DD	imagerel fsconvert_strdup+71
	DD	imagerel $chain$0$fsconvert_strdup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fsconvert_strdup DD imagerel fsconvert_strdup+71
	DD	imagerel fsconvert_strdup+122
	DD	imagerel $chain$2$fsconvert_strdup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fsconvert_strdup DD 020021H
	DD	063400H
	DD	imagerel fsconvert_strdup
	DD	imagerel fsconvert_strdup+34
	DD	imagerel $unwind$fsconvert_strdup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fsconvert_strdup DD 020521H
	DD	063405H
	DD	imagerel fsconvert_strdup
	DD	imagerel fsconvert_strdup+34
	DD	imagerel $unwind$fsconvert_strdup
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fsconvert_strdup DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fsconvert_strdup
_TEXT	SEGMENT
o$ = 48
out$ = 56
bytes$ = 64
fsconvert_strdup PROC					; COMDAT

; 4957 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b fa	 mov	 rdi, rdx

; 4958 :     PyObject *bytes;
; 4959 :     Py_ssize_t size;
; 4960 :     if (!PyUnicode_FSConverter(o, &bytes))

  00009	48 8d 54 24 40	 lea	 rdx, QWORD PTR bytes$[rsp]
  0000e	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  00013	85 c0		 test	 eax, eax
  00015	75 06		 jne	 SHORT $LN2@fsconvert_

; 4969 : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5f		 pop	 rdi
  0001c	c3		 ret	 0
$LN2@fsconvert_:

; 4961 :         return 0;
; 4962 :     size = PyBytes_GET_SIZE(bytes);

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR bytes$[rsp]
  00022	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00027	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]

; 4963 :     *out = PyMem_Malloc(size+1);

  0002b	48 8d 4b 01	 lea	 rcx, QWORD PTR [rbx+1]
  0002f	e8 00 00 00 00	 call	 PyMem_Malloc
  00034	48 89 07	 mov	 QWORD PTR [rdi], rax

; 4964 :     if (!*out)

  00037	48 85 c0	 test	 rax, rax
  0003a	75 0b		 jne	 SHORT $LN1@fsconvert_
  0003c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4969 : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN1@fsconvert_:

; 4965 :         return 0;
; 4966 :     memcpy(*out, PyBytes_AsString(bytes), size+1);

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  0004c	e8 00 00 00 00	 call	 PyBytes_AsString
  00051	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00054	4c 8d 43 01	 lea	 r8, QWORD PTR [rbx+1]
  00058	48 8b d0	 mov	 rdx, rax
  0005b	e8 00 00 00 00	 call	 memcpy

; 4967 :     Py_DECREF(bytes);

  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  00065	e8 00 00 00 00	 call	 _Py_DecRef
  0006a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 4968 :     return 1;

  0006f	b8 01 00 00 00	 mov	 eax, 1

; 4969 : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
fsconvert_strdup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@ ; `string'
PUBLIC	??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@		; `string'
EXTRN	PyOS_snprintf:PROC
EXTRN	PyList_GetItem:PROC
EXTRN	PyMapping_Values:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyMapping_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_envlist DD imagerel parse_envlist
	DD	imagerel parse_envlist+51
	DD	imagerel $unwind$parse_envlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$parse_envlist DD imagerel parse_envlist+51
	DD	imagerel parse_envlist+656
	DD	imagerel $chain$5$parse_envlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$parse_envlist DD imagerel parse_envlist+656
	DD	imagerel parse_envlist+804
	DD	imagerel $chain$7$parse_envlist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$parse_envlist DD imagerel parse_envlist+804
	DD	imagerel parse_envlist+824
	DD	imagerel $chain$8$parse_envlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$parse_envlist DD 020021H
	DD	0b7400H
	DD	imagerel parse_envlist
	DD	imagerel parse_envlist+51
	DD	imagerel $unwind$parse_envlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$parse_envlist DD 0c0021H
	DD	08f400H
	DD	09e400H
	DD	0ac400H
	DD	0b7400H
	DD	0c5400H
	DD	0103400H
	DD	imagerel parse_envlist
	DD	imagerel parse_envlist+51
	DD	imagerel $unwind$parse_envlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$parse_envlist DD 0c8021H
	DD	08f480H
	DD	09e479H
	DD	0ac471H
	DD	0c546cH
	DD	0103467H
	DD	0b7405H
	DD	imagerel parse_envlist
	DD	imagerel parse_envlist+51
	DD	imagerel $unwind$parse_envlist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_envlist DD 030c01H
	DD	0d008c20cH
	DD	06006H
xdata	ENDS
;	COMDAT ??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@
CONST	SEGMENT
??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@ DB 'e'
	DB	'nv.keys() or env.values() is not a list', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@ DB '%s=%s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parse_envlist
_TEXT	SEGMENT
v$1$ = 48
k$1$ = 56
env$ = 128
envc_ptr$ = 136
key2$ = 144
val2$ = 152
parse_envlist PROC					; COMDAT

; 4975 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	56		 push	 rsi
  00006	41 55		 push	 r13
  00008	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0000c	48 8b f1	 mov	 rsi, rcx

; 4976 :     char **envlist;
; 4977 :     Py_ssize_t i, pos, envc;
; 4978 :     PyObject *keys=NULL, *vals=NULL;
; 4979 :     PyObject *key, *val, *key2, *val2;
; 4980 :     char *p, *k, *v;
; 4981 :     size_t len;
; 4982 : 
; 4983 :     i = PyMapping_Size(env);

  0000f	e8 00 00 00 00	 call	 PyMapping_Size
  00014	4c 8b e8	 mov	 r13, rax

; 4984 :     if (i < 0)

  00017	48 85 c0	 test	 rax, rax
  0001a	79 0a		 jns	 SHORT $LN24@parse_envl

; 4985 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 5052 : }

  0001e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00022	41 5d		 pop	 r13
  00024	5e		 pop	 rsi
  00025	c3		 ret	 0
$LN24@parse_envl:

; 4986 :     envlist = PyMem_NEW(char *, i + 1);

  00026	48 ff c0	 inc	 rax
  00029	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00033	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00038	48 3b c1	 cmp	 rax, rcx
  0003b	0f 87 e3 02 00
	00		 ja	 $LN52@parse_envl
  00041	e8 00 00 00 00	 call	 _Py_PXCTX
  00046	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00050	85 c0		 test	 eax, eax
  00052	74 0f		 je	 SHORT $LN31@parse_envl
  00054	4a 8d 0c ed 08
	00 00 00	 lea	 rcx, QWORD PTR [r13*8+8]
  0005c	e8 00 00 00 00	 call	 _PxMem_Malloc
  00061	eb 23		 jmp	 SHORT $LN61@parse_envl
$LN31@parse_envl:
  00063	4a 8d 04 ed 08
	00 00 00	 lea	 rax, QWORD PTR [r13*8+8]
  0006b	48 3b c1	 cmp	 rax, rcx
  0006e	0f 87 b0 02 00
	00		 ja	 $LN52@parse_envl
  00074	48 85 c0	 test	 rax, rax
  00077	b9 01 00 00 00	 mov	 ecx, 1
  0007c	48 0f 45 c8	 cmovne	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN61@parse_envl:
  00086	48 8b f8	 mov	 rdi, rax

; 4987 :     if (envlist == NULL) {

  00089	48 85 c0	 test	 rax, rax
  0008c	0f 84 92 02 00
	00		 je	 $LN52@parse_envl

; 4990 :     }
; 4991 :     envc = 0;
; 4992 :     keys = PyMapping_Keys(env);

  00092	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  0009a	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0009f	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  000a4	48 8b ce	 mov	 rcx, rsi
  000a7	4c 89 74 24 48	 mov	 QWORD PTR [rsp+72], r14
  000ac	33 db		 xor	 ebx, ebx
  000ae	4c 89 7c 24 40	 mov	 QWORD PTR [rsp+64], r15
  000b3	e8 00 00 00 00	 call	 PyMapping_Keys

; 4993 :     vals = PyMapping_Values(env);

  000b8	48 8b ce	 mov	 rcx, rsi
  000bb	4c 8b f8	 mov	 r15, rax
  000be	e8 00 00 00 00	 call	 PyMapping_Values
  000c3	4c 8b e0	 mov	 r12, rax

; 4994 :     if (!keys || !vals)

  000c6	4d 85 ff	 test	 r15, r15
  000c9	0f 84 fd 01 00
	00		 je	 $LN9@parse_envl
  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 ec 01 00
	00		 je	 $error$122760

; 4995 :         goto error;
; 4996 :     if (!PyList_Check(keys) || !PyList_Check(vals)) {

  000d8	49 8b 4f 58	 mov	 rcx, QWORD PTR [r15+88]
  000dc	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  000e6	0f 84 c5 01 00
	00		 je	 $LN19@parse_envl
  000ec	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000f0	f7 81 00 01 00
	00 00 00 00 02	 test	 DWORD PTR [rcx+256], 33554432 ; 02000000H
  000fa	0f 84 b1 01 00
	00		 je	 $LN19@parse_envl

; 4999 :         goto error;
; 5000 :     }
; 5001 : 
; 5002 :     for (pos = 0; pos < i; pos++) {

  00100	45 33 f6	 xor	 r14d, r14d
  00103	4d 85 ed	 test	 r13, r13
  00106	0f 8e 35 01 00
	00		 jle	 $LN16@parse_envl
  0010c	0f 1f 40 00	 npad	 4
$LL18@parse_envl:

; 5003 :         key = PyList_GetItem(keys, pos);

  00110	49 8b d6	 mov	 rdx, r14
  00113	49 8b cf	 mov	 rcx, r15
  00116	e8 00 00 00 00	 call	 PyList_GetItem

; 5004 :         val = PyList_GetItem(vals, pos);

  0011b	49 8b d6	 mov	 rdx, r14
  0011e	49 8b cc	 mov	 rcx, r12
  00121	48 8b e8	 mov	 rbp, rax
  00124	e8 00 00 00 00	 call	 PyList_GetItem
  00129	48 8b f0	 mov	 rsi, rax

; 5005 :         if (!key || !val)

  0012c	48 85 ed	 test	 rbp, rbp
  0012f	0f 84 8f 01 00
	00		 je	 $error$122760
  00135	48 85 c0	 test	 rax, rax
  00138	0f 84 86 01 00
	00		 je	 $error$122760

; 5006 :             goto error;
; 5007 : 
; 5008 :         if (PyUnicode_FSConverter(key, &key2) == 0)

  0013e	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR key2$[rsp]
  00146	48 8b cd	 mov	 rcx, rbp
  00149	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  0014e	85 c0		 test	 eax, eax
  00150	0f 84 6e 01 00
	00		 je	 $error$122760

; 5009 :             goto error;
; 5010 :         if (PyUnicode_FSConverter(val, &val2) == 0) {

  00156	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR val2$[rsp]
  0015e	48 8b ce	 mov	 rcx, rsi
  00161	e8 00 00 00 00	 call	 PyUnicode_FSConverter

; 5011 :             Py_DECREF(key2);
; 5012 :             goto error;
; 5013 :         }
; 5014 : 
; 5015 : #if defined(PYOS_OS2)
; 5016 :         /* Omit Pseudo-Env Vars that Would Confuse Programs if Passed On */
; 5017 :         if (stricmp(k, "BEGINLIBPATH") != 0 && stricmp(k, "ENDLIBPATH") != 0) {
; 5018 : #endif
; 5019 :         k = PyBytes_AsString(key2);

  00166	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR key2$[rsp]
  0016e	85 c0		 test	 eax, eax
  00170	0f 84 34 01 00
	00		 je	 $LN49@parse_envl
  00176	e8 00 00 00 00	 call	 PyBytes_AsString

; 5020 :         v = PyBytes_AsString(val2);

  0017b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR val2$[rsp]
  00183	48 89 44 24 38	 mov	 QWORD PTR k$1$[rsp], rax
  00188	e8 00 00 00 00	 call	 PyBytes_AsString

; 5021 :         len = PyBytes_GET_SIZE(key2) + PyBytes_GET_SIZE(val2) + 2;

  0018d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR val2$[rsp]
  00195	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00199	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR key2$[rsp]
  001a1	48 89 44 24 30	 mov	 QWORD PTR v$1$[rsp], rax
  001a6	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]

; 5022 : 
; 5023 :         p = PyMem_NEW(char, len);

  001aa	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001b4	49 8d 6c 10 02	 lea	 rbp, QWORD PTR [r8+rdx+2]
  001b9	48 3b e8	 cmp	 rbp, rax
  001bc	0f 87 ce 00 00
	00		 ja	 $LN50@parse_envl
  001c2	e8 00 00 00 00	 call	 _Py_PXCTX
  001c7	85 c0		 test	 eax, eax
  001c9	74 0a		 je	 SHORT $LN37@parse_envl
  001cb	48 8b cd	 mov	 rcx, rbp
  001ce	e8 00 00 00 00	 call	 _PxMem_Malloc
  001d3	eb 12		 jmp	 SHORT $LN62@parse_envl
$LN37@parse_envl:
  001d5	48 85 ed	 test	 rbp, rbp
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	48 0f 45 cd	 cmovne	 rcx, rbp
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN62@parse_envl:
  001e7	48 8b f0	 mov	 rsi, rax

; 5024 :         if (p == NULL) {

  001ea	48 85 c0	 test	 rax, rax
  001ed	0f 84 9d 00 00
	00		 je	 $LN50@parse_envl

; 5029 :         }
; 5030 :         PyOS_snprintf(p, len, "%s=%s", k, v);

  001f3	48 8b 44 24 30	 mov	 rax, QWORD PTR v$1$[rsp]
  001f8	4c 8b 4c 24 38	 mov	 r9, QWORD PTR k$1$[rsp]
  001fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@
  00204	48 8b d5	 mov	 rdx, rbp
  00207	48 8b ce	 mov	 rcx, rsi
  0020a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020f	e8 00 00 00 00	 call	 PyOS_snprintf

; 5031 :         envlist[envc++] = p;

  00214	48 89 34 df	 mov	 QWORD PTR [rdi+rbx*8], rsi

; 5032 :         Py_DECREF(key2);

  00218	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR key2$[rsp]
  00220	48 ff c3	 inc	 rbx
  00223	e8 00 00 00 00	 call	 _Py_DecRef

; 5033 :         Py_DECREF(val2);

  00228	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR val2$[rsp]
  00230	e8 00 00 00 00	 call	 _Py_DecRef
  00235	49 ff c6	 inc	 r14
  00238	4d 3b f5	 cmp	 r14, r13
  0023b	0f 8c cf fe ff
	ff		 jl	 $LL18@parse_envl
$LN16@parse_envl:

; 5034 : #if defined(PYOS_OS2)
; 5035 :         }
; 5036 : #endif
; 5037 :     }
; 5038 :     Py_DECREF(vals);

  00241	49 8b cc	 mov	 rcx, r12
  00244	e8 00 00 00 00	 call	 _Py_DecRef

; 5039 :     Py_DECREF(keys);

  00249	49 8b cf	 mov	 rcx, r15
  0024c	e8 00 00 00 00	 call	 _Py_DecRef

; 5040 : 
; 5041 :     envlist[envc] = 0;
; 5042 :     *envc_ptr = envc;

  00251	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR envc_ptr$[rsp]
  00259	48 c7 04 df 00
	00 00 00	 mov	 QWORD PTR [rdi+rbx*8], 0
  00261	48 89 18	 mov	 QWORD PTR [rax], rbx

; 5043 :     return envlist;

  00264	48 8b c7	 mov	 rax, rdi
$LN60@parse_envl:
  00267	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  0026c	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00271	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00279	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  0027e	4c 8b 7c 24 40	 mov	 r15, QWORD PTR [rsp+64]
  00283	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 5052 : }

  00288	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0028c	41 5d		 pop	 r13
  0028e	5e		 pop	 rsi
  0028f	c3		 ret	 0
$LN50@parse_envl:

; 5025 :             PyErr_NoMemory();

  00290	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5026 :             Py_DECREF(key2);

  00295	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR key2$[rsp]
  0029d	e8 00 00 00 00	 call	 _Py_DecRef

; 5027 :             Py_DECREF(val2);

  002a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR val2$[rsp]
$LN49@parse_envl:
  002aa	e8 00 00 00 00	 call	 _Py_DecRef

; 5028 :             goto error;

  002af	eb 13		 jmp	 SHORT $error$122760
$LN19@parse_envl:

; 4997 :         PyErr_Format(PyExc_TypeError,
; 4998 :                      "env.keys() or env.values() is not a list");

  002b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@
  002bf	e8 00 00 00 00	 call	 PyErr_Format
$error$122760:

; 5044 : 
; 5045 : error:
; 5046 :     Py_XDECREF(keys);

  002c4	49 8b cf	 mov	 rcx, r15
  002c7	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@parse_envl:

; 5047 :     Py_XDECREF(vals);

  002cc	4d 85 e4	 test	 r12, r12
  002cf	74 08		 je	 SHORT $LN5@parse_envl
  002d1	49 8b cc	 mov	 rcx, r12
  002d4	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@parse_envl:

; 5048 :     while (--envc >= 0)

  002d9	48 ff cb	 dec	 rbx
  002dc	78 21		 js	 SHORT $LN1@parse_envl
  002de	66 90		 npad	 2
$LL2@parse_envl:

; 5049 :         PyMem_DEL(envlist[envc]);

  002e0	e8 00 00 00 00	 call	 _Py_PXCTX
  002e5	48 8b 0c df	 mov	 rcx, QWORD PTR [rdi+rbx*8]
  002e9	85 c0		 test	 eax, eax
  002eb	74 07		 je	 SHORT $LN41@parse_envl
  002ed	e8 00 00 00 00	 call	 _PxMem_Free
  002f2	eb 06		 jmp	 SHORT $LN42@parse_envl
$LN41@parse_envl:
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN42@parse_envl:

; 5048 :     while (--envc >= 0)

  002fa	48 ff cb	 dec	 rbx
  002fd	79 e1		 jns	 SHORT $LL2@parse_envl
$LN1@parse_envl:

; 5050 :     PyMem_DEL(envlist);

  002ff	e8 00 00 00 00	 call	 _Py_PXCTX
  00304	48 8b cf	 mov	 rcx, rdi
  00307	85 c0		 test	 eax, eax
  00309	74 0c		 je	 SHORT $LN43@parse_envl
  0030b	e8 00 00 00 00	 call	 _PxMem_Free

; 5051 :     return NULL;

  00310	33 c0		 xor	 eax, eax
  00312	e9 50 ff ff ff	 jmp	 $LN60@parse_envl
$LN43@parse_envl:

; 5050 :     PyMem_DEL(envlist);

  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 5051 :     return NULL;

  0031d	33 c0		 xor	 eax, eax
  0031f	e9 43 ff ff ff	 jmp	 $LN60@parse_envl
$LN52@parse_envl:

; 4988 :         PyErr_NoMemory();

  00324	e8 00 00 00 00	 call	 PyErr_NoMemory
  00329	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 4989 :         return NULL;

  0032e	33 c0		 xor	 eax, eax

; 5052 : }

  00330	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00334	41 5d		 pop	 r13
  00336	5e		 pop	 rsi
  00337	c3		 ret	 0
parse_envlist ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_arglist DD imagerel parse_arglist
	DD	imagerel parse_arglist+127
	DD	imagerel $unwind$parse_arglist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$parse_arglist DD imagerel parse_arglist+127
	DD	imagerel parse_arglist+263
	DD	imagerel $chain$2$parse_arglist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$parse_arglist DD imagerel parse_arglist+263
	DD	imagerel parse_arglist+286
	DD	imagerel $chain$4$parse_arglist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$parse_arglist DD imagerel parse_arglist+286
	DD	imagerel parse_arglist+302
	DD	imagerel $chain$5$parse_arglist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$parse_arglist DD 021H
	DD	imagerel parse_arglist
	DD	imagerel parse_arglist+127
	DD	imagerel $unwind$parse_arglist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$parse_arglist DD 060021H
	DD	0ac400H
	DD	097400H
	DD	086400H
	DD	imagerel parse_arglist
	DD	imagerel parse_arglist+127
	DD	imagerel $unwind$parse_arglist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$parse_arglist DD 061121H
	DD	0ac411H
	DD	09740aH
	DD	086405H
	DD	imagerel parse_arglist
	DD	imagerel parse_arglist+127
	DD	imagerel $unwind$parse_arglist
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_arglist DD 040901H
	DD	0d0053209H
	DD	030025003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT parse_arglist
_TEXT	SEGMENT
argv$ = 64
argc$ = 72
parse_arglist PROC					; COMDAT

; 5056 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 55		 push	 r13
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 5057 :     int i;
; 5058 :     char **argvlist = PyMem_NEW(char *, *argc+1);

  00009	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000c	4c 8b e9	 mov	 r13, rcx
  0000f	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00019	48 ff c0	 inc	 rax
  0001c	48 8b da	 mov	 rbx, rdx
  0001f	48 3b c1	 cmp	 rax, rcx
  00022	0f 87 f6 00 00
	00		 ja	 $LN21@parse_argl
  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	74 12		 je	 SHORT $LN13@parse_argl
  00031	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00034	48 8d 0c cd 08
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8+8]
  0003c	e8 00 00 00 00	 call	 _PxMem_Malloc
  00041	eb 30		 jmp	 SHORT $LN25@parse_argl
$LN13@parse_argl:
  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00050	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00058	48 3b c1	 cmp	 rax, rcx
  0005b	0f 87 bd 00 00
	00		 ja	 $LN21@parse_argl
  00061	48 85 c0	 test	 rax, rax
  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	48 0f 45 c8	 cmovne	 rcx, rax
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN25@parse_argl:
  00073	48 8b e8	 mov	 rbp, rax

; 5059 :     if (argvlist == NULL) {

  00076	48 85 c0	 test	 rax, rax
  00079	0f 84 9f 00 00
	00		 je	 $LN21@parse_argl

; 5062 :     }
; 5063 :     for (i = 0; i < *argc; i++) {

  0007f	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00084	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00089	33 ff		 xor	 edi, edi
  0008b	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  00090	48 39 3b	 cmp	 QWORD PTR [rbx], rdi
  00093	7e 4b		 jle	 SHORT $LN3@parse_argl
  00095	33 f6		 xor	 esi, esi
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL5@parse_argl:

; 5064 :         PyObject* item = PySequence_ITEM(argv, i);

  000a0	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  000a4	48 8b d6	 mov	 rdx, rsi
  000a7	49 8b cd	 mov	 rcx, r13
  000aa	4c 8b 80 c0 00
	00 00		 mov	 r8, QWORD PTR [rax+192]
  000b1	41 ff 50 18	 call	 QWORD PTR [r8+24]
  000b5	4c 8b e0	 mov	 r12, rax

; 5065 :         if (item == NULL)

  000b8	48 85 c0	 test	 rax, rax
  000bb	74 4f		 je	 SHORT $fail$122857

; 5066 :             goto fail;
; 5067 :         if (!fsconvert_strdup(item, &argvlist[i])) {

  000bd	48 8d 54 f5 00	 lea	 rdx, QWORD PTR [rbp+rsi*8]
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	e8 00 00 00 00	 call	 fsconvert_strdup

; 5069 :             goto fail;
; 5070 :         }
; 5071 :         Py_DECREF(item);

  000ca	49 8b cc	 mov	 rcx, r12
  000cd	85 c0		 test	 eax, eax
  000cf	74 36		 je	 SHORT $LN19@parse_argl
  000d1	e8 00 00 00 00	 call	 _Py_DecRef
  000d6	ff c7		 inc	 edi
  000d8	48 63 f7	 movsxd	 rsi, edi
  000db	48 3b 33	 cmp	 rsi, QWORD PTR [rbx]
  000de	7c c0		 jl	 SHORT $LL5@parse_argl
$LN3@parse_argl:

; 5072 :     }
; 5073 :     argvlist[*argc] = NULL;

  000e0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e3	48 c7 44 c5 00
	00 00 00 00	 mov	 QWORD PTR [rbp+rax*8], 0

; 5074 :     return argvlist;

  000ec	48 8b c5	 mov	 rax, rbp
$LN24@parse_argl:
  000ef	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000f4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f9	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]

; 5079 : }

  000fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00102	41 5d		 pop	 r13
  00104	5d		 pop	 rbp
  00105	5b		 pop	 rbx
  00106	c3		 ret	 0
$LN19@parse_argl:

; 5068 :             Py_DECREF(item);

  00107	e8 00 00 00 00	 call	 _Py_DecRef
$fail$122857:

; 5075 : fail:
; 5076 :     *argc = i;

  0010c	48 63 d7	 movsxd	 rdx, edi

; 5077 :     free_string_array(argvlist, *argc);

  0010f	48 8b cd	 mov	 rcx, rbp
  00112	48 89 13	 mov	 QWORD PTR [rbx], rdx
  00115	e8 00 00 00 00	 call	 free_string_array

; 5078 :     return NULL;

  0011a	33 c0		 xor	 eax, eax
  0011c	eb d1		 jmp	 SHORT $LN24@parse_argl
$LN21@parse_argl:

; 5060 :         PyErr_NoMemory();

  0011e	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5061 :         return NULL;

  00123	33 c0		 xor	 eax, eax

; 5079 : }

  00125	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00129	41 5d		 pop	 r13
  0012b	5d		 pop	 rbp
  0012c	5b		 pop	 rbx
  0012d	c3		 ret	 0
parse_arglist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@ ; `string'
PUBLIC	??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@ ; `string'
PUBLIC	??_C@_09NABGIDAP@O?$CGO?3execv?$AA@		; `string'
EXTRN	__imp_execv:PROC
EXTRN	PySequence_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_execv DD imagerel posix_execv
	DD	imagerel posix_execv+60
	DD	imagerel $unwind$posix_execv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_execv DD imagerel posix_execv+60
	DD	imagerel posix_execv+176
	DD	imagerel $chain$0$posix_execv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_execv DD imagerel posix_execv+176
	DD	imagerel posix_execv+231
	DD	imagerel $chain$3$posix_execv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix_execv DD imagerel posix_execv+231
	DD	imagerel posix_execv+286
	DD	imagerel $chain$5$posix_execv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix_execv DD 040021H
	DD	087400H
	DD	0a3400H
	DD	imagerel posix_execv
	DD	imagerel posix_execv+60
	DD	imagerel $unwind$posix_execv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_execv DD 040f21H
	DD	0a340fH
	DD	087400H
	DD	imagerel posix_execv
	DD	imagerel posix_execv+60
	DD	imagerel $unwind$posix_execv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_execv DD 020521H
	DD	087405H
	DD	imagerel posix_execv
	DD	imagerel posix_execv+60
	DD	imagerel $unwind$posix_execv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_execv DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@
CONST	SEGMENT
??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@ DB 'e'
	DB	'xecv() arg 2 must not be empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@
CONST	SEGMENT
??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@ DB 'exe'
	DB	'cv() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NABGIDAP@O?$CGO?3execv?$AA@
CONST	SEGMENT
??_C@_09NABGIDAP@O?$CGO?3execv?$AA@ DB 'O&O:execv', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_execv
_TEXT	SEGMENT
argc$ = 48
self$ = 80
args$ = 88
opath$ = 96
argv$ = 104
posix_execv PROC					; COMDAT

; 5092 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 5093 :     PyObject *opath;
; 5094 :     char *path;
; 5095 :     PyObject *argv;
; 5096 :     char **argvlist;
; 5097 :     Py_ssize_t argc;
; 5098 : 
; 5099 :     /* execv has two arguments: (path, argv), where
; 5100 :        argv is a list or tuple of strings. */
; 5101 : 
; 5102 :     if (!PyArg_ParseTuple(args, "O&O:execv",
; 5103 :                           PyUnicode_FSConverter,
; 5104 :                           &opath, &argv))

  00007	48 8d 4c 24 68	 lea	 rcx, QWORD PTR argv$[rsp]
  0000c	4c 8d 4c 24 60	 lea	 r9, QWORD PTR opath$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_FSConverter
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NABGIDAP@O?$CGO?3execv?$AA@
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002c	85 c0		 test	 eax, eax
  0002e	75 07		 jne	 SHORT $LN4@posix_exec

; 5105 :         return NULL;

  00030	33 c0		 xor	 eax, eax

; 5133 : }

  00032	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00036	c3		 ret	 0
$LN4@posix_exec:

; 5106 :     path = PyBytes_AsString(opath);

  00037	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opath$[rsp]
  0003c	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00041	e8 00 00 00 00	 call	 PyBytes_AsString

; 5107 :     if (!PyList_Check(argv) && !PyTuple_Check(argv)) {

  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR argv$[rsp]
  0004b	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	8b 91 00 01 00
	00		 mov	 edx, DWORD PTR [rcx+256]
  00058	0f ba e2 19	 bt	 edx, 25
  0005c	72 16		 jb	 SHORT $LN3@posix_exec
  0005e	0f ba e2 1a	 bt	 edx, 26
  00062	72 10		 jb	 SHORT $LN3@posix_exec

; 5108 :         PyErr_SetString(PyExc_TypeError,
; 5109 :                         "execv() arg 2 must be a tuple or list");

  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@

; 5110 :         Py_DECREF(opath);
; 5111 :         return NULL;

  00072	eb 21		 jmp	 SHORT $LN9@posix_exec
$LN3@posix_exec:

; 5112 :     }
; 5113 :     argc = PySequence_Size(argv);

  00074	49 8b c8	 mov	 rcx, r8
  00077	e8 00 00 00 00	 call	 PySequence_Size
  0007c	48 89 44 24 30	 mov	 QWORD PTR argc$[rsp], rax

; 5114 :     if (argc < 1) {

  00081	48 83 f8 01	 cmp	 rax, 1
  00085	7d 29		 jge	 SHORT $LN2@posix_exec

; 5115 :         PyErr_SetString(PyExc_ValueError, "execv() arg 2 must not be empty");

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@
$LN9@posix_exec:
  00095	e8 00 00 00 00	 call	 PyErr_SetString

; 5116 :         Py_DECREF(opath);

  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opath$[rsp]
  0009f	e8 00 00 00 00	 call	 _Py_DecRef
  000a4	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5117 :         return NULL;

  000a9	33 c0		 xor	 eax, eax

; 5133 : }

  000ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000af	c3		 ret	 0
$LN2@posix_exec:

; 5118 :     }
; 5119 : 
; 5120 :     argvlist = parse_arglist(argv, &argc);

  000b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  000b5	48 8d 54 24 30	 lea	 rdx, QWORD PTR argc$[rsp]
  000ba	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  000bf	e8 00 00 00 00	 call	 parse_arglist
  000c4	48 8b d8	 mov	 rbx, rax

; 5121 :     if (argvlist == NULL) {

  000c7	48 85 c0	 test	 rax, rax
  000ca	75 1b		 jne	 SHORT $LN1@posix_exec

; 5122 :         Py_DECREF(opath);

  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opath$[rsp]
  000d1	e8 00 00 00 00	 call	 _Py_DecRef
  000d6	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000db	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5123 :         return NULL;

  000e0	33 c0		 xor	 eax, eax

; 5133 : }

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
$LN1@posix_exec:

; 5124 :     }
; 5125 : 
; 5126 :     execv(path, argvlist);

  000e7	48 8b d0	 mov	 rdx, rax
  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_execv

; 5127 : 
; 5128 :     /* If we get here it's definitely an error */
; 5129 : 
; 5130 :     free_string_array(argvlist, argc);

  000f3	48 8b 54 24 30	 mov	 rdx, QWORD PTR argc$[rsp]
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 free_string_array

; 5131 :     Py_DECREF(opath);

  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR opath$[rsp]
  00105	e8 00 00 00 00	 call	 _Py_DecRef

; 5132 :     return posix_error();

  0010a	e8 00 00 00 00	 call	 posix_error
  0010f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00114	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 5133 : }

  00119	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011d	c3		 ret	 0
posix_execv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@ ; `string'
PUBLIC	??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@ ; `string'
PUBLIC	??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@		; `string'
EXTRN	__imp_execve:PROC
EXTRN	PyMapping_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_execve DD imagerel posix_execve
	DD	imagerel posix_execve+237
	DD	imagerel $unwind$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_execve DD imagerel posix_execve+237
	DD	imagerel posix_execve+270
	DD	imagerel $chain$0$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_execve DD imagerel posix_execve+270
	DD	imagerel posix_execve+301
	DD	imagerel $chain$1$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_execve DD imagerel posix_execve+301
	DD	imagerel posix_execve+387
	DD	imagerel $chain$2$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_execve DD imagerel posix_execve+387
	DD	imagerel posix_execve+420
	DD	imagerel $chain$3$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix_execve DD imagerel posix_execve+420
	DD	imagerel posix_execve+428
	DD	imagerel $chain$4$posix_execve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix_execve DD imagerel posix_execve+428
	DD	imagerel posix_execve+448
	DD	imagerel $chain$5$posix_execve
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix_execve DD 021H
	DD	imagerel posix_execve
	DD	imagerel posix_execve+237
	DD	imagerel $unwind$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix_execve DD 021H
	DD	imagerel posix_execve+237
	DD	imagerel posix_execve+270
	DD	imagerel $chain$0$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_execve DD 021H
	DD	imagerel posix_execve+270
	DD	imagerel posix_execve+301
	DD	imagerel $chain$1$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_execve DD 020821H
	DD	0183408H
	DD	imagerel posix_execve+270
	DD	imagerel posix_execve+301
	DD	imagerel $chain$1$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_execve DD 020821H
	DD	01a7408H
	DD	imagerel posix_execve+237
	DD	imagerel posix_execve+270
	DD	imagerel $chain$0$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_execve DD 020821H
	DD	0196408H
	DD	imagerel posix_execve
	DD	imagerel posix_execve+237
	DD	imagerel $unwind$posix_execve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_execve DD 030e01H
	DD	016010eH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@
CONST	SEGMENT
??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@ DB 'execve: en'
	DB	'vironment must be a mapping object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@
CONST	SEGMENT
??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@ DB 'execve: '
	DB	'argv must be a tuple or list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@
CONST	SEGMENT
??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@ DB 'O&OO:execve', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_execve
_TEXT	SEGMENT
env$ = 64
argc$ = 72
envc$ = 80
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
argv$ = 216
posix_execve PROC					; COMDAT

; 5149 : {

  00000	40 55		 push	 rbp
  00002	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00007	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 5150 :     path_t path;
; 5151 :     PyObject *argv, *env;
; 5152 :     char **argvlist = NULL;
; 5153 :     char **envlist;
; 5154 :     Py_ssize_t argc, envc;
; 5155 :     static char *keywords[] = {"path", "argv", "environment", NULL};
; 5156 : 
; 5157 :     /* execve has three arguments: (path, argv, env), where
; 5158 :        argv is a list or tuple of strings and env is a dictionary
; 5159 :        like posix.environ. */
; 5160 : 
; 5161 :     memset(&path, 0, sizeof(path));

  0000e	33 c9		 xor	 ecx, ecx
  00010	49 8b c0	 mov	 rax, r8
  00013	4c 8b d2	 mov	 r10, rdx
  00016	48 89 4d 07	 mov	 QWORD PTR path$[rbp-89], rcx
  0001a	48 89 4d 0f	 mov	 QWORD PTR path$[rbp-81], rcx
  0001e	48 89 4d 17	 mov	 QWORD PTR path$[rbp-73], rcx
  00022	48 89 4d 1f	 mov	 QWORD PTR path$[rbp-65], rcx
  00026	48 89 4d 27	 mov	 QWORD PTR path$[rbp-57], rcx
  0002a	48 89 4d 2f	 mov	 QWORD PTR path$[rbp-49], rcx
  0002e	48 89 4d 37	 mov	 QWORD PTR path$[rbp-41], rcx
  00032	48 89 4d 3f	 mov	 QWORD PTR path$[rbp-33], rcx
  00036	48 89 4d 47	 mov	 QWORD PTR path$[rbp-25], rcx

; 5162 : #ifdef HAVE_FEXECVE
; 5163 :     path.allow_fd = 1;
; 5164 : #endif
; 5165 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&OO:execve", keywords,
; 5166 :                           path_converter, &path,
; 5167 :                           &argv, &env
; 5168 :                           ))

  0003a	48 8d 4d e7	 lea	 rcx, QWORD PTR env$[rbp-89]
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_execve@@9@9
  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@
  0004c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00051	48 8d 4d 7f	 lea	 rcx, QWORD PTR argv$[rbp-89]
  00055	48 8b d0	 mov	 rdx, rax
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  00061	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  0006d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00072	49 8b ca	 mov	 rcx, r10
  00075	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007a	85 c0		 test	 eax, eax

; 5169 :         return NULL;

  0007c	0f 84 33 01 00
	00		 je	 $LN17@posix_exec@2

; 5170 : 
; 5171 :     if (!PyList_Check(argv) && !PyTuple_Check(argv)) {

  00082	48 8b 55 7f	 mov	 rdx, QWORD PTR argv$[rbp-89]
  00086	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  0008a	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  00090	0f ba e1 19	 bt	 ecx, 25
  00094	72 1e		 jb	 SHORT $LN7@posix_exec@2
  00096	0f ba e1 1a	 bt	 ecx, 26
  0009a	72 18		 jb	 SHORT $LN7@posix_exec@2

; 5172 :         PyErr_SetString(PyExc_TypeError,
; 5173 :                         "execve: argv must be a tuple or list");

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@
  000aa	e8 00 00 00 00	 call	 PyErr_SetString

; 5174 :         goto fail;

  000af	e9 f8 00 00 00	 jmp	 $LN1@posix_exec@2
$LN7@posix_exec@2:

; 5175 :     }
; 5176 :     argc = PySequence_Size(argv);

  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	e8 00 00 00 00	 call	 PySequence_Size

; 5177 :     if (!PyMapping_Check(env)) {

  000bc	48 8b 4d e7	 mov	 rcx, QWORD PTR env$[rbp-89]
  000c0	48 89 45 ef	 mov	 QWORD PTR argc$[rbp-89], rax
  000c4	e8 00 00 00 00	 call	 PyMapping_Check
  000c9	85 c0		 test	 eax, eax
  000cb	75 18		 jne	 SHORT $LN6@posix_exec@2

; 5178 :         PyErr_SetString(PyExc_TypeError,
; 5179 :                         "execve: environment must be a mapping object");

  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@
  000db	e8 00 00 00 00	 call	 PyErr_SetString

; 5180 :         goto fail;

  000e0	e9 c7 00 00 00	 jmp	 $LN1@posix_exec@2
$LN6@posix_exec@2:

; 5181 :     }
; 5182 : 
; 5183 :     argvlist = parse_arglist(argv, &argc);

  000e5	48 8b 4d 7f	 mov	 rcx, QWORD PTR argv$[rbp-89]
  000e9	48 8d 55 ef	 lea	 rdx, QWORD PTR argc$[rbp-89]
  000ed	48 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rsi
  000f5	e8 00 00 00 00	 call	 parse_arglist
  000fa	48 8b f0	 mov	 rsi, rax

; 5184 :     if (argvlist == NULL) {

  000fd	48 85 c0	 test	 rax, rax
  00100	0f 84 9e 00 00
	00		 je	 $LN16@posix_exec@2

; 5185 :         goto fail;
; 5186 :     }
; 5187 : 
; 5188 :     envlist = parse_envlist(env, &envc);

  00106	48 8b 4d e7	 mov	 rcx, QWORD PTR env$[rbp-89]
  0010a	48 8d 55 f7	 lea	 rdx, QWORD PTR envc$[rbp-89]
  0010e	48 89 bc 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rdi
  00116	e8 00 00 00 00	 call	 parse_envlist
  0011b	48 8b f8	 mov	 rdi, rax

; 5189 :     if (envlist == NULL)

  0011e	48 85 c0	 test	 rax, rax
  00121	74 6d		 je	 SHORT $fail$122922

; 5190 :         goto fail;
; 5191 : 
; 5192 : #ifdef HAVE_FEXECVE
; 5193 :     if (path.fd > -1)
; 5194 :         fexecve(path.fd, argvlist, envlist);
; 5195 :     else
; 5196 : #endif
; 5197 :         execve(path.narrow, argvlist, envlist);

  00123	48 8b 4d 27	 mov	 rcx, QWORD PTR path$[rbp-57]
  00127	4c 8b c0	 mov	 r8, rax
  0012a	48 8b d6	 mov	 rdx, rsi
  0012d	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_execve

; 5198 : 
; 5199 :     /* If we get here it's definitely an error */
; 5200 : 
; 5201 :     path_posix_error("execve", &path);

  0013b	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  0013f	e8 00 00 00 00	 call	 path_posix_error

; 5202 : 
; 5203 :     while (--envc >= 0)

  00144	48 8b 5d f7	 mov	 rbx, QWORD PTR envc$[rbp-89]
  00148	48 ff cb	 dec	 rbx
  0014b	78 22		 js	 SHORT $LN2@posix_exec@2
  0014d	0f 1f 00	 npad	 3
$LL3@posix_exec@2:

; 5204 :         PyMem_DEL(envlist[envc]);

  00150	e8 00 00 00 00	 call	 _Py_PXCTX
  00155	48 8b 0c df	 mov	 rcx, QWORD PTR [rdi+rbx*8]
  00159	85 c0		 test	 eax, eax
  0015b	74 07		 je	 SHORT $LN11@posix_exec@2
  0015d	e8 00 00 00 00	 call	 _PxMem_Free
  00162	eb 06		 jmp	 SHORT $LN12@posix_exec@2
$LN11@posix_exec@2:
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@posix_exec@2:

; 5202 : 
; 5203 :     while (--envc >= 0)

  0016a	48 ff cb	 dec	 rbx
  0016d	79 e1		 jns	 SHORT $LL3@posix_exec@2
$LN2@posix_exec@2:

; 5205 :     PyMem_DEL(envlist);

  0016f	e8 00 00 00 00	 call	 _Py_PXCTX
  00174	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  0017c	48 8b cf	 mov	 rcx, rdi
  0017f	85 c0		 test	 eax, eax
  00181	74 07		 je	 SHORT $LN13@posix_exec@2
  00183	e8 00 00 00 00	 call	 _PxMem_Free
  00188	eb 06		 jmp	 SHORT $fail$122922
$LN13@posix_exec@2:
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$fail$122922:

; 5206 :   fail:
; 5207 :     if (argvlist)
; 5208 :         free_string_array(argvlist, argc);

  00190	48 8b 55 ef	 mov	 rdx, QWORD PTR argc$[rbp-89]
  00194	48 8b ce	 mov	 rcx, rsi
  00197	e8 00 00 00 00	 call	 free_string_array
  0019c	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+208]
$LN16@posix_exec@2:
  001a4	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]
$LN1@posix_exec@2:

; 5209 :     path_cleanup(&path);

  001ac	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  001b0	e8 00 00 00 00	 call	 path_cleanup
$LN17@posix_exec@2:

; 5210 :     return NULL;

  001b5	33 c0		 xor	 eax, eax

; 5211 : }

  001b7	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  001be	5d		 pop	 rbp
  001bf	c3		 ret	 0
posix_execve ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@ ; `string'
PUBLIC	??_C@_01OCOKONAJ@L?$AA@				; `string'
PUBLIC	??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@ ; `string'
PUBLIC	??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@		; `string'
EXTRN	__imp__spawnv:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_spawnv DD imagerel posix_spawnv
	DD	imagerel posix_spawnv+71
	DD	imagerel $unwind$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_spawnv DD imagerel posix_spawnv+71
	DD	imagerel posix_spawnv+266
	DD	imagerel $chain$3$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix_spawnv DD imagerel posix_spawnv+266
	DD	imagerel posix_spawnv+449
	DD	imagerel $chain$5$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$posix_spawnv DD imagerel posix_spawnv+449
	DD	imagerel posix_spawnv+474
	DD	imagerel $chain$6$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$posix_spawnv DD imagerel posix_spawnv+474
	DD	imagerel posix_spawnv+538
	DD	imagerel $chain$8$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$posix_spawnv DD imagerel posix_spawnv+538
	DD	imagerel posix_spawnv+558
	DD	imagerel $chain$9$posix_spawnv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$posix_spawnv DD imagerel posix_spawnv+558
	DD	imagerel posix_spawnv+612
	DD	imagerel $chain$10$posix_spawnv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$posix_spawnv DD 060021H
	DD	08d400H
	DD	09c400H
	DD	0b6400H
	DD	imagerel posix_spawnv
	DD	imagerel posix_spawnv+71
	DD	imagerel $unwind$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$posix_spawnv DD 080021H
	DD	08d400H
	DD	09c400H
	DD	0b6400H
	DD	0c5400H
	DD	imagerel posix_spawnv
	DD	imagerel posix_spawnv+71
	DD	imagerel $unwind$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$posix_spawnv DD 0c0021H
	DD	08d400H
	DD	09c400H
	DD	0a7400H
	DD	0b6400H
	DD	0c5400H
	DD	0e3400H
	DD	imagerel posix_spawnv
	DD	imagerel posix_spawnv+71
	DD	imagerel $unwind$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$posix_spawnv DD 021H
	DD	imagerel posix_spawnv+71
	DD	imagerel posix_spawnv+266
	DD	imagerel $chain$3$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix_spawnv DD 040a21H
	DD	0a740aH
	DD	0e3405H
	DD	imagerel posix_spawnv+71
	DD	imagerel posix_spawnv+266
	DD	imagerel $chain$3$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_spawnv DD 086921H
	DD	0c5469H
	DD	08d40fH
	DD	09c40aH
	DD	0b6405H
	DD	imagerel posix_spawnv
	DD	imagerel posix_spawnv+71
	DD	imagerel $unwind$posix_spawnv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_spawnv DD 010701H
	DD	0c207H
xdata	ENDS
;	COMDAT ??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@
CONST	SEGMENT
??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@ DB 'spa'
	DB	'wnv() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L?$AA@
CONST	SEGMENT
??_C@_01OCOKONAJ@L?$AA@ DB 'L', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@
CONST	SEGMENT
??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@ DB 'spawn'
	DB	'v() arg 2 must contain only strings', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@
CONST	SEGMENT
??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@ DB 'iO&O:spawnv', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_spawnv
_TEXT	SEGMENT
argv$ = 48
self$ = 112
args$ = 120
mode$ = 128
opath$ = 136
posix_spawnv PROC					; COMDAT

; 5226 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5227 :     PyObject *opath;
; 5228 :     char *path;
; 5229 :     PyObject *argv;
; 5230 :     char **argvlist;
; 5231 :     int mode, i;
; 5232 :     Py_ssize_t argc;
; 5233 :     Py_intptr_t spawnval;
; 5234 :     PyObject *(*getitem)(PyObject *, Py_ssize_t);
; 5235 : 
; 5236 :     /* spawnv has three arguments: (mode, path, argv), where
; 5237 :        argv is a list or tuple of strings. */
; 5238 : 
; 5239 :     if (!PyArg_ParseTuple(args, "iO&O:spawnv", &mode,
; 5240 :                           PyUnicode_FSConverter,
; 5241 :                           &opath, &argv))

  00007	49 8d 4b c8	 lea	 rcx, QWORD PTR [r11-56]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyUnicode_FSConverter
  00015	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00019	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0001d	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00021	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN13@posix_spaw

; 5242 :         return NULL;

  00038	33 c0		 xor	 eax, eax

; 5300 : #endif
; 5301 : }

  0003a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0003e	c3		 ret	 0
$LN13@posix_spaw:

; 5243 :     path = PyBytes_AsString(opath);

  0003f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  00047	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0004c	4c 89 64 24 48	 mov	 QWORD PTR [rsp+72], r12
  00051	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13
  00056	e8 00 00 00 00	 call	 PyBytes_AsString

; 5244 :     if (PyList_Check(argv)) {

  0005b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argv$[rsp]
  00060	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00064	4c 8b e8	 mov	 r13, rax
  00067	44 8b 82 00 01
	00 00		 mov	 r8d, DWORD PTR [rdx+256]
  0006e	41 0f ba e0 19	 bt	 r8d, 25
  00073	73 0e		 jae	 SHORT $LN12@posix_spaw

; 5245 :         argc = PyList_Size(argv);

  00075	e8 00 00 00 00	 call	 PyList_Size

; 5246 :         getitem = PyList_GetItem;

  0007a	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyList_GetItem
  00081	eb 17		 jmp	 SHORT $LN34@posix_spaw
$LN12@posix_spaw:

; 5247 :     }
; 5248 :     else if (PyTuple_Check(argv)) {

  00083	41 0f ba e0 1a	 bt	 r8d, 26
  00088	0f 83 a0 01 00
	00		 jae	 $LN10@posix_spaw

; 5249 :         argc = PyTuple_Size(argv);

  0008e	e8 00 00 00 00	 call	 PyTuple_Size

; 5250 :         getitem = PyTuple_GetItem;

  00093	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyTuple_GetItem
$LN34@posix_spaw:

; 5257 :     }
; 5258 : 
; 5259 :     argvlist = PyMem_NEW(char *, argc+1);

  0009a	48 8b f0	 mov	 rsi, rax
  0009d	48 8d 40 01	 lea	 rax, QWORD PTR [rax+1]
  000a1	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  000ab	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  000b0	48 3b c1	 cmp	 rax, rcx
  000b3	0f 87 61 01 00
	00		 ja	 $LN27@posix_spaw
  000b9	e8 00 00 00 00	 call	 _Py_PXCTX
  000be	85 c0		 test	 eax, eax
  000c0	74 0f		 je	 SHORT $LN20@posix_spaw
  000c2	48 8d 0c f5 08
	00 00 00	 lea	 rcx, QWORD PTR [rsi*8+8]
  000ca	e8 00 00 00 00	 call	 _PxMem_Malloc
  000cf	eb 2d		 jmp	 SHORT $LN35@posix_spaw
$LN20@posix_spaw:
  000d1	48 8d 04 f5 08
	00 00 00	 lea	 rax, QWORD PTR [rsi*8+8]
  000d9	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  000e3	48 3b c1	 cmp	 rax, rcx
  000e6	0f 87 2e 01 00
	00		 ja	 $LN27@posix_spaw
  000ec	48 85 c0	 test	 rax, rax
  000ef	b9 01 00 00 00	 mov	 ecx, 1
  000f4	48 0f 45 c8	 cmovne	 rcx, rax
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN35@posix_spaw:
  000fe	48 8b e8	 mov	 rbp, rax

; 5260 :     if (argvlist == NULL) {

  00101	48 85 c0	 test	 rax, rax
  00104	0f 84 10 01 00
	00		 je	 $LN27@posix_spaw

; 5263 :     }
; 5264 :     for (i = 0; i < argc; i++) {

  0010a	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  0010f	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00114	33 ff		 xor	 edi, edi
  00116	48 85 f6	 test	 rsi, rsi
  00119	7e 32		 jle	 SHORT $LN5@posix_spaw
  0011b	33 c0		 xor	 eax, eax
  0011d	0f 1f 00	 npad	 3
$LL7@posix_spaw:

; 5265 :         if (!fsconvert_strdup((*getitem)(argv, i),
; 5266 :                               &argvlist[i])) {

  00120	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argv$[rsp]
  00125	48 8b d0	 mov	 rdx, rax
  00128	48 8d 5c c5 00	 lea	 rbx, QWORD PTR [rbp+rax*8]
  0012d	41 ff d4	 call	 r12
  00130	48 8b d3	 mov	 rdx, rbx
  00133	48 8b c8	 mov	 rcx, rax
  00136	e8 00 00 00 00	 call	 fsconvert_strdup
  0013b	85 c0		 test	 eax, eax
  0013d	0f 84 97 00 00
	00		 je	 $LN25@posix_spaw

; 5263 :     }
; 5264 :     for (i = 0; i < argc; i++) {

  00143	ff c7		 inc	 edi
  00145	48 63 c7	 movsxd	 rax, edi
  00148	48 3b c6	 cmp	 rax, rsi
  0014b	7c d3		 jl	 SHORT $LL7@posix_spaw
$LN5@posix_spaw:

; 5273 :         }
; 5274 :     }
; 5275 :     argvlist[argc] = NULL;

  0014d	48 c7 44 f5 00
	00 00 00 00	 mov	 QWORD PTR [rbp+rsi*8], 0

; 5276 : 
; 5277 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 5278 :     Py_BEGIN_ALLOW_THREADS
; 5279 :     spawnval = spawnv(mode, path, argvlist);
; 5280 :     Py_END_ALLOW_THREADS
; 5281 : #else
; 5282 :     if (mode == _OLD_P_OVERLAY)

  00156	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  0015d	b9 02 00 00 00	 mov	 ecx, 2
  00162	3b c1		 cmp	 eax, ecx
  00164	0f 44 c1	 cmove	 eax, ecx
  00167	89 84 24 80 00
	00 00		 mov	 DWORD PTR mode$[rsp], eax

; 5283 :         mode = _P_OVERLAY;
; 5284 : 
; 5285 :     Py_BEGIN_ALLOW_THREADS

  0016e	e8 00 00 00 00	 call	 PyEval_SaveThread

; 5286 :     spawnval = _spawnv(mode, path, argvlist);

  00173	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR mode$[rsp]
  0017a	4c 8b c5	 mov	 r8, rbp
  0017d	49 8b d5	 mov	 rdx, r13
  00180	48 8b d8	 mov	 rbx, rax
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__spawnv

; 5287 :     Py_END_ALLOW_THREADS

  00189	48 8b cb	 mov	 rcx, rbx
  0018c	48 8b f8	 mov	 rdi, rax
  0018f	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 5288 : #endif
; 5289 : 
; 5290 :     free_string_array(argvlist, argc);

  00194	48 8b d6	 mov	 rdx, rsi
  00197	48 8b cd	 mov	 rcx, rbp
  0019a	e8 00 00 00 00	 call	 free_string_array

; 5291 :     Py_DECREF(opath);

  0019f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  001a7	e8 00 00 00 00	 call	 _Py_DecRef

; 5292 : 
; 5293 :     if (spawnval == -1)

  001ac	48 83 ff ff	 cmp	 rdi, -1
  001b0	75 57		 jne	 SHORT $LN2@posix_spaw

; 5294 :         return posix_error();

  001b2	e8 00 00 00 00	 call	 posix_error
$LN33@posix_spaw:
  001b7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  001bc	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
$LN31@posix_spaw:
  001c1	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  001c6	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001cb	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  001d0	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]

; 5300 : #endif
; 5301 : }

  001d5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d9	c3		 ret	 0
$LN25@posix_spaw:

; 5267 :             free_string_array(argvlist, i);

  001da	48 63 d7	 movsxd	 rdx, edi
  001dd	48 8b cd	 mov	 rcx, rbp
  001e0	e8 00 00 00 00	 call	 free_string_array

; 5268 :             PyErr_SetString(
; 5269 :                 PyExc_TypeError,
; 5270 :                 "spawnv() arg 2 must contain only strings");

  001e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@
  001f3	e8 00 00 00 00	 call	 PyErr_SetString

; 5271 :             Py_DECREF(opath);

  001f8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 5272 :             return NULL;

  00205	33 c0		 xor	 eax, eax
  00207	eb ae		 jmp	 SHORT $LN33@posix_spaw
$LN2@posix_spaw:

; 5295 :     else
; 5296 : #if SIZEOF_LONG == SIZEOF_VOID_P
; 5297 :         return Py_BuildValue("l", (long) spawnval);
; 5298 : #else
; 5299 :         return Py_BuildValue("L", (PY_LONG_LONG) spawnval);

  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OCOKONAJ@L?$AA@
  00210	48 8b d7	 mov	 rdx, rdi
  00213	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00218	eb 9d		 jmp	 SHORT $LN33@posix_spaw
$LN27@posix_spaw:

; 5261 :         Py_DECREF(opath);

  0021a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  00222	e8 00 00 00 00	 call	 _Py_DecRef

; 5262 :         return PyErr_NoMemory();

  00227	e8 00 00 00 00	 call	 PyErr_NoMemory
  0022c	eb 93		 jmp	 SHORT $LN31@posix_spaw
$LN10@posix_spaw:

; 5251 :     }
; 5252 :     else {
; 5253 :         PyErr_SetString(PyExc_TypeError,
; 5254 :                         "spawnv() arg 2 must be a tuple or list");

  0022e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00235	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@
  0023c	e8 00 00 00 00	 call	 PyErr_SetString

; 5255 :         Py_DECREF(opath);

  00241	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  00249	e8 00 00 00 00	 call	 _Py_DecRef
  0024e	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00253	4c 8b 64 24 48	 mov	 r12, QWORD PTR [rsp+72]
  00258	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]

; 5256 :         return NULL;

  0025d	33 c0		 xor	 eax, eax

; 5300 : #endif
; 5301 : }

  0025f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00263	c3		 ret	 0
posix_spawnv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@ ; `string'
PUBLIC	??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@ ; `string'
PUBLIC	??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@	; `string'
EXTRN	__imp__spawnve:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_spawnve DD imagerel posix_spawnve
	DD	imagerel posix_spawnve+319
	DD	imagerel $unwind$posix_spawnve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$posix_spawnve DD imagerel posix_spawnve+319
	DD	imagerel posix_spawnve+623
	DD	imagerel $chain$5$posix_spawnve
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$posix_spawnve DD imagerel posix_spawnve+623
	DD	imagerel posix_spawnve+698
	DD	imagerel $chain$6$posix_spawnve
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$posix_spawnve DD 021H
	DD	imagerel posix_spawnve
	DD	imagerel posix_spawnve+319
	DD	imagerel $unwind$posix_spawnve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$posix_spawnve DD 040a21H
	DD	0e740aH
	DD	0f6405H
	DD	imagerel posix_spawnve
	DD	imagerel posix_spawnve+319
	DD	imagerel $unwind$posix_spawnve
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_spawnve DD 0a7301H
	DD	0ce473H
	DD	0dc46eH
	DD	0135469H
	DD	0123461H
	DD	0d005f20cH
xdata	ENDS
;	COMDAT ??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@
CONST	SEGMENT
??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@ DB 'spa'
	DB	'wnve() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@
CONST	SEGMENT
??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@ DB 'spaw'
	DB	'nve() arg 3 must be a mapping object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@
CONST	SEGMENT
??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@ DB 'iO&OO:spawnve', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_spawnve
_TEXT	SEGMENT
env$ = 64
opath$ = 72
envc$ = 80
self$ = 144
args$ = 152
mode$ = 160
argv$ = 168
posix_spawnve PROC					; COMDAT

; 5315 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	41 55		 push	 r13
  00005	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 5316 :     PyObject *opath;
; 5317 :     char *path;
; 5318 :     PyObject *argv, *env;
; 5319 :     char **argvlist;
; 5320 :     char **envlist;
; 5321 :     PyObject *res = NULL;
; 5322 :     int mode;
; 5323 :     Py_ssize_t argc, i, envc;
; 5324 :     Py_intptr_t spawnval;
; 5325 :     PyObject *(*getitem)(PyObject *, Py_ssize_t);
; 5326 :     Py_ssize_t lastarg = 0;
; 5327 : 
; 5328 :     /* spawnve has four arguments: (mode, path, argv, env), where
; 5329 :        argv is a list or tuple of strings and env is a dictionary
; 5330 :        like posix.environ. */
; 5331 : 
; 5332 :     if (!PyArg_ParseTuple(args, "iO&OO:spawnve", &mode,
; 5333 :                           PyUnicode_FSConverter,
; 5334 :                           &opath, &argv, &env))

  0000c	49 8d 4b b8	 lea	 rcx, QWORD PTR [r11-72]
  00010	48 8b c2	 mov	 rax, rdx
  00013	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyUnicode_FSConverter
  0001a	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  0001e	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00022	4d 8d 43 18	 lea	 r8, QWORD PTR [r11+24]
  00026	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  0002a	49 8d 4b c0	 lea	 rcx, QWORD PTR [r11-64]
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@
  00035	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00039	48 8b c8	 mov	 rcx, rax
  0003c	45 33 ed	 xor	 r13d, r13d
  0003f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00044	85 c0		 test	 eax, eax
  00046	75 0c		 jne	 SHORT $LN17@posix_spaw@2

; 5335 :         return NULL;

  00048	33 c0		 xor	 eax, eax

; 5406 : }

  0004a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00051	41 5d		 pop	 r13
  00053	c3		 ret	 0
$LN17@posix_spaw@2:

; 5336 :     path = PyBytes_AsString(opath);

  00054	48 8b 4c 24 48	 mov	 rcx, QWORD PTR opath$[rsp]
  00059	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00061	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  00069	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0006e	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00073	e8 00 00 00 00	 call	 PyBytes_AsString

; 5337 :     if (PyList_Check(argv)) {

  00078	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00080	4c 8b f0	 mov	 r14, rax
  00083	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00087	44 8b 82 00 01
	00 00		 mov	 r8d, DWORD PTR [rdx+256]
  0008e	41 0f ba e0 19	 bt	 r8d, 25
  00093	73 0e		 jae	 SHORT $LN16@posix_spaw@2

; 5338 :         argc = PyList_Size(argv);

  00095	e8 00 00 00 00	 call	 PyList_Size

; 5339 :         getitem = PyList_GetItem;

  0009a	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyList_GetItem
  000a1	eb 17		 jmp	 SHORT $LN37@posix_spaw@2
$LN16@posix_spaw@2:

; 5340 :     }
; 5341 :     else if (PyTuple_Check(argv)) {

  000a3	41 0f ba e0 1a	 bt	 r8d, 26
  000a8	0f 83 c8 01 00
	00		 jae	 $LN14@posix_spaw@2

; 5342 :         argc = PyTuple_Size(argv);

  000ae	e8 00 00 00 00	 call	 PyTuple_Size

; 5343 :         getitem = PyTuple_GetItem;

  000b3	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyTuple_GetItem
$LN37@posix_spaw@2:

; 5348 :         goto fail_0;
; 5349 :     }
; 5350 :     if (!PyMapping_Check(env)) {

  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR env$[rsp]
  000bf	48 8b d8	 mov	 rbx, rax
  000c2	e8 00 00 00 00	 call	 PyMapping_Check
  000c7	85 c0		 test	 eax, eax
  000c9	75 0c		 jne	 SHORT $LN12@posix_spaw@2

; 5351 :         PyErr_SetString(PyExc_TypeError,
; 5352 :                         "spawnve() arg 3 must be a mapping object");

  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@

; 5353 :         goto fail_0;

  000d2	e9 a6 01 00 00	 jmp	 $LN38@posix_spaw@2
$LN12@posix_spaw@2:

; 5354 :     }
; 5355 : 
; 5356 :     argvlist = PyMem_NEW(char *, argc+1);

  000d7	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
  000db	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  000e5	48 3b c1	 cmp	 rax, rcx
  000e8	0f 87 81 01 00
	00		 ja	 $LN36@posix_spaw@2
  000ee	e8 00 00 00 00	 call	 _Py_PXCTX
  000f3	85 c0		 test	 eax, eax
  000f5	74 0f		 je	 SHORT $LN24@posix_spaw@2
  000f7	48 8d 0c dd 08
	00 00 00	 lea	 rcx, QWORD PTR [rbx*8+8]
  000ff	e8 00 00 00 00	 call	 _PxMem_Malloc
  00104	eb 2d		 jmp	 SHORT $LN39@posix_spaw@2
$LN24@posix_spaw@2:
  00106	48 8d 04 dd 08
	00 00 00	 lea	 rax, QWORD PTR [rbx*8+8]
  0010e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00118	48 3b c1	 cmp	 rax, rcx
  0011b	0f 87 4e 01 00
	00		 ja	 $LN36@posix_spaw@2
  00121	48 85 c0	 test	 rax, rax
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	48 0f 45 c8	 cmovne	 rcx, rax
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
$LN39@posix_spaw@2:
  00133	48 8b e8	 mov	 rbp, rax

; 5357 :     if (argvlist == NULL) {

  00136	48 85 c0	 test	 rax, rax
  00139	0f 84 30 01 00
	00		 je	 $LN36@posix_spaw@2

; 5360 :     }
; 5361 :     for (i = 0; i < argc; i++) {

  0013f	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00144	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00149	49 8b f5	 mov	 rsi, r13
  0014c	48 85 db	 test	 rbx, rbx
  0014f	7e 3c		 jle	 SHORT $LN8@posix_spaw@2
  00151	48 8b f8	 mov	 rdi, rax
  00154	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL10@posix_spaw@2:

; 5362 :         if (!fsconvert_strdup((*getitem)(argv, i),
; 5363 :                               &argvlist[i]))

  00160	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00168	48 8b d6	 mov	 rdx, rsi
  0016b	41 ff d4	 call	 r12
  0016e	48 8b d7	 mov	 rdx, rdi
  00171	48 8b c8	 mov	 rcx, rax
  00174	e8 00 00 00 00	 call	 fsconvert_strdup
  00179	85 c0		 test	 eax, eax
  0017b	0f 84 d7 00 00
	00		 je	 $fail_1$123064

; 5360 :     }
; 5361 :     for (i = 0; i < argc; i++) {

  00181	48 ff c6	 inc	 rsi
  00184	48 83 c7 08	 add	 rdi, 8
  00188	48 3b f3	 cmp	 rsi, rbx
  0018b	7c d3		 jl	 SHORT $LL10@posix_spaw@2
$LN8@posix_spaw@2:

; 5364 :         {
; 5365 :             lastarg = i;
; 5366 :             goto fail_1;
; 5367 :         }
; 5368 :     }
; 5369 :     lastarg = argc;
; 5370 :     argvlist[argc] = NULL;

  0018d	4c 89 6c dd 00	 mov	 QWORD PTR [rbp+rbx*8], r13

; 5371 : 
; 5372 :     envlist = parse_envlist(env, &envc);

  00192	48 8b 4c 24 40	 mov	 rcx, QWORD PTR env$[rsp]
  00197	48 8d 54 24 50	 lea	 rdx, QWORD PTR envc$[rsp]
  0019c	48 8b f3	 mov	 rsi, rbx
  0019f	e8 00 00 00 00	 call	 parse_envlist
  001a4	48 8b f8	 mov	 rdi, rax

; 5373 :     if (envlist == NULL)

  001a7	48 85 c0	 test	 rax, rax
  001aa	0f 84 a8 00 00
	00		 je	 $fail_1$123064

; 5374 :         goto fail_1;
; 5375 : 
; 5376 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 5377 :     Py_BEGIN_ALLOW_THREADS
; 5378 :     spawnval = spawnve(mode, path, argvlist, envlist);
; 5379 :     Py_END_ALLOW_THREADS
; 5380 : #else
; 5381 :     if (mode == _OLD_P_OVERLAY)

  001b0	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR mode$[rsp]
  001b7	b8 02 00 00 00	 mov	 eax, 2
  001bc	3b c8		 cmp	 ecx, eax
  001be	0f 44 c8	 cmove	 ecx, eax
  001c1	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR mode$[rsp], ecx

; 5382 :         mode = _P_OVERLAY;
; 5383 : 
; 5384 :     Py_BEGIN_ALLOW_THREADS

  001c8	e8 00 00 00 00	 call	 PyEval_SaveThread

; 5385 :     spawnval = _spawnve(mode, path, argvlist, envlist);

  001cd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR mode$[rsp]
  001d4	4c 8b cf	 mov	 r9, rdi
  001d7	4c 8b c5	 mov	 r8, rbp
  001da	49 8b d6	 mov	 rdx, r14
  001dd	48 8b d8	 mov	 rbx, rax
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__spawnve

; 5386 :     Py_END_ALLOW_THREADS

  001e6	48 8b cb	 mov	 rcx, rbx
  001e9	4c 8b e0	 mov	 r12, rax
  001ec	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 5387 : #endif
; 5388 : 
; 5389 :     if (spawnval == -1)

  001f1	49 83 fc ff	 cmp	 r12, -1
  001f5	75 07		 jne	 SHORT $LN4@posix_spaw@2

; 5390 :         (void) posix_error();

  001f7	e8 00 00 00 00	 call	 posix_error

; 5391 :     else

  001fc	eb 12		 jmp	 SHORT $LN33@posix_spaw@2
$LN4@posix_spaw@2:

; 5392 : #if SIZEOF_LONG == SIZEOF_VOID_P
; 5393 :         res = Py_BuildValue("l", (long) spawnval);
; 5394 : #else
; 5395 :         res = Py_BuildValue("L", (PY_LONG_LONG) spawnval);

  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OCOKONAJ@L?$AA@
  00205	49 8b d4	 mov	 rdx, r12
  00208	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  0020d	4c 8b e8	 mov	 r13, rax
$LN33@posix_spaw@2:

; 5396 : #endif
; 5397 : 
; 5398 :     while (--envc >= 0)

  00210	48 8b 5c 24 50	 mov	 rbx, QWORD PTR envc$[rsp]
  00215	48 ff cb	 dec	 rbx
  00218	78 25		 js	 SHORT $LN1@posix_spaw@2
  0021a	66 0f 1f 44 00
	00		 npad	 6
$LL2@posix_spaw@2:

; 5399 :         PyMem_DEL(envlist[envc]);

  00220	e8 00 00 00 00	 call	 _Py_PXCTX
  00225	48 8b 0c df	 mov	 rcx, QWORD PTR [rdi+rbx*8]
  00229	85 c0		 test	 eax, eax
  0022b	74 07		 je	 SHORT $LN28@posix_spaw@2
  0022d	e8 00 00 00 00	 call	 _PxMem_Free
  00232	eb 06		 jmp	 SHORT $LN29@posix_spaw@2
$LN28@posix_spaw@2:
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN29@posix_spaw@2:

; 5396 : #endif
; 5397 : 
; 5398 :     while (--envc >= 0)

  0023a	48 ff cb	 dec	 rbx
  0023d	79 e1		 jns	 SHORT $LL2@posix_spaw@2
$LN1@posix_spaw@2:

; 5400 :     PyMem_DEL(envlist);

  0023f	e8 00 00 00 00	 call	 _Py_PXCTX
  00244	48 8b cf	 mov	 rcx, rdi
  00247	85 c0		 test	 eax, eax
  00249	74 07		 je	 SHORT $LN30@posix_spaw@2
  0024b	e8 00 00 00 00	 call	 _PxMem_Free
  00250	eb 06		 jmp	 SHORT $fail_1$123064
$LN30@posix_spaw@2:
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$fail_1$123064:

; 5401 :   fail_1:
; 5402 :     free_string_array(argvlist, lastarg);

  00258	48 8b d6	 mov	 rdx, rsi
  0025b	48 8b cd	 mov	 rcx, rbp
  0025e	e8 00 00 00 00	 call	 free_string_array
  00263	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00268	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0026d	eb 1a		 jmp	 SHORT $fail_0$123036
$LN36@posix_spaw@2:

; 5358 :         PyErr_NoMemory();

  0026f	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5359 :         goto fail_0;

  00274	eb 13		 jmp	 SHORT $fail_0$123036
$LN14@posix_spaw@2:

; 5344 :     }
; 5345 :     else {
; 5346 :         PyErr_SetString(PyExc_TypeError,
; 5347 :                         "spawnve() arg 2 must be a tuple or list");

  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@
$LN38@posix_spaw@2:
  0027d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00284	e8 00 00 00 00	 call	 PyErr_SetString
$fail_0$123036:

; 5403 :   fail_0:
; 5404 :     Py_DECREF(opath);

  00289	48 8b 4c 24 48	 mov	 rcx, QWORD PTR opath$[rsp]
  0028e	e8 00 00 00 00	 call	 _Py_DecRef
  00293	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  00298	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  0029d	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
  002a5	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 5405 :     return res;

  002ad	49 8b c5	 mov	 rax, r13

; 5406 : }

  002b0	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  002b7	41 5d		 pop	 r13
  002b9	c3		 ret	 0
posix_spawnve ENDP
_TEXT	ENDS
EXTRN	__imp_getpid:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getpid DD imagerel posix_getpid
	DD	imagerel posix_getpid+21
	DD	imagerel $unwind$posix_getpid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getpid DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT posix_getpid
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
posix_getpid PROC					; COMDAT

; 6225 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6226 :     return PyLong_FromPid(getpid());

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  0000a	8b c8		 mov	 ecx, eax

; 6227 : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	e9 00 00 00 00	 jmp	 PyLong_FromLong
posix_getpid ENDP
_TEXT	ENDS
EXTRN	Process32Next:PROC
EXTRN	Process32First:PROC
EXTRN	CreateToolhelp32Snapshot:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_getppid DD imagerel win32_getppid
	DD	imagerel win32_getppid+183
	DD	imagerel $unwind$win32_getppid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_getppid DD 050d01H
	DD	02c340dH
	DD	02a010dH
	DD	07006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_getppid
_TEXT	SEGMENT
pe$ = 32
win32_getppid PROC					; COMDAT

; 6515 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H

; 6516 :     HANDLE snapshot;
; 6517 :     pid_t mypid;
; 6518 :     PyObject* result = NULL;
; 6519 :     BOOL have_record;
; 6520 :     PROCESSENTRY32 pe;
; 6521 : 
; 6522 :     mypid = getpid(); /* This function never fails */

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid

; 6523 : 
; 6524 :     snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

  00013	33 d2		 xor	 edx, edx
  00015	8d 4a 02	 lea	 ecx, QWORD PTR [rdx+2]
  00018	8b d8		 mov	 ebx, eax
  0001a	e8 00 00 00 00	 call	 CreateToolhelp32Snapshot
  0001f	48 8b f8	 mov	 rdi, rax

; 6525 :     if (snapshot == INVALID_HANDLE_VALUE)

  00022	48 83 f8 ff	 cmp	 rax, -1
  00026	75 1e		 jne	 SHORT $LN5@win32_getp

; 6526 :         return PyErr_SetFromWindowsErr(GetLastError());

  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 6549 : }

  00035	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR [rsp+352]
  0003d	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN5@win32_getp:

; 6527 : 
; 6528 :     pe.dwSize = sizeof(pe);
; 6529 :     have_record = Process32First(snapshot, &pe);

  00046	48 8d 54 24 20	 lea	 rdx, QWORD PTR pe$[rsp]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	c7 44 24 20 30
	01 00 00	 mov	 DWORD PTR pe$[rsp], 304	; 00000130H
  00056	e8 00 00 00 00	 call	 Process32First

; 6530 :     while (have_record) {

  0005b	85 c0		 test	 eax, eax
  0005d	74 2b		 je	 SHORT $LN11@win32_getp
  0005f	90		 npad	 1
$LL4@win32_getp:

; 6531 :         if (mypid == (pid_t)pe.th32ProcessID) {

  00060	3b 5c 24 28	 cmp	 ebx, DWORD PTR pe$[rsp+8]
  00064	74 13		 je	 SHORT $LN9@win32_getp

; 6534 :             break;
; 6535 :         }
; 6536 : 
; 6537 :         have_record = Process32Next(snapshot, &pe);

  00066	48 8d 54 24 20	 lea	 rdx, QWORD PTR pe$[rsp]
  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	e8 00 00 00 00	 call	 Process32Next
  00073	85 c0		 test	 eax, eax
  00075	75 e9		 jne	 SHORT $LL4@win32_getp

; 6531 :         if (mypid == (pid_t)pe.th32ProcessID) {

  00077	eb 11		 jmp	 SHORT $LN11@win32_getp
$LN9@win32_getp:

; 6532 :             /* We could cache the ulong value in a static variable. */
; 6533 :             result = PyLong_FromPid((pid_t)pe.th32ParentProcessID);

  00079	8b 4c 24 40	 mov	 ecx, DWORD PTR pe$[rsp+32]
  0007d	e8 00 00 00 00	 call	 PyLong_FromLong
  00082	48 8b d8	 mov	 rbx, rax

; 6538 :     }
; 6539 : 
; 6540 :     /* If our loop exits and our pid was not found (result will be NULL)
; 6541 :      * then GetLastError will return ERROR_NO_MORE_FILES. This is an
; 6542 :      * error anyway, so let's raise it. */
; 6543 :     if (!result)

  00085	48 85 c0	 test	 rax, rax
  00088	75 10		 jne	 SHORT $LN1@win32_getp
$LN11@win32_getp:

; 6544 :         result = PyErr_SetFromWindowsErr(GetLastError());

  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00090	8b c8		 mov	 ecx, eax
  00092	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00097	48 8b d8	 mov	 rbx, rax
$LN1@win32_getp:

; 6545 : 
; 6546 :     CloseHandle(snapshot);

  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 6547 : 
; 6548 :     return result;

  000a3	48 8b c3	 mov	 rax, rbx

; 6549 : }

  000a6	48 8b 9c 24 60
	01 00 00	 mov	 rbx, QWORD PTR [rsp+352]
  000ae	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
win32_getppid ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT posix_getppid
_TEXT	SEGMENT
self$ = 8
noargs$ = 16
posix_getppid PROC					; COMDAT

; 6561 : #ifdef MS_WINDOWS
; 6562 :     return win32_getppid();
; 6563 : #else
; 6564 :     return PyLong_FromPid(getppid());
; 6565 : #endif
; 6566 : }

  00000	e9 00 00 00 00	 jmp	 win32_getppid
posix_getppid ENDP
_TEXT	ENDS
EXTRN	__imp_GetUserNameW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getlogin DD imagerel posix_getlogin
	DD	imagerel posix_getlogin+84
	DD	imagerel $unwind$posix_getlogin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getlogin DD 020a01H
	DD	047010aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT posix_getlogin
_TEXT	SEGMENT
user_name$ = 32
self$ = 576
noargs$ = 584
num_chars$ = 592
posix_getlogin PROC					; COMDAT

; 6577 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H

; 6578 :     PyObject *result = NULL;
; 6579 : #ifdef MS_WINDOWS
; 6580 :     wchar_t user_name[UNLEN + 1];
; 6581 :     DWORD num_chars = Py_ARRAY_LENGTH(user_name);
; 6582 : 
; 6583 :     if (GetUserNameW(user_name, &num_chars)) {

  0000a	48 8d 50 18	 lea	 rdx, QWORD PTR [rax+24]
  0000e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR user_name$[rsp]
  00013	c7 40 18 01 01
	00 00		 mov	 DWORD PTR [rax+24], 257	; 00000101H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetUserNameW
  00020	85 c0		 test	 eax, eax
  00022	74 1b		 je	 SHORT $LN2@posix_getl

; 6584 :         /* num_chars is the number of unicode chars plus null terminator */
; 6585 :         result = PyUnicode_FromWideChar(user_name, num_chars - 1);

  00024	8b 94 24 50 02
	00 00		 mov	 edx, DWORD PTR num_chars$[rsp]
  0002b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR user_name$[rsp]
  00030	ff ca		 dec	 edx
  00032	e8 00 00 00 00	 call	 PyUnicode_FromWideChar

; 6589 : #else
; 6590 :     char *name;
; 6591 :     int old_errno = errno;
; 6592 : 
; 6593 :     errno = 0;
; 6594 :     name = getlogin();
; 6595 :     if (name == NULL) {
; 6596 :         if (errno)
; 6597 :             posix_error();
; 6598 :         else
; 6599 :             PyErr_SetString(PyExc_OSError, "unable to determine login name");
; 6600 :     }
; 6601 :     else
; 6602 :         result = PyUnicode_DecodeFSDefault(name);
; 6603 :     errno = old_errno;
; 6604 : #endif
; 6605 :     return result;
; 6606 : }

  00037	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  0003e	c3		 ret	 0
$LN2@posix_getl:

; 6586 :     }
; 6587 :     else
; 6588 :         result = PyErr_SetFromWindowsErr(GetLastError());

  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00045	8b c8		 mov	 ecx, eax
  00047	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 6589 : #else
; 6590 :     char *name;
; 6591 :     int old_errno = errno;
; 6592 : 
; 6593 :     errno = 0;
; 6594 :     name = getlogin();
; 6595 :     if (name == NULL) {
; 6596 :         if (errno)
; 6597 :             posix_error();
; 6598 :         else
; 6599 :             PyErr_SetString(PyExc_OSError, "unable to determine login name");
; 6600 :     }
; 6601 :     else
; 6602 :         result = PyUnicode_DecodeFSDefault(name);
; 6603 :     errno = old_errno;
; 6604 : #endif
; 6605 :     return result;
; 6606 : }

  0004c	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  00053	c3		 ret	 0
posix_getlogin ENDP
_TEXT	ENDS
PUBLIC	??_C@_07BLEFEIJF@kk?3kill?$AA@			; `string'
EXTRN	__imp_TerminateProcess:PROC
EXTRN	__imp_OpenProcess:PROC
EXTRN	__imp_GenerateConsoleCtrlEvent:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$win32_kill DD imagerel win32_kill
	DD	imagerel win32_kill+44
	DD	imagerel $unwind$win32_kill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$win32_kill DD imagerel win32_kill+44
	DD	imagerel win32_kill+148
	DD	imagerel $chain$1$win32_kill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$win32_kill DD imagerel win32_kill+148
	DD	imagerel win32_kill+208
	DD	imagerel $chain$3$win32_kill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$win32_kill DD imagerel win32_kill+208
	DD	imagerel win32_kill+307
	DD	imagerel $chain$5$win32_kill
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$win32_kill DD imagerel win32_kill+307
	DD	imagerel win32_kill+392
	DD	imagerel $chain$7$win32_kill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$win32_kill DD 020021H
	DD	083400H
	DD	imagerel win32_kill
	DD	imagerel win32_kill+44
	DD	imagerel $unwind$win32_kill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$win32_kill DD 040021H
	DD	067400H
	DD	083400H
	DD	imagerel win32_kill
	DD	imagerel win32_kill+44
	DD	imagerel $unwind$win32_kill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$win32_kill DD 040021H
	DD	067400H
	DD	083400H
	DD	imagerel win32_kill
	DD	imagerel win32_kill+44
	DD	imagerel $unwind$win32_kill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$win32_kill DD 043e21H
	DD	06743eH
	DD	083405H
	DD	imagerel win32_kill
	DD	imagerel win32_kill+44
	DD	imagerel $unwind$win32_kill
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_kill DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_07BLEFEIJF@kk?3kill?$AA@
CONST	SEGMENT
??_C@_07BLEFEIJF@kk?3kill?$AA@ DB 'kk:kill', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT win32_kill
_TEXT	SEGMENT
self$ = 64
args$ = 72
pid$ = 80
sig$ = 88
win32_kill PROC						; COMDAT

; 6686 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6687 :     PyObject *result;
; 6688 :     DWORD pid, sig, err;
; 6689 :     HANDLE handle;
; 6690 : 
; 6691 :     if (!PyArg_ParseTuple(args, "kk:kill", &pid, &sig))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 58	 lea	 r9, QWORD PTR sig$[rsp]
  0000c	4c 8d 44 24 50	 lea	 r8, QWORD PTR pid$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BLEFEIJF@kk?3kill?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN8@win32_kill

; 6692 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 6723 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN8@win32_kill:

; 6693 : 
; 6694 :     /* Console processes which share a common console can be sent CTRL+C or
; 6695 :        CTRL+BREAK events, provided they handle said events. */
; 6696 :     if (sig == CTRL_C_EVENT || sig == CTRL_BREAK_EVENT) {

  00028	8b 4c 24 58	 mov	 ecx, DWORD PTR sig$[rsp]
  0002c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00031	85 c9		 test	 ecx, ecx
  00033	74 05		 je	 SHORT $LN6@win32_kill
  00035	83 f9 01	 cmp	 ecx, 1
  00038	75 1f		 jne	 SHORT $LN4@win32_kill
$LN6@win32_kill:

; 6697 :         if (GenerateConsoleCtrlEvent(sig, pid) == 0) {

  0003a	8b 54 24 50	 mov	 edx, DWORD PTR pid$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GenerateConsoleCtrlEvent
  00044	85 c0		 test	 eax, eax
  00046	0f 85 e7 00 00
	00		 jne	 $LN5@win32_kill

; 6698 :             err = GetLastError();

  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 6699 :             PyErr_SetFromWindowsErr(err);

  00052	8b c8		 mov	 ecx, eax
  00054	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN4@win32_kill:

; 6703 :     }
; 6704 : 
; 6705 :     /* If the signal is outside of what GenerateConsoleCtrlEvent can use,
; 6706 :        attempt to open and terminate the process. */
; 6707 :     handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

  00059	44 8b 44 24 50	 mov	 r8d, DWORD PTR pid$[rsp]
  0005e	33 d2		 xor	 edx, edx
  00060	b9 ff ff 1f 00	 mov	 ecx, 2097151		; 001fffffH
  00065	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcess
  00070	48 8b f8	 mov	 rdi, rax

; 6708 :     if (handle == NULL) {

  00073	48 85 c0	 test	 rax, rax
  00076	75 1c		 jne	 SHORT $LN3@win32_kill

; 6709 :         err = GetLastError();

  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 6710 :         return PyErr_SetFromWindowsErr(err);

  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00085	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  0008a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 6723 : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	c3		 ret	 0
$LN3@win32_kill:

; 6711 :     }
; 6712 : 
; 6713 :     if (TerminateProcess(handle, sig) == 0) {

  00094	8b 54 24 58	 mov	 edx, DWORD PTR sig$[rsp]
  00098	48 8b c8	 mov	 rcx, rax
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TerminateProcess
  000a1	85 c0		 test	 eax, eax
  000a3	75 2b		 jne	 SHORT $LN2@win32_kill

; 6714 :         err = GetLastError();

  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 6715 :         result = PyErr_SetFromWindowsErr(err);

  000ab	8b c8		 mov	 ecx, eax
  000ad	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 6718 :         result = Py_None;
; 6719 :     }
; 6720 : 
; 6721 :     CloseHandle(handle);

  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	48 8b d8	 mov	 rbx, rax
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  000be	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 6722 :     return result;

  000c3	48 8b c3	 mov	 rax, rbx
  000c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 6723 : }

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
$LN2@win32_kill:

; 6716 :     } else {
; 6717 :         Py_INCREF(Py_None);

  000d0	e8 00 00 00 00	 call	 _Py_PXCTX
  000d5	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  000dc	85 c0		 test	 eax, eax
  000de	75 38		 jne	 SHORT $LN16@win32_kill
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ee	4c 8b cb	 mov	 r9, rbx
  000f1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000ff	e8 00 00 00 00	 call	 _PyParallel_Guard
  00104	85 c0		 test	 eax, eax
  00106	75 09		 jne	 SHORT $LN15@win32_kill
  00108	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0010f	74 07		 je	 SHORT $LN16@win32_kill
$LN15@win32_kill:
  00111	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN16@win32_kill:

; 6718 :         result = Py_None;
; 6719 :     }
; 6720 : 
; 6721 :     CloseHandle(handle);

  00118	48 8b cf	 mov	 rcx, rdi
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00121	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 6722 :     return result;

  00126	48 8b c3	 mov	 rax, rbx
  00129	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 6723 : }

  0012e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00132	c3		 ret	 0
$LN5@win32_kill:

; 6700 :         }
; 6701 :         else
; 6702 :             Py_RETURN_NONE;

  00133	e8 00 00 00 00	 call	 _Py_PXCTX
  00138	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0013f	85 c0		 test	 eax, eax
  00141	75 38		 jne	 SHORT $LN12@win32_kill
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00151	4c 8b cb	 mov	 r9, rbx
  00154	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0015a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00162	e8 00 00 00 00	 call	 _PyParallel_Guard
  00167	85 c0		 test	 eax, eax
  00169	75 09		 jne	 SHORT $LN11@win32_kill
  0016b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00172	74 07		 je	 SHORT $LN12@win32_kill
$LN11@win32_kill:
  00174	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN12@win32_kill:
  0017b	48 8b c3	 mov	 rax, rbx
  0017e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 6723 : }

  00183	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00187	c3		 ret	 0
win32_kill ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MOIFFGMJ@Ni?$AA@			; `string'
PUBLIC	??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@		; `string'
EXTRN	__imp__cwait:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_waitpid DD imagerel posix_waitpid
	DD	imagerel posix_waitpid+40
	DD	imagerel $unwind$posix_waitpid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_waitpid DD imagerel posix_waitpid+40
	DD	imagerel posix_waitpid+113
	DD	imagerel $chain$0$posix_waitpid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_waitpid DD imagerel posix_waitpid+113
	DD	imagerel posix_waitpid+156
	DD	imagerel $chain$2$posix_waitpid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_waitpid DD 020021H
	DD	063400H
	DD	imagerel posix_waitpid
	DD	imagerel posix_waitpid+40
	DD	imagerel $unwind$posix_waitpid
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_waitpid DD 020521H
	DD	063405H
	DD	imagerel posix_waitpid
	DD	imagerel posix_waitpid+40
	DD	imagerel $unwind$posix_waitpid
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_waitpid DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02MOIFFGMJ@Ni?$AA@
CONST	SEGMENT
??_C@_02MOIFFGMJ@Ni?$AA@ DB 'Ni', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@
CONST	SEGMENT
??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@ DB 'ii:waitpid', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_waitpid
_TEXT	SEGMENT
pid$ = 32
self$ = 64
args$ = 72
options$ = 80
status$ = 88
posix_waitpid PROC					; COMDAT

; 7109 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7110 :     Py_intptr_t pid;
; 7111 :     int status, options;
; 7112 : 
; 7113 :     if (!PyArg_ParseTuple(args, _Py_PARSE_PID "i:waitpid", &pid, &options))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 50	 lea	 r9, QWORD PTR options$[rsp]
  0000c	4c 8d 44 24 20	 lea	 r8, QWORD PTR pid$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@posix_wait

; 7114 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 7123 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN2@posix_wait:
  00028	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 7115 :     Py_BEGIN_ALLOW_THREADS

  0002d	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7116 :     pid = _cwait(&status, pid, options);

  00032	44 8b 44 24 50	 mov	 r8d, DWORD PTR options$[rsp]
  00037	48 8b 54 24 20	 mov	 rdx, QWORD PTR pid$[rsp]
  0003c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR status$[rsp]
  00041	48 8b d8	 mov	 rbx, rax
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__cwait

; 7117 :     Py_END_ALLOW_THREADS

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	48 89 44 24 20	 mov	 QWORD PTR pid$[rsp], rax
  00052	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7118 :     if (pid == -1)

  00057	4c 8b 5c 24 20	 mov	 r11, QWORD PTR pid$[rsp]
  0005c	49 83 fb ff	 cmp	 r11, -1
  00060	75 0f		 jne	 SHORT $LN1@posix_wait

; 7119 :         return posix_error();

  00062	e8 00 00 00 00	 call	 posix_error
  00067	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 7123 : }

  0006c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00070	c3		 ret	 0
$LN1@posix_wait:

; 7120 : 
; 7121 :     /* shift the status left a byte so this is more like the POSIX waitpid */
; 7122 :     return Py_BuildValue("Ni", PyLong_FromPid(pid), status << 8);

  00071	8b 5c 24 58	 mov	 ebx, DWORD PTR status$[rsp]
  00075	41 8b cb	 mov	 ecx, r11d
  00078	c1 e3 08	 shl	 ebx, 8
  0007b	e8 00 00 00 00	 call	 PyLong_FromLong
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MOIFFGMJ@Ni?$AA@
  00087	48 8b d0	 mov	 rdx, rax
  0008a	44 8b c3	 mov	 r8d, ebx
  0008d	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00092	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 7123 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
posix_waitpid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@	; `string'
PUBLIC	??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_CreateSymbolicLink DD imagerel check_CreateSymbolicLink
	DD	imagerel check_CreateSymbolicLink+31
	DD	imagerel $unwind$check_CreateSymbolicLink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$check_CreateSymbolicLink DD imagerel check_CreateSymbolicLink+31
	DD	imagerel check_CreateSymbolicLink+106
	DD	imagerel $chain$0$check_CreateSymbolicLink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$check_CreateSymbolicLink DD imagerel check_CreateSymbolicLink+106
	DD	imagerel check_CreateSymbolicLink+128
	DD	imagerel $chain$1$check_CreateSymbolicLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$check_CreateSymbolicLink DD 021H
	DD	imagerel check_CreateSymbolicLink
	DD	imagerel check_CreateSymbolicLink+31
	DD	imagerel $unwind$check_CreateSymbolicLink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$check_CreateSymbolicLink DD 020521H
	DD	043405H
	DD	imagerel check_CreateSymbolicLink
	DD	imagerel check_CreateSymbolicLink+31
	DD	imagerel $unwind$check_CreateSymbolicLink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_CreateSymbolicLink DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@
CONST	SEGMENT
??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@ DB 'CreateSymbolicLinkA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@
CONST	SEGMENT
??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@ DB 'CreateSymbolicLinkW', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_CreateSymbolicLink
_TEXT	SEGMENT
check_CreateSymbolicLink PROC				; COMDAT

; 7231 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7232 :     HINSTANCE hKernel32;
; 7233 :     /* only recheck */
; 7234 :     if (Py_CreateSymbolicLinkW && Py_CreateSymbolicLinkA)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkW, 0
  0000c	74 0a		 je	 SHORT $LN1@check_Crea
  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkA, 0

; 7235 :         return 1;

  00016	75 57		 jne	 SHORT $LN6@check_Crea
$LN1@check_Crea:

; 7236 :     hKernel32 = GetModuleHandleW(L"KERNEL32");

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
  0001f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW

; 7237 :     *(FARPROC*)&Py_CreateSymbolicLinkW = GetProcAddress(hKernel32,
; 7238 :                                                         "CreateSymbolicLinkW");

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@
  00031	48 8b c8	 mov	 rcx, rax
  00034	48 8b d8	 mov	 rbx, rax
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress

; 7239 :     *(FARPROC*)&Py_CreateSymbolicLinkA = GetProcAddress(hKernel32,
; 7240 :                                                         "CreateSymbolicLinkA");

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@
  00044	48 8b cb	 mov	 rcx, rbx
  00047	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_CreateSymbolicLinkW, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress

; 7241 :     return (Py_CreateSymbolicLinkW && Py_CreateSymbolicLinkA);

  00054	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkW, 0
  0005c	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]
  00061	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_CreateSymbolicLinkA, rax
  00068	74 0f		 je	 SHORT $LN4@check_Crea
  0006a	48 85 c0	 test	 rax, rax
  0006d	74 0a		 je	 SHORT $LN4@check_Crea
$LN6@check_Crea:
  0006f	b8 01 00 00 00	 mov	 eax, 1

; 7242 : }

  00074	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00078	c3		 ret	 0
$LN4@check_Crea:

; 7241 :     return (Py_CreateSymbolicLinkW && Py_CreateSymbolicLinkA);

  00079	33 c0		 xor	 eax, eax

; 7242 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
check_CreateSymbolicLink ENDP
_TEXT	ENDS
PUBLIC	_dirnameW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_dirnameW DD imagerel $LN14
	DD	imagerel $LN14+70
	DD	imagerel $unwind$_dirnameW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_dirnameW DD 020501H
	DD	017405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _dirnameW
_TEXT	SEGMENT
path$ = 8
_dirnameW PROC						; COMDAT

; 7244 : void _dirnameW(WCHAR *path) {

$LN14:
  00000	48 89 7c 24 08	 mov	 QWORD PTR [rsp+8], rdi
  00005	48 8b d1	 mov	 rdx, rcx

; 7245 :     /* Remove the last portion of the path */
; 7246 : 
; 7247 :     WCHAR *ptr;
; 7248 : 
; 7249 :     /* walk the path from the end until a backslash is encountered */
; 7250 :     for(ptr = path + wcslen(path); ptr != path; ptr--)

  00008	48 83 c9 ff	 or	 rcx, -1
  0000c	33 c0		 xor	 eax, eax
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	66 f2 af	 repne scasw
  00014	48 f7 d1	 not	 rcx
  00017	48 ff c9	 dec	 rcx
  0001a	48 8d 04 4a	 lea	 rax, QWORD PTR [rdx+rcx*2]
  0001e	48 3b c2	 cmp	 rax, rdx
  00021	74 18		 je	 SHORT $LN13@dirnameW
$LL5@dirnameW:

; 7251 :     {
; 7252 :         if(*ptr == *L"\\" || *ptr == *L"/") {

  00023	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00026	66 83 f9 5c	 cmp	 cx, 92			; 0000005cH
  0002a	74 0f		 je	 SHORT $LN13@dirnameW
  0002c	66 83 f9 2f	 cmp	 cx, 47			; 0000002fH
  00030	74 09		 je	 SHORT $LN13@dirnameW

; 7245 :     /* Remove the last portion of the path */
; 7246 : 
; 7247 :     WCHAR *ptr;
; 7248 : 
; 7249 :     /* walk the path from the end until a backslash is encountered */
; 7250 :     for(ptr = path + wcslen(path); ptr != path; ptr--)

  00032	48 83 e8 02	 sub	 rax, 2
  00036	48 3b c2	 cmp	 rax, rdx
  00039	75 e8		 jne	 SHORT $LL5@dirnameW
$LN13@dirnameW:

; 7253 :             break;
; 7254 :         }
; 7255 :     }
; 7256 :     *ptr = 0;
; 7257 : }

  0003b	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  00040	33 c9		 xor	 ecx, ecx
  00042	66 89 08	 mov	 WORD PTR [rax], cx
  00045	c3		 ret	 0
_dirnameW ENDP
_TEXT	ENDS
PUBLIC	_dirnameA
;	COMDAT pdata
pdata	SEGMENT
$pdata$_dirnameA DD imagerel $LN14
	DD	imagerel $LN14+69
	DD	imagerel $unwind$_dirnameA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_dirnameA DD 020501H
	DD	017405H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _dirnameA
_TEXT	SEGMENT
path$ = 8
_dirnameA PROC						; COMDAT

; 7259 : void _dirnameA(char *path) {

$LN14:
  00000	48 89 7c 24 08	 mov	 QWORD PTR [rsp+8], rdi
  00005	48 8b d1	 mov	 rdx, rcx

; 7260 :     /* Remove the last portion of the path */
; 7261 : 
; 7262 :     char *ptr;
; 7263 : 
; 7264 :     /* walk the path from the end until a backslash is encountered */
; 7265 :     for(ptr = path + strlen(path); ptr != path; ptr--)

  00008	48 83 c9 ff	 or	 rcx, -1
  0000c	33 c0		 xor	 eax, eax
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	f2 ae		 repne scasb
  00013	48 f7 d1	 not	 rcx
  00016	48 ff c9	 dec	 rcx
  00019	48 03 ca	 add	 rcx, rdx
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	74 1c		 je	 SHORT $LN13@dirnameA
$LL5@dirnameA:

; 7266 :     {
; 7267 :         if(*ptr == '\\' || *ptr == '/') {

  00021	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00024	3c 5c		 cmp	 al, 92			; 0000005cH
  00026	74 0c		 je	 SHORT $LN11@dirnameA
  00028	3c 2f		 cmp	 al, 47			; 0000002fH
  0002a	74 08		 je	 SHORT $LN11@dirnameA

; 7260 :     /* Remove the last portion of the path */
; 7261 : 
; 7262 :     char *ptr;
; 7263 : 
; 7264 :     /* walk the path from the end until a backslash is encountered */
; 7265 :     for(ptr = path + strlen(path); ptr != path; ptr--)

  0002c	48 ff c9	 dec	 rcx
  0002f	48 3b ca	 cmp	 rcx, rdx
  00032	75 ed		 jne	 SHORT $LL5@dirnameA
$LN11@dirnameA:

; 7268 :             break;
; 7269 :         }
; 7270 :     }
; 7271 :     *ptr = 0;

  00034	c6 01 00	 mov	 BYTE PTR [rcx], 0

; 7272 : }

  00037	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  0003c	c3		 ret	 0
$LN13@dirnameA:
  0003d	48 8b 7c 24 08	 mov	 rdi, QWORD PTR [rsp+8]
  00042	88 01		 mov	 BYTE PTR [rcx], al
  00044	c3		 ret	 0
_dirnameA ENDP
_TEXT	ENDS
PUBLIC	_is_absW
; Function compile flags: /Ogtpy
;	COMDAT _is_absW
_TEXT	SEGMENT
path$ = 8
_is_absW PROC						; COMDAT

; 7275 :     /* Is this path absolute? */
; 7276 : 
; 7277 :     return path[0] == L'\\' || path[0] == L'/' || path[1] == L':';

  00000	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00003	66 83 f8 5c	 cmp	 ax, 92			; 0000005cH
  00007	74 10		 je	 SHORT $LN3@is_absW
  00009	66 83 f8 2f	 cmp	 ax, 47			; 0000002fH
  0000d	74 0a		 je	 SHORT $LN3@is_absW
  0000f	66 83 79 02 3a	 cmp	 WORD PTR [rcx+2], 58	; 0000003aH
  00014	74 03		 je	 SHORT $LN3@is_absW
  00016	33 c0		 xor	 eax, eax

; 7278 : 
; 7279 : }

  00018	c3		 ret	 0
$LN3@is_absW:

; 7275 :     /* Is this path absolute? */
; 7276 : 
; 7277 :     return path[0] == L'\\' || path[0] == L'/' || path[1] == L':';

  00019	b8 01 00 00 00	 mov	 eax, 1

; 7278 : 
; 7279 : }

  0001e	c3		 ret	 0
_is_absW ENDP
_TEXT	ENDS
PUBLIC	_is_absA
; Function compile flags: /Ogtpy
;	COMDAT _is_absA
_TEXT	SEGMENT
path$ = 8
_is_absA PROC						; COMDAT

; 7282 :     /* Is this path absolute? */
; 7283 : 
; 7284 :     return path[0] == '\\' || path[0] == '/' || path[1] == ':';

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00003	3c 5c		 cmp	 al, 92			; 0000005cH
  00005	74 0d		 je	 SHORT $LN3@is_absA
  00007	3c 2f		 cmp	 al, 47			; 0000002fH
  00009	74 09		 je	 SHORT $LN3@is_absA
  0000b	80 79 01 3a	 cmp	 BYTE PTR [rcx+1], 58	; 0000003aH
  0000f	74 03		 je	 SHORT $LN3@is_absA
  00011	33 c0		 xor	 eax, eax

; 7285 : 
; 7286 : }

  00013	c3		 ret	 0
$LN3@is_absA:

; 7282 :     /* Is this path absolute? */
; 7283 : 
; 7284 :     return path[0] == '\\' || path[0] == '/' || path[1] == ':';

  00014	b8 01 00 00 00	 mov	 eax, 1

; 7285 : 
; 7286 : }

  00019	c3		 ret	 0
_is_absA ENDP
_TEXT	ENDS
PUBLIC	_joinW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_joinW DD imagerel $LN11
	DD	imagerel $LN11+56
	DD	imagerel $unwind$_joinW
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_joinW DD imagerel $LN11+56
	DD	imagerel $LN11+122
	DD	imagerel $chain$0$_joinW
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_joinW DD imagerel $LN11+122
	DD	imagerel $LN11+184
	DD	imagerel $chain$1$_joinW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_joinW DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+56
	DD	imagerel $unwind$_joinW
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_joinW DD 020521H
	DD	047405H
	DD	imagerel $LN11
	DD	imagerel $LN11+56
	DD	imagerel $unwind$_joinW
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_joinW DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _joinW
_TEXT	SEGMENT
dest_path$ = 48
root$ = 56
rest$ = 64
_joinW	PROC						; COMDAT

; 7288 : void _joinW(WCHAR *dest_path, const WCHAR *root, const WCHAR *rest) {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 7289 :     /* join root and rest with a backslash */
; 7290 :     int root_len;
; 7291 : 
; 7292 :     if(_is_absW(rest)) {

  00007	49 8b c8	 mov	 rcx, r8
  0000a	e8 00 00 00 00	 call	 _is_absW
  0000f	85 c0		 test	 eax, eax
  00011	74 25		 je	 SHORT $LN2@joinW

; 7293 :         wcscpy(dest_path, rest);

  00013	4d 2b c8	 sub	 r9, r8
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@joinW:
  00020	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  00024	49 83 c0 02	 add	 r8, 2
  00028	66 43 89 44 01
	fe		 mov	 WORD PTR [r9+r8-2], ax
  0002e	66 85 c0	 test	 ax, ax
  00031	75 ed		 jne	 SHORT $LL5@joinW

; 7305 : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
$LN2@joinW:
  00038	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 7294 :         return;
; 7295 :     }
; 7296 : 
; 7297 :     root_len = wcslen(root);

  0003d	48 83 c9 ff	 or	 rcx, -1
  00041	33 c0		 xor	 eax, eax
  00043	48 8b fa	 mov	 rdi, rdx
  00046	66 f2 af	 repne scasw

; 7298 : 
; 7299 :     wcscpy(dest_path, root);

  00049	49 8b f9	 mov	 rdi, r9
  0004c	48 f7 d1	 not	 rcx
  0004f	48 ff c9	 dec	 rcx
  00052	48 2b fa	 sub	 rdi, rdx
  00055	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@joinW:
  00060	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00063	48 83 c2 02	 add	 rdx, 2
  00067	66 89 44 17 fe	 mov	 WORD PTR [rdi+rdx-2], ax
  0006c	66 85 c0	 test	 ax, ax
  0006f	75 ef		 jne	 SHORT $LL6@joinW

; 7300 :     if(root_len) {

  00071	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00076	85 c9		 test	 ecx, ecx
  00078	74 0f		 je	 SHORT $LN1@joinW

; 7301 :         dest_path[root_len] = *L"\\";

  0007a	48 63 c1	 movsxd	 rax, ecx
  0007d	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH

; 7302 :         root_len += 1;

  00082	ff c1		 inc	 ecx
  00084	66 41 89 14 41	 mov	 WORD PTR [r9+rax*2], dx
$LN1@joinW:

; 7303 :     }
; 7304 :     wcscpy(dest_path+root_len, rest);

  00089	48 63 c1	 movsxd	 rax, ecx
  0008c	48 8d 0c 00	 lea	 rcx, QWORD PTR [rax+rax]
  00090	49 2b c8	 sub	 rcx, r8
  00093	49 03 c9	 add	 rcx, r9
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@joinW:
  000a0	41 0f b7 00	 movzx	 eax, WORD PTR [r8]
  000a4	49 83 c0 02	 add	 r8, 2
  000a8	66 42 89 44 01
	fe		 mov	 WORD PTR [rcx+r8-2], ax
  000ae	66 85 c0	 test	 ax, ax
  000b1	75 ed		 jne	 SHORT $LL7@joinW

; 7305 : }

  000b3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b7	c3		 ret	 0
_joinW	ENDP
_TEXT	ENDS
PUBLIC	_joinA
;	COMDAT pdata
pdata	SEGMENT
$pdata$_joinA DD imagerel $LN11
	DD	imagerel $LN11+53
	DD	imagerel $unwind$_joinA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_joinA DD imagerel $LN11+53
	DD	imagerel $LN11+104
	DD	imagerel $chain$0$_joinA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_joinA DD imagerel $LN11+104
	DD	imagerel $LN11+149
	DD	imagerel $chain$1$_joinA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_joinA DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+53
	DD	imagerel $unwind$_joinA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_joinA DD 020521H
	DD	047405H
	DD	imagerel $LN11
	DD	imagerel $LN11+53
	DD	imagerel $unwind$_joinA
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_joinA DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _joinA
_TEXT	SEGMENT
dest_path$ = 48
root$ = 56
rest$ = 64
_joinA	PROC						; COMDAT

; 7307 : void _joinA(char *dest_path, const char *root, const char *rest) {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 7308 :     /* join root and rest with a backslash */
; 7309 :     int root_len;
; 7310 : 
; 7311 :     if(_is_absA(rest)) {

  00007	49 8b c8	 mov	 rcx, r8
  0000a	e8 00 00 00 00	 call	 _is_absA
  0000f	85 c0		 test	 eax, eax
  00011	74 22		 je	 SHORT $LN2@joinA

; 7312 :         strcpy(dest_path, rest);

  00013	4d 2b c8	 sub	 r9, r8
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@joinA:
  00020	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00024	49 ff c0	 inc	 r8
  00027	43 88 44 01 ff	 mov	 BYTE PTR [r9+r8-1], al
  0002c	84 c0		 test	 al, al
  0002e	75 f0		 jne	 SHORT $LL5@joinA

; 7324 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
$LN2@joinA:
  00035	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 7313 :         return;
; 7314 :     }
; 7315 : 
; 7316 :     root_len = strlen(root);

  0003a	48 83 c9 ff	 or	 rcx, -1
  0003e	33 c0		 xor	 eax, eax
  00040	48 8b fa	 mov	 rdi, rdx
  00043	f2 ae		 repne scasb

; 7317 : 
; 7318 :     strcpy(dest_path, root);

  00045	49 8b f9	 mov	 rdi, r9
  00048	48 f7 d1	 not	 rcx
  0004b	48 ff c9	 dec	 rcx
  0004e	48 2b fa	 sub	 rdi, rdx
$LL6@joinA:
  00051	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00054	48 ff c2	 inc	 rdx
  00057	88 44 17 ff	 mov	 BYTE PTR [rdi+rdx-1], al
  0005b	84 c0		 test	 al, al
  0005d	75 f2		 jne	 SHORT $LL6@joinA

; 7319 :     if(root_len) {

  0005f	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00064	85 c9		 test	 ecx, ecx
  00066	74 0a		 je	 SHORT $LN1@joinA

; 7320 :         dest_path[root_len] = '\\';

  00068	48 63 c1	 movsxd	 rax, ecx

; 7321 :         root_len += 1;

  0006b	ff c1		 inc	 ecx
  0006d	42 c6 04 08 5c	 mov	 BYTE PTR [rax+r9], 92	; 0000005cH
$LN1@joinA:

; 7322 :     }
; 7323 :     strcpy(dest_path+root_len, rest);

  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	49 2b c8	 sub	 rcx, r8
  00078	49 03 c9	 add	 rcx, r9
  0007b	0f 1f 44 00 00	 npad	 5
$LL7@joinA:
  00080	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00084	49 ff c0	 inc	 r8
  00087	42 88 44 01 ff	 mov	 BYTE PTR [rcx+r8-1], al
  0008c	84 c0		 test	 al, al
  0008e	75 f0		 jne	 SHORT $LL7@joinA

; 7324 : }

  00090	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00094	c3		 ret	 0
_joinA	ENDP
_TEXT	ENDS
PUBLIC	_check_dirW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_check_dirW DD imagerel $LN7
	DD	imagerel $LN7+172
	DD	imagerel $unwind$_check_dirW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_check_dirW DD 071201H
	DD	0916412H
	DD	0903412H
	DD	08e0112H
	DD	0700bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _check_dirW
_TEXT	SEGMENT
src_info$ = 32
src_resolved$ = 80
dest_parent$ = 608
src$ = 1152
dest$ = 1160
_check_dirW PROC					; COMDAT

; 7327 : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 70 04
	00 00		 sub	 rsp, 1136		; 00000470H
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 8b da	 mov	 rbx, rdx

; 7328 :     /* Return True if the path at src relative to dest is a directory */
; 7329 :     WIN32_FILE_ATTRIBUTE_DATA src_info;
; 7330 :     WCHAR dest_parent[MAX_PATH];
; 7331 :     WCHAR src_resolved[MAX_PATH] = L"";

  00018	48 8d 4c 24 52	 lea	 rcx, QWORD PTR src_resolved$[rsp+2]
  0001d	33 f6		 xor	 esi, esi
  0001f	33 d2		 xor	 edx, edx
  00021	41 b8 06 02 00
	00		 mov	 r8d, 518		; 00000206H
  00027	66 89 74 24 50	 mov	 WORD PTR src_resolved$[rsp], si
  0002c	e8 00 00 00 00	 call	 memset

; 7332 : 
; 7333 :     /* dest_parent = os.path.dirname(dest) */
; 7334 :     wcscpy(dest_parent, dest);

  00031	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00039	48 2b d3	 sub	 rdx, rbx
  0003c	0f 1f 40 00	 npad	 4
$LL3@check_dirW:
  00040	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00043	48 83 c3 02	 add	 rbx, 2
  00047	66 89 44 1a fe	 mov	 WORD PTR [rdx+rbx-2], ax
  0004c	66 85 c0	 test	 ax, ax
  0004f	75 ef		 jne	 SHORT $LL3@check_dirW

; 7335 :     _dirnameW(dest_parent);

  00051	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  00059	e8 00 00 00 00	 call	 _dirnameW

; 7336 :     /* src_resolved = os.path.join(dest_parent, src) */
; 7337 :     _joinW(src_resolved, dest_parent, src);

  0005e	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00066	48 8d 4c 24 50	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  0006b	4c 8b c7	 mov	 r8, rdi
  0006e	e8 00 00 00 00	 call	 _joinW

; 7338 :     return (
; 7339 :         GetFileAttributesExW(src_resolved, GetFileExInfoStandard, &src_info)
; 7340 :         && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
; 7341 :     );

  00073	4c 8d 44 24 20	 lea	 r8, QWORD PTR src_info$[rsp]
  00078	48 8d 4c 24 50	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  0007d	33 d2		 xor	 edx, edx
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExW
  00085	85 c0		 test	 eax, eax
  00087	74 0c		 je	 SHORT $LN4@check_dirW
  00089	f6 44 24 20 10	 test	 BYTE PTR src_info$[rsp], 16
  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	75 02		 jne	 SHORT $LN5@check_dirW
$LN4@check_dirW:
  00095	8b c6		 mov	 eax, esi
$LN5@check_dirW:

; 7342 : }

  00097	4c 8d 9c 24 70
	04 00 00	 lea	 r11, QWORD PTR [rsp+1136]
  0009f	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000a3	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000a7	49 8b e3	 mov	 rsp, r11
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
_check_dirW ENDP
_TEXT	ENDS
PUBLIC	_check_dirA
EXTRN	__imp_GetFileAttributesExA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_check_dirA DD imagerel $LN7
	DD	imagerel $LN7+182
	DD	imagerel $unwind$_check_dirA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_check_dirA DD 050d01H
	DD	050340dH
	DD	04e010dH
	DD	07006H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _check_dirA
_TEXT	SEGMENT
src_info$ = 32
src_resolved$ = 80
dest_parent$ = 352
src$ = 640
dest$ = 648
_check_dirA PROC					; COMDAT

; 7345 : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 8b da	 mov	 rbx, rdx

; 7346 :     /* Return True if the path at src relative to dest is a directory */
; 7347 :     WIN32_FILE_ATTRIBUTE_DATA src_info;
; 7348 :     char dest_parent[MAX_PATH];
; 7349 :     char src_resolved[MAX_PATH] = "";

  00013	48 8d 4c 24 51	 lea	 rcx, QWORD PTR src_resolved$[rsp+1]
  00018	33 d2		 xor	 edx, edx
  0001a	41 b8 03 01 00
	00		 mov	 r8d, 259		; 00000103H
  00020	c6 44 24 50 00	 mov	 BYTE PTR src_resolved$[rsp], 0
  00025	e8 00 00 00 00	 call	 memset

; 7350 : 
; 7351 :     /* dest_parent = os.path.dirname(dest) */
; 7352 :     strcpy(dest_parent, dest);

  0002a	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00032	48 2b d3	 sub	 rdx, rbx
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@check_dirA:
  00040	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00043	48 ff c3	 inc	 rbx
  00046	88 44 1a ff	 mov	 BYTE PTR [rdx+rbx-1], al
  0004a	84 c0		 test	 al, al
  0004c	75 f2		 jne	 SHORT $LL3@check_dirA

; 7353 :     _dirnameW(dest_parent);

  0004e	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  00056	e8 00 00 00 00	 call	 _dirnameW

; 7354 :     /* src_resolved = os.path.join(dest_parent, src) */
; 7355 :     _joinW(src_resolved, dest_parent, src);

  0005b	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00063	48 8d 4c 24 50	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  00068	4c 8b c7	 mov	 r8, rdi
  0006b	e8 00 00 00 00	 call	 _joinW

; 7356 :     return (
; 7357 :         GetFileAttributesExA(src_resolved, GetFileExInfoStandard, &src_info)
; 7358 :         && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
; 7359 :     );

  00070	4c 8d 44 24 20	 lea	 r8, QWORD PTR src_info$[rsp]
  00075	48 8d 4c 24 50	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  0007a	33 d2		 xor	 edx, edx
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExA
  00082	85 c0		 test	 eax, eax
  00084	74 1d		 je	 SHORT $LN4@check_dirA
  00086	f6 44 24 20 10	 test	 BYTE PTR src_info$[rsp], 16
  0008b	74 16		 je	 SHORT $LN4@check_dirA
  0008d	b8 01 00 00 00	 mov	 eax, 1

; 7360 : }

  00092	48 8b 9c 24 80
	02 00 00	 mov	 rbx, QWORD PTR [rsp+640]
  0009a	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@check_dirA:

; 7356 :     return (
; 7357 :         GetFileAttributesExA(src_resolved, GetFileExInfoStandard, &src_info)
; 7358 :         && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
; 7359 :     );

  000a3	33 c0		 xor	 eax, eax

; 7360 : }

  000a5	48 8b 9c 24 80
	02 00 00	 mov	 rbx, QWORD PTR [rsp+640]
  000ad	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
_check_dirA ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@ ; `string'
PUBLIC	??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@ ; `string'
PUBLIC	??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@ ; `string'
PUBLIC	??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_symlink DD imagerel posix_symlink
	DD	imagerel posix_symlink+546
	DD	imagerel $unwind$posix_symlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_symlink DD 091c01H
	DD	026741cH
	DD	025641cH
	DD	024341cH
	DD	022011cH
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@
CONST	SEGMENT
??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@ DB 'symlink: '
	DB	'src and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@
CONST	SEGMENT
??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@ DB 'O&O&|i$O&:syml'
	DB	'ink', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@
CONST	SEGMENT
??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@ DB 'symbolic lin'
	DB	'k privilege not held', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@
CONST	SEGMENT
??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@ DB 'CreateSymbolic'
	DB	'Link functions not found', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_symlink
_TEXT	SEGMENT
dir_fd$ = 96
src$ = 112
dst$ = 192
self$ = 288
args$ = 296
kwargs$ = 304
target_is_directory$ = 312
posix_symlink PROC					; COMDAT

; 7366 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	55		 push	 rbp
  00010	48 8d 6c 24 f0	 lea	 rbp, QWORD PTR [rsp-16]
  00015	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H

; 7367 :     path_t src;
; 7368 :     path_t dst;
; 7369 :     int dir_fd = DEFAULT_DIR_FD;
; 7370 :     int target_is_directory = 0;
; 7371 :     static char *keywords[] = {"src", "dst", "target_is_directory",
; 7372 :                                "dir_fd", NULL};
; 7373 :     PyObject *return_value;
; 7374 : #ifdef MS_WINDOWS
; 7375 :     DWORD result;
; 7376 : #else
; 7377 :     int result;
; 7378 : #endif
; 7379 : 
; 7380 :     memset(&src, 0, sizeof(src));

  0001c	33 c0		 xor	 eax, eax
  0001e	33 db		 xor	 ebx, ebx
  00020	49 8b f8	 mov	 rdi, r8
  00023	48 89 44 24 78	 mov	 QWORD PTR src$[rsp+8], rax
  00028	48 89 44 24 70	 mov	 QWORD PTR src$[rsp], rax
  0002d	48 89 45 80	 mov	 QWORD PTR src$[rbp-240], rax
  00031	48 89 45 88	 mov	 QWORD PTR src$[rbp-232], rax
  00035	48 89 45 90	 mov	 QWORD PTR src$[rbp-224], rax
  00039	48 89 45 98	 mov	 QWORD PTR src$[rbp-216], rax
  0003d	48 89 45 a0	 mov	 QWORD PTR src$[rbp-208], rax
  00041	48 89 45 a8	 mov	 QWORD PTR src$[rbp-200], rax
  00045	48 89 45 b0	 mov	 QWORD PTR src$[rbp-192], rax

; 7381 :     src.argument_name = "src";

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03LOJEKLML@src?$AA@
  00050	48 8b f2	 mov	 rsi, rdx
  00053	c7 44 24 60 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0005b	48 89 44 24 78	 mov	 QWORD PTR src$[rsp+8], rax

; 7382 :     memset(&dst, 0, sizeof(dst));

  00060	33 c0		 xor	 eax, eax
  00062	89 5d 38	 mov	 DWORD PTR target_is_directory$[rbp-256], ebx
  00065	48 89 45 c8	 mov	 QWORD PTR dst$[rbp-248], rax
  00069	48 89 45 c0	 mov	 QWORD PTR dst$[rbp-256], rax
  0006d	48 89 45 d0	 mov	 QWORD PTR dst$[rbp-240], rax
  00071	48 89 45 d8	 mov	 QWORD PTR dst$[rbp-232], rax
  00075	48 89 45 e0	 mov	 QWORD PTR dst$[rbp-224], rax
  00079	48 89 45 e8	 mov	 QWORD PTR dst$[rbp-216], rax
  0007d	48 89 45 f0	 mov	 QWORD PTR dst$[rbp-208], rax
  00081	48 89 45 f8	 mov	 QWORD PTR dst$[rbp-200], rax
  00085	48 89 45 00	 mov	 QWORD PTR dst$[rbp-192], rax

; 7383 :     dst.argument_name = "dst";

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  00090	48 89 45 c8	 mov	 QWORD PTR dst$[rbp-248], rax

; 7384 : 
; 7385 : #ifdef MS_WINDOWS
; 7386 :     if (!check_CreateSymbolicLink()) {

  00094	e8 00 00 00 00	 call	 check_CreateSymbolicLink
  00099	85 c0		 test	 eax, eax
  0009b	75 1a		 jne	 SHORT $LN9@posix_syml

; 7387 :         PyErr_SetString(PyExc_NotImplementedError,
; 7388 :             "CreateSymbolicLink functions not found");

  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@
  000ab	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@posix_syml:

; 7389 :                 return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 52 01 00 00	 jmp	 $LN10@posix_syml
$LN9@posix_syml:

; 7390 :         }
; 7391 :     if (!win32_can_symlink) {

  000b7	39 1d 00 00 00
	00		 cmp	 DWORD PTR win32_can_symlink, ebx
  000bd	75 1a		 jne	 SHORT $LN8@posix_syml

; 7392 :         PyErr_SetString(PyExc_OSError, "symbolic link privilege not held");

  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@
  000cd	e8 00 00 00 00	 call	 PyErr_SetString

; 7393 :                 return NULL;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 30 01 00 00	 jmp	 $LN10@posix_syml
$LN8@posix_syml:

; 7394 :         }
; 7395 : #endif
; 7396 : 
; 7397 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&O&|i$O&:symlink",
; 7398 :             keywords,
; 7399 :             path_converter, &src,
; 7400 :             path_converter, &dst,
; 7401 :             &target_is_directory,
; 7402 : #ifdef HAVE_SYMLINKAT
; 7403 :             dir_fd_converter, &dir_fd
; 7404 : #else
; 7405 :             dir_fd_unavailable, &dir_fd
; 7406 : #endif
; 7407 :             ))

  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  000e0	48 8d 44 24 60	 lea	 rax, QWORD PTR dir_fd$[rsp]
  000e5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_symlink@@9@9
  000ec	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  000f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@
  000ff	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00104	48 8d 45 38	 lea	 rax, QWORD PTR target_is_directory$[rbp-256]
  00108	48 8b d7	 mov	 rdx, rdi
  0010b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00110	48 8d 45 c0	 lea	 rax, QWORD PTR dst$[rbp-256]
  00114	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00119	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011e	48 8d 44 24 70	 lea	 rax, QWORD PTR src$[rsp]
  00123	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00128	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0012d	48 8b ce	 mov	 rcx, rsi
  00130	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00135	85 c0		 test	 eax, eax

; 7408 :         return NULL;

  00137	0f 84 73 ff ff
	ff		 je	 $LN13@posix_syml

; 7409 : 
; 7410 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  0013d	48 39 5d 90	 cmp	 QWORD PTR src$[rbp-224], rbx
  00141	74 06		 je	 SHORT $LN4@posix_syml
  00143	48 39 5d d8	 cmp	 QWORD PTR dst$[rbp-232], rbx
  00147	75 0c		 jne	 SHORT $LN5@posix_syml
$LN4@posix_syml:
  00149	48 39 5d 88	 cmp	 QWORD PTR src$[rbp-232], rbx
  0014d	74 1e		 je	 SHORT $LN6@posix_syml
  0014f	48 39 5d e0	 cmp	 QWORD PTR dst$[rbp-224], rbx
  00153	74 18		 je	 SHORT $LN6@posix_syml
$LN5@posix_syml:

; 7411 :         PyErr_SetString(PyExc_ValueError,
; 7412 :             "symlink: src and dst must be the same type");

  00155	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@
  00163	e8 00 00 00 00	 call	 PyErr_SetString

; 7413 :         return_value = NULL;
; 7414 :         goto exit;

  00168	e9 86 00 00 00	 jmp	 $exit$123476
$LN6@posix_syml:

; 7415 :     }
; 7416 : 
; 7417 : #ifdef MS_WINDOWS
; 7418 : 
; 7419 :     Py_BEGIN_ALLOW_THREADS

  0016d	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7420 :     if (dst.wide) {

  00172	48 8b 55 d8	 mov	 rdx, QWORD PTR dst$[rbp-232]
  00176	48 8b f8	 mov	 rdi, rax
  00179	48 85 d2	 test	 rdx, rdx
  0017c	74 24		 je	 SHORT $LN3@posix_syml

; 7421 :         /* if src is a directory, ensure target_is_directory==1 */
; 7422 :         target_is_directory |= _check_dirW(src.wide, dst.wide);

  0017e	48 8b 4d 88	 mov	 rcx, QWORD PTR src$[rbp-232]
  00182	e8 00 00 00 00	 call	 _check_dirW
  00187	44 8b 45 38	 mov	 r8d, DWORD PTR target_is_directory$[rbp-256]

; 7423 :         result = Py_CreateSymbolicLinkW(dst.wide, src.wide,
; 7424 :                                         target_is_directory);

  0018b	48 8b 55 88	 mov	 rdx, QWORD PTR src$[rbp-232]
  0018f	48 8b 4d d8	 mov	 rcx, QWORD PTR dst$[rbp-232]
  00193	44 0b c0	 or	 r8d, eax
  00196	44 89 45 38	 mov	 DWORD PTR target_is_directory$[rbp-256], r8d
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR Py_CreateSymbolicLinkW

; 7425 :     }
; 7426 :     else {

  001a0	eb 26		 jmp	 SHORT $LN12@posix_syml
$LN3@posix_syml:

; 7427 :         /* if src is a directory, ensure target_is_directory==1 */
; 7428 :         target_is_directory |= _check_dirA(src.narrow, dst.narrow);

  001a2	48 8b 55 e0	 mov	 rdx, QWORD PTR dst$[rbp-224]
  001a6	48 8b 4d 90	 mov	 rcx, QWORD PTR src$[rbp-224]
  001aa	e8 00 00 00 00	 call	 _check_dirA
  001af	44 8b 45 38	 mov	 r8d, DWORD PTR target_is_directory$[rbp-256]

; 7429 :         result = Py_CreateSymbolicLinkA(dst.narrow, src.narrow,
; 7430 :                                         target_is_directory);

  001b3	48 8b 55 90	 mov	 rdx, QWORD PTR src$[rbp-224]
  001b7	48 8b 4d e0	 mov	 rcx, QWORD PTR dst$[rbp-224]
  001bb	44 0b c0	 or	 r8d, eax
  001be	44 89 45 38	 mov	 DWORD PTR target_is_directory$[rbp-256], r8d
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR Py_CreateSymbolicLinkA
$LN12@posix_syml:

; 7431 :     }
; 7432 :     Py_END_ALLOW_THREADS

  001c8	48 8b cf	 mov	 rcx, rdi
  001cb	8b d8		 mov	 ebx, eax
  001cd	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7433 : 
; 7434 :     if (!result) {

  001d2	85 db		 test	 ebx, ebx
  001d4	75 0e		 jne	 SHORT $LN1@posix_syml

; 7435 :         return_value = win32_error_object("symlink", src.object);

  001d6	48 8b 4d a8	 mov	 rcx, QWORD PTR src$[rbp-200]
  001da	e8 00 00 00 00	 call	 win32_error_object
  001df	48 8b d8	 mov	 rbx, rax

; 7436 :         goto exit;

  001e2	eb 0f		 jmp	 SHORT $exit$123476
$LN1@posix_syml:

; 7437 :     }
; 7438 : 
; 7439 : #else
; 7440 : 
; 7441 :     Py_BEGIN_ALLOW_THREADS
; 7442 : #if HAVE_SYMLINKAT
; 7443 :     if (dir_fd != DEFAULT_DIR_FD)
; 7444 :         result = symlinkat(src.narrow, dir_fd, dst.narrow);
; 7445 :     else
; 7446 : #endif
; 7447 :         result = symlink(src.narrow, dst.narrow);
; 7448 :     Py_END_ALLOW_THREADS
; 7449 : 
; 7450 :     if (result) {
; 7451 :         return_value = path_error("symlink", &dst);
; 7452 :         goto exit;
; 7453 :     }
; 7454 : #endif
; 7455 : 
; 7456 :     return_value = Py_None;

  001e4	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct

; 7457 :     Py_INCREF(Py_None);

  001eb	48 8b cb	 mov	 rcx, rbx
  001ee	e8 00 00 00 00	 call	 _Py_IncRef
$exit$123476:

; 7458 :     goto exit; /* silence "unused label" warning */
; 7459 : exit:
; 7460 :     path_cleanup(&src);

  001f3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR src$[rsp]
  001f8	e8 00 00 00 00	 call	 path_cleanup

; 7461 :     path_cleanup(&dst);

  001fd	48 8d 4d c0	 lea	 rcx, QWORD PTR dst$[rbp-256]
  00201	e8 00 00 00 00	 call	 path_cleanup

; 7462 :     return return_value;

  00206	48 8b c3	 mov	 rax, rbx
$LN10@posix_syml:

; 7463 : }

  00209	4c 8d 9c 24 10
	01 00 00	 lea	 r11, QWORD PTR [rsp+272]
  00211	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00215	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00219	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  0021d	49 8b e3	 mov	 rsp, r11
  00220	5d		 pop	 rbp
  00221	c3		 ret	 0
posix_symlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@	; `string'
PUBLIC	??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$win_readlink DD imagerel win_readlink
	DD	imagerel win_readlink+98
	DD	imagerel $unwind$win_readlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$win_readlink DD imagerel win_readlink+98
	DD	imagerel win_readlink+135
	DD	imagerel $chain$0$win_readlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$win_readlink DD imagerel win_readlink+135
	DD	imagerel win_readlink+406
	DD	imagerel $chain$4$win_readlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$win_readlink DD 061021H
	DD	080d6410H
	DD	080c3408H
	DD	080a7400H
	DD	imagerel win_readlink
	DD	imagerel win_readlink+98
	DD	imagerel $unwind$win_readlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$win_readlink DD 020821H
	DD	080a7408H
	DD	imagerel win_readlink
	DD	imagerel win_readlink+98
	DD	imagerel $unwind$win_readlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win_readlink DD 020d01H
	DD	080b010dH
xdata	ENDS
;	COMDAT ??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@
CONST	SEGMENT
??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@ DB 'not a symbolic link', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@
CONST	SEGMENT
??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@ DB 'U|$O&:readlink', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win_readlink
_TEXT	SEGMENT
po$ = 64
n_bytes_returned$ = 72
target_buffer$ = 80
self$ = 16480
args$ = 16488
kwargs$ = 16496
dir_fd$ = 16504
win_readlink PROC					; COMDAT

; 7472 : {

  00000	b8 58 40 00 00	 mov	 eax, 16472		; 00004058H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	48 2b e0	 sub	 rsp, rax
  0000d	49 8b c0	 mov	 rax, r8
  00010	4c 8b d2	 mov	 r10, rdx

; 7473 :     wchar_t *path;
; 7474 :     DWORD n_bytes_returned;
; 7475 :     DWORD io_result;
; 7476 :     PyObject *po, *result;
; 7477 :         int dir_fd;
; 7478 :     HANDLE reparse_point_handle;
; 7479 : 
; 7480 :     char target_buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
; 7481 :     REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER *)target_buffer;
; 7482 :     wchar_t *print_name;
; 7483 : 
; 7484 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 7485 : 
; 7486 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "U|$O&:readlink", keywords,
; 7487 :                           &po,
; 7488 :                           dir_fd_unavailable, &dir_fd
; 7489 :                           ))

  00013	48 8d 8c 24 78
	40 00 00	 lea	 rcx, QWORD PTR dir_fd$[rsp]
  0001b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??win_readlink@@9@9
  0002e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00033	48 8d 4c 24 40	 lea	 rcx, QWORD PTR po$[rsp]
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@
  0003f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00044	49 8b ca	 mov	 rcx, r10
  00047	48 8b d0	 mov	 rdx, rax
  0004a	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004f	85 c0		 test	 eax, eax
  00051	75 0a		 jne	 SHORT $LN5@win_readli

; 7490 :         return NULL;

  00053	33 c0		 xor	 eax, eax

; 7539 : }

  00055	48 81 c4 58 40
	00 00		 add	 rsp, 16472		; 00004058H
  0005c	c3		 ret	 0
$LN5@win_readli:

; 7491 : 
; 7492 :     path = PyUnicode_AsUnicode(po);

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR po$[rsp]
  00062	48 89 bc 24 50
	40 00 00	 mov	 QWORD PTR [rsp+16464], rdi
  0006a	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0006f	48 8b f8	 mov	 rdi, rax

; 7493 :     if (path == NULL)

  00072	48 85 c0	 test	 rax, rax
  00075	75 10		 jne	 SHORT $LN4@win_readli
  00077	48 8b bc 24 50
	40 00 00	 mov	 rdi, QWORD PTR [rsp+16464]

; 7539 : }

  0007f	48 81 c4 58 40
	00 00		 add	 rsp, 16472		; 00004058H
  00086	c3		 ret	 0
$LN4@win_readli:
  00087	48 89 9c 24 60
	40 00 00	 mov	 QWORD PTR [rsp+16480], rbx
  0008f	48 89 b4 24 68
	40 00 00	 mov	 QWORD PTR [rsp+16488], rsi

; 7494 :         return NULL;
; 7495 : 
; 7496 :     /* First get a handle to the reparse point */
; 7497 :     Py_BEGIN_ALLOW_THREADS

  00097	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7498 :     reparse_point_handle = CreateFileW(
; 7499 :         path,
; 7500 :         0,
; 7501 :         0,
; 7502 :         0,
; 7503 :         OPEN_EXISTING,
; 7504 :         FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS,
; 7505 :         0);

  0009c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a5	45 33 c9	 xor	 r9d, r9d
  000a8	45 33 c0	 xor	 r8d, r8d
  000ab	33 d2		 xor	 edx, edx
  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	c7 44 24 28 00
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651584 ; 02200000H
  000b8	48 8b d8	 mov	 rbx, rax
  000bb	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW

; 7506 :     Py_END_ALLOW_THREADS

  000c9	48 8b cb	 mov	 rcx, rbx
  000cc	48 8b f0	 mov	 rsi, rax
  000cf	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7507 : 
; 7508 :     if (reparse_point_handle==INVALID_HANDLE_VALUE)

  000d4	48 83 fe ff	 cmp	 rsi, -1

; 7509 :         return win32_error_object("readlink", po);

  000d8	74 58		 je	 SHORT $LN11@win_readli

; 7510 : 
; 7511 :     Py_BEGIN_ALLOW_THREADS

  000da	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7512 :     /* New call DeviceIoControl to read the reparse point */
; 7513 :     io_result = DeviceIoControl(
; 7514 :         reparse_point_handle,
; 7515 :         FSCTL_GET_REPARSE_POINT,
; 7516 :         0, 0, /* in buffer */
; 7517 :         target_buffer, sizeof(target_buffer),
; 7518 :         &n_bytes_returned,
; 7519 :         0 /* we're not using OVERLAPPED_IO */
; 7520 :         );

  000df	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000e8	45 33 c9	 xor	 r9d, r9d
  000eb	48 8b f8	 mov	 rdi, rax
  000ee	48 8d 44 24 48	 lea	 rax, QWORD PTR n_bytes_returned$[rsp]
  000f3	45 33 c0	 xor	 r8d, r8d
  000f6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000fb	48 8d 44 24 50	 lea	 rax, QWORD PTR target_buffer$[rsp]
  00100	ba a8 00 09 00	 mov	 edx, 589992		; 000900a8H
  00105	48 8b ce	 mov	 rcx, rsi
  00108	c7 44 24 28 00
	40 00 00	 mov	 DWORD PTR [rsp+40], 16384 ; 00004000H
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl

; 7521 :     CloseHandle(reparse_point_handle);

  0011b	48 8b ce	 mov	 rcx, rsi
  0011e	8b d8		 mov	 ebx, eax
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 7522 :     Py_END_ALLOW_THREADS

  00126	48 8b cf	 mov	 rcx, rdi
  00129	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7523 : 
; 7524 :     if (io_result==0)

  0012e	85 db		 test	 ebx, ebx
  00130	75 0c		 jne	 SHORT $LN2@win_readli
$LN11@win_readli:

; 7525 :         return win32_error_object("readlink", po);

  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR po$[rsp]
  00137	e8 00 00 00 00	 call	 win32_error_object
  0013c	eb 38		 jmp	 SHORT $LN10@win_readli
$LN2@win_readli:

; 7526 : 
; 7527 :     if (rdb->ReparseTag != IO_REPARSE_TAG_SYMLINK)

  0013e	81 7c 24 50 0c
	00 00 a0	 cmp	 DWORD PTR target_buffer$[rsp], -1610612724 ; a000000cH
  00146	74 17		 je	 SHORT $LN1@win_readli

; 7528 :     {
; 7529 :         PyErr_SetString(PyExc_ValueError,
; 7530 :                 "not a symbolic link");

  00148	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@
  00156	e8 00 00 00 00	 call	 PyErr_SetString

; 7531 :         return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	eb 17		 jmp	 SHORT $LN10@win_readli
$LN1@win_readli:

; 7532 :     }
; 7533 :     print_name = rdb->SymbolicLinkReparseBuffer.PathBuffer +
; 7534 :                  rdb->SymbolicLinkReparseBuffer.PrintNameOffset;

  0015f	0f b7 44 24 5c	 movzx	 eax, WORD PTR target_buffer$[rsp+12]

; 7535 : 
; 7536 :     result = PyUnicode_FromWideChar(print_name,
; 7537 :                     rdb->SymbolicLinkReparseBuffer.PrintNameLength/2);
; 7538 :     return result;

  00164	0f b7 54 24 5e	 movzx	 edx, WORD PTR target_buffer$[rsp+14]
  00169	48 8d 4c 44 64	 lea	 rcx, QWORD PTR target_buffer$[rsp+rax*2+20]
  0016e	48 d1 ea	 shr	 rdx, 1
  00171	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
$LN10@win_readli:
  00176	48 8b b4 24 68
	40 00 00	 mov	 rsi, QWORD PTR [rsp+16488]
  0017e	48 8b 9c 24 60
	40 00 00	 mov	 rbx, QWORD PTR [rsp+16480]
  00186	48 8b bc 24 50
	40 00 00	 mov	 rdi, QWORD PTR [rsp+16464]

; 7539 : }

  0018e	48 81 c4 58 40
	00 00		 add	 rsp, 16472		; 00004058H
  00195	c3		 ret	 0
win_readlink ENDP
_TEXT	ENDS
_BSS	SEGMENT
TimesResultType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_times_result DD imagerel build_times_result
	DD	imagerel build_times_result+215
	DD	imagerel $unwind$build_times_result
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_times_result DD 0a3001H
	DD	029830H
	DD	038816H
	DD	047810H
	DD	05680bH
	DD	03002b206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT build_times_result
_TEXT	SEGMENT
user$ = 112
system$ = 120
children_user$ = 128
children_system$ = 136
elapsed$ = 144
build_times_result PROC					; COMDAT

; 7581 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  0000b	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  00010	44 0f 29 44 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm8

; 7582 :     PyObject *value = PyStructSequence_New(&TimesResultType);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TimesResultType
  0001d	66 0f 28 fb	 movapd	 xmm7, xmm3
  00021	66 44 0f 28 c2	 movapd	 xmm8, xmm2
  00026	66 0f 28 f0	 movapd	 xmm6, xmm0
  0002a	44 0f 29 4c 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm9
  00030	66 44 0f 28 c9	 movapd	 xmm9, xmm1
  00035	e8 00 00 00 00	 call	 PyStructSequence_New
  0003a	48 8b d8	 mov	 rbx, rax

; 7583 :     if (value == NULL)

  0003d	48 85 c0	 test	 rax, rax

; 7584 :         return NULL;

  00040	74 16		 je	 SHORT $LN9@build_time

; 7585 : 
; 7586 : #define SET(i, field) \
; 7587 :     { \
; 7588 :     PyObject *o = PyFloat_FromDouble(field); \
; 7589 :     if (!o) { \
; 7590 :         Py_DECREF(value); \
; 7591 :         return NULL; \
; 7592 :     } \
; 7593 :     PyStructSequence_SET_ITEM(value, i, o); \
; 7594 :     } \
; 7595 : 
; 7596 :     SET(0, user);

  00042	66 0f 28 c6	 movapd	 xmm0, xmm6
  00046	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0004b	48 85 c0	 test	 rax, rax
  0004e	75 0c		 jne	 SHORT $LN5@build_time
$LN10@build_time:
  00050	48 8b cb	 mov	 rcx, rbx
  00053	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@build_time:
  00058	33 c0		 xor	 eax, eax
  0005a	eb 5f		 jmp	 SHORT $LN7@build_time
$LN5@build_time:

; 7597 :     SET(1, system);

  0005c	66 41 0f 28 c1	 movapd	 xmm0, xmm9
  00061	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  00065	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0006a	48 85 c0	 test	 rax, rax
  0006d	74 e1		 je	 SHORT $LN10@build_time

; 7598 :     SET(2, children_user);

  0006f	66 41 0f 28 c0	 movapd	 xmm0, xmm8
  00074	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
  00078	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0007d	48 85 c0	 test	 rax, rax
  00080	74 ce		 je	 SHORT $LN10@build_time

; 7599 :     SET(3, children_system);

  00082	66 0f 28 c7	 movapd	 xmm0, xmm7
  00086	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  0008d	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00092	48 85 c0	 test	 rax, rax
  00095	74 b9		 je	 SHORT $LN10@build_time

; 7600 :     SET(4, elapsed);

  00097	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR elapsed$[rsp]
  000a0	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
  000a7	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000ac	48 85 c0	 test	 rax, rax
  000af	74 9f		 je	 SHORT $LN10@build_time
  000b1	48 89 83 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rax

; 7601 : 
; 7602 : #undef SET
; 7603 : 
; 7604 :     return value;

  000b8	48 8b c3	 mov	 rax, rbx
$LN7@build_time:

; 7605 : }

  000bb	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  000c0	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  000c5	44 0f 28 44 24
	30		 movaps	 xmm8, XMMWORD PTR [rsp+48]
  000cb	44 0f 28 4c 24
	20		 movaps	 xmm9, XMMWORD PTR [rsp+32]
  000d1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000d5	5b		 pop	 rbx
  000d6	c3		 ret	 0
build_times_result ENDP
_TEXT	ENDS
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__real@407ad7f29abcaf48
EXTRN	__imp_GetProcessTimes:PROC
EXTRN	__imp_GetCurrentProcess:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_times DD imagerel posix_times
	DD	imagerel posix_times+161
	DD	imagerel $unwind$posix_times
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_times DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT __real@407ad7f29abcaf48
CONST	SEGMENT
__real@407ad7f29abcaf48 DQ 0407ad7f29abcaf48r	; 429.497
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_times
_TEXT	SEGMENT
exit$ = 48
create$ = 56
self$ = 80
noargs$ = 88
kernel$ = 96
user$ = 104
posix_times PROC					; COMDAT

; 7640 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 7641 :     FILETIME create, exit, kernel, user;
; 7642 :     HANDLE hProc;
; 7643 :     hProc = GetCurrentProcess();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess

; 7644 :     GetProcessTimes(hProc, &create, &exit, &kernel, &user);

  0000a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR user$[rsp]
  0000f	4c 8d 4c 24 60	 lea	 r9, QWORD PTR kernel$[rsp]
  00014	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00019	4c 8d 44 24 30	 lea	 r8, QWORD PTR exit$[rsp]
  0001e	48 8d 54 24 38	 lea	 rdx, QWORD PTR create$[rsp]
  00023	48 8b c8	 mov	 rcx, rax
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessTimes

; 7645 :     /* The fields of a FILETIME structure are the hi and lo part
; 7646 :        of a 64-bit value expressed in 100 nanosecond units.
; 7647 :        1e7 is one second in such units; 1e-7 the inverse.
; 7648 :        429.4967296 is 2**32 / 1e7 or 2**32 * 1e-7.
; 7649 :     */
; 7650 :     return build_times_result(
; 7651 :         (double)(user.dwHighDateTime*429.4967296 +
; 7652 :                  user.dwLowDateTime*1e-7),
; 7653 :         (double)(kernel.dwHighDateTime*429.4967296 +
; 7654 :                  kernel.dwLowDateTime*1e-7),
; 7655 :         (double)0,
; 7656 :         (double)0,
; 7657 :         (double)0);

  0002c	8b 44 24 64	 mov	 eax, DWORD PTR kernel$[rsp+4]
  00030	44 8b 5c 24 60	 mov	 r11d, DWORD PTR kernel$[rsp]
  00035	66 0f ef c0	 pxor	 xmm0, xmm0
  00039	66 0f ef c9	 pxor	 xmm1, xmm1
  0003d	66 0f ef d2	 pxor	 xmm2, xmm2
  00041	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00046	8b 44 24 68	 mov	 eax, DWORD PTR user$[rsp]
  0004a	f2 49 0f 2a cb	 cvtsi2sd xmm1, r11
  0004f	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@407ad7f29abcaf48
  00057	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e7ad7f29abcaf48
  0005f	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00063	66 0f ef c0	 pxor	 xmm0, xmm0
  00067	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0006c	8b 44 24 6c	 mov	 eax, DWORD PTR user$[rsp+4]
  00070	f2 48 0f 2a d0	 cvtsi2sd xmm2, rax
  00075	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3e7ad7f29abcaf48
  0007d	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@407ad7f29abcaf48
  00085	f2 0f 58 c2	 addsd	 xmm0, xmm2
  00089	66 0f 57 d2	 xorpd	 xmm2, xmm2
  0008d	66 0f 28 da	 movapd	 xmm3, xmm2
  00091	f2 0f 11 54 24
	20		 movsdx	 QWORD PTR [rsp+32], xmm2
  00097	e8 00 00 00 00	 call	 build_times_result

; 7658 : }

  0009c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a0	c3		 ret	 0
posix_times ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@	; `string'
EXTRN	__imp_open:PROC
EXTRN	__imp__wopen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_open DD imagerel posix_open
	DD	imagerel posix_open+180
	DD	imagerel $unwind$posix_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_open DD imagerel posix_open+180
	DD	imagerel posix_open+253
	DD	imagerel $chain$1$posix_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_open DD imagerel posix_open+253
	DD	imagerel posix_open+317
	DD	imagerel $chain$2$posix_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_open DD 021H
	DD	imagerel posix_open
	DD	imagerel posix_open+180
	DD	imagerel $unwind$posix_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_open DD 020821H
	DD	0197408H
	DD	imagerel posix_open
	DD	imagerel posix_open+180
	DD	imagerel $unwind$posix_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_open DD 05b401H
	DD	01834b4H
	DD	016010eH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@
CONST	SEGMENT
??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@ DB 'O&i|i$O&:open', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_open
_TEXT	SEGMENT
flags$ = 80
dir_fd$ = 84
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
mode$ = 216
posix_open PROC						; COMDAT

; 7790 : {

  00000	40 55		 push	 rbp
  00002	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00007	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 7791 :     path_t path;
; 7792 :     int flags;
; 7793 :     int mode = 0777;
; 7794 :     int dir_fd = DEFAULT_DIR_FD;
; 7795 :     int fd;
; 7796 :     PyObject *return_value = NULL;
; 7797 :     static char *keywords[] = {"path", "flags", "mode", "dir_fd", NULL};
; 7798 : 
; 7799 :     memset(&path, 0, sizeof(path));

  0000e	33 c9		 xor	 ecx, ecx
  00010	49 8b c0	 mov	 rax, r8
  00013	4c 8b d2	 mov	 r10, rdx
  00016	48 89 4d 07	 mov	 QWORD PTR path$[rbp-89], rcx
  0001a	48 89 4d 0f	 mov	 QWORD PTR path$[rbp-81], rcx
  0001e	48 89 4d 17	 mov	 QWORD PTR path$[rbp-73], rcx
  00022	48 89 4d 1f	 mov	 QWORD PTR path$[rbp-65], rcx
  00026	48 89 4d 27	 mov	 QWORD PTR path$[rbp-57], rcx
  0002a	48 89 4d 2f	 mov	 QWORD PTR path$[rbp-49], rcx
  0002e	48 89 4d 37	 mov	 QWORD PTR path$[rbp-41], rcx
  00032	48 89 4d 3f	 mov	 QWORD PTR path$[rbp-33], rcx
  00036	48 89 4d 47	 mov	 QWORD PTR path$[rbp-25], rcx

; 7800 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|i$O&:open", keywords,
; 7801 :         path_converter, &path,
; 7802 :         &flags, &mode,
; 7803 : #ifdef HAVE_OPENAT
; 7804 :         dir_fd_converter, &dir_fd
; 7805 : #else
; 7806 :         dir_fd_unavailable, &dir_fd
; 7807 : #endif
; 7808 :         ))

  0003a	48 8d 4d fb	 lea	 rcx, QWORD PTR dir_fd$[rbp-89]
  0003e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_open@@9@9
  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@
  0004c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00058	48 8b d0	 mov	 rdx, rax
  0005b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00060	48 8d 4d 7f	 lea	 rcx, QWORD PTR mode$[rbp-89]
  00064	c7 45 7f ff 01
	00 00		 mov	 DWORD PTR mode$[rbp-89], 511 ; 000001ffH
  0006b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00070	48 8d 4d f7	 lea	 rcx, QWORD PTR flags$[rbp-89]
  00074	c7 45 fb 9c ff
	ff ff		 mov	 DWORD PTR dir_fd$[rbp-89], -100 ; ffffffffffffff9cH
  0007b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00080	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00090	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00095	49 8b ca	 mov	 rcx, r10
  00098	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009d	85 c0		 test	 eax, eax
  0009f	75 0b		 jne	 SHORT $LN6@posix_open

; 7809 :         return NULL;

  000a1	33 c0		 xor	 eax, eax

; 7841 : }

  000a3	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  000aa	5d		 pop	 rbp
  000ab	c3		 ret	 0
$LN6@posix_open:
  000ac	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  000b4	48 89 bc 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rdi

; 7810 : 
; 7811 :     Py_BEGIN_ALLOW_THREADS

  000bc	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7812 : #ifdef MS_WINDOWS
; 7813 :     if (path.wide)

  000c1	48 8b 4d 1f	 mov	 rcx, QWORD PTR path$[rbp-65]

; 7814 :         fd = _wopen(path.wide, flags, mode);

  000c5	44 8b 45 7f	 mov	 r8d, DWORD PTR mode$[rbp-89]
  000c9	8b 55 f7	 mov	 edx, DWORD PTR flags$[rbp-89]
  000cc	48 8b f8	 mov	 rdi, rax
  000cf	48 85 c9	 test	 rcx, rcx
  000d2	74 08		 je	 SHORT $LN5@posix_open
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen

; 7815 :     else

  000da	eb 0a		 jmp	 SHORT $LN9@posix_open
$LN5@posix_open:

; 7816 : #endif
; 7817 : #ifdef HAVE_OPENAT
; 7818 :     if (dir_fd != DEFAULT_DIR_FD)
; 7819 :         fd = openat(dir_fd, path.narrow, flags, mode);
; 7820 :     else
; 7821 : #endif
; 7822 :         fd = open(path.narrow, flags, mode);

  000dc	48 8b 4d 27	 mov	 rcx, QWORD PTR path$[rbp-57]
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
$LN9@posix_open:

; 7823 :     Py_END_ALLOW_THREADS

  000e6	48 8b cf	 mov	 rcx, rdi
  000e9	8b d8		 mov	 ebx, eax
  000eb	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000f0	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+200]

; 7824 : 
; 7825 :     if (fd == -1) {

  000f8	83 fb ff	 cmp	 ebx, -1
  000fb	75 19		 jne	 SHORT $LN3@posix_open

; 7826 : #ifdef MS_WINDOWS
; 7827 :         /* force use of posix_error here for exact backwards compatibility */
; 7828 :         if (path.wide)

  000fd	48 83 7d 1f 00	 cmp	 QWORD PTR path$[rbp-65], 0
  00102	74 07		 je	 SHORT $LN2@posix_open

; 7829 :             return_value = posix_error();

  00104	e8 00 00 00 00	 call	 posix_error

; 7830 :         else

  00109	eb 12		 jmp	 SHORT $LN10@posix_open
$LN2@posix_open:

; 7831 : #endif
; 7832 :         return_value = path_error("open", &path);

  0010b	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  0010f	e8 00 00 00 00	 call	 path_error

; 7833 :         goto exit;

  00114	eb 07		 jmp	 SHORT $LN10@posix_open
$LN3@posix_open:

; 7834 :     }
; 7835 : 
; 7836 :     return_value = PyLong_FromLong((long)fd);

  00116	8b cb		 mov	 ecx, ebx
  00118	e8 00 00 00 00	 call	 PyLong_FromLong
$LN10@posix_open:

; 7837 : 
; 7838 : exit:
; 7839 :     path_cleanup(&path);

  0011d	48 8d 4d 07	 lea	 rcx, QWORD PTR path$[rbp-89]
  00121	48 8b d8	 mov	 rbx, rax
$exit$123627:
  00124	e8 00 00 00 00	 call	 path_cleanup

; 7840 :     return return_value;

  00129	48 8b c3	 mov	 rax, rbx
  0012c	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]

; 7841 : }

  00134	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  0013b	5d		 pop	 rbp
  0013c	c3		 ret	 0
posix_open ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KGLACIBM@i?3close?$AA@			; `string'
EXTRN	__imp_close:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_close_ DD imagerel posix_close_
	DD	imagerel posix_close_+58
	DD	imagerel $unwind$posix_close_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_close_ DD imagerel posix_close_+58
	DD	imagerel posix_close_+110
	DD	imagerel $chain$1$posix_close_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_close_ DD imagerel posix_close_+110
	DD	imagerel posix_close_+191
	DD	imagerel $chain$2$posix_close_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_close_ DD 021H
	DD	imagerel posix_close_
	DD	imagerel posix_close_+58
	DD	imagerel $unwind$posix_close_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_close_ DD 040a21H
	DD	06740aH
	DD	083405H
	DD	imagerel posix_close_
	DD	imagerel posix_close_+58
	DD	imagerel $unwind$posix_close_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_close_ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_07KGLACIBM@i?3close?$AA@
CONST	SEGMENT
??_C@_07KGLACIBM@i?3close?$AA@ DB 'i:close', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_close_
_TEXT	SEGMENT
self$ = 64
args$ = 72
fd$ = 80
posix_close_ PROC					; COMDAT

; 7853 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7854 :     int fd, res;
; 7855 :     if (!PyArg_ParseTuple(args, "i:close", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KGLACIBM@i?3close?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN3@posix_clos

; 7856 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 7866 : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN3@posix_clos:

; 7857 :     if (!_PyVerify_fd(fd))

  00023	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  00027	e8 00 00 00 00	 call	 _PyVerify_fd
  0002c	85 c0		 test	 eax, eax
  0002e	75 0a		 jne	 SHORT $LN2@posix_clos
$LN10@posix_clos:

; 7858 :         return posix_error();

  00030	e8 00 00 00 00	 call	 posix_error

; 7866 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
$LN2@posix_clos:
  0003a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0003f	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 7859 :     Py_BEGIN_ALLOW_THREADS

  00044	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7860 :     res = close(fd);

  00049	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0004d	48 8b f8	 mov	 rdi, rax
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 7861 :     Py_END_ALLOW_THREADS

  00056	48 8b cf	 mov	 rcx, rdi
  00059	8b d8		 mov	 ebx, eax
  0005b	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00060	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 7862 :     if (res < 0)

  00065	85 db		 test	 ebx, ebx
  00067	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 7863 :         return posix_error();

  0006c	78 c2		 js	 SHORT $LN10@posix_clos

; 7864 :     Py_INCREF(Py_None);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 3c		 jne	 SHORT $LN7@posix_clos
  00077	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00092	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009f	85 c0		 test	 eax, eax
  000a1	75 09		 jne	 SHORT $LN6@posix_clos
  000a3	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000aa	74 07		 je	 SHORT $LN7@posix_clos
$LN6@posix_clos:
  000ac	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@posix_clos:

; 7865 :     return Py_None;

  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 7866 : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
posix_close_ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@GNICGHEB@ii?3closerange?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_closerange DD imagerel posix_closerange
	DD	imagerel posix_closerange+40
	DD	imagerel $unwind$posix_closerange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_closerange DD imagerel posix_closerange+40
	DD	imagerel posix_closerange+122
	DD	imagerel $chain$1$posix_closerange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_closerange DD imagerel posix_closerange+122
	DD	imagerel posix_closerange+194
	DD	imagerel $chain$2$posix_closerange
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_closerange DD 021H
	DD	imagerel posix_closerange
	DD	imagerel posix_closerange+40
	DD	imagerel $unwind$posix_closerange
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_closerange DD 040a21H
	DD	06740aH
	DD	083405H
	DD	imagerel posix_closerange
	DD	imagerel posix_closerange+40
	DD	imagerel $unwind$posix_closerange
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_closerange DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0O@GNICGHEB@ii?3closerange?$AA@
CONST	SEGMENT
??_C@_0O@GNICGHEB@ii?3closerange?$AA@ DB 'ii:closerange', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_closerange
_TEXT	SEGMENT
self$ = 64
args$ = 72
fd_to$ = 80
fd_from$ = 88
posix_closerange PROC					; COMDAT

; 7875 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7876 :     int fd_from, fd_to, i;
; 7877 :     if (!PyArg_ParseTuple(args, "ii:closerange", &fd_from, &fd_to))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 50	 lea	 r9, QWORD PTR fd_to$[rsp]
  0000c	4c 8d 44 24 58	 lea	 r8, QWORD PTR fd_from$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@GNICGHEB@ii?3closerange?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN5@posix_clos@2

; 7878 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 7885 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN5@posix_clos@2:
  00028	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0002d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 7879 :     Py_BEGIN_ALLOW_THREADS

  00032	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7880 :     for (i = fd_from; i < fd_to; i++)

  00037	8b 5c 24 58	 mov	 ebx, DWORD PTR fd_from$[rsp]
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	3b 5c 24 50	 cmp	 ebx, DWORD PTR fd_to$[rsp]
  00042	7d 1b		 jge	 SHORT $LN2@posix_clos@2
$LL4@posix_clos@2:

; 7881 :         if (_PyVerify_fd(i))

  00044	8b cb		 mov	 ecx, ebx
  00046	e8 00 00 00 00	 call	 _PyVerify_fd
  0004b	85 c0		 test	 eax, eax
  0004d	74 08		 je	 SHORT $LN3@posix_clos@2

; 7882 :             close(i);

  0004f	8b cb		 mov	 ecx, ebx
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN3@posix_clos@2:

; 7880 :     for (i = fd_from; i < fd_to; i++)

  00057	ff c3		 inc	 ebx
  00059	3b 5c 24 50	 cmp	 ebx, DWORD PTR fd_to$[rsp]
  0005d	7c e5		 jl	 SHORT $LL4@posix_clos@2
$LN2@posix_clos@2:

; 7883 :     Py_END_ALLOW_THREADS

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7884 :     Py_RETURN_NONE;

  00067	e8 00 00 00 00	 call	 _Py_PXCTX
  0006c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	85 c0		 test	 eax, eax
  00078	75 3c		 jne	 SHORT $LN9@posix_clos@2
  0007a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00095	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009d	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a2	85 c0		 test	 eax, eax
  000a4	75 09		 jne	 SHORT $LN8@posix_clos@2
  000a6	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000ad	74 07		 je	 SHORT $LN9@posix_clos@2
$LN8@posix_clos@2:
  000af	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@posix_clos@2:
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 7885 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
posix_closerange ENDP
_TEXT	ENDS
PUBLIC	??_C@_05EDBGBDPA@i?3dup?$AA@			; `string'
EXTRN	__imp_dup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_dup DD imagerel posix_dup
	DD	imagerel posix_dup+88
	DD	imagerel $unwind$posix_dup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_dup DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_05EDBGBDPA@i?3dup?$AA@
CONST	SEGMENT
??_C@_05EDBGBDPA@i?3dup?$AA@ DB 'i:dup', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_dup
_TEXT	SEGMENT
self$ = 48
args$ = 56
fd$ = 64
posix_dup PROC						; COMDAT

; 7894 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7895 :     int fd;
; 7896 :     if (!PyArg_ParseTuple(args, "i:dup", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05EDBGBDPA@i?3dup?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN3@posix_dup

; 7897 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 7904 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN3@posix_dup:

; 7898 :     if (!_PyVerify_fd(fd))

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00027	e8 00 00 00 00	 call	 _PyVerify_fd
  0002c	85 c0		 test	 eax, eax
  0002e	75 0a		 jne	 SHORT $LN2@posix_dup
$LN6@posix_dup:

; 7899 :         return posix_error();

  00030	e8 00 00 00 00	 call	 posix_error

; 7904 : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
$LN2@posix_dup:

; 7900 :     fd = dup(fd);

  0003a	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  00044	89 44 24 40	 mov	 DWORD PTR fd$[rsp], eax

; 7901 :     if (fd < 0)

  00048	85 c0		 test	 eax, eax

; 7902 :         return posix_error();

  0004a	78 e4		 js	 SHORT $LN6@posix_dup

; 7903 :     return PyLong_FromLong((long)fd);

  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 PyLong_FromLong

; 7904 : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
posix_dup ENDP
_TEXT	ENDS
PUBLIC	??_C@_07GHGEALPJ@ii?3dup2?$AA@			; `string'
EXTRN	__imp_dup2:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_dup2 DD imagerel posix_dup2
	DD	imagerel posix_dup2+166
	DD	imagerel $unwind$posix_dup2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_dup2 DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_07GHGEALPJ@ii?3dup2?$AA@
CONST	SEGMENT
??_C@_07GHGEALPJ@ii?3dup2?$AA@ DB 'ii:dup2', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_dup2
_TEXT	SEGMENT
self$ = 64
args$ = 72
fd2$ = 80
fd$ = 88
posix_dup2 PROC						; COMDAT

; 7913 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7914 :     int fd, fd2, res;
; 7915 :     if (!PyArg_ParseTuple(args, "ii:dup2", &fd, &fd2))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 50	 lea	 r9, QWORD PTR fd2$[rsp]
  0000c	4c 8d 44 24 58	 lea	 r8, QWORD PTR fd$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GHGEALPJ@ii?3dup2?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN3@posix_dup2

; 7916 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 7924 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN3@posix_dup2:

; 7917 :     if (!_PyVerify_fd_dup2(fd, fd2))

  00028	8b 54 24 50	 mov	 edx, DWORD PTR fd2$[rsp]
  0002c	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _PyVerify_fd_dup2
  00035	85 c0		 test	 eax, eax
  00037	75 0a		 jne	 SHORT $LN2@posix_dup2
$LN10@posix_dup2:

; 7918 :         return posix_error();

  00039	e8 00 00 00 00	 call	 posix_error

; 7924 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
$LN2@posix_dup2:

; 7919 :     res = dup2(fd, fd2);

  00043	8b 54 24 50	 mov	 edx, DWORD PTR fd2$[rsp]
  00047	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup2

; 7920 :     if (res < 0)

  00051	85 c0		 test	 eax, eax

; 7921 :         return posix_error();

  00053	78 e4		 js	 SHORT $LN10@posix_dup2

; 7922 :     Py_INCREF(Py_None);

  00055	e8 00 00 00 00	 call	 _Py_PXCTX
  0005a	85 c0		 test	 eax, eax
  0005c	75 3c		 jne	 SHORT $LN7@posix_dup2
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00073	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00079	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00081	e8 00 00 00 00	 call	 _PyParallel_Guard
  00086	85 c0		 test	 eax, eax
  00088	75 09		 jne	 SHORT $LN6@posix_dup2
  0008a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00091	74 07		 je	 SHORT $LN7@posix_dup2
$LN6@posix_dup2:
  00093	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN7@posix_dup2:

; 7923 :     return Py_None;

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 7924 : }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
posix_dup2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PGLCNMMB@iOi?3lseek?$AA@		; `string'
EXTRN	__imp__lseeki64:PROC
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_lseek DD imagerel posix_lseek
	DD	imagerel posix_lseek+57
	DD	imagerel $unwind$posix_lseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_lseek DD imagerel posix_lseek+57
	DD	imagerel posix_lseek+137
	DD	imagerel $chain$0$posix_lseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_lseek DD imagerel posix_lseek+137
	DD	imagerel posix_lseek+150
	DD	imagerel $chain$2$posix_lseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$posix_lseek DD imagerel posix_lseek+150
	DD	imagerel posix_lseek+202
	DD	imagerel $chain$3$posix_lseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix_lseek DD imagerel posix_lseek+202
	DD	imagerel posix_lseek+217
	DD	imagerel $chain$4$posix_lseek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$posix_lseek DD imagerel posix_lseek+217
	DD	imagerel posix_lseek+235
	DD	imagerel $chain$6$posix_lseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$posix_lseek DD 020021H
	DD	087400H
	DD	imagerel posix_lseek
	DD	imagerel posix_lseek+57
	DD	imagerel $unwind$posix_lseek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix_lseek DD 021H
	DD	imagerel posix_lseek+137
	DD	imagerel posix_lseek+150
	DD	imagerel $chain$2$posix_lseek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$posix_lseek DD 020521H
	DD	0a3405H
	DD	imagerel posix_lseek+137
	DD	imagerel posix_lseek+150
	DD	imagerel $chain$2$posix_lseek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_lseek DD 020021H
	DD	087400H
	DD	imagerel posix_lseek
	DD	imagerel posix_lseek+57
	DD	imagerel $unwind$posix_lseek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_lseek DD 020521H
	DD	087405H
	DD	imagerel posix_lseek
	DD	imagerel posix_lseek+57
	DD	imagerel $unwind$posix_lseek
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_lseek DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_09PGLCNMMB@iOi?3lseek?$AA@
CONST	SEGMENT
??_C@_09PGLCNMMB@iOi?3lseek?$AA@ DB 'iOi:lseek', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_lseek
_TEXT	SEGMENT
posobj$ = 48
self$ = 80
args$ = 88
how$ = 96
fd$ = 104
posix_lseek PROC					; COMDAT

; 7963 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 7964 :     int fd, how;
; 7965 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 7966 :     PY_LONG_LONG pos, res;
; 7967 : #else
; 7968 :     off_t pos, res;
; 7969 : #endif
; 7970 :     PyObject *posobj;
; 7971 :     if (!PyArg_ParseTuple(args, "iOi:lseek", &fd, &posobj, &how))

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR how$[rsp]
  0000c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR posobj$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 44 24 68	 lea	 r8, QWORD PTR fd$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PGLCNMMB@iOi?3lseek?$AA@
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN9@posix_lsee

; 7972 :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 8006 : #endif
; 8007 : }

  00030	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00034	c3		 ret	 0
$LN9@posix_lsee:

; 7973 : #ifdef SEEK_SET
; 7974 :     /* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */
; 7975 :     switch (how) {

  00035	8b 4c 24 60	 mov	 ecx, DWORD PTR how$[rsp]
  00039	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003e	85 c9		 test	 ecx, ecx
  00040	74 1c		 je	 SHORT $LN6@posix_lsee
  00042	ff c9		 dec	 ecx
  00044	74 0e		 je	 SHORT $LN5@posix_lsee
  00046	ff c9		 dec	 ecx
  00048	75 1c		 jne	 SHORT $LN7@posix_lsee

; 7978 :     case 2: how = SEEK_END; break;

  0004a	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR how$[rsp], 2
  00052	eb 12		 jmp	 SHORT $LN7@posix_lsee
$LN5@posix_lsee:

; 7977 :     case 1: how = SEEK_CUR; break;

  00054	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR how$[rsp], 1
  0005c	eb 08		 jmp	 SHORT $LN7@posix_lsee
$LN6@posix_lsee:

; 7976 :     case 0: how = SEEK_SET; break;

  0005e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR how$[rsp], 0
$LN7@posix_lsee:

; 7979 :     }
; 7980 : #endif /* SEEK_END */
; 7981 : 
; 7982 : #if !defined(HAVE_LARGEFILE_SUPPORT)
; 7983 :     pos = PyLong_AsLong(posobj);
; 7984 : #else
; 7985 :     pos = PyLong_AsLongLong(posobj);

  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  0006b	e8 00 00 00 00	 call	 PyLong_AsLongLong
  00070	48 8b f8	 mov	 rdi, rax

; 7986 : #endif
; 7987 :     if (PyErr_Occurred())

  00073	e8 00 00 00 00	 call	 PyErr_Occurred
  00078	48 85 c0	 test	 rax, rax
  0007b	74 0c		 je	 SHORT $LN3@posix_lsee

; 7988 :         return NULL;

  0007d	33 c0		 xor	 eax, eax
  0007f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 8006 : #endif
; 8007 : }

  00084	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00088	c3		 ret	 0
$LN3@posix_lsee:

; 7989 : 
; 7990 :     if (!_PyVerify_fd(fd))

  00089	8b 4c 24 68	 mov	 ecx, DWORD PTR fd$[rsp]
  0008d	e8 00 00 00 00	 call	 _PyVerify_fd
  00092	85 c0		 test	 eax, eax

; 7991 :         return posix_error();

  00094	74 34		 je	 SHORT $LN13@posix_lsee

; 7992 :     Py_BEGIN_ALLOW_THREADS

  00096	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0009b	e8 00 00 00 00	 call	 PyEval_SaveThread

; 7993 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 7994 :     res = _lseeki64(fd, pos, how);

  000a0	44 8b 44 24 60	 mov	 r8d, DWORD PTR how$[rsp]
  000a5	8b 4c 24 68	 mov	 ecx, DWORD PTR fd$[rsp]
  000a9	48 8b d7	 mov	 rdx, rdi
  000ac	48 8b d8	 mov	 rbx, rax
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 7995 : #else
; 7996 :     res = lseek(fd, pos, how);
; 7997 : #endif
; 7998 :     Py_END_ALLOW_THREADS

  000b5	48 8b cb	 mov	 rcx, rbx
  000b8	48 8b f8	 mov	 rdi, rax
  000bb	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000c0	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 7999 :     if (res < 0)

  000c5	48 85 ff	 test	 rdi, rdi
  000c8	79 0f		 jns	 SHORT $LN1@posix_lsee
$LN13@posix_lsee:

; 8000 :         return posix_error();

  000ca	e8 00 00 00 00	 call	 posix_error
  000cf	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 8006 : #endif
; 8007 : }

  000d4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d8	c3		 ret	 0
$LN1@posix_lsee:

; 8001 : 
; 8002 : #if !defined(HAVE_LARGEFILE_SUPPORT)
; 8003 :     return PyLong_FromLong(res);
; 8004 : #else
; 8005 :     return PyLong_FromLongLong(res);

  000d9	48 8b cf	 mov	 rcx, rdi
  000dc	e8 00 00 00 00	 call	 PyLong_FromLongLong
  000e1	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 8006 : #endif
; 8007 : }

  000e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ea	c3		 ret	 0
posix_lseek ENDP
_TEXT	ENDS
PUBLIC	??_C@_07CJNIANNB@ii?3read?$AA@			; `string'
EXTRN	_PyBytes_Resize:PROC
EXTRN	__imp_read:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_read DD imagerel posix_read
	DD	imagerel posix_read+124
	DD	imagerel $unwind$posix_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_read DD imagerel posix_read+124
	DD	imagerel posix_read+187
	DD	imagerel $chain$1$posix_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_read DD imagerel posix_read+187
	DD	imagerel posix_read+212
	DD	imagerel $chain$2$posix_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix_read DD imagerel posix_read+212
	DD	imagerel posix_read+250
	DD	imagerel $chain$4$posix_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix_read DD 020021H
	DD	067400H
	DD	imagerel posix_read
	DD	imagerel posix_read+124
	DD	imagerel $unwind$posix_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_read DD 020021H
	DD	067400H
	DD	imagerel posix_read
	DD	imagerel posix_read+124
	DD	imagerel $unwind$posix_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_read DD 040a21H
	DD	06740aH
	DD	083405H
	DD	imagerel posix_read
	DD	imagerel posix_read+124
	DD	imagerel $unwind$posix_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_read DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_07CJNIANNB@ii?3read?$AA@
CONST	SEGMENT
??_C@_07CJNIANNB@ii?3read?$AA@ DB 'ii:read', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_read
_TEXT	SEGMENT
buffer$ = 32
self$ = 64
args$ = 72
size$ = 80
fd$ = 88
posix_read PROC						; COMDAT

; 8016 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 8017 :     int fd, size;
; 8018 :     Py_ssize_t n;
; 8019 :     PyObject *buffer;
; 8020 :     if (!PyArg_ParseTuple(args, "ii:read", &fd, &size))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 50	 lea	 r9, QWORD PTR size$[rsp]
  0000c	4c 8d 44 24 58	 lea	 r8, QWORD PTR fd$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CJNIANNB@ii?3read?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN6@posix_read
$LN10@posix_read:

; 8021 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 8043 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN6@posix_read:

; 8022 :     if (size < 0) {

  00028	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	79 16		 jns	 SHORT $LN5@posix_read

; 8023 :         errno = EINVAL;

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00037	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 8024 :         return posix_error();

  0003d	e8 00 00 00 00	 call	 posix_error

; 8043 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
$LN5@posix_read:

; 8025 :     }
; 8026 :     buffer = PyBytes_FromStringAndSize((char *)NULL, size);

  00047	48 8b d0	 mov	 rdx, rax
  0004a	33 c9		 xor	 ecx, ecx
  0004c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00051	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 8027 :     if (buffer == NULL)

  00056	48 85 c0	 test	 rax, rax

; 8028 :         return NULL;

  00059	74 c6		 je	 SHORT $LN10@posix_read

; 8029 :     if (!_PyVerify_fd(fd)) {

  0005b	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  0005f	e8 00 00 00 00	 call	 _PyVerify_fd
  00064	85 c0		 test	 eax, eax
  00066	75 14		 jne	 SHORT $LN3@posix_read

; 8030 :         Py_DECREF(buffer);

  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef

; 8031 :         return posix_error();

  00072	e8 00 00 00 00	 call	 posix_error

; 8043 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
$LN3@posix_read:
  0007c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00081	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 8032 :     }
; 8033 :     Py_BEGIN_ALLOW_THREADS

  00086	e8 00 00 00 00	 call	 PyEval_SaveThread

; 8034 :     n = read(fd, PyBytes_AS_STRING(buffer), size);

  0008b	48 8b 54 24 20	 mov	 rdx, QWORD PTR buffer$[rsp]
  00090	44 8b 44 24 50	 mov	 r8d, DWORD PTR size$[rsp]
  00095	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  00099	48 83 c2 78	 add	 rdx, 120		; 00000078H
  0009d	48 8b d8	 mov	 rbx, rax
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 8035 :     Py_END_ALLOW_THREADS

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	48 63 f8	 movsxd	 rdi, eax
  000ac	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 8036 :     if (n < 0) {

  000b6	48 85 ff	 test	 rdi, rdi
  000b9	79 19		 jns	 SHORT $LN2@posix_read

; 8037 :         Py_DECREF(buffer);

  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buffer$[rsp]
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 8038 :         return posix_error();

  000c5	e8 00 00 00 00	 call	 posix_error
  000ca	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 8043 : }

  000cf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d3	c3		 ret	 0
$LN2@posix_read:

; 8039 :     }
; 8040 :     if (n != size)

  000d4	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  000d9	48 3b f8	 cmp	 rdi, rax
  000dc	74 0d		 je	 SHORT $LN1@posix_read

; 8041 :         _PyBytes_Resize(&buffer, n);

  000de	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buffer$[rsp]
  000e3	48 8b d7	 mov	 rdx, rdi
  000e6	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN1@posix_read:

; 8042 :     return buffer;

  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  000f0	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 8043 : }

  000f5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f9	c3		 ret	 0
posix_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JBELCAAO@iy?$CK?3write?$AA@		; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	__imp_write:PROC
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_write DD imagerel posix_write
	DD	imagerel posix_write+79
	DD	imagerel $unwind$posix_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_write DD imagerel posix_write+79
	DD	imagerel posix_write+92
	DD	imagerel $chain$0$posix_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_write DD imagerel posix_write+92
	DD	imagerel posix_write+169
	DD	imagerel $chain$1$posix_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_write DD imagerel posix_write+169
	DD	imagerel posix_write+187
	DD	imagerel $chain$2$posix_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix_write DD imagerel posix_write+187
	DD	imagerel posix_write+208
	DD	imagerel $chain$4$posix_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix_write DD 020021H
	DD	0103400H
	DD	imagerel posix_write
	DD	imagerel posix_write+79
	DD	imagerel $unwind$posix_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_write DD 021H
	DD	imagerel posix_write+79
	DD	imagerel posix_write+92
	DD	imagerel $chain$0$posix_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_write DD 020521H
	DD	0e7405H
	DD	imagerel posix_write+79
	DD	imagerel posix_write+92
	DD	imagerel $chain$0$posix_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_write DD 020821H
	DD	0103408H
	DD	imagerel posix_write
	DD	imagerel posix_write+79
	DD	imagerel $unwind$posix_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_write DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_09JBELCAAO@iy?$CK?3write?$AA@
CONST	SEGMENT
??_C@_09JBELCAAO@iy?$CK?3write?$AA@ DB 'iy*:write', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_write
_TEXT	SEGMENT
pbuf$ = 32
self$ = 128
args$ = 136
fd$ = 144
posix_write PROC					; COMDAT

; 8192 : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 8193 :     Py_buffer pbuf;
; 8194 :     int fd;
; 8195 :     Py_ssize_t size, len;
; 8196 : 
; 8197 :     if (!PyArg_ParseTuple(args, "iy*:write", &fd, &pbuf))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 20	 lea	 r9, QWORD PTR pbuf$[rsp]
  0000c	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR fd$[rsp]
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09JBELCAAO@iy?$CK?3write?$AA@
  0001b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00020	85 c0		 test	 eax, eax
  00022	75 07		 jne	 SHORT $LN4@posix_writ

; 8198 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 8217 : }

  00026	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0002a	c3		 ret	 0
$LN4@posix_writ:

; 8199 :     if (!_PyVerify_fd(fd)) {

  0002b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00032	e8 00 00 00 00	 call	 _PyVerify_fd
  00037	85 c0		 test	 eax, eax
  00039	75 14		 jne	 SHORT $LN3@posix_writ

; 8200 :         PyBuffer_Release(&pbuf);

  0003b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00040	e8 00 00 00 00	 call	 PyBuffer_Release

; 8201 :         return posix_error();

  00045	e8 00 00 00 00	 call	 posix_error

; 8217 : }

  0004a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0004e	c3		 ret	 0
$LN3@posix_writ:
  0004f	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx

; 8202 :     }
; 8203 :     len = pbuf.len;

  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pbuf$[rsp+16]
  0005c	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi

; 8204 :     Py_BEGIN_ALLOW_THREADS

  00061	e8 00 00 00 00	 call	 PyEval_SaveThread

; 8205 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 8206 :     if (len > INT_MAX)
; 8207 :         len = INT_MAX;
; 8208 :     size = write(fd, pbuf.buf, (int)len);

  00066	48 8b 54 24 20	 mov	 rdx, QWORD PTR pbuf$[rsp]
  0006b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00072	48 8b f8	 mov	 rdi, rax
  00075	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0007a	48 3b d8	 cmp	 rbx, rax
  0007d	48 0f 4f d8	 cmovg	 rbx, rax
  00081	44 8b c3	 mov	 r8d, ebx
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 8209 : #else
; 8210 :     size = write(fd, pbuf.buf, len);
; 8211 : #endif
; 8212 :     Py_END_ALLOW_THREADS

  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	48 63 d8	 movsxd	 rbx, eax
  00090	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 8213 :     PyBuffer_Release(&pbuf);

  00095	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  0009a	e8 00 00 00 00	 call	 PyBuffer_Release
  0009f	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]

; 8214 :     if (size < 0)

  000a4	48 85 db	 test	 rbx, rbx
  000a7	79 12		 jns	 SHORT $LN1@posix_writ

; 8215 :         return posix_error();

  000a9	e8 00 00 00 00	 call	 posix_error
  000ae	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 8217 : }

  000b6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000ba	c3		 ret	 0
$LN1@posix_writ:

; 8216 :     return PyLong_FromSsize_t(size);

  000bb	48 8b cb	 mov	 rcx, rbx
  000be	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000c3	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]

; 8217 : }

  000cb	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000cf	c3		 ret	 0
posix_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_07NPKODNGM@i?3fstat?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_fstat DD imagerel posix_fstat
	DD	imagerel posix_fstat+44
	DD	imagerel $unwind$posix_fstat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_fstat DD imagerel posix_fstat+44
	DD	imagerel posix_fstat+115
	DD	imagerel $chain$1$posix_fstat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_fstat DD imagerel posix_fstat+115
	DD	imagerel posix_fstat+148
	DD	imagerel $chain$2$posix_fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_fstat DD 021H
	DD	imagerel posix_fstat
	DD	imagerel posix_fstat+44
	DD	imagerel $unwind$posix_fstat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_fstat DD 041021H
	DD	0107410H
	DD	0123408H
	DD	imagerel posix_fstat
	DD	imagerel posix_fstat+44
	DD	imagerel $unwind$posix_fstat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_fstat DD 020701H
	DD	0110107H
xdata	ENDS
;	COMDAT ??_C@_07NPKODNGM@i?3fstat?$AA@
CONST	SEGMENT
??_C@_07NPKODNGM@i?3fstat?$AA@ DB 'i:fstat', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_fstat
_TEXT	SEGMENT
st$ = 32
self$ = 144
args$ = 152
fd$ = 160
posix_fstat PROC					; COMDAT

; 8365 : {

  00000	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 8366 :     int fd;
; 8367 :     STRUCT_STAT st;
; 8368 :     int res;
; 8369 :     if (!PyArg_ParseTuple(args, "i:fstat", &fd))

  00007	48 8b ca	 mov	 rcx, rdx
  0000a	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR fd$[rsp]
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NPKODNGM@i?3fstat?$AA@
  00019	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001e	85 c0		 test	 eax, eax
  00020	75 0a		 jne	 SHORT $LN2@posix_fsta

; 8370 :         return NULL;

  00022	33 c0		 xor	 eax, eax

; 8387 : }

  00024	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0002b	c3		 ret	 0
$LN2@posix_fsta:
  0002c	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00034	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi

; 8371 : #ifdef __VMS
; 8372 :     /* on OpenVMS we must ensure that all bytes are written to the file */
; 8373 :     fsync(fd);
; 8374 : #endif
; 8375 :     Py_BEGIN_ALLOW_THREADS

  0003c	e8 00 00 00 00	 call	 PyEval_SaveThread

; 8376 :     res = FSTAT(fd, &st);

  00041	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00048	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  0004d	48 8b f8	 mov	 rdi, rax
  00050	e8 00 00 00 00	 call	 win32_fstat

; 8377 :     Py_END_ALLOW_THREADS

  00055	48 8b cf	 mov	 rcx, rdi
  00058	8b d8		 mov	 ebx, eax
  0005a	e8 00 00 00 00	 call	 PyEval_RestoreThread
  0005f	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 8378 :     if (res != 0) {

  00067	85 db		 test	 ebx, ebx
  00069	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00071	74 0f		 je	 SHORT $LN1@posix_fsta

; 8379 : #ifdef MS_WINDOWS
; 8380 :         return win32_error("fstat", NULL);

  00073	33 c9		 xor	 ecx, ecx
  00075	e8 00 00 00 00	 call	 win32_error

; 8387 : }

  0007a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00081	c3		 ret	 0
$LN1@posix_fsta:

; 8381 : #else
; 8382 :         return posix_error();
; 8383 : #endif
; 8384 :     }
; 8385 : 
; 8386 :     return _pystat_fromstructstat(&st);

  00082	48 8d 4c 24 20	 lea	 rcx, QWORD PTR st$[rsp]
  00087	e8 00 00 00 00	 call	 _pystat_fromstructstat

; 8387 : }

  0008c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00093	c3		 ret	 0
posix_fstat ENDP
_TEXT	ENDS
PUBLIC	??_C@_08IDKJIOEH@i?3isatty?$AA@			; `string'
EXTRN	__imp_isatty:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_isatty DD imagerel posix_isatty
	DD	imagerel posix_isatty+82
	DD	imagerel $unwind$posix_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_isatty DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_08IDKJIOEH@i?3isatty?$AA@
CONST	SEGMENT
??_C@_08IDKJIOEH@i?3isatty?$AA@ DB 'i:isatty', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_isatty
_TEXT	SEGMENT
self$ = 48
args$ = 56
fd$ = 64
posix_isatty PROC					; COMDAT

; 8396 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 8397 :     int fd;
; 8398 :     if (!PyArg_ParseTuple(args, "i:isatty", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IDKJIOEH@i?3isatty?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@posix_isat

; 8399 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 8403 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN2@posix_isat:

; 8400 :     if (!_PyVerify_fd(fd))

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00027	e8 00 00 00 00	 call	 _PyVerify_fd
  0002c	85 c0		 test	 eax, eax
  0002e	75 0c		 jne	 SHORT $LN1@posix_isat

; 8401 :         return PyBool_FromLong(0);

  00030	33 c9		 xor	 ecx, ecx

; 8402 :     return PyBool_FromLong(isatty(fd));

  00032	e8 00 00 00 00	 call	 PyBool_FromLong

; 8403 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
$LN1@posix_isat:

; 8402 :     return PyBool_FromLong(isatty(fd));

  0003c	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 PyBool_FromLong

; 8403 : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
posix_isatty ENDP
_TEXT	ENDS
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ?$AA@		; `string'
EXTRN	__imp__open_osfhandle:PROC
EXTRN	__imp_CreatePipe:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_pipe DD imagerel posix_pipe
	DD	imagerel posix_pipe+105
	DD	imagerel $unwind$posix_pipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_pipe DD 033601H
	DD	043436H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ?$AA@ DB '(ii)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_pipe
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
read$ = 64
write$ = 72
posix_pipe PROC						; COMDAT

; 8412 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 8413 : #if defined(PYOS_OS2)
; 8414 :     HFILE read, write;
; 8415 :     APIRET rc;
; 8416 : 
; 8417 :     rc = DosCreatePipe( &read, &write, 4096);
; 8418 :     if (rc != NO_ERROR)
; 8419 :         return os2_error(rc);
; 8420 : 
; 8421 :     return Py_BuildValue("(ii)", read, write);
; 8422 : #else
; 8423 : #if !defined(MS_WINDOWS)
; 8424 :     int fds[2];
; 8425 :     int res;
; 8426 :     res = pipe(fds);
; 8427 :     if (res != 0)
; 8428 :         return posix_error();
; 8429 :     return Py_BuildValue("(ii)", fds[0], fds[1]);
; 8430 : #else /* MS_WINDOWS */
; 8431 :     HANDLE read, write;
; 8432 :     int read_fd, write_fd;
; 8433 :     BOOL ok;
; 8434 :     ok = CreatePipe(&read, &write, NULL, 0);

  00004	48 8d 54 24 48	 lea	 rdx, QWORD PTR write$[rsp]
  00009	48 8d 4c 24 40	 lea	 rcx, QWORD PTR read$[rsp]
  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePipe

; 8435 :     if (!ok)

  0001a	85 c0		 test	 eax, eax
  0001c	75 0c		 jne	 SHORT $LN1@posix_pipe

; 8436 :         return win32_error("CreatePipe", NULL);

  0001e	33 c9		 xor	 ecx, ecx
  00020	e8 00 00 00 00	 call	 win32_error

; 8440 : #endif /* MS_WINDOWS */
; 8441 : #endif
; 8442 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN1@posix_pipe:

; 8437 :     read_fd = _open_osfhandle((Py_intptr_t)read, 0);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR read$[rsp]
  0002f	33 d2		 xor	 edx, edx
  00031	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle

; 8438 :     write_fd = _open_osfhandle((Py_intptr_t)write, 1);

  0003c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR write$[rsp]
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	8b d8		 mov	 ebx, eax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle

; 8439 :     return Py_BuildValue("(ii)", read_fd, write_fd);

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00055	44 8b c0	 mov	 r8d, eax
  00058	8b d3		 mov	 edx, ebx
  0005a	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  0005f	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 8440 : #endif /* MS_WINDOWS */
; 8441 : #endif
; 8442 : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	c3		 ret	 0
posix_pipe ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@ ; `string'
PUBLIC	??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@		; `string'
PUBLIC	??_C@_09ODIBKEDE@UU?3putenv?$AA@		; `string'
EXTRN	__imp__wputenv:PROC
EXTRN	PyUnicode_FromFormat:PROC
_BSS	SEGMENT
posix_putenv_garbage DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$posix_putenv DD imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_putenv DD imagerel posix_putenv+57
	DD	imagerel posix_putenv+92
	DD	imagerel $chain$0$posix_putenv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_putenv DD imagerel posix_putenv+92
	DD	imagerel posix_putenv+242
	DD	imagerel $chain$2$posix_putenv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$posix_putenv DD imagerel posix_putenv+242
	DD	imagerel posix_putenv+346
	DD	imagerel $chain$4$posix_putenv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$posix_putenv DD imagerel posix_putenv+346
	DD	imagerel posix_putenv+368
	DD	imagerel $chain$6$posix_putenv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$posix_putenv DD imagerel posix_putenv+368
	DD	imagerel posix_putenv+388
	DD	imagerel $chain$8$posix_putenv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$posix_putenv DD 020021H
	DD	063400H
	DD	imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$posix_putenv DD 020021H
	DD	063400H
	DD	imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$posix_putenv DD 020021H
	DD	063400H
	DD	imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_putenv DD 020021H
	DD	063400H
	DD	imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_putenv DD 020521H
	DD	063405H
	DD	imagerel posix_putenv
	DD	imagerel posix_putenv+57
	DD	imagerel $unwind$posix_putenv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_putenv DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@
CONST	SEGMENT
??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@ DB 'the environm'
	DB	'ent variable is longer than %u characters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@
CONST	SEGMENT
??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@ DB '%U=%U', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODIBKEDE@UU?3putenv?$AA@
CONST	SEGMENT
??_C@_09ODIBKEDE@UU?3putenv?$AA@ DB 'UU:putenv', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT posix_putenv
_TEXT	SEGMENT
self$ = 64
args$ = 72
os1$ = 80
os2$ = 88
posix_putenv PROC					; COMDAT

; 8841 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 8842 :     PyObject *newstr = NULL;
; 8843 : #ifdef MS_WINDOWS
; 8844 :     PyObject *os1, *os2;
; 8845 :     wchar_t *newenv;
; 8846 : 
; 8847 :     if (!PyArg_ParseTuple(args,
; 8848 :                           "UU:putenv",
; 8849 :                           &os1, &os2))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 58	 lea	 r9, QWORD PTR os2$[rsp]
  0000c	4c 8d 44 24 50	 lea	 r8, QWORD PTR os1$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ODIBKEDE@UU?3putenv?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN11@posix_pute

; 8850 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 8922 : }

  00023	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00027	c3		 ret	 0
$LN11@posix_pute:

; 8851 : 
; 8852 :     newstr = PyUnicode_FromFormat("%U=%U", os1, os2);

  00028	4c 8b 44 24 58	 mov	 r8, QWORD PTR os2$[rsp]
  0002d	48 8b 54 24 50	 mov	 rdx, QWORD PTR os1$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@
  00039	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0003e	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00043	48 8b d8	 mov	 rbx, rax

; 8853 :     if (newstr == NULL) {

  00046	48 85 c0	 test	 rax, rax
  00049	75 11		 jne	 SHORT $LN10@posix_pute

; 8854 :         PyErr_NoMemory();

  0004b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 8921 :     return NULL;

  00055	33 c0		 xor	 eax, eax

; 8922 : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
$LN10@posix_pute:

; 8855 :         goto error;
; 8856 :     }
; 8857 :     if (_MAX_ENV < PyUnicode_GET_LENGTH(newstr)) {

  0005c	48 81 78 60 ff
	7f 00 00	 cmp	 QWORD PTR [rax+96], 32767 ; 00007fffH
  00064	0f 8e 88 00 00
	00		 jle	 $LN9@posix_pute

; 8858 :         PyErr_Format(PyExc_ValueError,
; 8859 :                      "the environment variable is longer than %u characters",
; 8860 :                      _MAX_ENV);

  0006a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@
  00078	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  0007e	e8 00 00 00 00	 call	 PyErr_Format
$error$123835:

; 8914 : 
; 8915 : error:
; 8916 : #ifndef MS_WINDOWS
; 8917 :     Py_DECREF(os1);
; 8918 :     Py_DECREF(os2);
; 8919 : #endif
; 8920 :     Py_XDECREF(newstr);

  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	0f 85 e8 00 00
	00		 jne	 $LN3@posix_pute
  00090	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00094	a8 20		 test	 al, 32			; 00000020H
  00096	0f 85 d4 00 00
	00		 jne	 $LN18@posix_pute
  0009c	84 c0		 test	 al, al
  0009e	0f 88 cc 00 00
	00		 js	 $LN18@posix_pute
  000a4	a8 02		 test	 al, 2
  000a6	0f 85 cc 00 00
	00		 jne	 $LN3@posix_pute
  000ac	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000b0	0f 85 c2 00 00
	00		 jne	 $LN3@posix_pute
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c4	4c 8b cb	 mov	 r9, rbx
  000c7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000cd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000da	48 8b cb	 mov	 rcx, rbx
  000dd	85 c0		 test	 eax, eax
  000df	74 79		 je	 SHORT $LN23@posix_pute
  000e1	e8 00 00 00 00	 call	 _Px_Dealloc
  000e6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 8921 :     return NULL;

  000eb	33 c0		 xor	 eax, eax

; 8922 : }

  000ed	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f1	c3		 ret	 0
$LN9@posix_pute:

; 8861 :         goto error;
; 8862 :     }
; 8863 : 
; 8864 :     newenv = PyUnicode_AsUnicode(newstr);

  000f2	48 8b c8	 mov	 rcx, rax
  000f5	e8 00 00 00 00	 call	 PyUnicode_AsUnicode

; 8865 :     if (newenv == NULL)

  000fa	48 85 c0	 test	 rax, rax
  000fd	74 84		 je	 SHORT $error$123835

; 8866 :         goto error;
; 8867 :     if (_wputenv(newenv)) {

  000ff	48 8b c8	 mov	 rcx, rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wputenv
  00108	85 c0		 test	 eax, eax
  0010a	74 0a		 je	 SHORT $LN7@posix_pute

; 8868 :         posix_error();

  0010c	e8 00 00 00 00	 call	 posix_error
  00111	e9 6d ff ff ff	 jmp	 $error$123835
$LN7@posix_pute:

; 8869 :         goto error;
; 8870 :     }
; 8871 : #else
; 8872 :     PyObject *os1, *os2;
; 8873 :     char *s1, *s2;
; 8874 :     char *newenv;
; 8875 : 
; 8876 :     if (!PyArg_ParseTuple(args,
; 8877 :                           "O&O&:putenv",
; 8878 :                           PyUnicode_FSConverter, &os1,
; 8879 :                           PyUnicode_FSConverter, &os2))
; 8880 :         return NULL;
; 8881 :     s1 = PyBytes_AsString(os1);
; 8882 :     s2 = PyBytes_AsString(os2);
; 8883 : 
; 8884 :     newstr = PyBytes_FromFormat("%s=%s", s1, s2);
; 8885 :     if (newstr == NULL) {
; 8886 :         PyErr_NoMemory();
; 8887 :         goto error;
; 8888 :     }
; 8889 : 
; 8890 :     newenv = PyBytes_AS_STRING(newstr);
; 8891 :     if (putenv(newenv)) {
; 8892 :         posix_error();
; 8893 :         goto error;
; 8894 :     }
; 8895 : #endif
; 8896 : 
; 8897 :     /* Install the first arg and newstr in posix_putenv_garbage;
; 8898 :      * this will cause previous value to be collected.  This has to
; 8899 :      * happen after the real putenv() call because the old value
; 8900 :      * was still accessible until then. */
; 8901 :     if (PyDict_SetItem(posix_putenv_garbage, os1, newstr)) {

  00116	48 8b 54 24 50	 mov	 rdx, QWORD PTR os1$[rsp]
  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR posix_putenv_garbage
  00122	4c 8b c3	 mov	 r8, rbx
  00125	e8 00 00 00 00	 call	 PyDict_SetItem
  0012a	85 c0		 test	 eax, eax
  0012c	74 07		 je	 SHORT $LN6@posix_pute

; 8902 :         /* really not much we can do; just leak */
; 8903 :         PyErr_Clear();

  0012e	e8 00 00 00 00	 call	 PyErr_Clear

; 8904 :     }
; 8905 :     else {

  00133	eb 08		 jmp	 SHORT $LN5@posix_pute
$LN6@posix_pute:

; 8906 :         Py_DECREF(newstr);

  00135	48 8b cb	 mov	 rcx, rbx
  00138	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@posix_pute:

; 8907 :     }
; 8908 : 
; 8909 : #ifndef MS_WINDOWS
; 8910 :     Py_DECREF(os1);
; 8911 :     Py_DECREF(os2);
; 8912 : #endif
; 8913 :     Py_RETURN_NONE;

  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00144	e8 00 00 00 00	 call	 _Py_IncRef
  00149	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0014e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 8922 : }

  00155	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00159	c3		 ret	 0

; 8914 : 
; 8915 : error:
; 8916 : #ifndef MS_WINDOWS
; 8917 :     Py_DECREF(os1);
; 8918 :     Py_DECREF(os2);
; 8919 : #endif
; 8920 :     Py_XDECREF(newstr);

$LN23@posix_pute:
  0015a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0015e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00164	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 8921 :     return NULL;

  00169	33 c0		 xor	 eax, eax

; 8922 : }

  0016b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016f	c3		 ret	 0

; 8914 : 
; 8915 : error:
; 8916 : #ifndef MS_WINDOWS
; 8917 :     Py_DECREF(os1);
; 8918 :     Py_DECREF(os2);
; 8919 : #endif
; 8920 :     Py_XDECREF(newstr);

$LN18@posix_pute:
  00170	48 8b cb	 mov	 rcx, rbx
  00173	e8 00 00 00 00	 call	 Px_DecRef
$LN3@posix_pute:

; 8921 :     return NULL;

  00178	33 c0		 xor	 eax, eax
  0017a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 8922 : }

  0017f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00183	c3		 ret	 0
posix_putenv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
PUBLIC	??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0L@BOGMIHBP@i?3strerror?$AA@		; `string'
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_strerror:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_strerror DD imagerel posix_strerror
	DD	imagerel posix_strerror+89
	DD	imagerel $unwind$posix_strerror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_strerror DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@ DB 'strerr'
	DB	'or() argument out of range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOGMIHBP@i?3strerror?$AA@
CONST	SEGMENT
??_C@_0L@BOGMIHBP@i?3strerror?$AA@ DB 'i:strerror', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_strerror
_TEXT	SEGMENT
self$ = 48
args$ = 56
code$ = 64
posix_strerror PROC					; COMDAT

; 8973 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 8974 :     int code;
; 8975 :     char *message;
; 8976 :     if (!PyArg_ParseTuple(args, "i:strerror", &code))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR code$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BOGMIHBP@i?3strerror?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax

; 8977 :         return NULL;

  0001a	74 22		 je	 SHORT $LN5@posix_stre

; 8978 :     message = strerror(code);

  0001c	8b 4c 24 40	 mov	 ecx, DWORD PTR code$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror

; 8979 :     if (message == NULL) {

  00026	48 85 c0	 test	 rax, rax
  00029	75 1a		 jne	 SHORT $LN1@posix_stre

; 8980 :         PyErr_SetString(PyExc_ValueError,
; 8981 :                         "strerror() argument out of range");

  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@
  00039	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@posix_stre:

; 8982 :         return NULL;

  0003e	33 c0		 xor	 eax, eax

; 8985 : }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
$LN1@posix_stre:

; 8983 :     }
; 8984 :     return PyUnicode_DecodeLocale(message, "surrogateescape");

  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale

; 8985 : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
posix_strerror ENDP
_TEXT	ENDS
PUBLIC	??_C@_04CEGIGAON@?$CILL?$CJ?$AA@		; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
EXTRN	__imp_GetDiskFreeSpaceExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32__getdiskusage DD imagerel win32__getdiskusage
	DD	imagerel win32__getdiskusage+35
	DD	imagerel $unwind$win32__getdiskusage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$win32__getdiskusage DD imagerel win32__getdiskusage+35
	DD	imagerel win32__getdiskusage+103
	DD	imagerel $chain$1$win32__getdiskusage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$win32__getdiskusage DD imagerel win32__getdiskusage+103
	DD	imagerel win32__getdiskusage+142
	DD	imagerel $chain$2$win32__getdiskusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$win32__getdiskusage DD 021H
	DD	imagerel win32__getdiskusage
	DD	imagerel win32__getdiskusage+35
	DD	imagerel $unwind$win32__getdiskusage
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$win32__getdiskusage DD 040a21H
	DD	06740aH
	DD	083405H
	DD	imagerel win32__getdiskusage
	DD	imagerel win32__getdiskusage+35
	DD	imagerel $unwind$win32__getdiskusage
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32__getdiskusage DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_04CEGIGAON@?$CILL?$CJ?$AA@
CONST	SEGMENT
??_C@_04CEGIGAON@?$CILL?$CJ?$AA@ DB '(LL)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32__getdiskusage
_TEXT	SEGMENT
total$ = 32
_$ = 40
self$ = 64
args$ = 72
path$ = 80
free$ = 88
win32__getdiskusage PROC				; COMDAT

; 9278 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 9279 :     BOOL retval;
; 9280 :     ULARGE_INTEGER _, total, free;
; 9281 :     const wchar_t *path;
; 9282 : 
; 9283 :     if (! PyArg_ParseTuple(args, "u", &path))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR path$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01OMGOGALD@u?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@win32__get

; 9284 :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 9293 : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN2@win32__get:
  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 9285 : 
; 9286 :     Py_BEGIN_ALLOW_THREADS

  0002d	e8 00 00 00 00	 call	 PyEval_SaveThread

; 9287 :     retval = GetDiskFreeSpaceExW(path, &_, &total, &free);

  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp]
  00037	4c 8d 4c 24 58	 lea	 r9, QWORD PTR free$[rsp]
  0003c	4c 8d 44 24 20	 lea	 r8, QWORD PTR total$[rsp]
  00041	48 8d 54 24 28	 lea	 rdx, QWORD PTR _$[rsp]
  00046	48 8b f8	 mov	 rdi, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDiskFreeSpaceExW

; 9288 :     Py_END_ALLOW_THREADS

  0004f	48 8b cf	 mov	 rcx, rdi
  00052	8b d8		 mov	 ebx, eax
  00054	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00059	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 9289 :     if (retval == 0)

  0005e	85 db		 test	 ebx, ebx
  00060	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00065	75 0c		 jne	 SHORT $LN1@win32__get

; 9290 :         return PyErr_SetFromWindowsErr(0);

  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 9293 : }

  0006e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00072	c3		 ret	 0
$LN1@win32__get:

; 9291 : 
; 9292 :     return Py_BuildValue("(LL)", total.QuadPart, free.QuadPart);

  00073	4c 8b 44 24 58	 mov	 r8, QWORD PTR free$[rsp]
  00078	48 8b 54 24 20	 mov	 rdx, QWORD PTR total$[rsp]
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CEGIGAON@?$CILL?$CJ?$AA@
  00084	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 9293 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
win32__getdiskusage ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT setup_confname_tables
_TEXT	SEGMENT
setup_confname_tables PROC				; COMDAT

; 10308: #if defined(HAVE_FPATHCONF) || defined(HAVE_PATHCONF)
; 10309:     if (setup_confname_table(posix_constants_pathconf,
; 10310:                              sizeof(posix_constants_pathconf)
; 10311:                                / sizeof(struct constdef),
; 10312:                              "pathconf_names", module))
; 10313:         return -1;
; 10314: #endif
; 10315: #ifdef HAVE_CONFSTR
; 10316:     if (setup_confname_table(posix_constants_confstr,
; 10317:                              sizeof(posix_constants_confstr)
; 10318:                                / sizeof(struct constdef),
; 10319:                              "confstr_names", module))
; 10320:         return -1;
; 10321: #endif
; 10322: #ifdef HAVE_SYSCONF
; 10323:     if (setup_confname_table(posix_constants_sysconf,
; 10324:                              sizeof(posix_constants_sysconf)
; 10325:                                / sizeof(struct constdef),
; 10326:                              "sysconf_names", module))
; 10327:         return -1;
; 10328: #endif
; 10329:     return 0;

  00000	33 c0		 xor	 eax, eax

; 10330: }

  00002	c3		 ret	 0
setup_confname_tables ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	__imp_abort:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_abort DD imagerel posix_abort
	DD	imagerel posix_abort+29
	DD	imagerel $unwind$posix_abort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_abort DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@
CONST	SEGMENT
??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@ DB 'abort'
	DB	'() called from Python code didn''t abort!', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_abort
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
posix_abort PROC					; COMDAT

; 10340: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 10341:     abort();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_abort

; 10342:     /*NOTREACHED*/
; 10343:     Py_FatalError("abort() called from Python code didn't abort!");

  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@
  00011	e8 00 00 00 00	 call	 Py_FatalError

; 10344:     return NULL;

  00016	33 c0		 xor	 eax, eax

; 10345: }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
posix_abort ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@	; `string'
PUBLIC	??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@	; `string'
EXTRN	__imp_ShellExecuteA:PROC
EXTRN	__imp_ShellExecuteW:PROC
EXTRN	PyUnicode_DecodeASCII:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$win32_startfile DD imagerel win32_startfile
	DD	imagerel win32_startfile+597
	DD	imagerel $unwind$win32_startfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_startfile DD 081201H
	DD	0e3412H
	DD	0d00e7212H
	DD	0700ac00cH
	DD	050086009H
xdata	ENDS
;	COMDAT ??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@
CONST	SEGMENT
??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@ DB 'O&|s:startfile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@
CONST	SEGMENT
??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@ DB 'U|s:startfile', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT win32_startfile
_TEXT	SEGMENT
unipath$ = 48
self$ = 112
args$ = 120
operation$ = 128
ofilepath$ = 136
win32_startfile PROC					; COMDAT

; 10369: {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00012	4c 8b e2	 mov	 r12, rdx

; 10370:     PyObject *ofilepath;
; 10371:     char *filepath;
; 10372:     char *operation = NULL;

  00015	45 33 ed	 xor	 r13d, r13d

; 10373:     wchar_t *wpath, *woperation;
; 10374:     HINSTANCE rc;
; 10375: 
; 10376:     PyObject *unipath, *uoperation = NULL;
; 10377:     if (!PyArg_ParseTuple(args, "U|s:startfile",
; 10378:                           &unipath, &operation)) {

  00018	4c 8d 48 18	 lea	 r9, QWORD PTR [rax+24]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@
  00023	4c 8d 40 c8	 lea	 r8, QWORD PTR [rax-56]
  00027	49 8b cc	 mov	 rcx, r12
  0002a	4c 89 68 18	 mov	 QWORD PTR [rax+24], r13
  0002e	41 8b dd	 mov	 ebx, r13d
  00031	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00036	85 c0		 test	 eax, eax
  00038	75 65		 jne	 SHORT $LN15@win32_star

; 10379:         PyErr_Clear();

  0003a	e8 00 00 00 00	 call	 PyErr_Clear
$normal$123995:

; 10413:     }
; 10414:     Py_INCREF(Py_None);
; 10415:     return Py_None;
; 10416: 
; 10417: normal:
; 10418:     if (!PyArg_ParseTuple(args, "O&|s:startfile",
; 10419:                           PyUnicode_FSConverter, &ofilepath,
; 10420:                           &operation))

  0003f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR operation$[rsp]
  00047	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR ofilepath$[rsp]
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_FSConverter
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@
  0005d	49 8b cc	 mov	 rcx, r12
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006a	85 c0		 test	 eax, eax

; 10421:         return NULL;

  0006c	0f 84 f6 00 00
	00		 je	 $LN29@win32_star

; 10422:     if (win32_warn_bytes_api()) {

  00072	e8 00 00 00 00	 call	 win32_warn_bytes_api

; 10423:         Py_DECREF(ofilepath);

  00077	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 f4 00 00
	00		 je	 $LN2@win32_star
  00087	e8 00 00 00 00	 call	 _Py_DecRef

; 10424:         return NULL;

  0008c	33 c0		 xor	 eax, eax

; 10439: }

  0008e	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	41 5d		 pop	 r13
  00099	41 5c		 pop	 r12
  0009b	5f		 pop	 rdi
  0009c	5e		 pop	 rsi
  0009d	5d		 pop	 rbp
  0009e	c3		 ret	 0
$LN15@win32_star:

; 10380:         goto normal;
; 10381:     }
; 10382: 
; 10383:     if (operation) {

  0009f	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR operation$[rsp]
  000a7	4d 85 c9	 test	 r9, r9
  000aa	74 37		 je	 SHORT $LN13@win32_star

; 10384:         uoperation = PyUnicode_DecodeASCII(operation,
; 10385:                                            strlen(operation), NULL);

  000ac	48 83 c9 ff	 or	 rcx, -1
  000b0	33 c0		 xor	 eax, eax
  000b2	49 8b f9	 mov	 rdi, r9
  000b5	f2 ae		 repne scasb
  000b7	45 33 c0	 xor	 r8d, r8d
  000ba	48 f7 d1	 not	 rcx
  000bd	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  000c1	49 8b c9	 mov	 rcx, r9
  000c4	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  000c9	48 8b d8	 mov	 rbx, rax

; 10386:         if (!uoperation) {

  000cc	48 85 c0	 test	 rax, rax
  000cf	75 12		 jne	 SHORT $LN13@win32_star

; 10387:             PyErr_Clear();

  000d1	e8 00 00 00 00	 call	 PyErr_Clear

; 10388:             operation = NULL;

  000d6	4c 89 ac 24 80
	00 00 00	 mov	 QWORD PTR operation$[rsp], r13

; 10389:             goto normal;

  000de	e9 5c ff ff ff	 jmp	 $normal$123995
$LN13@win32_star:

; 10390:         }
; 10391:     }
; 10392: 
; 10393:     wpath = PyUnicode_AsUnicode(unipath);

  000e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR unipath$[rsp]
  000e8	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  000ed	48 8b e8	 mov	 rbp, rax

; 10394:     if (wpath == NULL)

  000f0	48 85 c0	 test	 rax, rax
  000f3	0f 84 46 ff ff
	ff		 je	 $normal$123995

; 10395:         goto normal;
; 10396:     if (uoperation) {

  000f9	48 85 db	 test	 rbx, rbx
  000fc	74 15		 je	 SHORT $LN11@win32_star

; 10397:         woperation = PyUnicode_AsUnicode(uoperation);

  000fe	48 8b cb	 mov	 rcx, rbx
  00101	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00106	48 8b f0	 mov	 rsi, rax

; 10398:         if (woperation == NULL)

  00109	48 85 c0	 test	 rax, rax
  0010c	75 08		 jne	 SHORT $LN9@win32_star
  0010e	e9 2c ff ff ff	 jmp	 $normal$123995
$LN11@win32_star:

; 10399:             goto normal;
; 10400:     }
; 10401:     else
; 10402:         woperation = NULL;

  00113	49 8b f5	 mov	 rsi, r13
$LN9@win32_star:

; 10403: 
; 10404:     Py_BEGIN_ALLOW_THREADS

  00116	e8 00 00 00 00	 call	 PyEval_SaveThread

; 10405:     rc = ShellExecuteW((HWND)0, woperation, wpath,
; 10406:                        NULL, NULL, SW_SHOWNORMAL);

  0011b	45 33 c9	 xor	 r9d, r9d
  0011e	4c 8b c5	 mov	 r8, rbp
  00121	48 8b d6	 mov	 rdx, rsi
  00124	33 c9		 xor	 ecx, ecx
  00126	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  0012e	48 8b f8	 mov	 rdi, rax
  00131	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShellExecuteW

; 10407:     Py_END_ALLOW_THREADS

  0013c	48 8b cf	 mov	 rcx, rdi
  0013f	48 8b f0	 mov	 rsi, rax
  00142	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 10408: 
; 10409:     Py_XDECREF(uoperation);

  00147	48 85 db	 test	 rbx, rbx
  0014a	74 08		 je	 SHORT $LN7@win32_star
  0014c	48 8b cb	 mov	 rcx, rbx
  0014f	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@win32_star:

; 10410:     if (rc <= (HINSTANCE)32) {

  00154	48 83 fe 20	 cmp	 rsi, 32			; 00000020H
  00158	0f 87 9a 00 00
	00		 ja	 $LN4@win32_star

; 10411:         win32_error_object("startfile", unipath);

  0015e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR unipath$[rsp]
  00163	e8 00 00 00 00	 call	 win32_error_object
$LN29@win32_star:

; 10412:         return NULL;

  00168	33 c0		 xor	 eax, eax

; 10439: }

  0016a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0016f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00173	41 5d		 pop	 r13
  00175	41 5c		 pop	 r12
  00177	5f		 pop	 rdi
  00178	5e		 pop	 rsi
  00179	5d		 pop	 rbp
  0017a	c3		 ret	 0
$LN2@win32_star:

; 10425:     }
; 10426:     filepath = PyBytes_AsString(ofilepath);

  0017b	e8 00 00 00 00	 call	 PyBytes_AsString
  00180	48 8b f0	 mov	 rsi, rax

; 10427:     Py_BEGIN_ALLOW_THREADS

  00183	e8 00 00 00 00	 call	 PyEval_SaveThread

; 10428:     rc = ShellExecute((HWND)0, operation, filepath,
; 10429:                       NULL, NULL, SW_SHOWNORMAL);

  00188	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR operation$[rsp]
  00190	45 33 c9	 xor	 r9d, r9d
  00193	4c 8b c6	 mov	 r8, rsi
  00196	33 c9		 xor	 ecx, ecx
  00198	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  001a0	48 8b d8	 mov	 rbx, rax
  001a3	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShellExecuteA

; 10430:     Py_END_ALLOW_THREADS

  001ae	48 8b cb	 mov	 rcx, rbx
  001b1	48 8b f8	 mov	 rdi, rax
  001b4	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 10431:     if (rc <= (HINSTANCE)32) {

  001b9	48 83 ff 20	 cmp	 rdi, 32			; 00000020H
  001bd	77 2c		 ja	 SHORT $LN1@win32_star

; 10432:         PyObject *errval = win32_error("startfile", filepath);

  001bf	48 8b ce	 mov	 rcx, rsi
  001c2	e8 00 00 00 00	 call	 win32_error

; 10433:         Py_DECREF(ofilepath);

  001c7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  001cf	48 8b f8	 mov	 rdi, rax
  001d2	e8 00 00 00 00	 call	 _Py_DecRef

; 10434:         return errval;

  001d7	48 8b c7	 mov	 rax, rdi

; 10439: }

  001da	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001df	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001e3	41 5d		 pop	 r13
  001e5	41 5c		 pop	 r12
  001e7	5f		 pop	 rdi
  001e8	5e		 pop	 rsi
  001e9	5d		 pop	 rbp
  001ea	c3		 ret	 0
$LN1@win32_star:

; 10435:     }
; 10436:     Py_DECREF(ofilepath);

  001eb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  001f3	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@win32_star:

; 10437:     Py_INCREF(Py_None);

  001f8	e8 00 00 00 00	 call	 _Py_PXCTX
  001fd	85 c0		 test	 eax, eax
  001ff	75 3c		 jne	 SHORT $LN23@win32_star
  00201	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00216	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0021c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00224	e8 00 00 00 00	 call	 _PyParallel_Guard
  00229	85 c0		 test	 eax, eax
  0022b	75 09		 jne	 SHORT $LN22@win32_star
  0022d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00234	74 07		 je	 SHORT $LN23@win32_star
$LN22@win32_star:
  00236	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN23@win32_star:

; 10438:     return Py_None;

  0023d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 10439: }

  00244	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00249	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0024d	41 5d		 pop	 r13
  0024f	41 5c		 pop	 r12
  00251	5f		 pop	 rdi
  00252	5e		 pop	 rsi
  00253	5d		 pop	 rbp
  00254	c3		 ret	 0
win32_startfile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@	; `string'
EXTRN	_Py_device_encoding:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$device_encoding DD imagerel device_encoding
	DD	imagerel device_encoding+49
	DD	imagerel $unwind$device_encoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$device_encoding DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@
CONST	SEGMENT
??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@ DB 'i:device_encoding', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT device_encoding
_TEXT	SEGMENT
self$ = 48
args$ = 56
fd$ = 64
device_encoding PROC					; COMDAT

; 10468: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 10469:     int fd;
; 10470: 
; 10471:     if (!PyArg_ParseTuple(args, "i:device_encoding", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@device_enc

; 10472:         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 10475: }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN1@device_enc:

; 10473: 
; 10474:     return _Py_device_encoding(fd);

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00027	e8 00 00 00 00	 call	 _Py_device_encoding

; 10475: }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
device_encoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ ; `string'
PUBLIC	??_C@_09DFDFFLIA@n?3urandom?$AA@		; `string'
EXTRN	_PyOS_URandom:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_urandom DD imagerel posix_urandom
	DD	imagerel posix_urandom+71
	DD	imagerel $unwind$posix_urandom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_urandom DD imagerel posix_urandom+71
	DD	imagerel posix_urandom+127
	DD	imagerel $chain$0$posix_urandom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$posix_urandom DD imagerel posix_urandom+127
	DD	imagerel posix_urandom+140
	DD	imagerel $chain$2$posix_urandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$posix_urandom DD 020021H
	DD	043400H
	DD	imagerel posix_urandom
	DD	imagerel posix_urandom+71
	DD	imagerel $unwind$posix_urandom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_urandom DD 020521H
	DD	043405H
	DD	imagerel posix_urandom
	DD	imagerel posix_urandom+71
	DD	imagerel $unwind$posix_urandom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_urandom DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ DB 'negative arg'
	DB	'ument not allowed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFDFFLIA@n?3urandom?$AA@
CONST	SEGMENT
??_C@_09DFDFFLIA@n?3urandom?$AA@ DB 'n:urandom', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_urandom
_TEXT	SEGMENT
self$ = 48
args$ = 56
size$ = 64
posix_urandom PROC					; COMDAT

; 10861: {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 10862:     Py_ssize_t size;
; 10863:     PyObject *result;
; 10864:     int ret;
; 10865: 
; 10866:      /* Read arguments */
; 10867:     if (!PyArg_ParseTuple(args, "n:urandom", &size))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR size$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DFDFFLIA@n?3urandom?$AA@
  00013	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN4@posix_uran

; 10868:         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 10883: }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN4@posix_uran:

; 10869:     if (size < 0)

  00023	48 8b 54 24 40	 mov	 rdx, QWORD PTR size$[rsp]
  00028	48 85 d2	 test	 rdx, rdx
  0002b	79 18		 jns	 SHORT $LN3@posix_uran

; 10870:         return PyErr_Format(PyExc_ValueError,
; 10871:                             "negative argument not allowed");

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
  0003b	e8 00 00 00 00	 call	 PyErr_Format

; 10883: }

  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
$LN3@posix_uran:

; 10872:     result = PyBytes_FromStringAndSize(NULL, size);

  00045	33 c9		 xor	 ecx, ecx
  00047	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0004c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00051	48 8b d8	 mov	 rbx, rax

; 10873:     if (result == NULL)

  00054	48 85 c0	 test	 rax, rax

; 10874:         return NULL;

  00057	74 1a		 je	 SHORT $LN8@posix_uran

; 10875: 
; 10876:     ret = _PyOS_URandom(PyBytes_AS_STRING(result),
; 10877:                         PyBytes_GET_SIZE(result));

  00059	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0005d	48 8d 48 78	 lea	 rcx, QWORD PTR [rax+120]
  00061	e8 00 00 00 00	 call	 _PyOS_URandom

; 10878:     if (ret == -1) {

  00066	83 f8 ff	 cmp	 eax, -1
  00069	75 14		 jne	 SHORT $LN1@posix_uran

; 10879:         Py_DECREF(result);

  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@posix_uran:

; 10880:         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 10883: }

  0007a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007e	c3		 ret	 0
$LN1@posix_uran:

; 10881:     }
; 10882:     return result;

  0007f	48 8b c3	 mov	 rax, rbx
  00082	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 10883: }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
posix_urandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@ ; `string'
PUBLIC	??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@	; `string'
PUBLIC	??_C@_02OJGKGHDH@?$HMi?$AA@			; `string'
EXTRN	__imp_GetConsoleScreenBufferInfo:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp___iob_func:PROC
_BSS	SEGMENT
TerminalSizeType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_terminal_size DD imagerel get_terminal_size
	DD	imagerel get_terminal_size+291
	DD	imagerel $unwind$get_terminal_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_terminal_size DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@
CONST	SEGMENT
??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@ DB 'handle cannot b'
	DB	'e retrieved', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@
CONST	SEGMENT
??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@ DB 'bad file descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJGKGHDH@?$HMi?$AA@
CONST	SEGMENT
??_C@_02OJGKGHDH@?$HMi?$AA@ DB '|i', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_terminal_size
_TEXT	SEGMENT
csbi$124101 = 32
self$ = 80
args$ = 88
fd$ = 96
get_terminal_size PROC					; COMDAT

; 10923: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b da	 mov	 rbx, rdx

; 10924:     int columns, lines;
; 10925:     PyObject *termsize;
; 10926: 
; 10927:     int fd = fileno(stdout);

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0000f	48 8d 48 30	 lea	 rcx, QWORD PTR [rax+48]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno

; 10928:     /* Under some conditions stdout may not be connected and
; 10929:      * fileno(stdout) may point to an invalid file descriptor. For example
; 10930:      * GUI apps don't have valid standard streams by default.
; 10931:      *
; 10932:      * If this happens, and the optional fd argument is not present,
; 10933:      * the ioctl below will fail returning EBADF. This is what we want.
; 10934:      */
; 10935: 
; 10936:     if (!PyArg_ParseTuple(args, "|i", &fd))

  00019	4c 8d 44 24 60	 lea	 r8, QWORD PTR fd$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OJGKGHDH@?$HMi?$AA@
  00025	48 8b cb	 mov	 rcx, rbx
  00028	89 44 24 60	 mov	 DWORD PTR fd$[rsp], eax
  0002c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00031	85 c0		 test	 eax, eax

; 10937:         return NULL;

  00033	0f 84 d9 00 00
	00		 je	 $LN15@get_termin

; 10938: 
; 10939: #ifdef TERMSIZE_USE_IOCTL
; 10940:     {
; 10941:         struct winsize w;
; 10942:         if (ioctl(fd, TIOCGWINSZ, &w))
; 10943:             return PyErr_SetFromErrno(PyExc_OSError);
; 10944:         columns = w.ws_col;
; 10945:         lines = w.ws_row;
; 10946:     }
; 10947: #endif /* TERMSIZE_USE_IOCTL */
; 10948: 
; 10949: #ifdef TERMSIZE_USE_CONIO
; 10950:     {
; 10951:         DWORD nhandle;
; 10952:         HANDLE handle;
; 10953:         CONSOLE_SCREEN_BUFFER_INFO csbi;
; 10954:         switch (fd) {

  00039	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0003d	85 c9		 test	 ecx, ecx
  0003f	74 2f		 je	 SHORT $LN9@get_termin
  00041	ff c9		 dec	 ecx
  00043	74 24		 je	 SHORT $LN8@get_termin
  00045	ff c9		 dec	 ecx
  00047	74 19		 je	 SHORT $LN7@get_termin

; 10961:         default:
; 10962:             return PyErr_Format(PyExc_ValueError, "bad file descriptor");

  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@
  00057	e8 00 00 00 00	 call	 PyErr_Format

; 10988: }

  0005c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
$LN7@get_termin:

; 10959:         case 2: nhandle = STD_ERROR_HANDLE;

  00062	b9 f4 ff ff ff	 mov	 ecx, -12		; fffffff4H

; 10960:             break;

  00067	eb 0c		 jmp	 SHORT $LN10@get_termin
$LN8@get_termin:

; 10956:             break;
; 10957:         case 1: nhandle = STD_OUTPUT_HANDLE;

  00069	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 10958:             break;

  0006e	eb 05		 jmp	 SHORT $LN10@get_termin
$LN9@get_termin:

; 10955:         case 0: nhandle = STD_INPUT_HANDLE;

  00070	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
$LN10@get_termin:

; 10963:         }
; 10964:         handle = GetStdHandle(nhandle);

  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 10965:         if (handle == NULL)

  0007b	48 85 c0	 test	 rax, rax
  0007e	75 19		 jne	 SHORT $LN5@get_termin

; 10966:             return PyErr_Format(PyExc_OSError, "handle cannot be retrieved");

  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@
  0008e	e8 00 00 00 00	 call	 PyErr_Format

; 10988: }

  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5b		 pop	 rbx
  00098	c3		 ret	 0
$LN5@get_termin:

; 10967:         if (handle == INVALID_HANDLE_VALUE)

  00099	48 83 f8 ff	 cmp	 rax, -1
  0009d	75 0d		 jne	 SHORT $LN4@get_termin
$LN16@get_termin:

; 10968:             return PyErr_SetFromWindowsErr(0);

  0009f	33 c9		 xor	 ecx, ecx
  000a1	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 10988: }

  000a6	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000aa	5b		 pop	 rbx
  000ab	c3		 ret	 0
$LN4@get_termin:

; 10969: 
; 10970:         if (!GetConsoleScreenBufferInfo(handle, &csbi))

  000ac	48 8d 54 24 20	 lea	 rdx, QWORD PTR csbi$124101[rsp]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleScreenBufferInfo
  000ba	85 c0		 test	 eax, eax

; 10971:             return PyErr_SetFromWindowsErr(0);

  000bc	74 e1		 je	 SHORT $LN16@get_termin

; 10972: 
; 10973:         columns = csbi.srWindow.Right - csbi.srWindow.Left + 1;
; 10974:         lines = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
; 10975:     }
; 10976: #endif /* TERMSIZE_USE_CONIO */
; 10977: 
; 10978:     termsize = PyStructSequence_New(&TerminalSizeType);

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TerminalSizeType
  000c5	e8 00 00 00 00	 call	 PyStructSequence_New
  000ca	48 8b d8	 mov	 rbx, rax

; 10979:     if (termsize == NULL)

  000cd	48 85 c0	 test	 rax, rax

; 10980:         return NULL;

  000d0	74 40		 je	 SHORT $LN15@get_termin

; 10981:     PyStructSequence_SET_ITEM(termsize, 0, PyLong_FromLong(columns));

  000d2	0f bf 44 24 2a	 movsx	 eax, WORD PTR csbi$124101[rsp+10]
  000d7	0f bf 4c 24 2e	 movsx	 ecx, WORD PTR csbi$124101[rsp+14]
  000dc	2b c8		 sub	 ecx, eax
  000de	ff c1		 inc	 ecx
  000e0	e8 00 00 00 00	 call	 PyLong_FromLong

; 10982:     PyStructSequence_SET_ITEM(termsize, 1, PyLong_FromLong(lines));

  000e5	0f bf 4c 24 30	 movsx	 ecx, WORD PTR csbi$124101[rsp+16]
  000ea	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  000ee	0f bf 44 24 2c	 movsx	 eax, WORD PTR csbi$124101[rsp+12]
  000f3	2b c8		 sub	 ecx, eax
  000f5	ff c1		 inc	 ecx
  000f7	e8 00 00 00 00	 call	 PyLong_FromLong
  000fc	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 10983:     if (PyErr_Occurred()) {

  00100	e8 00 00 00 00	 call	 PyErr_Occurred
  00105	48 85 c0	 test	 rax, rax
  00108	74 10		 je	 SHORT $LN1@get_termin

; 10984:         Py_DECREF(termsize);

  0010a	48 8b cb	 mov	 rcx, rbx
  0010d	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@get_termin:

; 10985:         return NULL;

  00112	33 c0		 xor	 eax, eax

; 10988: }

  00114	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00118	5b		 pop	 rbx
  00119	c3		 ret	 0
$LN1@get_termin:

; 10986:     }
; 10987:     return termsize;

  0011a	48 8b c3	 mov	 rax, rbx

; 10988: }

  0011d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00121	5b		 pop	 rbx
  00122	c3		 ret	 0
get_terminal_size ENDP
_TEXT	ENDS
EXTRN	PyModule_AddIntConstant:PROC
; Function compile flags: /Ogtpy
;	COMDAT ins
_TEXT	SEGMENT
module$ = 8
symbol$ = 16
value$ = 24
ins	PROC						; COMDAT

; 11448:     return PyModule_AddIntConstant(module, symbol, value);
; 11449: }

  00000	e9 00 00 00 00	 jmp	 PyModule_AddIntConstant
ins	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@ ; `string'
EXTRN	__imp_AdjustTokenPrivileges:PROC
EXTRN	__imp_LookupPrivilegeValueA:PROC
EXTRN	__imp_OpenProcessToken:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$enable_symlink DD imagerel enable_symlink
	DD	imagerel enable_symlink+74
	DD	imagerel $unwind$enable_symlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$enable_symlink DD imagerel enable_symlink+74
	DD	imagerel enable_symlink+143
	DD	imagerel $chain$0$enable_symlink
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$enable_symlink DD imagerel enable_symlink+143
	DD	imagerel enable_symlink+169
	DD	imagerel $chain$2$enable_symlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$enable_symlink DD 020021H
	DD	083400H
	DD	imagerel enable_symlink
	DD	imagerel enable_symlink+74
	DD	imagerel $unwind$enable_symlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$enable_symlink DD 020521H
	DD	083405H
	DD	imagerel enable_symlink
	DD	imagerel enable_symlink+74
	DD	imagerel $unwind$enable_symlink
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enable_symlink DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@
CONST	SEGMENT
??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@ DB 'SeCreateSymboli'
	DB	'cLinkPrivilege', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT enable_symlink
_TEXT	SEGMENT
tok_priv$ = 48
luid$ = 80
tok$ = 88
enable_symlink PROC					; COMDAT

; 11507: {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 11508:     HANDLE tok;
; 11509:     TOKEN_PRIVILEGES tok_priv;
; 11510:     LUID luid;
; 11511:     int meth_idx = 0;
; 11512: 
; 11513:     if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &tok))

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  0000a	4c 8d 44 24 58	 lea	 r8, QWORD PTR tok$[rsp]
  0000f	ba ff 01 0f 00	 mov	 edx, 983551		; 000f01ffH
  00014	48 8b c8	 mov	 rcx, rax
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcessToken
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN3@enable_sym
$LN7@enable_sym:

; 11514:         return 0;

  00021	33 c0		 xor	 eax, eax

; 11530: }

  00023	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00027	c3		 ret	 0
$LN3@enable_sym:

; 11515: 
; 11516:     if (!LookupPrivilegeValue(NULL, SE_CREATE_SYMBOLIC_LINK_NAME, &luid))

  00028	4c 8d 44 24 50	 lea	 r8, QWORD PTR luid$[rsp]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@
  00034	33 c9		 xor	 ecx, ecx
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LookupPrivilegeValueA
  0003c	85 c0		 test	 eax, eax

; 11517:         return 0;

  0003e	74 e1		 je	 SHORT $LN7@enable_sym

; 11518: 
; 11519:     tok_priv.PrivilegeCount = 1;
; 11520:     tok_priv.Privileges[0].Luid = luid;

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR luid$[rsp]

; 11521:     tok_priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
; 11522: 
; 11523:     if (!AdjustTokenPrivileges(tok, FALSE, &tok_priv,
; 11524:                                sizeof(TOKEN_PRIVILEGES),
; 11525:                                (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL))

  00045	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tok$[rsp]
  0004a	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0004f	33 db		 xor	 ebx, ebx
  00051	4c 8d 44 24 30	 lea	 r8, QWORD PTR tok_priv$[rsp]
  00056	33 d2		 xor	 edx, edx
  00058	44 8d 4b 10	 lea	 r9d, QWORD PTR [rbx+16]
  0005c	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00061	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tok_priv$[rsp], 1
  00069	48 89 44 24 34	 mov	 QWORD PTR tok_priv$[rsp+4], rax
  0006e	c7 44 24 3c 02
	00 00 00	 mov	 DWORD PTR tok_priv$[rsp+12], 2
  00076	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AdjustTokenPrivileges
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN1@enable_sym
  00085	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 11530: }

  0008a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008e	c3		 ret	 0
$LN1@enable_sym:

; 11526:         return 0;
; 11527: 
; 11528:     /* ERROR_NOT_ALL_ASSIGNED returned when the privilege can't be assigned. */
; 11529:     return GetLastError() == ERROR_NOT_ALL_ASSIGNED ? 0 : 1;

  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00095	3d 14 05 00 00	 cmp	 eax, 1300		; 00000514H
  0009a	0f 95 c3	 setne	 bl
  0009d	8b c3		 mov	 eax, ebx
  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 11530: }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
enable_symlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KMDECBDP@P_DETACH?$AA@			; `string'
PUBLIC	??_C@_09IIOMBIO@P_NOWAITO?$AA@			; `string'
PUBLIC	??_C@_09GOJHHCLB@P_OVERLAY?$AA@			; `string'
PUBLIC	??_C@_08FJPPPEM@P_NOWAIT?$AA@			; `string'
PUBLIC	??_C@_06LEJJHBII@P_WAIT?$AA@			; `string'
PUBLIC	??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@		; `string'
PUBLIC	??_C@_08CJDBDFEN@O_RANDOM?$AA@			; `string'
PUBLIC	??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@		; `string'
PUBLIC	??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@		; `string'
PUBLIC	??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@		; `string'
PUBLIC	??_C@_06PACJLJGP@O_TEXT?$AA@			; `string'
PUBLIC	??_C@_08KPDCDMKK@O_BINARY?$AA@			; `string'
PUBLIC	??_C@_07DHLCPMFP@O_TRUNC?$AA@			; `string'
PUBLIC	??_C@_06JNLCFMNH@O_EXCL?$AA@			; `string'
PUBLIC	??_C@_07HHKHFKEI@O_CREAT?$AA@			; `string'
PUBLIC	??_C@_08OBPNNI@O_APPEND?$AA@			; `string'
PUBLIC	??_C@_06JKNDMLBB@O_RDWR?$AA@			; `string'
PUBLIC	??_C@_08IAHOMKAH@O_WRONLY?$AA@			; `string'
PUBLIC	??_C@_08HMJAECG@O_RDONLY?$AA@			; `string'
PUBLIC	??_C@_07LCOECJLF@TMP_MAX?$AA@			; `string'
PUBLIC	??_C@_04MKJLMPCP@X_OK?$AA@			; `string'
PUBLIC	??_C@_04EIMLFIPO@W_OK?$AA@			; `string'
PUBLIC	??_C@_04IACLNHIO@R_OK?$AA@			; `string'
PUBLIC	??_C@_04BFELOGMM@F_OK?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$all_ins DD imagerel all_ins
	DD	imagerel all_ins+656
	DD	imagerel $unwind$all_ins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$all_ins DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_08KMDECBDP@P_DETACH?$AA@
CONST	SEGMENT
??_C@_08KMDECBDP@P_DETACH?$AA@ DB 'P_DETACH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IIOMBIO@P_NOWAITO?$AA@
CONST	SEGMENT
??_C@_09IIOMBIO@P_NOWAITO?$AA@ DB 'P_NOWAITO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOJHHCLB@P_OVERLAY?$AA@
CONST	SEGMENT
??_C@_09GOJHHCLB@P_OVERLAY?$AA@ DB 'P_OVERLAY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJPPPEM@P_NOWAIT?$AA@
CONST	SEGMENT
??_C@_08FJPPPEM@P_NOWAIT?$AA@ DB 'P_NOWAIT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEJJHBII@P_WAIT?$AA@
CONST	SEGMENT
??_C@_06LEJJHBII@P_WAIT?$AA@ DB 'P_WAIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@
CONST	SEGMENT
??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@ DB 'O_SEQUENTIAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJDBDFEN@O_RANDOM?$AA@
CONST	SEGMENT
??_C@_08CJDBDFEN@O_RANDOM?$AA@ DB 'O_RANDOM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@
CONST	SEGMENT
??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@ DB 'O_TEMPORARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@
CONST	SEGMENT
??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@ DB 'O_SHORT_LIVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@
CONST	SEGMENT
??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@ DB 'O_NOINHERIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PACJLJGP@O_TEXT?$AA@
CONST	SEGMENT
??_C@_06PACJLJGP@O_TEXT?$AA@ DB 'O_TEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPDCDMKK@O_BINARY?$AA@
CONST	SEGMENT
??_C@_08KPDCDMKK@O_BINARY?$AA@ DB 'O_BINARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DHLCPMFP@O_TRUNC?$AA@
CONST	SEGMENT
??_C@_07DHLCPMFP@O_TRUNC?$AA@ DB 'O_TRUNC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNLCFMNH@O_EXCL?$AA@
CONST	SEGMENT
??_C@_06JNLCFMNH@O_EXCL?$AA@ DB 'O_EXCL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHKHFKEI@O_CREAT?$AA@
CONST	SEGMENT
??_C@_07HHKHFKEI@O_CREAT?$AA@ DB 'O_CREAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBPNNI@O_APPEND?$AA@
CONST	SEGMENT
??_C@_08OBPNNI@O_APPEND?$AA@ DB 'O_APPEND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKNDMLBB@O_RDWR?$AA@
CONST	SEGMENT
??_C@_06JKNDMLBB@O_RDWR?$AA@ DB 'O_RDWR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAHOMKAH@O_WRONLY?$AA@
CONST	SEGMENT
??_C@_08IAHOMKAH@O_WRONLY?$AA@ DB 'O_WRONLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMJAECG@O_RDONLY?$AA@
CONST	SEGMENT
??_C@_08HMJAECG@O_RDONLY?$AA@ DB 'O_RDONLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCOECJLF@TMP_MAX?$AA@
CONST	SEGMENT
??_C@_07LCOECJLF@TMP_MAX?$AA@ DB 'TMP_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKJLMPCP@X_OK?$AA@
CONST	SEGMENT
??_C@_04MKJLMPCP@X_OK?$AA@ DB 'X_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIMLFIPO@W_OK?$AA@
CONST	SEGMENT
??_C@_04EIMLFIPO@W_OK?$AA@ DB 'W_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IACLNHIO@R_OK?$AA@
CONST	SEGMENT
??_C@_04IACLNHIO@R_OK?$AA@ DB 'R_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFELOGMM@F_OK?$AA@
CONST	SEGMENT
??_C@_04BFELOGMM@F_OK?$AA@ DB 'F_OK', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT all_ins
_TEXT	SEGMENT
d$ = 48
all_ins	PROC						; COMDAT

; 11535: {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 11536: #ifdef F_OK
; 11537:     if (ins(d, "F_OK", (long)F_OK)) return -1;

  00006	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BFELOGMM@F_OK?$AA@
  0000d	45 33 c0	 xor	 r8d, r8d
  00010	48 8b d9	 mov	 rbx, rcx
  00013	e8 00 00 00 00	 call	 ins
  00018	85 c0		 test	 eax, eax
  0001a	74 09		 je	 SHORT $LN24@all_ins
$LN27@all_ins:
  0001c	83 c8 ff	 or	 eax, -1

; 11865: #endif
; 11866: #endif
; 11867: 
; 11868: #ifdef HAVE_SCHED_H
; 11869:     if (ins(d, "SCHED_OTHER", (long)SCHED_OTHER)) return -1;
; 11870:     if (ins(d, "SCHED_FIFO", (long)SCHED_FIFO)) return -1;
; 11871:     if (ins(d, "SCHED_RR", (long)SCHED_RR)) return -1;
; 11872: #ifdef SCHED_SPORADIC
; 11873:     if (ins(d, "SCHED_SPORADIC", (long)SCHED_SPORADIC)) return -1;
; 11874: #endif
; 11875: #ifdef SCHED_BATCH
; 11876:     if (ins(d, "SCHED_BATCH", (long)SCHED_BATCH)) return -1;
; 11877: #endif
; 11878: #ifdef SCHED_IDLE
; 11879:     if (ins(d, "SCHED_IDLE", (long)SCHED_IDLE)) return -1;
; 11880: #endif
; 11881: #ifdef SCHED_RESET_ON_FORK
; 11882:     if (ins(d, "SCHED_RESET_ON_FORK", (long)SCHED_RESET_ON_FORK)) return -1;
; 11883: #endif
; 11884: #ifdef SCHED_SYS
; 11885:     if (ins(d, "SCHED_SYS", (long)SCHED_SYS)) return -1;
; 11886: #endif
; 11887: #ifdef SCHED_IA
; 11888:     if (ins(d, "SCHED_IA", (long)SCHED_IA)) return -1;
; 11889: #endif
; 11890: #ifdef SCHED_FSS
; 11891:     if (ins(d, "SCHED_FSS", (long)SCHED_FSS)) return -1;
; 11892: #endif
; 11893: #ifdef SCHED_FX
; 11894:     if (ins(d, "SCHED_FX", (long)SCHED_FSS)) return -1;
; 11895: #endif
; 11896: #endif
; 11897: 
; 11898: #ifdef USE_XATTRS
; 11899:     if (ins(d, "XATTR_CREATE", (long)XATTR_CREATE)) return -1;
; 11900:     if (ins(d, "XATTR_REPLACE", (long)XATTR_REPLACE)) return -1;
; 11901:     if (ins(d, "XATTR_SIZE_MAX", (long)XATTR_SIZE_MAX)) return -1;
; 11902: #endif
; 11903: 
; 11904: #ifdef RTLD_LAZY
; 11905:     if (PyModule_AddIntMacro(d, RTLD_LAZY)) return -1;
; 11906: #endif
; 11907: #ifdef RTLD_NOW
; 11908:     if (PyModule_AddIntMacro(d, RTLD_NOW)) return -1;
; 11909: #endif
; 11910: #ifdef RTLD_GLOBAL
; 11911:     if (PyModule_AddIntMacro(d, RTLD_GLOBAL)) return -1;
; 11912: #endif
; 11913: #ifdef RTLD_LOCAL
; 11914:     if (PyModule_AddIntMacro(d, RTLD_LOCAL)) return -1;
; 11915: #endif
; 11916: #ifdef RTLD_NODELETE
; 11917:     if (PyModule_AddIntMacro(d, RTLD_NODELETE)) return -1;
; 11918: #endif
; 11919: #ifdef RTLD_NOLOAD
; 11920:     if (PyModule_AddIntMacro(d, RTLD_NOLOAD)) return -1;
; 11921: #endif
; 11922: #ifdef RTLD_DEEPBIND
; 11923:     if (PyModule_AddIntMacro(d, RTLD_DEEPBIND)) return -1;
; 11924: #endif
; 11925: 
; 11926: #if defined(PYOS_OS2)
; 11927:     if (insertvalues(d)) return -1;
; 11928: #endif
; 11929:     return 0;
; 11930: }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN24@all_ins:

; 11538: #endif
; 11539: #ifdef R_OK
; 11540:     if (ins(d, "R_OK", (long)R_OK)) return -1;

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IACLNHIO@R_OK?$AA@
  0002c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00032	48 8b cb	 mov	 rcx, rbx
  00035	e8 00 00 00 00	 call	 ins
  0003a	85 c0		 test	 eax, eax
  0003c	75 de		 jne	 SHORT $LN27@all_ins

; 11541: #endif
; 11542: #ifdef W_OK
; 11543:     if (ins(d, "W_OK", (long)W_OK)) return -1;

  0003e	44 8d 40 02	 lea	 r8d, QWORD PTR [rax+2]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04EIMLFIPO@W_OK?$AA@
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 ins
  00051	85 c0		 test	 eax, eax
  00053	75 c7		 jne	 SHORT $LN27@all_ins

; 11544: #endif
; 11545: #ifdef X_OK
; 11546:     if (ins(d, "X_OK", (long)X_OK)) return -1;

  00055	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MKJLMPCP@X_OK?$AA@
  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 ins
  00068	85 c0		 test	 eax, eax
  0006a	75 b0		 jne	 SHORT $LN27@all_ins

; 11547: #endif
; 11548: #ifdef NGROUPS_MAX
; 11549:     if (ins(d, "NGROUPS_MAX", (long)NGROUPS_MAX)) return -1;
; 11550: #endif
; 11551: #ifdef TMP_MAX
; 11552:     if (ins(d, "TMP_MAX", (long)TMP_MAX)) return -1;

  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LCOECJLF@TMP_MAX?$AA@
  00073	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  00079	48 8b cb	 mov	 rcx, rbx
  0007c	e8 00 00 00 00	 call	 ins
  00081	85 c0		 test	 eax, eax
  00083	75 97		 jne	 SHORT $LN27@all_ins

; 11553: #endif
; 11554: #ifdef WCONTINUED
; 11555:     if (ins(d, "WCONTINUED", (long)WCONTINUED)) return -1;
; 11556: #endif
; 11557: #ifdef WNOHANG
; 11558:     if (ins(d, "WNOHANG", (long)WNOHANG)) return -1;
; 11559: #endif
; 11560: #ifdef WUNTRACED
; 11561:     if (ins(d, "WUNTRACED", (long)WUNTRACED)) return -1;
; 11562: #endif
; 11563: #ifdef O_RDONLY
; 11564:     if (ins(d, "O_RDONLY", (long)O_RDONLY)) return -1;

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HMJAECG@O_RDONLY?$AA@
  0008c	45 33 c0	 xor	 r8d, r8d
  0008f	48 8b cb	 mov	 rcx, rbx
  00092	e8 00 00 00 00	 call	 ins
  00097	85 c0		 test	 eax, eax
  00099	75 81		 jne	 SHORT $LN27@all_ins

; 11565: #endif
; 11566: #ifdef O_WRONLY
; 11567:     if (ins(d, "O_WRONLY", (long)O_WRONLY)) return -1;

  0009b	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IAHOMKAH@O_WRONLY?$AA@
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	e8 00 00 00 00	 call	 ins
  000ae	85 c0		 test	 eax, eax
  000b0	0f 85 66 ff ff
	ff		 jne	 $LN27@all_ins

; 11568: #endif
; 11569: #ifdef O_RDWR
; 11570:     if (ins(d, "O_RDWR", (long)O_RDWR)) return -1;

  000b6	44 8d 40 02	 lea	 r8d, QWORD PTR [rax+2]
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JKNDMLBB@O_RDWR?$AA@
  000c1	48 8b cb	 mov	 rcx, rbx
  000c4	e8 00 00 00 00	 call	 ins
  000c9	85 c0		 test	 eax, eax
  000cb	0f 85 4b ff ff
	ff		 jne	 $LN27@all_ins

; 11571: #endif
; 11572: #ifdef O_NDELAY
; 11573:     if (ins(d, "O_NDELAY", (long)O_NDELAY)) return -1;
; 11574: #endif
; 11575: #ifdef O_NONBLOCK
; 11576:     if (ins(d, "O_NONBLOCK", (long)O_NONBLOCK)) return -1;
; 11577: #endif
; 11578: #ifdef O_APPEND
; 11579:     if (ins(d, "O_APPEND", (long)O_APPEND)) return -1;

  000d1	44 8d 40 08	 lea	 r8d, QWORD PTR [rax+8]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OBPNNI@O_APPEND?$AA@
  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 ins
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 30 ff ff
	ff		 jne	 $LN27@all_ins

; 11580: #endif
; 11581: #ifdef O_DSYNC
; 11582:     if (ins(d, "O_DSYNC", (long)O_DSYNC)) return -1;
; 11583: #endif
; 11584: #ifdef O_RSYNC
; 11585:     if (ins(d, "O_RSYNC", (long)O_RSYNC)) return -1;
; 11586: #endif
; 11587: #ifdef O_SYNC
; 11588:     if (ins(d, "O_SYNC", (long)O_SYNC)) return -1;
; 11589: #endif
; 11590: #ifdef O_NOCTTY
; 11591:     if (ins(d, "O_NOCTTY", (long)O_NOCTTY)) return -1;
; 11592: #endif
; 11593: #ifdef O_CREAT
; 11594:     if (ins(d, "O_CREAT", (long)O_CREAT)) return -1;

  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HHKHFKEI@O_CREAT?$AA@
  000f3	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	e8 00 00 00 00	 call	 ins
  00101	85 c0		 test	 eax, eax
  00103	0f 85 13 ff ff
	ff		 jne	 $LN27@all_ins

; 11595: #endif
; 11596: #ifdef O_EXCL
; 11597:     if (ins(d, "O_EXCL", (long)O_EXCL)) return -1;

  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JNLCFMNH@O_EXCL?$AA@
  00110	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  00116	48 8b cb	 mov	 rcx, rbx
  00119	e8 00 00 00 00	 call	 ins
  0011e	85 c0		 test	 eax, eax
  00120	0f 85 f6 fe ff
	ff		 jne	 $LN27@all_ins

; 11598: #endif
; 11599: #ifdef O_TRUNC
; 11600:     if (ins(d, "O_TRUNC", (long)O_TRUNC)) return -1;

  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DHLCPMFP@O_TRUNC?$AA@
  0012d	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 ins
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 d9 fe ff
	ff		 jne	 $LN27@all_ins

; 11601: #endif
; 11602: #ifdef O_BINARY
; 11603:     if (ins(d, "O_BINARY", (long)O_BINARY)) return -1;

  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KPDCDMKK@O_BINARY?$AA@
  0014a	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00150	48 8b cb	 mov	 rcx, rbx
  00153	e8 00 00 00 00	 call	 ins
  00158	85 c0		 test	 eax, eax
  0015a	0f 85 bc fe ff
	ff		 jne	 $LN27@all_ins

; 11604: #endif
; 11605: #ifdef O_TEXT
; 11606:     if (ins(d, "O_TEXT", (long)O_TEXT)) return -1;

  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PACJLJGP@O_TEXT?$AA@
  00167	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  0016d	48 8b cb	 mov	 rcx, rbx
  00170	e8 00 00 00 00	 call	 ins
  00175	85 c0		 test	 eax, eax
  00177	0f 85 9f fe ff
	ff		 jne	 $LN27@all_ins

; 11607: #endif
; 11608: #ifdef O_XATTR
; 11609:     if (ins(d, "O_XATTR", (long)O_XATTR)) return -1;
; 11610: #endif
; 11611: #ifdef O_LARGEFILE
; 11612:     if (ins(d, "O_LARGEFILE", (long)O_LARGEFILE)) return -1;
; 11613: #endif
; 11614: #ifdef O_SHLOCK
; 11615:     if (ins(d, "O_SHLOCK", (long)O_SHLOCK)) return -1;
; 11616: #endif
; 11617: #ifdef O_EXLOCK
; 11618:     if (ins(d, "O_EXLOCK", (long)O_EXLOCK)) return -1;
; 11619: #endif
; 11620: #ifdef O_EXEC
; 11621:     if (ins(d, "O_EXEC", (long)O_EXEC)) return -1;
; 11622: #endif
; 11623: #ifdef O_SEARCH
; 11624:     if (ins(d, "O_SEARCH", (long)O_SEARCH)) return -1;
; 11625: #endif
; 11626: #ifdef O_TTY_INIT
; 11627:     if (ins(d, "O_TTY_INIT", (long)O_TTY_INIT)) return -1;
; 11628: #endif
; 11629: #ifdef PRIO_PROCESS
; 11630:     if (ins(d, "PRIO_PROCESS", (long)PRIO_PROCESS)) return -1;
; 11631: #endif
; 11632: #ifdef PRIO_PGRP
; 11633:     if (ins(d, "PRIO_PGRP", (long)PRIO_PGRP)) return -1;
; 11634: #endif
; 11635: #ifdef PRIO_USER
; 11636:     if (ins(d, "PRIO_USER", (long)PRIO_USER)) return -1;
; 11637: #endif
; 11638: #ifdef O_CLOEXEC
; 11639:     if (ins(d, "O_CLOEXEC", (long)O_CLOEXEC)) return -1;
; 11640: #endif
; 11641: #ifdef O_ACCMODE
; 11642:     if (ins(d, "O_ACCMODE", (long)O_ACCMODE)) return -1;
; 11643: #endif
; 11644: 
; 11645: 
; 11646: #ifdef SEEK_HOLE
; 11647:     if (ins(d, "SEEK_HOLE", (long)SEEK_HOLE)) return -1;
; 11648: #endif
; 11649: #ifdef SEEK_DATA
; 11650:     if (ins(d, "SEEK_DATA", (long)SEEK_DATA)) return -1;
; 11651: #endif
; 11652: 
; 11653: /* MS Windows */
; 11654: #ifdef O_NOINHERIT
; 11655:     /* Don't inherit in child processes. */
; 11656:     if (ins(d, "O_NOINHERIT", (long)O_NOINHERIT)) return -1;

  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@
  00184	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0018a	48 8b cb	 mov	 rcx, rbx
  0018d	e8 00 00 00 00	 call	 ins
  00192	85 c0		 test	 eax, eax
  00194	0f 85 82 fe ff
	ff		 jne	 $LN27@all_ins

; 11657: #endif
; 11658: #ifdef _O_SHORT_LIVED
; 11659:     /* Optimize for short life (keep in memory). */
; 11660:     /* MS forgot to define this one with a non-underscore form too. */
; 11661:     if (ins(d, "O_SHORT_LIVED", (long)_O_SHORT_LIVED)) return -1;

  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@
  001a1	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  001a7	48 8b cb	 mov	 rcx, rbx
  001aa	e8 00 00 00 00	 call	 ins
  001af	85 c0		 test	 eax, eax
  001b1	0f 85 65 fe ff
	ff		 jne	 $LN27@all_ins

; 11662: #endif
; 11663: #ifdef O_TEMPORARY
; 11664:     /* Automatically delete when last handle is closed. */
; 11665:     if (ins(d, "O_TEMPORARY", (long)O_TEMPORARY)) return -1;

  001b7	44 8d 40 40	 lea	 r8d, QWORD PTR [rax+64]
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@
  001c2	48 8b cb	 mov	 rcx, rbx
  001c5	e8 00 00 00 00	 call	 ins
  001ca	85 c0		 test	 eax, eax
  001cc	0f 85 4a fe ff
	ff		 jne	 $LN27@all_ins

; 11666: #endif
; 11667: #ifdef O_RANDOM
; 11668:     /* Optimize for random access. */
; 11669:     if (ins(d, "O_RANDOM", (long)O_RANDOM)) return -1;

  001d2	44 8d 40 10	 lea	 r8d, QWORD PTR [rax+16]
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CJDBDFEN@O_RANDOM?$AA@
  001dd	48 8b cb	 mov	 rcx, rbx
  001e0	e8 00 00 00 00	 call	 ins
  001e5	85 c0		 test	 eax, eax
  001e7	0f 85 2f fe ff
	ff		 jne	 $LN27@all_ins

; 11670: #endif
; 11671: #ifdef O_SEQUENTIAL
; 11672:     /* Optimize for sequential access. */
; 11673:     if (ins(d, "O_SEQUENTIAL", (long)O_SEQUENTIAL)) return -1;

  001ed	44 8d 40 20	 lea	 r8d, QWORD PTR [rax+32]
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@
  001f8	48 8b cb	 mov	 rcx, rbx
  001fb	e8 00 00 00 00	 call	 ins
  00200	85 c0		 test	 eax, eax
  00202	0f 85 14 fe ff
	ff		 jne	 $LN27@all_ins

; 11674: #endif
; 11675: 
; 11676: /* GNU extensions. */
; 11677: #ifdef O_ASYNC
; 11678:     /* Send a SIGIO signal whenever input or output
; 11679:        becomes available on file descriptor */
; 11680:     if (ins(d, "O_ASYNC", (long)O_ASYNC)) return -1;
; 11681: #endif
; 11682: #ifdef O_DIRECT
; 11683:     /* Direct disk access. */
; 11684:     if (ins(d, "O_DIRECT", (long)O_DIRECT)) return -1;
; 11685: #endif
; 11686: #ifdef O_DIRECTORY
; 11687:     /* Must be a directory.      */
; 11688:     if (ins(d, "O_DIRECTORY", (long)O_DIRECTORY)) return -1;
; 11689: #endif
; 11690: #ifdef O_NOFOLLOW
; 11691:     /* Do not follow links.      */
; 11692:     if (ins(d, "O_NOFOLLOW", (long)O_NOFOLLOW)) return -1;
; 11693: #endif
; 11694: #ifdef O_NOLINKS
; 11695:     /* Fails if link count of the named file is greater than 1 */
; 11696:     if (ins(d, "O_NOLINKS", (long)O_NOLINKS)) return -1;
; 11697: #endif
; 11698: #ifdef O_NOATIME
; 11699:     /* Do not update the access time. */
; 11700:     if (ins(d, "O_NOATIME", (long)O_NOATIME)) return -1;
; 11701: #endif
; 11702: 
; 11703:     /* These come from sysexits.h */
; 11704: #ifdef EX_OK
; 11705:     if (ins(d, "EX_OK", (long)EX_OK)) return -1;
; 11706: #endif /* EX_OK */
; 11707: #ifdef EX_USAGE
; 11708:     if (ins(d, "EX_USAGE", (long)EX_USAGE)) return -1;
; 11709: #endif /* EX_USAGE */
; 11710: #ifdef EX_DATAERR
; 11711:     if (ins(d, "EX_DATAERR", (long)EX_DATAERR)) return -1;
; 11712: #endif /* EX_DATAERR */
; 11713: #ifdef EX_NOINPUT
; 11714:     if (ins(d, "EX_NOINPUT", (long)EX_NOINPUT)) return -1;
; 11715: #endif /* EX_NOINPUT */
; 11716: #ifdef EX_NOUSER
; 11717:     if (ins(d, "EX_NOUSER", (long)EX_NOUSER)) return -1;
; 11718: #endif /* EX_NOUSER */
; 11719: #ifdef EX_NOHOST
; 11720:     if (ins(d, "EX_NOHOST", (long)EX_NOHOST)) return -1;
; 11721: #endif /* EX_NOHOST */
; 11722: #ifdef EX_UNAVAILABLE
; 11723:     if (ins(d, "EX_UNAVAILABLE", (long)EX_UNAVAILABLE)) return -1;
; 11724: #endif /* EX_UNAVAILABLE */
; 11725: #ifdef EX_SOFTWARE
; 11726:     if (ins(d, "EX_SOFTWARE", (long)EX_SOFTWARE)) return -1;
; 11727: #endif /* EX_SOFTWARE */
; 11728: #ifdef EX_OSERR
; 11729:     if (ins(d, "EX_OSERR", (long)EX_OSERR)) return -1;
; 11730: #endif /* EX_OSERR */
; 11731: #ifdef EX_OSFILE
; 11732:     if (ins(d, "EX_OSFILE", (long)EX_OSFILE)) return -1;
; 11733: #endif /* EX_OSFILE */
; 11734: #ifdef EX_CANTCREAT
; 11735:     if (ins(d, "EX_CANTCREAT", (long)EX_CANTCREAT)) return -1;
; 11736: #endif /* EX_CANTCREAT */
; 11737: #ifdef EX_IOERR
; 11738:     if (ins(d, "EX_IOERR", (long)EX_IOERR)) return -1;
; 11739: #endif /* EX_IOERR */
; 11740: #ifdef EX_TEMPFAIL
; 11741:     if (ins(d, "EX_TEMPFAIL", (long)EX_TEMPFAIL)) return -1;
; 11742: #endif /* EX_TEMPFAIL */
; 11743: #ifdef EX_PROTOCOL
; 11744:     if (ins(d, "EX_PROTOCOL", (long)EX_PROTOCOL)) return -1;
; 11745: #endif /* EX_PROTOCOL */
; 11746: #ifdef EX_NOPERM
; 11747:     if (ins(d, "EX_NOPERM", (long)EX_NOPERM)) return -1;
; 11748: #endif /* EX_NOPERM */
; 11749: #ifdef EX_CONFIG
; 11750:     if (ins(d, "EX_CONFIG", (long)EX_CONFIG)) return -1;
; 11751: #endif /* EX_CONFIG */
; 11752: #ifdef EX_NOTFOUND
; 11753:     if (ins(d, "EX_NOTFOUND", (long)EX_NOTFOUND)) return -1;
; 11754: #endif /* EX_NOTFOUND */
; 11755: 
; 11756:     /* statvfs */
; 11757: #ifdef ST_RDONLY
; 11758:     if (ins(d, "ST_RDONLY", (long)ST_RDONLY)) return -1;
; 11759: #endif /* ST_RDONLY */
; 11760: #ifdef ST_NOSUID
; 11761:     if (ins(d, "ST_NOSUID", (long)ST_NOSUID)) return -1;
; 11762: #endif /* ST_NOSUID */
; 11763: 
; 11764:     /* FreeBSD sendfile() constants */
; 11765: #ifdef SF_NODISKIO
; 11766:     if (ins(d, "SF_NODISKIO", (long)SF_NODISKIO)) return -1;
; 11767: #endif
; 11768: #ifdef SF_MNOWAIT
; 11769:     if (ins(d, "SF_MNOWAIT", (long)SF_MNOWAIT)) return -1;
; 11770: #endif
; 11771: #ifdef SF_SYNC
; 11772:     if (ins(d, "SF_SYNC", (long)SF_SYNC)) return -1;
; 11773: #endif
; 11774: 
; 11775:     /* constants for posix_fadvise */
; 11776: #ifdef POSIX_FADV_NORMAL
; 11777:     if (ins(d, "POSIX_FADV_NORMAL", (long)POSIX_FADV_NORMAL)) return -1;
; 11778: #endif
; 11779: #ifdef POSIX_FADV_SEQUENTIAL
; 11780:     if (ins(d, "POSIX_FADV_SEQUENTIAL", (long)POSIX_FADV_SEQUENTIAL)) return -1;
; 11781: #endif
; 11782: #ifdef POSIX_FADV_RANDOM
; 11783:     if (ins(d, "POSIX_FADV_RANDOM", (long)POSIX_FADV_RANDOM)) return -1;
; 11784: #endif
; 11785: #ifdef POSIX_FADV_NOREUSE
; 11786:     if (ins(d, "POSIX_FADV_NOREUSE", (long)POSIX_FADV_NOREUSE)) return -1;
; 11787: #endif
; 11788: #ifdef POSIX_FADV_WILLNEED
; 11789:     if (ins(d, "POSIX_FADV_WILLNEED", (long)POSIX_FADV_WILLNEED)) return -1;
; 11790: #endif
; 11791: #ifdef POSIX_FADV_DONTNEED
; 11792:     if (ins(d, "POSIX_FADV_DONTNEED", (long)POSIX_FADV_DONTNEED)) return -1;
; 11793: #endif
; 11794: 
; 11795:     /* constants for waitid */
; 11796: #if defined(HAVE_SYS_WAIT_H) && defined(HAVE_WAITID)
; 11797:     if (ins(d, "P_PID", (long)P_PID)) return -1;
; 11798:     if (ins(d, "P_PGID", (long)P_PGID)) return -1;
; 11799:     if (ins(d, "P_ALL", (long)P_ALL)) return -1;
; 11800: #endif
; 11801: #ifdef WEXITED
; 11802:     if (ins(d, "WEXITED", (long)WEXITED)) return -1;
; 11803: #endif
; 11804: #ifdef WNOWAIT
; 11805:     if (ins(d, "WNOWAIT", (long)WNOWAIT)) return -1;
; 11806: #endif
; 11807: #ifdef WSTOPPED
; 11808:     if (ins(d, "WSTOPPED", (long)WSTOPPED)) return -1;
; 11809: #endif
; 11810: #ifdef CLD_EXITED
; 11811:     if (ins(d, "CLD_EXITED", (long)CLD_EXITED)) return -1;
; 11812: #endif
; 11813: #ifdef CLD_DUMPED
; 11814:     if (ins(d, "CLD_DUMPED", (long)CLD_DUMPED)) return -1;
; 11815: #endif
; 11816: #ifdef CLD_TRAPPED
; 11817:     if (ins(d, "CLD_TRAPPED", (long)CLD_TRAPPED)) return -1;
; 11818: #endif
; 11819: #ifdef CLD_CONTINUED
; 11820:     if (ins(d, "CLD_CONTINUED", (long)CLD_CONTINUED)) return -1;
; 11821: #endif
; 11822: 
; 11823:     /* constants for lockf */
; 11824: #ifdef F_LOCK
; 11825:     if (ins(d, "F_LOCK", (long)F_LOCK)) return -1;
; 11826: #endif
; 11827: #ifdef F_TLOCK
; 11828:     if (ins(d, "F_TLOCK", (long)F_TLOCK)) return -1;
; 11829: #endif
; 11830: #ifdef F_ULOCK
; 11831:     if (ins(d, "F_ULOCK", (long)F_ULOCK)) return -1;
; 11832: #endif
; 11833: #ifdef F_TEST
; 11834:     if (ins(d, "F_TEST", (long)F_TEST)) return -1;
; 11835: #endif
; 11836: 
; 11837: #ifdef HAVE_SPAWNV
; 11838: #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 11839:     if (ins(d, "P_WAIT", (long)P_WAIT)) return -1;
; 11840:     if (ins(d, "P_NOWAIT", (long)P_NOWAIT)) return -1;
; 11841:     if (ins(d, "P_OVERLAY", (long)P_OVERLAY)) return -1;
; 11842:     if (ins(d, "P_DEBUG", (long)P_DEBUG)) return -1;
; 11843:     if (ins(d, "P_SESSION", (long)P_SESSION)) return -1;
; 11844:     if (ins(d, "P_DETACH", (long)P_DETACH)) return -1;
; 11845:     if (ins(d, "P_PM", (long)P_PM)) return -1;
; 11846:     if (ins(d, "P_DEFAULT", (long)P_DEFAULT)) return -1;
; 11847:     if (ins(d, "P_MINIMIZE", (long)P_MINIMIZE)) return -1;
; 11848:     if (ins(d, "P_MAXIMIZE", (long)P_MAXIMIZE)) return -1;
; 11849:     if (ins(d, "P_FULLSCREEN", (long)P_FULLSCREEN)) return -1;
; 11850:     if (ins(d, "P_WINDOWED", (long)P_WINDOWED)) return -1;
; 11851:     if (ins(d, "P_FOREGROUND", (long)P_FOREGROUND)) return -1;
; 11852:     if (ins(d, "P_BACKGROUND", (long)P_BACKGROUND)) return -1;
; 11853:     if (ins(d, "P_NOCLOSE", (long)P_NOCLOSE)) return -1;
; 11854:     if (ins(d, "P_NOSESSION", (long)P_NOSESSION)) return -1;
; 11855:     if (ins(d, "P_QUOTE", (long)P_QUOTE)) return -1;
; 11856:     if (ins(d, "P_TILDE", (long)P_TILDE)) return -1;
; 11857:     if (ins(d, "P_UNRELATED", (long)P_UNRELATED)) return -1;
; 11858:     if (ins(d, "P_DEBUGDESC", (long)P_DEBUGDESC)) return -1;
; 11859: #else
; 11860:     if (ins(d, "P_WAIT", (long)_P_WAIT)) return -1;

  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LEJJHBII@P_WAIT?$AA@
  0020f	45 33 c0	 xor	 r8d, r8d
  00212	48 8b cb	 mov	 rcx, rbx
  00215	e8 00 00 00 00	 call	 ins
  0021a	85 c0		 test	 eax, eax
  0021c	0f 85 fa fd ff
	ff		 jne	 $LN27@all_ins

; 11861:     if (ins(d, "P_NOWAIT", (long)_P_NOWAIT)) return -1;

  00222	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08FJPPPEM@P_NOWAIT?$AA@
  0022d	48 8b cb	 mov	 rcx, rbx
  00230	e8 00 00 00 00	 call	 ins
  00235	85 c0		 test	 eax, eax
  00237	0f 85 df fd ff
	ff		 jne	 $LN27@all_ins

; 11862:     if (ins(d, "P_OVERLAY", (long)_OLD_P_OVERLAY)) return -1;

  0023d	44 8d 40 02	 lea	 r8d, QWORD PTR [rax+2]
  00241	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09GOJHHCLB@P_OVERLAY?$AA@
  00248	48 8b cb	 mov	 rcx, rbx
  0024b	e8 00 00 00 00	 call	 ins
  00250	85 c0		 test	 eax, eax
  00252	0f 85 c4 fd ff
	ff		 jne	 $LN27@all_ins

; 11863:     if (ins(d, "P_NOWAITO", (long)_P_NOWAITO)) return -1;

  00258	44 8d 40 03	 lea	 r8d, QWORD PTR [rax+3]
  0025c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IIOMBIO@P_NOWAITO?$AA@
  00263	48 8b cb	 mov	 rcx, rbx
  00266	e8 00 00 00 00	 call	 ins
  0026b	85 c0		 test	 eax, eax
  0026d	0f 85 a9 fd ff
	ff		 jne	 $LN27@all_ins

; 11864:     if (ins(d, "P_DETACH", (long)_P_DETACH)) return -1;

  00273	44 8d 40 04	 lea	 r8d, QWORD PTR [rax+4]
  00277	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KMDECBDP@P_DETACH?$AA@
  0027e	48 8b cb	 mov	 rcx, rbx
  00281	e8 00 00 00 00	 call	 ins
  00286	f7 d8		 neg	 eax
  00288	1b c0		 sbb	 eax, eax

; 11865: #endif
; 11866: #endif
; 11867: 
; 11868: #ifdef HAVE_SCHED_H
; 11869:     if (ins(d, "SCHED_OTHER", (long)SCHED_OTHER)) return -1;
; 11870:     if (ins(d, "SCHED_FIFO", (long)SCHED_FIFO)) return -1;
; 11871:     if (ins(d, "SCHED_RR", (long)SCHED_RR)) return -1;
; 11872: #ifdef SCHED_SPORADIC
; 11873:     if (ins(d, "SCHED_SPORADIC", (long)SCHED_SPORADIC)) return -1;
; 11874: #endif
; 11875: #ifdef SCHED_BATCH
; 11876:     if (ins(d, "SCHED_BATCH", (long)SCHED_BATCH)) return -1;
; 11877: #endif
; 11878: #ifdef SCHED_IDLE
; 11879:     if (ins(d, "SCHED_IDLE", (long)SCHED_IDLE)) return -1;
; 11880: #endif
; 11881: #ifdef SCHED_RESET_ON_FORK
; 11882:     if (ins(d, "SCHED_RESET_ON_FORK", (long)SCHED_RESET_ON_FORK)) return -1;
; 11883: #endif
; 11884: #ifdef SCHED_SYS
; 11885:     if (ins(d, "SCHED_SYS", (long)SCHED_SYS)) return -1;
; 11886: #endif
; 11887: #ifdef SCHED_IA
; 11888:     if (ins(d, "SCHED_IA", (long)SCHED_IA)) return -1;
; 11889: #endif
; 11890: #ifdef SCHED_FSS
; 11891:     if (ins(d, "SCHED_FSS", (long)SCHED_FSS)) return -1;
; 11892: #endif
; 11893: #ifdef SCHED_FX
; 11894:     if (ins(d, "SCHED_FX", (long)SCHED_FSS)) return -1;
; 11895: #endif
; 11896: #endif
; 11897: 
; 11898: #ifdef USE_XATTRS
; 11899:     if (ins(d, "XATTR_CREATE", (long)XATTR_CREATE)) return -1;
; 11900:     if (ins(d, "XATTR_REPLACE", (long)XATTR_REPLACE)) return -1;
; 11901:     if (ins(d, "XATTR_SIZE_MAX", (long)XATTR_SIZE_MAX)) return -1;
; 11902: #endif
; 11903: 
; 11904: #ifdef RTLD_LAZY
; 11905:     if (PyModule_AddIntMacro(d, RTLD_LAZY)) return -1;
; 11906: #endif
; 11907: #ifdef RTLD_NOW
; 11908:     if (PyModule_AddIntMacro(d, RTLD_NOW)) return -1;
; 11909: #endif
; 11910: #ifdef RTLD_GLOBAL
; 11911:     if (PyModule_AddIntMacro(d, RTLD_GLOBAL)) return -1;
; 11912: #endif
; 11913: #ifdef RTLD_LOCAL
; 11914:     if (PyModule_AddIntMacro(d, RTLD_LOCAL)) return -1;
; 11915: #endif
; 11916: #ifdef RTLD_NODELETE
; 11917:     if (PyModule_AddIntMacro(d, RTLD_NODELETE)) return -1;
; 11918: #endif
; 11919: #ifdef RTLD_NOLOAD
; 11920:     if (PyModule_AddIntMacro(d, RTLD_NOLOAD)) return -1;
; 11921: #endif
; 11922: #ifdef RTLD_DEEPBIND
; 11923:     if (PyModule_AddIntMacro(d, RTLD_DEEPBIND)) return -1;
; 11924: #endif
; 11925: 
; 11926: #if defined(PYOS_OS2)
; 11927:     if (insertvalues(d)) return -1;
; 11928: #endif
; 11929:     return 0;
; 11930: }

  0028a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028e	5b		 pop	 rbx
  0028f	c3		 ret	 0
all_ins	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LAEJAKJB@_have_functions?$AA@		; `string'
PUBLIC	??_C@_0O@DAAGAOJH@terminal_size?$AA@		; `string'
PUBLIC	??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@		; `string'
PUBLIC	??_C@_0BA@GNILAMAH@nt?4times_result?$AA@	; `string'
PUBLIC	??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@	; `string'
PUBLIC	??_C@_0P@PELKKPPB@nt?4stat_result?$AA@		; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_07OJMFOADC@environ?$AA@			; `string'
PUBLIC	PyInit_nt
EXTRN	PyStructSequence_InitType:PROC
EXTRN	PyStructSequence_UnnamedField:QWORD
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2:PROC
_BSS	SEGMENT
UnameResultType DB 01e0H DUP (?)
StatVFSResultType DB 01e0H DUP (?)
initialized DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit_nt DD imagerel $LN44
	DD	imagerel $LN44+48
	DD	imagerel $unwind$PyInit_nt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit_nt DD imagerel $LN44+48
	DD	imagerel $LN44+853
	DD	imagerel $chain$0$PyInit_nt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyInit_nt DD imagerel $LN44+853
	DD	imagerel $LN44+966
	DD	imagerel $chain$1$PyInit_nt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyInit_nt DD imagerel $LN44+966
	DD	imagerel $LN44+1117
	DD	imagerel $chain$4$PyInit_nt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyInit_nt DD imagerel $LN44+1117
	DD	imagerel $LN44+1121
	DD	imagerel $chain$6$PyInit_nt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$PyInit_nt DD imagerel $LN44+1121
	DD	imagerel $LN44+1134
	DD	imagerel $chain$7$PyInit_nt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$PyInit_nt DD 020021H
	DD	0b7400H
	DD	imagerel $LN44
	DD	imagerel $LN44+48
	DD	imagerel $unwind$PyInit_nt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyInit_nt DD 060021H
	DD	0b7400H
	DD	0a5400H
	DD	093400H
	DD	imagerel $LN44
	DD	imagerel $LN44+48
	DD	imagerel $unwind$PyInit_nt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyInit_nt DD 060d21H
	DD	09340dH
	DD	0b7400H
	DD	0a5400H
	DD	imagerel $LN44
	DD	imagerel $LN44+48
	DD	imagerel $unwind$PyInit_nt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyInit_nt DD 020521H
	DD	0a5405H
	DD	imagerel $LN44+48
	DD	imagerel $LN44+853
	DD	imagerel $chain$0$PyInit_nt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit_nt DD 020521H
	DD	0b7405H
	DD	imagerel $LN44
	DD	imagerel $LN44+48
	DD	imagerel $unwind$PyInit_nt
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_nt DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_0BA@LAEJAKJB@_have_functions?$AA@
CONST	SEGMENT
??_C@_0BA@LAEJAKJB@_have_functions?$AA@ DB '_have_functions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAAGAOJH@terminal_size?$AA@
CONST	SEGMENT
??_C@_0O@DAAGAOJH@terminal_size?$AA@ DB 'terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@
CONST	SEGMENT
??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@ DB 'nt.uname_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNILAMAH@nt?4times_result?$AA@
CONST	SEGMENT
??_C@_0BA@GNILAMAH@nt?4times_result?$AA@ DB 'nt.times_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@
CONST	SEGMENT
??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@ DB 'nt.statvfs_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PELKKPPB@nt?4stat_result?$AA@
CONST	SEGMENT
??_C@_0P@PELKKPPB@nt?4stat_result?$AA@ DB 'nt.stat_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJMFOADC@environ?$AA@
CONST	SEGMENT
??_C@_07OJMFOADC@environ?$AA@ DB 'environ', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\posixmodule.c
CONST	ENDS
;	COMDAT PyInit_nt
_TEXT	SEGMENT
ignored$124364 = 64
PyInit_nt PROC						; COMDAT

; 12091: {

$LN44:
  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 12092:     PyObject *m, *v;
; 12093:     PyObject *list;
; 12094:     char **trace;
; 12095: 
; 12096: #if defined(HAVE_SYMLINK) && defined(MS_WINDOWS)
; 12097:     win32_can_symlink = enable_symlink();

  00006	e8 00 00 00 00	 call	 enable_symlink

; 12098: #endif
; 12099: 
; 12100:     m = PyModule_Create(&posixmodule);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:posixmodule
  00012	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00017	89 05 00 00 00
	00		 mov	 DWORD PTR win32_can_symlink, eax
  0001d	e8 00 00 00 00	 call	 PyModule_Create2
  00022	48 8b f0	 mov	 rsi, rax

; 12101:     if (m == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 06		 jne	 SHORT $LN18@PyInit_nt

; 12258: 
; 12259: }

  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5e		 pop	 rsi
  0002f	c3		 ret	 0
$LN18@PyInit_nt:
  00030	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi

; 12102:         return NULL;
; 12103: 
; 12104:     /* Initialize environ dictionary */
; 12105:     v = convertenviron();

  00035	e8 00 00 00 00	 call	 convertenviron
  0003a	48 8b f8	 mov	 rdi, rax

; 12106:     Py_XINCREF(v);

  0003d	48 85 c0	 test	 rax, rax
  00040	0f 84 1b 04 00
	00		 je	 $LN12@PyInit_nt
  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 32		 jne	 SHORT $LN16@PyInit_nt
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005d	4c 8b cf	 mov	 r9, rdi
  00060	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00066	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00073	85 c0		 test	 eax, eax
  00075	75 06		 jne	 SHORT $LN21@PyInit_nt
  00077	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0007b	74 04		 je	 SHORT $LN16@PyInit_nt
$LN21@PyInit_nt:
  0007d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN16@PyInit_nt:

; 12107:     if (v == NULL || PyModule_AddObject(m, "environ", v) != 0)

  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OJMFOADC@environ?$AA@
  00088	4c 8b c7	 mov	 r8, rdi
  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	e8 00 00 00 00	 call	 PyModule_AddObject
  00093	85 c0		 test	 eax, eax
  00095	0f 85 c6 03 00
	00		 jne	 $LN12@PyInit_nt

; 12109:     Py_DECREF(v);

  0009b	48 8b cf	 mov	 rcx, rdi
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 12110: 
; 12111:     if (all_ins(m))

  000a3	48 8b ce	 mov	 rcx, rsi
  000a6	e8 00 00 00 00	 call	 all_ins
  000ab	85 c0		 test	 eax, eax

; 12112:         return NULL;

  000ad	0f 85 ae 03 00
	00		 jne	 $LN12@PyInit_nt

; 12113: 
; 12114:     if (setup_confname_tables(m))

  000b3	e8 00 00 00 00	 call	 setup_confname_tables
  000b8	85 c0		 test	 eax, eax

; 12115:         return NULL;

  000ba	0f 85 a1 03 00
	00		 jne	 $LN12@PyInit_nt

; 12116: 
; 12117:     Py_INCREF(PyExc_OSError);

  000c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 12118:     PyModule_AddObject(m, "error", PyExc_OSError);

  000cc	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_OSError
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000da	48 8b ce	 mov	 rcx, rsi
  000dd	e8 00 00 00 00	 call	 PyModule_AddObject

; 12119: 
; 12120: #ifdef HAVE_PUTENV
; 12121:     if (posix_putenv_garbage == NULL)

  000e2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR posix_putenv_garbage, 0
  000ea	75 0c		 jne	 SHORT $LN9@PyInit_nt

; 12122:         posix_putenv_garbage = PyDict_New();

  000ec	e8 00 00 00 00	 call	 PyDict_New
  000f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR posix_putenv_garbage, rax
$LN9@PyInit_nt:

; 12123: #endif
; 12124: 
; 12125:     if (!initialized) {

  000f8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  000ff	0f 85 ad 00 00
	00		 jne	 $LN8@PyInit_nt

; 12126: #if defined(HAVE_WAITID) && !defined(__APPLE__)
; 12127:         waitid_result_desc.name = MODNAME ".waitid_result";
; 12128:         PyStructSequence_InitType(&WaitidResultType, &waitid_result_desc);
; 12129: #endif
; 12130: 
; 12131:         stat_result_desc.name = MODNAME ".stat_result";
; 12132:         stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;

  00105	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR stat_result_desc+16
  0010c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@PELKKPPB@nt?4stat_result?$AA@

; 12133:         stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;
; 12134:         stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;
; 12135:         PyStructSequence_InitType(&StatResultType, &stat_result_desc);

  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stat_result_desc
  0011a	48 89 05 00 00
	00 00		 mov	 QWORD PTR stat_result_desc, rax
  00121	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyStructSequence_UnnamedField
  00128	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
  0012c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR stat_result_desc+16
  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyStructSequence_UnnamedField
  0013a	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  00141	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR stat_result_desc+16
  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyStructSequence_UnnamedField
  0014f	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatResultType
  0015d	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12136:         structseq_new = StatResultType.tp_new;

  00162	48 8b 15 90 01
	00 00		 mov	 rdx, QWORD PTR StatResultType+400

; 12137:         StatResultType.tp_new = statresult_new;

  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:statresult_new
  00170	48 89 05 90 01
	00 00		 mov	 QWORD PTR StatResultType+400, rax
  00177	48 89 15 00 00
	00 00		 mov	 QWORD PTR structseq_new, rdx

; 12138: 
; 12139:         statvfs_result_desc.name = MODNAME ".statvfs_result";

  0017e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@

; 12140:         PyStructSequence_InitType(&StatVFSResultType, &statvfs_result_desc);

  00185	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:statvfs_result_desc
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatVFSResultType
  00193	48 89 05 00 00
	00 00		 mov	 QWORD PTR statvfs_result_desc, rax
  0019a	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12141: #ifdef NEED_TICKS_PER_SECOND
; 12142: #  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
; 12143:         ticks_per_second = sysconf(_SC_CLK_TCK);
; 12144: #  elif defined(HZ)
; 12145:         ticks_per_second = HZ;
; 12146: #  else
; 12147:         ticks_per_second = 60; /* magic fallback value; may be bogus */
; 12148: #  endif
; 12149: #endif
; 12150: 
; 12151: #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER)
; 12152:         sched_param_desc.name = MODNAME ".sched_param";
; 12153:         PyStructSequence_InitType(&SchedParamType, &sched_param_desc);
; 12154:         SchedParamType.tp_new = sched_param_new;
; 12155: #endif
; 12156: 
; 12157:         /* initialize TerminalSize_info */
; 12158:         PyStructSequence_InitType(&TerminalSizeType, &TerminalSize_desc);

  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TerminalSize_desc
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TerminalSizeType
  001ad	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN8@PyInit_nt:

; 12159:     }
; 12160: #if defined(HAVE_WAITID) && !defined(__APPLE__)
; 12161:     Py_INCREF((PyObject*) &WaitidResultType);
; 12162:     PyModule_AddObject(m, "waitid_result", (PyObject*) &WaitidResultType);
; 12163: #endif
; 12164:     Py_INCREF((PyObject*) &StatResultType);

  001b2	e8 00 00 00 00	 call	 _Py_PXCTX
  001b7	85 c0		 test	 eax, eax
  001b9	75 3c		 jne	 SHORT $LN26@PyInit_nt
  001bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:StatResultType
  001c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001d0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001d6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001de	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e3	85 c0		 test	 eax, eax
  001e5	75 09		 jne	 SHORT $LN25@PyInit_nt
  001e7	f6 05 20 00 00
	00 20		 test	 BYTE PTR StatResultType+32, 32 ; 00000020H
  001ee	74 07		 je	 SHORT $LN26@PyInit_nt
$LN25@PyInit_nt:
  001f0	48 ff 05 50 00
	00 00		 inc	 QWORD PTR StatResultType+80
$LN26@PyInit_nt:

; 12165:     PyModule_AddObject(m, "stat_result", (PyObject*) &StatResultType);

  001f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:StatResultType
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@ENKKEMPE@stat_result?$AA@
  00205	48 8b ce	 mov	 rcx, rsi
  00208	e8 00 00 00 00	 call	 PyModule_AddObject

; 12166:     Py_INCREF((PyObject*) &StatVFSResultType);

  0020d	e8 00 00 00 00	 call	 _Py_PXCTX
  00212	85 c0		 test	 eax, eax
  00214	75 3c		 jne	 SHORT $LN30@PyInit_nt
  00216	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:StatVFSResultType
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0022b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00231	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00239	e8 00 00 00 00	 call	 _PyParallel_Guard
  0023e	85 c0		 test	 eax, eax
  00240	75 09		 jne	 SHORT $LN29@PyInit_nt
  00242	f6 05 20 00 00
	00 20		 test	 BYTE PTR StatVFSResultType+32, 32 ; 00000020H
  00249	74 07		 je	 SHORT $LN30@PyInit_nt
$LN29@PyInit_nt:
  0024b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR StatVFSResultType+80
$LN30@PyInit_nt:

; 12167:     PyModule_AddObject(m, "statvfs_result",
; 12168:                        (PyObject*) &StatVFSResultType);

  00252	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:StatVFSResultType
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HMGCCANC@statvfs_result?$AA@
  00260	48 8b ce	 mov	 rcx, rsi
  00263	e8 00 00 00 00	 call	 PyModule_AddObject

; 12169: 
; 12170: #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER)
; 12171:     Py_INCREF(&SchedParamType);
; 12172:     PyModule_AddObject(m, "sched_param", (PyObject *)&SchedParamType);
; 12173: #endif
; 12174: 
; 12175:     times_result_desc.name = MODNAME ".times_result";

  00268	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GNILAMAH@nt?4times_result?$AA@

; 12176:     PyStructSequence_InitType(&TimesResultType, &times_result_desc);

  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TimesResultType
  00276	48 89 15 00 00
	00 00		 mov	 QWORD PTR times_result_desc, rdx
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:times_result_desc
  00284	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12177:     PyModule_AddObject(m, "times_result", (PyObject *)&TimesResultType);

  00289	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TimesResultType
  00290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BNFIOIGL@times_result?$AA@
  00297	48 8b ce	 mov	 rcx, rsi
  0029a	e8 00 00 00 00	 call	 PyModule_AddObject

; 12178: 
; 12179:     uname_result_desc.name = MODNAME ".uname_result";

  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@

; 12180:     PyStructSequence_InitType(&UnameResultType, &uname_result_desc);

  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnameResultType
  002ad	48 89 15 00 00
	00 00		 mov	 QWORD PTR uname_result_desc, rdx
  002b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:uname_result_desc
  002bb	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12181:     PyModule_AddObject(m, "uname_result", (PyObject *)&UnameResultType);

  002c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:UnameResultType
  002c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HCEBDBKJ@uname_result?$AA@
  002ce	48 8b ce	 mov	 rcx, rsi
  002d1	e8 00 00 00 00	 call	 PyModule_AddObject

; 12182: 
; 12183: #ifdef __APPLE__
; 12184:     /*
; 12185:      * Step 2 of weak-linking support on Mac OS X.
; 12186:      *
; 12187:      * The code below removes functions that are not available on the
; 12188:      * currently active platform.
; 12189:      *
; 12190:      * This block allow one to use a python binary that was build on
; 12191:      * OSX 10.4 on OSX 10.3, without losing access to new APIs on
; 12192:      * OSX 10.4.
; 12193:      */
; 12194: #ifdef HAVE_FSTATVFS
; 12195:     if (fstatvfs == NULL) {
; 12196:         if (PyObject_DelAttrString(m, "fstatvfs") == -1) {
; 12197:             return NULL;
; 12198:         }
; 12199:     }
; 12200: #endif /* HAVE_FSTATVFS */
; 12201: 
; 12202: #ifdef HAVE_STATVFS
; 12203:     if (statvfs == NULL) {
; 12204:         if (PyObject_DelAttrString(m, "statvfs") == -1) {
; 12205:             return NULL;
; 12206:         }
; 12207:     }
; 12208: #endif /* HAVE_STATVFS */
; 12209: 
; 12210: # ifdef HAVE_LCHOWN
; 12211:     if (lchown == NULL) {
; 12212:         if (PyObject_DelAttrString(m, "lchown") == -1) {
; 12213:             return NULL;
; 12214:         }
; 12215:     }
; 12216: #endif /* HAVE_LCHOWN */
; 12217: 
; 12218: 
; 12219: #endif /* __APPLE__ */
; 12220: 
; 12221:     Py_INCREF(&TerminalSizeType);

  002d6	e8 00 00 00 00	 call	 _Py_PXCTX
  002db	85 c0		 test	 eax, eax
  002dd	75 3c		 jne	 SHORT $LN34@PyInit_nt
  002df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:TerminalSizeType
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002f4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002fa	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00302	e8 00 00 00 00	 call	 _PyParallel_Guard
  00307	85 c0		 test	 eax, eax
  00309	75 09		 jne	 SHORT $LN33@PyInit_nt
  0030b	f6 05 20 00 00
	00 20		 test	 BYTE PTR TerminalSizeType+32, 32 ; 00000020H
  00312	74 07		 je	 SHORT $LN34@PyInit_nt
$LN33@PyInit_nt:
  00314	48 ff 05 50 00
	00 00		 inc	 QWORD PTR TerminalSizeType+80
$LN34@PyInit_nt:

; 12222:     PyModule_AddObject(m, "terminal_size", (PyObject*) &TerminalSizeType);

  0031b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TerminalSizeType
  00322	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DAAGAOJH@terminal_size?$AA@
  00329	48 8b ce	 mov	 rcx, rsi
  0032c	e8 00 00 00 00	 call	 PyModule_AddObject

; 12223: 
; 12224:     billion = PyLong_FromLong(1000000000);

  00331	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00336	e8 00 00 00 00	 call	 PyLong_FromLong
  0033b	48 89 05 00 00
	00 00		 mov	 QWORD PTR billion, rax

; 12225:     if (!billion)

  00342	48 85 c0	 test	 rax, rax

; 12226:         return NULL;

  00345	0f 84 16 01 00
	00		 je	 $LN12@PyInit_nt

; 12227: 
; 12228:     /* suppress "function not used" warnings */
; 12229:     {
; 12230:     int ignored;
; 12231:     fd_specified("", -1);

  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00352	83 ca ff	 or	 edx, -1
  00355	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0035a	e8 00 00 00 00	 call	 fd_specified

; 12232:     follow_symlinks_specified("", 1);

  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00366	ba 01 00 00 00	 mov	 edx, 1
  0036b	e8 00 00 00 00	 call	 follow_symlinks_specified

; 12233:     dir_fd_and_follow_symlinks_invalid("chmod", DEFAULT_DIR_FD, 1);

  00370	ba 9c ff ff ff	 mov	 edx, -100		; ffffffffffffff9cH
  00375	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OCEJBCEE@chmod?$AA@
  0037c	44 8d 42 65	 lea	 r8d, QWORD PTR [rdx+101]
  00380	e8 00 00 00 00	 call	 dir_fd_and_follow_symlinks_invalid

; 12234:     dir_fd_converter(Py_None, &ignored);

  00385	48 8d 54 24 40	 lea	 rdx, QWORD PTR ignored$124364[rsp]
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00391	e8 00 00 00 00	 call	 dir_fd_converter

; 12235:     dir_fd_unavailable(Py_None, &ignored);

  00396	48 8d 54 24 40	 lea	 rdx, QWORD PTR ignored$124364[rsp]
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  003a2	e8 00 00 00 00	 call	 dir_fd_unavailable

; 12236:     }
; 12237: 
; 12238:     /*
; 12239:      * provide list of locally available functions
; 12240:      * so os.py can populate support_* lists
; 12241:      */
; 12242:     list = PyList_New(0);

  003a7	33 c9		 xor	 ecx, ecx
  003a9	e8 00 00 00 00	 call	 PyList_New
  003ae	48 8b e8	 mov	 rbp, rax

; 12243:     if (!list)

  003b1	48 85 c0	 test	 rax, rax
  003b4	75 10		 jne	 SHORT $LN6@PyInit_nt
  003b6	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  003bb	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 12258: 
; 12259: }

  003c0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003c4	5e		 pop	 rsi
  003c5	c3		 ret	 0
$LN6@PyInit_nt:

; 12244:         return NULL;
; 12245:     for (trace = have_functions; *trace; trace++) {

  003c6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR have_functions, 0
  003ce	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  003d3	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:have_functions
  003da	74 4d		 je	 SHORT $LN3@PyInit_nt
  003dc	0f 1f 40 00	 npad	 4
$LL5@PyInit_nt:

; 12246:         PyObject *unicode = PyUnicode_DecodeASCII(*trace, strlen(*trace), NULL);

  003e0	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
  003e3	48 83 c9 ff	 or	 rcx, -1
  003e7	33 c0		 xor	 eax, eax
  003e9	49 8b f9	 mov	 rdi, r9
  003ec	45 33 c0	 xor	 r8d, r8d
  003ef	f2 ae		 repne scasb
  003f1	48 f7 d1	 not	 rcx
  003f4	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  003f8	49 8b c9	 mov	 rcx, r9
  003fb	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00400	48 8b f8	 mov	 rdi, rax

; 12247:         if (!unicode)

  00403	48 85 c0	 test	 rax, rax
  00406	74 55		 je	 SHORT $LN38@PyInit_nt

; 12249:         if (PyList_Append(list, unicode))

  00408	48 8b d0	 mov	 rdx, rax
  0040b	48 8b cd	 mov	 rcx, rbp
  0040e	e8 00 00 00 00	 call	 PyList_Append
  00413	85 c0		 test	 eax, eax
  00415	75 46		 jne	 SHORT $LN38@PyInit_nt

; 12250:             return NULL;
; 12251:         Py_DECREF(unicode);

  00417	48 8b cf	 mov	 rcx, rdi
  0041a	e8 00 00 00 00	 call	 _Py_DecRef
  0041f	48 83 c3 08	 add	 rbx, 8
  00423	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00427	75 b7		 jne	 SHORT $LL5@PyInit_nt
$LN3@PyInit_nt:

; 12252:     }
; 12253:     PyModule_AddObject(m, "_have_functions", list);

  00429	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LAEJAKJB@_have_functions?$AA@
  00430	4c 8b c5	 mov	 r8, rbp
  00433	48 8b ce	 mov	 rcx, rsi
  00436	e8 00 00 00 00	 call	 PyModule_AddObject

; 12254: 
; 12255:     initialized = 1;

  0043b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR initialized, 1

; 12256: 
; 12257:     return m;

  00445	48 8b c6	 mov	 rax, rsi
$LN43@PyInit_nt:
  00448	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0044d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00452	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 12258: 
; 12259: }

  00457	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0045b	5e		 pop	 rsi
  0045c	c3		 ret	 0
$LN38@PyInit_nt:

; 12248:             return NULL;

  0045d	33 c0		 xor	 eax, eax
  0045f	eb e7		 jmp	 SHORT $LN43@PyInit_nt
$LN12@PyInit_nt:

; 12108:         return NULL;

  00461	33 c0		 xor	 eax, eax
  00463	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]

; 12258: 
; 12259: }

  00468	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0046c	5e		 pop	 rsi
  0046d	c3		 ret	 0
PyInit_nt ENDP
_TEXT	ENDS
PUBLIC	??_C@_04PNGHFIJN@?4com?$AA@			; `string'
PUBLIC	??_C@_04JLMDILM@?4exe?$AA@			; `string'
PUBLIC	??_C@_04CPCBDHLK@?4cmd?$AA@			; `string'
PUBLIC	??_C@_04NEEFLLOK@?4bat?$AA@			; `string'
EXTRN	__imp_stricmp:PROC
EXTRN	__imp_strrchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_impl DD imagerel win32_xstat_impl
	DD	imagerel win32_xstat_impl+536
	DD	imagerel $unwind$win32_xstat_impl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_impl DD 081501H
	DD	0155415H
	DD	0143415H
	DD	0c00ef215H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_04PNGHFIJN@?4com?$AA@
CONST	SEGMENT
??_C@_04PNGHFIJN@?4com?$AA@ DB '.com', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe?$AA@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe?$AA@ DB '.exe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPCBDHLK@?4cmd?$AA@
CONST	SEGMENT
??_C@_04CPCBDHLK@?4cmd?$AA@ DB '.cmd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEEFLLOK@?4bat?$AA@
CONST	SEGMENT
??_C@_04NEEFLLOK@?4bat?$AA@ DB '.bat', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_xstat_impl
_TEXT	SEGMENT
info$ = 64
path$ = 160
result$ = 168
traverse$ = 176
target_path$ = 184
reparse_tag$ = 184
win32_xstat_impl PROC					; COMDAT

; 1721 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1722 :     int code;
; 1723 :     HANDLE hFile, hFile2;
; 1724 :     BY_HANDLE_FILE_INFORMATION info;
; 1725 :     ULONG reparse_tag = 0;

  00015	33 f6		 xor	 esi, esi
  00017	41 8b e8	 mov	 ebp, r8d
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	89 b4 24 b8 00
	00 00		 mov	 DWORD PTR reparse_tag$[rsp], esi
  00024	4c 8b e1	 mov	 r12, rcx

; 1726 :     wchar_t *target_path;
; 1727 :     const char *dot;
; 1728 : 
; 1729 :     if(!check_GetFinalPathNameByHandle()) {

  00027	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  0002c	85 c0		 test	 eax, eax

; 1730 :         /* If the OS doesn't have GetFinalPathNameByHandle, don't
; 1731 :            traverse reparse point. */
; 1732 :         traverse = FALSE;
; 1733 :     }
; 1734 : 
; 1735 :     hFile = CreateFileA(
; 1736 :         path,
; 1737 :         FILE_READ_ATTRIBUTES, /* desired access */
; 1738 :         0, /* share mode */
; 1739 :         NULL, /* security attributes */
; 1740 :         OPEN_EXISTING,
; 1741 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 1742 :         /* FILE_FLAG_OPEN_REPARSE_POINT does not follow the symlink.
; 1743 :            Because of this, calls like GetFinalPathNameByHandle will return
; 1744 :            the symlink path again and not the actual final path. */
; 1745 :         FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS|
; 1746 :             FILE_FLAG_OPEN_REPARSE_POINT,
; 1747 :         NULL);

  0002e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00033	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00038	0f 44 ee	 cmove	 ebp, esi
  0003b	45 33 c9	 xor	 r9d, r9d
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	49 8b cc	 mov	 rcx, r12
  00044	c7 44 24 28 80
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651712 ; 02200080H
  0004c	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0005a	48 8b d8	 mov	 rbx, rax

; 1748 : 
; 1749 :     if (hFile == INVALID_HANDLE_VALUE) {

  0005d	48 83 f8 ff	 cmp	 rax, -1
  00061	75 4b		 jne	 SHORT $LN17@win32_xsta@2

; 1750 :         /* Either the target doesn't exist, or we don't have access to
; 1751 :            get a handle to it. If the former, we need to return an error.
; 1752 :            If the latter, we can use attributes_from_dir. */
; 1753 :         if (GetLastError() != ERROR_SHARING_VIOLATION)

  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00069	83 f8 20	 cmp	 eax, 32			; 00000020H

; 1754 :             return -1;

  0006c	75 38		 jne	 SHORT $LN22@win32_xsta@2

; 1755 :         /* Could not get attributes on open file. Fall back to
; 1756 :            reading the directory. */
; 1757 :         if (!attributes_from_dir(path, &info, &reparse_tag))

  0006e	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR reparse_tag$[rsp]
  00076	48 8d 54 24 40	 lea	 rdx, QWORD PTR info$[rsp]
  0007b	49 8b cc	 mov	 rcx, r12
  0007e	e8 00 00 00 00	 call	 attributes_from_dir
  00083	85 c0		 test	 eax, eax

; 1758 :             /* Very strange. This should not fail now */
; 1759 :             return -1;

  00085	74 1f		 je	 SHORT $LN22@win32_xsta@2

; 1760 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  00087	f7 44 24 40 00
	04 00 00	 test	 DWORD PTR info$[rsp], 1024 ; 00000400H
  0008f	0f 84 e0 00 00
	00		 je	 $LN21@win32_xsta@2

; 1761 :             if (traverse) {

  00095	85 ed		 test	 ebp, ebp
  00097	0f 84 d8 00 00
	00		 je	 $LN21@win32_xsta@2

; 1762 :                 /* Should traverse, but could not open reparse point handle */
; 1763 :                 SetLastError(ERROR_SHARING_VIOLATION);

  0009d	8d 4e 20	 lea	 ecx, QWORD PTR [rsi+32]
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError
$LN22@win32_xsta@2:

; 1764 :                 return -1;

  000a6	83 c8 ff	 or	 eax, -1
  000a9	e9 52 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN17@win32_xsta@2:

; 1765 :             }
; 1766 :         }
; 1767 :     } else {
; 1768 :         if (!GetFileInformationByHandle(hFile, &info)) {

  000ae	48 8d 54 24 40	 lea	 rdx, QWORD PTR info$[rsp]
  000b3	48 8b c8	 mov	 rcx, rax
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle

; 1769 :             CloseHandle(hFile);

  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	85 c0		 test	 eax, eax
  000c1	75 0e		 jne	 SHORT $LN11@win32_xsta@2
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1770 :             return -1;

  000c9	83 c8 ff	 or	 eax, -1
  000cc	e9 2f 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN11@win32_xsta@2:

; 1771 :         }
; 1772 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  000d1	f7 44 24 40 00
	04 00 00	 test	 DWORD PTR info$[rsp], 1024 ; 00000400H
  000d9	0f 84 9f 00 00
	00		 je	 $LN10@win32_xsta@2

; 1773 :             if (!win32_get_reparse_tag(hFile, &reparse_tag))

  000df	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR reparse_tag$[rsp]
  000e7	e8 00 00 00 00	 call	 win32_get_reparse_tag
  000ec	85 c0		 test	 eax, eax

; 1774 :                 return -1;

  000ee	74 b6		 je	 SHORT $LN22@win32_xsta@2

; 1775 : 
; 1776 :             /* Close the outer open file handle now that we're about to
; 1777 :                reopen it with different flags. */
; 1778 :             if (!CloseHandle(hFile))

  000f0	48 8b cb	 mov	 rcx, rbx
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  000f9	85 c0		 test	 eax, eax

; 1779 :                 return -1;

  000fb	74 a9		 je	 SHORT $LN22@win32_xsta@2

; 1780 : 
; 1781 :             if (traverse) {

  000fd	85 ed		 test	 ebp, ebp
  000ff	74 74		 je	 SHORT $LN21@win32_xsta@2

; 1782 :                 /* In order to call GetFinalPathNameByHandle we need to open
; 1783 :                    the file without the reparse handling flag set. */
; 1784 :                 hFile2 = CreateFileA(
; 1785 :                            path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ,
; 1786 :                            NULL, OPEN_EXISTING,
; 1787 :                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
; 1788 :                            NULL);

  00101	45 33 c9	 xor	 r9d, r9d
  00104	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00109	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0010e	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00112	49 8b cc	 mov	 rcx, r12
  00115	c7 44 24 28 80
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554560 ; 02000080H
  0011d	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA

; 1789 :                 if (hFile2 == INVALID_HANDLE_VALUE)

  0012b	48 83 f8 ff	 cmp	 rax, -1

; 1790 :                     return -1;

  0012f	0f 84 71 ff ff
	ff		 je	 $LN22@win32_xsta@2

; 1791 : 
; 1792 :                 if (!get_target_path(hFile2, &target_path))

  00135	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR target_path$[rsp]
  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 get_target_path
  00145	85 c0		 test	 eax, eax

; 1793 :                     return -1;

  00147	0f 84 59 ff ff
	ff		 je	 $LN22@win32_xsta@2

; 1794 : 
; 1795 :                 code = win32_xstat_impl_w(target_path, result, FALSE);

  0014d	48 8b d7	 mov	 rdx, rdi
  00150	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR target_path$[rsp]
  00158	45 33 c0	 xor	 r8d, r8d
  0015b	48 8b cf	 mov	 rcx, rdi
  0015e	e8 00 00 00 00	 call	 win32_xstat_impl_w

; 1796 :                 free(target_path);

  00163	48 8b cf	 mov	 rcx, rdi
  00166	8b d8		 mov	 ebx, eax
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1797 :                 return code;

  0016e	8b c3		 mov	 eax, ebx
  00170	e9 8b 00 00 00	 jmp	 $LN19@win32_xsta@2
$LN21@win32_xsta@2:

; 1798 :             }
; 1799 :         } else
; 1800 :             CloseHandle(hFile);

  00175	8b b4 24 b8 00
	00 00		 mov	 esi, DWORD PTR reparse_tag$[rsp]
  0017c	eb 06		 jmp	 SHORT $LN4@win32_xsta@2
$LN10@win32_xsta@2:
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN4@win32_xsta@2:

; 1801 :     }
; 1802 :     attribute_data_to_stat(&info, reparse_tag, result);

  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR info$[rsp]
  00189	4c 8b c7	 mov	 r8, rdi
  0018c	8b d6		 mov	 edx, esi
  0018e	e8 00 00 00 00	 call	 attribute_data_to_stat

; 1803 : 
; 1804 :     /* Set S_IEXEC if it is an .exe, .bat, ... */
; 1805 :     dot = strrchr(path, '.');

  00193	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00198	49 8b cc	 mov	 rcx, r12
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  001a1	48 8b d8	 mov	 rbx, rax

; 1806 :     if (dot) {

  001a4	48 85 c0	 test	 rax, rax
  001a7	74 55		 je	 SHORT $LN2@win32_xsta@2

; 1807 :         if (stricmp(dot, ".bat") == 0 || stricmp(dot, ".cmd") == 0 ||
; 1808 :             stricmp(dot, ".exe") == 0 || stricmp(dot, ".com") == 0)

  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04NEEFLLOK@?4bat?$AA@
  001b0	48 8b c8	 mov	 rcx, rax
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  001b9	85 c0		 test	 eax, eax
  001bb	74 3c		 je	 SHORT $LN1@win32_xsta@2
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CPCBDHLK@?4cmd?$AA@
  001c4	48 8b cb	 mov	 rcx, rbx
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  001cd	85 c0		 test	 eax, eax
  001cf	74 28		 je	 SHORT $LN1@win32_xsta@2
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JLMDILM@?4exe?$AA@
  001d8	48 8b cb	 mov	 rcx, rbx
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  001e1	85 c0		 test	 eax, eax
  001e3	74 14		 je	 SHORT $LN1@win32_xsta@2
  001e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PNGHFIJN@?4com?$AA@
  001ec	48 8b cb	 mov	 rcx, rbx
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  001f5	85 c0		 test	 eax, eax
  001f7	75 05		 jne	 SHORT $LN2@win32_xsta@2
$LN1@win32_xsta@2:

; 1809 :             result->st_mode |= 0111;

  001f9	66 83 4f 10 49	 or	 WORD PTR [rdi+16], 73	; 00000049H
$LN2@win32_xsta@2:

; 1810 :     }
; 1811 :     return 0;

  001fe	33 c0		 xor	 eax, eax
$LN19@win32_xsta@2:

; 1812 : }

  00200	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00208	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0020c	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  00210	49 8b e3	 mov	 rsp, r11
  00213	41 5c		 pop	 r12
  00215	5f		 pop	 rdi
  00216	5e		 pop	 rsi
  00217	c3		 ret	 0
win32_xstat_impl ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat DD imagerel win32_xstat
	DD	imagerel win32_xstat+33
	DD	imagerel $unwind$win32_xstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT win32_xstat
_TEXT	SEGMENT
path$ = 48
result$ = 56
traverse$ = 64
win32_xstat PROC					; COMDAT

; 1912 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1913 :     /* Protocol violation: we explicitly clear errno, instead of
; 1914 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1915 :     int code = win32_xstat_impl(path, result, traverse);

  00006	e8 00 00 00 00	 call	 win32_xstat_impl
  0000b	8b d8		 mov	 ebx, eax

; 1916 :     errno = 0;

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1917 :     return code;

  00019	8b c3		 mov	 eax, ebx

; 1918 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
win32_xstat ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT win32_lstat
_TEXT	SEGMENT
path$ = 8
result$ = 16
win32_lstat PROC					; COMDAT

; 1945 :     return win32_xstat(path, result, FALSE);

  00000	45 33 c0	 xor	 r8d, r8d

; 1946 : }

  00003	e9 00 00 00 00	 jmp	 win32_xstat
win32_lstat ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT win32_stat
_TEXT	SEGMENT
path$ = 8
result$ = 16
win32_stat PROC						; COMDAT

; 1957 :     return win32_xstat(path, result, TRUE);

  00000	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1958 : }

  00006	e9 00 00 00 00	 jmp	 win32_xstat
win32_stat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_do_stat DD imagerel posix_do_stat
	DD	imagerel posix_do_stat+104
	DD	imagerel $unwind$posix_do_stat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$posix_do_stat DD imagerel posix_do_stat+104
	DD	imagerel posix_do_stat+233
	DD	imagerel $chain$0$posix_do_stat
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$posix_do_stat DD imagerel posix_do_stat+233
	DD	imagerel posix_do_stat+278
	DD	imagerel $chain$1$posix_do_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$posix_do_stat DD 021H
	DD	imagerel posix_do_stat
	DD	imagerel posix_do_stat+104
	DD	imagerel $unwind$posix_do_stat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$posix_do_stat DD 020821H
	DD	0125408H
	DD	imagerel posix_do_stat
	DD	imagerel posix_do_stat+104
	DD	imagerel $unwind$posix_do_stat
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_do_stat DD 061201H
	DD	0146412H
	DD	0133412H
	DD	0700bf212H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT posix_do_stat
_TEXT	SEGMENT
st$ = 32
path$ = 144
dir_fd$ = 152
follow_symlinks$ = 160
posix_do_stat PROC					; COMDAT

; 2385 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00012	41 8b d8	 mov	 ebx, r8d
  00015	8b f2		 mov	 esi, edx

; 2386 :     STRUCT_STAT st;
; 2387 :     int result;
; 2388 : 
; 2389 : #if !defined(MS_WINDOWS) && !defined(HAVE_FSTATAT) && !defined(HAVE_LSTAT)
; 2390 :     if (follow_symlinks_specified(function_name, follow_symlinks))
; 2391 :         return NULL;
; 2392 : #endif
; 2393 : 
; 2394 :     if (path_and_dir_fd_invalid("stat", path, dir_fd) ||
; 2395 :         dir_fd_and_fd_invalid("stat", dir_fd, path->fd) ||
; 2396 :         fd_and_follow_symlinks_invalid("stat", path->fd, follow_symlinks))

  00017	44 8b c2	 mov	 r8d, edx
  0001a	48 8b d1	 mov	 rdx, rcx
  0001d	48 8b f9	 mov	 rdi, rcx
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00027	e8 00 00 00 00	 call	 path_and_dir_fd_invalid
  0002c	85 c0		 test	 eax, eax
  0002e	0f 85 cb 00 00
	00		 jne	 $LN10@posix_do_s
  00034	44 8b 47 28	 mov	 r8d, DWORD PTR [rdi+40]
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  0003f	8b d6		 mov	 edx, esi
  00041	e8 00 00 00 00	 call	 dir_fd_and_fd_invalid
  00046	85 c0		 test	 eax, eax
  00048	0f 85 b1 00 00
	00		 jne	 $LN10@posix_do_s
  0004e	8b 57 28	 mov	 edx, DWORD PTR [rdi+40]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00058	44 8b c3	 mov	 r8d, ebx
  0005b	e8 00 00 00 00	 call	 fd_and_follow_symlinks_invalid
  00060	85 c0		 test	 eax, eax
  00062	0f 85 97 00 00
	00		 jne	 $LN10@posix_do_s

; 2398 : 
; 2399 :     Py_BEGIN_ALLOW_THREADS

  00068	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbp
  00070	e8 00 00 00 00	 call	 PyEval_SaveThread

; 2400 :     if (path->fd != -1)

  00075	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  00078	48 8b e8	 mov	 rbp, rax
  0007b	83 f9 ff	 cmp	 ecx, -1
  0007e	74 0c		 je	 SHORT $LN9@posix_do_s

; 2401 :         result = FSTAT(path->fd, &st);

  00080	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  00085	e8 00 00 00 00	 call	 win32_fstat

; 2402 :     else

  0008a	eb 47		 jmp	 SHORT $LN14@posix_do_s
$LN9@posix_do_s:

; 2403 : #ifdef MS_WINDOWS
; 2404 :     if (path->wide) {

  0008c	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00090	48 85 c9	 test	 rcx, rcx
  00093	74 17		 je	 SHORT $LN7@posix_do_s

; 2405 :         if (follow_symlinks)
; 2406 :             result = win32_stat_w(path->wide, &st);

  00095	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  0009a	85 db		 test	 ebx, ebx
  0009c	74 07		 je	 SHORT $LN6@posix_do_s
  0009e	e8 00 00 00 00	 call	 win32_stat_w

; 2407 :         else

  000a3	eb 2e		 jmp	 SHORT $LN14@posix_do_s
$LN6@posix_do_s:

; 2408 :             result = win32_lstat_w(path->wide, &st);

  000a5	e8 00 00 00 00	 call	 win32_lstat_w

; 2409 :     }
; 2410 :     else

  000aa	eb 27		 jmp	 SHORT $LN14@posix_do_s
$LN7@posix_do_s:

; 2411 : #endif
; 2412 : #if defined(HAVE_LSTAT) || defined(MS_WINDOWS)
; 2413 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))

  000ac	85 db		 test	 ebx, ebx
  000ae	75 15		 jne	 SHORT $LN3@posix_do_s
  000b0	83 fe 9c	 cmp	 esi, -100		; ffffffffffffff9cH
  000b3	75 10		 jne	 SHORT $LN3@posix_do_s

; 2414 :         result = LSTAT(path->narrow, &st);

  000b5	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000b9	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  000be	e8 00 00 00 00	 call	 win32_lstat

; 2415 :     else

  000c3	eb 0e		 jmp	 SHORT $LN14@posix_do_s
$LN3@posix_do_s:

; 2416 : #endif
; 2417 : #ifdef HAVE_FSTATAT
; 2418 :     if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks)
; 2419 :         result = fstatat(dir_fd, path->narrow, &st,
; 2420 :                          follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
; 2421 :     else
; 2422 : #endif
; 2423 :         result = STAT(path->narrow, &st);

  000c5	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000c9	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  000ce	e8 00 00 00 00	 call	 win32_stat
$LN14@posix_do_s:

; 2424 :     Py_END_ALLOW_THREADS

  000d3	48 8b cd	 mov	 rcx, rbp
  000d6	8b d8		 mov	 ebx, eax
  000d8	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000dd	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR [rsp+144]

; 2425 : 
; 2426 :     if (result != 0)

  000e5	85 db		 test	 ebx, ebx
  000e7	74 0a		 je	 SHORT $LN1@posix_do_s

; 2427 :         return path_error("stat", path);

  000e9	48 8b cf	 mov	 rcx, rdi
  000ec	e8 00 00 00 00	 call	 path_error
  000f1	eb 0e		 jmp	 SHORT $LN12@posix_do_s
$LN1@posix_do_s:

; 2428 : 
; 2429 :     return _pystat_fromstructstat(&st);

  000f3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR st$[rsp]
  000f8	e8 00 00 00 00	 call	 _pystat_fromstructstat
  000fd	eb 02		 jmp	 SHORT $LN12@posix_do_s
$LN10@posix_do_s:

; 2397 :         return NULL;

  000ff	33 c0		 xor	 eax, eax
$LN12@posix_do_s:

; 2430 : }

  00101	4c 8d 9c 24 80
	00 00 00	 lea	 r11, QWORD PTR [rsp+128]
  00109	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0010d	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00111	49 8b e3	 mov	 rsp, r11
  00114	5f		 pop	 rdi
  00115	c3		 ret	 0
posix_do_stat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_stat DD imagerel posix_stat
	DD	imagerel posix_stat+228
	DD	imagerel $unwind$posix_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_stat DD 04bf01H
	DD	01634bfH
	DD	017010aH
xdata	ENDS
;	COMDAT ??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@
CONST	SEGMENT
??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@ DB 'O&|$O&p:stat', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_stat
_TEXT	SEGMENT
dir_fd$ = 80
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
follow_symlinks$ = 216
posix_stat PROC						; COMDAT

; 2450 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2451 :     static char *keywords[] = {"path", "dir_fd", "follow_symlinks", NULL};
; 2452 :     path_t path;
; 2453 :     int dir_fd = DEFAULT_DIR_FD;
; 2454 :     int follow_symlinks = 1;
; 2455 :     PyObject *return_value;
; 2456 : 
; 2457 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 2458 :     path.allow_fd = 1;
; 2459 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&p:stat", keywords,
; 2460 :         path_converter, &path,
; 2461 : #ifdef HAVE_FSTATAT
; 2462 :         dir_fd_converter, &dir_fd,
; 2463 : #else
; 2464 :         dir_fd_unavailable, &dir_fd,
; 2465 : #endif
; 2466 :         &follow_symlinks))

  00036	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_stat@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@
  00048	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  0004c	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00050	48 8b d0	 mov	 rdx, rax
  00053	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  0005e	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0006f	41 c7 43 20 01
	00 00 00	 mov	 DWORD PTR [r11+32], 1
  00077	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00083	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR path$[rsp+20], 1
  0008b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00090	49 8b ca	 mov	 rcx, r10
  00093	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00098	85 c0		 test	 eax, eax
  0009a	75 0a		 jne	 SHORT $LN1@posix_stat

; 2467 :         return NULL;

  0009c	33 c0		 xor	 eax, eax

; 2471 : }

  0009e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  000a5	c3		 ret	 0
$LN1@posix_stat:

; 2468 :     return_value = posix_do_stat("stat", &path, dir_fd, follow_symlinks);

  000a6	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR follow_symlinks$[rsp]
  000ae	8b 54 24 50	 mov	 edx, DWORD PTR dir_fd$[rsp]
  000b2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  000b7	48 89 9c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbx
  000bf	e8 00 00 00 00	 call	 posix_do_stat

; 2469 :     path_cleanup(&path);

  000c4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  000c9	48 8b d8	 mov	 rbx, rax
  000cc	e8 00 00 00 00	 call	 path_cleanup

; 2470 :     return return_value;

  000d1	48 8b c3	 mov	 rax, rbx
  000d4	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]

; 2471 : }

  000dc	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  000e3	c3		 ret	 0
posix_stat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_lstat DD imagerel posix_lstat
	DD	imagerel posix_lstat+199
	DD	imagerel $unwind$posix_lstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_lstat DD 04a201H
	DD	01234a2H
	DD	013010aH
xdata	ENDS
;	COMDAT ??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@
CONST	SEGMENT
??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@ DB 'O&|$O&:lstat', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT posix_lstat
_TEXT	SEGMENT
path$ = 64
self$ = 160
args$ = 168
kwargs$ = 176
dir_fd$ = 184
posix_lstat PROC					; COMDAT

; 2480 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2481 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 2482 :     path_t path;
; 2483 :     int dir_fd = DEFAULT_DIR_FD;
; 2484 :     int follow_symlinks = 0;
; 2485 :     PyObject *return_value;
; 2486 : 
; 2487 :     memset(&path, 0, sizeof(path));

  0000a	33 c9		 xor	 ecx, ecx
  0000c	49 8b c0	 mov	 rax, r8
  0000f	4c 8b d2	 mov	 r10, rdx
  00012	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00016	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  0001a	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001e	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00022	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00026	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  0002a	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  0002e	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00032	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx

; 2488 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:lstat", keywords,
; 2489 :         path_converter, &path,
; 2490 : #ifdef HAVE_FSTATAT
; 2491 :         dir_fd_converter, &dir_fd
; 2492 : #else
; 2493 :         dir_fd_unavailable, &dir_fd
; 2494 : #endif
; 2495 :         ))

  00036	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_lstat@@9@9
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@
  00048	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dir_fd_unavailable
  00053	48 8b d0	 mov	 rdx, rax
  00056	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0005a	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0005e	41 c7 43 20 9c
	ff ff ff	 mov	 DWORD PTR [r11+32], -100 ; ffffffffffffff9cH
  00066	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:path_converter
  00071	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00075	49 8b ca	 mov	 rcx, r10
  00078	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0007d	85 c0		 test	 eax, eax
  0007f	75 0a		 jne	 SHORT $LN1@posix_lsta

; 2496 :         return NULL;

  00081	33 c0		 xor	 eax, eax

; 2500 : }

  00083	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0008a	c3		 ret	 0
$LN1@posix_lsta:

; 2497 :     return_value = posix_do_stat("stat", &path, dir_fd, follow_symlinks);

  0008b	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR dir_fd$[rsp]
  00092	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  00097	45 33 c0	 xor	 r8d, r8d
  0009a	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  000a2	e8 00 00 00 00	 call	 posix_do_stat

; 2498 :     path_cleanup(&path);

  000a7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  000ac	48 8b d8	 mov	 rbx, rax
  000af	e8 00 00 00 00	 call	 path_cleanup

; 2499 :     return return_value;

  000b4	48 8b c3	 mov	 rax, rbx
  000b7	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 2500 : }

  000bf	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000c6	c3		 ret	 0
posix_lstat ENDP
_TEXT	ENDS
END
