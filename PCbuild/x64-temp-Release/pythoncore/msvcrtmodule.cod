; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06EGGDDPIF@msvcrt?$AA@			; `string'
PUBLIC	??_C@_08GNIEHJDM@ungetwch?$AA@			; `string'
PUBLIC	??_C@_06MIBLCGCE@putwch?$AA@			; `string'
PUBLIC	??_C@_07DFOBMEOJ@getwche?$AA@			; `string'
PUBLIC	??_C@_06GJLEIGPP@getwch?$AA@			; `string'
PUBLIC	??_C@_0N@FNBEHOIE@SetErrorMode?$AA@		; `string'
PUBLIC	??_C@_07OCCPOMBI@ungetch?$AA@			; `string'
PUBLIC	??_C@_05HHMFJPDP@putch?$AA@			; `string'
PUBLIC	??_C@_06PDENHJL@getche?$AA@			; `string'
PUBLIC	??_C@_05JPGDKJO@getch?$AA@			; `string'
PUBLIC	??_C@_05DNDLBGFJ@kbhit?$AA@			; `string'
PUBLIC	??_C@_0O@FHDEIKIH@get_osfhandle?$AA@		; `string'
PUBLIC	??_C@_0P@KCLKOFOI@open_osfhandle?$AA@		; `string'
PUBLIC	??_C@_07KEIMDCMH@setmode?$AA@			; `string'
PUBLIC	??_C@_07CODODBAF@locking?$AA@			; `string'
PUBLIC	??_C@_07PBDFNLC@heapmin?$AA@			; `string'
;	COMDAT ??_C@_06EGGDDPIF@msvcrt?$AA@
CONST	SEGMENT
??_C@_06EGGDDPIF@msvcrt?$AA@ DB 'msvcrt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNIEHJDM@ungetwch?$AA@
CONST	SEGMENT
??_C@_08GNIEHJDM@ungetwch?$AA@ DB 'ungetwch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIBLCGCE@putwch?$AA@
CONST	SEGMENT
??_C@_06MIBLCGCE@putwch?$AA@ DB 'putwch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFOBMEOJ@getwche?$AA@
CONST	SEGMENT
??_C@_07DFOBMEOJ@getwche?$AA@ DB 'getwche', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJLEIGPP@getwch?$AA@
CONST	SEGMENT
??_C@_06GJLEIGPP@getwch?$AA@ DB 'getwch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNBEHOIE@SetErrorMode?$AA@
CONST	SEGMENT
??_C@_0N@FNBEHOIE@SetErrorMode?$AA@ DB 'SetErrorMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCCPOMBI@ungetch?$AA@
CONST	SEGMENT
??_C@_07OCCPOMBI@ungetch?$AA@ DB 'ungetch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHMFJPDP@putch?$AA@
CONST	SEGMENT
??_C@_05HHMFJPDP@putch?$AA@ DB 'putch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDENHJL@getche?$AA@
CONST	SEGMENT
??_C@_06PDENHJL@getche?$AA@ DB 'getche', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPGDKJO@getch?$AA@
CONST	SEGMENT
??_C@_05JPGDKJO@getch?$AA@ DB 'getch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNDLBGFJ@kbhit?$AA@
CONST	SEGMENT
??_C@_05DNDLBGFJ@kbhit?$AA@ DB 'kbhit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHDEIKIH@get_osfhandle?$AA@
CONST	SEGMENT
??_C@_0O@FHDEIKIH@get_osfhandle?$AA@ DB 'get_osfhandle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCLKOFOI@open_osfhandle?$AA@
CONST	SEGMENT
??_C@_0P@KCLKOFOI@open_osfhandle?$AA@ DB 'open_osfhandle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEIMDCMH@setmode?$AA@
CONST	SEGMENT
??_C@_07KEIMDCMH@setmode?$AA@ DB 'setmode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CODODBAF@locking?$AA@
CONST	SEGMENT
??_C@_07CODODBAF@locking?$AA@ DB 'locking', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBDFNLC@heapmin?$AA@
CONST	SEGMENT
??_C@_07PBDFNLC@heapmin?$AA@ DB 'heapmin', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
heapmin_doc DB	'heapmin() -> None', 0aH, 0aH, 'Force the malloc() heap t'
	DB	'o clean itself up and return unused blocks', 0aH, 'to the ope'
	DB	'rating system. On failure, this raises IOError.', 00H
	ORG $+15
locking_doc DB	'locking(fd, mode, nbytes) -> None', 0aH, 0aH, 'Lock part'
	DB	' of a file based on file descriptor fd from the C runtime.', 0aH
	DB	'Raises IOError on failure. The locked region of the file exte'
	DB	'nds from', 0aH, 'the current file position for nbytes bytes, '
	DB	'and may continue beyond', 0aH, 'the end of the file. mode mus'
	DB	't be one of the LK_* constants listed', 0aH, 'below. Multiple'
	DB	' regions in a file may be locked at the same time, but', 0aH, 'm'
	DB	'ay not overlap. Adjacent regions are not merged; they must be'
	DB	' unlocked', 0aH, 'individually.', 00H
setmode_doc DB	'setmode(fd, mode) -> Previous mode', 0aH, 0aH, 'Set the '
	DB	'line-end translation mode for the file descriptor fd. To set', 0aH
	DB	'it to text mode, flags should be os.O_TEXT; for binary, it sh'
	DB	'ould be', 0aH, 'os.O_BINARY.', 00H
	ORG $+5
open_osfhandle_doc DB 'open_osfhandle(handle, flags) -> file descriptor', 0aH
	DB	0aH, 'Create a C runtime file descriptor from the file handle '
	DB	'handle. The', 0aH, 'flags parameter should be a bitwise OR of'
	DB	' os.O_APPEND, os.O_RDONLY,', 0aH, 'and os.O_TEXT. The returne'
	DB	'd file descriptor may be used as a parameter', 0aH, 'to os.fd'
	DB	'open() to create a file object.', 00H
	ORG $+7
get_osfhandle_doc DB 'get_osfhandle(fd) -> file handle', 0aH, 0aH, 'Retur'
	DB	'n the file handle for the file descriptor fd. Raises IOError', 0aH
	DB	'if fd is not recognized.', 00H
	ORG $+3
kbhit_doc DB	'kbhit() -> bool', 0aH, 0aH, 'Return true if a keypress i'
	DB	's waiting to be read.', 00H
	ORG $+14
getch_doc DB	'getch() -> key character', 0aH, 0aH, 'Read a keypress an'
	DB	'd return the resulting character as a byte string.', 0aH, 'No'
	DB	'thing is echoed to the console. This call will block if a key'
	DB	'press is', 0aH, 'not already available, but will not wait for'
	DB	' Enter to be pressed. If the', 0aH, 'pressed key was a specia'
	DB	'l function key, this will return ''\000'' or', 0aH, '''\xe0'''
	DB	'; the next call will return the keycode. The Control-C keypre'
	DB	'ss', 0aH, 'cannot be read with this function.', 00H
	ORG $+4
getwch_doc DB	'getwch() -> Unicode key character', 0aH, 0aH, 'Wide char'
	DB	' variant of getch(), returning a Unicode value.', 00H
	ORG $+4
getche_doc DB	'getche() -> key character', 0aH, 0aH, 'Similar to getch('
	DB	'), but the keypress will be echoed if it represents', 0aH, 'a'
	DB	' printable character.', 00H
	ORG $+9
getwche_doc DB	'getwche() -> Unicode key character', 0aH, 0aH, 'Wide cha'
	DB	'r variant of getche(), returning a Unicode value.', 00H
	ORG $+2
putch_doc DB	'putch(char) -> None', 0aH, 0aH, 'Print the byte string c'
	DB	'har to the console without buffering.', 00H
	ORG $+14
putwch_doc DB	'putwch(unicode_char) -> None', 0aH, 0aH, 'Wide char vari'
	DB	'ant of putch(), accepting a Unicode value.', 00H
	ORG $+9
ungetch_doc DB	'ungetch(char) -> None', 0aH, 0aH, 'Cause the byte string'
	DB	' char to be "pushed back" into the', 0aH, 'console buffer; it'
	DB	' will be the next character read by', 0aH, 'getch() or getche'
	DB	'().', 00H
	ORG $+6
ungetwch_doc DB	'ungetwch(unicode_char) -> None', 0aH, 0aH, 'Wide char va'
	DB	'riant of ungetch(), accepting a Unicode value.', 00H
	ORG $+5
msvcrt_functions DQ FLAT:??_C@_07PBDFNLC@heapmin?$AA@
	DQ	FLAT:msvcrt_heapmin
	DD	01H
	ORG $+4
	DQ	FLAT:heapmin_doc
	DQ	FLAT:??_C@_07CODODBAF@locking?$AA@
	DQ	FLAT:msvcrt_locking
	DD	01H
	ORG $+4
	DQ	FLAT:locking_doc
	DQ	FLAT:??_C@_07KEIMDCMH@setmode?$AA@
	DQ	FLAT:msvcrt_setmode
	DD	01H
	ORG $+4
	DQ	FLAT:setmode_doc
	DQ	FLAT:??_C@_0P@KCLKOFOI@open_osfhandle?$AA@
	DQ	FLAT:msvcrt_open_osfhandle
	DD	01H
	ORG $+4
	DQ	FLAT:open_osfhandle_doc
	DQ	FLAT:??_C@_0O@FHDEIKIH@get_osfhandle?$AA@
	DQ	FLAT:msvcrt_get_osfhandle
	DD	01H
	ORG $+4
	DQ	FLAT:get_osfhandle_doc
	DQ	FLAT:??_C@_05DNDLBGFJ@kbhit?$AA@
	DQ	FLAT:msvcrt_kbhit
	DD	01H
	ORG $+4
	DQ	FLAT:kbhit_doc
	DQ	FLAT:??_C@_05JPGDKJO@getch?$AA@
	DQ	FLAT:msvcrt_getch
	DD	01H
	ORG $+4
	DQ	FLAT:getch_doc
	DQ	FLAT:??_C@_06PDENHJL@getche?$AA@
	DQ	FLAT:msvcrt_getche
	DD	01H
	ORG $+4
	DQ	FLAT:getche_doc
	DQ	FLAT:??_C@_05HHMFJPDP@putch?$AA@
	DQ	FLAT:msvcrt_putch
	DD	01H
	ORG $+4
	DQ	FLAT:putch_doc
	DQ	FLAT:??_C@_07OCCPOMBI@ungetch?$AA@
	DQ	FLAT:msvcrt_ungetch
	DD	01H
	ORG $+4
	DQ	FLAT:ungetch_doc
	DQ	FLAT:??_C@_0N@FNBEHOIE@SetErrorMode?$AA@
	DQ	FLAT:seterrormode
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06GJLEIGPP@getwch?$AA@
	DQ	FLAT:msvcrt_getwch
	DD	01H
	ORG $+4
	DQ	FLAT:getwch_doc
	DQ	FLAT:??_C@_07DFOBMEOJ@getwche?$AA@
	DQ	FLAT:msvcrt_getwche
	DD	01H
	ORG $+4
	DQ	FLAT:getwche_doc
	DQ	FLAT:??_C@_06MIBLCGCE@putwch?$AA@
	DQ	FLAT:msvcrt_putwch
	DD	01H
	ORG $+4
	DQ	FLAT:putwch_doc
	DQ	FLAT:??_C@_08GNIEHJDM@ungetwch?$AA@
	DQ	FLAT:msvcrt_ungetwch
	DD	01H
	ORG $+4
	DQ	FLAT:ungetwch_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
msvcrtmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06EGGDDPIF@msvcrt?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:msvcrt_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DHCHNMDJ@?3heapmin?$AA@			; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	__imp__heapmin:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_heapmin DD imagerel msvcrt_heapmin
	DD	imagerel msvcrt_heapmin+137
	DD	imagerel $unwind$msvcrt_heapmin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_heapmin DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_08DHCHNMDJ@?3heapmin?$AA@
CONST	SEGMENT
??_C@_08DHCHNMDJ@?3heapmin?$AA@ DB ':heapmin', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_heapmin
_TEXT	SEGMENT
self$ = 64
args$ = 72
msvcrt_heapmin PROC					; COMDAT

; 39   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 40   :     if (!PyArg_ParseTuple(args, ":heapmin"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DHCHNMDJ@?3heapmin?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN2@msvcrt_hea

; 41   :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 48   : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	c3		 ret	 0
$LN2@msvcrt_hea:

; 42   : 
; 43   :     if (_heapmin() != 0)

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__heapmin
  00024	85 c0		 test	 eax, eax
  00026	74 10		 je	 SHORT $LN1@msvcrt_hea

; 44   :         return PyErr_SetFromErrno(PyExc_IOError);

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError

; 48   : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	e9 00 00 00 00	 jmp	 PyErr_SetFromErrno
$LN1@msvcrt_hea:

; 45   : 
; 46   :     Py_INCREF(Py_None);

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	85 c0		 test	 eax, eax
  0003f	75 3c		 jne	 SHORT $LN6@msvcrt_hea
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 09		 jne	 SHORT $LN5@msvcrt_hea
  0006d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00074	74 07		 je	 SHORT $LN6@msvcrt_hea
$LN5@msvcrt_hea:
  00076	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@msvcrt_hea:

; 47   :     return Py_None;

  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 48   : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
msvcrt_heapmin ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@NOGPHIJF@iil?3locking?$AA@		; `string'
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp__locking:PROC
EXTRN	PyEval_SaveThread:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$msvcrt_locking DD imagerel msvcrt_locking
	DD	imagerel msvcrt_locking+53
	DD	imagerel $unwind$msvcrt_locking
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$msvcrt_locking DD imagerel msvcrt_locking+53
	DD	imagerel msvcrt_locking+114
	DD	imagerel $chain$1$msvcrt_locking
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$msvcrt_locking DD imagerel msvcrt_locking+114
	DD	imagerel msvcrt_locking+212
	DD	imagerel $chain$2$msvcrt_locking
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$msvcrt_locking DD 021H
	DD	imagerel msvcrt_locking
	DD	imagerel msvcrt_locking+53
	DD	imagerel $unwind$msvcrt_locking
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$msvcrt_locking DD 040a21H
	DD	08740aH
	DD	0a3405H
	DD	imagerel msvcrt_locking
	DD	imagerel msvcrt_locking+53
	DD	imagerel $unwind$msvcrt_locking
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_locking DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0M@NOGPHIJF@iil?3locking?$AA@
CONST	SEGMENT
??_C@_0M@NOGPHIJF@iil?3locking?$AA@ DB 'iil:locking', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_locking
_TEXT	SEGMENT
fd$ = 48
self$ = 80
args$ = 88
nbytes$ = 96
mode$ = 104
msvcrt_locking PROC					; COMDAT

; 59   : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 60   :     int fd;
; 61   :     int mode;
; 62   :     long nbytes;
; 63   :     int err;
; 64   : 
; 65   :     if (!PyArg_ParseTuple(args, "iil:locking", &fd, &mode, &nbytes))

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR nbytes$[rsp]
  0000c	4c 8d 4c 24 68	 lea	 r9, QWORD PTR mode$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 44 24 30	 lea	 r8, QWORD PTR fd$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NOGPHIJF@iil?3locking?$AA@
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN2@msvcrt_loc

; 66   :         return NULL;

  0002e	33 c0		 xor	 eax, eax

; 76   : }

  00030	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00034	c3		 ret	 0
$LN2@msvcrt_loc:
  00035	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0003a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi

; 67   : 
; 68   :     Py_BEGIN_ALLOW_THREADS

  0003f	e8 00 00 00 00	 call	 PyEval_SaveThread

; 69   :     err = _locking(fd, mode, nbytes);

  00044	44 8b 44 24 60	 mov	 r8d, DWORD PTR nbytes$[rsp]
  00049	8b 54 24 68	 mov	 edx, DWORD PTR mode$[rsp]
  0004d	8b 4c 24 30	 mov	 ecx, DWORD PTR fd$[rsp]
  00051	48 8b f8	 mov	 rdi, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__locking

; 70   :     Py_END_ALLOW_THREADS

  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	8b d8		 mov	 ebx, eax
  0005f	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00064	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 71   :     if (err != 0)

  00069	85 db		 test	 ebx, ebx
  0006b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00070	74 11		 je	 SHORT $LN1@msvcrt_loc

; 72   :         return PyErr_SetFromErrno(PyExc_IOError);

  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00079	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 76   : }

  0007e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00082	c3		 ret	 0
$LN1@msvcrt_loc:

; 73   : 
; 74   :     Py_INCREF(Py_None);

  00083	e8 00 00 00 00	 call	 _Py_PXCTX
  00088	85 c0		 test	 eax, eax
  0008a	75 3c		 jne	 SHORT $LN6@msvcrt_loc
  0008c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	75 09		 jne	 SHORT $LN5@msvcrt_loc
  000b8	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000bf	74 07		 je	 SHORT $LN6@msvcrt_loc
$LN5@msvcrt_loc:
  000c1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@msvcrt_loc:

; 75   :     return Py_None;

  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 76   : }

  000cf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d3	c3		 ret	 0
msvcrt_locking ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@		; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	__imp__setmode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_setmode DD imagerel msvcrt_setmode
	DD	imagerel msvcrt_setmode+92
	DD	imagerel $unwind$msvcrt_setmode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_setmode DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@
CONST	SEGMENT
??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@ DB 'ii:setmode', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_setmode
_TEXT	SEGMENT
self$ = 48
args$ = 56
flags$ = 64
fd$ = 72
msvcrt_setmode PROC					; COMDAT

; 92   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 93   :     int fd;
; 94   :     int flags;
; 95   :     if (!PyArg_ParseTuple(args,"ii:setmode", &fd, &flags))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 40	 lea	 r9, QWORD PTR flags$[rsp]
  0000c	4c 8d 44 24 48	 lea	 r8, QWORD PTR fd$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@msvcrt_set

; 96   :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 103  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN2@msvcrt_set:

; 97   : 
; 98   :     flags = _setmode(fd, flags);

  00028	8b 54 24 40	 mov	 edx, DWORD PTR flags$[rsp]
  0002c	8b 4c 24 48	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode
  00036	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 99   :     if (flags == -1)

  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	75 11		 jne	 SHORT $LN1@msvcrt_set

; 100  :         return PyErr_SetFromErrno(PyExc_IOError);

  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00046	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 103  : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
$LN1@msvcrt_set:

; 101  : 
; 102  :     return PyLong_FromLong(flags);

  00050	8b c8		 mov	 ecx, eax
  00052	e8 00 00 00 00	 call	 PyLong_FromLong

; 103  : }

  00057	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005b	c3		 ret	 0
msvcrt_setmode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@	; `string'
EXTRN	__imp__open_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_open_osfhandle DD imagerel msvcrt_open_osfhandle
	DD	imagerel msvcrt_open_osfhandle+89
	DD	imagerel $unwind$msvcrt_open_osfhandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_open_osfhandle DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@
CONST	SEGMENT
??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@ DB 'li:open_osfhandle', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_open_osfhandle
_TEXT	SEGMENT
self$ = 48
args$ = 56
handle$ = 64
flags$ = 72
msvcrt_open_osfhandle PROC				; COMDAT

; 115  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 116  :     long handle;
; 117  :     int flags;
; 118  :     int fd;
; 119  : 
; 120  :     if (!PyArg_ParseTuple(args, "li:open_osfhandle", &handle, &flags))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 48	 lea	 r9, QWORD PTR flags$[rsp]
  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR handle$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@
  00018	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@msvcrt_ope

; 121  :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 128  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN2@msvcrt_ope:

; 122  : 
; 123  :     fd = _open_osfhandle(handle, flags);

  00028	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR handle$[rsp]
  0002d	8b 54 24 48	 mov	 edx, DWORD PTR flags$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle

; 124  :     if (fd == -1)

  00037	83 f8 ff	 cmp	 eax, -1
  0003a	75 11		 jne	 SHORT $LN1@msvcrt_ope

; 125  :         return PyErr_SetFromErrno(PyExc_IOError);

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00043	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 128  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
$LN1@msvcrt_ope:

; 126  : 
; 127  :     return PyLong_FromLong(fd);

  0004d	8b c8		 mov	 ecx, eax
  0004f	e8 00 00 00 00	 call	 PyLong_FromLong

; 128  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
msvcrt_open_osfhandle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@	; `string'
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	__imp__get_osfhandle:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_get_osfhandle DD imagerel msvcrt_get_osfhandle
	DD	imagerel msvcrt_get_osfhandle+94
	DD	imagerel $unwind$msvcrt_get_osfhandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_get_osfhandle DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@
CONST	SEGMENT
??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@ DB 'i:get_osfhandle', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_get_osfhandle
_TEXT	SEGMENT
self$ = 48
args$ = 56
fd$ = 64
msvcrt_get_osfhandle PROC				; COMDAT

; 141  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 142  :     int fd;
; 143  :     Py_intptr_t handle;
; 144  : 
; 145  :     if (!PyArg_ParseTuple(args,"i:get_osfhandle", &fd))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR fd$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN3@msvcrt_get

; 146  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 159  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN3@msvcrt_get:

; 147  : 
; 148  :     if (!_PyVerify_fd(fd))

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00027	e8 00 00 00 00	 call	 _PyVerify_fd
  0002c	85 c0		 test	 eax, eax
  0002e	75 11		 jne	 SHORT $LN2@msvcrt_get
$LN6@msvcrt_get:

; 149  :         return PyErr_SetFromErrno(PyExc_IOError);

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00037	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 159  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN2@msvcrt_get:

; 150  : 
; 151  :     handle = _get_osfhandle(fd);

  00041	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle

; 152  :     if (handle == -1)

  0004b	48 83 f8 ff	 cmp	 rax, -1

; 153  :         return PyErr_SetFromErrno(PyExc_IOError);

  0004f	74 df		 je	 SHORT $LN6@msvcrt_get

; 154  : 
; 155  :     /* technically 'handle' is not a pointer, but a integer as
; 156  :        large as a pointer, Python's *VoidPtr interface is the
; 157  :        most appropriate here */
; 158  :     return PyLong_FromVoidPtr((void*)handle);

  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 PyLong_FromVoidPtr

; 159  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
msvcrt_get_osfhandle ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BNIGJCJI@?3kbhit?$AA@			; `string'
EXTRN	__imp__kbhit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_kbhit DD imagerel msvcrt_kbhit
	DD	imagerel msvcrt_kbhit+47
	DD	imagerel $unwind$msvcrt_kbhit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_kbhit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_06BNIGJCJI@?3kbhit?$AA@
CONST	SEGMENT
??_C@_06BNIGJCJI@?3kbhit?$AA@ DB ':kbhit', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_kbhit
_TEXT	SEGMENT
self$ = 48
args$ = 56
msvcrt_kbhit PROC					; COMDAT

; 171  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 172  :     int ok;
; 173  : 
; 174  :     if (!PyArg_ParseTuple(args, ":kbhit"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BNIGJCJI@?3kbhit?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN1@msvcrt_kbh

; 175  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 179  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN1@msvcrt_kbh:

; 176  : 
; 177  :     ok = _kbhit();

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__kbhit

; 178  :     return PyLong_FromLong(ok);

  00024	8b c8		 mov	 ecx, eax

; 179  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	e9 00 00 00 00	 jmp	 PyLong_FromLong
msvcrt_kbhit ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CJELLOFP@?3getch?$AA@			; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp__getch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getch DD imagerel msvcrt_getch
	DD	imagerel msvcrt_getch+99
	DD	imagerel $unwind$msvcrt_getch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getch DD 052801H
	DD	047428H
	DD	063423H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_06CJELLOFP@?3getch?$AA@
CONST	SEGMENT
??_C@_06CJELLOFP@?3getch?$AA@ DB ':getch', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_getch
_TEXT	SEGMENT
self$ = 48
args$ = 56
s$ = 64
msvcrt_getch PROC					; COMDAT

; 188  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 189  :     int ch;
; 190  :     char s[1];
; 191  : 
; 192  :     if (!PyArg_ParseTuple(args, ":getch"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJELLOFP@?3getch?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN1@msvcrt_get@2

; 193  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 200  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN1@msvcrt_get@2:
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 194  : 
; 195  :     Py_BEGIN_ALLOW_THREADS

  00028	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002d	48 8b d8	 mov	 rbx, rax

; 196  :     ch = _getch();

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getch

; 197  :     Py_END_ALLOW_THREADS

  00036	48 8b cb	 mov	 rcx, rbx
  00039	8b f8		 mov	 edi, eax
  0003b	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 198  :     s[0] = ch;
; 199  :     return PyBytes_FromStringAndSize(s, 1);

  00040	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00045	ba 01 00 00 00	 mov	 edx, 1
  0004a	40 88 7c 24 40	 mov	 BYTE PTR s$[rsp], dil
  0004f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00054	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 200  : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
msvcrt_getch ENDP
_TEXT	ENDS
PUBLIC	??_C@_07IFPHMJFN@?3getwch?$AA@			; `string'
EXTRN	PyUnicode_FromOrdinal:PROC
EXTRN	__imp__getwch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getwch DD imagerel msvcrt_getwch
	DD	imagerel msvcrt_getwch+86
	DD	imagerel $unwind$msvcrt_getwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getwch DD 052801H
	DD	047428H
	DD	063423H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07IFPHMJFN@?3getwch?$AA@
CONST	SEGMENT
??_C@_07IFPHMJFN@?3getwch?$AA@ DB ':getwch', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_getwch
_TEXT	SEGMENT
self$ = 48
args$ = 56
msvcrt_getwch PROC					; COMDAT

; 215  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     wchar_t ch;
; 217  : 
; 218  :     if (!PyArg_ParseTuple(args, ":getwch"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07IFPHMJFN@?3getwch?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN1@msvcrt_get@3

; 219  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 225  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN1@msvcrt_get@3:
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 220  : 
; 221  :     Py_BEGIN_ALLOW_THREADS

  00028	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002d	48 8b d8	 mov	 rbx, rax

; 222  :     ch = _getwch();

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getwch

; 223  :     Py_END_ALLOW_THREADS

  00036	48 8b cb	 mov	 rcx, rbx
  00039	0f b7 f8	 movzx	 edi, ax
  0003c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 224  :     return PyUnicode_FromOrdinal(ch);

  00041	8b cf		 mov	 ecx, edi
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 225  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	e9 00 00 00 00	 jmp	 PyUnicode_FromOrdinal
msvcrt_getwch ENDP
_TEXT	ENDS
PUBLIC	??_C@_07ODHHJIDJ@?3getche?$AA@			; `string'
EXTRN	__imp__getche:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getche DD imagerel msvcrt_getche
	DD	imagerel msvcrt_getche+99
	DD	imagerel $unwind$msvcrt_getche
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getche DD 052801H
	DD	047428H
	DD	063423H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07ODHHJIDJ@?3getche?$AA@
CONST	SEGMENT
??_C@_07ODHHJIDJ@?3getche?$AA@ DB ':getche', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_getche
_TEXT	SEGMENT
self$ = 48
args$ = 56
s$ = 64
msvcrt_getche PROC					; COMDAT

; 235  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 236  :     int ch;
; 237  :     char s[1];
; 238  : 
; 239  :     if (!PyArg_ParseTuple(args, ":getche"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07ODHHJIDJ@?3getche?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN1@msvcrt_get@4

; 240  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 247  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN1@msvcrt_get@4:
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 241  : 
; 242  :     Py_BEGIN_ALLOW_THREADS

  00028	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002d	48 8b d8	 mov	 rbx, rax

; 243  :     ch = _getche();

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getche

; 244  :     Py_END_ALLOW_THREADS

  00036	48 8b cb	 mov	 rcx, rbx
  00039	8b f8		 mov	 edi, eax
  0003b	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 245  :     s[0] = ch;
; 246  :     return PyBytes_FromStringAndSize(s, 1);

  00040	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00045	ba 01 00 00 00	 mov	 edx, 1
  0004a	40 88 7c 24 40	 mov	 BYTE PTR s$[rsp], dil
  0004f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00054	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 247  : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
msvcrt_getche ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NNFEFGC@?3getwche?$AA@			; `string'
EXTRN	__imp__getwche:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getwche DD imagerel msvcrt_getwche
	DD	imagerel msvcrt_getwche+86
	DD	imagerel $unwind$msvcrt_getwche
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getwche DD 052801H
	DD	047428H
	DD	063423H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_08NNFEFGC@?3getwche?$AA@
CONST	SEGMENT
??_C@_08NNFEFGC@?3getwche?$AA@ DB ':getwche', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT msvcrt_getwche
_TEXT	SEGMENT
self$ = 48
args$ = 56
msvcrt_getwche PROC					; COMDAT

; 258  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 259  :     wchar_t ch;
; 260  : 
; 261  :     if (!PyArg_ParseTuple(args, ":getwche"))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NNFEFGC@?3getwche?$AA@
  0000e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00013	85 c0		 test	 eax, eax
  00015	75 07		 jne	 SHORT $LN1@msvcrt_get@5

; 262  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 268  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
$LN1@msvcrt_get@5:
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00023	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 263  : 
; 264  :     Py_BEGIN_ALLOW_THREADS

  00028	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002d	48 8b d8	 mov	 rbx, rax

; 265  :     ch = _getwche();

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getwche

; 266  :     Py_END_ALLOW_THREADS

  00036	48 8b cb	 mov	 rcx, rbx
  00039	0f b7 f8	 movzx	 edi, ax
  0003c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 267  :     return PyUnicode_FromOrdinal(ch);

  00041	8b cf		 mov	 ecx, edi
  00043	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 268  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	e9 00 00 00 00	 jmp	 PyUnicode_FromOrdinal
msvcrt_getwche ENDP
_TEXT	ENDS
PUBLIC	??_C@_07PBFCLMLB@c?3putch?$AA@			; `string'
EXTRN	__imp__putch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$msvcrt_putch DD imagerel msvcrt_putch
	DD	imagerel msvcrt_putch+127
	DD	imagerel $unwind$msvcrt_putch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_putch DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_07PBFCLMLB@c?3putch?$AA@
CONST	SEGMENT
??_C@_07PBFCLMLB@c?3putch?$AA@ DB 'c:putch', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_putch
_TEXT	SEGMENT
self$ = 64
args$ = 72
ch$ = 80
msvcrt_putch PROC					; COMDAT

; 278  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 279  :     char ch;
; 280  : 
; 281  :     if (!PyArg_ParseTuple(args, "c:putch", &ch))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR ch$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PBFCLMLB@c?3putch?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@msvcrt_put

; 282  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 287  : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN1@msvcrt_put:

; 283  : 
; 284  :     _putch(ch);

  00023	0f be 4c 24 50	 movsx	 ecx, BYTE PTR ch$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__putch

; 285  :     Py_INCREF(Py_None);

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	75 3c		 jne	 SHORT $LN5@msvcrt_put
  00037	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00052	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005f	85 c0		 test	 eax, eax
  00061	75 09		 jne	 SHORT $LN4@msvcrt_put
  00063	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0006a	74 07		 je	 SHORT $LN5@msvcrt_put
$LN4@msvcrt_put:
  0006c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@msvcrt_put:

; 286  :     return Py_None;

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 287  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
msvcrt_putch ENDP
_TEXT	ENDS
PUBLIC	??_C@_08EAGMJNID@C?3putwch?$AA@			; `string'
EXTRN	__imp__putwch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$msvcrt_putwch DD imagerel msvcrt_putwch
	DD	imagerel msvcrt_putwch+127
	DD	imagerel $unwind$msvcrt_putwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_putwch DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_08EAGMJNID@C?3putwch?$AA@
CONST	SEGMENT
??_C@_08EAGMJNID@C?3putwch?$AA@ DB 'C:putwch', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_putwch
_TEXT	SEGMENT
self$ = 64
args$ = 72
ch$ = 80
msvcrt_putwch PROC					; COMDAT

; 297  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 298  :     int ch;
; 299  : 
; 300  :     if (!PyArg_ParseTuple(args, "C:putwch", &ch))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR ch$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EAGMJNID@C?3putwch?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@msvcrt_put@2

; 301  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 305  : 
; 306  : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN1@msvcrt_put@2:

; 302  : 
; 303  :     _putwch(ch);

  00023	0f b7 4c 24 50	 movzx	 ecx, WORD PTR ch$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__putwch

; 304  :     Py_RETURN_NONE;

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	75 3c		 jne	 SHORT $LN5@msvcrt_put@2
  00037	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00052	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005f	85 c0		 test	 eax, eax
  00061	75 09		 jne	 SHORT $LN4@msvcrt_put@2
  00063	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0006a	74 07		 je	 SHORT $LN5@msvcrt_put@2
$LN4@msvcrt_put@2:
  0006c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@msvcrt_put@2:
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 305  : 
; 306  : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
msvcrt_putwch ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OFEIKODI@c?3ungetch?$AA@		; `string'
EXTRN	__imp__ungetch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$msvcrt_ungetch DD imagerel msvcrt_ungetch
	DD	imagerel msvcrt_ungetch+149
	DD	imagerel $unwind$msvcrt_ungetch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_ungetch DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_09OFEIKODI@c?3ungetch?$AA@
CONST	SEGMENT
??_C@_09OFEIKODI@c?3ungetch?$AA@ DB 'c:ungetch', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_ungetch
_TEXT	SEGMENT
self$ = 64
args$ = 72
ch$ = 80
msvcrt_ungetch PROC					; COMDAT

; 316  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 317  :     char ch;
; 318  : 
; 319  :     if (!PyArg_ParseTuple(args, "c:ungetch", &ch))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR ch$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OFEIKODI@c?3ungetch?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@msvcrt_ung

; 320  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 326  : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN2@msvcrt_ung:

; 321  : 
; 322  :     if (_ungetch(ch) == EOF)

  00023	0f be 4c 24 50	 movsx	 ecx, BYTE PTR ch$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ungetch
  0002e	83 f8 ff	 cmp	 eax, -1
  00031	75 11		 jne	 SHORT $LN1@msvcrt_ung

; 323  :         return PyErr_SetFromErrno(PyExc_IOError);

  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0003a	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 326  : }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
$LN1@msvcrt_ung:

; 324  :     Py_INCREF(Py_None);

  00044	e8 00 00 00 00	 call	 _Py_PXCTX
  00049	85 c0		 test	 eax, eax
  0004b	75 3c		 jne	 SHORT $LN6@msvcrt_ung
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00062	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00068	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00070	e8 00 00 00 00	 call	 _PyParallel_Guard
  00075	85 c0		 test	 eax, eax
  00077	75 09		 jne	 SHORT $LN5@msvcrt_ung
  00079	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00080	74 07		 je	 SHORT $LN6@msvcrt_ung
$LN5@msvcrt_ung:
  00082	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@msvcrt_ung:

; 325  :     return Py_None;

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 326  : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
msvcrt_ungetch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@		; `string'
EXTRN	__imp__ungetwch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$msvcrt_ungetwch DD imagerel msvcrt_ungetwch
	DD	imagerel msvcrt_ungetwch+154
	DD	imagerel $unwind$msvcrt_ungetwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_ungetwch DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@
CONST	SEGMENT
??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@ DB 'C:ungetwch', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\msvcrtmodule.c
CONST	ENDS
;	COMDAT msvcrt_ungetwch
_TEXT	SEGMENT
self$ = 64
args$ = 72
ch$ = 80
msvcrt_ungetwch PROC					; COMDAT

; 338  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 339  :     int ch;
; 340  : 
; 341  :     if (!PyArg_ParseTuple(args, "C:ungetwch", &ch))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 50	 lea	 r8, QWORD PTR ch$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN2@msvcrt_ung@2

; 342  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 348  : }

  0001e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00022	c3		 ret	 0
$LN2@msvcrt_ung@2:

; 343  : 
; 344  :     if (_ungetwch(ch) == WEOF)

  00023	0f b7 4c 24 50	 movzx	 ecx, WORD PTR ch$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ungetwch
  0002e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00033	66 3b c1	 cmp	 ax, cx
  00036	75 11		 jne	 SHORT $LN1@msvcrt_ung@2

; 345  :         return PyErr_SetFromErrno(PyExc_IOError);

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0003f	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 348  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
$LN1@msvcrt_ung@2:

; 346  :     Py_INCREF(Py_None);

  00049	e8 00 00 00 00	 call	 _Py_PXCTX
  0004e	85 c0		 test	 eax, eax
  00050	75 3c		 jne	 SHORT $LN6@msvcrt_ung@2
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00067	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00075	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007a	85 c0		 test	 eax, eax
  0007c	75 09		 jne	 SHORT $LN5@msvcrt_ung@2
  0007e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00085	74 07		 je	 SHORT $LN6@msvcrt_ung@2
$LN5@msvcrt_ung@2:
  00087	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@msvcrt_ung@2:

; 347  :     return Py_None;

  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 348  : }

  00095	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00099	c3		 ret	 0
msvcrt_ungetwch ENDP
_TEXT	ENDS
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertint DD imagerel insertint
	DD	imagerel insertint+94
	DD	imagerel $unwind$insertint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertint DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT insertint
_TEXT	SEGMENT
d$ = 48
name$ = 56
value$ = 64
insertint PROC						; COMDAT

; 358  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 359  :     PyObject *v = PyLong_FromLong((long) value);

  00012	41 8b c8	 mov	 ecx, r8d
  00015	48 8b fa	 mov	 rdi, rdx
  00018	e8 00 00 00 00	 call	 PyLong_FromLong
  0001d	48 8b d8	 mov	 rbx, rax

; 360  :     if (v == NULL) {

  00020	48 85 c0	 test	 rax, rax
  00023	75 14		 jne	 SHORT $LN2@insertint

; 367  :     }
; 368  : }

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	e9 00 00 00 00	 jmp	 PyErr_Clear
$LN2@insertint:

; 361  :         /* Don't bother reporting this error */
; 362  :         PyErr_Clear();
; 363  :     }
; 364  :     else {
; 365  :         PyDict_SetItemString(d, name, v);

  00039	4c 8b c0	 mov	 r8, rax
  0003c	48 8b d7	 mov	 rdx, rdi
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	e8 00 00 00 00	 call	 PyDict_SetItemString

; 366  :         Py_DECREF(v);

  00047	48 8b cb	 mov	 rcx, rbx

; 367  :     }
; 368  : }

  0004a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	e9 00 00 00 00	 jmp	 _Py_DecRef
insertint ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	__imp_SetErrorMode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$seterrormode DD imagerel seterrormode
	DD	imagerel seterrormode+57
	DD	imagerel $unwind$seterrormode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seterrormode DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT seterrormode
_TEXT	SEGMENT
self$ = 48
args$ = 56
mode$ = 64
seterrormode PROC					; COMDAT

; 415  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 416  :     unsigned int mode, res;
; 417  : 
; 418  :     if (!PyArg_ParseTuple(args, "I", &mode))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 44 24 40	 lea	 r8, QWORD PTR mode$[rsp]
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JPJNBJEM@I?$AA@
  00013	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00018	85 c0		 test	 eax, eax
  0001a	75 07		 jne	 SHORT $LN1@seterrormo

; 419  :         return NULL;

  0001c	33 c0		 xor	 eax, eax

; 422  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN1@seterrormo:

; 420  :     res = SetErrorMode(mode);

  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR mode$[rsp]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode

; 421  :     return PyLong_FromUnsignedLong(res);

  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 422  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
seterrormode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@	; `string'
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@	; `string'
PUBLIC	??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@	; `string'
PUBLIC	??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@ ; `string'
PUBLIC	??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@	; `string'
PUBLIC	??_C@_08ILCJGBBJ@LK_UNLCK?$AA@			; `string'
PUBLIC	??_C@_07KNHLLCOM@LK_RLCK?$AA@			; `string'
PUBLIC	??_C@_09OMNGHHCN@LK_NBRLCK?$AA@			; `string'
PUBLIC	??_C@_08CHMIHOEA@LK_NBLCK?$AA@			; `string'
PUBLIC	??_C@_07GABODEOB@LK_LOCK?$AA@			; `string'
PUBLIC	PyInit_msvcrt
EXTRN	PyModule_AddObject:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_msvcrt DD imagerel $LN5
	DD	imagerel $LN5+312
	DD	imagerel $unwind$PyInit_msvcrt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_msvcrt DD 042d01H
	DD	08342dH
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@
CONST	SEGMENT
??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@ DB 'CRT_ASSEMBLY_VERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@
CONST	SEGMENT
??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@ DB 'SEM_NOOPENFILEERRORBOX'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@
CONST	SEGMENT
??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@ DB 'SEM_NOGPFAULTERRORBOX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@
CONST	SEGMENT
??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@ DB 'SEM_NOALIGNMENTFAU'
	DB	'LTEXCEPT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@
CONST	SEGMENT
??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@ DB 'SEM_FAILCRITICALERRORS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILCJGBBJ@LK_UNLCK?$AA@
CONST	SEGMENT
??_C@_08ILCJGBBJ@LK_UNLCK?$AA@ DB 'LK_UNLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNHLLCOM@LK_RLCK?$AA@
CONST	SEGMENT
??_C@_07KNHLLCOM@LK_RLCK?$AA@ DB 'LK_RLCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMNGHHCN@LK_NBRLCK?$AA@
CONST	SEGMENT
??_C@_09OMNGHHCN@LK_NBRLCK?$AA@ DB 'LK_NBRLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHMIHOEA@LK_NBLCK?$AA@
CONST	SEGMENT
??_C@_08CHMIHOEA@LK_NBLCK?$AA@ DB 'LK_NBLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GABODEOB@LK_LOCK?$AA@
CONST	SEGMENT
??_C@_07GABODEOB@LK_LOCK?$AA@ DB 'LK_LOCK', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_msvcrt
_TEXT	SEGMENT
PyInit_msvcrt PROC					; COMDAT

; 467  : {

$LN5:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 468  :     int st;
; 469  :     PyObject *d, *version;
; 470  :     PyObject *m = PyModule_Create(&msvcrtmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:msvcrtmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b f8	 mov	 rdi, rax

; 471  :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 06		 jne	 SHORT $LN2@PyInit_msv

; 524  : #endif
; 525  : 
; 526  :     return m;
; 527  : }

  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN2@PyInit_msv:

; 472  :         return NULL;
; 473  :     d = PyModule_GetDict(m);

  00025	48 8b c8	 mov	 rcx, rax
  00028	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0002d	e8 00 00 00 00	 call	 PyModule_GetDict

; 474  : 
; 475  :     /* constants for the locking() function's mode argument */
; 476  :     insertint(d, "LK_LOCK", _LK_LOCK);

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GABODEOB@LK_LOCK?$AA@
  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	48 8b c8	 mov	 rcx, rax
  00042	48 8b d8	 mov	 rbx, rax
  00045	e8 00 00 00 00	 call	 insertint

; 477  :     insertint(d, "LK_NBLCK", _LK_NBLCK);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CHMIHOEA@LK_NBLCK?$AA@
  00051	41 b8 02 00 00
	00		 mov	 r8d, 2
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	e8 00 00 00 00	 call	 insertint

; 478  :     insertint(d, "LK_NBRLCK", _LK_NBRLCK);

  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OMNGHHCN@LK_NBRLCK?$AA@
  00066	41 b8 04 00 00
	00		 mov	 r8d, 4
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	e8 00 00 00 00	 call	 insertint

; 479  :     insertint(d, "LK_RLCK", _LK_RLCK);

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KNHLLCOM@LK_RLCK?$AA@
  0007b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 insertint

; 480  :     insertint(d, "LK_UNLCK", _LK_UNLCK);

  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ILCJGBBJ@LK_UNLCK?$AA@
  00090	45 33 c0	 xor	 r8d, r8d
  00093	48 8b cb	 mov	 rcx, rbx
  00096	e8 00 00 00 00	 call	 insertint

; 481  :     insertint(d, "SEM_FAILCRITICALERRORS", SEM_FAILCRITICALERRORS);

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@
  000a2	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 insertint

; 482  :     insertint(d, "SEM_NOALIGNMENTFAULTEXCEPT", SEM_NOALIGNMENTFAULTEXCEPT);

  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@
  000b7	41 b8 04 00 00
	00		 mov	 r8d, 4
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	e8 00 00 00 00	 call	 insertint

; 483  :     insertint(d, "SEM_NOGPFAULTERRORBOX", SEM_NOGPFAULTERRORBOX);

  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@
  000cc	41 b8 02 00 00
	00		 mov	 r8d, 2
  000d2	48 8b cb	 mov	 rcx, rbx
  000d5	e8 00 00 00 00	 call	 insertint

; 484  :     insertint(d, "SEM_NOOPENFILEERRORBOX", SEM_NOOPENFILEERRORBOX);

  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@
  000e1	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  000e7	48 8b cb	 mov	 rcx, rbx
  000ea	e8 00 00 00 00	 call	 insertint

; 485  : #ifdef _DEBUG
; 486  :     insertint(d, "CRT_WARN", _CRT_WARN);
; 487  :     insertint(d, "CRT_ERROR", _CRT_ERROR);
; 488  :     insertint(d, "CRT_ASSERT", _CRT_ASSERT);
; 489  :     insertint(d, "CRTDBG_MODE_DEBUG", _CRTDBG_MODE_DEBUG);
; 490  :     insertint(d, "CRTDBG_MODE_FILE", _CRTDBG_MODE_FILE);
; 491  :     insertint(d, "CRTDBG_MODE_WNDW", _CRTDBG_MODE_WNDW);
; 492  :     insertint(d, "CRTDBG_REPORT_MODE", _CRTDBG_REPORT_MODE);
; 493  :     insertint(d, "CRTDBG_FILE_STDERR", (int)_CRTDBG_FILE_STDERR);
; 494  :     insertint(d, "CRTDBG_FILE_STDOUT", (int)_CRTDBG_FILE_STDOUT);
; 495  :     insertint(d, "CRTDBG_REPORT_FILE", (int)_CRTDBG_REPORT_FILE);
; 496  : #endif
; 497  : 
; 498  :     /* constants for the crt versions */
; 499  :     (void)st;
; 500  : #ifdef _VC_ASSEMBLY_PUBLICKEYTOKEN
; 501  :     st = PyModule_AddStringConstant(m, "VC_ASSEMBLY_PUBLICKEYTOKEN",
; 502  :                                     _VC_ASSEMBLY_PUBLICKEYTOKEN);
; 503  :     if (st < 0) return NULL;
; 504  : #endif
; 505  : #ifdef _CRT_ASSEMBLY_VERSION
; 506  :     st = PyModule_AddStringConstant(m, "CRT_ASSEMBLY_VERSION",
; 507  :                                     _CRT_ASSEMBLY_VERSION);
; 508  :     if (st < 0) return NULL;
; 509  : #endif
; 510  : #ifdef __LIBRARIES_ASSEMBLY_NAME_PREFIX
; 511  :     st = PyModule_AddStringConstant(m, "LIBRARIES_ASSEMBLY_NAME_PREFIX",
; 512  :                                     __LIBRARIES_ASSEMBLY_NAME_PREFIX);
; 513  :     if (st < 0) return NULL;
; 514  : #endif
; 515  : 
; 516  :     /* constants for the 2010 crt versions */
; 517  : #if defined(_VC_CRT_MAJOR_VERSION) && defined (_VC_CRT_MINOR_VERSION) && defined(_VC_CRT_BUILD_VERSION) && defined(_VC_CRT_RBUILD_VERSION)
; 518  :     version = PyUnicode_FromFormat("%d.%d.%d.%d", _VC_CRT_MAJOR_VERSION,
; 519  :                                                   _VC_CRT_MINOR_VERSION,
; 520  :                                                   _VC_CRT_BUILD_VERSION,
; 521  :                                                   _VC_CRT_RBUILD_VERSION);

  000ef	45 33 c0	 xor	 r8d, r8d
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  000f9	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  000fd	41 b9 6f 76 00
	00		 mov	 r9d, 30319		; 0000766fH
  00103	c7 44 24 20 cc
	01 00 00	 mov	 DWORD PTR [rsp+32], 460	; 000001ccH
  0010b	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 522  :     st = PyModule_AddObject(m, "CRT_ASSEMBLY_VERSION", version);

  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@
  00117	48 8b cf	 mov	 rcx, rdi
  0011a	4c 8b c0	 mov	 r8, rax
  0011d	e8 00 00 00 00	 call	 PyModule_AddObject
  00122	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 523  :     if (st < 0) return NULL;

  00127	33 c9		 xor	 ecx, ecx
  00129	85 c0		 test	 eax, eax
  0012b	48 0f 48 f9	 cmovs	 rdi, rcx
  0012f	48 8b c7	 mov	 rax, rdi

; 524  : #endif
; 525  : 
; 526  :     return m;
; 527  : }

  00132	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00136	5f		 pop	 rdi
  00137	c3		 ret	 0
PyInit_msvcrt ENDP
_TEXT	ENDS
END
