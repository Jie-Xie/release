; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_07HHBPHOLM@__all__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_0L@KEEJPJHH@__import__?$AA@		; `string'
PUBLIC	??_C@_0BA@JDLNCAMO@__build_class__?$AA@		; `string'
PUBLIC	??_C@_04MIIPNNEF@send?$AA@			; `string'
PUBLIC	??_C@_0M@JAEGONOO@_after_fork?$AA@		; `string'
PUBLIC	_Py_CheckRecursionLimit
_BSS	SEGMENT
pending_lock DQ	01H DUP (?)
main_thread DD	01H DUP (?)
eval_breaker DD	01H DUP (?)
gil_drop_request DD 01H DUP (?)
pendingcalls_to_do DD 01H DUP (?)
pending_async_exc DD 01H DUP (?)
gil_switch_number DD 01H DUP (?)
gil_last_holder DQ 01H DUP (?)
pendingfirst DD	01H DUP (?)
pendinglast DD	01H DUP (?)
?busy@?1??Py_MakePendingCalls@@9@9 DD 01H DUP (?)	; `Py_MakePendingCalls'::`2'::busy
_Py_TracingPossible DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHBPHOLM@__all__?$AA@
CONST	SEGMENT
??_C@_07HHBPHOLM@__all__?$AA@ DB '__all__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEJPJHH@__import__?$AA@
CONST	SEGMENT
??_C@_0L@KEEJPJHH@__import__?$AA@ DB '__import__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDLNCAMO@__build_class__?$AA@
CONST	SEGMENT
??_C@_0BA@JDLNCAMO@__build_class__?$AA@ DB '__build_class__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIIPNNEF@send?$AA@
CONST	SEGMENT
??_C@_04MIIPNNEF@send?$AA@ DB 'send', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___build_class__@?ED@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`67'::PyId___build_class__
	DQ	FLAT:??_C@_0BA@JDLNCAMO@__build_class__?$AA@
	DQ	0000000000000000H
?PyId___dict__@?1??import_all_from@@9@9 DQ 0000000000000000H ; `import_all_from'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId___all__@?1??import_all_from@@9@9 DQ 0000000000000000H ; `import_all_from'::`2'::PyId___all__
	DQ	FLAT:??_C@_07HHBPHOLM@__all__?$AA@
	DQ	0000000000000000H
?PyId___enter__@?IL@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'[::L]::PyId___enter__
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	0000000000000000H
?PyId___exit__@?IL@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'[::L]::PyId___exit__
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	0000000000000000H
?PyId___import__@?HB@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`113'::PyId___import__
	DQ	FLAT:??_C@_0L@KEEJPJHH@__import__?$AA@
	DQ	0000000000000000H
?PyId_send@?CL@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`43'::PyId_send
	DQ	FLAT:??_C@_04MIIPNNEF@send?$AA@
	DQ	0000000000000000H
?PyId__after_fork@?1??PyEval_ReInitThreads@@9@9 DQ 0000000000000000H ; `PyEval_ReInitThreads'::`2'::PyId__after_fork
	DQ	FLAT:??_C@_0M@JAEGONOO@_after_fork?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0M@JAEGONOO@_after_fork?$AA@
CONST	SEGMENT
??_C@_0M@JAEGONOO@_after_fork?$AA@ DB '_after_fork', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
gil_interval DD	01388H
gil_locked DD	0ffffffffH
recursion_limit DD 03e8H
_Py_CheckRecursionLimit DD 03e8H
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetCallStats
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetCallStats DD imagerel $LN10
	DD	imagerel $LN10+100
	DD	imagerel $unwind$PyEval_GetCallStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetCallStats DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT PyEval_GetCallStats
_TEXT	SEGMENT
self$ = 64
PyEval_GetCallStats PROC				; COMDAT

; 217  : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 218  :     Py_INCREF(Py_None);

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	75 48		 jne	 SHORT $LN7@PyEval_Get
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00024	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002a	4c 8b cb	 mov	 r9, rbx
  0002d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	75 09		 jne	 SHORT $LN3@PyEval_Get
  0003e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00045	74 07		 je	 SHORT $LN9@PyEval_Get
$LN3@PyEval_Get:
  00047	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@PyEval_Get:

; 219  :     return Py_None;

  0004e	48 8b c3	 mov	 rax, rbx

; 220  : }

  00051	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
$LN7@PyEval_Get:

; 219  :     return Py_None;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 220  : }

  0005e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00062	5b		 pop	 rbx
  00063	c3		 ret	 0
PyEval_GetCallStats ENDP
_TEXT	ENDS
EXTRN	__imp_InitializeCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_INIT DD imagerel PyMUTEX_INIT
	DD	imagerel PyMUTEX_INIT+17
	DD	imagerel $unwind$PyMUTEX_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_INIT DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_INIT
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_INIT PROC					; COMDAT

; 175  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     InitializeCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 177  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 178  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_DeleteCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_FINI DD imagerel PyMUTEX_FINI
	DD	imagerel PyMUTEX_FINI+17
	DD	imagerel $unwind$PyMUTEX_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_FINI
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_FINI PROC					; COMDAT

; 182  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     DeleteCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 184  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 185  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_FINI ENDP
_TEXT	ENDS
EXTRN	__imp_EnterCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_LOCK DD imagerel PyMUTEX_LOCK
	DD	imagerel PyMUTEX_LOCK+17
	DD	imagerel $unwind$PyMUTEX_LOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_LOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_LOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_LOCK PROC					; COMDAT

; 189  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     EnterCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 191  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 192  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_LOCK ENDP
_TEXT	ENDS
EXTRN	__imp_LeaveCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_UNLOCK DD imagerel PyMUTEX_UNLOCK
	DD	imagerel PyMUTEX_UNLOCK+17
	DD	imagerel $unwind$PyMUTEX_UNLOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_UNLOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyMUTEX_UNLOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_UNLOCK PROC					; COMDAT

; 196  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     LeaveCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 198  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 199  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_UNLOCK ENDP
_TEXT	ENDS
EXTRN	__imp_CreateSemaphoreA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_INIT DD imagerel PyCOND_INIT
	DD	imagerel PyCOND_INIT+60
	DD	imagerel $unwind$PyCOND_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_INIT DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_INIT
_TEXT	SEGMENT
cv$ = 48
PyCOND_INIT PROC					; COMDAT

; 213  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 214  :     /* A semaphore with a "large" max value,  The positive value
; 215  :      * is only needed to catch those "lost wakeup" events and
; 216  :      * race conditions when a timed wait elapses.
; 217  :      */
; 218  :     cv->sem = CreateSemaphore(NULL, 0, 100000, NULL);

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	33 d2		 xor	 edx, edx
  0000e	33 c9		 xor	 ecx, ecx
  00010	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 219  :     if (cv->sem==NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	75 09		 jne	 SHORT $LN1@PyCOND_INI

; 220  :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 223  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN1@PyCOND_INI:

; 221  :     cv->waiting = 0;

  0002d	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [rbx+8], 0

; 222  :     return 0;

  00034	33 c0		 xor	 eax, eax

; 223  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
PyCOND_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_CloseHandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_FINI DD imagerel PyCOND_FINI
	DD	imagerel PyCOND_FINI+26
	DD	imagerel $unwind$PyCOND_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_FINI
_TEXT	SEGMENT
cv$ = 48
PyCOND_FINI PROC					; COMDAT

; 227  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 228  :     return CloseHandle(cv->sem) ? 0 : -1;

  00004	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0000d	f7 d8		 neg	 eax
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax
  00013	ff c8		 dec	 eax

; 229  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
PyCOND_FINI ENDP
_TEXT	ENDS
EXTRN	__imp_WaitForSingleObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCOND_WAIT_MS DD imagerel _PyCOND_WAIT_MS
	DD	imagerel _PyCOND_WAIT_MS+112
	DD	imagerel $unwind$_PyCOND_WAIT_MS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCOND_WAIT_MS DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyCOND_WAIT_MS
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
ms$ = 64
_PyCOND_WAIT_MS PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 237  :     DWORD wait;
; 238  :     cv->waiting++;

  0000f	ff 41 08	 inc	 DWORD PTR [rcx+8]
  00012	48 8b f1	 mov	 rsi, rcx

; 239  :     PyMUTEX_UNLOCK(cs);

  00015	48 8b ca	 mov	 rcx, rdx
  00018	41 8b d8	 mov	 ebx, r8d
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 240  :     /* "lost wakeup bug" would occur if the caller were interrupted here,
; 241  :      * but we are safe because we are using a semaphore wich has an internal
; 242  :      * count.
; 243  :      */
; 244  :     wait = WaitForSingleObject(cv->sem, ms);

  00024	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00027	8b d3		 mov	 edx, ebx
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 245  :     PyMUTEX_LOCK(cs);

  0002f	48 8b cf	 mov	 rcx, rdi
  00032	8b d8		 mov	 ebx, eax
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 246  :     if (wait != WAIT_OBJECT_0)

  0003a	85 db		 test	 ebx, ebx
  0003c	74 03		 je	 SHORT $LN2@PyCOND_WAI

; 247  :         --cv->waiting;

  0003e	ff 4e 08	 dec	 DWORD PTR [rsi+8]
$LN2@PyCOND_WAI:

; 248  :         /* Here we have a benign race condition with PyCOND_SIGNAL.
; 249  :          * When failure occurs or timeout, it is possible that
; 250  :          * PyCOND_SIGNAL also decrements this value
; 251  :          * and signals releases the mutex.  This is benign because it
; 252  :          * just means an extra spurious wakeup for a waiting thread.
; 253  :          * ('waiting' corresponds to the semaphore's "negative" count and
; 254  :          * we may end up with e.g. (waiting == -1 && sem.count == 1).  When
; 255  :          * a new thread comes along, it will pass right throuhgh, having
; 256  :          * adjusted it to (waiting == 0 && sem.count == 0).
; 257  :          */
; 258  :          
; 259  :     if (wait == WAIT_FAILED)

  00041	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00044	75 13		 jne	 SHORT $LN1@PyCOND_WAI

; 260  :         return -1;

  00046	83 c8 ff	 or	 eax, -1

; 261  :     /* return 0 on success, 1 on timeout */
; 262  :     return wait != WAIT_OBJECT_0;
; 263  : }

  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN1@PyCOND_WAI:
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	33 c0		 xor	 eax, eax
  00060	85 db		 test	 ebx, ebx
  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	0f 95 c0	 setne	 al
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
_PyCOND_WAIT_MS ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_WAIT DD imagerel PyCOND_WAIT
	DD	imagerel PyCOND_WAIT+103
	DD	imagerel $unwind$PyCOND_WAIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_WAIT DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_WAIT
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
PyCOND_WAIT PROC					; COMDAT

; 267  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 268  :     int result = _PyCOND_WAIT_MS(cv, cs, INFINITE);

  0000f	ff 41 08	 inc	 DWORD PTR [rcx+8]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	48 8b ca	 mov	 rcx, rdx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00021	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00024	83 ca ff	 or	 edx, -1			; ffffffffH
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	8b f0		 mov	 esi, eax
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00038	85 f6		 test	 esi, esi
  0003a	74 03		 je	 SHORT $LN4@PyCOND_WAI@2
  0003c	ff 4f 08	 dec	 DWORD PTR [rdi+8]
$LN4@PyCOND_WAI@2:
  0003f	33 c9		 xor	 ecx, ecx
  00041	83 fe ff	 cmp	 esi, -1			; ffffffffH
  00044	75 05		 jne	 SHORT $LN3@PyCOND_WAI@2
  00046	83 c8 ff	 or	 eax, -1
  00049	eb 07		 jmp	 SHORT $LN5@PyCOND_WAI@2
$LN3@PyCOND_WAI@2:
  0004b	85 f6		 test	 esi, esi
  0004d	8b c1		 mov	 eax, ecx
  0004f	0f 95 c0	 setne	 al
$LN5@PyCOND_WAI@2:

; 269  :     return result >= 0 ? 0 : result;
; 270  : }

  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005c	85 c0		 test	 eax, eax
  0005e	0f 49 c1	 cmovns	 eax, ecx
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
PyCOND_WAIT ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT PyCOND_TIMEDWAIT
_TEXT	SEGMENT
cv$ = 8
cs$ = 16
us$ = 24
PyCOND_TIMEDWAIT PROC					; COMDAT

; 274  : {

  00000	4c 8b ca	 mov	 r9, rdx

; 275  :     return _PyCOND_WAIT_MS(cv, cs, us/1000);

  00003	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00008	41 f7 e8	 imul	 r8d
  0000b	c1 fa 06	 sar	 edx, 6
  0000e	44 8b c2	 mov	 r8d, edx
  00011	41 c1 e8 1f	 shr	 r8d, 31
  00015	44 03 c2	 add	 r8d, edx
  00018	49 8b d1	 mov	 rdx, r9

; 276  : }

  0001b	e9 00 00 00 00	 jmp	 _PyCOND_WAIT_MS
PyCOND_TIMEDWAIT ENDP
_TEXT	ENDS
EXTRN	__imp_ReleaseSemaphore:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_SIGNAL DD imagerel PyCOND_SIGNAL
	DD	imagerel PyCOND_SIGNAL+52
	DD	imagerel $unwind$PyCOND_SIGNAL
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_SIGNAL DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCOND_SIGNAL
_TEXT	SEGMENT
cv$ = 48
PyCOND_SIGNAL PROC					; COMDAT

; 280  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 281  :     /* this test allows PyCOND_SIGNAL to be a no-op unless required
; 282  :      * to wake someone up, thus preventing an unbounded increase of
; 283  :      * the semaphore's internal counter.
; 284  :      */
; 285  :     if (cv->waiting > 0) {

  00004	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00007	85 c0		 test	 eax, eax
  00009	7e 22		 jle	 SHORT $LN1@PyCOND_SIG

; 286  :         /* notifying thread decreases the cv->waiting count so that
; 287  :          * a delay between notify and actual wakeup of the target thread
; 288  :          * doesn't cause a number of extra ReleaseSemaphore calls.
; 289  :          */
; 290  :         cv->waiting--;

  0000b	ff c8		 dec	 eax

; 291  :         return ReleaseSemaphore(cv->sem, 1, NULL) ? 0 : -1;

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  00020	f7 d8		 neg	 eax
  00022	1b c0		 sbb	 eax, eax
  00024	f7 d8		 neg	 eax
  00026	ff c8		 dec	 eax

; 294  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyCOND_SIG:

; 292  :     }
; 293  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 294  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
PyCOND_SIGNAL ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval_gil.h
_TEXT	ENDS
;	COMDAT gil_created
_TEXT	SEGMENT
gil_created PROC					; COMDAT

; 132  :     return _Py_atomic_load_explicit(&gil_locked, _Py_memory_order_acquire) >= 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR gil_locked, eax
  00008	0f 9d c0	 setge	 al

; 133  : }

  0000b	c3		 ret	 0
gil_created ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
EXTRN	_PyParallel_CreatedGIL:PROC
EXTRN	Py_FatalError:PROC
_BSS	SEGMENT
switch_cond DB	010H DUP (?)
gil_cond DB	010H DUP (?)
switch_mutex DB	028H DUP (?)
gil_mutex DB	028H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$create_gil DD imagerel create_gil
	DD	imagerel create_gil+159
	DD	imagerel $unwind$create_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create_gil DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_INIT(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_INI'
	DB	'T(gil_cond) failed', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval_gil.h
CONST	ENDS
;	COMDAT create_gil
_TEXT	SEGMENT
create_gil PROC						; COMDAT

; 136  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 137  :     MUTEX_INIT(gil_mutex);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 138  : #ifdef FORCE_SWITCHING
; 139  :     MUTEX_INIT(switch_mutex);

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 140  : #endif
; 141  :     COND_INIT(gil_cond);

  00020	45 33 c9	 xor	 r9d, r9d
  00023	33 d2		 xor	 edx, edx
  00025	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  0002b	33 c9		 xor	 ecx, ecx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  00033	33 db		 xor	 ebx, ebx
  00035	48 89 05 00 00
	00 00		 mov	 QWORD PTR gil_cond, rax
  0003c	48 85 c0	 test	 rax, rax
  0003f	74 08		 je	 SHORT $LN17@create_gil
  00041	89 1d 08 00 00
	00		 mov	 DWORD PTR gil_cond+8, ebx
  00047	eb 0c		 jmp	 SHORT $LN2@create_gil
$LN17@create_gil:
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@
  00050	e8 00 00 00 00	 call	 Py_FatalError
$LN2@create_gil:

; 142  : #ifdef FORCE_SWITCHING
; 143  :     COND_INIT(switch_cond);

  00055	45 33 c9	 xor	 r9d, r9d
  00058	33 d2		 xor	 edx, edx
  0005a	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00060	33 c9		 xor	 ecx, ecx
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  00068	48 89 05 00 00
	00 00		 mov	 QWORD PTR switch_cond, rax
  0006f	48 85 c0	 test	 rax, rax
  00072	74 08		 je	 SHORT $LN18@create_gil
  00074	89 1d 08 00 00
	00		 mov	 DWORD PTR switch_cond+8, ebx
  0007a	eb 0c		 jmp	 SHORT $LN1@create_gil
$LN18@create_gil:
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@
  00083	e8 00 00 00 00	 call	 Py_FatalError
$LN1@create_gil:

; 144  : #endif
; 145  :     _Py_atomic_store_relaxed(&gil_last_holder, NULL);

  00088	48 89 1d 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rbx

; 146  :     _Py_ANNOTATE_RWLOCK_CREATE(&gil_locked);
; 147  :     _Py_atomic_store_explicit(&gil_locked, 0, _Py_memory_order_release);

  0008f	89 1d 00 00 00
	00		 mov	 DWORD PTR gil_locked, ebx

; 148  : #ifdef WITH_PARALLEL
; 149  :     _PyParallel_CreatedGIL();
; 150  : #endif
; 151  : }

  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5b		 pop	 rbx
  0009a	e9 00 00 00 00	 jmp	 _PyParallel_CreatedGIL
create_gil ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
EXTRN	_PyParallel_DestroyedGIL:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$destroy_gil DD imagerel destroy_gil
	DD	imagerel destroy_gil+107
	DD	imagerel $unwind$destroy_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$destroy_gil DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_FINI(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_FI'
	DB	'NI(gil_cond) failed', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval_gil.h
CONST	ENDS
;	COMDAT destroy_gil
_TEXT	SEGMENT
destroy_gil PROC					; COMDAT

; 154  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 155  :     /* some pthread-like implementations tie the mutex to the cond
; 156  :      * and must have the cond destroyed first.
; 157  :      */
; 158  :     COND_FINI(gil_cond);

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gil_cond
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00011	85 c0		 test	 eax, eax
  00013	75 0c		 jne	 SHORT $LN4@destroy_gi
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@
  0001c	e8 00 00 00 00	 call	 Py_FatalError
$LN4@destroy_gi:

; 159  :     MUTEX_FINI(gil_mutex);

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 160  : #ifdef FORCE_SWITCHING
; 161  :     COND_FINI(switch_cond);

  0002e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR switch_cond
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0003b	85 c0		 test	 eax, eax
  0003d	75 0c		 jne	 SHORT $LN2@destroy_gi
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@
  00046	e8 00 00 00 00	 call	 Py_FatalError
$LN2@destroy_gi:

; 162  :     MUTEX_FINI(switch_mutex);

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 163  : #endif
; 164  :     _Py_atomic_store_explicit(&gil_locked, -1, _Py_memory_order_release);

  00058	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR gil_locked, -1

; 165  :     _Py_ANNOTATE_RWLOCK_DESTROY(&gil_locked);
; 166  : #ifdef WITH_PARALLEL
; 167  :     _PyParallel_DestroyedGIL();
; 168  : #endif
; 169  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	e9 00 00 00 00	 jmp	 _PyParallel_DestroyedGIL
destroy_gil ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT recreate_gil
_TEXT	SEGMENT
recreate_gil PROC					; COMDAT

; 173  :     _Py_ANNOTATE_RWLOCK_DESTROY(&gil_locked);
; 174  :     /* XXX should we destroy the old OS resources here? */
; 175  :     create_gil();
; 176  : }

  00000	e9 00 00 00 00	 jmp	 create_gil
recreate_gil ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@ ; `string'
EXTRN	_PyParallel_AboutToDropGIL:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$drop_gil DD imagerel drop_gil
	DD	imagerel drop_gil+342
	DD	imagerel $unwind$drop_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$drop_gil DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_WAIT(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_'
	DB	'SIGNAL(gil_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@
CONST	SEGMENT
??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@ DB 'drop_gil: GI'
	DB	'L is not locked', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval_gil.h
CONST	ENDS
;	COMDAT drop_gil
_TEXT	SEGMENT
tstate$ = 48
drop_gil PROC						; COMDAT

; 179  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 180  :     if (!_Py_atomic_load_relaxed(&gil_locked))

  0000a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_locked, 0
  00011	48 8b d9	 mov	 rbx, rcx
  00014	75 0c		 jne	 SHORT $LN13@drop_gil

; 181  :         Py_FatalError("drop_gil: GIL is not locked");

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@
  0001d	e8 00 00 00 00	 call	 Py_FatalError
$LN13@drop_gil:

; 182  :     /* tstate is allowed to be NULL (early interpreter init) */
; 183  :     if (tstate != NULL) {

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR gil_last_holder
  00029	48 85 db	 test	 rbx, rbx
  0002c	48 0f 45 c3	 cmovne	 rax, rbx
  00030	48 89 05 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rax

; 184  :         /* Sub-interpreter support: threads might have been switched
; 185  :            under our feet using PyThreadState_Swap(). Fix the GIL last
; 186  :            holder variable so that our heuristics work. */
; 187  :         _Py_atomic_store_relaxed(&gil_last_holder, tstate);
; 188  :     }
; 189  : 
; 190  : #ifdef WITH_PARALLEL
; 191  :     _PyParallel_AboutToDropGIL();

  00037	e8 00 00 00 00	 call	 _PyParallel_AboutToDropGIL

; 192  : #endif
; 193  :     MUTEX_LOCK(gil_mutex);

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 194  :     _Py_ANNOTATE_RWLOCK_RELEASED(&gil_locked, /*is_write=*/1);
; 195  :     _Py_atomic_store_relaxed(&gil_locked, 0);
; 196  :     COND_SIGNAL(gil_cond);

  00049	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR gil_cond+8
  0004f	33 ff		 xor	 edi, edi
  00051	89 3d 00 00 00
	00		 mov	 DWORD PTR gil_locked, edi
  00057	85 c0		 test	 eax, eax
  00059	7e 31		 jle	 SHORT $LN10@drop_gil
  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gil_cond
  00062	ff c8		 dec	 eax
  00064	8d 57 01	 lea	 edx, QWORD PTR [rdi+1]
  00067	45 33 c0	 xor	 r8d, r8d
  0006a	89 05 08 00 00
	00		 mov	 DWORD PTR gil_cond+8, eax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  00076	f7 d8		 neg	 eax
  00078	1b d2		 sbb	 edx, edx
  0007a	f7 da		 neg	 edx
  0007c	ff ca		 dec	 edx
  0007e	74 0c		 je	 SHORT $LN10@drop_gil
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@
  00087	e8 00 00 00 00	 call	 Py_FatalError
$LN10@drop_gil:

; 197  :     MUTEX_UNLOCK(gil_mutex);

  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 198  :     
; 199  : #ifdef FORCE_SWITCHING
; 200  :     if (_Py_atomic_load_relaxed(&gil_drop_request) && tstate != NULL) {

  00099	39 3d 00 00 00
	00		 cmp	 DWORD PTR gil_drop_request, edi
  0009f	0f 84 a6 00 00
	00		 je	 $LN1@drop_gil
  000a5	48 85 db	 test	 rbx, rbx
  000a8	0f 84 9d 00 00
	00		 je	 $LN1@drop_gil

; 201  :         MUTEX_LOCK(switch_mutex);

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 202  :         /* Not switched yet => wait */
; 203  :         if (_Py_atomic_load_relaxed(&gil_last_holder) == tstate) {

  000bb	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR gil_last_holder, rbx
  000c2	75 7a		 jne	 SHORT $LN2@drop_gil

; 204  :         RESET_GIL_DROP_REQUEST();

  000c4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc

; 205  :             /* NOTE: if COND_WAIT does not atomically start waiting when
; 206  :                releasing the mutex, another thread can run through, take
; 207  :                the GIL and drop it again, and reset the condition
; 208  :                before we even had a chance to wait for it. */
; 209  :             COND_WAIT(switch_cond, switch_mutex);

  000ca	ff 05 08 00 00
	00		 inc	 DWORD PTR switch_cond+8
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  000d7	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do
  000dd	89 3d 00 00 00
	00		 mov	 DWORD PTR gil_drop_request, edi
  000e3	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR switch_cond
  000f6	83 ca ff	 or	 edx, -1			; ffffffffH
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00106	8b d8		 mov	 ebx, eax
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  0010e	85 db		 test	 ebx, ebx
  00110	74 06		 je	 SHORT $LN28@drop_gil
  00112	ff 0d 08 00 00
	00		 dec	 DWORD PTR switch_cond+8
$LN28@drop_gil:
  00118	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  0011b	75 05		 jne	 SHORT $LN27@drop_gil
  0011d	83 c8 ff	 or	 eax, -1
  00120	eb 07		 jmp	 SHORT $LN29@drop_gil
$LN27@drop_gil:
  00122	85 db		 test	 ebx, ebx
  00124	8b c7		 mov	 eax, edi
  00126	0f 95 c0	 setne	 al
$LN29@drop_gil:
  00129	85 c0		 test	 eax, eax
  0012b	0f 49 c7	 cmovns	 eax, edi
  0012e	85 c0		 test	 eax, eax
  00130	74 0c		 je	 SHORT $LN2@drop_gil
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@
  00139	e8 00 00 00 00	 call	 Py_FatalError
$LN2@drop_gil:

; 210  :     }
; 211  :         MUTEX_UNLOCK(switch_mutex);

  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN1@drop_gil:

; 212  :     }
; 213  : #endif
; 214  : }

  0014b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00150	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00154	5f		 pop	 rdi
  00155	c3		 ret	 0
drop_gil ENDP
_TEXT	ENDS
PUBLIC	_PyEval_SetSwitchInterval
; Function compile flags: /Ogtpy
;	COMDAT _PyEval_SetSwitchInterval
_TEXT	SEGMENT
microseconds$ = 8
_PyEval_SetSwitchInterval PROC				; COMDAT

; 276  :     gil_interval = microseconds;

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR gil_interval, ecx

; 277  : }

  00006	c3		 ret	 0
_PyEval_SetSwitchInterval ENDP
_TEXT	ENDS
PUBLIC	_PyEval_GetSwitchInterval
; Function compile flags: /Ogtpy
;	COMDAT _PyEval_GetSwitchInterval
_TEXT	SEGMENT
_PyEval_GetSwitchInterval PROC				; COMDAT

; 281  :     return gil_interval;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_interval

; 282  : }

  00006	c3		 ret	 0
_PyEval_GetSwitchInterval ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@ ; `string'
PUBLIC	??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@	; `string'
PUBLIC	PyEval_ThreadsInitialized
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_ThreadsInitialized DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$PyEval_ThreadsInitialized
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ThreadsInitialized DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@
CONST	SEGMENT
??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@ DB 'PyEval_ThreadsIniti'
	DB	'alized', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
CONST	SEGMENT
??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@ DB '..\Python\ceval.c', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_ThreadsInitialized
_TEXT	SEGMENT
PyEval_ThreadsInitialized PROC				; COMDAT

; 303  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 304  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN1@PyEval_Thr
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 30 01 00
	00		 mov	 r8d, 304		; 00000130H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyEval_Thr:

; 305  :     return gil_created();
; 306  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	e9 00 00 00 00	 jmp	 gil_created
PyEval_ThreadsInitialized ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@	; `string'
PUBLIC	_PyEval_FiniThreads
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyEval_FiniThreads DD imagerel $LN5
	DD	imagerel $LN5+60
	DD	imagerel $unwind$_PyEval_FiniThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_FiniThreads DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@
CONST	SEGMENT
??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@ DB '_PyEval_FiniThreads', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyEval_FiniThreads
_TEXT	SEGMENT
_PyEval_FiniThreads PROC				; COMDAT

; 323  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 324  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN2@PyEval_Fin
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 44 01 00
	00		 mov	 r8d, 324		; 00000144H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@PyEval_Fin:

; 325  :     if (!gil_created())

  00029	e8 00 00 00 00	 call	 gil_created
  0002e	85 c0		 test	 eax, eax
  00030	74 05		 je	 SHORT $LN3@PyEval_Fin

; 326  :         return;
; 327  :     destroy_gil();

  00032	e8 00 00 00 00	 call	 destroy_gil
$LN3@PyEval_Fin:

; 328  :     assert(!gil_created());
; 329  : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
_PyEval_FiniThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@	; `string'
PUBLIC	PyEval_ReleaseLock
EXTRN	_PyThreadState_Current:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReleaseLock DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$PyEval_ReleaseLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReleaseLock DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@
CONST	SEGMENT
??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@ DB 'PyEval_ReleaseLock', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_ReleaseLock
_TEXT	SEGMENT
PyEval_ReleaseLock PROC					; COMDAT

; 343  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 344  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN1@PyEval_Rel
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 58 01 00
	00		 mov	 r8d, 344		; 00000158H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyEval_Rel:

; 345  :     /* This function must succeed when the current thread state is NULL.
; 346  :        We therefore avoid PyThreadState_GET() which dumps a fatal error
; 347  :        in debug mode.
; 348  :     */
; 349  :     drop_gil((PyThreadState*)_Py_atomic_load_relaxed(
; 350  :         &_PyThreadState_Current));

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyThreadState_Current

; 351  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	e9 00 00 00 00	 jmp	 drop_gil
PyEval_ReleaseLock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@ ; `string'
PUBLIC	??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@ ; `string'
PUBLIC	??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@	; `string'
PUBLIC	PyEval_ReleaseThread
EXTRN	PyThreadState_Swap:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReleaseThread DD imagerel $LN6
	DD	imagerel $LN6+100
	DD	imagerel $unwind$PyEval_ReleaseThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReleaseThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@
CONST	SEGMENT
??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@ DB 'PyEval_Releas'
	DB	'eThread: wrong thread state', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@
CONST	SEGMENT
??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@ DB 'PyEval_Releas'
	DB	'eThread: NULL thread state', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@
CONST	SEGMENT
??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@ DB 'PyEval_ReleaseThread', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_ReleaseThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_ReleaseThread PROC				; COMDAT

; 369  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 370  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN3@PyEval_Rel@2
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Rel@2:

; 371  :     if (tstate == NULL)

  0002e	48 85 db	 test	 rbx, rbx
  00031	75 0c		 jne	 SHORT $LN2@PyEval_Rel@2

; 372  :         Py_FatalError("PyEval_ReleaseThread: NULL thread state");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@
  0003a	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Rel@2:

; 373  :     if (PyThreadState_Swap(NULL) != tstate)

  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 PyThreadState_Swap
  00046	48 3b c3	 cmp	 rax, rbx
  00049	74 0c		 je	 SHORT $LN1@PyEval_Rel@2

; 374  :         Py_FatalError("PyEval_ReleaseThread: wrong thread state");

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@
  00052	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Rel@2:

; 375  :     drop_gil(tstate);

  00057	48 8b cb	 mov	 rcx, rbx

; 376  : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	e9 00 00 00 00	 jmp	 drop_gil
PyEval_ReleaseThread ENDP
_TEXT	ENDS
PUBLIC	_PyEval_SignalAsyncExc
; Function compile flags: /Ogtpy
;	COMDAT _PyEval_SignalAsyncExc
_TEXT	SEGMENT
_PyEval_SignalAsyncExc PROC				; COMDAT

; 427  :     SIGNAL_ASYNC_EXC();

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pending_async_exc, 1
  0000a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 428  : }

  00014	c3		 ret	 0
_PyEval_SignalAsyncExc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@ ; `string'
PUBLIC	PyEval_SaveThread
EXTRN	_PyParallel_BlockingCall:PROC
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	_PyParallel_GetCurrentThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_SaveThread DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$PyEval_SaveThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SaveThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@
CONST	SEGMENT
??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@ DB 'PyEval_Save'
	DB	'Thread: NULL tstate', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_SaveThread
_TEXT	SEGMENT
PyEval_SaveThread PROC					; COMDAT

; 440  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 441  :     PyThreadState *tstate;
; 442  : #ifdef WITH_PARALLEL
; 443  :     PyThreadState *pstate;
; 444  :     long cur_thread_id = _Py_get_current_thread_id();

  00006	65 8b 1c 25 48
	00 00 00	 mov	 ebx, DWORD PTR gs:72

; 445  :     tstate = _PyParallel_GetCurrentThreadState();

  0000e	e8 00 00 00 00	 call	 _PyParallel_GetCurrentThreadState

; 446  :     /*tstate = (PyThreadState*)_Py_atomic_load_relaxed(&_PyThreadState_Current);*/
; 447  :     if (tstate->thread_id != cur_thread_id) {

  00013	39 98 90 00 00
	00		 cmp	 DWORD PTR [rax+144], ebx
  00019	74 16		 je	 SHORT $LN3@PyEval_Sav

; 448  :         /* Verify we've been called from a parallel thread. */
; 449  :         pstate = _PyParallel_GetThreadState();

  0001b	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00020	48 8b d8	 mov	 rbx, rax

; 450  :         assert(tstate->is_parallel_thread == 0);
; 451  :         assert(pstate != NULL);
; 452  :         assert(pstate->thread_id == cur_thread_id);
; 453  :         assert(pstate->is_parallel_thread == 1);
; 454  :         _PyParallel_BlockingCall();

  00023	e8 00 00 00 00	 call	 _PyParallel_BlockingCall

; 465  : #endif
; 466  :     return tstate;

  00028	48 8b c3	 mov	 rax, rbx

; 467  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN3@PyEval_Sav:

; 455  :         return pstate;
; 456  :     }
; 457  :     assert(tstate->is_parallel_thread == 0);
; 458  : #endif
; 459  :     tstate = PyThreadState_Swap(NULL);

  00031	33 c9		 xor	 ecx, ecx
  00033	e8 00 00 00 00	 call	 PyThreadState_Swap
  00038	48 8b d8	 mov	 rbx, rax

; 460  :     if (tstate == NULL)

  0003b	48 85 c0	 test	 rax, rax
  0003e	75 0c		 jne	 SHORT $LN2@PyEval_Sav

; 461  :         Py_FatalError("PyEval_SaveThread: NULL tstate");

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@
  00047	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Sav:

; 462  : #ifdef WITH_THREAD
; 463  :     if (gil_created())

  0004c	e8 00 00 00 00	 call	 gil_created
  00051	85 c0		 test	 eax, eax
  00053	74 08		 je	 SHORT $LN1@PyEval_Sav

; 464  :         drop_gil(tstate);

  00055	48 8b cb	 mov	 rcx, rbx
  00058	e8 00 00 00 00	 call	 drop_gil
$LN1@PyEval_Sav:

; 465  : #endif
; 466  :     return tstate;

  0005d	48 8b c3	 mov	 rax, rbx

; 467  : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
PyEval_SaveThread ENDP
_TEXT	ENDS
PUBLIC	Py_AddPendingCall
EXTRN	PyThread_release_lock:PROC
EXTRN	PyThread_acquire_lock:PROC
_BSS	SEGMENT
pendingcalls DB	0200H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_AddPendingCall DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Py_AddPendingCall DD imagerel $LN19+41
	DD	imagerel $LN19+79
	DD	imagerel $chain$0$Py_AddPendingCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Py_AddPendingCall DD imagerel $LN19+79
	DD	imagerel $LN19+206
	DD	imagerel $chain$1$Py_AddPendingCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Py_AddPendingCall DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Py_AddPendingCall DD 020521H
	DD	063405H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_AddPendingCall DD 081501H
	DD	097415H
	DD	086415H
	DD	075415H
	DD	0c0113215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_AddPendingCall
_TEXT	SEGMENT
func$ = 48
arg$ = 56
Py_AddPendingCall PROC					; COMDAT

; 537  : {

$LN19:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 538  :     int i, j, result=0;
; 539  :     PyThread_type_lock lock = pending_lock;

  00015	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR pending_lock
  0001c	33 ff		 xor	 edi, edi
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	4c 8b e1	 mov	 r12, rcx

; 540  : 
; 541  :     /* try a few times for the lock.  Since this mechanism is used
; 542  :      * for signal handling (on the main thread), there is a (slim)
; 543  :      * chance that a signal is delivered on the same thread while we
; 544  :      * hold the lock during the Py_MakePendingCalls() function.
; 545  :      * This avoids a deadlock in that case.
; 546  :      * Note that signals can be delivered on any thread.  In particular,
; 547  :      * on Windows, a SIGINT is delivered on a system-created worker
; 548  :      * thread.
; 549  :      * We also check for lock being NULL, in the unlikely case that
; 550  :      * this function is called before any bytecode evaluation takes place.
; 551  :      */
; 552  :     if (lock != NULL) {

  00024	48 85 f6	 test	 rsi, rsi
  00027	74 2b		 je	 SHORT $LN7@Py_AddPend

; 553  :         for (i = 0; i<100; i++) {

  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002e	8b df		 mov	 ebx, edi
$LL11@Py_AddPend:

; 554  :             if (PyThread_acquire_lock(lock, NOWAIT_LOCK))

  00030	33 d2		 xor	 edx, edx
  00032	48 8b ce	 mov	 rcx, rsi
  00035	e8 00 00 00 00	 call	 PyThread_acquire_lock
  0003a	85 c0		 test	 eax, eax
  0003c	75 07		 jne	 SHORT $LN16@Py_AddPend

; 553  :         for (i = 0; i<100; i++) {

  0003e	ff c3		 inc	 ebx
  00040	83 fb 64	 cmp	 ebx, 100		; 00000064H
  00043	7c eb		 jl	 SHORT $LL11@Py_AddPend
$LN16@Py_AddPend:

; 555  :                 break;
; 556  :         }
; 557  :         if (i == 100)

  00045	83 fb 64	 cmp	 ebx, 100		; 00000064H
  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	75 05		 jne	 SHORT $LN7@Py_AddPend

; 558  :             return -1;

  0004f	83 c8 ff	 or	 eax, -1
  00052	eb 64		 jmp	 SHORT $LN13@Py_AddPend
$LN7@Py_AddPend:

; 559  :     }
; 560  : 
; 561  :     i = pendinglast;
; 562  :     j = (i + 1) % NPENDINGCALLS;

  00054	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR pendinglast
  0005b	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  0005e	25 1f 00 00 80	 and	 eax, -2147483617	; ffffffff8000001fH
  00063	7d 07		 jge	 SHORT $LN18@Py_AddPend
  00065	ff c8		 dec	 eax
  00067	83 c8 e0	 or	 eax, -32		; ffffffffffffffe0H
  0006a	ff c0		 inc	 eax
$LN18@Py_AddPend:

; 563  :     if (j == pendingfirst) {

  0006c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR pendingfirst
  00072	75 05		 jne	 SHORT $LN6@Py_AddPend

; 564  :         result = -1; /* Queue full */

  00074	83 cf ff	 or	 edi, -1

; 565  :     } else {

  00077	eb 1c		 jmp	 SHORT $LN4@Py_AddPend
$LN6@Py_AddPend:

; 566  :         pendingcalls[i].func = func;

  00079	48 8b d1	 mov	 rdx, rcx
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pendingcalls

; 567  :         pendingcalls[i].arg = arg;
; 568  :         pendinglast = j;

  00083	89 05 00 00 00
	00		 mov	 DWORD PTR pendinglast, eax
  00089	48 03 d2	 add	 rdx, rdx
  0008c	4c 89 24 d1	 mov	 QWORD PTR [rcx+rdx*8], r12
  00090	48 89 6c d1 08	 mov	 QWORD PTR [rcx+rdx*8+8], rbp
$LN4@Py_AddPend:

; 569  :     }
; 570  :     /* signal main loop */
; 571  :     SIGNAL_PENDING_CALLS();

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pendingcalls_to_do, 1
  0009f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 572  :     if (lock != NULL)

  000a9	48 85 f6	 test	 rsi, rsi
  000ac	74 08		 je	 SHORT $LN1@Py_AddPend

; 573  :         PyThread_release_lock(lock);

  000ae	48 8b ce	 mov	 rcx, rsi
  000b1	e8 00 00 00 00	 call	 PyThread_release_lock
$LN1@Py_AddPend:

; 574  :     return result;

  000b6	8b c7		 mov	 eax, edi
$LN13@Py_AddPend:

; 575  : }

  000b8	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000bd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c2	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cb	41 5c		 pop	 r12
  000cd	c3		 ret	 0
Py_AddPendingCall ENDP
_TEXT	ENDS
PUBLIC	Py_MakePendingCalls
EXTRN	PyThread_get_thread_ident:PROC
EXTRN	PyThread_allocate_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_MakePendingCalls DD imagerel $LN32
	DD	imagerel $LN32+364
	DD	imagerel $unwind$Py_MakePendingCalls
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_MakePendingCalls DD 0b7801H
	DD	04d478H
	DD	0a7473H
	DD	09546eH
	DD	083469H
	DD	0c0044208H
	DD	06002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_MakePendingCalls
_TEXT	SEGMENT
Py_MakePendingCalls PROC				; COMDAT

; 579  : {

$LN32:
  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 580  :     static int busy = 0;
; 581  :     int i;
; 582  :     int r = 0;
; 583  : 
; 584  :     if (!pending_lock) {

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
  0000f	45 33 e4	 xor	 r12d, r12d
  00012	41 8b f4	 mov	 esi, r12d
  00015	48 85 c0	 test	 rax, rax
  00018	75 1c		 jne	 SHORT $LN18@Py_MakePen

; 585  :         /* initial allocation of the lock */
; 586  :         pending_lock = PyThread_allocate_lock();

  0001a	e8 00 00 00 00	 call	 PyThread_allocate_lock
  0001f	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax

; 587  :         if (pending_lock == NULL)

  00026	48 85 c0	 test	 rax, rax
  00029	75 0b		 jne	 SHORT $LN18@Py_MakePen

; 588  :             return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 628  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	41 5c		 pop	 r12
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN18@Py_MakePen:

; 589  :     }
; 590  : 
; 591  :     /* only service pending calls on main thread */
; 592  :     if (main_thread && PyThread_get_thread_ident() != main_thread)

  00036	39 35 00 00 00
	00		 cmp	 DWORD PTR main_thread, esi
  0003c	74 1e		 je	 SHORT $LN17@Py_MakePen
  0003e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00049	74 0a		 je	 SHORT $LN27@Py_MakePen
$LN31@Py_MakePen:

; 593  :         return 0;

  0004b	33 c0		 xor	 eax, eax

; 628  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	41 5c		 pop	 r12
  00053	5e		 pop	 rsi
  00054	c3		 ret	 0
$LN27@Py_MakePen:

; 593  :         return 0;

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
$LN17@Py_MakePen:

; 594  :     /* don't perform recursive pending calls */
; 595  :     if (busy)

  0005c	39 35 00 00 00
	00		 cmp	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, esi

; 596  :         return 0;

  00062	75 e7		 jne	 SHORT $LN31@Py_MakePen

; 597  :     busy = 1;

  00064	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00069	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0006e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00073	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, 1

; 598  :     /* perform a bounded number of calls, in case of recursion */
; 599  :     for (i=0; i<NPENDINGCALLS; i++) {

  00082	41 8b dc	 mov	 ebx, r12d
  00085	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:pendingcalls
  0008c	0f 1f 40 00	 npad	 4
$LL15@Py_MakePen:

; 600  :         int j;
; 601  :         int (*func)(void *);
; 602  :         void *arg = NULL;
; 603  : 
; 604  :         /* pop one item off the queue while holding the lock */
; 605  :         PyThread_acquire_lock(pending_lock, WAIT_LOCK);

  00090	ba 01 00 00 00	 mov	 edx, 1
  00095	48 8b c8	 mov	 rcx, rax
  00098	49 8b ec	 mov	 rbp, r12
  0009b	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 606  :         j = pendingfirst;
; 607  :         if (j == pendinglast) {

  000a0	4c 63 1d 00 00
	00 00		 movsxd	 r11, DWORD PTR pendingfirst
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR pendinglast
  000ad	44 3b d9	 cmp	 r11d, ecx
  000b0	75 05		 jne	 SHORT $LN12@Py_MakePen

; 608  :             func = NULL; /* Queue empty */

  000b2	49 8b fc	 mov	 rdi, r12

; 609  :         } else {

  000b5	eb 2d		 jmp	 SHORT $LN11@Py_MakePen
$LN12@Py_MakePen:

; 610  :             func = pendingcalls[j].func;

  000b7	49 8b c3	 mov	 rax, r11
  000ba	48 03 c0	 add	 rax, rax

; 611  :             arg = pendingcalls[j].arg;
; 612  :             pendingfirst = (j + 1) % NPENDINGCALLS;

  000bd	41 ff c3	 inc	 r11d
  000c0	41 81 e3 1f 00
	00 80		 and	 r11d, -2147483617	; ffffffff8000001fH
  000c7	49 8b 7c c5 00	 mov	 rdi, QWORD PTR [r13+rax*8]
  000cc	49 8b 6c c5 08	 mov	 rbp, QWORD PTR [r13+rax*8+8]
  000d1	7d 0a		 jge	 SHORT $LN26@Py_MakePen
  000d3	41 ff cb	 dec	 r11d
  000d6	41 83 cb e0	 or	 r11d, -32		; ffffffffffffffe0H
  000da	41 ff c3	 inc	 r11d
$LN26@Py_MakePen:
  000dd	44 89 1d 00 00
	00 00		 mov	 DWORD PTR pendingfirst, r11d
$LN11@Py_MakePen:

; 613  :         }
; 614  :         if (pendingfirst != pendinglast)

  000e4	44 3b d9	 cmp	 r11d, ecx
  000e7	74 16		 je	 SHORT $LN5@Py_MakePen

; 615  :             SIGNAL_PENDING_CALLS();

  000e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pendingcalls_to_do, 1
  000f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 616  :         else

  000fd	eb 19		 jmp	 SHORT $LN3@Py_MakePen
$LN5@Py_MakePen:

; 617  :             UNSIGNAL_PENDING_CALLS();

  000ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc
  00105	44 89 25 00 00
	00 00		 mov	 DWORD PTR pendingcalls_to_do, r12d
  0010c	0b 05 00 00 00
	00		 or	 eax, DWORD PTR gil_drop_request
  00112	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
$LN3@Py_MakePen:

; 618  :         PyThread_release_lock(pending_lock);

  00118	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pending_lock
  0011f	e8 00 00 00 00	 call	 PyThread_release_lock

; 619  :         /* having released the lock, perform the callback */
; 620  :         if (func == NULL)

  00124	48 85 ff	 test	 rdi, rdi
  00127	74 1e		 je	 SHORT $LN30@Py_MakePen

; 621  :             break;
; 622  :         r = func(arg);

  00129	48 8b cd	 mov	 rcx, rbp
  0012c	ff d7		 call	 rdi
  0012e	8b f0		 mov	 esi, eax

; 623  :         if (r)

  00130	85 c0		 test	 eax, eax
  00132	75 13		 jne	 SHORT $LN30@Py_MakePen

; 598  :     /* perform a bounded number of calls, in case of recursion */
; 599  :     for (i=0; i<NPENDINGCALLS; i++) {

  00134	ff c3		 inc	 ebx
  00136	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00139	7d 0c		 jge	 SHORT $LN30@Py_MakePen
  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
  00142	e9 49 ff ff ff	 jmp	 $LL15@Py_MakePen
$LN30@Py_MakePen:
  00147	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  0014c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00151	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00156	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 624  :             break;
; 625  :     }
; 626  :     busy = 0;

  0015b	44 89 25 00 00
	00 00		 mov	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, r12d

; 627  :     return r;

  00162	8b c6		 mov	 eax, esi

; 628  : }

  00164	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00168	41 5c		 pop	 r12
  0016a	5e		 pop	 rsi
  0016b	c3		 ret	 0
Py_MakePendingCalls ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@	; `string'
PUBLIC	Py_GetRecursionLimit
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetRecursionLimit DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$Py_GetRecursionLimit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetRecursionLimit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@
CONST	SEGMENT
??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@ DB 'Py_GetRecursionLimit', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Py_GetRecursionLimit
_TEXT	SEGMENT
Py_GetRecursionLimit PROC				; COMDAT

; 731  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 732  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN4@Py_GetRecu
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 dc 02 00
	00		 mov	 r8d, 732		; 000002dcH
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@Py_GetRecu:

; 733  :     return recursion_limit;

  00029	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR recursion_limit

; 734  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
Py_GetRecursionLimit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@	; `string'
PUBLIC	Py_SetRecursionLimit
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_SetRecursionLimit DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$Py_SetRecursionLimit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_SetRecursionLimit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@
CONST	SEGMENT
??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@ DB 'Py_SetRecursionLimit', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Py_SetRecursionLimit
_TEXT	SEGMENT
new_limit$ = 48
Py_SetRecursionLimit PROC				; COMDAT

; 738  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 739  :     Py_GUARD

  00008	e8 00 00 00 00	 call	 _Py_PXCTX
  0000d	85 c0		 test	 eax, eax
  0000f	74 1c		 je	 SHORT $LN4@Py_SetRecu
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	41 b8 e3 02 00
	00		 mov	 r8d, 739		; 000002e3H
  00028	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@Py_SetRecu:

; 741  :     _Py_CheckRecursionLimit = recursion_limit;

  0002d	89 1d 00 00 00
	00		 mov	 DWORD PTR _Py_CheckRecursionLimit, ebx

; 740  :     recursion_limit = new_limit;

  00033	89 1d 00 00 00
	00		 mov	 DWORD PTR recursion_limit, ebx

; 742  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
Py_SetRecursionLimit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@ ; `string'
PUBLIC	??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@ ; `string'
PUBLIC	_Py_CheckRecursiveCall
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_CheckRecursiveCall DD imagerel $LN9
	DD	imagerel $LN9+141
	DD	imagerel $unwind$_Py_CheckRecursiveCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_CheckRecursiveCall DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@
CONST	SEGMENT
??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@ DB 'maximum recur'
	DB	'sion depth exceeded%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@
CONST	SEGMENT
??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@ DB 'Cannot recove'
	DB	'r from stack overflow.', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_CheckRecursiveCall
_TEXT	SEGMENT
where$ = 48
_Py_CheckRecursiveCall PROC				; COMDAT

; 751  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 752  :     PyThreadState *tstate = PyThreadState_GET();

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN7@Py_CheckRe
  00012	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00017	4c 8b d8	 mov	 r11, rax
  0001a	eb 07		 jmp	 SHORT $LN8@Py_CheckRe
$LN7@Py_CheckRe:
  0001c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN8@Py_CheckRe:

; 753  : 
; 754  : #ifdef USE_STACKCHECK
; 755  :     if (PyOS_CheckStack()) {
; 756  :         --tstate->recursion_depth;
; 757  :         PyErr_SetString(PyExc_MemoryError, "Stack overflow");
; 758  :         return -1;
; 759  :     }
; 760  : #endif
; 761  :     _Py_CheckRecursionLimit = recursion_limit;

  00023	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR recursion_limit
  00029	89 05 00 00 00
	00		 mov	 DWORD PTR _Py_CheckRecursionLimit, eax

; 762  :     if (tstate->recursion_critical)

  0002f	41 80 7b 1d 00	 cmp	 BYTE PTR [r11+29], 0

; 763  :         /* Somebody asked that we don't check for recursion. */
; 764  :         return 0;

  00034	75 1c		 jne	 SHORT $LN1@Py_CheckRe

; 765  :     if (tstate->overflowed) {

  00036	41 80 7b 1c 00	 cmp	 BYTE PTR [r11+28], 0
  0003b	74 1d		 je	 SHORT $LN3@Py_CheckRe

; 766  :         if (tstate->recursion_depth > recursion_limit + 50) {

  0003d	83 c0 32	 add	 eax, 50			; 00000032H
  00040	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00044	7e 0c		 jle	 SHORT $LN1@Py_CheckRe

; 767  :             /* Overflowing while handling an overflow. Give up. */
; 768  :             Py_FatalError("Cannot recover from stack overflow.");

  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@
  0004d	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_CheckRe:

; 779  :     }
; 780  :     return 0;

  00052	33 c0		 xor	 eax, eax

; 781  : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN3@Py_CheckRe:

; 769  :         }
; 770  :         return 0;
; 771  :     }
; 772  :     if (tstate->recursion_depth > recursion_limit) {

  0005a	41 8b 4b 18	 mov	 ecx, DWORD PTR [r11+24]
  0005e	3b c8		 cmp	 ecx, eax
  00060	7e f0		 jle	 SHORT $LN1@Py_CheckRe

; 773  :         --tstate->recursion_depth;

  00062	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 774  :         tstate->overflowed = 1;

  00065	41 c6 43 1c 01	 mov	 BYTE PTR [r11+28], 1

; 775  :         PyErr_Format(PyExc_RuntimeError,
; 776  :                      "maximum recursion depth exceeded%s",
; 777  :                      where);

  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@
  00071	41 89 43 18	 mov	 DWORD PTR [r11+24], eax
  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0007c	4c 8b c3	 mov	 r8, rbx
  0007f	e8 00 00 00 00	 call	 PyErr_Format

; 778  :         return -1;

  00084	83 c8 ff	 or	 eax, -1

; 781  : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
_Py_CheckRecursiveCall ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@	; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyUnicode_Concat:PROC
EXTRN	PyUnicode_Join:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyList_SetSlice:PROC
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$format_missing DD imagerel format_missing
	DD	imagerel format_missing+413
	DD	imagerel $unwind$format_missing
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_missing DD 0c1e01H
	DD	0f741eH
	DD	0e641eH
	DD	0d541eH
	DD	0c341eH
	DD	0e01a721eH
	DD	0c016d018H
xdata	ENDS
;	COMDAT ??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@
CONST	SEGMENT
??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@ DB '%'
	DB	'U() missing %i required %s argument%s: %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@
CONST	SEGMENT
??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@ DB '%U and %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@
CONST	SEGMENT
??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@ DB ', %U, and %U', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT format_missing
_TEXT	SEGMENT
kind$ = 96
co$ = 104
names$ = 112
format_missing PROC					; COMDAT

; 3154 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3155 :     int err;
; 3156 :     Py_ssize_t len = PyList_GET_SIZE(names);

  0001e	4d 8b 60 60	 mov	 r12, QWORD PTR [r8+96]
  00022	49 8b d8	 mov	 rbx, r8
  00025	4c 8b ea	 mov	 r13, rdx

; 3157 :     PyObject *name_str, *comma, *tail, *tmp;
; 3158 : 
; 3159 :     assert(PyList_CheckExact(names));
; 3160 :     assert(len >= 1);
; 3161 :     /* Deal with the joys of natural language. */
; 3162 :     switch (len) {

  00028	49 8b c4	 mov	 rax, r12
  0002b	4c 8b f1	 mov	 r14, rcx
  0002e	48 ff c8	 dec	 rax
  00031	0f 84 b6 00 00
	00		 je	 $LN8@format_mis
  00037	48 ff c8	 dec	 rax

; 3172 :     default:
; 3173 :         tail = PyUnicode_FromFormat(", %U, and %U",
; 3174 :                                     PyList_GET_ITEM(names, len - 2),
; 3175 :                                     PyList_GET_ITEM(names, len - 1));

  0003a	49 8b 50 70	 mov	 rdx, QWORD PTR [r8+112]
  0003e	0f 84 91 00 00
	00		 je	 $LN7@format_mis
  00044	4e 8b 44 e2 f8	 mov	 r8, QWORD PTR [rdx+r12*8-8]
  00049	4a 8b 54 e2 f0	 mov	 rdx, QWORD PTR [rdx+r12*8-16]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@
  00055	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0005a	48 8b f8	 mov	 rdi, rax

; 3176 :         if (tail == NULL)

  0005d	48 85 c0	 test	 rax, rax
  00060	0f 84 18 01 00
	00		 je	 $LN11@format_mis

; 3177 :             return;
; 3178 :         /* Chop off the last two objects in the list. This shouldn't actually
; 3179 :            fail, but we can't be too careful. */
; 3180 :         err = PyList_SetSlice(names, len - 2, len, NULL);

  00066	49 8d 54 24 fe	 lea	 rdx, QWORD PTR [r12-2]
  0006b	45 33 c9	 xor	 r9d, r9d
  0006e	4d 8b c4	 mov	 r8, r12
  00071	48 8b cb	 mov	 rcx, rbx
  00074	e8 00 00 00 00	 call	 PyList_SetSlice

; 3181 :         if (err == -1) {

  00079	83 f8 ff	 cmp	 eax, -1
  0007c	75 08		 jne	 SHORT $LN4@format_mis
$LN18@format_mis:

; 3182 :             Py_DECREF(tail);

  0007e	48 8b cf	 mov	 rcx, rdi

; 3183 :             return;

  00081	e9 f3 00 00 00	 jmp	 $LN17@format_mis
$LN4@format_mis:

; 3184 :         }
; 3185 :         /* Stitch everything up into a nice comma-separated list. */
; 3186 :         comma = PyUnicode_FromString(", ");

  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
  0008d	e8 00 00 00 00	 call	 PyUnicode_FromString
  00092	48 8b f0	 mov	 rsi, rax

; 3187 :         if (comma == NULL) {

  00095	48 85 c0	 test	 rax, rax

; 3188 :             Py_DECREF(tail);
; 3189 :             return;

  00098	74 e4		 je	 SHORT $LN18@format_mis

; 3190 :         }
; 3191 :         tmp = PyUnicode_Join(comma, names);

  0009a	48 8b d3	 mov	 rdx, rbx
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 PyUnicode_Join

; 3192 :         Py_DECREF(comma);

  000a5	48 8b ce	 mov	 rcx, rsi
  000a8	48 8b e8	 mov	 rbp, rax
  000ab	e8 00 00 00 00	 call	 _Py_DecRef

; 3193 :         if (tmp == NULL) {

  000b0	48 85 ed	 test	 rbp, rbp

; 3194 :             Py_DECREF(tail);
; 3195 :             return;

  000b3	74 c9		 je	 SHORT $LN18@format_mis

; 3196 :         }
; 3197 :         name_str = PyUnicode_Concat(tmp, tail);

  000b5	48 8b d7	 mov	 rdx, rdi
  000b8	48 8b cd	 mov	 rcx, rbp
  000bb	e8 00 00 00 00	 call	 PyUnicode_Concat

; 3198 :         Py_DECREF(tmp);

  000c0	48 8b cd	 mov	 rcx, rbp
  000c3	48 8b d8	 mov	 rbx, rax
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 3199 :         Py_DECREF(tail);

  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	e8 00 00 00 00	 call	 _Py_DecRef

; 3200 :         break;

  000d3	eb 5a		 jmp	 SHORT $LN14@format_mis
$LN7@format_mis:

; 3166 :         break;
; 3167 :     case 2:
; 3168 :         name_str = PyUnicode_FromFormat("%U and %U",
; 3169 :                                         PyList_GET_ITEM(names, len - 2),
; 3170 :                                         PyList_GET_ITEM(names, len - 1));

  000d5	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  000d9	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@
  000e3	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000e8	48 8b d8	 mov	 rbx, rax

; 3171 :         break;

  000eb	eb 42		 jmp	 SHORT $LN14@format_mis
$LN8@format_mis:

; 3163 :     case 1:
; 3164 :         name_str = PyList_GET_ITEM(names, 0);

  000ed	49 8b 40 70	 mov	 rax, QWORD PTR [r8+112]
  000f1	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 3165 :         Py_INCREF(name_str);

  000f4	e8 00 00 00 00	 call	 _Py_PXCTX
  000f9	85 c0		 test	 eax, eax
  000fb	75 32		 jne	 SHORT $LN14@format_mis
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0010b	4c 8b cb	 mov	 r9, rbx
  0010e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00114	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0011c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00121	85 c0		 test	 eax, eax
  00123	75 06		 jne	 SHORT $LN13@format_mis
  00125	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00129	74 04		 je	 SHORT $LN14@format_mis
$LN13@format_mis:
  0012b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN14@format_mis:

; 3201 :     }
; 3202 :     if (name_str == NULL)

  0012f	48 85 db	 test	 rbx, rbx
  00132	74 4a		 je	 SHORT $LN11@format_mis

; 3203 :         return;
; 3204 :     PyErr_Format(PyExc_TypeError,
; 3205 :                  "%U() missing %i required %s argument%s: %U",
; 3206 :                  co->co_name,
; 3207 :                  len,
; 3208 :                  kind,
; 3209 :                  len == 1 ? "" : "s",
; 3210 :                  name_str);

  00134	4d 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [r13+184]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00142	49 83 fc 01	 cmp	 r12, 1
  00146	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@
  00159	48 0f 44 c1	 cmove	 rax, rcx
  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00164	4d 8b cc	 mov	 r9, r12
  00167	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016c	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00171	e8 00 00 00 00	 call	 PyErr_Format

; 3211 :     Py_DECREF(name_str);

  00176	48 8b cb	 mov	 rcx, rbx
$LN17@format_mis:
  00179	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@format_mis:

; 3212 : }

  0017e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00183	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00188	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0018d	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00192	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00196	41 5e		 pop	 r14
  00198	41 5d		 pop	 r13
  0019a	41 5c		 pop	 r12
  0019c	c3		 ret	 0
format_missing ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@OOHFADNO@keyword?9only?$AA@		; `string'
PUBLIC	??_C@_0L@DLCGEICH@positional?$AA@		; `string'
EXTRN	PyObject_Repr:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$missing_arguments DD imagerel missing_arguments
	DD	imagerel missing_arguments+83
	DD	imagerel $unwind$missing_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$missing_arguments DD imagerel missing_arguments+83
	DD	imagerel missing_arguments+319
	DD	imagerel $chain$0$missing_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$missing_arguments DD imagerel missing_arguments+319
	DD	imagerel missing_arguments+342
	DD	imagerel $chain$1$missing_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$missing_arguments DD 021H
	DD	imagerel missing_arguments
	DD	imagerel missing_arguments+83
	DD	imagerel $unwind$missing_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$missing_arguments DD 020521H
	DD	0cd405H
	DD	imagerel missing_arguments
	DD	imagerel missing_arguments+83
	DD	imagerel $unwind$missing_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$missing_arguments DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0f0125216H
	DD	0c00ee010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0N@OOHFADNO@keyword?9only?$AA@
CONST	SEGMENT
??_C@_0N@OOHFADNO@keyword?9only?$AA@ DB 'keyword-only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCGEICH@positional?$AA@
CONST	SEGMENT
??_C@_0L@DLCGEICH@positional?$AA@ DB 'positional', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT missing_arguments
_TEXT	SEGMENT
co$ = 96
missing$ = 104
defcount$ = 112
fastlocals$ = 120
missing_arguments PROC					; COMDAT

; 3217 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3218 :     int i, j = 0;
; 3219 :     int start, end;
; 3220 :     int positional = defcount != -1;

  00016	33 ed		 xor	 ebp, ebp
  00018	41 83 f8 ff	 cmp	 r8d, -1

; 3221 :     const char *kind = positional ? "positional" : "keyword-only";

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@DLCGEICH@positional?$AA@
  00023	8b fd		 mov	 edi, ebp
  00025	40 0f 95 c7	 setne	 dil
  00029	4c 8b e1	 mov	 r12, rcx
  0002c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_0N@OOHFADNO@keyword?9only?$AA@
  00033	85 ff		 test	 edi, edi

; 3222 :     PyObject *missing_names;
; 3223 : 
; 3224 :     /* Compute the names of the arguments that are missing. */
; 3225 :     missing_names = PyList_New(missing);

  00035	48 63 ca	 movsxd	 rcx, edx
  00038	4d 8b f1	 mov	 r14, r9
  0003b	41 8b f0	 mov	 esi, r8d
  0003e	4c 0f 45 f8	 cmovne	 r15, rax
  00042	e8 00 00 00 00	 call	 PyList_New
  00047	48 8b d8	 mov	 rbx, rax

; 3226 :     if (missing_names == NULL)

  0004a	48 85 c0	 test	 rax, rax
  0004d	0f 84 ec 00 00
	00		 je	 $LN21@missing_ar

; 3227 :         return;
; 3228 :     if (positional) {

  00053	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00058	85 ff		 test	 edi, edi
  0005a	74 0b		 je	 SHORT $LN7@missing_ar

; 3229 :         start = 0;
; 3230 :         end = co->co_argcount - defcount;

  0005c	41 8b 44 24 60	 mov	 eax, DWORD PTR [r12+96]
  00061	8b cd		 mov	 ecx, ebp
  00063	2b c6		 sub	 eax, esi

; 3231 :     }
; 3232 :     else {

  00065	eb 0c		 jmp	 SHORT $LN6@missing_ar
$LN7@missing_ar:

; 3233 :         start = co->co_argcount;

  00067	41 8b 4c 24 60	 mov	 ecx, DWORD PTR [r12+96]

; 3234 :         end = start + co->co_kwonlyargcount;

  0006c	41 8b 44 24 64	 mov	 eax, DWORD PTR [r12+100]
  00071	03 c1		 add	 eax, ecx
$LN6@missing_ar:

; 3235 :     }
; 3236 :     for (i = start; i < end; i++) {

  00073	48 63 f1	 movsxd	 rsi, ecx
  00076	4c 63 e8	 movsxd	 r13, eax
  00079	49 3b f5	 cmp	 rsi, r13
  0007c	7d 3f		 jge	 SHORT $LN25@missing_ar
  0007e	48 8d 3c f5 70
	00 00 00	 lea	 rdi, QWORD PTR [rsi*8+112]
$LL5@missing_ar:

; 3237 :         if (GETLOCAL(i) == NULL) {

  00086	49 83 7c 3e 90
	00		 cmp	 QWORD PTR [r14+rdi-112], 0
  0008c	75 23		 jne	 SHORT $LN4@missing_ar

; 3238 :             PyObject *raw = PyTuple_GET_ITEM(co->co_varnames, i);

  0008e	49 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR [r12+144]

; 3239 :             PyObject *name = PyObject_Repr(raw);

  00096	48 8b 0c 07	 mov	 rcx, QWORD PTR [rdi+rax]
  0009a	e8 00 00 00 00	 call	 PyObject_Repr

; 3240 :             if (name == NULL) {

  0009f	48 85 c0	 test	 rax, rax
  000a2	74 78		 je	 SHORT $LN23@missing_ar

; 3243 :             }
; 3244 :             PyList_SET_ITEM(missing_names, j++, name);

  000a4	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000a8	48 83 c5 08	 add	 rbp, 8
  000ac	48 89 44 29 f8	 mov	 QWORD PTR [rcx+rbp-8], rax
$LN4@missing_ar:

; 3235 :     }
; 3236 :     for (i = start; i < end; i++) {

  000b1	48 ff c6	 inc	 rsi
  000b4	48 83 c7 08	 add	 rdi, 8
  000b8	49 3b f5	 cmp	 rsi, r13
  000bb	7c c9		 jl	 SHORT $LL5@missing_ar
$LN25@missing_ar:

; 3245 :         }
; 3246 :     }
; 3247 :     assert(j == missing);
; 3248 :     format_missing(kind, co, missing_names);

  000bd	4c 8b c3	 mov	 r8, rbx
  000c0	49 8b d4	 mov	 rdx, r12
  000c3	49 8b cf	 mov	 rcx, r15
  000c6	e8 00 00 00 00	 call	 format_missing

; 3249 :     Py_DECREF(missing_names);

  000cb	e8 00 00 00 00	 call	 _Py_PXCTX
  000d0	85 c0		 test	 eax, eax
  000d2	75 66		 jne	 SHORT $LN26@missing_ar
  000d4	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000d8	a8 20		 test	 al, 32			; 00000020H
  000da	75 56		 jne	 SHORT $LN15@missing_ar
  000dc	84 c0		 test	 al, al
  000de	78 52		 js	 SHORT $LN15@missing_ar
  000e0	a8 02		 test	 al, 2
  000e2	75 56		 jne	 SHORT $LN26@missing_ar
  000e4	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000e8	75 50		 jne	 SHORT $LN26@missing_ar
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f8	4c 8b cb	 mov	 r9, rbx
  000fb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00101	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00109	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010e	48 8b cb	 mov	 rcx, rbx
  00111	85 c0		 test	 eax, eax
  00113	74 11		 je	 SHORT $LN20@missing_ar
  00115	e8 00 00 00 00	 call	 _Px_Dealloc
  0011a	eb 1e		 jmp	 SHORT $LN26@missing_ar
$LN23@missing_ar:

; 3241 :                 Py_DECREF(missing_names);

  0011c	48 8b cb	 mov	 rcx, rbx
  0011f	e8 00 00 00 00	 call	 _Py_DecRef

; 3242 :                 return;

  00124	eb 14		 jmp	 SHORT $LN26@missing_ar

; 3249 :     Py_DECREF(missing_names);

$LN20@missing_ar:
  00126	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0012a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00130	eb 08		 jmp	 SHORT $LN26@missing_ar
$LN15@missing_ar:
  00132	48 8b cb	 mov	 rcx, rbx
  00135	e8 00 00 00 00	 call	 Px_DecRef
$LN26@missing_ar:
  0013a	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
$LN21@missing_ar:

; 3250 : }

  0013f	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00144	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00149	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014d	41 5f		 pop	 r15
  0014f	41 5e		 pop	 r14
  00151	41 5c		 pop	 r12
  00153	5f		 pop	 rdi
  00154	5e		 pop	 rsi
  00155	c3		 ret	 0
missing_arguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@ ; `string'
PUBLIC	??_C@_04DBCIBANA@were?$AA@			; `string'
PUBLIC	??_C@_03GFFEDDOE@was?$AA@			; `string'
PUBLIC	??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$too_many_positional DD imagerel too_many_positional
	DD	imagerel too_many_positional+131
	DD	imagerel $unwind$too_many_positional
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$too_many_positional DD imagerel too_many_positional+131
	DD	imagerel too_many_positional+341
	DD	imagerel $chain$2$too_many_positional
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$too_many_positional DD imagerel too_many_positional+341
	DD	imagerel too_many_positional+354
	DD	imagerel $chain$3$too_many_positional
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$too_many_positional DD 021H
	DD	imagerel too_many_positional
	DD	imagerel too_many_positional+131
	DD	imagerel $unwind$too_many_positional
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$too_many_positional DD 061221H
	DD	010f412H
	DD	0f640aH
	DD	0e5405H
	DD	imagerel too_many_positional
	DD	imagerel too_many_positional+131
	DD	imagerel $unwind$too_many_positional
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$too_many_positional DD 060d01H
	DD	0e009720dH
	DD	0c005d007H
	DD	030027003H
xdata	ENDS
;	COMDAT ??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@
CONST	SEGMENT
??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@ DB '%'
	DB	'U() takes %U positional argument%s but %d%U %s given', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBCIBANA@were?$AA@
CONST	SEGMENT
??_C@_04DBCIBANA@were?$AA@ DB 'were', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GFFEDDOE@was?$AA@
CONST	SEGMENT
??_C@_03GFFEDDOE@was?$AA@ DB 'was', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@
CONST	SEGMENT
??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@ DB ' p'
	DB	'ositional argument%s (and %d keyword-only argument%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@ DB 'from %d to %d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT too_many_positional
_TEXT	SEGMENT
co$ = 112
given$ = 120
defcount$ = 128
fastlocals$ = 136
too_many_positional PROC				; COMDAT

; 3254 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3257 :     int i;
; 3258 :     PyObject *sig, *kwonly_sig;
; 3259 : 
; 3260 :     assert((co->co_flags & CO_VARARGS) == 0);
; 3261 :     /* Count missing keyword-only args. */
; 3262 :     for (i = co->co_argcount; i < co->co_argcount + co->co_kwonlyargcount; i++)

  0000d	8b 41 64	 mov	 eax, DWORD PTR [rcx+100]
  00010	45 33 e4	 xor	 r12d, r12d
  00013	44 8b ea	 mov	 r13d, edx
  00016	48 63 51 60	 movsxd	 rdx, DWORD PTR [rcx+96]
  0001a	41 8b f8	 mov	 edi, r8d
  0001d	4c 8b f1	 mov	 r14, rcx
  00020	44 8d 14 02	 lea	 r10d, DWORD PTR [rdx+rax]
  00024	41 8b dc	 mov	 ebx, r12d
  00027	41 3b d2	 cmp	 edx, r10d
  0002a	7d 1a		 jge	 SHORT $LN8@too_many_p

; 3255 :     int plural;
; 3256 :     int kwonly_given = 0;

  0002c	44 2b d2	 sub	 r10d, edx
  0002f	49 8d 04 d1	 lea	 rax, QWORD PTR [r9+rdx*8]
  00033	41 8b ca	 mov	 ecx, r10d
$LL10@too_many_p:

; 3263 :         if (GETLOCAL(i) != NULL)

  00036	4c 39 20	 cmp	 QWORD PTR [rax], r12
  00039	74 02		 je	 SHORT $LN9@too_many_p

; 3264 :             kwonly_given++;

  0003b	ff c3		 inc	 ebx
$LN9@too_many_p:

; 3257 :     int i;
; 3258 :     PyObject *sig, *kwonly_sig;
; 3259 : 
; 3260 :     assert((co->co_flags & CO_VARARGS) == 0);
; 3261 :     /* Count missing keyword-only args. */
; 3262 :     for (i = co->co_argcount; i < co->co_argcount + co->co_kwonlyargcount; i++)

  0003d	48 83 c0 08	 add	 rax, 8
  00041	48 ff c9	 dec	 rcx
  00044	75 f0		 jne	 SHORT $LL10@too_many_p
$LN8@too_many_p:

; 3265 :     if (defcount) {

  00046	45 85 c0	 test	 r8d, r8d
  00049	74 19		 je	 SHORT $LN6@too_many_p

; 3266 :         int atleast = co->co_argcount - defcount;

  0004b	44 8b c2	 mov	 r8d, edx

; 3267 :         plural = 1;
; 3268 :         sig = PyUnicode_FromFormat("from %d to %d", atleast, co->co_argcount);

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@
  00055	2b d7		 sub	 edx, edi
  00057	41 bc 01 00 00
	00		 mov	 r12d, 1
  0005d	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 3269 :     }
; 3270 :     else {

  00062	eb 13		 jmp	 SHORT $LN20@too_many_p
$LN6@too_many_p:

; 3271 :         plural = co->co_argcount != 1;

  00064	83 fa 01	 cmp	 edx, 1

; 3272 :         sig = PyUnicode_FromFormat("%d", co->co_argcount);

  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  0006e	41 0f 95 c4	 setne	 r12b
  00072	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN20@too_many_p:
  00077	48 8b f8	 mov	 rdi, rax

; 3273 :     }
; 3274 :     if (sig == NULL)

  0007a	48 85 c0	 test	 rax, rax
  0007d	0f 84 d2 00 00
	00		 je	 $LN11@too_many_p

; 3275 :         return;
; 3276 :     if (kwonly_given) {

  00083	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00088	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  0008d	4c 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r15
  00095	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@

; 3277 :         const char *format = " positional argument%s (and %d keyword-only argument%s)";
; 3278 :         kwonly_sig = PyUnicode_FromFormat(format, given != 1 ? "s" : "", kwonly_given,
; 3279 :                                               kwonly_given != 1 ? "s" : "");

  0009c	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a3	85 db		 test	 ebx, ebx
  000a5	74 31		 je	 SHORT $LN3@too_many_p
  000a7	83 fb 01	 cmp	 ebx, 1
  000aa	4c 8b ce	 mov	 r9, rsi
  000ad	48 8b d6	 mov	 rdx, rsi
  000b0	4d 0f 45 cf	 cmovne	 r9, r15
  000b4	41 83 fd 01	 cmp	 r13d, 1
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@
  000bf	49 0f 45 d7	 cmovne	 rdx, r15
  000c3	44 8b c3	 mov	 r8d, ebx
  000c6	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000cb	48 8b e8	 mov	 rbp, rax

; 3280 :         if (kwonly_sig == NULL) {

  000ce	48 85 c0	 test	 rax, rax
  000d1	75 10		 jne	 SHORT $LN1@too_many_p

; 3281 :             Py_DECREF(sig);

  000d3	48 8b cf	 mov	 rcx, rdi

; 3282 :             return;

  000d6	eb 66		 jmp	 SHORT $LN21@too_many_p
$LN3@too_many_p:

; 3283 :         }
; 3284 :     }
; 3285 :     else {
; 3286 :         /* This will not fail. */
; 3287 :         kwonly_sig = PyUnicode_FromString("");

  000d8	48 8b ce	 mov	 rcx, rsi
  000db	e8 00 00 00 00	 call	 PyUnicode_FromString
  000e0	48 8b e8	 mov	 rbp, rax
$LN1@too_many_p:

; 3288 :         assert(kwonly_sig != NULL);
; 3289 :     }
; 3290 :     PyErr_Format(PyExc_TypeError,
; 3291 :                  "%U() takes %U positional argument%s but %d%U %s given",
; 3292 :                  co->co_name,
; 3293 :                  sig,
; 3294 :                  plural ? "s" : "",
; 3295 :                  given,
; 3296 :                  kwonly_sig,
; 3297 :                  given == 1 && !kwonly_given ? "was" : "were");

  000e3	41 83 fd 01	 cmp	 r13d, 1
  000e7	75 0b		 jne	 SHORT $LN13@too_many_p
  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03GFFEDDOE@was?$AA@
  000f0	85 db		 test	 ebx, ebx
  000f2	74 07		 je	 SHORT $LN14@too_many_p
$LN13@too_many_p:
  000f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04DBCIBANA@were?$AA@
$LN14@too_many_p:
  000fb	4d 8b 86 b8 00
	00 00		 mov	 r8, QWORD PTR [r14+184]
  00102	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00109	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0010e	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00113	45 85 e4	 test	 r12d, r12d
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@
  0011d	49 0f 45 f7	 cmovne	 rsi, r15
  00121	4c 8b cf	 mov	 r9, rdi
  00124	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  00129	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0012e	e8 00 00 00 00	 call	 PyErr_Format

; 3298 :     Py_DECREF(sig);

  00133	48 8b cf	 mov	 rcx, rdi
  00136	e8 00 00 00 00	 call	 _Py_DecRef

; 3299 :     Py_DECREF(kwonly_sig);

  0013b	48 8b cd	 mov	 rcx, rbp
$LN21@too_many_p:
  0013e	e8 00 00 00 00	 call	 _Py_DecRef
  00143	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  00148	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0014d	4c 8b bc 24 80
	00 00 00	 mov	 r15, QWORD PTR [rsp+128]
$LN11@too_many_p:

; 3300 : }

  00155	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00159	41 5e		 pop	 r14
  0015b	41 5d		 pop	 r13
  0015d	41 5c		 pop	 r12
  0015f	5f		 pop	 rdi
  00160	5b		 pop	 rbx
  00161	c3		 ret	 0
too_many_positional ENDP
_TEXT	ENDS
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyObject_LookupSpecial:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$special_lookup DD imagerel special_lookup
	DD	imagerel special_lookup+79
	DD	imagerel $unwind$special_lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$special_lookup DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT special_lookup
_TEXT	SEGMENT
o$ = 48
id$ = 56
special_lookup PROC					; COMDAT

; 3523 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 3524 :     PyObject *res;
; 3525 :     res = _PyObject_LookupSpecial(o, id);

  0000d	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00012	48 8b d8	 mov	 rbx, rax

; 3526 :     if (res == NULL && !PyErr_Occurred()) {

  00015	48 85 c0	 test	 rax, rax
  00018	75 27		 jne	 SHORT $LN1@special_lo
  0001a	e8 00 00 00 00	 call	 PyErr_Occurred
  0001f	48 85 c0	 test	 rax, rax
  00022	75 1d		 jne	 SHORT $LN1@special_lo

; 3527 :         PyErr_SetObject(PyExc_AttributeError, id->object);

  00024	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0002f	e8 00 00 00 00	 call	 PyErr_SetObject

; 3528 :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 3531 : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN1@special_lo:

; 3529 :     }
; 3530 :     return res;

  00041	48 8b c3	 mov	 rax, rbx

; 3531 : }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
special_lookup ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$save_exc_state DD imagerel save_exc_state
	DD	imagerel save_exc_state+641
	DD	imagerel $unwind$save_exc_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_exc_state DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT save_exc_state
_TEXT	SEGMENT
tstate$ = 64
f$ = 72
save_exc_state PROC					; COMDAT

; 3538 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3539 :     PyObject *type, *value, *traceback;
; 3540 :     Py_XINCREF(tstate->exc_type);

  0001a	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0001e	4c 8b e2	 mov	 r12, rdx
  00021	48 8b e9	 mov	 rbp, rcx
  00024	48 85 db	 test	 rbx, rbx
  00027	74 3b		 je	 SHORT $LN23@save_exc_s
  00029	e8 00 00 00 00	 call	 _Py_PXCTX
  0002e	85 c0		 test	 eax, eax
  00030	75 32		 jne	 SHORT $LN23@save_exc_s
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00040	4c 8b cb	 mov	 r9, rbx
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 06		 jne	 SHORT $LN27@save_exc_s
  0005a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005e	74 04		 je	 SHORT $LN23@save_exc_s
$LN27@save_exc_s:
  00060	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN23@save_exc_s:

; 3541 :     Py_XINCREF(tstate->exc_value);

  00064	48 8b 5d 68	 mov	 rbx, QWORD PTR [rbp+104]
  00068	48 85 db	 test	 rbx, rbx
  0006b	74 3b		 je	 SHORT $LN19@save_exc_s
  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	75 32		 jne	 SHORT $LN19@save_exc_s
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00084	4c 8b cb	 mov	 r9, rbx
  00087	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00095	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009a	85 c0		 test	 eax, eax
  0009c	75 06		 jne	 SHORT $LN31@save_exc_s
  0009e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a2	74 04		 je	 SHORT $LN19@save_exc_s
$LN31@save_exc_s:
  000a4	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN19@save_exc_s:

; 3542 :     Py_XINCREF(tstate->exc_traceback);

  000a8	48 8b 5d 70	 mov	 rbx, QWORD PTR [rbp+112]
  000ac	48 85 db	 test	 rbx, rbx
  000af	74 3b		 je	 SHORT $LN15@save_exc_s
  000b1	e8 00 00 00 00	 call	 _Py_PXCTX
  000b6	85 c0		 test	 eax, eax
  000b8	75 32		 jne	 SHORT $LN15@save_exc_s
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c8	4c 8b cb	 mov	 r9, rbx
  000cb	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	75 06		 jne	 SHORT $LN35@save_exc_s
  000e2	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000e6	74 04		 je	 SHORT $LN15@save_exc_s
$LN35@save_exc_s:
  000e8	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN15@save_exc_s:

; 3543 :     type = f->f_exc_type;
; 3544 :     value = f->f_exc_value;
; 3545 :     traceback = f->f_exc_traceback;
; 3546 :     f->f_exc_type = tstate->exc_type;

  000ec	48 8b 45 60	 mov	 rax, QWORD PTR [rbp+96]
  000f0	49 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR [r12+176]
  000f8	49 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR [r12+184]
  00100	49 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [r12+192]
  00108	49 89 84 24 b0
	00 00 00	 mov	 QWORD PTR [r12+176], rax

; 3547 :     f->f_exc_value = tstate->exc_value;

  00110	48 8b 45 68	 mov	 rax, QWORD PTR [rbp+104]
  00114	49 89 84 24 b8
	00 00 00	 mov	 QWORD PTR [r12+184], rax

; 3548 :     f->f_exc_traceback = tstate->exc_traceback;

  0011c	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00120	49 89 84 24 c0
	00 00 00	 mov	 QWORD PTR [r12+192], rax

; 3549 :     Py_XDECREF(type);

  00128	48 85 f6	 test	 rsi, rsi
  0012b	74 65		 je	 SHORT $LN11@save_exc_s
  0012d	e8 00 00 00 00	 call	 _Py_PXCTX
  00132	85 c0		 test	 eax, eax
  00134	75 5c		 jne	 SHORT $LN11@save_exc_s
  00136	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0013a	a8 20		 test	 al, 32			; 00000020H
  0013c	75 4c		 jne	 SHORT $LN43@save_exc_s
  0013e	84 c0		 test	 al, al
  00140	78 48		 js	 SHORT $LN43@save_exc_s
  00142	a8 02		 test	 al, 2
  00144	75 4c		 jne	 SHORT $LN11@save_exc_s
  00146	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0014a	75 46		 jne	 SHORT $LN11@save_exc_s
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0015a	4c 8b ce	 mov	 r9, rsi
  0015d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00163	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00170	48 8b ce	 mov	 rcx, rsi
  00173	85 c0		 test	 eax, eax
  00175	74 07		 je	 SHORT $LN48@save_exc_s
  00177	e8 00 00 00 00	 call	 _Px_Dealloc
  0017c	eb 14		 jmp	 SHORT $LN11@save_exc_s
$LN48@save_exc_s:
  0017e	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00182	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00188	eb 08		 jmp	 SHORT $LN11@save_exc_s
$LN43@save_exc_s:
  0018a	48 8b ce	 mov	 rcx, rsi
  0018d	e8 00 00 00 00	 call	 Px_DecRef
$LN11@save_exc_s:

; 3550 :     Py_XDECREF(value);

  00192	48 85 ff	 test	 rdi, rdi
  00195	74 65		 je	 SHORT $LN7@save_exc_s
  00197	e8 00 00 00 00	 call	 _Py_PXCTX
  0019c	85 c0		 test	 eax, eax
  0019e	75 5c		 jne	 SHORT $LN7@save_exc_s
  001a0	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001a4	a8 20		 test	 al, 32			; 00000020H
  001a6	75 4c		 jne	 SHORT $LN54@save_exc_s
  001a8	84 c0		 test	 al, al
  001aa	78 48		 js	 SHORT $LN54@save_exc_s
  001ac	a8 02		 test	 al, 2
  001ae	75 4c		 jne	 SHORT $LN7@save_exc_s
  001b0	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001b4	75 46		 jne	 SHORT $LN7@save_exc_s
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001c4	4c 8b cf	 mov	 r9, rdi
  001c7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001cd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d5	e8 00 00 00 00	 call	 _PyParallel_Guard
  001da	48 8b cf	 mov	 rcx, rdi
  001dd	85 c0		 test	 eax, eax
  001df	74 07		 je	 SHORT $LN59@save_exc_s
  001e1	e8 00 00 00 00	 call	 _Px_Dealloc
  001e6	eb 14		 jmp	 SHORT $LN7@save_exc_s
$LN59@save_exc_s:
  001e8	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001ec	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001f2	eb 08		 jmp	 SHORT $LN7@save_exc_s
$LN54@save_exc_s:
  001f4	48 8b cf	 mov	 rcx, rdi
  001f7	e8 00 00 00 00	 call	 Px_DecRef
$LN7@save_exc_s:

; 3551 :     Py_XDECREF(traceback);

  001fc	48 85 db	 test	 rbx, rbx
  001ff	74 65		 je	 SHORT $LN3@save_exc_s
  00201	e8 00 00 00 00	 call	 _Py_PXCTX
  00206	85 c0		 test	 eax, eax
  00208	75 5c		 jne	 SHORT $LN3@save_exc_s
  0020a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0020e	a8 20		 test	 al, 32			; 00000020H
  00210	75 4c		 jne	 SHORT $LN65@save_exc_s
  00212	84 c0		 test	 al, al
  00214	78 48		 js	 SHORT $LN65@save_exc_s
  00216	a8 02		 test	 al, 2
  00218	75 4c		 jne	 SHORT $LN3@save_exc_s
  0021a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0021e	75 46		 jne	 SHORT $LN3@save_exc_s
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0022e	4c 8b cb	 mov	 r9, rbx
  00231	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00237	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0023f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00244	48 8b cb	 mov	 rcx, rbx
  00247	85 c0		 test	 eax, eax
  00249	74 07		 je	 SHORT $LN70@save_exc_s
  0024b	e8 00 00 00 00	 call	 _Px_Dealloc
  00250	eb 14		 jmp	 SHORT $LN3@save_exc_s
$LN70@save_exc_s:
  00252	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00256	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0025c	eb 08		 jmp	 SHORT $LN3@save_exc_s
$LN65@save_exc_s:
  0025e	48 8b cb	 mov	 rcx, rbx
  00261	e8 00 00 00 00	 call	 Px_DecRef
$LN3@save_exc_s:

; 3552 : }

  00266	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0026b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00270	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00275	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0027a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0027e	41 5c		 pop	 r12
  00280	c3		 ret	 0
save_exc_state ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT swap_exc_state
_TEXT	SEGMENT
tstate$ = 8
f$ = 16
swap_exc_state PROC					; COMDAT

; 3557 :     PyObject *tmp;
; 3558 :     tmp = tstate->exc_type;

  00000	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]

; 3559 :     tstate->exc_type = f->f_exc_type;

  00004	48 8b 82 b0 00
	00 00		 mov	 rax, QWORD PTR [rdx+176]
  0000b	4c 8b c9	 mov	 r9, rcx
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3560 :     f->f_exc_type = tmp;
; 3561 :     tmp = tstate->exc_value;
; 3562 :     tstate->exc_value = f->f_exc_value;

  00012	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00019	4c 89 82 b0 00
	00 00		 mov	 QWORD PTR [rdx+176], r8
  00020	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00024	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 3563 :     f->f_exc_value = tmp;
; 3564 :     tmp = tstate->exc_traceback;
; 3565 :     tstate->exc_traceback = f->f_exc_traceback;

  00028	48 8b 82 c0 00
	00 00		 mov	 rax, QWORD PTR [rdx+192]
  0002f	4c 89 82 b8 00
	00 00		 mov	 QWORD PTR [rdx+184], r8
  00036	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0003a	49 89 41 70	 mov	 QWORD PTR [r9+112], rax

; 3566 :     f->f_exc_traceback = tmp;

  0003e	48 89 8a c0 00
	00 00		 mov	 QWORD PTR [rdx+192], rcx

; 3567 : }

  00045	c3		 ret	 0
swap_exc_state ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$restore_and_clear_exc_state DD imagerel restore_and_clear_exc_state
	DD	imagerel restore_and_clear_exc_state+448
	DD	imagerel $unwind$restore_and_clear_exc_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$restore_and_clear_exc_state DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT restore_and_clear_exc_state
_TEXT	SEGMENT
tstate$ = 64
f$ = 72
restore_and_clear_exc_state PROC			; COMDAT

; 3571 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3572 :     PyObject *type, *value, *tb;
; 3573 :     type = tstate->exc_type;
; 3574 :     value = tstate->exc_value;
; 3575 :     tb = tstate->exc_traceback;
; 3576 :     tstate->exc_type = f->f_exc_type;

  0000f	48 8b 82 b0 00
	00 00		 mov	 rax, QWORD PTR [rdx+176]
  00016	48 8b 71 60	 mov	 rsi, QWORD PTR [rcx+96]
  0001a	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  0001e	48 8b 59 70	 mov	 rbx, QWORD PTR [rcx+112]
  00022	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3577 :     tstate->exc_value = f->f_exc_value;

  00026	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  0002d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 3578 :     tstate->exc_traceback = f->f_exc_traceback;

  00031	48 8b 82 c0 00
	00 00		 mov	 rax, QWORD PTR [rdx+192]
  00038	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 3579 :     f->f_exc_type = NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	48 89 82 b0 00
	00 00		 mov	 QWORD PTR [rdx+176], rax

; 3580 :     f->f_exc_value = NULL;

  00045	48 89 82 b8 00
	00 00		 mov	 QWORD PTR [rdx+184], rax

; 3581 :     f->f_exc_traceback = NULL;

  0004c	48 89 82 c0 00
	00 00		 mov	 QWORD PTR [rdx+192], rax

; 3582 :     Py_XDECREF(type);

  00053	48 85 f6	 test	 rsi, rsi
  00056	74 65		 je	 SHORT $LN11@restore_an
  00058	e8 00 00 00 00	 call	 _Py_PXCTX
  0005d	85 c0		 test	 eax, eax
  0005f	75 5c		 jne	 SHORT $LN11@restore_an
  00061	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00065	a8 20		 test	 al, 32			; 00000020H
  00067	75 4c		 jne	 SHORT $LN19@restore_an
  00069	84 c0		 test	 al, al
  0006b	78 48		 js	 SHORT $LN19@restore_an
  0006d	a8 02		 test	 al, 2
  0006f	75 4c		 jne	 SHORT $LN11@restore_an
  00071	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00075	75 46		 jne	 SHORT $LN11@restore_an
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00085	4c 8b ce	 mov	 r9, rsi
  00088	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00096	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009b	48 8b ce	 mov	 rcx, rsi
  0009e	85 c0		 test	 eax, eax
  000a0	74 07		 je	 SHORT $LN24@restore_an
  000a2	e8 00 00 00 00	 call	 _Px_Dealloc
  000a7	eb 14		 jmp	 SHORT $LN11@restore_an
$LN24@restore_an:
  000a9	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  000ad	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b3	eb 08		 jmp	 SHORT $LN11@restore_an
$LN19@restore_an:
  000b5	48 8b ce	 mov	 rcx, rsi
  000b8	e8 00 00 00 00	 call	 Px_DecRef
$LN11@restore_an:

; 3583 :     Py_XDECREF(value);

  000bd	48 85 ff	 test	 rdi, rdi
  000c0	74 65		 je	 SHORT $LN7@restore_an
  000c2	e8 00 00 00 00	 call	 _Py_PXCTX
  000c7	85 c0		 test	 eax, eax
  000c9	75 5c		 jne	 SHORT $LN7@restore_an
  000cb	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000cf	a8 20		 test	 al, 32			; 00000020H
  000d1	75 4c		 jne	 SHORT $LN30@restore_an
  000d3	84 c0		 test	 al, al
  000d5	78 48		 js	 SHORT $LN30@restore_an
  000d7	a8 02		 test	 al, 2
  000d9	75 4c		 jne	 SHORT $LN7@restore_an
  000db	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000df	75 46		 jne	 SHORT $LN7@restore_an
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ef	4c 8b cf	 mov	 r9, rdi
  000f2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00100	e8 00 00 00 00	 call	 _PyParallel_Guard
  00105	48 8b cf	 mov	 rcx, rdi
  00108	85 c0		 test	 eax, eax
  0010a	74 07		 je	 SHORT $LN35@restore_an
  0010c	e8 00 00 00 00	 call	 _Px_Dealloc
  00111	eb 14		 jmp	 SHORT $LN7@restore_an
$LN35@restore_an:
  00113	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00117	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0011d	eb 08		 jmp	 SHORT $LN7@restore_an
$LN30@restore_an:
  0011f	48 8b cf	 mov	 rcx, rdi
  00122	e8 00 00 00 00	 call	 Px_DecRef
$LN7@restore_an:

; 3584 :     Py_XDECREF(tb);

  00127	48 85 db	 test	 rbx, rbx
  0012a	0f 84 80 00 00
	00		 je	 $LN3@restore_an
  00130	e8 00 00 00 00	 call	 _Py_PXCTX
  00135	85 c0		 test	 eax, eax
  00137	75 77		 jne	 SHORT $LN3@restore_an
  00139	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013d	a8 20		 test	 al, 32			; 00000020H
  0013f	75 67		 jne	 SHORT $LN41@restore_an
  00141	84 c0		 test	 al, al
  00143	78 63		 js	 SHORT $LN41@restore_an
  00145	a8 02		 test	 al, 2
  00147	75 67		 jne	 SHORT $LN3@restore_an
  00149	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0014d	75 61		 jne	 SHORT $LN3@restore_an
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0015d	4c 8b cb	 mov	 r9, rbx
  00160	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00166	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00173	48 8b cb	 mov	 rcx, rbx
  00176	85 c0		 test	 eax, eax
  00178	74 14		 je	 SHORT $LN46@restore_an

; 3585 : }

  0017a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0017f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00184	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00188	5f		 pop	 rdi
  00189	e9 00 00 00 00	 jmp	 _Px_Dealloc

; 3584 :     Py_XDECREF(tb);

$LN46@restore_an:
  0018e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 3585 : }

  00192	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00197	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0019c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a0	5f		 pop	 rdi
  001a1	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]

; 3584 :     Py_XDECREF(tb);

$LN41@restore_an:
  001a8	48 8b cb	 mov	 rcx, rbx
  001ab	e8 00 00 00 00	 call	 Px_DecRef
$LN3@restore_an:

; 3585 : }

  001b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b5	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001be	5f		 pop	 rdi
  001bf	c3		 ret	 0
restore_and_clear_exc_state ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@ ; `string'
PUBLIC	??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@ ; `string'
PUBLIC	??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@ ; `string'
PUBLIC	??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@ ; `string'
EXTRN	PyException_SetCause:PROC
EXTRN	PyObject_CallObject:PROC
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_SetString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$do_raise DD imagerel do_raise
	DD	imagerel do_raise+332
	DD	imagerel $unwind$do_raise
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$do_raise DD imagerel do_raise+332
	DD	imagerel do_raise+675
	DD	imagerel $chain$0$do_raise
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_raise DD imagerel do_raise+675
	DD	imagerel do_raise+696
	DD	imagerel $chain$1$do_raise
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_raise DD 021H
	DD	imagerel do_raise
	DD	imagerel do_raise+332
	DD	imagerel $unwind$do_raise
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$do_raise DD 020521H
	DD	085405H
	DD	imagerel do_raise
	DD	imagerel do_raise+332
	DD	imagerel $unwind$do_raise
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_raise DD 060f01H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@
CONST	SEGMENT
??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@ DB 'exceptions m'
	DB	'ust derive from BaseException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@
CONST	SEGMENT
??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@ DB 'exception ca'
	DB	'uses must derive from BaseException', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@
CONST	SEGMENT
??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@ DB 'calling '
	DB	'%R should have returned an instance of BaseException, not %R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@
CONST	SEGMENT
??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@ DB 'No active '
	DB	'exception to reraise', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT do_raise
_TEXT	SEGMENT
exc$ = 64
cause$ = 72
do_raise PROC						; COMDAT

; 3592 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 3593 :     PyObject *type = NULL, *value = NULL;
; 3594 : 
; 3595 :     if (exc == NULL) {

  00015	48 85 c9	 test	 rcx, rcx
  00018	0f 85 2a 01 00
	00		 jne	 $LN48@do_raise

; 3596 :         /* Reraise */
; 3597 :         PyThreadState *tstate = PyThreadState_GET();

  0001e	e8 00 00 00 00	 call	 _Py_PXCTX
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN51@do_raise
  00027	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0002c	eb 07		 jmp	 SHORT $LN52@do_raise
$LN51@do_raise:
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN52@do_raise:

; 3598 :         PyObject *tb;
; 3599 :         type = tstate->exc_type;

  00035	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 3600 :         value = tstate->exc_value;

  00039	48 8b 70 68	 mov	 rsi, QWORD PTR [rax+104]

; 3601 :         tb = tstate->exc_traceback;

  0003d	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]

; 3602 :         if (type == Py_None) {

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00048	48 3b f8	 cmp	 rdi, rax
  0004b	75 18		 jne	 SHORT $LN46@do_raise

; 3603 :             PyErr_SetString(PyExc_RuntimeError,
; 3604 :                             "No active exception to reraise");

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@
  0005b	e8 00 00 00 00	 call	 PyErr_SetString

; 3605 :             return WHY_EXCEPTION;

  00060	e9 3e 02 00 00	 jmp	 $LN67@do_raise
$LN46@do_raise:

; 3606 :             }
; 3607 :         Py_XINCREF(type);

  00065	48 85 ff	 test	 rdi, rdi
  00068	74 3b		 je	 SHORT $LN45@do_raise
  0006a	e8 00 00 00 00	 call	 _Py_PXCTX
  0006f	85 c0		 test	 eax, eax
  00071	75 32		 jne	 SHORT $LN45@do_raise
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	4c 8b cf	 mov	 r9, rdi
  00084	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00092	e8 00 00 00 00	 call	 _PyParallel_Guard
  00097	85 c0		 test	 eax, eax
  00099	75 06		 jne	 SHORT $LN53@do_raise
  0009b	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0009f	74 04		 je	 SHORT $LN45@do_raise
$LN53@do_raise:
  000a1	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN45@do_raise:

; 3608 :         Py_XINCREF(value);

  000a5	48 85 f6	 test	 rsi, rsi
  000a8	74 3b		 je	 SHORT $LN41@do_raise
  000aa	e8 00 00 00 00	 call	 _Py_PXCTX
  000af	85 c0		 test	 eax, eax
  000b1	75 32		 jne	 SHORT $LN41@do_raise
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c1	4c 8b ce	 mov	 r9, rsi
  000c4	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ca	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d2	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d7	85 c0		 test	 eax, eax
  000d9	75 06		 jne	 SHORT $LN57@do_raise
  000db	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  000df	74 04		 je	 SHORT $LN41@do_raise
$LN57@do_raise:
  000e1	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN41@do_raise:

; 3609 :         Py_XINCREF(tb);

  000e5	48 85 db	 test	 rbx, rbx
  000e8	74 3b		 je	 SHORT $LN37@do_raise
  000ea	e8 00 00 00 00	 call	 _Py_PXCTX
  000ef	85 c0		 test	 eax, eax
  000f1	75 32		 jne	 SHORT $LN37@do_raise
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00101	4c 8b cb	 mov	 r9, rbx
  00104	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00112	e8 00 00 00 00	 call	 _PyParallel_Guard
  00117	85 c0		 test	 eax, eax
  00119	75 06		 jne	 SHORT $LN61@do_raise
  0011b	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0011f	74 04		 je	 SHORT $LN37@do_raise
$LN61@do_raise:
  00121	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN37@do_raise:

; 3610 :         PyErr_Restore(type, value, tb);

  00125	4c 8b c3	 mov	 r8, rbx
  00128	48 8b d6	 mov	 rdx, rsi
  0012b	48 8b cf	 mov	 rcx, rdi
  0012e	e8 00 00 00 00	 call	 PyErr_Restore

; 3611 :         return WHY_RERAISE;

  00133	b8 04 00 00 00	 mov	 eax, 4

; 3680 :     return WHY_EXCEPTION;
; 3681 : }

  00138	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0013d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00142	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
$LN48@do_raise:

; 3612 :     }
; 3613 : 
; 3614 :     /* We support the following forms of raise:
; 3615 :        raise
; 3616 :        raise <instance>
; 3617 :        raise <type> */
; 3618 : 
; 3619 :     if (PyExceptionClass_Check(exc)) {

  00148	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0014c	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00151	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  00157	85 c0		 test	 eax, eax
  00159	79 4e		 jns	 SHORT $LN34@do_raise
  0015b	f7 83 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rbx+256], 1073741824 ; 40000000H
  00165	74 42		 je	 SHORT $LN34@do_raise

; 3620 :         type = exc;
; 3621 :         value = PyObject_CallObject(exc, NULL);

  00167	33 d2		 xor	 edx, edx
  00169	48 8b cb	 mov	 rcx, rbx
  0016c	e8 00 00 00 00	 call	 PyObject_CallObject
  00171	48 8b f0	 mov	 rsi, rax

; 3622 :         if (value == NULL)

  00174	48 85 c0	 test	 rax, rax
  00177	0f 84 ea 00 00
	00		 je	 $LN11@do_raise

; 3623 :             goto raise_error;
; 3624 :         if (!PyExceptionInstance_Check(value)) {

  0017d	4c 8b 48 58	 mov	 r9, QWORD PTR [rax+88]
  00181	41 f7 81 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r9+256], 1073741824 ; 40000000H
  0018c	75 30		 jne	 SHORT $LN29@do_raise

; 3625 :             PyErr_Format(PyExc_TypeError,
; 3626 :                          "calling %R should have returned an instance of "
; 3627 :                          "BaseException, not %R",
; 3628 :                          type, Py_TYPE(value));

  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@
  0019c	4c 8b c3	 mov	 r8, rbx
  0019f	e8 00 00 00 00	 call	 PyErr_Format

; 3629 :             goto raise_error;

  001a4	e9 b1 00 00 00	 jmp	 $raise_error$65941
$LN34@do_raise:

; 3630 :         }
; 3631 :     }
; 3632 :     else if (PyExceptionInstance_Check(exc)) {

  001a9	0f ba e0 1e	 bt	 eax, 30
  001ad	0f 83 c3 00 00
	00		 jae	 $LN30@do_raise

; 3633 :         value = exc;

  001b3	48 8b f3	 mov	 rsi, rbx

; 3634 :         type = PyExceptionInstance_Class(exc);

  001b6	48 8b d9	 mov	 rbx, rcx

; 3635 :         Py_INCREF(type);

  001b9	e8 00 00 00 00	 call	 _Py_IncRef
$LN29@do_raise:

; 3643 :         goto raise_error;
; 3644 :     }
; 3645 : 
; 3646 :     if (cause) {

  001be	48 85 ff	 test	 rdi, rdi
  001c1	74 62		 je	 SHORT $LN28@do_raise

; 3647 :         PyObject *fixed_cause;
; 3648 :         if (PyExceptionClass_Check(cause)) {

  001c3	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001c7	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  001cd	85 c9		 test	 ecx, ecx
  001cf	79 28		 jns	 SHORT $LN27@do_raise
  001d1	f7 87 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rdi+256], 1073741824 ; 40000000H
  001db	74 1c		 je	 SHORT $LN27@do_raise

; 3649 :             fixed_cause = PyObject_CallObject(cause, NULL);

  001dd	33 d2		 xor	 edx, edx
  001df	48 8b cf	 mov	 rcx, rdi
  001e2	e8 00 00 00 00	 call	 PyObject_CallObject
  001e7	48 8b e8	 mov	 rbp, rax

; 3650 :             if (fixed_cause == NULL)

  001ea	48 85 c0	 test	 rax, rax
  001ed	74 6b		 je	 SHORT $raise_error$65941

; 3651 :                 goto raise_error;
; 3652 :             Py_DECREF(cause);

  001ef	48 8b cf	 mov	 rcx, rdi
  001f2	e8 00 00 00 00	 call	 _Py_DecRef
  001f7	eb 21		 jmp	 SHORT $LN21@do_raise
$LN27@do_raise:

; 3653 :         }
; 3654 :         else if (PyExceptionInstance_Check(cause)) {

  001f9	0f ba e1 1e	 bt	 ecx, 30
  001fd	73 05		 jae	 SHORT $LN24@do_raise

; 3655 :             fixed_cause = cause;

  001ff	48 8b ef	 mov	 rbp, rdi
  00202	eb 16		 jmp	 SHORT $LN21@do_raise
$LN24@do_raise:

; 3656 :         }
; 3657 :         else if (cause == Py_None) {

  00204	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0020b	48 3b f8	 cmp	 rdi, rax
  0020e	75 37		 jne	 SHORT $LN22@do_raise

; 3658 :             Py_DECREF(cause);

  00210	48 8b cf	 mov	 rcx, rdi
  00213	e8 00 00 00 00	 call	 _Py_DecRef

; 3659 :             fixed_cause = NULL;

  00218	33 ed		 xor	 ebp, ebp
$LN21@do_raise:

; 3665 :             goto raise_error;
; 3666 :         }
; 3667 :         PyException_SetCause(value, fixed_cause);

  0021a	48 8b d5	 mov	 rdx, rbp
  0021d	48 8b ce	 mov	 rcx, rsi
  00220	e8 00 00 00 00	 call	 PyException_SetCause
$LN28@do_raise:

; 3668 :     }
; 3669 : 
; 3670 :     PyErr_SetObject(type, value);

  00225	48 8b d6	 mov	 rdx, rsi
  00228	48 8b cb	 mov	 rcx, rbx
  0022b	e8 00 00 00 00	 call	 PyErr_SetObject

; 3671 :     /* PyErr_SetObject incref's its arguments */
; 3672 :     Py_XDECREF(value);

  00230	48 85 f6	 test	 rsi, rsi
  00233	74 08		 je	 SHORT $LN19@do_raise
  00235	48 8b ce	 mov	 rcx, rsi
  00238	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@do_raise:

; 3673 :     Py_XDECREF(type);

  0023d	48 85 db	 test	 rbx, rbx
  00240	74 5c		 je	 SHORT $LN3@do_raise
  00242	48 8b cb	 mov	 rcx, rbx

; 3674 :     return WHY_EXCEPTION;

  00245	eb 52		 jmp	 SHORT $LN66@do_raise
$LN22@do_raise:

; 3660 :         }
; 3661 :         else {
; 3662 :             PyErr_SetString(PyExc_TypeError,
; 3663 :                             "exception causes must derive from "
; 3664 :                             "BaseException");

  00247	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@
  00255	e8 00 00 00 00	 call	 PyErr_SetString
$raise_error$65941:

; 3675 : 
; 3676 : raise_error:
; 3677 :     Py_XDECREF(value);

  0025a	48 85 f6	 test	 rsi, rsi
  0025d	74 08		 je	 SHORT $LN11@do_raise
  0025f	48 8b ce	 mov	 rcx, rsi
  00262	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@do_raise:

; 3678 :     Py_XDECREF(type);

  00267	48 85 db	 test	 rbx, rbx
  0026a	74 25		 je	 SHORT $LN7@do_raise
  0026c	48 8b cb	 mov	 rcx, rbx
  0026f	e8 00 00 00 00	 call	 _Py_DecRef
  00274	eb 1b		 jmp	 SHORT $LN7@do_raise
$LN30@do_raise:

; 3636 :     }
; 3637 :     else {
; 3638 :         /* Not something you can raise.  You get an exception
; 3639 :            anyway, just not what you specified :-) */
; 3640 :         Py_DECREF(exc);

  00276	48 8b cb	 mov	 rcx, rbx
  00279	e8 00 00 00 00	 call	 _Py_DecRef

; 3641 :         PyErr_SetString(PyExc_TypeError,
; 3642 :                         "exceptions must derive from BaseException");

  0027e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00285	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@
  0028c	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@do_raise:

; 3679 :     Py_XDECREF(cause);

  00291	48 85 ff	 test	 rdi, rdi
  00294	74 08		 je	 SHORT $LN3@do_raise
  00296	48 8b cf	 mov	 rcx, rdi
$LN66@do_raise:
  00299	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@do_raise:
  0029e	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN67@do_raise:

; 3680 :     return WHY_EXCEPTION;
; 3681 : }

  002a3	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  002a8	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  002ad	b8 02 00 00 00	 mov	 eax, 2
  002b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002b6	5f		 pop	 rdi
  002b7	c3		 ret	 0
do_raise ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@ ; `string'
PUBLIC	??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@ ; `string'
PUBLIC	??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@ ; `string'
EXTRN	PySequence_List:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unpack_iterable DD imagerel unpack_iterable
	DD	imagerel unpack_iterable+664
	DD	imagerel $unwind$unpack_iterable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_iterable DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
xdata	ENDS
;	COMDAT ??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@
CONST	SEGMENT
??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@ DB 'need mo'
	DB	're than %zd values to unpack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@
CONST	SEGMENT
??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@ DB 'too many'
	DB	' values to unpack (expected %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@
CONST	SEGMENT
??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@ DB 'need'
	DB	' more than %d value%s to unpack', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT unpack_iterable
_TEXT	SEGMENT
v$ = 64
argcnt$ = 72
argcntafter$ = 80
sp$ = 88
unpack_iterable PROC					; COMDAT

; 3692 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	49 8b d9	 mov	 rbx, r9
  0001d	4d 63 e0	 movsxd	 r12, r8d
  00020	48 63 f2	 movsxd	 rsi, edx

; 3693 :     int i = 0, j = 0;

  00023	33 ff		 xor	 edi, edi

; 3694 :     Py_ssize_t ll = 0;
; 3695 :     PyObject *it;  /* iter(v) */
; 3696 :     PyObject *w;
; 3697 :     PyObject *l = NULL; /* variable list */
; 3698 : 
; 3699 :     assert(v != NULL);
; 3700 : 
; 3701 :     it = PyObject_GetIter(v);

  00025	e8 00 00 00 00	 call	 PyObject_GetIter
  0002a	48 8b e8	 mov	 rbp, rax

; 3702 :     if (it == NULL)

  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 45 02 00
	00		 je	 $LN3@unpack_ite

; 3703 :         goto Error;
; 3704 : 
; 3705 :     for (; i < argcnt; i++) {

  00036	85 f6		 test	 esi, esi
  00038	7e 20		 jle	 SHORT $LN18@unpack_ite
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL20@unpack_ite:

; 3706 :         w = PyIter_Next(it);

  00040	48 8b cd	 mov	 rcx, rbp
  00043	e8 00 00 00 00	 call	 PyIter_Next

; 3707 :         if (w == NULL) {

  00048	48 85 c0	 test	 rax, rax
  0004b	74 44		 je	 SHORT $LN49@unpack_ite

; 3713 :             }
; 3714 :             goto Error;
; 3715 :         }
; 3716 :         *--sp = w;

  0004d	48 83 eb 08	 sub	 rbx, 8
  00051	ff c7		 inc	 edi
  00053	48 89 03	 mov	 QWORD PTR [rbx], rax
  00056	3b fe		 cmp	 edi, esi
  00058	7c e6		 jl	 SHORT $LL20@unpack_ite
$LN18@unpack_ite:

; 3717 :     }
; 3718 : 
; 3719 :     if (argcntafter == -1) {
; 3720 :         /* We better have exhausted the iterator now. */
; 3721 :         w = PyIter_Next(it);

  0005a	48 8b cd	 mov	 rcx, rbp
  0005d	41 83 fc ff	 cmp	 r12d, -1
  00061	0f 85 fb 00 00
	00		 jne	 $LN15@unpack_ite
  00067	e8 00 00 00 00	 call	 PyIter_Next

; 3722 :         if (w == NULL) {

  0006c	48 85 c0	 test	 rax, rax
  0006f	0f 85 ca 00 00
	00		 jne	 $LN14@unpack_ite

; 3723 :             if (PyErr_Occurred())

  00075	e8 00 00 00 00	 call	 PyErr_Occurred
  0007a	48 85 c0	 test	 rax, rax
  0007d	75 47		 jne	 SHORT $Error$66013

; 3724 :                 goto Error;
; 3725 :             Py_DECREF(it);

  0007f	48 8b cd	 mov	 rcx, rbp
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 3726 :             return 1;

  00087	41 8d 44 24 02	 lea	 eax, QWORD PTR [r12+2]
  0008c	e9 ec 01 00 00	 jmp	 $LN22@unpack_ite
$LN49@unpack_ite:

; 3708 :             /* Iterator done, via error or exhaustion. */
; 3709 :             if (!PyErr_Occurred()) {

  00091	e8 00 00 00 00	 call	 PyErr_Occurred
  00096	48 85 c0	 test	 rax, rax
  00099	75 2b		 jne	 SHORT $Error$66013

; 3710 :                 PyErr_Format(PyExc_ValueError,
; 3711 :                     "need more than %d value%s to unpack",
; 3712 :                     i, i == 1 ? "" : "s");

  0009b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000a9	83 ff 01	 cmp	 edi, 1
  000ac	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@
  000ba	44 8b c7	 mov	 r8d, edi
  000bd	4c 0f 44 c8	 cmove	 r9, rax
  000c1	e8 00 00 00 00	 call	 PyErr_Format
$Error$66013:

; 3755 : 
; 3756 : Error:
; 3757 :     for (; i > 0; i--, sp++)

  000c6	85 ff		 test	 edi, edi
  000c8	0f 8e 48 01 00
	00		 jle	 $LN4@unpack_ite
  000ce	66 90		 npad	 2
$LL7@unpack_ite:

; 3758 :         Py_DECREF(*sp);

  000d0	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
  000d3	e8 00 00 00 00	 call	 _Py_PXCTX
  000d8	85 c0		 test	 eax, eax
  000da	0f 85 28 01 00
	00		 jne	 $LN6@unpack_ite
  000e0	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000e4	a8 20		 test	 al, 32			; 00000020H
  000e6	0f 85 14 01 00
	00		 jne	 $LN28@unpack_ite
  000ec	84 c0		 test	 al, al
  000ee	0f 88 0c 01 00
	00		 js	 $LN28@unpack_ite
  000f4	a8 02		 test	 al, 2
  000f6	0f 85 0c 01 00
	00		 jne	 $LN6@unpack_ite
  000fc	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00100	0f 85 02 01 00
	00		 jne	 $LN6@unpack_ite
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00114	4c 8b ce	 mov	 r9, rsi
  00117	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0011d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00125	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012a	48 8b ce	 mov	 rcx, rsi
  0012d	85 c0		 test	 eax, eax
  0012f	0f 84 bf 00 00
	00		 je	 $LN33@unpack_ite
  00135	e8 00 00 00 00	 call	 _Px_Dealloc
  0013a	e9 c9 00 00 00	 jmp	 $LN6@unpack_ite
$LN14@unpack_ite:

; 3727 :         }
; 3728 :         Py_DECREF(w);

  0013f	48 8b c8	 mov	 rcx, rax
  00142	e8 00 00 00 00	 call	 _Py_DecRef

; 3729 :         PyErr_Format(PyExc_ValueError, "too many values to unpack "
; 3730 :                      "(expected %d)", argcnt);

  00147	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@
  00155	44 8b c6	 mov	 r8d, esi
  00158	e8 00 00 00 00	 call	 PyErr_Format

; 3731 :         goto Error;

  0015d	e9 64 ff ff ff	 jmp	 $Error$66013
$LN15@unpack_ite:

; 3732 :     }
; 3733 : 
; 3734 :     l = PySequence_List(it);

  00162	e8 00 00 00 00	 call	 PySequence_List
  00167	4c 8b d8	 mov	 r11, rax

; 3735 :     if (l == NULL)

  0016a	48 85 c0	 test	 rax, rax
  0016d	0f 84 53 ff ff
	ff		 je	 $Error$66013

; 3736 :         goto Error;
; 3737 :     *--sp = l;

  00173	48 83 eb 08	 sub	 rbx, 8

; 3738 :     i++;

  00177	ff c7		 inc	 edi
  00179	48 89 03	 mov	 QWORD PTR [rbx], rax

; 3739 : 
; 3740 :     ll = PyList_GET_SIZE(l);

  0017c	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]

; 3741 :     if (ll < argcntafter) {

  00180	4d 3b cc	 cmp	 r9, r12
  00183	7d 1c		 jge	 SHORT $LN11@unpack_ite

; 3742 :         PyErr_Format(PyExc_ValueError, "need more than %zd values to unpack",
; 3743 :                      argcnt + ll);

  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0018c	4d 8d 04 31	 lea	 r8, QWORD PTR [r9+rsi]
  00190	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@
  00197	e8 00 00 00 00	 call	 PyErr_Format
  0019c	e9 25 ff ff ff	 jmp	 $Error$66013
$LN11@unpack_ite:

; 3760 :     return 0;

  001a1	4d 8b c4	 mov	 r8, r12
  001a4	45 85 e4	 test	 r12d, r12d
  001a7	7e 32		 jle	 SHORT $LN8@unpack_ite

; 3744 :         goto Error;
; 3745 :     }
; 3746 : 
; 3747 :     /* Pop the "after-variable" args off the list. */
; 3748 :     for (j = argcntafter; j > 0; j--, i++) {
; 3749 :         *--sp = PyList_GET_ITEM(l, ll - j);

  001a9	49 8b d1	 mov	 rdx, r9
  001ac	49 2b d4	 sub	 rdx, r12
  001af	48 c1 e2 03	 shl	 rdx, 3
  001b3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@unpack_ite:
  001c0	49 8b 43 70	 mov	 rax, QWORD PTR [r11+112]
  001c4	48 83 eb 08	 sub	 rbx, 8
  001c8	49 ff c8	 dec	 r8
  001cb	48 8b 0c 02	 mov	 rcx, QWORD PTR [rdx+rax]
  001cf	48 83 c2 08	 add	 rdx, 8
  001d3	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  001d6	4d 85 c0	 test	 r8, r8
  001d9	7f e5		 jg	 SHORT $LL10@unpack_ite
$LN8@unpack_ite:

; 3750 :     }
; 3751 :     /* Resize the list. */
; 3752 :     Py_SIZE(l) = ll - argcntafter;

  001db	4d 2b cc	 sub	 r9, r12

; 3753 :     Py_DECREF(it);

  001de	48 8b cd	 mov	 rcx, rbp
  001e1	4d 89 4b 60	 mov	 QWORD PTR [r11+96], r9
  001e5	e8 00 00 00 00	 call	 _Py_DecRef

; 3754 :     return 1;

  001ea	b8 01 00 00 00	 mov	 eax, 1
  001ef	e9 89 00 00 00	 jmp	 $LN22@unpack_ite

; 3758 :         Py_DECREF(*sp);

$LN33@unpack_ite:
  001f4	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  001f8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001fe	eb 08		 jmp	 SHORT $LN6@unpack_ite
$LN28@unpack_ite:
  00200	48 8b ce	 mov	 rcx, rsi
  00203	e8 00 00 00 00	 call	 Px_DecRef
$LN6@unpack_ite:

; 3755 : 
; 3756 : Error:
; 3757 :     for (; i > 0; i--, sp++)

  00208	ff cf		 dec	 edi
  0020a	48 83 c3 08	 add	 rbx, 8
  0020e	85 ff		 test	 edi, edi
  00210	0f 8f ba fe ff
	ff		 jg	 $LL7@unpack_ite
$LN4@unpack_ite:

; 3759 :     Py_XDECREF(it);

  00216	e8 00 00 00 00	 call	 _Py_PXCTX
  0021b	85 c0		 test	 eax, eax
  0021d	75 5c		 jne	 SHORT $LN3@unpack_ite
  0021f	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00223	a8 20		 test	 al, 32			; 00000020H
  00225	75 4c		 jne	 SHORT $LN39@unpack_ite
  00227	84 c0		 test	 al, al
  00229	78 48		 js	 SHORT $LN39@unpack_ite
  0022b	a8 02		 test	 al, 2
  0022d	75 4c		 jne	 SHORT $LN3@unpack_ite
  0022f	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00233	75 46		 jne	 SHORT $LN3@unpack_ite
  00235	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00243	4c 8b cd	 mov	 r9, rbp
  00246	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0024c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00254	e8 00 00 00 00	 call	 _PyParallel_Guard
  00259	48 8b cd	 mov	 rcx, rbp
  0025c	85 c0		 test	 eax, eax
  0025e	74 07		 je	 SHORT $LN44@unpack_ite
  00260	e8 00 00 00 00	 call	 _Px_Dealloc
  00265	eb 14		 jmp	 SHORT $LN3@unpack_ite
$LN44@unpack_ite:
  00267	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  0026b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00271	eb 08		 jmp	 SHORT $LN3@unpack_ite
$LN39@unpack_ite:
  00273	48 8b cd	 mov	 rcx, rbp
  00276	e8 00 00 00 00	 call	 Px_DecRef
$LN3@unpack_ite:

; 3760 :     return 0;

  0027b	33 c0		 xor	 eax, eax
$LN22@unpack_ite:

; 3761 : }

  0027d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00282	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00287	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0028c	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00291	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00295	41 5c		 pop	 r12
  00297	c3		 ret	 0
unpack_iterable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_trace DD imagerel call_trace
	DD	imagerel call_trace+118
	DD	imagerel $unwind$call_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_trace DD 064301H
	DD	067443H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT call_trace
_TEXT	SEGMENT
func$ = 48
obj$ = 56
frame$ = 64
what$ = 72
arg$ = 80
call_trace PROC						; COMDAT

; 3827 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3828 :     register PyThreadState *tstate = frame->f_tstate;

  0000a	49 8b 98 c8 00
	00 00		 mov	 rbx, QWORD PTR [r8+200]
  00011	45 8b d1	 mov	 r10d, r9d
  00014	49 8b c0	 mov	 rax, r8

; 3829 :     int result;
; 3830 :     if (tstate->tracing)

  00017	83 7b 20 00	 cmp	 DWORD PTR [rbx+32], 0
  0001b	4c 8b da	 mov	 r11, rdx
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	74 0d		 je	 SHORT $LN1@call_trace

; 3831 :         return 0;

  00023	33 c0		 xor	 eax, eax

; 3838 :     return result;
; 3839 : }

  00025	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5e		 pop	 rsi
  0002f	c3		 ret	 0
$LN1@call_trace:

; 3832 :     tstate->tracing++;
; 3833 :     tstate->use_tracing = 0;
; 3834 :     result = func(obj, frame, what, arg);

  00030	4c 8b 4c 24 50	 mov	 r9, QWORD PTR arg$[rsp]
  00035	45 8b c2	 mov	 r8d, r10d
  00038	48 8b d0	 mov	 rdx, rax
  0003b	49 8b cb	 mov	 rcx, r11
  0003e	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00043	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  0004b	33 ff		 xor	 edi, edi
  0004d	ff d6		 call	 rsi

; 3835 :     tstate->use_tracing = ((tstate->c_tracefunc != NULL)
; 3836 :                            || (tstate->c_profilefunc != NULL));

  0004f	48 39 7b 30	 cmp	 QWORD PTR [rbx+48], rdi
  00053	75 06		 jne	 SHORT $LN4@call_trace
  00055	48 39 7b 28	 cmp	 QWORD PTR [rbx+40], rdi
  00059	74 05		 je	 SHORT $LN5@call_trace
$LN4@call_trace:
  0005b	bf 01 00 00 00	 mov	 edi, 1
$LN5@call_trace:

; 3837 :     tstate->tracing--;

  00060	ff 4b 20	 dec	 DWORD PTR [rbx+32]
  00063	89 7b 24	 mov	 DWORD PTR [rbx+36], edi
  00066	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3838 :     return result;
; 3839 : }

  0006b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5e		 pop	 rsi
  00075	c3		 ret	 0
call_trace ENDP
_TEXT	ENDS
EXTRN	_PyCode_CheckLineNumber:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$maybe_call_line_trace DD imagerel maybe_call_line_trace
	DD	imagerel maybe_call_line_trace+191
	DD	imagerel $unwind$maybe_call_line_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$maybe_call_line_trace DD 0a1801H
	DD	0d6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT maybe_call_line_trace
_TEXT	SEGMENT
func$ = 80
obj$ = 88
bounds$66161 = 96
frame$ = 96
instr_lb$ = 104
instr_ub$ = 112
instr_prev$ = 120
maybe_call_line_trace PROC				; COMDAT

; 3864 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3865 :     int result = 0;
; 3866 :     int line = frame->f_lineno;
; 3867 : 
; 3868 :     /* If the last instruction executed isn't in the current
; 3869 :        instruction window, reset the window.
; 3870 :     */
; 3871 :     if (frame->f_lasti < *instr_lb || frame->f_lasti >= *instr_ub) {

  00018	48 8b 7c 24 70	 mov	 rdi, QWORD PTR instr_ub$[rsp]
  0001d	49 8b d8	 mov	 rbx, r8
  00020	45 8b 80 d4 00
	00 00		 mov	 r8d, DWORD PTR [r8+212]
  00027	4c 8b e2	 mov	 r12, rdx
  0002a	8b 93 d0 00 00
	00		 mov	 edx, DWORD PTR [rbx+208]
  00030	33 f6		 xor	 esi, esi
  00032	49 8b e9	 mov	 rbp, r9
  00035	4c 8b e9	 mov	 r13, rcx
  00038	41 3b 11	 cmp	 edx, DWORD PTR [r9]
  0003b	7c 04		 jl	 SHORT $LN3@maybe_call
  0003d	3b 17		 cmp	 edx, DWORD PTR [rdi]
  0003f	7c 1e		 jl	 SHORT $LN4@maybe_call
$LN3@maybe_call:

; 3872 :         PyAddrPair bounds;
; 3873 :         line = _PyCode_CheckLineNumber(frame->f_code, frame->f_lasti,
; 3874 :                                        &bounds);

  00041	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00045	4c 8d 44 24 60	 lea	 r8, QWORD PTR bounds$66161[rsp]
  0004a	e8 00 00 00 00	 call	 _PyCode_CheckLineNumber
  0004f	44 8b c0	 mov	 r8d, eax

; 3875 :         *instr_lb = bounds.ap_lower;

  00052	8b 44 24 60	 mov	 eax, DWORD PTR bounds$66161[rsp]
  00056	89 45 00	 mov	 DWORD PTR [rbp], eax

; 3876 :         *instr_ub = bounds.ap_upper;

  00059	8b 44 24 64	 mov	 eax, DWORD PTR bounds$66161[rsp+4]
  0005d	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@maybe_call:

; 3877 :     }
; 3878 :     /* If the last instruction falls at the start of a line or if
; 3879 :        it represents a jump backwards, update the frame's line
; 3880 :        number and call the trace function. */
; 3881 :     if (frame->f_lasti == *instr_lb || frame->f_lasti < *instr_prev) {

  0005f	8b 83 d0 00 00
	00		 mov	 eax, DWORD PTR [rbx+208]
  00065	48 8b 7c 24 78	 mov	 rdi, QWORD PTR instr_prev$[rsp]
  0006a	3b 45 00	 cmp	 eax, DWORD PTR [rbp]
  0006d	74 04		 je	 SHORT $LN1@maybe_call
  0006f	3b 07		 cmp	 eax, DWORD PTR [rdi]
  00071	7d 29		 jge	 SHORT $LN2@maybe_call
$LN1@maybe_call:

; 3882 :         frame->f_lineno = line;
; 3883 :         result = call_trace(func, obj, frame, PyTrace_LINE, Py_None);

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007a	44 89 83 d4 00
	00 00		 mov	 DWORD PTR [rbx+212], r8d
  00081	41 b9 02 00 00
	00		 mov	 r9d, 2
  00087	4c 8b c3	 mov	 r8, rbx
  0008a	49 8b d4	 mov	 rdx, r12
  0008d	49 8b cd	 mov	 rcx, r13
  00090	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00095	e8 00 00 00 00	 call	 call_trace
  0009a	8b f0		 mov	 esi, eax
$LN2@maybe_call:

; 3884 :     }
; 3885 :     *instr_prev = frame->f_lasti;

  0009c	8b 8b d0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+208]

; 3886 :     return result;
; 3887 : }

  000a2	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000a7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ac	8b c6		 mov	 eax, esi
  000ae	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000b3	89 0f		 mov	 DWORD PTR [rdi], ecx
  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	41 5d		 pop	 r13
  000bb	41 5c		 pop	 r12
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
maybe_call_line_trace ENDP
_TEXT	ENDS
PUBLIC	PyEval_SetProfile
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyEval_SetProfile DD imagerel $LN30
	DD	imagerel $LN30+306
	DD	imagerel $unwind$PyEval_SetProfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SetProfile DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT PyEval_SetProfile
_TEXT	SEGMENT
func$ = 64
arg$ = 72
PyEval_SetProfile PROC					; COMDAT

; 3891 : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 3892 :     PyThreadState *tstate = PyThreadState_GET();

  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	74 0a		 je	 SHORT $LN11@PyEval_Set
  00023	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00028	48 8b d8	 mov	 rbx, rax
  0002b	eb 07		 jmp	 SHORT $LN12@PyEval_Set
$LN11@PyEval_Set:
  0002d	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyThreadState_Current
$LN12@PyEval_Set:

; 3893 :     PyObject *temp = tstate->c_profileobj;

  00034	48 8b 7b 38	 mov	 rdi, QWORD PTR [rbx+56]

; 3894 :     Py_XINCREF(arg);

  00038	48 85 f6	 test	 rsi, rsi
  0003b	74 3b		 je	 SHORT $LN7@PyEval_Set
  0003d	e8 00 00 00 00	 call	 _Py_PXCTX
  00042	85 c0		 test	 eax, eax
  00044	75 32		 jne	 SHORT $LN7@PyEval_Set
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00054	4c 8b ce	 mov	 r9, rsi
  00057	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00065	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006a	85 c0		 test	 eax, eax
  0006c	75 06		 jne	 SHORT $LN15@PyEval_Set
  0006e	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  00072	74 04		 je	 SHORT $LN7@PyEval_Set
$LN15@PyEval_Set:
  00074	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN7@PyEval_Set:

; 3895 :     tstate->c_profilefunc = NULL;
; 3896 :     tstate->c_profileobj = NULL;
; 3897 :     /* Must make sure that tracing is not ignored if 'temp' is freed */
; 3898 :     tstate->use_tracing = tstate->c_tracefunc != NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0
  00082	48 c7 43 38 00
	00 00 00	 mov	 QWORD PTR [rbx+56], 0
  0008a	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  0008e	0f 95 c0	 setne	 al
  00091	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 3899 :     Py_XDECREF(temp);

  00094	48 85 ff	 test	 rdi, rdi
  00097	74 65		 je	 SHORT $LN3@PyEval_Set
  00099	e8 00 00 00 00	 call	 _Py_PXCTX
  0009e	85 c0		 test	 eax, eax
  000a0	75 5c		 jne	 SHORT $LN3@PyEval_Set
  000a2	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000a6	a8 20		 test	 al, 32			; 00000020H
  000a8	75 4c		 jne	 SHORT $LN23@PyEval_Set
  000aa	84 c0		 test	 al, al
  000ac	78 48		 js	 SHORT $LN23@PyEval_Set
  000ae	a8 02		 test	 al, 2
  000b0	75 4c		 jne	 SHORT $LN3@PyEval_Set
  000b2	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000b6	75 46		 jne	 SHORT $LN3@PyEval_Set
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c6	4c 8b cf	 mov	 r9, rdi
  000c9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000cf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000dc	48 8b cf	 mov	 rcx, rdi
  000df	85 c0		 test	 eax, eax
  000e1	74 07		 je	 SHORT $LN28@PyEval_Set
  000e3	e8 00 00 00 00	 call	 _Px_Dealloc
  000e8	eb 14		 jmp	 SHORT $LN3@PyEval_Set
$LN28@PyEval_Set:
  000ea	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000ee	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f4	eb 08		 jmp	 SHORT $LN3@PyEval_Set
$LN23@PyEval_Set:
  000f6	48 8b cf	 mov	 rcx, rdi
  000f9	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyEval_Set:

; 3900 :     tstate->c_profilefunc = func;

  000fe	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp

; 3901 :     tstate->c_profileobj = arg;

  00102	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi

; 3902 :     /* Flag that tracing or profiling is turned on */
; 3903 :     tstate->use_tracing = (func != NULL) || (tstate->c_tracefunc != NULL);

  00106	48 85 ed	 test	 rbp, rbp
  00109	75 0b		 jne	 SHORT $LN13@PyEval_Set
  0010b	48 39 6b 30	 cmp	 QWORD PTR [rbx+48], rbp
  0010f	75 05		 jne	 SHORT $LN13@PyEval_Set
  00111	89 6b 24	 mov	 DWORD PTR [rbx+36], ebp
  00114	eb 07		 jmp	 SHORT $LN14@PyEval_Set
$LN13@PyEval_Set:
  00116	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1
$LN14@PyEval_Set:

; 3904 : }

  0011d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00122	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00127	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0012c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
PyEval_SetProfile ENDP
_TEXT	ENDS
PUBLIC	PyEval_SetTrace
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyEval_SetTrace DD imagerel $LN30
	DD	imagerel $LN30+331
	DD	imagerel $unwind$PyEval_SetTrace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SetTrace DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT PyEval_SetTrace
_TEXT	SEGMENT
func$ = 64
arg$ = 72
PyEval_SetTrace PROC					; COMDAT

; 3908 : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	48 8b e9	 mov	 rbp, rcx

; 3909 :     PyThreadState *tstate = PyThreadState_GET();

  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	74 0a		 je	 SHORT $LN11@PyEval_Set@2
  00023	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00028	48 8b d8	 mov	 rbx, rax
  0002b	eb 07		 jmp	 SHORT $LN12@PyEval_Set@2
$LN11@PyEval_Set@2:
  0002d	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyThreadState_Current
$LN12@PyEval_Set@2:

; 3910 :     PyObject *temp = tstate->c_traceobj;

  00034	48 8b 7b 40	 mov	 rdi, QWORD PTR [rbx+64]

; 3911 :     _Py_TracingPossible += (func != NULL) - (tstate->c_tracefunc != NULL);

  00038	33 c9		 xor	 ecx, ecx
  0003a	48 85 ed	 test	 rbp, rbp
  0003d	0f 95 c1	 setne	 cl
  00040	33 c0		 xor	 eax, eax
  00042	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  00046	0f 95 c0	 setne	 al
  00049	2b c8		 sub	 ecx, eax
  0004b	01 0d 00 00 00
	00		 add	 DWORD PTR _Py_TracingPossible, ecx

; 3912 :     Py_XINCREF(arg);

  00051	48 85 f6	 test	 rsi, rsi
  00054	74 3b		 je	 SHORT $LN7@PyEval_Set@2
  00056	e8 00 00 00 00	 call	 _Py_PXCTX
  0005b	85 c0		 test	 eax, eax
  0005d	75 32		 jne	 SHORT $LN7@PyEval_Set@2
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0006d	4c 8b ce	 mov	 r9, rsi
  00070	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00076	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00083	85 c0		 test	 eax, eax
  00085	75 06		 jne	 SHORT $LN15@PyEval_Set@2
  00087	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  0008b	74 04		 je	 SHORT $LN7@PyEval_Set@2
$LN15@PyEval_Set@2:
  0008d	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN7@PyEval_Set@2:

; 3913 :     tstate->c_tracefunc = NULL;
; 3914 :     tstate->c_traceobj = NULL;
; 3915 :     /* Must make sure that profiling is not ignored if 'temp' is freed */
; 3916 :     tstate->use_tracing = tstate->c_profilefunc != NULL;

  00091	33 c0		 xor	 eax, eax
  00093	48 c7 43 30 00
	00 00 00	 mov	 QWORD PTR [rbx+48], 0
  0009b	48 c7 43 40 00
	00 00 00	 mov	 QWORD PTR [rbx+64], 0
  000a3	48 39 43 28	 cmp	 QWORD PTR [rbx+40], rax
  000a7	0f 95 c0	 setne	 al
  000aa	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 3917 :     Py_XDECREF(temp);

  000ad	48 85 ff	 test	 rdi, rdi
  000b0	74 65		 je	 SHORT $LN3@PyEval_Set@2
  000b2	e8 00 00 00 00	 call	 _Py_PXCTX
  000b7	85 c0		 test	 eax, eax
  000b9	75 5c		 jne	 SHORT $LN3@PyEval_Set@2
  000bb	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000bf	a8 20		 test	 al, 32			; 00000020H
  000c1	75 4c		 jne	 SHORT $LN23@PyEval_Set@2
  000c3	84 c0		 test	 al, al
  000c5	78 48		 js	 SHORT $LN23@PyEval_Set@2
  000c7	a8 02		 test	 al, 2
  000c9	75 4c		 jne	 SHORT $LN3@PyEval_Set@2
  000cb	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000cf	75 46		 jne	 SHORT $LN3@PyEval_Set@2
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000df	4c 8b cf	 mov	 r9, rdi
  000e2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f5	48 8b cf	 mov	 rcx, rdi
  000f8	85 c0		 test	 eax, eax
  000fa	74 07		 je	 SHORT $LN28@PyEval_Set@2
  000fc	e8 00 00 00 00	 call	 _Px_Dealloc
  00101	eb 14		 jmp	 SHORT $LN3@PyEval_Set@2
$LN28@PyEval_Set@2:
  00103	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00107	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0010d	eb 08		 jmp	 SHORT $LN3@PyEval_Set@2
$LN23@PyEval_Set@2:
  0010f	48 8b cf	 mov	 rcx, rdi
  00112	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyEval_Set@2:

; 3918 :     tstate->c_tracefunc = func;

  00117	48 89 6b 30	 mov	 QWORD PTR [rbx+48], rbp

; 3919 :     tstate->c_traceobj = arg;

  0011b	48 89 73 40	 mov	 QWORD PTR [rbx+64], rsi

; 3920 :     /* Flag that tracing or profiling is turned on */
; 3921 :     tstate->use_tracing = ((func != NULL)
; 3922 :                            || (tstate->c_profilefunc != NULL));

  0011f	48 85 ed	 test	 rbp, rbp
  00122	75 0b		 jne	 SHORT $LN13@PyEval_Set@2
  00124	48 39 6b 28	 cmp	 QWORD PTR [rbx+40], rbp
  00128	75 05		 jne	 SHORT $LN13@PyEval_Set@2
  0012a	89 6b 24	 mov	 DWORD PTR [rbx+36], ebp
  0012d	eb 07		 jmp	 SHORT $LN14@PyEval_Set@2
$LN13@PyEval_Set@2:
  0012f	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1
$LN14@PyEval_Set@2:

; 3923 : }

  00136	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00140	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00145	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00149	5f		 pop	 rdi
  0014a	c3		 ret	 0
PyEval_SetTrace ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetFrame
EXTRN	_PyThreadState_GetFrame:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetFrame DD imagerel $LN5
	DD	imagerel $LN5+53
	DD	imagerel $unwind$PyEval_GetFrame
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetFrame DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_GetFrame
_TEXT	SEGMENT
PyEval_GetFrame PROC					; COMDAT

; 3957 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3958 :     PyThreadState *tstate = PyThreadState_GET();

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN3@PyEval_Get@2
  0000d	e8 00 00 00 00	 call	 _PyParallel_GetThreadState

; 3959 :     return _PyThreadState_GetFrame(tstate);

  00012	48 8b c8	 mov	 rcx, rax

; 3960 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR _PyThreadState_GetFrame
$LN3@PyEval_Get@2:

; 3958 :     PyThreadState *tstate = PyThreadState_GET();

  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current

; 3959 :     return _PyThreadState_GetFrame(tstate);

  00027	48 8b c8	 mov	 rcx, rax

; 3960 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR _PyThreadState_GetFrame
PyEval_GetFrame ENDP
_TEXT	ENDS
PUBLIC	PyEval_MergeCompilerFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_MergeCompilerFlags DD imagerel $LN7
	DD	imagerel $LN7+72
	DD	imagerel $unwind$PyEval_MergeCompilerFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_MergeCompilerFlags DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_MergeCompilerFlags
_TEXT	SEGMENT
cf$ = 48
PyEval_MergeCompilerFlags PROC				; COMDAT

; 3964 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3965 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00009	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3966 :     int result = cf->cf_flags != 0;

  0000e	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00011	33 d2		 xor	 edx, edx
  00013	45 85 c0	 test	 r8d, r8d
  00016	0f 95 c2	 setne	 dl

; 3967 : 
; 3968 :     if (current_frame != NULL) {

  00019	48 85 c0	 test	 rax, rax
  0001c	74 22		 je	 SHORT $LN6@PyEval_Mer

; 3969 :         const int codeflags = current_frame->f_code->co_flags;
; 3970 :         const int compilerflags = codeflags & PyCF_MASK;

  0001e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00022	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  00026	41 81 e1 00 e0
	07 00		 and	 r9d, 516096		; 0007e000H

; 3971 :         if (compilerflags) {

  0002d	74 11		 je	 SHORT $LN6@PyEval_Mer

; 3972 :             result = 1;
; 3973 :             cf->cf_flags |= compilerflags;

  0002f	45 0b c1	 or	 r8d, r9d

; 3974 :         }
; 3975 : #if 0 /* future keyword */
; 3976 :         if (codeflags & CO_GENERATOR_ALLOWED) {
; 3977 :             result = 1;
; 3978 :             cf->cf_flags |= CO_GENERATOR_ALLOWED;
; 3979 :         }
; 3980 : #endif
; 3981 :     }
; 3982 :     return result;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	44 89 03	 mov	 DWORD PTR [rbx], r8d

; 3983 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN6@PyEval_Mer:

; 3974 :         }
; 3975 : #if 0 /* future keyword */
; 3976 :         if (codeflags & CO_GENERATOR_ALLOWED) {
; 3977 :             result = 1;
; 3978 :             cf->cf_flags |= CO_GENERATOR_ALLOWED;
; 3979 :         }
; 3980 : #endif
; 3981 :     }
; 3982 :     return result;

  00040	8b c2		 mov	 eax, edx

; 3983 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
PyEval_MergeCompilerFlags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@ ; `string'
PUBLIC	??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@ ; `string'
PUBLIC	PyEval_CallObjectWithKeywords
EXTRN	PyObject_Call:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyEval_CallObjectWithKeywords DD imagerel $LN13
	DD	imagerel $LN13+286
	DD	imagerel $unwind$PyEval_CallObjectWithKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_CallObjectWithKeywords DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@
CONST	SEGMENT
??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@ DB 'keyword lis'
	DB	't must be a dictionary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@ DB 'argument l'
	DB	'ist must be a tuple', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT PyEval_CallObjectWithKeywords
_TEXT	SEGMENT
func$ = 64
arg$ = 72
kw$ = 80
PyEval_CallObjectWithKeywords PROC			; COMDAT

; 3991 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 3992 :     PyObject *result;
; 3993 : 
; 3994 :     if (arg == NULL) {

  00018	48 85 d2	 test	 rdx, rdx
  0001b	75 23		 jne	 SHORT $LN6@PyEval_Cal

; 3995 :         arg = PyTuple_New(0);

  0001d	33 c9		 xor	 ecx, ecx
  0001f	e8 00 00 00 00	 call	 PyTuple_New
  00024	48 8b f8	 mov	 rdi, rax

; 3996 :         if (arg == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	0f 85 80 00 00
	00		 jne	 $LN10@PyEval_Cal

; 4016 :     return result;
; 4017 : }

  00030	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00035	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0003a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN6@PyEval_Cal:

; 3997 :             return NULL;
; 3998 :     }
; 3999 :     else if (!PyTuple_Check(arg)) {

  00040	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00044	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0004e	75 25		 jne	 SHORT $LN3@PyEval_Cal

; 4000 :         PyErr_SetString(PyExc_TypeError,
; 4001 :                         "argument list must be a tuple");

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@
  0005e	e8 00 00 00 00	 call	 PyErr_SetString

; 4002 :         return NULL;

  00063	33 c0		 xor	 eax, eax

; 4016 :     return result;
; 4017 : }

  00065	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0006f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
$LN3@PyEval_Cal:

; 4003 :     }
; 4004 :     else
; 4005 :         Py_INCREF(arg);

  00075	e8 00 00 00 00	 call	 _Py_PXCTX
  0007a	85 c0		 test	 eax, eax
  0007c	75 32		 jne	 SHORT $LN10@PyEval_Cal
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008c	4c 8b cf	 mov	 r9, rdi
  0008f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00095	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0009d	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a2	85 c0		 test	 eax, eax
  000a4	75 06		 jne	 SHORT $LN9@PyEval_Cal
  000a6	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000aa	74 04		 je	 SHORT $LN10@PyEval_Cal
$LN9@PyEval_Cal:
  000ac	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN10@PyEval_Cal:

; 4006 : 
; 4007 :     if (kw != NULL && !PyDict_Check(kw)) {

  000b0	48 85 db	 test	 rbx, rbx
  000b3	74 3d		 je	 SHORT $LN1@PyEval_Cal
  000b5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b9	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  000c3	75 2d		 jne	 SHORT $LN1@PyEval_Cal

; 4008 :         PyErr_SetString(PyExc_TypeError,
; 4009 :                         "keyword list must be a dictionary");

  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@
  000d3	e8 00 00 00 00	 call	 PyErr_SetString

; 4010 :         Py_DECREF(arg);

  000d8	48 8b cf	 mov	 rcx, rdi
  000db	e8 00 00 00 00	 call	 _Py_DecRef

; 4011 :         return NULL;

  000e0	33 c0		 xor	 eax, eax

; 4016 :     return result;
; 4017 : }

  000e2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ec	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f0	5f		 pop	 rdi
  000f1	c3		 ret	 0
$LN1@PyEval_Cal:

; 4012 :     }
; 4013 : 
; 4014 :     result = PyObject_Call(func, arg, kw);

  000f2	4c 8b c3	 mov	 r8, rbx
  000f5	48 8b d7	 mov	 rdx, rdi
  000f8	48 8b ce	 mov	 rcx, rsi
  000fb	e8 00 00 00 00	 call	 PyObject_Call

; 4015 :     Py_DECREF(arg);

  00100	48 8b cf	 mov	 rcx, rdi
  00103	48 8b d8	 mov	 rbx, rax
  00106	e8 00 00 00 00	 call	 _Py_DecRef

; 4016 :     return result;
; 4017 : }

  0010b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00110	48 8b c3	 mov	 rax, rbx
  00113	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00118	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011c	5f		 pop	 rdi
  0011d	c3		 ret	 0
PyEval_CallObjectWithKeywords ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetFuncName
EXTRN	PyCFunction_Type:BYTE
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyFunction_Type:BYTE
EXTRN	PyMethod_Type:BYTE
; Function compile flags: /Ogtpy
;	COMDAT PyEval_GetFuncName
_TEXT	SEGMENT
func$ = 8
PyEval_GetFuncName PROC					; COMDAT

; 4022 :     if (PyMethod_Check(func))

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMethod_Type
  00007	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000b	75 0d		 jne	 SHORT $LN6@PyEval_Get@3
  0000d	0f 1f 00	 npad	 3
$LL9@PyEval_Get@3:

; 4023 :         return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));

  00010	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00014	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00018	74 f6		 je	 SHORT $LL9@PyEval_Get@3
$LN6@PyEval_Get@3:

; 4024 :     else if (PyFunction_Check(func))

  0001a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFunction_Type
  00025	48 3b c2	 cmp	 rax, rdx
  00028	75 0c		 jne	 SHORT $LN4@PyEval_Get@3

; 4025 :         return _PyUnicode_AsString(((PyFunctionObject*)func)->func_name);

  0002a	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]

; 4030 : }

  00031	e9 00 00 00 00	 jmp	 PyUnicode_AsUTF8
$LN4@PyEval_Get@3:

; 4026 :     else if (PyCFunction_Check(func))

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyCFunction_Type
  0003d	48 3b c2	 cmp	 rax, rdx
  00040	75 08		 jne	 SHORT $LN2@PyEval_Get@3

; 4027 :         return ((PyCFunctionObject*)func)->m_ml->ml_name;

  00042	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 4030 : }

  00049	c3		 ret	 0
$LN2@PyEval_Get@3:

; 4028 :     else
; 4029 :         return func->ob_type->tp_name;

  0004a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 4030 : }

  0004e	c3		 ret	 0
PyEval_GetFuncName ENDP
_TEXT	ENDS
PUBLIC	??_C@_07IFNBHBML@?5object?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	PyEval_GetFuncDesc
;	COMDAT ??_C@_07IFNBHBML@?5object?$AA@
CONST	SEGMENT
??_C@_07IFNBHBML@?5object?$AA@ DB ' object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_GetFuncDesc
_TEXT	SEGMENT
func$ = 8
PyEval_GetFuncDesc PROC					; COMDAT

; 4035 :     if (PyMethod_Check(func))

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMethod_Type
  0000b	48 3b c1	 cmp	 rax, rcx
  0000e	75 08		 jne	 SHORT $LN6@PyEval_Get@4
$LN9@PyEval_Get@4:

; 4036 :         return "()";

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 4043 : }

  00017	c3		 ret	 0
$LN6@PyEval_Get@4:

; 4037 :     else if (PyFunction_Check(func))

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFunction_Type
  0001f	48 3b c1	 cmp	 rax, rcx

; 4038 :         return "()";

  00022	74 ec		 je	 SHORT $LN9@PyEval_Get@4

; 4039 :     else if (PyCFunction_Check(func))

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyCFunction_Type
  0002b	48 3b c1	 cmp	 rax, rcx

; 4040 :         return "()";

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00035	74 07		 je	 SHORT $LN1@PyEval_Get@4

; 4041 :     else
; 4042 :         return " object";

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IFNBHBML@?5object?$AA@
$LN1@PyEval_Get@4:

; 4043 : }

  0003e	f3 c3		 fatret	 0
PyEval_GetFuncDesc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@ ; `string'
PUBLIC	??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@ ; `string'
;	COMDAT ??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@
CONST	SEGMENT
??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@ DB '%.2'
	DB	'00s() takes exactly one argument (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@
CONST	SEGMENT
??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@ DB '%'
	DB	'.200s() takes no arguments (%d given)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT err_args
_TEXT	SEGMENT
func$ = 8
flags$ = 16
nargs$ = 24
err_args PROC						; COMDAT

; 4047 : {

  00000	45 8b c8	 mov	 r9d, r8d

; 4048 :     if (flags & METH_NOARGS)
; 4049 :         PyErr_Format(PyExc_TypeError,
; 4050 :                      "%.200s() takes no arguments (%d given)",
; 4051 :                      ((PyCFunctionObject *)func)->m_ml->ml_name,
; 4052 :                      nargs);

  00003	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000e	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00011	f6 c2 04	 test	 dl, 4
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@
  0001b	75 07		 jne	 SHORT $LN5@err_args

; 4053 :     else
; 4054 :         PyErr_Format(PyExc_TypeError,
; 4055 :                      "%.200s() takes exactly one argument (%d given)",
; 4056 :                      ((PyCFunctionObject *)func)->m_ml->ml_name,
; 4057 :                      nargs);

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@
$LN5@err_args:

; 4058 : }

  00024	e9 00 00 00 00	 jmp	 PyErr_Format
err_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@ ; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyDict_Copy:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$update_keyword_args DD imagerel update_keyword_args
	DD	imagerel update_keyword_args+76
	DD	imagerel $unwind$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$update_keyword_args DD imagerel update_keyword_args+76
	DD	imagerel update_keyword_args+384
	DD	imagerel $chain$1$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$update_keyword_args DD imagerel update_keyword_args+384
	DD	imagerel update_keyword_args+405
	DD	imagerel $chain$2$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$update_keyword_args DD imagerel update_keyword_args+405
	DD	imagerel update_keyword_args+482
	DD	imagerel $chain$3$update_keyword_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$update_keyword_args DD 040021H
	DD	0b7400H
	DD	0a6400H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+76
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$update_keyword_args DD 021H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+76
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$update_keyword_args DD 040a21H
	DD	0b740aH
	DD	0a6405H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+76
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_keyword_args DD 081401H
	DD	0d5414H
	DD	0c3414H
	DD	0e0105214H
	DD	0c00cd00eH
xdata	ENDS
;	COMDAT ??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@
CONST	SEGMENT
??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@ DB '%.200s'
	DB	'%s got multiple values for keyword argument ''%U''', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT update_keyword_args
_TEXT	SEGMENT
orig_kwdict$ = 80
nk$ = 88
pp_stack$ = 96
func$ = 104
update_keyword_args PROC				; COMDAT

; 4241 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	4d 8b f1	 mov	 r14, r9
  00017	4d 8b e8	 mov	 r13, r8
  0001a	8b ea		 mov	 ebp, edx
  0001c	48 8b d9	 mov	 rbx, rcx

; 4242 :     PyObject *kwdict = NULL;
; 4243 :     if (orig_kwdict == NULL)

  0001f	48 85 c9	 test	 rcx, rcx
  00022	75 0a		 jne	 SHORT $LN7@update_key

; 4244 :         kwdict = PyDict_New();

  00024	e8 00 00 00 00	 call	 PyDict_New
  00029	4c 8b e0	 mov	 r12, rax

; 4245 :     else {

  0002c	eb 10		 jmp	 SHORT $LN6@update_key
$LN7@update_key:

; 4246 :         kwdict = PyDict_Copy(orig_kwdict);

  0002e	e8 00 00 00 00	 call	 PyDict_Copy

; 4247 :         Py_DECREF(orig_kwdict);

  00033	48 8b cb	 mov	 rcx, rbx
  00036	4c 8b e0	 mov	 r12, rax
  00039	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@update_key:

; 4248 :     }
; 4249 :     if (kwdict == NULL)

  0003e	4d 85 e4	 test	 r12, r12
  00041	75 07		 jne	 SHORT $LN32@update_key

; 4250 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 36 01 00 00	 jmp	 $LN8@update_key
$LN32@update_key:

; 4251 :     while (--nk >= 0) {

  0004a	ff cd		 dec	 ebp
  0004c	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00051	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00056	0f 88 17 01 00
	00		 js	 $LN3@update_key
  0005c	0f 1f 40 00	 npad	 4
$LL4@update_key:

; 4252 :         int err;
; 4253 :         PyObject *value = EXT_POP(*pp_stack);

  00060	49 83 45 00 f8	 add	 QWORD PTR [r13], -8
  00065	49 8b 45 00	 mov	 rax, QWORD PTR [r13]

; 4254 :         PyObject *key = EXT_POP(*pp_stack);
; 4255 :         if (PyDict_GetItem(kwdict, key) != NULL) {

  00069	49 8b cc	 mov	 rcx, r12
  0006c	48 8b 30	 mov	 rsi, QWORD PTR [rax]
  0006f	48 83 c0 f8	 add	 rax, -8
  00073	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00077	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  0007a	48 8b d7	 mov	 rdx, rdi
  0007d	e8 00 00 00 00	 call	 PyDict_GetItem
  00082	48 85 c0	 test	 rax, rax
  00085	0f 85 0a 01 00
	00		 jne	 $LN33@update_key

; 4266 :         }
; 4267 :         err = PyDict_SetItem(kwdict, key, value);

  0008b	4c 8b c6	 mov	 r8, rsi
  0008e	48 8b d7	 mov	 rdx, rdi
  00091	49 8b cc	 mov	 rcx, r12
  00094	e8 00 00 00 00	 call	 PyDict_SetItem
  00099	8b d8		 mov	 ebx, eax

; 4268 :         Py_DECREF(key);

  0009b	e8 00 00 00 00	 call	 _Py_PXCTX
  000a0	85 c0		 test	 eax, eax
  000a2	75 5e		 jne	 SHORT $LN20@update_key
  000a4	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000a8	f6 c1 20	 test	 cl, 32			; 00000020H
  000ab	75 4d		 jne	 SHORT $LN14@update_key
  000ad	84 c9		 test	 cl, cl
  000af	78 49		 js	 SHORT $LN14@update_key
  000b1	f6 c1 02	 test	 cl, 2
  000b4	75 4c		 jne	 SHORT $LN20@update_key
  000b6	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000ba	75 46		 jne	 SHORT $LN20@update_key
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ca	4c 8b cf	 mov	 r9, rdi
  000cd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000d3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000db	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e0	48 8b cf	 mov	 rcx, rdi
  000e3	85 c0		 test	 eax, eax
  000e5	74 07		 je	 SHORT $LN19@update_key
  000e7	e8 00 00 00 00	 call	 _Px_Dealloc
  000ec	eb 14		 jmp	 SHORT $LN20@update_key
$LN19@update_key:
  000ee	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000f2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000f8	eb 08		 jmp	 SHORT $LN20@update_key
$LN14@update_key:
  000fa	48 8b cf	 mov	 rcx, rdi
  000fd	e8 00 00 00 00	 call	 Px_DecRef
$LN20@update_key:

; 4269 :         Py_DECREF(value);

  00102	e8 00 00 00 00	 call	 _Py_PXCTX
  00107	85 c0		 test	 eax, eax
  00109	75 5c		 jne	 SHORT $LN31@update_key
  0010b	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0010f	a8 20		 test	 al, 32			; 00000020H
  00111	75 4c		 jne	 SHORT $LN25@update_key
  00113	84 c0		 test	 al, al
  00115	78 48		 js	 SHORT $LN25@update_key
  00117	a8 02		 test	 al, 2
  00119	75 4c		 jne	 SHORT $LN31@update_key
  0011b	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0011f	75 46		 jne	 SHORT $LN31@update_key
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012f	4c 8b ce	 mov	 r9, rsi
  00132	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00138	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00140	e8 00 00 00 00	 call	 _PyParallel_Guard
  00145	48 8b ce	 mov	 rcx, rsi
  00148	85 c0		 test	 eax, eax
  0014a	74 07		 je	 SHORT $LN30@update_key
  0014c	e8 00 00 00 00	 call	 _Px_Dealloc
  00151	eb 14		 jmp	 SHORT $LN31@update_key
$LN30@update_key:
  00153	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00157	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015d	eb 08		 jmp	 SHORT $LN31@update_key
$LN25@update_key:
  0015f	48 8b ce	 mov	 rcx, rsi
  00162	e8 00 00 00 00	 call	 Px_DecRef
$LN31@update_key:

; 4270 :         if (err) {

  00167	85 db		 test	 ebx, ebx
  00169	75 6b		 jne	 SHORT $LN34@update_key

; 4251 :     while (--nk >= 0) {

  0016b	ff cd		 dec	 ebp
  0016d	0f 89 ed fe ff
	ff		 jns	 $LL4@update_key
$LN3@update_key:

; 4271 :             Py_DECREF(kwdict);
; 4272 :             return NULL;
; 4273 :         }
; 4274 :     }
; 4275 :     return kwdict;

  00173	49 8b c4	 mov	 rax, r12
$LN36@update_key:
  00176	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0017b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
$LN8@update_key:

; 4276 : }

  00180	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00185	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0018a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0018e	41 5e		 pop	 r14
  00190	41 5d		 pop	 r13
  00192	41 5c		 pop	 r12
  00194	c3		 ret	 0
$LN33@update_key:

; 4256 :             PyErr_Format(PyExc_TypeError,
; 4257 :                          "%.200s%s got multiple values "
; 4258 :                          "for keyword argument '%U'",
; 4259 :                          PyEval_GetFuncName(func),
; 4260 :                          PyEval_GetFuncDesc(func),
; 4261 :                          key);

  00195	49 8b ce	 mov	 rcx, r14
  00198	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  0019d	49 8b ce	 mov	 rcx, r14
  001a0	48 8b d8	 mov	 rbx, rax
  001a3	e8 00 00 00 00	 call	 PyEval_GetFuncName
  001a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@
  001b6	4c 8b cb	 mov	 r9, rbx
  001b9	4c 8b c0	 mov	 r8, rax
  001bc	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  001c1	e8 00 00 00 00	 call	 PyErr_Format

; 4262 :             Py_DECREF(key);

  001c6	48 8b cf	 mov	 rcx, rdi
  001c9	e8 00 00 00 00	 call	 _Py_DecRef

; 4263 :             Py_DECREF(value);

  001ce	48 8b ce	 mov	 rcx, rsi
  001d1	e8 00 00 00 00	 call	 _Py_DecRef
$LN34@update_key:

; 4264 :             Py_DECREF(kwdict);

  001d6	49 8b cc	 mov	 rcx, r12
  001d9	e8 00 00 00 00	 call	 _Py_DecRef

; 4265 :             return NULL;

  001de	33 c0		 xor	 eax, eax
  001e0	eb 94		 jmp	 SHORT $LN36@update_key
update_keyword_args ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$update_star_args DD imagerel update_star_args
	DD	imagerel update_star_args+60
	DD	imagerel $unwind$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$update_star_args DD imagerel update_star_args+60
	DD	imagerel update_star_args+73
	DD	imagerel $chain$0$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$update_star_args DD imagerel update_star_args+73
	DD	imagerel update_star_args+177
	DD	imagerel $chain$1$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$update_star_args DD imagerel update_star_args+177
	DD	imagerel update_star_args+182
	DD	imagerel $chain$2$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$update_star_args DD imagerel update_star_args+182
	DD	imagerel update_star_args+255
	DD	imagerel $chain$3$update_star_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$update_star_args DD 021H
	DD	imagerel update_star_args
	DD	imagerel update_star_args+60
	DD	imagerel $unwind$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$update_star_args DD 021H
	DD	imagerel update_star_args+60
	DD	imagerel update_star_args+73
	DD	imagerel $chain$0$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$update_star_args DD 020521H
	DD	0b6405H
	DD	imagerel update_star_args+60
	DD	imagerel update_star_args+73
	DD	imagerel $chain$0$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$update_star_args DD 020521H
	DD	0a5405H
	DD	imagerel update_star_args
	DD	imagerel update_star_args+60
	DD	imagerel $unwind$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_star_args DD 081401H
	DD	0d7414H
	DD	0c3414H
	DD	0e0105214H
	DD	0c00cd00eH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT update_star_args
_TEXT	SEGMENT
nstack$ = 80
nstar$ = 88
stararg$ = 96
pp_stack$ = 104
update_star_args PROC					; COMDAT

; 4281 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	4c 63 f1	 movsxd	 r14, ecx
  00017	48 63 da	 movsxd	 rbx, edx
  0001a	49 8b f9	 mov	 rdi, r9

; 4282 :     PyObject *callargs, *w;
; 4283 : 
; 4284 :     callargs = PyTuple_New(nstack + nstar);

  0001d	41 8d 04 1e	 lea	 eax, DWORD PTR [r14+rbx]
  00021	4d 8b e8	 mov	 r13, r8
  00024	48 63 c8	 movsxd	 rcx, eax
  00027	e8 00 00 00 00	 call	 PyTuple_New
  0002c	4c 8b e0	 mov	 r12, rax

; 4285 :     if (callargs == NULL) {

  0002f	48 85 c0	 test	 rax, rax
  00032	0f 84 b2 00 00
	00		 je	 $LN8@update_sta
$LN7@update_sta:

; 4286 :         return NULL;
; 4287 :     }
; 4288 :     if (nstar) {

  00038	85 db		 test	 ebx, ebx
  0003a	74 7a		 je	 SHORT $LN15@update_sta

; 4289 :         int i;
; 4290 :         for (i = 0; i < nstar; i++) {

  0003c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00041	48 8b eb	 mov	 rbp, rbx
  00044	7e 6b		 jle	 SHORT $LN18@update_sta

; 4291 :             PyObject *a = PyTuple_GET_ITEM(stararg, i);

  00046	49 8b c6	 mov	 rax, r14
  00049	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0004e	4b 8d 74 f4 70	 lea	 rsi, QWORD PTR [r12+r14*8+112]
  00053	48 c1 e0 03	 shl	 rax, 3
  00057	4c 2b e8	 sub	 r13, rax
  0005a	4d 2b ec	 sub	 r13, r12
  0005d	0f 1f 00	 npad	 3
$LL5@update_sta:
  00060	49 8b 5c 35 00	 mov	 rbx, QWORD PTR [r13+rsi]

; 4292 :             Py_INCREF(a);

  00065	e8 00 00 00 00	 call	 _Py_PXCTX
  0006a	85 c0		 test	 eax, eax
  0006c	75 32		 jne	 SHORT $LN11@update_sta
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007c	4c 8b cb	 mov	 r9, rbx
  0007f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00092	85 c0		 test	 eax, eax
  00094	75 06		 jne	 SHORT $LN10@update_sta
  00096	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0009a	74 04		 je	 SHORT $LN11@update_sta
$LN10@update_sta:
  0009c	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN11@update_sta:

; 4293 :             PyTuple_SET_ITEM(callargs, nstack + i, a);

  000a0	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  000a3	48 83 c6 08	 add	 rsi, 8
  000a7	48 ff cd	 dec	 rbp
  000aa	75 b4		 jne	 SHORT $LL5@update_sta
  000ac	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
$LN18@update_sta:
  000b1	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
$LN15@update_sta:

; 4294 :         }
; 4295 :     }
; 4296 :     while (--nstack >= 0) {

  000b6	41 8d 46 ff	 lea	 eax, DWORD PTR [r14-1]
  000ba	48 63 d0	 movsxd	 rdx, eax
  000bd	85 c0		 test	 eax, eax
  000bf	78 26		 js	 SHORT $LN1@update_sta
  000c1	4d 8d 44 d4 70	 lea	 r8, QWORD PTR [r12+rdx*8+112]
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@update_sta:

; 4297 :         w = EXT_POP(*pp_stack);

  000d0	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  000d4	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000d7	49 83 e8 08	 sub	 r8, 8
  000db	48 ff ca	 dec	 rdx

; 4298 :         PyTuple_SET_ITEM(callargs, nstack, w);

  000de	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e1	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
  000e5	79 e9		 jns	 SHORT $LL2@update_sta
$LN1@update_sta:

; 4299 :     }
; 4300 :     return callargs;

  000e7	49 8b c4	 mov	 rax, r12
$LN8@update_sta:

; 4301 : }

  000ea	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ef	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000f4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f8	41 5e		 pop	 r14
  000fa	41 5d		 pop	 r13
  000fc	41 5c		 pop	 r12
  000fe	c3		 ret	 0
update_star_args ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_args DD imagerel load_args
	DD	imagerel load_args+101
	DD	imagerel $unwind$load_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_args DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT load_args
_TEXT	SEGMENT
pp_stack$ = 48
na$ = 56
load_args PROC						; COMDAT

; 4305 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx

; 4306 :     PyObject *args = PyTuple_New(na);

  00010	48 8b cf	 mov	 rcx, rdi
  00013	e8 00 00 00 00	 call	 PyTuple_New
  00018	4c 8b d8	 mov	 r11, rax

; 4307 :     PyObject *w;
; 4308 : 
; 4309 :     if (args == NULL)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN6@load_args

; 4316 : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN6@load_args:

; 4310 :         return NULL;
; 4311 :     while (--na >= 0) {

  0002b	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
  0002e	48 63 d0	 movsxd	 rdx, eax
  00031	85 c0		 test	 eax, eax
  00033	78 22		 js	 SHORT $LN1@load_args
  00035	4d 8d 44 d3 70	 lea	 r8, QWORD PTR [r11+rdx*8+112]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@load_args:

; 4312 :         w = EXT_POP(*pp_stack);

  00040	48 83 03 f8	 add	 QWORD PTR [rbx], -8
  00044	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00047	49 83 e8 08	 sub	 r8, 8
  0004b	48 ff ca	 dec	 rdx

; 4313 :         PyTuple_SET_ITEM(args, na, w);

  0004e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00051	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
  00055	79 e9		 jns	 SHORT $LL2@load_args
$LN1@load_args:

; 4314 :     }
; 4315 :     return args;

  00057	49 8b c3	 mov	 rax, r11

; 4316 : }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
load_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@ ; `string'
PUBLIC	_PyEval_SliceIndex
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyEval_SliceIndex DD imagerel $LN8
	DD	imagerel $LN8+121
	DD	imagerel $unwind$_PyEval_SliceIndex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_SliceIndex DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@
CONST	SEGMENT
??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@ DB 'slice indic'
	DB	'es must be integers or None or have an __index__ method', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyEval_SliceIndex
_TEXT	SEGMENT
v$ = 48
pi$ = 56
_PyEval_SliceIndex PROC					; COMDAT

; 4469 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 4470 :     if (v != NULL) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 37		 je	 SHORT $LN4@PyEval_Sli

; 4471 :         Py_ssize_t x;
; 4472 :         if (PyIndex_Check(v)) {

  00012	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00016	4c 8b 80 b8 00
	00 00		 mov	 r8, QWORD PTR [rax+184]
  0001d	4d 85 c0	 test	 r8, r8
  00020	74 37		 je	 SHORT $LN3@PyEval_Sli
  00022	49 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [r8+264], 0
  0002a	74 2d		 je	 SHORT $LN3@PyEval_Sli

; 4473 :             x = PyNumber_AsSsize_t(v, NULL);

  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00033	48 8b d8	 mov	 rbx, rax

; 4474 :             if (x == -1 && PyErr_Occurred())

  00036	48 83 f8 ff	 cmp	 rax, -1
  0003a	75 0a		 jne	 SHORT $LN2@PyEval_Sli
  0003c	e8 00 00 00 00	 call	 PyErr_Occurred
  00041	48 85 c0	 test	 rax, rax

; 4475 :                 return 0;

  00044	75 26		 jne	 SHORT $LN7@PyEval_Sli
$LN2@PyEval_Sli:

; 4482 :         }
; 4483 :         *pi = x;

  00046	48 89 1f	 mov	 QWORD PTR [rdi], rbx
$LN4@PyEval_Sli:

; 4484 :     }
; 4485 :     return 1;

  00049	b8 01 00 00 00	 mov	 eax, 1

; 4486 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN3@PyEval_Sli:

; 4476 :         }
; 4477 :         else {
; 4478 :             PyErr_SetString(PyExc_TypeError,
; 4479 :                             "slice indices must be integers or "
; 4480 :                             "None or have an __index__ method");

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@
  00067	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@PyEval_Sli:

; 4481 :             return 0;

  0006c	33 c0		 xor	 eax, eax

; 4486 : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
_PyEval_SliceIndex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@ ; `string'
EXTRN	PySequence_Contains:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	PyErr_GivenExceptionMatches:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyObject_RichCompare:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$cmp_outcome DD imagerel cmp_outcome
	DD	imagerel cmp_outcome+405
	DD	imagerel $unwind$cmp_outcome
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_outcome DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@
CONST	SEGMENT
??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@ DB 'catching cl'
	DB	'asses that do not inherit from BaseException is not allowed', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT cmp_outcome
_TEXT	SEGMENT
op$ = 64
v$ = 72
w$ = 80
cmp_outcome PROC					; COMDAT

; 4493 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4494 :     int res = 0;
; 4495 :     switch (op) {

  0000a	44 8b c9	 mov	 r9d, ecx
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b fa	 mov	 rdi, rdx
  00013	41 83 e9 06	 sub	 r9d, 6
  00017	0f 84 5f 01 00
	00		 je	 $LN15@cmp_outcom
  0001d	41 ff c9	 dec	 r9d
  00020	0f 84 40 01 00
	00		 je	 $LN13@cmp_outcom
  00026	41 ff c9	 dec	 r9d
  00029	0f 84 d2 00 00
	00		 je	 $LN17@cmp_outcom
  0002f	41 ff c9	 dec	 r9d
  00032	0f 84 bf 00 00
	00		 je	 $LN16@cmp_outcom
  00038	41 ff c9	 dec	 r9d
  0003b	74 18		 je	 SHORT $LN11@cmp_outcom

; 4535 :     default:
; 4536 :         return PyObject_RichCompare(v, w, op);

  0003d	44 8b c1	 mov	 r8d, ecx
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cf	 mov	 rcx, rdi

; 4541 : }

  00046	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	e9 00 00 00 00	 jmp	 PyObject_RichCompare
$LN11@cmp_outcom:

; 4513 :     case PyCmp_EXC_MATCH:
; 4514 :         if (PyTuple_Check(w)) {

  00055	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00059	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0005f	0f ba e1 1a	 bt	 ecx, 26
  00063	73 74		 jae	 SHORT $LN10@cmp_outcom

; 4515 :             Py_ssize_t i, length;
; 4516 :             length = PyTuple_Size(w);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 PyTuple_Size
  0006d	4c 8b d8	 mov	 r11, rax

; 4517 :             for (i = 0; i < length; i += 1) {

  00070	33 c0		 xor	 eax, eax
  00072	4d 85 db	 test	 r11, r11
  00075	7e 73		 jle	 SHORT $LN3@cmp_outcom

; 4515 :             Py_ssize_t i, length;
; 4516 :             length = PyTuple_Size(w);

  00077	48 8d 53 70	 lea	 rdx, QWORD PTR [rbx+112]
  0007b	0f 1f 44 00 00	 npad	 5
$LL9@cmp_outcom:

; 4518 :                 PyObject *exc = PyTuple_GET_ITEM(w, i);

  00080	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 4519 :                 if (!PyExceptionClass_Check(exc)) {

  00083	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  00087	f7 81 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rcx+256], -2147483648 ; ffffffff80000000H
  00091	74 26		 je	 SHORT $LN27@cmp_outcom
  00093	41 f7 80 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r8+256], 1073741824 ; 40000000H
  0009e	74 19		 je	 SHORT $LN27@cmp_outcom

; 4517 :             for (i = 0; i < length; i += 1) {

  000a0	48 ff c0	 inc	 rax
  000a3	48 83 c2 08	 add	 rdx, 8
  000a7	49 3b c3	 cmp	 rax, r11
  000aa	7c d4		 jl	 SHORT $LL9@cmp_outcom

; 4528 :                 PyErr_SetString(PyExc_TypeError,
; 4529 :                                 CANNOT_CATCH_MSG);
; 4530 :                 return NULL;
; 4531 :             }
; 4532 :         }
; 4533 :         res = PyErr_GivenExceptionMatches(v, w);

  000ac	48 8b d3	 mov	 rdx, rbx
  000af	48 8b cf	 mov	 rcx, rdi
  000b2	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches

; 4534 :         break;

  000b7	eb 50		 jmp	 SHORT $LN14@cmp_outcom
$LN27@cmp_outcom:

; 4520 :                     PyErr_SetString(PyExc_TypeError,
; 4521 :                                     CANNOT_CATCH_MSG);

  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@
  000c7	e8 00 00 00 00	 call	 PyErr_SetString

; 4522 :                     return NULL;

  000cc	33 c0		 xor	 eax, eax

; 4541 : }

  000ce	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
$LN10@cmp_outcom:

; 4523 :                 }
; 4524 :             }
; 4525 :         }
; 4526 :         else {
; 4527 :             if (!PyExceptionClass_Check(w)) {

  000d9	85 c9		 test	 ecx, ecx
  000db	79 dc		 jns	 SHORT $LN27@cmp_outcom
  000dd	41 f7 80 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r8+256], 1073741824 ; 40000000H
  000e8	74 cf		 je	 SHORT $LN27@cmp_outcom
$LN3@cmp_outcom:

; 4528 :                 PyErr_SetString(PyExc_TypeError,
; 4529 :                                 CANNOT_CATCH_MSG);
; 4530 :                 return NULL;
; 4531 :             }
; 4532 :         }
; 4533 :         res = PyErr_GivenExceptionMatches(v, w);

  000ea	48 8b d3	 mov	 rdx, rbx
  000ed	48 8b cf	 mov	 rcx, rdi
  000f0	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches

; 4534 :         break;

  000f5	eb 12		 jmp	 SHORT $LN14@cmp_outcom
$LN16@cmp_outcom:

; 4498 :         break;
; 4499 :     case PyCmp_IS_NOT:
; 4500 :         res = (v != w);

  000f7	33 c0		 xor	 eax, eax
  000f9	48 3b d3	 cmp	 rdx, rbx
  000fc	0f 95 c0	 setne	 al

; 4501 :         break;

  000ff	eb 08		 jmp	 SHORT $LN14@cmp_outcom
$LN17@cmp_outcom:

; 4496 :     case PyCmp_IS:
; 4497 :         res = (v == w);

  00101	33 c0		 xor	 eax, eax
  00103	48 3b d3	 cmp	 rdx, rbx
$LN29@cmp_outcom:

; 4511 :         res = !res;

  00106	0f 94 c0	 sete	 al
$LN14@cmp_outcom:

; 4537 :     }
; 4538 :     v = res ? Py_True : Py_False;

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00110	85 c0		 test	 eax, eax
  00112	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00119	48 0f 45 d9	 cmovne	 rbx, rcx

; 4539 :     Py_INCREF(v);

  0011d	e8 00 00 00 00	 call	 _Py_PXCTX
  00122	85 c0		 test	 eax, eax
  00124	75 32		 jne	 SHORT $LN23@cmp_outcom
  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00134	4c 8b cb	 mov	 r9, rbx
  00137	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0013d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00145	e8 00 00 00 00	 call	 _PyParallel_Guard
  0014a	85 c0		 test	 eax, eax
  0014c	75 06		 jne	 SHORT $LN22@cmp_outcom
  0014e	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00152	74 04		 je	 SHORT $LN23@cmp_outcom
$LN22@cmp_outcom:
  00154	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN23@cmp_outcom:

; 4540 :     return v;

  00158	48 8b c3	 mov	 rax, rbx

; 4541 : }

  0015b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00160	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00164	5f		 pop	 rdi
  00165	c3		 ret	 0
$LN13@cmp_outcom:

; 4506 :         break;
; 4507 :     case PyCmp_NOT_IN:
; 4508 :         res = PySequence_Contains(w, v);

  00166	48 8b cb	 mov	 rcx, rbx
  00169	e8 00 00 00 00	 call	 PySequence_Contains
  0016e	44 8b d8	 mov	 r11d, eax

; 4509 :         if (res < 0)

  00171	85 c0		 test	 eax, eax

; 4510 :             return NULL;

  00173	78 13		 js	 SHORT $LN30@cmp_outcom

; 4511 :         res = !res;

  00175	33 c0		 xor	 eax, eax
  00177	45 85 db	 test	 r11d, r11d

; 4512 :         break;

  0017a	eb 8a		 jmp	 SHORT $LN29@cmp_outcom
$LN15@cmp_outcom:

; 4502 :     case PyCmp_IN:
; 4503 :         res = PySequence_Contains(w, v);

  0017c	48 8b cb	 mov	 rcx, rbx
  0017f	e8 00 00 00 00	 call	 PySequence_Contains

; 4504 :         if (res < 0)

  00184	85 c0		 test	 eax, eax
  00186	79 81		 jns	 SHORT $LN14@cmp_outcom
$LN30@cmp_outcom:

; 4505 :             return NULL;

  00188	33 c0		 xor	 eax, eax

; 4541 : }

  0018a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0018f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00193	5f		 pop	 rdi
  00194	c3		 ret	 0
cmp_outcome ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@ ; `string'
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyObject_GetAttr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$import_from DD imagerel import_from
	DD	imagerel import_from+78
	DD	imagerel $unwind$import_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$import_from DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@
CONST	SEGMENT
??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@ DB 'cannot import nam'
	DB	'e %S', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT import_from
_TEXT	SEGMENT
v$ = 48
name$ = 56
import_from PROC					; COMDAT

; 4545 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 4546 :     PyObject *x;
; 4547 : 
; 4548 :     x = PyObject_GetAttr(v, name);

  0000d	e8 00 00 00 00	 call	 PyObject_GetAttr
  00012	48 8b d8	 mov	 rbx, rax

; 4549 :     if (x == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {

  00015	48 85 c0	 test	 rax, rax
  00018	75 29		 jne	 SHORT $LN1@import_fro
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00021	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00026	85 c0		 test	 eax, eax
  00028	74 16		 je	 SHORT $LN5@import_fro

; 4550 :         PyErr_Format(PyExc_ImportError, "cannot import name %S", name);

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@
  00038	4c 8b c7	 mov	 r8, rdi
  0003b	e8 00 00 00 00	 call	 PyErr_Format
$LN5@import_fro:

; 4551 :     }
; 4552 :     return x;

  00040	48 8b c3	 mov	 rax, rbx
$LN1@import_fro:

; 4553 : }

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
import_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@ ; `string'
EXTRN	PyExc_IndexError:QWORD
EXTRN	PyObject_SetItem:PROC
EXTRN	PyDict_Type:BYTE
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$import_all_from DD imagerel import_all_from
	DD	imagerel import_all_from+217
	DD	imagerel $unwind$import_all_from
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$import_all_from DD imagerel import_all_from+217
	DD	imagerel import_all_from+813
	DD	imagerel $chain$1$import_all_from
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$import_all_from DD imagerel import_all_from+813
	DD	imagerel import_all_from+930
	DD	imagerel $chain$2$import_all_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$import_all_from DD 021H
	DD	imagerel import_all_from
	DD	imagerel import_all_from+217
	DD	imagerel $unwind$import_all_from
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$import_all_from DD 020521H
	DD	0df405H
	DD	imagerel import_all_from
	DD	imagerel import_all_from+217
	DD	imagerel $unwind$import_all_from
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$import_all_from DD 0ad401H
	DD	0c54d4H
	DD	0e3411H
	DD	0e00d5211H
	DD	0c009d00bH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@
CONST	SEGMENT
??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@ DB 'from-im'
	DB	'port-* object has no __dict__ and no __all__', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT import_all_from
_TEXT	SEGMENT
locals$ = 96
v$ = 104
import_all_from PROC					; COMDAT

; 4557 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4558 :     _Py_IDENTIFIER(__all__);
; 4559 :     _Py_IDENTIFIER(__dict__);
; 4560 :     PyObject *all = _PyObject_GetAttrId(v, &PyId___all__);

  00011	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00018	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00021	4c 8b f2	 mov	 r14, rdx
  00024	4a 8b 1c c0	 mov	 rbx, QWORD PTR [rax+r8*8]
  00028	4c 8b e1	 mov	 r12, rcx
  0002b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___all__@?1??import_all_from@@9@9
  00030	48 03 d3	 add	 rdx, rbx
  00033	49 8b ce	 mov	 rcx, r14
  00036	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 4561 :     PyObject *dict, *name, *value;
; 4562 :     int skip_leading_underscores = 0;

  0003b	45 33 ed	 xor	 r13d, r13d
  0003e	48 8b f0	 mov	 rsi, rax
  00041	41 8b fd	 mov	 edi, r13d

; 4563 :     int pos, err;
; 4564 : 
; 4565 :     if (all == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	0f 85 82 00 00
	00		 jne	 $LN22@import_all

; 4566 :         if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00054	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00059	85 c0		 test	 eax, eax

; 4567 :             return -1; /* Unexpected error */

  0005b	74 40		 je	 SHORT $LN83@import_all

; 4568 :         PyErr_Clear();

  0005d	e8 00 00 00 00	 call	 PyErr_Clear

; 4569 :         dict = _PyObject_GetAttrId(v, &PyId___dict__);

  00062	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?1??import_all_from@@9@9
  00067	49 8b ce	 mov	 rcx, r14
  0006a	48 03 d3	 add	 rdx, rbx
  0006d	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00072	48 8b d8	 mov	 rbx, rax

; 4570 :         if (dict == NULL) {

  00075	48 85 c0	 test	 rax, rax
  00078	75 38		 jne	 SHORT $LN20@import_all

; 4571 :             if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00081	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00086	85 c0		 test	 eax, eax

; 4572 :                 return -1;

  00088	74 13		 je	 SHORT $LN83@import_all

; 4573 :             PyErr_SetString(PyExc_ImportError,
; 4574 :             "from-import-* object has no __dict__ and no __all__");

  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@
  00098	e8 00 00 00 00	 call	 PyErr_SetString
$LN83@import_all:

; 4575 :             return -1;

  0009d	83 c8 ff	 or	 eax, -1

; 4614 :     return err;
; 4615 : }

  000a0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	41 5e		 pop	 r14
  000ab	41 5d		 pop	 r13
  000ad	41 5c		 pop	 r12
  000af	5f		 pop	 rdi
  000b0	5e		 pop	 rsi
  000b1	c3		 ret	 0
$LN20@import_all:

; 4576 :         }
; 4577 :         all = PyMapping_Keys(dict);

  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 PyMapping_Keys

; 4578 :         Py_DECREF(dict);

  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	48 8b f0	 mov	 rsi, rax
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 4579 :         if (all == NULL)

  000c5	48 85 f6	 test	 rsi, rsi

; 4580 :             return -1;

  000c8	74 d3		 je	 SHORT $LN83@import_all

; 4581 :         skip_leading_underscores = 1;

  000ca	bf 01 00 00 00	 mov	 edi, 1
$LN22@import_all:
  000cf	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp

; 4585 :         name = PySequence_GetItem(all, pos);

  000d4	33 d2		 xor	 edx, edx
  000d6	48 8b ce	 mov	 rcx, rsi
  000d9	4c 89 7c 24 68	 mov	 QWORD PTR [rsp+104], r15
  000de	41 8b ed	 mov	 ebp, r13d
  000e1	e8 00 00 00 00	 call	 PySequence_GetItem
  000e6	48 8b d8	 mov	 rbx, rax

; 4591 :             break;
; 4592 :         }
; 4593 :         if (skip_leading_underscores &&
; 4594 :             PyUnicode_Check(name) &&
; 4595 :             PyUnicode_READY(name) != -1 &&
; 4596 :             PyUnicode_READ_CHAR(name, 0) == '_')

  000e9	4c 63 ff	 movsxd	 r15, edi
  000ec	48 85 c0	 test	 rax, rax
  000ef	0f 84 10 02 00
	00		 je	 $LN78@import_all
$LL17@import_all:
  000f5	4d 85 ff	 test	 r15, r15
  000f8	0f 84 cd 00 00
	00		 je	 $LN11@import_all
  000fe	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00102	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0010c	0f 84 b9 00 00
	00		 je	 $LN11@import_all
  00112	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00116	75 11		 jne	 SHORT $LN81@import_all
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00120	83 f8 ff	 cmp	 eax, -1
  00123	0f 84 a2 00 00
	00		 je	 $LN11@import_all
$LN81@import_all:
  00129	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  0012c	8b c8		 mov	 ecx, eax
  0012e	c1 e9 02	 shr	 ecx, 2
  00131	83 e1 07	 and	 ecx, 7
  00134	83 f9 01	 cmp	 ecx, 1
  00137	75 2c		 jne	 SHORT $LN41@import_all
  00139	a8 20		 test	 al, 32			; 00000020H
  0013b	74 1c		 je	 SHORT $LN29@import_all
  0013d	a8 40		 test	 al, 64			; 00000040H
  0013f	74 0c		 je	 SHORT $LN27@import_all
  00141	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00148	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0014b	eb 6c		 jmp	 SHORT $LN40@import_all
$LN27@import_all:
  0014d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00154	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00157	eb 60		 jmp	 SHORT $LN40@import_all
$LN29@import_all:
  00159	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00160	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00163	eb 54		 jmp	 SHORT $LN40@import_all
$LN41@import_all:
  00165	83 f9 02	 cmp	 ecx, 2
  00168	75 2c		 jne	 SHORT $LN39@import_all
  0016a	a8 20		 test	 al, 32			; 00000020H
  0016c	74 1c		 je	 SHORT $LN33@import_all
  0016e	a8 40		 test	 al, 64			; 00000040H
  00170	74 0c		 je	 SHORT $LN31@import_all
  00172	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00179	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0017c	eb 3b		 jmp	 SHORT $LN40@import_all
$LN31@import_all:
  0017e	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00185	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00188	eb 2f		 jmp	 SHORT $LN40@import_all
$LN33@import_all:
  0018a	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00191	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00194	eb 23		 jmp	 SHORT $LN40@import_all
$LN39@import_all:
  00196	a8 20		 test	 al, 32			; 00000020H
  00198	74 16		 je	 SHORT $LN37@import_all
  0019a	a8 40		 test	 al, 64			; 00000040H
  0019c	74 09		 je	 SHORT $LN35@import_all
  0019e	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  001a5	eb 10		 jmp	 SHORT $LN38@import_all
$LN35@import_all:
  001a7	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  001ae	eb 07		 jmp	 SHORT $LN38@import_all
$LN37@import_all:
  001b0	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN38@import_all:
  001b7	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN40@import_all:
  001b9	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  001bc	75 0d		 jne	 SHORT $LN11@import_all

; 4597 :         {
; 4598 :             Py_DECREF(name);

  001be	48 8b cb	 mov	 rcx, rbx
  001c1	e8 00 00 00 00	 call	 _Py_DecRef

; 4599 :             continue;

  001c6	e9 20 01 00 00	 jmp	 $LN16@import_all
$LN11@import_all:

; 4600 :         }
; 4601 :         value = PyObject_GetAttr(v, name);

  001cb	48 8b d3	 mov	 rdx, rbx
  001ce	49 8b ce	 mov	 rcx, r14
  001d1	e8 00 00 00 00	 call	 PyObject_GetAttr
  001d6	48 8b f8	 mov	 rdi, rax

; 4602 :         if (value == NULL)

  001d9	48 85 c0	 test	 rax, rax
  001dc	75 05		 jne	 SHORT $LN10@import_all

; 4603 :             err = -1;

  001de	83 cd ff	 or	 ebp, -1
  001e1	eb 35		 jmp	 SHORT $LN6@import_all
$LN10@import_all:

; 4604 :         else if (PyDict_CheckExact(locals))

  001e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  001ea	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  001ef	74 17		 je	 SHORT $LN7@import_all
  001f1	49 39 44 24 38	 cmp	 QWORD PTR [r12+56], rax
  001f6	74 10		 je	 SHORT $LN7@import_all

; 4606 :         else
; 4607 :             err = PyObject_SetItem(locals, name, value);

  001f8	4c 8b c7	 mov	 r8, rdi
  001fb	48 8b d3	 mov	 rdx, rbx
  001fe	49 8b cc	 mov	 rcx, r12
  00201	e8 00 00 00 00	 call	 PyObject_SetItem
  00206	eb 0e		 jmp	 SHORT $LN82@import_all
$LN7@import_all:

; 4605 :             err = PyDict_SetItem(locals, name, value);

  00208	4c 8b c7	 mov	 r8, rdi
  0020b	48 8b d3	 mov	 rdx, rbx
  0020e	49 8b cc	 mov	 rcx, r12
  00211	e8 00 00 00 00	 call	 PyDict_SetItem
$LN82@import_all:
  00216	8b e8		 mov	 ebp, eax
$LN6@import_all:

; 4608 :         Py_DECREF(name);

  00218	e8 00 00 00 00	 call	 _Py_PXCTX
  0021d	85 c0		 test	 eax, eax
  0021f	75 5c		 jne	 SHORT $LN5@import_all
  00221	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00225	a8 20		 test	 al, 32			; 00000020H
  00227	75 4c		 jne	 SHORT $LN47@import_all
  00229	84 c0		 test	 al, al
  0022b	78 48		 js	 SHORT $LN47@import_all
  0022d	a8 02		 test	 al, 2
  0022f	75 4c		 jne	 SHORT $LN5@import_all
  00231	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00235	75 46		 jne	 SHORT $LN5@import_all
  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00245	4c 8b cb	 mov	 r9, rbx
  00248	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0024e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00256	e8 00 00 00 00	 call	 _PyParallel_Guard
  0025b	48 8b cb	 mov	 rcx, rbx
  0025e	85 c0		 test	 eax, eax
  00260	74 07		 je	 SHORT $LN52@import_all
  00262	e8 00 00 00 00	 call	 _Px_Dealloc
  00267	eb 14		 jmp	 SHORT $LN5@import_all
$LN52@import_all:
  00269	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0026d	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00273	eb 08		 jmp	 SHORT $LN5@import_all
$LN47@import_all:
  00275	48 8b cb	 mov	 rcx, rbx
  00278	e8 00 00 00 00	 call	 Px_DecRef
$LN5@import_all:

; 4609 :         Py_XDECREF(value);

  0027d	48 85 ff	 test	 rdi, rdi
  00280	74 65		 je	 SHORT $LN4@import_all
  00282	e8 00 00 00 00	 call	 _Py_PXCTX
  00287	85 c0		 test	 eax, eax
  00289	75 5c		 jne	 SHORT $LN4@import_all
  0028b	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0028f	a8 20		 test	 al, 32			; 00000020H
  00291	75 4c		 jne	 SHORT $LN58@import_all
  00293	84 c0		 test	 al, al
  00295	78 48		 js	 SHORT $LN58@import_all
  00297	a8 02		 test	 al, 2
  00299	75 4c		 jne	 SHORT $LN4@import_all
  0029b	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0029f	75 46		 jne	 SHORT $LN4@import_all
  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002af	4c 8b cf	 mov	 r9, rdi
  002b2	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002b8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  002c5	48 8b cf	 mov	 rcx, rdi
  002c8	85 c0		 test	 eax, eax
  002ca	74 07		 je	 SHORT $LN63@import_all
  002cc	e8 00 00 00 00	 call	 _Px_Dealloc
  002d1	eb 14		 jmp	 SHORT $LN4@import_all
$LN63@import_all:
  002d3	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  002d7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002dd	eb 08		 jmp	 SHORT $LN4@import_all
$LN58@import_all:
  002df	48 8b cf	 mov	 rcx, rdi
  002e2	e8 00 00 00 00	 call	 Px_DecRef
$LN4@import_all:

; 4610 :         if (err != 0)

  002e7	85 ed		 test	 ebp, ebp
  002e9	75 34		 jne	 SHORT $LN12@import_all
$LN16@import_all:

; 4582 :     }
; 4583 : 
; 4584 :     for (pos = 0, err = 0; ; pos++) {

  002eb	41 ff c5	 inc	 r13d

; 4585 :         name = PySequence_GetItem(all, pos);

  002ee	48 8b ce	 mov	 rcx, rsi
  002f1	49 63 d5	 movsxd	 rdx, r13d
  002f4	e8 00 00 00 00	 call	 PySequence_GetItem
  002f9	48 8b d8	 mov	 rbx, rax

; 4586 :         if (name == NULL) {

  002fc	48 85 c0	 test	 rax, rax
  002ff	0f 85 f0 fd ff
	ff		 jne	 $LL17@import_all
$LN78@import_all:

; 4587 :             if (!PyErr_ExceptionMatches(PyExc_IndexError))

  00305	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0030c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00311	85 c0		 test	 eax, eax
  00313	75 05		 jne	 SHORT $LN13@import_all

; 4588 :                 err = -1;

  00315	83 cd ff	 or	 ebp, -1

; 4589 :             else

  00318	eb 05		 jmp	 SHORT $LN12@import_all
$LN13@import_all:

; 4590 :                 PyErr_Clear();

  0031a	e8 00 00 00 00	 call	 PyErr_Clear
$LN12@import_all:

; 4611 :             break;
; 4612 :     }
; 4613 :     Py_DECREF(all);

  0031f	e8 00 00 00 00	 call	 _Py_PXCTX
  00324	4c 8b 7c 24 68	 mov	 r15, QWORD PTR [rsp+104]
  00329	85 c0		 test	 eax, eax
  0032b	75 5c		 jne	 SHORT $LN75@import_all
  0032d	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00331	a8 20		 test	 al, 32			; 00000020H
  00333	75 4c		 jne	 SHORT $LN69@import_all
  00335	84 c0		 test	 al, al
  00337	78 48		 js	 SHORT $LN69@import_all
  00339	a8 02		 test	 al, 2
  0033b	75 4c		 jne	 SHORT $LN75@import_all
  0033d	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00341	75 46		 jne	 SHORT $LN75@import_all
  00343	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0034a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00351	4c 8b ce	 mov	 r9, rsi
  00354	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0035a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00362	e8 00 00 00 00	 call	 _PyParallel_Guard
  00367	48 8b ce	 mov	 rcx, rsi
  0036a	85 c0		 test	 eax, eax
  0036c	74 07		 je	 SHORT $LN74@import_all
  0036e	e8 00 00 00 00	 call	 _Px_Dealloc
  00373	eb 14		 jmp	 SHORT $LN75@import_all
$LN74@import_all:
  00375	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00379	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0037f	eb 08		 jmp	 SHORT $LN75@import_all
$LN69@import_all:
  00381	48 8b ce	 mov	 rcx, rsi
  00384	e8 00 00 00 00	 call	 Px_DecRef
$LN75@import_all:

; 4614 :     return err;
; 4615 : }

  00389	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0038e	8b c5		 mov	 eax, ebp
  00390	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00395	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00399	41 5e		 pop	 r14
  0039b	41 5d		 pop	 r13
  0039d	41 5c		 pop	 r12
  0039f	5f		 pop	 rdi
  003a0	5e		 pop	 rsi
  003a1	c3		 ret	 0
import_all_from ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_exc_check_arg DD imagerel format_exc_check_arg
	DD	imagerel format_exc_check_arg+60
	DD	imagerel $unwind$format_exc_check_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_exc_check_arg DD 040f01H
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT format_exc_check_arg
_TEXT	SEGMENT
exc$ = 48
format_str$ = 56
obj$ = 64
format_exc_check_arg PROC				; COMDAT

; 4620 :     const char *obj_str;
; 4621 : 
; 4622 :     if (!obj)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 35		 je	 SHORT $LN5@format_exc
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4619 : {

  0000f	48 8b f9	 mov	 rdi, rcx

; 4623 :         return;
; 4624 : 
; 4625 :     obj_str = _PyUnicode_AsString(obj);

  00012	49 8b c8	 mov	 rcx, r8
  00015	48 8b da	 mov	 rbx, rdx
  00018	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 4626 :     if (!obj_str)

  0001d	48 85 c0	 test	 rax, rax
  00020	74 0e		 je	 SHORT $LN3@format_exc

; 4627 :         return;
; 4628 : 
; 4629 :     PyErr_Format(exc, format_str, obj_str);

  00022	4c 8b c0	 mov	 r8, rax
  00025	48 8b d3	 mov	 rdx, rbx
  00028	48 8b cf	 mov	 rcx, rdi
  0002b	e8 00 00 00 00	 call	 PyErr_Format
$LN3@format_exc:

; 4630 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
$LN5@format_exc:
  0003a	f3 c3		 fatret	 0
format_exc_check_arg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@ ; `string'
PUBLIC	??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@ ; `string'
EXTRN	PyExc_NameError:QWORD
EXTRN	PyExc_UnboundLocalError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_exc_unbound DD imagerel format_exc_unbound
	DD	imagerel format_exc_unbound+124
	DD	imagerel $unwind$format_exc_unbound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_exc_unbound DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@
CONST	SEGMENT
??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@ DB 'free va'
	DB	'riable ''%.200s'' referenced before assignment in enclosing s'
	DB	'cope', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@
CONST	SEGMENT
??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@ DB 'local v'
	DB	'ariable ''%.200s'' referenced before assignment', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_exc_unbound
_TEXT	SEGMENT
co$ = 48
oparg$ = 56
format_exc_unbound PROC					; COMDAT

; 4634 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx

; 4635 :     PyObject *name;
; 4636 :     /* Don't stomp existing exception */
; 4637 :     if (PyErr_Occurred())

  00010	e8 00 00 00 00	 call	 PyErr_Occurred
  00015	48 85 c0	 test	 rax, rax
  00018	75 57		 jne	 SHORT $LN1@format_exc@2

; 4638 :         return;
; 4639 :     if (oparg < PyTuple_GET_SIZE(co->co_cellvars)) {

  0001a	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  00021	48 8b c7	 mov	 rax, rdi
  00024	49 8b 50 60	 mov	 rdx, QWORD PTR [r8+96]
  00028	48 3b fa	 cmp	 rdi, rdx
  0002b	7d 22		 jge	 SHORT $LN2@format_exc@2

; 4640 :         name = PyTuple_GET_ITEM(co->co_cellvars,
; 4641 :                                 oparg);
; 4642 :         format_exc_check_arg(
; 4643 :             PyExc_UnboundLocalError,
; 4644 :             UNBOUNDLOCAL_ERROR_MSG,
; 4645 :             name);

  0002d	4d 8b 44 f8 70	 mov	 r8, QWORD PTR [r8+rdi*8+112]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnboundLocalError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@

; 4651 :     }
; 4652 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	e9 00 00 00 00	 jmp	 format_exc_check_arg
$LN2@format_exc@2:

; 4646 :     } else {
; 4647 :         name = PyTuple_GET_ITEM(co->co_freevars, oparg -
; 4648 :                                 PyTuple_GET_SIZE(co->co_cellvars));
; 4649 :         format_exc_check_arg(PyExc_NameError,
; 4650 :                              UNBOUNDFREE_ERROR_MSG, name);

  0004f	4c 8b 83 98 00
	00 00		 mov	 r8, QWORD PTR [rbx+152]
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  0005d	48 2b c2	 sub	 rax, rdx
  00060	4d 8b 44 c0 70	 mov	 r8, QWORD PTR [r8+rax*8+112]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@
  0006c	e8 00 00 00 00	 call	 format_exc_check_arg
$LN1@format_exc@2:

; 4651 :     }
; 4652 : }

  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
format_exc_unbound ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Append:PROC
EXTRN	PyDict_DelItem:PROC
EXTRN	PyCell_Set:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$unicode_concatenate DD imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+31
	DD	imagerel $unwind$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_concatenate DD imagerel unicode_concatenate+31
	DD	imagerel unicode_concatenate+311
	DD	imagerel $chain$0$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_concatenate DD imagerel unicode_concatenate+311
	DD	imagerel unicode_concatenate+395
	DD	imagerel $chain$1$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$unicode_concatenate DD imagerel unicode_concatenate+395
	DD	imagerel unicode_concatenate+400
	DD	imagerel $chain$2$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$unicode_concatenate DD imagerel unicode_concatenate+400
	DD	imagerel unicode_concatenate+434
	DD	imagerel $chain$3$unicode_concatenate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$unicode_concatenate DD 021H
	DD	imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+31
	DD	imagerel $unwind$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$unicode_concatenate DD 021H
	DD	imagerel unicode_concatenate+31
	DD	imagerel unicode_concatenate+311
	DD	imagerel $chain$0$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_concatenate DD 020521H
	DD	0a6405H
	DD	imagerel unicode_concatenate+31
	DD	imagerel unicode_concatenate+311
	DD	imagerel $chain$0$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_concatenate DD 020521H
	DD	093405H
	DD	imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+31
	DD	imagerel $unwind$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_concatenate DD 040a01H
	DD	0b540aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT unicode_concatenate
_TEXT	SEGMENT
res$ = 64
v$ = 64
w$ = 72
f$ = 80
next_instr$ = 88
unicode_concatenate PROC				; COMDAT

; 4657 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4658 :     PyObject *res;
; 4659 :     if (Py_REFCNT(v) == 2) {

  0000a	48 83 79 50 02	 cmp	 QWORD PTR [rcx+80], 2
  0000f	48 8b ea	 mov	 rbp, rdx
  00012	48 8b f9	 mov	 rdi, rcx
  00015	0f 85 75 01 00
	00		 jne	 $LN1@unicode_co

; 4660 :         /* In the common case, there are 2 references to the value
; 4661 :          * stored in 'variable' when the += is performed: one on the
; 4662 :          * value stack (in 'v') and one still stored in the
; 4663 :          * 'variable'.  We try to delete the variable now to reduce
; 4664 :          * the refcnt to 1.
; 4665 :          */
; 4666 :         switch (*next_instr) {

  0001b	45 0f b6 11	 movzx	 r10d, BYTE PTR [r9]
  0001f	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00024	41 83 ea 5a	 sub	 r10d, 90		; 0000005aH
  00028	0f 84 f4 00 00
	00		 je	 $LN4@unicode_co
  0002e	41 83 ea 23	 sub	 r10d, 35		; 00000023H
  00032	74 44		 je	 SHORT $LN15@unicode_co
  00034	41 83 fa 0c	 cmp	 r10d, 12
  00038	0f 85 4d 01 00
	00		 jne	 $LN32@unicode_co

; 4674 :         }
; 4675 :         case STORE_DEREF:
; 4676 :         {
; 4677 :             PyObject **freevars = (f->f_localsplus +
; 4678 :                                    f->f_code->co_nlocals);
; 4679 :             PyObject *c = freevars[PEEKARG()];

  0003e	49 8b 40 78	 mov	 rax, QWORD PTR [r8+120]
  00042	41 0f b6 51 02	 movzx	 edx, BYTE PTR [r9+2]
  00047	48 63 48 68	 movsxd	 rcx, DWORD PTR [rax+104]
  0004b	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00050	48 c1 e2 08	 shl	 rdx, 8
  00054	48 03 d1	 add	 rdx, rcx
  00057	48 03 d0	 add	 rdx, rax
  0005a	49 8b 8c d0 d0
	01 00 00	 mov	 rcx, QWORD PTR [r8+rdx*8+464]

; 4680 :             if (PyCell_GET(c) == v)

  00062	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  00066	0f 85 1f 01 00
	00		 jne	 $LN32@unicode_co

; 4681 :                 PyCell_Set(c, NULL);

  0006c	33 d2		 xor	 edx, edx
  0006e	e8 00 00 00 00	 call	 PyCell_Set

; 4682 :             break;

  00073	e9 13 01 00 00	 jmp	 $LN32@unicode_co
$LN15@unicode_co:

; 4667 :         case STORE_FAST:
; 4668 :         {
; 4669 :             int oparg = PEEKARG();

  00078	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  0007d	41 0f b6 49 02	 movzx	 ecx, BYTE PTR [r9+2]
  00082	c1 e1 08	 shl	 ecx, 8
  00085	03 c1		 add	 eax, ecx

; 4670 :             PyObject **fastlocals = f->f_localsplus;
; 4671 :             if (GETLOCAL(oparg) == v)

  00087	48 98		 cdqe
  00089	49 8b 9c c0 d0
	01 00 00	 mov	 rbx, QWORD PTR [r8+rax*8+464]
  00091	48 3b df	 cmp	 rbx, rdi
  00094	0f 85 f1 00 00
	00		 jne	 $LN32@unicode_co

; 4672 :                 SETLOCAL(oparg, NULL);

  0009a	49 c7 84 c0 d0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR [r8+rax*8+464], 0
  000a6	48 85 db	 test	 rbx, rbx
  000a9	0f 84 dc 00 00
	00		 je	 $LN32@unicode_co
  000af	e8 00 00 00 00	 call	 _Py_PXCTX
  000b4	85 c0		 test	 eax, eax
  000b6	0f 85 cf 00 00
	00		 jne	 $LN32@unicode_co
  000bc	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000c0	a8 20		 test	 al, 32			; 00000020H
  000c2	75 54		 jne	 SHORT $LN25@unicode_co
  000c4	84 c0		 test	 al, al
  000c6	78 50		 js	 SHORT $LN25@unicode_co
  000c8	a8 02		 test	 al, 2
  000ca	0f 85 bb 00 00
	00		 jne	 $LN32@unicode_co
  000d0	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000d4	0f 85 b1 00 00
	00		 jne	 $LN32@unicode_co
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000e8	4c 8b cb	 mov	 r9, rbx
  000eb	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000f1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fe	48 8b cb	 mov	 rcx, rbx
  00101	85 c0		 test	 eax, eax
  00103	74 07		 je	 SHORT $LN30@unicode_co
  00105	e8 00 00 00 00	 call	 _Px_Dealloc
  0010a	eb 7f		 jmp	 SHORT $LN32@unicode_co
$LN30@unicode_co:
  0010c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00110	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00116	eb 73		 jmp	 SHORT $LN32@unicode_co
$LN25@unicode_co:
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	e8 00 00 00 00	 call	 Px_DecRef

; 4673 :             break;

  00120	eb 69		 jmp	 SHORT $LN32@unicode_co
$LN4@unicode_co:

; 4683 :         }
; 4684 :         case STORE_NAME:
; 4685 :         {
; 4686 :             PyObject *names = f->f_code->co_names;
; 4687 :             PyObject *name = GETITEM(names, PEEKARG());

  00122	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00127	41 0f b6 51 02	 movzx	 edx, BYTE PTR [r9+2]

; 4688 :             PyObject *locals = f->f_locals;

  0012c	49 8b 98 90 00
	00 00		 mov	 rbx, QWORD PTR [r8+144]
  00133	48 c1 e2 08	 shl	 rdx, 8
  00137	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0013c	48 03 d0	 add	 rdx, rax
  0013f	49 8b 40 78	 mov	 rax, QWORD PTR [r8+120]
  00143	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]

; 4689 :             if (PyDict_CheckExact(locals) &&
; 4690 :                 PyDict_GetItem(locals, name) == v) {

  0014a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00151	48 8b 74 d1 70	 mov	 rsi, QWORD PTR [rcx+rdx*8+112]
  00156	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  0015a	74 06		 je	 SHORT $LN2@unicode_co
  0015c	48 39 43 38	 cmp	 QWORD PTR [rbx+56], rax
  00160	75 24		 jne	 SHORT $LN33@unicode_co
$LN2@unicode_co:
  00162	48 8b d6	 mov	 rdx, rsi
  00165	48 8b cb	 mov	 rcx, rbx
  00168	e8 00 00 00 00	 call	 PyDict_GetItem
  0016d	48 3b c7	 cmp	 rax, rdi
  00170	75 14		 jne	 SHORT $LN33@unicode_co

; 4691 :                 if (PyDict_DelItem(locals, name) != 0) {

  00172	48 8b d6	 mov	 rdx, rsi
  00175	48 8b cb	 mov	 rcx, rbx
  00178	e8 00 00 00 00	 call	 PyDict_DelItem
  0017d	85 c0		 test	 eax, eax
  0017f	74 05		 je	 SHORT $LN33@unicode_co

; 4692 :                     PyErr_Clear();

  00181	e8 00 00 00 00	 call	 PyErr_Clear
$LN33@unicode_co:
  00186	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
$LN32@unicode_co:
  0018b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
$LN1@unicode_co:

; 4693 :                 }
; 4694 :             }
; 4695 :             break;
; 4696 :         }
; 4697 :         }
; 4698 :     }
; 4699 :     res = v;
; 4700 :     PyUnicode_Append(&res, w);

  00190	48 8d 4c 24 40	 lea	 rcx, QWORD PTR res$[rsp]
  00195	48 8b d5	 mov	 rdx, rbp
  00198	48 89 7c 24 40	 mov	 QWORD PTR res$[rsp], rdi
  0019d	e8 00 00 00 00	 call	 PyUnicode_Append

; 4701 :     return res;

  001a2	48 8b 44 24 40	 mov	 rax, QWORD PTR res$[rsp]

; 4702 : }

  001a7	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b0	5f		 pop	 rdi
  001b1	c3		 ret	 0
unicode_concatenate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@ ; `string'
EXTRN	_PyParallel_JustAcquiredGIL:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$take_gil DD imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$take_gil DD imagerel take_gil+6
	DD	imagerel take_gil+72
	DD	imagerel $chain$0$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$take_gil DD imagerel take_gil+72
	DD	imagerel take_gil+288
	DD	imagerel $chain$3$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$take_gil DD imagerel take_gil+288
	DD	imagerel take_gil+463
	DD	imagerel $chain$4$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$take_gil DD imagerel take_gil+463
	DD	imagerel take_gil+497
	DD	imagerel $chain$5$take_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$take_gil DD 021H
	DD	imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$take_gil DD 021H
	DD	imagerel take_gil+6
	DD	imagerel take_gil+72
	DD	imagerel $chain$0$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$take_gil DD 060f21H
	DD	09740fH
	DD	07540aH
	DD	063405H
	DD	imagerel take_gil+6
	DD	imagerel take_gil+72
	DD	imagerel $chain$0$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$take_gil DD 020521H
	DD	086405H
	DD	imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$take_gil DD 020601H
	DD	0c0023206H
xdata	ENDS
;	COMDAT ??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@
CONST	SEGMENT
??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@ DB 'PyCOND_SI'
	DB	'GNAL(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_WA'
	DB	'IT(gil_cond) failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@
CONST	SEGMENT
??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@ DB 'take_gil: NULL tstat'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval_gil.h
CONST	ENDS
;	COMDAT take_gil
_TEXT	SEGMENT
tstate$ = 48
take_gil PROC						; COMDAT

; 217  : {

  00000	41 54		 push	 r12
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0000b	48 8b f1	 mov	 rsi, rcx

; 218  :     int err;
; 219  :     if (tstate == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	75 0c		 jne	 SHORT $LN22@take_gil

; 220  :         Py_FatalError("take_gil: NULL tstate");

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@
  0001a	e8 00 00 00 00	 call	 Py_FatalError
$LN22@take_gil:

; 221  : 
; 222  :     err = errno;

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 223  :     MUTEX_LOCK(gil_mutex);

  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0002c	44 8b 20	 mov	 r12d, DWORD PTR [rax]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 224  : 
; 225  :     if (!_Py_atomic_load_relaxed(&gil_locked))

  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_locked, 0
  0003c	0f 84 de 00 00
	00		 je	 $_ready$64034
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR gil_switch_number
  00048	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004d	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00052	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00057	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL19@take_gil:

; 229  :         int timed_out = 0;
; 230  :         unsigned long saved_switchnum;
; 231  : 
; 232  :         saved_switchnum = gil_switch_number;
; 233  :         COND_TIMED_WAIT(gil_cond, gil_mutex, INTERVAL, timed_out);

  00060	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_interval
  00066	bb 01 00 00 00	 mov	 ebx, 1
  0006b	8b e9		 mov	 ebp, ecx
  0006d	3b c3		 cmp	 eax, ebx
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00076	0f 43 d8	 cmovae	 ebx, eax
  00079	ff 05 08 00 00
	00		 inc	 DWORD PTR gil_cond+8
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gil_cond
  0008c	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00091	f7 eb		 imul	 ebx
  00093	c1 fa 06	 sar	 edx, 6
  00096	8b c2		 mov	 eax, edx
  00098	c1 e8 1f	 shr	 eax, 31
  0009b	03 d0		 add	 edx, eax
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  000aa	8b f8		 mov	 edi, eax
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  000b2	85 ff		 test	 edi, edi
  000b4	74 06		 je	 SHORT $LN52@take_gil
  000b6	ff 0d 08 00 00
	00		 dec	 DWORD PTR gil_cond+8
$LN52@take_gil:
  000bc	83 ff ff	 cmp	 edi, -1			; ffffffffH
  000bf	75 05		 jne	 SHORT $LN29@take_gil
  000c1	83 cb ff	 or	 ebx, -1
  000c4	eb 0b		 jmp	 SHORT $LN51@take_gil
$LN29@take_gil:
  000c6	33 db		 xor	 ebx, ebx
  000c8	85 ff		 test	 edi, edi
  000ca	0f 95 c3	 setne	 bl
  000cd	85 db		 test	 ebx, ebx
  000cf	79 0c		 jns	 SHORT $LN17@take_gil
$LN51@take_gil:
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@
  000d8	e8 00 00 00 00	 call	 Py_FatalError
$LN17@take_gil:
  000dd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_locked
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR gil_switch_number
  000e9	85 db		 test	 ebx, ebx

; 234  :         /* If we timed out and no switch occurred in the meantime, it is time
; 235  :            to ask the GIL-holding thread to drop it. */
; 236  :         if (timed_out &&
; 237  :             _Py_atomic_load_relaxed(&gil_locked) &&
; 238  :             gil_switch_number == saved_switchnum) {

  000eb	74 1c		 je	 SHORT $LN11@take_gil
  000ed	85 c0		 test	 eax, eax
  000ef	74 20		 je	 SHORT $LN56@take_gil
  000f1	3b cd		 cmp	 ecx, ebp
  000f3	75 14		 jne	 SHORT $LN11@take_gil

; 239  :             SET_GIL_DROP_REQUEST();

  000f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gil_drop_request, 1
  000ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1
$LN11@take_gil:

; 226  :         goto _ready;
; 227  :     
; 228  :     while (_Py_atomic_load_relaxed(&gil_locked)) {

  00109	85 c0		 test	 eax, eax
  0010b	0f 85 4f ff ff
	ff		 jne	 $LL19@take_gil
$LN56@take_gil:
  00111	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00116	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$_ready$64034:

; 240  :         }
; 241  :     }
; 242  : _ready:
; 243  : #ifdef FORCE_SWITCHING
; 244  :     /* This mutex must be taken before modifying gil_last_holder (see drop_gil()). */
; 245  :     MUTEX_LOCK(switch_mutex);

  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 246  : #endif
; 247  :     /* We now hold the GIL */
; 248  : #ifdef WITH_PARALLEL
; 249  :     _PyParallel_JustAcquiredGIL();

  0012d	e8 00 00 00 00	 call	 _PyParallel_JustAcquiredGIL

; 250  : #endif
; 251  :     _Py_atomic_store_relaxed(&gil_locked, 1);
; 252  :     _Py_ANNOTATE_RWLOCK_ACQUIRED(&gil_locked, /*is_write=*/1);
; 253  : 
; 254  :     if (tstate != _Py_atomic_load_relaxed(&gil_last_holder)) {

  00132	48 3b 35 00 00
	00 00		 cmp	 rsi, QWORD PTR gil_last_holder
  00139	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gil_locked, 1
  00143	74 0d		 je	 SHORT $LN9@take_gil

; 255  :         _Py_atomic_store_relaxed(&gil_last_holder, tstate);
; 256  :         ++gil_switch_number;

  00145	ff 05 00 00 00
	00		 inc	 DWORD PTR gil_switch_number
  0014b	48 89 35 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rsi
$LN9@take_gil:

; 257  :     }
; 258  : 
; 259  : #ifdef FORCE_SWITCHING
; 260  :     COND_SIGNAL(switch_cond);

  00152	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR switch_cond+8
  00158	85 c0		 test	 eax, eax
  0015a	7e 32		 jle	 SHORT $LN8@take_gil
  0015c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR switch_cond
  00163	45 33 c0	 xor	 r8d, r8d
  00166	ff c8		 dec	 eax
  00168	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0016c	89 05 08 00 00
	00		 mov	 DWORD PTR switch_cond+8, eax
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  00178	f7 d8		 neg	 eax
  0017a	1b d2		 sbb	 edx, edx
  0017c	f7 da		 neg	 edx
  0017e	ff ca		 dec	 edx
  00180	74 0c		 je	 SHORT $LN8@take_gil
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@
  00189	e8 00 00 00 00	 call	 Py_FatalError
$LN8@take_gil:

; 261  :     MUTEX_UNLOCK(switch_mutex);

  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 262  : #endif
; 263  :     if (_Py_atomic_load_relaxed(&gil_drop_request)) {

  0019b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_drop_request, 0
  001a2	74 1c		 je	 SHORT $LN3@take_gil

; 264  :         RESET_GIL_DROP_REQUEST();

  001a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc
  001aa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR gil_drop_request, 0
  001b4	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do
  001ba	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
$LN3@take_gil:

; 265  :     }
; 266  :     if (tstate->async_exc != NULL) {

  001c0	48 83 be 88 00
	00 00 00	 cmp	 QWORD PTR [rsi+136], 0
  001c8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001cd	74 05		 je	 SHORT $LN2@take_gil

; 267  :         _PyEval_SignalAsyncExc();

  001cf	e8 00 00 00 00	 call	 _PyEval_SignalAsyncExc
$LN2@take_gil:

; 268  :     }
; 269  :     
; 270  :     MUTEX_UNLOCK(gil_mutex);

  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 271  :     errno = err;

  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001e7	44 89 20	 mov	 DWORD PTR [rax], r12d

; 272  : }

  001ea	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ee	41 5c		 pop	 r12
  001f0	c3		 ret	 0
take_gil ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@	; `string'
PUBLIC	PyEval_InitThreads
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_InitThreads DD imagerel $LN8
	DD	imagerel $LN8+124
	DD	imagerel $unwind$PyEval_InitThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_InitThreads DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@
CONST	SEGMENT
??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@ DB 'PyEval_InitThreads', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_InitThreads
_TEXT	SEGMENT
PyEval_InitThreads PROC					; COMDAT

; 310  : {

$LN8:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 311  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN3@PyEval_Ini
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 37 01 00
	00		 mov	 r8d, 311		; 00000137H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Ini:

; 312  :     if (gil_created())

  00029	e8 00 00 00 00	 call	 gil_created
  0002e	85 c0		 test	 eax, eax
  00030	75 45		 jne	 SHORT $LN1@PyEval_Ini

; 313  :         return;
; 314  :     create_gil();

  00032	e8 00 00 00 00	 call	 create_gil

; 315  :     take_gil(PyThreadState_GET());

  00037	e8 00 00 00 00	 call	 _Py_PXCTX
  0003c	85 c0		 test	 eax, eax
  0003e	74 07		 je	 SHORT $LN6@PyEval_Ini
  00040	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00045	eb 07		 jmp	 SHORT $LN7@PyEval_Ini
$LN6@PyEval_Ini:
  00047	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN7@PyEval_Ini:
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 take_gil

; 316  :     main_thread = PyThread_get_thread_ident();

  00056	e8 00 00 00 00	 call	 PyThread_get_thread_ident

; 317  :     if (!pending_lock)

  0005b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pending_lock, 0
  00063	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax
  00069	75 0c		 jne	 SHORT $LN1@PyEval_Ini

; 318  :         pending_lock = PyThread_allocate_lock();

  0006b	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00070	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax
$LN1@PyEval_Ini:

; 319  : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
PyEval_InitThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@ ; `string'
PUBLIC	??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@	; `string'
PUBLIC	PyEval_AcquireLock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_AcquireLock DD imagerel $LN7
	DD	imagerel $LN7+99
	DD	imagerel $unwind$PyEval_AcquireLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_AcquireLock DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@
CONST	SEGMENT
??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@ DB 'PyEval_Acquir'
	DB	'eLock: current thread state is NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@
CONST	SEGMENT
??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@ DB 'PyEval_AcquireLock', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_AcquireLock
_TEXT	SEGMENT
PyEval_AcquireLock PROC					; COMDAT

; 333  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 334  :     PyThreadState *tstate = PyThreadState_GET();

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	74 0a		 je	 SHORT $LN5@PyEval_Acq
  0000f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00014	48 8b d8	 mov	 rbx, rax
  00017	eb 07		 jmp	 SHORT $LN6@PyEval_Acq
$LN5@PyEval_Acq:
  00019	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyThreadState_Current
$LN6@PyEval_Acq:

; 335  :     Py_GUARD

  00020	e8 00 00 00 00	 call	 _Py_PXCTX
  00025	85 c0		 test	 eax, eax
  00027	74 1c		 je	 SHORT $LN2@PyEval_Acq
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	41 b8 4f 01 00
	00		 mov	 r8d, 335		; 0000014fH
  00040	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@PyEval_Acq:

; 336  :     if (tstate == NULL)

  00045	48 85 db	 test	 rbx, rbx
  00048	75 0c		 jne	 SHORT $LN1@PyEval_Acq

; 337  :         Py_FatalError("PyEval_AcquireLock: current thread state is NULL");

  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@
  00051	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Acq:

; 338  :     take_gil(tstate);

  00056	48 8b cb	 mov	 rcx, rbx

; 339  : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	e9 00 00 00 00	 jmp	 take_gil
PyEval_AcquireLock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@ ; `string'
PUBLIC	??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@ ; `string'
PUBLIC	??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@	; `string'
PUBLIC	PyEval_AcquireThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_AcquireThread DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$PyEval_AcquireThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_AcquireThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@
CONST	SEGMENT
??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@ DB 'PyEval_Acqui'
	DB	'reThread: non-NULL old thread state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@
CONST	SEGMENT
??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@ DB 'PyEval_Acqui'
	DB	'reThread: NULL new thread state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@
CONST	SEGMENT
??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@ DB 'PyEval_AcquireThread', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_AcquireThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_AcquireThread PROC				; COMDAT

; 355  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 356  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN3@PyEval_Acq@2
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 64 01 00
	00		 mov	 r8d, 356		; 00000164H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Acq@2:

; 357  :     if (tstate == NULL)

  0002e	48 85 db	 test	 rbx, rbx
  00031	75 0c		 jne	 SHORT $LN2@PyEval_Acq@2

; 358  :         Py_FatalError("PyEval_AcquireThread: NULL new thread state");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@
  0003a	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Acq@2:

; 359  :     /* Check someone has called PyEval_InitThreads() to create the lock */
; 360  :     assert(gil_created());
; 361  :     take_gil(tstate);

  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 take_gil

; 362  :     if (PyThreadState_Swap(tstate) != NULL)

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 PyThreadState_Swap
  0004f	48 85 c0	 test	 rax, rax
  00052	74 0c		 je	 SHORT $LN1@PyEval_Acq@2

; 363  :         Py_FatalError(
; 364  :             "PyEval_AcquireThread: non-NULL old thread state");

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@
  0005b	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Acq@2:

; 365  : }

  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5b		 pop	 rbx
  00065	c3		 ret	 0
PyEval_AcquireThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LCFGMKMJ@threading?$AA@			; `string'
PUBLIC	??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@	; `string'
PUBLIC	PyEval_ReInitThreads
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyMapping_GetItemString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReInitThreads DD imagerel $LN12
	DD	imagerel $LN12+262
	DD	imagerel $unwind$PyEval_ReInitThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReInitThreads DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09LCFGMKMJ@threading?$AA@
CONST	SEGMENT
??_C@_09LCFGMKMJ@threading?$AA@ DB 'threading', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@
CONST	SEGMENT
??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@ DB 'PyEval_ReInitThreads', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_ReInitThreads
_TEXT	SEGMENT
PyEval_ReInitThreads PROC				; COMDAT

; 385  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 386  :     _Py_IDENTIFIER(_after_fork);
; 387  :     PyObject *threading, *result;
; 388  :     PyThreadState *tstate = PyThreadState_GET();

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	74 0a		 je	 SHORT $LN8@PyEval_ReI
  0000f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00014	48 8b d8	 mov	 rbx, rax
  00017	eb 07		 jmp	 SHORT $LN9@PyEval_ReI
$LN8@PyEval_ReI:
  00019	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR _PyThreadState_Current
$LN9@PyEval_ReI:

; 389  :     Py_GUARD

  00020	e8 00 00 00 00	 call	 _Py_PXCTX
  00025	85 c0		 test	 eax, eax
  00027	74 1c		 je	 SHORT $LN5@PyEval_ReI
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	41 b8 85 01 00
	00		 mov	 r8d, 389		; 00000185H
  00040	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN5@PyEval_ReI:

; 390  : 
; 391  :     if (!gil_created())

  00045	e8 00 00 00 00	 call	 gil_created
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 ae 00 00
	00		 je	 $LN6@PyEval_ReI

; 392  :         return;
; 393  :     recreate_gil();

  00052	e8 00 00 00 00	 call	 recreate_gil

; 394  :     pending_lock = PyThread_allocate_lock();

  00057	e8 00 00 00 00	 call	 PyThread_allocate_lock

; 395  :     take_gil(tstate);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax
  00066	e8 00 00 00 00	 call	 take_gil

; 396  :     main_thread = PyThread_get_thread_ident();

  0006b	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00070	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 397  : 
; 398  :     /* Update the threading module with the new state.
; 399  :      */
; 400  :     tstate = PyThreadState_GET();

  00076	e8 00 00 00 00	 call	 _Py_PXCTX
  0007b	85 c0		 test	 eax, eax
  0007d	74 07		 je	 SHORT $LN10@PyEval_ReI
  0007f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00084	eb 07		 jmp	 SHORT $LN11@PyEval_ReI
$LN10@PyEval_ReI:
  00086	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN11@PyEval_ReI:

; 401  :     threading = PyMapping_GetItemString(tstate->interp->modules,
; 402  :                                         "threading");

  0008d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LCFGMKMJ@threading?$AA@
  00098	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0009c	e8 00 00 00 00	 call	 PyMapping_GetItemString
  000a1	48 8b d8	 mov	 rbx, rax

; 403  :     if (threading == NULL) {

  000a4	48 85 c0	 test	 rax, rax
  000a7	75 0a		 jne	 SHORT $LN3@PyEval_ReI

; 414  : }

  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5b		 pop	 rbx
  000ae	e9 00 00 00 00	 jmp	 PyErr_Clear
$LN3@PyEval_ReI:

; 404  :         /* threading not imported */
; 405  :         PyErr_Clear();
; 406  :         return;
; 407  :     }
; 408  :     result = _PyObject_CallMethodId(threading, &PyId__after_fork, NULL);

  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b9	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000c2	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__after_fork@?1??PyEval_ReInitThreads@@9@9
  000c7	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000cb	45 33 c0	 xor	 r8d, r8d
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 409  :     if (result == NULL)

  000d6	48 85 c0	 test	 rax, rax
  000d9	75 15		 jne	 SHORT $LN2@PyEval_ReI

; 410  :         PyErr_WriteUnraisable(threading);

  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 PyErr_WriteUnraisable

; 413  :     Py_DECREF(threading);

  000e3	48 8b cb	 mov	 rcx, rbx

; 414  : }

  000e6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ea	5b		 pop	 rbx
  000eb	e9 00 00 00 00	 jmp	 _Py_DecRef
$LN2@PyEval_ReI:

; 411  :     else
; 412  :         Py_DECREF(result);

  000f0	48 8b c8	 mov	 rcx, rax
  000f3	e8 00 00 00 00	 call	 _Py_DecRef

; 413  :     Py_DECREF(threading);

  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@PyEval_ReI:

; 414  : }

  00100	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00104	5b		 pop	 rbx
  00105	c3		 ret	 0
PyEval_ReInitThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@ ; `string'
PUBLIC	PyEval_RestoreThread
EXTRN	PyThread_exit_thread:PROC
EXTRN	_Py_Finalizing:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_RestoreThread DD imagerel $LN7
	DD	imagerel $LN7+44
	DD	imagerel $unwind$PyEval_RestoreThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyEval_RestoreThread DD imagerel $LN7+44
	DD	imagerel $LN7+108
	DD	imagerel $chain$0$PyEval_RestoreThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyEval_RestoreThread DD imagerel $LN7+108
	DD	imagerel $LN7+122
	DD	imagerel $chain$1$PyEval_RestoreThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyEval_RestoreThread DD 021H
	DD	imagerel $LN7
	DD	imagerel $LN7+44
	DD	imagerel $unwind$PyEval_RestoreThread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyEval_RestoreThread DD 020521H
	DD	067405H
	DD	imagerel $LN7
	DD	imagerel $LN7+44
	DD	imagerel $unwind$PyEval_RestoreThread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_RestoreThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@
CONST	SEGMENT
??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@ DB 'PyEval_Restor'
	DB	'eThread: NULL tstate', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyEval_RestoreThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_RestoreThread PROC				; COMDAT

; 471  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 472  :     if (tstate == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0c		 jne	 SHORT $LN4@PyEval_Res

; 473  :         Py_FatalError("PyEval_RestoreThread: NULL tstate");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@
  00015	e8 00 00 00 00	 call	 Py_FatalError
$LN4@PyEval_Res:

; 474  : #ifdef WITH_PARALLEL
; 475  :     /* Ensure this is a no-op when called from a parallel context thread. */
; 476  :     if (tstate->is_parallel_thread == 1)

  0001a	83 bb a8 00 00
	00 01		 cmp	 DWORD PTR [rbx+168], 1
  00021	74 51		 je	 SHORT $LN5@PyEval_Res

; 477  :         return;
; 478  : #endif
; 479  : #ifdef WITH_THREAD
; 480  :     if (gil_created()) {

  00023	e8 00 00 00 00	 call	 gil_created
  00028	85 c0		 test	 eax, eax
  0002a	74 40		 je	 SHORT $LN2@PyEval_Res

; 481  :         int err = errno;

  0002c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 482  :         take_gil(tstate);

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	8b 38		 mov	 edi, DWORD PTR [rax]
  0003c	e8 00 00 00 00	 call	 take_gil

; 483  :         /* _Py_Finalizing is protected by the GIL */
; 484  :         if (_Py_Finalizing && tstate != _Py_Finalizing) {

  00041	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _Py_Finalizing
  00048	4d 85 db	 test	 r11, r11
  0004b	74 12		 je	 SHORT $LN1@PyEval_Res
  0004d	49 3b db	 cmp	 rbx, r11
  00050	74 0d		 je	 SHORT $LN1@PyEval_Res

; 485  :             drop_gil(tstate);

  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 drop_gil

; 486  :             PyThread_exit_thread();

  0005a	e8 00 00 00 00	 call	 PyThread_exit_thread
$LN1@PyEval_Res:

; 487  :             assert(0);  /* unreachable */
; 488  :         }
; 489  :         errno = err;

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00065	89 38		 mov	 DWORD PTR [rax], edi
  00067	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN2@PyEval_Res:

; 490  :     }
; 491  : #endif
; 492  :     PyThreadState_Swap(tstate);

  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	e8 00 00 00 00	 call	 PyThreadState_Swap
$LN5@PyEval_Res:

; 493  : }

  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
PyEval_RestoreThread ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
EXTRN	PyErr_NormalizeException:PROC
EXTRN	PyErr_Fetch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_exc_trace DD imagerel call_exc_trace
	DD	imagerel call_exc_trace+331
	DD	imagerel $unwind$call_exc_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_exc_trace DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT call_exc_trace
_TEXT	SEGMENT
type$ = 48
traceback$ = 56
func$ = 80
self$ = 88
f$ = 96
value$ = 104
call_exc_trace PROC					; COMDAT

; 3778 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	49 8b d8	 mov	 rbx, r8
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 3779 :     PyObject *type, *value, *traceback, *arg;
; 3780 :     int err;
; 3781 :     PyErr_Fetch(&type, &value, &traceback);

  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR traceback$[rsp]
  00022	48 8d 54 24 68	 lea	 rdx, QWORD PTR value$[rsp]
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  0002c	e8 00 00 00 00	 call	 PyErr_Fetch

; 3782 :     if (value == NULL) {

  00031	48 83 7c 24 68
	00		 cmp	 QWORD PTR value$[rsp], 0
  00037	75 4d		 jne	 SHORT $LN20@call_exc_t

; 3783 :         value = Py_None;

  00039	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00040	48 89 7c 24 68	 mov	 QWORD PTR value$[rsp], rdi

; 3784 :         Py_INCREF(value);

  00045	e8 00 00 00 00	 call	 _Py_PXCTX
  0004a	85 c0		 test	 eax, eax
  0004c	75 38		 jne	 SHORT $LN20@call_exc_t
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0005c	4c 8b cf	 mov	 r9, rdi
  0005f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00065	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0006d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN19@call_exc_t
  00076	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0007d	74 07		 je	 SHORT $LN20@call_exc_t
$LN19@call_exc_t:
  0007f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN20@call_exc_t:

; 3785 :     }
; 3786 :     PyErr_NormalizeException(&type, &value, &traceback);

  00086	4c 8d 44 24 38	 lea	 r8, QWORD PTR traceback$[rsp]
  0008b	48 8d 54 24 68	 lea	 rdx, QWORD PTR value$[rsp]
  00090	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  00095	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 3787 :     arg = PyTuple_Pack(3, type, value, traceback);

  0009a	4c 8b 4c 24 38	 mov	 r9, QWORD PTR traceback$[rsp]
  0009f	4c 8b 44 24 68	 mov	 r8, QWORD PTR value$[rsp]
  000a4	48 8b 54 24 30	 mov	 rdx, QWORD PTR type$[rsp]
  000a9	b9 03 00 00 00	 mov	 ecx, 3
  000ae	e8 00 00 00 00	 call	 PyTuple_Pack
  000b3	48 8b f8	 mov	 rdi, rax

; 3788 :     if (arg == NULL) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	75 16		 jne	 SHORT $LN15@call_exc_t

; 3789 :         PyErr_Restore(type, value, traceback);

  000bb	4c 8b 44 24 38	 mov	 r8, QWORD PTR traceback$[rsp]
  000c0	48 8b 54 24 68	 mov	 rdx, QWORD PTR value$[rsp]
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  000ca	e8 00 00 00 00	 call	 PyErr_Restore

; 3790 :         return;

  000cf	eb 65		 jmp	 SHORT $LN2@call_exc_t
$LN15@call_exc_t:

; 3791 :     }
; 3792 :     err = call_trace(func, self, f, PyTrace_EXCEPTION, arg);

  000d1	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d7	4c 8b c3	 mov	 r8, rbx
  000da	48 8b d6	 mov	 rdx, rsi
  000dd	48 8b cd	 mov	 rcx, rbp
  000e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e5	e8 00 00 00 00	 call	 call_trace

; 3793 :     Py_DECREF(arg);

  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	8b d8		 mov	 ebx, eax
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 3794 :     if (err == 0)
; 3795 :         PyErr_Restore(type, value, traceback);

  000f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  000f9	85 db		 test	 ebx, ebx
  000fb	75 11		 jne	 SHORT $LN12@call_exc_t
  000fd	4c 8b 44 24 38	 mov	 r8, QWORD PTR traceback$[rsp]
  00102	48 8b 54 24 68	 mov	 rdx, QWORD PTR value$[rsp]
  00107	e8 00 00 00 00	 call	 PyErr_Restore

; 3796 :     else {

  0010c	eb 28		 jmp	 SHORT $LN2@call_exc_t
$LN12@call_exc_t:

; 3797 :         Py_XDECREF(type);

  0010e	48 85 c9	 test	 rcx, rcx
  00111	74 05		 je	 SHORT $LN11@call_exc_t
  00113	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@call_exc_t:

; 3798 :         Py_XDECREF(value);

  00118	48 8b 4c 24 68	 mov	 rcx, QWORD PTR value$[rsp]
  0011d	48 85 c9	 test	 rcx, rcx
  00120	74 05		 je	 SHORT $LN7@call_exc_t
  00122	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@call_exc_t:

; 3799 :         Py_XDECREF(traceback);

  00127	48 8b 4c 24 38	 mov	 rcx, QWORD PTR traceback$[rsp]
  0012c	48 85 c9	 test	 rcx, rcx
  0012f	74 05		 je	 SHORT $LN2@call_exc_t
  00131	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@call_exc_t:

; 3800 :     }
; 3801 : }

  00136	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0013b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00140	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00145	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00149	5f		 pop	 rdi
  0014a	c3		 ret	 0
call_exc_trace ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_trace_protected DD imagerel call_trace_protected
	DD	imagerel call_trace_protected+470
	DD	imagerel $unwind$call_trace_protected
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_trace_protected DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT call_trace_protected
_TEXT	SEGMENT
type$ = 48
value$ = 56
traceback$ = 64
func$ = 96
obj$ = 104
frame$ = 112
what$ = 120
arg$ = 128
call_trace_protected PROC				; COMDAT

; 3806 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	49 8b f8	 mov	 rdi, r8
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 3807 :     PyObject *type, *value, *traceback;
; 3808 :     int err;
; 3809 :     PyErr_Fetch(&type, &value, &traceback);

  0001d	4c 8d 44 24 40	 lea	 r8, QWORD PTR traceback$[rsp]
  00022	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  0002c	41 8b d9	 mov	 ebx, r9d
  0002f	e8 00 00 00 00	 call	 PyErr_Fetch

; 3810 :     err = call_trace(func, obj, frame, what, arg);

  00034	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR arg$[rsp]
  0003c	44 8b cb	 mov	 r9d, ebx
  0003f	4c 8b c7	 mov	 r8, rdi
  00042	48 8b d6	 mov	 rdx, rsi
  00045	48 8b cd	 mov	 rcx, rbp
  00048	4c 89 5c 24 20	 mov	 QWORD PTR [rsp+32], r11
  0004d	e8 00 00 00 00	 call	 call_trace

; 3811 :     if (err == 0)

  00052	85 c0		 test	 eax, eax
  00054	75 1b		 jne	 SHORT $LN12@call_trace@2

; 3812 :     {
; 3813 :         PyErr_Restore(type, value, traceback);

  00056	4c 8b 44 24 40	 mov	 r8, QWORD PTR traceback$[rsp]
  0005b	48 8b 54 24 38	 mov	 rdx, QWORD PTR value$[rsp]
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  00065	e8 00 00 00 00	 call	 PyErr_Restore

; 3814 :         return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 50 01 00 00	 jmp	 $LN13@call_trace@2
$LN12@call_trace@2:

; 3815 :     }
; 3816 :     else {
; 3817 :         Py_XDECREF(type);

  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR type$[rsp]
  00076	48 85 db	 test	 rbx, rbx
  00079	74 65		 je	 SHORT $LN11@call_trace@2
  0007b	e8 00 00 00 00	 call	 _Py_PXCTX
  00080	85 c0		 test	 eax, eax
  00082	75 5c		 jne	 SHORT $LN11@call_trace@2
  00084	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00088	a8 20		 test	 al, 32			; 00000020H
  0008a	75 4c		 jne	 SHORT $LN21@call_trace@2
  0008c	84 c0		 test	 al, al
  0008e	78 48		 js	 SHORT $LN21@call_trace@2
  00090	a8 02		 test	 al, 2
  00092	75 4c		 jne	 SHORT $LN11@call_trace@2
  00094	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00098	75 46		 jne	 SHORT $LN11@call_trace@2
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a8	4c 8b cb	 mov	 r9, rbx
  000ab	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000be	48 8b cb	 mov	 rcx, rbx
  000c1	85 c0		 test	 eax, eax
  000c3	74 07		 je	 SHORT $LN26@call_trace@2
  000c5	e8 00 00 00 00	 call	 _Px_Dealloc
  000ca	eb 14		 jmp	 SHORT $LN11@call_trace@2
$LN26@call_trace@2:
  000cc	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000d6	eb 08		 jmp	 SHORT $LN11@call_trace@2
$LN21@call_trace@2:
  000d8	48 8b cb	 mov	 rcx, rbx
  000db	e8 00 00 00 00	 call	 Px_DecRef
$LN11@call_trace@2:

; 3818 :         Py_XDECREF(value);

  000e0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR value$[rsp]
  000e5	48 85 db	 test	 rbx, rbx
  000e8	74 65		 je	 SHORT $LN7@call_trace@2
  000ea	e8 00 00 00 00	 call	 _Py_PXCTX
  000ef	85 c0		 test	 eax, eax
  000f1	75 5c		 jne	 SHORT $LN7@call_trace@2
  000f3	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000f7	a8 20		 test	 al, 32			; 00000020H
  000f9	75 4c		 jne	 SHORT $LN32@call_trace@2
  000fb	84 c0		 test	 al, al
  000fd	78 48		 js	 SHORT $LN32@call_trace@2
  000ff	a8 02		 test	 al, 2
  00101	75 4c		 jne	 SHORT $LN7@call_trace@2
  00103	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00107	75 46		 jne	 SHORT $LN7@call_trace@2
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00117	4c 8b cb	 mov	 r9, rbx
  0011a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00120	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00128	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012d	48 8b cb	 mov	 rcx, rbx
  00130	85 c0		 test	 eax, eax
  00132	74 07		 je	 SHORT $LN37@call_trace@2
  00134	e8 00 00 00 00	 call	 _Px_Dealloc
  00139	eb 14		 jmp	 SHORT $LN7@call_trace@2
$LN37@call_trace@2:
  0013b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0013f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00145	eb 08		 jmp	 SHORT $LN7@call_trace@2
$LN32@call_trace@2:
  00147	48 8b cb	 mov	 rcx, rbx
  0014a	e8 00 00 00 00	 call	 Px_DecRef
$LN7@call_trace@2:

; 3819 :         Py_XDECREF(traceback);

  0014f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR traceback$[rsp]
  00154	48 85 db	 test	 rbx, rbx
  00157	74 65		 je	 SHORT $LN3@call_trace@2
  00159	e8 00 00 00 00	 call	 _Py_PXCTX
  0015e	85 c0		 test	 eax, eax
  00160	75 5c		 jne	 SHORT $LN3@call_trace@2
  00162	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00166	a8 20		 test	 al, 32			; 00000020H
  00168	75 4c		 jne	 SHORT $LN43@call_trace@2
  0016a	84 c0		 test	 al, al
  0016c	78 48		 js	 SHORT $LN43@call_trace@2
  0016e	a8 02		 test	 al, 2
  00170	75 4c		 jne	 SHORT $LN3@call_trace@2
  00172	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00176	75 46		 jne	 SHORT $LN3@call_trace@2
  00178	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00186	4c 8b cb	 mov	 r9, rbx
  00189	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0018f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00197	e8 00 00 00 00	 call	 _PyParallel_Guard
  0019c	48 8b cb	 mov	 rcx, rbx
  0019f	85 c0		 test	 eax, eax
  001a1	74 07		 je	 SHORT $LN48@call_trace@2
  001a3	e8 00 00 00 00	 call	 _Px_Dealloc
  001a8	eb 14		 jmp	 SHORT $LN3@call_trace@2
$LN48@call_trace@2:
  001aa	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001ae	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001b4	eb 08		 jmp	 SHORT $LN3@call_trace@2
$LN43@call_trace@2:
  001b6	48 8b cb	 mov	 rcx, rbx
  001b9	e8 00 00 00 00	 call	 Px_DecRef
$LN3@call_trace@2:

; 3820 :         return -1;

  001be	83 c8 ff	 or	 eax, -1
$LN13@call_trace@2:

; 3821 :     }
; 3822 : }

  001c1	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  001c6	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  001cb	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  001d0	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001d4	5f		 pop	 rdi
  001d5	c3		 ret	 0
call_trace_protected ENDP
_TEXT	ENDS
PUBLIC	_PyEval_CallTracing
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyEval_CallTracing DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$_PyEval_CallTracing
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_CallTracing DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyEval_CallTracing
_TEXT	SEGMENT
func$ = 48
args$ = 56
_PyEval_CallTracing PROC				; COMDAT

; 3843 : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 3844 :     PyFrameObject *frame = PyEval_GetFrame();

  00020	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3845 :     PyThreadState *tstate = frame->f_tstate;

  00025	48 8b 98 c8 00
	00 00		 mov	 rbx, QWORD PTR [rax+200]

; 3846 :     int save_tracing = tstate->tracing;
; 3847 :     int save_use_tracing = tstate->use_tracing;
; 3848 :     PyObject *result;
; 3849 : 
; 3850 :     tstate->tracing = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	8b 6b 20	 mov	 ebp, DWORD PTR [rbx+32]
  00031	44 8b 63 24	 mov	 r12d, DWORD PTR [rbx+36]
  00035	89 43 20	 mov	 DWORD PTR [rbx+32], eax

; 3851 :     tstate->use_tracing = ((tstate->c_tracefunc != NULL)
; 3852 :                            || (tstate->c_profilefunc != NULL));

  00038	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  0003c	75 06		 jne	 SHORT $LN3@PyEval_Cal@2
  0003e	48 39 43 28	 cmp	 QWORD PTR [rbx+40], rax
  00042	74 05		 je	 SHORT $LN4@PyEval_Cal@2
$LN3@PyEval_Cal@2:
  00044	b8 01 00 00 00	 mov	 eax, 1
$LN4@PyEval_Cal@2:

; 3853 :     result = PyObject_Call(func, args, NULL);

  00049	45 33 c0	 xor	 r8d, r8d
  0004c	48 8b d7	 mov	 rdx, rdi
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	89 43 24	 mov	 DWORD PTR [rbx+36], eax
  00055	e8 00 00 00 00	 call	 PyObject_Call

; 3854 :     tstate->tracing = save_tracing;
; 3855 :     tstate->use_tracing = save_use_tracing;
; 3856 :     return result;
; 3857 : }

  0005a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0005f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00064	89 6b 20	 mov	 DWORD PTR [rbx+32], ebp
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	44 89 63 24	 mov	 DWORD PTR [rbx+36], r12d
  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	41 5c		 pop	 r12
  0007b	c3		 ret	 0
_PyEval_CallTracing ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetBuiltins
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetBuiltins DD imagerel $LN7
	DD	imagerel $LN7+73
	DD	imagerel $unwind$PyEval_GetBuiltins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetBuiltins DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_GetBuiltins
_TEXT	SEGMENT
PyEval_GetBuiltins PROC					; COMDAT

; 3927 : {

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3928 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00004	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3929 :     if (current_frame == NULL)

  00009	48 85 c0	 test	 rax, rax
  0000c	75 2f		 jne	 SHORT $LN2@PyEval_Get@5

; 3930 :         return PyThreadState_GET()->interp->builtins;

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 12		 je	 SHORT $LN5@PyEval_Get@5
  00017	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0001c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00020	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 3933 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
$LN5@PyEval_Get@5:

; 3930 :         return PyThreadState_GET()->interp->builtins;

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00030	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00034	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 3933 : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
$LN2@PyEval_Get@5:

; 3931 :     else
; 3932 :         return current_frame->f_builtins;

  0003d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]

; 3933 : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
PyEval_GetBuiltins ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetLocals
EXTRN	PyFrame_FastToLocals:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetLocals DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$PyEval_GetLocals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetLocals DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_GetLocals
_TEXT	SEGMENT
PyEval_GetLocals PROC					; COMDAT

; 3937 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3938 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00006	e8 00 00 00 00	 call	 PyEval_GetFrame
  0000b	48 8b d8	 mov	 rbx, rax

; 3939 :     if (current_frame == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@PyEval_Get@6

; 3943 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN1@PyEval_Get@6:

; 3940 :         return NULL;
; 3941 :     PyFrame_FastToLocals(current_frame);

  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 PyFrame_FastToLocals

; 3942 :     return current_frame->f_locals;

  00021	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 3943 : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
PyEval_GetLocals ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetGlobals
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetGlobals DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$PyEval_GetGlobals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetGlobals DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_GetGlobals
_TEXT	SEGMENT
PyEval_GetGlobals PROC					; COMDAT

; 3947 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3948 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00004	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3949 :     if (current_frame == NULL)

  00009	48 85 c0	 test	 rax, rax
  0000c	75 05		 jne	 SHORT $LN2@PyEval_Get@7

; 3953 : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
$LN2@PyEval_Get@7:

; 3950 :         return NULL;
; 3951 :     else
; 3952 :         return current_frame->f_globals;

  00013	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]

; 3953 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
PyEval_GetGlobals ENDP
_TEXT	ENDS
EXTRN	PyCFunction_Call:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$do_call DD imagerel do_call
	DD	imagerel do_call+534
	DD	imagerel $unwind$do_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_call DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT do_call
_TEXT	SEGMENT
func$ = 64
pp_stack$ = 72
na$ = 80
nk$ = 88
do_call	PROC						; COMDAT

; 4320 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4321 :     PyObject *callargs = NULL;
; 4322 :     PyObject *kwdict = NULL;

  0001a	33 ff		 xor	 edi, edi

; 4323 :     PyObject *result = NULL;

  0001c	33 db		 xor	 ebx, ebx
  0001e	41 8b c1	 mov	 eax, r9d
  00021	41 8b e8	 mov	 ebp, r8d
  00024	48 8b f2	 mov	 rsi, rdx
  00027	4c 8b e1	 mov	 r12, rcx

; 4324 : 
; 4325 :     if (nk > 0) {

  0002a	45 85 c9	 test	 r9d, r9d
  0002d	7e 1b		 jle	 SHORT $LN20@do_call

; 4326 :         kwdict = update_keyword_args(NULL, nk, pp_stack, func);

  0002f	4c 8b c9	 mov	 r9, rcx
  00032	4c 8b c2	 mov	 r8, rdx
  00035	8b d0		 mov	 edx, eax
  00037	33 c9		 xor	 ecx, ecx
  00039	e8 00 00 00 00	 call	 update_keyword_args
  0003e	48 8b f8	 mov	 rdi, rax

; 4327 :         if (kwdict == NULL)

  00041	48 85 c0	 test	 rax, rax

; 4357 :     Py_XDECREF(kwdict);

  00044	0f 84 ae 01 00
	00		 je	 $LN50@do_call
$LN20@do_call:

; 4328 :             goto call_fail;
; 4329 :     }
; 4330 :     callargs = load_args(pp_stack, na);

  0004a	8b d5		 mov	 edx, ebp
  0004c	48 8b ce	 mov	 rcx, rsi
  0004f	e8 00 00 00 00	 call	 load_args
  00054	48 8b f0	 mov	 rsi, rax

; 4331 :     if (callargs == NULL)

  00057	48 85 c0	 test	 rax, rax
  0005a	0f 84 2e 01 00
	00		 je	 $LN7@do_call

; 4332 :         goto call_fail;
; 4333 : #ifdef CALL_PROFILE
; 4334 :     /* At this point, we have to look at the type of func to
; 4335 :        update the call stats properly.  Do it here so as to avoid
; 4336 :        exposing the call stats machinery outside ceval.c
; 4337 :     */
; 4338 :     if (PyFunction_Check(func))
; 4339 :         PCALL(PCALL_FUNCTION);
; 4340 :     else if (PyMethod_Check(func))
; 4341 :         PCALL(PCALL_METHOD);
; 4342 :     else if (PyType_Check(func))
; 4343 :         PCALL(PCALL_TYPE);
; 4344 :     else if (PyCFunction_Check(func))
; 4345 :         PCALL(PCALL_CFUNCTION);
; 4346 :     else
; 4347 :         PCALL(PCALL_OTHER);
; 4348 : #endif
; 4349 :     if (PyCFunction_Check(func)) {

  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  00067	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  0006c	0f 85 a6 00 00
	00		 jne	 $LN18@do_call

; 4350 :         PyThreadState *tstate = PyThreadState_GET();

  00072	e8 00 00 00 00	 call	 _Py_PXCTX
  00077	85 c0		 test	 eax, eax
  00079	74 0a		 je	 SHORT $LN24@do_call
  0007b	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00080	48 8b e8	 mov	 rbp, rax
  00083	eb 07		 jmp	 SHORT $LN25@do_call
$LN24@do_call:
  00085	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR _PyThreadState_Current
$LN25@do_call:

; 4351 :         C_TRACE(result, PyCFunction_Call(func, callargs, kwdict));

  0008c	39 5d 24	 cmp	 DWORD PTR [rbp+36], ebx
  0008f	74 77		 je	 SHORT $LN17@do_call
  00091	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  00095	48 85 c9	 test	 rcx, rcx
  00098	74 6e		 je	 SHORT $LN17@do_call
  0009a	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  0009e	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  000a2	41 b9 04 00 00
	00		 mov	 r9d, 4
  000a8	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000ad	e8 00 00 00 00	 call	 call_trace
  000b2	85 c0		 test	 eax, eax
  000b4	75 73		 jne	 SHORT $call_fail$66565
  000b6	4c 8b c7	 mov	 r8, rdi
  000b9	48 8b d6	 mov	 rdx, rsi
  000bc	49 8b cc	 mov	 rcx, r12
  000bf	e8 00 00 00 00	 call	 PyCFunction_Call
  000c4	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  000c8	48 8b d8	 mov	 rbx, rax
  000cb	48 85 c9	 test	 rcx, rcx
  000ce	74 59		 je	 SHORT $call_fail$66565
  000d0	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  000d4	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  000d8	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000dd	48 85 c0	 test	 rax, rax
  000e0	75 0b		 jne	 SHORT $LN13@do_call
  000e2	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  000e6	e8 00 00 00 00	 call	 call_trace_protected
  000eb	eb 3c		 jmp	 SHORT $call_fail$66565
$LN13@do_call:
  000ed	41 b9 06 00 00
	00		 mov	 r9d, 6
  000f3	e8 00 00 00 00	 call	 call_trace
  000f8	85 c0		 test	 eax, eax
  000fa	74 2d		 je	 SHORT $call_fail$66565
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 _Py_DecRef
  00104	33 db		 xor	 ebx, ebx
  00106	eb 21		 jmp	 SHORT $call_fail$66565
$LN17@do_call:
  00108	4c 8b c7	 mov	 r8, rdi
  0010b	48 8b d6	 mov	 rdx, rsi
  0010e	49 8b cc	 mov	 rcx, r12
  00111	e8 00 00 00 00	 call	 PyCFunction_Call

; 4352 :     }
; 4353 :     else

  00116	eb 0e		 jmp	 SHORT $LN53@do_call
$LN18@do_call:

; 4354 :         result = PyObject_Call(func, callargs, kwdict);

  00118	4c 8b c7	 mov	 r8, rdi
  0011b	48 8b d6	 mov	 rdx, rsi
  0011e	49 8b cc	 mov	 rcx, r12
  00121	e8 00 00 00 00	 call	 PyObject_Call
$LN53@do_call:
  00126	48 8b d8	 mov	 rbx, rax
$call_fail$66565:

; 4355 : call_fail:
; 4356 :     Py_XDECREF(callargs);

  00129	e8 00 00 00 00	 call	 _Py_PXCTX
  0012e	85 c0		 test	 eax, eax
  00130	75 5c		 jne	 SHORT $LN7@do_call
  00132	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00136	a8 20		 test	 al, 32			; 00000020H
  00138	75 4c		 jne	 SHORT $LN30@do_call
  0013a	84 c0		 test	 al, al
  0013c	78 48		 js	 SHORT $LN30@do_call
  0013e	a8 02		 test	 al, 2
  00140	75 4c		 jne	 SHORT $LN7@do_call
  00142	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00146	75 46		 jne	 SHORT $LN7@do_call
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00156	4c 8b ce	 mov	 r9, rsi
  00159	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0015f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00167	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016c	48 8b ce	 mov	 rcx, rsi
  0016f	85 c0		 test	 eax, eax
  00171	74 07		 je	 SHORT $LN35@do_call
  00173	e8 00 00 00 00	 call	 _Px_Dealloc
  00178	eb 14		 jmp	 SHORT $LN7@do_call
$LN35@do_call:
  0017a	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0017e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00184	eb 08		 jmp	 SHORT $LN7@do_call
$LN30@do_call:
  00186	48 8b ce	 mov	 rcx, rsi
  00189	e8 00 00 00 00	 call	 Px_DecRef
$LN7@do_call:

; 4357 :     Py_XDECREF(kwdict);

  0018e	48 85 ff	 test	 rdi, rdi
  00191	74 65		 je	 SHORT $LN50@do_call
  00193	e8 00 00 00 00	 call	 _Py_PXCTX
  00198	85 c0		 test	 eax, eax
  0019a	75 5c		 jne	 SHORT $LN50@do_call
  0019c	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001a0	a8 20		 test	 al, 32			; 00000020H
  001a2	75 4c		 jne	 SHORT $LN41@do_call
  001a4	84 c0		 test	 al, al
  001a6	78 48		 js	 SHORT $LN41@do_call
  001a8	a8 02		 test	 al, 2
  001aa	75 4c		 jne	 SHORT $LN50@do_call
  001ac	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001b0	75 46		 jne	 SHORT $LN50@do_call
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001c0	4c 8b cf	 mov	 r9, rdi
  001c3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001c9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d6	48 8b cf	 mov	 rcx, rdi
  001d9	85 c0		 test	 eax, eax
  001db	74 07		 je	 SHORT $LN46@do_call
  001dd	e8 00 00 00 00	 call	 _Px_Dealloc
  001e2	eb 14		 jmp	 SHORT $LN50@do_call
$LN46@do_call:
  001e4	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001e8	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001ee	eb 08		 jmp	 SHORT $LN50@do_call
$LN41@do_call:
  001f0	48 8b cf	 mov	 rcx, rdi
  001f3	e8 00 00 00 00	 call	 Px_DecRef
$LN50@do_call:

; 4358 :     return result;
; 4359 : }

  001f8	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001fd	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00202	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00207	48 8b c3	 mov	 rax, rbx
  0020a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0020f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00213	41 5c		 pop	 r12
  00215	c3		 ret	 0
do_call	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@ ; `string'
PUBLIC	??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@ ; `string'
EXTRN	PySequence_Tuple:PROC
EXTRN	PyDict_Update:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$ext_do_call DD imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ext_do_call DD imagerel ext_do_call+13
	DD	imagerel ext_do_call+892
	DD	imagerel $chain$5$ext_do_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ext_do_call DD imagerel ext_do_call+892
	DD	imagerel ext_do_call+1019
	DD	imagerel $chain$6$ext_do_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ext_do_call DD 021H
	DD	imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ext_do_call DD 0c1821H
	DD	06f418H
	DD	07e414H
	DD	08d410H
	DD	0ec40cH
	DD	0d7408H
	DD	0c3404H
	DD	imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ext_do_call DD 030d01H
	DD	06009820dH
	DD	05008H
xdata	ENDS
;	COMDAT ??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@
CONST	SEGMENT
??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@ DB '%'
	DB	'.200s%.200s argument after * must be a sequence, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@
CONST	SEGMENT
??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@ DB '%'
	DB	'.200s%.200s argument after ** must be a mapping, not %.200s', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT ext_do_call
_TEXT	SEGMENT
func$ = 96
pp_stack$ = 104
flags$ = 112
na$ = 120
nk$ = 128
ext_do_call PROC					; COMDAT

; 4363 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000d	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00011	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi
  00015	4c 89 60 18	 mov	 QWORD PTR [rax+24], r12
  00019	4c 89 68 e8	 mov	 QWORD PTR [rax-24], r13
  0001d	4c 89 70 e0	 mov	 QWORD PTR [rax-32], r14
  00021	4c 89 78 d8	 mov	 QWORD PTR [rax-40], r15

; 4364 :     int nstar = 0;

  00025	45 33 ff	 xor	 r15d, r15d

; 4365 :     PyObject *callargs = NULL;
; 4366 :     PyObject *stararg = NULL;

  00028	33 ed		 xor	 ebp, ebp

; 4367 :     PyObject *kwdict = NULL;

  0002a	45 33 e4	 xor	 r12d, r12d

; 4368 :     PyObject *result = NULL;

  0002d	33 f6		 xor	 esi, esi
  0002f	45 8b f0	 mov	 r14d, r8d
  00032	48 8b fa	 mov	 rdi, rdx
  00035	4c 8b e9	 mov	 r13, rcx

; 4369 : 
; 4370 :     if (flags & CALL_FLAG_KW) {

  00038	41 f6 c0 02	 test	 r8b, 2
  0003c	0f 84 a5 00 00
	00		 je	 $LN33@ext_do_cal

; 4371 :         kwdict = EXT_POP(*pp_stack);

  00042	48 83 02 f8	 add	 QWORD PTR [rdx], -8
  00046	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00049	4c 8b 20	 mov	 r12, QWORD PTR [rax]

; 4372 :         if (!PyDict_Check(kwdict)) {

  0004c	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00051	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  0005b	0f 85 86 00 00
	00		 jne	 $LN33@ext_do_cal

; 4373 :             PyObject *d;
; 4374 :             d = PyDict_New();

  00061	e8 00 00 00 00	 call	 PyDict_New
  00066	48 8b d8	 mov	 rbx, rax

; 4375 :             if (d == NULL)

  00069	48 85 c0	 test	 rax, rax
  0006c	0f 84 7a 02 00
	00		 je	 $LN11@ext_do_cal

; 4376 :                 goto ext_call_fail;
; 4377 :             if (PyDict_Update(d, kwdict) != 0) {

  00072	49 8b d4	 mov	 rdx, r12
  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 PyDict_Update
  0007d	85 c0		 test	 eax, eax
  0007f	74 5b		 je	 SHORT $LN31@ext_do_cal

; 4378 :                 Py_DECREF(d);

  00081	48 8b cb	 mov	 rcx, rbx
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 4379 :                 /* PyDict_Update raises attribute
; 4380 :                  * error (percolated from an attempt
; 4381 :                  * to get 'keys' attribute) instead of
; 4382 :                  * a type error if its second argument
; 4383 :                  * is not a mapping.
; 4384 :                  */
; 4385 :                 if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00090	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00095	85 c0		 test	 eax, eax
  00097	0f 84 4f 02 00
	00		 je	 $LN11@ext_do_cal

; 4386 :                     PyErr_Format(PyExc_TypeError,
; 4387 :                                  "%.200s%.200s argument after ** "
; 4388 :                                  "must be a mapping, not %.200s",
; 4389 :                                  PyEval_GetFuncName(func),
; 4390 :                                  PyEval_GetFuncDesc(func),
; 4391 :                                  kwdict->ob_type->tp_name);

  0009d	49 8b 7c 24 58	 mov	 rdi, QWORD PTR [r12+88]
  000a2	49 8b cd	 mov	 rcx, r13
  000a5	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  000aa	49 8b cd	 mov	 rcx, r13
  000ad	48 8b d8	 mov	 rbx, rax
  000b0	e8 00 00 00 00	 call	 PyEval_GetFuncName
  000b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bc	4c 8b c0	 mov	 r8, rax
  000bf	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@
  000ca	4c 8b cb	 mov	 r9, rbx
  000cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d2	e8 00 00 00 00	 call	 PyErr_Format

; 4392 :                 }
; 4393 :                 goto ext_call_fail;

  000d7	e9 10 02 00 00	 jmp	 $LN11@ext_do_cal
$LN31@ext_do_cal:

; 4394 :             }
; 4395 :             Py_DECREF(kwdict);

  000dc	49 8b cc	 mov	 rcx, r12
  000df	e8 00 00 00 00	 call	 _Py_DecRef

; 4396 :             kwdict = d;

  000e4	4c 8b e3	 mov	 r12, rbx
$LN33@ext_do_cal:

; 4397 :         }
; 4398 :     }
; 4399 :     if (flags & CALL_FLAG_VAR) {

  000e7	41 f6 c6 01	 test	 r14b, 1
  000eb	0f 84 8b 00 00
	00		 je	 $LN29@ext_do_cal

; 4400 :         stararg = EXT_POP(*pp_stack);

  000f1	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  000f5	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000f8	48 8b 28	 mov	 rbp, QWORD PTR [rax]

; 4401 :         if (!PyTuple_Check(stararg)) {

  000fb	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  000ff	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  00109	75 6d		 jne	 SHORT $LN28@ext_do_cal

; 4402 :             PyObject *t = NULL;
; 4403 :             t = PySequence_Tuple(stararg);

  0010b	48 8b cd	 mov	 rcx, rbp
  0010e	e8 00 00 00 00	 call	 PySequence_Tuple
  00113	48 8b d8	 mov	 rbx, rax

; 4404 :             if (t == NULL) {

  00116	48 85 c0	 test	 rax, rax
  00119	75 52		 jne	 SHORT $LN27@ext_do_cal

; 4405 :                 if (PyErr_ExceptionMatches(PyExc_TypeError)) {

  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00122	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00127	85 c0		 test	 eax, eax
  00129	0f 84 bd 01 00
	00		 je	 $LN11@ext_do_cal

; 4406 :                     PyErr_Format(PyExc_TypeError,
; 4407 :                                  "%.200s%.200s argument after * "
; 4408 :                                  "must be a sequence, not %.200s",
; 4409 :                                  PyEval_GetFuncName(func),
; 4410 :                                  PyEval_GetFuncDesc(func),
; 4411 :                                  stararg->ob_type->tp_name);

  0012f	48 8b 7d 58	 mov	 rdi, QWORD PTR [rbp+88]
  00133	49 8b cd	 mov	 rcx, r13
  00136	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  0013b	49 8b cd	 mov	 rcx, r13
  0013e	48 8b d8	 mov	 rbx, rax
  00141	e8 00 00 00 00	 call	 PyEval_GetFuncName
  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014d	4c 8b c0	 mov	 r8, rax
  00150	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@
  0015b	4c 8b cb	 mov	 r9, rbx
  0015e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00163	e8 00 00 00 00	 call	 PyErr_Format

; 4412 :                 }
; 4413 :                 goto ext_call_fail;

  00168	e9 7f 01 00 00	 jmp	 $LN11@ext_do_cal
$LN27@ext_do_cal:

; 4414 :             }
; 4415 :             Py_DECREF(stararg);

  0016d	48 8b cd	 mov	 rcx, rbp
  00170	e8 00 00 00 00	 call	 _Py_DecRef

; 4416 :             stararg = t;

  00175	48 8b eb	 mov	 rbp, rbx
$LN28@ext_do_cal:

; 4417 :         }
; 4418 :         nstar = PyTuple_GET_SIZE(stararg);

  00178	44 8b 7d 60	 mov	 r15d, DWORD PTR [rbp+96]
$LN29@ext_do_cal:

; 4419 :     }
; 4420 :     if (nk > 0) {

  0017c	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR nk$[rsp]
  00183	85 d2		 test	 edx, edx
  00185	7e 1a		 jle	 SHORT $LN24@ext_do_cal

; 4421 :         kwdict = update_keyword_args(kwdict, nk, pp_stack, func);

  00187	4d 8b cd	 mov	 r9, r13
  0018a	4c 8b c7	 mov	 r8, rdi
  0018d	49 8b cc	 mov	 rcx, r12
  00190	e8 00 00 00 00	 call	 update_keyword_args
  00195	4c 8b e0	 mov	 r12, rax

; 4422 :         if (kwdict == NULL)

  00198	48 85 c0	 test	 rax, rax
  0019b	0f 84 b8 01 00
	00		 je	 $LN7@ext_do_cal
$LN24@ext_do_cal:

; 4423 :             goto ext_call_fail;
; 4424 :     }
; 4425 :     callargs = update_star_args(na, nstar, stararg, pp_stack);

  001a1	8b 4c 24 78	 mov	 ecx, DWORD PTR na$[rsp]
  001a5	4c 8b cf	 mov	 r9, rdi
  001a8	4c 8b c5	 mov	 r8, rbp
  001ab	41 8b d7	 mov	 edx, r15d
  001ae	e8 00 00 00 00	 call	 update_star_args
  001b3	48 8b d8	 mov	 rbx, rax

; 4426 :     if (callargs == NULL)

  001b6	48 85 c0	 test	 rax, rax
  001b9	0f 84 2d 01 00
	00		 je	 $LN11@ext_do_cal

; 4427 :         goto ext_call_fail;
; 4428 : #ifdef CALL_PROFILE
; 4429 :     /* At this point, we have to look at the type of func to
; 4430 :        update the call stats properly.  Do it here so as to avoid
; 4431 :        exposing the call stats machinery outside ceval.c
; 4432 :     */
; 4433 :     if (PyFunction_Check(func))
; 4434 :         PCALL(PCALL_FUNCTION);
; 4435 :     else if (PyMethod_Check(func))
; 4436 :         PCALL(PCALL_METHOD);
; 4437 :     else if (PyType_Check(func))
; 4438 :         PCALL(PCALL_TYPE);
; 4439 :     else if (PyCFunction_Check(func))
; 4440 :         PCALL(PCALL_CFUNCTION);
; 4441 :     else
; 4442 :         PCALL(PCALL_OTHER);
; 4443 : #endif
; 4444 :     if (PyCFunction_Check(func)) {

  001bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  001c6	49 39 45 58	 cmp	 QWORD PTR [r13+88], rax
  001ca	0f 85 a6 00 00
	00		 jne	 $LN22@ext_do_cal

; 4445 :         PyThreadState *tstate = PyThreadState_GET();

  001d0	e8 00 00 00 00	 call	 _Py_PXCTX
  001d5	85 c0		 test	 eax, eax
  001d7	74 0a		 je	 SHORT $LN37@ext_do_cal
  001d9	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  001de	48 8b f8	 mov	 rdi, rax
  001e1	eb 07		 jmp	 SHORT $LN38@ext_do_cal
$LN37@ext_do_cal:
  001e3	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR _PyThreadState_Current
$LN38@ext_do_cal:

; 4446 :         C_TRACE(result, PyCFunction_Call(func, callargs, kwdict));

  001ea	39 77 24	 cmp	 DWORD PTR [rdi+36], esi
  001ed	74 77		 je	 SHORT $LN21@ext_do_cal
  001ef	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  001f3	48 85 c9	 test	 rcx, rcx
  001f6	74 6e		 je	 SHORT $LN21@ext_do_cal
  001f8	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  001fc	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00200	41 b9 04 00 00
	00		 mov	 r9d, 4
  00206	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0020b	e8 00 00 00 00	 call	 call_trace
  00210	85 c0		 test	 eax, eax
  00212	75 73		 jne	 SHORT $ext_call_fail$66622
  00214	4d 8b c4	 mov	 r8, r12
  00217	48 8b d3	 mov	 rdx, rbx
  0021a	49 8b cd	 mov	 rcx, r13
  0021d	e8 00 00 00 00	 call	 PyCFunction_Call
  00222	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00226	48 8b f0	 mov	 rsi, rax
  00229	48 85 c9	 test	 rcx, rcx
  0022c	74 59		 je	 SHORT $ext_call_fail$66622
  0022e	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00232	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00236	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0023b	48 85 c0	 test	 rax, rax
  0023e	75 0b		 jne	 SHORT $LN17@ext_do_cal
  00240	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  00244	e8 00 00 00 00	 call	 call_trace_protected
  00249	eb 3c		 jmp	 SHORT $ext_call_fail$66622
$LN17@ext_do_cal:
  0024b	41 b9 06 00 00
	00		 mov	 r9d, 6
  00251	e8 00 00 00 00	 call	 call_trace
  00256	85 c0		 test	 eax, eax
  00258	74 2d		 je	 SHORT $ext_call_fail$66622
  0025a	48 8b ce	 mov	 rcx, rsi
  0025d	e8 00 00 00 00	 call	 _Py_DecRef
  00262	33 f6		 xor	 esi, esi
  00264	eb 21		 jmp	 SHORT $ext_call_fail$66622
$LN21@ext_do_cal:
  00266	4d 8b c4	 mov	 r8, r12
  00269	48 8b d3	 mov	 rdx, rbx
  0026c	49 8b cd	 mov	 rcx, r13
  0026f	e8 00 00 00 00	 call	 PyCFunction_Call

; 4447 :     }
; 4448 :     else

  00274	eb 0e		 jmp	 SHORT $LN76@ext_do_cal
$LN22@ext_do_cal:

; 4449 :         result = PyObject_Call(func, callargs, kwdict);

  00276	4d 8b c4	 mov	 r8, r12
  00279	48 8b d3	 mov	 rdx, rbx
  0027c	49 8b cd	 mov	 rcx, r13
  0027f	e8 00 00 00 00	 call	 PyObject_Call
$LN76@ext_do_cal:
  00284	48 8b f0	 mov	 rsi, rax
$ext_call_fail$66622:

; 4450 : ext_call_fail:
; 4451 :     Py_XDECREF(callargs);

  00287	e8 00 00 00 00	 call	 _Py_PXCTX
  0028c	85 c0		 test	 eax, eax
  0028e	75 5c		 jne	 SHORT $LN11@ext_do_cal
  00290	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00294	a8 20		 test	 al, 32			; 00000020H
  00296	75 4c		 jne	 SHORT $LN43@ext_do_cal
  00298	84 c0		 test	 al, al
  0029a	78 48		 js	 SHORT $LN43@ext_do_cal
  0029c	a8 02		 test	 al, 2
  0029e	75 4c		 jne	 SHORT $LN11@ext_do_cal
  002a0	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002a4	75 46		 jne	 SHORT $LN11@ext_do_cal
  002a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002b4	4c 8b cb	 mov	 r9, rbx
  002b7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002bd	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  002ca	48 8b cb	 mov	 rcx, rbx
  002cd	85 c0		 test	 eax, eax
  002cf	74 07		 je	 SHORT $LN48@ext_do_cal
  002d1	e8 00 00 00 00	 call	 _Px_Dealloc
  002d6	eb 14		 jmp	 SHORT $LN11@ext_do_cal
$LN48@ext_do_cal:
  002d8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002dc	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002e2	eb 08		 jmp	 SHORT $LN11@ext_do_cal
$LN43@ext_do_cal:
  002e4	48 8b cb	 mov	 rcx, rbx
  002e7	e8 00 00 00 00	 call	 Px_DecRef
$LN11@ext_do_cal:

; 4452 :     Py_XDECREF(kwdict);

  002ec	4d 85 e4	 test	 r12, r12
  002ef	74 68		 je	 SHORT $LN7@ext_do_cal
  002f1	e8 00 00 00 00	 call	 _Py_PXCTX
  002f6	85 c0		 test	 eax, eax
  002f8	75 5f		 jne	 SHORT $LN7@ext_do_cal
  002fa	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  002ff	a8 20		 test	 al, 32			; 00000020H
  00301	75 4e		 jne	 SHORT $LN54@ext_do_cal
  00303	84 c0		 test	 al, al
  00305	78 4a		 js	 SHORT $LN54@ext_do_cal
  00307	a8 02		 test	 al, 2
  00309	75 4e		 jne	 SHORT $LN7@ext_do_cal
  0030b	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  00310	75 47		 jne	 SHORT $LN7@ext_do_cal
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00320	4d 8b cc	 mov	 r9, r12
  00323	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00329	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00331	e8 00 00 00 00	 call	 _PyParallel_Guard
  00336	49 8b cc	 mov	 rcx, r12
  00339	85 c0		 test	 eax, eax
  0033b	74 07		 je	 SHORT $LN59@ext_do_cal
  0033d	e8 00 00 00 00	 call	 _Px_Dealloc
  00342	eb 15		 jmp	 SHORT $LN7@ext_do_cal
$LN59@ext_do_cal:
  00344	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00349	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0034f	eb 08		 jmp	 SHORT $LN7@ext_do_cal
$LN54@ext_do_cal:
  00351	49 8b cc	 mov	 rcx, r12
  00354	e8 00 00 00 00	 call	 Px_DecRef
$LN7@ext_do_cal:

; 4453 :     Py_XDECREF(stararg);

  00359	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  0035e	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  00363	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  00368	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  0036d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00372	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00377	48 85 ed	 test	 rbp, rbp
  0037a	74 75		 je	 SHORT $LN74@ext_do_cal
  0037c	e8 00 00 00 00	 call	 _Py_PXCTX
  00381	85 c0		 test	 eax, eax
  00383	75 6c		 jne	 SHORT $LN74@ext_do_cal
  00385	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00389	a8 20		 test	 al, 32			; 00000020H
  0038b	75 5c		 jne	 SHORT $LN65@ext_do_cal
  0038d	84 c0		 test	 al, al
  0038f	78 58		 js	 SHORT $LN65@ext_do_cal
  00391	a8 02		 test	 al, 2
  00393	75 5c		 jne	 SHORT $LN74@ext_do_cal
  00395	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00399	75 56		 jne	 SHORT $LN74@ext_do_cal
  0039b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003a9	4c 8b cd	 mov	 r9, rbp
  003ac	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003b2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003ba	e8 00 00 00 00	 call	 _PyParallel_Guard
  003bf	48 8b cd	 mov	 rcx, rbp
  003c2	85 c0		 test	 eax, eax
  003c4	74 0f		 je	 SHORT $LN70@ext_do_cal
  003c6	e8 00 00 00 00	 call	 _Px_Dealloc

; 4454 :     return result;

  003cb	48 8b c6	 mov	 rax, rsi

; 4455 : }

  003ce	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003d2	5e		 pop	 rsi
  003d3	5d		 pop	 rbp
  003d4	c3		 ret	 0

; 4453 :     Py_XDECREF(stararg);

$LN70@ext_do_cal:
  003d5	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  003d9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 4454 :     return result;

  003df	48 8b c6	 mov	 rax, rsi

; 4455 : }

  003e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003e6	5e		 pop	 rsi
  003e7	5d		 pop	 rbp
  003e8	c3		 ret	 0

; 4453 :     Py_XDECREF(stararg);

$LN65@ext_do_cal:
  003e9	48 8b cd	 mov	 rcx, rbp
  003ec	e8 00 00 00 00	 call	 Px_DecRef
$LN74@ext_do_cal:

; 4454 :     return result;

  003f1	48 8b c6	 mov	 rax, rsi

; 4455 : }

  003f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003f8	5e		 pop	 rsi
  003f9	5d		 pop	 rbp
  003fa	c3		 ret	 0
ext_do_call ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_function DD imagerel call_function
	DD	imagerel call_function+13
	DD	imagerel $unwind$call_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$call_function DD imagerel call_function+13
	DD	imagerel call_function+944
	DD	imagerel $chain$3$call_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$call_function DD imagerel call_function+944
	DD	imagerel call_function+1076
	DD	imagerel $chain$4$call_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$call_function DD 021H
	DD	imagerel call_function
	DD	imagerel call_function+13
	DD	imagerel $unwind$call_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$call_function DD 082c21H
	DD	06e42cH
	DD	0ed415H
	DD	0dc40aH
	DD	0c6405H
	DD	imagerel call_function
	DD	imagerel call_function+13
	DD	imagerel $unwind$call_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_function DD 050a01H
	DD	0f006620aH
	DD	050037004H
	DD	03002H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
xdata	ENDS
;	COMDAT call_function
_TEXT	SEGMENT
pp_stack$ = 96
oparg$ = 104
call_function PROC					; COMDAT

; 4098 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 57		 push	 r15
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4099 :     int na = oparg & 0xff;
; 4100 :     int nk = (oparg>>8) & 0xff;
; 4101 :     int n = na + 2 * nk;
; 4102 :     PyObject **pfunc = (*pp_stack) - n - 1;

  0000a	4c 8b 39	 mov	 r15, QWORD PTR [rcx]
  0000d	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00012	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00017	0f b6 fa	 movzx	 edi, dl
  0001a	c1 fa 08	 sar	 edx, 8
  0001d	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  00022	44 0f b6 e2	 movzx	 r12d, dl
  00026	48 8b e9	 mov	 rbp, rcx

; 4103 :     PyObject *func = *pfunc;
; 4104 :     PyObject *x, *w;
; 4105 : 
; 4106 :     /* Always dispatch PyCFunction first, because these are
; 4107 :        presumed to be the most frequent callable object.
; 4108 :     */
; 4109 :     if (PyCFunction_Check(func) && nk == 0) {

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyCFunction_Type
  00030	46 8d 2c 67	 lea	 r13d, DWORD PTR [rdi+r12*2]
  00034	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  00039	49 63 c5	 movsxd	 rax, r13d
  0003c	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00044	4c 2b f8	 sub	 r15, rax
  00047	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
  0004a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0004e	48 3b c1	 cmp	 rax, rcx
  00051	0f 85 82 02 00
	00		 jne	 $LN42@call_funct
  00057	84 d2		 test	 dl, dl
  00059	0f 85 7a 02 00
	00		 jne	 $LN42@call_funct

; 4110 :         int flags = PyCFunction_GET_FLAGS(func);

  0005f	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00063	44 8b 60 10	 mov	 r12d, DWORD PTR [rax+16]

; 4111 :         PyThreadState *tstate = PyThreadState_GET();

  00067	e8 00 00 00 00	 call	 _Py_PXCTX
  0006c	85 c0		 test	 eax, eax
  0006e	74 0a		 je	 SHORT $LN45@call_funct
  00070	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00075	48 8b f0	 mov	 rsi, rax
  00078	eb 07		 jmp	 SHORT $LN46@call_funct
$LN45@call_funct:
  0007a	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR _PyThreadState_Current
$LN46@call_funct:

; 4112 : 
; 4113 :         PCALL(PCALL_CFUNCTION);
; 4114 :         if (flags & (METH_NOARGS | METH_O)) {

  00081	41 f6 c4 0c	 test	 r12b, 12
  00085	0f 84 9e 01 00
	00		 je	 $LN41@call_funct

; 4115 :             PyCFunction meth = PyCFunction_GET_FUNCTION(func);

  0008b	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]

; 4116 :             PyObject *self = PyCFunction_GET_SELF(func);

  0008f	f6 40 10 20	 test	 BYTE PTR [rax+16], 32	; 00000020H
  00093	4c 8b 70 08	 mov	 r14, QWORD PTR [rax+8]
  00097	74 05		 je	 SHORT $LN47@call_funct
  00099	45 33 ed	 xor	 r13d, r13d
  0009c	eb 04		 jmp	 SHORT $LN48@call_funct
$LN47@call_funct:
  0009e	4c 8b 6b 68	 mov	 r13, QWORD PTR [rbx+104]
$LN48@call_funct:

; 4117 :             if (flags & METH_NOARGS && na == 0) {

  000a2	41 f6 c4 04	 test	 r12b, 4
  000a6	0f 84 a5 00 00
	00		 je	 $LN40@call_funct
  000ac	85 ff		 test	 edi, edi
  000ae	0f 85 9d 00 00
	00		 jne	 $LN40@call_funct

; 4118 :                 C_TRACE(x, (*meth)(self,NULL));

  000b4	39 7e 24	 cmp	 DWORD PTR [rsi+36], edi
  000b7	0f 84 84 00 00
	00		 je	 $LN39@call_funct
  000bd	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  000c1	48 85 c9	 test	 rcx, rcx
  000c4	74 7b		 je	 SHORT $LN39@call_funct
  000c6	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  000ca	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  000ce	44 8d 4f 04	 lea	 r9d, QWORD PTR [rdi+4]
  000d2	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000d7	e8 00 00 00 00	 call	 call_trace
  000dc	85 c0		 test	 eax, eax
  000de	74 07		 je	 SHORT $LN38@call_funct
  000e0	33 ff		 xor	 edi, edi
  000e2	e9 a3 02 00 00	 jmp	 $LN64@call_funct
$LN38@call_funct:
  000e7	33 d2		 xor	 edx, edx
  000e9	49 8b cd	 mov	 rcx, r13
  000ec	41 ff d6	 call	 r14
  000ef	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  000f3	48 8b f8	 mov	 rdi, rax
  000f6	48 85 c9	 test	 rcx, rcx
  000f9	0f 84 8b 02 00
	00		 je	 $LN64@call_funct
  000ff	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  00103	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  00107	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0010c	48 85 c0	 test	 rax, rax
  0010f	75 0e		 jne	 SHORT $LN35@call_funct
  00111	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  00115	e8 00 00 00 00	 call	 call_trace_protected
  0011a	e9 6b 02 00 00	 jmp	 $LN64@call_funct
$LN35@call_funct:
  0011f	41 b9 06 00 00
	00		 mov	 r9d, 6
  00125	e8 00 00 00 00	 call	 call_trace
  0012a	85 c0		 test	 eax, eax
  0012c	0f 84 58 02 00
	00		 je	 $LN64@call_funct
  00132	48 8b cf	 mov	 rcx, rdi
  00135	e8 00 00 00 00	 call	 _Py_DecRef
  0013a	33 ff		 xor	 edi, edi
  0013c	e9 49 02 00 00	 jmp	 $LN64@call_funct
$LN39@call_funct:
  00141	33 d2		 xor	 edx, edx
  00143	49 8b cd	 mov	 rcx, r13
  00146	41 ff d6	 call	 r14
  00149	48 8b f8	 mov	 rdi, rax
  0014c	e9 39 02 00 00	 jmp	 $LN64@call_funct
$LN40@call_funct:

; 4119 :             }
; 4120 :             else if (flags & METH_O && na == 1) {

  00151	41 f6 c4 08	 test	 r12b, 8
  00155	0f 84 b9 00 00
	00		 je	 $LN30@call_funct
  0015b	83 ff 01	 cmp	 edi, 1
  0015e	0f 85 b0 00 00
	00		 jne	 $LN30@call_funct

; 4121 :                 PyObject *arg = EXT_POP(*pp_stack);

  00164	48 83 45 00 f8	 add	 QWORD PTR [rbp], -8

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  00169	83 7e 24 00	 cmp	 DWORD PTR [rsi+36], 0
  0016d	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  00171	4c 8b 20	 mov	 r12, QWORD PTR [rax]
  00174	0f 84 86 00 00
	00		 je	 $LN29@call_funct
  0017a	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  0017e	48 85 c9	 test	 rcx, rcx
  00181	74 7d		 je	 SHORT $LN29@call_funct
  00183	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  00187	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  0018b	44 8d 4f 03	 lea	 r9d, QWORD PTR [rdi+3]
  0018f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00194	e8 00 00 00 00	 call	 call_trace
  00199	85 c0		 test	 eax, eax
  0019b	74 0a		 je	 SHORT $LN28@call_funct
  0019d	33 ff		 xor	 edi, edi

; 4123 :                 Py_DECREF(arg);

  0019f	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  001a2	e9 de 01 00 00	 jmp	 $LN66@call_funct
$LN28@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  001a7	49 8b d4	 mov	 rdx, r12
  001aa	49 8b cd	 mov	 rcx, r13
  001ad	41 ff d6	 call	 r14
  001b0	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  001b4	48 8b f8	 mov	 rdi, rax
  001b7	48 85 c9	 test	 rcx, rcx
  001ba	74 50		 je	 SHORT $LN22@call_funct
  001bc	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  001c0	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  001c4	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001c9	48 85 c0	 test	 rax, rax
  001cc	75 11		 jne	 SHORT $LN25@call_funct
  001ce	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  001d2	e8 00 00 00 00	 call	 call_trace_protected

; 4123 :                 Py_DECREF(arg);

  001d7	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  001da	e9 a6 01 00 00	 jmp	 $LN66@call_funct
$LN25@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  001df	41 b9 06 00 00
	00		 mov	 r9d, 6
  001e5	e8 00 00 00 00	 call	 call_trace
  001ea	85 c0		 test	 eax, eax
  001ec	74 1e		 je	 SHORT $LN22@call_funct
  001ee	48 8b cf	 mov	 rcx, rdi
  001f1	e8 00 00 00 00	 call	 _Py_DecRef
  001f6	33 ff		 xor	 edi, edi

; 4123 :                 Py_DECREF(arg);

  001f8	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  001fb	e9 85 01 00 00	 jmp	 $LN66@call_funct
$LN29@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  00200	49 8b d4	 mov	 rdx, r12
  00203	49 8b cd	 mov	 rcx, r13
  00206	41 ff d6	 call	 r14
  00209	48 8b f8	 mov	 rdi, rax
$LN22@call_funct:

; 4123 :                 Py_DECREF(arg);

  0020c	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  0020f	e9 71 01 00 00	 jmp	 $LN66@call_funct
$LN30@call_funct:

; 4126 :                 err_args(func, flags, na);

  00214	44 8b c7	 mov	 r8d, edi
  00217	41 8b d4	 mov	 edx, r12d
  0021a	48 8b cb	 mov	 rcx, rbx
  0021d	e8 00 00 00 00	 call	 err_args

; 4127 :                 x = NULL;

  00222	33 ff		 xor	 edi, edi

; 4128 :             }
; 4129 :         }
; 4130 :         else {

  00224	e9 61 01 00 00	 jmp	 $LN64@call_funct
$LN41@call_funct:

; 4131 :             PyObject *callargs;
; 4132 :             callargs = load_args(pp_stack, na);

  00229	8b d7		 mov	 edx, edi
  0022b	48 8b cd	 mov	 rcx, rbp
  0022e	e8 00 00 00 00	 call	 load_args

; 4133 :             READ_TIMESTAMP(*pintr0);
; 4134 :             C_TRACE(x, PyCFunction_Call(func,callargs,NULL));

  00233	83 7e 24 00	 cmp	 DWORD PTR [rsi+36], 0
  00237	4c 8b e0	 mov	 r12, rax
  0023a	74 7b		 je	 SHORT $LN19@call_funct
  0023c	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  00240	48 85 c9	 test	 rcx, rcx
  00243	74 72		 je	 SHORT $LN19@call_funct
  00245	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  00249	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  0024d	41 b9 04 00 00
	00		 mov	 r9d, 4
  00253	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00258	e8 00 00 00 00	 call	 call_trace
  0025d	85 c0		 test	 eax, eax
  0025f	74 04		 je	 SHORT $LN18@call_funct
  00261	33 ff		 xor	 edi, edi
  00263	eb 63		 jmp	 SHORT $LN11@call_funct
$LN18@call_funct:
  00265	45 33 c0	 xor	 r8d, r8d
  00268	49 8b d4	 mov	 rdx, r12
  0026b	48 8b cb	 mov	 rcx, rbx
  0026e	e8 00 00 00 00	 call	 PyCFunction_Call
  00273	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  00277	48 8b f8	 mov	 rdi, rax
  0027a	48 85 c9	 test	 rcx, rcx
  0027d	74 49		 je	 SHORT $LN11@call_funct
  0027f	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  00283	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  00287	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0028c	48 85 c0	 test	 rax, rax
  0028f	75 0b		 jne	 SHORT $LN15@call_funct
  00291	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  00295	e8 00 00 00 00	 call	 call_trace_protected
  0029a	eb 2c		 jmp	 SHORT $LN11@call_funct
$LN15@call_funct:
  0029c	41 b9 06 00 00
	00		 mov	 r9d, 6
  002a2	e8 00 00 00 00	 call	 call_trace
  002a7	85 c0		 test	 eax, eax
  002a9	74 1d		 je	 SHORT $LN11@call_funct
  002ab	48 8b cf	 mov	 rcx, rdi
  002ae	e8 00 00 00 00	 call	 _Py_DecRef
  002b3	33 ff		 xor	 edi, edi
  002b5	eb 11		 jmp	 SHORT $LN11@call_funct
$LN19@call_funct:
  002b7	45 33 c0	 xor	 r8d, r8d
  002ba	48 8b d0	 mov	 rdx, rax
  002bd	48 8b cb	 mov	 rcx, rbx
  002c0	e8 00 00 00 00	 call	 PyCFunction_Call
  002c5	48 8b f8	 mov	 rdi, rax
$LN11@call_funct:

; 4135 :             READ_TIMESTAMP(*pintr1);
; 4136 :             Py_XDECREF(callargs);

  002c8	4d 85 e4	 test	 r12, r12
  002cb	0f 84 b9 00 00
	00		 je	 $LN64@call_funct
  002d1	49 8b cc	 mov	 rcx, r12

; 4137 :         }
; 4138 :     } else {

  002d4	e9 ac 00 00 00	 jmp	 $LN66@call_funct
$LN42@call_funct:

; 4139 :         if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {

  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMethod_Type
  002e0	48 3b c1	 cmp	 rax, rcx
  002e3	75 2f		 jne	 SHORT $LN6@call_funct
  002e5	48 8b 73 68	 mov	 rsi, QWORD PTR [rbx+104]
  002e9	48 85 f6	 test	 rsi, rsi
  002ec	74 26		 je	 SHORT $LN6@call_funct

; 4140 :             /* optimize access to bound methods */
; 4141 :             PyObject *self = PyMethod_GET_SELF(func);
; 4142 :             PCALL(PCALL_METHOD);
; 4143 :             PCALL(PCALL_BOUND_METHOD);
; 4144 :             Py_INCREF(self);

  002ee	48 8b ce	 mov	 rcx, rsi
  002f1	e8 00 00 00 00	 call	 _Py_IncRef

; 4145 :             func = PyMethod_GET_FUNCTION(func);

  002f6	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]

; 4146 :             Py_INCREF(func);

  002fa	48 8b cb	 mov	 rcx, rbx
  002fd	e8 00 00 00 00	 call	 _Py_IncRef

; 4147 :             Py_DECREF(*pfunc);

  00302	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  00305	e8 00 00 00 00	 call	 _Py_DecRef

; 4148 :             *pfunc = self;
; 4149 :             na++;

  0030a	ff c7		 inc	 edi

; 4150 :             n++;

  0030c	41 ff c5	 inc	 r13d
  0030f	49 89 37	 mov	 QWORD PTR [r15], rsi

; 4151 :         } else

  00312	eb 3b		 jmp	 SHORT $LN50@call_funct
$LN6@call_funct:

; 4152 :             Py_INCREF(func);

  00314	e8 00 00 00 00	 call	 _Py_PXCTX
  00319	85 c0		 test	 eax, eax
  0031b	75 32		 jne	 SHORT $LN50@call_funct
  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0032b	4c 8b cb	 mov	 r9, rbx
  0032e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00334	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0033c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00341	85 c0		 test	 eax, eax
  00343	75 06		 jne	 SHORT $LN49@call_funct
  00345	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00349	74 04		 je	 SHORT $LN50@call_funct
$LN49@call_funct:
  0034b	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN50@call_funct:

; 4153 :         READ_TIMESTAMP(*pintr0);
; 4154 :         if (PyFunction_Check(func))

  0034f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFunction_Type

; 4155 :             x = fast_function(func, pp_stack, n, na, nk);

  00356	48 8b d5	 mov	 rdx, rbp
  00359	48 8b cb	 mov	 rcx, rbx
  0035c	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00360	75 12		 jne	 SHORT $LN4@call_funct
  00362	44 8b cf	 mov	 r9d, edi
  00365	45 8b c5	 mov	 r8d, r13d
  00368	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  0036d	e8 00 00 00 00	 call	 fast_function

; 4156 :         else

  00372	eb 0b		 jmp	 SHORT $LN67@call_funct
$LN4@call_funct:

; 4157 :             x = do_call(func, pp_stack, na, nk);

  00374	45 8b cc	 mov	 r9d, r12d
  00377	44 8b c7	 mov	 r8d, edi
  0037a	e8 00 00 00 00	 call	 do_call
$LN67@call_funct:
  0037f	48 8b f8	 mov	 rdi, rax

; 4158 :         READ_TIMESTAMP(*pintr1);
; 4159 :         Py_DECREF(func);

  00382	48 8b cb	 mov	 rcx, rbx
$LN66@call_funct:
  00385	e8 00 00 00 00	 call	 _Py_DecRef
$LN64@call_funct:
  0038a	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
  0038f	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  00394	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00399	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]

; 4160 :     }
; 4161 : 
; 4162 :     /* Clear the stack of the function object.  Also removes
; 4163 :        the arguments in case they weren't consumed already
; 4164 :        (fast_function() and err_args() leave them on the stack).
; 4165 :      */
; 4166 :     while ((*pp_stack) > pfunc) {

  0039e	4c 39 7d 00	 cmp	 QWORD PTR [rbp], r15
  003a2	0f 86 7f 00 00
	00		 jbe	 $LN65@call_funct
  003a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@call_funct:

; 4167 :         w = EXT_POP(*pp_stack);

  003b0	48 83 45 00 f8	 add	 QWORD PTR [rbp], -8
  003b5	48 8b 45 00	 mov	 rax, QWORD PTR [rbp]
  003b9	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 4168 :         Py_DECREF(w);

  003bc	e8 00 00 00 00	 call	 _Py_PXCTX
  003c1	85 c0		 test	 eax, eax
  003c3	75 5c		 jne	 SHORT $LN63@call_funct
  003c5	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  003c9	a8 20		 test	 al, 32			; 00000020H
  003cb	75 4c		 jne	 SHORT $LN57@call_funct
  003cd	84 c0		 test	 al, al
  003cf	78 48		 js	 SHORT $LN57@call_funct
  003d1	a8 02		 test	 al, 2
  003d3	75 4c		 jne	 SHORT $LN63@call_funct
  003d5	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  003d9	75 46		 jne	 SHORT $LN63@call_funct
  003db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  003e9	4c 8b cb	 mov	 r9, rbx
  003ec	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  003f2	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  003ff	48 8b cb	 mov	 rcx, rbx
  00402	85 c0		 test	 eax, eax
  00404	74 07		 je	 SHORT $LN62@call_funct
  00406	e8 00 00 00 00	 call	 _Px_Dealloc
  0040b	eb 14		 jmp	 SHORT $LN63@call_funct
$LN62@call_funct:
  0040d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00411	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00417	eb 08		 jmp	 SHORT $LN63@call_funct
$LN57@call_funct:
  00419	48 8b cb	 mov	 rcx, rbx
  0041c	e8 00 00 00 00	 call	 Px_DecRef
$LN63@call_funct:

; 4160 :     }
; 4161 : 
; 4162 :     /* Clear the stack of the function object.  Also removes
; 4163 :        the arguments in case they weren't consumed already
; 4164 :        (fast_function() and err_args() leave them on the stack).
; 4165 :      */
; 4166 :     while ((*pp_stack) > pfunc) {

  00421	4c 39 7d 00	 cmp	 QWORD PTR [rbp], r15
  00425	77 89		 ja	 SHORT $LL2@call_funct
$LN65@call_funct:

; 4169 :         PCALL(PCALL_POP);
; 4170 :     }
; 4171 :     return x;

  00427	48 8b c7	 mov	 rax, rdi

; 4172 : }

  0042a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0042e	41 5f		 pop	 r15
  00430	5f		 pop	 rdi
  00431	5d		 pop	 rbp
  00432	5b		 pop	 rbx
  00433	c3		 ret	 0
call_function ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@	; `string'
PUBLIC	??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@		; `string'
PUBLIC	??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@ ; `string'
PUBLIC	??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@ ; `string'
PUBLIC	??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@ ; `string'
PUBLIC	??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@	; `string'
PUBLIC	??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@ ; `string'
PUBLIC	??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@ ; `string'
PUBLIC	??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@ ; `string'
PUBLIC	??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@ ; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@ ; `string'
PUBLIC	??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@	; `string'
PUBLIC	??_C@_0M@OABHHABA@displayhook?$AA@		; `string'
PUBLIC	??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@	; `string'
PUBLIC	??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@ ; `string'
PUBLIC	PyEval_EvalFrameEx
EXTRN	PyException_SetTraceback:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyFrame_GetLineNumber:PROC
EXTRN	PyTraceBack_Here:PROC
EXTRN	PySlice_New:PROC
EXTRN	PyFunction_SetKwDefaults:PROC
EXTRN	PyFunction_SetDefaults:PROC
EXTRN	PyFunction_SetAnnotations:PROC
EXTRN	PyFunction_SetClosure:PROC
EXTRN	PyFunction_NewWithQualName:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyFrame_BlockSetup:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyList_Type:BYTE
EXTRN	PyFrame_LocalsToFast:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyDict_NewPresized:PROC
EXTRN	PySet_New:PROC
EXTRN	PyCell_Get:PROC
EXTRN	_PyDict_LoadGlobal:PROC
EXTRN	PyObject_SetAttr:PROC
EXTRN	_PyDict_GetItemId:PROC
EXTRN	PyExc_KeyError:QWORD
EXTRN	_PyUnicode_FromId:PROC
EXTRN	PyFrame_BlockPop:PROC
EXTRN	_PyGen_FetchStopIterationValue:PROC
EXTRN	_PyGen_Send:PROC
EXTRN	PyGen_Type:BYTE
EXTRN	PyExc_SystemError:QWORD
EXTRN	PySys_GetObject:PROC
EXTRN	PyObject_DelItem:PROC
EXTRN	PyNumber_InPlaceOr:PROC
EXTRN	PyNumber_InPlaceXor:PROC
EXTRN	PyNumber_InPlaceAnd:PROC
EXTRN	PyNumber_InPlaceRshift:PROC
EXTRN	PyNumber_InPlaceLshift:PROC
EXTRN	PyNumber_InPlaceSubtract:PROC
EXTRN	PyNumber_InPlaceAdd:PROC
EXTRN	PyNumber_InPlaceRemainder:PROC
EXTRN	PyNumber_InPlaceFloorDivide:PROC
EXTRN	PyNumber_InPlaceTrueDivide:PROC
EXTRN	PyNumber_InPlaceMultiply:PROC
EXTRN	PyNumber_InPlacePower:PROC
EXTRN	PySet_Add:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyNumber_Or:PROC
EXTRN	PyNumber_Xor:PROC
EXTRN	PyNumber_And:PROC
EXTRN	PyNumber_Rshift:PROC
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyObject_GetItem:PROC
EXTRN	PyNumber_Subtract:PROC
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Remainder:PROC
EXTRN	PyUnicode_Format:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyNumber_FloorDivide:PROC
EXTRN	PyNumber_TrueDivide:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyNumber_Power:PROC
EXTRN	PyNumber_Invert:PROC
EXTRN	PyNumber_Negative:PROC
EXTRN	PyNumber_Positive:PROC
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyTuple_Type:BYTE
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyErr_SetNone:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyEval_EvalFrameEx DD imagerel $LN1093
	DD	imagerel $LN1093+254
	DD	imagerel $unwind$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyEval_EvalFrameEx DD imagerel $LN1093+254
	DD	imagerel $LN1093+262
	DD	imagerel $chain$0$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyEval_EvalFrameEx DD imagerel $LN1093+262
	DD	imagerel $LN1093+12687
	DD	imagerel $chain$2$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyEval_EvalFrameEx DD imagerel $LN1093+12687
	DD	imagerel $LN1093+13033
	DD	imagerel $chain$3$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyEval_EvalFrameEx DD imagerel $LN1093+13033
	DD	imagerel $LN1093+13144
	DD	imagerel $chain$4$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyEval_EvalFrameEx DD imagerel $LN1093+13144
	DD	imagerel $LN1093+13679
	DD	imagerel $chain$5$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyEval_EvalFrameEx DD 060021H
	DD	018f400H
	DD	019c400H
	DD	0217400H
	DD	imagerel $LN1093
	DD	imagerel $LN1093+254
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyEval_EvalFrameEx DD 021H
	DD	imagerel $LN1093
	DD	imagerel $LN1093+254
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyEval_EvalFrameEx DD 021H
	DD	imagerel $LN1093+254
	DD	imagerel $LN1093+262
	DD	imagerel $chain$0$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyEval_EvalFrameEx DD 042d21H
	DD	018f42dH
	DD	019c408H
	DD	imagerel $LN1093+254
	DD	imagerel $LN1093+262
	DD	imagerel $chain$0$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyEval_EvalFrameEx DD 020821H
	DD	0217408H
	DD	imagerel $LN1093
	DD	imagerel $LN1093+254
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalFrameEx DD 071801H
	DD	01a0118H
	DD	0d00ae00cH
	DD	030076008H
	DD	05006H
xdata	ENDS
;	COMDAT ??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
CONST	SEGMENT
??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@ DB 'PyEval_EvalFrameEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@
CONST	SEGMENT
??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@ DB 'unknown opcode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@ DB 'XXX'
	DB	' lineno: %d, opcode: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@
CONST	SEGMENT
??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@ DB '''finally'''
	DB	' pops bad exception', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@
CONST	SEGMENT
??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@ DB 'no loca'
	DB	'ls found during ''import *''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@
CONST	SEGMENT
??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@ DB 'error return'
	DB	' without exception set', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@ DB '__import__ not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
CONST	SEGMENT
??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@ DB 'import not p'
	DB	'ermitted within parallel context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@ DB 'no locals wh'
	DB	'en loading %R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
CONST	SEGMENT
??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@ DB 'global'
	DB	' name ''%.200s'' is not defined', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@ DB 'no locals w'
	DB	'hen deleting %R', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@
CONST	SEGMENT
??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@ DB 'name '''
	DB	'%.200s'' is not defined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@ DB 'no lo'
	DB	'cals found when storing %R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@ DB '__build_class__ n'
	DB	'ot found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@
CONST	SEGMENT
??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@ DB 'popped blo'
	DB	'ck is not an except handler', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@
CONST	SEGMENT
??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@ DB 'bad RAISE_VARARGS o'
	DB	'parg', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@
CONST	SEGMENT
??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@ DB 'lost sys.displayhook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OABHHABA@displayhook?$AA@
CONST	SEGMENT
??_C@_0M@OABHHABA@displayhook?$AA@ DB 'displayhook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@
CONST	SEGMENT
??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@ DB 'ceval: orphan tstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@
CONST	SEGMENT
??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@ DB 'ceval: tstate mix-up'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT PyEval_EvalFrameEx
_TEXT	SEGMENT
next_instr$1$ = 48
tstate$1$ = 56
consts$1$ = 64
first_instr$1$ = 72
names$1$ = 80
retval$1$ = 88
tmp$1$ = 96
tb$65382 = 104
val$65381 = 112
co$1$ = 120
posdefaults$1$ = 128
sp$65229 = 128
freevars$1$ = 136
exc$65380 = 144
instr_lb$ = 152
instr_ub$ = 156
instr_prev$ = 160
sp$65215 = 168
val$64705 = 176
f$ = 256
throwflag$ = 264
why$1$ = 272
err$1$ = 280
PyEval_EvalFrameEx PROC					; COMDAT

; 834  : {

$LN1093:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  00011	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 835  : #ifdef DXPAIRS
; 836  :     int lastopcode = 0;
; 837  : #endif
; 838  :     register PyObject **stack_pointer;  /* Next free slot in value stack */
; 839  :     register unsigned char *next_instr;
; 840  :     register int opcode;        /* Current opcode */
; 841  :     register int oparg;         /* Current opcode argument, if any */
; 842  :     register enum why_code why; /* Reason for block stack unwind */
; 843  :     register int err;           /* Error status -- nonzero if error */
; 844  :     register PyObject *x;       /* Result object -- NULL if error */
; 845  :     register PyObject *v;       /* Temporary objects popped off stack */
; 846  :     register PyObject *w;
; 847  :     register PyObject *u;
; 848  :     register PyObject *t;
; 849  :     register PyObject **fastlocals, **freevars;
; 850  :     PyObject *retval = NULL;            /* Return value */

  00018	33 f6		 xor	 esi, esi
  0001a	8b da		 mov	 ebx, edx
  0001c	4c 8b f1	 mov	 r14, rcx
  0001f	48 89 75 bf	 mov	 QWORD PTR retval$1$[rbp-153], rsi

; 851  :     PyThreadState *tstate = PyThreadState_GET();

  00023	e8 00 00 00 00	 call	 _Py_PXCTX
  00028	85 c0		 test	 eax, eax
  0002a	74 0a		 je	 SHORT $LN544@PyEval_Eva
  0002c	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00031	4c 8b e8	 mov	 r13, rax
  00034	eb 07		 jmp	 SHORT $LN1023@PyEval_Eva
$LN544@PyEval_Eva:
  00036	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR _PyThreadState_Current
$LN1023@PyEval_Eva:
  0003d	4c 89 6d 9f	 mov	 QWORD PTR tstate$1$[rbp-153], r13

; 852  :     PyCodeObject *co;
; 853  : 
; 854  :     /* when tracing we set things up so that
; 855  : 
; 856  :            not (instr_lb <= current_bytecode_offset < instr_ub)
; 857  : 
; 858  :        is true when the line being executed has changed.  The
; 859  :        initial values are such as to make this false the first
; 860  :        time it is tested. */
; 861  :     int instr_ub = -1, instr_lb = 0, instr_prev = -1;

  00041	c7 45 03 ff ff
	ff ff		 mov	 DWORD PTR instr_ub$[rbp-153], -1
  00048	89 75 ff	 mov	 DWORD PTR instr_lb$[rbp-153], esi
  0004b	c7 45 07 ff ff
	ff ff		 mov	 DWORD PTR instr_prev$[rbp-153], -1

; 862  : 
; 863  :     unsigned char *first_instr;
; 864  :     PyObject *names;
; 865  :     PyObject *consts;
; 866  : 
; 867  : #ifdef LLTRACE
; 868  :     _Py_IDENTIFIER(__ltrace__);
; 869  : #endif
; 870  : 
; 871  : /* Computed GOTOs, or
; 872  :        the-optimization-commonly-but-improperly-known-as-"threaded code"
; 873  :    using gcc's labels-as-values extension
; 874  :    (http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html).
; 875  : 
; 876  :    The traditional bytecode evaluation loop uses a "switch" statement, which
; 877  :    decent compilers will optimize as a single indirect branch instruction
; 878  :    combined with a lookup table of jump addresses. However, since the
; 879  :    indirect jump instruction is shared by all opcodes, the CPU will have a
; 880  :    hard time making the right prediction for where to jump next (actually,
; 881  :    it will be always wrong except in the uncommon case of a sequence of
; 882  :    several identical opcodes).
; 883  : 
; 884  :    "Threaded code" in contrast, uses an explicit jump table and an explicit
; 885  :    indirect jump instruction at the end of each opcode. Since the jump
; 886  :    instruction is at a different address for each opcode, the CPU will make a
; 887  :    separate prediction for each of these instructions, which is equivalent to
; 888  :    predicting the second opcode of each opcode pair. These predictions have
; 889  :    a much better chance to turn out valid, especially in small bytecode loops.
; 890  : 
; 891  :    A mispredicted branch on a modern CPU flushes the whole pipeline and
; 892  :    can cost several CPU cycles (depending on the pipeline depth),
; 893  :    and potentially many more instructions (depending on the pipeline width).
; 894  :    A correctly predicted branch, however, is nearly free.
; 895  : 
; 896  :    At the time of this writing, the "threaded code" version is up to 15-20%
; 897  :    faster than the normal "switch" version, depending on the compiler and the
; 898  :    CPU architecture.
; 899  : 
; 900  :    We disable the optimization if DYNAMIC_EXECUTION_PROFILE is defined,
; 901  :    because it would render the measurements invalid.
; 902  : 
; 903  : 
; 904  :    NOTE: care must be taken that the compiler doesn't try to "optimize" the
; 905  :    indirect jumps by sharing them between all opcodes. Such optimizations
; 906  :    can be disabled on gcc by using the -fno-gcse flag (or possibly
; 907  :    -fno-crossjumping).
; 908  : */
; 909  : 
; 910  : #ifdef DYNAMIC_EXECUTION_PROFILE
; 911  : #undef USE_COMPUTED_GOTOS
; 912  : #define USE_COMPUTED_GOTOS 0
; 913  : #endif
; 914  : 
; 915  : #ifdef HAVE_COMPUTED_GOTOS
; 916  :     #ifndef USE_COMPUTED_GOTOS
; 917  :     #define USE_COMPUTED_GOTOS 1
; 918  :     #endif
; 919  : #else
; 920  :     #if defined(USE_COMPUTED_GOTOS) && USE_COMPUTED_GOTOS
; 921  :     #error "Computed gotos are not supported on this compiler."
; 922  :     #endif
; 923  :     #undef USE_COMPUTED_GOTOS
; 924  :     #define USE_COMPUTED_GOTOS 0
; 925  : #endif
; 926  : 
; 927  : #if USE_COMPUTED_GOTOS
; 928  : /* Import the static jump table */
; 929  : #include "opcode_targets.h"
; 930  : 
; 931  : /* This macro is used when several opcodes defer to the same implementation
; 932  :    (e.g. SETUP_LOOP, SETUP_FINALLY) */
; 933  : #define TARGET_WITH_IMPL(op, impl) \
; 934  :     TARGET_##op: \
; 935  :         opcode = op; \
; 936  :         if (HAS_ARG(op)) \
; 937  :             oparg = NEXTARG(); \
; 938  :     case op: \
; 939  :         goto impl; \
; 940  : 
; 941  : #define TARGET(op) \
; 942  :     TARGET_##op: \
; 943  :         opcode = op; \
; 944  :         if (HAS_ARG(op)) \
; 945  :             oparg = NEXTARG(); \
; 946  :     case op:
; 947  : 
; 948  : 
; 949  : #define DISPATCH() \
; 950  :     { \
; 951  :         if (!_Py_atomic_load_relaxed(&eval_breaker)) {      \
; 952  :                     FAST_DISPATCH(); \
; 953  :         } \
; 954  :         continue; \
; 955  :     }
; 956  : 
; 957  : #ifdef LLTRACE
; 958  : #define FAST_DISPATCH() \
; 959  :     { \
; 960  :         if (!lltrace && !_Py_TracingPossible) { \
; 961  :             f->f_lasti = INSTR_OFFSET(); \
; 962  :             goto *opcode_targets[*next_instr++]; \
; 963  :         } \
; 964  :         goto fast_next_opcode; \
; 965  :     }
; 966  : #else
; 967  : #define FAST_DISPATCH() \
; 968  :     { \
; 969  :         if (!_Py_TracingPossible) { \
; 970  :             f->f_lasti = INSTR_OFFSET(); \
; 971  :             goto *opcode_targets[*next_instr++]; \
; 972  :         } \
; 973  :         goto fast_next_opcode; \
; 974  :     }
; 975  : #endif
; 976  : 
; 977  : #else
; 978  : #define TARGET(op) \
; 979  :     case op:
; 980  : #define TARGET_WITH_IMPL(op, impl) \
; 981  :     /* silence compiler warnings about `impl` unused */ \
; 982  :     if (0) goto impl; \
; 983  :     case op:
; 984  : #define DISPATCH() continue
; 985  : #define FAST_DISPATCH() goto fast_next_opcode
; 986  : #endif
; 987  : 
; 988  : 
; 989  : /* Tuple access macros */
; 990  : 
; 991  : #ifndef Py_DEBUG
; 992  : #define GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
; 993  : #else
; 994  : #define GETITEM(v, i) PyTuple_GetItem((v), (i))
; 995  : #endif
; 996  : 
; 997  : #ifdef WITH_TSC
; 998  : /* Use Pentium timestamp counter to mark certain events:
; 999  :    inst0 -- beginning of switch statement for opcode dispatch
; 1000 :    inst1 -- end of switch statement (may be skipped)
; 1001 :    loop0 -- the top of the mainloop
; 1002 :    loop1 -- place where control returns again to top of mainloop
; 1003 :             (may be skipped)
; 1004 :    intr1 -- beginning of long interruption
; 1005 :    intr2 -- end of long interruption
; 1006 : 
; 1007 :    Many opcodes call out to helper C functions.  In some cases, the
; 1008 :    time in those functions should be counted towards the time for the
; 1009 :    opcode, but not in all cases.  For example, a CALL_FUNCTION opcode
; 1010 :    calls another Python function; there's no point in charge all the
; 1011 :    bytecode executed by the called function to the caller.
; 1012 : 
; 1013 :    It's hard to make a useful judgement statically.  In the presence
; 1014 :    of operator overloading, it's impossible to tell if a call will
; 1015 :    execute new Python code or not.
; 1016 : 
; 1017 :    It's a case-by-case judgement.  I'll use intr1 for the following
; 1018 :    cases:
; 1019 : 
; 1020 :    IMPORT_STAR
; 1021 :    IMPORT_FROM
; 1022 :    CALL_FUNCTION (and friends)
; 1023 : 
; 1024 :  */
; 1025 :     uint64 inst0, inst1, loop0, loop1, intr0 = 0, intr1 = 0;
; 1026 :     int ticked = 0;
; 1027 : 
; 1028 :     READ_TIMESTAMP(inst0);
; 1029 :     READ_TIMESTAMP(inst1);
; 1030 :     READ_TIMESTAMP(loop0);
; 1031 :     READ_TIMESTAMP(loop1);
; 1032 : 
; 1033 :     /* shut up the compiler */
; 1034 :     opcode = 0;
; 1035 : #endif
; 1036 : 
; 1037 : /* Code access macros */
; 1038 : 
; 1039 : #define INSTR_OFFSET()  ((int)(next_instr - first_instr))
; 1040 : #define NEXTOP()        (*next_instr++)
; 1041 : #define NEXTARG()       (next_instr += 2, (next_instr[-1]<<8) + next_instr[-2])
; 1042 : #define PEEKARG()       ((next_instr[2]<<8) + next_instr[1])
; 1043 : #define JUMPTO(x)       (next_instr = first_instr + (x))
; 1044 : #define JUMPBY(x)       (next_instr += (x))
; 1045 : 
; 1046 : /* OpCode prediction macros
; 1047 :     Some opcodes tend to come in pairs thus making it possible to
; 1048 :     predict the second code when the first is run.  For example,
; 1049 :     COMPARE_OP is often followed by JUMP_IF_FALSE or JUMP_IF_TRUE.  And,
; 1050 :     those opcodes are often followed by a POP_TOP.
; 1051 : 
; 1052 :     Verifying the prediction costs a single high-speed test of a register
; 1053 :     variable against a constant.  If the pairing was good, then the
; 1054 :     processor's own internal branch predication has a high likelihood of
; 1055 :     success, resulting in a nearly zero-overhead transition to the
; 1056 :     next opcode.  A successful prediction saves a trip through the eval-loop
; 1057 :     including its two unpredictable branches, the HAS_ARG test and the
; 1058 :     switch-case.  Combined with the processor's internal branch prediction,
; 1059 :     a successful PREDICT has the effect of making the two opcodes run as if
; 1060 :     they were a single new opcode with the bodies combined.
; 1061 : 
; 1062 :     If collecting opcode statistics, your choices are to either keep the
; 1063 :     predictions turned-on and interpret the results as if some opcodes
; 1064 :     had been combined or turn-off predictions so that the opcode frequency
; 1065 :     counter updates for both opcodes.
; 1066 : 
; 1067 :     Opcode prediction is disabled with threaded code, since the latter allows
; 1068 :     the CPU to record separate branch prediction information for each
; 1069 :     opcode.
; 1070 : 
; 1071 : */
; 1072 : 
; 1073 : #if defined(DYNAMIC_EXECUTION_PROFILE) || USE_COMPUTED_GOTOS
; 1074 : #define PREDICT(op)             if (0) goto PRED_##op
; 1075 : #define PREDICTED(op)           PRED_##op:
; 1076 : #define PREDICTED_WITH_ARG(op)  PRED_##op:
; 1077 : #else
; 1078 : #define PREDICT(op)             if (*next_instr == op) goto PRED_##op
; 1079 : #define PREDICTED(op)           PRED_##op: next_instr++
; 1080 : #define PREDICTED_WITH_ARG(op)  PRED_##op: oparg = PEEKARG(); next_instr += 3
; 1081 : #endif
; 1082 : 
; 1083 : 
; 1084 : /* Stack manipulation macros */
; 1085 : 
; 1086 : /* The stack can grow at most MAXINT deep, as co_nlocals and
; 1087 :    co_stacksize are ints. */
; 1088 : #define STACK_LEVEL()     ((int)(stack_pointer - f->f_valuestack))
; 1089 : #define EMPTY()           (STACK_LEVEL() == 0)
; 1090 : #define TOP()             (stack_pointer[-1])
; 1091 : #define SECOND()          (stack_pointer[-2])
; 1092 : #define THIRD()           (stack_pointer[-3])
; 1093 : #define FOURTH()          (stack_pointer[-4])
; 1094 : #define PEEK(n)           (stack_pointer[-(n)])
; 1095 : #define SET_TOP(v)        (stack_pointer[-1] = (v))
; 1096 : #define SET_SECOND(v)     (stack_pointer[-2] = (v))
; 1097 : #define SET_THIRD(v)      (stack_pointer[-3] = (v))
; 1098 : #define SET_FOURTH(v)     (stack_pointer[-4] = (v))
; 1099 : #define SET_VALUE(n, v)   (stack_pointer[-(n)] = (v))
; 1100 : #define BASIC_STACKADJ(n) (stack_pointer += n)
; 1101 : #define BASIC_PUSH(v)     (*stack_pointer++ = (v))
; 1102 : #define BASIC_POP()       (*--stack_pointer)
; 1103 : 
; 1104 : #ifdef LLTRACE
; 1105 : #define PUSH(v)         { (void)(BASIC_PUSH(v), \
; 1106 :                           lltrace && prtrace(TOP(), "push")); \
; 1107 :                           assert(STACK_LEVEL() <= co->co_stacksize); }
; 1108 : #define POP()           ((void)(lltrace && prtrace(TOP(), "pop")), \
; 1109 :                          BASIC_POP())
; 1110 : #define STACKADJ(n)     { (void)(BASIC_STACKADJ(n), \
; 1111 :                           lltrace && prtrace(TOP(), "stackadj")); \
; 1112 :                           assert(STACK_LEVEL() <= co->co_stacksize); }
; 1113 : #define EXT_POP(STACK_POINTER) ((void)(lltrace && \
; 1114 :                                 prtrace((STACK_POINTER)[-1], "ext_pop")), \
; 1115 :                                 *--(STACK_POINTER))
; 1116 : #else
; 1117 : #define PUSH(v)                BASIC_PUSH(v)
; 1118 : #define POP()                  BASIC_POP()
; 1119 : #define STACKADJ(n)            BASIC_STACKADJ(n)
; 1120 : #define EXT_POP(STACK_POINTER) (*--(STACK_POINTER))
; 1121 : #endif
; 1122 : 
; 1123 : /* Local variable macros */
; 1124 : 
; 1125 : #define GETLOCAL(i)     (fastlocals[i])
; 1126 : 
; 1127 : /* The SETLOCAL() macro must not DECREF the local variable in-place and
; 1128 :    then store the new value; it must copy the old value to a temporary
; 1129 :    value, then store the new value, and then DECREF the temporary value.
; 1130 :    This is because it is possible that during the DECREF the frame is
; 1131 :    accessed by other code (e.g. a __del__ method or gc.collect()) and the
; 1132 :    variable would be pointing to already-freed memory. */
; 1133 : #define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \
; 1134 :                                      GETLOCAL(i) = value; \
; 1135 :                                      Py_XDECREF(tmp); } while (0)
; 1136 : 
; 1137 : 
; 1138 : #define UNWIND_BLOCK(b) \
; 1139 :     while (STACK_LEVEL() > (b)->b_level) { \
; 1140 :         PyObject *v = POP(); \
; 1141 :         Py_XDECREF(v); \
; 1142 :     }
; 1143 : 
; 1144 : #define UNWIND_EXCEPT_HANDLER(b) \
; 1145 :     { \
; 1146 :         PyObject *type, *value, *traceback; \
; 1147 :         assert(STACK_LEVEL() >= (b)->b_level + 3); \
; 1148 :         while (STACK_LEVEL() > (b)->b_level + 3) { \
; 1149 :             value = POP(); \
; 1150 :             Py_XDECREF(value); \
; 1151 :         } \
; 1152 :         type = tstate->exc_type; \
; 1153 :         value = tstate->exc_value; \
; 1154 :         traceback = tstate->exc_traceback; \
; 1155 :         tstate->exc_type = POP(); \
; 1156 :         tstate->exc_value = POP(); \
; 1157 :         tstate->exc_traceback = POP(); \
; 1158 :         Py_XDECREF(type); \
; 1159 :         Py_XDECREF(value); \
; 1160 :         Py_XDECREF(traceback); \
; 1161 :     }
; 1162 : 
; 1163 : /* Start of code */
; 1164 : 
; 1165 :     /* push frame */
; 1166 :     if (Py_EnterRecursiveCall(""))

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	74 07		 je	 SHORT $LN546@PyEval_Eva
  0005b	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00060	eb 07		 jmp	 SHORT $LN547@PyEval_Eva
$LN546@PyEval_Eva:
  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN547@PyEval_Eva:
  00069	ff 40 18	 inc	 DWORD PTR [rax+24]
  0006c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0006f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  00075	7e 21		 jle	 SHORT $LN541@PyEval_Eva
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0007e	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00083	85 c0		 test	 eax, eax
  00085	74 11		 je	 SHORT $LN541@PyEval_Eva

; 1167 :         return NULL;

  00087	33 c0		 xor	 eax, eax

; 3150 : }

  00089	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00090	41 5e		 pop	 r14
  00092	41 5d		 pop	 r13
  00094	5e		 pop	 rsi
  00095	5b		 pop	 rbx
  00096	5d		 pop	 rbp
  00097	c3		 ret	 0
$LN541@PyEval_Eva:

; 1168 : 
; 1169 :     tstate->frame = f;

  00098	4d 89 75 10	 mov	 QWORD PTR [r13+16], r14

; 1170 : 
; 1171 :     if (tstate->use_tracing) {

  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a3	41 39 75 24	 cmp	 DWORD PTR [r13+36], esi
  000a7	74 51		 je	 SHORT $LN536@PyEval_Eva

; 1172 :         if (tstate->c_tracefunc != NULL) {

  000a9	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  000ad	48 85 c9	 test	 rcx, rcx
  000b0	74 23		 je	 SHORT $LN538@PyEval_Eva

; 1173 :             /* tstate->c_tracefunc, if defined, is a
; 1174 :                function that will be called on *every* entry
; 1175 :                to a code block.  Its return value, if not
; 1176 :                None, is a function that will be called at
; 1177 :                the start of each executed line of code.
; 1178 :                (Actually, the function must return itself
; 1179 :                in order to continue tracing.)  The trace
; 1180 :                functions are called with three arguments:
; 1181 :                a pointer to the current frame, a string
; 1182 :                indicating why the function is called, and
; 1183 :                an argument which depends on the situation.
; 1184 :                The global trace function is also called
; 1185 :                whenever an exception is detected. */
; 1186 :             if (call_trace_protected(tstate->c_tracefunc,
; 1187 :                                      tstate->c_traceobj,
; 1188 :                                      f, PyTrace_CALL, Py_None)) {

  000b2	49 8b 55 40	 mov	 rdx, QWORD PTR [r13+64]
  000b6	45 33 c9	 xor	 r9d, r9d
  000b9	4d 8b c6	 mov	 r8, r14
  000bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c1	e8 00 00 00 00	 call	 call_trace_protected
  000c6	85 c0		 test	 eax, eax
  000c8	0f 85 1b 32 00
	00		 jne	 $exit_eval_frame$64383
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN538@PyEval_Eva:

; 1189 :                 /* Trace function raised an error */
; 1190 :                 goto exit_eval_frame;
; 1191 :             }
; 1192 :         }
; 1193 :         if (tstate->c_profilefunc != NULL) {

  000d5	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  000d9	48 85 c9	 test	 rcx, rcx
  000dc	74 1c		 je	 SHORT $LN536@PyEval_Eva

; 1194 :             /* Similar for c_profilefunc, except it needn't
; 1195 :                return itself and isn't called for "line" events */
; 1196 :             if (call_trace_protected(tstate->c_profilefunc,
; 1197 :                                      tstate->c_profileobj,
; 1198 :                                      f, PyTrace_CALL, Py_None)) {

  000de	49 8b 55 38	 mov	 rdx, QWORD PTR [r13+56]
  000e2	45 33 c9	 xor	 r9d, r9d
  000e5	4d 8b c6	 mov	 r8, r14
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	e8 00 00 00 00	 call	 call_trace_protected
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 ef 31 00
	00		 jne	 $exit_eval_frame$64383
$LN536@PyEval_Eva:

; 1199 :                 /* Profile function raised an error */
; 1200 :                 goto exit_eval_frame;
; 1201 :             }
; 1202 :         }
; 1203 :     }
; 1204 : 
; 1205 :     co = f->f_code;

  000fa	4d 8b 46 78	 mov	 r8, QWORD PTR [r14+120]
  000fe	48 89 bc 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rdi
  00106	4c 89 a4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], r12

; 1206 :     names = co->co_names;

  0010e	49 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [r8+136]

; 1207 :     consts = co->co_consts;

  00115	4d 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [r8+128]

; 1208 :     fastlocals = f->f_localsplus;
; 1209 :     freevars = f->f_localsplus + co->co_nlocals;
; 1210 :     first_instr = (unsigned char*) PyBytes_AS_STRING(co->co_code);
; 1211 :     /* An explanation is in order for the next line.
; 1212 : 
; 1213 :        f->f_lasti now refers to the index of the last instruction
; 1214 :        executed.  You might think this was obvious from the name, but
; 1215 :        this wasn't always true before 2.3!  PyFrame_New now sets
; 1216 :        f->f_lasti to -1 (i.e. the index *before* the first instruction)
; 1217 :        and YIELD_VALUE doesn't fiddle with f_lasti any more.  So this
; 1218 :        does work.  Promise.
; 1219 :        YIELD_FROM sets f_lasti to itself, in order to repeated yield
; 1220 :        multiple values.
; 1221 : 
; 1222 :        When the PREDICT() macros are enabled, some opcode pairs follow in
; 1223 :        direct succession without updating f->f_lasti.  A successful
; 1224 :        prediction effectively links the two codes together as if they
; 1225 :        were a single new opcode; accordingly,f->f_lasti will point to
; 1226 :        the first code in the pair (for instance, GET_ITER followed by
; 1227 :        FOR_ITER is effectively a single opcode and f->f_lasti will point
; 1228 :        at to the beginning of the combined pair.)
; 1229 :     */
; 1230 :     next_instr = first_instr + f->f_lasti + 1;
; 1231 :     stack_pointer = f->f_stacktop;

  0011c	4d 8b a6 a0 00
	00 00		 mov	 r12, QWORD PTR [r14+160]
  00123	48 89 45 b7	 mov	 QWORD PTR names$1$[rbp-153], rax
  00127	49 63 40 68	 movsxd	 rax, DWORD PTR [r8+104]
  0012b	4c 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r15
  00133	49 8d 8c c6 d0
	01 00 00	 lea	 rcx, QWORD PTR [r14+rax*8+464]
  0013b	49 63 86 d0 00
	00 00		 movsxd	 rax, DWORD PTR [r14+208]
  00142	4c 89 45 df	 mov	 QWORD PTR co$1$[rbp-153], r8
  00146	48 89 4d ef	 mov	 QWORD PTR freevars$1$[rbp-153], rcx
  0014a	49 8b 48 78	 mov	 rcx, QWORD PTR [r8+120]

; 1232 :     assert(stack_pointer != NULL);
; 1233 :     f->f_stacktop = NULL;       /* remains NULL unless yield suspends frame */

  0014e	49 89 b6 a0 00
	00 00		 mov	 QWORD PTR [r14+160], rsi
  00155	48 83 c1 78	 add	 rcx, 120		; 00000078H

; 1234 : 
; 1235 :     if (co->co_flags & CO_GENERATOR && !throwflag) {

  00159	41 f6 40 70 20	 test	 BYTE PTR [r8+112], 32	; 00000020H
  0015e	4c 89 4d a7	 mov	 QWORD PTR consts$1$[rbp-153], r9
  00162	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  00167	48 89 4d af	 mov	 QWORD PTR first_instr$1$[rbp-153], rcx
  0016b	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  0016f	74 44		 je	 SHORT $LN1022@PyEval_Eva
  00171	85 db		 test	 ebx, ebx
  00173	75 40		 jne	 SHORT $LN1022@PyEval_Eva

; 1236 :         if (f->f_exc_type != NULL && f->f_exc_type != Py_None) {

  00175	49 8b 86 b0 00
	00 00		 mov	 rax, QWORD PTR [r14+176]
  0017c	48 85 c0	 test	 rax, rax
  0017f	74 21		 je	 SHORT $LN534@PyEval_Eva
  00181	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_NoneStruct
  00188	49 3b c2	 cmp	 rax, r10
  0018b	74 15		 je	 SHORT $LN534@PyEval_Eva

; 1237 :             /* We were in an except handler when we left,
; 1238 :                restore the exception state which was put aside
; 1239 :                (see YIELD_VALUE). */
; 1240 :             swap_exc_state(tstate, f);

  0018d	49 8b d6	 mov	 rdx, r14
  00190	49 8b cd	 mov	 rcx, r13
  00193	e8 00 00 00 00	 call	 swap_exc_state

; 1241 :         }
; 1242 :         else

  00198	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0019c	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  001a0	eb 1a		 jmp	 SHORT $LN533@PyEval_Eva
$LN534@PyEval_Eva:

; 1243 :             save_exc_state(tstate, f);

  001a2	49 8b d6	 mov	 rdx, r14
  001a5	49 8b cd	 mov	 rcx, r13
  001a8	e8 00 00 00 00	 call	 save_exc_state
  001ad	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  001b1	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
$LN1022@PyEval_Eva:

; 1949 : 
; 1950 :         PREDICTED(END_FINALLY);

  001b5	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_NoneStruct
$LN533@PyEval_Eva:

; 1244 :     }
; 1245 : 
; 1246 : #ifdef LLTRACE
; 1247 :     lltrace = _PyDict_GetItemId(f->f_globals, &PyId___ltrace__) != NULL;
; 1248 : #endif
; 1249 : 
; 1250 :     why = WHY_NOT;

  001bc	c7 45 77 01 00
	00 00		 mov	 DWORD PTR why$1$[rbp-153], 1

; 1251 :     err = 0;

  001c3	8b fe		 mov	 edi, esi
  001c5	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi

; 1252 :     x = Py_None;        /* Not a reference, just anything non-NULL */

  001c8	4d 8b fa	 mov	 r15, r10

; 1253 :     w = NULL;
; 1254 : 
; 1255 :     if (throwflag) { /* support for generator.throw() */

  001cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  001d2	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  001d9	ba 02 00 00 00	 mov	 edx, 2
  001de	85 db		 test	 ebx, ebx
  001e0	74 17		 je	 SHORT $LN937@PyEval_Eva

; 1256 :         why = WHY_EXCEPTION;

  001e2	8b ca		 mov	 ecx, edx
  001e4	89 55 77	 mov	 DWORD PTR why$1$[rbp-153], edx

; 1257 :         goto on_error;

  001e7	e9 41 20 00 00	 jmp	 $on_error$64398
$LN1002@PyEval_Eva:

; 3078 :             break;
; 3079 :         READ_TIMESTAMP(loop1);
; 3080 : 
; 3081 :     } /* main loop */

  001ec	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
$LN1008@PyEval_Eva:
  001f0	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  001f4	eb 03		 jmp	 SHORT $LN937@PyEval_Eva
$LN1010@PyEval_Eva:

; 2348 :             PREDICT(POP_JUMP_IF_TRUE);

  001f6	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
$LN937@PyEval_Eva:
  001f9	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
$LN531@PyEval_Eva:

; 1258 :     }
; 1259 : 
; 1260 :     for (;;) {
; 1261 : #ifdef WITH_TSC
; 1262 :         if (inst1 == 0) {
; 1263 :             /* Almost surely, the opcode executed a break
; 1264 :                or a continue, preventing inst1 from being set
; 1265 :                on the way out of the loop.
; 1266 :             */
; 1267 :             READ_TIMESTAMP(inst1);
; 1268 :             loop1 = inst1;
; 1269 :         }
; 1270 :         dump_tsc(opcode, ticked, inst0, inst1, loop0, loop1,
; 1271 :                  intr0, intr1);
; 1272 :         ticked = 0;
; 1273 :         inst1 = 0;
; 1274 :         intr0 = 0;
; 1275 :         intr1 = 0;
; 1276 :         READ_TIMESTAMP(loop0);
; 1277 : #endif
; 1278 :         assert(stack_pointer >= f->f_valuestack); /* else underflow */
; 1279 :         assert(STACK_LEVEL() <= co->co_stacksize);  /* else overflow */
; 1280 : 
; 1281 : #ifdef WITH_PARALLEL
; 1282 :         /* Parallel threads skip the normal thread periodic tasks below. */
; 1283 : 
; 1284 :         if (tstate->is_parallel_thread) {

  001fd	41 83 bd a8 00
	00 00 00	 cmp	 DWORD PTR [r13+168], 0
  00205	0f 85 d9 00 00
	00		 jne	 $fast_next_opcode_notracing$64405

; 1285 :             goto fast_next_opcode_notracing;
; 1286 :         }
; 1287 : #endif /* WITH_PARALLEL */
; 1288 : 
; 1289 : 
; 1290 :         /* Do periodic things.  Doing this every time through
; 1291 :            the loop would add too much overhead, so we do it
; 1292 :            only every Nth instruction.  We also do it if
; 1293 :            ``pendingcalls_to_do'' is set, i.e. when an asynchronous
; 1294 :            event needs attention (e.g. a signal handler or
; 1295 :            async I/O handler); see Py_AddPendingCall() and
; 1296 :            Py_MakePendingCalls() above. */
; 1297 : 
; 1298 :         if (_Py_atomic_load_relaxed(&eval_breaker)) {

  0020b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR eval_breaker, 0
  00212	0f 84 45 06 00
	00		 je	 $LN967@PyEval_Eva

; 1299 :             if (*next_instr == SETUP_FINALLY) {

  00218	80 38 7a	 cmp	 BYTE PTR [rax], 122	; 0000007aH
  0021b	0f 84 3c 06 00
	00		 je	 $LN967@PyEval_Eva

; 1300 :                 /* Make the last opcode before
; 1301 :                    a try: finally: block uninterruptible. */
; 1302 :                 goto fast_next_opcode;
; 1303 :             }
; 1304 :             tstate->tick_counter++;

  00221	41 ff 85 80 00
	00 00		 inc	 DWORD PTR [r13+128]

; 1305 : #ifdef WITH_TSC
; 1306 :             ticked = 1;
; 1307 : #endif
; 1308 :             if (_Py_atomic_load_relaxed(&pendingcalls_to_do)) {

  00228	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pendingcalls_to_do, 0
  0022f	74 18		 je	 SHORT $LN938@PyEval_Eva

; 1309 :                 if (Py_MakePendingCalls() < 0) {

  00231	e8 00 00 00 00	 call	 Py_MakePendingCalls
  00236	85 c0		 test	 eax, eax
  00238	79 0f		 jns	 SHORT $LN938@PyEval_Eva

; 1310 :                     why = WHY_EXCEPTION;

  0023a	bb 02 00 00 00	 mov	 ebx, 2
  0023f	8b fb		 mov	 edi, ebx
  00241	89 5d 77	 mov	 DWORD PTR why$1$[rbp-153], ebx

; 1311 :                     goto on_error;

  00244	e9 0a 20 00 00	 jmp	 $LN80@PyEval_Eva
$LN938@PyEval_Eva:

; 1312 :                 }
; 1313 :             }
; 1314 : #ifdef WITH_THREAD
; 1315 :             if (_Py_atomic_load_relaxed(&gil_drop_request)) {

  00249	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_drop_request, 0
  00250	74 41		 je	 SHORT $LN939@PyEval_Eva

; 1316 :                 /* Give another thread a chance */
; 1317 :                 if (PyThreadState_Swap(NULL) != tstate)

  00252	33 c9		 xor	 ecx, ecx
  00254	e8 00 00 00 00	 call	 PyThreadState_Swap
  00259	49 3b c5	 cmp	 rax, r13
  0025c	74 0c		 je	 SHORT $LN523@PyEval_Eva

; 1318 :                     Py_FatalError("ceval: tstate mix-up");

  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@
  00265	e8 00 00 00 00	 call	 Py_FatalError
$LN523@PyEval_Eva:

; 1319 :                 drop_gil(tstate);

  0026a	49 8b cd	 mov	 rcx, r13
  0026d	e8 00 00 00 00	 call	 drop_gil

; 1320 : 
; 1321 :                 /* Other threads may run now */
; 1322 : 
; 1323 :                 take_gil(tstate);

  00272	49 8b cd	 mov	 rcx, r13
  00275	e8 00 00 00 00	 call	 take_gil

; 1324 :                 if (PyThreadState_Swap(tstate) != NULL)

  0027a	49 8b cd	 mov	 rcx, r13
  0027d	e8 00 00 00 00	 call	 PyThreadState_Swap
  00282	48 85 c0	 test	 rax, rax
  00285	74 0c		 je	 SHORT $LN939@PyEval_Eva

; 1325 :                     Py_FatalError("ceval: orphan tstate");

  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@
  0028e	e8 00 00 00 00	 call	 Py_FatalError
$LN939@PyEval_Eva:

; 1326 :             }
; 1327 : #endif
; 1328 :             /* Check for asynchronous exceptions. */
; 1329 :             if (tstate->async_exc != NULL) {

  00293	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]
  0029a	48 85 c0	 test	 rax, rax
  0029d	0f 84 c0 05 00
	00		 je	 $LN969@PyEval_Eva

; 1330 :                 x = tstate->async_exc;

  002a3	4c 8b f8	 mov	 r15, rax

; 1331 :                 tstate->async_exc = NULL;
; 1332 :                 UNSIGNAL_ASYNC_EXC();

  002a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_drop_request
  002ac	49 89 b5 88 00
	00 00		 mov	 QWORD PTR [r13+136], rsi
  002b3	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do

; 1333 :                 PyErr_SetNone(x);

  002b9	49 8b cf	 mov	 rcx, r15
  002bc	89 35 00 00 00
	00		 mov	 DWORD PTR pending_async_exc, esi
  002c2	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
  002c8	e8 00 00 00 00	 call	 PyErr_SetNone

; 1334 :                 Py_DECREF(x);

  002cd	49 8b cf	 mov	 rcx, r15
  002d0	e8 00 00 00 00	 call	 _Py_DecRef

; 1335 :                 why = WHY_EXCEPTION;

  002d5	bb 02 00 00 00	 mov	 ebx, 2
  002da	8b fb		 mov	 edi, ebx
  002dc	89 5d 77	 mov	 DWORD PTR why$1$[rbp-153], ebx

; 1336 :                 goto on_error;

  002df	e9 6f 1f 00 00	 jmp	 $LN80@PyEval_Eva
$fast_next_opcode_notracing$64405:

; 1362 :                 /* trace function raised an exception */
; 1363 :                 goto on_error;
; 1364 :             }
; 1365 :         }
; 1366 : 
; 1367 :         /* Extract opcode and argument */
; 1368 : #ifdef WITH_PARALLEL
; 1369 :     fast_next_opcode_notracing:
; 1370 : #endif
; 1371 :         opcode = NEXTOP();

  002e4	44 0f b6 28	 movzx	 r13d, BYTE PTR [rax]
  002e8	48 ff c0	 inc	 rax
  002eb	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax

; 1372 :         oparg = 0;   /* allows oparg to be stored in a register because
; 1373 :             it doesn't have to be remembered across a full loop */
; 1374 :         if (HAS_ARG(opcode))

  002ef	41 83 fd 5a	 cmp	 r13d, 90		; 0000005aH
  002f3	7c 15		 jl	 SHORT $LN943@PyEval_Eva

; 1375 :             oparg = NEXTARG();

  002f5	0f b6 70 01	 movzx	 esi, BYTE PTR [rax+1]
  002f9	48 83 c0 02	 add	 rax, 2
  002fd	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  00301	0f b6 40 fe	 movzx	 eax, BYTE PTR [rax-2]
  00305	c1 e6 08	 shl	 esi, 8
  00308	03 f0		 add	 esi, eax
$LN943@PyEval_Eva:
  0030a	48 8b 5d 97	 mov	 rbx, QWORD PTR next_instr$1$[rbp-153]
  0030e	66 90		 npad	 2
$dispatch_opcode$64433:

; 1376 :     dispatch_opcode:
; 1377 : #ifdef DYNAMIC_EXECUTION_PROFILE
; 1378 : #ifdef DXPAIRS
; 1379 :         dxpairs[lastopcode][opcode]++;
; 1380 :         lastopcode = opcode;
; 1381 : #endif
; 1382 :         dxp[opcode]++;
; 1383 : #endif
; 1384 : 
; 1385 : #ifdef LLTRACE
; 1386 :         /* Instruction tracing */
; 1387 : 
; 1388 :         if (lltrace) {
; 1389 :             if (HAS_ARG(opcode)) {
; 1390 :                 printf("%d: %d, %d\n",
; 1391 :                        f->f_lasti, opcode, oparg);
; 1392 :             }
; 1393 :             else {
; 1394 :                 printf("%d: %d\n",
; 1395 :                        f->f_lasti, opcode);
; 1396 :             }
; 1397 :         }
; 1398 : #endif
; 1399 : 
; 1400 :         /* Main switch on opcode */
; 1401 :         READ_TIMESTAMP(inst0);
; 1402 : 
; 1403 :         switch (opcode) {

  00310	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  00314	3d 92 00 00 00	 cmp	 eax, 146		; 00000092H
  00319	0f 87 6a 2a 00
	00		 ja	 $LN84@PyEval_Eva
  0031f	48 98		 cdqe
  00321	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN916@PyEval_Eva[r8+rax]
  0032a	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN917@PyEval_Eva[r8+rax*4]
  00332	49 03 c8	 add	 rcx, r8
  00335	ff e1		 jmp	 rcx
$LN85@PyEval_Eva:

; 2913 :             break;
; 2914 : 
; 2915 :         TARGET(EXTENDED_ARG)
; 2916 :             opcode = NEXTOP();
; 2917 :             oparg = oparg<<16 | NEXTARG();

  00337	0f b6 43 01	 movzx	 eax, BYTE PTR [rbx+1]
  0033b	44 0f b6 2b	 movzx	 r13d, BYTE PTR [rbx]
  0033f	0f b6 4b 02	 movzx	 ecx, BYTE PTR [rbx+2]
  00343	48 83 c3 03	 add	 rbx, 3
  00347	c1 e1 08	 shl	 ecx, 8
  0034a	03 c8		 add	 ecx, eax
  0034c	8b c6		 mov	 eax, esi
  0034e	48 89 5d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rbx
  00352	c1 e0 10	 shl	 eax, 16
  00355	8b f1		 mov	 esi, ecx
  00357	0b f0		 or	 esi, eax

; 2918 :             goto dispatch_opcode;

  00359	eb b5		 jmp	 SHORT $dispatch_opcode$64433
$LN510@PyEval_Eva:

; 1404 : 
; 1405 :         /* BEWARE!
; 1406 :            It is essential that any operation that fails sets either
; 1407 :            x to NULL, err to nonzero, or why to anything but WHY_NOT,
; 1408 :            and that no operation that succeeds does this! */
; 1409 : 
; 1410 :         TARGET(NOP)
; 1411 :             FAST_DISPATCH();
; 1412 : 
; 1413 :         TARGET(LOAD_FAST)
; 1414 :             x = GETLOCAL(oparg);

  0035b	48 63 c6	 movsxd	 rax, esi
  0035e	4d 8b bc c6 d0
	01 00 00	 mov	 r15, QWORD PTR [r14+rax*8+464]

; 1415 :             if (x != NULL) {

  00366	4d 85 ff	 test	 r15, r15
  00369	0f 84 f1 05 00
	00		 je	 $LN509@PyEval_Eva
$LN1066@PyEval_Eva:

; 1416 :                 Py_INCREF(x);

  0036f	e8 00 00 00 00	 call	 _Py_PXCTX
  00374	85 c0		 test	 eax, eax
  00376	75 34		 jne	 SHORT $LN563@PyEval_Eva
  00378	b8 02 00 00 00	 mov	 eax, 2
  0037d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0038b	4d 8b cf	 mov	 r9, r15
  0038e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00394	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00398	e8 00 00 00 00	 call	 _PyParallel_Guard
  0039d	85 c0		 test	 eax, eax
  0039f	75 07		 jne	 SHORT $LN562@PyEval_Eva
  003a1	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  003a6	74 04		 je	 SHORT $LN563@PyEval_Eva
$LN562@PyEval_Eva:
  003a8	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN563@PyEval_Eva:

; 1417 :                 PUSH(x);
; 1418 :                 FAST_DISPATCH();

  003ac	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  003b0	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  003b4	49 83 c4 08	 add	 r12, 8
  003b8	e9 b8 04 00 00	 jmp	 $LN1013@PyEval_Eva
$LN508@PyEval_Eva:

; 1424 : 
; 1425 :         TARGET(LOAD_CONST)
; 1426 :             x = GETITEM(consts, oparg);

  003bd	48 63 c6	 movsxd	 rax, esi
  003c0	4d 8b 7c c1 70	 mov	 r15, QWORD PTR [r9+rax*8+112]

; 1427 :             Py_INCREF(x);
; 1428 :             PUSH(x);
; 1429 :             FAST_DISPATCH();

  003c5	eb a8		 jmp	 SHORT $LN1066@PyEval_Eva
$LN499@PyEval_Eva:

; 1435 :             FAST_DISPATCH();
; 1436 : 
; 1437 :         TARGET(POP_TOP)
; 1438 :             v = POP();
; 1439 :             Py_DECREF(v);

  003c7	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  003cc	49 83 ec 08	 sub	 r12, 8
  003d0	e8 00 00 00 00	 call	 _Py_DecRef
  003d5	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  003d9	e9 97 04 00 00	 jmp	 $LN1013@PyEval_Eva
$LN498@PyEval_Eva:

; 1440 :             FAST_DISPATCH();
; 1441 : 
; 1442 :         TARGET(ROT_TWO)
; 1443 :             v = TOP();

  003de	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]

; 1444 :             w = SECOND();
; 1445 :             SET_TOP(w);

  003e3	49 8b 44 24 f0	 mov	 rax, QWORD PTR [r12-16]
  003e8	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax

; 1446 :             SET_SECOND(v);

  003ed	49 89 4c 24 f0	 mov	 QWORD PTR [r12-16], rcx
$LN966@PyEval_Eva:

; 1447 :             FAST_DISPATCH();

  003f2	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  003f6	e9 7e 04 00 00	 jmp	 $LN1028@PyEval_Eva
$LN497@PyEval_Eva:

; 1448 : 
; 1449 :         TARGET(ROT_THREE)
; 1450 :             v = TOP();

  003fb	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]

; 1451 :             w = SECOND();
; 1452 :             x = THIRD();

  00400	4d 8b 7c 24 e8	 mov	 r15, QWORD PTR [r12-24]

; 1453 :             SET_TOP(w);

  00405	49 8b 44 24 f0	 mov	 rax, QWORD PTR [r12-16]

; 1454 :             SET_SECOND(x);
; 1455 :             SET_THIRD(v);
; 1456 :             FAST_DISPATCH();

  0040a	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  0040e	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax
  00413	4d 89 7c 24 f0	 mov	 QWORD PTR [r12-16], r15
  00418	49 89 4c 24 e8	 mov	 QWORD PTR [r12-24], rcx
  0041d	e9 57 04 00 00	 jmp	 $LN1028@PyEval_Eva
$LN496@PyEval_Eva:

; 1457 : 
; 1458 :         TARGET(DUP_TOP)
; 1459 :             v = TOP();

  00422	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 1460 :             Py_INCREF(v);

  00427	e8 00 00 00 00	 call	 _Py_PXCTX
  0042c	85 c0		 test	 eax, eax
  0042e	75 33		 jne	 SHORT $LN582@PyEval_Eva
  00430	b8 02 00 00 00	 mov	 eax, 2
  00435	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00443	4c 8b cb	 mov	 r9, rbx
  00446	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0044c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00450	e8 00 00 00 00	 call	 _PyParallel_Guard
  00455	85 c0		 test	 eax, eax
  00457	75 06		 jne	 SHORT $LN581@PyEval_Eva
  00459	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0045d	74 04		 je	 SHORT $LN582@PyEval_Eva
$LN581@PyEval_Eva:
  0045f	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN582@PyEval_Eva:

; 1461 :             PUSH(v);

  00463	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00467	49 89 1c 24	 mov	 QWORD PTR [r12], rbx
  0046b	49 83 c4 08	 add	 r12, 8
  0046f	e9 01 04 00 00	 jmp	 $LN1013@PyEval_Eva
$LN495@PyEval_Eva:

; 1462 :             FAST_DISPATCH();
; 1463 : 
; 1464 :         TARGET(DUP_TOP_TWO)
; 1465 :             x = TOP();

  00474	4d 8b 7c 24 f8	 mov	 r15, QWORD PTR [r12-8]

; 1466 :             Py_INCREF(x);

  00479	e8 00 00 00 00	 call	 _Py_PXCTX
  0047e	bf 02 00 00 00	 mov	 edi, 2
  00483	85 c0		 test	 eax, eax
  00485	75 2f		 jne	 SHORT $LN586@PyEval_Eva
  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00495	4d 8b cf	 mov	 r9, r15
  00498	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0049e	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  004a2	e8 00 00 00 00	 call	 _PyParallel_Guard
  004a7	85 c0		 test	 eax, eax
  004a9	75 07		 jne	 SHORT $LN585@PyEval_Eva
  004ab	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  004b0	74 04		 je	 SHORT $LN586@PyEval_Eva
$LN585@PyEval_Eva:
  004b2	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN586@PyEval_Eva:

; 1467 :             w = SECOND();

  004b6	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]

; 1468 :             Py_INCREF(w);

  004bb	e8 00 00 00 00	 call	 _Py_PXCTX
  004c0	85 c0		 test	 eax, eax
  004c2	75 2e		 jne	 SHORT $LN590@PyEval_Eva
  004c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  004d2	4c 8b cb	 mov	 r9, rbx
  004d5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  004db	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  004df	e8 00 00 00 00	 call	 _PyParallel_Guard
  004e4	85 c0		 test	 eax, eax
  004e6	75 06		 jne	 SHORT $LN589@PyEval_Eva
  004e8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  004ec	74 04		 je	 SHORT $LN590@PyEval_Eva
$LN589@PyEval_Eva:
  004ee	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN590@PyEval_Eva:

; 1469 :             STACKADJ(2);

  004f2	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  004f6	49 83 c4 10	 add	 r12, 16

; 1470 :             SET_TOP(x);

  004fa	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15

; 1471 :             SET_SECOND(w);

  004ff	49 89 5c 24 f0	 mov	 QWORD PTR [r12-16], rbx
  00504	e9 6c 03 00 00	 jmp	 $LN1013@PyEval_Eva
$LN219@PyEval_Eva:

; 2338 : 
; 2339 :         TARGET(COMPARE_OP)
; 2340 :             w = POP();

  00509	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2341 :             v = TOP();

  0050e	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00513	49 83 ec 08	 sub	 r12, 8

; 2342 :             x = cmp_outcome(oparg, v, w);

  00517	4c 8b c7	 mov	 r8, rdi
  0051a	48 8b d3	 mov	 rdx, rbx
  0051d	8b ce		 mov	 ecx, esi
  0051f	e8 00 00 00 00	 call	 cmp_outcome

; 2343 :             Py_DECREF(v);

  00524	48 8b cb	 mov	 rcx, rbx
  00527	4c 8b f8	 mov	 r15, rax
  0052a	e8 00 00 00 00	 call	 _Py_DecRef

; 2344 :             Py_DECREF(w);

  0052f	48 8b cf	 mov	 rcx, rdi
  00532	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :             SET_TOP(x);

  00537	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15

; 2346 :             if (x == NULL) break;

  0053c	4d 85 ff	 test	 r15, r15
  0053f	0f 84 ba 06 00
	00		 je	 $LN977@PyEval_Eva

; 2347 :             PREDICT(POP_JUMP_IF_FALSE);

  00545	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]

; 2442 : 
; 2443 :         PREDICTED_WITH_ARG(POP_JUMP_IF_FALSE);

  00549	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  00550	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
  00555	3c 72		 cmp	 al, 114			; 00000072H
  00557	75 19		 jne	 SHORT $LN217@PyEval_Eva
  00559	41 0f b6 75 02	 movzx	 esi, BYTE PTR [r13+2]
  0055e	41 0f b6 45 01	 movzx	 eax, BYTE PTR [r13+1]
$PRED_POP_JUMP_IF_FALSE$65037:
  00563	c1 e6 08	 shl	 esi, 8
  00566	03 f0		 add	 esi, eax
  00568	49 83 c5 03	 add	 r13, 3
  0056c	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
  00570	eb 51		 jmp	 SHORT $LN190@PyEval_Eva
$LN217@PyEval_Eva:

; 2348 :             PREDICT(POP_JUMP_IF_TRUE);

  00572	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  00575	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00579	be 00 00 00 00	 mov	 esi, 0
  0057e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00585	3c 73		 cmp	 al, 115			; 00000073H
  00587	0f 85 5f fc ff
	ff		 jne	 $LN1002@PyEval_Eva

; 2459 :             else if (err == 0)
; 2460 :                 JUMPTO(oparg);
; 2461 :             else
; 2462 :                 break;
; 2463 :             DISPATCH();
; 2464 : 
; 2465 :         PREDICTED_WITH_ARG(POP_JUMP_IF_TRUE);

  0058d	41 0f b6 75 02	 movzx	 esi, BYTE PTR [r13+2]
  00592	41 0f b6 45 01	 movzx	 eax, BYTE PTR [r13+1]
$PRED_POP_JUMP_IF_TRUE$65039:
  00597	c1 e6 08	 shl	 esi, 8
  0059a	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  005a1	03 f0		 add	 esi, eax
  005a3	49 83 c5 03	 add	 r13, 3
  005a7	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
  005ab	eb 54		 jmp	 SHORT $LN183@PyEval_Eva
$LN191@PyEval_Eva:

; 2438 : 
; 2439 :         TARGET(JUMP_FORWARD)
; 2440 :             JUMPBY(oparg);

  005ad	48 63 c6	 movsxd	 rax, esi
  005b0	48 03 d8	 add	 rbx, rax
  005b3	48 89 5d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rbx

; 2441 :             FAST_DISPATCH();

  005b7	4c 8b eb	 mov	 r13, rbx
  005ba	e9 ba 02 00 00	 jmp	 $LN1028@PyEval_Eva
$LN972@PyEval_Eva:

; 2564 : 
; 2565 :         PREDICTED_WITH_ARG(FOR_ITER);

  005bf	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
$LN190@PyEval_Eva:

; 2444 :         TARGET(POP_JUMP_IF_FALSE)
; 2445 :             w = POP();

  005c3	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  005c8	49 83 ec 08	 sub	 r12, 8

; 2446 :             if (w == Py_True) {

  005cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  005d3	48 3b d8	 cmp	 rbx, rax

; 2447 :                 Py_DECREF(w);
; 2448 :                 FAST_DISPATCH();

  005d6	0f 84 91 02 00
	00		 je	 $LN1033@PyEval_Eva

; 2449 :             }
; 2450 :             if (w == Py_False) {
; 2451 :                 Py_DECREF(w);

  005dc	48 8b cb	 mov	 rcx, rbx
  005df	49 3b db	 cmp	 rbx, r11
  005e2	0f 85 b0 03 00
	00		 jne	 $LN188@PyEval_Eva
$LN1031@PyEval_Eva:
  005e8	e8 00 00 00 00	 call	 _Py_DecRef
$LN1032@PyEval_Eva:

; 2452 :                 JUMPTO(oparg);

  005ed	4c 63 ee	 movsxd	 r13, esi
  005f0	4c 03 6d af	 add	 r13, QWORD PTR first_instr$1$[rbp-153]
  005f4	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13

; 2453 :                 FAST_DISPATCH();

  005f8	e9 78 02 00 00	 jmp	 $LN1013@PyEval_Eva
$LN971@PyEval_Eva:

; 2564 : 
; 2565 :         PREDICTED_WITH_ARG(FOR_ITER);

  005fd	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
$LN183@PyEval_Eva:

; 2466 :         TARGET(POP_JUMP_IF_TRUE)
; 2467 :             w = POP();

  00601	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  00606	49 83 ec 08	 sub	 r12, 8

; 2468 :             if (w == Py_False) {

  0060a	49 3b db	 cmp	 rbx, r11

; 2470 :                 FAST_DISPATCH();

  0060d	0f 84 5a 02 00
	00		 je	 $LN1033@PyEval_Eva

; 2471 :             }
; 2472 :             if (w == Py_True) {

  00613	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 2473 :                 Py_DECREF(w);

  0061a	48 8b cb	 mov	 rcx, rbx
  0061d	48 3b d8	 cmp	 rbx, rax
  00620	74 c6		 je	 SHORT $LN1031@PyEval_Eva

; 2474 :                 JUMPTO(oparg);
; 2475 :                 FAST_DISPATCH();
; 2476 :             }
; 2477 :             err = PyObject_IsTrue(w);

  00622	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2478 :             Py_DECREF(w);

  00627	48 8b cb	 mov	 rcx, rbx
  0062a	8b f8		 mov	 edi, eax
  0062c	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  0062f	e8 00 00 00 00	 call	 _Py_DecRef

; 2479 :             if (err > 0) {

  00634	85 ff		 test	 edi, edi
  00636	0f 8e 8a 03 00
	00		 jle	 $LN1036@PyEval_Eva
$LN1062@PyEval_Eva:

; 2480 :                 err = 0;
; 2481 :                 JUMPTO(oparg);

  0063c	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  00640	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00644	33 ff		 xor	 edi, edi
  00646	48 63 c6	 movsxd	 rax, esi
  00649	89 7d 7f	 mov	 DWORD PTR err$1$[rbp-153], edi
  0064c	48 03 c2	 add	 rax, rdx
  0064f	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  00653	e9 78 2a 00 00	 jmp	 $LN1026@PyEval_Eva
$LN176@PyEval_Eva:

; 2488 : 
; 2489 :         TARGET(JUMP_IF_FALSE_OR_POP)
; 2490 :             w = TOP();

  00658	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2491 :             if (w == Py_True) {

  0065d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00664	48 3b d9	 cmp	 rbx, rcx
  00667	75 15		 jne	 SHORT $LN175@PyEval_Eva

; 2492 :                 STACKADJ(-1);
; 2493 :                 Py_DECREF(w);

  00669	48 8b cb	 mov	 rcx, rbx
  0066c	49 83 c4 f8	 add	 r12, -8
  00670	e8 00 00 00 00	 call	 _Py_DecRef
  00675	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00679	e9 f7 01 00 00	 jmp	 $LN1013@PyEval_Eva
$LN175@PyEval_Eva:

; 2494 :                 FAST_DISPATCH();
; 2495 :             }
; 2496 :             if (w == Py_False) {

  0067e	49 3b db	 cmp	 rbx, r11
  00681	0f 84 66 ff ff
	ff		 je	 $LN1032@PyEval_Eva

; 2497 :                 JUMPTO(oparg);
; 2498 :                 FAST_DISPATCH();
; 2499 :             }
; 2500 :             err = PyObject_IsTrue(w);

  00687	48 8b cb	 mov	 rcx, rbx
  0068a	e8 00 00 00 00	 call	 PyObject_IsTrue
  0068f	8b f8		 mov	 edi, eax
  00691	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax

; 2501 :             if (err > 0) {

  00694	85 c0		 test	 eax, eax
  00696	0f 8e 39 03 00
	00		 jle	 $LN1037@PyEval_Eva

; 2502 :                 STACKADJ(-1);
; 2503 :                 Py_DECREF(w);

  0069c	48 8b cb	 mov	 rcx, rbx
  0069f	49 83 ec 08	 sub	 r12, 8
  006a3	e8 00 00 00 00	 call	 _Py_DecRef

; 2504 :                 err = 0;

  006a8	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  006ac	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  006b0	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  006b4	33 f6		 xor	 esi, esi
  006b6	8b fe		 mov	 edi, esi
  006b8	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi
  006bb	e9 12 2a 00 00	 jmp	 $LN1035@PyEval_Eva
$LN169@PyEval_Eva:

; 2511 : 
; 2512 :         TARGET(JUMP_IF_TRUE_OR_POP)
; 2513 :             w = TOP();

  006c0	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2514 :             if (w == Py_False) {

  006c5	49 3b db	 cmp	 rbx, r11
  006c8	75 15		 jne	 SHORT $LN168@PyEval_Eva

; 2515 :                 STACKADJ(-1);
; 2516 :                 Py_DECREF(w);

  006ca	48 8b cb	 mov	 rcx, rbx
  006cd	49 83 c4 f8	 add	 r12, -8
  006d1	e8 00 00 00 00	 call	 _Py_DecRef
  006d6	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  006da	e9 96 01 00 00	 jmp	 $LN1013@PyEval_Eva
$LN168@PyEval_Eva:

; 2517 :                 FAST_DISPATCH();
; 2518 :             }
; 2519 :             if (w == Py_True) {

  006df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  006e6	48 3b d8	 cmp	 rbx, rax
  006e9	0f 84 fe fe ff
	ff		 je	 $LN1032@PyEval_Eva

; 2520 :                 JUMPTO(oparg);
; 2521 :                 FAST_DISPATCH();
; 2522 :             }
; 2523 :             err = PyObject_IsTrue(w);

  006ef	48 8b cb	 mov	 rcx, rbx
  006f2	e8 00 00 00 00	 call	 PyObject_IsTrue
  006f7	8b f8		 mov	 edi, eax
  006f9	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax

; 2524 :             if (err > 0) {

  006fc	85 c0		 test	 eax, eax

; 2525 :                 err = 0;
; 2526 :                 JUMPTO(oparg);

  006fe	0f 8f 38 ff ff
	ff		 jg	 $LN1062@PyEval_Eva

; 2527 :             }
; 2528 :             else if (err == 0) {

  00704	0f 85 7f 02 00
	00		 jne	 $LN1053@PyEval_Eva

; 2529 :                 STACKADJ(-1);

  0070a	49 83 ec 08	 sub	 r12, 8
$LN1059@PyEval_Eva:

; 2530 :                 Py_DECREF(w);

  0070e	48 8b cb	 mov	 rcx, rbx
  00711	e8 00 00 00 00	 call	 _Py_DecRef

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  00716	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0071a	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0071e	e9 a9 29 00 00	 jmp	 $LN1025@PyEval_Eva
$LN161@PyEval_Eva:

; 2550 : #endif
; 2551 : 
; 2552 :         TARGET(GET_ITER)
; 2553 :             /* before: [obj]; after [getiter(obj)] */
; 2554 :             v = TOP();

  00723	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2555 :             x = PyObject_GetIter(v);

  00728	48 8b cb	 mov	 rcx, rbx
  0072b	e8 00 00 00 00	 call	 PyObject_GetIter

; 2556 :             Py_DECREF(v);

  00730	48 8b cb	 mov	 rcx, rbx
  00733	4c 8b f8	 mov	 r15, rax
  00736	e8 00 00 00 00	 call	 _Py_DecRef

; 2557 :             if (x != NULL) {
; 2558 :                 SET_TOP(x);
; 2559 :                 PREDICT(FOR_ITER);

  0073b	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0073f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00746	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  0074d	4d 85 ff	 test	 r15, r15
  00750	0f 84 9c 02 00
	00		 je	 $LN160@PyEval_Eva
  00756	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  0075a	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15
  0075f	80 38 5d	 cmp	 BYTE PTR [rax], 93	; 0000005dH
  00762	be 00 00 00 00	 mov	 esi, 0
  00767	0f 85 83 fa ff
	ff		 jne	 $LN1008@PyEval_Eva

; 2564 : 
; 2565 :         PREDICTED_WITH_ARG(FOR_ITER);

  0076d	0f b6 70 02	 movzx	 esi, BYTE PTR [rax+2]
  00771	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00775	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00779	c1 e6 08	 shl	 esi, 8
$PRED_FOR_ITER$65145:
  0077c	03 f0		 add	 esi, eax
  0077e	49 83 c5 03	 add	 r13, 3
  00782	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
$LN158@PyEval_Eva:

; 2566 :         TARGET(FOR_ITER)
; 2567 :             /* before: [iter]; after: [iter, iter()] *or* [] */
; 2568 :             v = TOP();

  00786	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]

; 2569 :             x = (*v->ob_type->tp_iternext)(v);

  0078b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0078f	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  00795	4c 8b f8	 mov	 r15, rax

; 2570 :             if (x != NULL) {

  00798	48 85 c0	 test	 rax, rax
  0079b	0f 84 fd 02 00
	00		 je	 $LN157@PyEval_Eva

; 2571 :                 PUSH(x);

  007a1	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 2572 :                 PREDICT(STORE_FAST);

  007a5	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  007a9	49 83 c4 08	 add	 r12, 8
  007ad	80 38 7d	 cmp	 BYTE PTR [rax], 125	; 0000007dH
  007b0	0f 85 4b 02 00
	00		 jne	 $LN156@PyEval_Eva

; 1430 : 
; 1431 :         PREDICTED_WITH_ARG(STORE_FAST);

  007b6	0f b6 70 02	 movzx	 esi, BYTE PTR [rax+2]
  007ba	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  007be	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  007c2	c1 e6 08	 shl	 esi, 8
$PRED_STORE_FAST$64448:
  007c5	03 f0		 add	 esi, eax
  007c7	49 83 c5 03	 add	 r13, 3
  007cb	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
  007cf	eb 04		 jmp	 SHORT $LN507@PyEval_Eva
$LN970@PyEval_Eva:

; 1417 :                 PUSH(x);
; 1418 :                 FAST_DISPATCH();

  007d1	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
$LN507@PyEval_Eva:

; 1432 :         TARGET(STORE_FAST)
; 1433 :             v = POP();
; 1434 :             SETLOCAL(oparg, v);

  007d5	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  007da	48 63 ce	 movsxd	 rcx, esi
  007dd	49 83 ec 08	 sub	 r12, 8
  007e1	49 8b 9c ce d0
	01 00 00	 mov	 rbx, QWORD PTR [r14+rcx*8+464]
  007e9	49 89 84 ce d0
	01 00 00	 mov	 QWORD PTR [r14+rcx*8+464], rax
  007f1	48 85 db	 test	 rbx, rbx
  007f4	74 7f		 je	 SHORT $LN1013@PyEval_Eva
  007f6	e8 00 00 00 00	 call	 _Py_PXCTX
  007fb	85 c0		 test	 eax, eax
  007fd	75 76		 jne	 SHORT $LN1013@PyEval_Eva
  007ff	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00803	a8 20		 test	 al, 32			; 00000020H
  00805	75 4c		 jne	 SHORT $LN574@PyEval_Eva
  00807	84 c0		 test	 al, al
  00809	78 48		 js	 SHORT $LN574@PyEval_Eva
  0080b	a8 02		 test	 al, 2
  0080d	75 66		 jne	 SHORT $LN1013@PyEval_Eva
  0080f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00813	75 60		 jne	 SHORT $LN1013@PyEval_Eva
  00815	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0081c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00823	4c 8b cb	 mov	 r9, rbx
  00826	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0082c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00834	e8 00 00 00 00	 call	 _PyParallel_Guard
  00839	48 8b cb	 mov	 rcx, rbx
  0083c	85 c0		 test	 eax, eax
  0083e	74 07		 je	 SHORT $LN579@PyEval_Eva
  00840	e8 00 00 00 00	 call	 _Px_Dealloc
  00845	eb 2e		 jmp	 SHORT $LN1013@PyEval_Eva
$LN579@PyEval_Eva:
  00847	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0084b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00851	eb 22		 jmp	 SHORT $LN1013@PyEval_Eva
$LN574@PyEval_Eva:
  00853	48 8b cb	 mov	 rcx, rbx
  00856	e8 00 00 00 00	 call	 Px_DecRef
  0085b	eb 18		 jmp	 SHORT $LN1013@PyEval_Eva
$LN967@PyEval_Eva:

; 2041 :             break;
; 2042 : 
; 2043 :         PREDICTED_WITH_ARG(UNPACK_SEQUENCE);

  0085d	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00861	eb 18		 jmp	 SHORT $fast_next_opcode$64408
$LN969@PyEval_Eva:
  00863	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00867	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  0086b	eb 0e		 jmp	 SHORT $fast_next_opcode$64408
$LN1033@PyEval_Eva:

; 2469 :                 Py_DECREF(w);

  0086d	48 8b cb	 mov	 rcx, rbx
  00870	e8 00 00 00 00	 call	 _Py_DecRef
$LN1013@PyEval_Eva:

; 1432 :         TARGET(STORE_FAST)
; 1433 :             v = POP();
; 1434 :             SETLOCAL(oparg, v);

  00875	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
$LN1028@PyEval_Eva:
  00879	33 f6		 xor	 esi, esi
$fast_next_opcode$64408:

; 1337 :             }
; 1338 :         }
; 1339 : 
; 1340 :     fast_next_opcode:
; 1341 :         f->f_lasti = INSTR_OFFSET();
; 1342 : 
; 1343 :         /* line-by-line tracing support */
; 1344 : 
; 1345 :         if (_Py_TracingPossible &&
; 1346 :             tstate->c_tracefunc != NULL && !tstate->tracing) {

  0087b	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  0087e	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00882	41 8b c5	 mov	 eax, r13d
  00885	2b c2		 sub	 eax, edx
  00887	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Py_TracingPossible, 0
  0088e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00895	41 89 86 d0 00
	00 00		 mov	 DWORD PTR [r14+208], eax
  0089c	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  008a0	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  008a7	0f 84 37 fa ff
	ff		 je	 $fast_next_opcode_notracing$64405
  008ad	48 8b 4d 9f	 mov	 rcx, QWORD PTR tstate$1$[rbp-153]
  008b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  008b8	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  008bf	48 83 79 30 00	 cmp	 QWORD PTR [rcx+48], 0
  008c4	0f 84 1a fa ff
	ff		 je	 $fast_next_opcode_notracing$64405
  008ca	83 79 20 00	 cmp	 DWORD PTR [rcx+32], 0
  008ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  008d5	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  008dc	0f 85 02 fa ff
	ff		 jne	 $fast_next_opcode_notracing$64405

; 1347 :             /* see maybe_call_line_trace
; 1348 :                for expository comments */
; 1349 :             f->f_stacktop = stack_pointer;

  008e2	4d 89 a6 a0 00
	00 00		 mov	 QWORD PTR [r14+160], r12

; 1350 : 
; 1351 :             err = maybe_call_line_trace(tstate->c_tracefunc,
; 1352 :                                         tstate->c_traceobj,
; 1353 :                                         f, &instr_lb, &instr_ub,
; 1354 :                                         &instr_prev);

  008e9	48 8b 51 40	 mov	 rdx, QWORD PTR [rcx+64]
  008ed	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  008f1	48 8d 45 07	 lea	 rax, QWORD PTR instr_prev$[rbp-153]
  008f5	4c 8d 4d ff	 lea	 r9, QWORD PTR instr_lb$[rbp-153]
  008f9	4d 8b c6	 mov	 r8, r14
  008fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00901	48 8d 45 03	 lea	 rax, QWORD PTR instr_ub$[rbp-153]
  00905	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0090a	e8 00 00 00 00	 call	 maybe_call_line_trace

; 1355 :             /* Reload possibly changed frame fields */
; 1356 :             JUMPTO(f->f_lasti);

  0090f	4d 63 ae d0 00
	00 00		 movsxd	 r13, DWORD PTR [r14+208]
  00916	4c 03 6d af	 add	 r13, QWORD PTR first_instr$1$[rbp-153]
  0091a	8b f8		 mov	 edi, eax
  0091c	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax

; 1357 :             if (f->f_stacktop != NULL) {

  0091f	49 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [r14+160]
  00926	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
  0092a	48 85 c0	 test	 rax, rax
  0092d	74 0a		 je	 SHORT $LN516@PyEval_Eva

; 1358 :                 stack_pointer = f->f_stacktop;

  0092f	4c 8b e0	 mov	 r12, rax

; 1359 :                 f->f_stacktop = NULL;

  00932	49 89 b6 a0 00
	00 00		 mov	 QWORD PTR [r14+160], rsi
$LN516@PyEval_Eva:

; 1360 :             }
; 1361 :             if (err) {

  00939	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0093d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00944	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  0094b	85 ff		 test	 edi, edi
  0094d	0f 85 f0 23 00
	00		 jne	 $LN994@PyEval_Eva
  00953	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  00957	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  0095b	e9 84 f9 ff ff	 jmp	 $fast_next_opcode_notracing$64405
$LN509@PyEval_Eva:

; 1419 :             }
; 1420 :             format_exc_check_arg(PyExc_UnboundLocalError,
; 1421 :                 UNBOUNDLOCAL_ERROR_MSG,
; 1422 :                 PyTuple_GetItem(co->co_varnames, oparg));

  00960	48 63 d6	 movsxd	 rdx, esi
$LN257@PyEval_Eva:
  00963	48 8b 45 df	 mov	 rax, QWORD PTR co$1$[rbp-153]
  00967	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  0096e	e8 00 00 00 00	 call	 PyTuple_GetItem
  00973	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnboundLocalError
  0097a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@
  00981	4c 8b c0	 mov	 r8, rax
$LN1054@PyEval_Eva:
  00984	e8 00 00 00 00	 call	 format_exc_check_arg
$LN1053@PyEval_Eva:

; 1423 :             break;

  00989	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
$LN992@PyEval_Eva:
  0098d	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
$LN1051@PyEval_Eva:
  00991	33 f6		 xor	 esi, esi
  00993	e9 78 18 00 00	 jmp	 $LN1052@PyEval_Eva
$LN188@PyEval_Eva:

; 2454 :             }
; 2455 :             err = PyObject_IsTrue(w);

  00998	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2456 :             Py_DECREF(w);

  0099d	48 8b cb	 mov	 rcx, rbx
  009a0	8b f8		 mov	 edi, eax
  009a2	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  009a5	e8 00 00 00 00	 call	 _Py_DecRef

; 2457 :             if (err > 0)
; 2458 :                 err = 0;

  009aa	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  009ae	85 ff		 test	 edi, edi
  009b0	7e 27		 jle	 SHORT $LN1034@PyEval_Eva
  009b2	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  009b6	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  009ba	33 f6		 xor	 esi, esi
  009bc	8b fe		 mov	 edi, esi
  009be	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi
  009c1	e9 0c 27 00 00	 jmp	 $LN1035@PyEval_Eva
$LN1036@PyEval_Eva:

; 2482 :             }
; 2483 :             else if (err == 0)
; 2484 :                 ;
; 2485 :             else
; 2486 :                 break;
; 2487 :             DISPATCH();

  009c6	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  009ca	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  009ce	75 c1		 jne	 SHORT $LN1051@PyEval_Eva
  009d0	e9 f7 26 00 00	 jmp	 $LN1025@PyEval_Eva
$LN1037@PyEval_Eva:

; 2508 :             else
; 2509 :                 break;
; 2510 :             DISPATCH();

  009d5	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
$LN1034@PyEval_Eva:

; 2505 :             }
; 2506 :             else if (err == 0)

  009d9	0f 85 59 23 00
	00		 jne	 $LN974@PyEval_Eva

; 2507 :                 JUMPTO(oparg);

  009df	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  009e3	48 63 c6	 movsxd	 rax, esi
  009e6	48 03 c2	 add	 rax, rdx
  009e9	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax

; 2508 :             else
; 2509 :                 break;
; 2510 :             DISPATCH();

  009ed	e9 de 26 00 00	 jmp	 $LN1026@PyEval_Eva
$LN160@PyEval_Eva:

; 2560 :                 DISPATCH();
; 2561 :             }
; 2562 :             STACKADJ(-1);
; 2563 :             break;

  009f2	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  009f6	49 83 ec 08	 sub	 r12, 8
$LN978@PyEval_Eva:
  009fa	33 f6		 xor	 esi, esi
  009fc	e9 1d 18 00 00	 jmp	 $LN1011@PyEval_Eva
$LN156@PyEval_Eva:

; 2573 :                 PREDICT(UNPACK_SEQUENCE);

  00a01	80 38 5c	 cmp	 BYTE PTR [rax], 92	; 0000005cH
  00a04	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00a08	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00a0c	be 00 00 00 00	 mov	 esi, 0
  00a11	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00a18	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  00a1f	0f 85 d4 f7 ff
	ff		 jne	 $LN937@PyEval_Eva

; 2041 :             break;
; 2042 : 
; 2043 :         PREDICTED_WITH_ARG(UNPACK_SEQUENCE);

  00a25	0f b6 70 02	 movzx	 esi, BYTE PTR [rax+2]
  00a29	4c 8b 6d 97	 mov	 r13, QWORD PTR next_instr$1$[rbp-153]
  00a2d	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00a31	c1 e6 08	 shl	 esi, 8
$PRED_UNPACK_SEQUENCE$64842:
  00a34	03 f0		 add	 esi, eax
  00a36	49 83 c5 03	 add	 r13, 3
  00a3a	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
$LN312@PyEval_Eva:

; 2044 :         TARGET(UNPACK_SEQUENCE)
; 2045 :             v = POP();

  00a3e	4d 8b 6c 24 f8	 mov	 r13, QWORD PTR [r12-8]
  00a43	49 83 ec 08	 sub	 r12, 8

; 2046 :             if (PyTuple_CheckExact(v) &&
; 2047 :                 PyTuple_GET_SIZE(v) == oparg) {

  00a47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTuple_Type
  00a4e	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  00a52	48 63 fe	 movsxd	 rdi, esi
  00a55	48 3b c1	 cmp	 rax, rcx
  00a58	0f 85 ec 18 00
	00		 jne	 $LN311@PyEval_Eva
  00a5e	49 39 7d 60	 cmp	 QWORD PTR [r13+96], rdi
  00a62	0f 85 e2 18 00
	00		 jne	 $LN311@PyEval_Eva

; 2048 :                 PyObject **items = \
; 2049 :                     ((PyTupleObject *)v)->ob_item;
; 2050 :                 while (oparg--) {

  00a68	85 f6		 test	 esi, esi
  00a6a	74 21		 je	 SHORT $LN824@PyEval_Eva
  00a6c	0f 1f 40 00	 npad	 4
$LL310@PyEval_Eva:

; 2051 :                     w = items[oparg];

  00a70	49 8b 5c fd 68	 mov	 rbx, QWORD PTR [r13+rdi*8+104]
  00a75	48 ff cf	 dec	 rdi

; 2052 :                     Py_INCREF(w);

  00a78	48 8b cb	 mov	 rcx, rbx
  00a7b	e8 00 00 00 00	 call	 _Py_IncRef

; 2053 :                     PUSH(w);

  00a80	49 89 1c 24	 mov	 QWORD PTR [r12], rbx
  00a84	49 83 c4 08	 add	 r12, 8
  00a88	48 85 ff	 test	 rdi, rdi
  00a8b	75 e3		 jne	 SHORT $LL310@PyEval_Eva
$LN824@PyEval_Eva:

; 2054 :                 }
; 2055 :                 Py_DECREF(v);

  00a8d	49 8b cd	 mov	 rcx, r13
  00a90	e8 00 00 00 00	 call	 _Py_DecRef

; 2056 :                 DISPATCH();

  00a95	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00a99	e9 27 26 00 00	 jmp	 $LN1040@PyEval_Eva
$LN157@PyEval_Eva:

; 2574 :                 DISPATCH();
; 2575 :             }
; 2576 :             if (PyErr_Occurred()) {

  00a9e	e8 00 00 00 00	 call	 PyErr_Occurred
  00aa3	48 85 c0	 test	 rax, rax
  00aa6	74 19		 je	 SHORT $LN154@PyEval_Eva

; 2577 :                 if (!PyErr_ExceptionMatches(
; 2578 :                                 PyExc_StopIteration))

  00aa8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00aaf	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00ab4	85 c0		 test	 eax, eax
  00ab6	0f 84 cd fe ff
	ff		 je	 $LN1053@PyEval_Eva

; 2579 :                     break;
; 2580 :                 PyErr_Clear();

  00abc	e8 00 00 00 00	 call	 PyErr_Clear
$LN154@PyEval_Eva:

; 2581 :             }
; 2582 :             /* iterator ended normally */
; 2583 :             x = v = POP();

  00ac1	4d 8b 7c 24 f8	 mov	 r15, QWORD PTR [r12-8]
  00ac6	49 83 ec 08	 sub	 r12, 8

; 2584 :             Py_DECREF(v);

  00aca	49 8b cf	 mov	 rcx, r15
  00acd	e8 00 00 00 00	 call	 _Py_DecRef

; 2585 :             JUMPBY(oparg);

  00ad2	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]

; 2586 :             DISPATCH();

  00ad6	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00ada	4c 63 de	 movsxd	 r11, esi
  00add	49 03 c3	 add	 rax, r11
  00ae0	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  00ae4	e9 e3 25 00 00	 jmp	 $LN1025@PyEval_Eva
$LN494@PyEval_Eva:

; 1472 :             FAST_DISPATCH();
; 1473 : 
; 1474 :         TARGET(UNARY_POSITIVE)
; 1475 :             v = TOP();

  00ae9	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 1476 :             x = PyNumber_Positive(v);

  00aee	48 8b cb	 mov	 rcx, rbx
  00af1	e8 00 00 00 00	 call	 PyNumber_Positive

; 1477 :             Py_DECREF(v);
; 1478 :             SET_TOP(x);
; 1479 :             if (x != NULL) DISPATCH();
; 1480 :             break;

  00af6	e9 23 01 00 00	 jmp	 $LN1078@PyEval_Eva
$LN492@PyEval_Eva:

; 1481 : 
; 1482 :         TARGET(UNARY_NEGATIVE)
; 1483 :             v = TOP();

  00afb	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 1484 :             x = PyNumber_Negative(v);

  00b00	48 8b cb	 mov	 rcx, rbx
  00b03	e8 00 00 00 00	 call	 PyNumber_Negative

; 1485 :             Py_DECREF(v);
; 1486 :             SET_TOP(x);
; 1487 :             if (x != NULL) DISPATCH();
; 1488 :             break;

  00b08	e9 11 01 00 00	 jmp	 $LN1078@PyEval_Eva
$LN490@PyEval_Eva:

; 1489 : 
; 1490 :         TARGET(UNARY_NOT)
; 1491 :             v = TOP();

  00b0d	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 1492 :             err = PyObject_IsTrue(v);

  00b12	48 8b cb	 mov	 rcx, rbx
  00b15	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1493 :             Py_DECREF(v);

  00b1a	48 8b cb	 mov	 rcx, rbx
  00b1d	44 8b e8	 mov	 r13d, eax
  00b20	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  00b23	e8 00 00 00 00	 call	 _Py_DecRef

; 1494 :             if (err == 0) {

  00b28	45 85 ed	 test	 r13d, r13d
  00b2b	75 5b		 jne	 SHORT $LN1039@PyEval_Eva

; 1495 :                 Py_INCREF(Py_True);

  00b2d	e8 00 00 00 00	 call	 _Py_PXCTX
  00b32	85 c0		 test	 eax, eax
  00b34	75 3d		 jne	 SHORT $LN594@PyEval_Eva
  00b36	b8 02 00 00 00	 mov	 eax, 2
  00b3b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  00b42	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00b49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00b50	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00b56	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b5a	e8 00 00 00 00	 call	 _PyParallel_Guard
  00b5f	85 c0		 test	 eax, eax
  00b61	75 09		 jne	 SHORT $LN593@PyEval_Eva
  00b63	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00b6a	74 07		 je	 SHORT $LN594@PyEval_Eva
$LN593@PyEval_Eva:
  00b6c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN594@PyEval_Eva:

; 1496 :                 SET_TOP(Py_True);
; 1497 :                 DISPATCH();

  00b73	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00b77	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00b7e	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax
  00b83	e9 3d 25 00 00	 jmp	 $LN1040@PyEval_Eva
$LN1039@PyEval_Eva:

; 1498 :             }
; 1499 :             else if (err > 0) {

  00b88	7e 71		 jle	 SHORT $LN487@PyEval_Eva

; 1500 :                 Py_INCREF(Py_False);

  00b8a	e8 00 00 00 00	 call	 _Py_PXCTX
  00b8f	85 c0		 test	 eax, eax
  00b91	75 3d		 jne	 SHORT $LN598@PyEval_Eva
  00b93	b8 02 00 00 00	 mov	 eax, 2
  00b98	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00b9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00ba6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00bad	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00bb3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bb7	e8 00 00 00 00	 call	 _PyParallel_Guard
  00bbc	85 c0		 test	 eax, eax
  00bbe	75 09		 jne	 SHORT $LN597@PyEval_Eva
  00bc0	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00bc7	74 07		 je	 SHORT $LN598@PyEval_Eva
$LN597@PyEval_Eva:
  00bc9	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN598@PyEval_Eva:

; 1501 :                 SET_TOP(Py_False);
; 1502 :                 err = 0;
; 1503 :                 DISPATCH();

  00bd0	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  00bd4	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00bd8	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00bdc	33 f6		 xor	 esi, esi
  00bde	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  00be5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00bec	4d 89 5c 24 f8	 mov	 QWORD PTR [r12-8], r11
  00bf1	8b fe		 mov	 edi, esi
  00bf3	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi
  00bf6	e9 fe f5 ff ff	 jmp	 $LN937@PyEval_Eva
$LN487@PyEval_Eva:

; 1504 :             }
; 1505 :             STACKADJ(-1);

  00bfb	49 83 c4 f8	 add	 r12, -8
$LN977@PyEval_Eva:

; 1506 :             break;

  00bff	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  00c02	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  00c06	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00c0a	33 f6		 xor	 esi, esi
  00c0c	e9 ff 15 00 00	 jmp	 $LN1052@PyEval_Eva
$LN486@PyEval_Eva:

; 1507 : 
; 1508 :         TARGET(UNARY_INVERT)
; 1509 :             v = TOP();

  00c11	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 1510 :             x = PyNumber_Invert(v);

  00c16	48 8b cb	 mov	 rcx, rbx
  00c19	e8 00 00 00 00	 call	 PyNumber_Invert
$LN1078@PyEval_Eva:

; 1511 :             Py_DECREF(v);

  00c1e	48 8b cb	 mov	 rcx, rbx
  00c21	4c 8b f8	 mov	 r15, rax
  00c24	e8 00 00 00 00	 call	 _Py_DecRef

; 1512 :             SET_TOP(x);

  00c29	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15
$LN1075@PyEval_Eva:

; 1513 :             if (x != NULL) DISPATCH();

  00c2e	4d 85 ff	 test	 r15, r15
$LN1076@PyEval_Eva:
  00c31	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  00c35	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00c39	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00c3d	be 00 00 00 00	 mov	 esi, 0
  00c42	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00c49	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  00c50	0f 85 a3 f5 ff
	ff		 jne	 $LN937@PyEval_Eva

; 1514 :             break;

  00c56	e9 b5 15 00 00	 jmp	 $LN1052@PyEval_Eva
$LN484@PyEval_Eva:

; 1515 : 
; 1516 :         TARGET(BINARY_POWER)
; 1517 :             w = POP();

  00c5b	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1518 :             v = TOP();

  00c60	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00c65	49 83 ec 08	 sub	 r12, 8

; 1519 :             x = PyNumber_Power(v, w, Py_None);

  00c69	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00c70	48 8b d7	 mov	 rdx, rdi
  00c73	48 8b cb	 mov	 rcx, rbx
  00c76	e8 00 00 00 00	 call	 PyNumber_Power
$LN1079@PyEval_Eva:

; 1520 :             Py_DECREF(v);

  00c7b	48 8b cb	 mov	 rcx, rbx
  00c7e	4c 8b f8	 mov	 r15, rax
  00c81	e8 00 00 00 00	 call	 _Py_DecRef

; 1521 :             Py_DECREF(w);

  00c86	48 8b cf	 mov	 rcx, rdi
$LN1080@PyEval_Eva:
  00c89	e8 00 00 00 00	 call	 _Py_DecRef

; 1522 :             SET_TOP(x);
; 1523 :             if (x != NULL) DISPATCH();

  00c8e	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  00c92	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00c96	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  00c99	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  00c9d	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15
  00ca2	be 00 00 00 00	 mov	 esi, 0
  00ca7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00cae	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  00cb5	4d 85 ff	 test	 r15, r15
  00cb8	0f 85 3b f5 ff
	ff		 jne	 $LN937@PyEval_Eva

; 1524 :             break;

  00cbe	e9 4d 15 00 00	 jmp	 $LN1052@PyEval_Eva
$LN482@PyEval_Eva:

; 1525 : 
; 1526 :         TARGET(BINARY_MULTIPLY)
; 1527 :             w = POP();

  00cc3	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1528 :             v = TOP();

  00cc8	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00ccd	49 83 ec 08	 sub	 r12, 8

; 1529 :             x = PyNumber_Multiply(v, w);

  00cd1	48 8b d7	 mov	 rdx, rdi
  00cd4	48 8b cb	 mov	 rcx, rbx
  00cd7	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1530 :             Py_DECREF(v);
; 1531 :             Py_DECREF(w);
; 1532 :             SET_TOP(x);
; 1533 :             if (x != NULL) DISPATCH();
; 1534 :             break;

  00cdc	eb 9d		 jmp	 SHORT $LN1079@PyEval_Eva
$LN480@PyEval_Eva:

; 1535 : 
; 1536 :         TARGET(BINARY_TRUE_DIVIDE)
; 1537 :             w = POP();

  00cde	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1538 :             v = TOP();

  00ce3	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00ce8	49 83 ec 08	 sub	 r12, 8

; 1539 :             x = PyNumber_TrueDivide(v, w);

  00cec	48 8b d7	 mov	 rdx, rdi
  00cef	48 8b cb	 mov	 rcx, rbx
  00cf2	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 1540 :             Py_DECREF(v);
; 1541 :             Py_DECREF(w);
; 1542 :             SET_TOP(x);
; 1543 :             if (x != NULL) DISPATCH();
; 1544 :             break;

  00cf7	eb 82		 jmp	 SHORT $LN1079@PyEval_Eva
$LN478@PyEval_Eva:

; 1545 : 
; 1546 :         TARGET(BINARY_FLOOR_DIVIDE)
; 1547 :             w = POP();

  00cf9	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1548 :             v = TOP();

  00cfe	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00d03	49 83 ec 08	 sub	 r12, 8

; 1549 :             x = PyNumber_FloorDivide(v, w);

  00d07	48 8b d7	 mov	 rdx, rdi
  00d0a	48 8b cb	 mov	 rcx, rbx
  00d0d	e8 00 00 00 00	 call	 PyNumber_FloorDivide

; 1550 :             Py_DECREF(v);
; 1551 :             Py_DECREF(w);
; 1552 :             SET_TOP(x);
; 1553 :             if (x != NULL) DISPATCH();
; 1554 :             break;

  00d12	e9 64 ff ff ff	 jmp	 $LN1079@PyEval_Eva
$LN476@PyEval_Eva:

; 1555 : 
; 1556 :         TARGET(BINARY_MODULO)
; 1557 :             w = POP();
; 1558 :             v = TOP();

  00d17	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00d1c	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]
  00d21	49 83 ec 08	 sub	 r12, 8

; 1559 :             if (PyUnicode_CheckExact(v))

  00d25	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type

; 1560 :                 x = PyUnicode_Format(v, w);

  00d2c	48 8b d7	 mov	 rdx, rdi
  00d2f	48 8b cb	 mov	 rcx, rbx
  00d32	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00d36	75 0a		 jne	 SHORT $LN475@PyEval_Eva
  00d38	e8 00 00 00 00	 call	 PyUnicode_Format

; 1561 :             else

  00d3d	e9 39 ff ff ff	 jmp	 $LN1079@PyEval_Eva
$LN475@PyEval_Eva:

; 1562 :                 x = PyNumber_Remainder(v, w);

  00d42	e8 00 00 00 00	 call	 PyNumber_Remainder

; 1563 :             Py_DECREF(v);
; 1564 :             Py_DECREF(w);
; 1565 :             SET_TOP(x);
; 1566 :             if (x != NULL) DISPATCH();
; 1567 :             break;

  00d47	e9 2f ff ff ff	 jmp	 $LN1079@PyEval_Eva
$LN472@PyEval_Eva:

; 1568 : 
; 1569 :         TARGET(BINARY_ADD)
; 1570 :             w = POP();
; 1571 :             v = TOP();

  00d4c	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]
  00d51	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  00d56	49 83 ec 08	 sub	 r12, 8

; 1572 :             if (PyUnicode_CheckExact(v) &&
; 1573 :                      PyUnicode_CheckExact(w)) {

  00d5a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00d61	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00d65	75 23		 jne	 SHORT $LN471@PyEval_Eva
  00d67	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  00d6b	75 1d		 jne	 SHORT $LN471@PyEval_Eva
$LN1088@PyEval_Eva:

; 1574 :                 x = unicode_concatenate(v, w, f, next_instr);

  00d6d	4c 8b 4d 97	 mov	 r9, QWORD PTR next_instr$1$[rbp-153]
  00d71	4d 8b c6	 mov	 r8, r14
  00d74	48 8b d3	 mov	 rdx, rbx
  00d77	48 8b cf	 mov	 rcx, rdi
  00d7a	e8 00 00 00 00	 call	 unicode_concatenate
$skip_decref_v$64602:

; 1582 :           skip_decref_vx:
; 1583 :             Py_DECREF(w);

  00d7f	48 8b cb	 mov	 rcx, rbx
  00d82	4c 8b f8	 mov	 r15, rax

; 1584 :             SET_TOP(x);
; 1585 :             if (x != NULL) DISPATCH();
; 1586 :             break;

  00d85	e9 ff fe ff ff	 jmp	 $LN1080@PyEval_Eva
$LN471@PyEval_Eva:

; 1575 :                 /* unicode_concatenate consumed the ref to v */
; 1576 :                 goto skip_decref_vx;
; 1577 :             }
; 1578 :             else {
; 1579 :                 x = PyNumber_Add(v, w);

  00d8a	48 8b d3	 mov	 rdx, rbx
  00d8d	48 8b cf	 mov	 rcx, rdi
  00d90	e8 00 00 00 00	 call	 PyNumber_Add

; 1580 :             }
; 1581 :             Py_DECREF(v);

  00d95	48 8b cf	 mov	 rcx, rdi
  00d98	4c 8b f8	 mov	 r15, rax
  00d9b	e8 00 00 00 00	 call	 _Py_DecRef

; 1582 :           skip_decref_vx:
; 1583 :             Py_DECREF(w);

  00da0	48 8b cb	 mov	 rcx, rbx
$skip_decref_v_1$64602:
$skip_decref_vx$64523:

; 1584 :             SET_TOP(x);
; 1585 :             if (x != NULL) DISPATCH();
; 1586 :             break;

  00da3	e9 e1 fe ff ff	 jmp	 $LN1080@PyEval_Eva
$LN468@PyEval_Eva:

; 1587 : 
; 1588 :         TARGET(BINARY_SUBTRACT)
; 1589 :             w = POP();

  00da8	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1590 :             v = TOP();

  00dad	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00db2	49 83 ec 08	 sub	 r12, 8

; 1591 :             x = PyNumber_Subtract(v, w);

  00db6	48 8b d7	 mov	 rdx, rdi
  00db9	48 8b cb	 mov	 rcx, rbx
  00dbc	e8 00 00 00 00	 call	 PyNumber_Subtract

; 1592 :             Py_DECREF(v);
; 1593 :             Py_DECREF(w);
; 1594 :             SET_TOP(x);
; 1595 :             if (x != NULL) DISPATCH();
; 1596 :             break;

  00dc1	e9 b5 fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN466@PyEval_Eva:

; 1597 : 
; 1598 :         TARGET(BINARY_SUBSCR)
; 1599 :             w = POP();

  00dc6	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1600 :             v = TOP();

  00dcb	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00dd0	49 83 ec 08	 sub	 r12, 8

; 1601 :             x = PyObject_GetItem(v, w);

  00dd4	48 8b d7	 mov	 rdx, rdi
  00dd7	48 8b cb	 mov	 rcx, rbx
  00dda	e8 00 00 00 00	 call	 PyObject_GetItem

; 1602 :             Py_DECREF(v);
; 1603 :             Py_DECREF(w);
; 1604 :             SET_TOP(x);
; 1605 :             if (x != NULL) DISPATCH();
; 1606 :             break;

  00ddf	e9 97 fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN464@PyEval_Eva:

; 1607 : 
; 1608 :         TARGET(BINARY_LSHIFT)
; 1609 :             w = POP();

  00de4	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1610 :             v = TOP();

  00de9	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00dee	49 83 ec 08	 sub	 r12, 8

; 1611 :             x = PyNumber_Lshift(v, w);

  00df2	48 8b d7	 mov	 rdx, rdi
  00df5	48 8b cb	 mov	 rcx, rbx
  00df8	e8 00 00 00 00	 call	 PyNumber_Lshift

; 1612 :             Py_DECREF(v);
; 1613 :             Py_DECREF(w);
; 1614 :             SET_TOP(x);
; 1615 :             if (x != NULL) DISPATCH();
; 1616 :             break;

  00dfd	e9 79 fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN462@PyEval_Eva:

; 1617 : 
; 1618 :         TARGET(BINARY_RSHIFT)
; 1619 :             w = POP();

  00e02	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1620 :             v = TOP();

  00e07	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00e0c	49 83 ec 08	 sub	 r12, 8

; 1621 :             x = PyNumber_Rshift(v, w);

  00e10	48 8b d7	 mov	 rdx, rdi
  00e13	48 8b cb	 mov	 rcx, rbx
  00e16	e8 00 00 00 00	 call	 PyNumber_Rshift

; 1622 :             Py_DECREF(v);
; 1623 :             Py_DECREF(w);
; 1624 :             SET_TOP(x);
; 1625 :             if (x != NULL) DISPATCH();
; 1626 :             break;

  00e1b	e9 5b fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN460@PyEval_Eva:

; 1627 : 
; 1628 :         TARGET(BINARY_AND)
; 1629 :             w = POP();

  00e20	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1630 :             v = TOP();

  00e25	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00e2a	49 83 ec 08	 sub	 r12, 8

; 1631 :             x = PyNumber_And(v, w);

  00e2e	48 8b d7	 mov	 rdx, rdi
  00e31	48 8b cb	 mov	 rcx, rbx
  00e34	e8 00 00 00 00	 call	 PyNumber_And

; 1632 :             Py_DECREF(v);
; 1633 :             Py_DECREF(w);
; 1634 :             SET_TOP(x);
; 1635 :             if (x != NULL) DISPATCH();
; 1636 :             break;

  00e39	e9 3d fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN458@PyEval_Eva:

; 1637 : 
; 1638 :         TARGET(BINARY_XOR)
; 1639 :             w = POP();

  00e3e	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1640 :             v = TOP();

  00e43	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00e48	49 83 ec 08	 sub	 r12, 8

; 1641 :             x = PyNumber_Xor(v, w);

  00e4c	48 8b d7	 mov	 rdx, rdi
  00e4f	48 8b cb	 mov	 rcx, rbx
  00e52	e8 00 00 00 00	 call	 PyNumber_Xor

; 1642 :             Py_DECREF(v);
; 1643 :             Py_DECREF(w);
; 1644 :             SET_TOP(x);
; 1645 :             if (x != NULL) DISPATCH();
; 1646 :             break;

  00e57	e9 1f fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN456@PyEval_Eva:

; 1647 : 
; 1648 :         TARGET(BINARY_OR)
; 1649 :             w = POP();

  00e5c	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1650 :             v = TOP();

  00e61	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00e66	49 83 ec 08	 sub	 r12, 8

; 1651 :             x = PyNumber_Or(v, w);

  00e6a	48 8b d7	 mov	 rdx, rdi
  00e6d	48 8b cb	 mov	 rcx, rbx
  00e70	e8 00 00 00 00	 call	 PyNumber_Or

; 1652 :             Py_DECREF(v);
; 1653 :             Py_DECREF(w);
; 1654 :             SET_TOP(x);
; 1655 :             if (x != NULL) DISPATCH();
; 1656 :             break;

  00e75	e9 01 fe ff ff	 jmp	 $LN1079@PyEval_Eva
$LN454@PyEval_Eva:

; 1657 : 
; 1658 :         TARGET(LIST_APPEND)
; 1659 :             w = POP();

  00e7a	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  00e7f	49 83 ec 08	 sub	 r12, 8

; 1660 :             v = PEEK(oparg);

  00e83	48 63 d6	 movsxd	 rdx, esi
  00e86	48 c1 e2 03	 shl	 rdx, 3
  00e8a	49 8b c4	 mov	 rax, r12
  00e8d	48 2b c2	 sub	 rax, rdx

; 1661 :             err = PyList_Append(v, w);

  00e90	48 8b d3	 mov	 rdx, rbx
  00e93	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00e96	e8 00 00 00 00	 call	 PyList_Append

; 1662 :             Py_DECREF(w);
; 1663 :             if (err == 0) {
; 1664 :                 PREDICT(JUMP_ABSOLUTE);
; 1665 :                 DISPATCH();

  00e9b	eb 21		 jmp	 SHORT $LN1086@PyEval_Eva
$LN451@PyEval_Eva:

; 1666 :             }
; 1667 :             break;
; 1668 : 
; 1669 :         TARGET(SET_ADD)
; 1670 :             w = POP();

  00e9d	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  00ea2	49 83 ec 08	 sub	 r12, 8

; 1671 :             v = stack_pointer[-oparg];

  00ea6	48 63 d6	 movsxd	 rdx, esi
  00ea9	48 c1 e2 03	 shl	 rdx, 3
  00ead	49 8b c4	 mov	 rax, r12
  00eb0	48 2b c2	 sub	 rax, rdx

; 1672 :             err = PySet_Add(v, w);

  00eb3	48 8b d3	 mov	 rdx, rbx
  00eb6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00eb9	e8 00 00 00 00	 call	 PySet_Add
$LN1086@PyEval_Eva:

; 1673 :             Py_DECREF(w);

  00ebe	48 8b cb	 mov	 rcx, rbx
  00ec1	8b f8		 mov	 edi, eax
  00ec3	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  00ec6	e8 00 00 00 00	 call	 _Py_DecRef

; 1674 :             if (err == 0) {
; 1675 :                 PREDICT(JUMP_ABSOLUTE);

  00ecb	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  00ecf	85 ff		 test	 edi, edi
  00ed1	0f 85 b6 fa ff
	ff		 jne	 $LN992@PyEval_Eva
  00ed7	80 38 71	 cmp	 BYTE PTR [rax], 113	; 00000071H
  00eda	0f 84 64 11 00
	00		 je	 $PRED_JUMP_ABSOLUTE$64568

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  00ee0	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  00ee4	e9 e3 21 00 00	 jmp	 $LN1025@PyEval_Eva
$LN448@PyEval_Eva:

; 1676 :                 DISPATCH();
; 1677 :             }
; 1678 :             break;
; 1679 : 
; 1680 :         TARGET(INPLACE_POWER)
; 1681 :             w = POP();

  00ee9	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1682 :             v = TOP();

  00eee	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00ef3	49 83 ec 08	 sub	 r12, 8

; 1683 :             x = PyNumber_InPlacePower(v, w, Py_None);

  00ef7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00efe	48 8b d7	 mov	 rdx, rdi
  00f01	48 8b cb	 mov	 rcx, rbx
  00f04	e8 00 00 00 00	 call	 PyNumber_InPlacePower

; 1684 :             Py_DECREF(v);
; 1685 :             Py_DECREF(w);
; 1686 :             SET_TOP(x);
; 1687 :             if (x != NULL) DISPATCH();
; 1688 :             break;

  00f09	e9 6d fd ff ff	 jmp	 $LN1079@PyEval_Eva
$LN446@PyEval_Eva:

; 1689 : 
; 1690 :         TARGET(INPLACE_MULTIPLY)
; 1691 :             w = POP();

  00f0e	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1692 :             v = TOP();

  00f13	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00f18	49 83 ec 08	 sub	 r12, 8

; 1693 :             x = PyNumber_InPlaceMultiply(v, w);

  00f1c	48 8b d7	 mov	 rdx, rdi
  00f1f	48 8b cb	 mov	 rcx, rbx
  00f22	e8 00 00 00 00	 call	 PyNumber_InPlaceMultiply

; 1694 :             Py_DECREF(v);
; 1695 :             Py_DECREF(w);
; 1696 :             SET_TOP(x);
; 1697 :             if (x != NULL) DISPATCH();
; 1698 :             break;

  00f27	e9 4f fd ff ff	 jmp	 $LN1079@PyEval_Eva
$LN444@PyEval_Eva:

; 1699 : 
; 1700 :         TARGET(INPLACE_TRUE_DIVIDE)
; 1701 :             w = POP();

  00f2c	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1702 :             v = TOP();

  00f31	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00f36	49 83 ec 08	 sub	 r12, 8

; 1703 :             x = PyNumber_InPlaceTrueDivide(v, w);

  00f3a	48 8b d7	 mov	 rdx, rdi
  00f3d	48 8b cb	 mov	 rcx, rbx
  00f40	e8 00 00 00 00	 call	 PyNumber_InPlaceTrueDivide

; 1704 :             Py_DECREF(v);
; 1705 :             Py_DECREF(w);
; 1706 :             SET_TOP(x);
; 1707 :             if (x != NULL) DISPATCH();
; 1708 :             break;

  00f45	e9 31 fd ff ff	 jmp	 $LN1079@PyEval_Eva
$LN442@PyEval_Eva:

; 1709 : 
; 1710 :         TARGET(INPLACE_FLOOR_DIVIDE)
; 1711 :             w = POP();

  00f4a	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1712 :             v = TOP();

  00f4f	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00f54	49 83 ec 08	 sub	 r12, 8

; 1713 :             x = PyNumber_InPlaceFloorDivide(v, w);

  00f58	48 8b d7	 mov	 rdx, rdi
  00f5b	48 8b cb	 mov	 rcx, rbx
  00f5e	e8 00 00 00 00	 call	 PyNumber_InPlaceFloorDivide

; 1714 :             Py_DECREF(v);
; 1715 :             Py_DECREF(w);
; 1716 :             SET_TOP(x);
; 1717 :             if (x != NULL) DISPATCH();
; 1718 :             break;

  00f63	e9 13 fd ff ff	 jmp	 $LN1079@PyEval_Eva
$LN440@PyEval_Eva:

; 1719 : 
; 1720 :         TARGET(INPLACE_MODULO)
; 1721 :             w = POP();

  00f68	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1722 :             v = TOP();

  00f6d	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00f72	49 83 ec 08	 sub	 r12, 8

; 1723 :             x = PyNumber_InPlaceRemainder(v, w);

  00f76	48 8b d7	 mov	 rdx, rdi
  00f79	48 8b cb	 mov	 rcx, rbx
  00f7c	e8 00 00 00 00	 call	 PyNumber_InPlaceRemainder

; 1724 :             Py_DECREF(v);
; 1725 :             Py_DECREF(w);
; 1726 :             SET_TOP(x);
; 1727 :             if (x != NULL) DISPATCH();
; 1728 :             break;

  00f81	e9 f5 fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN438@PyEval_Eva:

; 1729 : 
; 1730 :         TARGET(INPLACE_ADD)
; 1731 :             w = POP();
; 1732 :             v = TOP();

  00f86	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]
  00f8b	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  00f90	49 83 ec 08	 sub	 r12, 8

; 1733 :             if (PyUnicode_CheckExact(v) &&
; 1734 :                      PyUnicode_CheckExact(w)) {

  00f94	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  00f9b	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00f9f	75 0a		 jne	 SHORT $LN437@PyEval_Eva
  00fa1	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax

; 1735 :                 x = unicode_concatenate(v, w, f, next_instr);
; 1736 :                 /* unicode_concatenate consumed the ref to v */
; 1737 :                 goto skip_decref_v;

  00fa5	0f 84 c2 fd ff
	ff		 je	 $LN1088@PyEval_Eva
$LN437@PyEval_Eva:

; 1738 :             }
; 1739 :             else {
; 1740 :                 x = PyNumber_InPlaceAdd(v, w);

  00fab	48 8b d3	 mov	 rdx, rbx
  00fae	48 8b cf	 mov	 rcx, rdi
  00fb1	e8 00 00 00 00	 call	 PyNumber_InPlaceAdd

; 1741 :             }
; 1742 :             Py_DECREF(v);

  00fb6	48 8b cf	 mov	 rcx, rdi
  00fb9	4c 8b f8	 mov	 r15, rax
  00fbc	e8 00 00 00 00	 call	 _Py_DecRef

; 1743 :           skip_decref_v:
; 1744 :             Py_DECREF(w);

  00fc1	48 8b cb	 mov	 rcx, rbx

; 1745 :             SET_TOP(x);
; 1746 :             if (x != NULL) DISPATCH();
; 1747 :             break;

  00fc4	e9 c0 fc ff ff	 jmp	 $LN1080@PyEval_Eva
$LN434@PyEval_Eva:

; 1748 : 
; 1749 :         TARGET(INPLACE_SUBTRACT)
; 1750 :             w = POP();

  00fc9	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1751 :             v = TOP();

  00fce	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00fd3	49 83 ec 08	 sub	 r12, 8

; 1752 :             x = PyNumber_InPlaceSubtract(v, w);

  00fd7	48 8b d7	 mov	 rdx, rdi
  00fda	48 8b cb	 mov	 rcx, rbx
  00fdd	e8 00 00 00 00	 call	 PyNumber_InPlaceSubtract

; 1753 :             Py_DECREF(v);
; 1754 :             Py_DECREF(w);
; 1755 :             SET_TOP(x);
; 1756 :             if (x != NULL) DISPATCH();
; 1757 :             break;

  00fe2	e9 94 fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN432@PyEval_Eva:

; 1758 : 
; 1759 :         TARGET(INPLACE_LSHIFT)
; 1760 :             w = POP();

  00fe7	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1761 :             v = TOP();

  00fec	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  00ff1	49 83 ec 08	 sub	 r12, 8

; 1762 :             x = PyNumber_InPlaceLshift(v, w);

  00ff5	48 8b d7	 mov	 rdx, rdi
  00ff8	48 8b cb	 mov	 rcx, rbx
  00ffb	e8 00 00 00 00	 call	 PyNumber_InPlaceLshift

; 1763 :             Py_DECREF(v);
; 1764 :             Py_DECREF(w);
; 1765 :             SET_TOP(x);
; 1766 :             if (x != NULL) DISPATCH();
; 1767 :             break;

  01000	e9 76 fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN430@PyEval_Eva:

; 1768 : 
; 1769 :         TARGET(INPLACE_RSHIFT)
; 1770 :             w = POP();

  01005	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1771 :             v = TOP();

  0100a	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  0100f	49 83 ec 08	 sub	 r12, 8

; 1772 :             x = PyNumber_InPlaceRshift(v, w);

  01013	48 8b d7	 mov	 rdx, rdi
  01016	48 8b cb	 mov	 rcx, rbx
  01019	e8 00 00 00 00	 call	 PyNumber_InPlaceRshift

; 1773 :             Py_DECREF(v);
; 1774 :             Py_DECREF(w);
; 1775 :             SET_TOP(x);
; 1776 :             if (x != NULL) DISPATCH();
; 1777 :             break;

  0101e	e9 58 fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN428@PyEval_Eva:

; 1778 : 
; 1779 :         TARGET(INPLACE_AND)
; 1780 :             w = POP();

  01023	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1781 :             v = TOP();

  01028	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  0102d	49 83 ec 08	 sub	 r12, 8

; 1782 :             x = PyNumber_InPlaceAnd(v, w);

  01031	48 8b d7	 mov	 rdx, rdi
  01034	48 8b cb	 mov	 rcx, rbx
  01037	e8 00 00 00 00	 call	 PyNumber_InPlaceAnd

; 1783 :             Py_DECREF(v);
; 1784 :             Py_DECREF(w);
; 1785 :             SET_TOP(x);
; 1786 :             if (x != NULL) DISPATCH();
; 1787 :             break;

  0103c	e9 3a fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN426@PyEval_Eva:

; 1788 : 
; 1789 :         TARGET(INPLACE_XOR)
; 1790 :             w = POP();

  01041	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1791 :             v = TOP();

  01046	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  0104b	49 83 ec 08	 sub	 r12, 8

; 1792 :             x = PyNumber_InPlaceXor(v, w);

  0104f	48 8b d7	 mov	 rdx, rdi
  01052	48 8b cb	 mov	 rcx, rbx
  01055	e8 00 00 00 00	 call	 PyNumber_InPlaceXor

; 1793 :             Py_DECREF(v);
; 1794 :             Py_DECREF(w);
; 1795 :             SET_TOP(x);
; 1796 :             if (x != NULL) DISPATCH();
; 1797 :             break;

  0105a	e9 1c fc ff ff	 jmp	 $LN1079@PyEval_Eva
$LN424@PyEval_Eva:

; 1798 : 
; 1799 :         TARGET(INPLACE_OR)
; 1800 :             w = POP();

  0105f	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1801 :             v = TOP();

  01064	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  01069	49 83 ec 08	 sub	 r12, 8

; 1802 :             x = PyNumber_InPlaceOr(v, w);

  0106d	48 8b d7	 mov	 rdx, rdi
  01070	48 8b cb	 mov	 rcx, rbx
  01073	e8 00 00 00 00	 call	 PyNumber_InPlaceOr

; 1803 :             Py_DECREF(v);
; 1804 :             Py_DECREF(w);
; 1805 :             SET_TOP(x);
; 1806 :             if (x != NULL) DISPATCH();
; 1807 :             break;

  01078	e9 fe fb ff ff	 jmp	 $LN1079@PyEval_Eva
$LN422@PyEval_Eva:

; 1808 : 
; 1809 :         TARGET(STORE_SUBSCR)
; 1810 :             w = TOP();

  0107d	49 8b 74 24 f8	 mov	 rsi, QWORD PTR [r12-8]

; 1811 :             v = SECOND();

  01082	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]

; 1812 :             u = THIRD();

  01087	49 8b 5c 24 e8	 mov	 rbx, QWORD PTR [r12-24]
  0108c	49 83 c4 e8	 add	 r12, -24

; 1813 :             STACKADJ(-3);
; 1814 :             /* v[w] = u */
; 1815 :             err = PyObject_SetItem(v, w, u);

  01090	4c 8b c3	 mov	 r8, rbx
  01093	48 8b d6	 mov	 rdx, rsi
  01096	48 8b cf	 mov	 rcx, rdi
  01099	e8 00 00 00 00	 call	 PyObject_SetItem

; 1816 :             Py_DECREF(u);

  0109e	48 8b cb	 mov	 rcx, rbx
  010a1	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  010a4	e8 00 00 00 00	 call	 _Py_DecRef

; 1817 :             Py_DECREF(v);

  010a9	48 8b cf	 mov	 rcx, rdi
  010ac	e8 00 00 00 00	 call	 _Py_DecRef

; 1818 :             Py_DECREF(w);

  010b1	48 8b ce	 mov	 rcx, rsi
$LN1082@PyEval_Eva:
  010b4	e8 00 00 00 00	 call	 _Py_DecRef

; 1819 :             if (err == 0) DISPATCH();

  010b9	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
$LN1083@PyEval_Eva:
  010bc	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  010c0	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  010c4	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  010c8	be 00 00 00 00	 mov	 esi, 0
  010cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  010d4	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  010db	85 ff		 test	 edi, edi
  010dd	0f 84 16 f1 ff
	ff		 je	 $LN937@PyEval_Eva

; 1820 :             break;

  010e3	e9 28 11 00 00	 jmp	 $LN1052@PyEval_Eva
$LN420@PyEval_Eva:

; 1821 : 
; 1822 :         TARGET(DELETE_SUBSCR)
; 1823 :             w = TOP();

  010e8	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 1824 :             v = SECOND();

  010ed	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  010f2	49 83 c4 f0	 add	 r12, -16

; 1825 :             STACKADJ(-2);
; 1826 :             /* del v[w] */
; 1827 :             err = PyObject_DelItem(v, w);

  010f6	48 8b cb	 mov	 rcx, rbx
  010f9	48 8b d7	 mov	 rdx, rdi
  010fc	e8 00 00 00 00	 call	 PyObject_DelItem

; 1828 :             Py_DECREF(v);

  01101	48 8b cb	 mov	 rcx, rbx
  01104	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  01107	e8 00 00 00 00	 call	 _Py_DecRef

; 1829 :             Py_DECREF(w);

  0110c	48 8b cf	 mov	 rcx, rdi

; 1830 :             if (err == 0) DISPATCH();
; 1831 :             break;

  0110f	eb a3		 jmp	 SHORT $LN1082@PyEval_Eva
$LN418@PyEval_Eva:

; 1832 : 
; 1833 :         TARGET(PRINT_EXPR)
; 1834 :             v = POP();

  01111	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]
  01116	49 83 ec 08	 sub	 r12, 8

; 1835 :             w = PySys_GetObject("displayhook");

  0111a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@OABHHABA@displayhook?$AA@
  01121	e8 00 00 00 00	 call	 PySys_GetObject
  01126	48 8b d8	 mov	 rbx, rax

; 1836 :             if (w == NULL) {

  01129	48 85 c0	 test	 rax, rax
  0112c	0f 85 a3 00 00
	00		 jne	 $LN417@PyEval_Eva

; 1837 :                 PyErr_SetString(PyExc_RuntimeError,
; 1838 :                                 "lost sys.displayhook");

  01132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  01139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@
  01140	e8 00 00 00 00	 call	 PyErr_SetString

; 1839 :                 err = -1;
; 1840 :                 x = NULL;

  01145	45 33 ff	 xor	 r15d, r15d
$LN853@PyEval_Eva:

; 1851 :                     err = -1;

  01148	c7 45 7f ff ff
	ff ff		 mov	 DWORD PTR err$1$[rbp-153], -1
$LN409@PyEval_Eva:

; 1852 :             }
; 1853 :             Py_DECREF(v);

  0114f	48 8b cf	 mov	 rcx, rdi
  01152	e8 00 00 00 00	 call	 _Py_DecRef

; 1854 :             Py_XDECREF(x);

  01157	4d 85 ff	 test	 r15, r15
  0115a	0f 84 9f fa ff
	ff		 je	 $LN977@PyEval_Eva
  01160	e8 00 00 00 00	 call	 _Py_PXCTX
  01165	85 c0		 test	 eax, eax
  01167	0f 85 92 fa ff
	ff		 jne	 $LN977@PyEval_Eva
  0116d	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  01171	a8 20		 test	 al, 32			; 00000020H
  01173	0f 85 c1 00 00
	00		 jne	 $LN605@PyEval_Eva
  01179	84 c0		 test	 al, al
  0117b	0f 88 b9 00 00
	00		 js	 $LN605@PyEval_Eva
  01181	a8 02		 test	 al, 2
  01183	0f 85 76 fa ff
	ff		 jne	 $LN977@PyEval_Eva
  01189	49 ff 4f 50	 dec	 QWORD PTR [r15+80]
  0118d	0f 85 6c fa ff
	ff		 jne	 $LN977@PyEval_Eva
  01193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0119a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  011a1	4d 8b cf	 mov	 r9, r15
  011a4	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  011aa	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  011b2	e8 00 00 00 00	 call	 _PyParallel_Guard
  011b7	49 8b cf	 mov	 rcx, r15
  011ba	85 c0		 test	 eax, eax
  011bc	74 60		 je	 SHORT $LN610@PyEval_Eva
  011be	e8 00 00 00 00	 call	 _Px_Dealloc
  011c3	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  011c6	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  011ca	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  011ce	33 f6		 xor	 esi, esi
  011d0	e9 3b 10 00 00	 jmp	 $LN1052@PyEval_Eva
$LN417@PyEval_Eva:

; 1841 :             }
; 1842 :             if (err == 0) {

  011d5	44 8b 6d 7f	 mov	 r13d, DWORD PTR err$1$[rbp-153]
  011d9	45 85 ed	 test	 r13d, r13d
  011dc	0f 85 6d ff ff
	ff		 jne	 $LN409@PyEval_Eva

; 1843 :                 x = PyTuple_Pack(1, v);

  011e2	41 8d 4d 01	 lea	 ecx, QWORD PTR [r13+1]
  011e6	48 8b d7	 mov	 rdx, rdi
  011e9	e8 00 00 00 00	 call	 PyTuple_Pack
  011ee	4c 8b f8	 mov	 r15, rax

; 1844 :                 if (x == NULL)

  011f1	48 85 c0	 test	 rax, rax

; 1845 :                     err = -1;
; 1846 :             }
; 1847 :             if (err == 0) {

  011f4	0f 84 4e ff ff
	ff		 je	 $LN853@PyEval_Eva

; 1848 :                 w = PyEval_CallObject(w, x);

  011fa	45 33 c0	 xor	 r8d, r8d
  011fd	48 8b d0	 mov	 rdx, rax
  01200	48 8b cb	 mov	 rcx, rbx
  01203	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 1849 :                 Py_XDECREF(w);

  01208	48 85 c0	 test	 rax, rax
  0120b	0f 84 37 ff ff
	ff		 je	 $LN853@PyEval_Eva
  01211	48 8b c8	 mov	 rcx, rax
  01214	e8 00 00 00 00	 call	 _Py_DecRef

; 1850 :                 if (w == NULL)

  01219	e9 31 ff ff ff	 jmp	 $LN409@PyEval_Eva

; 1854 :             Py_XDECREF(x);

$LN610@PyEval_Eva:
  0121e	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  01222	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  01228	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  0122b	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0122f	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01233	33 f6		 xor	 esi, esi
  01235	e9 d6 0f 00 00	 jmp	 $LN1052@PyEval_Eva
$LN605@PyEval_Eva:
  0123a	49 8b cf	 mov	 rcx, r15
  0123d	e8 00 00 00 00	 call	 Px_DecRef

; 1855 :             break;

  01242	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  01245	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01249	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0124d	33 f6		 xor	 esi, esi
  0124f	e9 bc 0f 00 00	 jmp	 $LN1052@PyEval_Eva
$LN404@PyEval_Eva:

; 1856 : 
; 1857 : #ifdef CASE_TOO_BIG
; 1858 :         default: switch (opcode) {
; 1859 : #endif
; 1860 :         TARGET(RAISE_VARARGS)
; 1861 :             v = w = NULL;

  01254	33 c0		 xor	 eax, eax
  01256	8b c8		 mov	 ecx, eax
  01258	8b d0		 mov	 edx, eax

; 1862 :             switch (oparg) {

  0125a	85 f6		 test	 esi, esi
  0125c	74 3c		 je	 SHORT $LN399@PyEval_Eva
  0125e	ff ce		 dec	 esi
  01260	74 2f		 je	 SHORT $LN400@PyEval_Eva
  01262	ff ce		 dec	 esi
  01264	74 22		 je	 SHORT $LN401@PyEval_Eva

; 1869 :                 break;
; 1870 :             default:
; 1871 :                 PyErr_SetString(PyExc_SystemError,
; 1872 :                            "bad RAISE_VARARGS oparg");

  01266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@
$LN1056@PyEval_Eva:
  0126d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  01274	e8 00 00 00 00	 call	 PyErr_SetString

; 1873 :                 why = WHY_EXCEPTION;

  01279	bb 02 00 00 00	 mov	 ebx, 2
  0127e	8b fb		 mov	 edi, ebx
  01280	89 5d 77	 mov	 DWORD PTR why$1$[rbp-153], ebx

; 1874 :                 break;

  01283	e9 cb 0f 00 00	 jmp	 $LN80@PyEval_Eva
$LN401@PyEval_Eva:

; 1863 :             case 2:
; 1864 :                 v = POP(); /* cause */

  01288	49 8b 54 24 f8	 mov	 rdx, QWORD PTR [r12-8]
  0128d	49 83 ec 08	 sub	 r12, 8
$LN400@PyEval_Eva:

; 1865 :             case 1:
; 1866 :                 w = POP(); /* exc */

  01291	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  01296	49 83 ec 08	 sub	 r12, 8
$LN399@PyEval_Eva:

; 1867 :             case 0: /* Fallthrough */
; 1868 :                 why = do_raise(w, v);

  0129a	e8 00 00 00 00	 call	 do_raise
  0129f	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  012a3	33 f6		 xor	 esi, esi
  012a5	89 45 77	 mov	 DWORD PTR why$1$[rbp-153], eax
  012a8	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  012ac	e9 5f 0f 00 00	 jmp	 $LN1052@PyEval_Eva
$LN397@PyEval_Eva:

; 1875 :             }
; 1876 :             break;
; 1877 : 
; 1878 :         TARGET(STORE_LOCALS)
; 1879 :             x = POP();
; 1880 :             v = f->f_locals;

  012b1	49 8b 9e 90 00
	00 00		 mov	 rbx, QWORD PTR [r14+144]
  012b8	4d 8b 7c 24 f8	 mov	 r15, QWORD PTR [r12-8]
  012bd	49 83 ec 08	 sub	 r12, 8

; 1881 :             Py_XDECREF(v);

  012c1	48 85 db	 test	 rbx, rbx
  012c4	74 73		 je	 SHORT $LN395@PyEval_Eva
  012c6	e8 00 00 00 00	 call	 _Py_PXCTX
  012cb	85 c0		 test	 eax, eax
  012cd	75 5c		 jne	 SHORT $LN1016@PyEval_Eva
  012cf	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  012d3	a8 20		 test	 al, 32			; 00000020H
  012d5	75 4c		 jne	 SHORT $LN616@PyEval_Eva
  012d7	84 c0		 test	 al, al
  012d9	78 48		 js	 SHORT $LN616@PyEval_Eva
  012db	a8 02		 test	 al, 2
  012dd	75 4c		 jne	 SHORT $LN1016@PyEval_Eva
  012df	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  012e3	75 46		 jne	 SHORT $LN1016@PyEval_Eva
  012e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  012ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  012f3	4c 8b cb	 mov	 r9, rbx
  012f6	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  012fc	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  01304	e8 00 00 00 00	 call	 _PyParallel_Guard
  01309	48 8b cb	 mov	 rcx, rbx
  0130c	85 c0		 test	 eax, eax
  0130e	74 07		 je	 SHORT $LN621@PyEval_Eva
  01310	e8 00 00 00 00	 call	 _Px_Dealloc
  01315	eb 14		 jmp	 SHORT $LN1016@PyEval_Eva
$LN621@PyEval_Eva:
  01317	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0131b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  01321	eb 08		 jmp	 SHORT $LN1016@PyEval_Eva
$LN616@PyEval_Eva:
  01323	48 8b cb	 mov	 rcx, rbx
  01326	e8 00 00 00 00	 call	 Px_DecRef
$LN1016@PyEval_Eva:

; 1241 :         }
; 1242 :         else

  0132b	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  01332	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
$LN395@PyEval_Eva:

; 1882 :             f->f_locals = x;
; 1883 :             DISPATCH();

  01339	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0133d	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01341	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  01345	4d 89 be 90 00
	00 00		 mov	 QWORD PTR [r14+144], r15
  0134c	33 f6		 xor	 esi, esi
  0134e	e9 a6 ee ff ff	 jmp	 $LN937@PyEval_Eva
$LN392@PyEval_Eva:

; 1884 : 
; 1885 :         TARGET(RETURN_VALUE)
; 1886 :             retval = POP();

  01353	49 8b 54 24 f8	 mov	 rdx, QWORD PTR [r12-8]
  01358	49 83 ec 08	 sub	 r12, 8

; 1887 :             why = WHY_RETURN;

  0135c	bf 08 00 00 00	 mov	 edi, 8
  01361	48 89 55 bf	 mov	 QWORD PTR retval$1$[rbp-153], rdx

; 1888 :             goto fast_block_end;

  01365	e9 5d 1a 00 00	 jmp	 $LN1042@PyEval_Eva
$LN391@PyEval_Eva:

; 1889 : 
; 1890 :         TARGET(YIELD_FROM)
; 1891 :             u = POP();

  0136a	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  0136f	49 83 ec 08	 sub	 r12, 8

; 1892 :             x = TOP();
; 1893 :             /* send u to x */
; 1894 :             if (PyGen_CheckExact(x)) {

  01373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyGen_Type
  0137a	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  0137f	49 8d 7c 24 f8	 lea	 rdi, QWORD PTR [r12-8]
  01384	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  01388	48 3b c2	 cmp	 rax, rdx
  0138b	75 0a		 jne	 SHORT $LN390@PyEval_Eva

; 1895 :                 retval = _PyGen_Send((PyGenObject *)x, u);

  0138d	48 8b d3	 mov	 rdx, rbx
  01390	e8 00 00 00 00	 call	 _PyGen_Send

; 1896 :             } else {

  01395	eb 3c		 jmp	 SHORT $LN1043@PyEval_Eva
$LN390@PyEval_Eva:

; 1897 :                 _Py_IDENTIFIER(send);
; 1898 :                 if (u == Py_None)

  01397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0139e	48 3b da	 cmp	 rbx, rdx
  013a1	75 08		 jne	 SHORT $LN388@PyEval_Eva

; 1899 :                     retval = Py_TYPE(x)->tp_iternext(x);

  013a3	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 1900 :                 else

  013a9	eb 28		 jmp	 SHORT $LN1043@PyEval_Eva
$LN388@PyEval_Eva:

; 1901 :                     retval = _PyObject_CallMethodId(x, &PyId_send, "O", u);

  013ab	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  013b2	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  013bb	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_send@?CL@??PyEval_EvalFrameEx@@9@9
  013c0	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  013c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  013cb	4c 8b cb	 mov	 r9, rbx
  013ce	e8 00 00 00 00	 call	 _PyObject_CallMethodId
$LN1043@PyEval_Eva:

; 1902 :             }
; 1903 :             Py_DECREF(u);

  013d3	48 8b cb	 mov	 rcx, rbx
  013d6	48 8b f0	 mov	 rsi, rax
  013d9	48 89 45 bf	 mov	 QWORD PTR retval$1$[rbp-153], rax
  013dd	e8 00 00 00 00	 call	 _Py_DecRef

; 1904 :             if (!retval) {

  013e2	48 85 f6	 test	 rsi, rsi
  013e5	0f 85 07 1d 00
	00		 jne	 $LN386@PyEval_Eva

; 1905 :                 PyObject *val;
; 1906 :                 x = POP(); /* Remove iter from stack */
; 1907 :                 Py_DECREF(x);

  013eb	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  013ee	4c 8b e7	 mov	 r12, rdi
  013f1	e8 00 00 00 00	 call	 _Py_DecRef

; 1908 :                 err = _PyGen_FetchStopIterationValue(&val);

  013f6	48 8d 4d 17	 lea	 rcx, QWORD PTR val$64705[rbp-153]
  013fa	e8 00 00 00 00	 call	 _PyGen_FetchStopIterationValue

; 1911 :                     break;

  013ff	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01403	8b f8		 mov	 edi, eax
  01405	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  01408	85 c0		 test	 eax, eax
  0140a	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0140e	79 08		 jns	 SHORT $LN385@PyEval_Eva

; 1909 :                 if (err < 0) {
; 1910 :                     x = NULL;

  01410	4c 8b fe	 mov	 r15, rsi

; 1911 :                     break;

  01413	e9 f8 0d 00 00	 jmp	 $LN1052@PyEval_Eva
$LN385@PyEval_Eva:

; 1912 :                 }
; 1913 :                 x = val;

  01418	4c 8b 7d 17	 mov	 r15, QWORD PTR val$64705[rbp-153]

; 1914 :                 PUSH(x);

  0141c	49 83 c4 08	 add	 r12, 8
  01420	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15

; 1915 :                 continue;

  01425	e9 a2 1c 00 00	 jmp	 $LN1025@PyEval_Eva
$LN383@PyEval_Eva:

; 1929 : 
; 1930 :         TARGET(POP_EXCEPT)
; 1931 :             {
; 1932 :                 PyTryBlock *b = PyFrame_BlockPop(f);

  0142a	49 8b ce	 mov	 rcx, r14
  0142d	e8 00 00 00 00	 call	 PyFrame_BlockPop
  01432	48 8b f8	 mov	 rdi, rax

; 1933 :                 if (b->b_type != EXCEPT_HANDLER) {

  01435	81 38 01 01 00
	00		 cmp	 DWORD PTR [rax], 257	; 00000101H
  0143b	74 0c		 je	 SHORT $LN796@PyEval_Eva

; 1934 :                     PyErr_SetString(PyExc_SystemError,
; 1935 :                         "popped block is not an except handler");

  0143d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@

; 1936 :                     why = WHY_EXCEPTION;
; 1937 :                     break;

  01444	e9 24 fe ff ff	 jmp	 $LN1056@PyEval_Eva
$LN796@PyEval_Eva:

; 1938 :                 }
; 1939 :                 UNWIND_EXCEPT_HANDLER(b);

  01449	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0144c	49 8b cc	 mov	 rcx, r12
  0144f	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  01456	83 c0 03	 add	 eax, 3
  01459	48 c1 f9 03	 sar	 rcx, 3
  0145d	3b c8		 cmp	 ecx, eax
  0145f	0f 8e 9a 00 00
	00		 jle	 $LN380@PyEval_Eva
  01465	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL381@PyEval_Eva:
  01470	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  01475	49 83 ec 08	 sub	 r12, 8
  01479	48 85 db	 test	 rbx, rbx
  0147c	74 65		 je	 SHORT $LN378@PyEval_Eva
  0147e	e8 00 00 00 00	 call	 _Py_PXCTX
  01483	85 c0		 test	 eax, eax
  01485	75 5c		 jne	 SHORT $LN378@PyEval_Eva
  01487	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0148b	a8 20		 test	 al, 32			; 00000020H
  0148d	75 4c		 jne	 SHORT $LN627@PyEval_Eva
  0148f	84 c0		 test	 al, al
  01491	78 48		 js	 SHORT $LN627@PyEval_Eva
  01493	a8 02		 test	 al, 2
  01495	75 4c		 jne	 SHORT $LN378@PyEval_Eva
  01497	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0149b	75 46		 jne	 SHORT $LN378@PyEval_Eva
  0149d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  014a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  014ab	4c 8b cb	 mov	 r9, rbx
  014ae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  014b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  014bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  014c1	48 8b cb	 mov	 rcx, rbx
  014c4	85 c0		 test	 eax, eax
  014c6	74 07		 je	 SHORT $LN632@PyEval_Eva
  014c8	e8 00 00 00 00	 call	 _Px_Dealloc
  014cd	eb 14		 jmp	 SHORT $LN378@PyEval_Eva
$LN632@PyEval_Eva:
  014cf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  014d3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  014d9	eb 08		 jmp	 SHORT $LN378@PyEval_Eva
$LN627@PyEval_Eva:
  014db	48 8b cb	 mov	 rcx, rbx
  014de	e8 00 00 00 00	 call	 Px_DecRef
$LN378@PyEval_Eva:
  014e3	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  014e6	49 8b cc	 mov	 rcx, r12
  014e9	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  014f0	83 c0 03	 add	 eax, 3
  014f3	48 c1 f9 03	 sar	 rcx, 3
  014f7	3b c8		 cmp	 ecx, eax
  014f9	0f 8f 71 ff ff
	ff		 jg	 $LL381@PyEval_Eva
$LN380@PyEval_Eva:
  014ff	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01503	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  01508	49 83 ec 18	 sub	 r12, 24
  0150c	49 8b 4d 60	 mov	 rcx, QWORD PTR [r13+96]
  01510	49 8b 5d 68	 mov	 rbx, QWORD PTR [r13+104]
  01514	49 8b 7d 70	 mov	 rdi, QWORD PTR [r13+112]
  01518	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  0151c	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  01521	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  01525	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  01529	49 89 45 70	 mov	 QWORD PTR [r13+112], rax
  0152d	48 85 c9	 test	 rcx, rcx
  01530	74 05		 je	 SHORT $LN374@PyEval_Eva
  01532	e8 00 00 00 00	 call	 _Py_DecRef
$LN374@PyEval_Eva:
  01537	48 85 db	 test	 rbx, rbx
  0153a	74 08		 je	 SHORT $LN370@PyEval_Eva
  0153c	48 8b cb	 mov	 rcx, rbx
  0153f	e8 00 00 00 00	 call	 _Py_DecRef
$LN370@PyEval_Eva:
  01544	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01548	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  0154c	be 00 00 00 00	 mov	 esi, 0
  01551	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  01558	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  0155f	48 85 ff	 test	 rdi, rdi
  01562	0f 84 8e ec ff
	ff		 je	 $LN1010@PyEval_Eva
  01568	48 8b cf	 mov	 rcx, rdi
  0156b	e8 00 00 00 00	 call	 _Py_DecRef

; 1940 :             }
; 1941 :             DISPATCH();

  01570	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01574	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  01577	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  0157b	e9 52 1b 00 00	 jmp	 $LN1035@PyEval_Eva
$LN363@PyEval_Eva:

; 1942 : 
; 1943 :         TARGET(POP_BLOCK)
; 1944 :             {
; 1945 :                 PyTryBlock *b = PyFrame_BlockPop(f);

  01580	49 8b ce	 mov	 rcx, r14
  01583	e8 00 00 00 00	 call	 PyFrame_BlockPop

; 1946 :                 UNWIND_BLOCK(b);

  01588	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0158c	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  01590	49 8b cc	 mov	 rcx, r12
  01593	48 8b f8	 mov	 rdi, rax
  01596	be 00 00 00 00	 mov	 esi, 0
  0159b	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  015a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  015a9	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  015b0	48 c1 f9 03	 sar	 rcx, 3
  015b4	3b 48 08	 cmp	 ecx, DWORD PTR [rax+8]
  015b7	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  015bb	0f 8e 35 ec ff
	ff		 jle	 $LN1010@PyEval_Eva
$LL362@PyEval_Eva:
  015c1	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  015c6	49 83 ec 08	 sub	 r12, 8
  015ca	48 85 db	 test	 rbx, rbx
  015cd	74 65		 je	 SHORT $LN359@PyEval_Eva
  015cf	e8 00 00 00 00	 call	 _Py_PXCTX
  015d4	85 c0		 test	 eax, eax
  015d6	75 5c		 jne	 SHORT $LN359@PyEval_Eva
  015d8	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  015dc	a8 20		 test	 al, 32			; 00000020H
  015de	75 4c		 jne	 SHORT $LN638@PyEval_Eva
  015e0	84 c0		 test	 al, al
  015e2	78 48		 js	 SHORT $LN638@PyEval_Eva
  015e4	a8 02		 test	 al, 2
  015e6	75 4c		 jne	 SHORT $LN359@PyEval_Eva
  015e8	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  015ec	75 46		 jne	 SHORT $LN359@PyEval_Eva
  015ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  015f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  015fc	4c 8b cb	 mov	 r9, rbx
  015ff	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  01605	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0160d	e8 00 00 00 00	 call	 _PyParallel_Guard
  01612	48 8b cb	 mov	 rcx, rbx
  01615	85 c0		 test	 eax, eax
  01617	74 07		 je	 SHORT $LN643@PyEval_Eva
  01619	e8 00 00 00 00	 call	 _Px_Dealloc
  0161e	eb 14		 jmp	 SHORT $LN359@PyEval_Eva
$LN643@PyEval_Eva:
  01620	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  01624	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0162a	eb 08		 jmp	 SHORT $LN359@PyEval_Eva
$LN638@PyEval_Eva:
  0162c	48 8b cb	 mov	 rcx, rbx
  0162f	e8 00 00 00 00	 call	 Px_DecRef
$LN359@PyEval_Eva:
  01634	49 8b c4	 mov	 rax, r12
  01637	49 2b 86 98 00
	00 00		 sub	 rax, QWORD PTR [r14+152]
  0163e	48 c1 f8 03	 sar	 rax, 3
  01642	3b 47 08	 cmp	 eax, DWORD PTR [rdi+8]
  01645	0f 8f 76 ff ff
	ff		 jg	 $LL362@PyEval_Eva

; 1947 :             }
; 1948 :             DISPATCH();

  0164b	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0164f	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  01652	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  01656	e9 77 1a 00 00	 jmp	 $LN1035@PyEval_Eva
$LN329@PyEval_Eva:

; 1983 :             break;
; 1984 : 
; 1985 :         TARGET(LOAD_BUILD_CLASS)
; 1986 :         {
; 1987 :             _Py_IDENTIFIER(__build_class__);
; 1988 : 
; 1989 :             if (PyDict_CheckExact(f->f_builtins)) {

  0165b	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  01662	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:PyDict_Type
  01669	4c 39 59 58	 cmp	 QWORD PTR [rcx+88], r11
  0166d	74 7d		 je	 SHORT $LN327@PyEval_Eva
  0166f	4c 39 59 38	 cmp	 QWORD PTR [rcx+56], r11
  01673	74 77		 je	 SHORT $LN327@PyEval_Eva

; 1997 :             }
; 1998 :             else {
; 1999 :                 PyObject *build_class_str = _PyUnicode_FromId(&PyId___build_class__);

  01675	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  0167b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  01684	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PyId___build_class__@?ED@??PyEval_EvalFrameEx@@9@9
  01689	48 03 0c d0	 add	 rcx, QWORD PTR [rax+rdx*8]
  0168d	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 2000 :                 if (build_class_str == NULL)

  01692	48 85 c0	 test	 rax, rax
  01695	0f 84 ee f2 ff
	ff		 je	 $LN1053@PyEval_Eva

; 2001 :                     break;
; 2002 :                 x = PyObject_GetItem(f->f_builtins, build_class_str);

  0169b	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  016a2	48 8b d0	 mov	 rdx, rax
  016a5	e8 00 00 00 00	 call	 PyObject_GetItem
  016aa	4c 8b f8	 mov	 r15, rax

; 2003 :                 if (x == NULL) {

  016ad	48 85 c0	 test	 rax, rax
  016b0	0f 85 99 00 00
	00		 jne	 $LN646@PyEval_Eva

; 2004 :                     if (PyErr_ExceptionMatches(PyExc_KeyError))

  016b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  016bd	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  016c2	85 c0		 test	 eax, eax
  016c4	0f 84 bf f2 ff
	ff		 je	 $LN1053@PyEval_Eva
$LN1070@PyEval_Eva:

; 2005 :                         PyErr_SetString(PyExc_NameError,
; 2006 :                                         "__build_class__ not found");

  016ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  016d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@
$LN1071@PyEval_Eva:
  016d8	e8 00 00 00 00	 call	 PyErr_SetString
  016dd	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  016e1	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  016e5	33 f6		 xor	 esi, esi
  016e7	e9 24 0b 00 00	 jmp	 $LN1052@PyEval_Eva
$LN327@PyEval_Eva:

; 1990 :                 x = _PyDict_GetItemId(f->f_builtins, &PyId___build_class__);

  016ec	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  016f3	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  016fc	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___build_class__@?ED@??PyEval_EvalFrameEx@@9@9
  01701	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  01705	e8 00 00 00 00	 call	 _PyDict_GetItemId
  0170a	4c 8b f8	 mov	 r15, rax

; 1991 :                 if (x == NULL) {

  0170d	48 85 c0	 test	 rax, rax

; 1992 :                     PyErr_SetString(PyExc_NameError,
; 1993 :                                     "__build_class__ not found");
; 1994 :                     break;

  01710	74 b8		 je	 SHORT $LN1070@PyEval_Eva

; 1995 :                 }
; 1996 :                 Py_INCREF(x);

  01712	e8 00 00 00 00	 call	 _Py_PXCTX
  01717	85 c0		 test	 eax, eax
  01719	75 34		 jne	 SHORT $LN646@PyEval_Eva
  0171b	b8 02 00 00 00	 mov	 eax, 2
  01720	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  01727	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0172e	4d 8b cf	 mov	 r9, r15
  01731	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  01737	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0173b	e8 00 00 00 00	 call	 _PyParallel_Guard
  01740	85 c0		 test	 eax, eax
  01742	75 07		 jne	 SHORT $LN645@PyEval_Eva
  01744	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  01749	74 04		 je	 SHORT $LN646@PyEval_Eva
$LN645@PyEval_Eva:
  0174b	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN646@PyEval_Eva:

; 1423 :             break;

  0174f	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01753	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]

; 2007 :                     break;
; 2008 :                 }
; 2009 :             }
; 2010 :             PUSH(x);

  01757	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  0175b	49 83 c4 08	 add	 r12, 8
  0175f	33 f6		 xor	 esi, esi
  01761	e9 aa 0a 00 00	 jmp	 $LN1052@PyEval_Eva
$LN321@PyEval_Eva:

; 2011 :             break;
; 2012 :         }
; 2013 : 
; 2014 :         TARGET(STORE_NAME)
; 2015 :             w = GETITEM(names, oparg);

  01766	4c 8b 4d b7	 mov	 r9, QWORD PTR names$1$[rbp-153]

; 2016 :             v = POP();
; 2017 :             if ((x = f->f_locals) != NULL) {

  0176a	4d 8b be 90 00
	00 00		 mov	 r15, QWORD PTR [r14+144]
  01771	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  01776	49 83 ec 08	 sub	 r12, 8
  0177a	48 63 c6	 movsxd	 rax, esi
  0177d	49 8b 4c c1 70	 mov	 rcx, QWORD PTR [r9+rax*8+112]
  01782	4d 85 ff	 test	 r15, r15
  01785	74 53		 je	 SHORT $LN320@PyEval_Eva

; 2018 :                 if (PyDict_CheckExact(x))

  01787	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:PyDict_Type
  0178e	4d 39 5f 58	 cmp	 QWORD PTR [r15+88], r11
  01792	74 26		 je	 SHORT $LN318@PyEval_Eva
  01794	4d 39 5f 38	 cmp	 QWORD PTR [r15+56], r11
  01798	74 20		 je	 SHORT $LN318@PyEval_Eva

; 2020 :                 else
; 2021 :                     err = PyObject_SetItem(x, w, v);

  0179a	48 8b d1	 mov	 rdx, rcx
  0179d	4c 8b c3	 mov	 r8, rbx
  017a0	49 8b cf	 mov	 rcx, r15
  017a3	e8 00 00 00 00	 call	 PyObject_SetItem

; 2022 :                 Py_DECREF(v);

  017a8	48 8b cb	 mov	 rcx, rbx
  017ab	8b f8		 mov	 edi, eax
  017ad	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  017b0	e8 00 00 00 00	 call	 _Py_DecRef

; 2023 :                 if (err == 0) DISPATCH();
; 2024 :                 break;

  017b5	e9 02 f9 ff ff	 jmp	 $LN1083@PyEval_Eva
$LN318@PyEval_Eva:

; 2019 :                     err = PyDict_SetItem(x, w, v);

  017ba	48 8b d1	 mov	 rdx, rcx
  017bd	4c 8b c3	 mov	 r8, rbx
  017c0	49 8b cf	 mov	 rcx, r15
  017c3	e8 00 00 00 00	 call	 PyDict_SetItem

; 2022 :                 Py_DECREF(v);

  017c8	48 8b cb	 mov	 rcx, rbx
  017cb	8b f8		 mov	 edi, eax
  017cd	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  017d0	e8 00 00 00 00	 call	 _Py_DecRef

; 2023 :                 if (err == 0) DISPATCH();
; 2024 :                 break;

  017d5	e9 e2 f8 ff ff	 jmp	 $LN1083@PyEval_Eva
$LN320@PyEval_Eva:

; 2025 :             }
; 2026 :             PyErr_Format(PyExc_SystemError,
; 2027 :                          "no locals found when storing %R", w);

  017da	4c 8b c1	 mov	 r8, rcx
  017dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  017e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@
  017eb	e8 00 00 00 00	 call	 PyErr_Format
  017f0	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  017f4	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  017f8	33 f6		 xor	 esi, esi
  017fa	e9 11 0a 00 00	 jmp	 $LN1052@PyEval_Eva
$LN315@PyEval_Eva:

; 2028 :             break;
; 2029 : 
; 2030 :         TARGET(DELETE_NAME)
; 2031 :             w = GETITEM(names, oparg);

  017ff	4c 8b 4d b7	 mov	 r9, QWORD PTR names$1$[rbp-153]

; 2032 :             if ((x = f->f_locals) != NULL) {

  01803	4d 8b be 90 00
	00 00		 mov	 r15, QWORD PTR [r14+144]
  0180a	48 63 c6	 movsxd	 rax, esi
  0180d	49 8b 5c c1 70	 mov	 rbx, QWORD PTR [r9+rax*8+112]
  01812	4d 85 ff	 test	 r15, r15
  01815	74 2e		 je	 SHORT $LN314@PyEval_Eva

; 2033 :                 if ((err = PyObject_DelItem(x, w)) != 0)

  01817	48 8b d3	 mov	 rdx, rbx
  0181a	49 8b cf	 mov	 rcx, r15
  0181d	e8 00 00 00 00	 call	 PyObject_DelItem
  01822	8b f8		 mov	 edi, eax
  01824	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
$LN1067@PyEval_Eva:
  01827	85 c0		 test	 eax, eax
  01829	0f 84 5a f1 ff
	ff		 je	 $LN1053@PyEval_Eva
$LN1068@PyEval_Eva:

; 2034 :                     format_exc_check_arg(PyExc_NameError,
; 2035 :                                          NAME_ERROR_MSG,
; 2036 :                                          w);

  0182f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01836	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@
  0183d	4c 8b c3	 mov	 r8, rbx

; 2037 :                 break;

  01840	e9 3f f1 ff ff	 jmp	 $LN1054@PyEval_Eva
$LN314@PyEval_Eva:

; 2038 :             }
; 2039 :             PyErr_Format(PyExc_SystemError,
; 2040 :                          "no locals when deleting %R", w);

  01845	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0184c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@
  01853	4c 8b c3	 mov	 r8, rbx
  01856	e8 00 00 00 00	 call	 PyErr_Format
  0185b	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0185f	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01863	33 f6		 xor	 esi, esi
  01865	e9 a6 09 00 00	 jmp	 $LN1052@PyEval_Eva
$LN301@PyEval_Eva:

; 2075 : 
; 2076 :         TARGET(UNPACK_EX)
; 2077 :         {
; 2078 :             int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);
; 2079 :             v = POP();

  0186a	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]
  0186f	40 0f b6 d6	 movzx	 edx, sil
  01873	c1 fe 08	 sar	 esi, 8
  01876	8d 44 16 01	 lea	 eax, DWORD PTR [rsi+rdx+1]
  0187a	49 83 ec 08	 sub	 r12, 8

; 2080 : 
; 2081 :             if (unpack_iterable(v, oparg & 0xFF, oparg >> 8,
; 2082 :                                 stack_pointer + totalargs)) {

  0187e	44 8b c6	 mov	 r8d, esi
  01881	48 98		 cdqe
  01883	48 8b cf	 mov	 rcx, rdi
  01886	49 8d 1c c4	 lea	 rbx, QWORD PTR [r12+rax*8]
  0188a	4c 8b cb	 mov	 r9, rbx
  0188d	e8 00 00 00 00	 call	 unpack_iterable
  01892	85 c0		 test	 eax, eax
  01894	74 05		 je	 SHORT $LN300@PyEval_Eva

; 2083 :                 stack_pointer += totalargs;

  01896	4c 8b e3	 mov	 r12, rbx

; 2084 :             } else {

  01899	eb 08		 jmp	 SHORT $LN299@PyEval_Eva
$LN300@PyEval_Eva:

; 2085 :                 why = WHY_EXCEPTION;

  0189b	b8 02 00 00 00	 mov	 eax, 2
  018a0	89 45 77	 mov	 DWORD PTR why$1$[rbp-153], eax
$LN299@PyEval_Eva:

; 2086 :             }
; 2087 :             Py_DECREF(v);

  018a3	48 8b cf	 mov	 rcx, rdi
$LN1072@PyEval_Eva:
  018a6	e8 00 00 00 00	 call	 _Py_DecRef

; 2088 :             break;

  018ab	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  018af	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  018b3	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  018b6	33 f6		 xor	 esi, esi
  018b8	e9 53 09 00 00	 jmp	 $LN1052@PyEval_Eva
$LN298@PyEval_Eva:

; 2089 :         }
; 2090 : 
; 2091 :         TARGET(STORE_ATTR)
; 2092 :             w = GETITEM(names, oparg);
; 2093 :             v = TOP();

  018bd	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2094 :             u = SECOND();
; 2095 :             STACKADJ(-2);
; 2096 :             err = PyObject_SetAttr(v, w, u); /* v.w = u */

  018c2	4c 8b 4d b7	 mov	 r9, QWORD PTR names$1$[rbp-153]
  018c6	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]
  018cb	48 63 c6	 movsxd	 rax, esi
  018ce	49 83 c4 f0	 add	 r12, -16
  018d2	4c 8b c7	 mov	 r8, rdi
  018d5	49 8b 54 c1 70	 mov	 rdx, QWORD PTR [r9+rax*8+112]
  018da	48 8b cb	 mov	 rcx, rbx
  018dd	e8 00 00 00 00	 call	 PyObject_SetAttr

; 2097 :             Py_DECREF(v);

  018e2	48 8b cb	 mov	 rcx, rbx
  018e5	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  018e8	e8 00 00 00 00	 call	 _Py_DecRef

; 2098 :             Py_DECREF(u);

  018ed	48 8b cf	 mov	 rcx, rdi

; 2099 :             if (err == 0) DISPATCH();
; 2100 :             break;

  018f0	e9 bf f7 ff ff	 jmp	 $LN1082@PyEval_Eva
$LN296@PyEval_Eva:

; 2101 : 
; 2102 :         TARGET(DELETE_ATTR)
; 2103 :             w = GETITEM(names, oparg);
; 2104 :             v = POP();
; 2105 :             err = PyObject_SetAttr(v, w, (PyObject *)NULL);

  018f5	4c 8b 4d b7	 mov	 r9, QWORD PTR names$1$[rbp-153]
  018f9	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  018fe	48 63 c6	 movsxd	 rax, esi
  01901	49 8b 54 c1 70	 mov	 rdx, QWORD PTR [r9+rax*8+112]
  01906	49 83 ec 08	 sub	 r12, 8
  0190a	45 33 c0	 xor	 r8d, r8d
  0190d	48 8b cb	 mov	 rcx, rbx
  01910	e8 00 00 00 00	 call	 PyObject_SetAttr

; 2106 :                                             /* del v.w */
; 2107 :             Py_DECREF(v);

  01915	48 8b cb	 mov	 rcx, rbx
  01918	8b f8		 mov	 edi, eax
  0191a	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  0191d	e8 00 00 00 00	 call	 _Py_DecRef
  01922	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01926	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0192a	33 f6		 xor	 esi, esi
  0192c	e9 df 08 00 00	 jmp	 $LN1052@PyEval_Eva
$LN295@PyEval_Eva:

; 2108 :             break;
; 2109 : 
; 2110 :         TARGET(STORE_GLOBAL)
; 2111 :             w = GETITEM(names, oparg);
; 2112 :             v = POP();
; 2113 :             err = PyDict_SetItem(f->f_globals, w, v);

  01931	4c 8b 4d b7	 mov	 r9, QWORD PTR names$1$[rbp-153]
  01935	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  0193a	49 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [r14+136]
  01941	48 63 c6	 movsxd	 rax, esi
  01944	49 83 ec 08	 sub	 r12, 8
  01948	4c 8b c3	 mov	 r8, rbx
  0194b	49 8b 54 c1 70	 mov	 rdx, QWORD PTR [r9+rax*8+112]
  01950	e8 00 00 00 00	 call	 PyDict_SetItem

; 2114 :             Py_DECREF(v);

  01955	48 8b cb	 mov	 rcx, rbx
  01958	8b f8		 mov	 edi, eax
  0195a	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  0195d	e8 00 00 00 00	 call	 _Py_DecRef

; 2115 :             if (err == 0) DISPATCH();
; 2116 :             break;

  01962	e9 55 f7 ff ff	 jmp	 $LN1083@PyEval_Eva
$LN293@PyEval_Eva:

; 2117 : 
; 2118 :         TARGET(DELETE_GLOBAL)
; 2119 :             w = GETITEM(names, oparg);

  01967	4c 8b 45 b7	 mov	 r8, QWORD PTR names$1$[rbp-153]

; 2120 :             if ((err = PyDict_DelItem(f->f_globals, w)) != 0)

  0196b	49 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [r14+136]
  01972	48 63 c6	 movsxd	 rax, esi
  01975	49 8b 5c c0 70	 mov	 rbx, QWORD PTR [r8+rax*8+112]
  0197a	48 8b d3	 mov	 rdx, rbx
  0197d	e8 00 00 00 00	 call	 PyDict_DelItem
  01982	8b f8		 mov	 edi, eax
  01984	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  01987	85 c0		 test	 eax, eax
  01989	0f 84 fa ef ff
	ff		 je	 $LN1053@PyEval_Eva

; 2121 :                 format_exc_check_arg(
; 2122 :                     PyExc_NameError, GLOBAL_NAME_ERROR_MSG, w);

  0198f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01996	4c 8b c3	 mov	 r8, rbx
  01999	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@

; 2123 :             break;

  019a0	e9 df ef ff ff	 jmp	 $LN1054@PyEval_Eva
$LN291@PyEval_Eva:

; 2124 : 
; 2125 :         TARGET(LOAD_NAME)
; 2126 :             w = GETITEM(names, oparg);

  019a5	4c 8b 45 b7	 mov	 r8, QWORD PTR names$1$[rbp-153]

; 2127 :             if ((v = f->f_locals) == NULL) {

  019a9	49 8b 8e 90 00
	00 00		 mov	 rcx, QWORD PTR [r14+144]
  019b0	48 63 c6	 movsxd	 rax, esi
  019b3	49 8b 5c c0 70	 mov	 rbx, QWORD PTR [r8+rax*8+112]
  019b8	48 85 c9	 test	 rcx, rcx
  019bb	75 25		 jne	 SHORT $LN290@PyEval_Eva

; 2128 :                 PyErr_Format(PyExc_SystemError,
; 2129 :                              "no locals when loading %R", w);

  019bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  019c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@
  019cb	4c 8b c3	 mov	 r8, rbx
  019ce	e8 00 00 00 00	 call	 PyErr_Format
  019d3	bb 02 00 00 00	 mov	 ebx, 2
  019d8	8b fb		 mov	 edi, ebx
  019da	89 5d 77	 mov	 DWORD PTR why$1$[rbp-153], ebx
  019dd	e9 71 08 00 00	 jmp	 $LN80@PyEval_Eva
$LN290@PyEval_Eva:

; 2130 :                 why = WHY_EXCEPTION;
; 2131 :                 break;
; 2132 :             }
; 2133 :             if (PyDict_CheckExact(v)) {

  019e2	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:PyDict_Type
  019e9	4c 39 59 58	 cmp	 QWORD PTR [rcx+88], r11
  019ed	74 53		 je	 SHORT $LN288@PyEval_Eva
  019ef	4c 39 59 38	 cmp	 QWORD PTR [rcx+56], r11
  019f3	74 4d		 je	 SHORT $LN288@PyEval_Eva

; 2136 :             }
; 2137 :             else {
; 2138 :                 x = PyObject_GetItem(v, w);

  019f5	48 8b d3	 mov	 rdx, rbx
  019f8	e8 00 00 00 00	 call	 PyObject_GetItem
  019fd	4c 8b f8	 mov	 r15, rax

; 2139 :                 if (x == NULL && _PyErr_OCCURRED()) {

  01a00	48 85 c0	 test	 rax, rax
  01a03	0f 85 0d 01 00
	00		 jne	 $LN260@PyEval_Eva
  01a09	e8 00 00 00 00	 call	 _Py_PXCTX
  01a0e	85 c0		 test	 eax, eax
  01a10	74 07		 je	 SHORT $LN548@PyEval_Eva
  01a12	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  01a17	eb 07		 jmp	 SHORT $LN549@PyEval_Eva
$LN548@PyEval_Eva:
  01a19	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN549@PyEval_Eva:
  01a20	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  01a25	74 2b		 je	 SHORT $LN852@PyEval_Eva

; 2140 :                     if (!PyErr_ExceptionMatches(
; 2141 :                                     PyExc_KeyError))

  01a27	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  01a2e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  01a33	85 c0		 test	 eax, eax
  01a35	0f 84 4e ef ff
	ff		 je	 $LN1053@PyEval_Eva

; 2142 :                         break;
; 2143 :                     PyErr_Clear();

  01a3b	e8 00 00 00 00	 call	 PyErr_Clear
  01a40	eb 10		 jmp	 SHORT $LN852@PyEval_Eva
$LN288@PyEval_Eva:

; 2134 :                 x = PyDict_GetItem(v, w);

  01a42	48 8b d3	 mov	 rdx, rbx
  01a45	e8 00 00 00 00	 call	 PyDict_GetItem
  01a4a	4c 8b f8	 mov	 r15, rax

; 2135 :                 Py_XINCREF(x);

  01a4d	48 85 c0	 test	 rax, rax

; 2144 :                 }
; 2145 :             }
; 2146 :             if (x == NULL) {

  01a50	75 17		 jne	 SHORT $LN1045@PyEval_Eva
$LN852@PyEval_Eva:

; 2147 :                 x = PyDict_GetItem(f->f_globals, w);

  01a52	49 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [r14+136]
  01a59	48 8b d3	 mov	 rdx, rbx
  01a5c	e8 00 00 00 00	 call	 PyDict_GetItem
  01a61	4c 8b f8	 mov	 r15, rax

; 2148 :                 Py_XINCREF(x);

  01a64	48 85 c0	 test	 rax, rax
  01a67	74 56		 je	 SHORT $LN851@PyEval_Eva
$LN1045@PyEval_Eva:
  01a69	e8 00 00 00 00	 call	 _Py_PXCTX
  01a6e	85 c0		 test	 eax, eax
  01a70	0f 85 a0 00 00
	00		 jne	 $LN260@PyEval_Eva
  01a76	b8 02 00 00 00	 mov	 eax, 2
  01a7b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  01a82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  01a89	4d 8b cf	 mov	 r9, r15
  01a8c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  01a92	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01a96	e8 00 00 00 00	 call	 _PyParallel_Guard
  01a9b	85 c0		 test	 eax, eax
  01a9d	75 07		 jne	 SHORT $LN653@PyEval_Eva
  01a9f	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  01aa4	74 70		 je	 SHORT $LN260@PyEval_Eva
$LN653@PyEval_Eva:
  01aa6	49 ff 47 50	 inc	 QWORD PTR [r15+80]

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  01aaa	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01aae	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01ab2	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  01ab6	49 83 c4 08	 add	 r12, 8
  01aba	e9 0d 16 00 00	 jmp	 $LN1025@PyEval_Eva
$LN851@PyEval_Eva:

; 2149 :                 if (x == NULL) {
; 2150 :                     if (PyDict_CheckExact(f->f_builtins)) {

  01abf	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  01ac6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDict_Type
  01acd	48 39 51 58	 cmp	 QWORD PTR [rcx+88], rdx
  01ad1	74 27		 je	 SHORT $LN273@PyEval_Eva
  01ad3	48 39 51 38	 cmp	 QWORD PTR [rcx+56], rdx
  01ad7	74 21		 je	 SHORT $LN273@PyEval_Eva

; 2153 :                             format_exc_check_arg(
; 2154 :                                         PyExc_NameError,
; 2155 :                                         NAME_ERROR_MSG, w);
; 2156 :                             break;
; 2157 :                         }
; 2158 :                         Py_INCREF(x);
; 2159 :                     }
; 2160 :                     else {
; 2161 :                         x = PyObject_GetItem(f->f_builtins, w);

  01ad9	48 8b d3	 mov	 rdx, rbx
  01adc	e8 00 00 00 00	 call	 PyObject_GetItem
  01ae1	4c 8b f8	 mov	 r15, rax

; 2162 :                         if (x == NULL) {

  01ae4	48 85 c0	 test	 rax, rax
  01ae7	75 2d		 jne	 SHORT $LN260@PyEval_Eva

; 2163 :                             if (PyErr_ExceptionMatches(PyExc_KeyError))

  01ae9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  01af0	e8 00 00 00 00	 call	 PyErr_ExceptionMatches

; 2164 :                                 format_exc_check_arg(
; 2165 :                                             PyExc_NameError,
; 2166 :                                             NAME_ERROR_MSG, w);
; 2167 :                             break;

  01af5	e9 2d fd ff ff	 jmp	 $LN1067@PyEval_Eva
$LN273@PyEval_Eva:

; 2151 :                         x = PyDict_GetItem(f->f_builtins, w);

  01afa	48 8b d3	 mov	 rdx, rbx
  01afd	e8 00 00 00 00	 call	 PyDict_GetItem
  01b02	4c 8b f8	 mov	 r15, rax

; 2152 :                         if (x == NULL) {

  01b05	48 85 c0	 test	 rax, rax
  01b08	0f 84 21 fd ff
	ff		 je	 $LN1068@PyEval_Eva
$LN264@PyEval_Eva:

; 2186 :                     break;
; 2187 :                 }
; 2188 :                 Py_INCREF(x);

  01b0e	48 8b c8	 mov	 rcx, rax
  01b11	e8 00 00 00 00	 call	 _Py_IncRef
$LN260@PyEval_Eva:

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  01b16	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01b1a	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01b1e	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  01b22	49 83 c4 08	 add	 r12, 8
  01b26	e9 a1 15 00 00	 jmp	 $LN1025@PyEval_Eva
$LN268@PyEval_Eva:

; 2168 :                         }
; 2169 :                     }
; 2170 :                 }
; 2171 :             }
; 2172 :             PUSH(x);
; 2173 :             DISPATCH();
; 2174 : 
; 2175 :         TARGET(LOAD_GLOBAL)
; 2176 :             w = GETITEM(names, oparg);
; 2177 :             if (PyDict_CheckExact(f->f_globals)
; 2178 :                 && PyDict_CheckExact(f->f_builtins)) {

  01b2b	49 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [r14+136]
  01b32	4c 8b 45 b7	 mov	 r8, QWORD PTR names$1$[rbp-153]
  01b36	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:PyDict_Type
  01b3d	48 63 c6	 movsxd	 rax, esi
  01b40	49 8b 5c c0 70	 mov	 rbx, QWORD PTR [r8+rax*8+112]
  01b45	4c 39 59 58	 cmp	 QWORD PTR [rcx+88], r11
  01b49	74 06		 je	 SHORT $LN266@PyEval_Eva
  01b4b	4c 39 59 38	 cmp	 QWORD PTR [rcx+56], r11
  01b4f	75 13		 jne	 SHORT $LN267@PyEval_Eva
$LN266@PyEval_Eva:
  01b51	49 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [r14+128]
  01b58	4c 39 5a 58	 cmp	 QWORD PTR [rdx+88], r11
  01b5c	74 57		 je	 SHORT $LN265@PyEval_Eva
  01b5e	4c 39 5a 38	 cmp	 QWORD PTR [rdx+56], r11
  01b62	74 51		 je	 SHORT $LN265@PyEval_Eva
$LN267@PyEval_Eva:

; 2189 :             }
; 2190 :             else {
; 2191 :                 /* Slow-path if globals or builtins is not a dict */
; 2192 :                 x = PyObject_GetItem(f->f_globals, w);

  01b64	48 8b d3	 mov	 rdx, rbx
  01b67	e8 00 00 00 00	 call	 PyObject_GetItem
  01b6c	4c 8b f8	 mov	 r15, rax

; 2193 :                 if (x == NULL) {

  01b6f	48 85 c0	 test	 rax, rax
  01b72	75 a2		 jne	 SHORT $LN260@PyEval_Eva

; 2194 :                     x = PyObject_GetItem(f->f_builtins, w);

  01b74	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  01b7b	48 8b d3	 mov	 rdx, rbx
  01b7e	e8 00 00 00 00	 call	 PyObject_GetItem
  01b83	4c 8b f8	 mov	 r15, rax

; 2195 :                     if (x == NULL) {

  01b86	48 85 c0	 test	 rax, rax
  01b89	75 8b		 jne	 SHORT $LN260@PyEval_Eva

; 2196 :                         if (PyErr_ExceptionMatches(PyExc_KeyError))

  01b8b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  01b92	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  01b97	85 c0		 test	 eax, eax
  01b99	0f 84 ea ed ff
	ff		 je	 $LN1053@PyEval_Eva

; 2197 :                             format_exc_check_arg(
; 2198 :                                         PyExc_NameError,
; 2199 :                                         GLOBAL_NAME_ERROR_MSG, w);

  01b9f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01ba6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
  01bad	4c 8b c3	 mov	 r8, rbx
  01bb0	e9 cf ed ff ff	 jmp	 $LN1054@PyEval_Eva
$LN265@PyEval_Eva:

; 2179 :                 x = _PyDict_LoadGlobal((PyDictObject *)f->f_globals,
; 2180 :                                        (PyDictObject *)f->f_builtins,
; 2181 :                                        w);

  01bb5	4c 8b c3	 mov	 r8, rbx
  01bb8	e8 00 00 00 00	 call	 _PyDict_LoadGlobal
  01bbd	4c 8b f8	 mov	 r15, rax

; 2182 :                 if (x == NULL) {

  01bc0	48 85 c0	 test	 rax, rax
  01bc3	0f 85 45 ff ff
	ff		 jne	 $LN264@PyEval_Eva

; 2183 :                     if (!_PyErr_OCCURRED())

  01bc9	e8 00 00 00 00	 call	 _Py_PXCTX
  01bce	85 c0		 test	 eax, eax
  01bd0	74 07		 je	 SHORT $LN550@PyEval_Eva
  01bd2	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  01bd7	eb 07		 jmp	 SHORT $LN551@PyEval_Eva
$LN550@PyEval_Eva:
  01bd9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN551@PyEval_Eva:
  01be0	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  01be5	0f 85 9e ed ff
	ff		 jne	 $LN1053@PyEval_Eva

; 2184 :                         format_exc_check_arg(PyExc_NameError,
; 2185 :                                              GLOBAL_NAME_ERROR_MSG, w);

  01beb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01bf2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
  01bf9	4c 8b c3	 mov	 r8, rbx
  01bfc	e9 83 ed ff ff	 jmp	 $LN1054@PyEval_Eva
$LN258@PyEval_Eva:

; 2200 :                         break;
; 2201 :                     }
; 2202 :                 }
; 2203 :             }
; 2204 :             PUSH(x);
; 2205 :             DISPATCH();
; 2206 : 
; 2207 :         TARGET(DELETE_FAST)
; 2208 :             x = GETLOCAL(oparg);

  01c01	48 63 d6	 movsxd	 rdx, esi
  01c04	4d 8b bc d6 d0
	01 00 00	 mov	 r15, QWORD PTR [r14+rdx*8+464]

; 2209 :             if (x != NULL) {

  01c0c	4d 85 ff	 test	 r15, r15
  01c0f	0f 84 4e ed ff
	ff		 je	 $LN257@PyEval_Eva

; 2210 :                 SETLOCAL(oparg, NULL);

  01c15	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01c19	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01c1d	33 f6		 xor	 esi, esi
  01c1f	49 89 b4 d6 d0
	01 00 00	 mov	 QWORD PTR [r14+rdx*8+464], rsi
  01c27	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  01c2b	4d 85 ff	 test	 r15, r15
  01c2e	0f 84 c9 e5 ff
	ff		 je	 $LN531@PyEval_Eva
  01c34	e8 00 00 00 00	 call	 _Py_PXCTX
  01c39	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  01c3d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  01c44	85 c0		 test	 eax, eax
  01c46	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01c4a	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  01c51	0f 85 a2 e5 ff
	ff		 jne	 $LN937@PyEval_Eva
  01c57	49 8b 47 20	 mov	 rax, QWORD PTR [r15+32]
  01c5b	a8 20		 test	 al, 32			; 00000020H
  01c5d	0f 85 8e 00 00
	00		 jne	 $LN661@PyEval_Eva
  01c63	84 c0		 test	 al, al
  01c65	0f 88 86 00 00
	00		 js	 $LN661@PyEval_Eva
  01c6b	a8 02		 test	 al, 2
  01c6d	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01c71	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  01c78	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  01c7f	0f 85 74 e5 ff
	ff		 jne	 $LN937@PyEval_Eva
  01c85	49 ff 4f 50	 dec	 QWORD PTR [r15+80]
  01c89	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  01c90	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  01c97	0f 85 5c e5 ff
	ff		 jne	 $LN937@PyEval_Eva
  01c9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  01ca4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  01cab	4d 8b cf	 mov	 r9, r15
  01cae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  01cb4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  01cbc	e8 00 00 00 00	 call	 _PyParallel_Guard
  01cc1	49 8b cf	 mov	 rcx, r15
  01cc4	85 c0		 test	 eax, eax
  01cc6	74 12		 je	 SHORT $LN666@PyEval_Eva
  01cc8	e8 00 00 00 00	 call	 _Px_Dealloc
  01ccd	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01cd1	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  01cd5	e9 f8 13 00 00	 jmp	 $LN1035@PyEval_Eva
$LN666@PyEval_Eva:
  01cda	49 8b 47 58	 mov	 rax, QWORD PTR [r15+88]
  01cde	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  01ce4	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01ce8	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  01cec	e9 e1 13 00 00	 jmp	 $LN1035@PyEval_Eva
$LN661@PyEval_Eva:
  01cf1	49 8b cf	 mov	 rcx, r15
  01cf4	e8 00 00 00 00	 call	 Px_DecRef

; 2211 :                 DISPATCH();

  01cf9	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01cfd	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  01d01	e9 cc 13 00 00	 jmp	 $LN1035@PyEval_Eva
$LN249@PyEval_Eva:

; 2212 :             }
; 2213 :             format_exc_check_arg(
; 2214 :                 PyExc_UnboundLocalError,
; 2215 :                 UNBOUNDLOCAL_ERROR_MSG,
; 2216 :                 PyTuple_GetItem(co->co_varnames, oparg)
; 2217 :                 );
; 2218 :             break;
; 2219 : 
; 2220 :         TARGET(DELETE_DEREF)
; 2221 :             x = freevars[oparg];

  01d06	4c 8b 4d ef	 mov	 r9, QWORD PTR freevars$1$[rbp-153]
  01d0a	48 63 c6	 movsxd	 rax, esi
  01d0d	4d 8b 3c c1	 mov	 r15, QWORD PTR [r9+rax*8]

; 2222 :             if (PyCell_GET(x) != NULL) {

  01d11	49 83 7f 60 00	 cmp	 QWORD PTR [r15+96], 0
  01d16	74 17		 je	 SHORT $LN248@PyEval_Eva

; 2223 :                 PyCell_Set(x, NULL);

  01d18	33 d2		 xor	 edx, edx
  01d1a	49 8b cf	 mov	 rcx, r15
  01d1d	e8 00 00 00 00	 call	 PyCell_Set

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  01d22	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01d26	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01d2a	e9 9d 13 00 00	 jmp	 $LN1025@PyEval_Eva
$LN248@PyEval_Eva:

; 2224 :                 DISPATCH();
; 2225 :             }
; 2226 :             err = -1;
; 2227 :             format_exc_unbound(co, oparg);

  01d2f	48 8b 4d df	 mov	 rcx, QWORD PTR co$1$[rbp-153]
  01d33	83 cf ff	 or	 edi, -1
  01d36	8b d6		 mov	 edx, esi
  01d38	89 7d 7f	 mov	 DWORD PTR err$1$[rbp-153], edi
  01d3b	e8 00 00 00 00	 call	 format_exc_unbound
  01d40	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01d44	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01d48	33 f6		 xor	 esi, esi
  01d4a	e9 c1 04 00 00	 jmp	 $LN1052@PyEval_Eva
$LN247@PyEval_Eva:

; 2228 :             break;
; 2229 : 
; 2230 :         TARGET(LOAD_CLOSURE)
; 2231 :             x = freevars[oparg];

  01d4f	4c 8b 4d ef	 mov	 r9, QWORD PTR freevars$1$[rbp-153]
  01d53	48 63 c6	 movsxd	 rax, esi
  01d56	4d 8b 3c c1	 mov	 r15, QWORD PTR [r9+rax*8]

; 2232 :             Py_INCREF(x);

  01d5a	e8 00 00 00 00	 call	 _Py_PXCTX
  01d5f	85 c0		 test	 eax, eax
  01d61	75 34		 jne	 SHORT $LN669@PyEval_Eva
  01d63	b8 02 00 00 00	 mov	 eax, 2
  01d68	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  01d6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  01d76	4d 8b cf	 mov	 r9, r15
  01d79	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  01d7f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01d83	e8 00 00 00 00	 call	 _PyParallel_Guard
  01d88	85 c0		 test	 eax, eax
  01d8a	75 07		 jne	 SHORT $LN668@PyEval_Eva
  01d8c	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  01d91	74 04		 je	 SHORT $LN669@PyEval_Eva
$LN668@PyEval_Eva:
  01d93	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN669@PyEval_Eva:

; 2233 :             PUSH(x);

  01d97	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  01d9b	49 83 c4 08	 add	 r12, 8

; 2234 :             if (x != NULL) DISPATCH();
; 2235 :             break;

  01d9f	e9 8a ee ff ff	 jmp	 $LN1075@PyEval_Eva
$LN245@PyEval_Eva:

; 2236 : 
; 2237 :         TARGET(LOAD_DEREF)
; 2238 :             x = freevars[oparg];

  01da4	4c 8b 4d ef	 mov	 r9, QWORD PTR freevars$1$[rbp-153]
  01da8	48 63 c6	 movsxd	 rax, esi
  01dab	4d 8b 3c c1	 mov	 r15, QWORD PTR [r9+rax*8]

; 2239 :             w = PyCell_Get(x);

  01daf	49 8b cf	 mov	 rcx, r15
  01db2	e8 00 00 00 00	 call	 PyCell_Get

; 2240 :             if (w != NULL) {

  01db7	48 85 c0	 test	 rax, rax
  01dba	0f 84 6f ff ff
	ff		 je	 $LN248@PyEval_Eva

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  01dc0	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01dc4	49 89 04 24	 mov	 QWORD PTR [r12], rax
  01dc8	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01dcc	49 83 c4 08	 add	 r12, 8
  01dd0	e9 f7 12 00 00	 jmp	 $LN1025@PyEval_Eva
$LN243@PyEval_Eva:

; 2241 :                 PUSH(w);
; 2242 :                 DISPATCH();
; 2243 :             }
; 2244 :             err = -1;
; 2245 :             format_exc_unbound(co, oparg);
; 2246 :             break;
; 2247 : 
; 2248 :         TARGET(STORE_DEREF)
; 2249 :             w = POP();
; 2250 :             x = freevars[oparg];

  01dd5	4c 8b 4d ef	 mov	 r9, QWORD PTR freevars$1$[rbp-153]
  01dd9	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  01dde	49 83 ec 08	 sub	 r12, 8
  01de2	48 63 c6	 movsxd	 rax, esi

; 2251 :             PyCell_Set(x, w);

  01de5	48 8b d3	 mov	 rdx, rbx
  01de8	4d 8b 3c c1	 mov	 r15, QWORD PTR [r9+rax*8]
  01dec	49 8b cf	 mov	 rcx, r15
  01def	e8 00 00 00 00	 call	 PyCell_Set

; 2252 :             Py_DECREF(w);
; 2253 :             DISPATCH();

  01df4	e9 15 e9 ff ff	 jmp	 $LN1059@PyEval_Eva
$LN242@PyEval_Eva:

; 2254 : 
; 2255 :         TARGET(BUILD_TUPLE)
; 2256 :             x = PyTuple_New(oparg);

  01df9	48 63 ce	 movsxd	 rcx, esi
  01dfc	e8 00 00 00 00	 call	 PyTuple_New
  01e01	4c 8b f8	 mov	 r15, rax

; 2257 :             if (x != NULL) {

  01e04	48 85 c0	 test	 rax, rax
  01e07	0f 84 7c eb ff
	ff		 je	 $LN1053@PyEval_Eva

; 2258 :                 for (; --oparg >= 0;) {

  01e0d	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  01e10	48 63 c8	 movsxd	 rcx, eax
  01e13	85 c0		 test	 eax, eax
  01e15	78 70		 js	 SHORT $LN235@PyEval_Eva
  01e17	49 8d 54 cf 70	 lea	 rdx, QWORD PTR [r15+rcx*8+112]
  01e1c	0f 1f 40 00	 npad	 4
$LL240@PyEval_Eva:

; 2259 :                     w = POP();
; 2260 :                     PyTuple_SET_ITEM(x, oparg, w);

  01e20	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  01e25	49 83 ec 08	 sub	 r12, 8
  01e29	48 83 ea 08	 sub	 rdx, 8
  01e2d	48 ff c9	 dec	 rcx
  01e30	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
  01e34	79 ea		 jns	 SHORT $LL240@PyEval_Eva

; 2273 :                 }
; 2274 :                 PUSH(x);
; 2275 :                 DISPATCH();

  01e36	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01e3a	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  01e3e	49 83 c4 08	 add	 r12, 8
  01e42	e9 81 12 00 00	 jmp	 $LN1090@PyEval_Eva
$LN238@PyEval_Eva:

; 2261 :                 }
; 2262 :                 PUSH(x);
; 2263 :                 DISPATCH();
; 2264 :             }
; 2265 :             break;
; 2266 : 
; 2267 :         TARGET(BUILD_LIST)
; 2268 :             x =  PyList_New(oparg);

  01e47	48 63 ce	 movsxd	 rcx, esi
  01e4a	e8 00 00 00 00	 call	 PyList_New
  01e4f	4c 8b f8	 mov	 r15, rax

; 2269 :             if (x != NULL) {

  01e52	48 85 c0	 test	 rax, rax
  01e55	0f 84 2e eb ff
	ff		 je	 $LN1053@PyEval_Eva

; 2270 :                 for (; --oparg >= 0;) {

  01e5b	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  01e5e	48 63 d0	 movsxd	 rdx, eax
  01e61	85 c0		 test	 eax, eax
  01e63	78 22		 js	 SHORT $LN235@PyEval_Eva
  01e65	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL236@PyEval_Eva:

; 2271 :                     w = POP();
; 2272 :                     PyList_SET_ITEM(x, oparg, w);

  01e70	49 8b 4f 70	 mov	 rcx, QWORD PTR [r15+112]
  01e74	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  01e79	49 83 ec 08	 sub	 r12, 8
  01e7d	48 ff ca	 dec	 rdx
  01e80	48 89 44 d1 08	 mov	 QWORD PTR [rcx+rdx*8+8], rax
  01e85	79 e9		 jns	 SHORT $LL236@PyEval_Eva
$LN235@PyEval_Eva:

; 2273 :                 }
; 2274 :                 PUSH(x);
; 2275 :                 DISPATCH();

  01e87	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01e8b	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  01e8f	49 83 c4 08	 add	 r12, 8
  01e93	e9 30 12 00 00	 jmp	 $LN1090@PyEval_Eva
$LN234@PyEval_Eva:

; 2276 :             }
; 2277 :             break;
; 2278 : 
; 2279 :         TARGET(BUILD_SET)
; 2280 :             x = PySet_New(NULL);

  01e98	33 c9		 xor	 ecx, ecx
  01e9a	e8 00 00 00 00	 call	 PySet_New
  01e9f	4c 8b f8	 mov	 r15, rax

; 2281 :             if (x != NULL) {

  01ea2	48 85 c0	 test	 rax, rax
  01ea5	0f 84 de ea ff
	ff		 je	 $LN1053@PyEval_Eva

; 2282 :                 for (; --oparg >= 0;) {

  01eab	ff ce		 dec	 esi
  01ead	0f 88 8a 00 00
	00		 js	 $LN231@PyEval_Eva
$LL232@PyEval_Eva:

; 2283 :                     w = POP();

  01eb3	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  01eb8	49 83 ec 08	 sub	 r12, 8

; 2284 :                     if (err == 0)

  01ebc	85 ff		 test	 edi, edi
  01ebe	75 0d		 jne	 SHORT $LN230@PyEval_Eva

; 2285 :                         err = PySet_Add(x, w);

  01ec0	48 8b d3	 mov	 rdx, rbx
  01ec3	49 8b cf	 mov	 rcx, r15
  01ec6	e8 00 00 00 00	 call	 PySet_Add
  01ecb	8b f8		 mov	 edi, eax
$LN230@PyEval_Eva:

; 2286 :                     Py_DECREF(w);

  01ecd	e8 00 00 00 00	 call	 _Py_PXCTX
  01ed2	85 c0		 test	 eax, eax
  01ed4	75 5c		 jne	 SHORT $LN682@PyEval_Eva
  01ed6	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  01eda	a8 20		 test	 al, 32			; 00000020H
  01edc	75 4c		 jne	 SHORT $LN676@PyEval_Eva
  01ede	84 c0		 test	 al, al
  01ee0	78 48		 js	 SHORT $LN676@PyEval_Eva
  01ee2	a8 02		 test	 al, 2
  01ee4	75 4c		 jne	 SHORT $LN682@PyEval_Eva
  01ee6	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  01eea	75 46		 jne	 SHORT $LN682@PyEval_Eva
  01eec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  01ef3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  01efa	4c 8b cb	 mov	 r9, rbx
  01efd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  01f03	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  01f0b	e8 00 00 00 00	 call	 _PyParallel_Guard
  01f10	48 8b cb	 mov	 rcx, rbx
  01f13	85 c0		 test	 eax, eax
  01f15	74 07		 je	 SHORT $LN681@PyEval_Eva
  01f17	e8 00 00 00 00	 call	 _Px_Dealloc
  01f1c	eb 14		 jmp	 SHORT $LN682@PyEval_Eva
$LN681@PyEval_Eva:
  01f1e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  01f22	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  01f28	eb 08		 jmp	 SHORT $LN682@PyEval_Eva
$LN676@PyEval_Eva:
  01f2a	48 8b cb	 mov	 rcx, rbx
  01f2d	e8 00 00 00 00	 call	 Px_DecRef
$LN682@PyEval_Eva:

; 2282 :                 for (; --oparg >= 0;) {

  01f32	ff ce		 dec	 esi
  01f34	0f 89 79 ff ff
	ff		 jns	 $LL232@PyEval_Eva
  01f3a	89 7d 7f	 mov	 DWORD PTR err$1$[rbp-153], edi
$LN231@PyEval_Eva:

; 2287 :                 }
; 2288 :                 if (err != 0) {

  01f3d	85 ff		 test	 edi, edi
  01f3f	0f 84 42 ff ff
	ff		 je	 $LN235@PyEval_Eva

; 2289 :                     Py_DECREF(x);

  01f45	49 8b cf	 mov	 rcx, r15
  01f48	e8 00 00 00 00	 call	 _Py_DecRef
  01f4d	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01f51	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01f55	33 f6		 xor	 esi, esi
  01f57	e9 b4 02 00 00	 jmp	 $LN1052@PyEval_Eva
$LN228@PyEval_Eva:

; 2290 :                     break;
; 2291 :                 }
; 2292 :                 PUSH(x);
; 2293 :                 DISPATCH();
; 2294 :             }
; 2295 :             break;
; 2296 : 
; 2297 :         TARGET(BUILD_MAP)
; 2298 :             x = _PyDict_NewPresized((Py_ssize_t)oparg);

  01f5c	48 63 ce	 movsxd	 rcx, esi
  01f5f	e8 00 00 00 00	 call	 _PyDict_NewPresized

; 2299 :             PUSH(x);

  01f64	49 83 c4 08	 add	 r12, 8
  01f68	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax

; 2300 :             if (x != NULL) DISPATCH();

  01f6d	48 85 c0	 test	 rax, rax
  01f70	4c 8b f8	 mov	 r15, rax

; 2301 :             break;

  01f73	e9 b9 ec ff ff	 jmp	 $LN1076@PyEval_Eva
$LN226@PyEval_Eva:

; 2302 : 
; 2303 :         TARGET(STORE_MAP)
; 2304 :             w = TOP();     /* key */

  01f78	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2305 :             u = SECOND();  /* value */

  01f7d	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]

; 2306 :             v = THIRD();   /* dict */

  01f82	49 8b 4c 24 e8	 mov	 rcx, QWORD PTR [r12-24]

; 2307 :             STACKADJ(-2);
; 2308 :             assert (PyDict_CheckExact(v));
; 2309 :             err = PyDict_SetItem(v, w, u);  /* v[w] = u */

  01f87	4c 8b c3	 mov	 r8, rbx
  01f8a	48 8b d7	 mov	 rdx, rdi
  01f8d	49 83 c4 f0	 add	 r12, -16
  01f91	e8 00 00 00 00	 call	 PyDict_SetItem

; 2310 :             Py_DECREF(u);

  01f96	48 8b cb	 mov	 rcx, rbx
  01f99	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  01f9c	e8 00 00 00 00	 call	 _Py_DecRef

; 2311 :             Py_DECREF(w);

  01fa1	48 8b cf	 mov	 rcx, rdi
  01fa4	e8 00 00 00 00	 call	 _Py_DecRef

; 2312 :             if (err == 0) DISPATCH();

  01fa9	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
$LN1087@PyEval_Eva:
  01fac	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  01fb0	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  01fb4	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  01fb8	be 00 00 00 00	 mov	 esi, 0
  01fbd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  01fc4	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  01fcb	85 ff		 test	 edi, edi
  01fcd	0f 84 26 e2 ff
	ff		 je	 $LN937@PyEval_Eva

; 1514 :             break;

  01fd3	e9 38 02 00 00	 jmp	 $LN1052@PyEval_Eva
$LN224@PyEval_Eva:

; 2313 :             break;
; 2314 : 
; 2315 :         TARGET(MAP_ADD)
; 2316 :             w = TOP();     /* key */

  01fd8	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2317 :             u = SECOND();  /* value */

  01fdd	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  01fe2	49 83 c4 f0	 add	 r12, -16

; 2318 :             STACKADJ(-2);
; 2319 :             v = stack_pointer[-oparg];  /* dict */

  01fe6	48 63 d6	 movsxd	 rdx, esi
  01fe9	49 8b c4	 mov	 rax, r12

; 2320 :             assert (PyDict_CheckExact(v));
; 2321 :             err = PyDict_SetItem(v, w, u);  /* v[w] = u */

  01fec	4c 8b c3	 mov	 r8, rbx
  01fef	48 c1 e2 03	 shl	 rdx, 3
  01ff3	48 2b c2	 sub	 rax, rdx
  01ff6	48 8b d7	 mov	 rdx, rdi
  01ff9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  01ffc	e8 00 00 00 00	 call	 PyDict_SetItem

; 2322 :             Py_DECREF(u);

  02001	48 8b cb	 mov	 rcx, rbx
  02004	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  02007	e8 00 00 00 00	 call	 _Py_DecRef

; 2323 :             Py_DECREF(w);

  0200c	48 8b cf	 mov	 rcx, rdi
  0200f	e8 00 00 00 00	 call	 _Py_DecRef

; 2324 :             if (err == 0) {

  02014	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]

; 2325 :                 PREDICT(JUMP_ABSOLUTE);

  02017	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0201b	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0201f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  02026	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  0202d	85 ff		 test	 edi, edi
  0202f	0f 85 c5 e9 ff
	ff		 jne	 $LN978@PyEval_Eva
  02035	80 38 71	 cmp	 BYTE PTR [rax], 113	; 00000071H
  02038	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  0203c	8b f7		 mov	 esi, edi
  0203e	0f 85 b5 e1 ff
	ff		 jne	 $LN937@PyEval_Eva
$PRED_JUMP_ABSOLUTE$64568:

; 2535 : 
; 2536 :         PREDICTED_WITH_ARG(JUMP_ABSOLUTE);

  02044	0f b6 70 02	 movzx	 esi, BYTE PTR [rax+2]
  02048	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0204c	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
  02050	c1 e6 08	 shl	 esi, 8
  02053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0205a	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  02061	03 f0		 add	 esi, eax
$LN162@PyEval_Eva:

; 2537 :         TARGET(JUMP_ABSOLUTE)
; 2538 :             JUMPTO(oparg);
; 2539 : #if FAST_LOOPS
; 2540 :             /* Enabling this path speeds-up all while and for-loops by bypassing
; 2541 :                the per-loop checks for signals.  By default, this should be turned-off
; 2542 :                because it prevents detection of a control-break in tight loops like
; 2543 :                "while 1: pass".  Compile with this option turned-on when you need
; 2544 :                the speed-up and do not need break checking inside tight loops (ones
; 2545 :                that contain only instructions ending with FAST_DISPATCH).
; 2546 :             */
; 2547 :             FAST_DISPATCH();
; 2548 : #else
; 2549 :             DISPATCH();

  02063	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02067	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  0206b	48 63 c6	 movsxd	 rax, esi
  0206e	48 03 c2	 add	 rax, rdx
  02071	33 f6		 xor	 esi, esi
  02073	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  02077	e9 81 e1 ff ff	 jmp	 $LN531@PyEval_Eva
$LN221@PyEval_Eva:

; 2326 :                 DISPATCH();
; 2327 :             }
; 2328 :             break;
; 2329 : 
; 2330 :         TARGET(LOAD_ATTR)
; 2331 :             w = GETITEM(names, oparg);
; 2332 :             v = TOP();
; 2333 :             x = PyObject_GetAttr(v, w);

  0207c	4c 8b 45 b7	 mov	 r8, QWORD PTR names$1$[rbp-153]
  02080	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  02085	48 63 c6	 movsxd	 rax, esi
  02088	49 8b 54 c0 70	 mov	 rdx, QWORD PTR [r8+rax*8+112]
  0208d	48 8b cb	 mov	 rcx, rbx
  02090	e8 00 00 00 00	 call	 PyObject_GetAttr

; 2334 :             Py_DECREF(v);
; 2335 :             SET_TOP(x);
; 2336 :             if (x != NULL) DISPATCH();
; 2337 :             break;

  02095	e9 84 eb ff ff	 jmp	 $LN1078@PyEval_Eva
$LN214@PyEval_Eva:

; 2349 :             DISPATCH();
; 2350 : 
; 2351 : #ifdef WITH_PARALLEL
; 2352 : #define PREVENT_PARALLEL_IMPORT() do {                                      \
; 2353 :     if (Py_PXCTX) {                                                         \
; 2354 :         PyErr_SetString(PyExc_ImportError,                                  \
; 2355 :                         "import not permitted within parallel context");    \
; 2356 :         break;                                                              \
; 2357 :     }                                                                       \
; 2358 : } while (0)
; 2359 : #else
; 2360 : #define PREVENT_PARALLEL_IMPORT()
; 2361 : #endif
; 2362 : 
; 2363 :         TARGET(IMPORT_NAME)
; 2364 :         {
; 2365 :             _Py_IDENTIFIER(__import__);
; 2366 :             PREVENT_PARALLEL_IMPORT();

  0209a	e8 00 00 00 00	 call	 _Py_PXCTX
  0209f	85 c0		 test	 eax, eax
  020a1	74 13		 je	 SHORT $LN213@PyEval_Eva
  020a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  020aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  020b1	e8 00 00 00 00	 call	 PyErr_SetString
$LN213@PyEval_Eva:

; 2367 :             w = GETITEM(names, oparg);

  020b6	48 8b 4d b7	 mov	 rcx, QWORD PTR names$1$[rbp-153]
  020ba	48 63 c6	 movsxd	 rax, esi

; 2368 :             x = _PyDict_GetItemId(f->f_builtins, &PyId___import__);

  020bd	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___import__@?HB@??PyEval_EvalFrameEx@@9@9
  020c2	48 8b 7c c1 70	 mov	 rdi, QWORD PTR [rcx+rax*8+112]
  020c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  020cd	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  020d6	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  020da	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  020e1	e8 00 00 00 00	 call	 _PyDict_GetItemId
  020e6	4c 8b f8	 mov	 r15, rax

; 2369 :             if (x == NULL) {

  020e9	48 85 c0	 test	 rax, rax
  020ec	75 25		 jne	 SHORT $LN210@PyEval_Eva

; 2370 :                 PyErr_SetString(PyExc_ImportError,
; 2371 :                                 "__import__ not found");

  020ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  020f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@
  020fc	e8 00 00 00 00	 call	 PyErr_SetString

; 2372 :                 break;

  02101	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02104	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02108	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  0210c	33 f6		 xor	 esi, esi
  0210e	e9 fd 00 00 00	 jmp	 $LN1052@PyEval_Eva
$LN210@PyEval_Eva:

; 2373 :             }
; 2374 :             Py_INCREF(x);

  02113	e8 00 00 00 00	 call	 _Py_PXCTX
  02118	85 c0		 test	 eax, eax
  0211a	75 34		 jne	 SHORT $LN684@PyEval_Eva
  0211c	b8 02 00 00 00	 mov	 eax, 2
  02121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  02128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0212f	4d 8b cf	 mov	 r9, r15
  02132	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  02138	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0213c	e8 00 00 00 00	 call	 _PyParallel_Guard
  02141	85 c0		 test	 eax, eax
  02143	75 07		 jne	 SHORT $LN683@PyEval_Eva
  02145	41 f6 47 20 20	 test	 BYTE PTR [r15+32], 32	; 00000020H
  0214a	74 04		 je	 SHORT $LN684@PyEval_Eva
$LN683@PyEval_Eva:
  0214c	49 ff 47 50	 inc	 QWORD PTR [r15+80]
$LN684@PyEval_Eva:

; 2375 :             v = POP();
; 2376 :             u = TOP();

  02150	49 8b 74 24 f0	 mov	 rsi, QWORD PTR [r12-16]
  02155	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  0215a	49 83 ec 08	 sub	 r12, 8

; 2377 :             if (PyLong_AsLong(u) != -1 || PyErr_Occurred())

  0215e	48 8b ce	 mov	 rcx, rsi
  02161	e8 00 00 00 00	 call	 PyLong_AsLong
  02166	83 f8 ff	 cmp	 eax, -1
  02169	75 3a		 jne	 SHORT $LN208@PyEval_Eva
  0216b	e8 00 00 00 00	 call	 PyErr_Occurred
  02170	48 85 c0	 test	 rax, rax
  02173	75 30		 jne	 SHORT $LN208@PyEval_Eva

; 2385 :             else
; 2386 :                 w = PyTuple_Pack(4,
; 2387 :                             w,
; 2388 :                             f->f_globals,
; 2389 :                             f->f_locals == NULL ?
; 2390 :                                   Py_None : f->f_locals,
; 2391 :                             v);

  02175	49 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [r14+144]
  0217c	4d 8b 86 88 00
	00 00		 mov	 r8, QWORD PTR [r14+136]
  02183	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0218a	48 85 c0	 test	 rax, rax
  0218d	48 8b d7	 mov	 rdx, rdi
  02190	b9 04 00 00 00	 mov	 ecx, 4
  02195	4c 0f 45 c8	 cmovne	 r9, rax
  02199	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0219e	e8 00 00 00 00	 call	 PyTuple_Pack
  021a3	eb 33		 jmp	 SHORT $LN1046@PyEval_Eva
$LN208@PyEval_Eva:

; 2378 :                 w = PyTuple_Pack(5,
; 2379 :                             w,
; 2380 :                             f->f_globals,
; 2381 :                             f->f_locals == NULL ?
; 2382 :                                   Py_None : f->f_locals,
; 2383 :                             v,
; 2384 :                             u);

  021a5	49 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [r14+144]
  021ac	4d 8b 86 88 00
	00 00		 mov	 r8, QWORD PTR [r14+136]
  021b3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  021ba	48 85 c0	 test	 rax, rax
  021bd	48 8b d7	 mov	 rdx, rdi
  021c0	b9 05 00 00 00	 mov	 ecx, 5
  021c5	4c 0f 45 c8	 cmovne	 r9, rax
  021c9	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  021ce	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  021d3	e8 00 00 00 00	 call	 PyTuple_Pack
$LN1046@PyEval_Eva:

; 2392 :             Py_DECREF(v);

  021d8	48 8b cb	 mov	 rcx, rbx
  021db	48 8b f8	 mov	 rdi, rax
  021de	e8 00 00 00 00	 call	 _Py_DecRef

; 2393 :             Py_DECREF(u);

  021e3	48 8b ce	 mov	 rcx, rsi
  021e6	e8 00 00 00 00	 call	 _Py_DecRef

; 2394 :             if (w == NULL) {
; 2395 :                 u = POP();
; 2396 :                 Py_DECREF(x);

  021eb	49 8b cf	 mov	 rcx, r15
  021ee	48 85 ff	 test	 rdi, rdi
  021f1	0f 85 87 00 00
	00		 jne	 $LN206@PyEval_Eva
  021f7	49 83 c4 f8	 add	 r12, -8
  021fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1084@PyEval_Eva:

; 2397 :                 x = NULL;

  02200	33 f6		 xor	 esi, esi
  02202	44 8b fe	 mov	 r15d, esi
$LN1085@PyEval_Eva:

; 2398 :                 break;

  02205	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
$LN995@PyEval_Eva:

; 1854 :             Py_XDECREF(x);

  02208	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
$LN1005@PyEval_Eva:

; 2989 : 
; 2990 :             if (tstate->c_tracefunc != NULL)

  0220c	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
$LN1052@PyEval_Eva:
  02210	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  02217	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
$LN1011@PyEval_Eva:

; 1423 :             break;

  0221e	8b 4d 77	 mov	 ecx, DWORD PTR why$1$[rbp-153]
  02221	ba 02 00 00 00	 mov	 edx, 2
  02226	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_NoneStruct
$on_error$64398:

; 2930 :             break;
; 2931 : 
; 2932 : #ifdef CASE_TOO_BIG
; 2933 :         }
; 2934 : #endif
; 2935 : 
; 2936 :         } /* switch */
; 2937 : 
; 2938 :         on_error:
; 2939 : 
; 2940 :         READ_TIMESTAMP(inst1);
; 2941 : 
; 2942 :         /* Quickly continue if no error occurred */
; 2943 : 
; 2944 :         if (why == WHY_NOT) {

  0222d	83 f9 01	 cmp	 ecx, 1
  02230	0f 85 16 0b 00
	00		 jne	 $LN83@PyEval_Eva

; 2945 :             if (err == 0 && x != NULL) {

  02236	85 ff		 test	 edi, edi
  02238	75 09		 jne	 SHORT $LN82@PyEval_Eva
  0223a	4d 85 ff	 test	 r15, r15
  0223d	0f 85 a6 0e 00
	00		 jne	 $LN962@PyEval_Eva
$LN82@PyEval_Eva:

; 2946 : #ifdef CHECKEXC
; 2947 :                 /* This check is expensive! */
; 2948 :                 if (PyErr_Occurred())
; 2949 :                     fprintf(stderr,
; 2950 :                         "XXX undetected error\n");
; 2951 :                 else {
; 2952 : #endif
; 2953 :                     READ_TIMESTAMP(loop1);
; 2954 :                     continue; /* Normal, fast path */
; 2955 : #ifdef CHECKEXC
; 2956 :                 }
; 2957 : #endif
; 2958 :             }
; 2959 :             why = WHY_EXCEPTION;

  02243	8b fa		 mov	 edi, edx
  02245	89 55 77	 mov	 DWORD PTR why$1$[rbp-153], edx

; 2960 :             x = Py_None;

  02248	4d 8b fa	 mov	 r15, r10

; 2961 :             err = 0;

  0224b	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi
$LN1019@PyEval_Eva:

; 1466 :             Py_INCREF(x);

  0224e	bb 02 00 00 00	 mov	 ebx, 2
$LN80@PyEval_Eva:

; 2967 :             if (!PyErr_Occurred()) {

  02253	e8 00 00 00 00	 call	 PyErr_Occurred
  02258	48 85 c0	 test	 rax, rax
  0225b	0f 85 00 0b 00
	00		 jne	 $LN79@PyEval_Eva

; 2968 :                 PyErr_SetString(PyExc_SystemError,
; 2969 :                     "error return without exception set");

  02261	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  02268	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@
  0226f	e8 00 00 00 00	 call	 PyErr_SetString

; 2970 :                 why = WHY_EXCEPTION;

  02274	8b fb		 mov	 edi, ebx
  02276	89 5d 77	 mov	 DWORD PTR why$1$[rbp-153], ebx

; 2971 :             }
; 2972 :         }
; 2973 : #ifdef CHECKEXC
; 2974 :         else {
; 2975 :             /* This check is expensive! */
; 2976 :             if (PyErr_Occurred()) {
; 2977 :                 char buf[128];
; 2978 :                 sprintf(buf, "Stack unwind with exception "
; 2979 :                     "set and why=%d", why);
; 2980 :                 Py_FatalError(buf);
; 2981 :             }
; 2982 :         }
; 2983 : #endif
; 2984 : 
; 2985 :         /* Log traceback info if this is a real exception */
; 2986 : 
; 2987 :         if (why == WHY_EXCEPTION) {

  02279	e9 e8 0a 00 00	 jmp	 $LN875@PyEval_Eva
$LN206@PyEval_Eva:

; 2399 :             }
; 2400 :             READ_TIMESTAMP(intr0);
; 2401 :             v = x;
; 2402 :             x = PyEval_CallObject(v, w);

  0227e	45 33 c0	 xor	 r8d, r8d
  02281	48 8b d7	 mov	 rdx, rdi
  02284	49 8b df	 mov	 rbx, r15
  02287	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 2403 :             Py_DECREF(v);
; 2404 :             READ_TIMESTAMP(intr1);
; 2405 :             Py_DECREF(w);
; 2406 :             SET_TOP(x);
; 2407 :             if (x != NULL) DISPATCH();
; 2408 :             break;

  0228c	e9 ea e9 ff ff	 jmp	 $LN1079@PyEval_Eva
$LN203@PyEval_Eva:

; 2409 :         }
; 2410 : 
; 2411 :         TARGET(IMPORT_STAR)
; 2412 :             PREVENT_PARALLEL_IMPORT();

  02291	e8 00 00 00 00	 call	 _Py_PXCTX
  02296	85 c0		 test	 eax, eax
  02298	74 13		 je	 SHORT $LN202@PyEval_Eva
  0229a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  022a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  022a8	e8 00 00 00 00	 call	 PyErr_SetString
$LN202@PyEval_Eva:

; 2413 :             v = POP();

  022ad	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  022b2	49 83 ec 08	 sub	 r12, 8

; 2414 :             PyFrame_FastToLocals(f);

  022b6	49 8b ce	 mov	 rcx, r14
  022b9	e8 00 00 00 00	 call	 PyFrame_FastToLocals

; 2415 :             if ((x = f->f_locals) == NULL) {

  022be	4d 8b be 90 00
	00 00		 mov	 r15, QWORD PTR [r14+144]
  022c5	4d 85 ff	 test	 r15, r15
  022c8	75 13		 jne	 SHORT $LN199@PyEval_Eva

; 2416 :                 PyErr_SetString(PyExc_SystemError,
; 2417 :                     "no locals found during 'import *'");

  022ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  022d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@

; 2418 :                 break;

  022d8	e9 fb f3 ff ff	 jmp	 $LN1071@PyEval_Eva
$LN199@PyEval_Eva:

; 2419 :             }
; 2420 :             READ_TIMESTAMP(intr0);
; 2421 :             err = import_all_from(x, v);

  022dd	48 8b d3	 mov	 rdx, rbx
  022e0	49 8b cf	 mov	 rcx, r15
  022e3	e8 00 00 00 00	 call	 import_all_from

; 2422 :             READ_TIMESTAMP(intr1);
; 2423 :             PyFrame_LocalsToFast(f, 0);

  022e8	33 d2		 xor	 edx, edx
  022ea	49 8b ce	 mov	 rcx, r14
  022ed	8b f8		 mov	 edi, eax
  022ef	89 45 7f	 mov	 DWORD PTR err$1$[rbp-153], eax
  022f2	e8 00 00 00 00	 call	 PyFrame_LocalsToFast

; 2424 :             Py_DECREF(v);

  022f7	48 8b cb	 mov	 rcx, rbx
  022fa	e8 00 00 00 00	 call	 _Py_DecRef

; 2425 :             if (err == 0) DISPATCH();
; 2426 :             break;

  022ff	e9 a8 fc ff ff	 jmp	 $LN1087@PyEval_Eva
$LN196@PyEval_Eva:

; 2427 : 
; 2428 :         TARGET(IMPORT_FROM)
; 2429 :             PREVENT_PARALLEL_IMPORT();

  02304	e8 00 00 00 00	 call	 _Py_PXCTX
  02309	85 c0		 test	 eax, eax
  0230b	74 13		 je	 SHORT $LN195@PyEval_Eva
  0230d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  02314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  0231b	e8 00 00 00 00	 call	 PyErr_SetString
$LN195@PyEval_Eva:

; 2430 :             w = GETITEM(names, oparg);
; 2431 :             v = TOP();
; 2432 :             READ_TIMESTAMP(intr0);
; 2433 :             x = import_from(v, w);

  02320	48 8b 4d b7	 mov	 rcx, QWORD PTR names$1$[rbp-153]
  02324	48 63 c6	 movsxd	 rax, esi
  02327	48 8b 54 c1 70	 mov	 rdx, QWORD PTR [rcx+rax*8+112]
  0232c	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  02331	e8 00 00 00 00	 call	 import_from

; 2434 :             READ_TIMESTAMP(intr1);
; 2435 :             PUSH(x);

  02336	49 83 c4 08	 add	 r12, 8
  0233a	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax

; 2436 :             if (x != NULL) DISPATCH();

  0233f	48 85 c0	 test	 rax, rax
  02342	4c 8b f8	 mov	 r15, rax

; 2437 :             break;

  02345	e9 e7 e8 ff ff	 jmp	 $LN1076@PyEval_Eva
$LN311@PyEval_Eva:

; 2057 :             } else if (PyList_CheckExact(v) &&
; 2058 :                        PyList_GET_SIZE(v) == oparg) {

  0234a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  02351	48 3b c1	 cmp	 rax, rcx
  02354	75 3f		 jne	 SHORT $LN307@PyEval_Eva
  02356	49 39 7d 60	 cmp	 QWORD PTR [r13+96], rdi
  0235a	75 39		 jne	 SHORT $LN307@PyEval_Eva

; 2059 :                 PyObject **items = \
; 2060 :                     ((PyListObject *)v)->ob_item;

  0235c	49 8b 75 70	 mov	 rsi, QWORD PTR [r13+112]

; 2061 :                 while (oparg--) {

  02360	48 85 ff	 test	 rdi, rdi
  02363	74 5c		 je	 SHORT $LN302@PyEval_Eva
  02365	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL306@PyEval_Eva:

; 2062 :                     w = items[oparg];

  02370	48 8b 5c fe f8	 mov	 rbx, QWORD PTR [rsi+rdi*8-8]
  02375	48 ff cf	 dec	 rdi

; 2063 :                     Py_INCREF(w);

  02378	48 8b cb	 mov	 rcx, rbx
  0237b	e8 00 00 00 00	 call	 _Py_IncRef

; 2064 :                     PUSH(w);

  02380	49 89 1c 24	 mov	 QWORD PTR [r12], rbx
  02384	49 83 c4 08	 add	 r12, 8
  02388	48 85 ff	 test	 rdi, rdi
  0238b	75 e3		 jne	 SHORT $LL306@PyEval_Eva

; 2072 :             }
; 2073 :             Py_DECREF(v);

  0238d	49 8b cd	 mov	 rcx, r13

; 2074 :             break;

  02390	e9 11 f5 ff ff	 jmp	 $LN1072@PyEval_Eva
$LN307@PyEval_Eva:

; 2065 :                 }
; 2066 :             } else if (unpack_iterable(v, oparg, -1,
; 2067 :                                        stack_pointer + oparg)) {

  02395	49 8d 1c fc	 lea	 rbx, QWORD PTR [r12+rdi*8]
  02399	41 83 c8 ff	 or	 r8d, -1
  0239d	8b d6		 mov	 edx, esi
  0239f	4c 8b cb	 mov	 r9, rbx
  023a2	49 8b cd	 mov	 rcx, r13
  023a5	e8 00 00 00 00	 call	 unpack_iterable
  023aa	85 c0		 test	 eax, eax
  023ac	74 0b		 je	 SHORT $LN303@PyEval_Eva

; 2068 :                 STACKADJ(oparg);

  023ae	4c 8b e3	 mov	 r12, rbx

; 2072 :             }
; 2073 :             Py_DECREF(v);

  023b1	49 8b cd	 mov	 rcx, r13

; 2074 :             break;

  023b4	e9 ed f4 ff ff	 jmp	 $LN1072@PyEval_Eva
$LN303@PyEval_Eva:

; 2069 :             } else {
; 2070 :                 /* unpack_iterable() raised an exception */
; 2071 :                 why = WHY_EXCEPTION;

  023b9	b8 02 00 00 00	 mov	 eax, 2
  023be	89 45 77	 mov	 DWORD PTR why$1$[rbp-153], eax
$LN302@PyEval_Eva:

; 2072 :             }
; 2073 :             Py_DECREF(v);

  023c1	49 8b cd	 mov	 rcx, r13

; 2074 :             break;

  023c4	e9 dd f4 ff ff	 jmp	 $LN1072@PyEval_Eva
$LN152@PyEval_Eva:

; 2587 : 
; 2588 :         TARGET(BREAK_LOOP)
; 2589 :             why = WHY_BREAK;

  023c9	bf 10 00 00 00	 mov	 edi, 16

; 2590 :             goto fast_block_end;

  023ce	e9 f4 09 00 00	 jmp	 $LN1042@PyEval_Eva
$LN151@PyEval_Eva:

; 2591 : 
; 2592 :         TARGET(CONTINUE_LOOP)
; 2593 :             retval = PyLong_FromLong(oparg);

  023d3	8b ce		 mov	 ecx, esi
  023d5	e8 00 00 00 00	 call	 PyLong_FromLong

; 2594 :             if (!retval) {
; 2595 :                 x = NULL;
; 2596 :                 break;

  023da	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  023de	48 89 45 bf	 mov	 QWORD PTR retval$1$[rbp-153], rax
  023e2	48 85 c0	 test	 rax, rax
  023e5	75 0e		 jne	 SHORT $LN150@PyEval_Eva
  023e7	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  023eb	33 f6		 xor	 esi, esi
  023ed	44 8b fe	 mov	 r15d, esi
  023f0	e9 1b fe ff ff	 jmp	 $LN1052@PyEval_Eva
$LN150@PyEval_Eva:

; 2597 :             }
; 2598 :             why = WHY_CONTINUE;

  023f5	bf 20 00 00 00	 mov	 edi, 32			; 00000020H

; 2599 :             goto fast_block_end;

  023fa	e9 cc 09 00 00	 jmp	 $LN1047@PyEval_Eva
$_setup_finally$65159:

; 2600 : 
; 2601 :         TARGET_WITH_IMPL(SETUP_LOOP, _setup_finally)
; 2602 :         TARGET_WITH_IMPL(SETUP_EXCEPT, _setup_finally)
; 2603 :         TARGET(SETUP_FINALLY)
; 2604 :         _setup_finally:
; 2605 :             /* NOTE: If you add any new block-setup opcodes that
; 2606 :                are not try/except/finally handlers, you may need
; 2607 :                to update the PyGen_NeedsFinalizing() function.
; 2608 :                */
; 2609 : 
; 2610 :             PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,
; 2611 :                                STACK_LEVEL());

  023ff	44 8b c3	 mov	 r8d, ebx
  02402	4d 8b cc	 mov	 r9, r12
  02405	49 8b ce	 mov	 rcx, r14
  02408	4d 2b 8e 98 00
	00 00		 sub	 r9, QWORD PTR [r14+152]
  0240f	44 2b c2	 sub	 r8d, edx
  02412	41 8b d5	 mov	 edx, r13d
  02415	49 c1 f9 03	 sar	 r9, 3
  02419	44 03 c6	 add	 r8d, esi
  0241c	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 2612 :             DISPATCH();

  02421	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02425	e9 9e 0c 00 00	 jmp	 $LN1090@PyEval_Eva
$LN145@PyEval_Eva:

; 2613 : 
; 2614 :         TARGET(SETUP_WITH)
; 2615 :         {
; 2616 :             _Py_IDENTIFIER(__exit__);
; 2617 :             _Py_IDENTIFIER(__enter__);
; 2618 :             w = TOP();
; 2619 :             x = special_lookup(w, &PyId___exit__);

  0242a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  02430	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  02439	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]
  0243e	48 8b 1c c8	 mov	 rbx, QWORD PTR [rax+rcx*8]
  02442	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___exit__@?IL@??PyEval_EvalFrameEx@@9@9
  02447	48 8b cf	 mov	 rcx, rdi
  0244a	48 03 d3	 add	 rdx, rbx
  0244d	e8 00 00 00 00	 call	 special_lookup
  02452	4c 8b f8	 mov	 r15, rax

; 2620 :             if (!x)

  02455	48 85 c0	 test	 rax, rax
  02458	0f 84 a1 e7 ff
	ff		 je	 $LN977@PyEval_Eva

; 2621 :                 break;
; 2622 :             SET_TOP(x);
; 2623 :             u = special_lookup(w, &PyId___enter__);

  0245e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___enter__@?IL@??PyEval_EvalFrameEx@@9@9
  02463	48 8b cf	 mov	 rcx, rdi
  02466	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax
  0246b	48 03 d3	 add	 rdx, rbx
  0246e	e8 00 00 00 00	 call	 special_lookup

; 2624 :             Py_DECREF(w);

  02473	48 8b cf	 mov	 rcx, rdi
  02476	48 8b d8	 mov	 rbx, rax
  02479	e8 00 00 00 00	 call	 _Py_DecRef

; 2625 :             if (!u) {

  0247e	48 85 db	 test	 rbx, rbx

; 2626 :                 x = NULL;
; 2627 :                 break;

  02481	0f 84 79 fd ff
	ff		 je	 $LN1084@PyEval_Eva

; 2628 :             }
; 2629 :             x = PyObject_CallFunctionObjArgs(u, NULL);

  02487	33 d2		 xor	 edx, edx
  02489	48 8b cb	 mov	 rcx, rbx
  0248c	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 2630 :             Py_DECREF(u);

  02491	48 8b cb	 mov	 rcx, rbx
  02494	4c 8b f8	 mov	 r15, rax
  02497	e8 00 00 00 00	 call	 _Py_DecRef

; 2631 :             if (!x)

  0249c	4d 85 ff	 test	 r15, r15
  0249f	0f 84 5a e7 ff
	ff		 je	 $LN977@PyEval_Eva

; 2632 :                 break;
; 2633 :             /* Setup the finally block before pushing the result
; 2634 :                of __enter__ on the stack. */
; 2635 :             PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,
; 2636 :                                STACK_LEVEL());

  024a5	4c 8b 45 97	 mov	 r8, QWORD PTR next_instr$1$[rbp-153]
  024a9	4d 8b cc	 mov	 r9, r12
  024ac	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  024b1	44 2b 45 af	 sub	 r8d, DWORD PTR first_instr$1$[rbp-153]
  024b5	4d 2b 8e 98 00
	00 00		 sub	 r9, QWORD PTR [r14+152]
  024bc	49 8b ce	 mov	 rcx, r14
  024bf	44 03 c6	 add	 r8d, esi
  024c2	49 c1 f9 03	 sar	 r9, 3
  024c6	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 2637 : 
; 2638 :             PUSH(x);
; 2639 :             DISPATCH();

  024cb	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  024cf	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  024d3	49 83 c4 08	 add	 r12, 8
  024d7	e9 e9 0b 00 00	 jmp	 $LN1040@PyEval_Eva
$LN141@PyEval_Eva:

; 2640 :         }
; 2641 : 
; 2642 :         TARGET(WITH_CLEANUP)
; 2643 :         {
; 2644 :             /* At the top of the stack are 1-6 values indicating
; 2645 :                how/why we entered the finally clause:
; 2646 :                - TOP = None
; 2647 :                - (TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retval
; 2648 :                - TOP = WHY_*; no retval below it
; 2649 :                - (TOP, SECOND, THIRD) = exc_info()
; 2650 :                  (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER
; 2651 :                Below them is EXIT, the context.__exit__ bound method.
; 2652 :                In the last case, we must call
; 2653 :                  EXIT(TOP, SECOND, THIRD)
; 2654 :                otherwise we must call
; 2655 :                  EXIT(None, None, None)
; 2656 : 
; 2657 :                In the first three cases, we remove EXIT from the
; 2658 :                stack, leaving the rest in the same order.  In the
; 2659 :                fourth case, we shift the bottom 3 values of the
; 2660 :                stack down, and replace the empty spot with NULL.
; 2661 : 
; 2662 :                In addition, if the stack represents an exception,
; 2663 :                *and* the function call returns a 'true' value, we
; 2664 :                push WHY_SILENCED onto the stack.  END_FINALLY will
; 2665 :                then not re-raise the exception.  (But non-local
; 2666 :                gotos should still be resumed.)
; 2667 :             */
; 2668 : 
; 2669 :             PyObject *exit_func;
; 2670 :             u = TOP();

  024dc	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  024e1	49 8d 4c 24 f8	 lea	 rcx, QWORD PTR [r12-8]

; 2671 :             if (u == Py_None) {

  024e6	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_NoneStruct
  024ed	49 3b da	 cmp	 rbx, r10
  024f0	75 18		 jne	 SHORT $LN140@PyEval_Eva

; 2672 :                 (void)POP();
; 2673 :                 exit_func = TOP();

  024f2	48 8b 79 f8	 mov	 rdi, QWORD PTR [rcx-8]
  024f6	4c 8b e1	 mov	 r12, rcx

; 2674 :                 SET_TOP(u);
; 2675 :                 v = w = Py_None;

  024f9	4d 8b ca	 mov	 r9, r10
  024fc	48 89 59 f8	 mov	 QWORD PTR [rcx-8], rbx
  02500	4d 8b c2	 mov	 r8, r10
  02503	33 f6		 xor	 esi, esi
  02505	e9 9f 00 00 00	 jmp	 $LN1048@PyEval_Eva
$LN140@PyEval_Eva:

; 2676 :             }
; 2677 :             else if (PyLong_Check(u)) {

  0250a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0250e	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  02518	74 44		 je	 SHORT $LN138@PyEval_Eva

; 2678 :                 (void)POP();

  0251a	4c 8b e1	 mov	 r12, rcx

; 2679 :                 switch(PyLong_AsLong(u)) {

  0251d	48 8b cb	 mov	 rcx, rbx
  02520	e8 00 00 00 00	 call	 PyLong_AsLong
  02525	83 f8 08	 cmp	 eax, 8
  02528	74 0c		 je	 SHORT $LN135@PyEval_Eva
  0252a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0252d	74 07		 je	 SHORT $LN135@PyEval_Eva

; 2685 :                     SET_TOP(u);
; 2686 :                     break;
; 2687 :                 default:
; 2688 :                     exit_func = TOP();

  0252f	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2689 :                     SET_TOP(u);
; 2690 :                     break;

  02534	eb 0f		 jmp	 SHORT $LN1049@PyEval_Eva
$LN135@PyEval_Eva:

; 2680 :                 case WHY_RETURN:
; 2681 :                 case WHY_CONTINUE:
; 2682 :                     /* Retval in TOP. */
; 2683 :                     exit_func = SECOND();
; 2684 :                     SET_SECOND(TOP());

  02536	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  0253b	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]
  02540	49 89 44 24 f0	 mov	 QWORD PTR [r12-16], rax
$LN1049@PyEval_Eva:

; 2691 :                 }
; 2692 :                 u = v = w = Py_None;

  02545	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  0254c	49 89 5c 24 f8	 mov	 QWORD PTR [r12-8], rbx

; 2693 :             }
; 2694 :             else {

  02551	33 f6		 xor	 esi, esi
  02553	4d 8b cd	 mov	 r9, r13
  02556	4d 8b c5	 mov	 r8, r13
  02559	49 8b dd	 mov	 rbx, r13
  0255c	eb 52		 jmp	 SHORT $LN133@PyEval_Eva
$LN138@PyEval_Eva:

; 2695 :                 PyObject *tp, *exc, *tb;
; 2696 :                 PyTryBlock *block;
; 2697 :                 v = SECOND();
; 2698 :                 w = THIRD();
; 2699 :                 tp = FOURTH();
; 2700 :                 exc = PEEK(5);
; 2701 :                 tb = PEEK(6);
; 2702 :                 exit_func = PEEK(7);
; 2703 :                 SET_VALUE(7, tb);

  0255e	49 8b 44 24 d0	 mov	 rax, QWORD PTR [r12-48]
  02563	49 8b 7c 24 c8	 mov	 rdi, QWORD PTR [r12-56]
  02568	4d 8b 44 24 f0	 mov	 r8, QWORD PTR [r12-16]
  0256d	4d 8b 4c 24 e8	 mov	 r9, QWORD PTR [r12-24]
  02572	49 89 44 24 c8	 mov	 QWORD PTR [r12-56], rax

; 2704 :                 SET_VALUE(6, exc);

  02577	49 8b 44 24 d8	 mov	 rax, QWORD PTR [r12-40]
  0257c	49 89 44 24 d0	 mov	 QWORD PTR [r12-48], rax

; 2705 :                 SET_VALUE(5, tp);

  02581	49 8b 44 24 e0	 mov	 rax, QWORD PTR [r12-32]

; 2706 :                 /* UNWIND_EXCEPT_HANDLER will pop this off. */
; 2707 :                 SET_FOURTH(NULL);

  02586	33 f6		 xor	 esi, esi
  02588	49 89 44 24 d8	 mov	 QWORD PTR [r12-40], rax
  0258d	49 89 74 24 e0	 mov	 QWORD PTR [r12-32], rsi

; 2708 :                 /* We just shifted the stack down, so we have
; 2709 :                    to tell the except handler block that the
; 2710 :                    values are lower than it expects. */
; 2711 :                 block = &f->f_blockstack[f->f_iblock - 1];

  02592	41 8b 86 d8 00
	00 00		 mov	 eax, DWORD PTR [r14+216]
  02599	ff c8		 dec	 eax
  0259b	48 98		 cdqe
  0259d	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]

; 2712 :                 assert(block->b_type == EXCEPT_HANDLER);
; 2713 :                 block->b_level--;

  025a1	41 ff 8c 96 e4
	00 00 00	 dec	 DWORD PTR [r14+rdx*4+228]
$LN1048@PyEval_Eva:
  025a9	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
$LN133@PyEval_Eva:

; 2714 :             }
; 2715 :             /* XXX Not the fastest way to call it... */
; 2716 :             x = PyObject_CallFunctionObjArgs(exit_func, u, v, w,
; 2717 :                                              NULL);

  025b0	48 8b d3	 mov	 rdx, rbx
  025b3	48 8b cf	 mov	 rcx, rdi
  025b6	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  025bb	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 2718 :             Py_DECREF(exit_func);

  025c0	48 8b cf	 mov	 rcx, rdi
  025c3	4c 8b f8	 mov	 r15, rax
  025c6	e8 00 00 00 00	 call	 _Py_DecRef

; 2719 :             if (x == NULL)

  025cb	4d 85 ff	 test	 r15, r15
  025ce	0f 84 31 fc ff
	ff		 je	 $LN1085@PyEval_Eva

; 2720 :                 break; /* Go to error exit */
; 2721 : 
; 2722 :             if (u != Py_None)

  025d4	49 3b dd	 cmp	 rbx, r13
  025d7	74 0c		 je	 SHORT $LN131@PyEval_Eva

; 2723 :                 err = PyObject_IsTrue(x);

  025d9	49 8b cf	 mov	 rcx, r15
  025dc	e8 00 00 00 00	 call	 PyObject_IsTrue
  025e1	8b f8		 mov	 edi, eax

; 2724 :             else

  025e3	eb 02		 jmp	 SHORT $LN1050@PyEval_Eva
$LN131@PyEval_Eva:

; 2725 :                 err = 0;

  025e5	8b fe		 mov	 edi, esi
$LN1050@PyEval_Eva:

; 2726 :             Py_DECREF(x);

  025e7	49 8b cf	 mov	 rcx, r15
  025ea	89 7d 7f	 mov	 DWORD PTR err$1$[rbp-153], edi
  025ed	e8 00 00 00 00	 call	 _Py_DecRef

; 2727 : 
; 2728 :             if (err < 0)

  025f2	85 ff		 test	 edi, edi
  025f4	0f 88 0e fc ff
	ff		 js	 $LN995@PyEval_Eva

; 2729 :                 break; /* Go to error exit */
; 2730 :             else if (err > 0) {

  025fa	7e 18		 jle	 SHORT $LN127@PyEval_Eva

; 2731 :                 err = 0;
; 2732 :                 /* There was an exception and a True return */
; 2733 :                 PUSH(PyLong_FromLong((long) WHY_SILENCED));

  025fc	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02601	8b fe		 mov	 edi, esi
  02603	89 75 7f	 mov	 DWORD PTR err$1$[rbp-153], esi
  02606	e8 00 00 00 00	 call	 PyLong_FromLong
  0260b	49 83 c4 08	 add	 r12, 8
  0260f	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax
$LN127@PyEval_Eva:

; 2734 :             }
; 2735 :             PREDICT(END_FINALLY);

  02614	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02618	80 38 58	 cmp	 BYTE PTR [rax], 88	; 00000058H
  0261b	0f 85 eb fb ff
	ff		 jne	 $LN1005@PyEval_Eva

; 1949 : 
; 1950 :         PREDICTED(END_FINALLY);

  02621	48 ff c0	 inc	 rax
$PRED_END_FINALLY$64755:
  02624	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  02628	eb 07		 jmp	 SHORT $LN356@PyEval_Eva
$LN1020@PyEval_Eva:

; 2929 :             why = WHY_EXCEPTION;

  0262a	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
$LN356@PyEval_Eva:

; 1951 :         TARGET(END_FINALLY)
; 1952 :             v = POP();

  02631	49 8b 74 24 f8	 mov	 rsi, QWORD PTR [r12-8]
  02636	49 83 ec 08	 sub	 r12, 8

; 1953 :             if (PyLong_Check(v)) {

  0263a	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0263e	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  02644	0f ba e1 18	 bt	 ecx, 24
  02648	0f 83 ed 00 00
	00		 jae	 $LN355@PyEval_Eva

; 1954 :                 why = (enum why_code) PyLong_AS_LONG(v);

  0264e	48 8b ce	 mov	 rcx, rsi
  02651	e8 00 00 00 00	 call	 PyLong_AsLong
  02656	8b f8		 mov	 edi, eax
  02658	89 45 77	 mov	 DWORD PTR why$1$[rbp-153], eax

; 1955 :                 assert(why != WHY_YIELD);
; 1956 :                 if (why == WHY_RETURN ||
; 1957 :                     why == WHY_CONTINUE)

  0265b	83 f8 08	 cmp	 eax, 8
  0265e	74 05		 je	 SHORT $LN353@PyEval_Eva
  02660	83 f8 20	 cmp	 eax, 32			; 00000020H
  02663	75 0d		 jne	 SHORT $LN354@PyEval_Eva
$LN353@PyEval_Eva:

; 1958 :                     retval = POP();

  02665	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  0266a	49 83 ec 08	 sub	 r12, 8
  0266e	48 89 45 bf	 mov	 QWORD PTR retval$1$[rbp-153], rax
$LN354@PyEval_Eva:

; 1959 :                 if (why == WHY_SILENCED) {

  02672	81 ff 80 00 00
	00		 cmp	 edi, 128		; 00000080H
  02678	0f 85 10 01 00
	00		 jne	 $LN1007@PyEval_Eva

; 1960 :                     /* An exception was silenced by 'with', we must
; 1961 :                     manually unwind the EXCEPT_HANDLER block which was
; 1962 :                     created when the exception was caught, otherwise
; 1963 :                     the stack will be in an inconsistent state. */
; 1964 :                     PyTryBlock *b = PyFrame_BlockPop(f);

  0267e	49 8b ce	 mov	 rcx, r14
  02681	e8 00 00 00 00	 call	 PyFrame_BlockPop

; 1965 :                     assert(b->b_type == EXCEPT_HANDLER);
; 1966 :                     UNWIND_EXCEPT_HANDLER(b);

  02686	49 8b d4	 mov	 rdx, r12
  02689	49 2b 96 98 00
	00 00		 sub	 rdx, QWORD PTR [r14+152]
  02690	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  02693	48 8b d8	 mov	 rbx, rax
  02696	83 c1 03	 add	 ecx, 3
  02699	48 c1 fa 03	 sar	 rdx, 3
  0269d	3b d1		 cmp	 edx, ecx
  0269f	7e 2b		 jle	 SHORT $LN350@PyEval_Eva
$LL351@PyEval_Eva:
  026a1	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  026a6	49 83 ec 08	 sub	 r12, 8
  026aa	48 85 c9	 test	 rcx, rcx
  026ad	74 05		 je	 SHORT $LN348@PyEval_Eva
  026af	e8 00 00 00 00	 call	 _Py_DecRef
$LN348@PyEval_Eva:
  026b4	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  026b7	49 8b cc	 mov	 rcx, r12
  026ba	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  026c1	83 c0 03	 add	 eax, 3
  026c4	48 c1 f9 03	 sar	 rcx, 3
  026c8	3b c8		 cmp	 ecx, eax
  026ca	7f d5		 jg	 SHORT $LL351@PyEval_Eva
$LN350@PyEval_Eva:
  026cc	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  026d0	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  026d5	49 83 ec 18	 sub	 r12, 24
  026d9	49 8b 4d 60	 mov	 rcx, QWORD PTR [r13+96]
  026dd	49 8b 5d 68	 mov	 rbx, QWORD PTR [r13+104]
  026e1	49 8b 7d 70	 mov	 rdi, QWORD PTR [r13+112]
  026e5	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  026e9	49 8b 44 24 08	 mov	 rax, QWORD PTR [r12+8]
  026ee	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  026f2	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  026f6	49 89 45 70	 mov	 QWORD PTR [r13+112], rax
  026fa	48 85 c9	 test	 rcx, rcx
  026fd	74 05		 je	 SHORT $LN344@PyEval_Eva
  026ff	e8 00 00 00 00	 call	 _Py_DecRef
$LN344@PyEval_Eva:
  02704	48 85 db	 test	 rbx, rbx
  02707	74 08		 je	 SHORT $LN340@PyEval_Eva
  02709	48 8b cb	 mov	 rcx, rbx
  0270c	e8 00 00 00 00	 call	 _Py_DecRef
$LN340@PyEval_Eva:
  02711	48 85 ff	 test	 rdi, rdi
  02714	74 08		 je	 SHORT $LN336@PyEval_Eva
  02716	48 8b cf	 mov	 rcx, rdi
  02719	e8 00 00 00 00	 call	 _Py_DecRef
$LN336@PyEval_Eva:

; 1981 :             }
; 1982 :             Py_DECREF(v);

  0271e	48 8b ce	 mov	 rcx, rsi
  02721	c7 45 77 01 00
	00 00		 mov	 DWORD PTR why$1$[rbp-153], 1
  02728	e8 00 00 00 00	 call	 _Py_DecRef

; 2088 :             break;

  0272d	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02731	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02734	33 f6		 xor	 esi, esi
  02736	e9 d5 fa ff ff	 jmp	 $LN1052@PyEval_Eva
$LN355@PyEval_Eva:

; 1967 :                     why = WHY_NOT;
; 1968 :                 }
; 1969 :             }
; 1970 :             else if (PyExceptionClass_Check(v)) {

  0273b	85 c9		 test	 ecx, ecx
  0273d	79 2f		 jns	 SHORT $LN332@PyEval_Eva
  0273f	f7 86 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rsi+256], 1073741824 ; 40000000H
  02749	74 23		 je	 SHORT $LN332@PyEval_Eva

; 1971 :                 w = POP();

  0274b	49 8b 54 24 f8	 mov	 rdx, QWORD PTR [r12-8]

; 1972 :                 u = POP();
; 1973 :                 PyErr_Restore(v, w, u);

  02750	4d 8b 44 24 f0	 mov	 r8, QWORD PTR [r12-16]
  02755	49 83 ec 10	 sub	 r12, 16
  02759	48 8b ce	 mov	 rcx, rsi
  0275c	e8 00 00 00 00	 call	 PyErr_Restore

; 1974 :                 why = WHY_RERAISE;

  02761	bf 04 00 00 00	 mov	 edi, 4
  02766	89 7d 77	 mov	 DWORD PTR why$1$[rbp-153], edi

; 1975 :                 break;

  02769	e9 e0 fa ff ff	 jmp	 $LN1019@PyEval_Eva
$LN332@PyEval_Eva:

; 1976 :             }
; 1977 :             else if (v != Py_None) {

  0276e	49 3b f5	 cmp	 rsi, r13
  02771	74 1b		 je	 SHORT $LN1007@PyEval_Eva

; 1978 :                 PyErr_SetString(PyExc_SystemError,
; 1979 :                     "'finally' pops bad exception");

  02773	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0277a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@
  02781	e8 00 00 00 00	 call	 PyErr_SetString

; 1980 :                 why = WHY_EXCEPTION;

  02786	b8 02 00 00 00	 mov	 eax, 2
  0278b	89 45 77	 mov	 DWORD PTR why$1$[rbp-153], eax
$LN1007@PyEval_Eva:

; 1981 :             }
; 1982 :             Py_DECREF(v);

  0278e	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02792	48 8b ce	 mov	 rcx, rsi
  02795	e8 00 00 00 00	 call	 _Py_DecRef

; 2088 :             break;

  0279a	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0279e	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  027a1	33 f6		 xor	 esi, esi
  027a3	e9 68 fa ff ff	 jmp	 $LN1052@PyEval_Eva
$LN125@PyEval_Eva:

; 2736 :             break;
; 2737 :         }
; 2738 : 
; 2739 :         TARGET(CALL_FUNCTION)
; 2740 :         {
; 2741 :             PyObject **sp;
; 2742 :             PCALL(PCALL_ALL);
; 2743 :             sp = stack_pointer;
; 2744 : #ifdef WITH_TSC
; 2745 :             x = call_function(&sp, oparg, &intr0, &intr1);
; 2746 : #else
; 2747 :             x = call_function(&sp, oparg);

  027a8	48 8d 4d 0f	 lea	 rcx, QWORD PTR sp$65215[rbp-153]
  027ac	8b d6		 mov	 edx, esi
  027ae	4c 89 65 0f	 mov	 QWORD PTR sp$65215[rbp-153], r12
  027b2	e8 00 00 00 00	 call	 call_function

; 2748 : #endif
; 2749 :             stack_pointer = sp;

  027b7	4c 8b 65 0f	 mov	 r12, QWORD PTR sp$65215[rbp-153]

; 2750 :             PUSH(x);

  027bb	49 89 04 24	 mov	 QWORD PTR [r12], rax
  027bf	49 83 c4 08	 add	 r12, 8

; 2751 :             if (x != NULL)

  027c3	48 85 c0	 test	 rax, rax
  027c6	4c 8b f8	 mov	 r15, rax

; 2752 :                 DISPATCH();
; 2753 :             break;

  027c9	e9 63 e4 ff ff	 jmp	 $LN1076@PyEval_Eva
$_call_function_var_kw$65219:

; 2754 :         }
; 2755 : 
; 2756 :         TARGET_WITH_IMPL(CALL_FUNCTION_VAR, _call_function_var_kw)
; 2757 :         TARGET_WITH_IMPL(CALL_FUNCTION_KW, _call_function_var_kw)
; 2758 :         TARGET(CALL_FUNCTION_VAR_KW)
; 2759 :         _call_function_var_kw:
; 2760 :         {
; 2761 :             int na = oparg & 0xff;

  027ce	44 0f b6 f6	 movzx	 r14d, sil

; 2762 :             int nk = (oparg>>8) & 0xff;

  027d2	c1 fe 08	 sar	 esi, 8

; 2763 :             int flags = (opcode - CALL_FUNCTION) & 3;

  027d5	41 ff c5	 inc	 r13d
  027d8	41 83 e5 03	 and	 r13d, 3
  027dc	40 0f b6 f6	 movzx	 esi, sil

; 2764 :             int n = na + 2 * nk;

  027e0	41 8d 04 76	 lea	 eax, DWORD PTR [r14+rsi*2]

; 2765 :             PyObject **pfunc, *func, **sp;
; 2766 :             PCALL(PCALL_ALL);
; 2767 :             if (flags & CALL_FLAG_VAR)

  027e4	41 f6 c5 01	 test	 r13b, 1
  027e8	74 02		 je	 SHORT $LN119@PyEval_Eva

; 2768 :                 n++;

  027ea	ff c0		 inc	 eax
$LN119@PyEval_Eva:

; 2769 :             if (flags & CALL_FLAG_KW)

  027ec	41 f6 c5 02	 test	 r13b, 2
  027f0	74 02		 je	 SHORT $LN118@PyEval_Eva

; 2770 :                 n++;

  027f2	ff c0		 inc	 eax
$LN118@PyEval_Eva:

; 2771 :             pfunc = stack_pointer - n - 1;

  027f4	48 98		 cdqe
  027f6	4d 8b fc	 mov	 r15, r12
  027f9	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  02801	4c 2b f8	 sub	 r15, rax

; 2772 :             func = *pfunc;
; 2773 : 
; 2774 :             if (PyMethod_Check(func)
; 2775 :                 && PyMethod_GET_SELF(func) != NULL) {

  02804	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMethod_Type
  0280b	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
  0280e	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  02812	0f 85 99 00 00
	00		 jne	 $LN117@PyEval_Eva
  02818	48 8b 7b 68	 mov	 rdi, QWORD PTR [rbx+104]
  0281c	48 85 ff	 test	 rdi, rdi
  0281f	0f 84 8c 00 00
	00		 je	 $LN117@PyEval_Eva

; 2776 :                 PyObject *self = PyMethod_GET_SELF(func);
; 2777 :                 Py_INCREF(self);

  02825	e8 00 00 00 00	 call	 _Py_PXCTX
  0282a	85 c0		 test	 eax, eax
  0282c	75 33		 jne	 SHORT $LN688@PyEval_Eva
  0282e	b8 02 00 00 00	 mov	 eax, 2
  02833	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0283a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  02841	4c 8b cf	 mov	 r9, rdi
  02844	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0284a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0284e	e8 00 00 00 00	 call	 _PyParallel_Guard
  02853	85 c0		 test	 eax, eax
  02855	75 06		 jne	 SHORT $LN687@PyEval_Eva
  02857	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0285b	74 04		 je	 SHORT $LN688@PyEval_Eva
$LN687@PyEval_Eva:
  0285d	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN688@PyEval_Eva:

; 2778 :                 func = PyMethod_GET_FUNCTION(func);

  02861	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]

; 2779 :                 Py_INCREF(func);

  02865	e8 00 00 00 00	 call	 _Py_PXCTX
  0286a	85 c0		 test	 eax, eax
  0286c	75 33		 jne	 SHORT $LN692@PyEval_Eva
  0286e	b8 02 00 00 00	 mov	 eax, 2
  02873	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0287a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  02881	4c 8b cb	 mov	 r9, rbx
  02884	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0288a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0288e	e8 00 00 00 00	 call	 _PyParallel_Guard
  02893	85 c0		 test	 eax, eax
  02895	75 06		 jne	 SHORT $LN691@PyEval_Eva
  02897	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0289b	74 04		 je	 SHORT $LN692@PyEval_Eva
$LN691@PyEval_Eva:
  0289d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN692@PyEval_Eva:

; 2780 :                 Py_DECREF(*pfunc);

  028a1	49 8b 0f	 mov	 rcx, QWORD PTR [r15]
  028a4	e8 00 00 00 00	 call	 _Py_DecRef

; 2781 :                 *pfunc = self;

  028a9	49 89 3f	 mov	 QWORD PTR [r15], rdi

; 2782 :                 na++;

  028ac	41 ff c6	 inc	 r14d

; 2783 :                 /* n++; */
; 2784 :             } else

  028af	eb 3c		 jmp	 SHORT $LN696@PyEval_Eva
$LN117@PyEval_Eva:

; 2785 :                 Py_INCREF(func);

  028b1	e8 00 00 00 00	 call	 _Py_PXCTX
  028b6	85 c0		 test	 eax, eax
  028b8	75 33		 jne	 SHORT $LN696@PyEval_Eva
  028ba	b8 02 00 00 00	 mov	 eax, 2
  028bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  028c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  028cd	4c 8b cb	 mov	 r9, rbx
  028d0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  028d6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  028da	e8 00 00 00 00	 call	 _PyParallel_Guard
  028df	85 c0		 test	 eax, eax
  028e1	75 06		 jne	 SHORT $LN695@PyEval_Eva
  028e3	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  028e7	74 04		 je	 SHORT $LN696@PyEval_Eva
$LN695@PyEval_Eva:
  028e9	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN696@PyEval_Eva:

; 2786 :             sp = stack_pointer;
; 2787 :             READ_TIMESTAMP(intr0);
; 2788 :             x = ext_do_call(func, &sp, flags, na, nk);

  028ed	48 8d 55 e7	 lea	 rdx, QWORD PTR sp$65229[rbp-153]
  028f1	45 8b ce	 mov	 r9d, r14d
  028f4	45 8b c5	 mov	 r8d, r13d
  028f7	48 8b cb	 mov	 rcx, rbx
  028fa	4c 89 65 e7	 mov	 QWORD PTR sp$65229[rbp-153], r12
  028fe	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  02902	e8 00 00 00 00	 call	 ext_do_call

; 2789 :             READ_TIMESTAMP(intr1);
; 2790 :             stack_pointer = sp;

  02907	4c 8b 65 e7	 mov	 r12, QWORD PTR sp$65229[rbp-153]

; 2791 :             Py_DECREF(func);

  0290b	48 8b cb	 mov	 rcx, rbx
  0290e	48 89 45 c7	 mov	 QWORD PTR tmp$1$[rbp-153], rax
  02912	e8 00 00 00 00	 call	 _Py_DecRef

; 2792 : 
; 2793 :             while (stack_pointer > pfunc) {

  02917	4d 3b e7	 cmp	 r12, r15
  0291a	76 77		 jbe	 SHORT $LN114@PyEval_Eva
  0291c	0f 1f 40 00	 npad	 4
$LL115@PyEval_Eva:

; 2794 :                 w = POP();

  02920	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  02925	49 83 ec 08	 sub	 r12, 8

; 2795 :                 Py_DECREF(w);

  02929	e8 00 00 00 00	 call	 _Py_PXCTX
  0292e	85 c0		 test	 eax, eax
  02930	75 5c		 jne	 SHORT $LN709@PyEval_Eva
  02932	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  02936	a8 20		 test	 al, 32			; 00000020H
  02938	75 4c		 jne	 SHORT $LN703@PyEval_Eva
  0293a	84 c0		 test	 al, al
  0293c	78 48		 js	 SHORT $LN703@PyEval_Eva
  0293e	a8 02		 test	 al, 2
  02940	75 4c		 jne	 SHORT $LN709@PyEval_Eva
  02942	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  02946	75 46		 jne	 SHORT $LN709@PyEval_Eva
  02948	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0294f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  02956	4c 8b cb	 mov	 r9, rbx
  02959	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0295f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  02967	e8 00 00 00 00	 call	 _PyParallel_Guard
  0296c	48 8b cb	 mov	 rcx, rbx
  0296f	85 c0		 test	 eax, eax
  02971	74 07		 je	 SHORT $LN708@PyEval_Eva
  02973	e8 00 00 00 00	 call	 _Px_Dealloc
  02978	eb 14		 jmp	 SHORT $LN709@PyEval_Eva
$LN708@PyEval_Eva:
  0297a	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0297e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  02984	eb 08		 jmp	 SHORT $LN709@PyEval_Eva
$LN703@PyEval_Eva:
  02986	48 8b cb	 mov	 rcx, rbx
  02989	e8 00 00 00 00	 call	 Px_DecRef
$LN709@PyEval_Eva:

; 2792 : 
; 2793 :             while (stack_pointer > pfunc) {

  0298e	4d 3b e7	 cmp	 r12, r15
  02991	77 8d		 ja	 SHORT $LL115@PyEval_Eva
$LN114@PyEval_Eva:

; 2796 :             }
; 2797 :             PUSH(x);

  02993	4c 8b 7d c7	 mov	 r15, QWORD PTR tmp$1$[rbp-153]

; 2798 :             if (x != NULL)

  02997	4c 8b 75 67	 mov	 r14, QWORD PTR f$[rbp-153]
  0299b	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  0299f	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  029a3	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  029a6	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  029aa	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  029ae	49 83 c4 08	 add	 r12, 8
  029b2	be 00 00 00 00	 mov	 esi, 0
  029b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  029be	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  029c5	4d 85 ff	 test	 r15, r15
  029c8	0f 85 2b d8 ff
	ff		 jne	 $LN937@PyEval_Eva

; 1524 :             break;

  029ce	e9 3d f8 ff ff	 jmp	 $LN1052@PyEval_Eva
$_make_function$65251:

; 2799 :                 DISPATCH();
; 2800 :             break;
; 2801 :         }
; 2802 : 
; 2803 :         TARGET_WITH_IMPL(MAKE_CLOSURE, _make_function)
; 2804 :         TARGET(MAKE_FUNCTION)
; 2805 :         _make_function:
; 2806 :         {
; 2807 :             int posdefaults = oparg & 0xff;
; 2808 :             int kwdefaults = (oparg>>8) & 0xff;
; 2809 :             int num_annotations = (oparg >> 16) & 0x7fff;
; 2810 : 
; 2811 :             w = POP(); /* qualname */

  029d3	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2812 :             v = POP(); /* code object */

  029d8	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]

; 2813 :             x = PyFunction_NewWithQualName(v, f->f_globals, w);

  029dd	48 8b 55 67	 mov	 rdx, QWORD PTR f$[rbp-153]
  029e1	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
  029e8	8b c6		 mov	 eax, esi
  029ea	44 0f b6 f6	 movzx	 r14d, sil
  029ee	c1 f8 08	 sar	 eax, 8
  029f1	49 83 ec 10	 sub	 r12, 16
  029f5	c1 fe 10	 sar	 esi, 16
  029f8	48 8b cb	 mov	 rcx, rbx
  029fb	4c 8b c7	 mov	 r8, rdi
  029fe	44 89 75 e7	 mov	 DWORD PTR posdefaults$1$[rbp-153], r14d
  02a02	44 0f b6 f8	 movzx	 r15d, al
  02a06	81 e6 ff 7f 00
	00		 and	 esi, 32767		; 00007fffH
  02a0c	e8 00 00 00 00	 call	 PyFunction_NewWithQualName

; 2814 :             Py_DECREF(v);

  02a11	48 8b cb	 mov	 rcx, rbx
  02a14	48 89 45 c7	 mov	 QWORD PTR tmp$1$[rbp-153], rax
  02a18	e8 00 00 00 00	 call	 _Py_DecRef

; 2815 :             Py_DECREF(w);

  02a1d	48 8b cf	 mov	 rcx, rdi
  02a20	e8 00 00 00 00	 call	 _Py_DecRef

; 2816 : 
; 2817 :             if (x != NULL && opcode == MAKE_CLOSURE) {

  02a25	48 8b 7d c7	 mov	 rdi, QWORD PTR tmp$1$[rbp-153]
  02a29	48 85 ff	 test	 rdi, rdi
  02a2c	0f 84 e3 01 00
	00		 je	 $LN964@PyEval_Eva
  02a32	41 81 fd 86 00
	00 00		 cmp	 r13d, 134		; 00000086H
  02a39	75 2c		 jne	 SHORT $LN110@PyEval_Eva

; 2818 :                 v = POP();

  02a3b	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]
  02a40	49 83 ec 08	 sub	 r12, 8

; 2819 :                 if (PyFunction_SetClosure(x, v) != 0) {

  02a44	48 8b cf	 mov	 rcx, rdi
  02a47	48 8b d3	 mov	 rdx, rbx
  02a4a	e8 00 00 00 00	 call	 PyFunction_SetClosure
  02a4f	8b 4d 77	 mov	 ecx, DWORD PTR why$1$[rbp-153]
  02a52	85 c0		 test	 eax, eax
  02a54	b8 02 00 00 00	 mov	 eax, 2
  02a59	0f 45 c8	 cmovne	 ecx, eax
  02a5c	89 4d 77	 mov	 DWORD PTR why$1$[rbp-153], ecx

; 2820 :                     /* Can't happen unless bytecode is corrupt. */
; 2821 :                     why = WHY_EXCEPTION;
; 2822 :                 }
; 2823 :                 Py_DECREF(v);

  02a5f	48 8b cb	 mov	 rcx, rbx
  02a62	e8 00 00 00 00	 call	 _Py_DecRef
$LN110@PyEval_Eva:

; 2824 :             }
; 2825 : 
; 2826 :             if (x != NULL && num_annotations > 0) {

  02a67	85 f6		 test	 esi, esi
  02a69	0f 8e a2 00 00
	00		 jle	 $LN1017@PyEval_Eva

; 2827 :                 Py_ssize_t name_ix;
; 2828 :                 u = POP(); /* names of args with annotations */

  02a6f	4d 8b 74 24 f8	 mov	 r14, QWORD PTR [r12-8]
  02a74	49 83 ec 08	 sub	 r12, 8

; 2829 :                 v = PyDict_New();

  02a78	e8 00 00 00 00	 call	 PyDict_New
  02a7d	4c 8b e8	 mov	 r13, rax

; 2830 :                 if (v == NULL) {

  02a80	48 85 c0	 test	 rax, rax
  02a83	75 11		 jne	 SHORT $LN107@PyEval_Eva
$LN1091@PyEval_Eva:

; 2831 :                     Py_DECREF(x);

  02a85	48 8b cf	 mov	 rcx, rdi
  02a88	e8 00 00 00 00	 call	 _Py_DecRef

; 2832 :                     x = NULL;
; 2833 :                     break;

  02a8d	4c 8b 75 67	 mov	 r14, QWORD PTR f$[rbp-153]
  02a91	e9 6a f7 ff ff	 jmp	 $LN1084@PyEval_Eva
$LN107@PyEval_Eva:

; 2834 :                 }
; 2835 :                 name_ix = PyTuple_Size(u);

  02a96	49 8b ce	 mov	 rcx, r14
  02a99	e8 00 00 00 00	 call	 PyTuple_Size
  02a9e	48 8b f8	 mov	 rdi, rax

; 2836 :                 assert(num_annotations == name_ix+1);
; 2837 :                 while (name_ix > 0) {

  02aa1	48 85 c0	 test	 rax, rax
  02aa4	7e 36		 jle	 SHORT $LN105@PyEval_Eva

; 2834 :                 }
; 2835 :                 name_ix = PyTuple_Size(u);

  02aa6	49 8d 74 c6 70	 lea	 rsi, QWORD PTR [r14+rax*8+112]
  02aab	0f 1f 44 00 00	 npad	 5
$LL106@PyEval_Eva:

; 2838 :                     --name_ix;
; 2839 :                     t = PyTuple_GET_ITEM(u, name_ix);
; 2840 :                     w = POP();

  02ab0	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2841 :                     /* XXX(nnorwitz): check for errors */
; 2842 :                     PyDict_SetItem(v, t, w);

  02ab5	48 8b 56 f8	 mov	 rdx, QWORD PTR [rsi-8]
  02ab9	49 83 ec 08	 sub	 r12, 8
  02abd	48 83 ee 08	 sub	 rsi, 8
  02ac1	49 8b cd	 mov	 rcx, r13
  02ac4	4c 8b c3	 mov	 r8, rbx
  02ac7	48 ff cf	 dec	 rdi
  02aca	e8 00 00 00 00	 call	 PyDict_SetItem

; 2843 :                     Py_DECREF(w);

  02acf	48 8b cb	 mov	 rcx, rbx
  02ad2	e8 00 00 00 00	 call	 _Py_DecRef
  02ad7	48 85 ff	 test	 rdi, rdi
  02ada	7f d4		 jg	 SHORT $LL106@PyEval_Eva
$LN105@PyEval_Eva:

; 2844 :                 }
; 2845 : 
; 2846 :                 if (PyFunction_SetAnnotations(x, v) != 0) {

  02adc	48 8b 7d c7	 mov	 rdi, QWORD PTR tmp$1$[rbp-153]
  02ae0	49 8b d5	 mov	 rdx, r13
  02ae3	48 8b cf	 mov	 rcx, rdi
  02ae6	e8 00 00 00 00	 call	 PyFunction_SetAnnotations
  02aeb	8b 4d 77	 mov	 ecx, DWORD PTR why$1$[rbp-153]
  02aee	be 02 00 00 00	 mov	 esi, 2
  02af3	85 c0		 test	 eax, eax
  02af5	0f 45 ce	 cmovne	 ecx, esi
  02af8	89 4d 77	 mov	 DWORD PTR why$1$[rbp-153], ecx

; 2847 :                     /* Can't happen unless
; 2848 :                        PyFunction_SetAnnotations changes. */
; 2849 :                     why = WHY_EXCEPTION;
; 2850 :                 }
; 2851 :                 Py_DECREF(v);

  02afb	49 8b cd	 mov	 rcx, r13
  02afe	e8 00 00 00 00	 call	 _Py_DecRef

; 2852 :                 Py_DECREF(u);

  02b03	49 8b ce	 mov	 rcx, r14
  02b06	e8 00 00 00 00	 call	 _Py_DecRef
  02b0b	44 8b 75 e7	 mov	 r14d, DWORD PTR posdefaults$1$[rbp-153]
  02b0f	eb 05		 jmp	 SHORT $LN108@PyEval_Eva
$LN1017@PyEval_Eva:

; 1241 :         }
; 1242 :         else

  02b11	be 02 00 00 00	 mov	 esi, 2
$LN108@PyEval_Eva:

; 2853 :             }
; 2854 : 
; 2855 :             /* XXX Maybe this should be a separate opcode? */
; 2856 :             if (x != NULL && posdefaults > 0) {

  02b16	45 85 f6	 test	 r14d, r14d
  02b19	7e 5e		 jle	 SHORT $LN1012@PyEval_Eva

; 2857 :                 v = PyTuple_New(posdefaults);

  02b1b	49 63 ce	 movsxd	 rcx, r14d
  02b1e	e8 00 00 00 00	 call	 PyTuple_New
  02b23	48 8b d8	 mov	 rbx, rax

; 2858 :                 if (v == NULL) {

  02b26	48 85 c0	 test	 rax, rax

; 2859 :                     Py_DECREF(x);
; 2860 :                     x = NULL;
; 2861 :                     break;

  02b29	0f 84 56 ff ff
	ff		 je	 $LN1091@PyEval_Eva

; 2862 :                 }
; 2863 :                 while (--posdefaults >= 0) {

  02b2f	41 8d 46 ff	 lea	 eax, DWORD PTR [r14-1]
  02b33	48 63 c8	 movsxd	 rcx, eax
  02b36	85 c0		 test	 eax, eax
  02b38	78 1c		 js	 SHORT $LN100@PyEval_Eva
  02b3a	48 8d 54 cb 70	 lea	 rdx, QWORD PTR [rbx+rcx*8+112]
  02b3f	90		 npad	 1
$LL101@PyEval_Eva:

; 2864 :                     w = POP();
; 2865 :                     PyTuple_SET_ITEM(v, posdefaults, w);

  02b40	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  02b45	49 83 ec 08	 sub	 r12, 8
  02b49	48 83 ea 08	 sub	 rdx, 8
  02b4d	48 ff c9	 dec	 rcx
  02b50	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
  02b54	79 ea		 jns	 SHORT $LL101@PyEval_Eva
$LN100@PyEval_Eva:

; 2866 :                 }
; 2867 :                 if (PyFunction_SetDefaults(x, v) != 0) {

  02b56	48 8b d3	 mov	 rdx, rbx
  02b59	48 8b cf	 mov	 rcx, rdi
  02b5c	e8 00 00 00 00	 call	 PyFunction_SetDefaults
  02b61	44 8b 6d 77	 mov	 r13d, DWORD PTR why$1$[rbp-153]

; 2868 :                     /* Can't happen unless
; 2869 :                        PyFunction_SetDefaults changes. */
; 2870 :                     why = WHY_EXCEPTION;
; 2871 :                 }
; 2872 :                 Py_DECREF(v);

  02b65	48 8b cb	 mov	 rcx, rbx
  02b68	85 c0		 test	 eax, eax
  02b6a	44 0f 45 ee	 cmovne	 r13d, esi
  02b6e	44 89 6d 77	 mov	 DWORD PTR why$1$[rbp-153], r13d
  02b72	e8 00 00 00 00	 call	 _Py_DecRef
  02b77	eb 04		 jmp	 SHORT $LN103@PyEval_Eva
$LN1012@PyEval_Eva:

; 2888 :                 }
; 2889 :                 if (PyFunction_SetKwDefaults(x, v) != 0) {

  02b79	44 8b 6d 77	 mov	 r13d, DWORD PTR why$1$[rbp-153]
$LN103@PyEval_Eva:

; 2873 :             }
; 2874 :             if (x != NULL && kwdefaults > 0) {

  02b7d	45 85 ff	 test	 r15d, r15d
  02b80	0f 8e b0 00 00
	00		 jle	 $LN965@PyEval_Eva

; 2875 :                 v = PyDict_New();

  02b86	e8 00 00 00 00	 call	 PyDict_New
  02b8b	48 8b f0	 mov	 rsi, rax

; 2876 :                 if (v == NULL) {

  02b8e	48 85 c0	 test	 rax, rax

; 2877 :                     Py_DECREF(x);
; 2878 :                     x = NULL;
; 2879 :                     break;

  02b91	0f 84 ee fe ff
	ff		 je	 $LN1091@PyEval_Eva

; 2880 :                 }
; 2881 :                 while (--kwdefaults >= 0) {

  02b97	41 ff cf	 dec	 r15d
  02b9a	78 35		 js	 SHORT $LN95@PyEval_Eva
  02b9c	0f 1f 40 00	 npad	 4
$LL96@PyEval_Eva:

; 2882 :                     w = POP(); /* default value */

  02ba0	49 8b 5c 24 f8	 mov	 rbx, QWORD PTR [r12-8]

; 2883 :                     u = POP(); /* kw only arg name */

  02ba5	49 8b 7c 24 f0	 mov	 rdi, QWORD PTR [r12-16]
  02baa	49 83 ec 10	 sub	 r12, 16

; 2884 :                     /* XXX(nnorwitz): check for errors */
; 2885 :                     PyDict_SetItem(v, u, w);

  02bae	48 8b d7	 mov	 rdx, rdi
  02bb1	4c 8b c3	 mov	 r8, rbx
  02bb4	48 8b ce	 mov	 rcx, rsi
  02bb7	e8 00 00 00 00	 call	 PyDict_SetItem

; 2886 :                     Py_DECREF(w);

  02bbc	48 8b cb	 mov	 rcx, rbx
  02bbf	e8 00 00 00 00	 call	 _Py_DecRef

; 2887 :                     Py_DECREF(u);

  02bc4	48 8b cf	 mov	 rcx, rdi
  02bc7	e8 00 00 00 00	 call	 _Py_DecRef
  02bcc	41 ff cf	 dec	 r15d
  02bcf	79 cf		 jns	 SHORT $LL96@PyEval_Eva
$LN95@PyEval_Eva:

; 2888 :                 }
; 2889 :                 if (PyFunction_SetKwDefaults(x, v) != 0) {

  02bd1	4c 8b 7d c7	 mov	 r15, QWORD PTR tmp$1$[rbp-153]
  02bd5	48 8b d6	 mov	 rdx, rsi
  02bd8	49 8b cf	 mov	 rcx, r15
  02bdb	e8 00 00 00 00	 call	 PyFunction_SetKwDefaults

; 2890 :                     /* Can't happen unless
; 2891 :                        PyFunction_SetKwDefaults changes. */
; 2892 :                     why = WHY_EXCEPTION;
; 2893 :                 }
; 2894 :                 Py_DECREF(v);

  02be0	48 8b ce	 mov	 rcx, rsi
  02be3	85 c0		 test	 eax, eax
  02be5	b8 02 00 00 00	 mov	 eax, 2
  02bea	44 0f 45 e8	 cmovne	 r13d, eax
  02bee	44 89 6d 77	 mov	 DWORD PTR why$1$[rbp-153], r13d
  02bf2	e8 00 00 00 00	 call	 _Py_DecRef

; 2895 :             }
; 2896 :             PUSH(x);
; 2897 :             break;

  02bf7	4c 8b 75 67	 mov	 r14, QWORD PTR f$[rbp-153]
  02bfb	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02bff	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02c03	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02c06	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  02c0a	49 83 c4 08	 add	 r12, 8
  02c0e	33 f6		 xor	 esi, esi
  02c10	e9 fb f5 ff ff	 jmp	 $LN1052@PyEval_Eva
$LN964@PyEval_Eva:
  02c15	4c 8b 75 67	 mov	 r14, QWORD PTR f$[rbp-153]
  02c19	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02c1d	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02c21	49 89 3c 24	 mov	 QWORD PTR [r12], rdi
  02c25	49 83 c4 08	 add	 r12, 8
  02c29	4c 8b ff	 mov	 r15, rdi
  02c2c	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02c2f	33 f6		 xor	 esi, esi
  02c31	e9 da f5 ff ff	 jmp	 $LN1052@PyEval_Eva
$LN965@PyEval_Eva:

; 2816 : 
; 2817 :             if (x != NULL && opcode == MAKE_CLOSURE) {

  02c36	4c 8b 7d c7	 mov	 r15, QWORD PTR tmp$1$[rbp-153]

; 2895 :             }
; 2896 :             PUSH(x);
; 2897 :             break;

  02c3a	4c 8b 75 67	 mov	 r14, QWORD PTR f$[rbp-153]
  02c3e	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02c42	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02c46	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02c49	4d 89 3c 24	 mov	 QWORD PTR [r12], r15
  02c4d	49 83 c4 08	 add	 r12, 8
  02c51	33 f6		 xor	 esi, esi
  02c53	e9 b8 f5 ff ff	 jmp	 $LN1052@PyEval_Eva
$LN93@PyEval_Eva:

; 2898 :         }
; 2899 : 
; 2900 :         TARGET(BUILD_SLICE)
; 2901 :             if (oparg == 3)

  02c58	83 fe 03	 cmp	 esi, 3
  02c5b	75 0b		 jne	 SHORT $LN92@PyEval_Eva

; 2902 :                 w = POP();

  02c5d	49 8b 74 24 f8	 mov	 rsi, QWORD PTR [r12-8]
  02c62	49 83 ec 08	 sub	 r12, 8

; 2903 :             else

  02c66	eb 02		 jmp	 SHORT $LN91@PyEval_Eva
$LN92@PyEval_Eva:

; 2904 :                 w = NULL;

  02c68	33 f6		 xor	 esi, esi
$LN91@PyEval_Eva:

; 2905 :             v = POP();

  02c6a	49 8b 7c 24 f8	 mov	 rdi, QWORD PTR [r12-8]

; 2906 :             u = TOP();

  02c6f	49 8b 5c 24 f0	 mov	 rbx, QWORD PTR [r12-16]
  02c74	49 83 ec 08	 sub	 r12, 8

; 2907 :             x = PySlice_New(u, v, w);

  02c78	48 8b d7	 mov	 rdx, rdi
  02c7b	48 8b cb	 mov	 rcx, rbx
  02c7e	4c 8b c6	 mov	 r8, rsi
  02c81	e8 00 00 00 00	 call	 PySlice_New

; 2908 :             Py_DECREF(u);

  02c86	48 8b cb	 mov	 rcx, rbx
  02c89	4c 8b f8	 mov	 r15, rax
  02c8c	e8 00 00 00 00	 call	 _Py_DecRef

; 2909 :             Py_DECREF(v);

  02c91	48 8b cf	 mov	 rcx, rdi
  02c94	e8 00 00 00 00	 call	 _Py_DecRef

; 2910 :             Py_XDECREF(w);

  02c99	48 85 f6	 test	 rsi, rsi
  02c9c	74 65		 je	 SHORT $LN89@PyEval_Eva
  02c9e	e8 00 00 00 00	 call	 _Py_PXCTX
  02ca3	85 c0		 test	 eax, eax
  02ca5	75 5c		 jne	 SHORT $LN89@PyEval_Eva
  02ca7	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  02cab	a8 20		 test	 al, 32			; 00000020H
  02cad	75 4c		 jne	 SHORT $LN714@PyEval_Eva
  02caf	84 c0		 test	 al, al
  02cb1	78 48		 js	 SHORT $LN714@PyEval_Eva
  02cb3	a8 02		 test	 al, 2
  02cb5	75 4c		 jne	 SHORT $LN89@PyEval_Eva
  02cb7	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  02cbb	75 46		 jne	 SHORT $LN89@PyEval_Eva
  02cbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  02cc4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  02ccb	4c 8b ce	 mov	 r9, rsi
  02cce	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  02cd4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  02cdc	e8 00 00 00 00	 call	 _PyParallel_Guard
  02ce1	48 8b ce	 mov	 rcx, rsi
  02ce4	85 c0		 test	 eax, eax
  02ce6	74 07		 je	 SHORT $LN719@PyEval_Eva
  02ce8	e8 00 00 00 00	 call	 _Px_Dealloc
  02ced	eb 14		 jmp	 SHORT $LN89@PyEval_Eva
$LN719@PyEval_Eva:
  02cef	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  02cf3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  02cf9	eb 08		 jmp	 SHORT $LN89@PyEval_Eva
$LN714@PyEval_Eva:
  02cfb	48 8b ce	 mov	 rcx, rsi
  02cfe	e8 00 00 00 00	 call	 Px_DecRef
$LN89@PyEval_Eva:

; 2911 :             SET_TOP(x);
; 2912 :             if (x != NULL) DISPATCH();

  02d03	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02d07	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02d0b	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02d0e	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  02d12	4d 89 7c 24 f8	 mov	 QWORD PTR [r12-8], r15
  02d17	be 00 00 00 00	 mov	 esi, 0
  02d1c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  02d23	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  02d2a	4d 85 ff	 test	 r15, r15
  02d2d	0f 85 c6 d4 ff
	ff		 jne	 $LN937@PyEval_Eva
  02d33	e9 e6 f4 ff ff	 jmp	 $LN1011@PyEval_Eva
$LN974@PyEval_Eva:

; 3069 :                 why = WHY_NOT;
; 3070 :                 JUMPTO(b->b_handler);

  02d38	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
  02d3c	33 f6		 xor	 esi, esi
  02d3e	e9 cd f4 ff ff	 jmp	 $LN1052@PyEval_Eva
$LN994@PyEval_Eva:

; 1854 :             Py_XDECREF(x);

  02d43	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02d47	e9 d2 f4 ff ff	 jmp	 $LN1011@PyEval_Eva
$LN83@PyEval_Eva:

; 2962 :         }
; 2963 : 
; 2964 :         /* Double-check exception status */
; 2965 : 
; 2966 :         if (why == WHY_EXCEPTION || why == WHY_RERAISE) {

  02d4c	8b 7d 77	 mov	 edi, DWORD PTR why$1$[rbp-153]
  02d4f	83 ff 02	 cmp	 edi, 2
  02d52	0f 84 f6 f4 ff
	ff		 je	 $LN1019@PyEval_Eva
  02d58	83 ff 04	 cmp	 edi, 4
  02d5b	0f 84 ed f4 ff
	ff		 je	 $LN1019@PyEval_Eva
$LN79@PyEval_Eva:

; 2971 :             }
; 2972 :         }
; 2973 : #ifdef CHECKEXC
; 2974 :         else {
; 2975 :             /* This check is expensive! */
; 2976 :             if (PyErr_Occurred()) {
; 2977 :                 char buf[128];
; 2978 :                 sprintf(buf, "Stack unwind with exception "
; 2979 :                     "set and why=%d", why);
; 2980 :                 Py_FatalError(buf);
; 2981 :             }
; 2982 :         }
; 2983 : #endif
; 2984 : 
; 2985 :         /* Log traceback info if this is a real exception */
; 2986 : 
; 2987 :         if (why == WHY_EXCEPTION) {

  02d61	83 ff 02	 cmp	 edi, 2
  02d64	75 56		 jne	 SHORT $LN77@PyEval_Eva
$LN875@PyEval_Eva:

; 2988 :             PyTraceBack_Here(f);

  02d66	49 8b ce	 mov	 rcx, r14
  02d69	e8 00 00 00 00	 call	 PyTraceBack_Here

; 2989 : 
; 2990 :             if (tstate->c_tracefunc != NULL)

  02d6e	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  02d72	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  02d76	48 85 c9	 test	 rcx, rcx
  02d79	74 53		 je	 SHORT $LN808@PyEval_Eva

; 2991 :                 call_exc_trace(tstate->c_tracefunc,
; 2992 :                                tstate->c_traceobj, f);

  02d7b	49 8b 55 40	 mov	 rdx, QWORD PTR [r13+64]
  02d7f	4d 8b c6	 mov	 r8, r14
  02d82	e8 00 00 00 00	 call	 call_exc_trace

; 2993 :         }
; 2994 : 
; 2995 :         /* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */
; 2996 : 
; 2997 :         if (why == WHY_RERAISE)

  02d87	eb 45		 jmp	 SHORT $LN808@PyEval_Eva
$LN84@PyEval_Eva:

; 2919 : 
; 2920 : #if USE_COMPUTED_GOTOS
; 2921 :         _unknown_opcode:
; 2922 : #endif
; 2923 :         default:
; 2924 :             fprintf(stderr,
; 2925 :                 "XXX lineno: %d, opcode: %d\n",
; 2926 :                 PyFrame_GetLineNumber(f),
; 2927 :                 opcode);

  02d89	49 8b ce	 mov	 rcx, r14
  02d8c	e8 00 00 00 00	 call	 PyFrame_GetLineNumber
  02d91	8b d8		 mov	 ebx, eax
  02d93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  02d99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@
  02da0	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  02da4	45 8b cd	 mov	 r9d, r13d
  02da7	44 8b c3	 mov	 r8d, ebx
  02daa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 2928 :             PyErr_SetString(PyExc_SystemError, "unknown opcode");

  02db0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@

; 2929 :             why = WHY_EXCEPTION;

  02db7	e9 b1 e4 ff ff	 jmp	 $LN1056@PyEval_Eva
$LN77@PyEval_Eva:

; 2993 :         }
; 2994 : 
; 2995 :         /* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */
; 2996 : 
; 2997 :         if (why == WHY_RERAISE)

  02dbc	83 ff 04	 cmp	 edi, 4
  02dbf	b8 02 00 00 00	 mov	 eax, 2
  02dc4	0f 44 f8	 cmove	 edi, eax
$LN1042@PyEval_Eva:
  02dc7	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
$LN1047@PyEval_Eva:
  02dcb	89 7d 77	 mov	 DWORD PTR why$1$[rbp-153], edi
$LN808@PyEval_Eva:

; 2998 :             why = WHY_EXCEPTION;
; 2999 : 
; 3000 :         /* Unwind stacks if a (pseudo) exception occurred */
; 3001 : 
; 3002 : fast_block_end:
; 3003 :         while (why != WHY_NOT && f->f_iblock > 0) {

  02dce	48 63 f7	 movsxd	 rsi, edi
$fast_block_end$64690:
  02dd1	48 83 fe 01	 cmp	 rsi, 1
  02dd5	0f 84 e2 02 00
	00		 je	 $LN74@PyEval_Eva
  02ddb	41 8b 86 d8 00
	00 00		 mov	 eax, DWORD PTR [r14+216]
  02de2	85 c0		 test	 eax, eax
  02de4	0f 8e d3 02 00
	00		 jle	 $LN74@PyEval_Eva

; 3004 :             /* Peek at the current block. */
; 3005 :             PyTryBlock *b = &f->f_blockstack[f->f_iblock - 1];

  02dea	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  02ded	48 63 c1	 movsxd	 rax, ecx
  02df0	48 8d 1c 40	 lea	 rbx, QWORD PTR [rax+rax*2]

; 3006 : 
; 3007 :             assert(why != WHY_YIELD);
; 3008 :             if (b->b_type == SETUP_LOOP && why == WHY_CONTINUE) {

  02df4	41 83 bc 9e dc
	00 00 00 78	 cmp	 DWORD PTR [r14+rbx*4+220], 120 ; 00000078H
  02dfd	75 0a		 jne	 SHORT $LN73@PyEval_Eva
  02dff	48 83 fe 20	 cmp	 rsi, 32			; 00000020H
  02e03	0f 84 d2 01 00
	00		 je	 $LN817@PyEval_Eva
$LN73@PyEval_Eva:

; 3013 :             }
; 3014 :             /* Now we have to pop the block. */
; 3015 :             f->f_iblock--;

  02e09	41 89 8e d8 00
	00 00		 mov	 DWORD PTR [r14+216], ecx

; 3016 : 
; 3017 :             if (b->b_type == EXCEPT_HANDLER) {

  02e10	41 81 bc 9e dc
	00 00 00 01 01
	00 00		 cmp	 DWORD PTR [r14+rbx*4+220], 257 ; 00000101H
  02e1c	0f 85 a5 00 00
	00		 jne	 $LN811@PyEval_Eva

; 3018 :                 UNWIND_EXCEPT_HANDLER(b);

  02e22	41 8b 84 9e e4
	00 00 00	 mov	 eax, DWORD PTR [r14+rbx*4+228]
  02e2a	49 8b cc	 mov	 rcx, r12
  02e2d	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  02e34	83 c0 03	 add	 eax, 3
  02e37	48 c1 f9 03	 sar	 rcx, 3
  02e3b	3b c8		 cmp	 ecx, eax
  02e3d	7e 31		 jle	 SHORT $LN70@PyEval_Eva
  02e3f	90		 npad	 1
$LL71@PyEval_Eva:
  02e40	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  02e45	49 83 ec 08	 sub	 r12, 8
  02e49	48 85 c9	 test	 rcx, rcx
  02e4c	74 05		 je	 SHORT $LN68@PyEval_Eva
  02e4e	e8 00 00 00 00	 call	 _Py_DecRef
$LN68@PyEval_Eva:
  02e53	41 8b 84 9e e4
	00 00 00	 mov	 eax, DWORD PTR [r14+rbx*4+228]
  02e5b	49 8b cc	 mov	 rcx, r12
  02e5e	49 2b 8e 98 00
	00 00		 sub	 rcx, QWORD PTR [r14+152]
  02e65	83 c0 03	 add	 eax, 3
  02e68	48 c1 f9 03	 sar	 rcx, 3
  02e6c	3b c8		 cmp	 ecx, eax
  02e6e	7f d0		 jg	 SHORT $LL71@PyEval_Eva
$LN70@PyEval_Eva:
  02e70	49 8b 44 24 f8	 mov	 rax, QWORD PTR [r12-8]
  02e75	49 8b 4d 60	 mov	 rcx, QWORD PTR [r13+96]
  02e79	49 8b 5d 68	 mov	 rbx, QWORD PTR [r13+104]
  02e7d	49 8b 7d 70	 mov	 rdi, QWORD PTR [r13+112]
  02e81	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  02e85	49 8b 44 24 f0	 mov	 rax, QWORD PTR [r12-16]
  02e8a	49 83 ec 18	 sub	 r12, 24
  02e8e	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  02e92	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  02e96	49 89 45 70	 mov	 QWORD PTR [r13+112], rax
  02e9a	48 85 c9	 test	 rcx, rcx
  02e9d	74 05		 je	 SHORT $LN64@PyEval_Eva
  02e9f	e8 00 00 00 00	 call	 _Py_DecRef
$LN64@PyEval_Eva:
  02ea4	48 85 db	 test	 rbx, rbx
  02ea7	74 08		 je	 SHORT $LN60@PyEval_Eva
  02ea9	48 8b cb	 mov	 rcx, rbx
  02eac	e8 00 00 00 00	 call	 _Py_DecRef
$LN60@PyEval_Eva:
  02eb1	48 85 ff	 test	 rdi, rdi
  02eb4	0f 84 17 ff ff
	ff		 je	 $fast_block_end$64690
  02eba	48 8b cf	 mov	 rcx, rdi
  02ebd	e8 00 00 00 00	 call	 _Py_DecRef

; 3019 :                 continue;

  02ec2	e9 0a ff ff ff	 jmp	 $fast_block_end$64690
$LN811@PyEval_Eva:

; 3020 :             }
; 3021 :             UNWIND_BLOCK(b);

  02ec7	49 8b c4	 mov	 rax, r12
  02eca	49 2b 86 98 00
	00 00		 sub	 rax, QWORD PTR [r14+152]
  02ed1	48 c1 f8 03	 sar	 rax, 3
  02ed5	41 3b 84 9e e4
	00 00 00	 cmp	 eax, DWORD PTR [r14+rbx*4+228]
  02edd	7e 2c		 jle	 SHORT $LN52@PyEval_Eva
  02edf	90		 npad	 1
$LL53@PyEval_Eva:
  02ee0	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  02ee5	49 83 ec 08	 sub	 r12, 8
  02ee9	48 85 c9	 test	 rcx, rcx
  02eec	74 05		 je	 SHORT $LN50@PyEval_Eva
  02eee	e8 00 00 00 00	 call	 _Py_DecRef
$LN50@PyEval_Eva:
  02ef3	49 8b c4	 mov	 rax, r12
  02ef6	49 2b 86 98 00
	00 00		 sub	 rax, QWORD PTR [r14+152]
  02efd	48 c1 f8 03	 sar	 rax, 3
  02f01	41 3b 84 9e e4
	00 00 00	 cmp	 eax, DWORD PTR [r14+rbx*4+228]
  02f09	7f d5		 jg	 SHORT $LL53@PyEval_Eva
$LN52@PyEval_Eva:

; 3022 :             if (b->b_type == SETUP_LOOP && why == WHY_BREAK) {

  02f0b	41 8b 84 9e dc
	00 00 00	 mov	 eax, DWORD PTR [r14+rbx*4+220]
  02f13	83 f8 78	 cmp	 eax, 120		; 00000078H
  02f16	75 0a		 jne	 SHORT $LN47@PyEval_Eva
  02f18	48 83 fe 10	 cmp	 rsi, 16
  02f1c	0f 84 97 00 00
	00		 je	 $LN818@PyEval_Eva
$LN47@PyEval_Eva:

; 3023 :                 why = WHY_NOT;
; 3024 :                 JUMPTO(b->b_handler);
; 3025 :                 break;
; 3026 :             }
; 3027 :             if (why == WHY_EXCEPTION && (b->b_type == SETUP_EXCEPT
; 3028 :                 || b->b_type == SETUP_FINALLY)) {

  02f22	48 83 fe 02	 cmp	 rsi, 2
  02f26	75 64		 jne	 SHORT $LN46@PyEval_Eva
  02f28	83 f8 79	 cmp	 eax, 121		; 00000079H
  02f2b	74 09		 je	 SHORT $LN45@PyEval_Eva
  02f2d	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  02f30	0f 85 9b fe ff
	ff		 jne	 $fast_block_end$64690
$LN45@PyEval_Eva:

; 3029 :                 PyObject *exc, *val, *tb;
; 3030 :                 int handler = b->b_handler;

  02f36	49 63 9c 9e e0
	00 00 00	 movsxd	 rbx, DWORD PTR [r14+rbx*4+224]

; 3031 :                 /* Beware, this invalidates all b->b_* fields */
; 3032 :                 PyFrame_BlockSetup(f, EXCEPT_HANDLER, -1, STACK_LEVEL());

  02f3e	4d 8b cc	 mov	 r9, r12
  02f41	41 83 c8 ff	 or	 r8d, -1
  02f45	4d 2b 8e 98 00
	00 00		 sub	 r9, QWORD PTR [r14+152]
  02f4c	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  02f51	49 8b ce	 mov	 rcx, r14
  02f54	49 c1 f9 03	 sar	 r9, 3
  02f58	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 3033 :                 PUSH(tstate->exc_traceback);

  02f5d	49 8b 45 70	 mov	 rax, QWORD PTR [r13+112]

; 3037 :                 }
; 3038 :                 else {

  02f61	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  02f68	49 89 04 24	 mov	 QWORD PTR [r12], rax
  02f6c	49 8b 45 68	 mov	 rax, QWORD PTR [r13+104]
  02f70	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax
  02f75	49 8b 45 60	 mov	 rax, QWORD PTR [r13+96]
  02f79	48 85 c0	 test	 rax, rax
  02f7c	0f 84 88 00 00
	00		 je	 $LN44@PyEval_Eva

; 3034 :                 PUSH(tstate->exc_value);
; 3035 :                 if (tstate->exc_type != NULL) {
; 3036 :                     PUSH(tstate->exc_type);

  02f82	49 89 44 24 10	 mov	 QWORD PTR [r12+16], rax

; 3037 :                 }
; 3038 :                 else {

  02f87	e9 8b 00 00 00	 jmp	 $LN1058@PyEval_Eva
$LN46@PyEval_Eva:

; 3064 :             }
; 3065 :             if (b->b_type == SETUP_FINALLY) {

  02f8c	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  02f8f	0f 85 3c fe ff
	ff		 jne	 $fast_block_end$64690

; 3066 :                 if (why & (WHY_RETURN | WHY_CONTINUE))

  02f95	8b 45 77	 mov	 eax, DWORD PTR why$1$[rbp-153]
  02f98	a8 28		 test	 al, 40			; 00000028H
  02f9a	74 0d		 je	 SHORT $LN40@PyEval_Eva

; 3067 :                     PUSH(retval);

  02f9c	48 8b 4d bf	 mov	 rcx, QWORD PTR retval$1$[rbp-153]
  02fa0	49 83 c4 08	 add	 r12, 8
  02fa4	49 89 4c 24 f8	 mov	 QWORD PTR [r12-8], rcx
$LN40@PyEval_Eva:

; 3068 :                 PUSH(PyLong_FromLong((long)why));

  02fa9	8b c8		 mov	 ecx, eax
  02fab	e8 00 00 00 00	 call	 PyLong_FromLong
  02fb0	49 83 c4 08	 add	 r12, 8
  02fb4	49 89 44 24 f8	 mov	 QWORD PTR [r12-8], rax
$LN818@PyEval_Eva:

; 3069 :                 why = WHY_NOT;
; 3070 :                 JUMPTO(b->b_handler);

  02fb9	49 63 84 9e e0
	00 00 00	 movsxd	 rax, DWORD PTR [r14+rbx*4+224]
  02fc1	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]

; 3071 :                 break;
; 3072 :             }
; 3073 :         } /* unwind stack */
; 3074 : 
; 3075 :         /* End the loop if we still have an error (or return) */
; 3076 : 
; 3077 :         if (why != WHY_NOT)

  02fc5	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  02fc8	48 03 c2	 add	 rax, rdx
  02fcb	c7 45 77 01 00
	00 00		 mov	 DWORD PTR why$1$[rbp-153], 1
  02fd2	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  02fd6	e9 f5 00 00 00	 jmp	 $LN1026@PyEval_Eva
$LN817@PyEval_Eva:

; 3009 :                 why = WHY_NOT;
; 3010 :                 JUMPTO(PyLong_AS_LONG(retval));

  02fdb	48 8b 5d bf	 mov	 rbx, QWORD PTR retval$1$[rbp-153]
  02fdf	c7 45 77 01 00
	00 00		 mov	 DWORD PTR why$1$[rbp-153], 1
  02fe6	48 8b cb	 mov	 rcx, rbx
  02fe9	e8 00 00 00 00	 call	 PyLong_AsLong

; 3011 :                 Py_DECREF(retval);

  02fee	48 8b cb	 mov	 rcx, rbx
  02ff1	4c 63 e8	 movsxd	 r13, eax
  02ff4	4c 03 6d af	 add	 r13, QWORD PTR first_instr$1$[rbp-153]
  02ff8	4c 89 6d 97	 mov	 QWORD PTR next_instr$1$[rbp-153], r13
  02ffc	e8 00 00 00 00	 call	 _Py_DecRef

; 3012 :                 break;

  03001	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  03005	e9 bb 00 00 00	 jmp	 $LN1040@PyEval_Eva
$LN44@PyEval_Eva:

; 3039 :                     Py_INCREF(Py_None);

  0300a	48 8b cf	 mov	 rcx, rdi
  0300d	e8 00 00 00 00	 call	 _Py_IncRef

; 3040 :                     PUSH(Py_None);

  03012	49 89 7c 24 10	 mov	 QWORD PTR [r12+16], rdi
$LN1058@PyEval_Eva:

; 3041 :                 }
; 3042 :                 PyErr_Fetch(&exc, &val, &tb);

  03017	4c 8d 45 cf	 lea	 r8, QWORD PTR tb$65382[rbp-153]
  0301b	48 8d 55 d7	 lea	 rdx, QWORD PTR val$65381[rbp-153]
  0301f	48 8d 4d f7	 lea	 rcx, QWORD PTR exc$65380[rbp-153]
  03023	49 83 c4 18	 add	 r12, 24
  03027	e8 00 00 00 00	 call	 PyErr_Fetch

; 3043 :                 /* Make the raw exception data
; 3044 :                    available to the handler,
; 3045 :                    so a program can emulate the
; 3046 :                    Python main loop. */
; 3047 :                 PyErr_NormalizeException(
; 3048 :                     &exc, &val, &tb);

  0302c	4c 8d 45 cf	 lea	 r8, QWORD PTR tb$65382[rbp-153]
  03030	48 8d 55 d7	 lea	 rdx, QWORD PTR val$65381[rbp-153]
  03034	48 8d 4d f7	 lea	 rcx, QWORD PTR exc$65380[rbp-153]
  03038	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 3049 :                 PyException_SetTraceback(val, tb);

  0303d	48 8b 55 cf	 mov	 rdx, QWORD PTR tb$65382[rbp-153]
  03041	48 8b 4d d7	 mov	 rcx, QWORD PTR val$65381[rbp-153]
  03045	e8 00 00 00 00	 call	 PyException_SetTraceback

; 3050 :                 Py_INCREF(exc);

  0304a	48 8b 4d f7	 mov	 rcx, QWORD PTR exc$65380[rbp-153]
  0304e	e8 00 00 00 00	 call	 _Py_IncRef

; 3051 :                 tstate->exc_type = exc;

  03053	4c 8b 5d f7	 mov	 r11, QWORD PTR exc$65380[rbp-153]

; 3052 :                 Py_INCREF(val);

  03057	48 8b 4d d7	 mov	 rcx, QWORD PTR val$65381[rbp-153]
  0305b	4d 89 5d 60	 mov	 QWORD PTR [r13+96], r11
  0305f	e8 00 00 00 00	 call	 _Py_IncRef

; 3053 :                 tstate->exc_value = val;
; 3054 :                 tstate->exc_traceback = tb;

  03064	48 8b 45 cf	 mov	 rax, QWORD PTR tb$65382[rbp-153]
  03068	4c 8b 5d d7	 mov	 r11, QWORD PTR val$65381[rbp-153]

; 3055 :                 if (tb == NULL)

  0306c	48 85 c0	 test	 rax, rax
  0306f	48 8b cf	 mov	 rcx, rdi
  03072	48 0f 45 c8	 cmovne	 rcx, rax
  03076	4d 89 5d 68	 mov	 QWORD PTR [r13+104], r11
  0307a	49 89 45 70	 mov	 QWORD PTR [r13+112], rax
  0307e	48 89 4d cf	 mov	 QWORD PTR tb$65382[rbp-153], rcx

; 3056 :                     tb = Py_None;
; 3057 :                 Py_INCREF(tb);

  03082	e8 00 00 00 00	 call	 _Py_IncRef

; 3058 :                 PUSH(tb);
; 3059 :                 PUSH(val);

  03087	48 8b 45 d7	 mov	 rax, QWORD PTR val$65381[rbp-153]
  0308b	4c 8b 5d cf	 mov	 r11, QWORD PTR tb$65382[rbp-153]

; 3060 :                 PUSH(exc);
; 3061 :                 why = WHY_NOT;
; 3062 :                 JUMPTO(handler);

  0308f	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]

; 3063 :                 break;

  03093	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
  03096	4d 89 1c 24	 mov	 QWORD PTR [r12], r11
  0309a	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax
  0309f	48 8b 45 f7	 mov	 rax, QWORD PTR exc$65380[rbp-153]
  030a3	49 89 44 24 10	 mov	 QWORD PTR [r12+16], rax
  030a8	48 8d 04 1a	 lea	 rax, QWORD PTR [rdx+rbx]
  030ac	49 83 c4 18	 add	 r12, 24
  030b0	48 89 45 97	 mov	 QWORD PTR next_instr$1$[rbp-153], rax
  030b4	c7 45 77 01 00
	00 00		 mov	 DWORD PTR why$1$[rbp-153], 1
  030bb	eb 13		 jmp	 SHORT $LN1026@PyEval_Eva
$LN74@PyEval_Eva:

; 3071 :                 break;
; 3072 :             }
; 3073 :         } /* unwind stack */
; 3074 : 
; 3075 :         /* End the loop if we still have an error (or return) */
; 3076 : 
; 3077 :         if (why != WHY_NOT)

  030bd	8b 7d 77	 mov	 edi, DWORD PTR why$1$[rbp-153]
  030c0	83 ff 01	 cmp	 edi, 1
  030c3	75 5d		 jne	 SHORT $LN820@PyEval_Eva
$LN1040@PyEval_Eva:

; 3078 :             break;
; 3079 :         READ_TIMESTAMP(loop1);
; 3080 : 
; 3081 :     } /* main loop */

  030c5	8b 7d 7f	 mov	 edi, DWORD PTR err$1$[rbp-153]
$LN1090@PyEval_Eva:
  030c8	48 8b 45 97	 mov	 rax, QWORD PTR next_instr$1$[rbp-153]
$LN1025@PyEval_Eva:
  030cc	48 8b 55 af	 mov	 rdx, QWORD PTR first_instr$1$[rbp-153]
$LN1026@PyEval_Eva:
  030d0	33 f6		 xor	 esi, esi
$LN1035@PyEval_Eva:
  030d2	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  030d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  030dd	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:_Py_FalseStruct
  030e4	e9 14 d1 ff ff	 jmp	 $LN531@PyEval_Eva
$LN962@PyEval_Eva:

; 2564 : 
; 2565 :         PREDICTED_WITH_ARG(FOR_ITER);

  030e9	4c 8b 4d a7	 mov	 r9, QWORD PTR consts$1$[rbp-153]
  030ed	e9 07 d1 ff ff	 jmp	 $LN937@PyEval_Eva
$LN386@PyEval_Eva:

; 1916 :             }
; 1917 :             /* x remains on stack, retval is value to be yielded */
; 1918 :             f->f_stacktop = stack_pointer;
; 1919 :             why = WHY_YIELD;
; 1920 :             /* and repeat... */
; 1921 :             f->f_lasti--;

  030f2	41 ff 8e d0 00
	00 00		 dec	 DWORD PTR [r14+208]
  030f9	4d 89 a6 a0 00
	00 00		 mov	 QWORD PTR [r14+160], r12
  03100	bf 40 00 00 00	 mov	 edi, 64			; 00000040H

; 1922 :             goto fast_yield;

  03105	33 db		 xor	 ebx, ebx
  03107	eb 6c		 jmp	 SHORT $fast_yield$64709
$LN384@PyEval_Eva:

; 1923 : 
; 1924 :         TARGET(YIELD_VALUE)
; 1925 :             retval = POP();

  03109	49 8b 74 24 f8	 mov	 rsi, QWORD PTR [r12-8]
  0310e	49 83 ec 08	 sub	 r12, 8

; 1926 :             f->f_stacktop = stack_pointer;
; 1927 :             why = WHY_YIELD;

  03112	bf 40 00 00 00	 mov	 edi, 64			; 00000040H
  03117	4d 89 a6 a0 00
	00 00		 mov	 QWORD PTR [r14+160], r12

; 1928 :             goto fast_yield;

  0311e	33 db		 xor	 ebx, ebx
  03120	eb 53		 jmp	 SHORT $fast_yield$64709
$LN820@PyEval_Eva:

; 3082 : 
; 3083 :     assert(why != WHY_YIELD);
; 3084 :     /* Pop remaining stack entries. */
; 3085 :     while (!EMPTY()) {

  03122	49 8b c4	 mov	 rax, r12
  03125	49 2b 86 98 00
	00 00		 sub	 rax, QWORD PTR [r14+152]
  0312c	48 c1 f8 03	 sar	 rax, 3
  03130	85 c0		 test	 eax, eax
  03132	74 31		 je	 SHORT $LN37@PyEval_Eva
  03134	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL38@PyEval_Eva:

; 3086 :         v = POP();

  03140	49 8b 4c 24 f8	 mov	 rcx, QWORD PTR [r12-8]
  03145	49 83 ec 08	 sub	 r12, 8

; 3087 :         Py_XDECREF(v);

  03149	48 85 c9	 test	 rcx, rcx
  0314c	74 05		 je	 SHORT $LN35@PyEval_Eva
  0314e	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@PyEval_Eva:

; 3082 : 
; 3083 :     assert(why != WHY_YIELD);
; 3084 :     /* Pop remaining stack entries. */
; 3085 :     while (!EMPTY()) {

  03153	49 8b c4	 mov	 rax, r12
  03156	49 2b 86 98 00
	00 00		 sub	 rax, QWORD PTR [r14+152]
  0315d	48 c1 f8 03	 sar	 rax, 3
  03161	85 c0		 test	 eax, eax
  03163	75 db		 jne	 SHORT $LL38@PyEval_Eva
$LN37@PyEval_Eva:

; 3088 :     }
; 3089 : 
; 3090 :     if (why != WHY_RETURN)

  03165	48 8b 75 bf	 mov	 rsi, QWORD PTR retval$1$[rbp-153]
  03169	83 ff 08	 cmp	 edi, 8
  0316c	bb 00 00 00 00	 mov	 ebx, 0
  03171	48 0f 45 f3	 cmovne	 rsi, rbx
$fast_yield$64709:

; 3091 :         retval = NULL;
; 3092 : 
; 3093 : fast_yield:
; 3094 :     if (co->co_flags & CO_GENERATOR && (why == WHY_YIELD || why == WHY_RETURN)) {

  03175	48 8b 45 df	 mov	 rax, QWORD PTR co$1$[rbp-153]
  03179	4c 8b bc 24 c0
	00 00 00	 mov	 r15, QWORD PTR [rsp+192]
  03181	4c 8b a4 24 c8
	00 00 00	 mov	 r12, QWORD PTR [rsp+200]
  03189	f6 40 70 20	 test	 BYTE PTR [rax+112], 32	; 00000020H
  0318d	74 4f		 je	 SHORT $LN1004@PyEval_Eva
  0318f	83 ff 40	 cmp	 edi, 64			; 00000040H
  03192	74 05		 je	 SHORT $LN30@PyEval_Eva
  03194	83 ff 08	 cmp	 edi, 8
  03197	75 45		 jne	 SHORT $LN1004@PyEval_Eva
$LN30@PyEval_Eva:

; 3095 :         /* The purpose of this block is to put aside the generator's exception
; 3096 :            state and restore that of the calling frame. If the current
; 3097 :            exception state is from the caller, we clear the exception values
; 3098 :            on the generator frame, so they are not swapped back in latter. The
; 3099 :            origin of the current exception state is determined by checking for
; 3100 :            except handler blocks, which we must be in iff a new exception
; 3101 :            state came into existence in this frame. (An uncaught exception
; 3102 :            would have why == WHY_EXCEPTION, and we wouldn't be here). */
; 3103 :         int i;
; 3104 :         for (i = 0; i < f->f_iblock; i++)

  03199	41 8b 96 d8 00
	00 00		 mov	 edx, DWORD PTR [r14+216]
  031a0	8b c3		 mov	 eax, ebx
  031a2	85 d2		 test	 edx, edx
  031a4	7e 1c		 jle	 SHORT $LN963@PyEval_Eva
  031a6	49 8d 8e dc 00
	00 00		 lea	 rcx, QWORD PTR [r14+220]
  031ad	0f 1f 00	 npad	 3
$LL29@PyEval_Eva:

; 3105 :             if (f->f_blockstack[i].b_type == EXCEPT_HANDLER)

  031b0	81 39 01 01 00
	00		 cmp	 DWORD PTR [rcx], 257	; 00000101H
  031b6	74 0a		 je	 SHORT $LN963@PyEval_Eva

; 3095 :         /* The purpose of this block is to put aside the generator's exception
; 3096 :            state and restore that of the calling frame. If the current
; 3097 :            exception state is from the caller, we clear the exception values
; 3098 :            on the generator frame, so they are not swapped back in latter. The
; 3099 :            origin of the current exception state is determined by checking for
; 3100 :            except handler blocks, which we must be in iff a new exception
; 3101 :            state came into existence in this frame. (An uncaught exception
; 3102 :            would have why == WHY_EXCEPTION, and we wouldn't be here). */
; 3103 :         int i;
; 3104 :         for (i = 0; i < f->f_iblock; i++)

  031b8	ff c0		 inc	 eax
  031ba	48 83 c1 0c	 add	 rcx, 12
  031be	3b c2		 cmp	 eax, edx
  031c0	7c ee		 jl	 SHORT $LL29@PyEval_Eva
$LN963@PyEval_Eva:

; 3106 :                 break;
; 3107 :         if (i == f->f_iblock)
; 3108 :             /* We did not create this exception. */
; 3109 :             restore_and_clear_exc_state(tstate, f);

  031c2	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
  031c6	3b c2		 cmp	 eax, edx
  031c8	49 8b d6	 mov	 rdx, r14
  031cb	49 8b cd	 mov	 rcx, r13
  031ce	75 07		 jne	 SHORT $LN25@PyEval_Eva
  031d0	e8 00 00 00 00	 call	 restore_and_clear_exc_state

; 3110 :         else

  031d5	eb 0b		 jmp	 SHORT $LN24@PyEval_Eva
$LN25@PyEval_Eva:

; 3111 :             swap_exc_state(tstate, f);

  031d7	e8 00 00 00 00	 call	 swap_exc_state
  031dc	eb 04		 jmp	 SHORT $LN24@PyEval_Eva
$LN1004@PyEval_Eva:

; 851  :     PyThreadState *tstate = PyThreadState_GET();

  031de	4c 8b 6d 9f	 mov	 r13, QWORD PTR tstate$1$[rbp-153]
$LN24@PyEval_Eva:

; 3112 :     }
; 3113 : 
; 3114 :     if (tstate->use_tracing) {

  031e2	41 83 7d 24 00	 cmp	 DWORD PTR [r13+36], 0
  031e7	0f 84 f4 00 00
	00		 je	 $LN6@PyEval_Eva

; 3115 :         if (tstate->c_tracefunc) {

  031ed	49 8b 4d 30	 mov	 rcx, QWORD PTR [r13+48]
  031f1	48 85 c9	 test	 rcx, rcx
  031f4	74 7e		 je	 SHORT $LN19@PyEval_Eva

; 3116 :             if (why == WHY_RETURN || why == WHY_YIELD) {

  031f6	83 ff 08	 cmp	 edi, 8
  031f9	74 21		 je	 SHORT $LN20@PyEval_Eva
  031fb	83 ff 40	 cmp	 edi, 64			; 00000040H
  031fe	74 1c		 je	 SHORT $LN20@PyEval_Eva

; 3122 :                 }
; 3123 :             }
; 3124 :             else if (why == WHY_EXCEPTION) {

  03200	83 ff 02	 cmp	 edi, 2
  03203	75 6f		 jne	 SHORT $LN19@PyEval_Eva

; 3125 :                 call_trace_protected(tstate->c_tracefunc,
; 3126 :                                      tstate->c_traceobj, f,
; 3127 :                                      PyTrace_RETURN, NULL);

  03205	49 8b 55 40	 mov	 rdx, QWORD PTR [r13+64]
  03209	44 8d 4f 01	 lea	 r9d, QWORD PTR [rdi+1]
  0320d	4d 8b c6	 mov	 r8, r14
  03210	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  03215	e8 00 00 00 00	 call	 call_trace_protected
  0321a	eb 58		 jmp	 SHORT $LN19@PyEval_Eva
$LN20@PyEval_Eva:

; 3117 :                 if (call_trace(tstate->c_tracefunc,
; 3118 :                                tstate->c_traceobj, f,
; 3119 :                                PyTrace_RETURN, retval)) {

  0321c	49 8b 55 40	 mov	 rdx, QWORD PTR [r13+64]
  03220	41 b9 03 00 00
	00		 mov	 r9d, 3
  03226	4d 8b c6	 mov	 r8, r14
  03229	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0322e	e8 00 00 00 00	 call	 call_trace
  03233	85 c0		 test	 eax, eax
  03235	74 3d		 je	 SHORT $LN19@PyEval_Eva

; 3120 :                     Py_CLEAR(retval);

  03237	48 85 f6	 test	 rsi, rsi
  0323a	74 33		 je	 SHORT $LN17@PyEval_Eva
  0323c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  03243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
  0324a	4c 8b ce	 mov	 r9, rsi
  0324d	41 b8 30 0c 00
	00		 mov	 r8d, 3120		; 00000c30H
  03253	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0325b	e8 00 00 00 00	 call	 _PyParallel_Guard
  03260	85 c0		 test	 eax, eax
  03262	75 0b		 jne	 SHORT $LN17@PyEval_Eva
  03264	48 8b ce	 mov	 rcx, rsi
  03267	48 8b f3	 mov	 rsi, rbx
  0326a	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@PyEval_Eva:

; 3121 :                     why = WHY_EXCEPTION;

  0326f	bf 02 00 00 00	 mov	 edi, 2
$LN19@PyEval_Eva:

; 3128 :             }
; 3129 :         }
; 3130 :         if (tstate->c_profilefunc) {

  03274	49 8b 4d 28	 mov	 rcx, QWORD PTR [r13+40]
  03278	48 85 c9	 test	 rcx, rcx
  0327b	74 64		 je	 SHORT $LN6@PyEval_Eva

; 3131 :             if (why == WHY_EXCEPTION)
; 3132 :                 call_trace_protected(tstate->c_profilefunc,
; 3133 :                                      tstate->c_profileobj, f,
; 3134 :                                      PyTrace_RETURN, NULL);

  0327d	49 8b 55 38	 mov	 rdx, QWORD PTR [r13+56]
  03281	41 b9 03 00 00
	00		 mov	 r9d, 3
  03287	4d 8b c6	 mov	 r8, r14
  0328a	83 ff 02	 cmp	 edi, 2
  0328d	75 0c		 jne	 SHORT $LN11@PyEval_Eva
  0328f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  03294	e8 00 00 00 00	 call	 call_trace_protected

; 3135 :             else if (call_trace(tstate->c_profilefunc,

  03299	eb 46		 jmp	 SHORT $LN6@PyEval_Eva
$LN11@PyEval_Eva:

; 3136 :                                 tstate->c_profileobj, f,
; 3137 :                                 PyTrace_RETURN, retval)) {

  0329b	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  032a0	e8 00 00 00 00	 call	 call_trace
  032a5	85 c0		 test	 eax, eax
  032a7	74 38		 je	 SHORT $LN6@PyEval_Eva

; 3138 :                 Py_CLEAR(retval);

  032a9	48 85 f6	 test	 rsi, rsi
  032ac	74 33		 je	 SHORT $LN6@PyEval_Eva
  032ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  032b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
  032bc	4c 8b ce	 mov	 r9, rsi
  032bf	41 b8 42 0c 00
	00		 mov	 r8d, 3138		; 00000c42H
  032c5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  032cd	e8 00 00 00 00	 call	 _PyParallel_Guard
  032d2	85 c0		 test	 eax, eax
  032d4	75 0b		 jne	 SHORT $LN6@PyEval_Eva
  032d6	48 8b ce	 mov	 rcx, rsi
  032d9	48 8b f3	 mov	 rsi, rbx
  032dc	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@PyEval_Eva:
  032e1	48 8b bc 24 08
	01 00 00	 mov	 rdi, QWORD PTR [rsp+264]
$exit_eval_frame$64383:

; 3139 :                 /* why = WHY_EXCEPTION; */
; 3140 :             }
; 3141 :         }
; 3142 :     }
; 3143 : 
; 3144 :     /* pop frame */
; 3145 : exit_eval_frame:
; 3146 :     Py_LeaveRecursiveCall();

  032e9	e8 00 00 00 00	 call	 _Py_PXCTX
  032ee	85 c0		 test	 eax, eax
  032f0	74 0a		 je	 SHORT $LN556@PyEval_Eva
  032f2	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  032f7	4c 8b d8	 mov	 r11, rax
  032fa	eb 07		 jmp	 SHORT $LN557@PyEval_Eva
$LN556@PyEval_Eva:
  032fc	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _PyThreadState_Current
$LN557@PyEval_Eva:
  03303	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  03309	83 f8 64	 cmp	 eax, 100		; 00000064H
  0330c	7e 05		 jle	 SHORT $LN558@PyEval_Eva
  0330e	83 c0 ce	 add	 eax, -50		; ffffffffffffffceH
  03311	eb 06		 jmp	 SHORT $LN559@PyEval_Eva
$LN558@PyEval_Eva:
  03313	c1 f8 02	 sar	 eax, 2
  03316	8d 04 40	 lea	 eax, DWORD PTR [rax+rax*2]
$LN559@PyEval_Eva:
  03319	41 ff 4b 18	 dec	 DWORD PTR [r11+24]
  0331d	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  03321	7d 1b		 jge	 SHORT $LN3@PyEval_Eva
  03323	e8 00 00 00 00	 call	 _Py_PXCTX
  03328	85 c0		 test	 eax, eax
  0332a	74 07		 je	 SHORT $LN560@PyEval_Eva
  0332c	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  03331	eb 07		 jmp	 SHORT $LN561@PyEval_Eva
$LN560@PyEval_Eva:
  03333	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN561@PyEval_Eva:
  0333a	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN3@PyEval_Eva:

; 3147 :     tstate->frame = f->f_back;

  0333e	49 8b 46 70	 mov	 rax, QWORD PTR [r14+112]
  03342	49 89 45 10	 mov	 QWORD PTR [r13+16], rax

; 3148 : 
; 3149 :     return retval;

  03346	48 8b c6	 mov	 rax, rsi

; 3150 : }

  03349	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  03350	41 5e		 pop	 r14
  03352	41 5d		 pop	 r13
  03354	5e		 pop	 rsi
  03355	5b		 pop	 rbx
  03356	5d		 pop	 rbp
  03357	c3		 ret	 0
$LN917@PyEval_Eva:
  03358	00 00 00 00	 DD	 $LN499@PyEval_Eva
  0335c	00 00 00 00	 DD	 $LN498@PyEval_Eva
  03360	00 00 00 00	 DD	 $LN497@PyEval_Eva
  03364	00 00 00 00	 DD	 $LN496@PyEval_Eva
  03368	00 00 00 00	 DD	 $LN495@PyEval_Eva
  0336c	00 00 00 00	 DD	 $LN966@PyEval_Eva
  03370	00 00 00 00	 DD	 $LN494@PyEval_Eva
  03374	00 00 00 00	 DD	 $LN492@PyEval_Eva
  03378	00 00 00 00	 DD	 $LN490@PyEval_Eva
  0337c	00 00 00 00	 DD	 $LN486@PyEval_Eva
  03380	00 00 00 00	 DD	 $LN484@PyEval_Eva
  03384	00 00 00 00	 DD	 $LN482@PyEval_Eva
  03388	00 00 00 00	 DD	 $LN476@PyEval_Eva
  0338c	00 00 00 00	 DD	 $LN472@PyEval_Eva
  03390	00 00 00 00	 DD	 $LN468@PyEval_Eva
  03394	00 00 00 00	 DD	 $LN466@PyEval_Eva
  03398	00 00 00 00	 DD	 $LN478@PyEval_Eva
  0339c	00 00 00 00	 DD	 $LN480@PyEval_Eva
  033a0	00 00 00 00	 DD	 $LN442@PyEval_Eva
  033a4	00 00 00 00	 DD	 $LN444@PyEval_Eva
  033a8	00 00 00 00	 DD	 $LN226@PyEval_Eva
  033ac	00 00 00 00	 DD	 $LN438@PyEval_Eva
  033b0	00 00 00 00	 DD	 $LN434@PyEval_Eva
  033b4	00 00 00 00	 DD	 $LN446@PyEval_Eva
  033b8	00 00 00 00	 DD	 $LN440@PyEval_Eva
  033bc	00 00 00 00	 DD	 $LN422@PyEval_Eva
  033c0	00 00 00 00	 DD	 $LN420@PyEval_Eva
  033c4	00 00 00 00	 DD	 $LN464@PyEval_Eva
  033c8	00 00 00 00	 DD	 $LN462@PyEval_Eva
  033cc	00 00 00 00	 DD	 $LN460@PyEval_Eva
  033d0	00 00 00 00	 DD	 $LN458@PyEval_Eva
  033d4	00 00 00 00	 DD	 $LN456@PyEval_Eva
  033d8	00 00 00 00	 DD	 $LN448@PyEval_Eva
  033dc	00 00 00 00	 DD	 $LN161@PyEval_Eva
  033e0	00 00 00 00	 DD	 $LN397@PyEval_Eva
  033e4	00 00 00 00	 DD	 $LN418@PyEval_Eva
  033e8	00 00 00 00	 DD	 $LN329@PyEval_Eva
  033ec	00 00 00 00	 DD	 $LN391@PyEval_Eva
  033f0	00 00 00 00	 DD	 $LN432@PyEval_Eva
  033f4	00 00 00 00	 DD	 $LN430@PyEval_Eva
  033f8	00 00 00 00	 DD	 $LN428@PyEval_Eva
  033fc	00 00 00 00	 DD	 $LN426@PyEval_Eva
  03400	00 00 00 00	 DD	 $LN424@PyEval_Eva
  03404	00 00 00 00	 DD	 $LN152@PyEval_Eva
  03408	00 00 00 00	 DD	 $LN141@PyEval_Eva
  0340c	00 00 00 00	 DD	 $LN392@PyEval_Eva
  03410	00 00 00 00	 DD	 $LN203@PyEval_Eva
  03414	00 00 00 00	 DD	 $LN384@PyEval_Eva
  03418	00 00 00 00	 DD	 $LN363@PyEval_Eva
  0341c	00 00 00 00	 DD	 $LN1020@PyEval_Eva
  03420	00 00 00 00	 DD	 $LN383@PyEval_Eva
  03424	00 00 00 00	 DD	 $LN321@PyEval_Eva
  03428	00 00 00 00	 DD	 $LN315@PyEval_Eva
  0342c	00 00 00 00	 DD	 $LN312@PyEval_Eva
  03430	00 00 00 00	 DD	 $LN158@PyEval_Eva
  03434	00 00 00 00	 DD	 $LN301@PyEval_Eva
  03438	00 00 00 00	 DD	 $LN298@PyEval_Eva
  0343c	00 00 00 00	 DD	 $LN296@PyEval_Eva
  03440	00 00 00 00	 DD	 $LN295@PyEval_Eva
  03444	00 00 00 00	 DD	 $LN293@PyEval_Eva
  03448	00 00 00 00	 DD	 $LN508@PyEval_Eva
  0344c	00 00 00 00	 DD	 $LN291@PyEval_Eva
  03450	00 00 00 00	 DD	 $LN242@PyEval_Eva
  03454	00 00 00 00	 DD	 $LN238@PyEval_Eva
  03458	00 00 00 00	 DD	 $LN234@PyEval_Eva
  0345c	00 00 00 00	 DD	 $LN228@PyEval_Eva
  03460	00 00 00 00	 DD	 $LN221@PyEval_Eva
  03464	00 00 00 00	 DD	 $LN219@PyEval_Eva
  03468	00 00 00 00	 DD	 $LN214@PyEval_Eva
  0346c	00 00 00 00	 DD	 $LN196@PyEval_Eva
  03470	00 00 00 00	 DD	 $LN191@PyEval_Eva
  03474	00 00 00 00	 DD	 $LN176@PyEval_Eva
  03478	00 00 00 00	 DD	 $LN169@PyEval_Eva
  0347c	00 00 00 00	 DD	 $LN162@PyEval_Eva
  03480	00 00 00 00	 DD	 $LN972@PyEval_Eva
  03484	00 00 00 00	 DD	 $LN971@PyEval_Eva
  03488	00 00 00 00	 DD	 $LN268@PyEval_Eva
  0348c	00 00 00 00	 DD	 $LN151@PyEval_Eva
  03490	00 00 00 00	 DD	 $_setup_finally$65159
  03494	00 00 00 00	 DD	 $LN510@PyEval_Eva
  03498	00 00 00 00	 DD	 $LN970@PyEval_Eva
  0349c	00 00 00 00	 DD	 $LN258@PyEval_Eva
  034a0	00 00 00 00	 DD	 $LN404@PyEval_Eva
  034a4	00 00 00 00	 DD	 $LN125@PyEval_Eva
  034a8	00 00 00 00	 DD	 $_make_function$65251
  034ac	00 00 00 00	 DD	 $LN93@PyEval_Eva
  034b0	00 00 00 00	 DD	 $LN247@PyEval_Eva
  034b4	00 00 00 00	 DD	 $LN245@PyEval_Eva
  034b8	00 00 00 00	 DD	 $LN243@PyEval_Eva
  034bc	00 00 00 00	 DD	 $LN249@PyEval_Eva
  034c0	00 00 00 00	 DD	 $_call_function_var_kw$65219
  034c4	00 00 00 00	 DD	 $LN145@PyEval_Eva
  034c8	00 00 00 00	 DD	 $LN85@PyEval_Eva
  034cc	00 00 00 00	 DD	 $LN454@PyEval_Eva
  034d0	00 00 00 00	 DD	 $LN451@PyEval_Eva
  034d4	00 00 00 00	 DD	 $LN224@PyEval_Eva
  034d8	00 00 00 00	 DD	 $LN84@PyEval_Eva
$LN916@PyEval_Eva:
  034dc	00		 DB	 0
  034dd	01		 DB	 1
  034de	02		 DB	 2
  034df	03		 DB	 3
  034e0	04		 DB	 4
  034e1	60		 DB	 96			; 00000060H
  034e2	60		 DB	 96			; 00000060H
  034e3	60		 DB	 96			; 00000060H
  034e4	05		 DB	 5
  034e5	06		 DB	 6
  034e6	07		 DB	 7
  034e7	08		 DB	 8
  034e8	60		 DB	 96			; 00000060H
  034e9	60		 DB	 96			; 00000060H
  034ea	09		 DB	 9
  034eb	60		 DB	 96			; 00000060H
  034ec	60		 DB	 96			; 00000060H
  034ed	60		 DB	 96			; 00000060H
  034ee	0a		 DB	 10
  034ef	0b		 DB	 11
  034f0	60		 DB	 96			; 00000060H
  034f1	0c		 DB	 12
  034f2	0d		 DB	 13
  034f3	0e		 DB	 14
  034f4	0f		 DB	 15
  034f5	10		 DB	 16
  034f6	11		 DB	 17
  034f7	12		 DB	 18
  034f8	13		 DB	 19
  034f9	60		 DB	 96			; 00000060H
  034fa	60		 DB	 96			; 00000060H
  034fb	60		 DB	 96			; 00000060H
  034fc	60		 DB	 96			; 00000060H
  034fd	60		 DB	 96			; 00000060H
  034fe	60		 DB	 96			; 00000060H
  034ff	60		 DB	 96			; 00000060H
  03500	60		 DB	 96			; 00000060H
  03501	60		 DB	 96			; 00000060H
  03502	60		 DB	 96			; 00000060H
  03503	60		 DB	 96			; 00000060H
  03504	60		 DB	 96			; 00000060H
  03505	60		 DB	 96			; 00000060H
  03506	60		 DB	 96			; 00000060H
  03507	60		 DB	 96			; 00000060H
  03508	60		 DB	 96			; 00000060H
  03509	60		 DB	 96			; 00000060H
  0350a	60		 DB	 96			; 00000060H
  0350b	60		 DB	 96			; 00000060H
  0350c	60		 DB	 96			; 00000060H
  0350d	60		 DB	 96			; 00000060H
  0350e	60		 DB	 96			; 00000060H
  0350f	60		 DB	 96			; 00000060H
  03510	60		 DB	 96			; 00000060H
  03511	14		 DB	 20
  03512	15		 DB	 21
  03513	16		 DB	 22
  03514	17		 DB	 23
  03515	60		 DB	 96			; 00000060H
  03516	18		 DB	 24
  03517	19		 DB	 25
  03518	1a		 DB	 26
  03519	1b		 DB	 27
  0351a	1c		 DB	 28
  0351b	1d		 DB	 29
  0351c	1e		 DB	 30
  0351d	1f		 DB	 31
  0351e	20		 DB	 32			; 00000020H
  0351f	21		 DB	 33			; 00000021H
  03520	22		 DB	 34			; 00000022H
  03521	23		 DB	 35			; 00000023H
  03522	24		 DB	 36			; 00000024H
  03523	25		 DB	 37			; 00000025H
  03524	60		 DB	 96			; 00000060H
  03525	60		 DB	 96			; 00000060H
  03526	26		 DB	 38			; 00000026H
  03527	27		 DB	 39			; 00000027H
  03528	28		 DB	 40			; 00000028H
  03529	29		 DB	 41			; 00000029H
  0352a	2a		 DB	 42			; 0000002aH
  0352b	2b		 DB	 43			; 0000002bH
  0352c	2c		 DB	 44			; 0000002cH
  0352d	60		 DB	 96			; 00000060H
  0352e	2d		 DB	 45			; 0000002dH
  0352f	2e		 DB	 46			; 0000002eH
  03530	60		 DB	 96			; 00000060H
  03531	2f		 DB	 47			; 0000002fH
  03532	30		 DB	 48			; 00000030H
  03533	31		 DB	 49			; 00000031H
  03534	32		 DB	 50			; 00000032H
  03535	33		 DB	 51			; 00000033H
  03536	34		 DB	 52			; 00000034H
  03537	35		 DB	 53			; 00000035H
  03538	36		 DB	 54			; 00000036H
  03539	37		 DB	 55			; 00000037H
  0353a	38		 DB	 56			; 00000038H
  0353b	39		 DB	 57			; 00000039H
  0353c	3a		 DB	 58			; 0000003aH
  0353d	3b		 DB	 59			; 0000003bH
  0353e	60		 DB	 96			; 00000060H
  0353f	3c		 DB	 60			; 0000003cH
  03540	3d		 DB	 61			; 0000003dH
  03541	3e		 DB	 62			; 0000003eH
  03542	3f		 DB	 63			; 0000003fH
  03543	40		 DB	 64			; 00000040H
  03544	41		 DB	 65			; 00000041H
  03545	42		 DB	 66			; 00000042H
  03546	43		 DB	 67			; 00000043H
  03547	44		 DB	 68			; 00000044H
  03548	45		 DB	 69			; 00000045H
  03549	46		 DB	 70			; 00000046H
  0354a	47		 DB	 71			; 00000047H
  0354b	48		 DB	 72			; 00000048H
  0354c	49		 DB	 73			; 00000049H
  0354d	4a		 DB	 74			; 0000004aH
  0354e	4b		 DB	 75			; 0000004bH
  0354f	4c		 DB	 76			; 0000004cH
  03550	60		 DB	 96			; 00000060H
  03551	60		 DB	 96			; 00000060H
  03552	4d		 DB	 77			; 0000004dH
  03553	4e		 DB	 78			; 0000004eH
  03554	4e		 DB	 78			; 0000004eH
  03555	4e		 DB	 78			; 0000004eH
  03556	60		 DB	 96			; 00000060H
  03557	4f		 DB	 79			; 0000004fH
  03558	50		 DB	 80			; 00000050H
  03559	51		 DB	 81			; 00000051H
  0355a	60		 DB	 96			; 00000060H
  0355b	60		 DB	 96			; 00000060H
  0355c	60		 DB	 96			; 00000060H
  0355d	52		 DB	 82			; 00000052H
  0355e	53		 DB	 83			; 00000053H
  0355f	54		 DB	 84			; 00000054H
  03560	55		 DB	 85			; 00000055H
  03561	54		 DB	 84			; 00000054H
  03562	56		 DB	 86			; 00000056H
  03563	57		 DB	 87			; 00000057H
  03564	58		 DB	 88			; 00000058H
  03565	59		 DB	 89			; 00000059H
  03566	60		 DB	 96			; 00000060H
  03567	5a		 DB	 90			; 0000005aH
  03568	5a		 DB	 90			; 0000005aH
  03569	5a		 DB	 90			; 0000005aH
  0356a	5b		 DB	 91			; 0000005bH
  0356b	5c		 DB	 92			; 0000005cH
  0356c	5d		 DB	 93			; 0000005dH
  0356d	5e		 DB	 94			; 0000005eH
  0356e	5f		 DB	 95			; 0000005fH
PyEval_EvalFrameEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@	; `string'
PUBLIC	??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@ ; `string'
PUBLIC	??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@ ; `string'
PUBLIC	??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@ ; `string'
PUBLIC	??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@ ; `string'
PUBLIC	PyEval_EvalCodeEx
EXTRN	PyGen_New:PROC
EXTRN	PyCell_New:PROC
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyFrame_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyEval_EvalCodeEx DD imagerel $LN307
	DD	imagerel $LN307+3079
	DD	imagerel $unwind$PyEval_EvalCodeEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalCodeEx DD 0ac001H
	DD	016d4c0H
	DD	0f00fb213H
	DD	0c00be00dH
	DD	060087009H
	DD	030065007H
xdata	ENDS
;	COMDAT ??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@
CONST	SEGMENT
??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@ DB 'PyEval_EvalCodeEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@
CONST	SEGMENT
??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@ DB '%U'
	DB	'() keywords must be strings', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@
CONST	SEGMENT
??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@ DB '%U'
	DB	'() got an unexpected keyword argument ''%S''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@
CONST	SEGMENT
??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@ DB '%U'
	DB	'() got multiple values for argument ''%S''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@
CONST	SEGMENT
??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@ DB 'PyEval_Eva'
	DB	'lCodeEx: NULL globals', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\ceval.c
CONST	ENDS
;	COMDAT PyEval_EvalCodeEx
_TEXT	SEGMENT
i$2$ = 48
f$1$ = 56
fastlocals$1$ = 64
kwdict$1$ = 72
tstate$1$ = 80
freevars$1$ = 88
_co$ = 160
total_args$1$ = 168
globals$ = 168
locals$ = 176
args$ = 184
argcount$ = 192
kws$ = 200
kwcount$ = 208
defs$ = 216
defcount$ = 224
kwdefs$ = 232
closure$ = 240
PyEval_EvalCodeEx PROC					; COMDAT

; 3310 : {

$LN307:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	4d 8b f1	 mov	 r14, r9
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b da	 mov	 rbx, rdx
  0001c	48 8b e9	 mov	 rbp, rcx

; 3311 :     PyCodeObject* co = (PyCodeObject*)_co;
; 3312 :     register PyFrameObject *f;
; 3313 :     register PyObject *retval = NULL;

  0001f	33 f6		 xor	 esi, esi

; 3314 :     register PyObject **fastlocals, **freevars;
; 3315 :     PyThreadState *tstate = PyThreadState_GET();

  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	85 c0		 test	 eax, eax
  00028	74 07		 je	 SHORT $LN126@PyEval_Eva@2
  0002a	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0002f	eb 07		 jmp	 SHORT $LN300@PyEval_Eva@2
$LN126@PyEval_Eva@2:
  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN300@PyEval_Eva@2:

; 3316 :     PyObject *x, *u;
; 3317 :     int total_args = co->co_argcount + co->co_kwonlyargcount;

  00038	44 8b 65 60	 mov	 r12d, DWORD PTR [rbp+96]

; 3318 :     int i;
; 3319 :     int n = argcount;

  0003c	4c 63 bc 24 c0
	00 00 00	 movsxd	 r15, DWORD PTR argcount$[rsp]
  00044	48 89 44 24 50	 mov	 QWORD PTR tstate$1$[rsp], rax
  00049	44 03 65 64	 add	 r12d, DWORD PTR [rbp+100]

; 3320 :     PyObject *kwdict = NULL;

  0004d	48 89 74 24 48	 mov	 QWORD PTR kwdict$1$[rsp], rsi
  00052	44 89 a4 24 a8
	00 00 00	 mov	 DWORD PTR total_args$1$[rsp], r12d

; 3321 : 
; 3322 :     if (globals == NULL) {

  0005a	48 85 db	 test	 rbx, rbx
  0005d	75 24		 jne	 SHORT $LN123@PyEval_Eva@2

; 3323 :         PyErr_SetString(PyExc_SystemError,
; 3324 :                         "PyEval_EvalCodeEx: NULL globals");

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@
  0006d	e8 00 00 00 00	 call	 PyErr_SetString
$LN304@PyEval_Eva@2:

; 3325 :         return NULL;

  00072	33 c0		 xor	 eax, eax

; 3518 : }

  00074	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00078	41 5f		 pop	 r15
  0007a	41 5e		 pop	 r14
  0007c	41 5c		 pop	 r12
  0007e	5f		 pop	 rdi
  0007f	5e		 pop	 rsi
  00080	5d		 pop	 rbp
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$LN123@PyEval_Eva@2:

; 3326 :     }
; 3327 : 
; 3328 :     assert(tstate != NULL);
; 3329 :     assert(globals != NULL);
; 3330 :     f = PyFrame_New(tstate, co, globals, locals);

  00083	4c 8b cf	 mov	 r9, rdi
  00086	4c 8b c3	 mov	 r8, rbx
  00089	48 8b d5	 mov	 rdx, rbp
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 PyFrame_New
  00094	48 8b d8	 mov	 rbx, rax
  00097	48 89 44 24 38	 mov	 QWORD PTR f$1$[rsp], rax

; 3331 :     if (f == NULL)

  0009c	48 85 c0	 test	 rax, rax

; 3332 :         return NULL;

  0009f	74 d1		 je	 SHORT $LN304@PyEval_Eva@2

; 3333 : 
; 3334 :     fastlocals = f->f_localsplus;
; 3335 :     freevars = f->f_localsplus + co->co_nlocals;
; 3336 : 
; 3337 :     /* Parse arguments. */
; 3338 :     if (co->co_flags & CO_VARKEYWORDS) {

  000a1	f6 45 70 08	 test	 BYTE PTR [rbp+112], 8
  000a5	48 8d b8 d0 01
	00 00		 lea	 rdi, QWORD PTR [rax+464]
  000ac	48 63 45 68	 movsxd	 rax, DWORD PTR [rbp+104]
  000b0	48 8d 84 c3 d0
	01 00 00	 lea	 rax, QWORD PTR [rbx+rax*8+464]
  000b8	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  000c0	48 89 7c 24 40	 mov	 QWORD PTR fastlocals$1$[rsp], rdi
  000c5	48 89 44 24 58	 mov	 QWORD PTR freevars$1$[rsp], rax
  000ca	0f 84 96 00 00
	00		 je	 $LN116@PyEval_Eva@2

; 3339 :         kwdict = PyDict_New();

  000d0	e8 00 00 00 00	 call	 PyDict_New
  000d5	48 89 44 24 48	 mov	 QWORD PTR kwdict$1$[rsp], rax

; 3340 :         if (kwdict == NULL)

  000da	48 85 c0	 test	 rax, rax
  000dd	0f 84 46 05 00
	00		 je	 $LN298@PyEval_Eva@2

; 3341 :             goto fail;
; 3342 :         i = total_args;
; 3343 :         if (co->co_flags & CO_VARARGS)

  000e3	f6 45 70 04	 test	 BYTE PTR [rbp+112], 4
  000e7	41 8b cc	 mov	 ecx, r12d
  000ea	74 05		 je	 SHORT $LN118@PyEval_Eva@2

; 3344 :             i++;

  000ec	41 8d 4c 24 01	 lea	 ecx, DWORD PTR [r12+1]
$LN118@PyEval_Eva@2:

; 3345 :         SETLOCAL(i, kwdict);

  000f1	48 63 c9	 movsxd	 rcx, ecx
  000f4	48 8b 1c cf	 mov	 rbx, QWORD PTR [rdi+rcx*8]
  000f8	48 89 04 cf	 mov	 QWORD PTR [rdi+rcx*8], rax
  000fc	48 85 db	 test	 rbx, rbx
  000ff	74 65		 je	 SHORT $LN116@PyEval_Eva@2
  00101	e8 00 00 00 00	 call	 _Py_PXCTX
  00106	85 c0		 test	 eax, eax
  00108	75 5c		 jne	 SHORT $LN116@PyEval_Eva@2
  0010a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0010e	a8 20		 test	 al, 32			; 00000020H
  00110	75 4c		 jne	 SHORT $LN132@PyEval_Eva@2
  00112	84 c0		 test	 al, al
  00114	78 48		 js	 SHORT $LN132@PyEval_Eva@2
  00116	a8 02		 test	 al, 2
  00118	75 4c		 jne	 SHORT $LN116@PyEval_Eva@2
  0011a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0011e	75 46		 jne	 SHORT $LN116@PyEval_Eva@2
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0012e	4c 8b cb	 mov	 r9, rbx
  00131	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00137	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0013f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00144	48 8b cb	 mov	 rcx, rbx
  00147	85 c0		 test	 eax, eax
  00149	74 07		 je	 SHORT $LN137@PyEval_Eva@2
  0014b	e8 00 00 00 00	 call	 _Px_Dealloc
  00150	eb 14		 jmp	 SHORT $LN116@PyEval_Eva@2
$LN137@PyEval_Eva@2:
  00152	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00156	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0015c	eb 08		 jmp	 SHORT $LN116@PyEval_Eva@2
$LN132@PyEval_Eva@2:
  0015e	48 8b cb	 mov	 rcx, rbx
  00161	e8 00 00 00 00	 call	 Px_DecRef
$LN116@PyEval_Eva@2:

; 3346 :     }
; 3347 :     if (argcount > co->co_argcount)

  00166	8b 45 60	 mov	 eax, DWORD PTR [rbp+96]
  00169	41 8b cf	 mov	 ecx, r15d
  0016c	44 3b f8	 cmp	 r15d, eax
  0016f	0f 4f c8	 cmovg	 ecx, eax
  00172	89 4c 24 30	 mov	 DWORD PTR i$2$[rsp], ecx

; 3348 :         n = co->co_argcount;
; 3349 :     for (i = 0; i < n; i++) {

  00176	4c 63 e9	 movsxd	 r13, ecx
  00179	85 c9		 test	 ecx, ecx
  0017b	0f 8e e4 00 00
	00		 jle	 $LN108@PyEval_Eva@2
  00181	4d 8b e6	 mov	 r12, r14

; 3350 :         x = args[i];

  00184	48 8b f7	 mov	 rsi, rdi
  00187	49 8b ed	 mov	 rbp, r13
  0018a	4c 2b e7	 sub	 r12, rdi
  0018d	0f 1f 00	 npad	 3
$LL110@PyEval_Eva@2:
  00190	49 8b 3c 34	 mov	 rdi, QWORD PTR [r12+rsi]

; 3351 :         Py_INCREF(x);

  00194	e8 00 00 00 00	 call	 _Py_PXCTX
  00199	85 c0		 test	 eax, eax
  0019b	75 32		 jne	 SHORT $LN107@PyEval_Eva@2
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001ab	4c 8b cf	 mov	 r9, rdi
  001ae	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001b4	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c1	85 c0		 test	 eax, eax
  001c3	75 06		 jne	 SHORT $LN139@PyEval_Eva@2
  001c5	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001c9	74 04		 je	 SHORT $LN107@PyEval_Eva@2
$LN139@PyEval_Eva@2:
  001cb	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN107@PyEval_Eva@2:

; 3352 :         SETLOCAL(i, x);

  001cf	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  001d2	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  001d5	48 85 db	 test	 rbx, rbx
  001d8	74 65		 je	 SHORT $LN103@PyEval_Eva@2
  001da	e8 00 00 00 00	 call	 _Py_PXCTX
  001df	85 c0		 test	 eax, eax
  001e1	75 5c		 jne	 SHORT $LN103@PyEval_Eva@2
  001e3	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001e7	a8 20		 test	 al, 32			; 00000020H
  001e9	75 4c		 jne	 SHORT $LN147@PyEval_Eva@2
  001eb	84 c0		 test	 al, al
  001ed	78 48		 js	 SHORT $LN147@PyEval_Eva@2
  001ef	a8 02		 test	 al, 2
  001f1	75 4c		 jne	 SHORT $LN103@PyEval_Eva@2
  001f3	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001f7	75 46		 jne	 SHORT $LN103@PyEval_Eva@2
  001f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00207	4c 8b cb	 mov	 r9, rbx
  0020a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00210	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00218	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021d	48 8b cb	 mov	 rcx, rbx
  00220	85 c0		 test	 eax, eax
  00222	74 07		 je	 SHORT $LN152@PyEval_Eva@2
  00224	e8 00 00 00 00	 call	 _Px_Dealloc
  00229	eb 14		 jmp	 SHORT $LN103@PyEval_Eva@2
$LN152@PyEval_Eva@2:
  0022b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0022f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00235	eb 08		 jmp	 SHORT $LN103@PyEval_Eva@2
$LN147@PyEval_Eva@2:
  00237	48 8b cb	 mov	 rcx, rbx
  0023a	e8 00 00 00 00	 call	 Px_DecRef
$LN103@PyEval_Eva@2:

; 3348 :         n = co->co_argcount;
; 3349 :     for (i = 0; i < n; i++) {

  0023f	48 83 c6 08	 add	 rsi, 8
  00243	48 ff cd	 dec	 rbp
  00246	0f 85 44 ff ff
	ff		 jne	 $LL110@PyEval_Eva@2
  0024c	44 8b a4 24 a8
	00 00 00	 mov	 r12d, DWORD PTR total_args$1$[rsp]
  00254	8b 4c 24 30	 mov	 ecx, DWORD PTR i$2$[rsp]
  00258	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR _co$[rsp]
  00260	48 8b 7c 24 40	 mov	 rdi, QWORD PTR fastlocals$1$[rsp]
$LN108@PyEval_Eva@2:

; 3353 :     }
; 3354 :     if (co->co_flags & CO_VARARGS) {

  00265	f6 45 70 04	 test	 BYTE PTR [rbp+112], 4
  00269	0f 84 04 01 00
	00		 je	 $LN89@PyEval_Eva@2

; 3355 :         u = PyTuple_New(argcount - n);

  0026f	41 8b c7	 mov	 eax, r15d
  00272	2b c1		 sub	 eax, ecx
  00274	48 63 c8	 movsxd	 rcx, eax
  00277	e8 00 00 00 00	 call	 PyTuple_New
  0027c	48 8b e8	 mov	 rbp, rax

; 3356 :         if (u == NULL)

  0027f	48 85 c0	 test	 rax, rax
  00282	0f 84 9c 03 00
	00		 je	 $LN297@PyEval_Eva@2

; 3357 :             goto fail;
; 3358 :         SETLOCAL(total_args, u);

  00288	49 63 cc	 movsxd	 rcx, r12d
  0028b	48 8b 1c cf	 mov	 rbx, QWORD PTR [rdi+rcx*8]
  0028f	48 89 04 cf	 mov	 QWORD PTR [rdi+rcx*8], rax
  00293	48 85 db	 test	 rbx, rbx
  00296	74 65		 je	 SHORT $LN94@PyEval_Eva@2
  00298	e8 00 00 00 00	 call	 _Py_PXCTX
  0029d	85 c0		 test	 eax, eax
  0029f	75 5c		 jne	 SHORT $LN94@PyEval_Eva@2
  002a1	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  002a5	a8 20		 test	 al, 32			; 00000020H
  002a7	75 4c		 jne	 SHORT $LN158@PyEval_Eva@2
  002a9	84 c0		 test	 al, al
  002ab	78 48		 js	 SHORT $LN158@PyEval_Eva@2
  002ad	a8 02		 test	 al, 2
  002af	75 4c		 jne	 SHORT $LN94@PyEval_Eva@2
  002b1	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  002b5	75 46		 jne	 SHORT $LN94@PyEval_Eva@2
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  002c5	4c 8b cb	 mov	 r9, rbx
  002c8	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  002ce	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002d6	e8 00 00 00 00	 call	 _PyParallel_Guard
  002db	48 8b cb	 mov	 rcx, rbx
  002de	85 c0		 test	 eax, eax
  002e0	74 07		 je	 SHORT $LN163@PyEval_Eva@2
  002e2	e8 00 00 00 00	 call	 _Px_Dealloc
  002e7	eb 14		 jmp	 SHORT $LN94@PyEval_Eva@2
$LN163@PyEval_Eva@2:
  002e9	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002ed	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  002f3	eb 08		 jmp	 SHORT $LN94@PyEval_Eva@2
$LN158@PyEval_Eva@2:
  002f5	48 8b cb	 mov	 rcx, rbx
  002f8	e8 00 00 00 00	 call	 Px_DecRef
$LN94@PyEval_Eva@2:

; 3359 :         for (i = n; i < argcount; i++) {

  002fd	49 8b f7	 mov	 rsi, r15
  00300	4d 3b ef	 cmp	 r13, r15
  00303	7d 66		 jge	 SHORT $LN292@PyEval_Eva@2
  00305	b8 0e 00 00 00	 mov	 eax, 14
  0030a	4b 8d 3c ee	 lea	 rdi, QWORD PTR [r14+r13*8]
  0030e	49 2b c5	 sub	 rax, r13
  00311	48 c1 e0 03	 shl	 rax, 3
  00315	49 2b c6	 sub	 rax, r14
  00318	48 03 e8	 add	 rbp, rax
  0031b	49 2b f5	 sub	 rsi, r13
  0031e	66 90		 npad	 2
$LL91@PyEval_Eva@2:

; 3360 :             x = args[i];

  00320	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3361 :             Py_INCREF(x);

  00323	e8 00 00 00 00	 call	 _Py_PXCTX
  00328	85 c0		 test	 eax, eax
  0032a	75 32		 jne	 SHORT $LN166@PyEval_Eva@2
  0032c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0033a	4c 8b cb	 mov	 r9, rbx
  0033d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00343	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0034b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00350	85 c0		 test	 eax, eax
  00352	75 06		 jne	 SHORT $LN165@PyEval_Eva@2
  00354	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00358	74 04		 je	 SHORT $LN166@PyEval_Eva@2
$LN165@PyEval_Eva@2:
  0035a	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN166@PyEval_Eva@2:

; 3362 :             PyTuple_SET_ITEM(u, i-n, x);

  0035e	48 89 1c 2f	 mov	 QWORD PTR [rdi+rbp], rbx
  00362	48 83 c7 08	 add	 rdi, 8
  00366	48 ff ce	 dec	 rsi
  00369	75 b5		 jne	 SHORT $LL91@PyEval_Eva@2
$LN292@PyEval_Eva@2:

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  0036b	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR _co$[rsp]
$LN89@PyEval_Eva@2:
  00373	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR kwcount$[rsp]
  0037b	45 33 db	 xor	 r11d, r11d

; 3379 :         for (j = 0; j < total_args; j++) {

  0037e	4d 63 fc	 movsxd	 r15, r12d
  00381	45 8b f3	 mov	 r14d, r11d
  00384	48 85 c0	 test	 rax, rax
  00387	0f 8e 10 02 00
	00		 jle	 $LN86@PyEval_Eva@2

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  0038d	4c 8b ac 24 c8
	00 00 00	 mov	 r13, QWORD PTR kws$[rsp]
$LL88@PyEval_Eva@2:

; 3366 :         PyObject **co_varnames;
; 3367 :         PyObject *keyword = kws[2*i];

  00395	49 8b 75 00	 mov	 rsi, QWORD PTR [r13]

; 3368 :         PyObject *value = kws[2*i + 1];

  00399	4d 8b 65 08	 mov	 r12, QWORD PTR [r13+8]

; 3369 :         int j;
; 3370 :         if (keyword == NULL || !PyUnicode_Check(keyword)) {

  0039d	48 85 f6	 test	 rsi, rsi
  003a0	0f 84 d8 01 00
	00		 je	 $LN84@PyEval_Eva@2
  003a6	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  003aa	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  003b4	0f 84 c4 01 00
	00		 je	 $LN84@PyEval_Eva@2

; 3375 :         }
; 3376 :         /* Speed hack: do raw pointer compares. As names are
; 3377 :            normally interned this should almost always hit. */
; 3378 :         co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;

  003ba	48 8b ad 90 00
	00 00		 mov	 rbp, QWORD PTR [rbp+144]

; 3379 :         for (j = 0; j < total_args; j++) {

  003c1	49 8b db	 mov	 rbx, r11
  003c4	4d 85 ff	 test	 r15, r15
  003c7	7e 1a		 jle	 SHORT $LN81@PyEval_Eva@2
  003c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL83@PyEval_Eva@2:

; 3380 :             PyObject *nm = co_varnames[j];
; 3381 :             if (nm == keyword)

  003d0	48 39 74 dd 70	 cmp	 QWORD PTR [rbp+rbx*8+112], rsi
  003d5	0f 84 92 00 00
	00		 je	 $kw_found$65696

; 3379 :         for (j = 0; j < total_args; j++) {

  003db	48 ff c3	 inc	 rbx
  003de	49 3b df	 cmp	 rbx, r15
  003e1	7c ed		 jl	 SHORT $LL83@PyEval_Eva@2
$LN81@PyEval_Eva@2:

; 3382 :                 goto kw_found;
; 3383 :         }
; 3384 :         /* Slow fallback, just in case */
; 3385 :         for (j = 0; j < total_args; j++) {

  003e3	41 8b fb	 mov	 edi, r11d
  003e6	49 8b db	 mov	 rbx, r11
  003e9	4d 85 ff	 test	 r15, r15
  003ec	7e 29		 jle	 SHORT $LN77@PyEval_Eva@2
  003ee	66 90		 npad	 2
$LL79@PyEval_Eva@2:

; 3386 :             PyObject *nm = co_varnames[j];
; 3387 :             int cmp = PyObject_RichCompareBool(
; 3388 :                 keyword, nm, Py_EQ);

  003f0	48 8b 54 dd 70	 mov	 rdx, QWORD PTR [rbp+rbx*8+112]
  003f5	41 b8 02 00 00
	00		 mov	 r8d, 2
  003fb	48 8b ce	 mov	 rcx, rsi
  003fe	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 3389 :             if (cmp > 0)

  00403	85 c0		 test	 eax, eax
  00405	7f 66		 jg	 SHORT $kw_found$65696

; 3390 :                 goto kw_found;
; 3391 :             else if (cmp < 0)

  00407	0f 88 17 02 00
	00		 js	 $LN297@PyEval_Eva@2

; 3382 :                 goto kw_found;
; 3383 :         }
; 3384 :         /* Slow fallback, just in case */
; 3385 :         for (j = 0; j < total_args; j++) {

  0040d	48 ff c3	 inc	 rbx
  00410	ff c7		 inc	 edi
  00412	49 3b df	 cmp	 rbx, r15
  00415	7c d9		 jl	 SHORT $LL79@PyEval_Eva@2
$LN77@PyEval_Eva@2:

; 3392 :                 goto fail;
; 3393 :         }
; 3394 :         if (j >= total_args && kwdict == NULL) {

  00417	48 8b 44 24 48	 mov	 rax, QWORD PTR kwdict$1$[rsp]
  0041c	3b bc 24 a8 00
	00 00		 cmp	 edi, DWORD PTR total_args$1$[rsp]
  00423	7c 09		 jl	 SHORT $LN73@PyEval_Eva@2
  00425	48 85 c0	 test	 rax, rax
  00428	0f 84 47 01 00
	00		 je	 $LN277@PyEval_Eva@2
$LN73@PyEval_Eva@2:

; 3401 :         }
; 3402 :         if (PyDict_SetItem(kwdict, keyword, value) == -1) {

  0042e	4d 8b c4	 mov	 r8, r12
  00431	48 8b d6	 mov	 rdx, rsi
  00434	48 8b c8	 mov	 rcx, rax
  00437	e8 00 00 00 00	 call	 PyDict_SetItem
  0043c	83 f8 ff	 cmp	 eax, -1
  0043f	0f 84 df 01 00
	00		 je	 $LN297@PyEval_Eva@2
$LN87@PyEval_Eva@2:

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  00445	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR kwcount$[rsp]
  0044d	49 ff c6	 inc	 r14
  00450	49 83 c5 10	 add	 r13, 16
  00454	45 33 db	 xor	 r11d, r11d
  00457	4c 3b f0	 cmp	 r14, rax
  0045a	0f 8d 3d 01 00
	00		 jge	 $LN86@PyEval_Eva@2
  00460	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR _co$[rsp]
  00468	e9 28 ff ff ff	 jmp	 $LL88@PyEval_Eva@2
$kw_found$65696:

; 3403 :             goto fail;
; 3404 :         }
; 3405 :         continue;
; 3406 :       kw_found:
; 3407 :         if (GETLOCAL(j) != NULL) {

  0046d	48 8b 6c 24 40	 mov	 rbp, QWORD PTR fastlocals$1$[rsp]
  00472	48 83 7c dd 00
	00		 cmp	 QWORD PTR [rbp+rbx*8], 0
  00478	0f 85 cd 00 00
	00		 jne	 $LN276@PyEval_Eva@2

; 3414 :         }
; 3415 :         Py_INCREF(value);

  0047e	e8 00 00 00 00	 call	 _Py_PXCTX
  00483	85 c0		 test	 eax, eax
  00485	75 35		 jne	 SHORT $LN70@PyEval_Eva@2
  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00495	4d 8b cc	 mov	 r9, r12
  00498	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0049e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  004a6	e8 00 00 00 00	 call	 _PyParallel_Guard
  004ab	85 c0		 test	 eax, eax
  004ad	75 08		 jne	 SHORT $LN169@PyEval_Eva@2
  004af	41 f6 44 24 20
	20		 test	 BYTE PTR [r12+32], 32	; 00000020H
  004b5	74 05		 je	 SHORT $LN70@PyEval_Eva@2
$LN169@PyEval_Eva@2:
  004b7	49 ff 44 24 50	 inc	 QWORD PTR [r12+80]
$LN70@PyEval_Eva@2:

; 3416 :         SETLOCAL(j, value);

  004bc	48 8b 7c dd 00	 mov	 rdi, QWORD PTR [rbp+rbx*8]
  004c1	4c 89 64 dd 00	 mov	 QWORD PTR [rbp+rbx*8], r12
  004c6	48 85 ff	 test	 rdi, rdi
  004c9	0f 84 76 ff ff
	ff		 je	 $LN87@PyEval_Eva@2
  004cf	e8 00 00 00 00	 call	 _Py_PXCTX
  004d4	85 c0		 test	 eax, eax
  004d6	0f 85 69 ff ff
	ff		 jne	 $LN87@PyEval_Eva@2
  004dc	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004e0	a8 20		 test	 al, 32			; 00000020H
  004e2	75 5a		 jne	 SHORT $LN177@PyEval_Eva@2
  004e4	84 c0		 test	 al, al
  004e6	78 56		 js	 SHORT $LN177@PyEval_Eva@2
  004e8	a8 02		 test	 al, 2
  004ea	0f 85 55 ff ff
	ff		 jne	 $LN87@PyEval_Eva@2
  004f0	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  004f4	0f 85 4b ff ff
	ff		 jne	 $LN87@PyEval_Eva@2
  004fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00501	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00508	4c 8b cf	 mov	 r9, rdi
  0050b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00511	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00519	e8 00 00 00 00	 call	 _PyParallel_Guard
  0051e	48 8b cf	 mov	 rcx, rdi
  00521	85 c0		 test	 eax, eax
  00523	74 0a		 je	 SHORT $LN182@PyEval_Eva@2
  00525	e8 00 00 00 00	 call	 _Px_Dealloc
  0052a	e9 16 ff ff ff	 jmp	 $LN87@PyEval_Eva@2
$LN182@PyEval_Eva@2:
  0052f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00533	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00539	e9 07 ff ff ff	 jmp	 $LN87@PyEval_Eva@2
$LN177@PyEval_Eva@2:
  0053e	48 8b cf	 mov	 rcx, rdi
  00541	e8 00 00 00 00	 call	 Px_DecRef

; 3417 :     }

  00546	e9 fa fe ff ff	 jmp	 $LN87@PyEval_Eva@2
$LN276@PyEval_Eva@2:

; 3408 :             PyErr_Format(PyExc_TypeError,
; 3409 :                          "%U() got multiple "
; 3410 :                          "values for argument '%S'",
; 3411 :                          co->co_name,
; 3412 :                          keyword);

  0054b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@
$LN305@PyEval_Eva@2:
  00552	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR _co$[rsp]
  0055a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00561	4c 8b ce	 mov	 r9, rsi
  00564	4d 8b 80 b8 00
	00 00		 mov	 r8, QWORD PTR [r8+184]
  0056b	e8 00 00 00 00	 call	 PyErr_Format

; 3413 :             goto fail;

  00570	e9 af 00 00 00	 jmp	 $LN297@PyEval_Eva@2
$LN277@PyEval_Eva@2:

; 3395 :             PyErr_Format(PyExc_TypeError,
; 3396 :                          "%U() got an unexpected "
; 3397 :                          "keyword argument '%S'",
; 3398 :                          co->co_name,
; 3399 :                          keyword);

  00575	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@

; 3400 :             goto fail;

  0057c	eb d4		 jmp	 SHORT $LN305@PyEval_Eva@2
$LN84@PyEval_Eva@2:

; 3371 :             PyErr_Format(PyExc_TypeError,
; 3372 :                          "%U() keywords must be strings",
; 3373 :                          co->co_name);

  0057e	4c 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [rbp+184]
  00585	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0058c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@
  00593	e8 00 00 00 00	 call	 PyErr_Format

; 3374 :             goto fail;

  00598	e9 87 00 00 00	 jmp	 $LN297@PyEval_Eva@2
$LN86@PyEval_Eva@2:

; 3418 :     if (argcount > co->co_argcount && !(co->co_flags & CO_VARARGS)) {

  0059d	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR _co$[rsp]
  005a5	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR argcount$[rsp]
  005ad	41 8b 4e 60	 mov	 ecx, DWORD PTR [r14+96]
  005b1	3b c1		 cmp	 eax, ecx
  005b3	7e 22		 jle	 SHORT $LN301@PyEval_Eva@2
  005b5	41 f6 46 70 04	 test	 BYTE PTR [r14+112], 4
  005ba	75 19		 jne	 SHORT $LN63@PyEval_Eva@2

; 3419 :         too_many_positional(co, argcount, defcount, fastlocals);

  005bc	4c 8b 4c 24 40	 mov	 r9, QWORD PTR fastlocals$1$[rsp]
  005c1	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR defcount$[rsp]
  005c9	8b d0		 mov	 edx, eax
  005cb	49 8b ce	 mov	 rcx, r14
  005ce	e8 00 00 00 00	 call	 too_many_positional

; 3420 :         goto fail;

  005d3	eb 4f		 jmp	 SHORT $LN297@PyEval_Eva@2
$LN63@PyEval_Eva@2:

; 3421 :     }
; 3422 :     if (argcount < co->co_argcount) {

  005d5	3b c1		 cmp	 eax, ecx
$LN301@PyEval_Eva@2:
  005d7	0f 8d ca 01 00
	00		 jge	 $LN52@PyEval_Eva@2

; 3423 :         int m = co->co_argcount - defcount;

  005dd	4c 63 84 24 e0
	00 00 00	 movsxd	 r8, DWORD PTR defcount$[rsp]
  005e5	4c 8b 54 24 40	 mov	 r10, QWORD PTR fastlocals$1$[rsp]

; 3424 :         int missing = 0;

  005ea	41 8b d3	 mov	 edx, r11d
  005ed	41 2b c8	 sub	 ecx, r8d

; 3425 :         for (i = argcount; i < m; i++)

  005f0	4c 63 c9	 movsxd	 r9, ecx
  005f3	49 3b c1	 cmp	 rax, r9
  005f6	0f 8d a6 00 00
	00		 jge	 $LN57@PyEval_Eva@2
  005fc	0f 1f 40 00	 npad	 4
$LL61@PyEval_Eva@2:

; 3426 :             if (GETLOCAL(i) == NULL)

  00600	49 83 3c c2 00	 cmp	 QWORD PTR [r10+rax*8], 0
  00605	75 02		 jne	 SHORT $LN60@PyEval_Eva@2

; 3427 :                 missing++;

  00607	ff c2		 inc	 edx
$LN60@PyEval_Eva@2:

; 3425 :         for (i = argcount; i < m; i++)

  00609	48 ff c0	 inc	 rax
  0060c	49 3b c1	 cmp	 rax, r9
  0060f	7c ef		 jl	 SHORT $LL61@PyEval_Eva@2

; 3428 :         if (missing) {

  00611	85 d2		 test	 edx, edx
  00613	0f 84 89 00 00
	00		 je	 $LN57@PyEval_Eva@2

; 3429 :             missing_arguments(co, missing, defcount, fastlocals);

  00619	4d 8b ca	 mov	 r9, r10
$LN306@PyEval_Eva@2:

; 3462 :             missing_arguments(co, missing, -1, fastlocals);

  0061c	49 8b ce	 mov	 rcx, r14
  0061f	e8 00 00 00 00	 call	 missing_arguments
$LN297@PyEval_Eva@2:

; 3326 :     }
; 3327 : 
; 3328 :     assert(tstate != NULL);
; 3329 :     assert(globals != NULL);
; 3330 :     f = PyFrame_New(tstate, co, globals, locals);

  00624	48 8b 5c 24 38	 mov	 rbx, QWORD PTR f$1$[rsp]
$LN298@PyEval_Eva@2:

; 3502 :     }
; 3503 : 
; 3504 :     retval = PyEval_EvalFrameEx(f,0);

  00629	45 33 ff	 xor	 r15d, r15d
$fail$65636:

; 3505 : 
; 3506 : fail: /* Jump here from prelude on failure */
; 3507 : 
; 3508 :     /* decref'ing the frame can cause __del__ methods to get invoked,
; 3509 :        which can call back into Python.  While we're done with the
; 3510 :        current Python frame (f), the associated C stack is still in use,
; 3511 :        so recursion_depth must be boosted for the duration.
; 3512 :     */
; 3513 :     assert(tstate != NULL);
; 3514 :     ++tstate->recursion_depth;

  0062c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  00631	ff 47 18	 inc	 DWORD PTR [rdi+24]

; 3515 :     Py_DECREF(f);

  00634	e8 00 00 00 00	 call	 _Py_PXCTX
  00639	85 c0		 test	 eax, eax
  0063b	0f 85 a9 05 00
	00		 jne	 $LN261@PyEval_Eva@2
  00641	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00645	f6 c1 20	 test	 cl, 32			; 00000020H
  00648	0f 85 94 05 00
	00		 jne	 $LN255@PyEval_Eva@2
  0064e	84 c9		 test	 cl, cl
  00650	0f 88 8c 05 00
	00		 js	 $LN255@PyEval_Eva@2
  00656	f6 c1 02	 test	 cl, 2
  00659	0f 85 8b 05 00
	00		 jne	 $LN261@PyEval_Eva@2
  0065f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00663	0f 85 81 05 00
	00		 jne	 $LN261@PyEval_Eva@2
  00669	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00677	4c 8b cb	 mov	 r9, rbx
  0067a	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00680	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00688	e8 00 00 00 00	 call	 _PyParallel_Guard
  0068d	48 8b cb	 mov	 rcx, rbx
  00690	85 c0		 test	 eax, eax
  00692	0f 84 3e 05 00
	00		 je	 $LN260@PyEval_Eva@2
  00698	e8 00 00 00 00	 call	 _Px_Dealloc
  0069d	e9 48 05 00 00	 jmp	 $LN261@PyEval_Eva@2
$LN57@PyEval_Eva@2:

; 3430 :             goto fail;
; 3431 :         }
; 3432 :         if (n > m)

  006a2	8b 44 24 30	 mov	 eax, DWORD PTR i$2$[rsp]
  006a6	3b c1		 cmp	 eax, ecx
  006a8	7e 04		 jle	 SHORT $LN56@PyEval_Eva@2

; 3433 :             i = n - m;

  006aa	2b c1		 sub	 eax, ecx

; 3434 :         else

  006ac	eb 03		 jmp	 SHORT $LN55@PyEval_Eva@2
$LN56@PyEval_Eva@2:

; 3435 :             i = 0;

  006ae	41 8b c3	 mov	 eax, r11d
$LN55@PyEval_Eva@2:
  006b1	48 63 c8	 movsxd	 rcx, eax

; 3436 :         for (; i < defcount; i++) {

  006b4	49 8b e8	 mov	 rbp, r8
  006b7	49 3b c8	 cmp	 rcx, r8
  006ba	0f 8d e7 00 00
	00		 jge	 $LN52@PyEval_Eva@2
  006c0	4c 8b a4 24 d8
	00 00 00	 mov	 r12, QWORD PTR defs$[rsp]
  006c8	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  006cc	49 8d 34 c2	 lea	 rsi, QWORD PTR [r10+rax*8]
  006d0	4a 8d 04 cd 00
	00 00 00	 lea	 rax, QWORD PTR [r9*8]
  006d8	4c 2b e0	 sub	 r12, rax
  006db	4d 2b e2	 sub	 r12, r10
  006de	48 2b e9	 sub	 rbp, rcx
$LL54@PyEval_Eva@2:

; 3437 :             if (GETLOCAL(m+i) == NULL) {

  006e1	48 83 3e 00	 cmp	 QWORD PTR [rsi], 0
  006e5	0f 85 af 00 00
	00		 jne	 $LN48@PyEval_Eva@2

; 3438 :                 PyObject *def = defs[i];

  006eb	49 8b 3c 34	 mov	 rdi, QWORD PTR [r12+rsi]

; 3439 :                 Py_INCREF(def);

  006ef	e8 00 00 00 00	 call	 _Py_PXCTX
  006f4	85 c0		 test	 eax, eax
  006f6	75 32		 jne	 SHORT $LN50@PyEval_Eva@2
  006f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00706	4c 8b cf	 mov	 r9, rdi
  00709	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0070f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00717	e8 00 00 00 00	 call	 _PyParallel_Guard
  0071c	85 c0		 test	 eax, eax
  0071e	75 06		 jne	 SHORT $LN184@PyEval_Eva@2
  00720	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00724	74 04		 je	 SHORT $LN50@PyEval_Eva@2
$LN184@PyEval_Eva@2:
  00726	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN50@PyEval_Eva@2:

; 3440 :                 SETLOCAL(m+i, def);

  0072a	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  0072d	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00730	48 85 db	 test	 rbx, rbx
  00733	74 65		 je	 SHORT $LN48@PyEval_Eva@2
  00735	e8 00 00 00 00	 call	 _Py_PXCTX
  0073a	85 c0		 test	 eax, eax
  0073c	75 5c		 jne	 SHORT $LN48@PyEval_Eva@2
  0073e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00742	a8 20		 test	 al, 32			; 00000020H
  00744	75 4c		 jne	 SHORT $LN192@PyEval_Eva@2
  00746	84 c0		 test	 al, al
  00748	78 48		 js	 SHORT $LN192@PyEval_Eva@2
  0074a	a8 02		 test	 al, 2
  0074c	75 4c		 jne	 SHORT $LN48@PyEval_Eva@2
  0074e	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00752	75 46		 jne	 SHORT $LN48@PyEval_Eva@2
  00754	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0075b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00762	4c 8b cb	 mov	 r9, rbx
  00765	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0076b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00773	e8 00 00 00 00	 call	 _PyParallel_Guard
  00778	48 8b cb	 mov	 rcx, rbx
  0077b	85 c0		 test	 eax, eax
  0077d	74 07		 je	 SHORT $LN197@PyEval_Eva@2
  0077f	e8 00 00 00 00	 call	 _Px_Dealloc
  00784	eb 14		 jmp	 SHORT $LN48@PyEval_Eva@2
$LN197@PyEval_Eva@2:
  00786	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0078a	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00790	eb 08		 jmp	 SHORT $LN48@PyEval_Eva@2
$LN192@PyEval_Eva@2:
  00792	48 8b cb	 mov	 rcx, rbx
  00795	e8 00 00 00 00	 call	 Px_DecRef
$LN48@PyEval_Eva@2:

; 3436 :         for (; i < defcount; i++) {

  0079a	48 83 c6 08	 add	 rsi, 8
  0079e	48 ff cd	 dec	 rbp
  007a1	0f 85 3a ff ff
	ff		 jne	 $LL54@PyEval_Eva@2
$LN52@PyEval_Eva@2:

; 3441 :             }
; 3442 :         }
; 3443 :     }
; 3444 :     if (co->co_kwonlyargcount > 0) {

  007a7	41 83 7e 64 00	 cmp	 DWORD PTR [r14+100], 0
  007ac	0f 8e 35 01 00
	00		 jle	 $LN29@PyEval_Eva@2

; 3446 :         for (i = co->co_argcount; i < total_args; i++) {

  007b2	49 63 46 60	 movsxd	 rax, DWORD PTR [r14+96]
  007b6	33 f6		 xor	 esi, esi
  007b8	8b ee		 mov	 ebp, esi
  007ba	49 3b c7	 cmp	 rax, r15
  007bd	0f 8d 24 01 00
	00		 jge	 $LN29@PyEval_Eva@2

; 3445 :         int missing = 0;

  007c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fastlocals$1$[rsp]
  007c8	4c 8b a4 24 e8
	00 00 00	 mov	 r12, QWORD PTR kwdefs$[rsp]

; 3446 :         for (i = co->co_argcount; i < total_args; i++) {

  007d0	41 bd 70 00 00
	00		 mov	 r13d, 112		; 00000070H
  007d6	4c 2b e9	 sub	 r13, rcx
  007d9	48 8d 34 c1	 lea	 rsi, QWORD PTR [rcx+rax*8]
  007dd	4c 2b f8	 sub	 r15, rax
$LL42@PyEval_Eva@2:

; 3447 :             PyObject *name;
; 3448 :             if (GETLOCAL(i) != NULL)

  007e0	48 83 3e 00	 cmp	 QWORD PTR [rsi], 0
  007e4	0f 85 dc 00 00
	00		 jne	 $LN41@PyEval_Eva@2

; 3449 :                 continue;
; 3450 :             name = PyTuple_GET_ITEM(co->co_varnames, i);

  007ea	49 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [r14+144]
  007f1	49 8d 4c 05 00	 lea	 rcx, QWORD PTR [r13+rax]

; 3451 :             if (kwdefs != NULL) {

  007f6	4d 85 e4	 test	 r12, r12
  007f9	0f 84 c5 00 00
	00		 je	 $LN37@PyEval_Eva@2

; 3452 :                 PyObject *def = PyDict_GetItem(kwdefs, name);

  007ff	48 8b 14 31	 mov	 rdx, QWORD PTR [rcx+rsi]
  00803	49 8b cc	 mov	 rcx, r12
  00806	e8 00 00 00 00	 call	 PyDict_GetItem
  0080b	48 8b f8	 mov	 rdi, rax

; 3453 :                 if (def) {

  0080e	48 85 c0	 test	 rax, rax
  00811	0f 84 ad 00 00
	00		 je	 $LN37@PyEval_Eva@2

; 3454 :                     Py_INCREF(def);

  00817	e8 00 00 00 00	 call	 _Py_PXCTX
  0081c	85 c0		 test	 eax, eax
  0081e	75 32		 jne	 SHORT $LN36@PyEval_Eva@2
  00820	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00827	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0082e	4c 8b cf	 mov	 r9, rdi
  00831	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00837	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0083f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00844	85 c0		 test	 eax, eax
  00846	75 06		 jne	 SHORT $LN199@PyEval_Eva@2
  00848	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0084c	74 04		 je	 SHORT $LN36@PyEval_Eva@2
$LN199@PyEval_Eva@2:
  0084e	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN36@PyEval_Eva@2:

; 3455 :                     SETLOCAL(i, def);

  00852	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  00855	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00858	48 85 db	 test	 rbx, rbx
  0085b	74 69		 je	 SHORT $LN41@PyEval_Eva@2
  0085d	e8 00 00 00 00	 call	 _Py_PXCTX
  00862	85 c0		 test	 eax, eax
  00864	75 60		 jne	 SHORT $LN41@PyEval_Eva@2
  00866	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0086a	a8 20		 test	 al, 32			; 00000020H
  0086c	75 4c		 jne	 SHORT $LN207@PyEval_Eva@2
  0086e	84 c0		 test	 al, al
  00870	78 48		 js	 SHORT $LN207@PyEval_Eva@2
  00872	a8 02		 test	 al, 2
  00874	75 50		 jne	 SHORT $LN41@PyEval_Eva@2
  00876	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0087a	75 4a		 jne	 SHORT $LN41@PyEval_Eva@2
  0087c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00883	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0088a	4c 8b cb	 mov	 r9, rbx
  0088d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00893	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0089b	e8 00 00 00 00	 call	 _PyParallel_Guard
  008a0	48 8b cb	 mov	 rcx, rbx
  008a3	85 c0		 test	 eax, eax
  008a5	74 07		 je	 SHORT $LN212@PyEval_Eva@2
  008a7	e8 00 00 00 00	 call	 _Px_Dealloc
  008ac	eb 18		 jmp	 SHORT $LN41@PyEval_Eva@2
$LN212@PyEval_Eva@2:
  008ae	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  008b2	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  008b8	eb 0c		 jmp	 SHORT $LN41@PyEval_Eva@2
$LN207@PyEval_Eva@2:
  008ba	48 8b cb	 mov	 rcx, rbx
  008bd	e8 00 00 00 00	 call	 Px_DecRef

; 3456 :                     continue;

  008c2	eb 02		 jmp	 SHORT $LN41@PyEval_Eva@2
$LN37@PyEval_Eva@2:

; 3457 :                 }
; 3458 :             }
; 3459 :             missing++;

  008c4	ff c5		 inc	 ebp
$LN41@PyEval_Eva@2:

; 3446 :         for (i = co->co_argcount; i < total_args; i++) {

  008c6	48 83 c6 08	 add	 rsi, 8
  008ca	49 ff cf	 dec	 r15
  008cd	0f 85 0d ff ff
	ff		 jne	 $LL42@PyEval_Eva@2

; 3460 :         }
; 3461 :         if (missing) {

  008d3	85 ed		 test	 ebp, ebp
  008d5	74 10		 je	 SHORT $LN29@PyEval_Eva@2

; 3462 :             missing_arguments(co, missing, -1, fastlocals);

  008d7	4c 8b 4c 24 40	 mov	 r9, QWORD PTR fastlocals$1$[rsp]
  008dc	41 83 c8 ff	 or	 r8d, -1
  008e0	8b d5		 mov	 edx, ebp

; 3463 :             goto fail;

  008e2	e9 35 fd ff ff	 jmp	 $LN306@PyEval_Eva@2
$LN29@PyEval_Eva@2:

; 3464 :         }
; 3465 :     }
; 3466 : 
; 3467 :     /* Allocate and initialize storage for cell vars, and copy free
; 3468 :        vars into frame. */
; 3469 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {

  008e7	49 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [r14+160]
  008ee	45 33 ff	 xor	 r15d, r15d
  008f1	45 8b e7	 mov	 r12d, r15d
  008f4	41 8b ef	 mov	 ebp, r15d
  008f7	4c 39 78 60	 cmp	 QWORD PTR [rax+96], r15
  008fb	0f 8e 5e 01 00
	00		 jle	 $LN26@PyEval_Eva@2
  00901	4c 8b 6c 24 40	 mov	 r13, QWORD PTR fastlocals$1$[rsp]
  00906	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL28@PyEval_Eva@2:

; 3470 :         PyObject *c;
; 3471 :         int arg;
; 3472 :         /* Possibly account for the cell variable being an argument. */
; 3473 :         if (co->co_cell2arg != NULL &&
; 3474 :             (arg = co->co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {

  00910	49 8b 86 a8 00
	00 00		 mov	 rax, QWORD PTR [r14+168]
  00917	48 85 c0	 test	 rax, rax
  0091a	0f 84 97 00 00
	00		 je	 $LN25@PyEval_Eva@2
  00920	0f b6 0c 28	 movzx	 ecx, BYTE PTR [rax+rbp]
  00924	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  0092a	0f 84 87 00 00
	00		 je	 $LN25@PyEval_Eva@2

; 3475 :             c = PyCell_New(GETLOCAL(arg));

  00930	8b d9		 mov	 ebx, ecx
  00932	49 8b 4c cd 00	 mov	 rcx, QWORD PTR [r13+rcx*8]
  00937	e8 00 00 00 00	 call	 PyCell_New

; 3476 :             /* Clear the local copy. */
; 3477 :             SETLOCAL(arg, NULL);

  0093c	49 8b 7c dd 00	 mov	 rdi, QWORD PTR [r13+rbx*8]
  00941	4d 89 7c dd 00	 mov	 QWORD PTR [r13+rbx*8], r15
  00946	48 8b f0	 mov	 rsi, rax
  00949	48 85 ff	 test	 rdi, rdi
  0094c	74 73		 je	 SHORT $LN17@PyEval_Eva@2
  0094e	e8 00 00 00 00	 call	 _Py_PXCTX
  00953	85 c0		 test	 eax, eax
  00955	75 6a		 jne	 SHORT $LN17@PyEval_Eva@2
  00957	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0095b	f6 c1 20	 test	 cl, 32			; 00000020H
  0095e	75 4d		 jne	 SHORT $LN218@PyEval_Eva@2
  00960	84 c9		 test	 cl, cl
  00962	78 49		 js	 SHORT $LN218@PyEval_Eva@2
  00964	f6 c1 02	 test	 cl, 2
  00967	75 58		 jne	 SHORT $LN17@PyEval_Eva@2
  00969	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0096d	75 52		 jne	 SHORT $LN17@PyEval_Eva@2
  0096f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00976	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0097d	4c 8b cf	 mov	 r9, rdi
  00980	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00986	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0098e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00993	48 8b cf	 mov	 rcx, rdi
  00996	85 c0		 test	 eax, eax
  00998	74 07		 je	 SHORT $LN223@PyEval_Eva@2
  0099a	e8 00 00 00 00	 call	 _Px_Dealloc
  0099f	eb 20		 jmp	 SHORT $LN17@PyEval_Eva@2
$LN223@PyEval_Eva@2:
  009a1	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  009a5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  009ab	eb 14		 jmp	 SHORT $LN17@PyEval_Eva@2
$LN218@PyEval_Eva@2:
  009ad	48 8b cf	 mov	 rcx, rdi
  009b0	e8 00 00 00 00	 call	 Px_DecRef

; 3478 :         }
; 3479 :         else {

  009b5	eb 0a		 jmp	 SHORT $LN17@PyEval_Eva@2
$LN25@PyEval_Eva@2:

; 3480 :             c = PyCell_New(NULL);

  009b7	33 c9		 xor	 ecx, ecx
  009b9	e8 00 00 00 00	 call	 PyCell_New
  009be	48 8b f0	 mov	 rsi, rax
$LN17@PyEval_Eva@2:

; 3481 :         }
; 3482 :         if (c == NULL)

  009c1	48 85 f6	 test	 rsi, rsi
  009c4	0f 84 02 02 00
	00		 je	 $LN294@PyEval_Eva@2

; 3483 :             goto fail;
; 3484 :         SETLOCAL(co->co_nlocals + i, c);

  009ca	49 63 46 68	 movsxd	 rax, DWORD PTR [r14+104]
  009ce	48 03 c5	 add	 rax, rbp
  009d1	49 8b 5c c5 00	 mov	 rbx, QWORD PTR [r13+rax*8]
  009d6	49 89 74 c5 00	 mov	 QWORD PTR [r13+rax*8], rsi
  009db	48 85 db	 test	 rbx, rbx
  009de	74 65		 je	 SHORT $LN11@PyEval_Eva@2
  009e0	e8 00 00 00 00	 call	 _Py_PXCTX
  009e5	85 c0		 test	 eax, eax
  009e7	75 5c		 jne	 SHORT $LN11@PyEval_Eva@2
  009e9	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  009ed	a8 20		 test	 al, 32			; 00000020H
  009ef	75 4c		 jne	 SHORT $LN229@PyEval_Eva@2
  009f1	84 c0		 test	 al, al
  009f3	78 48		 js	 SHORT $LN229@PyEval_Eva@2
  009f5	a8 02		 test	 al, 2
  009f7	75 4c		 jne	 SHORT $LN11@PyEval_Eva@2
  009f9	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  009fd	75 46		 jne	 SHORT $LN11@PyEval_Eva@2
  009ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00a06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00a0d	4c 8b cb	 mov	 r9, rbx
  00a10	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00a16	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00a1e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00a23	48 8b cb	 mov	 rcx, rbx
  00a26	85 c0		 test	 eax, eax
  00a28	74 07		 je	 SHORT $LN234@PyEval_Eva@2
  00a2a	e8 00 00 00 00	 call	 _Px_Dealloc
  00a2f	eb 14		 jmp	 SHORT $LN11@PyEval_Eva@2
$LN234@PyEval_Eva@2:
  00a31	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00a35	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00a3b	eb 08		 jmp	 SHORT $LN11@PyEval_Eva@2
$LN229@PyEval_Eva@2:
  00a3d	48 8b cb	 mov	 rcx, rbx
  00a40	e8 00 00 00 00	 call	 Px_DecRef
$LN11@PyEval_Eva@2:

; 3464 :         }
; 3465 :     }
; 3466 : 
; 3467 :     /* Allocate and initialize storage for cell vars, and copy free
; 3468 :        vars into frame. */
; 3469 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {

  00a45	49 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [r14+160]
  00a4c	41 ff c4	 inc	 r12d
  00a4f	48 ff c5	 inc	 rbp
  00a52	49 63 cc	 movsxd	 rcx, r12d
  00a55	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  00a59	0f 8c b1 fe ff
	ff		 jl	 $LL28@PyEval_Eva@2
$LN26@PyEval_Eva@2:

; 3485 :     }
; 3486 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {

  00a5f	49 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [r14+152]
  00a66	41 8b f7	 mov	 esi, r15d
  00a69	49 8b ef	 mov	 rbp, r15
  00a6c	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi
  00a70	7e 7a		 jle	 SHORT $LN6@PyEval_Eva@2
  00a72	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR closure$[rsp]
  00a7a	4c 8b 64 24 58	 mov	 r12, QWORD PTR freevars$1$[rsp]
  00a7f	48 83 c7 70	 add	 rdi, 112		; 00000070H
$LL8@PyEval_Eva@2:

; 3487 :         PyObject *o = PyTuple_GET_ITEM(closure, i);

  00a83	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3488 :         Py_INCREF(o);

  00a86	e8 00 00 00 00	 call	 _Py_PXCTX
  00a8b	85 c0		 test	 eax, eax
  00a8d	75 32		 jne	 SHORT $LN237@PyEval_Eva@2
  00a8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00a96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00a9d	4c 8b cb	 mov	 r9, rbx
  00aa0	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00aa6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00aae	e8 00 00 00 00	 call	 _PyParallel_Guard
  00ab3	85 c0		 test	 eax, eax
  00ab5	75 06		 jne	 SHORT $LN236@PyEval_Eva@2
  00ab7	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00abb	74 04		 je	 SHORT $LN237@PyEval_Eva@2
$LN236@PyEval_Eva@2:
  00abd	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN237@PyEval_Eva@2:

; 3489 :         freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;

  00ac1	49 8b 86 a0 00
	00 00		 mov	 rax, QWORD PTR [r14+160]
  00ac8	ff c6		 inc	 esi
  00aca	48 83 c7 08	 add	 rdi, 8
  00ace	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00ad2	48 63 ce	 movsxd	 rcx, esi
  00ad5	48 03 c5	 add	 rax, rbp
  00ad8	48 ff c5	 inc	 rbp
  00adb	49 89 1c c4	 mov	 QWORD PTR [r12+rax*8], rbx
  00adf	49 8b 86 98 00
	00 00		 mov	 rax, QWORD PTR [r14+152]
  00ae6	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  00aea	7c 97		 jl	 SHORT $LL8@PyEval_Eva@2
$LN6@PyEval_Eva@2:

; 3490 :     }
; 3491 : 
; 3492 :     if (co->co_flags & CO_GENERATOR) {

  00aec	41 f6 46 70 20	 test	 BYTE PTR [r14+112], 32	; 00000020H
  00af1	0f 84 be 00 00
	00		 je	 $LN5@PyEval_Eva@2

; 3493 :         /* Don't need to keep the reference to f_back, it will be set
; 3494 :          * when the generator is resumed. */
; 3495 :         Py_CLEAR(f->f_back);

  00af7	48 8b 7c 24 38	 mov	 rdi, QWORD PTR f$1$[rsp]
  00afc	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00b00	4d 85 c9	 test	 r9, r9
  00b03	0f 84 a2 00 00
	00		 je	 $LN3@PyEval_Eva@2
  00b09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00b10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@
  00b17	41 b8 a7 0d 00
	00		 mov	 r8d, 3495		; 00000da7H
  00b1d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00b25	e8 00 00 00 00	 call	 _PyParallel_Guard
  00b2a	85 c0		 test	 eax, eax
  00b2c	75 7d		 jne	 SHORT $LN3@PyEval_Eva@2
  00b2e	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00b32	4c 89 7f 70	 mov	 QWORD PTR [rdi+112], r15
  00b36	e8 00 00 00 00	 call	 _Py_PXCTX
  00b3b	85 c0		 test	 eax, eax
  00b3d	75 6c		 jne	 SHORT $LN3@PyEval_Eva@2
  00b3f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00b43	a8 20		 test	 al, 32			; 00000020H
  00b45	75 5c		 jne	 SHORT $LN244@PyEval_Eva@2
  00b47	84 c0		 test	 al, al
  00b49	78 58		 js	 SHORT $LN244@PyEval_Eva@2
  00b4b	a8 02		 test	 al, 2
  00b4d	75 5c		 jne	 SHORT $LN3@PyEval_Eva@2
  00b4f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00b53	75 56		 jne	 SHORT $LN3@PyEval_Eva@2
  00b55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00b63	4c 8b cb	 mov	 r9, rbx
  00b66	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00b6c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00b74	e8 00 00 00 00	 call	 _PyParallel_Guard
  00b79	48 8b cb	 mov	 rcx, rbx
  00b7c	85 c0		 test	 eax, eax
  00b7e	74 0f		 je	 SHORT $LN249@PyEval_Eva@2
  00b80	e8 00 00 00 00	 call	 _Px_Dealloc

; 3496 : 
; 3497 :         PCALL(PCALL_GENERATOR);
; 3498 : 
; 3499 :         /* Create a new generator that owns the ready to run frame
; 3500 :          * and return that as the value. */
; 3501 :         return PyGen_New(f);

  00b85	48 8b cf	 mov	 rcx, rdi
  00b88	e8 00 00 00 00	 call	 PyGen_New
  00b8d	eb 61		 jmp	 SHORT $LN299@PyEval_Eva@2

; 3493 :         /* Don't need to keep the reference to f_back, it will be set
; 3494 :          * when the generator is resumed. */
; 3495 :         Py_CLEAR(f->f_back);

$LN249@PyEval_Eva@2:
  00b8f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00b93	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 3496 : 
; 3497 :         PCALL(PCALL_GENERATOR);
; 3498 : 
; 3499 :         /* Create a new generator that owns the ready to run frame
; 3500 :          * and return that as the value. */
; 3501 :         return PyGen_New(f);

  00b99	48 8b cf	 mov	 rcx, rdi
  00b9c	e8 00 00 00 00	 call	 PyGen_New
  00ba1	eb 4d		 jmp	 SHORT $LN299@PyEval_Eva@2

; 3493 :         /* Don't need to keep the reference to f_back, it will be set
; 3494 :          * when the generator is resumed. */
; 3495 :         Py_CLEAR(f->f_back);

$LN244@PyEval_Eva@2:
  00ba3	48 8b cb	 mov	 rcx, rbx
  00ba6	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyEval_Eva@2:

; 3496 : 
; 3497 :         PCALL(PCALL_GENERATOR);
; 3498 : 
; 3499 :         /* Create a new generator that owns the ready to run frame
; 3500 :          * and return that as the value. */
; 3501 :         return PyGen_New(f);

  00bab	48 8b cf	 mov	 rcx, rdi
  00bae	e8 00 00 00 00	 call	 PyGen_New
  00bb3	eb 3b		 jmp	 SHORT $LN299@PyEval_Eva@2
$LN5@PyEval_Eva@2:

; 3502 :     }
; 3503 : 
; 3504 :     retval = PyEval_EvalFrameEx(f,0);

  00bb5	48 8b 5c 24 38	 mov	 rbx, QWORD PTR f$1$[rsp]
  00bba	33 d2		 xor	 edx, edx
  00bbc	48 8b cb	 mov	 rcx, rbx
  00bbf	e8 00 00 00 00	 call	 PyEval_EvalFrameEx
  00bc4	4c 8b f8	 mov	 r15, rax
  00bc7	e9 60 fa ff ff	 jmp	 $fail$65636
$LN294@PyEval_Eva@2:

; 3326 :     }
; 3327 : 
; 3328 :     assert(tstate != NULL);
; 3329 :     assert(globals != NULL);
; 3330 :     f = PyFrame_New(tstate, co, globals, locals);

  00bcc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR f$1$[rsp]
  00bd1	e9 56 fa ff ff	 jmp	 $fail$65636

; 3515 :     Py_DECREF(f);

$LN260@PyEval_Eva@2:
  00bd6	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00bda	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00be0	eb 08		 jmp	 SHORT $LN261@PyEval_Eva@2
$LN255@PyEval_Eva@2:
  00be2	48 8b cb	 mov	 rcx, rbx
  00be5	e8 00 00 00 00	 call	 Px_DecRef
$LN261@PyEval_Eva@2:

; 3516 :     --tstate->recursion_depth;

  00bea	ff 4f 18	 dec	 DWORD PTR [rdi+24]

; 3517 :     return retval;

  00bed	49 8b c7	 mov	 rax, r15
$LN299@PyEval_Eva@2:
  00bf0	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]

; 3518 : }

  00bf8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00bfc	41 5f		 pop	 r15
  00bfe	41 5e		 pop	 r14
  00c00	41 5c		 pop	 r12
  00c02	5f		 pop	 rdi
  00c03	5e		 pop	 rsi
  00c04	5d		 pop	 rbp
  00c05	5b		 pop	 rbx
  00c06	c3		 ret	 0
PyEval_EvalCodeEx ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_function DD imagerel fast_function
	DD	imagerel fast_function+377
	DD	imagerel $unwind$fast_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_function DD 0c1c01H
	DD	014641cH
	DD	013541cH
	DD	012341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fast_function
_TEXT	SEGMENT
func$ = 144
pp_stack$ = 152
n$ = 160
na$ = 168
nk$ = 176
fast_function PROC					; COMDAT

; 4185 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 4186 :     PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
; 4187 :     PyObject *globals = PyFunction_GET_GLOBALS(func);
; 4188 :     PyObject *argdefs = PyFunction_GET_DEFAULTS(func);

  0001c	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00020	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00024	4c 8b 69 68	 mov	 r13, QWORD PTR [rcx+104]

; 4189 :     PyObject *kwdefs = PyFunction_GET_KW_DEFAULTS(func);

  00028	4c 8b 79 78	 mov	 r15, QWORD PTR [rcx+120]

; 4190 :     PyObject **d = NULL;
; 4191 :     int nd = 0;
; 4192 : 
; 4193 :     PCALL(PCALL_FUNCTION);
; 4194 :     PCALL(PCALL_FAST_FUNCTION);
; 4195 :     if (argdefs == NULL && co->co_argcount == n &&
; 4196 :         co->co_kwonlyargcount == 0 && nk==0 &&
; 4197 :         co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {

  0002c	44 8b 9c 24 b0
	00 00 00	 mov	 r11d, DWORD PTR nk$[rsp]
  00034	33 ff		 xor	 edi, edi
  00036	41 8b e9	 mov	 ebp, r9d
  00039	4d 63 e0	 movsxd	 r12, r8d
  0003c	4c 8b f2	 mov	 r14, rdx
  0003f	4c 8b d1	 mov	 r10, rcx
  00042	8b f7		 mov	 esi, edi
  00044	48 85 c0	 test	 rax, rax
  00047	0f 85 b2 00 00
	00		 jne	 $LN13@fast_funct
  0004d	44 39 63 60	 cmp	 DWORD PTR [rbx+96], r12d
  00051	0f 85 af 00 00
	00		 jne	 $LN1@fast_funct
  00057	39 7b 64	 cmp	 DWORD PTR [rbx+100], edi
  0005a	0f 85 a6 00 00
	00		 jne	 $LN1@fast_funct
  00060	45 85 db	 test	 r11d, r11d
  00063	0f 85 9d 00 00
	00		 jne	 $LN1@fast_funct
  00069	83 7b 70 43	 cmp	 DWORD PTR [rbx+112], 67	; 00000043H
  0006d	0f 85 93 00 00
	00		 jne	 $LN1@fast_funct

; 4198 :         PyFrameObject *f;
; 4199 :         PyObject *retval = NULL;
; 4200 :         PyThreadState *tstate = PyThreadState_GET();

  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	74 0a		 je	 SHORT $LN9@fast_funct
  0007c	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00081	48 8b e8	 mov	 rbp, rax
  00084	eb 07		 jmp	 SHORT $LN10@fast_funct
$LN9@fast_funct:
  00086	48 8b 2d 00 00
	00 00		 mov	 rbp, QWORD PTR _PyThreadState_Current
$LN10@fast_funct:

; 4201 :         PyObject **fastlocals, **stack;
; 4202 :         int i;
; 4203 : 
; 4204 :         PCALL(PCALL_FASTER_FUNCTION);
; 4205 :         assert(globals != NULL);
; 4206 :         /* XXX Perhaps we should create a specialized
; 4207 :            PyFrame_New() that doesn't take locals, but does
; 4208 :            take builtins without sanity checking them.
; 4209 :         */
; 4210 :         assert(tstate != NULL);
; 4211 :         f = PyFrame_New(tstate, co, globals, NULL);

  0008d	45 33 c9	 xor	 r9d, r9d
  00090	4d 8b c5	 mov	 r8, r13
  00093	48 8b d3	 mov	 rdx, rbx
  00096	48 8b cd	 mov	 rcx, rbp
  00099	e8 00 00 00 00	 call	 PyFrame_New
  0009e	48 8b f0	 mov	 rsi, rax

; 4212 :         if (f == NULL)

  000a1	48 85 c0	 test	 rax, rax
  000a4	0f 84 b1 00 00
	00		 je	 $LN7@fast_funct
$LN5@fast_funct:

; 4213 :             return NULL;
; 4214 : 
; 4215 :         fastlocals = f->f_localsplus;
; 4216 :         stack = (*pp_stack) - n;

  000aa	49 8b 1e	 mov	 rbx, QWORD PTR [r14]
  000ad	4a 8d 04 e5 00
	00 00 00	 lea	 rax, QWORD PTR [r12*8]
  000b5	48 2b d8	 sub	 rbx, rax

; 4217 : 
; 4218 :         for (i = 0; i < n; i++) {

  000b8	4d 85 e4	 test	 r12, r12
  000bb	7e 22		 jle	 SHORT $LN2@fast_funct
  000bd	0f 1f 00	 npad	 3
$LL4@fast_funct:

; 4219 :             Py_INCREF(*stack);

  000c0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000c3	e8 00 00 00 00	 call	 _Py_IncRef

; 4220 :             fastlocals[i] = *stack++;

  000c8	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  000cb	48 ff c7	 inc	 rdi
  000ce	4c 89 9c fe c8
	01 00 00	 mov	 QWORD PTR [rsi+rdi*8+456], r11
  000d6	48 83 c3 08	 add	 rbx, 8
  000da	49 3b fc	 cmp	 rdi, r12
  000dd	7c e1		 jl	 SHORT $LL4@fast_funct
$LN2@fast_funct:

; 4221 :         }
; 4222 :         retval = PyEval_EvalFrameEx(f,0);

  000df	33 d2		 xor	 edx, edx
  000e1	48 8b ce	 mov	 rcx, rsi
  000e4	e8 00 00 00 00	 call	 PyEval_EvalFrameEx

; 4223 :         ++tstate->recursion_depth;

  000e9	ff 45 18	 inc	 DWORD PTR [rbp+24]

; 4224 :         Py_DECREF(f);

  000ec	48 8b ce	 mov	 rcx, rsi
  000ef	48 8b d8	 mov	 rbx, rax
  000f2	e8 00 00 00 00	 call	 _Py_DecRef

; 4225 :         --tstate->recursion_depth;

  000f7	ff 4d 18	 dec	 DWORD PTR [rbp+24]

; 4226 :         return retval;

  000fa	48 8b c3	 mov	 rax, rbx
  000fd	eb 5c		 jmp	 SHORT $LN7@fast_funct
$LN13@fast_funct:

; 4227 :     }
; 4228 :     if (argdefs != NULL) {
; 4229 :         d = &PyTuple_GET_ITEM(argdefs, 0);
; 4230 :         nd = Py_SIZE(argdefs);

  000ff	8b 70 60	 mov	 esi, DWORD PTR [rax+96]
  00102	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
$LN1@fast_funct:

; 4231 :     }
; 4232 :     return PyEval_EvalCodeEx((PyObject*)co, globals,
; 4233 :                              (PyObject *)NULL, (*pp_stack)-n, na,
; 4234 :                              (*pp_stack)-2*nk, nk, d, nd, kwdefs,
; 4235 :                              PyFunction_GET_CLOSURE(func));

  00106	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
  00109	43 8d 04 1b	 lea	 eax, DWORD PTR [r11+r11]
  0010d	49 8b d5	 mov	 rdx, r13
  00110	48 63 c8	 movsxd	 rcx, eax
  00113	4d 8b c1	 mov	 r8, r9
  00116	4a 8d 04 e5 00
	00 00 00	 lea	 rax, QWORD PTR [r12*8]
  0011e	48 c1 e1 03	 shl	 rcx, 3
  00122	4c 2b c8	 sub	 r9, rax
  00125	49 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [r10+128]
  0012c	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00131	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15
  00136	89 74 24 40	 mov	 DWORD PTR [rsp+64], esi
  0013a	4c 2b c1	 sub	 r8, rcx
  0013d	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00142	44 89 5c 24 30	 mov	 DWORD PTR [rsp+48], r11d
  00147	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  0014c	45 33 c0	 xor	 r8d, r8d
  0014f	48 8b cb	 mov	 rcx, rbx
  00152	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  00156	e8 00 00 00 00	 call	 PyEval_EvalCodeEx
$LN7@fast_funct:

; 4236 : }

  0015b	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00160	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00164	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  00168	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0016c	49 8b e3	 mov	 rsp, r11
  0016f	41 5f		 pop	 r15
  00171	41 5e		 pop	 r14
  00173	41 5d		 pop	 r13
  00175	41 5c		 pop	 r12
  00177	5f		 pop	 rdi
  00178	c3		 ret	 0
fast_function ENDP
_TEXT	ENDS
PUBLIC	PyEval_EvalCode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_EvalCode DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$PyEval_EvalCode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalCode DD 010401H
	DD	0c204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyEval_EvalCode
_TEXT	SEGMENT
co$ = 112
globals$ = 120
locals$ = 128
PyEval_EvalCode PROC					; COMDAT

; 812  : {

$LN3:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 813  :     return PyEval_EvalCodeEx(co,
; 814  :                       globals, locals,
; 815  :                       (PyObject **)NULL, 0,
; 816  :                       (PyObject **)NULL, 0,
; 817  :                       (PyObject **)NULL, 0,
; 818  :                       NULL, NULL);

  00004	33 c0		 xor	 eax, eax
  00006	45 33 c9	 xor	 r9d, r9d
  00009	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0000e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00013	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00017	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0001c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00020	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00025	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00029	e8 00 00 00 00	 call	 PyEval_EvalCodeEx

; 819  : }

  0002e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00032	c3		 ret	 0
PyEval_EvalCode ENDP
_TEXT	ENDS
PUBLIC	PyEval_EvalFrame
; Function compile flags: /Ogtpy
;	COMDAT PyEval_EvalFrame
_TEXT	SEGMENT
f$ = 8
PyEval_EvalFrame PROC					; COMDAT

; 826  :     /* This is for backward compatibility with extension modules that
; 827  :        used this API; core interpreter code should call
; 828  :        PyEval_EvalFrameEx() */
; 829  :     return PyEval_EvalFrameEx(f, 0);

  00000	33 d2		 xor	 edx, edx

; 830  : }

  00002	e9 00 00 00 00	 jmp	 PyEval_EvalFrameEx
PyEval_EvalFrame ENDP
_TEXT	ENDS
END
