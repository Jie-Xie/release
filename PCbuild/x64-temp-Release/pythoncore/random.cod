; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_Py_HashSecret_Initialized DD 01H DUP (?)
	ALIGN	8

pCryptGenRandom DQ 01H DUP (?)
hCryptProv DQ	01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@ ; `string'
PUBLIC	??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@		; `string'
PUBLIC	??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@	; `string'
PUBLIC	??_C@_0N@INAGJMNN@advapi32?4dll?$AA@		; `string'
EXTRN	Py_FatalError:PROC
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleA:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\random.c
pdata	SEGMENT
$pdata$win32_urandom_init DD imagerel win32_urandom_init
	DD	imagerel win32_urandom_init+201
	DD	imagerel $unwind$win32_urandom_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_urandom_init DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@
CONST	SEGMENT
??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@ DB 'Failed to in'
	DB	'itialize Windows random API (CryptoGen)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@
CONST	SEGMENT
??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@ DB 'CryptGenRandom', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@
CONST	SEGMENT
??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@ DB 'CryptAcquireContextA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@INAGJMNN@advapi32?4dll?$AA@ DB 'advapi32.dll', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_urandom_init
_TEXT	SEGMENT
raise$ = 64
win32_urandom_init PROC					; COMDAT

; 28   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	8b f9		 mov	 edi, ecx

; 29   :     HINSTANCE hAdvAPI32 = NULL;
; 30   :     CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;
; 31   : 
; 32   :     /* Obtain handle to the DLL containing CryptoAPI. This should not fail. */
; 33   :     hAdvAPI32 = GetModuleHandle("advapi32.dll");

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0001e	48 8b d8	 mov	 rbx, rax

; 34   :     if(hAdvAPI32 == NULL)

  00021	48 85 c0	 test	 rax, rax
  00024	74 66		 je	 SHORT $error$120321

; 35   :         goto error;
; 36   : 
; 37   :     /* Obtain pointers to the CryptoAPI functions. This will fail on some early
; 38   :        versions of Win95. */
; 39   :     pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(
; 40   :                                hAdvAPI32, "CryptAcquireContextA");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ILOJAFDL@CryptAcquireContextA?$AA@
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00036	48 8b f0	 mov	 rsi, rax

; 41   :     if (pCryptAcquireContext == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 4e		 je	 SHORT $error$120321

; 42   :         goto error;
; 43   : 
; 44   :     pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32,
; 45   :                                                      "CryptGenRandom");

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HGPEDCEI@CryptGenRandom?$AA@
  00045	48 8b cb	 mov	 rcx, rbx
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0004e	48 89 05 00 00
	00 00		 mov	 QWORD PTR pCryptGenRandom, rax

; 46   :     if (pCryptGenRandom == NULL)

  00055	48 85 c0	 test	 rax, rax
  00058	74 32		 je	 SHORT $error$120321

; 47   :         goto error;
; 48   : 
; 49   :     /* Acquire context */
; 50   :     if (! pCryptAcquireContext(&hCryptProv, NULL, NULL,
; 51   :                                PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hCryptProv
  00061	41 b9 01 00 00
	00		 mov	 r9d, 1
  00067	45 33 c0	 xor	 r8d, r8d
  0006a	33 d2		 xor	 edx, edx
  0006c	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  00074	ff d6		 call	 rsi
  00076	85 c0		 test	 eax, eax
  00078	74 12		 je	 SHORT $error$120321

; 52   :         goto error;
; 53   : 
; 54   :     return 0;

  0007a	33 c0		 xor	 eax, eax

; 62   : }

  0007c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00081	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00086	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008a	5f		 pop	 rdi
  0008b	c3		 ret	 0
$error$120321:

; 55   : 
; 56   : error:
; 57   :     if (raise)

  0008c	85 ff		 test	 edi, edi
  0008e	74 1a		 je	 SHORT $LN2@win32_uran

; 58   :         PyErr_SetFromWindowsErr(0);

  00090	33 c9		 xor	 ecx, ecx
  00092	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 61   :     return -1;

  00097	83 c8 ff	 or	 eax, -1

; 62   : }

  0009a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
$LN2@win32_uran:

; 59   :     else
; 60   :         Py_FatalError("Failed to initialize Windows random API (CryptoGen)");

  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FCHIGGOP@Failed?5to?5initialize?5Windows?5ran@
  000b1	e8 00 00 00 00	 call	 Py_FatalError

; 62   : }

  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000bb	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c0	83 c8 ff	 or	 eax, -1
  000c3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
win32_urandom_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_urandom DD imagerel win32_urandom
	DD	imagerel win32_urandom+65
	DD	imagerel $unwind$win32_urandom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$win32_urandom DD imagerel win32_urandom+65
	DD	imagerel win32_urandom+167
	DD	imagerel $chain$1$win32_urandom
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$win32_urandom DD imagerel win32_urandom+167
	DD	imagerel win32_urandom+200
	DD	imagerel $chain$3$win32_urandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$win32_urandom DD 040021H
	DD	07c400H
	DD	067400H
	DD	imagerel win32_urandom
	DD	imagerel win32_urandom+65
	DD	imagerel $unwind$win32_urandom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$win32_urandom DD 040a21H
	DD	07c40aH
	DD	067405H
	DD	imagerel win32_urandom
	DD	imagerel win32_urandom+65
	DD	imagerel $unwind$win32_urandom
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_urandom DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT ??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@
CONST	SEGMENT
??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@ DB 'Failed to in'
	DB	'itialized the randomized hash secret using CryptoGen)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT win32_urandom
_TEXT	SEGMENT
buffer$ = 48
size$ = 56
raise$ = 64
win32_urandom PROC					; COMDAT

; 68   : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   :     Py_ssize_t chunk;
; 70   : 
; 71   :     if (hCryptProv == 0)

  0000f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hCryptProv, 0
  00017	41 8b e8	 mov	 ebp, r8d
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f1	 mov	 rsi, rcx
  00020	75 1f		 jne	 SHORT $LN13@win32_uran@2

; 72   :     {
; 73   :         if (win32_urandom_init(raise) == -1)

  00022	41 8b c8	 mov	 ecx, r8d
  00025	e8 00 00 00 00	 call	 win32_urandom_init
  0002a	83 f8 ff	 cmp	 eax, -1
  0002d	75 12		 jne	 SHORT $LN13@win32_uran@2

; 74   :             return -1;

  0002f	0b c0		 or	 eax, eax

; 94   : }

  00031	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00036	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5e		 pop	 rsi
  00040	c3		 ret	 0
$LN13@win32_uran@2:
  00041	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00046	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12

; 75   :     }
; 76   : 
; 77   :     while (size > 0)

  0004b	48 85 db	 test	 rbx, rbx
  0004e	7e 3b		 jle	 SHORT $LN4@win32_uran@2
  00050	41 bc ff ff ff
	7f		 mov	 r12d, 2147483647	; 7fffffffH
  00056	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@win32_uran@2:

; 78   :     {
; 79   :         chunk = size > INT_MAX ? INT_MAX : size;
; 80   :         if (!pCryptGenRandom(hCryptProv, chunk, buffer))

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hCryptProv
  00067	48 8b fb	 mov	 rdi, rbx
  0006a	49 3b dc	 cmp	 rbx, r12
  0006d	49 0f 4f fc	 cmovg	 rdi, r12
  00071	4c 8b c6	 mov	 r8, rsi
  00074	8b d7		 mov	 edx, edi
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR pCryptGenRandom
  0007c	85 c0		 test	 eax, eax
  0007e	74 27		 je	 SHORT $LN11@win32_uran@2

; 89   :         }
; 90   :         buffer += chunk;
; 91   :         size -= chunk;

  00080	48 2b df	 sub	 rbx, rdi
  00083	48 03 f7	 add	 rsi, rdi
  00086	48 85 db	 test	 rbx, rbx
  00089	7f d5		 jg	 SHORT $LL5@win32_uran@2
$LN4@win32_uran@2:

; 92   :     }
; 93   :     return 0;

  0008b	33 c0		 xor	 eax, eax
$LN19@win32_uran@2:
  0008d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00092	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]

; 94   : }

  00097	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
$LN11@win32_uran@2:

; 81   :         {
; 82   :             /* CryptGenRandom() failed */
; 83   :             if (raise)

  000a7	85 ed		 test	 ebp, ebp
  000a9	74 0c		 je	 SHORT $LN2@win32_uran@2

; 84   :                 PyErr_SetFromWindowsErr(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 88   :             return -1;

  000b2	83 c8 ff	 or	 eax, -1
  000b5	eb d6		 jmp	 SHORT $LN19@win32_uran@2
$LN2@win32_uran@2:

; 85   :             else
; 86   :                 Py_FatalError("Failed to initialized the randomized hash "
; 87   :                         "secret using CryptoGen)");

  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EC@MBOFJODN@Failed?5to?5initialized?5the?5random@
  000be	e8 00 00 00 00	 call	 Py_FatalError

; 88   :             return -1;

  000c3	83 c8 ff	 or	 eax, -1
  000c6	eb c5		 jmp	 SHORT $LN19@win32_uran@2
win32_urandom ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lcg_urandom
_TEXT	SEGMENT
x0$ = 8
buffer$ = 16
size$ = 24
lcg_urandom PROC					; COMDAT

; 215  :     size_t index;
; 216  :     unsigned int x;
; 217  : 
; 218  :     x = x0;
; 219  :     for (index=0; index < size; index++) {

  00000	45 33 c9	 xor	 r9d, r9d
  00003	4d 85 c0	 test	 r8, r8
  00006	74 26		 je	 SHORT $LN1@lcg_urando
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@lcg_urando:

; 220  :         x *= 214013;

  00010	69 c9 fd 43 03
	00		 imul	 ecx, 214013		; 000343fdH
  00016	49 ff c1	 inc	 r9

; 221  :         x += 2531011;

  00019	81 c1 c3 9e 26
	00		 add	 ecx, 2531011		; 00269ec3H

; 222  :         /* modulo 2 ^ (8 * sizeof(int)) */
; 223  :         buffer[index] = (x >> 16) & 0xff;

  0001f	8b c1		 mov	 eax, ecx
  00021	c1 e8 10	 shr	 eax, 16
  00024	41 88 44 11 ff	 mov	 BYTE PTR [r9+rdx-1], al
  00029	4d 3b c8	 cmp	 r9, r8
  0002c	72 e2		 jb	 SHORT $LL3@lcg_urando
$LN1@lcg_urando:

; 224  :     }
; 225  : }

  0002e	f3 c3		 fatret	 0
lcg_urandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ ; `string'
PUBLIC	_PyOS_URandom
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyOS_URandom DD imagerel $LN6
	DD	imagerel $LN6+60
	DD	imagerel $unwind$_PyOS_URandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyOS_URandom DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ DB 'negative arg'
	DB	'ument not allowed', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyOS_URandom
_TEXT	SEGMENT
buffer$ = 48
size$ = 56
_PyOS_URandom PROC					; COMDAT

; 234  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 235  :     if (size < 0) {

  00004	48 85 d2	 test	 rdx, rdx
  00007	79 1b		 jns	 SHORT $LN5@PyOS_URand

; 236  :         PyErr_Format(PyExc_ValueError,
; 237  :                      "negative argument not allowed");

  00009	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
  00017	e8 00 00 00 00	 call	 PyErr_Format

; 238  :         return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 245  : #else
; 246  : # ifdef __VMS
; 247  :     return vms_urandom((unsigned char *)buffer, size, 1);
; 248  : # else
; 249  :     return dev_urandom_python((char*)buffer, size);
; 250  : # endif
; 251  : #endif
; 252  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN5@PyOS_URand:

; 239  :     }
; 240  :     if (size == 0)

  00024	75 07		 jne	 SHORT $LN1@PyOS_URand

; 241  :         return 0;

  00026	33 c0		 xor	 eax, eax

; 245  : #else
; 246  : # ifdef __VMS
; 247  :     return vms_urandom((unsigned char *)buffer, size, 1);
; 248  : # else
; 249  :     return dev_urandom_python((char*)buffer, size);
; 250  : # endif
; 251  : #endif
; 252  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyOS_URand:

; 242  : 
; 243  : #ifdef MS_WINDOWS
; 244  :     return win32_urandom((unsigned char *)buffer, size, 1);

  0002d	41 b8 01 00 00
	00		 mov	 r8d, 1

; 245  : #else
; 246  : # ifdef __VMS
; 247  :     return vms_urandom((unsigned char *)buffer, size, 1);
; 248  : # else
; 249  :     return dev_urandom_python((char*)buffer, size);
; 250  : # endif
; 251  : #endif
; 252  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	e9 00 00 00 00	 jmp	 win32_urandom
_PyOS_URandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@ ; `string'
PUBLIC	??_C@_06NLFCANPD@random?$AA@			; `string'
PUBLIC	??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@		; `string'
PUBLIC	_PyRandom_Init
EXTRN	_Py_HashSecret:BYTE
EXTRN	__imp__errno:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyRandom_Init DD imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyRandom_Init DD imagerel $LN13+24
	DD	imagerel $LN13+76
	DD	imagerel $chain$0$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyRandom_Init DD imagerel $LN13+76
	DD	imagerel $LN13+109
	DD	imagerel $chain$1$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyRandom_Init DD imagerel $LN13+109
	DD	imagerel $LN13+209
	DD	imagerel $chain$2$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyRandom_Init DD imagerel $LN13+209
	DD	imagerel $LN13+238
	DD	imagerel $chain$4$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_PyRandom_Init DD imagerel $LN13+238
	DD	imagerel $LN13+262
	DD	imagerel $chain$6$_PyRandom_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_PyRandom_Init DD imagerel $LN13+262
	DD	imagerel $LN13+267
	DD	imagerel $chain$7$_PyRandom_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_PyRandom_Init DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_PyRandom_Init DD 020021H
	DD	047400H
	DD	imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyRandom_Init DD 020021H
	DD	047400H
	DD	imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyRandom_Init DD 021H
	DD	imagerel $LN13+24
	DD	imagerel $LN13+76
	DD	imagerel $chain$0$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyRandom_Init DD 020521H
	DD	076405H
	DD	imagerel $LN13+24
	DD	imagerel $LN13+76
	DD	imagerel $chain$0$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyRandom_Init DD 020521H
	DD	047405H
	DD	imagerel $LN13
	DD	imagerel $LN13+24
	DD	imagerel $unwind$_PyRandom_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyRandom_Init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@
CONST	SEGMENT
??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@ DB 'PYTHON'
	DB	'HASHSEED must be "random" or an integer in range [0; 42949672'
	DB	'95]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLFCANPD@random?$AA@
CONST	SEGMENT
??_C@_06NLFCANPD@random?$AA@ DB 'random', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@
CONST	SEGMENT
??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@ DB 'PYTHONHASHSEED', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyRandom_Init
_TEXT	SEGMENT
endptr$120387 = 48
_PyRandom_Init PROC					; COMDAT

; 256  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 257  :     char *env;
; 258  :     void *secret = &_Py_HashSecret;
; 259  :     Py_ssize_t secret_size = sizeof(_Py_HashSecret_t);
; 260  : 
; 261  :     if (_Py_HashSecret_Initialized)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Py_HashSecret_Initialized, 0
  0000b	0f 85 f5 00 00
	00		 jne	 $LN1@PyRandom_I

; 262  :         return;
; 263  :     _Py_HashSecret_Initialized = 1;
; 264  : 
; 265  :     /*
; 266  :       Hash randomization is enabled.  Generate a per-process secret,
; 267  :       using PYTHONHASHSEED if provided.
; 268  :     */
; 269  : 
; 270  :     env = Py_GETENV("PYTHONHASHSEED");

  00011	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00018	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0001d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _Py_HashSecret_Initialized, 1
  00027	0f 85 c1 00 00
	00		 jne	 $LN6@PyRandom_I
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@FFABKKFN@PYTHONHASHSEED?$AA@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv

; 271  :     if (env && *env != '\0' && strcmp(env, "random") != 0) {

  0003a	48 85 c0	 test	 rax, rax
  0003d	0f 84 ab 00 00
	00		 je	 $LN6@PyRandom_I
  00043	80 38 00	 cmp	 BYTE PTR [rax], 0
  00046	0f 84 a2 00 00
	00		 je	 $LN6@PyRandom_I
  0004c	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00051	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06NLFCANPD@random?$AA@
  00058	b9 07 00 00 00	 mov	 ecx, 7
  0005d	48 8b f0	 mov	 rsi, rax
  00060	f3 a6		 repe cmpsb
  00062	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00067	0f 84 81 00 00
	00		 je	 $LN6@PyRandom_I

; 272  :         char *endptr = env;
; 273  :         unsigned long seed;
; 274  :         seed = strtoul(env, &endptr, 10);

  0006d	48 8d 54 24 30	 lea	 rdx, QWORD PTR endptr$120387[rsp]
  00072	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00078	48 8b c8	 mov	 rcx, rax
  0007b	48 89 44 24 30	 mov	 QWORD PTR endptr$120387[rsp], rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul

; 275  :         if (*endptr != '\0'
; 276  :             || seed > 4294967295UL
; 277  :             || (errno == ERANGE && seed == ULONG_MAX))

  00086	48 8b 4c 24 30	 mov	 rcx, QWORD PTR endptr$120387[rsp]
  0008b	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0008e	8b f8		 mov	 edi, eax
  00090	75 15		 jne	 SHORT $LN4@PyRandom_I
  00092	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00095	77 10		 ja	 SHORT $LN4@PyRandom_I
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009d	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  000a0	75 11		 jne	 SHORT $LN5@PyRandom_I
  000a2	83 ff ff	 cmp	 edi, -1			; ffffffffH
  000a5	75 0c		 jne	 SHORT $LN5@PyRandom_I
$LN4@PyRandom_I:

; 278  :         {
; 279  :             Py_FatalError("PYTHONHASHSEED must be \"random\" or an integer "
; 280  :                           "in range [0; 4294967295]");

  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EH@INPDKPJA@PYTHONHASHSEED?5must?5be?5?$CCrandom?$CC?5@
  000ae	e8 00 00 00 00	 call	 Py_FatalError
$LN5@PyRandom_I:

; 281  :         }
; 282  :         if (seed == 0) {

  000b3	85 ff		 test	 edi, edi
  000b5	75 1a		 jne	 SHORT $LN3@PyRandom_I

; 283  :             /* disable the randomized hash */
; 284  :             memset(secret, 0, secret_size);

  000b7	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000bc	33 c0		 xor	 eax, eax
  000be	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_HashSecret, rax
  000c5	48 89 05 08 00
	00 00		 mov	 QWORD PTR _Py_HashSecret+8, rax

; 293  : #else /* #ifdef MS_WINDOWS */
; 294  : # ifdef __VMS
; 295  :         vms_urandom((unsigned char *)secret, secret_size, 0);
; 296  : # else
; 297  :         dev_urandom_noraise((char*)secret, secret_size);
; 298  : # endif
; 299  : #endif
; 300  :     }
; 301  : }

  000cc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d0	c3		 ret	 0
$LN3@PyRandom_I:

; 285  :         }
; 286  :         else {
; 287  :             lcg_urandom(seed, (unsigned char*)secret, secret_size);

  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_HashSecret
  000d8	41 b8 10 00 00
	00		 mov	 r8d, 16
  000de	8b cf		 mov	 ecx, edi
  000e0	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 293  : #else /* #ifdef MS_WINDOWS */
; 294  : # ifdef __VMS
; 295  :         vms_urandom((unsigned char *)secret, secret_size, 0);
; 296  : # else
; 297  :         dev_urandom_noraise((char*)secret, secret_size);
; 298  : # endif
; 299  : #endif
; 300  :     }
; 301  : }

  000e5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e9	e9 00 00 00 00	 jmp	 lcg_urandom
$LN6@PyRandom_I:

; 288  :         }
; 289  :     }
; 290  :     else {
; 291  : #ifdef MS_WINDOWS
; 292  :         (void)win32_urandom((unsigned char *)secret, secret_size, 0);

  000ee	45 33 c0	 xor	 r8d, r8d
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_HashSecret
  000f8	41 8d 50 10	 lea	 edx, QWORD PTR [r8+16]
  000fc	e8 00 00 00 00	 call	 win32_urandom
  00101	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
$LN1@PyRandom_I:

; 293  : #else /* #ifdef MS_WINDOWS */
; 294  : # ifdef __VMS
; 295  :         vms_urandom((unsigned char *)secret, secret_size, 0);
; 296  : # else
; 297  :         dev_urandom_noraise((char*)secret, secret_size);
; 298  : # endif
; 299  : #endif
; 300  :     }
; 301  : }

  00106	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010a	c3		 ret	 0
_PyRandom_Init ENDP
_TEXT	ENDS
END
