; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
PUBLIC	??_C@_0O@BNPCNOJJ@surrogatepass?$AA@		; `string'
PUBLIC	??_C@_0HO@BMBAFHMD@Implements?5the?5?8backslashreplace@ ; `string'
PUBLIC	??_C@_0BI@DFNAJBLL@backslashreplace_errors?$AA@	; `string'
PUBLIC	??_C@_0BB@GGCFDDAA@backslashreplace?$AA@	; `string'
PUBLIC	??_C@_0IJ@BGIKOPNG@Implements?5the?5?8xmlcharrefreplac@ ; `string'
PUBLIC	??_C@_0BJ@PKKJBMDC@xmlcharrefreplace_errors?$AA@ ; `string'
PUBLIC	??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@	; `string'
PUBLIC	??_C@_0GC@JHANBNN@Implements?5the?5?8replace?8?5error?5h@ ; `string'
PUBLIC	??_C@_0P@EAIPFBP@replace_errors?$AA@		; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_0FE@LJBBJPHI@Implements?5the?5?8ignore?8?5error?5ha@ ; `string'
PUBLIC	??_C@_0O@DJBKIKOC@ignore_errors?$AA@		; `string'
PUBLIC	??_C@_06GDPEBLPA@ignore?$AA@			; `string'
PUBLIC	??_C@_0FG@FHKDHEAN@Implements?5the?5?8strict?8?5error?5ha@ ; `string'
PUBLIC	??_C@_0O@BGCCHANL@strict_errors?$AA@		; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_08BHKDPDAA@__name__?$AA@			; `string'
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	??_C@_0BC@NCOEPKED@_is_text_encoding?$AA@	; `string'
PUBLIC	??_C@_0BB@JCEFLFJE@0123456789abcdef?$AA@	; `string'
PUBLIC	Py_hexdigits
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
CONST	SEGMENT
??_C@_0O@BNPCNOJJ@surrogatepass?$AA@ DB 'surrogatepass', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HO@BMBAFHMD@Implements?5the?5?8backslashreplace@
CONST	SEGMENT
??_C@_0HO@BMBAFHMD@Implements?5the?5?8backslashreplace@ DB 'Implements th'
	DB	'e ''backslashreplace'' error handling, which replaces an unen'
	DB	'codable character with a backslashed escape sequence.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFNAJBLL@backslashreplace_errors?$AA@
CONST	SEGMENT
??_C@_0BI@DFNAJBLL@backslashreplace_errors?$AA@ DB 'backslashreplace_erro'
	DB	'rs', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGCFDDAA@backslashreplace?$AA@
CONST	SEGMENT
??_C@_0BB@GGCFDDAA@backslashreplace?$AA@ DB 'backslashreplace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IJ@BGIKOPNG@Implements?5the?5?8xmlcharrefreplac@
CONST	SEGMENT
??_C@_0IJ@BGIKOPNG@Implements?5the?5?8xmlcharrefreplac@ DB 'Implements th'
	DB	'e ''xmlcharrefreplace'' error handling, which replaces an une'
	DB	'ncodable character with the appropriate XML character referen'
	DB	'ce.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKKJBMDC@xmlcharrefreplace_errors?$AA@
CONST	SEGMENT
??_C@_0BJ@PKKJBMDC@xmlcharrefreplace_errors?$AA@ DB 'xmlcharrefreplace_er'
	DB	'rors', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
CONST	SEGMENT
??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@ DB 'xmlcharrefreplace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@JHANBNN@Implements?5the?5?8replace?8?5error?5h@
CONST	SEGMENT
??_C@_0GC@JHANBNN@Implements?5the?5?8replace?8?5error?5h@ DB 'Implements '
	DB	'the ''replace'' error handling, which replaces malformed data'
	DB	' with a replacement marker.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EAIPFBP@replace_errors?$AA@
CONST	SEGMENT
??_C@_0P@EAIPFBP@replace_errors?$AA@ DB 'replace_errors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FE@LJBBJPHI@Implements?5the?5?8ignore?8?5error?5ha@
CONST	SEGMENT
??_C@_0FE@LJBBJPHI@Implements?5the?5?8ignore?8?5error?5ha@ DB 'Implements'
	DB	' the ''ignore'' error handling, which ignores malformed data '
	DB	'and continues.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DJBKIKOC@ignore_errors?$AA@
CONST	SEGMENT
??_C@_0O@DJBKIKOC@ignore_errors?$AA@ DB 'ignore_errors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GDPEBLPA@ignore?$AA@
CONST	SEGMENT
??_C@_06GDPEBLPA@ignore?$AA@ DB 'ignore', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@FHKDHEAN@Implements?5the?5?8strict?8?5error?5ha@
CONST	SEGMENT
??_C@_0FG@FHKDHEAN@Implements?5the?5?8strict?8?5error?5ha@ DB 'Implements'
	DB	' the ''strict'' error handling, which raises a UnicodeError o'
	DB	'n coding errors.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BGCCHANL@strict_errors?$AA@
CONST	SEGMENT
??_C@_0O@BGCCHANL@strict_errors?$AA@ DB 'strict_errors', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BHKDPDAA@__name__?$AA@
CONST	SEGMENT
??_C@_08BHKDPDAA@__name__?$AA@ DB '__name__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___name__@?1??wrong_exception_type@@9@9 DQ 0000000000000000H ; `wrong_exception_type'::`2'::PyId___name__
	DQ	FLAT:??_C@_08BHKDPDAA@__name__?$AA@
	DQ	0000000000000000H
?PyId___class__@?1??wrong_exception_type@@9@9 DQ 0000000000000000H ; `wrong_exception_type'::`2'::PyId___class__
	DQ	FLAT:??_C@_09LFGACEKG@__class__?$AA@
	DQ	0000000000000000H
?PyId__is_text_encoding@?1??_PyCodec_LookupTextEncoding@@9@9 DQ 0000000000000000H ; `_PyCodec_LookupTextEncoding'::`2'::PyId__is_text_encoding
	DQ	FLAT:??_C@_0BC@NCOEPKED@_is_text_encoding?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0BC@NCOEPKED@_is_text_encoding?$AA@
CONST	SEGMENT
??_C@_0BC@NCOEPKED@_is_text_encoding?$AA@ DB '_is_text_encoding', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
Py_hexdigits DQ	FLAT:??_C@_0BB@JCEFLFJE@0123456789abcdef?$AA@
	ORG $+8
?methods@?1??_PyCodecRegistry_Init@@9@9 DQ FLAT:??_C@_06OLFOGHEN@strict?$AA@ ; `_PyCodecRegistry_Init'::`2'::methods
	DQ	FLAT:??_C@_0O@BGCCHANL@strict_errors?$AA@
	DQ	FLAT:strict_errors
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0FG@FHKDHEAN@Implements?5the?5?8strict?8?5error?5ha@
	DQ	FLAT:??_C@_06GDPEBLPA@ignore?$AA@
	DQ	FLAT:??_C@_0O@DJBKIKOC@ignore_errors?$AA@
	DQ	FLAT:ignore_errors
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0FE@LJBBJPHI@Implements?5the?5?8ignore?8?5error?5ha@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:??_C@_0P@EAIPFBP@replace_errors?$AA@
	DQ	FLAT:replace_errors
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0GC@JHANBNN@Implements?5the?5?8replace?8?5error?5h@
	DQ	FLAT:??_C@_0BC@EBFFMGGH@xmlcharrefreplace?$AA@
	DQ	FLAT:??_C@_0BJ@PKKJBMDC@xmlcharrefreplace_errors?$AA@
	DQ	FLAT:xmlcharrefreplace_errors
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0IJ@BGIKOPNG@Implements?5the?5?8xmlcharrefreplac@
	DQ	FLAT:??_C@_0BB@GGCFDDAA@backslashreplace?$AA@
	DQ	FLAT:??_C@_0BI@DFNAJBLL@backslashreplace_errors?$AA@
	DQ	FLAT:backslashreplace_errors
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0HO@BMBAFHMD@Implements?5the?5?8backslashreplace@
	DQ	FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
	DQ	FLAT:??_C@_0O@BNPCNOJJ@surrogatepass?$AA@
	DQ	FLAT:surrogatepass_errors
	DD	08H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
	DQ	FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
	DQ	FLAT:surrogateescape_errors
	DD	08H
	ORG $+4
	ORG $+8
_DATA	ENDS
;	COMDAT ??_C@_0BB@JCEFLFJE@0123456789abcdef?$AA@
CONST	SEGMENT
??_C@_0BB@JCEFLFJE@0123456789abcdef?$AA@ DB '0123456789abcdef', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@HLPAOMLE@string?5is?5too?5large?$AA@	; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	_Py_ctype_tolower:BYTE
EXTRN	PyMem_Malloc:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\codecs.c
pdata	SEGMENT
$pdata$normalizestring DD imagerel normalizestring
	DD	imagerel normalizestring+83
	DD	imagerel $unwind$normalizestring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$normalizestring DD imagerel normalizestring+83
	DD	imagerel normalizestring+196
	DD	imagerel $chain$0$normalizestring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$normalizestring DD imagerel normalizestring+196
	DD	imagerel normalizestring+223
	DD	imagerel $chain$2$normalizestring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$normalizestring DD 020021H
	DD	063400H
	DD	imagerel normalizestring
	DD	imagerel normalizestring+83
	DD	imagerel $unwind$normalizestring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$normalizestring DD 020521H
	DD	063405H
	DD	imagerel normalizestring
	DD	imagerel normalizestring+83
	DD	imagerel $unwind$normalizestring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalizestring DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BE@HLPAOMLE@string?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BE@HLPAOMLE@string?5is?5too?5large?$AA@ DB 'string is too large', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT normalizestring
_TEXT	SEGMENT
string$ = 48
normalizestring PROC					; COMDAT

; 55   : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 56   :     register size_t i;
; 57   :     size_t len = strlen(string);

  0000d	48 83 c9 ff	 or	 rcx, -1
  00011	33 c0		 xor	 eax, eax
  00013	48 8b fe	 mov	 rdi, rsi
  00016	f2 ae		 repne scasb

; 58   :     char *p;
; 59   :     PyObject *v;
; 60   : 
; 61   :     if (len > PY_SSIZE_T_MAX) {

  00018	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00022	48 f7 d1	 not	 rcx
  00025	48 ff c9	 dec	 rcx
  00028	48 8b f9	 mov	 rdi, rcx
  0002b	48 3b c8	 cmp	 rcx, rax
  0002e	76 20		 jbe	 SHORT $LN8@normalizes

; 62   :         PyErr_SetString(PyExc_OverflowError, "string is too large");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@HLPAOMLE@string?5is?5too?5large?$AA@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString

; 63   :         return NULL;

  00043	33 c0		 xor	 eax, eax

; 82   :     return v;
; 83   : }

  00045	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN8@normalizes:

; 64   :     }
; 65   : 
; 66   :     p = PyMem_Malloc(len + 1);

  00050	48 ff c1	 inc	 rcx
  00053	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00058	e8 00 00 00 00	 call	 PyMem_Malloc
  0005d	48 8b d8	 mov	 rbx, rax

; 67   :     if (p == NULL)

  00060	48 85 c0	 test	 rax, rax

; 68   :         return NULL;

  00063	74 4d		 je	 SHORT $LN14@normalizes

; 69   :     for (i = 0; i < len; i++) {

  00065	33 d2		 xor	 edx, edx
  00067	48 85 ff	 test	 rdi, rdi
  0006a	74 32		 je	 SHORT $LN4@normalizes
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	48 2b f0	 sub	 rsi, rax
  00072	48 8b d7	 mov	 rdx, rdi
  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_ctype_tolower
  0007c	0f 1f 40 00	 npad	 4
$LL6@normalizes:

; 70   :         register char ch = string[i];

  00080	0f b6 04 0e	 movzx	 eax, BYTE PTR [rsi+rcx]

; 71   :         if (ch == ' ')

  00084	3c 20		 cmp	 al, 32			; 00000020H
  00086	75 04		 jne	 SHORT $LN3@normalizes

; 72   :             ch = '-';

  00088	b0 2d		 mov	 al, 45			; 0000002dH

; 73   :         else

  0008a	eb 08		 jmp	 SHORT $LN2@normalizes
$LN3@normalizes:

; 74   :             ch = Py_TOLOWER(Py_CHARMASK(ch));

  0008c	0f b6 c0	 movzx	 eax, al
  0008f	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
$LN2@normalizes:

; 75   :         p[i] = ch;

  00094	88 01		 mov	 BYTE PTR [rcx], al
  00096	48 ff c1	 inc	 rcx
  00099	48 ff cf	 dec	 rdi
  0009c	75 e2		 jne	 SHORT $LL6@normalizes
$LN4@normalizes:

; 76   :     }
; 77   :     p[i] = '\0';
; 78   :     v = PyUnicode_FromString(p);

  0009e	48 8b cb	 mov	 rcx, rbx
  000a1	c6 04 1a 00	 mov	 BYTE PTR [rdx+rbx], 0
  000a5	e8 00 00 00 00	 call	 PyUnicode_FromString
  000aa	48 8b f8	 mov	 rdi, rax

; 79   :     if (v == NULL)

  000ad	48 85 c0	 test	 rax, rax
  000b0	75 12		 jne	 SHORT $LN1@normalizes
$LN14@normalizes:

; 80   :         return NULL;

  000b2	33 c0		 xor	 eax, eax
  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 82   :     return v;
; 83   : }

  000b9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
$LN1@normalizes:

; 81   :     PyMem_Free(p);

  000c4	48 8b cb	 mov	 rcx, rbx
  000c7	e8 00 00 00 00	 call	 PyMem_Free
  000cc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 82   :     return v;
; 83   : }

  000d1	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d6	48 8b c7	 mov	 rax, rdi
  000d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
normalizestring ENDP
_TEXT	ENDS
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$args_tuple DD imagerel args_tuple
	DD	imagerel args_tuple+177
	DD	imagerel $unwind$args_tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$args_tuple DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
xdata	ENDS
;	COMDAT args_tuple
_TEXT	SEGMENT
object$ = 64
errors$ = 72
args_tuple PROC						; COMDAT

; 208  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 209  :     PyObject *args;
; 210  : 
; 211  :     args = PyTuple_New(1 + (errors != NULL));

  0000f	33 c0		 xor	 eax, eax
  00011	48 85 d2	 test	 rdx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	0f 95 c0	 setne	 al
  0001a	48 8b f2	 mov	 rsi, rdx
  0001d	ff c0		 inc	 eax
  0001f	48 63 c8	 movsxd	 rcx, eax
  00022	e8 00 00 00 00	 call	 PyTuple_New
  00027	48 8b d8	 mov	 rbx, rax

; 212  :     if (args == NULL)

  0002a	48 85 c0	 test	 rax, rax

; 213  :         return NULL;

  0002d	74 59		 je	 SHORT $LN10@args_tuple

; 214  :     Py_INCREF(object);

  0002f	e8 00 00 00 00	 call	 _Py_PXCTX
  00034	85 c0		 test	 eax, eax
  00036	75 32		 jne	 SHORT $LN7@args_tuple
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00046	4c 8b cf	 mov	 r9, rdi
  00049	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00057	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005c	85 c0		 test	 eax, eax
  0005e	75 06		 jne	 SHORT $LN6@args_tuple
  00060	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00064	74 04		 je	 SHORT $LN7@args_tuple
$LN6@args_tuple:
  00066	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN7@args_tuple:

; 215  :     PyTuple_SET_ITEM(args,0,object);

  0006a	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 216  :     if (errors) {

  0006e	48 85 f6	 test	 rsi, rsi
  00071	74 2b		 je	 SHORT $LN2@args_tuple

; 217  :         PyObject *v;
; 218  : 
; 219  :         v = PyUnicode_FromString(errors);

  00073	48 8b ce	 mov	 rcx, rsi
  00076	e8 00 00 00 00	 call	 PyUnicode_FromString

; 220  :         if (v == NULL) {

  0007b	48 85 c0	 test	 rax, rax
  0007e	75 1a		 jne	 SHORT $LN1@args_tuple

; 221  :             Py_DECREF(args);

  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@args_tuple:

; 222  :             return NULL;

  00088	33 c0		 xor	 eax, eax

; 225  :     }
; 226  :     return args;
; 227  : }

  0008a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
$LN1@args_tuple:

; 223  :         }
; 224  :         PyTuple_SET_ITEM(args, 1, v);

  0009a	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax
$LN2@args_tuple:

; 225  :     }
; 226  :     return args;
; 227  : }

  0009e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a3	48 8b c3	 mov	 rax, rbx
  000a6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	c3		 ret	 0
args_tuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
EXTRN	PyObject_CallFunction:PROC
EXTRN	PyObject_GetAttrString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$codec_makeincrementalcodec DD imagerel codec_makeincrementalcodec
	DD	imagerel codec_makeincrementalcodec+97
	DD	imagerel $unwind$codec_makeincrementalcodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$codec_makeincrementalcodec DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT codec_makeincrementalcodec
_TEXT	SEGMENT
codec_info$ = 48
errors$ = 56
attrname$ = 64
codec_makeincrementalcodec PROC				; COMDAT

; 251  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 252  :     PyObject *ret, *inccodec;
; 253  : 
; 254  :     inccodec = PyObject_GetAttrString(codec_info, attrname);

  0000d	49 8b d0	 mov	 rdx, r8
  00010	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00015	48 8b d8	 mov	 rbx, rax

; 255  :     if (inccodec == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN3@codec_make

; 262  :     return ret;
; 263  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN3@codec_make:

; 256  :         return NULL;
; 257  :     if (errors)
; 258  :         ret = PyObject_CallFunction(inccodec, "s", errors);

  00028	48 8b c8	 mov	 rcx, rax
  0002b	48 85 ff	 test	 rdi, rdi
  0002e	74 11		 je	 SHORT $LN2@codec_make
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00037	4c 8b c7	 mov	 r8, rdi
  0003a	e8 00 00 00 00	 call	 PyObject_CallFunction

; 259  :     else

  0003f	eb 07		 jmp	 SHORT $LN6@codec_make
$LN2@codec_make:

; 260  :         ret = PyObject_CallFunction(inccodec, NULL);

  00041	33 d2		 xor	 edx, edx
  00043	e8 00 00 00 00	 call	 PyObject_CallFunction
$LN6@codec_make:

; 261  :     Py_DECREF(inccodec);

  00048	48 8b cb	 mov	 rcx, rbx
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	e8 00 00 00 00	 call	 _Py_DecRef

; 262  :     return ret;
; 263  : }

  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 8b c7	 mov	 rax, rdi
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
codec_makeincrementalcodec ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LLLDLNBG@incrementaldecoder?$AA@	; `string'
PUBLIC	_PyCodecInfo_GetIncrementalDecoder
;	COMDAT ??_C@_0BD@LLLDLNBG@incrementaldecoder?$AA@
CONST	SEGMENT
??_C@_0BD@LLLDLNBG@incrementaldecoder?$AA@ DB 'incrementaldecoder', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodecInfo_GetIncrementalDecoder
_TEXT	SEGMENT
codec_info$ = 8
errors$ = 16
_PyCodecInfo_GetIncrementalDecoder PROC			; COMDAT

; 309  :     return codec_makeincrementalcodec(codec_info, errors,
; 310  :                                       "incrementaldecoder");

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@LLLDLNBG@incrementaldecoder?$AA@

; 311  : }

  00007	e9 00 00 00 00	 jmp	 codec_makeincrementalcodec
_PyCodecInfo_GetIncrementalDecoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@HFBOOJHC@incrementalencoder?$AA@	; `string'
PUBLIC	_PyCodecInfo_GetIncrementalEncoder
;	COMDAT ??_C@_0BD@HFBOOJHC@incrementalencoder?$AA@
CONST	SEGMENT
??_C@_0BD@HFBOOJHC@incrementalencoder?$AA@ DB 'incrementalencoder', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodecInfo_GetIncrementalEncoder
_TEXT	SEGMENT
codec_info$ = 8
errors$ = 16
_PyCodecInfo_GetIncrementalEncoder PROC			; COMDAT

; 316  :     return codec_makeincrementalcodec(codec_info, errors,
; 317  :                                       "incrementalencoder");

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@HFBOOJHC@incrementalencoder?$AA@

; 318  : }

  00007	e9 00 00 00 00	 jmp	 codec_makeincrementalcodec
_PyCodecInfo_GetIncrementalEncoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@MNIHGCMD@encoder?5must?5return?5a?5tuple?5?$CIobj@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyEval_CallObjectWithKeywords:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyCodec_EncodeInternal DD imagerel _PyCodec_EncodeInternal
	DD	imagerel _PyCodec_EncodeInternal+87
	DD	imagerel $unwind$_PyCodec_EncodeInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyCodec_EncodeInternal DD imagerel _PyCodec_EncodeInternal+87
	DD	imagerel _PyCodec_EncodeInternal+152
	DD	imagerel $chain$0$_PyCodec_EncodeInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyCodec_EncodeInternal DD imagerel _PyCodec_EncodeInternal+152
	DD	imagerel _PyCodec_EncodeInternal+533
	DD	imagerel $chain$1$_PyCodec_EncodeInternal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyCodec_EncodeInternal DD 021H
	DD	imagerel _PyCodec_EncodeInternal
	DD	imagerel _PyCodec_EncodeInternal+87
	DD	imagerel $unwind$_PyCodec_EncodeInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyCodec_EncodeInternal DD 020521H
	DD	083405H
	DD	imagerel _PyCodec_EncodeInternal
	DD	imagerel _PyCodec_EncodeInternal+87
	DD	imagerel $unwind$_PyCodec_EncodeInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_EncodeInternal DD 060f01H
	DD	0a640fH
	DD	09540fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CO@MNIHGCMD@encoder?5must?5return?5a?5tuple?5?$CIobj@
CONST	SEGMENT
??_C@_0CO@MNIHGCMD@encoder?5must?5return?5a?5tuple?5?$CIobj@ DB 'encoder '
	DB	'must return a tuple (object, integer)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
CONST	ENDS
;	COMDAT _PyCodec_EncodeInternal
_TEXT	SEGMENT
object$ = 64
encoder$ = 72
errors$ = 80
_PyCodec_EncodeInternal PROC				; COMDAT

; 373  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fa	 mov	 rdi, rdx

; 374  :     PyObject *args = NULL, *result = NULL;
; 375  :     PyObject *v = NULL;
; 376  : 
; 377  :     args = args_tuple(object, errors);

  00012	49 8b d0	 mov	 rdx, r8
  00015	e8 00 00 00 00	 call	 args_tuple
  0001a	48 8b e8	 mov	 rbp, rax

; 378  :     if (args == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	0f 84 4f 01 00
	00		 je	 $LN7@PyCodec_En

; 379  :         goto onError;
; 380  : 
; 381  :     result = PyEval_CallObject(encoder, args);

  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 8b d0	 mov	 rdx, rax
  0002c	48 8b cf	 mov	 rcx, rdi
  0002f	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  00034	48 8b f0	 mov	 rsi, rax

; 382  :     if (result == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	0f 84 d0 00 00
	00		 je	 $LN11@PyCodec_En

; 383  :         goto onError;
; 384  : 
; 385  :     if (!PyTuple_Check(result) ||
; 386  :         PyTuple_GET_SIZE(result) != 2) {

  00040	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00044	f7 81 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rcx+256], 67108864 ; 04000000H
  0004e	74 48		 je	 SHORT $LN13@PyCodec_En
  00050	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00055	75 41		 jne	 SHORT $LN13@PyCodec_En

; 389  :         goto onError;
; 390  :     }
; 391  :     v = PyTuple_GET_ITEM(result,0);

  00057	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0005c	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]

; 392  :     Py_INCREF(v);

  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 _Py_IncRef

; 393  :     /* We don't check or use the second (integer) entry. */
; 394  : 
; 395  :     Py_DECREF(args);

  00068	48 8b cd	 mov	 rcx, rbp
  0006b	e8 00 00 00 00	 call	 _Py_DecRef

; 396  :     Py_DECREF(encoder);

  00070	48 8b cf	 mov	 rcx, rdi
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 397  :     Py_DECREF(result);

  00078	48 8b ce	 mov	 rcx, rsi
  0007b	e8 00 00 00 00	 call	 _Py_DecRef

; 398  :     return v;

  00080	48 8b c3	 mov	 rax, rbx
  00083	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 405  : }

  00088	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0008d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
$LN13@PyCodec_En:

; 387  :         PyErr_SetString(PyExc_TypeError,
; 388  :                         "encoder must return a tuple (object, integer)");

  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@MNIHGCMD@encoder?5must?5return?5a?5tuple?5?$CIobj@
  000a6	e8 00 00 00 00	 call	 PyErr_SetString
$onError$20433:

; 399  : 
; 400  :  onError:
; 401  :     Py_XDECREF(result);

  000ab	e8 00 00 00 00	 call	 _Py_PXCTX
  000b0	85 c0		 test	 eax, eax
  000b2	75 5c		 jne	 SHORT $LN11@PyCodec_En
  000b4	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000b8	a8 20		 test	 al, 32			; 00000020H
  000ba	75 4c		 jne	 SHORT $LN23@PyCodec_En
  000bc	84 c0		 test	 al, al
  000be	78 48		 js	 SHORT $LN23@PyCodec_En
  000c0	a8 02		 test	 al, 2
  000c2	75 4c		 jne	 SHORT $LN11@PyCodec_En
  000c4	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  000c8	75 46		 jne	 SHORT $LN11@PyCodec_En
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000d8	4c 8b ce	 mov	 r9, rsi
  000db	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000e1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ee	48 8b ce	 mov	 rcx, rsi
  000f1	85 c0		 test	 eax, eax
  000f3	74 07		 je	 SHORT $LN28@PyCodec_En
  000f5	e8 00 00 00 00	 call	 _Px_Dealloc
  000fa	eb 14		 jmp	 SHORT $LN11@PyCodec_En
$LN28@PyCodec_En:
  000fc	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00100	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00106	eb 08		 jmp	 SHORT $LN11@PyCodec_En
$LN23@PyCodec_En:
  00108	48 8b ce	 mov	 rcx, rsi
  0010b	e8 00 00 00 00	 call	 Px_DecRef
$LN11@PyCodec_En:

; 402  :     Py_XDECREF(args);

  00110	e8 00 00 00 00	 call	 _Py_PXCTX
  00115	85 c0		 test	 eax, eax
  00117	75 5c		 jne	 SHORT $LN7@PyCodec_En
  00119	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  0011d	a8 20		 test	 al, 32			; 00000020H
  0011f	75 4c		 jne	 SHORT $LN34@PyCodec_En
  00121	84 c0		 test	 al, al
  00123	78 48		 js	 SHORT $LN34@PyCodec_En
  00125	a8 02		 test	 al, 2
  00127	75 4c		 jne	 SHORT $LN7@PyCodec_En
  00129	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  0012d	75 46		 jne	 SHORT $LN7@PyCodec_En
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013d	4c 8b cd	 mov	 r9, rbp
  00140	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00146	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00153	48 8b cd	 mov	 rcx, rbp
  00156	85 c0		 test	 eax, eax
  00158	74 07		 je	 SHORT $LN39@PyCodec_En
  0015a	e8 00 00 00 00	 call	 _Px_Dealloc
  0015f	eb 14		 jmp	 SHORT $LN7@PyCodec_En
$LN39@PyCodec_En:
  00161	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00165	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0016b	eb 08		 jmp	 SHORT $LN7@PyCodec_En
$LN34@PyCodec_En:
  0016d	48 8b cd	 mov	 rcx, rbp
  00170	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyCodec_En:

; 403  :     Py_XDECREF(encoder);

  00175	48 85 ff	 test	 rdi, rdi
  00178	0f 84 85 00 00
	00		 je	 $LN3@PyCodec_En
  0017e	e8 00 00 00 00	 call	 _Py_PXCTX
  00183	85 c0		 test	 eax, eax
  00185	75 7c		 jne	 SHORT $LN3@PyCodec_En
  00187	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0018b	a8 20		 test	 al, 32			; 00000020H
  0018d	75 6c		 jne	 SHORT $LN45@PyCodec_En
  0018f	84 c0		 test	 al, al
  00191	78 68		 js	 SHORT $LN45@PyCodec_En
  00193	a8 02		 test	 al, 2
  00195	75 6c		 jne	 SHORT $LN3@PyCodec_En
  00197	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0019b	75 66		 jne	 SHORT $LN3@PyCodec_En
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001ab	4c 8b cf	 mov	 r9, rdi
  001ae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c1	48 8b cf	 mov	 rcx, rdi
  001c4	85 c0		 test	 eax, eax
  001c6	74 17		 je	 SHORT $LN50@PyCodec_En
  001c8	e8 00 00 00 00	 call	 _Px_Dealloc

; 404  :     return NULL;

  001cd	33 c0		 xor	 eax, eax

; 405  : }

  001cf	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001d4	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001dd	5f		 pop	 rdi
  001de	c3		 ret	 0

; 403  :     Py_XDECREF(encoder);

$LN50@PyCodec_En:
  001df	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001e3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 404  :     return NULL;

  001e9	33 c0		 xor	 eax, eax

; 405  : }

  001eb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001f0	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001f5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001f9	5f		 pop	 rdi
  001fa	c3		 ret	 0

; 403  :     Py_XDECREF(encoder);

$LN45@PyCodec_En:
  001fb	48 8b cf	 mov	 rcx, rdi
  001fe	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyCodec_En:

; 405  : }

  00203	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00208	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0020d	33 c0		 xor	 eax, eax
  0020f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00213	5f		 pop	 rdi
  00214	c3		 ret	 0
_PyCodec_EncodeInternal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@KGDHGJFI@decoder?5must?5return?5a?5tuple?5?$CIobj@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyCodec_DecodeInternal DD imagerel _PyCodec_DecodeInternal
	DD	imagerel _PyCodec_DecodeInternal+85
	DD	imagerel $unwind$_PyCodec_DecodeInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyCodec_DecodeInternal DD imagerel _PyCodec_DecodeInternal+85
	DD	imagerel _PyCodec_DecodeInternal+150
	DD	imagerel $chain$0$_PyCodec_DecodeInternal
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_PyCodec_DecodeInternal DD imagerel _PyCodec_DecodeInternal+150
	DD	imagerel _PyCodec_DecodeInternal+536
	DD	imagerel $chain$1$_PyCodec_DecodeInternal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_PyCodec_DecodeInternal DD 021H
	DD	imagerel _PyCodec_DecodeInternal
	DD	imagerel _PyCodec_DecodeInternal+85
	DD	imagerel $unwind$_PyCodec_DecodeInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyCodec_DecodeInternal DD 020521H
	DD	083405H
	DD	imagerel _PyCodec_DecodeInternal
	DD	imagerel _PyCodec_DecodeInternal+85
	DD	imagerel $unwind$_PyCodec_DecodeInternal
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_DecodeInternal DD 060f01H
	DD	0a640fH
	DD	09540fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CN@KGDHGJFI@decoder?5must?5return?5a?5tuple?5?$CIobj@
CONST	SEGMENT
??_C@_0CN@KGDHGJFI@decoder?5must?5return?5a?5tuple?5?$CIobj@ DB 'decoder '
	DB	'must return a tuple (object,integer)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
CONST	ENDS
;	COMDAT _PyCodec_DecodeInternal
_TEXT	SEGMENT
object$ = 64
decoder$ = 72
errors$ = 80
_PyCodec_DecodeInternal PROC				; COMDAT

; 417  : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f2	 mov	 rsi, rdx

; 418  :     PyObject *args = NULL, *result = NULL;
; 419  :     PyObject *v;
; 420  : 
; 421  :     args = args_tuple(object, errors);

  00012	49 8b d0	 mov	 rdx, r8
  00015	33 ff		 xor	 edi, edi
  00017	e8 00 00 00 00	 call	 args_tuple
  0001c	48 8b e8	 mov	 rbp, rax

; 422  :     if (args == NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	0f 84 e6 00 00
	00		 je	 $LN11@PyCodec_De

; 423  :         goto onError;
; 424  : 
; 425  :     result = PyEval_CallObject(decoder,args);

  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b ce	 mov	 rcx, rsi
  00031	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  00036	48 8b f8	 mov	 rdi, rax

; 426  :     if (result == NULL)

  00039	48 85 c0	 test	 rax, rax
  0003c	74 6b		 je	 SHORT $onError$20481

; 427  :         goto onError;
; 428  :     if (!PyTuple_Check(result) ||
; 429  :         PyTuple_GET_SIZE(result) != 2) {

  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	f7 81 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rcx+256], 67108864 ; 04000000H
  0004c	74 48		 je	 SHORT $LN13@PyCodec_De
  0004e	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00053	75 41		 jne	 SHORT $LN13@PyCodec_De

; 432  :         goto onError;
; 433  :     }
; 434  :     v = PyTuple_GET_ITEM(result,0);

  00055	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0005a	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]

; 435  :     Py_INCREF(v);

  0005e	48 8b cb	 mov	 rcx, rbx
  00061	e8 00 00 00 00	 call	 _Py_IncRef

; 436  :     /* We don't check or use the second (integer) entry. */
; 437  : 
; 438  :     Py_DECREF(args);

  00066	48 8b cd	 mov	 rcx, rbp
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 439  :     Py_DECREF(decoder);

  0006e	48 8b ce	 mov	 rcx, rsi
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 440  :     Py_DECREF(result);

  00076	48 8b cf	 mov	 rcx, rdi
  00079	e8 00 00 00 00	 call	 _Py_DecRef

; 441  :     return v;

  0007e	48 8b c3	 mov	 rax, rbx
  00081	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 448  : }

  00086	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0008b	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00090	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
$LN13@PyCodec_De:

; 430  :         PyErr_SetString(PyExc_TypeError,
; 431  :                         "decoder must return a tuple (object,integer)");

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@KGDHGJFI@decoder?5must?5return?5a?5tuple?5?$CIobj@
  000a4	e8 00 00 00 00	 call	 PyErr_SetString
$onError$20481:

; 442  : 
; 443  :  onError:
; 444  :     Py_XDECREF(args);

  000a9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ae	85 c0		 test	 eax, eax
  000b0	75 5c		 jne	 SHORT $LN11@PyCodec_De
  000b2	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  000b6	a8 20		 test	 al, 32			; 00000020H
  000b8	75 4c		 jne	 SHORT $LN23@PyCodec_De
  000ba	84 c0		 test	 al, al
  000bc	78 48		 js	 SHORT $LN23@PyCodec_De
  000be	a8 02		 test	 al, 2
  000c0	75 4c		 jne	 SHORT $LN11@PyCodec_De
  000c2	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  000c6	75 46		 jne	 SHORT $LN11@PyCodec_De
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000d6	4c 8b cd	 mov	 r9, rbp
  000d9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000df	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ec	48 8b cd	 mov	 rcx, rbp
  000ef	85 c0		 test	 eax, eax
  000f1	74 07		 je	 SHORT $LN28@PyCodec_De
  000f3	e8 00 00 00 00	 call	 _Px_Dealloc
  000f8	eb 14		 jmp	 SHORT $LN11@PyCodec_De
$LN28@PyCodec_De:
  000fa	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  000fe	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00104	eb 08		 jmp	 SHORT $LN11@PyCodec_De
$LN23@PyCodec_De:
  00106	48 8b cd	 mov	 rcx, rbp
  00109	e8 00 00 00 00	 call	 Px_DecRef
$LN11@PyCodec_De:

; 445  :     Py_XDECREF(decoder);

  0010e	48 85 f6	 test	 rsi, rsi
  00111	74 65		 je	 SHORT $LN7@PyCodec_De
  00113	e8 00 00 00 00	 call	 _Py_PXCTX
  00118	85 c0		 test	 eax, eax
  0011a	75 5c		 jne	 SHORT $LN7@PyCodec_De
  0011c	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  00120	a8 20		 test	 al, 32			; 00000020H
  00122	75 4c		 jne	 SHORT $LN34@PyCodec_De
  00124	84 c0		 test	 al, al
  00126	78 48		 js	 SHORT $LN34@PyCodec_De
  00128	a8 02		 test	 al, 2
  0012a	75 4c		 jne	 SHORT $LN7@PyCodec_De
  0012c	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  00130	75 46		 jne	 SHORT $LN7@PyCodec_De
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00140	4c 8b ce	 mov	 r9, rsi
  00143	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00149	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00151	e8 00 00 00 00	 call	 _PyParallel_Guard
  00156	48 8b ce	 mov	 rcx, rsi
  00159	85 c0		 test	 eax, eax
  0015b	74 07		 je	 SHORT $LN39@PyCodec_De
  0015d	e8 00 00 00 00	 call	 _Px_Dealloc
  00162	eb 14		 jmp	 SHORT $LN7@PyCodec_De
$LN39@PyCodec_De:
  00164	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00168	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0016e	eb 08		 jmp	 SHORT $LN7@PyCodec_De
$LN34@PyCodec_De:
  00170	48 8b ce	 mov	 rcx, rsi
  00173	e8 00 00 00 00	 call	 Px_DecRef
$LN7@PyCodec_De:

; 446  :     Py_XDECREF(result);

  00178	48 85 ff	 test	 rdi, rdi
  0017b	0f 84 85 00 00
	00		 je	 $LN3@PyCodec_De
  00181	e8 00 00 00 00	 call	 _Py_PXCTX
  00186	85 c0		 test	 eax, eax
  00188	75 7c		 jne	 SHORT $LN3@PyCodec_De
  0018a	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0018e	a8 20		 test	 al, 32			; 00000020H
  00190	75 6c		 jne	 SHORT $LN45@PyCodec_De
  00192	84 c0		 test	 al, al
  00194	78 68		 js	 SHORT $LN45@PyCodec_De
  00196	a8 02		 test	 al, 2
  00198	75 6c		 jne	 SHORT $LN3@PyCodec_De
  0019a	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0019e	75 66		 jne	 SHORT $LN3@PyCodec_De
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001ae	4c 8b cf	 mov	 r9, rdi
  001b1	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001b7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001bf	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c4	48 8b cf	 mov	 rcx, rdi
  001c7	85 c0		 test	 eax, eax
  001c9	74 17		 je	 SHORT $LN50@PyCodec_De
  001cb	e8 00 00 00 00	 call	 _Px_Dealloc

; 447  :     return NULL;

  001d0	33 c0		 xor	 eax, eax

; 448  : }

  001d2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001d7	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001e0	5f		 pop	 rdi
  001e1	c3		 ret	 0

; 446  :     Py_XDECREF(result);

$LN50@PyCodec_De:
  001e2	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  001e6	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 447  :     return NULL;

  001ec	33 c0		 xor	 eax, eax

; 448  : }

  001ee	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001f3	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  001f8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001fc	5f		 pop	 rdi
  001fd	c3		 ret	 0

; 446  :     Py_XDECREF(result);

$LN45@PyCodec_De:
  001fe	48 8b cf	 mov	 rcx, rdi
  00201	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyCodec_De:

; 448  : }

  00206	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0020b	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00210	33 c0		 xor	 eax, eax
  00212	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00216	5f		 pop	 rdi
  00217	c3		 ret	 0
_PyCodec_DecodeInternal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@ICFBCEJM@handler?5must?5be?5callable?$AA@ ; `string'
PUBLIC	PyCodec_RegisterError
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyCallable_Check:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	_PyParallel_GetThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_RegisterError DD imagerel $LN8
	DD	imagerel $LN8+144
	DD	imagerel $unwind$PyCodec_RegisterError
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_RegisterError DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BJ@ICFBCEJM@handler?5must?5be?5callable?$AA@
CONST	SEGMENT
??_C@_0BJ@ICFBCEJM@handler?5must?5be?5callable?$AA@ DB 'handler must be c'
	DB	'allable', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_RegisterError
_TEXT	SEGMENT
name$ = 48
error$ = 56
PyCodec_RegisterError PROC				; COMDAT

; 583  : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b f1	 mov	 rsi, rcx

; 584  :     PyInterpreterState *interp = PyThreadState_GET()->interp;

  00015	e8 00 00 00 00	 call	 _Py_PXCTX
  0001a	85 c0		 test	 eax, eax
  0001c	74 07		 je	 SHORT $LN5@PyCodec_Re
  0001e	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00023	eb 07		 jmp	 SHORT $LN6@PyCodec_Re
$LN5@PyCodec_Re:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN6@PyCodec_Re:
  0002c	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]

; 585  :     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())

  00030	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  00035	75 09		 jne	 SHORT $LN2@PyCodec_Re
  00037	e8 00 00 00 00	 call	 _PyCodecRegistry_Init
  0003c	85 c0		 test	 eax, eax

; 586  :         return -1;

  0003e	75 1f		 jne	 SHORT $LN7@PyCodec_Re
$LN2@PyCodec_Re:

; 587  :     if (!PyCallable_Check(error)) {

  00040	48 8b cf	 mov	 rcx, rdi
  00043	e8 00 00 00 00	 call	 PyCallable_Check
  00048	85 c0		 test	 eax, eax
  0004a	75 26		 jne	 SHORT $LN1@PyCodec_Re

; 588  :         PyErr_SetString(PyExc_TypeError, "handler must be callable");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@ICFBCEJM@handler?5must?5be?5callable?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@PyCodec_Re:

; 589  :         return -1;

  0005f	83 c8 ff	 or	 eax, -1

; 593  : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5f		 pop	 rdi
  00071	c3		 ret	 0
$LN1@PyCodec_Re:

; 590  :     }
; 591  :     return PyDict_SetItemString(interp->codec_error_registry,
; 592  :                                 (char *)name, error);

  00072	48 8b 4b 48	 mov	 rcx, QWORD PTR [rbx+72]
  00076	4c 8b c7	 mov	 r8, rdi
  00079	48 8b d6	 mov	 rdx, rsi

; 593  : }

  0007c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00081	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5f		 pop	 rdi
  0008b	e9 00 00 00 00	 jmp	 PyDict_SetItemString
PyCodec_RegisterError ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@DJKMKMDO@don?8t?5know?5how?5to?5handle?5?$CFS?5in?5e@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrong_exception_type DD imagerel wrong_exception_type
	DD	imagerel wrong_exception_type+123
	DD	imagerel $unwind$wrong_exception_type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrong_exception_type DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CO@DJKMKMDO@don?8t?5know?5how?5to?5handle?5?$CFS?5in?5e@
CONST	SEGMENT
??_C@_0CO@DJKMKMDO@don?8t?5know?5how?5to?5handle?5?$CFS?5in?5e@ DB 'don'''
	DB	't know how to handle %S in error callback', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT wrong_exception_type
_TEXT	SEGMENT
exc$ = 48
wrong_exception_type PROC				; COMDAT

; 617  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 618  :     _Py_IDENTIFIER(__class__);
; 619  :     _Py_IDENTIFIER(__name__);
; 620  :     PyObject *type = _PyObject_GetAttrId(exc, &PyId___class__);

  0000a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00010	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00019	48 8b 1c d0	 mov	 rbx, QWORD PTR [rax+rdx*8]
  0001d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___class__@?1??wrong_exception_type@@9@9
  00022	48 03 d3	 add	 rdx, rbx
  00025	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0002a	48 8b f8	 mov	 rdi, rax

; 621  :     if (type != NULL) {

  0002d	48 85 c0	 test	 rax, rax
  00030	74 3e		 je	 SHORT $LN1@wrong_exce

; 622  :         PyObject *name = _PyObject_GetAttrId(type, &PyId___name__);

  00032	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___name__@?1??wrong_exception_type@@9@9
  00037	48 8b c8	 mov	 rcx, rax
  0003a	48 03 d3	 add	 rdx, rbx
  0003d	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 623  :         Py_DECREF(type);

  00042	48 8b cf	 mov	 rcx, rdi
  00045	48 8b d8	 mov	 rbx, rax
  00048	e8 00 00 00 00	 call	 _Py_DecRef

; 624  :         if (name != NULL) {

  0004d	48 85 db	 test	 rbx, rbx
  00050	74 1e		 je	 SHORT $LN1@wrong_exce

; 625  :             PyErr_Format(PyExc_TypeError,
; 626  :                          "don't know how to handle %S in error callback", name);

  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@DJKMKMDO@don?8t?5know?5how?5to?5handle?5?$CFS?5in?5e@
  00060	4c 8b c3	 mov	 r8, rbx
  00063	e8 00 00 00 00	 call	 PyErr_Format

; 627  :             Py_DECREF(name);

  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@wrong_exce:

; 628  :         }
; 629  :     }
; 630  : }

  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
wrong_exception_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@PECDDKM@codec?5must?5pass?5exception?5instan@ ; `string'
PUBLIC	PyCodec_StrictErrors
EXTRN	PyErr_SetObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_StrictErrors DD imagerel $LN6
	DD	imagerel $LN6+64
	DD	imagerel $unwind$PyCodec_StrictErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_StrictErrors DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CD@PECDDKM@codec?5must?5pass?5exception?5instan@
CONST	SEGMENT
??_C@_0CD@PECDDKM@codec?5must?5pass?5exception?5instan@ DB 'codec must pa'
	DB	'ss exception instance', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_StrictErrors
_TEXT	SEGMENT
exc$ = 48
PyCodec_StrictErrors PROC				; COMDAT

; 633  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 634  :     if (PyExceptionInstance_Check(exc))

  00004	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00008	f7 80 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rax+256], 1073741824 ; 40000000H
  00012	74 12		 je	 SHORT $LN2@PyCodec_St

; 635  :         PyErr_SetObject(PyExceptionInstance_Class(exc), exc);

  00014	48 8b d1	 mov	 rdx, rcx
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 PyErr_SetObject

; 638  :     return NULL;

  0001f	33 c0		 xor	 eax, eax

; 639  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN2@PyCodec_St:

; 636  :     else
; 637  :         PyErr_SetString(PyExc_TypeError, "codec must pass exception instance");

  00026	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@PECDDKM@codec?5must?5pass?5exception?5instan@
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 638  :     return NULL;

  00039	33 c0		 xor	 eax, eax

; 639  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
PyCodec_StrictErrors ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@		; `string'
PUBLIC	PyCodec_IgnoreErrors
EXTRN	Py_BuildValue:PROC
EXTRN	PyUnicode_New:PROC
EXTRN	PyUnicodeTranslateError_GetEnd:PROC
EXTRN	PyExc_UnicodeTranslateError:QWORD
EXTRN	PyUnicodeDecodeError_GetEnd:PROC
EXTRN	PyExc_UnicodeDecodeError:QWORD
EXTRN	PyUnicodeEncodeError_GetEnd:PROC
EXTRN	PyObject_IsInstance:PROC
EXTRN	PyExc_UnicodeEncodeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_IgnoreErrors DD imagerel $LN13
	DD	imagerel $LN13+172
	DD	imagerel $unwind$PyCodec_IgnoreErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_IgnoreErrors DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
CONST	SEGMENT
??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@ DB '(Nn)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_IgnoreErrors
_TEXT	SEGMENT
exc$ = 48
end$ = 56
PyCodec_IgnoreErrors PROC				; COMDAT

; 643  : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 644  :     Py_ssize_t end;
; 645  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	e8 00 00 00 00	 call	 PyObject_IsInstance

; 646  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00015	48 8b cb	 mov	 rcx, rbx
  00018	85 c0		 test	 eax, eax
  0001a	74 16		 je	 SHORT $LN9@PyCodec_Ig
  0001c	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  00021	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  00026	85 c0		 test	 eax, eax
  00028	74 52		 je	 SHORT $LN2@PyCodec_Ig

; 659  :         return NULL;

  0002a	33 c0		 xor	 eax, eax

; 662  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN9@PyCodec_Ig:

; 647  :             return NULL;
; 648  :     }
; 649  :     else if (PyObject_IsInstance(exc, PyExc_UnicodeDecodeError)) {

  00032	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeDecodeError
  00039	e8 00 00 00 00	 call	 PyObject_IsInstance

; 650  :         if (PyUnicodeDecodeError_GetEnd(exc, &end))

  0003e	48 8b cb	 mov	 rcx, rbx
  00041	85 c0		 test	 eax, eax
  00043	74 16		 je	 SHORT $LN6@PyCodec_Ig
  00045	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  0004a	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetEnd
  0004f	85 c0		 test	 eax, eax
  00051	74 29		 je	 SHORT $LN2@PyCodec_Ig

; 659  :         return NULL;

  00053	33 c0		 xor	 eax, eax

; 662  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
$LN6@PyCodec_Ig:

; 651  :             return NULL;
; 652  :     }
; 653  :     else if (PyObject_IsInstance(exc, PyExc_UnicodeTranslateError)) {

  0005b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeTranslateError
  00062	e8 00 00 00 00	 call	 PyObject_IsInstance

; 654  :         if (PyUnicodeTranslateError_GetEnd(exc, &end))

  00067	48 8b cb	 mov	 rcx, rbx
  0006a	85 c0		 test	 eax, eax
  0006c	74 31		 je	 SHORT $LN3@PyCodec_Ig
  0006e	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  00073	e8 00 00 00 00	 call	 PyUnicodeTranslateError_GetEnd
  00078	85 c0		 test	 eax, eax

; 655  :             return NULL;

  0007a	75 28		 jne	 SHORT $LN12@PyCodec_Ig
$LN2@PyCodec_Ig:

; 660  :     }
; 661  :     return Py_BuildValue("(Nn)", PyUnicode_New(0, 0), end);

  0007c	33 d2		 xor	 edx, edx
  0007e	33 c9		 xor	 ecx, ecx
  00080	e8 00 00 00 00	 call	 PyUnicode_New
  00085	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$[rsp]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  00091	48 8b d0	 mov	 rdx, rax
  00094	e8 00 00 00 00	 call	 Py_BuildValue

; 662  : }

  00099	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
$LN3@PyCodec_Ig:

; 656  :     }
; 657  :     else {
; 658  :         wrong_exception_type(exc);

  0009f	e8 00 00 00 00	 call	 wrong_exception_type
$LN12@PyCodec_Ig:

; 659  :         return NULL;

  000a4	33 c0		 xor	 eax, eax

; 662  : }

  000a6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000aa	5b		 pop	 rbx
  000ab	c3		 ret	 0
PyCodec_IgnoreErrors ENDP
_TEXT	ENDS
PUBLIC	??_C@_04EHMCOCDF@?$CICn?$CJ?$AA@		; `string'
PUBLIC	PyCodec_ReplaceErrors
EXTRN	PyUnicodeTranslateError_GetStart:PROC
EXTRN	PyUnicodeEncodeError_GetStart:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_ReplaceErrors DD imagerel $LN51
	DD	imagerel $LN51+516
	DD	imagerel $unwind$PyCodec_ReplaceErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_ReplaceErrors DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04EHMCOCDF@?$CICn?$CJ?$AA@
CONST	SEGMENT
??_C@_04EHMCOCDF@?$CICn?$CJ?$AA@ DB '(Cn)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_ReplaceErrors
_TEXT	SEGMENT
exc$ = 48
end$ = 56
start$ = 64
PyCodec_ReplaceErrors PROC				; COMDAT

; 666  : {

$LN51:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 667  :     Py_ssize_t start, end, i, len;
; 668  : 
; 669  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  0000a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  00011	48 8b d9	 mov	 rbx, rcx
  00014	e8 00 00 00 00	 call	 PyObject_IsInstance

; 670  :         PyObject *res;
; 671  :         int kind;
; 672  :         void *data;
; 673  :         if (PyUnicodeEncodeError_GetStart(exc, &start))

  00019	48 8b cb	 mov	 rcx, rbx
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 c5 00 00
	00		 je	 $LN35@PyCodec_Re@2
  00024	48 8d 54 24 40	 lea	 rdx, QWORD PTR start$[rsp]
  00029	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetStart
  0002e	85 c0		 test	 eax, eax

; 674  :             return NULL;

  00030	0f 85 c1 01 00
	00		 jne	 $LN50@PyCodec_Re@2

; 675  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00036	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  00043	85 c0		 test	 eax, eax

; 676  :             return NULL;

  00045	0f 85 ac 01 00
	00		 jne	 $LN50@PyCodec_Re@2

; 677  :         len = end - start;

  0004b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR end$[rsp]

; 678  :         res = PyUnicode_New(len, '?');

  00050	bf 3f 00 00 00	 mov	 edi, 63			; 0000003fH
  00055	48 2b 5c 24 40	 sub	 rbx, QWORD PTR start$[rsp]
  0005a	8b d7		 mov	 edx, edi
  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 PyUnicode_New
  00064	4c 8b d8	 mov	 r11, rax

; 679  :         if (res == NULL)

  00067	48 85 c0	 test	 rax, rax

; 680  :             return NULL;

  0006a	0f 84 87 01 00
	00		 je	 $LN50@PyCodec_Re@2

; 681  :         kind = PyUnicode_KIND(res);

  00070	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00073	44 8b c8	 mov	 r9d, eax
  00076	41 c1 e9 02	 shr	 r9d, 2
  0007a	41 83 e1 07	 and	 r9d, 7

; 682  :         data = PyUnicode_DATA(res);

  0007e	a8 20		 test	 al, 32			; 00000020H
  00080	74 16		 je	 SHORT $LN40@PyCodec_Re@2
  00082	a8 40		 test	 al, 64			; 00000040H
  00084	74 09		 je	 SHORT $LN38@PyCodec_Re@2
  00086	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  0008d	eb 10		 jmp	 SHORT $LN41@PyCodec_Re@2
$LN38@PyCodec_Re@2:
  0008f	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  00096	eb 07		 jmp	 SHORT $LN41@PyCodec_Re@2
$LN40@PyCodec_Re@2:
  00098	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN41@PyCodec_Re@2:

; 683  :         for (i = 0; i < len; ++i)

  0009f	33 c9		 xor	 ecx, ecx
  000a1	48 85 db	 test	 rbx, rbx
  000a4	7e 24		 jle	 SHORT $LN29@PyCodec_Re@2
$LL31@PyCodec_Re@2:

; 684  :             PyUnicode_WRITE(kind, data, i, '?');

  000a6	41 8b d1	 mov	 edx, r9d
  000a9	ff ca		 dec	 edx
  000ab	74 11		 je	 SHORT $LN23@PyCodec_Re@2
  000ad	ff ca		 dec	 edx
  000af	74 06		 je	 SHORT $LN22@PyCodec_Re@2
  000b1	41 89 3c 88	 mov	 DWORD PTR [r8+rcx*4], edi
  000b5	eb 0b		 jmp	 SHORT $LN27@PyCodec_Re@2
$LN22@PyCodec_Re@2:
  000b7	66 41 89 3c 48	 mov	 WORD PTR [r8+rcx*2], di
  000bc	eb 04		 jmp	 SHORT $LN27@PyCodec_Re@2
$LN23@PyCodec_Re@2:
  000be	42 88 3c 01	 mov	 BYTE PTR [rcx+r8], dil
$LN27@PyCodec_Re@2:

; 683  :         for (i = 0; i < len; ++i)

  000c2	48 ff c1	 inc	 rcx
  000c5	48 3b cb	 cmp	 rcx, rbx
  000c8	7c dc		 jl	 SHORT $LL31@PyCodec_Re@2
$LN29@PyCodec_Re@2:

; 685  :         assert(_PyUnicode_CheckConsistency(res, 1));
; 686  :         return Py_BuildValue("(Nn)", res, end);

  000ca	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$[rsp]
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  000d6	49 8b d3	 mov	 rdx, r11
  000d9	e8 00 00 00 00	 call	 Py_BuildValue

; 717  :     }
; 718  : }

  000de	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e7	5f		 pop	 rdi
  000e8	c3		 ret	 0
$LN35@PyCodec_Re@2:

; 687  :     }
; 688  :     else if (PyObject_IsInstance(exc, PyExc_UnicodeDecodeError)) {

  000e9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeDecodeError
  000f0	e8 00 00 00 00	 call	 PyObject_IsInstance

; 689  :         if (PyUnicodeDecodeError_GetEnd(exc, &end))

  000f5	48 8b cb	 mov	 rcx, rbx
  000f8	85 c0		 test	 eax, eax
  000fa	74 33		 je	 SHORT $LN19@PyCodec_Re@2
  000fc	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  00101	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetEnd
  00106	85 c0		 test	 eax, eax

; 690  :             return NULL;

  00108	0f 85 e9 00 00
	00		 jne	 $LN50@PyCodec_Re@2

; 691  :         return Py_BuildValue("(Cn)",
; 692  :                              (int)Py_UNICODE_REPLACEMENT_CHARACTER,
; 693  :                              end);

  0010e	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04EHMCOCDF@?$CICn?$CJ?$AA@
  0011a	ba fd ff 00 00	 mov	 edx, 65533		; 0000fffdH
  0011f	e8 00 00 00 00	 call	 Py_BuildValue

; 717  :     }
; 718  : }

  00124	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00129	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012d	5f		 pop	 rdi
  0012e	c3		 ret	 0
$LN19@PyCodec_Re@2:

; 694  :     }
; 695  :     else if (PyObject_IsInstance(exc, PyExc_UnicodeTranslateError)) {

  0012f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeTranslateError
  00136	e8 00 00 00 00	 call	 PyObject_IsInstance

; 696  :         PyObject *res;
; 697  :         int kind;
; 698  :         void *data;
; 699  :         if (PyUnicodeTranslateError_GetStart(exc, &start))

  0013b	48 8b cb	 mov	 rcx, rbx
  0013e	85 c0		 test	 eax, eax
  00140	0f 84 ac 00 00
	00		 je	 $LN16@PyCodec_Re@2
  00146	48 8d 54 24 40	 lea	 rdx, QWORD PTR start$[rsp]
  0014b	e8 00 00 00 00	 call	 PyUnicodeTranslateError_GetStart
  00150	85 c0		 test	 eax, eax

; 700  :             return NULL;

  00152	0f 85 9f 00 00
	00		 jne	 $LN50@PyCodec_Re@2

; 701  :         if (PyUnicodeTranslateError_GetEnd(exc, &end))

  00158	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  0015d	48 8b cb	 mov	 rcx, rbx
  00160	e8 00 00 00 00	 call	 PyUnicodeTranslateError_GetEnd
  00165	85 c0		 test	 eax, eax

; 702  :             return NULL;

  00167	0f 85 8a 00 00
	00		 jne	 $LN50@PyCodec_Re@2

; 703  :         len = end - start;

  0016d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR end$[rsp]

; 704  :         res = PyUnicode_New(len, Py_UNICODE_REPLACEMENT_CHARACTER);

  00172	bb fd ff 00 00	 mov	 ebx, 65533		; 0000fffdH
  00177	48 2b 7c 24 40	 sub	 rdi, QWORD PTR start$[rsp]
  0017c	8b d3		 mov	 edx, ebx
  0017e	48 8b cf	 mov	 rcx, rdi
  00181	e8 00 00 00 00	 call	 PyUnicode_New
  00186	4c 8b d8	 mov	 r11, rax

; 705  :         if (res == NULL)

  00189	48 85 c0	 test	 rax, rax

; 706  :             return NULL;

  0018c	74 69		 je	 SHORT $LN50@PyCodec_Re@2

; 707  :         kind = PyUnicode_KIND(res);

  0018e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00191	44 8b c8	 mov	 r9d, eax
  00194	41 c1 e9 02	 shr	 r9d, 2
  00198	41 83 e1 07	 and	 r9d, 7

; 708  :         data = PyUnicode_DATA(res);

  0019c	a8 20		 test	 al, 32			; 00000020H
  0019e	74 16		 je	 SHORT $LN44@PyCodec_Re@2
  001a0	a8 40		 test	 al, 64			; 00000040H
  001a2	74 09		 je	 SHORT $LN42@PyCodec_Re@2
  001a4	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  001ab	eb 10		 jmp	 SHORT $LN45@PyCodec_Re@2
$LN42@PyCodec_Re@2:
  001ad	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  001b4	eb 07		 jmp	 SHORT $LN45@PyCodec_Re@2
$LN44@PyCodec_Re@2:
  001b6	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN45@PyCodec_Re@2:

; 709  :         for (i=0; i < len; i++)

  001bd	33 c9		 xor	 ecx, ecx
  001bf	48 85 ff	 test	 rdi, rdi
  001c2	0f 8e 02 ff ff
	ff		 jle	 $LN29@PyCodec_Re@2
$LL12@PyCodec_Re@2:

; 710  :             PyUnicode_WRITE(kind, data, i, Py_UNICODE_REPLACEMENT_CHARACTER);

  001c8	41 8b d1	 mov	 edx, r9d
  001cb	ff ca		 dec	 edx
  001cd	74 11		 je	 SHORT $LN4@PyCodec_Re@2
  001cf	ff ca		 dec	 edx
  001d1	74 06		 je	 SHORT $LN3@PyCodec_Re@2
  001d3	41 89 1c 88	 mov	 DWORD PTR [r8+rcx*4], ebx
  001d7	eb 0c		 jmp	 SHORT $LN8@PyCodec_Re@2
$LN3@PyCodec_Re@2:
  001d9	66 41 89 1c 48	 mov	 WORD PTR [r8+rcx*2], bx
  001de	eb 05		 jmp	 SHORT $LN8@PyCodec_Re@2
$LN4@PyCodec_Re@2:
  001e0	41 c6 04 08 fd	 mov	 BYTE PTR [r8+rcx], 253	; 000000fdH
$LN8@PyCodec_Re@2:

; 709  :         for (i=0; i < len; i++)

  001e5	48 ff c1	 inc	 rcx
  001e8	48 3b cf	 cmp	 rcx, rdi
  001eb	7c db		 jl	 SHORT $LL12@PyCodec_Re@2

; 711  :         assert(_PyUnicode_CheckConsistency(res, 1));
; 712  :         return Py_BuildValue("(Nn)", res, end);

  001ed	e9 d8 fe ff ff	 jmp	 $LN29@PyCodec_Re@2
$LN16@PyCodec_Re@2:

; 713  :     }
; 714  :     else {
; 715  :         wrong_exception_type(exc);

  001f2	e8 00 00 00 00	 call	 wrong_exception_type
$LN50@PyCodec_Re@2:

; 716  :         return NULL;

  001f7	33 c0		 xor	 eax, eax

; 717  :     }
; 718  : }

  001f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00202	5f		 pop	 rdi
  00203	c3		 ret	 0
PyCodec_ReplaceErrors ENDP
_TEXT	ENDS
PUBLIC	PyCodec_XMLCharRefReplaceErrors
EXTRN	PyUnicodeEncodeError_GetObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_XMLCharRefReplaceErrors DD imagerel $LN92
	DD	imagerel $LN92+74
	DD	imagerel $unwind$PyCodec_XMLCharRefReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyCodec_XMLCharRefReplaceErrors DD imagerel $LN92+74
	DD	imagerel $LN92+424
	DD	imagerel $chain$0$PyCodec_XMLCharRefReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyCodec_XMLCharRefReplaceErrors DD imagerel $LN92+424
	DD	imagerel $LN92+894
	DD	imagerel $chain$2$PyCodec_XMLCharRefReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyCodec_XMLCharRefReplaceErrors DD imagerel $LN92+894
	DD	imagerel $LN92+907
	DD	imagerel $chain$3$PyCodec_XMLCharRefReplaceErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyCodec_XMLCharRefReplaceErrors DD 021H
	DD	imagerel $LN92
	DD	imagerel $LN92+74
	DD	imagerel $unwind$PyCodec_XMLCharRefReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyCodec_XMLCharRefReplaceErrors DD 020021H
	DD	067400H
	DD	imagerel $LN92
	DD	imagerel $LN92+74
	DD	imagerel $unwind$PyCodec_XMLCharRefReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyCodec_XMLCharRefReplaceErrors DD 020521H
	DD	067405H
	DD	imagerel $LN92
	DD	imagerel $LN92+74
	DD	imagerel $unwind$PyCodec_XMLCharRefReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_XMLCharRefReplaceErrors DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_XMLCharRefReplaceErrors
_TEXT	SEGMENT
exc$ = 48
end$20806 = 56
start$20805 = 64
PyCodec_XMLCharRefReplaceErrors PROC			; COMDAT

; 721  : {

$LN92:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 722  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	e8 00 00 00 00	 call	 PyObject_IsInstance

; 723  :         PyObject *restuple;
; 724  :         PyObject *object;
; 725  :         Py_ssize_t i;
; 726  :         Py_ssize_t start;
; 727  :         Py_ssize_t end;
; 728  :         PyObject *res;
; 729  :         unsigned char *outp;
; 730  :         int ressize;
; 731  :         Py_UCS4 ch;
; 732  :         if (PyUnicodeEncodeError_GetStart(exc, &start))

  00015	48 8b cb	 mov	 rcx, rbx
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 5e 03 00
	00		 je	 $LN38@PyCodec_XM
  00020	48 8d 54 24 40	 lea	 rdx, QWORD PTR start$20805[rsp]
  00025	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetStart
  0002a	85 c0		 test	 eax, eax

; 733  :             return NULL;

  0002c	0f 85 51 03 00
	00		 jne	 $LN91@PyCodec_XM

; 734  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00032	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$20806[rsp]
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  0003f	85 c0		 test	 eax, eax

; 735  :             return NULL;

  00041	0f 85 3c 03 00
	00		 jne	 $LN91@PyCodec_XM

; 736  :         if (!(object = PyUnicodeEncodeError_GetObject(exc)))

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0004f	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetObject
  00054	48 8b f8	 mov	 rdi, rax
  00057	48 85 c0	 test	 rax, rax

; 737  :             return NULL;

  0005a	0f 84 3b 01 00
	00		 je	 $LN90@PyCodec_XM

; 738  :         for (i = start, ressize = 0; i < end; ++i) {

  00060	48 8b 54 24 40	 mov	 rdx, QWORD PTR start$20805[rsp]
  00065	4c 8b 5c 24 38	 mov	 r11, QWORD PTR end$20806[rsp]
  0006a	33 c0		 xor	 eax, eax
  0006c	49 3b d3	 cmp	 rdx, r11
  0006f	0f 8d 09 01 00
	00		 jge	 $LN32@PyCodec_XM
  00075	44 8b 4f 70	 mov	 r9d, DWORD PTR [rdi+112]
  00079	45 8b d1	 mov	 r10d, r9d
  0007c	45 8b c1	 mov	 r8d, r9d
  0007f	41 c1 ea 02	 shr	 r10d, 2
  00083	41 c1 e8 05	 shr	 r8d, 5
  00087	41 83 e2 07	 and	 r10d, 7
  0008b	41 83 e0 01	 and	 r8d, 1
  0008f	90		 npad	 1
$LL34@PyCodec_XM:

; 739  :             /* object is guaranteed to be "ready" */
; 740  :             ch = PyUnicode_READ_CHAR(object, i);

  00090	41 83 fa 01	 cmp	 r10d, 1
  00094	75 32		 jne	 SHORT $LN55@PyCodec_XM
  00096	45 85 c0	 test	 r8d, r8d
  00099	74 20		 je	 SHORT $LN43@PyCodec_XM
  0009b	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  0009f	74 0d		 je	 SHORT $LN41@PyCodec_XM
  000a1	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  000a8	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  000ac	eb 79		 jmp	 SHORT $LN54@PyCodec_XM
$LN41@PyCodec_XM:
  000ae	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  000b5	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  000b9	eb 6c		 jmp	 SHORT $LN54@PyCodec_XM
$LN43@PyCodec_XM:
  000bb	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
  000c2	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  000c6	eb 5f		 jmp	 SHORT $LN54@PyCodec_XM
$LN55@PyCodec_XM:
  000c8	41 83 fa 02	 cmp	 r10d, 2
  000cc	75 32		 jne	 SHORT $LN53@PyCodec_XM
  000ce	45 85 c0	 test	 r8d, r8d
  000d1	74 20		 je	 SHORT $LN47@PyCodec_XM
  000d3	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  000d7	74 0d		 je	 SHORT $LN45@PyCodec_XM
  000d9	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  000e0	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  000e4	eb 41		 jmp	 SHORT $LN54@PyCodec_XM
$LN45@PyCodec_XM:
  000e6	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  000ed	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  000f1	eb 34		 jmp	 SHORT $LN54@PyCodec_XM
$LN47@PyCodec_XM:
  000f3	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
  000fa	0f b7 0c 51	 movzx	 ecx, WORD PTR [rcx+rdx*2]
  000fe	eb 27		 jmp	 SHORT $LN54@PyCodec_XM
$LN53@PyCodec_XM:
  00100	45 85 c0	 test	 r8d, r8d
  00103	74 18		 je	 SHORT $LN51@PyCodec_XM
  00105	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  00109	74 09		 je	 SHORT $LN49@PyCodec_XM
  0010b	48 8d 8f 80 00
	00 00		 lea	 rcx, QWORD PTR [rdi+128]
  00112	eb 10		 jmp	 SHORT $LN52@PyCodec_XM
$LN49@PyCodec_XM:
  00114	48 8d 8f a0 00
	00 00		 lea	 rcx, QWORD PTR [rdi+160]
  0011b	eb 07		 jmp	 SHORT $LN52@PyCodec_XM
$LN51@PyCodec_XM:
  0011d	48 8b 8f a0 00
	00 00		 mov	 rcx, QWORD PTR [rdi+160]
$LN52@PyCodec_XM:
  00124	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
$LN54@PyCodec_XM:

; 741  :             if (ch<10)

  00127	83 f9 0a	 cmp	 ecx, 10
  0012a	73 05		 jae	 SHORT $LN31@PyCodec_XM

; 742  :                 ressize += 2+1+1;

  0012c	83 c0 04	 add	 eax, 4
  0012f	eb 41		 jmp	 SHORT $LN33@PyCodec_XM
$LN31@PyCodec_XM:

; 743  :             else if (ch<100)

  00131	83 f9 64	 cmp	 ecx, 100		; 00000064H
  00134	73 05		 jae	 SHORT $LN29@PyCodec_XM

; 744  :                 ressize += 2+2+1;

  00136	83 c0 05	 add	 eax, 5
  00139	eb 37		 jmp	 SHORT $LN33@PyCodec_XM
$LN29@PyCodec_XM:

; 745  :             else if (ch<1000)

  0013b	81 f9 e8 03 00
	00		 cmp	 ecx, 1000		; 000003e8H
  00141	73 05		 jae	 SHORT $LN27@PyCodec_XM

; 746  :                 ressize += 2+3+1;

  00143	83 c0 06	 add	 eax, 6
  00146	eb 2a		 jmp	 SHORT $LN33@PyCodec_XM
$LN27@PyCodec_XM:

; 747  :             else if (ch<10000)

  00148	81 f9 10 27 00
	00		 cmp	 ecx, 10000		; 00002710H
  0014e	73 05		 jae	 SHORT $LN25@PyCodec_XM

; 748  :                 ressize += 2+4+1;

  00150	83 c0 07	 add	 eax, 7
  00153	eb 1d		 jmp	 SHORT $LN33@PyCodec_XM
$LN25@PyCodec_XM:

; 749  :             else if (ch<100000)

  00155	81 f9 a0 86 01
	00		 cmp	 ecx, 100000		; 000186a0H
  0015b	73 05		 jae	 SHORT $LN23@PyCodec_XM

; 750  :                 ressize += 2+5+1;

  0015d	83 c0 08	 add	 eax, 8
  00160	eb 10		 jmp	 SHORT $LN33@PyCodec_XM
$LN23@PyCodec_XM:

; 751  :             else if (ch<1000000)

  00162	81 f9 40 42 0f
	00		 cmp	 ecx, 1000000		; 000f4240H
  00168	73 05		 jae	 SHORT $LN21@PyCodec_XM

; 752  :                 ressize += 2+6+1;

  0016a	83 c0 09	 add	 eax, 9

; 753  :             else

  0016d	eb 03		 jmp	 SHORT $LN33@PyCodec_XM
$LN21@PyCodec_XM:

; 754  :                 ressize += 2+7+1;

  0016f	83 c0 0a	 add	 eax, 10
$LN33@PyCodec_XM:

; 738  :         for (i = start, ressize = 0; i < end; ++i) {

  00172	48 ff c2	 inc	 rdx
  00175	49 3b d3	 cmp	 rdx, r11
  00178	0f 8c 12 ff ff
	ff		 jl	 $LL34@PyCodec_XM
$LN32@PyCodec_XM:

; 755  :         }
; 756  :         /* allocate replacement */
; 757  :         res = PyUnicode_New(ressize, 127);

  0017e	48 63 c8	 movsxd	 rcx, eax
  00181	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00186	e8 00 00 00 00	 call	 PyUnicode_New
  0018b	48 8b d8	 mov	 rbx, rax

; 758  :         if (res == NULL) {

  0018e	48 85 c0	 test	 rax, rax
  00191	75 15		 jne	 SHORT $LN19@PyCodec_XM

; 759  :             Py_DECREF(object);

  00193	48 8b cf	 mov	 rcx, rdi
  00196	e8 00 00 00 00	 call	 _Py_DecRef
$LN90@PyCodec_XM:

; 760  :             return NULL;

  0019b	33 c0		 xor	 eax, eax
  0019d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 813  :     }
; 814  : }

  001a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a6	5b		 pop	 rbx
  001a7	c3		 ret	 0
$LN19@PyCodec_XM:

; 761  :         }
; 762  :         outp = PyUnicode_1BYTE_DATA(res);

  001a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001ab	a8 20		 test	 al, 32			; 00000020H
  001ad	74 16		 je	 SHORT $LN59@PyCodec_XM
  001af	a8 40		 test	 al, 64			; 00000040H
  001b1	74 09		 je	 SHORT $LN57@PyCodec_XM
  001b3	4c 8d 93 80 00
	00 00		 lea	 r10, QWORD PTR [rbx+128]
  001ba	eb 10		 jmp	 SHORT $LN60@PyCodec_XM
$LN57@PyCodec_XM:
  001bc	4c 8d 93 a0 00
	00 00		 lea	 r10, QWORD PTR [rbx+160]
  001c3	eb 07		 jmp	 SHORT $LN60@PyCodec_XM
$LN59@PyCodec_XM:
  001c5	4c 8b 93 a0 00
	00 00		 mov	 r10, QWORD PTR [rbx+160]
$LN60@PyCodec_XM:

; 763  :         /* generate replacement */
; 764  :         for (i = start; i < end; ++i) {

  001cc	4c 8b 5c 24 40	 mov	 r11, QWORD PTR start$20805[rsp]
  001d1	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$20806[rsp]
  001d6	4d 3b d8	 cmp	 r11, r8
  001d9	0f 8d 77 01 00
	00		 jge	 $LN16@PyCodec_XM
  001df	90		 npad	 1
$LL18@PyCodec_XM:

; 765  :             int digits;
; 766  :             int base;
; 767  :             ch = PyUnicode_READ_CHAR(object, i);

  001e0	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  001e3	8b c8		 mov	 ecx, eax
  001e5	c1 e9 02	 shr	 ecx, 2
  001e8	83 e1 07	 and	 ecx, 7
  001eb	83 f9 01	 cmp	 ecx, 1
  001ee	75 32		 jne	 SHORT $LN75@PyCodec_XM
  001f0	a8 20		 test	 al, 32			; 00000020H
  001f2	74 20		 je	 SHORT $LN63@PyCodec_XM
  001f4	a8 40		 test	 al, 64			; 00000040H
  001f6	74 0e		 je	 SHORT $LN61@PyCodec_XM
  001f8	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  001ff	46 0f b6 04 18	 movzx	 r8d, BYTE PTR [rax+r11]
  00204	eb 78		 jmp	 SHORT $LN74@PyCodec_XM
$LN61@PyCodec_XM:
  00206	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0020d	46 0f b6 04 18	 movzx	 r8d, BYTE PTR [rax+r11]
  00212	eb 6a		 jmp	 SHORT $LN74@PyCodec_XM
$LN63@PyCodec_XM:
  00214	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0021b	46 0f b6 04 18	 movzx	 r8d, BYTE PTR [rax+r11]
  00220	eb 5c		 jmp	 SHORT $LN74@PyCodec_XM
$LN75@PyCodec_XM:
  00222	83 f9 02	 cmp	 ecx, 2
  00225	75 32		 jne	 SHORT $LN73@PyCodec_XM
  00227	a8 20		 test	 al, 32			; 00000020H
  00229	74 20		 je	 SHORT $LN67@PyCodec_XM
  0022b	a8 40		 test	 al, 64			; 00000040H
  0022d	74 0e		 je	 SHORT $LN65@PyCodec_XM
  0022f	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00236	46 0f b7 04 58	 movzx	 r8d, WORD PTR [rax+r11*2]
  0023b	eb 41		 jmp	 SHORT $LN74@PyCodec_XM
$LN65@PyCodec_XM:
  0023d	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00244	46 0f b7 04 58	 movzx	 r8d, WORD PTR [rax+r11*2]
  00249	eb 33		 jmp	 SHORT $LN74@PyCodec_XM
$LN67@PyCodec_XM:
  0024b	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00252	46 0f b7 04 58	 movzx	 r8d, WORD PTR [rax+r11*2]
  00257	eb 25		 jmp	 SHORT $LN74@PyCodec_XM
$LN73@PyCodec_XM:
  00259	a8 20		 test	 al, 32			; 00000020H
  0025b	74 16		 je	 SHORT $LN71@PyCodec_XM
  0025d	a8 40		 test	 al, 64			; 00000040H
  0025f	74 09		 je	 SHORT $LN69@PyCodec_XM
  00261	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00268	eb 10		 jmp	 SHORT $LN72@PyCodec_XM
$LN69@PyCodec_XM:
  0026a	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00271	eb 07		 jmp	 SHORT $LN72@PyCodec_XM
$LN71@PyCodec_XM:
  00273	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN72@PyCodec_XM:
  0027a	46 8b 04 98	 mov	 r8d, DWORD PTR [rax+r11*4]
$LN74@PyCodec_XM:

; 768  :             *outp++ = '&';

  0027e	66 41 c7 02 26
	23		 mov	 WORD PTR [r10], 8998	; 00002326H

; 769  :             *outp++ = '#';

  00284	49 83 c2 02	 add	 r10, 2

; 770  :             if (ch<10) {

  00288	41 83 f8 0a	 cmp	 r8d, 10
  0028c	73 0a		 jae	 SHORT $LN15@PyCodec_XM

; 771  :                 digits = 1;
; 772  :                 base = 1;

  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	44 8b c9	 mov	 r9d, ecx
  00296	eb 78		 jmp	 SHORT $LL3@PyCodec_XM
$LN15@PyCodec_XM:

; 773  :             }
; 774  :             else if (ch<100) {

  00298	41 83 f8 64	 cmp	 r8d, 100		; 00000064H
  0029c	73 0b		 jae	 SHORT $LN13@PyCodec_XM

; 775  :                 digits = 2;
; 776  :                 base = 10;

  0029e	b9 0a 00 00 00	 mov	 ecx, 10
  002a3	44 8d 49 f8	 lea	 r9d, QWORD PTR [rcx-8]
  002a7	eb 67		 jmp	 SHORT $LL3@PyCodec_XM
$LN13@PyCodec_XM:

; 777  :             }
; 778  :             else if (ch<1000) {

  002a9	41 81 f8 e8 03
	00 00		 cmp	 r8d, 1000		; 000003e8H
  002b0	73 0b		 jae	 SHORT $LN11@PyCodec_XM

; 779  :                 digits = 3;
; 780  :                 base = 100;

  002b2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  002b7	44 8d 49 9f	 lea	 r9d, QWORD PTR [rcx-97]
  002bb	eb 53		 jmp	 SHORT $LL3@PyCodec_XM
$LN11@PyCodec_XM:

; 781  :             }
; 782  :             else if (ch<10000) {

  002bd	41 81 f8 10 27
	00 00		 cmp	 r8d, 10000		; 00002710H
  002c4	73 0d		 jae	 SHORT $LN9@PyCodec_XM

; 783  :                 digits = 4;
; 784  :                 base = 1000;

  002c6	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  002cb	41 b9 04 00 00
	00		 mov	 r9d, 4
  002d1	eb 3d		 jmp	 SHORT $LL3@PyCodec_XM
$LN9@PyCodec_XM:

; 785  :             }
; 786  :             else if (ch<100000) {

  002d3	41 81 f8 a0 86
	01 00		 cmp	 r8d, 100000		; 000186a0H
  002da	73 0d		 jae	 SHORT $LN7@PyCodec_XM

; 787  :                 digits = 5;
; 788  :                 base = 10000;

  002dc	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  002e1	41 b9 05 00 00
	00		 mov	 r9d, 5
  002e7	eb 27		 jmp	 SHORT $LL3@PyCodec_XM
$LN7@PyCodec_XM:

; 789  :             }
; 790  :             else if (ch<1000000) {

  002e9	41 81 f8 40 42
	0f 00		 cmp	 r8d, 1000000		; 000f4240H
  002f0	73 0d		 jae	 SHORT $LN5@PyCodec_XM

; 791  :                 digits = 6;
; 792  :                 base = 100000;

  002f2	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  002f7	41 b9 06 00 00
	00		 mov	 r9d, 6

; 793  :             }
; 794  :             else {

  002fd	eb 11		 jmp	 SHORT $LL3@PyCodec_XM
$LN5@PyCodec_XM:

; 795  :                 digits = 7;
; 796  :                 base = 1000000;

  002ff	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00304	41 b9 07 00 00
	00		 mov	 r9d, 7
  0030a	66 0f 1f 44 00
	00		 npad	 6
$LL3@PyCodec_XM:

; 797  :             }
; 798  :             while (digits-->0) {
; 799  :                 *outp++ = '0' + ch/base;

  00310	33 d2		 xor	 edx, edx
  00312	41 8b c0	 mov	 eax, r8d
  00315	41 ff c9	 dec	 r9d
  00318	f7 f1		 div	 ecx
  0031a	49 ff c2	 inc	 r10
  0031d	04 30		 add	 al, 48			; 00000030H
  0031f	44 8b c2	 mov	 r8d, edx
  00322	41 88 42 ff	 mov	 BYTE PTR [r10-1], al

; 800  :                 ch %= base;
; 801  :                 base /= 10;

  00326	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0032b	f7 e9		 imul	 ecx
  0032d	8b ca		 mov	 ecx, edx
  0032f	c1 f9 02	 sar	 ecx, 2
  00332	8b c1		 mov	 eax, ecx
  00334	c1 e8 1f	 shr	 eax, 31
  00337	03 c8		 add	 ecx, eax
  00339	45 85 c9	 test	 r9d, r9d
  0033c	7f d2		 jg	 SHORT $LL3@PyCodec_XM

; 802  :             }
; 803  :             *outp++ = ';';

  0033e	41 c6 02 3b	 mov	 BYTE PTR [r10], 59	; 0000003bH
  00342	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$20806[rsp]
  00347	49 ff c3	 inc	 r11
  0034a	49 ff c2	 inc	 r10
  0034d	4d 3b d8	 cmp	 r11, r8
  00350	0f 8c 8a fe ff
	ff		 jl	 $LL18@PyCodec_XM
$LN16@PyCodec_XM:

; 804  :         }
; 805  :         assert(_PyUnicode_CheckConsistency(res, 1));
; 806  :         restuple = Py_BuildValue("(Nn)", res, end);

  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  0035d	48 8b d3	 mov	 rdx, rbx
  00360	e8 00 00 00 00	 call	 Py_BuildValue

; 807  :         Py_DECREF(object);

  00365	48 8b cf	 mov	 rcx, rdi
  00368	48 8b d8	 mov	 rbx, rax
  0036b	e8 00 00 00 00	 call	 _Py_DecRef
  00370	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 808  :         return restuple;

  00375	48 8b c3	 mov	 rax, rbx

; 813  :     }
; 814  : }

  00378	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0037c	5b		 pop	 rbx
  0037d	c3		 ret	 0
$LN38@PyCodec_XM:

; 809  :     }
; 810  :     else {
; 811  :         wrong_exception_type(exc);

  0037e	e8 00 00 00 00	 call	 wrong_exception_type
$LN91@PyCodec_XM:

; 812  :         return NULL;

  00383	33 c0		 xor	 eax, eax

; 813  :     }
; 814  : }

  00385	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00389	5b		 pop	 rbx
  0038a	c3		 ret	 0
PyCodec_XMLCharRefReplaceErrors ENDP
_TEXT	ENDS
PUBLIC	PyCodec_BackslashReplaceErrors
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_BackslashReplaceErrors DD imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$PyCodec_BackslashReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyCodec_BackslashReplaceErrors DD imagerel $LN66+74
	DD	imagerel $LN66+370
	DD	imagerel $chain$0$PyCodec_BackslashReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyCodec_BackslashReplaceErrors DD imagerel $LN66+370
	DD	imagerel $LN66+954
	DD	imagerel $chain$2$PyCodec_BackslashReplaceErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyCodec_BackslashReplaceErrors DD imagerel $LN66+954
	DD	imagerel $LN66+967
	DD	imagerel $chain$3$PyCodec_BackslashReplaceErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyCodec_BackslashReplaceErrors DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$PyCodec_BackslashReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyCodec_BackslashReplaceErrors DD 020021H
	DD	067400H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$PyCodec_BackslashReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyCodec_BackslashReplaceErrors DD 020521H
	DD	067405H
	DD	imagerel $LN66
	DD	imagerel $LN66+74
	DD	imagerel $unwind$PyCodec_BackslashReplaceErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_BackslashReplaceErrors DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_BackslashReplaceErrors
_TEXT	SEGMENT
exc$ = 48
end$20970 = 56
start$20969 = 64
PyCodec_BackslashReplaceErrors PROC			; COMDAT

; 817  : {

$LN66:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 818  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	e8 00 00 00 00	 call	 PyObject_IsInstance

; 819  :         PyObject *restuple;
; 820  :         PyObject *object;
; 821  :         Py_ssize_t i;
; 822  :         Py_ssize_t start;
; 823  :         Py_ssize_t end;
; 824  :         PyObject *res;
; 825  :         unsigned char *outp;
; 826  :         int ressize;
; 827  :         Py_UCS4 c;
; 828  :         if (PyUnicodeEncodeError_GetStart(exc, &start))

  00015	48 8b cb	 mov	 rcx, rbx
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 9a 03 00
	00		 je	 $LN20@PyCodec_Ba
  00020	48 8d 54 24 40	 lea	 rdx, QWORD PTR start$20969[rsp]
  00025	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetStart
  0002a	85 c0		 test	 eax, eax

; 829  :             return NULL;

  0002c	0f 85 8d 03 00
	00		 jne	 $LN65@PyCodec_Ba

; 830  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00032	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$20970[rsp]
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  0003f	85 c0		 test	 eax, eax

; 831  :             return NULL;

  00041	0f 85 78 03 00
	00		 jne	 $LN65@PyCodec_Ba

; 832  :         if (!(object = PyUnicodeEncodeError_GetObject(exc)))

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0004f	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetObject
  00054	48 8b f8	 mov	 rdi, rax
  00057	48 85 c0	 test	 rax, rax

; 833  :             return NULL;

  0005a	0f 84 05 01 00
	00		 je	 $LN64@PyCodec_Ba

; 834  :         for (i = start, ressize = 0; i < end; ++i) {

  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR start$20969[rsp]
  00065	4c 8b 5c 24 38	 mov	 r11, QWORD PTR end$20970[rsp]
  0006a	33 c0		 xor	 eax, eax
  0006c	49 3b cb	 cmp	 rcx, r11
  0006f	0f 8d db 00 00
	00		 jge	 $LN14@PyCodec_Ba
  00075	44 8b 4f 70	 mov	 r9d, DWORD PTR [rdi+112]
  00079	45 8b d1	 mov	 r10d, r9d
  0007c	45 8b c1	 mov	 r8d, r9d
  0007f	41 c1 ea 02	 shr	 r10d, 2
  00083	41 c1 e8 05	 shr	 r8d, 5
  00087	41 83 e2 07	 and	 r10d, 7
  0008b	41 83 e0 01	 and	 r8d, 1
  0008f	90		 npad	 1
$LL16@PyCodec_Ba:

; 835  :             /* object is guaranteed to be "ready" */
; 836  :             c = PyUnicode_READ_CHAR(object, i);

  00090	41 83 fa 01	 cmp	 r10d, 1
  00094	75 32		 jne	 SHORT $LN37@PyCodec_Ba
  00096	45 85 c0	 test	 r8d, r8d
  00099	74 20		 je	 SHORT $LN25@PyCodec_Ba
  0009b	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  0009f	74 0d		 je	 SHORT $LN23@PyCodec_Ba
  000a1	48 8d 97 80 00
	00 00		 lea	 rdx, QWORD PTR [rdi+128]
  000a8	0f b6 14 0a	 movzx	 edx, BYTE PTR [rdx+rcx]
  000ac	eb 79		 jmp	 SHORT $LN36@PyCodec_Ba
$LN23@PyCodec_Ba:
  000ae	48 8d 97 a0 00
	00 00		 lea	 rdx, QWORD PTR [rdi+160]
  000b5	0f b6 14 0a	 movzx	 edx, BYTE PTR [rdx+rcx]
  000b9	eb 6c		 jmp	 SHORT $LN36@PyCodec_Ba
$LN25@PyCodec_Ba:
  000bb	48 8b 97 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdi+160]
  000c2	0f b6 14 0a	 movzx	 edx, BYTE PTR [rdx+rcx]
  000c6	eb 5f		 jmp	 SHORT $LN36@PyCodec_Ba
$LN37@PyCodec_Ba:
  000c8	41 83 fa 02	 cmp	 r10d, 2
  000cc	75 32		 jne	 SHORT $LN35@PyCodec_Ba
  000ce	45 85 c0	 test	 r8d, r8d
  000d1	74 20		 je	 SHORT $LN29@PyCodec_Ba
  000d3	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  000d7	74 0d		 je	 SHORT $LN27@PyCodec_Ba
  000d9	48 8d 97 80 00
	00 00		 lea	 rdx, QWORD PTR [rdi+128]
  000e0	0f b7 14 4a	 movzx	 edx, WORD PTR [rdx+rcx*2]
  000e4	eb 41		 jmp	 SHORT $LN36@PyCodec_Ba
$LN27@PyCodec_Ba:
  000e6	48 8d 97 a0 00
	00 00		 lea	 rdx, QWORD PTR [rdi+160]
  000ed	0f b7 14 4a	 movzx	 edx, WORD PTR [rdx+rcx*2]
  000f1	eb 34		 jmp	 SHORT $LN36@PyCodec_Ba
$LN29@PyCodec_Ba:
  000f3	48 8b 97 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdi+160]
  000fa	0f b7 14 4a	 movzx	 edx, WORD PTR [rdx+rcx*2]
  000fe	eb 27		 jmp	 SHORT $LN36@PyCodec_Ba
$LN35@PyCodec_Ba:
  00100	45 85 c0	 test	 r8d, r8d
  00103	74 18		 je	 SHORT $LN33@PyCodec_Ba
  00105	41 f6 c1 40	 test	 r9b, 64			; 00000040H
  00109	74 09		 je	 SHORT $LN31@PyCodec_Ba
  0010b	48 8d 97 80 00
	00 00		 lea	 rdx, QWORD PTR [rdi+128]
  00112	eb 10		 jmp	 SHORT $LN34@PyCodec_Ba
$LN31@PyCodec_Ba:
  00114	48 8d 97 a0 00
	00 00		 lea	 rdx, QWORD PTR [rdi+160]
  0011b	eb 07		 jmp	 SHORT $LN34@PyCodec_Ba
$LN33@PyCodec_Ba:
  0011d	48 8b 97 a0 00
	00 00		 mov	 rdx, QWORD PTR [rdi+160]
$LN34@PyCodec_Ba:
  00124	8b 14 8a	 mov	 edx, DWORD PTR [rdx+rcx*4]
$LN36@PyCodec_Ba:

; 837  :             if (c >= 0x10000) {

  00127	81 fa 00 00 01
	00		 cmp	 edx, 65536		; 00010000H
  0012d	72 05		 jb	 SHORT $LN13@PyCodec_Ba

; 838  :                 ressize += 1+1+8;

  0012f	83 c0 0a	 add	 eax, 10
  00132	eb 10		 jmp	 SHORT $LN15@PyCodec_Ba
$LN13@PyCodec_Ba:

; 839  :             }
; 840  :             else if (c >= 0x100) {

  00134	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  0013a	72 05		 jb	 SHORT $LN11@PyCodec_Ba

; 841  :                 ressize += 1+1+4;

  0013c	83 c0 06	 add	 eax, 6

; 842  :             }
; 843  :             else

  0013f	eb 03		 jmp	 SHORT $LN15@PyCodec_Ba
$LN11@PyCodec_Ba:

; 844  :                 ressize += 1+1+2;

  00141	83 c0 04	 add	 eax, 4
$LN15@PyCodec_Ba:

; 834  :         for (i = start, ressize = 0; i < end; ++i) {

  00144	48 ff c1	 inc	 rcx
  00147	49 3b cb	 cmp	 rcx, r11
  0014a	0f 8c 40 ff ff
	ff		 jl	 $LL16@PyCodec_Ba
$LN14@PyCodec_Ba:

; 845  :         }
; 846  :         res = PyUnicode_New(ressize, 127);

  00150	48 63 c8	 movsxd	 rcx, eax
  00153	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00158	e8 00 00 00 00	 call	 PyUnicode_New
  0015d	4c 8b d8	 mov	 r11, rax

; 847  :         if (res==NULL)

  00160	48 85 c0	 test	 rax, rax
  00163	75 0d		 jne	 SHORT $LN9@PyCodec_Ba
$LN64@PyCodec_Ba:

; 848  :             return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 881  :     }
; 882  : }

  0016c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00170	5b		 pop	 rbx
  00171	c3		 ret	 0
$LN9@PyCodec_Ba:

; 849  :         for (i = start, outp = PyUnicode_1BYTE_DATA(res);
; 850  :             i < end; ++i) {

  00172	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00175	4c 8b 54 24 40	 mov	 r10, QWORD PTR start$20969[rsp]
  0017a	a8 20		 test	 al, 32			; 00000020H
  0017c	74 16		 je	 SHORT $LN41@PyCodec_Ba
  0017e	a8 40		 test	 al, 64			; 00000040H
  00180	74 09		 je	 SHORT $LN39@PyCodec_Ba
  00182	4d 8d 83 80 00
	00 00		 lea	 r8, QWORD PTR [r11+128]
  00189	eb 10		 jmp	 SHORT $LN42@PyCodec_Ba
$LN39@PyCodec_Ba:
  0018b	4d 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [r11+160]
  00192	eb 07		 jmp	 SHORT $LN42@PyCodec_Ba
$LN41@PyCodec_Ba:
  00194	4d 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [r11+160]
$LN42@PyCodec_Ba:
  0019b	48 8b 44 24 38	 mov	 rax, QWORD PTR end$20970[rsp]
  001a0	4c 3b d0	 cmp	 r10, rax
  001a3	0f 8d e6 01 00
	00		 jge	 $LN6@PyCodec_Ba
  001a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@PyCodec_Ba:

; 851  :             c = PyUnicode_READ_CHAR(object, i);

  001b0	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  001b3	8b c8		 mov	 ecx, eax
  001b5	c1 e9 02	 shr	 ecx, 2
  001b8	83 e1 07	 and	 ecx, 7
  001bb	83 f9 01	 cmp	 ecx, 1
  001be	75 32		 jne	 SHORT $LN57@PyCodec_Ba
  001c0	a8 20		 test	 al, 32			; 00000020H
  001c2	74 20		 je	 SHORT $LN45@PyCodec_Ba
  001c4	a8 40		 test	 al, 64			; 00000040H
  001c6	74 0e		 je	 SHORT $LN43@PyCodec_Ba
  001c8	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  001cf	46 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+r10]
  001d4	eb 78		 jmp	 SHORT $LN56@PyCodec_Ba
$LN43@PyCodec_Ba:
  001d6	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  001dd	46 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+r10]
  001e2	eb 6a		 jmp	 SHORT $LN56@PyCodec_Ba
$LN45@PyCodec_Ba:
  001e4	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  001eb	46 0f b6 0c 10	 movzx	 r9d, BYTE PTR [rax+r10]
  001f0	eb 5c		 jmp	 SHORT $LN56@PyCodec_Ba
$LN57@PyCodec_Ba:
  001f2	83 f9 02	 cmp	 ecx, 2
  001f5	75 32		 jne	 SHORT $LN55@PyCodec_Ba
  001f7	a8 20		 test	 al, 32			; 00000020H
  001f9	74 20		 je	 SHORT $LN49@PyCodec_Ba
  001fb	a8 40		 test	 al, 64			; 00000040H
  001fd	74 0e		 je	 SHORT $LN47@PyCodec_Ba
  001ff	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00206	46 0f b7 0c 50	 movzx	 r9d, WORD PTR [rax+r10*2]
  0020b	eb 41		 jmp	 SHORT $LN56@PyCodec_Ba
$LN47@PyCodec_Ba:
  0020d	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00214	46 0f b7 0c 50	 movzx	 r9d, WORD PTR [rax+r10*2]
  00219	eb 33		 jmp	 SHORT $LN56@PyCodec_Ba
$LN49@PyCodec_Ba:
  0021b	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00222	46 0f b7 0c 50	 movzx	 r9d, WORD PTR [rax+r10*2]
  00227	eb 25		 jmp	 SHORT $LN56@PyCodec_Ba
$LN55@PyCodec_Ba:
  00229	a8 20		 test	 al, 32			; 00000020H
  0022b	74 16		 je	 SHORT $LN53@PyCodec_Ba
  0022d	a8 40		 test	 al, 64			; 00000040H
  0022f	74 09		 je	 SHORT $LN51@PyCodec_Ba
  00231	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00238	eb 10		 jmp	 SHORT $LN54@PyCodec_Ba
$LN51@PyCodec_Ba:
  0023a	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00241	eb 07		 jmp	 SHORT $LN54@PyCodec_Ba
$LN53@PyCodec_Ba:
  00243	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN54@PyCodec_Ba:
  0024a	46 8b 0c 90	 mov	 r9d, DWORD PTR [rax+r10*4]
$LN56@PyCodec_Ba:

; 852  :             *outp++ = '\\';

  0024e	41 c6 00 5c	 mov	 BYTE PTR [r8], 92	; 0000005cH

; 853  :             if (c >= 0x00010000) {

  00252	41 81 f9 00 00
	01 00		 cmp	 r9d, 65536		; 00010000H
  00259	0f 82 9e 00 00
	00		 jb	 $LN5@PyCodec_Ba

; 854  :                 *outp++ = 'U';

  0025f	41 c6 40 01 55	 mov	 BYTE PTR [r8+1], 85	; 00000055H

; 855  :                 *outp++ = Py_hexdigits[(c>>28)&0xf];

  00264	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  0026b	41 8b c9	 mov	 ecx, r9d
  0026e	48 c1 e9 1c	 shr	 rcx, 28
  00272	41 8b d1	 mov	 edx, r9d
  00275	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]

; 856  :                 *outp++ = Py_hexdigits[(c>>24)&0xf];
; 857  :                 *outp++ = Py_hexdigits[(c>>20)&0xf];
; 858  :                 *outp++ = Py_hexdigits[(c>>16)&0xf];
; 859  :                 *outp++ = Py_hexdigits[(c>>12)&0xf];
; 860  :                 *outp++ = Py_hexdigits[(c>>8)&0xf];

  00279	48 c1 ea 08	 shr	 rdx, 8
  0027d	41 88 48 02	 mov	 BYTE PTR [r8+2], cl
  00281	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00288	41 8b c9	 mov	 ecx, r9d
  0028b	48 c1 e9 18	 shr	 rcx, 24
  0028f	83 e2 0f	 and	 edx, 15
  00292	83 e1 0f	 and	 ecx, 15
  00295	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00299	41 88 48 03	 mov	 BYTE PTR [r8+3], cl
  0029d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002a4	41 8b c9	 mov	 ecx, r9d
  002a7	48 c1 e9 14	 shr	 rcx, 20
  002ab	83 e1 0f	 and	 ecx, 15
  002ae	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  002b2	41 88 48 04	 mov	 BYTE PTR [r8+4], cl
  002b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002bd	41 8b c9	 mov	 ecx, r9d
  002c0	48 c1 e9 10	 shr	 rcx, 16
  002c4	83 e1 0f	 and	 ecx, 15
  002c7	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  002cb	41 88 48 05	 mov	 BYTE PTR [r8+5], cl
  002cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002d6	41 8b c9	 mov	 ecx, r9d
  002d9	48 c1 e9 0c	 shr	 rcx, 12
  002dd	83 e1 0f	 and	 ecx, 15
  002e0	49 83 c0 08	 add	 r8, 8
  002e4	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  002e8	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  002ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  002f3	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  002f7	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  002fb	eb 4f		 jmp	 SHORT $LN2@PyCodec_Ba
$LN5@PyCodec_Ba:

; 861  :             }
; 862  :             else if (c >= 0x100) {

  002fd	41 81 f9 00 01
	00 00		 cmp	 r9d, 256		; 00000100H
  00304	72 3d		 jb	 SHORT $LN3@PyCodec_Ba

; 863  :                 *outp++ = 'u';

  00306	41 c6 40 01 75	 mov	 BYTE PTR [r8+1], 117	; 00000075H

; 864  :                 *outp++ = Py_hexdigits[(c>>12)&0xf];

  0030b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00312	41 8b c9	 mov	 ecx, r9d
  00315	48 c1 e9 0c	 shr	 rcx, 12
  00319	41 8b d1	 mov	 edx, r9d
  0031c	83 e1 0f	 and	 ecx, 15

; 865  :                 *outp++ = Py_hexdigits[(c>>8)&0xf];

  0031f	48 c1 ea 08	 shr	 rdx, 8
  00323	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00327	83 e2 0f	 and	 edx, 15
  0032a	49 83 c0 04	 add	 r8, 4
  0032e	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  00332	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00339	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  0033d	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl

; 866  :             }
; 867  :             else

  00341	eb 09		 jmp	 SHORT $LN2@PyCodec_Ba
$LN3@PyCodec_Ba:

; 868  :                 *outp++ = 'x';

  00343	41 c6 40 01 78	 mov	 BYTE PTR [r8+1], 120	; 00000078H
  00348	49 83 c0 02	 add	 r8, 2
$LN2@PyCodec_Ba:

; 869  :             *outp++ = Py_hexdigits[(c>>4)&0xf];

  0034c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00353	41 8b d1	 mov	 edx, r9d
  00356	41 8b c9	 mov	 ecx, r9d
  00359	48 c1 e9 04	 shr	 rcx, 4

; 870  :             *outp++ = Py_hexdigits[c&0xf];

  0035d	83 e2 0f	 and	 edx, 15
  00360	49 ff c2	 inc	 r10
  00363	83 e1 0f	 and	 ecx, 15
  00366	49 83 c0 02	 add	 r8, 2
  0036a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0036e	41 88 48 fe	 mov	 BYTE PTR [r8-2], cl
  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR Py_hexdigits
  00379	0f b6 0c 02	 movzx	 ecx, BYTE PTR [rdx+rax]
  0037d	41 88 48 ff	 mov	 BYTE PTR [r8-1], cl
  00381	48 8b 44 24 38	 mov	 rax, QWORD PTR end$20970[rsp]
  00386	4c 3b d0	 cmp	 r10, rax
  00389	0f 8c 21 fe ff
	ff		 jl	 $LL8@PyCodec_Ba
$LN6@PyCodec_Ba:

; 871  :         }
; 872  : 
; 873  :         assert(_PyUnicode_CheckConsistency(res, 1));
; 874  :         restuple = Py_BuildValue("(Nn)", res, end);

  0038f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  00396	4c 8b c0	 mov	 r8, rax
  00399	49 8b d3	 mov	 rdx, r11
  0039c	e8 00 00 00 00	 call	 Py_BuildValue

; 875  :         Py_DECREF(object);

  003a1	48 8b cf	 mov	 rcx, rdi
  003a4	48 8b d8	 mov	 rbx, rax
  003a7	e8 00 00 00 00	 call	 _Py_DecRef
  003ac	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 876  :         return restuple;

  003b1	48 8b c3	 mov	 rax, rbx

; 881  :     }
; 882  : }

  003b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003b8	5b		 pop	 rbx
  003b9	c3		 ret	 0
$LN20@PyCodec_Ba:

; 877  :     }
; 878  :     else {
; 879  :         wrong_exception_type(exc);

  003ba	e8 00 00 00 00	 call	 wrong_exception_type
$LN65@PyCodec_Ba:

; 880  :         return NULL;

  003bf	33 c0		 xor	 eax, eax

; 881  :     }
; 882  : }

  003c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003c5	5b		 pop	 rbx
  003c6	c3		 ret	 0
PyCodec_BackslashReplaceErrors ENDP
_TEXT	ENDS
PUBLIC	??_C@_04NBEFNIN@?$CIOn?$CJ?$AA@			; `string'
EXTRN	PyUnicode_FromOrdinal:PROC
EXTRN	PyUnicodeDecodeError_GetObject:PROC
EXTRN	PyUnicodeDecodeError_GetStart:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_SurrogatePassErrors DD imagerel PyCodec_SurrogatePassErrors
	DD	imagerel PyCodec_SurrogatePassErrors+100
	DD	imagerel $unwind$PyCodec_SurrogatePassErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyCodec_SurrogatePassErrors DD imagerel PyCodec_SurrogatePassErrors+100
	DD	imagerel PyCodec_SurrogatePassErrors+449
	DD	imagerel $chain$0$PyCodec_SurrogatePassErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyCodec_SurrogatePassErrors DD imagerel PyCodec_SurrogatePassErrors+449
	DD	imagerel PyCodec_SurrogatePassErrors+492
	DD	imagerel $chain$2$PyCodec_SurrogatePassErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyCodec_SurrogatePassErrors DD imagerel PyCodec_SurrogatePassErrors+492
	DD	imagerel PyCodec_SurrogatePassErrors+788
	DD	imagerel $chain$3$PyCodec_SurrogatePassErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyCodec_SurrogatePassErrors DD 021H
	DD	imagerel PyCodec_SurrogatePassErrors
	DD	imagerel PyCodec_SurrogatePassErrors+100
	DD	imagerel $unwind$PyCodec_SurrogatePassErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyCodec_SurrogatePassErrors DD 020021H
	DD	085400H
	DD	imagerel PyCodec_SurrogatePassErrors
	DD	imagerel PyCodec_SurrogatePassErrors+100
	DD	imagerel $unwind$PyCodec_SurrogatePassErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyCodec_SurrogatePassErrors DD 020521H
	DD	085405H
	DD	imagerel PyCodec_SurrogatePassErrors
	DD	imagerel PyCodec_SurrogatePassErrors+100
	DD	imagerel $unwind$PyCodec_SurrogatePassErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_SurrogatePassErrors DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT ??_C@_04NBEFNIN@?$CIOn?$CJ?$AA@
CONST	SEGMENT
??_C@_04NBEFNIN@?$CIOn?$CJ?$AA@ DB '(On)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_SurrogatePassErrors
_TEXT	SEGMENT
exc$ = 64
start$ = 72
end$ = 80
PyCodec_SurrogatePassErrors PROC			; COMDAT

; 888  : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 889  :     PyObject *restuple;
; 890  :     PyObject *object;
; 891  :     Py_ssize_t i;
; 892  :     Py_ssize_t start;
; 893  :     Py_ssize_t end;
; 894  :     PyObject *res;
; 895  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  00008	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	e8 00 00 00 00	 call	 PyObject_IsInstance

; 896  :         char *outp;
; 897  :         if (PyUnicodeEncodeError_GetStart(exc, &start))

  00017	48 8b ce	 mov	 rcx, rsi
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 ca 01 00
	00		 je	 $LN21@PyCodec_Su
  00022	48 8d 54 24 48	 lea	 rdx, QWORD PTR start$[rsp]
  00027	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetStart
  0002c	85 c0		 test	 eax, eax

; 898  :             return NULL;

  0002e	0f 85 07 02 00
	00		 jne	 $LN45@PyCodec_Su

; 899  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00034	48 8d 54 24 50	 lea	 rdx, QWORD PTR end$[rsp]
  00039	48 8b ce	 mov	 rcx, rsi
  0003c	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  00041	85 c0		 test	 eax, eax

; 900  :             return NULL;

  00043	0f 85 f2 01 00
	00		 jne	 $LN45@PyCodec_Su

; 901  :         if (!(object = PyUnicodeEncodeError_GetObject(exc)))

  00049	48 8b ce	 mov	 rcx, rsi
  0004c	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetObject
  00051	48 8b f8	 mov	 rdi, rax
  00054	48 85 c0	 test	 rax, rax

; 902  :             return NULL;

  00057	0f 84 de 01 00
	00		 je	 $LN45@PyCodec_Su

; 903  :         res = PyBytes_FromStringAndSize(NULL, 3*(end-start));

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR end$[rsp]
  00062	33 c9		 xor	 ecx, ecx
  00064	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00069	48 2b 44 24 48	 sub	 rax, QWORD PTR start$[rsp]
  0006e	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00072	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00077	48 8b e8	 mov	 rbp, rax

; 904  :         if (!res) {

  0007a	48 85 c0	 test	 rax, rax

; 905  :             Py_DECREF(object);
; 906  :             return NULL;

  0007d	0f 84 52 01 00
	00		 je	 $LN44@PyCodec_Su

; 907  :         }
; 908  :         outp = PyBytes_AsString(res);

  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 PyBytes_AsString

; 909  :         for (i = start; i < end; i++) {

  0008b	4c 8b 44 24 48	 mov	 r8, QWORD PTR start$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR end$[rsp]
  00095	4c 8b d8	 mov	 r11, rax
  00098	4c 3b c1	 cmp	 r8, rcx
  0009b	0f 8d eb 00 00
	00		 jge	 $LN14@PyCodec_Su
$LL16@PyCodec_Su:

; 910  :             /* object is guaranteed to be "ready" */
; 911  :             Py_UCS4 ch = PyUnicode_READ_CHAR(object, i);

  000a1	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  000a4	8b d1		 mov	 edx, ecx
  000a6	c1 ea 02	 shr	 edx, 2
  000a9	83 e2 07	 and	 edx, 7
  000ac	83 fa 01	 cmp	 edx, 1
  000af	75 37		 jne	 SHORT $LN38@PyCodec_Su
  000b1	f6 c1 20	 test	 cl, 32			; 00000020H
  000b4	74 24		 je	 SHORT $LN26@PyCodec_Su
  000b6	f6 c1 40	 test	 cl, 64			; 00000040H
  000b9	74 11		 je	 SHORT $LN24@PyCodec_Su
  000bb	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  000c2	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  000c7	e9 7c 00 00 00	 jmp	 $LN37@PyCodec_Su
$LN24@PyCodec_Su:
  000cc	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  000d3	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  000d8	eb 6e		 jmp	 SHORT $LN37@PyCodec_Su
$LN26@PyCodec_Su:
  000da	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  000e1	42 0f b6 0c 00	 movzx	 ecx, BYTE PTR [rax+r8]
  000e6	eb 60		 jmp	 SHORT $LN37@PyCodec_Su
$LN38@PyCodec_Su:
  000e8	83 fa 02	 cmp	 edx, 2
  000eb	75 34		 jne	 SHORT $LN36@PyCodec_Su
  000ed	f6 c1 20	 test	 cl, 32			; 00000020H
  000f0	74 21		 je	 SHORT $LN30@PyCodec_Su
  000f2	f6 c1 40	 test	 cl, 64			; 00000040H
  000f5	74 0e		 je	 SHORT $LN28@PyCodec_Su
  000f7	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  000fe	42 0f b7 0c 40	 movzx	 ecx, WORD PTR [rax+r8*2]
  00103	eb 43		 jmp	 SHORT $LN37@PyCodec_Su
$LN28@PyCodec_Su:
  00105	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0010c	42 0f b7 0c 40	 movzx	 ecx, WORD PTR [rax+r8*2]
  00111	eb 35		 jmp	 SHORT $LN37@PyCodec_Su
$LN30@PyCodec_Su:
  00113	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  0011a	42 0f b7 0c 40	 movzx	 ecx, WORD PTR [rax+r8*2]
  0011f	eb 27		 jmp	 SHORT $LN37@PyCodec_Su
$LN36@PyCodec_Su:
  00121	f6 c1 20	 test	 cl, 32			; 00000020H
  00124	74 17		 je	 SHORT $LN34@PyCodec_Su
  00126	f6 c1 40	 test	 cl, 64			; 00000040H
  00129	74 09		 je	 SHORT $LN32@PyCodec_Su
  0012b	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  00132	eb 10		 jmp	 SHORT $LN35@PyCodec_Su
$LN32@PyCodec_Su:
  00134	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  0013b	eb 07		 jmp	 SHORT $LN35@PyCodec_Su
$LN34@PyCodec_Su:
  0013d	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN35@PyCodec_Su:
  00144	42 8b 0c 80	 mov	 ecx, DWORD PTR [rax+r8*4]
$LN37@PyCodec_Su:

; 912  :             if (ch < 0xd800 || ch > 0xdfff) {

  00148	8d 81 00 28 ff
	ff		 lea	 eax, DWORD PTR [rcx-55296]
  0014e	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00153	77 6c		 ja	 SHORT $LN41@PyCodec_Su

; 918  :             }
; 919  :             *outp++ = (char)(0xe0 | (ch >> 12));

  00155	8b c1		 mov	 eax, ecx
  00157	49 ff c0	 inc	 r8

; 920  :             *outp++ = (char)(0x80 | ((ch >> 6) & 0x3f));
; 921  :             *outp++ = (char)(0x80 | (ch & 0x3f));

  0015a	49 83 c3 03	 add	 r11, 3
  0015e	c1 e8 0c	 shr	 eax, 12
  00161	0c e0		 or	 al, -32			; ffffffffffffffe0H
  00163	41 88 43 fd	 mov	 BYTE PTR [r11-3], al
  00167	8b c1		 mov	 eax, ecx
  00169	80 e1 3f	 and	 cl, 63			; 0000003fH
  0016c	c1 e8 06	 shr	 eax, 6
  0016f	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00172	24 3f		 and	 al, 63			; 0000003fH
  00174	0c 80		 or	 al, -128		; ffffffffffffff80H
  00176	41 88 43 fe	 mov	 BYTE PTR [r11-2], al
  0017a	41 88 4b ff	 mov	 BYTE PTR [r11-1], cl
  0017e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR end$[rsp]
  00183	4c 3b c1	 cmp	 r8, rcx
  00186	0f 8c 15 ff ff
	ff		 jl	 $LL16@PyCodec_Su
$LN14@PyCodec_Su:

; 922  :         }
; 923  :         restuple = Py_BuildValue("(On)", res, end);

  0018c	4c 8b c1	 mov	 r8, rcx
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NBEFNIN@?$CIOn?$CJ?$AA@
  00196	48 8b d5	 mov	 rdx, rbp
  00199	e8 00 00 00 00	 call	 Py_BuildValue

; 924  :         Py_DECREF(res);

  0019e	48 8b cd	 mov	 rcx, rbp
  001a1	48 8b d8	 mov	 rbx, rax
  001a4	e8 00 00 00 00	 call	 _Py_DecRef

; 925  :         Py_DECREF(object);

  001a9	48 8b cf	 mov	 rcx, rdi
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
  001b1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 926  :         return restuple;

  001b6	48 8b c3	 mov	 rax, rbx

; 965  :     }
; 966  : }

  001b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001bd	5f		 pop	 rdi
  001be	5e		 pop	 rsi
  001bf	5b		 pop	 rbx
  001c0	c3		 ret	 0
$LN41@PyCodec_Su:

; 913  :                 /* Not a surrogate, fail with original exception */
; 914  :                 PyErr_SetObject(PyExceptionInstance_Class(exc), exc);

  001c1	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  001c5	48 8b d6	 mov	 rdx, rsi
  001c8	e8 00 00 00 00	 call	 PyErr_SetObject

; 915  :                 Py_DECREF(res);

  001cd	48 8b cd	 mov	 rcx, rbp
  001d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN44@PyCodec_Su:

; 916  :                 Py_DECREF(object);

  001d5	48 8b cf	 mov	 rcx, rdi
  001d8	e8 00 00 00 00	 call	 _Py_DecRef
  001dd	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 917  :                 return NULL;

  001e2	33 c0		 xor	 eax, eax

; 965  :     }
; 966  : }

  001e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001e8	5f		 pop	 rdi
  001e9	5e		 pop	 rsi
  001ea	5b		 pop	 rbx
  001eb	c3		 ret	 0
$LN21@PyCodec_Su:

; 927  :     }
; 928  :     else if (PyObject_IsInstance(exc, PyExc_UnicodeDecodeError)) {

  001ec	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeDecodeError
  001f3	e8 00 00 00 00	 call	 PyObject_IsInstance

; 929  :         unsigned char *p;
; 930  :         Py_UCS4 ch = 0;
; 931  :         if (PyUnicodeDecodeError_GetStart(exc, &start))

  001f8	48 8b ce	 mov	 rcx, rsi
  001fb	85 c0		 test	 eax, eax
  001fd	0f 84 02 01 00
	00		 je	 $LN10@PyCodec_Su
  00203	48 8d 54 24 48	 lea	 rdx, QWORD PTR start$[rsp]
  00208	33 db		 xor	 ebx, ebx
  0020a	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetStart
  0020f	85 c0		 test	 eax, eax

; 932  :             return NULL;

  00211	75 28		 jne	 SHORT $LN45@PyCodec_Su

; 933  :         if (!(object = PyUnicodeDecodeError_GetObject(exc)))

  00213	48 8b ce	 mov	 rcx, rsi
  00216	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetObject
  0021b	48 8b f8	 mov	 rdi, rax
  0021e	48 85 c0	 test	 rax, rax

; 934  :             return NULL;

  00221	74 18		 je	 SHORT $LN45@PyCodec_Su

; 935  :         if (!(p = (unsigned char*)PyBytes_AsString(object))) {

  00223	48 8b c8	 mov	 rcx, rax
  00226	e8 00 00 00 00	 call	 PyBytes_AsString
  0022b	4c 8b d8	 mov	 r11, rax
  0022e	48 85 c0	 test	 rax, rax
  00231	75 12		 jne	 SHORT $LN7@PyCodec_Su

; 936  :             Py_DECREF(object);

  00233	48 8b cf	 mov	 rcx, rdi
  00236	e8 00 00 00 00	 call	 _Py_DecRef
$LN45@PyCodec_Su:

; 937  :             return NULL;

  0023b	33 c0		 xor	 eax, eax

; 965  :     }
; 966  : }

  0023d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00241	5f		 pop	 rdi
  00242	5e		 pop	 rsi
  00243	5b		 pop	 rbx
  00244	c3		 ret	 0
$LN7@PyCodec_Su:

; 938  :         }
; 939  :         /* Try decoding a single surrogate character. If
; 940  :            there are more, let the codec call us again. */
; 941  :         p += start;

  00245	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]

; 942  :         if (PyBytes_GET_SIZE(object) - start >= 3 &&
; 943  :             (p[0] & 0xf0) == 0xe0 &&
; 944  :             (p[1] & 0xc0) == 0x80 &&
; 945  :             (p[2] & 0xc0) == 0x80) {

  0024a	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  0024e	48 2b c1	 sub	 rax, rcx
  00251	4c 03 d9	 add	 r11, rcx
  00254	48 83 f8 03	 cmp	 rax, 3
  00258	7c 59		 jl	 SHORT $LN5@PyCodec_Su
  0025a	41 0f b6 0b	 movzx	 ecx, BYTE PTR [r11]
  0025e	0f b6 c1	 movzx	 eax, cl
  00261	24 f0		 and	 al, 240			; 000000f0H
  00263	3c e0		 cmp	 al, 224			; 000000e0H
  00265	75 4c		 jne	 SHORT $LN5@PyCodec_Su
  00267	41 0f b6 53 01	 movzx	 edx, BYTE PTR [r11+1]
  0026c	0f b6 c2	 movzx	 eax, dl
  0026f	24 c0		 and	 al, 192			; 000000c0H
  00271	3c 80		 cmp	 al, 128			; 00000080H
  00273	75 3e		 jne	 SHORT $LN5@PyCodec_Su
  00275	45 0f b6 43 02	 movzx	 r8d, BYTE PTR [r11+2]
  0027a	41 0f b6 c0	 movzx	 eax, r8b
  0027e	24 c0		 and	 al, 192			; 000000c0H
  00280	3c 80		 cmp	 al, 128			; 00000080H
  00282	75 2f		 jne	 SHORT $LN5@PyCodec_Su

; 946  :             /* it's a three-byte code */
; 947  :             ch = ((p[0] & 0x0f) << 12) + ((p[1] & 0x3f) << 6) + (p[2] & 0x3f);

  00284	0f b6 da	 movzx	 ebx, dl
  00287	0f b6 c1	 movzx	 eax, cl
  0028a	83 e3 3f	 and	 ebx, 63			; 0000003fH
  0028d	83 e0 0f	 and	 eax, 15
  00290	c1 e0 0c	 shl	 eax, 12
  00293	c1 e3 06	 shl	 ebx, 6
  00296	03 d8		 add	 ebx, eax
  00298	41 0f b6 c0	 movzx	 eax, r8b
  0029c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0029f	03 d8		 add	 ebx, eax

; 948  :             if (ch < 0xd800 || ch > 0xdfff)

  002a1	81 fb 00 d8 00
	00		 cmp	 ebx, 55296		; 0000d800H
  002a7	72 08		 jb	 SHORT $LN4@PyCodec_Su
  002a9	81 fb ff df 00
	00		 cmp	 ebx, 57343		; 0000dfffH
  002af	76 02		 jbe	 SHORT $LN5@PyCodec_Su
$LN4@PyCodec_Su:

; 949  :                 /* it's not a surrogate - fail */
; 950  :                 ch = 0;

  002b1	33 db		 xor	 ebx, ebx
$LN5@PyCodec_Su:

; 951  :         }
; 952  :         Py_DECREF(object);

  002b3	48 8b cf	 mov	 rcx, rdi
  002b6	e8 00 00 00 00	 call	 _Py_DecRef

; 953  :         if (ch == 0) {

  002bb	85 db		 test	 ebx, ebx
  002bd	75 16		 jne	 SHORT $LN3@PyCodec_Su

; 954  :             PyErr_SetObject(PyExceptionInstance_Class(exc), exc);

  002bf	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  002c3	48 8b d6	 mov	 rdx, rsi
  002c6	e8 00 00 00 00	 call	 PyErr_SetObject

; 955  :             return NULL;

  002cb	33 c0		 xor	 eax, eax

; 965  :     }
; 966  : }

  002cd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002d1	5f		 pop	 rdi
  002d2	5e		 pop	 rsi
  002d3	5b		 pop	 rbx
  002d4	c3		 ret	 0
$LN3@PyCodec_Su:

; 956  :         }
; 957  :         res = PyUnicode_FromOrdinal(ch);

  002d5	8b cb		 mov	 ecx, ebx
  002d7	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 958  :         if (res == NULL)

  002dc	48 85 c0	 test	 rax, rax

; 959  :             return NULL;

  002df	0f 84 56 ff ff
	ff		 je	 $LN45@PyCodec_Su

; 960  :         return Py_BuildValue("(Nn)", res, start+3);

  002e5	4c 8b 44 24 48	 mov	 r8, QWORD PTR start$[rsp]
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  002f1	48 8b d0	 mov	 rdx, rax
  002f4	49 83 c0 03	 add	 r8, 3
  002f8	e8 00 00 00 00	 call	 Py_BuildValue

; 965  :     }
; 966  : }

  002fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00301	5f		 pop	 rdi
  00302	5e		 pop	 rsi
  00303	5b		 pop	 rbx
  00304	c3		 ret	 0
$LN10@PyCodec_Su:

; 961  :     }
; 962  :     else {
; 963  :         wrong_exception_type(exc);

  00305	e8 00 00 00 00	 call	 wrong_exception_type

; 964  :         return NULL;

  0030a	33 c0		 xor	 eax, eax

; 965  :     }
; 966  : }

  0030c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00310	5f		 pop	 rdi
  00311	5e		 pop	 rsi
  00312	5b		 pop	 rbx
  00313	c3		 ret	 0
PyCodec_SurrogatePassErrors ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromKindAndData:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_SurrogateEscapeErrors DD imagerel PyCodec_SurrogateEscapeErrors
	DD	imagerel PyCodec_SurrogateEscapeErrors+100
	DD	imagerel $unwind$PyCodec_SurrogateEscapeErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyCodec_SurrogateEscapeErrors DD imagerel PyCodec_SurrogateEscapeErrors+100
	DD	imagerel PyCodec_SurrogateEscapeErrors+408
	DD	imagerel $chain$0$PyCodec_SurrogateEscapeErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyCodec_SurrogateEscapeErrors DD imagerel PyCodec_SurrogateEscapeErrors+408
	DD	imagerel PyCodec_SurrogateEscapeErrors+451
	DD	imagerel $chain$2$PyCodec_SurrogateEscapeErrors
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyCodec_SurrogateEscapeErrors DD imagerel PyCodec_SurrogateEscapeErrors+451
	DD	imagerel PyCodec_SurrogateEscapeErrors+734
	DD	imagerel $chain$3$PyCodec_SurrogateEscapeErrors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyCodec_SurrogateEscapeErrors DD 021H
	DD	imagerel PyCodec_SurrogateEscapeErrors
	DD	imagerel PyCodec_SurrogateEscapeErrors+100
	DD	imagerel $unwind$PyCodec_SurrogateEscapeErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyCodec_SurrogateEscapeErrors DD 020021H
	DD	085400H
	DD	imagerel PyCodec_SurrogateEscapeErrors
	DD	imagerel PyCodec_SurrogateEscapeErrors+100
	DD	imagerel $unwind$PyCodec_SurrogateEscapeErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyCodec_SurrogateEscapeErrors DD 020521H
	DD	085405H
	DD	imagerel PyCodec_SurrogateEscapeErrors
	DD	imagerel PyCodec_SurrogateEscapeErrors+100
	DD	imagerel $unwind$PyCodec_SurrogateEscapeErrors
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_SurrogateEscapeErrors DD 040801H
	DD	070043208H
	DD	030026003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_SurrogateEscapeErrors
_TEXT	SEGMENT
exc$ = 64
end$ = 72
start$ = 80
ch$21296 = 88
PyCodec_SurrogateEscapeErrors PROC			; COMDAT

; 970  : {

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 971  :     PyObject *restuple;
; 972  :     PyObject *object;
; 973  :     Py_ssize_t i;
; 974  :     Py_ssize_t start;
; 975  :     Py_ssize_t end;
; 976  :     PyObject *res;
; 977  :     if (PyObject_IsInstance(exc, PyExc_UnicodeEncodeError)) {

  00008	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeEncodeError
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	e8 00 00 00 00	 call	 PyObject_IsInstance

; 978  :         char *outp;
; 979  :         if (PyUnicodeEncodeError_GetStart(exc, &start))

  00017	48 8b ce	 mov	 rcx, rsi
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 a1 01 00
	00		 je	 $LN22@PyCodec_Su@2
  00022	48 8d 54 24 50	 lea	 rdx, QWORD PTR start$[rsp]
  00027	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetStart
  0002c	85 c0		 test	 eax, eax

; 980  :             return NULL;

  0002e	0f 85 ef 01 00
	00		 jne	 $LN49@PyCodec_Su@2

; 981  :         if (PyUnicodeEncodeError_GetEnd(exc, &end))

  00034	48 8d 54 24 48	 lea	 rdx, QWORD PTR end$[rsp]
  00039	48 8b ce	 mov	 rcx, rsi
  0003c	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetEnd
  00041	85 c0		 test	 eax, eax

; 982  :             return NULL;

  00043	0f 85 da 01 00
	00		 jne	 $LN49@PyCodec_Su@2

; 983  :         if (!(object = PyUnicodeEncodeError_GetObject(exc)))

  00049	48 8b ce	 mov	 rcx, rsi
  0004c	e8 00 00 00 00	 call	 PyUnicodeEncodeError_GetObject
  00051	48 8b f8	 mov	 rdi, rax
  00054	48 85 c0	 test	 rax, rax

; 984  :             return NULL;

  00057	0f 84 c6 01 00
	00		 je	 $LN49@PyCodec_Su@2

; 985  :         res = PyBytes_FromStringAndSize(NULL, end-start);

  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR end$[rsp]
  00062	33 c9		 xor	 ecx, ecx
  00064	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00069	48 2b 54 24 50	 sub	 rdx, QWORD PTR start$[rsp]
  0006e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00073	48 8b e8	 mov	 rbp, rax

; 986  :         if (!res) {

  00076	48 85 c0	 test	 rax, rax

; 987  :             Py_DECREF(object);
; 988  :             return NULL;

  00079	0f 84 2d 01 00
	00		 je	 $LN48@PyCodec_Su@2

; 989  :         }
; 990  :         outp = PyBytes_AsString(res);

  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 PyBytes_AsString

; 991  :         for (i = start; i < end; i++) {

  00087	4c 8b 4c 24 50	 mov	 r9, QWORD PTR start$[rsp]
  0008c	4c 8b 44 24 48	 mov	 r8, QWORD PTR end$[rsp]
  00091	4c 8b d8	 mov	 r11, rax
  00094	4d 3b c8	 cmp	 r9, r8
  00097	0f 8d c9 00 00
	00		 jge	 $LN15@PyCodec_Su@2
  0009d	0f 1f 00	 npad	 3
$LL17@PyCodec_Su@2:

; 992  :             /* object is guaranteed to be "ready" */
; 993  :             Py_UCS4 ch = PyUnicode_READ_CHAR(object, i);

  000a0	8b 4f 70	 mov	 ecx, DWORD PTR [rdi+112]
  000a3	8b d1		 mov	 edx, ecx
  000a5	c1 ea 02	 shr	 edx, 2
  000a8	83 e2 07	 and	 edx, 7
  000ab	83 fa 01	 cmp	 edx, 1
  000ae	75 34		 jne	 SHORT $LN39@PyCodec_Su@2
  000b0	f6 c1 20	 test	 cl, 32			; 00000020H
  000b3	74 21		 je	 SHORT $LN27@PyCodec_Su@2
  000b5	f6 c1 40	 test	 cl, 64			; 00000040H
  000b8	74 0e		 je	 SHORT $LN25@PyCodec_Su@2
  000ba	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  000c1	42 0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+r9]
  000c6	eb 7c		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN25@PyCodec_Su@2:
  000c8	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  000cf	42 0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+r9]
  000d4	eb 6e		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN27@PyCodec_Su@2:
  000d6	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  000dd	42 0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+r9]
  000e2	eb 60		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN39@PyCodec_Su@2:
  000e4	83 fa 02	 cmp	 edx, 2
  000e7	75 34		 jne	 SHORT $LN37@PyCodec_Su@2
  000e9	f6 c1 20	 test	 cl, 32			; 00000020H
  000ec	74 21		 je	 SHORT $LN31@PyCodec_Su@2
  000ee	f6 c1 40	 test	 cl, 64			; 00000040H
  000f1	74 0e		 je	 SHORT $LN29@PyCodec_Su@2
  000f3	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  000fa	42 0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+r9*2]
  000ff	eb 43		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN29@PyCodec_Su@2:
  00101	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00108	42 0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+r9*2]
  0010d	eb 35		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN31@PyCodec_Su@2:
  0010f	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
  00116	42 0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+r9*2]
  0011b	eb 27		 jmp	 SHORT $LN38@PyCodec_Su@2
$LN37@PyCodec_Su@2:
  0011d	f6 c1 20	 test	 cl, 32			; 00000020H
  00120	74 17		 je	 SHORT $LN35@PyCodec_Su@2
  00122	f6 c1 40	 test	 cl, 64			; 00000040H
  00125	74 09		 je	 SHORT $LN33@PyCodec_Su@2
  00127	48 8d 87 80 00
	00 00		 lea	 rax, QWORD PTR [rdi+128]
  0012e	eb 10		 jmp	 SHORT $LN36@PyCodec_Su@2
$LN33@PyCodec_Su@2:
  00130	48 8d 87 a0 00
	00 00		 lea	 rax, QWORD PTR [rdi+160]
  00137	eb 07		 jmp	 SHORT $LN36@PyCodec_Su@2
$LN35@PyCodec_Su@2:
  00139	48 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [rdi+160]
$LN36@PyCodec_Su@2:
  00140	42 8b 0c 88	 mov	 ecx, DWORD PTR [rax+r9*4]
$LN38@PyCodec_Su@2:

; 994  :             if (ch < 0xdc80 || ch > 0xdcff) {

  00144	8d 81 80 23 ff
	ff		 lea	 eax, DWORD PTR [rcx-56448]
  0014a	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0014d	77 49		 ja	 SHORT $LN43@PyCodec_Su@2

; 1000 :             }
; 1001 :             *outp++ = ch - 0xdc00;

  0014f	41 88 0b	 mov	 BYTE PTR [r11], cl
  00152	4c 8b 44 24 48	 mov	 r8, QWORD PTR end$[rsp]
  00157	49 ff c1	 inc	 r9
  0015a	49 ff c3	 inc	 r11
  0015d	4d 3b c8	 cmp	 r9, r8
  00160	0f 8c 3a ff ff
	ff		 jl	 $LL17@PyCodec_Su@2
$LN15@PyCodec_Su@2:

; 1002 :         }
; 1003 :         restuple = Py_BuildValue("(On)", res, end);

  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04NBEFNIN@?$CIOn?$CJ?$AA@
  0016d	48 8b d5	 mov	 rdx, rbp
  00170	e8 00 00 00 00	 call	 Py_BuildValue

; 1004 :         Py_DECREF(res);

  00175	48 8b cd	 mov	 rcx, rbp
  00178	48 8b d8	 mov	 rbx, rax
  0017b	e8 00 00 00 00	 call	 _Py_DecRef

; 1005 :         Py_DECREF(object);

  00180	48 8b cf	 mov	 rcx, rdi
  00183	e8 00 00 00 00	 call	 _Py_DecRef
  00188	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1006 :         return restuple;

  0018d	48 8b c3	 mov	 rax, rbx

; 1044 :     }
; 1045 : }

  00190	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00194	5f		 pop	 rdi
  00195	5e		 pop	 rsi
  00196	5b		 pop	 rbx
  00197	c3		 ret	 0
$LN43@PyCodec_Su@2:

; 995  :                 /* Not a UTF-8b surrogate, fail with original exception */
; 996  :                 PyErr_SetObject(PyExceptionInstance_Class(exc), exc);

  00198	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0019c	48 8b d6	 mov	 rdx, rsi
  0019f	e8 00 00 00 00	 call	 PyErr_SetObject

; 997  :                 Py_DECREF(res);

  001a4	48 8b cd	 mov	 rcx, rbp
  001a7	e8 00 00 00 00	 call	 _Py_DecRef
$LN48@PyCodec_Su@2:

; 998  :                 Py_DECREF(object);

  001ac	48 8b cf	 mov	 rcx, rdi
  001af	e8 00 00 00 00	 call	 _Py_DecRef
  001b4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 999  :                 return NULL;

  001b9	33 c0		 xor	 eax, eax

; 1044 :     }
; 1045 : }

  001bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001bf	5f		 pop	 rdi
  001c0	5e		 pop	 rsi
  001c1	5b		 pop	 rbx
  001c2	c3		 ret	 0
$LN22@PyCodec_Su@2:

; 1007 :     }
; 1008 :     else if (PyObject_IsInstance(exc, PyExc_UnicodeDecodeError)) {

  001c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_UnicodeDecodeError
  001ca	e8 00 00 00 00	 call	 PyObject_IsInstance

; 1013 :         if (PyUnicodeDecodeError_GetStart(exc, &start))

  001cf	48 8b ce	 mov	 rcx, rsi
  001d2	85 c0		 test	 eax, eax
  001d4	0f 84 f5 00 00
	00		 je	 $LN11@PyCodec_Su@2
  001da	48 8d 54 24 50	 lea	 rdx, QWORD PTR start$[rsp]
  001df	33 db		 xor	 ebx, ebx
  001e1	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetStart
  001e6	85 c0		 test	 eax, eax

; 1014 :             return NULL;

  001e8	75 39		 jne	 SHORT $LN49@PyCodec_Su@2

; 1015 :         if (PyUnicodeDecodeError_GetEnd(exc, &end))

  001ea	48 8d 54 24 48	 lea	 rdx, QWORD PTR end$[rsp]
  001ef	48 8b ce	 mov	 rcx, rsi
  001f2	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetEnd
  001f7	85 c0		 test	 eax, eax

; 1016 :             return NULL;

  001f9	75 28		 jne	 SHORT $LN49@PyCodec_Su@2

; 1017 :         if (!(object = PyUnicodeDecodeError_GetObject(exc)))

  001fb	48 8b ce	 mov	 rcx, rsi
  001fe	e8 00 00 00 00	 call	 PyUnicodeDecodeError_GetObject
  00203	48 8b f8	 mov	 rdi, rax
  00206	48 85 c0	 test	 rax, rax

; 1018 :             return NULL;

  00209	74 18		 je	 SHORT $LN49@PyCodec_Su@2

; 1019 :         if (!(p = (unsigned char*)PyBytes_AsString(object))) {

  0020b	48 8b c8	 mov	 rcx, rax
  0020e	e8 00 00 00 00	 call	 PyBytes_AsString
  00213	4c 8b d8	 mov	 r11, rax
  00216	48 85 c0	 test	 rax, rax
  00219	75 12		 jne	 SHORT $LN42@PyCodec_Su@2

; 1020 :             Py_DECREF(object);

  0021b	48 8b cf	 mov	 rcx, rdi
  0021e	e8 00 00 00 00	 call	 _Py_DecRef
$LN49@PyCodec_Su@2:

; 1021 :             return NULL;

  00223	33 c0		 xor	 eax, eax

; 1044 :     }
; 1045 : }

  00225	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00229	5f		 pop	 rdi
  0022a	5e		 pop	 rsi
  0022b	5b		 pop	 rbx
  0022c	c3		 ret	 0
$LN42@PyCodec_Su@2:

; 1009 :         PyObject *str;
; 1010 :         unsigned char *p;
; 1011 :         Py_UCS2 ch[4]; /* decode up to 4 bad bytes. */
; 1012 :         int consumed = 0;

  0022d	4c 8b 44 24 48	 mov	 r8, QWORD PTR end$[rsp]
  00232	4c 8b 4c 24 50	 mov	 r9, QWORD PTR start$[rsp]
  00237	48 8b d3	 mov	 rdx, rbx
  0023a	4d 2b c1	 sub	 r8, r9
  0023d	41 ba 00 24 00
	00		 mov	 r10d, 9216		; 00002400H
$LL6@PyCodec_Su@2:

; 1022 :         }
; 1023 :         while (consumed < 4 && consumed < end-start) {

  00243	48 63 c3	 movsxd	 rax, ebx
  00246	49 3b c0	 cmp	 rax, r8
  00249	7d 24		 jge	 SHORT $LN44@PyCodec_Su@2

; 1024 :             /* Refuse to escape ASCII bytes. */
; 1025 :             if (p[start+consumed] < 128)

  0024b	4a 8d 04 1a	 lea	 rax, QWORD PTR [rdx+r11]
  0024f	42 0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+r9]
  00254	80 f9 80	 cmp	 cl, 128			; 00000080H
  00257	72 16		 jb	 SHORT $LN44@PyCodec_Su@2

; 1026 :                 break;
; 1027 :             ch[consumed] = 0xdc00 + p[start+consumed];

  00259	0f b6 c1	 movzx	 eax, cl

; 1028 :             consumed++;

  0025c	ff c3		 inc	 ebx
  0025e	48 ff c2	 inc	 rdx
  00261	66 41 2b c2	 sub	 ax, r10w
  00265	66 89 44 54 56	 mov	 WORD PTR ch$21296[rsp+rdx*2-2], ax
  0026a	83 fb 04	 cmp	 ebx, 4
  0026d	7c d4		 jl	 SHORT $LL6@PyCodec_Su@2
$LN44@PyCodec_Su@2:

; 1029 :         }
; 1030 :         Py_DECREF(object);

  0026f	48 8b cf	 mov	 rcx, rdi
  00272	e8 00 00 00 00	 call	 _Py_DecRef

; 1031 :         if (!consumed) {

  00277	85 db		 test	 ebx, ebx
  00279	75 16		 jne	 SHORT $LN3@PyCodec_Su@2

; 1032 :             /* codec complained about ASCII byte. */
; 1033 :             PyErr_SetObject(PyExceptionInstance_Class(exc), exc);

  0027b	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0027f	48 8b d6	 mov	 rdx, rsi
  00282	e8 00 00 00 00	 call	 PyErr_SetObject

; 1034 :             return NULL;

  00287	33 c0		 xor	 eax, eax

; 1044 :     }
; 1045 : }

  00289	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028d	5f		 pop	 rdi
  0028e	5e		 pop	 rsi
  0028f	5b		 pop	 rbx
  00290	c3		 ret	 0
$LN3@PyCodec_Su@2:

; 1035 :         }
; 1036 :         str = PyUnicode_FromKindAndData(PyUnicode_2BYTE_KIND, ch, consumed);

  00291	48 63 db	 movsxd	 rbx, ebx
  00294	48 8d 54 24 58	 lea	 rdx, QWORD PTR ch$21296[rsp]
  00299	b9 02 00 00 00	 mov	 ecx, 2
  0029e	4c 8b c3	 mov	 r8, rbx
  002a1	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  002a6	48 8b d0	 mov	 rdx, rax

; 1037 :         if (str == NULL)

  002a9	48 85 c0	 test	 rax, rax

; 1038 :             return NULL;

  002ac	0f 84 71 ff ff
	ff		 je	 $LN49@PyCodec_Su@2

; 1039 :         return Py_BuildValue("(Nn)", str, start+consumed);

  002b2	48 8b 44 24 50	 mov	 rax, QWORD PTR start$[rsp]
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LFKIDKOI@?$CINn?$CJ?$AA@
  002be	4c 8d 04 03	 lea	 r8, QWORD PTR [rbx+rax]
  002c2	e8 00 00 00 00	 call	 Py_BuildValue

; 1044 :     }
; 1045 : }

  002c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002cb	5f		 pop	 rdi
  002cc	5e		 pop	 rsi
  002cd	5b		 pop	 rbx
  002ce	c3		 ret	 0
$LN11@PyCodec_Su@2:

; 1040 :     }
; 1041 :     else {
; 1042 :         wrong_exception_type(exc);

  002cf	e8 00 00 00 00	 call	 wrong_exception_type

; 1043 :         return NULL;

  002d4	33 c0		 xor	 eax, eax

; 1044 :     }
; 1045 : }

  002d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002da	5f		 pop	 rdi
  002db	5e		 pop	 rsi
  002dc	5b		 pop	 rbx
  002dd	c3		 ret	 0
PyCodec_SurrogateEscapeErrors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT strict_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
strict_errors PROC					; COMDAT

; 1050 :     return PyCodec_StrictErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1051 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_StrictErrors
strict_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ignore_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
ignore_errors PROC					; COMDAT

; 1056 :     return PyCodec_IgnoreErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1057 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_IgnoreErrors
ignore_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT replace_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
replace_errors PROC					; COMDAT

; 1062 :     return PyCodec_ReplaceErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1063 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_ReplaceErrors
replace_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT xmlcharrefreplace_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
xmlcharrefreplace_errors PROC				; COMDAT

; 1068 :     return PyCodec_XMLCharRefReplaceErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1069 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_XMLCharRefReplaceErrors
xmlcharrefreplace_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT backslashreplace_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
backslashreplace_errors PROC				; COMDAT

; 1074 :     return PyCodec_BackslashReplaceErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1075 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_BackslashReplaceErrors
backslashreplace_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT surrogatepass_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
surrogatepass_errors PROC				; COMDAT

; 1079 :     return PyCodec_SurrogatePassErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1080 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_SurrogatePassErrors
surrogatepass_errors ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT surrogateescape_errors
_TEXT	SEGMENT
self$ = 8
exc$ = 16
surrogateescape_errors PROC				; COMDAT

; 1084 :     return PyCodec_SurrogateEscapeErrors(exc);

  00000	48 8b ca	 mov	 rcx, rdx

; 1085 : }

  00003	e9 00 00 00 00	 jmp	 PyCodec_SurrogateEscapeErrors
surrogateescape_errors ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JLELGAP@encodings?$AA@			; `string'
PUBLIC	??_C@_0CA@HPGLPMCB@can?8t?5initialize?5codec?5registry?$AA@ ; `string'
PUBLIC	??_C@_0CG@KAJPKAEK@can?8t?5initialize?5codec?5error?5reg@ ; `string'
EXTRN	PyImport_ImportModuleNoBlock:PROC
EXTRN	Py_FatalError:PROC
EXTRN	PyCFunction_NewEx:PROC
EXTRN	PyDict_New:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCodecRegistry_Init DD imagerel _PyCodecRegistry_Init
	DD	imagerel _PyCodecRegistry_Init+82
	DD	imagerel $unwind$_PyCodecRegistry_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyCodecRegistry_Init DD imagerel _PyCodecRegistry_Init+82
	DD	imagerel _PyCodecRegistry_Init+237
	DD	imagerel $chain$4$_PyCodecRegistry_Init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_PyCodecRegistry_Init DD imagerel _PyCodecRegistry_Init+237
	DD	imagerel _PyCodecRegistry_Init+319
	DD	imagerel $chain$5$_PyCodecRegistry_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_PyCodecRegistry_Init DD 021H
	DD	imagerel _PyCodecRegistry_Init
	DD	imagerel _PyCodecRegistry_Init+82
	DD	imagerel $unwind$_PyCodecRegistry_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyCodecRegistry_Init DD 0a2721H
	DD	04d427H
	DD	05c414H
	DD	0a640fH
	DD	09540aH
	DD	083405H
	DD	imagerel _PyCodecRegistry_Init
	DD	imagerel _PyCodecRegistry_Init+82
	DD	imagerel $unwind$_PyCodecRegistry_Init
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodecRegistry_Init DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_09JLELGAP@encodings?$AA@
CONST	SEGMENT
??_C@_09JLELGAP@encodings?$AA@ DB 'encodings', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@HPGLPMCB@can?8t?5initialize?5codec?5registry?$AA@
CONST	SEGMENT
??_C@_0CA@HPGLPMCB@can?8t?5initialize?5codec?5registry?$AA@ DB 'can''t in'
	DB	'itialize codec registry', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KAJPKAEK@can?8t?5initialize?5codec?5error?5reg@
CONST	SEGMENT
??_C@_0CG@KAJPKAEK@can?8t?5initialize?5codec?5error?5reg@ DB 'can''t init'
	DB	'ialize codec error registry', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodecRegistry_Init
_TEXT	SEGMENT
_PyCodecRegistry_Init PROC				; COMDAT

; 1088 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1089 :     static struct {
; 1090 :         char *name;
; 1091 :         PyMethodDef def;
; 1092 :     } methods[] =
; 1093 :     {
; 1094 :         {
; 1095 :             "strict",
; 1096 :             {
; 1097 :                 "strict_errors",
; 1098 :                 strict_errors,
; 1099 :                 METH_O,
; 1100 :                 PyDoc_STR("Implements the 'strict' error handling, which "
; 1101 :                           "raises a UnicodeError on coding errors.")
; 1102 :             }
; 1103 :         },
; 1104 :         {
; 1105 :             "ignore",
; 1106 :             {
; 1107 :                 "ignore_errors",
; 1108 :                 ignore_errors,
; 1109 :                 METH_O,
; 1110 :                 PyDoc_STR("Implements the 'ignore' error handling, which "
; 1111 :                           "ignores malformed data and continues.")
; 1112 :             }
; 1113 :         },
; 1114 :         {
; 1115 :             "replace",
; 1116 :             {
; 1117 :                 "replace_errors",
; 1118 :                 replace_errors,
; 1119 :                 METH_O,
; 1120 :                 PyDoc_STR("Implements the 'replace' error handling, which "
; 1121 :                           "replaces malformed data with a replacement marker.")
; 1122 :             }
; 1123 :         },
; 1124 :         {
; 1125 :             "xmlcharrefreplace",
; 1126 :             {
; 1127 :                 "xmlcharrefreplace_errors",
; 1128 :                 xmlcharrefreplace_errors,
; 1129 :                 METH_O,
; 1130 :                 PyDoc_STR("Implements the 'xmlcharrefreplace' error handling, "
; 1131 :                           "which replaces an unencodable character with the "
; 1132 :                           "appropriate XML character reference.")
; 1133 :             }
; 1134 :         },
; 1135 :         {
; 1136 :             "backslashreplace",
; 1137 :             {
; 1138 :                 "backslashreplace_errors",
; 1139 :                 backslashreplace_errors,
; 1140 :                 METH_O,
; 1141 :                 PyDoc_STR("Implements the 'backslashreplace' error handling, "
; 1142 :                           "which replaces an unencodable character with a "
; 1143 :                           "backslashed escape sequence.")
; 1144 :             }
; 1145 :         },
; 1146 :         {
; 1147 :             "surrogatepass",
; 1148 :             {
; 1149 :                 "surrogatepass",
; 1150 :                 surrogatepass_errors,
; 1151 :                 METH_O
; 1152 :             }
; 1153 :         },
; 1154 :         {
; 1155 :             "surrogateescape",
; 1156 :             {
; 1157 :                 "surrogateescape",
; 1158 :                 surrogateescape_errors,
; 1159 :                 METH_O
; 1160 :             }
; 1161 :         }
; 1162 :     };
; 1163 : 
; 1164 :     PyInterpreterState *interp = PyThreadState_GET()->interp;

  00006	e8 00 00 00 00	 call	 _Py_PXCTX
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN13@PyCodecReg
  0000f	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00014	eb 07		 jmp	 SHORT $LN14@PyCodecReg
$LN13@PyCodecReg:
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN14@PyCodecReg:
  0001d	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]

; 1165 :     PyObject *mod;
; 1166 :     unsigned i;
; 1167 : 
; 1168 :     if (interp->codec_search_path != NULL)

  00021	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0

; 1169 :         return 0;

  00026	0f 85 0b 01 00
	00		 jne	 $LN17@PyCodecReg

; 1170 : 
; 1171 :     interp->codec_search_path = PyList_New(0);

  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 PyList_New
  00033	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1172 :     interp->codec_search_cache = PyDict_New();

  00037	e8 00 00 00 00	 call	 PyDict_New
  0003c	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax

; 1173 :     interp->codec_error_registry = PyDict_New();

  00040	e8 00 00 00 00	 call	 PyDict_New
  00045	48 89 47 48	 mov	 QWORD PTR [rdi+72], rax

; 1174 : 
; 1175 :     if (interp->codec_error_registry) {

  00049	48 85 c0	 test	 rax, rax
  0004c	0f 84 9b 00 00
	00		 je	 $LN6@PyCodecReg

; 1176 :         for (i = 0; i < Py_ARRAY_LENGTH(methods); ++i) {

  00052	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00057	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0005c	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  00061	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00066	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:?methods@?1??_PyCodecRegistry_Init@@9@9
  0006d	48 8d 35 08 00
	00 00		 lea	 rsi, OFFSET FLAT:?methods@?1??_PyCodecRegistry_Init@@9@9+8
  00074	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00079	41 bc 07 00 00
	00		 mov	 r12d, 7
  0007f	90		 npad	 1
$LL8@PyCodecReg:

; 1177 :             PyObject *func = PyCFunction_New(&methods[i].def, NULL);

  00080	45 33 c0	 xor	 r8d, r8d
  00083	33 d2		 xor	 edx, edx
  00085	48 8b ce	 mov	 rcx, rsi
  00088	e8 00 00 00 00	 call	 PyCFunction_NewEx
  0008d	4c 8b e8	 mov	 r13, rax

; 1178 :             int res;
; 1179 :             if (!func)

  00090	48 85 c0	 test	 rax, rax
  00093	75 0c		 jne	 SHORT $LN5@PyCodecReg

; 1180 :                 Py_FatalError("can't initialize codec error registry");

  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@KAJPKAEK@can?8t?5initialize?5codec?5error?5reg@
  0009c	e8 00 00 00 00	 call	 Py_FatalError
$LN5@PyCodecReg:

; 1181 :             res = PyCodec_RegisterError(methods[i].name, func);

  000a1	48 8b 4d 00	 mov	 rcx, QWORD PTR [rbp]
  000a5	49 8b d5	 mov	 rdx, r13
  000a8	e8 00 00 00 00	 call	 PyCodec_RegisterError

; 1182 :             Py_DECREF(func);

  000ad	49 8b cd	 mov	 rcx, r13
  000b0	8b d8		 mov	 ebx, eax
  000b2	e8 00 00 00 00	 call	 _Py_DecRef

; 1183 :             if (res)

  000b7	85 db		 test	 ebx, ebx
  000b9	74 0c		 je	 SHORT $LN7@PyCodecReg

; 1184 :                 Py_FatalError("can't initialize codec error registry");

  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@KAJPKAEK@can?8t?5initialize?5codec?5error?5reg@
  000c2	e8 00 00 00 00	 call	 Py_FatalError
$LN7@PyCodecReg:

; 1176 :         for (i = 0; i < Py_ARRAY_LENGTH(methods); ++i) {

  000c7	48 83 c6 28	 add	 rsi, 40			; 00000028H
  000cb	48 83 c5 28	 add	 rbp, 40			; 00000028H
  000cf	49 ff cc	 dec	 r12
  000d2	75 ac		 jne	 SHORT $LL8@PyCodecReg
  000d4	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  000d9	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  000de	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000e3	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN6@PyCodecReg:

; 1185 :         }
; 1186 :     }
; 1187 : 
; 1188 :     if (interp->codec_search_path == NULL ||
; 1189 :         interp->codec_search_cache == NULL ||
; 1190 :         interp->codec_error_registry == NULL)

  000ed	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  000f2	74 0e		 je	 SHORT $LN2@PyCodecReg
  000f4	48 83 7f 40 00	 cmp	 QWORD PTR [rdi+64], 0
  000f9	74 07		 je	 SHORT $LN2@PyCodecReg
  000fb	48 83 7f 48 00	 cmp	 QWORD PTR [rdi+72], 0
  00100	75 0c		 jne	 SHORT $LN3@PyCodecReg
$LN2@PyCodecReg:

; 1191 :         Py_FatalError("can't initialize codec registry");

  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@HPGLPMCB@can?8t?5initialize?5codec?5registry?$AA@
  00109	e8 00 00 00 00	 call	 Py_FatalError
$LN3@PyCodecReg:

; 1192 : 
; 1193 :     mod = PyImport_ImportModuleNoBlock("encodings");

  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09JLELGAP@encodings?$AA@
  00115	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock

; 1194 :     if (mod == NULL) {

  0011a	48 85 c0	 test	 rax, rax
  0011d	75 09		 jne	 SHORT $LN1@PyCodecReg

; 1195 :         return -1;

  0011f	83 c8 ff	 or	 eax, -1

; 1200 : }

  00122	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00126	5f		 pop	 rdi
  00127	c3		 ret	 0
$LN1@PyCodecReg:

; 1196 :     }
; 1197 :     Py_DECREF(mod);

  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 _Py_DecRef

; 1198 :     interp->codecs_initialized = 1;

  00130	c7 47 50 01 00
	00 00		 mov	 DWORD PTR [rdi+80], 1
$LN17@PyCodecReg:

; 1199 :     return 0;

  00137	33 c0		 xor	 eax, eax

; 1200 : }

  00139	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013d	5f		 pop	 rdi
  0013e	c3		 ret	 0
_PyCodecRegistry_Init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PAOEIBOE@argument?5must?5be?5callable?$AA@ ; `string'
PUBLIC	PyCodec_Register
EXTRN	PyList_Append:PROC
EXTRN	PyErr_BadArgument:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_Register DD imagerel $LN8
	DD	imagerel $LN8+147
	DD	imagerel $unwind$PyCodec_Register
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_Register DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BK@PAOEIBOE@argument?5must?5be?5callable?$AA@
CONST	SEGMENT
??_C@_0BK@PAOEIBOE@argument?5must?5be?5callable?$AA@ DB 'argument must be'
	DB	' callable', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyCodec_Register
_TEXT	SEGMENT
search_function$ = 48
PyCodec_Register PROC					; COMDAT

; 32   : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 33   :     PyInterpreterState *interp = PyThreadState_GET()->interp;

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN6@PyCodec_Re@3
  00016	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0001b	eb 07		 jmp	 SHORT $LN7@PyCodec_Re@3
$LN6@PyCodec_Re@3:
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN7@PyCodec_Re@3:
  00024	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]

; 34   :     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())

  00028	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  0002d	75 09		 jne	 SHORT $LN3@PyCodec_Re@3
  0002f	e8 00 00 00 00	 call	 _PyCodecRegistry_Init
  00034	85 c0		 test	 eax, eax
  00036	75 37		 jne	 SHORT $onError$20188
$LN3@PyCodec_Re@3:

; 35   :         goto onError;
; 36   :     if (search_function == NULL) {

  00038	48 85 db	 test	 rbx, rbx
  0003b	75 13		 jne	 SHORT $LN2@PyCodec_Re@3

; 37   :         PyErr_BadArgument();

  0003d	e8 00 00 00 00	 call	 PyErr_BadArgument

; 45   : 
; 46   :  onError:
; 47   :     return -1;

  00042	83 c8 ff	 or	 eax, -1

; 48   : }

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN2@PyCodec_Re@3:

; 38   :         goto onError;
; 39   :     }
; 40   :     if (!PyCallable_Check(search_function)) {

  00050	48 8b cb	 mov	 rcx, rbx
  00053	e8 00 00 00 00	 call	 PyCallable_Check
  00058	85 c0		 test	 eax, eax
  0005a	75 21		 jne	 SHORT $LN1@PyCodec_Re@3

; 41   :         PyErr_SetString(PyExc_TypeError, "argument must be callable");

  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PAOEIBOE@argument?5must?5be?5callable?$AA@
  0006a	e8 00 00 00 00	 call	 PyErr_SetString
$onError$20188:

; 45   : 
; 46   :  onError:
; 47   :     return -1;

  0006f	83 c8 ff	 or	 eax, -1

; 48   : }

  00072	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN1@PyCodec_Re@3:

; 42   :         goto onError;
; 43   :     }
; 44   :     return PyList_Append(interp->codec_search_path, search_function);

  0007d	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00081	48 8b d3	 mov	 rdx, rbx

; 48   : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	e9 00 00 00 00	 jmp	 PyList_Append
PyCodec_Register ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@LLLEHON@codec?5search?5functions?5must?5retu@ ; `string'
PUBLIC	??_C@_0BF@KNKEBGAE@unknown?5encoding?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0DK@MHMNAODF@no?5codec?5search?5functions?5regist@ ; `string'
PUBLIC	_PyCodec_Lookup
EXTRN	PyDict_SetItem:PROC
EXTRN	PyList_GetItem:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyExc_LookupError:QWORD
EXTRN	PyList_Size:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyUnicode_InternInPlace:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_PyCodec_Lookup DD imagerel $LN42
	DD	imagerel $LN42+577
	DD	imagerel $unwind$_PyCodec_Lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_Lookup DD 0a1601H
	DD	0e5416H
	DD	0d3416H
	DD	0e0125216H
	DD	0c00ed010H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0CM@LLLEHON@codec?5search?5functions?5must?5retu@
CONST	SEGMENT
??_C@_0CM@LLLEHON@codec?5search?5functions?5must?5retu@ DB 'codec search '
	DB	'functions must return 4-tuples', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KNKEBGAE@unknown?5encoding?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@KNKEBGAE@unknown?5encoding?3?5?$CFs?$AA@ DB 'unknown encoding: '
	DB	'%s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@MHMNAODF@no?5codec?5search?5functions?5regist@
CONST	SEGMENT
??_C@_0DK@MHMNAODF@no?5codec?5search?5functions?5regist@ DB 'no codec sea'
	DB	'rch functions registered: can''t find encoding', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
CONST	ENDS
;	COMDAT _PyCodec_Lookup
_TEXT	SEGMENT
v$ = 96
encoding$ = 96
_PyCodec_Lookup PROC					; COMDAT

; 101  : {

$LN42:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	4c 8b e9	 mov	 r13, rcx

; 102  :     PyInterpreterState *interp;
; 103  :     PyObject *result, *args = NULL, *v;
; 104  :     Py_ssize_t i, len;
; 105  : 
; 106  :     if (encoding == NULL) {

  00019	48 85 c9	 test	 rcx, rcx
  0001c	75 0a		 jne	 SHORT $LN21@PyCodec_Lo

; 107  :         PyErr_BadArgument();

  0001e	e8 00 00 00 00	 call	 PyErr_BadArgument

; 108  :         goto onError;

  00023	e9 00 02 00 00	 jmp	 $LN3@PyCodec_Lo
$LN21@PyCodec_Lo:

; 109  :     }
; 110  : 
; 111  :     interp = PyThreadState_GET()->interp;

  00028	e8 00 00 00 00	 call	 _Py_PXCTX
  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN24@PyCodec_Lo
  00031	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  00036	eb 07		 jmp	 SHORT $LN25@PyCodec_Lo
$LN24@PyCodec_Lo:
  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN25@PyCodec_Lo:
  0003f	4c 8b 60 08	 mov	 r12, QWORD PTR [rax+8]

; 112  :     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())

  00043	49 83 7c 24 38
	00		 cmp	 QWORD PTR [r12+56], 0
  00049	75 0d		 jne	 SHORT $LN20@PyCodec_Lo
  0004b	e8 00 00 00 00	 call	 _PyCodecRegistry_Init
  00050	85 c0		 test	 eax, eax
  00052	0f 85 d0 01 00
	00		 jne	 $LN3@PyCodec_Lo
$LN20@PyCodec_Lo:

; 113  :         goto onError;
; 114  : 
; 115  :     /* Convert the encoding to a normalized Python string: all
; 116  :        characters are converted to lower case, spaces and hyphens are
; 117  :        replaced with underscores. */
; 118  :     v = normalizestring(encoding);

  00058	49 8b cd	 mov	 rcx, r13
  0005b	e8 00 00 00 00	 call	 normalizestring
  00060	48 89 44 24 60	 mov	 QWORD PTR v$[rsp], rax

; 119  :     if (v == NULL)

  00065	48 85 c0	 test	 rax, rax
  00068	0f 84 ba 01 00
	00		 je	 $LN3@PyCodec_Lo

; 120  :         goto onError;
; 121  :     PyUnicode_InternInPlace(&v);

  0006e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR v$[rsp]
  00073	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 122  : 
; 123  :     /* First, try to lookup the name in the registry dictionary */
; 124  :     result = PyDict_GetItem(interp->codec_search_cache, v);

  00078	48 8b 54 24 60	 mov	 rdx, QWORD PTR v$[rsp]
  0007d	49 8b 4c 24 40	 mov	 rcx, QWORD PTR [r12+64]
  00082	e8 00 00 00 00	 call	 PyDict_GetItem
  00087	48 8b d8	 mov	 rbx, rax

; 125  :     if (result != NULL) {

  0008a	48 85 c0	 test	 rax, rax
  0008d	74 1a		 je	 SHORT $LN18@PyCodec_Lo

; 126  :         Py_INCREF(result);

  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 _Py_IncRef

; 127  :         Py_DECREF(v);

  00097	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 128  :         return result;

  000a1	48 8b c3	 mov	 rax, rbx
  000a4	e9 81 01 00 00	 jmp	 $LN22@PyCodec_Lo
$LN18@PyCodec_Lo:

; 129  :     }
; 130  : 
; 131  :     /* Next, scan the search functions in order of registration */
; 132  :     args = PyTuple_New(1);

  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	e8 00 00 00 00	 call	 PyTuple_New
  000b3	48 8b f8	 mov	 rdi, rax

; 133  :     if (args == NULL)

  000b6	48 85 c0	 test	 rax, rax
  000b9	0f 84 69 01 00
	00		 je	 $LN3@PyCodec_Lo

; 134  :         goto onError;
; 135  :     PyTuple_SET_ITEM(args,0,v);

  000bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  000c4	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 136  : 
; 137  :     len = PyList_Size(interp->codec_search_path);

  000c8	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  000cd	e8 00 00 00 00	 call	 PyList_Size
  000d2	48 8b e8	 mov	 rbp, rax

; 138  :     if (len < 0)

  000d5	48 85 c0	 test	 rax, rax
  000d8	0f 88 c2 00 00
	00		 js	 $onError$20232

; 139  :         goto onError;
; 140  :     if (len == 0) {

  000de	75 18		 jne	 SHORT $LN15@PyCodec_Lo

; 141  :         PyErr_SetString(PyExc_LookupError,
; 142  :                         "no codec search functions registered: "
; 143  :                         "can't find encoding");

  000e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@MHMNAODF@no?5codec?5search?5functions?5regist@
  000ee	e8 00 00 00 00	 call	 PyErr_SetString

; 144  :         goto onError;

  000f3	e9 a8 00 00 00	 jmp	 $onError$20232
$LN15@PyCodec_Lo:

; 145  :     }
; 146  : 
; 147  :     for (i = 0; i < len; i++) {

  000f8	33 f6		 xor	 esi, esi
  000fa	48 85 c0	 test	 rax, rax
  000fd	7e 4e		 jle	 SHORT $LN12@PyCodec_Lo
  000ff	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct
  00106	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL14@PyCodec_Lo:

; 148  :         PyObject *func;
; 149  : 
; 150  :         func = PyList_GetItem(interp->codec_search_path, i);

  00110	49 8b 4c 24 38	 mov	 rcx, QWORD PTR [r12+56]
  00115	48 8b d6	 mov	 rdx, rsi
  00118	e8 00 00 00 00	 call	 PyList_GetItem

; 151  :         if (func == NULL)

  0011d	48 85 c0	 test	 rax, rax
  00120	74 7e		 je	 SHORT $onError$20232

; 152  :             goto onError;
; 153  :         result = PyEval_CallObject(func, args);

  00122	45 33 c0	 xor	 r8d, r8d
  00125	48 8b d7	 mov	 rdx, rdi
  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  00130	48 8b d8	 mov	 rbx, rax

; 154  :         if (result == NULL)

  00133	48 85 c0	 test	 rax, rax
  00136	74 68		 je	 SHORT $onError$20232

; 155  :             goto onError;
; 156  :         if (result == Py_None) {

  00138	49 3b c6	 cmp	 rax, r14
  0013b	75 31		 jne	 SHORT $LN9@PyCodec_Lo

; 157  :             Py_DECREF(result);

  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 _Py_DecRef
  00145	48 ff c6	 inc	 rsi
  00148	48 3b f5	 cmp	 rsi, rbp
  0014b	7c c3		 jl	 SHORT $LL14@PyCodec_Lo
$LN12@PyCodec_Lo:

; 163  :             Py_DECREF(result);
; 164  :             goto onError;
; 165  :         }
; 166  :         break;
; 167  :     }
; 168  :     if (i == len) {

  0014d	48 3b f5	 cmp	 rsi, rbp
  00150	0f 85 9b 00 00
	00		 jne	 $LN6@PyCodec_Lo

; 169  :         /* XXX Perhaps we should cache misses too ? */
; 170  :         PyErr_Format(PyExc_LookupError,
; 171  :                      "unknown encoding: %s", encoding);

  00156	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KNKEBGAE@unknown?5encoding?3?5?$CFs?$AA@
  00164	4d 8b c5	 mov	 r8, r13
  00167	e8 00 00 00 00	 call	 PyErr_Format

; 172  :         goto onError;

  0016c	eb 32		 jmp	 SHORT $onError$20232
$LN9@PyCodec_Lo:

; 158  :             continue;
; 159  :         }
; 160  :         if (!PyTuple_Check(result) || PyTuple_GET_SIZE(result) != 4) {

  0016e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00172	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0017c	74 07		 je	 SHORT $LN7@PyCodec_Lo
  0017e	48 83 7b 60 04	 cmp	 QWORD PTR [rbx+96], 4
  00183	74 c8		 je	 SHORT $LN12@PyCodec_Lo
$LN7@PyCodec_Lo:

; 161  :             PyErr_SetString(PyExc_TypeError,
; 162  :                             "codec search functions must return 4-tuples");

  00185	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@LLLEHON@codec?5search?5functions?5must?5retu@
  00193	e8 00 00 00 00	 call	 PyErr_SetString
$LN41@PyCodec_Lo:

; 177  :         Py_DECREF(result);

  00198	48 8b cb	 mov	 rcx, rbx
  0019b	e8 00 00 00 00	 call	 _Py_DecRef
$onError$20232:

; 182  : 
; 183  :  onError:
; 184  :     Py_XDECREF(args);

  001a0	e8 00 00 00 00	 call	 _Py_PXCTX
  001a5	85 c0		 test	 eax, eax
  001a7	75 7f		 jne	 SHORT $LN3@PyCodec_Lo
  001a9	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001ad	a8 20		 test	 al, 32			; 00000020H
  001af	75 6f		 jne	 SHORT $LN30@PyCodec_Lo
  001b1	84 c0		 test	 al, al
  001b3	78 6b		 js	 SHORT $LN30@PyCodec_Lo
  001b5	a8 02		 test	 al, 2
  001b7	75 6f		 jne	 SHORT $LN3@PyCodec_Lo
  001b9	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001bd	75 69		 jne	 SHORT $LN3@PyCodec_Lo
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001cd	4c 8b cf	 mov	 r9, rdi
  001d0	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001d6	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001de	e8 00 00 00 00	 call	 _PyParallel_Guard
  001e3	48 8b cf	 mov	 rcx, rdi
  001e6	85 c0		 test	 eax, eax
  001e8	74 2a		 je	 SHORT $LN35@PyCodec_Lo
  001ea	e8 00 00 00 00	 call	 _Px_Dealloc
  001ef	eb 37		 jmp	 SHORT $LN3@PyCodec_Lo
$LN6@PyCodec_Lo:

; 173  :     }
; 174  : 
; 175  :     /* Cache and return the result */
; 176  :     if (PyDict_SetItem(interp->codec_search_cache, v, result) < 0) {

  001f1	48 8b 54 24 60	 mov	 rdx, QWORD PTR v$[rsp]
  001f6	49 8b 4c 24 40	 mov	 rcx, QWORD PTR [r12+64]
  001fb	4c 8b c3	 mov	 r8, rbx
  001fe	e8 00 00 00 00	 call	 PyDict_SetItem
  00203	85 c0		 test	 eax, eax

; 177  :         Py_DECREF(result);

  00205	78 91		 js	 SHORT $LN41@PyCodec_Lo

; 178  :         goto onError;
; 179  :     }
; 180  :     Py_DECREF(args);

  00207	48 8b cf	 mov	 rcx, rdi
  0020a	e8 00 00 00 00	 call	 _Py_DecRef

; 181  :     return result;

  0020f	48 8b c3	 mov	 rax, rbx
  00212	eb 16		 jmp	 SHORT $LN22@PyCodec_Lo

; 182  : 
; 183  :  onError:
; 184  :     Py_XDECREF(args);

$LN35@PyCodec_Lo:
  00214	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00218	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0021e	eb 08		 jmp	 SHORT $LN3@PyCodec_Lo
$LN30@PyCodec_Lo:
  00220	48 8b cf	 mov	 rcx, rdi
  00223	e8 00 00 00 00	 call	 Px_DecRef
$LN3@PyCodec_Lo:

; 185  :     return NULL;

  00228	33 c0		 xor	 eax, eax
$LN22@PyCodec_Lo:

; 186  : }

  0022a	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  0022f	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00234	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00238	41 5e		 pop	 r14
  0023a	41 5d		 pop	 r13
  0023c	41 5c		 pop	 r12
  0023e	5f		 pop	 rdi
  0023f	5e		 pop	 rsi
  00240	c3		 ret	 0
_PyCodec_Lookup ENDP
_TEXT	ENDS
PUBLIC	PyCodec_KnownEncoding
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_KnownEncoding DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$PyCodec_KnownEncoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_KnownEncoding DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_KnownEncoding
_TEXT	SEGMENT
encoding$ = 48
PyCodec_KnownEncoding PROC				; COMDAT

; 191  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 192  :     PyObject *codecs;
; 193  : 
; 194  :     codecs = _PyCodec_Lookup(encoding);

  00004	e8 00 00 00 00	 call	 _PyCodec_Lookup

; 195  :     if (!codecs) {

  00009	48 85 c0	 test	 rax, rax
  0000c	75 0c		 jne	 SHORT $LN2@PyCodec_Kn

; 196  :         PyErr_Clear();

  0000e	e8 00 00 00 00	 call	 PyErr_Clear

; 197  :         return 0;

  00013	33 c0		 xor	 eax, eax

; 202  :     }
; 203  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
$LN2@PyCodec_Kn:

; 198  :     }
; 199  :     else {
; 200  :         Py_DECREF(codecs);

  0001a	48 8b c8	 mov	 rcx, rax
  0001d	e8 00 00 00 00	 call	 _Py_DecRef

; 201  :         return 1;

  00022	b8 01 00 00 00	 mov	 eax, 1

; 202  :     }
; 203  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
PyCodec_KnownEncoding ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$codec_getitem DD imagerel codec_getitem
	DD	imagerel codec_getitem+106
	DD	imagerel $unwind$codec_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$codec_getitem DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
xdata	ENDS
;	COMDAT codec_getitem
_TEXT	SEGMENT
encoding$ = 64
index$ = 72
codec_getitem PROC					; COMDAT

; 233  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 63 da	 movsxd	 rbx, edx

; 234  :     PyObject *codecs;
; 235  :     PyObject *v;
; 236  : 
; 237  :     codecs = _PyCodec_Lookup(encoding);

  00009	e8 00 00 00 00	 call	 _PyCodec_Lookup
  0000e	48 8b c8	 mov	 rcx, rax

; 238  :     if (codecs == NULL)

  00011	48 85 c0	 test	 rax, rax
  00014	75 06		 jne	 SHORT $LN1@codec_geti

; 244  : }

  00016	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
$LN1@codec_geti:

; 239  :         return NULL;
; 240  :     v = PyTuple_GET_ITEM(codecs, index);

  0001c	48 8b 5c d8 70	 mov	 rbx, QWORD PTR [rax+rbx*8+112]

; 241  :     Py_DECREF(codecs);

  00021	e8 00 00 00 00	 call	 _Py_DecRef

; 242  :     Py_INCREF(v);

  00026	e8 00 00 00 00	 call	 _Py_PXCTX
  0002b	85 c0		 test	 eax, eax
  0002d	75 32		 jne	 SHORT $LN5@codec_geti
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003d	4c 8b cb	 mov	 r9, rbx
  00040	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00046	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00053	85 c0		 test	 eax, eax
  00055	75 06		 jne	 SHORT $LN4@codec_geti
  00057	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005b	74 04		 je	 SHORT $LN5@codec_geti
$LN4@codec_geti:
  0005d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@codec_geti:

; 243  :     return v;

  00061	48 8b c3	 mov	 rax, rbx

; 244  : }

  00064	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
codec_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$codec_getincrementalcodec DD imagerel codec_getincrementalcodec
	DD	imagerel codec_getincrementalcodec+94
	DD	imagerel $unwind$codec_getincrementalcodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$codec_getincrementalcodec DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT codec_getincrementalcodec
_TEXT	SEGMENT
encoding$ = 48
errors$ = 56
attrname$ = 64
codec_getincrementalcodec PROC				; COMDAT

; 269  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b f2	 mov	 rsi, rdx

; 270  :     PyObject *codec_info, *ret;
; 271  : 
; 272  :     codec_info = _PyCodec_Lookup(encoding);

  00015	e8 00 00 00 00	 call	 _PyCodec_Lookup
  0001a	48 8b f8	 mov	 rdi, rax

; 273  :     if (codec_info == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 10		 jne	 SHORT $LN1@codec_geti@2

; 277  :     return ret;
; 278  : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN1@codec_geti@2:

; 274  :         return NULL;
; 275  :     ret = codec_makeincrementalcodec(codec_info, errors, attrname);

  00032	4c 8b c3	 mov	 r8, rbx
  00035	48 8b d6	 mov	 rdx, rsi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 codec_makeincrementalcodec

; 276  :     Py_DECREF(codec_info);

  00040	48 8b cf	 mov	 rcx, rdi
  00043	48 8b d8	 mov	 rbx, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 277  :     return ret;
; 278  : }

  0004b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5f		 pop	 rdi
  0005d	c3		 ret	 0
codec_getincrementalcodec ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_02HPGKMGCF@Os?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$codec_getstreamcodec DD imagerel codec_getstreamcodec
	DD	imagerel codec_getstreamcodec+119
	DD	imagerel $unwind$codec_getstreamcodec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$codec_getstreamcodec DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HPGKMGCF@Os?$AA@
CONST	SEGMENT
??_C@_02HPGKMGCF@Os?$AA@ DB 'Os', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT codec_getstreamcodec
_TEXT	SEGMENT
encoding$ = 48
stream$ = 56
errors$ = 64
index$ = 72
codec_getstreamcodec PROC				; COMDAT

; 287  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 63 f1	 movsxd	 rsi, r9d
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b ea	 mov	 rbp, rdx

; 288  :     PyObject *codecs, *streamcodec, *codeccls;
; 289  : 
; 290  :     codecs = _PyCodec_Lookup(encoding);

  0001d	e8 00 00 00 00	 call	 _PyCodec_Lookup
  00022	48 8b f8	 mov	 rdi, rax

; 291  :     if (codecs == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	74 38		 je	 SHORT $LN4@codec_gets
$LN3@codec_gets:

; 292  :         return NULL;
; 293  : 
; 294  :     codeccls = PyTuple_GET_ITEM(codecs, index);

  0002a	48 8b 4c f0 70	 mov	 rcx, QWORD PTR [rax+rsi*8+112]

; 295  :     if (errors != NULL)
; 296  :         streamcodec = PyObject_CallFunction(codeccls, "Os", stream, errors);

  0002f	4c 8b c5	 mov	 r8, rbp
  00032	48 85 db	 test	 rbx, rbx
  00035	74 11		 je	 SHORT $LN2@codec_gets
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HPGKMGCF@Os?$AA@
  0003e	4c 8b cb	 mov	 r9, rbx
  00041	e8 00 00 00 00	 call	 PyObject_CallFunction

; 297  :     else

  00046	eb 0c		 jmp	 SHORT $LN6@codec_gets
$LN2@codec_gets:

; 298  :         streamcodec = PyObject_CallFunction(codeccls, "O", stream);

  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0004f	e8 00 00 00 00	 call	 PyObject_CallFunction
$LN6@codec_gets:

; 299  :     Py_DECREF(codecs);

  00054	48 8b cf	 mov	 rcx, rdi
  00057	48 8b d8	 mov	 rbx, rax
  0005a	e8 00 00 00 00	 call	 _Py_DecRef

; 300  :     return streamcodec;

  0005f	48 8b c3	 mov	 rax, rbx
$LN4@codec_gets:

; 301  : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
codec_getstreamcodec ENDP
_TEXT	ENDS
PUBLIC	PyCodec_Encoder
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_Encoder
_TEXT	SEGMENT
encoding$ = 8
PyCodec_Encoder PROC					; COMDAT

; 329  :     return codec_getitem(encoding, 0);

  00000	33 d2		 xor	 edx, edx

; 330  : }

  00002	e9 00 00 00 00	 jmp	 codec_getitem
PyCodec_Encoder ENDP
_TEXT	ENDS
PUBLIC	PyCodec_Decoder
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_Decoder
_TEXT	SEGMENT
encoding$ = 8
PyCodec_Decoder PROC					; COMDAT

; 334  :     return codec_getitem(encoding, 1);

  00000	ba 01 00 00 00	 mov	 edx, 1

; 335  : }

  00005	e9 00 00 00 00	 jmp	 codec_getitem
PyCodec_Decoder ENDP
_TEXT	ENDS
PUBLIC	PyCodec_IncrementalEncoder
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_IncrementalEncoder
_TEXT	SEGMENT
encoding$ = 8
errors$ = 16
PyCodec_IncrementalEncoder PROC				; COMDAT

; 340  :     return codec_getincrementalcodec(encoding, errors, "incrementalencoder");

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@HFBOOJHC@incrementalencoder?$AA@

; 341  : }

  00007	e9 00 00 00 00	 jmp	 codec_getincrementalcodec
PyCodec_IncrementalEncoder ENDP
_TEXT	ENDS
PUBLIC	PyCodec_IncrementalDecoder
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_IncrementalDecoder
_TEXT	SEGMENT
encoding$ = 8
errors$ = 16
PyCodec_IncrementalDecoder PROC				; COMDAT

; 346  :     return codec_getincrementalcodec(encoding, errors, "incrementaldecoder");

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@LLLDLNBG@incrementaldecoder?$AA@

; 347  : }

  00007	e9 00 00 00 00	 jmp	 codec_getincrementalcodec
PyCodec_IncrementalDecoder ENDP
_TEXT	ENDS
PUBLIC	PyCodec_StreamReader
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_StreamReader
_TEXT	SEGMENT
encoding$ = 8
stream$ = 16
errors$ = 24
PyCodec_StreamReader PROC				; COMDAT

; 353  :     return codec_getstreamcodec(encoding, stream, errors, 2);

  00000	41 b9 02 00 00
	00		 mov	 r9d, 2

; 354  : }

  00006	e9 00 00 00 00	 jmp	 codec_getstreamcodec
PyCodec_StreamReader ENDP
_TEXT	ENDS
PUBLIC	PyCodec_StreamWriter
; Function compile flags: /Ogtpy
;	COMDAT PyCodec_StreamWriter
_TEXT	SEGMENT
encoding$ = 8
stream$ = 16
errors$ = 24
PyCodec_StreamWriter PROC				; COMDAT

; 360  :     return codec_getstreamcodec(encoding, stream, errors, 3);

  00000	41 b9 03 00 00
	00		 mov	 r9d, 3

; 361  : }

  00006	e9 00 00 00 00	 jmp	 codec_getstreamcodec
PyCodec_StreamWriter ENDP
_TEXT	ENDS
PUBLIC	PyCodec_Encode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_Encode DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$PyCodec_Encode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_Encode DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_Encode
_TEXT	SEGMENT
object$ = 48
encoding$ = 56
errors$ = 64
PyCodec_Encode PROC					; COMDAT

; 454  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 455  :     PyObject *encoder;
; 456  : 
; 457  :     encoder = PyCodec_Encoder(encoding);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	49 8b d8	 mov	 rbx, r8
  00013	e8 00 00 00 00	 call	 PyCodec_Encoder

; 458  :     if (encoder == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@PyCodec_En@2

; 462  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@PyCodec_En@2:

; 459  :         return NULL;
; 460  : 
; 461  :     return _PyCodec_EncodeInternal(object, encoder, encoding, errors);

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b cf	 mov	 rcx, rdi

; 462  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	e9 00 00 00 00	 jmp	 _PyCodec_EncodeInternal
PyCodec_Encode ENDP
_TEXT	ENDS
PUBLIC	PyCodec_Decode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCodec_Decode DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$PyCodec_Decode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_Decode DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT PyCodec_Decode
_TEXT	SEGMENT
object$ = 48
encoding$ = 56
errors$ = 64
PyCodec_Decode PROC					; COMDAT

; 467  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 468  :     PyObject *decoder;
; 469  : 
; 470  :     decoder = PyCodec_Decoder(encoding);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	49 8b d8	 mov	 rbx, r8
  00013	e8 00 00 00 00	 call	 PyCodec_Decoder

; 471  :     if (decoder == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@PyCodec_De@2

; 475  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@PyCodec_De@2:

; 472  :         return NULL;
; 473  : 
; 474  :     return _PyCodec_DecodeInternal(object, decoder, encoding, errors);

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b cf	 mov	 rcx, rdi

; 475  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	e9 00 00 00 00	 jmp	 _PyCodec_DecodeInternal
PyCodec_Decode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@DJOHLNAJ@?8?$CF?4400s?8?5is?5not?5a?5text?5encoding?$DL@ ; `string'
PUBLIC	_PyCodec_LookupTextEncoding
EXTRN	PyObject_IsTrue:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCodec_LookupTextEncoding DD imagerel $LN11
	DD	imagerel $LN11+59
	DD	imagerel $unwind$_PyCodec_LookupTextEncoding
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_PyCodec_LookupTextEncoding DD imagerel $LN11+59
	DD	imagerel $LN11+156
	DD	imagerel $chain$0$_PyCodec_LookupTextEncoding
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_PyCodec_LookupTextEncoding DD imagerel $LN11+156
	DD	imagerel $LN11+171
	DD	imagerel $chain$2$_PyCodec_LookupTextEncoding
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_PyCodec_LookupTextEncoding DD imagerel $LN11+171
	DD	imagerel $LN11+200
	DD	imagerel $chain$3$_PyCodec_LookupTextEncoding
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_PyCodec_LookupTextEncoding DD imagerel $LN11+200
	DD	imagerel $LN11+237
	DD	imagerel $chain$4$_PyCodec_LookupTextEncoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_PyCodec_LookupTextEncoding DD 021H
	DD	imagerel $LN11+156
	DD	imagerel $LN11+171
	DD	imagerel $chain$2$_PyCodec_LookupTextEncoding
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_PyCodec_LookupTextEncoding DD 020521H
	DD	063405H
	DD	imagerel $LN11+156
	DD	imagerel $LN11+171
	DD	imagerel $chain$2$_PyCodec_LookupTextEncoding
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_PyCodec_LookupTextEncoding DD 020021H
	DD	075400H
	DD	imagerel $LN11
	DD	imagerel $LN11+59
	DD	imagerel $unwind$_PyCodec_LookupTextEncoding
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_PyCodec_LookupTextEncoding DD 020521H
	DD	075405H
	DD	imagerel $LN11
	DD	imagerel $LN11+59
	DD	imagerel $unwind$_PyCodec_LookupTextEncoding
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_LookupTextEncoding DD 061001H
	DD	097410H
	DD	086410H
	DD	0c00c3210H
xdata	ENDS
;	COMDAT ??_C@_0ED@DJOHLNAJ@?8?$CF?4400s?8?5is?5not?5a?5text?5encoding?$DL@
CONST	SEGMENT
??_C@_0ED@DJOHLNAJ@?8?$CF?4400s?8?5is?5not?5a?5text?5encoding?$DL@ DB ''''
	DB	'%.400s'' is not a text encoding; use %s to handle arbitrary c'
	DB	'odecs', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodec_LookupTextEncoding
_TEXT	SEGMENT
encoding$ = 48
alternate_command$ = 56
_PyCodec_LookupTextEncoding PROC			; COMDAT

; 480  : {

$LN11:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00010	4c 8b e2	 mov	 r12, rdx
  00013	48 8b f1	 mov	 rsi, rcx

; 481  :     _Py_IDENTIFIER(_is_text_encoding);
; 482  :     PyObject *codec;
; 483  :     PyObject *attr;
; 484  :     int is_text_codec;
; 485  : 
; 486  :     codec = _PyCodec_Lookup(encoding);

  00016	e8 00 00 00 00	 call	 _PyCodec_Lookup
  0001b	48 8b f8	 mov	 rdi, rax

; 487  :     if (codec == NULL)

  0001e	48 85 c0	 test	 rax, rax
  00021	75 11		 jne	 SHORT $LN7@PyCodec_Lo@2

; 519  : }

  00023	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00028	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	41 5c		 pop	 r12
  00033	c3		 ret	 0
$LN7@PyCodec_Lo@2:

; 488  :         return NULL;
; 489  : 
; 490  :     /* Backwards compatibility: assume any raw tuple describes a text
; 491  :      * encoding, and the same for anything lacking the private
; 492  :      * attribute.
; 493  :      */
; 494  :     if (!PyTuple_CheckExact(codec)) {

  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  0003b	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00040	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  00044	74 3d		 je	 SHORT $LN1@PyCodec_Lo@2

; 495  :         attr = _PyObject_GetAttrId(codec, &PyId__is_text_encoding);

  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004c	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00055	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__is_text_encoding@?1??_PyCodec_LookupTextEncoding@@9@9
  0005a	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0005e	48 8b cf	 mov	 rcx, rdi
  00061	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00066	48 8b e8	 mov	 rbp, rax

; 496  :         if (attr == NULL) {

  00069	48 85 c0	 test	 rax, rax
  0006c	75 3a		 jne	 SHORT $LN5@PyCodec_Lo@2

; 497  :             if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00075	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0007a	85 c0		 test	 eax, eax
  0007c	74 1e		 je	 SHORT $LN4@PyCodec_Lo@2

; 498  :                 PyErr_Clear();

  0007e	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@PyCodec_Lo@2:

; 513  :             }
; 514  :         }
; 515  :     }
; 516  : 
; 517  :     /* This appears to be a valid text encoding */
; 518  :     return codec;

  00083	48 8b c7	 mov	 rax, rdi
$LN10@PyCodec_Lo@2:
  00086	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 519  : }

  0008b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00090	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	41 5c		 pop	 r12
  0009b	c3		 ret	 0
$LN4@PyCodec_Lo@2:

; 499  :             } else {
; 500  :                 Py_DECREF(codec);

  0009c	48 8b cf	 mov	 rcx, rdi
  0009f	e8 00 00 00 00	 call	 _Py_DecRef

; 501  :                 return NULL;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb de		 jmp	 SHORT $LN10@PyCodec_Lo@2
$LN5@PyCodec_Lo@2:

; 502  :             }
; 503  :         } else {
; 504  :             is_text_codec = PyObject_IsTrue(attr);

  000a8	48 8b c8	 mov	 rcx, rax
  000ab	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  000b0	e8 00 00 00 00	 call	 PyObject_IsTrue

; 505  :             Py_DECREF(attr);

  000b5	48 8b cd	 mov	 rcx, rbp
  000b8	8b d8		 mov	 ebx, eax
  000ba	e8 00 00 00 00	 call	 _Py_DecRef

; 506  :             if (!is_text_codec) {

  000bf	85 db		 test	 ebx, ebx
  000c1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c6	75 bb		 jne	 SHORT $LN1@PyCodec_Lo@2

; 507  :                 Py_DECREF(codec);

  000c8	48 8b cf	 mov	 rcx, rdi
  000cb	e8 00 00 00 00	 call	 _Py_DecRef

; 508  :                 PyErr_Format(PyExc_LookupError,
; 509  :                              "'%.400s' is not a text encoding; "
; 510  :                              "use %s to handle arbitrary codecs",
; 511  :                              encoding, alternate_command);

  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@DJOHLNAJ@?8?$CF?4400s?8?5is?5not?5a?5text?5encoding?$DL@
  000de	4d 8b cc	 mov	 r9, r12
  000e1	4c 8b c6	 mov	 r8, rsi
  000e4	e8 00 00 00 00	 call	 PyErr_Format

; 512  :                 return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	eb 99		 jmp	 SHORT $LN10@PyCodec_Lo@2
_PyCodec_LookupTextEncoding ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$codec_getitem_checked DD imagerel codec_getitem_checked
	DD	imagerel codec_getitem_checked+123
	DD	imagerel $unwind$codec_getitem_checked
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$codec_getitem_checked DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
xdata	ENDS
;	COMDAT codec_getitem_checked
_TEXT	SEGMENT
encoding$ = 64
alternate_command$ = 72
index$ = 80
codec_getitem_checked PROC				; COMDAT

; 526  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	49 63 d8	 movsxd	 rbx, r8d

; 527  :     PyObject *codec;
; 528  :     PyObject *v;
; 529  : 
; 530  :     codec = _PyCodec_LookupTextEncoding(encoding, alternate_command);

  0000d	e8 00 00 00 00	 call	 _PyCodec_LookupTextEncoding
  00012	48 8b f8	 mov	 rdi, rax

; 531  :     if (codec == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@codec_geti@3

; 538  : }

  0001a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@codec_geti@3:

; 532  :         return NULL;
; 533  : 
; 534  :     v = PyTuple_GET_ITEM(codec, index);

  00025	48 8b 5c d8 70	 mov	 rbx, QWORD PTR [rax+rbx*8+112]

; 535  :     Py_INCREF(v);

  0002a	e8 00 00 00 00	 call	 _Py_PXCTX
  0002f	85 c0		 test	 eax, eax
  00031	75 32		 jne	 SHORT $LN5@codec_geti@3
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00041	4c 8b cb	 mov	 r9, rbx
  00044	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0004a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00052	e8 00 00 00 00	 call	 _PyParallel_Guard
  00057	85 c0		 test	 eax, eax
  00059	75 06		 jne	 SHORT $LN4@codec_geti@3
  0005b	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0005f	74 04		 je	 SHORT $LN5@codec_geti@3
$LN4@codec_geti@3:
  00061	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@codec_geti@3:

; 536  :     Py_DECREF(codec);

  00065	48 8b cf	 mov	 rcx, rdi
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 537  :     return v;

  0006d	48 8b c3	 mov	 rax, rbx

; 538  : }

  00070	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
codec_getitem_checked ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@HIHFBICN@codecs?4encode?$CI?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0BA@HIHFBICN@codecs?4encode?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@HIHFBICN@codecs?4encode?$CI?$CJ?$AA@ DB 'codecs.encode()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodec_TextEncoder
_TEXT	SEGMENT
encoding$ = 8
_PyCodec_TextEncoder PROC				; COMDAT

; 542  :     return codec_getitem_checked(encoding, "codecs.encode()", 0);

  00000	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HIHFBICN@codecs?4encode?$CI?$CJ?$AA@
  00007	45 33 c0	 xor	 r8d, r8d

; 543  : }

  0000a	e9 00 00 00 00	 jmp	 codec_getitem_checked
_PyCodec_TextEncoder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@DCGEBADI@codecs?4decode?$CI?$CJ?$AA@	; `string'
;	COMDAT ??_C@_0BA@DCGEBADI@codecs?4decode?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@DCGEBADI@codecs?4decode?$CI?$CJ?$AA@ DB 'codecs.decode()', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _PyCodec_TextDecoder
_TEXT	SEGMENT
encoding$ = 8
_PyCodec_TextDecoder PROC				; COMDAT

; 547  :     return codec_getitem_checked(encoding, "codecs.decode()", 1);

  00000	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DCGEBADI@codecs?4decode?$CI?$CJ?$AA@
  00007	41 b8 01 00 00
	00		 mov	 r8d, 1

; 548  : }

  0000d	e9 00 00 00 00	 jmp	 codec_getitem_checked
_PyCodec_TextDecoder ENDP
_TEXT	ENDS
PUBLIC	_PyCodec_EncodeText
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCodec_EncodeText DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$_PyCodec_EncodeText
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_EncodeText DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyCodec_EncodeText
_TEXT	SEGMENT
object$ = 48
encoding$ = 56
errors$ = 64
_PyCodec_EncodeText PROC				; COMDAT

; 553  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 554  :     PyObject *encoder;
; 555  : 
; 556  :     encoder = _PyCodec_TextEncoder(encoding);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	49 8b d8	 mov	 rbx, r8
  00013	e8 00 00 00 00	 call	 _PyCodec_TextEncoder

; 557  :     if (encoder == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@PyCodec_En@3

; 561  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@PyCodec_En@3:

; 558  :         return NULL;
; 559  : 
; 560  :     return _PyCodec_EncodeInternal(object, encoder, encoding, errors);

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b cf	 mov	 rcx, rdi

; 561  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	e9 00 00 00 00	 jmp	 _PyCodec_EncodeInternal
_PyCodec_EncodeText ENDP
_TEXT	ENDS
PUBLIC	_PyCodec_DecodeText
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCodec_DecodeText DD imagerel $LN4
	DD	imagerel $LN4+64
	DD	imagerel $unwind$_PyCodec_DecodeText
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCodec_DecodeText DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _PyCodec_DecodeText
_TEXT	SEGMENT
object$ = 48
encoding$ = 56
errors$ = 64
_PyCodec_DecodeText PROC				; COMDAT

; 566  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 567  :     PyObject *decoder;
; 568  : 
; 569  :     decoder = _PyCodec_TextDecoder(encoding);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	49 8b d8	 mov	 rbx, r8
  00013	e8 00 00 00 00	 call	 _PyCodec_TextDecoder

; 570  :     if (decoder == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0b		 jne	 SHORT $LN1@PyCodec_De@3

; 574  : }

  0001d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@PyCodec_De@3:

; 571  :         return NULL;
; 572  : 
; 573  :     return _PyCodec_DecodeInternal(object, decoder, encoding, errors);

  00028	4c 8b c3	 mov	 r8, rbx
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b cf	 mov	 rcx, rdi

; 574  : }

  00031	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	e9 00 00 00 00	 jmp	 _PyCodec_DecodeInternal
_PyCodec_DecodeText ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@JPNGEIEM@unknown?5error?5handler?5name?5?8?$CF?440@ ; `string'
PUBLIC	PyCodec_LookupError
EXTRN	PyDict_GetItemString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyCodec_LookupError DD imagerel $LN13
	DD	imagerel $LN13+73
	DD	imagerel $unwind$PyCodec_LookupError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyCodec_LookupError DD imagerel $LN13+73
	DD	imagerel $LN13+149
	DD	imagerel $chain$0$PyCodec_LookupError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyCodec_LookupError DD imagerel $LN13+149
	DD	imagerel $LN13+227
	DD	imagerel $chain$2$PyCodec_LookupError
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyCodec_LookupError DD 020021H
	DD	087400H
	DD	imagerel $LN13
	DD	imagerel $LN13+73
	DD	imagerel $unwind$PyCodec_LookupError
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyCodec_LookupError DD 020521H
	DD	087405H
	DD	imagerel $LN13
	DD	imagerel $LN13+73
	DD	imagerel $unwind$PyCodec_LookupError
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCodec_LookupError DD 040a01H
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0CE@JPNGEIEM@unknown?5error?5handler?5name?5?8?$CF?440@
CONST	SEGMENT
??_C@_0CE@JPNGEIEM@unknown?5error?5handler?5name?5?8?$CF?440@ DB 'unknown'
	DB	' error handler name ''%.400s''', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\python\codecs.c
CONST	ENDS
;	COMDAT PyCodec_LookupError
_TEXT	SEGMENT
name$ = 64
PyCodec_LookupError PROC				; COMDAT

; 599  : {

$LN13:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 600  :     PyObject *handler = NULL;
; 601  : 
; 602  :     PyInterpreterState *interp = PyThreadState_GET()->interp;

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 07		 je	 SHORT $LN7@PyCodec_Lo@3
  00016	e8 00 00 00 00	 call	 _PyParallel_GetThreadState
  0001b	eb 07		 jmp	 SHORT $LN8@PyCodec_Lo@3
$LN7@PyCodec_Lo@3:
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
$LN8@PyCodec_Lo@3:
  00024	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]

; 603  :     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())

  00028	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  0002d	75 16		 jne	 SHORT $LN4@PyCodec_Lo@3
  0002f	e8 00 00 00 00	 call	 _PyCodecRegistry_Init
  00034	85 c0		 test	 eax, eax
  00036	74 0d		 je	 SHORT $LN4@PyCodec_Lo@3

; 604  :         return NULL;

  00038	33 c0		 xor	 eax, eax

; 614  : }

  0003a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5e		 pop	 rsi
  00044	c3		 ret	 0
$LN4@PyCodec_Lo@3:

; 605  : 
; 606  :     if (name==NULL)
; 607  :         name = "strict";
; 608  :     handler = PyDict_GetItemString(interp->codec_error_registry, (char *)name);

  00045	48 8b 4b 48	 mov	 rcx, QWORD PTR [rbx+72]
  00049	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00055	48 85 f6	 test	 rsi, rsi
  00058	48 0f 45 fe	 cmovne	 rdi, rsi
  0005c	48 8b d7	 mov	 rdx, rdi
  0005f	e8 00 00 00 00	 call	 PyDict_GetItemString
  00064	48 8b d8	 mov	 rbx, rax

; 609  :     if (!handler)

  00067	48 85 c0	 test	 rax, rax
  0006a	75 29		 jne	 SHORT $LN2@PyCodec_Lo@3

; 610  :         PyErr_Format(PyExc_LookupError, "unknown error handler name '%.400s'", name);

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_LookupError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@JPNGEIEM@unknown?5error?5handler?5name?5?8?$CF?440@
  0007a	4c 8b c7	 mov	 r8, rdi
  0007d	e8 00 00 00 00	 call	 PyErr_Format
  00082	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 613  :     return handler;

  00087	48 8b c3	 mov	 rax, rbx

; 614  : }

  0008a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00093	5e		 pop	 rsi
  00094	c3		 ret	 0
$LN2@PyCodec_Lo@3:

; 611  :     else
; 612  :         Py_INCREF(handler);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	75 32		 jne	 SHORT $LN10@PyCodec_Lo@3
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ac	4c 8b cb	 mov	 r9, rbx
  000af	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c2	85 c0		 test	 eax, eax
  000c4	75 06		 jne	 SHORT $LN9@PyCodec_Lo@3
  000c6	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000ca	74 04		 je	 SHORT $LN10@PyCodec_Lo@3
$LN9@PyCodec_Lo@3:
  000cc	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@PyCodec_Lo@3:

; 613  :     return handler;

  000d0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000d5	48 8b c3	 mov	 rax, rbx

; 614  : }

  000d8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5e		 pop	 rsi
  000e2	c3		 ret	 0
PyCodec_LookupError ENDP
_TEXT	ENDS
END
