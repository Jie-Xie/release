; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@		; `string'
PUBLIC	??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@ ; `string'
PUBLIC	??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@ ; `string'
PUBLIC	??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@ ; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@		; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_08BPEKIGCI@readinto?$AA@			; `string'
PUBLIC	??_C@_07JCDFOMC@readall?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_06MNHBHLPO@opener?$AA@			; `string'
PUBLIC	??_C@_07IOEMJIMP@closefd?$AA@			; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	PyFileIO_Type
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@
CONST	SEGMENT
??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@ DB '_io.FileIO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@
CONST	SEGMENT
??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@ DB 'String giving'
	DB	' the file mode', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@
CONST	SEGMENT
??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@ DB 'True if the'
	DB	' file descriptor will be closed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@
CONST	SEGMENT
??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@ DB 'True if the f'
	DB	'ile is closed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
CONST	SEGMENT
??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@ DB '_dealloc_warn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEKIGCI@readinto?$AA@
CONST	SEGMENT
??_C@_08BPEKIGCI@readinto?$AA@ DB 'readinto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCDFOMC@readall?$AA@
CONST	SEGMENT
??_C@_07JCDFOMC@readall?$AA@ DB 'readall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??fileio_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `fileio_init'::`2'::kwlist
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_07IOEMJIMP@closefd?$AA@
	DQ	FLAT:??_C@_06MNHBHLPO@opener?$AA@
	DQ	0000000000000000H
tell_doc DB	'tell() -> int.  Current file position', 00H
	ORG $+2
fileio_doc DB	'file(name: str[, mode: str][, opener: None]) -> file IO '
	DB	'object', 0aH, 0aH, 'Open a file.  The mode can be ''r'', ''w'''
	DB	', ''x'' or ''a'' for reading (default),', 0aH, 'writing, excl'
	DB	'usive creation or appending.  The file will be created if it', 0aH
	DB	'doesn''t exist when opened for writing or appending; it will '
	DB	'be truncated', 0aH, 'when opened for writing.  A `FileExistsE'
	DB	'rror` will be raised if it already', 0aH, 'exists when opened'
	DB	' for creating. Opening a file for creating implies', 0aH, 'wr'
	DB	'iting so this mode behaves in a similar way to ''w''.Add a '''
	DB	'+'' to the mode', 0aH, 'to allow simultaneous reading and wri'
	DB	'ting. A custom opener can be used by', 0aH, 'passing a callab'
	DB	'le as *opener*. The underlying file descriptor for the file', 0aH
	DB	'object is then obtained by calling opener with (*name*, *flag'
	DB	's*).', 0aH, '*opener* must return an open file descriptor (pa'
	DB	'ssing os.open as *opener*', 0aH, 'results in functionality si'
	DB	'milar to passing None).', 00H
	ORG $+3
read_doc DB	'read(size: int) -> bytes.  read at most size bytes, retu'
	DB	'rned as bytes.', 0aH, 0aH, 'Only makes one system call, so le'
	DB	'ss data may be returned than requested', 0aH, 'In non-blockin'
	DB	'g mode, returns None if no data is available.', 0aH, 'On end-'
	DB	'of-file, returns ''''.', 00H
	ORG $+8
readall_doc DB	'readall() -> bytes.  read all data from the file, return'
	DB	'ed as bytes.', 0aH, 0aH, 'In non-blocking mode, returns as mu'
	DB	'ch as is immediately available,', 0aH, 'or None if no data is'
	DB	' available.  On end-of-file, returns ''''.', 00H
	ORG $+9
write_doc DB	'write(b: bytes) -> int.  Write bytes b to file, return n'
	DB	'umber written.', 0aH, 0aH, 'Only makes one system call, so no'
	DB	't all of the data may be written.', 0aH, 'The number of bytes'
	DB	' actually written is returned.', 00H
	ORG $+3
fileno_doc DB	'fileno() -> int. "file descriptor".', 0aH, 0aH, 'This is'
	DB	' needed for lower-level file interfaces, such the fcntl modul'
	DB	'e.', 00H
	ORG $+4
seek_doc DB	'seek(offset: int[, whence: int]) -> None.  Move to new f'
	DB	'ile position.', 0aH, 0aH, 'Argument offset is a byte count.  '
	DB	'Optional argument whence defaults to', 0aH, '0 (offset from s'
	DB	'tart of file, offset should be >= 0); other values are 1', 0aH
	DB	'(move relative to current position, positive or negative), an'
	DB	'd 2 (move', 0aH, 'relative to end of file, usually negative, '
	DB	'although many platforms allow', 0aH, 'seeking beyond the end '
	DB	'of a file).', 0aH, 'Note that not all file objects are seekab'
	DB	'le.', 00H
	ORG $+9
truncate_doc DB	'truncate([size: int]) -> None.  Truncate the file to at '
	DB	'most size bytes.', 0aH, 0aH, 'Size defaults to the current fi'
	DB	'le position, as returned by tell().The current file position '
	DB	'is changed to the value of size.', 00H
	ORG $+1
readinto_doc DB	'readinto() -> Same as RawIOBase.readinto().', 00H
	ORG $+12
close_doc DB	'close() -> None.  Close the file.', 0aH, 0aH, 'A closed '
	DB	'file cannot be used for further I/O operations.  close() may '
	DB	'be', 0aH, 'called more than once without error.  Changes the '
	DB	'fileno to -1.', 00H
	ORG $+4
isatty_doc DB	'isatty() -> bool.  True if the file is connected to a tt'
	DB	'y device.', 00H
	ORG $+6
seekable_doc DB	'seekable() -> bool.  True if file supports random-access'
	DB	'.', 00H
	ORG $+6
readable_doc DB	'readable() -> bool.  True if file was opened in a read m'
	DB	'ode.', 00H
	ORG $+3
writable_doc DB	'writable() -> bool.  True if file was opened in a write '
	DB	'mode.', 00H
	ORG $+10
fileio_methods DQ FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:fileio_read
	DD	01H
	ORG $+4
	DQ	FLAT:read_doc
	DQ	FLAT:??_C@_07JCDFOMC@readall?$AA@
	DQ	FLAT:fileio_readall
	DD	04H
	ORG $+4
	DQ	FLAT:readall_doc
	DQ	FLAT:??_C@_08BPEKIGCI@readinto?$AA@
	DQ	FLAT:fileio_readinto
	DD	01H
	ORG $+4
	DQ	FLAT:readinto_doc
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:fileio_write
	DD	01H
	ORG $+4
	DQ	FLAT:write_doc
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:fileio_seek
	DD	01H
	ORG $+4
	DQ	FLAT:seek_doc
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:fileio_tell
	DD	01H
	ORG $+4
	DQ	FLAT:tell_doc
	DQ	FLAT:??_C@_08MABILMFG@truncate?$AA@
	DQ	FLAT:fileio_truncate
	DD	01H
	ORG $+4
	DQ	FLAT:truncate_doc
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:fileio_close
	DD	04H
	ORG $+4
	DQ	FLAT:close_doc
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	FLAT:fileio_seekable
	DD	04H
	ORG $+4
	DQ	FLAT:seekable_doc
	DQ	FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	FLAT:fileio_readable
	DD	04H
	ORG $+4
	DQ	FLAT:readable_doc
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	FLAT:fileio_writable
	DD	04H
	ORG $+4
	DQ	FLAT:writable_doc
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	FLAT:fileio_fileno
	DD	04H
	ORG $+4
	DQ	FLAT:fileno_doc
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:fileio_isatty
	DD	04H
	ORG $+4
	DQ	FLAT:isatty_doc
	DQ	FLAT:??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
	DQ	FLAT:fileio_dealloc_warn
	DD	08H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	FLAT:fileio_getstate
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
fileio_getsetlist DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:get_closed
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07IOEMJIMP@closefd?$AA@
	DQ	FLAT:get_closefd
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@
	ORG $+8
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:get_mode
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyFileIO_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:fileio_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fileio_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:fileio_doc
	DQ	FLAT:fileio_traverse
	DQ	FLAT:fileio_clear
	DQ	0000000000000000H
	DQ	0000000000000068H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fileio_methods
	DQ	0000000000000000H
	DQ	FLAT:fileio_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000070H
	DQ	FLAT:fileio_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:fileio_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_DATA	ENDS
;	COMDAT ??_C@_06MNHBHLPO@opener?$AA@
CONST	SEGMENT
??_C@_06MNHBHLPO@opener?$AA@ DB 'opener', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOEMJIMP@closefd?$AA@
CONST	SEGMENT
??_C@_07IOEMJIMP@closefd?$AA@ DB 'closefd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_name@?1??fileio_repr@@9@9 DQ 0000000000000000H	; `fileio_repr'::`2'::PyId_name
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	0000000000000000H
?PyId_close@?1??fileio_close@@9@9 DQ 0000000000000000H	; `fileio_close'::`2'::PyId_close
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
EXTRN	__imp__fstat64i32:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 8
_Stat$ = 16
fstat	PROC						; COMDAT

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);
; 55   : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__fstat64i32
fstat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	_PyFileIO_closed
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
;	COMDAT _PyFileIO_closed
_TEXT	SEGMENT
self$ = 8
_PyFileIO_closed PROC					; COMDAT

; 67   :     return ((fileio *)self)->fd < 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00005	0f 9c c0	 setl	 al

; 68   : }

  00008	c3		 ret	 0
_PyFileIO_closed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_Warning:QWORD
EXTRN	PyErr_WarnFormat:PROC
EXTRN	PyExc_ResourceWarning:QWORD
EXTRN	PyErr_Fetch:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fileio_dealloc_warn DD imagerel fileio_dealloc_warn
	DD	imagerel fileio_dealloc_warn+227
	DD	imagerel $unwind$fileio_dealloc_warn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_dealloc_warn DD 040a01H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@ DB 'unclosed file %R', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT fileio_dealloc_warn
_TEXT	SEGMENT
tb$63701 = 64
self$ = 64
source$ = 72
val$63700 = 80
exc$63699 = 88
fileio_dealloc_warn PROC				; COMDAT

; 75   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 76   :     if (self->fd >= 0 && self->closefd) {

  0000a	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	7c 65		 jl	 SHORT $LN3@fileio_dea
  00016	f6 41 64 40	 test	 BYTE PTR [rcx+100], 64	; 00000040H
  0001a	74 5f		 je	 SHORT $LN3@fileio_dea

; 77   :         PyObject *exc, *val, *tb;
; 78   :         PyErr_Fetch(&exc, &val, &tb);

  0001c	4c 8d 44 24 40	 lea	 r8, QWORD PTR tb$63701[rsp]
  00021	48 8d 54 24 50	 lea	 rdx, QWORD PTR val$63700[rsp]
  00026	48 8d 4c 24 58	 lea	 rcx, QWORD PTR exc$63699[rsp]
  0002b	e8 00 00 00 00	 call	 PyErr_Fetch

; 79   :         if (PyErr_WarnFormat(PyExc_ResourceWarning, 1,
; 80   :                              "unclosed file %R", source)) {

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ResourceWarning
  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@
  0003e	4c 8b cf	 mov	 r9, rdi
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	e8 00 00 00 00	 call	 PyErr_WarnFormat
  0004b	85 c0		 test	 eax, eax
  0004d	74 18		 je	 SHORT $LN1@fileio_dea

; 81   :             /* Spurious errors can appear at shutdown */
; 82   :             if (PyErr_ExceptionMatches(PyExc_Warning))

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_Warning
  00056	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0005b	85 c0		 test	 eax, eax
  0005d	74 08		 je	 SHORT $LN1@fileio_dea

; 83   :                 PyErr_WriteUnraisable((PyObject *) self);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 PyErr_WriteUnraisable
$LN1@fileio_dea:

; 84   :         }
; 85   :         PyErr_Restore(exc, val, tb);

  00067	4c 8b 44 24 40	 mov	 r8, QWORD PTR tb$63701[rsp]
  0006c	48 8b 54 24 50	 mov	 rdx, QWORD PTR val$63700[rsp]
  00071	48 8b 4c 24 58	 mov	 rcx, QWORD PTR exc$63699[rsp]
  00076	e8 00 00 00 00	 call	 PyErr_Restore
$LN3@fileio_dea:

; 86   :     }
; 87   :     Py_RETURN_NONE;

  0007b	e8 00 00 00 00	 call	 _Py_PXCTX
  00080	85 c0		 test	 eax, eax
  00082	75 4d		 jne	 SHORT $LN10@fileio_dea
  00084	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00099	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009f	4c 8b cb	 mov	 r9, rbx
  000a2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000aa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000af	85 c0		 test	 eax, eax
  000b1	75 09		 jne	 SHORT $LN6@fileio_dea
  000b3	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  000ba	74 07		 je	 SHORT $LN12@fileio_dea
$LN6@fileio_dea:
  000bc	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN12@fileio_dea:
  000c3	48 8b c3	 mov	 rax, rbx

; 88   : }

  000c6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
$LN10@fileio_dea:

; 86   :     }
; 87   :     Py_RETURN_NONE;

  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 88   : }

  000d8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5f		 pop	 rdi
  000e2	c3		 ret	 0
fileio_dealloc_warn ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_close:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$internal_close DD imagerel internal_close
	DD	imagerel internal_close+37
	DD	imagerel $unwind$internal_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$internal_close DD imagerel internal_close+37
	DD	imagerel internal_close+89
	DD	imagerel $chain$0$internal_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$internal_close DD imagerel internal_close+89
	DD	imagerel internal_close+144
	DD	imagerel $chain$1$internal_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$internal_close DD 021H
	DD	imagerel internal_close
	DD	imagerel internal_close+37
	DD	imagerel $unwind$internal_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$internal_close DD 020521H
	DD	066405H
	DD	imagerel internal_close
	DD	imagerel internal_close+37
	DD	imagerel $unwind$internal_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_close DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT internal_close
_TEXT	SEGMENT
self$ = 48
internal_close PROC					; COMDAT

; 98   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 99   :     int err = 0;
; 100  :     int save_errno = 0;
; 101  :     if (self->fd >= 0) {

  0000a	8b 79 60	 mov	 edi, DWORD PTR [rcx+96]
  0000d	33 db		 xor	 ebx, ebx
  0000f	85 ff		 test	 edi, edi
  00011	78 46		 js	 SHORT $LN1@internal_c

; 102  :         int fd = self->fd;
; 103  :         self->fd = -1;

  00013	c7 41 60 ff ff
	ff ff		 mov	 DWORD PTR [rcx+96], -1

; 104  :         /* fd is accessible and someone else may have closed it */
; 105  :         if (_PyVerify_fd(fd)) {

  0001a	8b cf		 mov	 ecx, edi
  0001c	e8 00 00 00 00	 call	 _PyVerify_fd
  00021	85 c0		 test	 eax, eax
  00023	74 41		 je	 SHORT $LN4@internal_c

; 106  :             Py_BEGIN_ALLOW_THREADS

  00025	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002a	e8 00 00 00 00	 call	 PyEval_SaveThread

; 107  :             err = close(fd);

  0002f	8b cf		 mov	 ecx, edi
  00031	48 8b f0	 mov	 rsi, rax
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  0003a	8b f8		 mov	 edi, eax

; 108  :             if (err < 0)

  0003c	85 c0		 test	 eax, eax
  0003e	79 08		 jns	 SHORT $LN3@internal_c

; 109  :                 save_errno = errno;

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00046	8b 18		 mov	 ebx, DWORD PTR [rax]
$LN3@internal_c:

; 110  :             Py_END_ALLOW_THREADS

  00048	48 8b ce	 mov	 rcx, rsi
  0004b	e8 00 00 00 00	 call	 PyEval_RestoreThread
  00050	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 113  :             err = -1;
; 114  :         }
; 115  :     }
; 116  :     if (err < 0) {

  00055	85 ff		 test	 edi, edi
  00057	78 15		 js	 SHORT $LN8@internal_c
$LN1@internal_c:

; 119  :         return -1;
; 120  :     }
; 121  :     return 0;

  00059	33 c0		 xor	 eax, eax

; 122  : }

  0005b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN4@internal_c:

; 111  :         } else {
; 112  :             save_errno = errno;

  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006c	8b 18		 mov	 ebx, DWORD PTR [rax]
$LN8@internal_c:

; 117  :         errno = save_errno;

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00074	89 18		 mov	 DWORD PTR [rax], ebx

; 118  :         PyErr_SetFromErrno(PyExc_IOError);

  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0007d	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 122  : }

  00082	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00087	83 c8 ff	 or	 eax, -1
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
internal_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	PyRawIOBase_Type:BYTE
EXTRN	PyErr_Clear:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fileio_close DD imagerel fileio_close
	DD	imagerel fileio_close+105
	DD	imagerel $unwind$fileio_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_close DD imagerel fileio_close+105
	DD	imagerel fileio_close+177
	DD	imagerel $chain$0$fileio_close
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fileio_close DD imagerel fileio_close+177
	DD	imagerel fileio_close+236
	DD	imagerel $chain$1$fileio_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fileio_close DD 021H
	DD	imagerel fileio_close
	DD	imagerel fileio_close+105
	DD	imagerel $unwind$fileio_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_close DD 020521H
	DD	083405H
	DD	imagerel fileio_close
	DD	imagerel fileio_close+105
	DD	imagerel $unwind$fileio_close
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_close DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT fileio_close
_TEXT	SEGMENT
self$ = 64
fileio_close PROC					; COMDAT

; 126  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 127  :     _Py_IDENTIFIER(close);
; 128  :     if (!self->closefd) {

  00006	8b 41 64	 mov	 eax, DWORD PTR [rcx+100]
  00009	48 8b f9	 mov	 rdi, rcx
  0000c	a8 40		 test	 al, 64			; 00000040H
  0000e	75 59		 jne	 SHORT $LN5@fileio_clo

; 129  :         self->fd = -1;

  00010	c7 41 60 ff ff
	ff ff		 mov	 DWORD PTR [rcx+96], -1

; 130  :         Py_RETURN_NONE;

  00017	e8 00 00 00 00	 call	 _Py_PXCTX
  0001c	85 c0		 test	 eax, eax
  0001e	75 3c		 jne	 SHORT $LN9@fileio_clo
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00035	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0003b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00043	e8 00 00 00 00	 call	 _PyParallel_Guard
  00048	85 c0		 test	 eax, eax
  0004a	75 09		 jne	 SHORT $LN8@fileio_clo
  0004c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00053	74 07		 je	 SHORT $LN9@fileio_clo
$LN8@fileio_clo:
  00055	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN9@fileio_clo:
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 145  : }

  00063	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN5@fileio_clo:
  00069	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 131  :     }
; 132  :     if (self->deallocating) {

  0006e	84 c0		 test	 al, al
  00070	79 1c		 jns	 SHORT $LN2@fileio_clo

; 133  :         PyObject *r = fileio_dealloc_warn(self, (PyObject *) self);

  00072	48 8b d1	 mov	 rdx, rcx
  00075	e8 00 00 00 00	 call	 fileio_dealloc_warn

; 134  :         if (r)

  0007a	48 85 c0	 test	 rax, rax
  0007d	74 0a		 je	 SHORT $LN3@fileio_clo

; 135  :             Py_DECREF(r);

  0007f	48 8b c8	 mov	 rcx, rax
  00082	e8 00 00 00 00	 call	 _Py_DecRef

; 136  :         else

  00087	eb 05		 jmp	 SHORT $LN2@fileio_clo
$LN3@fileio_clo:

; 137  :             PyErr_Clear();

  00089	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@fileio_clo:

; 138  :     }
; 139  :     errno = internal_close(self);

  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00094	48 8b cf	 mov	 rcx, rdi
  00097	48 8b d8	 mov	 rbx, rax
  0009a	e8 00 00 00 00	 call	 internal_close
  0009f	89 03		 mov	 DWORD PTR [rbx], eax

; 140  :     if (errno < 0)

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ac	83 38 00	 cmp	 DWORD PTR [rax], 0
  000af	7d 08		 jge	 SHORT $LN1@fileio_clo

; 141  :         return NULL;

  000b1	33 c0		 xor	 eax, eax

; 145  : }

  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
$LN1@fileio_clo:

; 142  : 
; 143  :     return _PyObject_CallMethodId((PyObject*)&PyRawIOBase_Type,
; 144  :                                   &PyId_close, "O", self);

  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000bf	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000c8	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_close@?1??fileio_close@@9@9
  000cd	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyRawIOBase_Type
  000df	4c 8b cf	 mov	 r9, rdi

; 145  : }

  000e2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e6	5f		 pop	 rdi
  000e7	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId_SizeT
fileio_close ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_new DD imagerel fileio_new
	DD	imagerel fileio_new+48
	DD	imagerel $unwind$fileio_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_new DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fileio_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
fileio_new PROC						; COMDAT

; 149  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8b c1	 mov	 rax, rcx

; 150  :     fileio *self;
; 151  : 
; 152  :     assert(type != NULL && type->tp_alloc != NULL);
; 153  : 
; 154  :     self = (fileio *) type->tp_alloc(type, 0);

  00007	33 d2		 xor	 edx, edx
  00009	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 155  :     if (self != NULL) {

  0000f	48 85 c0	 test	 rax, rax
  00012	74 17		 je	 SHORT $LN4@fileio_new

; 156  :         self->fd = -1;
; 157  :         self->created = 0;
; 158  :         self->readable = 0;
; 159  :         self->writable = 0;
; 160  :         self->appending = 0;

  00014	83 60 64 f0	 and	 DWORD PTR [rax+100], -16 ; fffffff0H

; 161  :         self->seekable = -1;
; 162  :         self->closefd = 1;

  00018	83 48 64 70	 or	 DWORD PTR [rax+100], 112 ; 00000070H
  0001c	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1

; 163  :         self->weakreflist = NULL;

  00023	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN4@fileio_new:

; 164  :     }
; 165  : 
; 166  :     return (PyObject *) self;
; 167  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
fileio_new ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrnoWithFilenameObject:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$dircheck DD imagerel dircheck
	DD	imagerel dircheck+98
	DD	imagerel $unwind$dircheck
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dircheck DD 020601H
	DD	030029206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
xdata	ENDS
;	COMDAT dircheck
_TEXT	SEGMENT
buf$ = 32
self$ = 96
nameobj$ = 104
dircheck PROC						; COMDAT

; 175  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 176  : #if defined(HAVE_FSTAT) && defined(S_ISDIR) && defined(EISDIR)
; 177  :     struct stat buf;
; 178  :     if (self->fd < 0)

  00006	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00009	48 8b da	 mov	 rbx, rdx
  0000c	85 c9		 test	 ecx, ecx

; 179  :         return 0;

  0000e	78 4a		 js	 SHORT $LN1@dircheck

; 180  :     if (fstat(self->fd, &buf) == 0 && S_ISDIR(buf.st_mode)) {

  00010	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32
  0001b	85 c0		 test	 eax, eax
  0001d	75 3b		 jne	 SHORT $LN1@dircheck
  0001f	0f b7 44 24 26	 movzx	 eax, WORD PTR buf$[rsp+6]
  00024	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  00029	66 23 c1	 and	 ax, cx
  0002c	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00031	66 3b c1	 cmp	 ax, cx
  00034	75 24		 jne	 SHORT $LN1@dircheck

; 181  :         errno = EISDIR;

  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 182  :         PyErr_SetFromErrnoWithFilenameObject(PyExc_IOError, nameobj);

  0003c	48 8b d3	 mov	 rdx, rbx
  0003f	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0004c	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilenameObject

; 183  :         return -1;

  00051	83 c8 ff	 or	 eax, -1

; 187  : }

  00054	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
$LN1@dircheck:

; 184  :     }
; 185  : #endif
; 186  :     return 0;

  0005a	33 c0		 xor	 eax, eax

; 187  : }

  0005c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
dircheck ENDP
_TEXT	ENDS
PUBLIC	??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	_PyObject_CallFunction_SizeT:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp_strerror:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$check_fd DD imagerel check_fd
	DD	imagerel check_fd+239
	DD	imagerel $unwind$check_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_fd DD 020601H
	DD	03002b206H
xdata	ENDS
;	COMDAT ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
CONST	SEGMENT
??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@ DB '(is)', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT check_fd
_TEXT	SEGMENT
buf$ = 48
fd$ = 112
check_fd PROC						; COMDAT

; 191  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	8b d9		 mov	 ebx, ecx

; 192  : #if defined(HAVE_FSTAT)
; 193  :     struct stat buf;
; 194  :     if (!_PyVerify_fd(fd) || (fstat(fd, &buf) < 0 && errno == EBADF)) {

  00008	e8 00 00 00 00	 call	 _PyVerify_fd
  0000d	85 c0		 test	 eax, eax
  0000f	74 24		 je	 SHORT $LN5@check_fd
  00011	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00016	8b cb		 mov	 ecx, ebx
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32
  0001e	85 c0		 test	 eax, eax
  00020	79 0b		 jns	 SHORT $LN6@check_fd
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00028	83 38 09	 cmp	 DWORD PTR [rax], 9
  0002b	74 08		 je	 SHORT $LN5@check_fd
$LN6@check_fd:

; 202  :     }
; 203  : #endif
; 204  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 205  : }

  0002f	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN5@check_fd:

; 195  :         PyObject *exc;
; 196  :         char *msg = strerror(EBADF);

  00035	b9 09 00 00 00	 mov	 ecx, 9
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror

; 197  :         exc = PyObject_CallFunction(PyExc_OSError, "(is)",
; 198  :                                     EBADF, msg);

  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  0004e	4c 8b c8	 mov	 r9, rax
  00051	41 b8 09 00 00
	00		 mov	 r8d, 9
  00057	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT

; 199  :         PyErr_SetObject(PyExc_OSError, exc);

  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00063	48 8b d0	 mov	 rdx, rax
  00066	48 8b d8	 mov	 rbx, rax
  00069	e8 00 00 00 00	 call	 PyErr_SetObject

; 200  :         Py_XDECREF(exc);

  0006e	48 85 db	 test	 rbx, rbx
  00071	74 73		 je	 SHORT $LN3@check_fd
  00073	e8 00 00 00 00	 call	 _Py_PXCTX
  00078	85 c0		 test	 eax, eax
  0007a	75 6a		 jne	 SHORT $LN3@check_fd
  0007c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00080	a8 20		 test	 al, 32			; 00000020H
  00082	75 5a		 jne	 SHORT $LN15@check_fd
  00084	84 c0		 test	 al, al
  00086	78 56		 js	 SHORT $LN15@check_fd
  00088	a8 02		 test	 al, 2
  0008a	75 5a		 jne	 SHORT $LN3@check_fd
  0008c	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00090	75 54		 jne	 SHORT $LN3@check_fd
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000a0	4c 8b cb	 mov	 r9, rbx
  000a3	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000a9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b6	48 8b cb	 mov	 rcx, rbx
  000b9	85 c0		 test	 eax, eax
  000bb	74 0e		 je	 SHORT $LN20@check_fd
  000bd	e8 00 00 00 00	 call	 _Px_Dealloc

; 201  :         return -1;

  000c2	83 c8 ff	 or	 eax, -1

; 205  : }

  000c5	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000c9	5b		 pop	 rbx
  000ca	c3		 ret	 0

; 200  :         Py_XDECREF(exc);

$LN20@check_fd:
  000cb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000cf	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 201  :         return -1;

  000d5	83 c8 ff	 or	 eax, -1

; 205  : }

  000d8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000dc	5b		 pop	 rbx
  000dd	c3		 ret	 0

; 200  :         Py_XDECREF(exc);

$LN15@check_fd:
  000de	48 8b cb	 mov	 rcx, rbx
  000e1	e8 00 00 00 00	 call	 Px_DecRef
$LN3@check_fd:

; 201  :         return -1;

  000e6	83 c8 ff	 or	 eax, -1

; 205  : }

  000e9	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000ed	5b		 pop	 rbx
  000ee	c3		 ret	 0
check_fd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@KLLNOING@fileio_traverse?$AA@		; `string'
PUBLIC	??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@ ; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_traverse DD imagerel fileio_traverse
	DD	imagerel fileio_traverse+97
	DD	imagerel $unwind$fileio_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BA@KLLNOING@fileio_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@KLLNOING@fileio_traverse?$AA@ DB 'fileio_traverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
CONST	SEGMENT
??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@ DB '..\Modules\_io\'
	DB	'fileio.c', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
fileio_traverse PROC					; COMDAT

; 437  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 438  :     Py_VISIT(self->dict);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@fileio_tra
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KLLNOING@fileio_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@fileio_tra:
  0003d	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@fileio_tra
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@fileio_tra
$LN5@fileio_tra:

; 439  :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@fileio_tra:

; 440  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
fileio_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CALGGHPA@fileio_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fileio_clear DD imagerel fileio_clear
	DD	imagerel fileio_clear+63
	DD	imagerel $unwind$fileio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_clear DD imagerel fileio_clear+63
	DD	imagerel fileio_clear+172
	DD	imagerel $chain$0$fileio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fileio_clear DD imagerel fileio_clear+172
	DD	imagerel fileio_clear+195
	DD	imagerel $chain$2$fileio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fileio_clear DD imagerel fileio_clear+195
	DD	imagerel fileio_clear+208
	DD	imagerel $chain$4$fileio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$fileio_clear DD imagerel fileio_clear+208
	DD	imagerel fileio_clear+216
	DD	imagerel $chain$5$fileio_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$fileio_clear DD 021H
	DD	imagerel fileio_clear
	DD	imagerel fileio_clear+63
	DD	imagerel $unwind$fileio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fileio_clear DD 020021H
	DD	083400H
	DD	imagerel fileio_clear
	DD	imagerel fileio_clear+63
	DD	imagerel $unwind$fileio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fileio_clear DD 020021H
	DD	083400H
	DD	imagerel fileio_clear
	DD	imagerel fileio_clear+63
	DD	imagerel $unwind$fileio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_clear DD 020521H
	DD	083405H
	DD	imagerel fileio_clear
	DD	imagerel fileio_clear+63
	DD	imagerel $unwind$fileio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0N@CALGGHPA@fileio_clear?$AA@
CONST	SEGMENT
??_C@_0N@CALGGHPA@fileio_clear?$AA@ DB 'fileio_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT fileio_clear
_TEXT	SEGMENT
self$ = 64
fileio_clear PROC					; COMDAT

; 444  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 445  :     Py_CLEAR(self->dict);

  00006	4c 8b 49 70	 mov	 r9, QWORD PTR [rcx+112]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 ba 00 00
	00		 je	 $LN21@fileio_cle
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CALGGHPA@fileio_clear?$AA@
  00024	41 b8 bd 01 00
	00		 mov	 r8d, 445		; 000001bdH
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	0f 85 91 00 00
	00		 jne	 $LN21@fileio_cle
  0003f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00044	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  00048	48 c7 47 70 00
	00 00 00	 mov	 QWORD PTR [rdi+112], 0
  00050	e8 00 00 00 00	 call	 _Py_PXCTX
  00055	85 c0		 test	 eax, eax
  00057	75 72		 jne	 SHORT $LN22@fileio_cle
  00059	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0005d	a8 20		 test	 al, 32			; 00000020H
  0005f	75 62		 jne	 SHORT $LN11@fileio_cle
  00061	84 c0		 test	 al, al
  00063	78 5e		 js	 SHORT $LN11@fileio_cle
  00065	a8 02		 test	 al, 2
  00067	75 62		 jne	 SHORT $LN22@fileio_cle
  00069	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0006d	75 5c		 jne	 SHORT $LN22@fileio_cle
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0007d	4c 8b cb	 mov	 r9, rbx
  00080	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00086	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00093	48 8b cb	 mov	 rcx, rbx
  00096	85 c0		 test	 eax, eax
  00098	74 12		 je	 SHORT $LN16@fileio_cle
  0009a	e8 00 00 00 00	 call	 _Px_Dealloc
  0009f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 446  :     return 0;

  000a4	33 c0		 xor	 eax, eax

; 447  : }

  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0

; 445  :     Py_CLEAR(self->dict);

$LN16@fileio_cle:
  000ac	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000b6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 446  :     return 0;

  000bb	33 c0		 xor	 eax, eax

; 447  : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0

; 445  :     Py_CLEAR(self->dict);

$LN11@fileio_cle:
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 Px_DecRef
$LN22@fileio_cle:
  000cb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN21@fileio_cle:

; 446  :     return 0;

  000d0	33 c0		 xor	 eax, eax

; 447  : }

  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
fileio_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@		; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	_PyIOBase_finalize:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$fileio_dealloc DD imagerel fileio_dealloc
	DD	imagerel fileio_dealloc+218
	DD	imagerel $unwind$fileio_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_dealloc DD imagerel fileio_dealloc+218
	DD	imagerel fileio_dealloc+341
	DD	imagerel $chain$0$fileio_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fileio_dealloc DD imagerel fileio_dealloc+341
	DD	imagerel fileio_dealloc+360
	DD	imagerel $chain$1$fileio_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fileio_dealloc DD 021H
	DD	imagerel fileio_dealloc
	DD	imagerel fileio_dealloc+218
	DD	imagerel $unwind$fileio_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_dealloc DD 020521H
	DD	087405H
	DD	imagerel fileio_dealloc
	DD	imagerel fileio_dealloc+218
	DD	imagerel $unwind$fileio_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_dealloc DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
CONST	SEGMENT
??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@ DB 'fileio_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT fileio_dealloc
_TEXT	SEGMENT
self$ = 64
fileio_dealloc PROC					; COMDAT

; 451  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 452  :     self->deallocating = 1;

  00006	81 49 64 80 00
	00 00		 or	 DWORD PTR [rcx+100], 128 ; 00000080H
  0000d	48 8b d9	 mov	 rbx, rcx

; 453  :     if (_PyIOBase_finalize((PyObject *) self) < 0)

  00010	e8 00 00 00 00	 call	 _PyIOBase_finalize
  00015	85 c0		 test	 eax, eax
  00017	0f 88 45 01 00
	00		 js	 $LN11@fileio_dea@2

; 454  :         return;
; 455  :     _PyObject_GC_UNTRACK(self);

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  0002b	4c 8b cb	 mov	 r9, rbx
  0002e	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  00034	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	75 54		 jne	 SHORT $LN6@fileio_dea@2
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  00053	4c 8b cb	 mov	 r9, rbx
  00056	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  0005c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	74 04		 je	 SHORT $LN13@fileio_dea@2
  0006d	33 d2		 xor	 edx, edx
  0006f	eb 04		 jmp	 SHORT $LN14@fileio_dea@2
$LN13@fileio_dea@2:
  00071	48 8d 53 e8	 lea	 rdx, QWORD PTR [rbx-24]
$LN14@fileio_dea@2:
  00075	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00078	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  0007c	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00084	48 89 01	 mov	 QWORD PTR [rcx], rax
  00087	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0008a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0008e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00092	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN6@fileio_dea@2:

; 456  :     if (self->weakreflist != NULL)

  00099	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  0009e	74 08		 je	 SHORT $LN4@fileio_dea@2

; 457  :         PyObject_ClearWeakRefs((PyObject *) self);

  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN4@fileio_dea@2:

; 458  :     Py_CLEAR(self->dict);

  000a8	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  000ac	4d 85 c9	 test	 r9, r9
  000af	0f 84 a0 00 00
	00		 je	 $LN3@fileio_dea@2
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  000c3	41 b8 ca 01 00
	00		 mov	 r8d, 458		; 000001caH
  000c9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d6	85 c0		 test	 eax, eax
  000d8	75 7b		 jne	 SHORT $LN3@fileio_dea@2
  000da	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000df	48 8b 7b 70	 mov	 rdi, QWORD PTR [rbx+112]
  000e3	48 c7 43 70 00
	00 00 00	 mov	 QWORD PTR [rbx+112], 0
  000eb	e8 00 00 00 00	 call	 _Py_PXCTX
  000f0	85 c0		 test	 eax, eax
  000f2	75 5c		 jne	 SHORT $LN26@fileio_dea@2
  000f4	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000f8	a8 20		 test	 al, 32			; 00000020H
  000fa	75 4c		 jne	 SHORT $LN19@fileio_dea@2
  000fc	84 c0		 test	 al, al
  000fe	78 48		 js	 SHORT $LN19@fileio_dea@2
  00100	a8 02		 test	 al, 2
  00102	75 4c		 jne	 SHORT $LN26@fileio_dea@2
  00104	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00108	75 46		 jne	 SHORT $LN26@fileio_dea@2
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00118	4c 8b cf	 mov	 r9, rdi
  0011b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00121	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00129	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012e	48 8b cf	 mov	 rcx, rdi
  00131	85 c0		 test	 eax, eax
  00133	74 07		 je	 SHORT $LN24@fileio_dea@2
  00135	e8 00 00 00 00	 call	 _Px_Dealloc
  0013a	eb 14		 jmp	 SHORT $LN26@fileio_dea@2
$LN24@fileio_dea@2:
  0013c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00140	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00146	eb 08		 jmp	 SHORT $LN26@fileio_dea@2
$LN19@fileio_dea@2:
  00148	48 8b cf	 mov	 rcx, rdi
  0014b	e8 00 00 00 00	 call	 Px_DecRef
$LN26@fileio_dea@2:
  00150	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN3@fileio_dea@2:

; 459  :     Py_TYPE(self)->tp_free((PyObject *)self);

  00155	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00159	48 8b cb	 mov	 rcx, rbx
  0015c	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN11@fileio_dea@2:

; 460  : }

  00162	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00166	5b		 pop	 rbx
  00167	c3		 ret	 0
fileio_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$err_closed DD imagerel err_closed
	DD	imagerel err_closed+30
	DD	imagerel $unwind$err_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$err_closed DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@
CONST	SEGMENT
??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@ DB 'I/O operati'
	DB	'on on closed file', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT err_closed
_TEXT	SEGMENT
err_closed PROC						; COMDAT

; 464  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 465  :     PyErr_SetString(PyExc_ValueError, "I/O operation on closed file");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 466  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 467  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
err_closed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyModule_GetState:PROC
EXTRN	PyState_FindModule:PROC
EXTRN	_PyIO_Module:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$err_mode DD imagerel err_mode
	DD	imagerel err_mode+56
	DD	imagerel $unwind$err_mode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$err_mode DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@ DB 'File not open for'
	DB	' %s', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT err_mode
_TEXT	SEGMENT
action$ = 48
err_mode PROC						; COMDAT

; 471  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 472  :     PyErr_Format(IO_STATE->unsupported_operation,
; 473  :                  "File not open for %s", action);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyIO_Module
  00010	e8 00 00 00 00	 call	 PyState_FindModule
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@
  00024	4c 8b c3	 mov	 r8, rbx
  00027	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0002b	e8 00 00 00 00	 call	 PyErr_Format

; 474  :     return NULL;

  00030	33 c0		 xor	 eax, eax

; 475  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
err_mode ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT fileio_fileno
_TEXT	SEGMENT
self$ = 8
fileio_fileno PROC					; COMDAT

; 480  :     if (self->fd < 0)

  00000	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00003	85 c9		 test	 ecx, ecx
  00005	79 05		 jns	 SHORT $LN1@fileio_fil

; 481  :         return err_closed();
; 482  :     return PyLong_FromLong((long) self->fd);
; 483  : }

  00007	e9 00 00 00 00	 jmp	 err_closed
$LN1@fileio_fil:
  0000c	e9 00 00 00 00	 jmp	 PyLong_FromLong
fileio_fileno ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT fileio_readable
_TEXT	SEGMENT
self$ = 8
fileio_readable PROC					; COMDAT

; 488  :     if (self->fd < 0)

  00000	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00004	7d 05		 jge	 SHORT $LN1@fileio_rea

; 491  : }

  00006	e9 00 00 00 00	 jmp	 err_closed
$LN1@fileio_rea:

; 489  :         return err_closed();
; 490  :     return PyBool_FromLong((long) self->readable);

  0000b	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  0000e	d1 e9		 shr	 ecx, 1
  00010	83 e1 01	 and	 ecx, 1

; 491  : }

  00013	e9 00 00 00 00	 jmp	 PyBool_FromLong
fileio_readable ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fileio_writable
_TEXT	SEGMENT
self$ = 8
fileio_writable PROC					; COMDAT

; 496  :     if (self->fd < 0)

  00000	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00004	7d 05		 jge	 SHORT $LN1@fileio_wri

; 499  : }

  00006	e9 00 00 00 00	 jmp	 err_closed
$LN1@fileio_wri:

; 497  :         return err_closed();
; 498  :     return PyBool_FromLong((long) self->writable);

  0000b	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  0000e	c1 e9 02	 shr	 ecx, 2
  00011	83 e1 01	 and	 ecx, 1

; 499  : }

  00014	e9 00 00 00 00	 jmp	 PyBool_FromLong
fileio_writable ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DOGLJEBA@w?$CK?$AA@			; `string'
PUBLIC	??_C@_07CMOHHLII@reading?$AA@			; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyBuffer_Release:PROC
EXTRN	__imp_read:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_readinto DD imagerel fileio_readinto
	DD	imagerel fileio_readinto+287
	DD	imagerel $unwind$fileio_readinto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_readinto DD 066801H
	DD	0117468H
	DD	0103460H
	DD	06002d206H
xdata	ENDS
;	COMDAT ??_C@_02DOGLJEBA@w?$CK?$AA@
CONST	SEGMENT
??_C@_02DOGLJEBA@w?$CK?$AA@ DB 'w*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMOHHLII@reading?$AA@
CONST	SEGMENT
??_C@_07CMOHHLII@reading?$AA@ DB 'reading', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_readinto
_TEXT	SEGMENT
pbuf$ = 32
self$ = 128
args$ = 136
fileio_readinto PROC					; COMDAT

; 521  : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 522  :     Py_buffer pbuf;
; 523  :     Py_ssize_t n, len;
; 524  :     int err;
; 525  : 
; 526  :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	7d 0b		 jge	 SHORT $LN8@fileio_rea@2

; 527  :         return err_closed();

  00012	e8 00 00 00 00	 call	 err_closed

; 559  : }

  00017	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0001b	5e		 pop	 rsi
  0001c	c3		 ret	 0
$LN8@fileio_rea@2:

; 528  :     if (!self->readable)

  0001d	f6 41 64 02	 test	 BYTE PTR [rcx+100], 2
  00021	75 12		 jne	 SHORT $LN7@fileio_rea@2

; 529  :         return err_mode("reading");

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CMOHHLII@reading?$AA@
  0002a	e8 00 00 00 00	 call	 err_mode

; 559  : }

  0002f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00033	5e		 pop	 rsi
  00034	c3		 ret	 0
$LN7@fileio_rea@2:

; 530  : 
; 531  :     if (!PyArg_ParseTuple(args, "w*", &pbuf))

  00035	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbuf$[rsp]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DOGLJEBA@w?$CK?$AA@
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00049	85 c0		 test	 eax, eax
  0004b	75 08		 jne	 SHORT $LN6@fileio_rea@2

; 532  :         return NULL;

  0004d	33 c0		 xor	 eax, eax

; 559  : }

  0004f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00053	5e		 pop	 rsi
  00054	c3		 ret	 0
$LN6@fileio_rea@2:

; 533  : 
; 534  :     if (_PyVerify_fd(self->fd)) {

  00055	8b 4e 60	 mov	 ecx, DWORD PTR [rsi+96]
  00058	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00060	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  00068	e8 00 00 00 00	 call	 _PyVerify_fd
  0006d	85 c0		 test	 eax, eax
  0006f	74 43		 je	 SHORT $LN5@fileio_rea@2

; 535  :         len = pbuf.len;

  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR pbuf$[rsp+16]

; 536  :         Py_BEGIN_ALLOW_THREADS

  00076	e8 00 00 00 00	 call	 PyEval_SaveThread
  0007b	48 8b f8	 mov	 rdi, rax

; 537  :         errno = 0;

  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 538  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 539  :         if (len > INT_MAX)
; 540  :             len = INT_MAX;
; 541  :         n = read(self->fd, pbuf.buf, (int)len);

  0008a	48 8b 54 24 20	 mov	 rdx, QWORD PTR pbuf$[rsp]
  0008f	8b 4e 60	 mov	 ecx, DWORD PTR [rsi+96]
  00092	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00097	48 3b d8	 cmp	 rbx, rax
  0009a	48 0f 4f d8	 cmovg	 rbx, rax
  0009e	44 8b c3	 mov	 r8d, ebx
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 542  : #else
; 543  :         n = read(self->fd, pbuf.buf, len);
; 544  : #endif
; 545  :         Py_END_ALLOW_THREADS

  000a7	48 8b cf	 mov	 rcx, rdi
  000aa	48 63 d8	 movsxd	 rbx, eax
  000ad	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 546  :     } else

  000b2	eb 04		 jmp	 SHORT $LN3@fileio_rea@2
$LN5@fileio_rea@2:

; 547  :         n = -1;

  000b4	48 83 cb ff	 or	 rbx, -1
$LN3@fileio_rea@2:

; 548  :     err = errno;

  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 549  :     PyBuffer_Release(&pbuf);

  000be	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000c3	8b 38		 mov	 edi, DWORD PTR [rax]
  000c5	e8 00 00 00 00	 call	 PyBuffer_Release

; 550  :     if (n < 0) {

  000ca	48 85 db	 test	 rbx, rbx
  000cd	79 32		 jns	 SHORT $LN2@fileio_rea@2

; 551  :         if (err == EAGAIN)

  000cf	83 ff 0b	 cmp	 edi, 11
  000d2	75 15		 jne	 SHORT $LN1@fileio_rea@2

; 552  :             Py_RETURN_NONE;

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000db	e8 00 00 00 00	 call	 _Py_IncRef
  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e7	eb 20		 jmp	 SHORT $LN12@fileio_rea@2
$LN1@fileio_rea@2:

; 553  :         errno = err;

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ef	89 38		 mov	 DWORD PTR [rax], edi

; 554  :         PyErr_SetFromErrno(PyExc_IOError);

  000f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000f8	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 555  :         return NULL;

  000fd	33 c0		 xor	 eax, eax
  000ff	eb 08		 jmp	 SHORT $LN12@fileio_rea@2
$LN2@fileio_rea@2:

; 556  :     }
; 557  : 
; 558  :     return PyLong_FromSsize_t(n);

  00101	48 8b cb	 mov	 rcx, rbx
  00104	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN12@fileio_rea@2:
  00109	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00111	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]

; 559  : }

  00119	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0011d	5e		 pop	 rsi
  0011e	c3		 ret	 0
fileio_readinto ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT new_buffersize
_TEXT	SEGMENT
currentsize$ = 8
pos$ = 16
end$ = 24
new_buffersize PROC					; COMDAT

; 568  :     size_t addend;
; 569  : #ifdef HAVE_FSTAT
; 570  :     if (end != (Py_off_t)-1) {

  00000	41 b9 00 20 00
	00		 mov	 r9d, 8192		; 00002000H
  00006	49 83 f8 ff	 cmp	 r8, -1
  0000a	74 29		 je	 SHORT $LN4@new_buffer

; 571  :         /* Files claiming a size smaller than SMALLCHUNK may
; 572  :            actually be streaming pseudo-files. In this case, we
; 573  :            apply the more aggressive algorithm below.
; 574  :         */
; 575  :         if (end >= SMALLCHUNK && end >= pos && pos >= 0) {

  0000c	4d 3b c1	 cmp	 r8, r9
  0000f	7c 24		 jl	 SHORT $LN4@new_buffer
  00011	4c 3b c2	 cmp	 r8, rdx
  00014	7c 1f		 jl	 SHORT $LN4@new_buffer
  00016	48 85 d2	 test	 rdx, rdx
  00019	78 1a		 js	 SHORT $LN4@new_buffer

; 576  :             /* Add 1 so if the file were to grow we'd notice. */
; 577  :             Py_off_t bufsize = currentsize + end - pos + 1;

  0001b	48 2b ca	 sub	 rcx, rdx

; 578  :             if (bufsize < PY_SSIZE_T_MAX)

  0001e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00028	4a 8d 4c 01 01	 lea	 rcx, QWORD PTR [rcx+r8+1]
  0002d	48 3b c8	 cmp	 rcx, rax
  00030	48 0f 4c c1	 cmovl	 rax, rcx

; 596  : }

  00034	c3		 ret	 0
$LN4@new_buffer:

; 579  :                 return (size_t)bufsize;
; 580  :             else
; 581  :                 return PY_SSIZE_T_MAX;
; 582  :         }
; 583  :     }
; 584  : #endif
; 585  :     /* Expand the buffer by an amount proportional to the current size,
; 586  :        giving us amortized linear-time behavior.  For bigger sizes, use a
; 587  :        less-than-double growth factor to avoid excessive allocation. */
; 588  :     if (currentsize > 65536)

  00035	48 81 f9 00 00
	01 00		 cmp	 rcx, 65536		; 00010000H
  0003c	76 12		 jbe	 SHORT $LN3@new_buffer

; 589  :         addend = currentsize >> 3;

  0003e	48 8b c1	 mov	 rax, rcx
  00041	48 c1 e8 03	 shr	 rax, 3

; 592  :     if (addend < SMALLCHUNK)

  00045	49 3b c1	 cmp	 rax, r9
  00048	49 0f 42 c1	 cmovb	 rax, r9

; 593  :         /* Avoid tiny read() calls. */
; 594  :         addend = SMALLCHUNK;
; 595  :     return addend + currentsize;

  0004c	48 03 c1	 add	 rax, rcx

; 596  : }

  0004f	c3		 ret	 0
$LN3@new_buffer:

; 590  :     else
; 591  :         addend = 256 + currentsize;

  00050	48 8d 81 00 01
	00 00		 lea	 rax, QWORD PTR [rcx+256]

; 592  :     if (addend < SMALLCHUNK)

  00057	49 3b c1	 cmp	 rax, r9
  0005a	49 0f 42 c1	 cmovb	 rax, r9

; 593  :         /* Avoid tiny read() calls. */
; 594  :         addend = SMALLCHUNK;
; 595  :     return addend + currentsize;

  0005e	48 03 c1	 add	 rax, rcx

; 596  : }

  00061	c3		 ret	 0
new_buffersize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_CheckSignals:PROC
EXTRN	_PyBytes_Resize:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$fileio_readall DD imagerel fileio_readall
	DD	imagerel fileio_readall+111
	DD	imagerel $unwind$fileio_readall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fileio_readall DD imagerel fileio_readall+111
	DD	imagerel fileio_readall+488
	DD	imagerel $chain$4$fileio_readall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$fileio_readall DD imagerel fileio_readall+488
	DD	imagerel fileio_readall+617
	DD	imagerel $chain$6$fileio_readall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$fileio_readall DD 0a0021H
	DD	0ae400H
	DD	0bc400H
	DD	0137400H
	DD	0125400H
	DD	0113400H
	DD	imagerel fileio_readall
	DD	imagerel fileio_readall+111
	DD	imagerel $unwind$fileio_readall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fileio_readall DD 0a5721H
	DD	0113457H
	DD	0ae420H
	DD	0bc41bH
	DD	0137412H
	DD	0125408H
	DD	imagerel fileio_readall
	DD	imagerel fileio_readall+111
	DD	imagerel $unwind$fileio_readall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_readall DD 040a01H
	DD	0f006b20aH
	DD	06002d004H
xdata	ENDS
;	COMDAT ??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@
CONST	SEGMENT
??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@ DB 'unbounded re'
	DB	'ad returned more bytes than a Python string can hold ', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\fileio.c
CONST	ENDS
;	COMDAT fileio_readall
_TEXT	SEGMENT
st$ = 32
result$ = 128
self$ = 128
fileio_readall PROC					; COMDAT

; 600  : {

  00000	40 56		 push	 rsi
  00002	41 55		 push	 r13
  00004	41 57		 push	 r15
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 601  : #ifdef HAVE_FSTAT
; 602  :     struct stat st;
; 603  :     Py_off_t pos, end;
; 604  : #endif
; 605  :     PyObject *result;
; 606  :     Py_ssize_t total = 0;

  0000a	45 33 ff	 xor	 r15d, r15d
  0000d	4c 8b e9	 mov	 r13, rcx

; 607  :     Py_ssize_t n;
; 608  :     size_t newsize;
; 609  : 
; 610  :     if (self->fd < 0)

  00010	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00013	41 8b f7	 mov	 esi, r15d
  00016	85 c9		 test	 ecx, ecx
  00018	79 0f		 jns	 SHORT $LN21@fileio_rea@3

; 611  :         return err_closed();

  0001a	e8 00 00 00 00	 call	 err_closed

; 703  : }

  0001f	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00023	41 5f		 pop	 r15
  00025	41 5d		 pop	 r13
  00027	5e		 pop	 rsi
  00028	c3		 ret	 0
$LN21@fileio_rea@3:

; 612  :     if (!_PyVerify_fd(self->fd))

  00029	e8 00 00 00 00	 call	 _PyVerify_fd
  0002e	85 c0		 test	 eax, eax
  00030	75 16		 jne	 SHORT $LN20@fileio_rea@3

; 613  :         return PyErr_SetFromErrno(PyExc_IOError);

  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00039	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 703  : }

  0003e	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00042	41 5f		 pop	 r15
  00044	41 5d		 pop	 r13
  00046	5e		 pop	 rsi
  00047	c3		 ret	 0
$LN20@fileio_rea@3:

; 614  : 
; 615  :     result = PyBytes_FromStringAndSize(NULL, SMALLCHUNK);

  00048	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  0004d	33 c9		 xor	 ecx, ecx
  0004f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00054	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 616  :     if (result == NULL)

  0005c	48 85 c0	 test	 rax, rax
  0005f	75 0a		 jne	 SHORT $LN19@fileio_rea@3

; 703  : }

  00061	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00065	41 5f		 pop	 r15
  00067	41 5d		 pop	 r13
  00069	5e		 pop	 rsi
  0006a	c3		 ret	 0
$LN19@fileio_rea@3:

; 617  :         return NULL;
; 618  : 
; 619  : #ifdef HAVE_FSTAT
; 620  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 621  :     pos = _lseeki64(self->fd, 0L, SEEK_CUR);

  0006b	41 8b 4d 60	 mov	 ecx, DWORD PTR [r13+96]
  0006f	48 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbp
  00077	33 d2		 xor	 edx, edx
  00079	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  00081	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00085	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12
  0008a	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 622  : #else
; 623  :     pos = lseek(self->fd, 0L, SEEK_CUR);
; 624  : #endif
; 625  :     if (fstat(self->fd, &st) == 0)

  00095	41 8b 4d 60	 mov	 ecx, DWORD PTR [r13+96]
  00099	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  0009e	48 8b e8	 mov	 rbp, rax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32
  000a7	85 c0		 test	 eax, eax
  000a9	75 07		 jne	 SHORT $LN18@fileio_rea@3

; 626  :         end = st.st_size;

  000ab	4c 63 64 24 34	 movsxd	 r12, DWORD PTR st$[rsp+20]

; 627  :     else

  000b0	eb 04		 jmp	 SHORT $LN27@fileio_rea@3
$LN18@fileio_rea@3:

; 628  :         end = (Py_off_t)-1;

  000b2	49 83 cc ff	 or	 r12, -1
$LN27@fileio_rea@3:

; 629  : #endif
; 630  :     while (1) {
; 631  : #ifdef HAVE_FSTAT
; 632  :         newsize = new_buffersize(self, total, pos, end);

  000b6	4d 8b c4	 mov	 r8, r12
  000b9	48 8b d5	 mov	 rdx, rbp
  000bc	33 c9		 xor	 ecx, ecx
  000be	48 89 9c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbx
  000c6	e8 00 00 00 00	 call	 new_buffersize

; 633  : #else
; 634  :         newsize = new_buffersize(self, total);
; 635  : #endif
; 636  :         if (newsize > PY_SSIZE_T_MAX || newsize <= 0) {

  000cb	49 be ff ff ff
	ff ff ff ff 7f	 mov	 r14, 9223372036854775807 ; 7fffffffffffffffH
  000d5	48 8b f8	 mov	 rdi, rax
  000d8	49 3b c6	 cmp	 rax, r14
  000db	0f 87 b9 00 00
	00		 ja	 $LN13@fileio_rea@3
$LL16@fileio_rea@3:
  000e1	48 85 ff	 test	 rdi, rdi
  000e4	0f 84 b0 00 00
	00		 je	 $LN13@fileio_rea@3

; 642  :         }
; 643  : 
; 644  :         if (PyBytes_GET_SIZE(result) < (Py_ssize_t)newsize) {

  000ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  000f2	48 39 78 60	 cmp	 QWORD PTR [rax+96], rdi
  000f6	7d 18		 jge	 SHORT $LN11@fileio_rea@3

; 645  :             if (_PyBytes_Resize(&result, newsize) < 0) {

  000f8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  00100	48 8b d7	 mov	 rdx, rdi
  00103	e8 00 00 00 00	 call	 _PyBytes_Resize
  00108	85 c0		 test	 eax, eax
  0010a	0f 88 d8 00 00
	00		 js	 $LN29@fileio_rea@3
$LN11@fileio_rea@3:

; 651  :                 break;
; 652  :             }
; 653  :         }
; 654  :         Py_BEGIN_ALLOW_THREADS

  00110	e8 00 00 00 00	 call	 PyEval_SaveThread
  00115	48 8b d8	 mov	 rbx, rax

; 655  :         errno = 0;

  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 656  :         n = newsize - total;

  0011e	48 2b fe	 sub	 rdi, rsi
  00121	44 89 38	 mov	 DWORD PTR [rax], r15d

; 657  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 658  :         if (n > INT_MAX)
; 659  :             n = INT_MAX;
; 660  :         n = read(self->fd,
; 661  :                  PyBytes_AS_STRING(result) + total,
; 662  :                  (int)n);

  00124	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0012c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00131	48 3b f8	 cmp	 rdi, rax
  00134	48 8d 54 31 78	 lea	 rdx, QWORD PTR [rcx+rsi+120]
  00139	41 8b 4d 60	 mov	 ecx, DWORD PTR [r13+96]
  0013d	48 0f 4f f8	 cmovg	 rdi, rax
  00141	44 8b c7	 mov	 r8d, edi
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 663  : #else
; 664  :         n = read(self->fd,
; 665  :                  PyBytes_AS_STRING(result) + total,
; 666  :                  n);
; 667  : #endif
; 668  :         Py_END_ALLOW_THREADS

  0014a	48 8b cb	 mov	 rcx, rbx
  0014d	48 63 f8	 movsxd	 rdi, eax
  00150	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 669  :         if (n == 0)

  00155	48 85 ff	 test	 rdi, rdi
  00158	0f 84 94 00 00
	00		 je	 $LN15@fileio_rea@3

; 670  :             break;
; 671  :         if (n < 0) {

  0015e	79 1a		 jns	 SHORT $LN7@fileio_rea@3

; 672  :             if (errno == EINTR) {

  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00166	83 38 04	 cmp	 DWORD PTR [rax], 4
  00169	0f 85 af 00 00
	00		 jne	 $LN6@fileio_rea@3

; 673  :                 if (PyErr_CheckSignals()) {

  0016f	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00174	85 c0		 test	 eax, eax
  00176	75 35		 jne	 SHORT $LN40@fileio_rea@3

; 674  :                     Py_DECREF(result);
; 675  :                     return NULL;
; 676  :                 }
; 677  :                 continue;

  00178	eb 06		 jmp	 SHORT $LN32@fileio_rea@3
$LN7@fileio_rea@3:

; 688  :         }
; 689  :         total += n;

  0017a	48 03 f7	 add	 rsi, rdi

; 690  : #ifdef HAVE_FSTAT
; 691  :         pos += n;

  0017d	48 03 ef	 add	 rbp, rdi
$LN32@fileio_rea@3:

; 629  : #endif
; 630  :     while (1) {
; 631  : #ifdef HAVE_FSTAT
; 632  :         newsize = new_buffersize(self, total, pos, end);

  00180	4d 8b c4	 mov	 r8, r12
  00183	48 8b d5	 mov	 rdx, rbp
  00186	48 8b ce	 mov	 rcx, rsi
  00189	e8 00 00 00 00	 call	 new_buffersize
  0018e	48 8b f8	 mov	 rdi, rax

; 633  : #else
; 634  :         newsize = new_buffersize(self, total);
; 635  : #endif
; 636  :         if (newsize > PY_SSIZE_T_MAX || newsize <= 0) {

  00191	49 3b c6	 cmp	 rax, r14
  00194	0f 86 47 ff ff
	ff		 jbe	 $LL16@fileio_rea@3
$LN13@fileio_rea@3:

; 637  :             PyErr_SetString(PyExc_OverflowError,
; 638  :                 "unbounded read returned more bytes "
; 639  :                 "than a Python string can hold ");

  0019a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@
  001a8	e8 00 00 00 00	 call	 PyErr_SetString
$LN40@fileio_rea@3:

; 640  :             Py_DECREF(result);

  001ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  001b5	e8 00 00 00 00	 call	 _Py_DecRef
$LN41@fileio_rea@3:

; 641  :             return NULL;

  001ba	33 c0		 xor	 eax, eax
$LN39@fileio_rea@3:
  001bc	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  001c4	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]
  001cc	48 8b ac 24 90
	00 00 00	 mov	 rbp, QWORD PTR [rsp+144]
  001d4	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]
  001d9	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]

; 703  : }

  001de	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001e2	41 5f		 pop	 r15
  001e4	41 5d		 pop	 r13
  001e6	5e		 pop	 rsi
  001e7	c3		 ret	 0
$LN29@fileio_rea@3:

; 646  :                 if (total == 0) {

  001e8	48 85 f6	 test	 rsi, rsi

; 647  :                     Py_DECREF(result);
; 648  :                     return NULL;

  001eb	74 c0		 je	 SHORT $LN40@fileio_rea@3

; 649  :                 }
; 650  :                 PyErr_Clear();

  001ed	e8 00 00 00 00	 call	 PyErr_Clear
$LN15@fileio_rea@3:

; 692  : #endif
; 693  :     }
; 694  : 
; 695  :     if (PyBytes_GET_SIZE(result) > total) {

  001f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  001fa	48 39 70 60	 cmp	 QWORD PTR [rax+96], rsi
  001fe	7e bc		 jle	 SHORT $LN39@fileio_rea@3

; 696  :         if (_PyBytes_Resize(&result, total) < 0) {

  00200	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  00208	48 8b d6	 mov	 rdx, rsi
  0020b	e8 00 00 00 00	 call	 _PyBytes_Resize
  00210	85 c0		 test	 eax, eax

; 697  :             /* This should never happen, but just in case */
; 698  :             Py_DECREF(result);
; 699  :             return NULL;

  00212	78 99		 js	 SHORT $LN40@fileio_rea@3
  00214	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]

; 700  :         }
; 701  :     }
; 702  :     return result;

  0021c	eb 9e		 jmp	 SHORT $LN39@fileio_rea@3
$LN6@fileio_rea@3:

; 678  :             }
; 679  :             if (total > 0)

  0021e	48 85 f6	 test	 rsi, rsi
  00221	7f cf		 jg	 SHORT $LN15@fileio_rea@3

; 680  :                 break;
; 681  :             if (errno == EAGAIN) {

  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 682  :                 Py_DECREF(result);

  00229	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00231	83 38 0b	 cmp	 DWORD PTR [rax], 11
  00234	75 1d		 jne	 SHORT $LN3@fileio_rea@3
  00236	e8 00 00 00 00	 call	 _Py_DecRef

; 683  :                 Py_RETURN_NONE;

  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00242	e8 00 00 00 00	 call	 _Py_IncRef
  00247	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0024e	e9 69 ff ff ff	 jmp	 $LN39@fileio_rea@3
$LN3@fileio_rea@3:

; 684  :             }
; 685  :             Py_DECREF(result);

  00253	e8 00 00 00 00	 call	 _Py_DecRef

; 686  :             PyErr_SetFromErrno(PyExc_IOError);

  00258	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0025f	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 687  :             return NULL;

  00264	e9 51 ff ff ff	 jmp	 $LN41@fileio_rea@3
fileio_readall ENDP
_TEXT	ENDS
PUBLIC	??_C@_03EHEKHGBO@?$HMO?$CG?$AA@			; `string'
EXTRN	_PyIO_ConvertSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_read DD imagerel fileio_read
	DD	imagerel fileio_read+162
	DD	imagerel $unwind$fileio_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$fileio_read DD imagerel fileio_read+162
	DD	imagerel fileio_read+290
	DD	imagerel $chain$1$fileio_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fileio_read DD imagerel fileio_read+290
	DD	imagerel fileio_read+311
	DD	imagerel $chain$3$fileio_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$fileio_read DD imagerel fileio_read+311
	DD	imagerel fileio_read+369
	DD	imagerel $chain$5$fileio_read
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$fileio_read DD imagerel fileio_read+369
	DD	imagerel fileio_read+407
	DD	imagerel $chain$7$fileio_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$fileio_read DD 040021H
	DD	096400H
	DD	073400H
	DD	imagerel fileio_read
	DD	imagerel fileio_read+162
	DD	imagerel $unwind$fileio_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$fileio_read DD 040021H
	DD	096400H
	DD	073400H
	DD	imagerel fileio_read
	DD	imagerel fileio_read+162
	DD	imagerel $unwind$fileio_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fileio_read DD 040021H
	DD	096400H
	DD	073400H
	DD	imagerel fileio_read
	DD	imagerel fileio_read+162
	DD	imagerel $unwind$fileio_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$fileio_read DD 040a21H
	DD	09640aH
	DD	073405H
	DD	imagerel fileio_read
	DD	imagerel fileio_read+162
	DD	imagerel $unwind$fileio_read
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_read DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_03EHEKHGBO@?$HMO?$CG?$AA@
CONST	SEGMENT
??_C@_03EHEKHGBO@?$HMO?$CG?$AA@ DB '|O&', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_read
_TEXT	SEGMENT
size$ = 48
self$ = 48
args$ = 56
bytes$ = 64
fileio_read PROC					; COMDAT

; 707  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 708  :     char *ptr;
; 709  :     Py_ssize_t n;
; 710  :     Py_ssize_t size = -1;
; 711  :     PyObject *bytes;
; 712  : 
; 713  :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR size$[rsp], -1
  00019	7d 0b		 jge	 SHORT $LN12@fileio_rea@4

; 714  :         return err_closed();

  0001b	e8 00 00 00 00	 call	 err_closed

; 764  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
$LN12@fileio_rea@4:

; 715  :     if (!self->readable)

  00026	f6 41 64 02	 test	 BYTE PTR [rcx+100], 2
  0002a	75 12		 jne	 SHORT $LN11@fileio_rea@4

; 716  :         return err_mode("reading");

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CMOHHLII@reading?$AA@
  00033	e8 00 00 00 00	 call	 err_mode

; 764  : }

  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5f		 pop	 rdi
  0003d	c3		 ret	 0
$LN11@fileio_rea@4:

; 717  : 
; 718  :     if (!PyArg_ParseTuple(args, "|O&", &_PyIO_ConvertSsize_t, &size))

  0003e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR size$[rsp]
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyIO_ConvertSsize_t
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EHEKHGBO@?$HMO?$CG?$AA@
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00059	85 c0		 test	 eax, eax
  0005b	75 08		 jne	 SHORT $LN10@fileio_rea@4
$LN19@fileio_rea@4:

; 719  :         return NULL;

  0005d	33 c0		 xor	 eax, eax

; 764  : }

  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
$LN10@fileio_rea@4:

; 720  : 
; 721  :     if (size < 0) {

  00065	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  0006a	48 85 d2	 test	 rdx, rdx
  0006d	79 0e		 jns	 SHORT $LN9@fileio_rea@4

; 722  :         return fileio_readall(self);

  0006f	48 8b cf	 mov	 rcx, rdi
  00072	e8 00 00 00 00	 call	 fileio_readall

; 764  : }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN9@fileio_rea@4:

; 723  :     }
; 724  : 
; 725  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 726  :     if (size > INT_MAX)

  0007d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00082	48 3b d0	 cmp	 rdx, rax
  00085	48 0f 4f d0	 cmovg	 rdx, rax

; 727  :         size = INT_MAX;
; 728  : #endif
; 729  :     bytes = PyBytes_FromStringAndSize(NULL, size);

  00089	33 c9		 xor	 ecx, ecx
  0008b	48 89 54 24 30	 mov	 QWORD PTR size$[rsp], rdx
  00090	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00095	48 89 44 24 40	 mov	 QWORD PTR bytes$[rsp], rax

; 730  :     if (bytes == NULL)

  0009a	48 85 c0	 test	 rax, rax

; 731  :         return NULL;

  0009d	74 be		 je	 SHORT $LN19@fileio_rea@4

; 732  :     ptr = PyBytes_AS_STRING(bytes);
; 733  : 
; 734  :     if (_PyVerify_fd(self->fd)) {

  0009f	8b 4f 60	 mov	 ecx, DWORD PTR [rdi+96]
  000a2	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  000a7	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000ac	48 8d 70 78	 lea	 rsi, QWORD PTR [rax+120]
  000b0	e8 00 00 00 00	 call	 _PyVerify_fd
  000b5	85 c0		 test	 eax, eax
  000b7	74 7e		 je	 SHORT $LN15@fileio_rea@4

; 735  :         Py_BEGIN_ALLOW_THREADS

  000b9	e8 00 00 00 00	 call	 PyEval_SaveThread
  000be	48 8b d8	 mov	 rbx, rax

; 736  :         errno = 0;

  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 737  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 738  :         n = read(self->fd, ptr, (int)size);

  000c7	48 8b d6	 mov	 rdx, rsi
  000ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000d0	44 8b 44 24 30	 mov	 r8d, DWORD PTR size$[rsp]
  000d5	8b 4f 60	 mov	 ecx, DWORD PTR [rdi+96]
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 739  : #else
; 740  :         n = read(self->fd, ptr, size);
; 741  : #endif
; 742  :         Py_END_ALLOW_THREADS

  000de	48 8b cb	 mov	 rcx, rbx
  000e1	48 63 f8	 movsxd	 rdi, eax
  000e4	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 743  :     } else
; 744  :         n = -1;
; 745  : 
; 746  :     if (n < 0) {

  000e9	48 85 ff	 test	 rdi, rdi
  000ec	78 49		 js	 SHORT $LN15@fileio_rea@4

; 754  :     }
; 755  : 
; 756  :     if (n != size) {

  000ee	48 3b 7c 24 30	 cmp	 rdi, QWORD PTR size$[rsp]
  000f3	74 2d		 je	 SHORT $LN1@fileio_rea@4

; 757  :         if (_PyBytes_Resize(&bytes, n) < 0) {

  000f5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR bytes$[rsp]
  000fa	48 8b d7	 mov	 rdx, rdi
  000fd	e8 00 00 00 00	 call	 _PyBytes_Resize
  00102	85 c0		 test	 eax, eax
  00104	79 1c		 jns	 SHORT $LN1@fileio_rea@4

; 758  :             Py_DECREF(bytes);

  00106	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  0010b	e8 00 00 00 00	 call	 _Py_DecRef
  00110	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00115	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0011a	33 c0		 xor	 eax, eax

; 764  : }

  0011c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00120	5f		 pop	 rdi
  00121	c3		 ret	 0
$LN1@fileio_rea@4:

; 759  :             return NULL;
; 760  :         }
; 761  :     }
; 762  : 
; 763  :     return (PyObject *) bytes;

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR bytes$[rsp]
  00127	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0012c	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 764  : }

  00131	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00135	5f		 pop	 rdi
  00136	c3		 ret	 0
$LN15@fileio_rea@4:

; 747  :         int err = errno;

  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 748  :         Py_DECREF(bytes);

  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bytes$[rsp]
  00142	8b 18		 mov	 ebx, DWORD PTR [rax]
  00144	e8 00 00 00 00	 call	 _Py_DecRef

; 749  :         if (err == EAGAIN)

  00149	83 fb 0b	 cmp	 ebx, 11
  0014c	75 23		 jne	 SHORT $LN3@fileio_rea@4

; 750  :             Py_RETURN_NONE;

  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00155	e8 00 00 00 00	 call	 _Py_IncRef
  0015a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0015f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00164	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 764  : }

  0016b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016f	5f		 pop	 rdi
  00170	c3		 ret	 0
$LN3@fileio_rea@4:

; 751  :         errno = err;

  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00177	89 18		 mov	 DWORD PTR [rax], ebx

; 752  :         PyErr_SetFromErrno(PyExc_IOError);

  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00180	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00185	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0018a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 753  :         return NULL;

  0018f	33 c0		 xor	 eax, eax

; 764  : }

  00191	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00195	5f		 pop	 rdi
  00196	c3		 ret	 0
fileio_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DEPFLJBK@y?$CK?$AA@			; `string'
PUBLIC	??_C@_07EKMNMCED@writing?$AA@			; `string'
EXTRN	__imp_write:PROC
EXTRN	__imp_isatty:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_write DD imagerel fileio_write
	DD	imagerel fileio_write+88
	DD	imagerel $unwind$fileio_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_write DD imagerel fileio_write+88
	DD	imagerel fileio_write+105
	DD	imagerel $chain$0$fileio_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fileio_write DD imagerel fileio_write+105
	DD	imagerel fileio_write+230
	DD	imagerel $chain$2$fileio_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$fileio_write DD imagerel fileio_write+230
	DD	imagerel fileio_write+295
	DD	imagerel $chain$3$fileio_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$fileio_write DD imagerel fileio_write+295
	DD	imagerel fileio_write+331
	DD	imagerel $chain$5$fileio_write
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$fileio_write DD imagerel fileio_write+331
	DD	imagerel fileio_write+353
	DD	imagerel $chain$7$fileio_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$fileio_write DD 020021H
	DD	0127400H
	DD	imagerel fileio_write
	DD	imagerel fileio_write+88
	DD	imagerel $unwind$fileio_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$fileio_write DD 020021H
	DD	0127400H
	DD	imagerel fileio_write
	DD	imagerel fileio_write+88
	DD	imagerel $unwind$fileio_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$fileio_write DD 021H
	DD	imagerel fileio_write+88
	DD	imagerel fileio_write+105
	DD	imagerel $chain$0$fileio_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fileio_write DD 041021H
	DD	0116410H
	DD	0105408H
	DD	imagerel fileio_write+88
	DD	imagerel fileio_write+105
	DD	imagerel $chain$0$fileio_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_write DD 020821H
	DD	0127408H
	DD	imagerel fileio_write
	DD	imagerel fileio_write+88
	DD	imagerel $unwind$fileio_write
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_write DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT ??_C@_02DEPFLJBK@y?$CK?$AA@
CONST	SEGMENT
??_C@_02DEPFLJBK@y?$CK?$AA@ DB 'y*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKMNMCED@writing?$AA@
CONST	SEGMENT
??_C@_07EKMNMCED@writing?$AA@ DB 'writing', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_write
_TEXT	SEGMENT
pbuf$ = 32
self$ = 128
args$ = 136
fileio_write PROC					; COMDAT

; 768  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 769  :     Py_buffer pbuf;
; 770  :     Py_ssize_t n, len;
; 771  :     int err;
; 772  : 
; 773  :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	7d 0b		 jge	 SHORT $LN10@fileio_wri@2

; 774  :         return err_closed();

  00012	e8 00 00 00 00	 call	 err_closed

; 815  : }

  00017	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN10@fileio_wri@2:

; 775  :     if (!self->writable)

  0001d	f6 41 64 04	 test	 BYTE PTR [rcx+100], 4
  00021	75 12		 jne	 SHORT $LN9@fileio_wri@2

; 776  :         return err_mode("writing");

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EKMNMCED@writing?$AA@
  0002a	e8 00 00 00 00	 call	 err_mode

; 815  : }

  0002f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
$LN9@fileio_wri@2:

; 777  : 
; 778  :     if (!PyArg_ParseTuple(args, "y*", &pbuf))

  00035	4c 8d 44 24 20	 lea	 r8, QWORD PTR pbuf$[rsp]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DEPFLJBK@y?$CK?$AA@
  00041	48 8b c8	 mov	 rcx, rax
  00044	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00049	85 c0		 test	 eax, eax
  0004b	75 08		 jne	 SHORT $LN8@fileio_wri@2

; 779  :         return NULL;

  0004d	33 c0		 xor	 eax, eax

; 815  : }

  0004f	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN8@fileio_wri@2:

; 780  : 
; 781  :     if (_PyVerify_fd(self->fd)) {

  00055	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  00058	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi
  00060	e8 00 00 00 00	 call	 _PyVerify_fd
  00065	85 c0		 test	 eax, eax
  00067	74 7d		 je	 SHORT $LN7@fileio_wri@2

; 782  :         Py_BEGIN_ALLOW_THREADS

  00069	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00071	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  00079	e8 00 00 00 00	 call	 PyEval_SaveThread
  0007e	48 8b e8	 mov	 rbp, rax

; 783  :         errno = 0;

  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 784  :         len = pbuf.len;
; 785  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 786  :         if (len > 32767 && isatty(self->fd)) {

  00087	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00092	48 8b 74 24 30	 mov	 rsi, QWORD PTR pbuf$[rsp+16]
  00097	48 3b f7	 cmp	 rsi, rdi
  0009a	7e 0d		 jle	 SHORT $LN6@fileio_wri@2
  0009c	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  000a5	85 c0		 test	 eax, eax
  000a7	75 0f		 jne	 SHORT $LN4@fileio_wri@2
$LN6@fileio_wri@2:

; 787  :             /* Issue #11395: the Windows console returns an error (12: not
; 788  :                enough space error) on writing into stdout if stdout mode is
; 789  :                binary and the length is greater than 66,000 bytes (or less,
; 790  :                depending on heap usage). */
; 791  :             len = 32767;
; 792  :         }
; 793  :         else if (len > INT_MAX)

  000a9	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000ae	48 8b fe	 mov	 rdi, rsi
  000b1	48 3b f0	 cmp	 rsi, rax
  000b4	48 0f 4f f8	 cmovg	 rdi, rax
$LN4@fileio_wri@2:

; 794  :             len = INT_MAX;
; 795  :         n = write(self->fd, pbuf.buf, (int)len);

  000b8	48 8b 54 24 20	 mov	 rdx, QWORD PTR pbuf$[rsp]
  000bd	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  000c0	44 8b c7	 mov	 r8d, edi
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 796  : #else
; 797  :         n = write(self->fd, pbuf.buf, len);
; 798  : #endif
; 799  :         Py_END_ALLOW_THREADS

  000c9	48 8b cd	 mov	 rcx, rbp
  000cc	48 63 d8	 movsxd	 rbx, eax
  000cf	e8 00 00 00 00	 call	 PyEval_RestoreThread
  000d4	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  000dc	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]

; 800  :     } else

  000e4	eb 04		 jmp	 SHORT $LN3@fileio_wri@2
$LN7@fileio_wri@2:

; 801  :         n = -1;

  000e6	48 83 cb ff	 or	 rbx, -1
$LN3@fileio_wri@2:

; 802  :     err = errno;

  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 803  : 
; 804  :     PyBuffer_Release(&pbuf);

  000f0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000f5	8b 38		 mov	 edi, DWORD PTR [rax]
  000f7	e8 00 00 00 00	 call	 PyBuffer_Release

; 805  : 
; 806  :     if (n < 0) {

  000fc	48 85 db	 test	 rbx, rbx
  000ff	79 4a		 jns	 SHORT $LN2@fileio_wri@2

; 807  :         if (err == EAGAIN)

  00101	83 ff 0b	 cmp	 edi, 11
  00104	75 21		 jne	 SHORT $LN1@fileio_wri@2

; 808  :             Py_RETURN_NONE;

  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0010d	e8 00 00 00 00	 call	 _Py_IncRef
  00112	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]
  0011a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 815  : }

  00121	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00125	5b		 pop	 rbx
  00126	c3		 ret	 0
$LN1@fileio_wri@2:

; 809  :         errno = err;

  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012d	89 38		 mov	 DWORD PTR [rax], edi

; 810  :         PyErr_SetFromErrno(PyExc_IOError);

  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00136	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0013b	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]

; 811  :         return NULL;

  00143	33 c0		 xor	 eax, eax

; 815  : }

  00145	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00149	5b		 pop	 rbx
  0014a	c3		 ret	 0
$LN2@fileio_wri@2:

; 812  :     }
; 813  : 
; 814  :     return PyLong_FromSsize_t(n);

  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00153	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]

; 815  : }

  0015b	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0015f	5b		 pop	 rbx
  00160	c3		 ret	 0
fileio_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLongLong:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$portable_lseek DD imagerel portable_lseek
	DD	imagerel portable_lseek+198
	DD	imagerel $unwind$portable_lseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$portable_lseek DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT portable_lseek
_TEXT	SEGMENT
fd$ = 48
posobj$ = 56
whence$ = 64
portable_lseek PROC					; COMDAT

; 822  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b e8	 mov	 ebp, r8d
  00017	48 8b da	 mov	 rbx, rdx
  0001a	8b f1		 mov	 esi, ecx

; 823  :     Py_off_t pos, res;
; 824  : 
; 825  : #ifdef SEEK_SET
; 826  :     /* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */
; 827  :     switch (whence) {
; 828  : #if SEEK_SET != 0
; 829  :     case 0: whence = SEEK_SET; break;
; 830  : #endif
; 831  : #if SEEK_CUR != 1
; 832  :     case 1: whence = SEEK_CUR; break;
; 833  : #endif
; 834  : #if SEEK_END != 2
; 835  :     case 2: whence = SEEK_END; break;
; 836  : #endif
; 837  :     }
; 838  : #endif /* SEEK_SET */
; 839  : 
; 840  :     if (posobj == NULL)

  0001c	48 85 d2	 test	 rdx, rdx
  0001f	75 04		 jne	 SHORT $LN8@portable_l

; 841  :         pos = 0;

  00021	33 ff		 xor	 edi, edi

; 842  :     else {

  00023	eb 2e		 jmp	 SHORT $LN4@portable_l
$LN8@portable_l:

; 843  :         if(PyFloat_Check(posobj)) {

  00025	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00030	48 3b ca	 cmp	 rcx, rdx
  00033	74 67		 je	 SHORT $LN5@portable_l
  00035	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003a	85 c0		 test	 eax, eax
  0003c	75 5e		 jne	 SHORT $LN5@portable_l

; 846  :         }
; 847  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 848  :         pos = PyLong_AsLongLong(posobj);

  0003e	48 8b cb	 mov	 rcx, rbx
  00041	e8 00 00 00 00	 call	 PyLong_AsLongLong
  00046	48 8b f8	 mov	 rdi, rax

; 849  : #else
; 850  :         pos = PyLong_AsLong(posobj);
; 851  : #endif
; 852  :         if (PyErr_Occurred())

  00049	e8 00 00 00 00	 call	 PyErr_Occurred
  0004e	48 85 c0	 test	 rax, rax

; 853  :             return NULL;

  00051	75 5c		 jne	 SHORT $LN14@portable_l
$LN4@portable_l:

; 854  :     }
; 855  : 
; 856  :     if (_PyVerify_fd(fd)) {

  00053	8b ce		 mov	 ecx, esi
  00055	e8 00 00 00 00	 call	 _PyVerify_fd
  0005a	85 c0		 test	 eax, eax
  0005c	74 30		 je	 SHORT $LN13@portable_l

; 857  :         Py_BEGIN_ALLOW_THREADS

  0005e	e8 00 00 00 00	 call	 PyEval_SaveThread

; 858  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 859  :         res = _lseeki64(fd, pos, whence);

  00063	44 8b c5	 mov	 r8d, ebp
  00066	48 8b d7	 mov	 rdx, rdi
  00069	8b ce		 mov	 ecx, esi
  0006b	48 8b d8	 mov	 rbx, rax
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 860  : #else
; 861  :         res = lseek(fd, pos, whence);
; 862  : #endif
; 863  :         Py_END_ALLOW_THREADS

  00074	48 8b cb	 mov	 rcx, rbx
  00077	48 8b f8	 mov	 rdi, rax
  0007a	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 864  :     } else
; 865  :         res = -1;
; 866  :     if (res < 0)

  0007f	48 85 ff	 test	 rdi, rdi
  00082	78 0a		 js	 SHORT $LN13@portable_l

; 868  : 
; 869  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 870  :     return PyLong_FromLongLong(res);

  00084	48 8b cf	 mov	 rcx, rdi
  00087	e8 00 00 00 00	 call	 PyLong_FromLongLong
  0008c	eb 23		 jmp	 SHORT $LN11@portable_l
$LN13@portable_l:

; 867  :         return PyErr_SetFromErrno(PyExc_IOError);

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00095	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0009a	eb 15		 jmp	 SHORT $LN11@portable_l
$LN5@portable_l:

; 844  :             PyErr_SetString(PyExc_TypeError, "an integer is required");

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  000aa	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@portable_l:

; 845  :             return NULL;

  000af	33 c0		 xor	 eax, eax
$LN11@portable_l:

; 871  : #else
; 872  :     return PyLong_FromLong(res);
; 873  : #endif
; 874  : }

  000b1	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b6	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000bb	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	5f		 pop	 rdi
  000c5	c3		 ret	 0
portable_lseek ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PEBICJFC@O?$HMi?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_seek DD imagerel fileio_seek
	DD	imagerel fileio_seek+98
	DD	imagerel $unwind$fileio_seek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_seek DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_03PEBICJFC@O?$HMi?$AA@
CONST	SEGMENT
??_C@_03PEBICJFC@O?$HMi?$AA@ DB 'O|i', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_seek
_TEXT	SEGMENT
whence$ = 48
self$ = 48
args$ = 56
posobj$ = 64
fileio_seek PROC					; COMDAT

; 878  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 879  :     PyObject *posobj;
; 880  :     int whence = 0;
; 881  : 
; 882  :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR whence$[rsp], 0
  00018	7d 0b		 jge	 SHORT $LN2@fileio_see

; 883  :         return err_closed();

  0001a	e8 00 00 00 00	 call	 err_closed

; 889  : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN2@fileio_see:

; 884  : 
; 885  :     if (!PyArg_ParseTuple(args, "O|i", &posobj, &whence))

  00025	4c 8d 4c 24 30	 lea	 r9, QWORD PTR whence$[rsp]
  0002a	4c 8d 44 24 40	 lea	 r8, QWORD PTR posobj$[rsp]
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03PEBICJFC@O?$HMi?$AA@
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 08		 jne	 SHORT $LN1@fileio_see

; 886  :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 889  : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN1@fileio_see:

; 887  : 
; 888  :     return portable_lseek(self->fd, posobj, whence);

  0004a	44 8b 44 24 30	 mov	 r8d, DWORD PTR whence$[rsp]
  0004f	48 8b 54 24 40	 mov	 rdx, QWORD PTR posobj$[rsp]
  00054	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  00057	e8 00 00 00 00	 call	 portable_lseek

; 889  : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
fileio_seek ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT fileio_tell
_TEXT	SEGMENT
self$ = 8
args$ = 16
fileio_tell PROC					; COMDAT

; 894  :     if (self->fd < 0)

  00000	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  00003	85 c9		 test	 ecx, ecx
  00005	79 05		 jns	 SHORT $LN1@fileio_tel

; 898  : }

  00007	e9 00 00 00 00	 jmp	 err_closed
$LN1@fileio_tel:

; 895  :         return err_closed();
; 896  : 
; 897  :     return portable_lseek(self->fd, NULL, 1);

  0000c	33 d2		 xor	 edx, edx
  0000e	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]

; 898  : }

  00012	e9 00 00 00 00	 jmp	 portable_lseek
fileio_tell ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	__imp_SetEndOfFile:PROC
EXTRN	__imp__get_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_truncate DD imagerel fileio_truncate
	DD	imagerel fileio_truncate+148
	DD	imagerel $unwind$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_truncate DD imagerel fileio_truncate+148
	DD	imagerel fileio_truncate+221
	DD	imagerel $chain$0$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fileio_truncate DD imagerel fileio_truncate+221
	DD	imagerel fileio_truncate+224
	DD	imagerel $chain$2$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fileio_truncate DD imagerel fileio_truncate+224
	DD	imagerel fileio_truncate+354
	DD	imagerel $chain$4$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$fileio_truncate DD imagerel fileio_truncate+354
	DD	imagerel fileio_truncate+382
	DD	imagerel $chain$5$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$fileio_truncate DD imagerel fileio_truncate+382
	DD	imagerel fileio_truncate+434
	DD	imagerel $chain$7$fileio_truncate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$fileio_truncate DD imagerel fileio_truncate+434
	DD	imagerel fileio_truncate+455
	DD	imagerel $chain$9$fileio_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$fileio_truncate DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel fileio_truncate
	DD	imagerel fileio_truncate+148
	DD	imagerel $unwind$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$fileio_truncate DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel fileio_truncate
	DD	imagerel fileio_truncate+148
	DD	imagerel $unwind$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$fileio_truncate DD 020021H
	DD	086400H
	DD	imagerel fileio_truncate+221
	DD	imagerel fileio_truncate+224
	DD	imagerel $chain$2$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fileio_truncate DD 040a21H
	DD	08640aH
	DD	075405H
	DD	imagerel fileio_truncate+221
	DD	imagerel fileio_truncate+224
	DD	imagerel $chain$2$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fileio_truncate DD 020021H
	DD	097400H
	DD	imagerel fileio_truncate
	DD	imagerel fileio_truncate+148
	DD	imagerel $unwind$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_truncate DD 020521H
	DD	097405H
	DD	imagerel fileio_truncate
	DD	imagerel fileio_truncate+148
	DD	imagerel $unwind$fileio_truncate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_truncate DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_truncate
_TEXT	SEGMENT
posobj$ = 48
self$ = 48
args$ = 56
fileio_truncate PROC					; COMDAT

; 903  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 904  :     PyObject *posobj = NULL; /* the new size wanted by the user */
; 905  : #ifndef MS_WINDOWS
; 906  :     Py_off_t pos;
; 907  : #endif
; 908  :     int ret;
; 909  :     int fd;
; 910  : 
; 911  :     fd = self->fd;

  00006	8b 59 60	 mov	 ebx, DWORD PTR [rcx+96]
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR posobj$[rsp], 0

; 912  :     if (fd < 0)

  00015	85 db		 test	 ebx, ebx
  00017	79 0b		 jns	 SHORT $LN13@fileio_tru

; 913  :         return err_closed();

  00019	e8 00 00 00 00	 call	 err_closed

; 1000 : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
$LN13@fileio_tru:

; 914  :     if (!self->writable)

  00024	f6 41 64 04	 test	 BYTE PTR [rcx+100], 4
  00028	75 12		 jne	 SHORT $LN12@fileio_tru

; 915  :         return err_mode("writing");

  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EKMNMCED@writing?$AA@
  00031	e8 00 00 00 00	 call	 err_mode

; 1000 : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
$LN12@fileio_tru:

; 916  : 
; 917  :     if (!PyArg_ParseTuple(args, "|O", &posobj))

  0003c	4c 8d 44 24 30	 lea	 r8, QWORD PTR posobj$[rsp]
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00050	85 c0		 test	 eax, eax
  00052	75 08		 jne	 SHORT $LN11@fileio_tru
$LN19@fileio_tru:

; 918  :         return NULL;

  00054	33 c0		 xor	 eax, eax

; 1000 : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN11@fileio_tru:

; 919  : 
; 920  :     if (posobj == Py_None || posobj == NULL) {

  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00068	48 3b c8	 cmp	 rcx, rax
  0006b	74 0c		 je	 SHORT $LN9@fileio_tru
  0006d	48 85 c9	 test	 rcx, rcx
  00070	74 07		 je	 SHORT $LN9@fileio_tru

; 925  :     }
; 926  :     else {
; 927  :         Py_INCREF(posobj);

  00072	e8 00 00 00 00	 call	 _Py_IncRef
  00077	eb 17		 jmp	 SHORT $LN8@fileio_tru
$LN9@fileio_tru:

; 921  :         /* Get the current position. */
; 922  :         posobj = portable_lseek(fd, NULL, 1);

  00079	33 d2		 xor	 edx, edx
  0007b	8b cb		 mov	 ecx, ebx
  0007d	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00081	e8 00 00 00 00	 call	 portable_lseek
  00086	48 89 44 24 30	 mov	 QWORD PTR posobj$[rsp], rax

; 923  :         if (posobj == NULL)

  0008b	48 85 c0	 test	 rax, rax

; 924  :             return NULL;

  0008e	74 c4		 je	 SHORT $LN19@fileio_tru
$LN8@fileio_tru:

; 928  :     }
; 929  : 
; 930  : #ifdef MS_WINDOWS
; 931  :     /* MS _chsize doesn't work if newsize doesn't fit in 32 bits,
; 932  :        so don't even try using it. */
; 933  :     {
; 934  :         PyObject *oldposobj, *tempposobj;
; 935  :         HANDLE hFile;
; 936  : 
; 937  :         /* we save the file pointer position */
; 938  :         oldposobj = portable_lseek(fd, NULL, 1);

  00090	33 d2		 xor	 edx, edx
  00092	8b cb		 mov	 ecx, ebx
  00094	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00099	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0009d	e8 00 00 00 00	 call	 portable_lseek
  000a2	48 8b f8	 mov	 rdi, rax

; 939  :         if (oldposobj == NULL) {

  000a5	48 85 c0	 test	 rax, rax

; 940  :             Py_DECREF(posobj);
; 941  :             return NULL;

  000a8	74 1c		 je	 SHORT $LN18@fileio_tru

; 942  :         }
; 943  : 
; 944  :         /* we then move to the truncation position */
; 945  :         tempposobj = portable_lseek(fd, posobj, 0);

  000aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR posobj$[rsp]
  000af	45 33 c0	 xor	 r8d, r8d
  000b2	8b cb		 mov	 ecx, ebx
  000b4	e8 00 00 00 00	 call	 portable_lseek

; 946  :         if (tempposobj == NULL) {

  000b9	48 85 c0	 test	 rax, rax
  000bc	75 1f		 jne	 SHORT $LN5@fileio_tru

; 947  :             Py_DECREF(oldposobj);

  000be	48 8b cf	 mov	 rcx, rdi
  000c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN18@fileio_tru:

; 948  :             Py_DECREF(posobj);

  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  000cb	e8 00 00 00 00	 call	 _Py_DecRef
  000d0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 949  :             return NULL;

  000d5	33 c0		 xor	 eax, eax

; 1000 : }

  000d7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000db	5b		 pop	 rbx
  000dc	c3		 ret	 0
$LN5@fileio_tru:

; 950  :         }
; 951  :         Py_DECREF(tempposobj);

  000dd	48 8b c8	 mov	 rcx, rax
  000e0	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  000e5	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000ea	e8 00 00 00 00	 call	 _Py_DecRef

; 952  : 
; 953  :         /* Truncate.  Note that this may grow the file! */
; 954  :         Py_BEGIN_ALLOW_THREADS

  000ef	e8 00 00 00 00	 call	 PyEval_SaveThread
  000f4	48 8b e8	 mov	 rbp, rax

; 955  :         errno = 0;

  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 956  :         hFile = (HANDLE)_get_osfhandle(fd);

  000fd	8b cb		 mov	 ecx, ebx
  000ff	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle

; 957  :         ret = hFile == (HANDLE)-1; /* testing for INVALID_HANDLE value */

  0010b	33 f6		 xor	 esi, esi
  0010d	48 83 f8 ff	 cmp	 rax, -1
  00111	40 0f 94 c6	 sete	 sil

; 958  :         if (ret == 0) {

  00115	85 f6		 test	 esi, esi
  00117	75 1f		 jne	 SHORT $LN3@fileio_tru

; 959  :             ret = SetEndOfFile(hFile) == 0;

  00119	48 8b c8	 mov	 rcx, rax
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEndOfFile
  00122	85 c0		 test	 eax, eax
  00124	40 0f 94 c6	 sete	 sil

; 960  :             if (ret)

  00128	85 f6		 test	 esi, esi
  0012a	74 0c		 je	 SHORT $LN3@fileio_tru

; 961  :                 errno = EACCES;

  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00132	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13
$LN3@fileio_tru:

; 962  :         }
; 963  :         Py_END_ALLOW_THREADS

  00138	48 8b cd	 mov	 rcx, rbp
  0013b	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 964  : 
; 965  :         /* we restore the file pointer position in any case */
; 966  :         tempposobj = portable_lseek(fd, oldposobj, 0);

  00140	45 33 c0	 xor	 r8d, r8d
  00143	48 8b d7	 mov	 rdx, rdi
  00146	8b cb		 mov	 ecx, ebx
  00148	e8 00 00 00 00	 call	 portable_lseek

; 967  :         Py_DECREF(oldposobj);

  0014d	48 8b cf	 mov	 rcx, rdi
  00150	48 8b d8	 mov	 rbx, rax
  00153	e8 00 00 00 00	 call	 _Py_DecRef
  00158	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 968  :         if (tempposobj == NULL) {

  0015d	48 85 db	 test	 rbx, rbx
  00160	75 1c		 jne	 SHORT $LN2@fileio_tru

; 969  :             Py_DECREF(posobj);

  00162	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  00167	e8 00 00 00 00	 call	 _Py_DecRef
  0016c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00171	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 970  :             return NULL;

  00176	33 c0		 xor	 eax, eax

; 1000 : }

  00178	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017c	5b		 pop	 rbx
  0017d	c3		 ret	 0
$LN2@fileio_tru:

; 971  :         }
; 972  :         Py_DECREF(tempposobj);

  0017e	48 8b cb	 mov	 rcx, rbx
  00181	e8 00 00 00 00	 call	 _Py_DecRef

; 973  :     }
; 974  : #else
; 975  : 
; 976  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 977  :     pos = PyLong_AsLongLong(posobj);
; 978  : #else
; 979  :     pos = PyLong_AsLong(posobj);
; 980  : #endif
; 981  :     if (PyErr_Occurred()){
; 982  :         Py_DECREF(posobj);
; 983  :         return NULL;
; 984  :     }
; 985  : 
; 986  :     Py_BEGIN_ALLOW_THREADS
; 987  :     errno = 0;
; 988  :     ret = ftruncate(fd, pos);
; 989  :     Py_END_ALLOW_THREADS
; 990  : 
; 991  : #endif /* !MS_WINDOWS */
; 992  : 
; 993  :     if (ret != 0) {

  00186	85 f6		 test	 esi, esi
  00188	74 28		 je	 SHORT $LN1@fileio_tru

; 994  :         Py_DECREF(posobj);

  0018a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  0018f	e8 00 00 00 00	 call	 _Py_DecRef

; 995  :         PyErr_SetFromErrno(PyExc_IOError);

  00194	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0019b	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  001a0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001a5	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 996  :         return NULL;

  001aa	33 c0		 xor	 eax, eax

; 1000 : }

  001ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b0	5b		 pop	 rbx
  001b1	c3		 ret	 0
$LN1@fileio_tru:

; 997  :     }
; 998  : 
; 999  :     return posobj;

  001b2	48 8b 44 24 30	 mov	 rax, QWORD PTR posobj$[rsp]
  001b7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001bc	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1000 : }

  001c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c5	5b		 pop	 rbx
  001c6	c3		 ret	 0
fileio_truncate ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03CCKOKKND@rb?$CL?$AA@			; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
PUBLIC	??_C@_03GAACFCKC@ab?$CL?$AA@			; `string'
PUBLIC	??_C@_02NJHBGCA@xb?$AA@				; `string'
PUBLIC	??_C@_03ENBDEKLH@xb?$CL?$AA@			; `string'
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCKOKKND@rb?$CL?$AA@
CONST	SEGMENT
??_C@_03CCKOKKND@rb?$CL?$AA@ DB 'rb+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GAACFCKC@ab?$CL?$AA@
CONST	SEGMENT
??_C@_03GAACFCKC@ab?$CL?$AA@ DB 'ab+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJHBGCA@xb?$AA@
CONST	SEGMENT
??_C@_02NJHBGCA@xb?$AA@ DB 'xb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ENBDEKLH@xb?$CL?$AA@
CONST	SEGMENT
??_C@_03ENBDEKLH@xb?$CL?$AA@ DB 'xb+', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT mode_string
_TEXT	SEGMENT
self$ = 8
mode_string PROC					; COMDAT

; 1006 :     if (self->created) {

  00000	8b 41 64	 mov	 eax, DWORD PTR [rcx+100]
  00003	a8 01		 test	 al, 1
  00005	74 14		 je	 SHORT $LN9@mode_strin

; 1007 :         if (self->readable)

  00007	a8 02		 test	 al, 2
  00009	74 08		 je	 SHORT $LN10@mode_strin

; 1008 :             return "xb+";

  0000b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ENBDEKLH@xb?$CL?$AA@

; 1026 : }

  00012	c3		 ret	 0
$LN10@mode_strin:

; 1009 :         else
; 1010 :             return "xb";

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02NJHBGCA@xb?$AA@

; 1026 : }

  0001a	c3		 ret	 0
$LN9@mode_strin:

; 1011 :     }
; 1012 :     if (self->appending) {

  0001b	a8 08		 test	 al, 8
  0001d	74 14		 je	 SHORT $LN8@mode_strin

; 1013 :         if (self->readable)

  0001f	a8 02		 test	 al, 2
  00021	74 08		 je	 SHORT $LN7@mode_strin

; 1014 :             return "ab+";

  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03GAACFCKC@ab?$CL?$AA@

; 1026 : }

  0002a	c3		 ret	 0
$LN7@mode_strin:

; 1015 :         else
; 1016 :             return "ab";

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02BOGAIONP@ab?$AA@

; 1026 : }

  00032	c3		 ret	 0
$LN8@mode_strin:

; 1017 :     }
; 1018 :     else if (self->readable) {

  00033	a8 02		 test	 al, 2
  00035	74 14		 je	 SHORT $LN4@mode_strin

; 1019 :         if (self->writable)

  00037	a8 04		 test	 al, 4
  00039	74 08		 je	 SHORT $LN3@mode_strin

; 1020 :             return "rb+";

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03CCKOKKND@rb?$CL?$AA@

; 1026 : }

  00042	c3		 ret	 0
$LN3@mode_strin:

; 1021 :         else
; 1022 :             return "rb";

  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02JDPG@rb?$AA@

; 1026 : }

  0004a	c3		 ret	 0
$LN4@mode_strin:

; 1023 :     }
; 1024 :     else
; 1025 :         return "wb";

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@

; 1026 : }

  00052	c3		 ret	 0
mode_string ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@ ; `string'
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_repr DD imagerel fileio_repr
	DD	imagerel fileio_repr+59
	DD	imagerel $unwind$fileio_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$fileio_repr DD imagerel fileio_repr+59
	DD	imagerel fileio_repr+138
	DD	imagerel $chain$0$fileio_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$fileio_repr DD imagerel fileio_repr+138
	DD	imagerel fileio_repr+151
	DD	imagerel $chain$2$fileio_repr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$fileio_repr DD imagerel fileio_repr+151
	DD	imagerel fileio_repr+202
	DD	imagerel $chain$4$fileio_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$fileio_repr DD 020021H
	DD	067400H
	DD	imagerel fileio_repr
	DD	imagerel fileio_repr+59
	DD	imagerel $unwind$fileio_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$fileio_repr DD 020021H
	DD	067400H
	DD	imagerel fileio_repr
	DD	imagerel fileio_repr+59
	DD	imagerel $unwind$fileio_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$fileio_repr DD 020521H
	DD	067405H
	DD	imagerel fileio_repr
	DD	imagerel fileio_repr+59
	DD	imagerel $unwind$fileio_repr
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_repr DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@
CONST	SEGMENT
??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@ DB '<'
	DB	'_io.FileIO name=%R mode=''%s''>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@
CONST	SEGMENT
??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@ DB '<'
	DB	'_io.FileIO fd=%d mode=''%s''>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@
CONST	SEGMENT
??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@ DB '<_io.File'
	DB	'IO [closed]>', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_repr
_TEXT	SEGMENT
self$ = 48
fileio_repr PROC					; COMDAT

; 1030 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1031 :     _Py_IDENTIFIER(name);
; 1032 :     PyObject *nameobj, *res;
; 1033 : 
; 1034 :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7d 11		 jge	 SHORT $LN5@fileio_rep

; 1035 :         return PyUnicode_FromFormat("<_io.FileIO [closed]>");

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@

; 1052 : }

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN5@fileio_rep:

; 1036 : 
; 1037 :     nameobj = _PyObject_GetAttrId((PyObject *) self, &PyId_name);

  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00026	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0002f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_name@?1??fileio_repr@@9@9
  00034	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00040	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00045	48 8b f8	 mov	 rdi, rax

; 1038 :     if (nameobj == NULL) {

  00048	48 85 c0	 test	 rax, rax
  0004b	75 4a		 jne	 SHORT $LN4@fileio_rep

; 1039 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00054	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00059	85 c0		 test	 eax, eax
  0005b	74 2d		 je	 SHORT $LN3@fileio_rep

; 1040 :             PyErr_Clear();

  0005d	e8 00 00 00 00	 call	 PyErr_Clear

; 1043 :         res = PyUnicode_FromFormat("<_io.FileIO fd=%d mode='%s'>",
; 1044 :                                    self->fd, mode_string(self));

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 mode_string
  0006a	8b 53 60	 mov	 edx, DWORD PTR [rbx+96]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@
  00074	4c 8b c0	 mov	 r8, rax
  00077	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0007c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  00081	48 8b d8	 mov	 rbx, rax

; 1052 : }

  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5b		 pop	 rbx
  00089	c3		 ret	 0
$LN3@fileio_rep:

; 1041 :         else
; 1042 :             return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1052 : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5b		 pop	 rbx
  00096	c3		 ret	 0
$LN4@fileio_rep:

; 1045 :     }
; 1046 :     else {
; 1047 :         res = PyUnicode_FromFormat("<_io.FileIO name=%R mode='%s'>",
; 1048 :                                    nameobj, mode_string(self));

  00097	48 8b cb	 mov	 rcx, rbx
  0009a	e8 00 00 00 00	 call	 mode_string
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@
  000a6	48 8b d7	 mov	 rdx, rdi
  000a9	4c 8b c0	 mov	 r8, rax
  000ac	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 1049 :         Py_DECREF(nameobj);

  000b1	48 8b cf	 mov	 rcx, rdi
  000b4	48 8b d8	 mov	 rbx, rax
  000b7	e8 00 00 00 00	 call	 _Py_DecRef
  000bc	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1050 :     }
; 1051 :     return res;

  000c1	48 8b c3	 mov	 rax, rbx

; 1052 : }

  000c4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c8	5b		 pop	 rbx
  000c9	c3		 ret	 0
fileio_repr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_isatty DD imagerel fileio_isatty
	DD	imagerel fileio_isatty+74
	DD	imagerel $unwind$fileio_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_isatty DD 041e01H
	DD	06741eH
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fileio_isatty
_TEXT	SEGMENT
self$ = 48
fileio_isatty PROC					; COMDAT

; 1056 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1057 :     long res;
; 1058 : 
; 1059 :     if (self->fd < 0)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	7d 0a		 jge	 SHORT $LN1@fileio_isa

; 1065 : }

  0000f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00013	5b		 pop	 rbx
  00014	e9 00 00 00 00	 jmp	 err_closed
$LN1@fileio_isa:
  00019	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 1060 :         return err_closed();
; 1061 :     Py_BEGIN_ALLOW_THREADS

  0001e	e8 00 00 00 00	 call	 PyEval_SaveThread

; 1062 :     res = isatty(self->fd);

  00023	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  00026	48 8b f8	 mov	 rdi, rax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty

; 1063 :     Py_END_ALLOW_THREADS

  0002f	48 8b cf	 mov	 rcx, rdi
  00032	8b d8		 mov	 ebx, eax
  00034	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1064 :     return PyBool_FromLong(res);

  00039	8b cb		 mov	 ecx, ebx
  0003b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1065 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	e9 00 00 00 00	 jmp	 PyBool_FromLong
fileio_isatty ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_getstate DD imagerel fileio_getstate
	DD	imagerel fileio_getstate+38
	DD	imagerel $unwind$fileio_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_getstate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
CONST	SEGMENT
??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ DB 'cannot s'
	DB	'erialize ''%s'' object', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_getstate
_TEXT	SEGMENT
self$ = 48
fileio_getstate PROC					; COMDAT

; 1069 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1070 :     PyErr_Format(PyExc_TypeError,
; 1071 :                  "cannot serialize '%s' object", Py_TYPE(self)->tp_name);

  00004	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00008	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
  00016	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0001a	e8 00 00 00 00	 call	 PyErr_Format

; 1072 :     return NULL;

  0001f	33 c0		 xor	 eax, eax

; 1073 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
fileio_getstate ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT get_closed
_TEXT	SEGMENT
self$ = 8
closure$ = 16
get_closed PROC						; COMDAT

; 1184 :     return PyBool_FromLong((long)(self->fd < 0));

  00000	33 c0		 xor	 eax, eax
  00002	39 41 60	 cmp	 DWORD PTR [rcx+96], eax
  00005	0f 9c c0	 setl	 al
  00008	8b c8		 mov	 ecx, eax

; 1185 : }

  0000a	e9 00 00 00 00	 jmp	 PyBool_FromLong
get_closed ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT get_closefd
_TEXT	SEGMENT
self$ = 8
closure$ = 16
get_closefd PROC					; COMDAT

; 1190 :     return PyBool_FromLong((long)(self->closefd));

  00000	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  00003	c1 e9 06	 shr	 ecx, 6
  00006	83 e1 01	 and	 ecx, 1

; 1191 : }

  00009	e9 00 00 00 00	 jmp	 PyBool_FromLong
get_closefd ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_mode DD imagerel get_mode
	DD	imagerel get_mode+21
	DD	imagerel $unwind$get_mode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_mode DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_mode
_TEXT	SEGMENT
self$ = 48
closure$ = 56
get_mode PROC						; COMDAT

; 1195 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1196 :     return PyUnicode_FromString(mode_string(self));

  00004	e8 00 00 00 00	 call	 mode_string
  00009	48 8b c8	 mov	 rcx, rax

; 1197 : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	e9 00 00 00 00	 jmp	 PyUnicode_FromString
get_mode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ ; `string'
PUBLIC	??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@ ; `string'
PUBLIC	??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@ ; `string'
PUBLIC	??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@ ; `string'
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@ ; `string'
PUBLIC	??_C@_0M@LJPPJMDP@fileio_init?$AA@		; `string'
PUBLIC	??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ ; `string'
PUBLIC	??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@	; `string'
PUBLIC	??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@		; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp__wopen:PROC
EXTRN	PyObject_SetAttrString:PROC
EXTRN	__imp__setmode:PROC
EXTRN	PyUnicode_FSConverter:PROC
EXTRN	__ImageBase:BYTE
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	_PyUnicode_HasNULChars:PROC
EXTRN	_PyLong_AsInt:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_init DD imagerel fileio_init
	DD	imagerel fileio_init+1330
	DD	imagerel $unwind$fileio_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_init DD 0a1701H
	DD	0173417H
	DD	0f010d217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
CONST	SEGMENT
??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ DB 'integer arg'
	DB	'ument expected, got float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@
CONST	SEGMENT
??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@ DB 'Must have e'
	DB	'xactly one of create/read/write/append mode and at most one p'
	DB	'lus', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@ DB 'invalid mode: %.2'
	DB	'00s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@
CONST	SEGMENT
??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@ DB 'expected inte'
	DB	'ger from opener', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@
CONST	SEGMENT
??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@ DB 'Cannot us'
	DB	'e closefd=False with file name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJPPJMDP@fileio_init?$AA@
CONST	SEGMENT
??_C@_0M@LJPPJMDP@fileio_init?$AA@ DB 'fileio_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
CONST	SEGMENT
??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ DB 'embedded NUL charact'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@
CONST	SEGMENT
??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@ DB 'Negative filedescript'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@
CONST	SEGMENT
??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@ DB 'O|siO:fileio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fileio_init
_TEXT	SEGMENT
ret$1$ = 64
nameobj$ = 72
stringobj$ = 80
mode$ = 96
opener$ = 104
closefd$ = 176
oself$ = 176
args$ = 184
kwds$ = 192
fd_is_own$1$ = 200
fileio_init PROC					; COMDAT

; 210  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 211  :     fileio *self = (fileio *) oself;
; 212  :     static char *kwlist[] = {"file", "mode", "closefd", "opener", NULL};
; 213  :     const char *name = NULL;
; 214  :     PyObject *nameobj, *stringobj = NULL, *opener = Py_None;

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	33 c9		 xor	 ecx, ecx
  00023	48 89 45 f8	 mov	 QWORD PTR opener$[rbp-112], rax

; 215  :     char *mode = "r";

  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0002e	49 8b f0	 mov	 rsi, r8
  00031	4c 8b e2	 mov	 r12, rdx
  00034	48 89 4d e0	 mov	 QWORD PTR stringobj$[rbp-112], rcx

; 216  :     char *s;
; 217  : #ifdef MS_WINDOWS
; 218  :     Py_UNICODE *widename = NULL;

  00038	44 8b f1	 mov	 r14d, ecx
  0003b	48 89 45 f0	 mov	 QWORD PTR mode$[rbp-112], rax

; 219  : #endif
; 220  :     int ret = 0;

  0003f	89 4d d0	 mov	 DWORD PTR ret$1$[rbp-112], ecx

; 221  :     int rwa = 0, plus = 0;

  00042	44 8b e9	 mov	 r13d, ecx
  00045	44 8b f9	 mov	 r15d, ecx

; 222  :     int flags = 0;

  00048	8b f9		 mov	 edi, ecx

; 223  :     int fd = -1;
; 224  :     int closefd = 1;

  0004a	c7 45 40 01 00
	00 00		 mov	 DWORD PTR closefd$[rbp-112], 1

; 225  :     int fd_is_own = 0;

  00051	89 4d 58	 mov	 DWORD PTR fd_is_own$1$[rbp-112], ecx

; 226  : 
; 227  :     assert(PyFileIO_Check(oself));
; 228  :     if (self->fd >= 0) {

  00054	39 4b 60	 cmp	 DWORD PTR [rbx+96], ecx
  00057	7c 1e		 jl	 SHORT $LN58@fileio_ini

; 229  :         if (self->closefd) {

  00059	f6 43 64 40	 test	 BYTE PTR [rbx+100], 64	; 00000040H
  0005d	74 11		 je	 SHORT $LN60@fileio_ini

; 230  :             /* Have to close the existing file first. */
; 231  :             if (internal_close(self) < 0)

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	e8 00 00 00 00	 call	 internal_close
  00067	85 c0		 test	 eax, eax
  00069	79 0c		 jns	 SHORT $LN58@fileio_ini

; 232  :                 return -1;

  0006b	e9 3c 04 00 00	 jmp	 $LN75@fileio_ini
$LN60@fileio_ini:

; 233  :         }
; 234  :         else
; 235  :             self->fd = -1;

  00070	c7 43 60 ff ff
	ff ff		 mov	 DWORD PTR [rbx+96], -1
$LN58@fileio_ini:

; 236  :     }
; 237  : 
; 238  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|siO:fileio",
; 239  :                                      kwlist, &nameobj, &mode, &closefd,
; 240  :                                      &opener))

  00077	48 8d 45 f8	 lea	 rax, QWORD PTR opener$[rbp-112]
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??fileio_init@@9@9
  00082	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@
  00089	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0008e	48 8d 45 40	 lea	 rax, QWORD PTR closefd$[rbp-112]
  00092	48 8b d6	 mov	 rdx, rsi
  00095	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0009a	48 8d 45 f0	 lea	 rax, QWORD PTR mode$[rbp-112]
  0009e	49 8b cc	 mov	 rcx, r12
  000a1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a6	48 8d 45 d8	 lea	 rax, QWORD PTR nameobj$[rbp-112]
  000aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000af	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000b4	85 c0		 test	 eax, eax

; 241  :         return -1;

  000b6	0f 84 f0 03 00
	00		 je	 $LN75@fileio_ini

; 242  : 
; 243  :     if (PyFloat_Check(nameobj)) {

  000bc	48 8b 4d d8	 mov	 rcx, QWORD PTR nameobj$[rbp-112]
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000c7	48 39 51 58	 cmp	 QWORD PTR [rcx+88], rdx
  000cb	0f 84 c8 03 00
	00		 je	 $LN55@fileio_ini
  000d1	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  000d5	e8 00 00 00 00	 call	 PyType_IsSubtype
  000da	85 c0		 test	 eax, eax
  000dc	0f 85 b7 03 00
	00		 jne	 $LN55@fileio_ini

; 247  :     }
; 248  : 
; 249  :     fd = _PyLong_AsInt(nameobj);

  000e2	48 8b 4d d8	 mov	 rcx, QWORD PTR nameobj$[rbp-112]
  000e6	e8 00 00 00 00	 call	 _PyLong_AsInt
  000eb	8b f0		 mov	 esi, eax

; 250  :     if (fd < 0) {

  000ed	85 c0		 test	 eax, eax
  000ef	79 22		 jns	 SHORT $LN54@fileio_ini

; 251  :         if (!PyErr_Occurred()) {

  000f1	e8 00 00 00 00	 call	 PyErr_Occurred
  000f6	48 85 c0	 test	 rax, rax
  000f9	75 13		 jne	 SHORT $LN53@fileio_ini

; 252  :             PyErr_SetString(PyExc_ValueError,
; 253  :                             "Negative filedescriptor");

  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@

; 254  :             return -1;

  00109	e9 99 03 00 00	 jmp	 $LN76@fileio_ini
$LN53@fileio_ini:

; 255  :         }
; 256  :         PyErr_Clear();

  0010e	e8 00 00 00 00	 call	 PyErr_Clear
$LN54@fileio_ini:

; 257  :     }
; 258  : 
; 259  : #ifdef MS_WINDOWS
; 260  :     if (PyUnicode_Check(nameobj)) {

  00113	48 8b 4d d8	 mov	 rcx, QWORD PTR nameobj$[rbp-112]
  00117	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0011b	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00125	0f 84 7f 00 00
	00		 je	 $LN52@fileio_ini

; 261  :         int rv = _PyUnicode_HasNULChars(nameobj);

  0012b	e8 00 00 00 00	 call	 _PyUnicode_HasNULChars

; 262  :         if (rv) {

  00130	85 c0		 test	 eax, eax
  00132	74 15		 je	 SHORT $LN51@fileio_ini

; 263  :             if (rv != -1)

  00134	83 f8 ff	 cmp	 eax, -1
  00137	0f 84 6f 03 00
	00		 je	 $LN75@fileio_ini

; 264  :                 PyErr_SetString(PyExc_TypeError, "embedded NUL character");

  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@

; 265  :             return -1;

  00144	e9 57 03 00 00	 jmp	 $LN77@fileio_ini
$LN51@fileio_ini:

; 266  :         }
; 267  :         widename = PyUnicode_AsUnicode(nameobj);

  00149	48 8b 4d d8	 mov	 rcx, QWORD PTR nameobj$[rbp-112]
  0014d	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00152	4c 8b f0	 mov	 r14, rax

; 268  :         if (widename == NULL)

  00155	48 85 c0	 test	 rax, rax
  00158	0f 84 4e 03 00
	00		 je	 $LN75@fileio_ini
$LN73@fileio_ini:

; 278  :     }
; 279  : 
; 280  :     s = mode;

  0015e	4c 8b e7	 mov	 r12, rdi
$LN47@fileio_ini:
  00161	4c 8b 45 f0	 mov	 r8, QWORD PTR mode$[rbp-112]
  00165	49 8b d0	 mov	 rdx, r8

; 281  :     while (*s) {

  00168	41 38 38	 cmp	 BYTE PTR [r8], dil
  0016b	0f 84 f2 02 00
	00		 je	 $bad_mode$63863
  00171	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00178	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL45@fileio_ini:

; 282  :         switch (*s++) {

  00180	0f be 02	 movsx	 eax, BYTE PTR [rdx]
  00183	48 ff c2	 inc	 rdx
  00186	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00189	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0018c	0f 87 bc 02 00
	00		 ja	 $LN30@fileio_ini
  00192	48 98		 cdqe
  00194	41 0f b6 84 01
	00 00 00 00	 movzx	 eax, BYTE PTR $LN70@fileio_ini[r9+rax]
  0019d	41 8b 8c 81 00
	00 00 00	 mov	 ecx, DWORD PTR $LN71@fileio_ini[r9+rax*4]
  001a5	49 03 c9	 add	 rcx, r9
  001a8	ff e1		 jmp	 rcx
$LN52@fileio_ini:

; 269  :             return -1;
; 270  :     } else
; 271  : #endif
; 272  :     if (fd < 0)

  001aa	85 f6		 test	 esi, esi
  001ac	79 b0		 jns	 SHORT $LN73@fileio_ini

; 273  :     {
; 274  :         if (!PyUnicode_FSConverter(nameobj, &stringobj)) {

  001ae	48 8d 55 e0	 lea	 rdx, QWORD PTR stringobj$[rbp-112]
  001b2	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  001b7	85 c0		 test	 eax, eax

; 275  :             return -1;

  001b9	0f 84 ed 02 00
	00		 je	 $LN75@fileio_ini

; 276  :         }
; 277  :         name = PyBytes_AS_STRING(stringobj);

  001bf	4c 8b 65 e0	 mov	 r12, QWORD PTR stringobj$[rbp-112]
  001c3	49 83 c4 78	 add	 r12, 120		; 00000078H
  001c7	eb 98		 jmp	 SHORT $LN47@fileio_ini
$LN41@fileio_ini:

; 283  :         case 'x':
; 284  :             if (rwa) {

  001c9	45 85 ed	 test	 r13d, r13d
  001cc	0f 85 91 02 00
	00		 jne	 $bad_mode$63863

; 289  :                 goto error;
; 290  :             }
; 291  :             rwa = 1;
; 292  :             self->created = 1;
; 293  :             self->writable = 1;

  001d2	83 4b 64 05	 or	 DWORD PTR [rbx+100], 5
  001d6	41 bd 01 00 00
	00		 mov	 r13d, 1

; 294  :             flags |= O_EXCL | O_CREAT;

  001dc	81 cf 00 05 00
	00		 or	 edi, 1280		; 00000500H

; 295  :             break;

  001e2	eb 5e		 jmp	 SHORT $LN42@fileio_ini
$LN39@fileio_ini:

; 296  :         case 'r':
; 297  :             if (rwa)

  001e4	45 85 ed	 test	 r13d, r13d
  001e7	0f 85 76 02 00
	00		 jne	 $bad_mode$63863

; 298  :                 goto bad_mode;
; 299  :             rwa = 1;
; 300  :             self->readable = 1;

  001ed	83 4b 64 02	 or	 DWORD PTR [rbx+100], 2
  001f1	41 bd 01 00 00
	00		 mov	 r13d, 1

; 301  :             break;

  001f7	eb 49		 jmp	 SHORT $LN42@fileio_ini
$LN37@fileio_ini:

; 302  :         case 'w':
; 303  :             if (rwa)

  001f9	45 85 ed	 test	 r13d, r13d
  001fc	0f 85 61 02 00
	00		 jne	 $bad_mode$63863

; 304  :                 goto bad_mode;
; 305  :             rwa = 1;
; 306  :             self->writable = 1;

  00202	83 4b 64 04	 or	 DWORD PTR [rbx+100], 4
  00206	41 bd 01 00 00
	00		 mov	 r13d, 1

; 307  :             flags |= O_CREAT | O_TRUNC;

  0020c	81 cf 00 03 00
	00		 or	 edi, 768		; 00000300H

; 308  :             break;

  00212	eb 2e		 jmp	 SHORT $LN42@fileio_ini
$LN35@fileio_ini:

; 309  :         case 'a':
; 310  :             if (rwa)

  00214	45 85 ed	 test	 r13d, r13d
  00217	0f 85 46 02 00
	00		 jne	 $bad_mode$63863

; 311  :                 goto bad_mode;
; 312  :             rwa = 1;
; 313  :             self->writable = 1;
; 314  :             self->appending = 1;

  0021d	83 4b 64 0c	 or	 DWORD PTR [rbx+100], 12
  00221	41 bd 01 00 00
	00		 mov	 r13d, 1

; 315  :             flags |= O_APPEND | O_CREAT;

  00227	81 cf 08 01 00
	00		 or	 edi, 264		; 00000108H

; 316  :             break;

  0022d	eb 13		 jmp	 SHORT $LN42@fileio_ini
$LN32@fileio_ini:

; 317  :         case 'b':
; 318  :             break;
; 319  :         case '+':
; 320  :             if (plus)

  0022f	45 85 ff	 test	 r15d, r15d
  00232	0f 85 2b 02 00
	00		 jne	 $bad_mode$63863

; 321  :                 goto bad_mode;
; 322  :             self->readable = self->writable = 1;

  00238	83 4b 64 06	 or	 DWORD PTR [rbx+100], 6

; 323  :             plus = 1;

  0023c	41 bf 01 00 00
	00		 mov	 r15d, 1
$LN42@fileio_ini:

; 281  :     while (*s) {

  00242	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00245	0f 85 35 ff ff
	ff		 jne	 $LL45@fileio_ini

; 329  :         }
; 330  :     }
; 331  : 
; 332  :     if (!rwa)

  0024b	45 85 ed	 test	 r13d, r13d
  0024e	0f 84 0f 02 00
	00		 je	 $bad_mode$63863

; 333  :         goto bad_mode;
; 334  : 
; 335  :     if (self->readable && self->writable)

  00254	8b 4b 64	 mov	 ecx, DWORD PTR [rbx+100]
  00257	8b c1		 mov	 eax, ecx
  00259	d1 e8		 shr	 eax, 1
  0025b	83 e0 01	 and	 eax, 1
  0025e	74 0a		 je	 SHORT $LN28@fileio_ini
  00260	f6 c1 04	 test	 cl, 4
  00263	74 05		 je	 SHORT $LN28@fileio_ini

; 336  :         flags |= O_RDWR;

  00265	83 cf 02	 or	 edi, 2
  00268	eb 07		 jmp	 SHORT $LN25@fileio_ini
$LN28@fileio_ini:

; 337  :     else if (self->readable)

  0026a	85 c0		 test	 eax, eax
  0026c	75 03		 jne	 SHORT $LN25@fileio_ini

; 338  :         flags |= O_RDONLY;
; 339  :     else
; 340  :         flags |= O_WRONLY;

  0026e	83 cf 01	 or	 edi, 1
$LN25@fileio_ini:

; 341  : 
; 342  : #ifdef O_BINARY
; 343  :     flags |= O_BINARY;

  00271	0f ba ef 0f	 bts	 edi, 15

; 344  : #endif
; 345  : 
; 346  :     if (fd >= 0) {

  00275	85 f6		 test	 esi, esi
  00277	0f 88 cd 00 00
	00		 js	 $LN24@fileio_ini

; 347  :         if (check_fd(fd))

  0027d	8b ce		 mov	 ecx, esi
  0027f	e8 00 00 00 00	 call	 check_fd
  00284	85 c0		 test	 eax, eax
  00286	0f 85 ea 01 00
	00		 jne	 $error$63865

; 348  :             goto error;
; 349  :         self->fd = fd;
; 350  :         self->closefd = closefd;

  0028c	8b 45 40	 mov	 eax, DWORD PTR closefd$[rbp-112]
  0028f	83 63 64 bf	 and	 DWORD PTR [rbx+100], -65 ; ffffffbfH
  00293	89 73 60	 mov	 DWORD PTR [rbx+96], esi
  00296	83 e0 01	 and	 eax, 1
  00299	c1 e0 06	 shl	 eax, 6
  0029c	09 43 64	 or	 DWORD PTR [rbx+100], eax
$LN13@fileio_ini:

; 398  :         }
; 399  :     }
; 400  :     if (dircheck(self, nameobj) < 0)

  0029f	48 8b 55 d8	 mov	 rdx, QWORD PTR nameobj$[rbp-112]
  002a3	48 8b cb	 mov	 rcx, rbx
  002a6	e8 00 00 00 00	 call	 dircheck
  002ab	85 c0		 test	 eax, eax
  002ad	0f 88 c3 01 00
	00		 js	 $error$63865

; 401  :         goto error;
; 402  : 
; 403  : #if defined(MS_WINDOWS) || defined(__CYGWIN__)
; 404  :     /* don't translate newlines (\r\n <=> \n) */
; 405  :     _setmode(self->fd, O_BINARY);

  002b3	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  002b6	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 406  : #endif
; 407  : 
; 408  :     if (PyObject_SetAttrString((PyObject *)self, "name", nameobj) < 0)

  002c1	4c 8b 45 d8	 mov	 r8, QWORD PTR nameobj$[rbp-112]
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MEMAJGDJ@name?$AA@
  002cc	48 8b cb	 mov	 rcx, rbx
  002cf	e8 00 00 00 00	 call	 PyObject_SetAttrString
  002d4	85 c0		 test	 eax, eax
  002d6	0f 88 9a 01 00
	00		 js	 $error$63865

; 409  :         goto error;
; 410  : 
; 411  :     if (self->appending) {

  002dc	f6 43 64 08	 test	 BYTE PTR [rbx+100], 8
  002e0	74 1f		 je	 SHORT $LN74@fileio_ini

; 412  :         /* For consistent behaviour, we explicitly seek to the
; 413  :            end of file (otherwise, it might be done only on the
; 414  :            first write()). */
; 415  :         PyObject *pos = portable_lseek(self->fd, NULL, 2);

  002e2	8b 4b 60	 mov	 ecx, DWORD PTR [rbx+96]
  002e5	33 d2		 xor	 edx, edx
  002e7	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  002eb	e8 00 00 00 00	 call	 portable_lseek

; 416  :         if (pos == NULL)

  002f0	48 85 c0	 test	 rax, rax
  002f3	0f 84 7d 01 00
	00		 je	 $error$63865

; 417  :             goto error;
; 418  :         Py_DECREF(pos);

  002f9	48 8b c8	 mov	 rcx, rax
  002fc	e8 00 00 00 00	 call	 _Py_DecRef
$LN74@fileio_ini:

; 278  :     }
; 279  : 
; 280  :     s = mode;

  00301	8b 7d d0	 mov	 edi, DWORD PTR ret$1$[rbp-112]
$done$63917:

; 429  : 
; 430  :  done:
; 431  :     Py_CLEAR(stringobj);

  00304	4c 8b 4d e0	 mov	 r9, QWORD PTR stringobj$[rbp-112]
  00308	4d 85 c9	 test	 r9, r9
  0030b	74 36		 je	 SHORT $LN3@fileio_ini
  0030d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@LJPPJMDP@fileio_init?$AA@
  0031b	41 b8 af 01 00
	00		 mov	 r8d, 431		; 000001afH
  00321	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00329	e8 00 00 00 00	 call	 _PyParallel_Guard
  0032e	85 c0		 test	 eax, eax
  00330	75 11		 jne	 SHORT $LN3@fileio_ini
  00332	48 8b 4d e0	 mov	 rcx, QWORD PTR stringobj$[rbp-112]
  00336	48 c7 45 e0 00
	00 00 00	 mov	 QWORD PTR stringobj$[rbp-112], 0
  0033e	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@fileio_ini:

; 432  :     return ret;

  00343	8b c7		 mov	 eax, edi
  00345	e9 65 01 00 00	 jmp	 $LN62@fileio_ini
$LN24@fileio_ini:

; 351  :     }
; 352  :     else {
; 353  :         self->closefd = 1;

  0034a	83 c9 40	 or	 ecx, 64			; 00000040H

; 354  :         if (!closefd) {

  0034d	83 7d 40 00	 cmp	 DWORD PTR closefd$[rbp-112], 0
  00351	89 4b 64	 mov	 DWORD PTR [rbx+100], ecx
  00354	75 0c		 jne	 SHORT $LN21@fileio_ini

; 355  :             PyErr_SetString(PyExc_ValueError,
; 356  :                 "Cannot use closefd=False with file name");

  00356	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@

; 357  :             goto error;

  0035d	e9 08 01 00 00	 jmp	 $LN78@fileio_ini
$LN21@fileio_ini:

; 358  :         }
; 359  : 
; 360  :         errno = 0;

  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00368	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 361  :         if (opener == Py_None) {

  0036e	48 8b 4d f8	 mov	 rcx, QWORD PTR opener$[rbp-112]
  00372	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00379	48 3b c8	 cmp	 rcx, rax
  0037c	75 41		 jne	 SHORT $LN20@fileio_ini

; 362  :             Py_BEGIN_ALLOW_THREADS

  0037e	e8 00 00 00 00	 call	 PyEval_SaveThread

; 363  : #ifdef MS_WINDOWS
; 364  :             if (widename != NULL)
; 365  :                 self->fd = _wopen(widename, flags, 0666);

  00383	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00389	8b d7		 mov	 edx, edi
  0038b	48 8b f0	 mov	 rsi, rax
  0038e	4d 85 f6	 test	 r14, r14
  00391	74 16		 je	 SHORT $LN19@fileio_ini
  00393	49 8b ce	 mov	 rcx, r14
  00396	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen

; 369  :             Py_END_ALLOW_THREADS

  0039c	48 8b ce	 mov	 rcx, rsi
  0039f	89 43 60	 mov	 DWORD PTR [rbx+96], eax
  003a2	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 370  :         } else {

  003a7	eb 73		 jmp	 SHORT $LN14@fileio_ini
$LN19@fileio_ini:

; 366  :             else
; 367  : #endif
; 368  :                 self->fd = open(name, flags, 0666);

  003a9	49 8b cc	 mov	 rcx, r12
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open

; 369  :             Py_END_ALLOW_THREADS

  003b2	48 8b ce	 mov	 rcx, rsi
  003b5	89 43 60	 mov	 DWORD PTR [rbx+96], eax
  003b8	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 370  :         } else {

  003bd	eb 5d		 jmp	 SHORT $LN14@fileio_ini
$LN20@fileio_ini:

; 371  :             PyObject *fdobj = PyObject_CallFunction(
; 372  :                                   opener, "Oi", nameobj, flags);

  003bf	4c 8b 45 d8	 mov	 r8, QWORD PTR nameobj$[rbp-112]
  003c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  003ca	44 8b cf	 mov	 r9d, edi
  003cd	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  003d2	48 8b f8	 mov	 rdi, rax

; 373  :             if (fdobj == NULL)

  003d5	48 85 c0	 test	 rax, rax
  003d8	0f 84 98 00 00
	00		 je	 $error$63865

; 374  :                 goto error;
; 375  :             if (!PyLong_Check(fdobj)) {

  003de	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  003e2	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H

; 376  :                 Py_DECREF(fdobj);

  003ec	48 8b c8	 mov	 rcx, rax
  003ef	75 15		 jne	 SHORT $LN15@fileio_ini
  003f1	e8 00 00 00 00	 call	 _Py_DecRef

; 377  :                 PyErr_SetString(PyExc_TypeError,
; 378  :                         "expected integer from opener");

  003f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@

; 379  :                 goto error;

  00404	eb 6b		 jmp	 SHORT $LN80@fileio_ini
$LN15@fileio_ini:

; 380  :             }
; 381  : 
; 382  :             self->fd = _PyLong_AsInt(fdobj);

  00406	e8 00 00 00 00	 call	 _PyLong_AsInt

; 383  :             Py_DECREF(fdobj);

  0040b	48 8b cf	 mov	 rcx, rdi
  0040e	89 43 60	 mov	 DWORD PTR [rbx+96], eax
  00411	e8 00 00 00 00	 call	 _Py_DecRef

; 384  :             if (self->fd == -1) {

  00416	83 7b 60 ff	 cmp	 DWORD PTR [rbx+96], -1
  0041a	74 5a		 je	 SHORT $error$63865
$LN14@fileio_ini:

; 385  :                 goto error;
; 386  :             }
; 387  :         }
; 388  : 
; 389  :         fd_is_own = 1;
; 390  :         if (self->fd < 0) {

  0041c	83 7b 60 00	 cmp	 DWORD PTR [rbx+96], 0
  00420	c7 45 58 01 00
	00 00		 mov	 DWORD PTR fd_is_own$1$[rbp-112], 1
  00427	0f 8d 72 fe ff
	ff		 jge	 $LN13@fileio_ini

; 391  : #ifdef MS_WINDOWS
; 392  :             if (widename != NULL)
; 393  :                 PyErr_SetFromErrnoWithFilenameObject(PyExc_IOError, nameobj);

  0042d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00434	4d 85 f6	 test	 r14, r14
  00437	74 0b		 je	 SHORT $LN12@fileio_ini
  00439	48 8b 55 d8	 mov	 rdx, QWORD PTR nameobj$[rbp-112]
  0043d	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilenameObject

; 394  :             else

  00442	eb 32		 jmp	 SHORT $error$63865
$LN12@fileio_ini:

; 395  : #endif
; 396  :                 PyErr_SetFromErrnoWithFilename(PyExc_IOError, name);

  00444	49 8b d4	 mov	 rdx, r12
  00447	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename

; 397  :             goto error;

  0044c	eb 28		 jmp	 SHORT $error$63865
$LN30@fileio_ini:

; 324  :             break;
; 325  :         default:
; 326  :             PyErr_Format(PyExc_ValueError,
; 327  :                          "invalid mode: %.200s", mode);

  0044e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00455	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@
  0045c	e8 00 00 00 00	 call	 PyErr_Format

; 328  :             goto error;

  00461	eb 13		 jmp	 SHORT $error$63865
$bad_mode$63863:

; 285  :             bad_mode:
; 286  :                 PyErr_SetString(PyExc_ValueError,
; 287  :                                 "Must have exactly one of create/read/write/append "
; 288  :                                 "mode and at most one plus");

  00463	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@
$LN78@fileio_ini:
  0046a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
$LN80@fileio_ini:
  00471	e8 00 00 00 00	 call	 PyErr_SetString
$error$63865:

; 419  :     }
; 420  : 
; 421  :     goto done;
; 422  : 
; 423  :  error:
; 424  :     ret = -1;

  00476	83 cf ff	 or	 edi, -1

; 425  :     if (!fd_is_own)

  00479	83 7d 58 00	 cmp	 DWORD PTR fd_is_own$1$[rbp-112], 0
  0047d	75 03		 jne	 SHORT $LN6@fileio_ini

; 426  :         self->fd = -1;

  0047f	89 7b 60	 mov	 DWORD PTR [rbx+96], edi
$LN6@fileio_ini:

; 427  :     if (self->fd >= 0)

  00482	83 7b 60 00	 cmp	 DWORD PTR [rbx+96], 0
  00486	0f 8c 78 fe ff
	ff		 jl	 $done$63917

; 428  :         internal_close(self);

  0048c	48 8b cb	 mov	 rcx, rbx
  0048f	e8 00 00 00 00	 call	 internal_close
  00494	e9 6b fe ff ff	 jmp	 $done$63917
$LN55@fileio_ini:

; 244  :         PyErr_SetString(PyExc_TypeError,
; 245  :                         "integer argument expected, got float");

  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
$LN77@fileio_ini:
  004a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
$LN76@fileio_ini:
  004a7	e8 00 00 00 00	 call	 PyErr_SetString
$LN75@fileio_ini:

; 246  :         return -1;

  004ac	83 c8 ff	 or	 eax, -1
$LN62@fileio_ini:

; 433  : }

  004af	48 8b 9c 24 b8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+184]
  004b7	48 83 c4 70	 add	 rsp, 112		; 00000070H
  004bb	41 5f		 pop	 r15
  004bd	41 5e		 pop	 r14
  004bf	41 5d		 pop	 r13
  004c1	41 5c		 pop	 r12
  004c3	5f		 pop	 rdi
  004c4	5e		 pop	 rsi
  004c5	5d		 pop	 rbp
  004c6	c3		 ret	 0
  004c7	90		 npad	 1
$LN71@fileio_ini:
  004c8	00 00 00 00	 DD	 $LN32@fileio_ini
  004cc	00 00 00 00	 DD	 $LN35@fileio_ini
  004d0	00 00 00 00	 DD	 $LN42@fileio_ini
  004d4	00 00 00 00	 DD	 $LN39@fileio_ini
  004d8	00 00 00 00	 DD	 $LN37@fileio_ini
  004dc	00 00 00 00	 DD	 $LN41@fileio_ini
  004e0	00 00 00 00	 DD	 $LN30@fileio_ini
$LN70@fileio_ini:
  004e4	00		 DB	 0
  004e5	06		 DB	 6
  004e6	06		 DB	 6
  004e7	06		 DB	 6
  004e8	06		 DB	 6
  004e9	06		 DB	 6
  004ea	06		 DB	 6
  004eb	06		 DB	 6
  004ec	06		 DB	 6
  004ed	06		 DB	 6
  004ee	06		 DB	 6
  004ef	06		 DB	 6
  004f0	06		 DB	 6
  004f1	06		 DB	 6
  004f2	06		 DB	 6
  004f3	06		 DB	 6
  004f4	06		 DB	 6
  004f5	06		 DB	 6
  004f6	06		 DB	 6
  004f7	06		 DB	 6
  004f8	06		 DB	 6
  004f9	06		 DB	 6
  004fa	06		 DB	 6
  004fb	06		 DB	 6
  004fc	06		 DB	 6
  004fd	06		 DB	 6
  004fe	06		 DB	 6
  004ff	06		 DB	 6
  00500	06		 DB	 6
  00501	06		 DB	 6
  00502	06		 DB	 6
  00503	06		 DB	 6
  00504	06		 DB	 6
  00505	06		 DB	 6
  00506	06		 DB	 6
  00507	06		 DB	 6
  00508	06		 DB	 6
  00509	06		 DB	 6
  0050a	06		 DB	 6
  0050b	06		 DB	 6
  0050c	06		 DB	 6
  0050d	06		 DB	 6
  0050e	06		 DB	 6
  0050f	06		 DB	 6
  00510	06		 DB	 6
  00511	06		 DB	 6
  00512	06		 DB	 6
  00513	06		 DB	 6
  00514	06		 DB	 6
  00515	06		 DB	 6
  00516	06		 DB	 6
  00517	06		 DB	 6
  00518	06		 DB	 6
  00519	06		 DB	 6
  0051a	01		 DB	 1
  0051b	02		 DB	 2
  0051c	06		 DB	 6
  0051d	06		 DB	 6
  0051e	06		 DB	 6
  0051f	06		 DB	 6
  00520	06		 DB	 6
  00521	06		 DB	 6
  00522	06		 DB	 6
  00523	06		 DB	 6
  00524	06		 DB	 6
  00525	06		 DB	 6
  00526	06		 DB	 6
  00527	06		 DB	 6
  00528	06		 DB	 6
  00529	06		 DB	 6
  0052a	06		 DB	 6
  0052b	03		 DB	 3
  0052c	06		 DB	 6
  0052d	06		 DB	 6
  0052e	06		 DB	 6
  0052f	06		 DB	 6
  00530	04		 DB	 4
  00531	05		 DB	 5
fileio_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_seekable DD imagerel fileio_seekable
	DD	imagerel fileio_seekable+109
	DD	imagerel $unwind$fileio_seekable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_seekable DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT fileio_seekable
_TEXT	SEGMENT
self$ = 48
fileio_seekable PROC					; COMDAT

; 503  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 504  :     if (self->fd < 0)

  00009	8b 49 60	 mov	 ecx, DWORD PTR [rcx+96]
  0000c	85 c9		 test	 ecx, ecx
  0000e	79 0a		 jns	 SHORT $LN4@fileio_see@2

; 517  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	e9 00 00 00 00	 jmp	 err_closed
$LN4@fileio_see@2:

; 505  :         return err_closed();
; 506  :     if (self->seekable < 0) {

  0001a	8b 43 64	 mov	 eax, DWORD PTR [rbx+100]
  0001d	83 e0 f0	 and	 eax, -16
  00020	c1 e0 1a	 shl	 eax, 26
  00023	85 c0		 test	 eax, eax
  00025	79 33		 jns	 SHORT $LN1@fileio_see@2

; 507  :         PyObject *pos = portable_lseek(self->fd, NULL, SEEK_CUR);

  00027	33 d2		 xor	 edx, edx
  00029	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  0002d	e8 00 00 00 00	 call	 portable_lseek

; 508  :         if (pos == NULL) {

  00032	48 85 c0	 test	 rax, rax
  00035	75 0b		 jne	 SHORT $LN2@fileio_see@2

; 509  :             PyErr_Clear();

  00037	e8 00 00 00 00	 call	 PyErr_Clear

; 510  :             self->seekable = 0;

  0003c	83 63 64 cf	 and	 DWORD PTR [rbx+100], -49 ; ffffffffffffffcfH

; 511  :         } else {

  00040	eb 18		 jmp	 SHORT $LN1@fileio_see@2
$LN2@fileio_see@2:

; 512  :             Py_DECREF(pos);

  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 _Py_DecRef

; 513  :             self->seekable = 1;

  0004a	44 8b 5b 64	 mov	 r11d, DWORD PTR [rbx+100]
  0004e	41 83 e3 df	 and	 r11d, -33		; ffffffffffffffdfH
  00052	41 83 cb 10	 or	 r11d, 16
  00056	44 89 5b 64	 mov	 DWORD PTR [rbx+100], r11d
$LN1@fileio_see@2:

; 514  :         }
; 515  :     }
; 516  :     return PyBool_FromLong((long) self->seekable);

  0005a	8b 4b 64	 mov	 ecx, DWORD PTR [rbx+100]
  0005d	c1 e1 1a	 shl	 ecx, 26
  00060	c1 f9 1e	 sar	 ecx, 30

; 517  : }

  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5b		 pop	 rbx
  00068	e9 00 00 00 00	 jmp	 PyBool_FromLong
fileio_seekable ENDP
_TEXT	ENDS
END
