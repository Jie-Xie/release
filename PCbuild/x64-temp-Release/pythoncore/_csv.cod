; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04IFNPAAGM@_csv?$AA@			; `string'
PUBLIC	??_C@_0BB@BNOLCBNI@field_size_limit?$AA@	; `string'
PUBLIC	??_C@_0M@HDPFACFG@get_dialect?$AA@		; `string'
PUBLIC	??_C@_0BD@BDAIJALH@unregister_dialect?$AA@	; `string'
PUBLIC	??_C@_0BB@LIENFODA@register_dialect?$AA@	; `string'
PUBLIC	??_C@_0O@OHENEOBL@list_dialects?$AA@		; `string'
PUBLIC	??_C@_06CONMFCKG@writer?$AA@			; `string'
PUBLIC	??_C@_06CFOFDHM@reader?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_0M@DNIHIKFD@_csv?4writer?$AA@		; `string'
PUBLIC	??_C@_09OMPEDDGA@writerows?$AA@			; `string'
PUBLIC	??_C@_08FOMNGGEH@writerow?$AA@			; `string'
PUBLIC	??_C@_0M@BBAFILIJ@_csv?4reader?$AA@		; `string'
PUBLIC	??_C@_08MGGOMFL@line_num?$AA@			; `string'
PUBLIC	??_C@_0N@HGLADAPF@_csv?4Dialect?$AA@		; `string'
PUBLIC	??_C@_07ECACAPOI@dialect?$AA@			; `string'
PUBLIC	??_C@_07JPFMBGFH@quoting?$AA@			; `string'
PUBLIC	??_C@_09ICADEPGB@quotechar?$AA@			; `string'
PUBLIC	??_C@_0P@JHFLIELP@lineterminator?$AA@		; `string'
PUBLIC	??_C@_0L@BBGHHBGG@escapechar?$AA@		; `string'
PUBLIC	??_C@_09NMOHGHGG@delimiter?$AA@			; `string'
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_0M@IJBGDELB@doublequote?$AA@		; `string'
PUBLIC	??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@	; `string'
PUBLIC	??_C@_0L@JKGHGFCE@QUOTE_NONE?$AA@		; `string'
PUBLIC	??_C@_0BB@FBNDDEOM@QUOTE_NONNUMERIC?$AA@	; `string'
PUBLIC	??_C@_09LGHDOLBD@QUOTE_ALL?$AA@			; `string'
PUBLIC	??_C@_0O@JIFNDNHJ@QUOTE_MINIMAL?$AA@		; `string'
EXTRN	PyObject_SelfIter:PROC
_BSS	SEGMENT
Reader_methods DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_04IFNPAAGM@_csv?$AA@
CONST	SEGMENT
??_C@_04IFNPAAGM@_csv?$AA@ DB '_csv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BNOLCBNI@field_size_limit?$AA@
CONST	SEGMENT
??_C@_0BB@BNOLCBNI@field_size_limit?$AA@ DB 'field_size_limit', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HDPFACFG@get_dialect?$AA@
CONST	SEGMENT
??_C@_0M@HDPFACFG@get_dialect?$AA@ DB 'get_dialect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BDAIJALH@unregister_dialect?$AA@
CONST	SEGMENT
??_C@_0BD@BDAIJALH@unregister_dialect?$AA@ DB 'unregister_dialect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LIENFODA@register_dialect?$AA@
CONST	SEGMENT
??_C@_0BB@LIENFODA@register_dialect?$AA@ DB 'register_dialect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OHENEOBL@list_dialects?$AA@
CONST	SEGMENT
??_C@_0O@OHENEOBL@list_dialects?$AA@ DB 'list_dialects', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CONMFCKG@writer?$AA@
CONST	SEGMENT
??_C@_06CONMFCKG@writer?$AA@ DB 'writer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06CFOFDHM@reader?$AA@
CONST	SEGMENT
??_C@_06CFOFDHM@reader?$AA@ DB 'reader', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_write@?1??csv_writer@@9@9 DQ 0000000000000000H	; `csv_writer'::`2'::PyId_write
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DNIHIKFD@_csv?4writer?$AA@
CONST	SEGMENT
??_C@_0M@DNIHIKFD@_csv?4writer?$AA@ DB '_csv.writer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMPEDDGA@writerows?$AA@
CONST	SEGMENT
??_C@_09OMPEDDGA@writerows?$AA@ DB 'writerows', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FOMNGGEH@writerow?$AA@
CONST	SEGMENT
??_C@_08FOMNGGEH@writerow?$AA@ DB 'writerow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BBAFILIJ@_csv?4reader?$AA@
CONST	SEGMENT
??_C@_0M@BBAFILIJ@_csv?4reader?$AA@ DB '_csv.reader', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MGGOMFL@line_num?$AA@
CONST	SEGMENT
??_C@_08MGGOMFL@line_num?$AA@ DB 'line_num', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGLADAPF@_csv?4Dialect?$AA@
CONST	SEGMENT
??_C@_0N@HGLADAPF@_csv?4Dialect?$AA@ DB '_csv.Dialect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECACAPOI@dialect?$AA@
CONST	SEGMENT
??_C@_07ECACAPOI@dialect?$AA@ DB 'dialect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JPFMBGFH@quoting?$AA@
CONST	SEGMENT
??_C@_07JPFMBGFH@quoting?$AA@ DB 'quoting', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICADEPGB@quotechar?$AA@
CONST	SEGMENT
??_C@_09ICADEPGB@quotechar?$AA@ DB 'quotechar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JHFLIELP@lineterminator?$AA@
CONST	SEGMENT
??_C@_0P@JHFLIELP@lineterminator?$AA@ DB 'lineterminator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BBGHHBGG@escapechar?$AA@
CONST	SEGMENT
??_C@_0L@BBGHHBGG@escapechar?$AA@ DB 'escapechar', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NMOHGHGG@delimiter?$AA@
CONST	SEGMENT
??_C@_09NMOHGHGG@delimiter?$AA@ DB 'delimiter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IJBGDELB@doublequote?$AA@
CONST	SEGMENT
??_C@_0M@IJBGDELB@doublequote?$AA@ DB 'doublequote', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@
CONST	SEGMENT
??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@ DB 'skipinitialspace', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
quote_styles DD	00H
	ORG $+4
	DQ	FLAT:??_C@_0O@JIFNDNHJ@QUOTE_MINIMAL?$AA@
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_09LGHDOLBD@QUOTE_ALL?$AA@
	DD	02H
	ORG $+4
	DQ	FLAT:??_C@_0BB@FBNDDEOM@QUOTE_NONNUMERIC?$AA@
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0L@JKGHGFCE@QUOTE_NONE?$AA@
	DD	00H
	ORG $+4
	ORG $+8
Dialect_memberlist DQ FLAT:??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0M@IJBGDELB@doublequote?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06OLFOGHEN@strict?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000084H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
Dialect_getsetlist DQ FLAT:??_C@_09NMOHGHGG@delimiter?$AA@
	DQ	FLAT:Dialect_get_delimiter
	ORG $+24
	DQ	FLAT:??_C@_0L@BBGHHBGG@escapechar?$AA@
	DQ	FLAT:Dialect_get_escapechar
	ORG $+24
	DQ	FLAT:??_C@_0P@JHFLIELP@lineterminator?$AA@
	DQ	FLAT:Dialect_get_lineterminator
	ORG $+24
	DQ	FLAT:??_C@_09ICADEPGB@quotechar?$AA@
	DQ	FLAT:Dialect_get_quotechar
	ORG $+24
	DQ	FLAT:??_C@_07JPFMBGFH@quoting?$AA@
	DQ	FLAT:Dialect_get_quoting
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
dialect_kws DQ	FLAT:??_C@_07ECACAPOI@dialect?$AA@
	DQ	FLAT:??_C@_09NMOHGHGG@delimiter?$AA@
	DQ	FLAT:??_C@_0M@IJBGDELB@doublequote?$AA@
	DQ	FLAT:??_C@_0L@BBGHHBGG@escapechar?$AA@
	DQ	FLAT:??_C@_0P@JHFLIELP@lineterminator?$AA@
	DQ	FLAT:??_C@_09ICADEPGB@quotechar?$AA@
	DQ	FLAT:??_C@_07JPFMBGFH@quoting?$AA@
	DQ	FLAT:??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@
	DQ	FLAT:??_C@_06OLFOGHEN@strict?$AA@
	DQ	0000000000000000H
Dialect_Type_doc DB 'CSV dialect', 0aH, 0aH, 'The Dialect type records CS'
	DB	'V parsing and generation options.', 0aH, 00H
	ORG $+5
Dialect_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@HGLADAPF@_csv?4Dialect?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:Dialect_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:Dialect_Type_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Dialect_memberlist
	DQ	FLAT:Dialect_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:dialect_new
	DQ	0000000000000000H
	ORG $+64
Reader_Type_doc DB 'CSV reader', 0aH, 0aH, 'Reader objects are responsibl'
	DB	'e for reading and parsing tabular data', 0aH, 'in CSV format.'
	DB	0aH, 00H
Reader_memberlist DQ FLAT:??_C@_07ECACAPOI@dialect?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MGGOMFL@line_num?$AA@
	DD	0cH
	ORG $+4
	DQ	000000000000009cH
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Reader_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@BBAFILIJ@_csv?4reader?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:Reader_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Reader_Type_doc
	DQ	FLAT:Reader_traverse
	DQ	FLAT:Reader_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:Reader_iternext
	DQ	FLAT:Reader_methods
	DQ	FLAT:Reader_memberlist
	DQ	0000000000000000H
	ORG $+136
csv_writerow_doc DB 'writerow(sequence)', 0aH, 0aH, 'Construct and write '
	DB	'a CSV record from a sequence of fields.  Non-string', 0aH, 'e'
	DB	'lements will be converted to string.', 00H
	ORG $+14
csv_writerows_doc DB 'writerows(sequence of sequences)', 0aH, 0aH, 'Const'
	DB	'ruct and write a series of sequences to a csv file.  Non-stri'
	DB	'ng', 0aH, 'elements will be converted to string.', 00H
	ORG $+3
Writer_methods DQ FLAT:??_C@_08FOMNGGEH@writerow?$AA@
	DQ	FLAT:csv_writerow
	DD	08H
	ORG $+4
	DQ	FLAT:csv_writerow_doc
	DQ	FLAT:??_C@_09OMPEDDGA@writerows?$AA@
	DQ	FLAT:csv_writerows
	DD	08H
	ORG $+4
	DQ	FLAT:csv_writerows_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
Writer_memberlist DQ FLAT:??_C@_07ECACAPOI@dialect?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
Writer_Type_doc DB 'CSV writer', 0aH, 0aH, 'Writer objects are responsibl'
	DB	'e for generating tabular data', 0aH, 'in CSV format from sequ'
	DB	'ence input.', 0aH, 00H
	ORG $+5
Writer_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@DNIHIKFD@_csv?4writer?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:Writer_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:Writer_Type_doc
	DQ	FLAT:Writer_traverse
	DQ	FLAT:Writer_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:Writer_methods
	DQ	FLAT:Writer_memberlist
	DQ	0000000000000000H
	ORG $+136
csv_module_doc DB 'CSV parsing and writing.', 0aH, 0aH, 'This module prov'
	DB	'ides classes that assist in the reading and writing', 0aH, 'o'
	DB	'f Comma Separated Value (CSV) files, and implements the inter'
	DB	'face', 0aH, 'described by PEP 305.  Although many CSV files a'
	DB	're simple to parse,', 0aH, 'the format is not formally define'
	DB	'd by a stable specification and', 0aH, 'is subtle enough that'
	DB	' parsing lines of a CSV file with something', 0aH, 'like line'
	DB	'.split(",") is bound to fail.  The module supports three', 0aH
	DB	'basic APIs: reading, writing, and registration of dialects.', 0aH
	DB	0aH, 0aH, 'DIALECT REGISTRATION:', 0aH, 0aH, 'Readers and writ'
	DB	'ers support a dialect argument, which is a convenient', 0aH, 'h'
	DB	'andle on a group of settings.  When the dialect argument is a'
	DB	' string,', 0aH, 'it identifies one of the dialects previously'
	DB	' registered with the module.', 0aH, 'If it is a class or inst'
	DB	'ance, the attributes of the argument are used as', 0aH, 'the '
	DB	'settings for the reader or writer:', 0aH, 0aH, '    class exc'
	DB	'el:', 0aH, '        delimiter = '',''', 0aH, '        quotech'
	DB	'ar = ''"''', 0aH, '        escapechar = None', 0aH, '        '
	DB	'doublequote = True', 0aH, '        skipinitialspace = False', 0aH
	DB	'        lineterminator = ''\r\n''', 0aH, '        quoting = Q'
	DB	'UOTE_MINIMAL', 0aH, 0aH, 'SETTINGS:', 0aH, 0aH, '    * quotec'
	DB	'har - specifies a one-character string to use as the ', 0aH, ' '
	DB	'       quoting character.  It defaults to ''"''.', 0aH, '    '
	DB	'* delimiter - specifies a one-character string to use as the '
	DB	0aH, '        field separator.  It defaults to '',''.', 0aH, ' '
	DB	'   * skipinitialspace - specifies how to interpret whitespace'
	DB	' which', 0aH, '        immediately follows a delimiter.  It d'
	DB	'efaults to False, which', 0aH, '        means that whitespace'
	DB	' immediately following a delimiter is part', 0aH, '        of'
	DB	' the following field.', 0aH, '    * lineterminator -  specifi'
	DB	'es the character sequence which should ', 0aH, '        termi'
	DB	'nate rows.', 0aH, '    * quoting - controls when quotes shoul'
	DB	'd be generated by the writer.', 0aH, '        It can take on '
	DB	'any of the following module constants:', 0aH, 0aH, '        c'
	DB	'sv.QUOTE_MINIMAL means only when required, for example, when '
	DB	'a', 0aH, '            field contains either the quotechar or '
	DB	'the delimiter', 0aH, '        csv.QUOTE_ALL means that quotes'
	DB	' are always placed around fields.', 0aH, '        csv.QUOTE_N'
	DB	'ONNUMERIC means that quotes are always placed around', 0aH, ' '
	DB	'           fields which do not parse as integers or floating '
	DB	'point', 0aH, '            numbers.', 0aH, '        csv.QUOTE_'
	DB	'NONE means that quotes are never placed around fields.', 0aH, ' '
	DB	'   * escapechar - specifies a one-character string used to es'
	DB	'cape ', 0aH, '        the delimiter when quoting is set to QU'
	DB	'OTE_NONE.', 0aH, '    * doublequote - controls the handling o'
	DB	'f quotes inside fields.  When', 0aH, '        True, two conse'
	DB	'cutive quotes are interpreted as one during read,', 0aH, '   '
	DB	'     and when writing, each quote character embedded in the d'
	DB	'ata is', 0aH, '        written as two quotes', 0aH, 00H
	ORG $+12
csv_reader_doc DB '    csv_reader = reader(iterable [, dialect=''excel'']'
	DB	0aH, '                        [optional keyword args])', 0aH, ' '
	DB	'   for row in csv_reader:', 0aH, '        process(row)', 0aH, 0aH
	DB	'The "iterable" argument can be any object that returns a line'
	DB	0aH, 'of input for each iteration, such as a file object or a '
	DB	'list.  The', 0aH, 'optional "dialect" parameter is discussed '
	DB	'below.  The function', 0aH, 'also accepts optional keyword ar'
	DB	'guments which override settings', 0aH, 'provided by the diale'
	DB	'ct.', 0aH, 0aH, 'The returned object is an iterator.  Each it'
	DB	'eration returns a row', 0aH, 'of the CSV file (which can span'
	DB	' multiple input lines):', 0aH, 00H
	ORG $+5
csv_writer_doc DB '    csv_writer = csv.writer(fileobj [, dialect=''excel'
	DB	''']', 0aH, '                            [optional keyword arg'
	DB	's])', 0aH, '    for row in sequence:', 0aH, '        csv_writ'
	DB	'er.writerow(row)', 0aH, 0aH, '    [or]', 0aH, 0aH, '    csv_w'
	DB	'riter = csv.writer(fileobj [, dialect=''excel'']', 0aH, '    '
	DB	'                        [optional keyword args])', 0aH, '    '
	DB	'csv_writer.writerows(rows)', 0aH, 0aH, 'The "fileobj" argumen'
	DB	't can be any object that supports the file API.', 0aH, 00H
	ORG $+11
csv_list_dialects_doc DB 'Return a list of all know dialect names.', 0aH, ' '
	DB	'   names = csv.list_dialects()', 00H
	ORG $+7
csv_get_dialect_doc DB 'Return the dialect instance associated with name.'
	DB	0aH, '    dialect = csv.get_dialect(name)', 00H
	ORG $+10
csv_register_dialect_doc DB 'Create a mapping from a string name to a dia'
	DB	'lect class.', 0aH, '    dialect = csv.register_dialect(name, '
	DB	'dialect)', 00H
	ORG $+6
csv_unregister_dialect_doc DB 'Delete the name/dialect mapping associated'
	DB	' with a string name.', 0aH, '    csv.unregister_dialect(name)'
	DB	00H
csv_field_size_limit_doc DB 'Sets an upper limit on parsed fields.', 0aH, ' '
	DB	'   csv.field_size_limit([limit])', 0aH, 0aH, 'Returns old lim'
	DB	'it. If limit is not given, no new limit is set and', 0aH, 'th'
	DB	'e old limit is returned', 00H
	ORG $+11
csv_methods DQ	FLAT:??_C@_06CFOFDHM@reader?$AA@
	DQ	FLAT:csv_reader
	DD	03H
	ORG $+4
	DQ	FLAT:csv_reader_doc
	DQ	FLAT:??_C@_06CONMFCKG@writer?$AA@
	DQ	FLAT:csv_writer
	DD	03H
	ORG $+4
	DQ	FLAT:csv_writer_doc
	DQ	FLAT:??_C@_0O@OHENEOBL@list_dialects?$AA@
	DQ	FLAT:csv_list_dialects
	DD	04H
	ORG $+4
	DQ	FLAT:csv_list_dialects_doc
	DQ	FLAT:??_C@_0BB@LIENFODA@register_dialect?$AA@
	DQ	FLAT:csv_register_dialect
	DD	03H
	ORG $+4
	DQ	FLAT:csv_register_dialect_doc
	DQ	FLAT:??_C@_0BD@BDAIJALH@unregister_dialect?$AA@
	DQ	FLAT:csv_unregister_dialect
	DD	08H
	ORG $+4
	DQ	FLAT:csv_unregister_dialect_doc
	DQ	FLAT:??_C@_0M@HDPFACFG@get_dialect?$AA@
	DQ	FLAT:csv_get_dialect
	DD	08H
	ORG $+4
	DQ	FLAT:csv_get_dialect_doc
	DQ	FLAT:??_C@_0BB@BNOLCBNI@field_size_limit?$AA@
	DQ	FLAT:csv_field_size_limit
	DD	01H
	ORG $+4
	DQ	FLAT:csv_field_size_limit_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_csvmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04IFNPAAGM@_csv?$AA@
	DQ	FLAT:csv_module_doc
	DQ	0000000000000018H
	DQ	FLAT:csv_methods
	DQ	0000000000000000H
	DQ	FLAT:_csv_traverse
	DQ	FLAT:_csv_clear
	DQ	FLAT:_csv_free
_DATA	ENDS
;	COMDAT ??_C@_0L@JKGHGFCE@QUOTE_NONE?$AA@
CONST	SEGMENT
??_C@_0L@JKGHGFCE@QUOTE_NONE?$AA@ DB 'QUOTE_NONE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FBNDDEOM@QUOTE_NONNUMERIC?$AA@
CONST	SEGMENT
??_C@_0BB@FBNDDEOM@QUOTE_NONNUMERIC?$AA@ DB 'QUOTE_NONNUMERIC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LGHDOLBD@QUOTE_ALL?$AA@
CONST	SEGMENT
??_C@_09LGHDOLBD@QUOTE_ALL?$AA@ DB 'QUOTE_ALL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JIFNDNHJ@QUOTE_MINIMAL?$AA@
CONST	SEGMENT
??_C@_0O@JIFNDNHJ@QUOTE_MINIMAL?$AA@ DB 'QUOTE_MINIMAL', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LJCEHMDB@_csv_clear?$AA@		; `string'
PUBLIC	??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@	; `string'
EXTRN	PyModule_GetState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_csv_clear DD imagerel _csv_clear
	DD	imagerel _csv_clear+439
	DD	imagerel $unwind$_csv_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_csv_clear DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0L@LJCEHMDB@_csv_clear?$AA@
CONST	SEGMENT
??_C@_0L@LJCEHMDB@_csv_clear?$AA@ DB '_csv_clear', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
CONST	SEGMENT
??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@ DB '..\Modules\_csv.c', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT _csv_clear
_TEXT	SEGMENT
m$ = 64
_csv_clear PROC						; COMDAT

; 27   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 28   :     Py_CLEAR(_csvstate(m)->error_obj);

  0000d	e8 00 00 00 00	 call	 PyModule_GetState
  00012	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00016	0f 84 af 00 00
	00		 je	 $LN7@csv_clear
  0001c	48 8b cf	 mov	 rcx, rdi
  0001f	e8 00 00 00 00	 call	 PyModule_GetState
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LJCEHMDB@_csv_clear?$AA@
  00032	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00035	41 b8 1c 00 00
	00		 mov	 r8d, 28
  0003b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00043	e8 00 00 00 00	 call	 _PyParallel_Guard
  00048	85 c0		 test	 eax, eax
  0004a	75 7f		 jne	 SHORT $LN7@csv_clear
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	e8 00 00 00 00	 call	 PyModule_GetState
  00054	48 8b cf	 mov	 rcx, rdi
  00057	48 8b 18	 mov	 rbx, QWORD PTR [rax]
  0005a	e8 00 00 00 00	 call	 PyModule_GetState
  0005f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00066	e8 00 00 00 00	 call	 _Py_PXCTX
  0006b	85 c0		 test	 eax, eax
  0006d	75 5c		 jne	 SHORT $LN7@csv_clear
  0006f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00073	a8 20		 test	 al, 32			; 00000020H
  00075	75 4c		 jne	 SHORT $LN15@csv_clear
  00077	84 c0		 test	 al, al
  00079	78 48		 js	 SHORT $LN15@csv_clear
  0007b	a8 02		 test	 al, 2
  0007d	75 4c		 jne	 SHORT $LN7@csv_clear
  0007f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00083	75 46		 jne	 SHORT $LN7@csv_clear
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00093	4c 8b cb	 mov	 r9, rbx
  00096	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0009c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	85 c0		 test	 eax, eax
  000ae	74 07		 je	 SHORT $LN20@csv_clear
  000b0	e8 00 00 00 00	 call	 _Px_Dealloc
  000b5	eb 14		 jmp	 SHORT $LN7@csv_clear
$LN20@csv_clear:
  000b7	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000bb	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000c1	eb 08		 jmp	 SHORT $LN7@csv_clear
$LN15@csv_clear:
  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 Px_DecRef
$LN7@csv_clear:

; 29   :     Py_CLEAR(_csvstate(m)->dialects);

  000cb	48 8b cf	 mov	 rcx, rdi
  000ce	e8 00 00 00 00	 call	 PyModule_GetState
  000d3	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d8	0f 84 cc 00 00
	00		 je	 $LN35@csv_clear
  000de	48 8b cf	 mov	 rcx, rdi
  000e1	e8 00 00 00 00	 call	 PyModule_GetState
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@LJCEHMDB@_csv_clear?$AA@
  000f4	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  000f8	41 b8 1d 00 00
	00		 mov	 r8d, 29
  000fe	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00106	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010b	85 c0		 test	 eax, eax
  0010d	0f 85 97 00 00
	00		 jne	 $LN35@csv_clear
  00113	48 8b cf	 mov	 rcx, rdi
  00116	e8 00 00 00 00	 call	 PyModule_GetState
  0011b	48 8b cf	 mov	 rcx, rdi
  0011e	48 8b 58 08	 mov	 rbx, QWORD PTR [rax+8]
  00122	e8 00 00 00 00	 call	 PyModule_GetState
  00127	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0012f	e8 00 00 00 00	 call	 _Py_PXCTX
  00134	85 c0		 test	 eax, eax
  00136	75 72		 jne	 SHORT $LN35@csv_clear
  00138	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0013c	a8 20		 test	 al, 32			; 00000020H
  0013e	75 62		 jne	 SHORT $LN26@csv_clear
  00140	84 c0		 test	 al, al
  00142	78 5e		 js	 SHORT $LN26@csv_clear
  00144	a8 02		 test	 al, 2
  00146	75 62		 jne	 SHORT $LN35@csv_clear
  00148	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0014c	75 5c		 jne	 SHORT $LN35@csv_clear
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0015c	4c 8b cb	 mov	 r9, rbx
  0015f	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00165	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0016d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00172	48 8b cb	 mov	 rcx, rbx
  00175	85 c0		 test	 eax, eax
  00177	74 12		 je	 SHORT $LN31@csv_clear
  00179	e8 00 00 00 00	 call	 _Px_Dealloc

; 30   :     return 0;

  0017e	33 c0		 xor	 eax, eax

; 31   : }

  00180	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00185	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00189	5f		 pop	 rdi
  0018a	c3		 ret	 0

; 29   :     Py_CLEAR(_csvstate(m)->dialects);

$LN31@csv_clear:
  0018b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018f	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 30   :     return 0;

  00195	33 c0		 xor	 eax, eax

; 31   : }

  00197	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0019c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001a0	5f		 pop	 rdi
  001a1	c3		 ret	 0

; 29   :     Py_CLEAR(_csvstate(m)->dialects);

$LN26@csv_clear:
  001a2	48 8b cb	 mov	 rcx, rbx
  001a5	e8 00 00 00 00	 call	 Px_DecRef
$LN35@csv_clear:

; 30   :     return 0;

  001aa	33 c0		 xor	 eax, eax

; 31   : }

  001ac	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b5	5f		 pop	 rdi
  001b6	c3		 ret	 0
_csv_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@IMOHCNMK@_csv_traverse?$AA@		; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_csv_traverse DD imagerel _csv_traverse
	DD	imagerel _csv_traverse+182
	DD	imagerel $unwind$_csv_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_csv_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0O@IMOHCNMK@_csv_traverse?$AA@
CONST	SEGMENT
??_C@_0O@IMOHCNMK@_csv_traverse?$AA@ DB '_csv_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _csv_traverse
_TEXT	SEGMENT
m$ = 48
visit$ = 56
arg$ = 64
_csv_traverse PROC					; COMDAT

; 35   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 36   :     Py_VISIT(_csvstate(m)->error_obj);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1a		 je	 SHORT $LN9@csv_traver
  00021	45 33 c9	 xor	 r9d, r9d
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@IMOHCNMK@_csv_traverse?$AA@
  00032	45 8d 41 24	 lea	 r8d, QWORD PTR [r9+36]
  00036	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@csv_traver:
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 PyModule_GetState
  00043	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00047	74 14		 je	 SHORT $LN11@csv_traver
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	e8 00 00 00 00	 call	 PyModule_GetState
  00051	48 8b d7	 mov	 rdx, rdi
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00057	ff d6		 call	 rsi
  00059	85 c0		 test	 eax, eax
  0005b	75 49		 jne	 SHORT $LN13@csv_traver
$LN11@csv_traver:

; 37   :     Py_VISIT(_csvstate(m)->dialects);

  0005d	e8 00 00 00 00	 call	 _Py_PXCTX
  00062	85 c0		 test	 eax, eax
  00064	74 1a		 je	 SHORT $LN3@csv_traver
  00066	45 33 c9	 xor	 r9d, r9d
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@IMOHCNMK@_csv_traverse?$AA@
  00077	45 8d 41 25	 lea	 r8d, QWORD PTR [r9+37]
  0007b	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@csv_traver:
  00080	48 8b cb	 mov	 rcx, rbx
  00083	e8 00 00 00 00	 call	 PyModule_GetState
  00088	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0008d	74 15		 je	 SHORT $LN5@csv_traver
  0008f	48 8b cb	 mov	 rcx, rbx
  00092	e8 00 00 00 00	 call	 PyModule_GetState
  00097	48 8b d7	 mov	 rdx, rdi
  0009a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0009e	ff d6		 call	 rsi
  000a0	85 c0		 test	 eax, eax
  000a2	75 02		 jne	 SHORT $LN13@csv_traver
$LN5@csv_traver:

; 38   :     return 0;

  000a4	33 c0		 xor	 eax, eax
$LN13@csv_traver:

; 39   : }

  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ab	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
_csv_traverse ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT _csv_free
_TEXT	SEGMENT
m$ = 8
_csv_free PROC						; COMDAT

; 44   :    _csv_clear((PyObject *)m);
; 45   : }

  00000	e9 00 00 00 00	 jmp	 _csv_clear
_csv_free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@DGBJMIAO@unknown?5dialect?$AA@	; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyState_FindModule:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_dialect_from_registry DD imagerel get_dialect_from_registry
	DD	imagerel get_dialect_from_registry+171
	DD	imagerel $unwind$get_dialect_from_registry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_dialect_from_registry DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BA@DGBJMIAO@unknown?5dialect?$AA@
CONST	SEGMENT
??_C@_0BA@DGBJMIAO@unknown?5dialect?$AA@ DB 'unknown dialect', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT get_dialect_from_registry
_TEXT	SEGMENT
name_obj$ = 64
get_dialect_from_registry PROC				; COMDAT

; 131  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 132  :     PyObject *dialect_obj;
; 133  : 
; 134  :     dialect_obj = PyDict_GetItem(_csvstate_global->dialects, name_obj);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00010	e8 00 00 00 00	 call	 PyState_FindModule
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	48 8b d3	 mov	 rdx, rbx
  00020	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00024	e8 00 00 00 00	 call	 PyDict_GetItem
  00029	48 8b d8	 mov	 rbx, rax

; 135  :     if (dialect_obj == NULL) {

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 36		 jne	 SHORT $LN3@get_dialec

; 136  :         if (!PyErr_Occurred())

  00031	e8 00 00 00 00	 call	 PyErr_Occurred
  00036	48 85 c0	 test	 rax, rax
  00039	75 67		 jne	 SHORT $LN10@get_dialec

; 137  :             PyErr_Format(_csvstate_global->error_obj, "unknown dialect");

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00042	e8 00 00 00 00	 call	 PyState_FindModule
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 PyModule_GetState
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DGBJMIAO@unknown?5dialect?$AA@
  00056	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00059	e8 00 00 00 00	 call	 PyErr_Format

; 141  :     return dialect_obj;

  0005e	48 8b c3	 mov	 rax, rbx

; 142  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
$LN3@get_dialec:

; 138  :     }
; 139  :     else
; 140  :         Py_INCREF(dialect_obj);

  00067	e8 00 00 00 00	 call	 _Py_PXCTX
  0006c	85 c0		 test	 eax, eax
  0006e	75 32		 jne	 SHORT $LN10@get_dialec
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007e	4c 8b cb	 mov	 r9, rbx
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 06		 jne	 SHORT $LN6@get_dialec
  00098	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0009c	74 04		 je	 SHORT $LN10@get_dialec
$LN6@get_dialec:
  0009e	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@get_dialec:

; 141  :     return dialect_obj;

  000a2	48 8b c3	 mov	 rax, rbx

; 142  : }

  000a5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a9	5b		 pop	 rbx
  000aa	c3		 ret	 0
get_dialect_from_registry ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_string DD imagerel get_string
	DD	imagerel get_string+82
	DD	imagerel $unwind$get_string
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_string DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT get_string
_TEXT	SEGMENT
str$ = 64
get_string PROC						; COMDAT

; 146  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 147  :     Py_XINCREF(str);

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3b		 je	 SHORT $LN13@get_string
  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	75 32		 jne	 SHORT $LN13@get_string
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00025	4c 8b cb	 mov	 r9, rbx
  00028	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 06		 jne	 SHORT $LN7@get_string
  0003f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00043	74 04		 je	 SHORT $LN13@get_string
$LN7@get_string:
  00045	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN13@get_string:

; 148  :     return str;

  00049	48 8b c3	 mov	 rax, rbx

; 149  : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
get_string ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromOrdinal:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$get_nullchar_as_None DD imagerel get_nullchar_as_None
	DD	imagerel get_nullchar_as_None+98
	DD	imagerel $unwind$get_nullchar_as_None
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_nullchar_as_None DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT get_nullchar_as_None
_TEXT	SEGMENT
c$ = 64
get_nullchar_as_None PROC				; COMDAT

; 153  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 154  :     if (c == '\0') {

  00004	85 c9		 test	 ecx, ecx
  00006	75 51		 jne	 SHORT $LN2@get_nullch

; 155  :         Py_INCREF(Py_None);

  00008	e8 00 00 00 00	 call	 _Py_PXCTX
  0000d	85 c0		 test	 eax, eax
  0000f	75 3c		 jne	 SHORT $LN6@get_nullch
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00026	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00034	e8 00 00 00 00	 call	 _PyParallel_Guard
  00039	85 c0		 test	 eax, eax
  0003b	75 09		 jne	 SHORT $LN5@get_nullch
  0003d	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00044	74 07		 je	 SHORT $LN6@get_nullch
$LN5@get_nullch:
  00046	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN6@get_nullch:

; 156  :         return Py_None;

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 157  :     }
; 158  :     else
; 159  :         return PyUnicode_FromOrdinal(c);
; 160  : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
$LN2@get_nullch:
  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	e9 00 00 00 00	 jmp	 PyUnicode_FromOrdinal
get_nullchar_as_None ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Dialect_get_lineterminator
_TEXT	SEGMENT
self$ = 8
Dialect_get_lineterminator PROC				; COMDAT

; 165  :     return get_string(self->lineterminator);

  00000	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]

; 166  : }

  00004	e9 00 00 00 00	 jmp	 get_string
Dialect_get_lineterminator ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Dialect_get_delimiter
_TEXT	SEGMENT
self$ = 8
Dialect_get_delimiter PROC				; COMDAT

; 171  :     return get_nullchar_as_None(self->delimiter);

  00000	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]

; 172  : }

  00003	e9 00 00 00 00	 jmp	 get_nullchar_as_None
Dialect_get_delimiter ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Dialect_get_escapechar
_TEXT	SEGMENT
self$ = 8
Dialect_get_escapechar PROC				; COMDAT

; 177  :     return get_nullchar_as_None(self->escapechar);

  00000	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]

; 178  : }

  00003	e9 00 00 00 00	 jmp	 get_nullchar_as_None
Dialect_get_escapechar ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT Dialect_get_quotechar
_TEXT	SEGMENT
self$ = 8
Dialect_get_quotechar PROC				; COMDAT

; 183  :     return get_nullchar_as_None(self->quotechar);

  00000	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]

; 184  : }

  00003	e9 00 00 00 00	 jmp	 get_nullchar_as_None
Dialect_get_quotechar ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
; Function compile flags: /Ogtpy
;	COMDAT Dialect_get_quoting
_TEXT	SEGMENT
self$ = 8
Dialect_get_quoting PROC				; COMDAT

; 189  :     return PyLong_FromLong(self->quoting);

  00000	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]

; 190  : }

  00006	e9 00 00 00 00	 jmp	 PyLong_FromLong
Dialect_get_quoting ENDP
_TEXT	ENDS
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_set_bool DD imagerel _set_bool
	DD	imagerel _set_bool+56
	DD	imagerel $unwind$_set_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_set_bool DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _set_bool
_TEXT	SEGMENT
target$ = 48
src$ = 56
dflt$ = 64
_set_bool PROC						; COMDAT

; 194  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 195  :     if (src == NULL)

  00009	48 85 d2	 test	 rdx, rdx
  0000c	75 0b		 jne	 SHORT $LN3@set_bool

; 196  :         *target = dflt;

  0000e	44 89 01	 mov	 DWORD PTR [rcx], r8d

; 202  :     }
; 203  :     return 0;

  00011	33 c0		 xor	 eax, eax

; 204  : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN3@set_bool:

; 197  :     else {
; 198  :         int b = PyObject_IsTrue(src);

  00019	48 8b ca	 mov	 rcx, rdx
  0001c	e8 00 00 00 00	 call	 PyObject_IsTrue

; 199  :         if (b < 0)

  00021	85 c0		 test	 eax, eax
  00023	79 09		 jns	 SHORT $LN1@set_bool

; 200  :             return -1;

  00025	83 c8 ff	 or	 eax, -1

; 204  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
$LN1@set_bool:

; 201  :         *target = b;

  0002e	89 03		 mov	 DWORD PTR [rbx], eax

; 202  :     }
; 203  :     return 0;

  00030	33 c0		 xor	 eax, eax

; 204  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
_set_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GENCJOL@?$CC?$CFs?$CC?5must?5be?5an?5integer?$AA@ ; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_set_int DD imagerel _set_int
	DD	imagerel _set_int+123
	DD	imagerel $unwind$_set_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_set_int DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BI@GENCJOL@?$CC?$CFs?$CC?5must?5be?5an?5integer?$AA@
CONST	SEGMENT
??_C@_0BI@GENCJOL@?$CC?$CFs?$CC?5must?5be?5an?5integer?$AA@ DB '"%s" must'
	DB	' be an integer', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _set_int
_TEXT	SEGMENT
name$ = 48
target$ = 56
src$ = 64
dflt$ = 72
_set_int PROC						; COMDAT

; 208  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 209  :     if (src == NULL)

  0000d	4d 85 c0	 test	 r8, r8
  00010	75 10		 jne	 SHORT $LN4@set_int

; 210  :         *target = dflt;

  00012	44 89 0a	 mov	 DWORD PTR [rdx], r9d

; 229  :     }
; 230  :     return 0;

  00015	33 c0		 xor	 eax, eax

; 231  : }

  00017	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
$LN4@set_int:

; 211  :     else {
; 212  :         long value;
; 213  :         if (!PyLong_CheckExact(src)) {

  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00029	49 39 40 58	 cmp	 QWORD PTR [r8+88], rax
  0002d	74 24		 je	 SHORT $LN2@set_int

; 214  :             PyErr_Format(PyExc_TypeError,
; 215  :                          "\"%s\" must be an integer", name);

  0002f	4c 8b c1	 mov	 r8, rcx
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GENCJOL@?$CC?$CFs?$CC?5must?5be?5an?5integer?$AA@
  00040	e8 00 00 00 00	 call	 PyErr_Format
$LN7@set_int:

; 216  :             return -1;

  00045	83 c8 ff	 or	 eax, -1

; 231  : }

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN2@set_int:

; 217  :         }
; 218  :         value = PyLong_AsLong(src);

  00053	49 8b c8	 mov	 rcx, r8
  00056	e8 00 00 00 00	 call	 PyLong_AsLong
  0005b	8b d8		 mov	 ebx, eax

; 219  :         if (value == -1 && PyErr_Occurred())

  0005d	83 f8 ff	 cmp	 eax, -1
  00060	75 0a		 jne	 SHORT $LN1@set_int
  00062	e8 00 00 00 00	 call	 PyErr_Occurred
  00067	48 85 c0	 test	 rax, rax

; 220  :             return -1;

  0006a	75 d9		 jne	 SHORT $LN7@set_int
$LN1@set_int:

; 221  : #if SIZEOF_LONG > SIZEOF_INT
; 222  :         if (value > INT_MAX || value < INT_MIN) {
; 223  :             PyErr_Format(PyExc_ValueError,
; 224  :                          "integer out of range for \"%s\"", name);
; 225  :             return -1;
; 226  :         }
; 227  : #endif
; 228  :         *target = (int)value;

  0006c	89 1f		 mov	 DWORD PTR [rdi], ebx

; 231  : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	33 c0		 xor	 eax, eax
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
_set_int ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@KOOPOFBL@?$CC?$CFs?$CC?5must?5be?5an?51?9character?5stri@ ; `string'
PUBLIC	??_C@_0CA@BHAKGOMP@?$CC?$CFs?$CC?5must?5be?5string?0?5not?5?$CF?4200s?$AA@ ; `string'
EXTRN	PyUnicode_GetLength:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_set_char DD imagerel _set_char
	DD	imagerel _set_char+353
	DD	imagerel $unwind$_set_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_set_char DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CD@KOOPOFBL@?$CC?$CFs?$CC?5must?5be?5an?51?9character?5stri@
CONST	SEGMENT
??_C@_0CD@KOOPOFBL@?$CC?$CFs?$CC?5must?5be?5an?51?9character?5stri@ DB '"'
	DB	'%s" must be an 1-character string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BHAKGOMP@?$CC?$CFs?$CC?5must?5be?5string?0?5not?5?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0CA@BHAKGOMP@?$CC?$CFs?$CC?5must?5be?5string?0?5not?5?$CF?4200s?$AA@ DB '"'
	DB	'%s" must be string, not %.200s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _set_char
_TEXT	SEGMENT
name$ = 48
target$ = 56
src$ = 64
dflt$ = 72
_set_char PROC						; COMDAT

; 235  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 236  :     if (src == NULL)

  00018	4d 85 c0	 test	 r8, r8
  0001b	75 15		 jne	 SHORT $LN6@set_char

; 237  :         *target = dflt;

  0001d	44 89 0a	 mov	 DWORD PTR [rdx], r9d

; 258  :         }
; 259  :     }
; 260  :     return 0;

  00020	33 c0		 xor	 eax, eax

; 261  : }

  00022	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00027	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
$LN6@set_char:

; 238  :     else {
; 239  :         *target = '\0';
; 240  :         if (src != Py_None) {

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00039	c7 02 00 00 00
	00		 mov	 DWORD PTR [rdx], 0
  0003f	48 3b d8	 cmp	 rbx, rax
  00042	0f 84 07 01 00
	00		 je	 $LN1@set_char

; 241  :             Py_ssize_t len;
; 242  :             if (!PyUnicode_Check(src)) {

  00048	4d 8b 48 58	 mov	 r9, QWORD PTR [r8+88]
  0004c	41 f7 81 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r9+256], 268435456 ; 10000000H
  00057	75 2d		 jne	 SHORT $LN3@set_char

; 243  :                 PyErr_Format(PyExc_TypeError,
; 244  :                     "\"%s\" must be string, not %.200s", name,
; 245  :                     src->ob_type->tp_name);

  00059	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0005d	4c 8b c1	 mov	 r8, rcx
  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@BHAKGOMP@?$CC?$CFs?$CC?5must?5be?5string?0?5not?5?$CF?4200s?$AA@
  0006e	e8 00 00 00 00	 call	 PyErr_Format

; 246  :                 return -1;

  00073	83 c8 ff	 or	 eax, -1

; 261  : }

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00084	5f		 pop	 rdi
  00085	c3		 ret	 0
$LN3@set_char:

; 247  :             }
; 248  :             len = PyUnicode_GetLength(src);

  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 PyUnicode_GetLength

; 249  :             if (len > 1) {

  0008e	48 83 f8 01	 cmp	 rax, 1
  00092	7e 29		 jle	 SHORT $LN2@set_char

; 250  :                 PyErr_Format(PyExc_TypeError,
; 251  :                     "\"%s\" must be an 1-character string",
; 252  :                     name);

  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@KOOPOFBL@?$CC?$CFs?$CC?5must?5be?5an?51?9character?5stri@
  000a2	4c 8b c6	 mov	 r8, rsi
  000a5	e8 00 00 00 00	 call	 PyErr_Format

; 253  :                 return -1;

  000aa	83 c8 ff	 or	 eax, -1

; 261  : }

  000ad	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b2	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
$LN2@set_char:

; 254  :             }
; 255  :             /* PyUnicode_READY() is called in PyUnicode_GetLength() */
; 256  :             if (len > 0)

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 8e 89 00 00
	00		 jle	 $LN1@set_char

; 257  :                 *target = PyUnicode_READ_CHAR(src, 0);

  000c6	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  000c9	8b c8		 mov	 ecx, eax
  000cb	c1 e9 02	 shr	 ecx, 2
  000ce	83 e1 07	 and	 ecx, 7
  000d1	83 f9 01	 cmp	 ecx, 1
  000d4	75 29		 jne	 SHORT $LN23@set_char
  000d6	a8 20		 test	 al, 32			; 00000020H
  000d8	74 19		 je	 SHORT $LN11@set_char
  000da	a8 40		 test	 al, 64			; 00000040H
  000dc	74 09		 je	 SHORT $LN9@set_char
  000de	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  000e2	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000e5	eb 66		 jmp	 SHORT $LN22@set_char
$LN9@set_char:
  000e7	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  000ee	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000f1	eb 5a		 jmp	 SHORT $LN22@set_char
$LN11@set_char:
  000f3	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  000fa	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000fd	eb 4e		 jmp	 SHORT $LN22@set_char
$LN23@set_char:
  000ff	83 f9 02	 cmp	 ecx, 2
  00102	75 29		 jne	 SHORT $LN21@set_char
  00104	a8 20		 test	 al, 32			; 00000020H
  00106	74 19		 je	 SHORT $LN15@set_char
  00108	a8 40		 test	 al, 64			; 00000040H
  0010a	74 09		 je	 SHORT $LN13@set_char
  0010c	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00110	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00113	eb 38		 jmp	 SHORT $LN22@set_char
$LN13@set_char:
  00115	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  0011c	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0011f	eb 2c		 jmp	 SHORT $LN22@set_char
$LN15@set_char:
  00121	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
  00128	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0012b	eb 20		 jmp	 SHORT $LN22@set_char
$LN21@set_char:
  0012d	a8 20		 test	 al, 32			; 00000020H
  0012f	74 13		 je	 SHORT $LN19@set_char
  00131	a8 40		 test	 al, 64			; 00000040H
  00133	74 06		 je	 SHORT $LN17@set_char
  00135	48 83 eb 80	 sub	 rbx, -128		; ffffffffffffff80H
  00139	eb 10		 jmp	 SHORT $LN20@set_char
$LN17@set_char:
  0013b	48 81 c3 a0 00
	00 00		 add	 rbx, 160		; 000000a0H
  00142	eb 07		 jmp	 SHORT $LN20@set_char
$LN19@set_char:
  00144	48 8b 9b a0 00
	00 00		 mov	 rbx, QWORD PTR [rbx+160]
$LN20@set_char:
  0014b	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN22@set_char:
  0014d	89 07		 mov	 DWORD PTR [rdi], eax
$LN1@set_char:

; 261  : }

  0014f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00154	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00159	33 c0		 xor	 eax, eax
  0015b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015f	5f		 pop	 rdi
  00160	c3		 ret	 0
_set_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@OPDEJNGK@?$CC?$CFs?$CC?5must?5be?5a?5string?$AA@ ; `string'
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PyUnicode_DecodeASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_set_str DD imagerel _set_str
	DD	imagerel _set_str+204
	DD	imagerel $unwind$_set_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_set_str DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@OPDEJNGK@?$CC?$CFs?$CC?5must?5be?5a?5string?$AA@
CONST	SEGMENT
??_C@_0BG@OPDEJNGK@?$CC?$CFs?$CC?5must?5be?5a?5string?$AA@ DB '"%s" must '
	DB	'be a string', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _set_str
_TEXT	SEGMENT
name$ = 48
target$ = 56
src$ = 64
dflt$ = 72
_set_str PROC						; COMDAT

; 265  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b da	 mov	 rbx, rdx

; 266  :     if (src == NULL)

  00010	4d 85 c0	 test	 r8, r8
  00013	75 2a		 jne	 SHORT $LN11@set_str

; 267  :         *target = PyUnicode_DecodeASCII(dflt, strlen(dflt), NULL);

  00015	48 83 c9 ff	 or	 rcx, -1
  00019	33 c0		 xor	 eax, eax
  0001b	49 8b f9	 mov	 rdi, r9
  0001e	f2 ae		 repne scasb
  00020	48 f7 d1	 not	 rcx
  00023	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  00027	49 8b c9	 mov	 rcx, r9
  0002a	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  0002f	48 89 03	 mov	 QWORD PTR [rbx], rax

; 282  :         }
; 283  :     }
; 284  :     return 0;

  00032	33 c0		 xor	 eax, eax

; 285  : }

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN11@set_str:

; 268  :     else {
; 269  :         if (src == Py_None)

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00046	4c 3b c0	 cmp	 r8, rax
  00049	75 14		 jne	 SHORT $LN9@set_str

; 270  :             *target = NULL;

  0004b	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0

; 282  :         }
; 283  :     }
; 284  :     return 0;

  00052	33 c0		 xor	 eax, eax

; 285  : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN9@set_str:

; 271  :         else if (!PyUnicode_Check(src)) {

  0005f	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00063	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0006d	75 24		 jne	 SHORT $LN7@set_str

; 272  :             PyErr_Format(PyExc_TypeError,
; 273  :                          "\"%s\" must be a string", name);

  0006f	4c 8b c1	 mov	 r8, rcx
  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@OPDEJNGK@?$CC?$CFs?$CC?5must?5be?5a?5string?$AA@
  00080	e8 00 00 00 00	 call	 PyErr_Format
$LN16@set_str:

; 274  :             return -1;

  00085	83 c8 ff	 or	 eax, -1

; 285  : }

  00088	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
$LN7@set_str:

; 275  :         }
; 276  :         else {
; 277  :             if (PyUnicode_READY(src) == -1)

  00093	41 f6 40 70 80	 test	 BYTE PTR [r8+112], 128	; 00000080H
  00098	75 0d		 jne	 SHORT $LN4@set_str
  0009a	49 8b c8	 mov	 rcx, r8
  0009d	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000a2	83 f8 ff	 cmp	 eax, -1

; 278  :                 return -1;

  000a5	74 de		 je	 SHORT $LN16@set_str
$LN4@set_str:

; 279  :             Py_XDECREF(*target);

  000a7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000aa	48 85 c9	 test	 rcx, rcx
  000ad	74 05		 je	 SHORT $LN3@set_str
  000af	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@set_str:

; 280  :             Py_INCREF(src);

  000b4	48 8b cf	 mov	 rcx, rdi
  000b7	e8 00 00 00 00	 call	 _Py_IncRef

; 281  :             *target = src;

  000bc	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 285  : }

  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	33 c0		 xor	 eax, eax
  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
_set_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@MOEHADNO@bad?5?$CCquoting?$CC?5value?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dialect_check_quoting DD imagerel dialect_check_quoting
	DD	imagerel dialect_check_quoting+70
	DD	imagerel $unwind$dialect_check_quoting
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dialect_check_quoting DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BE@MOEHADNO@bad?5?$CCquoting?$CC?5value?$AA@
CONST	SEGMENT
??_C@_0BE@MOEHADNO@bad?5?$CCquoting?$CC?5value?$AA@ DB 'bad "quoting" val'
	DB	'ue', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT dialect_check_quoting
_TEXT	SEGMENT
quoting$ = 48
dialect_check_quoting PROC				; COMDAT

; 289  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 290  :     StyleDesc *qs;
; 291  : 
; 292  :     for (qs = quote_styles; qs->name; qs++) {

  00004	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR quote_styles+8, 0
  0000c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:quote_styles
  00013	74 0f		 je	 SHORT $LN2@dialect_ch
$LL4@dialect_ch:

; 293  :         if (qs->style == quoting)

  00015	39 08		 cmp	 DWORD PTR [rax], ecx
  00017	74 26		 je	 SHORT $LN8@dialect_ch

; 290  :     StyleDesc *qs;
; 291  : 
; 292  :     for (qs = quote_styles; qs->name; qs++) {

  00019	48 83 c0 10	 add	 rax, 16
  0001d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00022	75 f1		 jne	 SHORT $LL4@dialect_ch
$LN2@dialect_ch:

; 295  :     }
; 296  :     PyErr_Format(PyExc_TypeError, "bad \"quoting\" value");

  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@MOEHADNO@bad?5?$CCquoting?$CC?5value?$AA@
  00032	e8 00 00 00 00	 call	 PyErr_Format

; 297  :     return -1;

  00037	83 c8 ff	 or	 eax, -1

; 298  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
$LN8@dialect_ch:

; 294  :             return 0;

  0003f	33 c0		 xor	 eax, eax

; 298  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
dialect_check_quoting ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Dialect_dealloc DD imagerel Dialect_dealloc
	DD	imagerel Dialect_dealloc+147
	DD	imagerel $unwind$Dialect_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Dialect_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT Dialect_dealloc
_TEXT	SEGMENT
self$ = 64
Dialect_dealloc PROC					; COMDAT

; 320  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 321  :     Py_XDECREF(self->lineterminator);

  0000a	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 65		 je	 SHORT $LN3@Dialect_de
  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 5c		 jne	 SHORT $LN3@Dialect_de
  0001f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00023	a8 20		 test	 al, 32			; 00000020H
  00025	75 4c		 jne	 SHORT $LN11@Dialect_de
  00027	84 c0		 test	 al, al
  00029	78 48		 js	 SHORT $LN11@Dialect_de
  0002b	a8 02		 test	 al, 2
  0002d	75 4c		 jne	 SHORT $LN3@Dialect_de
  0002f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00033	75 46		 jne	 SHORT $LN3@Dialect_de
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00043	4c 8b cb	 mov	 r9, rbx
  00046	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	48 8b cb	 mov	 rcx, rbx
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN16@Dialect_de
  00060	e8 00 00 00 00	 call	 _Px_Dealloc
  00065	eb 14		 jmp	 SHORT $LN3@Dialect_de
$LN16@Dialect_de:
  00067	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00071	eb 08		 jmp	 SHORT $LN3@Dialect_de
$LN11@Dialect_de:
  00073	48 8b cb	 mov	 rcx, rbx
  00076	e8 00 00 00 00	 call	 Px_DecRef
$LN3@Dialect_de:

; 322  :     Py_TYPE(self)->tp_free((PyObject *)self);

  0007b	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0007f	48 8b cf	 mov	 rcx, rdi

; 323  : }

  00082	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
Dialect_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@BEOHJCBM@lineterminator?5must?5be?5set?$AA@ ; `string'
PUBLIC	??_C@_0CJ@MDIOJFDM@quotechar?5must?5be?5set?5if?5quoting@ ; `string'
PUBLIC	??_C@_0CK@KMDCNNH@?$CCdelimiter?$CC?5must?5be?5an?51?9charact@ ; `string'
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_0L@KHNJGNHA@?$HMOOOOOOOOO?$AA@		; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$dialect_new DD imagerel dialect_new
	DD	imagerel dialect_new+370
	DD	imagerel $unwind$dialect_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$dialect_new DD imagerel dialect_new+370
	DD	imagerel dialect_new+1308
	DD	imagerel $chain$2$dialect_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$dialect_new DD imagerel dialect_new+1308
	DD	imagerel dialect_new+1571
	DD	imagerel $chain$3$dialect_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$dialect_new DD imagerel dialect_new+1571
	DD	imagerel dialect_new+1612
	DD	imagerel $chain$4$dialect_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$dialect_new DD imagerel dialect_new+1612
	DD	imagerel dialect_new+1744
	DD	imagerel $chain$5$dialect_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$dialect_new DD 021H
	DD	imagerel dialect_new
	DD	imagerel dialect_new+370
	DD	imagerel $unwind$dialect_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$dialect_new DD 021H
	DD	imagerel dialect_new+370
	DD	imagerel dialect_new+1308
	DD	imagerel $chain$2$dialect_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$dialect_new DD 020821H
	DD	01c6408H
	DD	imagerel dialect_new+370
	DD	imagerel dialect_new+1308
	DD	imagerel $chain$2$dialect_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$dialect_new DD 062021H
	DD	016d420H
	DD	017c418H
	DD	01d7408H
	DD	imagerel dialect_new
	DD	imagerel dialect_new+370
	DD	imagerel $unwind$dialect_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dialect_new DD 051101H
	DD	0180111H
	DD	03003e005H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BL@BEOHJCBM@lineterminator?5must?5be?5set?$AA@
CONST	SEGMENT
??_C@_0BL@BEOHJCBM@lineterminator?5must?5be?5set?$AA@ DB 'lineterminator '
	DB	'must be set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@MDIOJFDM@quotechar?5must?5be?5set?5if?5quoting@
CONST	SEGMENT
??_C@_0CJ@MDIOJFDM@quotechar?5must?5be?5set?5if?5quoting@ DB 'quotechar m'
	DB	'ust be set if quoting enabled', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KMDCNNH@?$CCdelimiter?$CC?5must?5be?5an?51?9charact@
CONST	SEGMENT
??_C@_0CK@KMDCNNH@?$CCdelimiter?$CC?5must?5be?5an?51?9charact@ DB '"delim'
	DB	'iter" must be an 1-character string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KHNJGNHA@?$HMOOOOOOOOO?$AA@
CONST	SEGMENT
??_C@_0L@KHNJGNHA@?$HMOOOOOOOOO?$AA@ DB '|OOOOOOOOO', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT dialect_new
_TEXT	SEGMENT
quotechar$ = 112
quoting$ = 120
delimiter$ = 128
doublequote$ = 136
escapechar$ = 144
lineterminator$ = 152
skipinitialspace$ = 160
strict$ = 168
type$ = 224
args$ = 232
kwargs$ = 240
dialect$ = 248
dialect_new PROC					; COMDAT

; 340  : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	41 56		 push	 r14
  00005	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  0000a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00011	48 8b d9	 mov	 rbx, rcx

; 341  :     DialectObj *self;
; 342  :     PyObject *ret = NULL;

  00014	45 33 f6	 xor	 r14d, r14d

; 343  :     PyObject *dialect = NULL;
; 344  :     PyObject *delimiter = NULL;
; 345  :     PyObject *doublequote = NULL;
; 346  :     PyObject *escapechar = NULL;
; 347  :     PyObject *lineterminator = NULL;
; 348  :     PyObject *quotechar = NULL;
; 349  :     PyObject *quoting = NULL;
; 350  :     PyObject *skipinitialspace = NULL;
; 351  :     PyObject *strict = NULL;
; 352  : 
; 353  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 354  :                                      "|OOOOOOOOO", dialect_kws,
; 355  :                                      &dialect,
; 356  :                                      &delimiter,
; 357  :                                      &doublequote,
; 358  :                                      &escapechar,
; 359  :                                      &lineterminator,
; 360  :                                      &quotechar,
; 361  :                                      &quoting,
; 362  :                                      &skipinitialspace,
; 363  :                                      &strict))

  00017	48 8d 4d 2f	 lea	 rcx, QWORD PTR strict$[rbp-121]
  0001b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00020	48 8d 4d 27	 lea	 rcx, QWORD PTR skipinitialspace$[rbp-121]
  00024	49 8b c0	 mov	 rax, r8
  00027	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0002c	48 8d 4d ff	 lea	 rcx, QWORD PTR quoting$[rbp-121]
  00030	4c 8b d2	 mov	 r10, rdx
  00033	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00038	48 8d 4d f7	 lea	 rcx, QWORD PTR quotechar$[rbp-121]
  0003c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:dialect_kws
  00043	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00048	48 8d 4d 1f	 lea	 rcx, QWORD PTR lineterminator$[rbp-121]
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@KHNJGNHA@?$HMOOOOOOOOO?$AA@
  00053	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00058	48 8d 4d 17	 lea	 rcx, QWORD PTR escapechar$[rbp-121]
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00064	48 8d 4d 0f	 lea	 rcx, QWORD PTR doublequote$[rbp-121]
  00068	4c 89 75 7f	 mov	 QWORD PTR dialect$[rbp-121], r14
  0006c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00071	48 8d 4d 07	 lea	 rcx, QWORD PTR delimiter$[rbp-121]
  00075	4c 89 75 07	 mov	 QWORD PTR delimiter$[rbp-121], r14
  00079	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007e	48 8d 4d 7f	 lea	 rcx, QWORD PTR dialect$[rbp-121]
  00082	4c 89 75 0f	 mov	 QWORD PTR doublequote$[rbp-121], r14
  00086	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008b	49 8b ca	 mov	 rcx, r10
  0008e	4c 89 75 17	 mov	 QWORD PTR escapechar$[rbp-121], r14
  00092	4c 89 75 1f	 mov	 QWORD PTR lineterminator$[rbp-121], r14
  00096	4c 89 75 f7	 mov	 QWORD PTR quotechar$[rbp-121], r14
  0009a	4c 89 75 ff	 mov	 QWORD PTR quoting$[rbp-121], r14
  0009e	4c 89 75 27	 mov	 QWORD PTR skipinitialspace$[rbp-121], r14
  000a2	4c 89 75 2f	 mov	 QWORD PTR strict$[rbp-121], r14
  000a6	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000ab	85 c0		 test	 eax, eax

; 364  :         return NULL;

  000ad	74 2b		 je	 SHORT $LN150@dialect_ne

; 365  : 
; 366  :     if (dialect != NULL) {

  000af	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  000b3	48 85 c9	 test	 rcx, rcx
  000b6	0f 84 87 00 00
	00		 je	 $LN101@dialect_ne

; 367  :         if (PyUnicode_Check(dialect)) {

  000bc	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  000c0	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000ca	74 1c		 je	 SHORT $LN104@dialect_ne

; 368  :             dialect = get_dialect_from_registry(dialect);

  000cc	e8 00 00 00 00	 call	 get_dialect_from_registry
  000d1	48 89 45 7f	 mov	 QWORD PTR dialect$[rbp-121], rax

; 369  :             if (dialect == NULL)

  000d5	48 85 c0	 test	 rax, rax
  000d8	75 17		 jne	 SHORT $LN102@dialect_ne
$LN150@dialect_ne:

; 370  :                 return NULL;

  000da	33 c0		 xor	 eax, eax

; 464  : }

  000dc	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  000e3	41 5e		 pop	 r14
  000e5	5b		 pop	 rbx
  000e6	5d		 pop	 rbp
  000e7	c3		 ret	 0
$LN104@dialect_ne:

; 371  :         }
; 372  :         else
; 373  :             Py_INCREF(dialect);

  000e8	e8 00 00 00 00	 call	 _Py_IncRef
  000ed	48 8b 45 7f	 mov	 rax, QWORD PTR dialect$[rbp-121]
$LN102@dialect_ne:

; 374  :         /* Can we reuse this instance? */
; 375  :         if (PyObject_TypeCheck(dialect, &Dialect_Type) &&
; 376  :             delimiter == 0 &&
; 377  :             doublequote == 0 &&
; 378  :             escapechar == 0 &&
; 379  :             lineterminator == 0 &&
; 380  :             quotechar == 0 &&
; 381  :             quoting == 0 &&
; 382  :             skipinitialspace == 0 &&
; 383  :             strict == 0)

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Dialect_Type
  000f8	48 39 50 58	 cmp	 QWORD PTR [rax+88], rdx
  000fc	74 11		 je	 SHORT $LN100@dialect_ne
  000fe	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00102	e8 00 00 00 00	 call	 PyType_IsSubtype
  00107	85 c0		 test	 eax, eax
  00109	74 38		 je	 SHORT $LN101@dialect_ne
  0010b	48 8b 45 7f	 mov	 rax, QWORD PTR dialect$[rbp-121]
$LN100@dialect_ne:
  0010f	4c 39 75 07	 cmp	 QWORD PTR delimiter$[rbp-121], r14
  00113	75 2e		 jne	 SHORT $LN101@dialect_ne
  00115	4c 39 75 0f	 cmp	 QWORD PTR doublequote$[rbp-121], r14
  00119	75 28		 jne	 SHORT $LN101@dialect_ne
  0011b	4c 39 75 17	 cmp	 QWORD PTR escapechar$[rbp-121], r14
  0011f	75 22		 jne	 SHORT $LN101@dialect_ne
  00121	4c 39 75 1f	 cmp	 QWORD PTR lineterminator$[rbp-121], r14
  00125	75 1c		 jne	 SHORT $LN101@dialect_ne
  00127	4c 39 75 f7	 cmp	 QWORD PTR quotechar$[rbp-121], r14
  0012b	75 16		 jne	 SHORT $LN101@dialect_ne
  0012d	4c 39 75 ff	 cmp	 QWORD PTR quoting$[rbp-121], r14
  00131	75 10		 jne	 SHORT $LN101@dialect_ne
  00133	4c 39 75 27	 cmp	 QWORD PTR skipinitialspace$[rbp-121], r14
  00137	75 0a		 jne	 SHORT $LN101@dialect_ne
  00139	4c 39 75 2f	 cmp	 QWORD PTR strict$[rbp-121], r14

; 384  :             return dialect;

  0013d	0f 84 81 05 00
	00		 je	 $LN107@dialect_ne
$LN101@dialect_ne:

; 385  :     }
; 386  : 
; 387  :     self = (DialectObj *)type->tp_alloc(type, 0);

  00143	33 d2		 xor	 edx, edx
  00145	48 8b cb	 mov	 rcx, rbx
  00148	ff 93 88 01 00
	00		 call	 QWORD PTR [rbx+392]
  0014e	48 8b d8	 mov	 rbx, rax

; 388  :     if (self == NULL) {

  00151	48 85 c0	 test	 rax, rax
  00154	75 1c		 jne	 SHORT $LN99@dialect_ne

; 389  :         Py_XDECREF(dialect);

  00156	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  0015a	48 85 c9	 test	 rcx, rcx
  0015d	74 05		 je	 SHORT $LN97@dialect_ne
  0015f	e8 00 00 00 00	 call	 _Py_DecRef
$LN97@dialect_ne:

; 390  :         return NULL;

  00164	33 c0		 xor	 eax, eax

; 464  : }

  00166	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0016d	41 5e		 pop	 r14
  0016f	5b		 pop	 rbx
  00170	5d		 pop	 rbp
  00171	c3		 ret	 0
$LN99@dialect_ne:
  00172	48 89 bc 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rdi

; 391  :     }
; 392  :     self->lineterminator = NULL;

  0017a	4c 89 70 78	 mov	 QWORD PTR [rax+120], r14

; 393  : 
; 394  :     Py_XINCREF(delimiter);

  0017e	48 8b 7d 07	 mov	 rdi, QWORD PTR delimiter$[rbp-121]
  00182	4c 89 a4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r12
  0018a	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13
  00192	48 85 ff	 test	 rdi, rdi
  00195	74 3b		 je	 SHORT $LN93@dialect_ne
  00197	e8 00 00 00 00	 call	 _Py_PXCTX
  0019c	85 c0		 test	 eax, eax
  0019e	75 32		 jne	 SHORT $LN93@dialect_ne
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001ae	4c 8b cf	 mov	 r9, rdi
  001b1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001b7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001bf	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c4	85 c0		 test	 eax, eax
  001c6	75 06		 jne	 SHORT $LN109@dialect_ne
  001c8	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  001cc	74 04		 je	 SHORT $LN93@dialect_ne
$LN109@dialect_ne:
  001ce	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN93@dialect_ne:

; 395  :     Py_XINCREF(doublequote);

  001d2	48 8b 7d 0f	 mov	 rdi, QWORD PTR doublequote$[rbp-121]
  001d6	48 85 ff	 test	 rdi, rdi
  001d9	74 3b		 je	 SHORT $LN89@dialect_ne
  001db	e8 00 00 00 00	 call	 _Py_PXCTX
  001e0	85 c0		 test	 eax, eax
  001e2	75 32		 jne	 SHORT $LN89@dialect_ne
  001e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  001f2	4c 8b cf	 mov	 r9, rdi
  001f5	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  001fb	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00203	e8 00 00 00 00	 call	 _PyParallel_Guard
  00208	85 c0		 test	 eax, eax
  0020a	75 06		 jne	 SHORT $LN113@dialect_ne
  0020c	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00210	74 04		 je	 SHORT $LN89@dialect_ne
$LN113@dialect_ne:
  00212	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN89@dialect_ne:

; 396  :     Py_XINCREF(escapechar);

  00216	48 8b 7d 17	 mov	 rdi, QWORD PTR escapechar$[rbp-121]
  0021a	48 85 ff	 test	 rdi, rdi
  0021d	74 3b		 je	 SHORT $LN85@dialect_ne
  0021f	e8 00 00 00 00	 call	 _Py_PXCTX
  00224	85 c0		 test	 eax, eax
  00226	75 32		 jne	 SHORT $LN85@dialect_ne
  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0022f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00236	4c 8b cf	 mov	 r9, rdi
  00239	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0023f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00247	e8 00 00 00 00	 call	 _PyParallel_Guard
  0024c	85 c0		 test	 eax, eax
  0024e	75 06		 jne	 SHORT $LN117@dialect_ne
  00250	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00254	74 04		 je	 SHORT $LN85@dialect_ne
$LN117@dialect_ne:
  00256	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN85@dialect_ne:

; 397  :     Py_XINCREF(lineterminator);

  0025a	48 8b 7d 1f	 mov	 rdi, QWORD PTR lineterminator$[rbp-121]
  0025e	48 85 ff	 test	 rdi, rdi
  00261	74 3b		 je	 SHORT $LN81@dialect_ne
  00263	e8 00 00 00 00	 call	 _Py_PXCTX
  00268	85 c0		 test	 eax, eax
  0026a	75 32		 jne	 SHORT $LN81@dialect_ne
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0027a	4c 8b cf	 mov	 r9, rdi
  0027d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00283	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0028b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00290	85 c0		 test	 eax, eax
  00292	75 06		 jne	 SHORT $LN121@dialect_ne
  00294	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00298	74 04		 je	 SHORT $LN81@dialect_ne
$LN121@dialect_ne:
  0029a	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN81@dialect_ne:

; 398  :     Py_XINCREF(quotechar);

  0029e	48 8b 7d f7	 mov	 rdi, QWORD PTR quotechar$[rbp-121]
  002a2	48 85 ff	 test	 rdi, rdi
  002a5	74 3b		 je	 SHORT $LN77@dialect_ne
  002a7	e8 00 00 00 00	 call	 _Py_PXCTX
  002ac	85 c0		 test	 eax, eax
  002ae	75 32		 jne	 SHORT $LN77@dialect_ne
  002b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  002be	4c 8b cf	 mov	 r9, rdi
  002c1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  002c7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002cf	e8 00 00 00 00	 call	 _PyParallel_Guard
  002d4	85 c0		 test	 eax, eax
  002d6	75 06		 jne	 SHORT $LN125@dialect_ne
  002d8	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  002dc	74 04		 je	 SHORT $LN77@dialect_ne
$LN125@dialect_ne:
  002de	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN77@dialect_ne:

; 399  :     Py_XINCREF(quoting);

  002e2	48 8b 7d ff	 mov	 rdi, QWORD PTR quoting$[rbp-121]
  002e6	48 85 ff	 test	 rdi, rdi
  002e9	74 3b		 je	 SHORT $LN73@dialect_ne
  002eb	e8 00 00 00 00	 call	 _Py_PXCTX
  002f0	85 c0		 test	 eax, eax
  002f2	75 32		 jne	 SHORT $LN73@dialect_ne
  002f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00302	4c 8b cf	 mov	 r9, rdi
  00305	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0030b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00313	e8 00 00 00 00	 call	 _PyParallel_Guard
  00318	85 c0		 test	 eax, eax
  0031a	75 06		 jne	 SHORT $LN129@dialect_ne
  0031c	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00320	74 04		 je	 SHORT $LN73@dialect_ne
$LN129@dialect_ne:
  00322	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN73@dialect_ne:

; 400  :     Py_XINCREF(skipinitialspace);

  00326	48 8b 7d 27	 mov	 rdi, QWORD PTR skipinitialspace$[rbp-121]
  0032a	48 85 ff	 test	 rdi, rdi
  0032d	74 3b		 je	 SHORT $LN69@dialect_ne
  0032f	e8 00 00 00 00	 call	 _Py_PXCTX
  00334	85 c0		 test	 eax, eax
  00336	75 32		 jne	 SHORT $LN69@dialect_ne
  00338	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0033f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00346	4c 8b cf	 mov	 r9, rdi
  00349	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0034f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00357	e8 00 00 00 00	 call	 _PyParallel_Guard
  0035c	85 c0		 test	 eax, eax
  0035e	75 06		 jne	 SHORT $LN133@dialect_ne
  00360	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  00364	74 04		 je	 SHORT $LN69@dialect_ne
$LN133@dialect_ne:
  00366	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN69@dialect_ne:

; 401  :     Py_XINCREF(strict);

  0036a	48 8b 7d 2f	 mov	 rdi, QWORD PTR strict$[rbp-121]
  0036e	48 85 ff	 test	 rdi, rdi
  00371	74 3b		 je	 SHORT $LN65@dialect_ne
  00373	e8 00 00 00 00	 call	 _Py_PXCTX
  00378	85 c0		 test	 eax, eax
  0037a	75 32		 jne	 SHORT $LN65@dialect_ne
  0037c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0038a	4c 8b cf	 mov	 r9, rdi
  0038d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00393	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0039b	e8 00 00 00 00	 call	 _PyParallel_Guard
  003a0	85 c0		 test	 eax, eax
  003a2	75 06		 jne	 SHORT $LN137@dialect_ne
  003a4	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  003a8	74 04		 je	 SHORT $LN65@dialect_ne
$LN137@dialect_ne:
  003aa	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN65@dialect_ne:

; 402  :     if (dialect != NULL) {

  003ae	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  003b2	48 85 c9	 test	 rcx, rcx
  003b5	0f 84 d1 00 00
	00		 je	 $LN62@dialect_ne

; 403  : #define DIALECT_GETATTR(v, n) \
; 404  :         if (v == NULL) \
; 405  :             v = PyObject_GetAttrString(dialect, n)
; 406  :         DIALECT_GETATTR(delimiter, "delimiter");

  003bb	4c 39 75 07	 cmp	 QWORD PTR delimiter$[rbp-121], r14
  003bf	75 14		 jne	 SHORT $LN61@dialect_ne
  003c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NMOHGHGG@delimiter?$AA@
  003c8	e8 00 00 00 00	 call	 PyObject_GetAttrString
  003cd	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  003d1	48 89 45 07	 mov	 QWORD PTR delimiter$[rbp-121], rax
$LN61@dialect_ne:

; 407  :         DIALECT_GETATTR(doublequote, "doublequote");

  003d5	4c 39 75 0f	 cmp	 QWORD PTR doublequote$[rbp-121], r14
  003d9	75 14		 jne	 SHORT $LN60@dialect_ne
  003db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@IJBGDELB@doublequote?$AA@
  003e2	e8 00 00 00 00	 call	 PyObject_GetAttrString
  003e7	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  003eb	48 89 45 0f	 mov	 QWORD PTR doublequote$[rbp-121], rax
$LN60@dialect_ne:

; 408  :         DIALECT_GETATTR(escapechar, "escapechar");

  003ef	4c 39 75 17	 cmp	 QWORD PTR escapechar$[rbp-121], r14
  003f3	75 14		 jne	 SHORT $LN59@dialect_ne
  003f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BBGHHBGG@escapechar?$AA@
  003fc	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00401	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  00405	48 89 45 17	 mov	 QWORD PTR escapechar$[rbp-121], rax
$LN59@dialect_ne:

; 409  :         DIALECT_GETATTR(lineterminator, "lineterminator");

  00409	4c 39 75 1f	 cmp	 QWORD PTR lineterminator$[rbp-121], r14
  0040d	75 14		 jne	 SHORT $LN58@dialect_ne
  0040f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@JHFLIELP@lineterminator?$AA@
  00416	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0041b	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  0041f	48 89 45 1f	 mov	 QWORD PTR lineterminator$[rbp-121], rax
$LN58@dialect_ne:

; 410  :         DIALECT_GETATTR(quotechar, "quotechar");

  00423	4c 39 75 f7	 cmp	 QWORD PTR quotechar$[rbp-121], r14
  00427	75 14		 jne	 SHORT $LN57@dialect_ne
  00429	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ICADEPGB@quotechar?$AA@
  00430	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00435	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  00439	48 89 45 f7	 mov	 QWORD PTR quotechar$[rbp-121], rax
$LN57@dialect_ne:

; 411  :         DIALECT_GETATTR(quoting, "quoting");

  0043d	4c 39 75 ff	 cmp	 QWORD PTR quoting$[rbp-121], r14
  00441	75 14		 jne	 SHORT $LN56@dialect_ne
  00443	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07JPFMBGFH@quoting?$AA@
  0044a	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0044f	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  00453	48 89 45 ff	 mov	 QWORD PTR quoting$[rbp-121], rax
$LN56@dialect_ne:

; 412  :         DIALECT_GETATTR(skipinitialspace, "skipinitialspace");

  00457	4c 39 75 27	 cmp	 QWORD PTR skipinitialspace$[rbp-121], r14
  0045b	75 14		 jne	 SHORT $LN55@dialect_ne
  0045d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CFMLGKKP@skipinitialspace?$AA@
  00464	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00469	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  0046d	48 89 45 27	 mov	 QWORD PTR skipinitialspace$[rbp-121], rax
$LN55@dialect_ne:

; 413  :         DIALECT_GETATTR(strict, "strict");

  00471	4c 39 75 2f	 cmp	 QWORD PTR strict$[rbp-121], r14
  00475	75 10		 jne	 SHORT $LN54@dialect_ne
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  0047e	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00483	48 89 45 2f	 mov	 QWORD PTR strict$[rbp-121], rax
$LN54@dialect_ne:

; 414  :         PyErr_Clear();

  00487	e8 00 00 00 00	 call	 PyErr_Clear
$LN62@dialect_ne:

; 415  :     }
; 416  : 
; 417  :     /* check types and convert to C values */
; 418  : #define DIASET(meth, name, target, src, dflt) \
; 419  :     if (meth(name, target, src, dflt)) \
; 420  :         goto err
; 421  :     DIASET(_set_char, "delimiter", &self->delimiter, delimiter, ',');

  0048c	4c 8b 45 07	 mov	 r8, QWORD PTR delimiter$[rbp-121]
  00490	48 8d 53 64	 lea	 rdx, QWORD PTR [rbx+100]
  00494	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09NMOHGHGG@delimiter?$AA@
  0049b	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  004a1	e8 00 00 00 00	 call	 _set_char
  004a6	85 c0		 test	 eax, eax
  004a8	0f 85 75 01 00
	00		 jne	 $err$20698

; 422  :     DIASET(_set_bool, "doublequote", &self->doublequote, doublequote, 1);

  004ae	48 8b 55 0f	 mov	 rdx, QWORD PTR doublequote$[rbp-121]
  004b2	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
  004b6	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  004ba	e8 00 00 00 00	 call	 _set_bool
  004bf	85 c0		 test	 eax, eax
  004c1	0f 85 5c 01 00
	00		 jne	 $err$20698

; 423  :     DIASET(_set_char, "escapechar", &self->escapechar, escapechar, 0);

  004c7	4c 8b 45 17	 mov	 r8, QWORD PTR escapechar$[rbp-121]
  004cb	48 8d 53 6c	 lea	 rdx, QWORD PTR [rbx+108]
  004cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@BBGHHBGG@escapechar?$AA@
  004d6	45 33 c9	 xor	 r9d, r9d
  004d9	e8 00 00 00 00	 call	 _set_char
  004de	85 c0		 test	 eax, eax
  004e0	0f 85 3d 01 00
	00		 jne	 $err$20698

; 424  :     DIASET(_set_str, "lineterminator", &self->lineterminator, lineterminator, "\r\n");

  004e6	4c 8b 45 1f	 mov	 r8, QWORD PTR lineterminator$[rbp-121]
  004ea	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02PCIJFNDE@?$AN?6?$AA@
  004f1	48 8d 53 78	 lea	 rdx, QWORD PTR [rbx+120]
  004f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@JHFLIELP@lineterminator?$AA@
  004fc	e8 00 00 00 00	 call	 _set_str
  00501	85 c0		 test	 eax, eax
  00503	0f 85 1a 01 00
	00		 jne	 $err$20698

; 425  :     DIASET(_set_char, "quotechar", &self->quotechar, quotechar, '"');

  00509	4c 8b 45 f7	 mov	 r8, QWORD PTR quotechar$[rbp-121]
  0050d	44 8d 48 22	 lea	 r9d, QWORD PTR [rax+34]
  00511	48 8d 53 68	 lea	 rdx, QWORD PTR [rbx+104]
  00515	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09ICADEPGB@quotechar?$AA@
  0051c	48 89 b4 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rsi
  00524	e8 00 00 00 00	 call	 _set_char
  00529	85 c0		 test	 eax, eax
  0052b	0f 85 ea 00 00
	00		 jne	 $LN149@dialect_ne

; 426  :     DIASET(_set_int, "quoting", &self->quoting, quoting, QUOTE_MINIMAL);

  00531	4c 8b 45 ff	 mov	 r8, QWORD PTR quoting$[rbp-121]
  00535	48 8d 93 80 00
	00 00		 lea	 rdx, QWORD PTR [rbx+128]
  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07JPFMBGFH@quoting?$AA@
  00543	45 33 c9	 xor	 r9d, r9d
  00546	e8 00 00 00 00	 call	 _set_int
  0054b	85 c0		 test	 eax, eax
  0054d	0f 85 c8 00 00
	00		 jne	 $LN149@dialect_ne

; 427  :     DIASET(_set_bool, "skipinitialspace", &self->skipinitialspace, skipinitialspace, 0);

  00553	48 8b 55 27	 mov	 rdx, QWORD PTR skipinitialspace$[rbp-121]
  00557	48 8d 4b 70	 lea	 rcx, QWORD PTR [rbx+112]
  0055b	45 33 c0	 xor	 r8d, r8d
  0055e	e8 00 00 00 00	 call	 _set_bool
  00563	85 c0		 test	 eax, eax
  00565	0f 85 b0 00 00
	00		 jne	 $LN149@dialect_ne

; 428  :     DIASET(_set_bool, "strict", &self->strict, strict, 0);

  0056b	48 8b 55 2f	 mov	 rdx, QWORD PTR strict$[rbp-121]
  0056f	48 8d 8b 84 00
	00 00		 lea	 rcx, QWORD PTR [rbx+132]
  00576	45 33 c0	 xor	 r8d, r8d
  00579	e8 00 00 00 00	 call	 _set_bool
  0057e	85 c0		 test	 eax, eax
  00580	0f 85 95 00 00
	00		 jne	 $LN149@dialect_ne

; 429  : 
; 430  :     /* validate options */
; 431  :     if (dialect_check_quoting(self->quoting))

  00586	8b 8b 80 00 00
	00		 mov	 ecx, DWORD PTR [rbx+128]
  0058c	e8 00 00 00 00	 call	 dialect_check_quoting
  00591	85 c0		 test	 eax, eax
  00593	0f 85 82 00 00
	00		 jne	 $LN149@dialect_ne

; 432  :         goto err;
; 433  :     if (self->delimiter == 0) {

  00599	44 39 73 64	 cmp	 DWORD PTR [rbx+100], r14d
  0059d	75 15		 jne	 SHORT $LN44@dialect_ne

; 434  :         PyErr_SetString(PyExc_TypeError,
; 435  :                         "\"delimiter\" must be an 1-character string");

  0059f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  005a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KMDCNNH@?$CCdelimiter?$CC?5must?5be?5an?51?9charact@
  005ad	e8 00 00 00 00	 call	 PyErr_SetString

; 436  :         goto err;

  005b2	eb 67		 jmp	 SHORT $LN149@dialect_ne
$LN44@dialect_ne:

; 437  :     }
; 438  :     if (quotechar == Py_None && quoting == NULL)

  005b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  005bb	48 39 45 f7	 cmp	 QWORD PTR quotechar$[rbp-121], rax
  005bf	75 10		 jne	 SHORT $LN43@dialect_ne
  005c1	4c 39 75 ff	 cmp	 QWORD PTR quoting$[rbp-121], r14
  005c5	75 0a		 jne	 SHORT $LN43@dialect_ne

; 439  :         self->quoting = QUOTE_NONE;

  005c7	c7 83 80 00 00
	00 03 00 00 00	 mov	 DWORD PTR [rbx+128], 3
$LN43@dialect_ne:

; 440  :     if (self->quoting != QUOTE_NONE && self->quotechar == 0) {

  005d1	83 bb 80 00 00
	00 03		 cmp	 DWORD PTR [rbx+128], 3
  005d8	74 1b		 je	 SHORT $LN42@dialect_ne
  005da	44 39 73 68	 cmp	 DWORD PTR [rbx+104], r14d
  005de	75 15		 jne	 SHORT $LN42@dialect_ne

; 441  :         PyErr_SetString(PyExc_TypeError,
; 442  :                         "quotechar must be set if quoting enabled");

  005e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  005e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@MDIOJFDM@quotechar?5must?5be?5set?5if?5quoting@
  005ee	e8 00 00 00 00	 call	 PyErr_SetString

; 443  :         goto err;

  005f3	eb 26		 jmp	 SHORT $LN149@dialect_ne
$LN42@dialect_ne:

; 444  :     }
; 445  :     if (self->lineterminator == 0) {

  005f5	4c 39 73 78	 cmp	 QWORD PTR [rbx+120], r14
  005f9	75 15		 jne	 SHORT $LN41@dialect_ne

; 446  :         PyErr_SetString(PyExc_TypeError, "lineterminator must be set");

  005fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00602	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@BEOHJCBM@lineterminator?5must?5be?5set?$AA@
  00609	e8 00 00 00 00	 call	 PyErr_SetString

; 447  :         goto err;

  0060e	eb 0b		 jmp	 SHORT $LN149@dialect_ne
$LN41@dialect_ne:

; 448  :     }
; 449  : 
; 450  :     ret = (PyObject *)self;
; 451  :     Py_INCREF(self);

  00610	48 8b cb	 mov	 rcx, rbx
  00613	4c 8b f3	 mov	 r14, rbx
  00616	e8 00 00 00 00	 call	 _Py_IncRef
$LN149@dialect_ne:
  0061b	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+224]
$err$20698:

; 452  : err:
; 453  :     Py_XDECREF(self);

  00623	48 8b cb	 mov	 rcx, rbx
  00626	e8 00 00 00 00	 call	 _Py_DecRef

; 454  :     Py_XDECREF(dialect);

  0062b	48 8b 4d 7f	 mov	 rcx, QWORD PTR dialect$[rbp-121]
  0062f	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]
  00637	4c 8b a4 24 b8
	00 00 00	 mov	 r12, QWORD PTR [rsp+184]
  0063f	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+232]
  00647	48 85 c9	 test	 rcx, rcx
  0064a	74 05		 je	 SHORT $LN35@dialect_ne
  0064c	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@dialect_ne:

; 455  :     Py_XDECREF(delimiter);

  00651	48 8b 4d 07	 mov	 rcx, QWORD PTR delimiter$[rbp-121]
  00655	48 85 c9	 test	 rcx, rcx
  00658	74 05		 je	 SHORT $LN31@dialect_ne
  0065a	e8 00 00 00 00	 call	 _Py_DecRef
$LN31@dialect_ne:

; 456  :     Py_XDECREF(doublequote);

  0065f	48 8b 4d 0f	 mov	 rcx, QWORD PTR doublequote$[rbp-121]
  00663	48 85 c9	 test	 rcx, rcx
  00666	74 05		 je	 SHORT $LN27@dialect_ne
  00668	e8 00 00 00 00	 call	 _Py_DecRef
$LN27@dialect_ne:

; 457  :     Py_XDECREF(escapechar);

  0066d	48 8b 4d 17	 mov	 rcx, QWORD PTR escapechar$[rbp-121]
  00671	48 85 c9	 test	 rcx, rcx
  00674	74 05		 je	 SHORT $LN23@dialect_ne
  00676	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@dialect_ne:

; 458  :     Py_XDECREF(lineterminator);

  0067b	48 8b 4d 1f	 mov	 rcx, QWORD PTR lineterminator$[rbp-121]
  0067f	48 85 c9	 test	 rcx, rcx
  00682	74 05		 je	 SHORT $LN19@dialect_ne
  00684	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@dialect_ne:

; 459  :     Py_XDECREF(quotechar);

  00689	48 8b 4d f7	 mov	 rcx, QWORD PTR quotechar$[rbp-121]
  0068d	48 85 c9	 test	 rcx, rcx
  00690	74 05		 je	 SHORT $LN15@dialect_ne
  00692	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@dialect_ne:

; 460  :     Py_XDECREF(quoting);

  00697	48 8b 4d ff	 mov	 rcx, QWORD PTR quoting$[rbp-121]
  0069b	48 85 c9	 test	 rcx, rcx
  0069e	74 05		 je	 SHORT $LN11@dialect_ne
  006a0	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@dialect_ne:

; 461  :     Py_XDECREF(skipinitialspace);

  006a5	48 8b 4d 27	 mov	 rcx, QWORD PTR skipinitialspace$[rbp-121]
  006a9	48 85 c9	 test	 rcx, rcx
  006ac	74 05		 je	 SHORT $LN7@dialect_ne
  006ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@dialect_ne:

; 462  :     Py_XDECREF(strict);

  006b3	48 8b 4d 2f	 mov	 rcx, QWORD PTR strict$[rbp-121]
  006b7	48 85 c9	 test	 rcx, rcx
  006ba	74 05		 je	 SHORT $LN3@dialect_ne
  006bc	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@dialect_ne:

; 463  :     return ret;

  006c1	49 8b c6	 mov	 rax, r14
$LN107@dialect_ne:

; 464  : }

  006c4	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  006cb	41 5e		 pop	 r14
  006cd	5b		 pop	 rbx
  006ce	5d		 pop	 rbp
  006cf	c3		 ret	 0
dialect_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
EXTRN	PyObject_Call:PROC
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_call_dialect DD imagerel _call_dialect
	DD	imagerel _call_dialect+104
	DD	imagerel $unwind$_call_dialect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_call_dialect DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _call_dialect
_TEXT	SEGMENT
dialect_inst$ = 48
kwargs$ = 56
_call_dialect PROC					; COMDAT

; 521  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b d1	 mov	 rdx, rcx

; 522  :     PyObject *ctor_args;
; 523  :     PyObject *dialect;
; 524  : 
; 525  :     ctor_args = Py_BuildValue(dialect_inst ? "(O)" : "()", dialect_inst);

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00017	48 85 d2	 test	 rdx, rdx
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00021	48 0f 45 c8	 cmovne	 rcx, rax
  00025	e8 00 00 00 00	 call	 Py_BuildValue
  0002a	48 8b f8	 mov	 rdi, rax

; 526  :     if (ctor_args == NULL)

  0002d	48 85 c0	 test	 rax, rax
  00030	75 0b		 jne	 SHORT $LN1@call_diale

; 531  : }

  00032	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN1@call_diale:

; 527  :         return NULL;
; 528  :     dialect = PyObject_Call((PyObject *)&Dialect_Type, ctor_args, kwargs);

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Dialect_Type
  00044	4c 8b c3	 mov	 r8, rbx
  00047	48 8b d0	 mov	 rdx, rax
  0004a	e8 00 00 00 00	 call	 PyObject_Call

; 529  :     Py_DECREF(ctor_args);

  0004f	48 8b cf	 mov	 rcx, rdi
  00052	48 8b d8	 mov	 rbx, rax
  00055	e8 00 00 00 00	 call	 _Py_DecRef

; 530  :     return dialect;

  0005a	48 8b c3	 mov	 rax, rbx

; 531  : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
_call_dialect ENDP
_TEXT	ENDS
EXTRN	PyList_Append:PROC
EXTRN	PyNumber_Float:PROC
EXTRN	PyUnicode_FromKindAndData:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_save_field DD imagerel parse_save_field
	DD	imagerel parse_save_field+61
	DD	imagerel $unwind$parse_save_field
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$parse_save_field DD imagerel parse_save_field+61
	DD	imagerel parse_save_field+130
	DD	imagerel $chain$0$parse_save_field
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$parse_save_field DD imagerel parse_save_field+130
	DD	imagerel parse_save_field+171
	DD	imagerel $chain$2$parse_save_field
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$parse_save_field DD 020021H
	DD	066400H
	DD	imagerel parse_save_field
	DD	imagerel parse_save_field+61
	DD	imagerel $unwind$parse_save_field
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$parse_save_field DD 020521H
	DD	066405H
	DD	imagerel parse_save_field
	DD	imagerel parse_save_field+61
	DD	imagerel $unwind$parse_save_field
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_save_field DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT parse_save_field
_TEXT	SEGMENT
self$ = 48
parse_save_field PROC					; COMDAT

; 538  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 539  :     PyObject *field;
; 540  : 
; 541  :     field = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
; 542  :                                       (void *) self->field, self->field_len);

  0000a	4c 8b 81 90 00
	00 00		 mov	 r8, QWORD PTR [rcx+144]
  00011	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	b9 04 00 00 00	 mov	 ecx, 4
  00020	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  00025	48 8b d8	 mov	 rbx, rax

; 543  :     if (field == NULL)

  00028	48 85 c0	 test	 rax, rax
  0002b	75 0e		 jne	 SHORT $LN3@parse_save

; 544  :         return -1;

  0002d	83 c8 ff	 or	 eax, -1

; 558  :     return 0;
; 559  : }

  00030	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN3@parse_save:

; 545  :     self->field_len = 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00042	48 89 87 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rax

; 546  :     if (self->numeric_field) {

  00049	39 87 98 00 00
	00		 cmp	 DWORD PTR [rdi+152], eax
  0004f	74 34		 je	 SHORT $LN2@parse_save

; 547  :         PyObject *tmp;
; 548  : 
; 549  :         self->numeric_field = 0;
; 550  :         tmp = PyNumber_Float(field);

  00051	48 8b cb	 mov	 rcx, rbx
  00054	89 87 98 00 00
	00		 mov	 DWORD PTR [rdi+152], eax
  0005a	e8 00 00 00 00	 call	 PyNumber_Float

; 551  :         Py_DECREF(field);

  0005f	48 8b cb	 mov	 rcx, rbx
  00062	48 8b f0	 mov	 rsi, rax
  00065	e8 00 00 00 00	 call	 _Py_DecRef

; 552  :         if (tmp == NULL)

  0006a	48 85 f6	 test	 rsi, rsi
  0006d	75 13		 jne	 SHORT $LN1@parse_save

; 553  :             return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 558  :     return 0;
; 559  : }

  00077	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
$LN1@parse_save:

; 554  :         field = tmp;

  00082	48 8b de	 mov	 rbx, rsi
$LN2@parse_save:

; 555  :     }
; 556  :     PyList_Append(self->fields, field);

  00085	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  00089	48 8b d3	 mov	 rdx, rbx
  0008c	e8 00 00 00 00	 call	 PyList_Append

; 557  :     Py_DECREF(field);

  00091	48 8b cb	 mov	 rcx, rbx
  00094	e8 00 00 00 00	 call	 _Py_DecRef
  00099	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 558  :     return 0;
; 559  : }

  0009e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000a3	33 c0		 xor	 eax, eax
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
parse_save_field ENDP
_TEXT	ENDS
EXTRN	PyMem_Realloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_grow_buff DD imagerel parse_grow_buff
	DD	imagerel parse_grow_buff+183
	DD	imagerel $unwind$parse_grow_buff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_grow_buff DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT parse_grow_buff
_TEXT	SEGMENT
self$ = 48
parse_grow_buff PROC					; COMDAT

; 563  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 564  :     if (self->field_size == 0) {

  00006	48 8b 81 88 00
	00 00		 mov	 rax, QWORD PTR [rcx+136]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 85 c0	 test	 rax, rax
  00013	75 41		 jne	 SHORT $LN5@parse_grow

; 565  :         self->field_size = 4096;

  00015	48 c7 81 88 00
	00 00 00 10 00
	00		 mov	 QWORD PTR [rcx+136], 4096 ; 00001000H

; 566  :         if (self->field != NULL)

  00020	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 05		 je	 SHORT $LN4@parse_grow

; 567  :             PyMem_Free(self->field);

  0002c	e8 00 00 00 00	 call	 PyMem_Free
$LN4@parse_grow:

; 568  :         self->field = PyMem_New(Py_UCS4, self->field_size);

  00031	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00038	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00042	48 3b c8	 cmp	 rcx, rax
  00045	76 04		 jbe	 SHORT $LN8@parse_grow
  00047	33 c0		 xor	 eax, eax
  00049	eb 55		 jmp	 SHORT $LN11@parse_grow
$LN8@parse_grow:
  0004b	48 c1 e1 02	 shl	 rcx, 2
  0004f	e8 00 00 00 00	 call	 PyMem_Malloc

; 569  :     }
; 570  :     else {

  00054	eb 4a		 jmp	 SHORT $LN11@parse_grow
$LN5@parse_grow:

; 571  :         Py_UCS4 *field = self->field;
; 572  :         if (self->field_size > PY_SSIZE_T_MAX / 2) {

  00056	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH
  00060	48 3b c1	 cmp	 rax, rcx
  00063	7e 0d		 jle	 SHORT $LN2@parse_grow
$LN12@parse_grow:

; 573  :             PyErr_NoMemory();

  00065	e8 00 00 00 00	 call	 PyErr_NoMemory

; 574  :             return 0;

  0006a	33 c0		 xor	 eax, eax

; 584  : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
$LN2@parse_grow:

; 575  :         }
; 576  :         self->field_size *= 2;

  00072	48 8d 14 00	 lea	 rdx, QWORD PTR [rax+rax]

; 577  :         self->field = PyMem_Resize(field, Py_UCS4, self->field_size);

  00076	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00080	48 89 93 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rdx
  00087	48 3b d0	 cmp	 rdx, rax
  0008a	76 04		 jbe	 SHORT $LN10@parse_grow
  0008c	33 c0		 xor	 eax, eax
  0008e	eb 10		 jmp	 SHORT $LN11@parse_grow
$LN10@parse_grow:
  00090	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00097	48 c1 e2 02	 shl	 rdx, 2
  0009b	e8 00 00 00 00	 call	 PyMem_Realloc
$LN11@parse_grow:
  000a0	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 578  :     }
; 579  :     if (self->field == NULL) {

  000a7	48 85 c0	 test	 rax, rax

; 580  :         PyErr_NoMemory();
; 581  :         return 0;

  000aa	74 b9		 je	 SHORT $LN12@parse_grow

; 582  :     }
; 583  :     return 1;

  000ac	b8 01 00 00 00	 mov	 eax, 1

; 584  : }

  000b1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
parse_grow_buff ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LGBILMFL@field?5larger?5than?5field?5limit?5?$CI?$CF@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_add_char DD imagerel parse_add_char
	DD	imagerel parse_add_char+200
	DD	imagerel $unwind$parse_add_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_add_char DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CE@LGBILMFL@field?5larger?5than?5field?5limit?5?$CI?$CF@
CONST	SEGMENT
??_C@_0CE@LGBILMFL@field?5larger?5than?5field?5limit?5?$CI?$CF@ DB 'field'
	DB	' larger than field limit (%ld)', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parse_add_char
_TEXT	SEGMENT
self$ = 48
c$ = 56
parse_add_char PROC					; COMDAT

; 588  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 589  :     if (self->field_len >= _csvstate_global->field_limit) {

  0000f	48 8b b9 90 00
	00 00		 mov	 rdi, QWORD PTR [rcx+144]
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00020	8b f2		 mov	 esi, edx
  00022	e8 00 00 00 00	 call	 PyState_FindModule
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 PyModule_GetState
  0002f	4c 63 40 10	 movsxd	 r8, DWORD PTR [rax+16]
  00033	49 3b f8	 cmp	 rdi, r8
  00036	7c 51		 jl	 SHORT $LN2@parse_add_

; 590  :         PyErr_Format(_csvstate_global->error_obj, "field larger than field limit (%ld)",
; 591  :                      _csvstate_global->field_limit);

  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  0003f	e8 00 00 00 00	 call	 PyState_FindModule
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 PyModule_GetState
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00053	48 8b d8	 mov	 rbx, rax
  00056	e8 00 00 00 00	 call	 PyState_FindModule
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 PyModule_GetState
  00063	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@LGBILMFL@field?5larger?5than?5field?5limit?5?$CI?$CF@
  0006d	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00071	e8 00 00 00 00	 call	 PyErr_Format
$LN5@parse_add_:

; 592  :         return -1;

  00076	83 c8 ff	 or	 eax, -1

; 597  :     return 0;
; 598  : }

  00079	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
$LN2@parse_add_:

; 593  :     }
; 594  :     if (self->field_len == self->field_size && !parse_grow_buff(self))

  00089	48 3b bb 88 00
	00 00		 cmp	 rdi, QWORD PTR [rbx+136]
  00090	75 0c		 jne	 SHORT $LN1@parse_add_
  00092	48 8b cb	 mov	 rcx, rbx
  00095	e8 00 00 00 00	 call	 parse_grow_buff
  0009a	85 c0		 test	 eax, eax

; 595  :         return -1;

  0009c	74 d8		 je	 SHORT $LN5@parse_add_
$LN1@parse_add_:

; 596  :     self->field[self->field_len++] = c;

  0009e	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  000a5	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000ac	89 34 88	 mov	 DWORD PTR [rax+rcx*4], esi
  000af	48 ff 83 90 00
	00 00		 inc	 QWORD PTR [rbx+144]

; 597  :     return 0;
; 598  : }

  000b6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000bb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c0	33 c0		 xor	 eax, eax
  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	c3		 ret	 0
parse_add_char ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GE@PLHPFOMK@new?9line?5character?5seen?5in?5unquo@ ; `string'
PUBLIC	??_C@_0BJ@HMHEPCIE@?8?$CFc?8?5expected?5after?5?8?$CFc?8?$AA@ ; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_process_char DD imagerel parse_process_char
	DD	imagerel parse_process_char+728
	DD	imagerel $unwind$parse_process_char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_process_char DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0GE@PLHPFOMK@new?9line?5character?5seen?5in?5unquo@
CONST	SEGMENT
??_C@_0GE@PLHPFOMK@new?9line?5character?5seen?5in?5unquo@ DB 'new-line ch'
	DB	'aracter seen in unquoted field - do you need to open the file'
	DB	' in universal-newline mode?', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMHEPCIE@?8?$CFc?8?5expected?5after?5?8?$CFc?8?$AA@
CONST	SEGMENT
??_C@_0BJ@HMHEPCIE@?8?$CFc?8?5expected?5after?5?8?$CFc?8?$AA@ DB '''%c'' '
	DB	'expected after ''%c''', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT parse_process_char
_TEXT	SEGMENT
self$ = 48
c$ = 56
parse_process_char PROC					; COMDAT

; 602  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 603  :     DialectObj *dialect = self->dialect;
; 604  : 
; 605  :     switch (self->state) {

  00014	48 63 41 78	 movsxd	 rax, DWORD PTR [rcx+120]
  00018	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]
  0001c	8b da		 mov	 ebx, edx
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	83 f8 07	 cmp	 eax, 7
  00024	0f 87 c0 00 00
	00		 ja	 $LN4@parse_proc
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00031	8b 94 81 00 00
	00 00		 mov	 edx, DWORD PTR $LN73@parse_proc[rcx+rax*4]
  00038	48 03 d1	 add	 rdx, rcx
  0003b	ff e2		 jmp	 rdx
$LN68@parse_proc:

; 606  :     case START_RECORD:
; 607  :         /* start of record */
; 608  :         if (c == '\0')

  0003d	85 db		 test	 ebx, ebx
  0003f	0f 84 a5 00 00
	00		 je	 $LN4@parse_proc

; 609  :             /* empty line - return [] */
; 610  :             break;
; 611  :         else if (c == '\n' || c == '\r') {

  00045	83 fb 0a	 cmp	 ebx, 10
  00048	74 3a		 je	 SHORT $LN64@parse_proc
  0004a	83 fb 0d	 cmp	 ebx, 13
  0004d	74 35		 je	 SHORT $LN64@parse_proc

; 614  :         }
; 615  :         /* normal character - handle as START_FIELD */
; 616  :         self->state = START_FIELD;

  0004f	c7 47 78 01 00
	00 00		 mov	 DWORD PTR [rdi+120], 1
$LN63@parse_proc:

; 617  :         /* fallthru */
; 618  :     case START_FIELD:
; 619  :         /* expecting field */
; 620  :         if (c == '\n' || c == '\r' || c == '\0') {

  00056	83 fb 0a	 cmp	 ebx, 10
  00059	74 79		 je	 SHORT $LN61@parse_proc
  0005b	83 fb 0d	 cmp	 ebx, 13
  0005e	74 74		 je	 SHORT $LN61@parse_proc
  00060	85 db		 test	 ebx, ebx
  00062	74 70		 je	 SHORT $LN61@parse_proc

; 625  :         }
; 626  :         else if (c == dialect->quotechar &&
; 627  :                  dialect->quoting != QUOTE_NONE) {

  00064	3b 5e 68	 cmp	 ebx, DWORD PTR [rsi+104]
  00067	75 0d		 jne	 SHORT $LN58@parse_proc
  00069	83 be 80 00 00
	00 03		 cmp	 DWORD PTR [rsi+128], 3

; 628  :             /* start quoted field */
; 629  :             self->state = IN_QUOTED_FIELD;

  00070	0f 85 65 01 00
	00		 jne	 $LN21@parse_proc
$LN58@parse_proc:

; 630  :         }
; 631  :         else if (c == dialect->escapechar) {

  00076	3b 5e 6c	 cmp	 ebx, DWORD PTR [rsi+108]
  00079	75 12		 jne	 SHORT $LN56@parse_proc
$LN74@parse_proc:

; 632  :             /* possible escaped character */
; 633  :             self->state = ESCAPED_CHAR;

  0007b	c7 47 78 02 00
	00 00		 mov	 DWORD PTR [rdi+120], 2
  00082	eb 66		 jmp	 SHORT $LN4@parse_proc
$LN64@parse_proc:

; 612  :             self->state = EAT_CRNL;

  00084	c7 47 78 07 00
	00 00		 mov	 DWORD PTR [rdi+120], 7

; 613  :             break;

  0008b	eb 5d		 jmp	 SHORT $LN4@parse_proc
$LN56@parse_proc:

; 634  :         }
; 635  :         else if (c == ' ' && dialect->skipinitialspace)

  0008d	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00090	75 06		 jne	 SHORT $LN54@parse_proc
  00092	83 7e 70 00	 cmp	 DWORD PTR [rsi+112], 0
  00096	75 52		 jne	 SHORT $LN4@parse_proc
$LN54@parse_proc:

; 636  :             /* ignore space at start of field */
; 637  :             ;
; 638  :         else if (c == dialect->delimiter) {

  00098	3b 5e 64	 cmp	 ebx, DWORD PTR [rsi+100]
  0009b	75 11		 jne	 SHORT $LN52@parse_proc

; 639  :             /* save empty field */
; 640  :             if (parse_save_field(self) < 0)

  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	e8 00 00 00 00	 call	 parse_save_field
  000a5	85 c0		 test	 eax, eax
  000a7	79 41		 jns	 SHORT $LN4@parse_proc
$LN76@parse_proc:

; 641  :                 return -1;

  000a9	83 c8 ff	 or	 eax, -1
  000ac	eb 3e		 jmp	 SHORT $LN71@parse_proc
$LN52@parse_proc:

; 642  :         }
; 643  :         else {
; 644  :             /* begin new unquoted field */
; 645  :             if (dialect->quoting == QUOTE_NONNUMERIC)

  000ae	83 be 80 00 00
	00 02		 cmp	 DWORD PTR [rsi+128], 2
  000b5	75 0a		 jne	 SHORT $LN49@parse_proc

; 646  :                 self->numeric_field = 1;

  000b7	c7 87 98 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rdi+152], 1
$LN49@parse_proc:

; 647  :             if (parse_add_char(self, c) < 0)

  000c1	8b d3		 mov	 edx, ebx
  000c3	48 8b cf	 mov	 rcx, rdi
  000c6	e8 00 00 00 00	 call	 parse_add_char
  000cb	85 c0		 test	 eax, eax
  000cd	79 4a		 jns	 SHORT $LN45@parse_proc

; 648  :                 return -1;

  000cf	83 c8 ff	 or	 eax, -1
  000d2	eb 18		 jmp	 SHORT $LN71@parse_proc
$LN61@parse_proc:

; 621  :             /* save empty field - return [fields] */
; 622  :             if (parse_save_field(self) < 0)

  000d4	48 8b cf	 mov	 rcx, rdi
  000d7	e8 00 00 00 00	 call	 parse_save_field
  000dc	85 c0		 test	 eax, eax

; 623  :                 return -1;

  000de	78 c9		 js	 SHORT $LN76@parse_proc
$LN60@parse_proc:

; 624  :             self->state = (c == '\0' ? START_RECORD : EAT_CRNL);

  000e0	f7 db		 neg	 ebx
  000e2	1b c0		 sbb	 eax, eax
  000e4	83 e0 07	 and	 eax, 7
$LN75@parse_proc:

; 658  :         self->state = IN_FIELD;

  000e7	89 47 78	 mov	 DWORD PTR [rdi+120], eax
$LN4@parse_proc:

; 762  :             return -1;
; 763  :         }
; 764  :         break;
; 765  : 
; 766  :     }
; 767  :     return 0;

  000ea	33 c0		 xor	 eax, eax
$LN71@parse_proc:

; 768  : }

  000ec	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f1	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000f6	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000fb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ff	5f		 pop	 rdi
  00100	c3		 ret	 0
$LN47@parse_proc:

; 649  :             self->state = IN_FIELD;
; 650  :         }
; 651  :         break;
; 652  : 
; 653  :     case ESCAPED_CHAR:
; 654  :         if (c == '\0')

  00101	b8 0a 00 00 00	 mov	 eax, 10
  00106	85 db		 test	 ebx, ebx

; 655  :             c = '\n';
; 656  :         if (parse_add_char(self, c) < 0)

  00108	48 8b cf	 mov	 rcx, rdi
  0010b	0f 44 d8	 cmove	 ebx, eax
  0010e	8b d3		 mov	 edx, ebx
  00110	e8 00 00 00 00	 call	 parse_add_char
  00115	85 c0		 test	 eax, eax

; 657  :             return -1;

  00117	78 90		 js	 SHORT $LN76@parse_proc
$LN45@parse_proc:

; 658  :         self->state = IN_FIELD;

  00119	b8 03 00 00 00	 mov	 eax, 3

; 659  :         break;

  0011e	eb c7		 jmp	 SHORT $LN75@parse_proc
$LN44@parse_proc:

; 660  : 
; 661  :     case IN_FIELD:
; 662  :         /* in unquoted field */
; 663  :         if (c == '\n' || c == '\r' || c == '\0') {

  00120	83 fb 0a	 cmp	 ebx, 10
  00123	74 40		 je	 SHORT $LN42@parse_proc
  00125	83 fb 0d	 cmp	 ebx, 13
  00128	74 3b		 je	 SHORT $LN42@parse_proc
  0012a	85 db		 test	 ebx, ebx
  0012c	74 37		 je	 SHORT $LN42@parse_proc

; 667  :             self->state = (c == '\0' ? START_RECORD : EAT_CRNL);
; 668  :         }
; 669  :         else if (c == dialect->escapechar) {

  0012e	3b 5e 6c	 cmp	 ebx, DWORD PTR [rsi+108]

; 670  :             /* possible escaped character */
; 671  :             self->state = ESCAPED_CHAR;

  00131	0f 84 44 ff ff
	ff		 je	 $LN74@parse_proc

; 672  :         }
; 673  :         else if (c == dialect->delimiter) {
; 674  :             /* save field - wait for new field */
; 675  :             if (parse_save_field(self) < 0)

  00137	48 8b cf	 mov	 rcx, rdi
  0013a	3b 5e 64	 cmp	 ebx, DWORD PTR [rsi+100]
  0013d	75 16		 jne	 SHORT $LN37@parse_proc
  0013f	e8 00 00 00 00	 call	 parse_save_field
  00144	85 c0		 test	 eax, eax

; 676  :                 return -1;

  00146	0f 88 5d ff ff
	ff		 js	 $LN76@parse_proc
$LN36@parse_proc:

; 677  :             self->state = START_FIELD;

  0014c	c7 47 78 01 00
	00 00		 mov	 DWORD PTR [rdi+120], 1

; 678  :         }
; 679  :         else {

  00153	eb 95		 jmp	 SHORT $LN4@parse_proc
$LN37@parse_proc:

; 680  :             /* normal character - save in field */
; 681  :             if (parse_add_char(self, c) < 0)

  00155	8b d3		 mov	 edx, ebx
  00157	e8 00 00 00 00	 call	 parse_add_char
  0015c	85 c0		 test	 eax, eax
  0015e	79 8a		 jns	 SHORT $LN4@parse_proc

; 682  :                 return -1;

  00160	83 c8 ff	 or	 eax, -1
  00163	eb 87		 jmp	 SHORT $LN71@parse_proc
$LN42@parse_proc:

; 664  :             /* end of line - return [fields] */
; 665  :             if (parse_save_field(self) < 0)

  00165	48 8b cf	 mov	 rcx, rdi
  00168	e8 00 00 00 00	 call	 parse_save_field
  0016d	85 c0		 test	 eax, eax
  0016f	0f 89 6b ff ff
	ff		 jns	 $LN60@parse_proc

; 666  :                 return -1;

  00175	83 c8 ff	 or	 eax, -1
  00178	e9 6f ff ff ff	 jmp	 $LN71@parse_proc
$LN33@parse_proc:

; 683  :         }
; 684  :         break;
; 685  : 
; 686  :     case IN_QUOTED_FIELD:
; 687  :         /* in quoted field */
; 688  :         if (c == '\0')

  0017d	85 db		 test	 ebx, ebx
  0017f	0f 84 65 ff ff
	ff		 je	 $LN4@parse_proc

; 689  :             ;
; 690  :         else if (c == dialect->escapechar) {

  00185	3b 5e 6c	 cmp	 ebx, DWORD PTR [rsi+108]
  00188	75 0c		 jne	 SHORT $LN30@parse_proc

; 691  :             /* Possible escape character */
; 692  :             self->state = ESCAPE_IN_QUOTED_FIELD;

  0018a	c7 47 78 05 00
	00 00		 mov	 DWORD PTR [rdi+120], 5

; 693  :         }
; 694  :         else if (c == dialect->quotechar &&

  00191	e9 54 ff ff ff	 jmp	 $LN4@parse_proc
$LN30@parse_proc:

; 695  :                  dialect->quoting != QUOTE_NONE) {

  00196	3b 5e 68	 cmp	 ebx, DWORD PTR [rsi+104]
  00199	75 1f		 jne	 SHORT $LN28@parse_proc
  0019b	83 be 80 00 00
	00 03		 cmp	 DWORD PTR [rsi+128], 3
  001a2	74 16		 je	 SHORT $LN28@parse_proc

; 696  :             if (dialect->doublequote) {

  001a4	83 7e 60 00	 cmp	 DWORD PTR [rsi+96], 0
  001a8	b8 03 00 00 00	 mov	 eax, 3
  001ad	b9 06 00 00 00	 mov	 ecx, 6
  001b2	0f 45 c1	 cmovne	 eax, ecx

; 697  :                 /* doublequote; " represented by "" */
; 698  :                 self->state = QUOTE_IN_QUOTED_FIELD;
; 699  :             }
; 700  :             else {
; 701  :                 /* end of quote part of field */
; 702  :                 self->state = IN_FIELD;
; 703  :             }
; 704  :         }
; 705  :         else {

  001b5	e9 2d ff ff ff	 jmp	 $LN75@parse_proc
$LN28@parse_proc:

; 706  :             /* normal character - save in field */
; 707  :             if (parse_add_char(self, c) < 0)

  001ba	48 8b cf	 mov	 rcx, rdi

; 708  :                 return -1;

  001bd	eb 96		 jmp	 SHORT $LN37@parse_proc
$LN23@parse_proc:

; 709  :         }
; 710  :         break;
; 711  : 
; 712  :     case ESCAPE_IN_QUOTED_FIELD:
; 713  :         if (c == '\0')

  001bf	b8 0a 00 00 00	 mov	 eax, 10
  001c4	85 db		 test	 ebx, ebx
  001c6	0f 44 d8	 cmove	 ebx, eax
$LN79@parse_proc:

; 714  :             c = '\n';
; 715  :         if (parse_add_char(self, c) < 0)

  001c9	8b d3		 mov	 edx, ebx
  001cb	48 8b cf	 mov	 rcx, rdi
  001ce	e8 00 00 00 00	 call	 parse_add_char
  001d3	85 c0		 test	 eax, eax

; 716  :             return -1;

  001d5	0f 88 ce fe ff
	ff		 js	 $LN76@parse_proc
$LN21@parse_proc:

; 717  :         self->state = IN_QUOTED_FIELD;

  001db	c7 47 78 04 00
	00 00		 mov	 DWORD PTR [rdi+120], 4

; 718  :         break;

  001e2	e9 03 ff ff ff	 jmp	 $LN4@parse_proc
$LN20@parse_proc:

; 719  : 
; 720  :     case QUOTE_IN_QUOTED_FIELD:
; 721  :         /* doublequote - seen a quote in an quoted field */
; 722  :         if (dialect->quoting != QUOTE_NONE &&
; 723  :             c == dialect->quotechar) {

  001e7	83 be 80 00 00
	00 03		 cmp	 DWORD PTR [rsi+128], 3
  001ee	74 05		 je	 SHORT $LN19@parse_proc
  001f0	3b 5e 68	 cmp	 ebx, DWORD PTR [rsi+104]

; 724  :             /* save "" as " */
; 725  :             if (parse_add_char(self, c) < 0)
; 726  :                 return -1;

  001f3	74 d4		 je	 SHORT $LN79@parse_proc
$LN19@parse_proc:

; 727  :             self->state = IN_QUOTED_FIELD;
; 728  :         }
; 729  :         else if (c == dialect->delimiter) {

  001f5	8b 6e 64	 mov	 ebp, DWORD PTR [rsi+100]
  001f8	3b dd		 cmp	 ebx, ebp
  001fa	75 18		 jne	 SHORT $LN16@parse_proc

; 730  :             /* save field - wait for new field */
; 731  :             if (parse_save_field(self) < 0)

  001fc	48 8b cf	 mov	 rcx, rdi
  001ff	e8 00 00 00 00	 call	 parse_save_field
  00204	85 c0		 test	 eax, eax
  00206	0f 89 40 ff ff
	ff		 jns	 $LN36@parse_proc

; 641  :                 return -1;

  0020c	83 c8 ff	 or	 eax, -1
  0020f	e9 d8 fe ff ff	 jmp	 $LN71@parse_proc
$LN16@parse_proc:

; 732  :                 return -1;
; 733  :             self->state = START_FIELD;
; 734  :         }
; 735  :         else if (c == '\n' || c == '\r' || c == '\0') {

  00214	83 fb 0a	 cmp	 ebx, 10
  00217	0f 84 48 ff ff
	ff		 je	 $LN42@parse_proc
  0021d	83 fb 0d	 cmp	 ebx, 13
  00220	0f 84 3f ff ff
	ff		 je	 $LN42@parse_proc
  00226	85 db		 test	 ebx, ebx
  00228	0f 84 37 ff ff
	ff		 je	 $LN42@parse_proc

; 736  :             /* end of line - return [fields] */
; 737  :             if (parse_save_field(self) < 0)
; 738  :                 return -1;
; 739  :             self->state = (c == '\0' ? START_RECORD : EAT_CRNL);
; 740  :         }
; 741  :         else if (!dialect->strict) {

  0022e	83 be 84 00 00
	00 00		 cmp	 DWORD PTR [rsi+132], 0

; 742  :             if (parse_add_char(self, c) < 0)
; 743  :                 return -1;

  00235	0f 84 86 fe ff
	ff		 je	 $LN49@parse_proc

; 744  :             self->state = IN_FIELD;
; 745  :         }
; 746  :         else {
; 747  :             /* illegal */
; 748  :             PyErr_Format(_csvstate_global->error_obj, "'%c' expected after '%c'",
; 749  :                             dialect->delimiter,
; 750  :                             dialect->quotechar);

  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00242	e8 00 00 00 00	 call	 PyState_FindModule
  00247	48 8b c8	 mov	 rcx, rax
  0024a	e8 00 00 00 00	 call	 PyModule_GetState
  0024f	44 8b 4e 68	 mov	 r9d, DWORD PTR [rsi+104]
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@HMHEPCIE@?8?$CFc?8?5expected?5after?5?8?$CFc?8?$AA@
  0025a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0025d	44 8b c5	 mov	 r8d, ebp
  00260	e8 00 00 00 00	 call	 PyErr_Format
  00265	83 c8 ff	 or	 eax, -1
  00268	e9 7f fe ff ff	 jmp	 $LN71@parse_proc
$LN6@parse_proc:

; 751  :             return -1;
; 752  :         }
; 753  :         break;
; 754  : 
; 755  :     case EAT_CRNL:
; 756  :         if (c == '\n' || c == '\r')

  0026d	83 fb 0a	 cmp	 ebx, 10
  00270	0f 84 74 fe ff
	ff		 je	 $LN4@parse_proc
  00276	83 fb 0d	 cmp	 ebx, 13
  00279	0f 84 6b fe ff
	ff		 je	 $LN4@parse_proc

; 757  :             ;
; 758  :         else if (c == '\0')

  0027f	85 db		 test	 ebx, ebx
  00281	75 08		 jne	 SHORT $LN2@parse_proc

; 759  :             self->state = START_RECORD;

  00283	89 5f 78	 mov	 DWORD PTR [rdi+120], ebx

; 760  :         else {

  00286	e9 5f fe ff ff	 jmp	 $LN4@parse_proc
$LN2@parse_proc:

; 761  :             PyErr_Format(_csvstate_global->error_obj, "new-line character seen in unquoted field - do you need to open the file in universal-newline mode?");

  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00292	e8 00 00 00 00	 call	 PyState_FindModule
  00297	48 8b c8	 mov	 rcx, rax
  0029a	e8 00 00 00 00	 call	 PyModule_GetState
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GE@PLHPFOMK@new?9line?5character?5seen?5in?5unquo@
  002a6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002a9	e8 00 00 00 00	 call	 PyErr_Format
  002ae	83 c8 ff	 or	 eax, -1
  002b1	e9 36 fe ff ff	 jmp	 $LN71@parse_proc
  002b6	66 90		 npad	 2
$LN73@parse_proc:

; 768  : }

  002b8	00 00 00 00	 DD	 $LN68@parse_proc
  002bc	00 00 00 00	 DD	 $LN63@parse_proc
  002c0	00 00 00 00	 DD	 $LN47@parse_proc
  002c4	00 00 00 00	 DD	 $LN44@parse_proc
  002c8	00 00 00 00	 DD	 $LN33@parse_proc
  002cc	00 00 00 00	 DD	 $LN23@parse_proc
  002d0	00 00 00 00	 DD	 $LN20@parse_proc
  002d4	00 00 00 00	 DD	 $LN6@parse_proc
parse_process_char ENDP
_TEXT	ENDS
EXTRN	PyList_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$parse_reset DD imagerel parse_reset
	DD	imagerel parse_reset+182
	DD	imagerel $unwind$parse_reset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_reset DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT parse_reset
_TEXT	SEGMENT
self$ = 64
parse_reset PROC					; COMDAT

; 772  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 773  :     Py_XDECREF(self->fields);

  0000a	48 8b 59 70	 mov	 rbx, QWORD PTR [rcx+112]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 65		 je	 SHORT $LN4@parse_rese
  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 5c		 jne	 SHORT $LN4@parse_rese
  0001f	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00023	a8 20		 test	 al, 32			; 00000020H
  00025	75 4c		 jne	 SHORT $LN12@parse_rese
  00027	84 c0		 test	 al, al
  00029	78 48		 js	 SHORT $LN12@parse_rese
  0002b	a8 02		 test	 al, 2
  0002d	75 4c		 jne	 SHORT $LN4@parse_rese
  0002f	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00033	75 46		 jne	 SHORT $LN4@parse_rese
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00043	4c 8b cb	 mov	 r9, rbx
  00046	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0004c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00054	e8 00 00 00 00	 call	 _PyParallel_Guard
  00059	48 8b cb	 mov	 rcx, rbx
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN17@parse_rese
  00060	e8 00 00 00 00	 call	 _Px_Dealloc
  00065	eb 14		 jmp	 SHORT $LN4@parse_rese
$LN17@parse_rese:
  00067	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0006b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00071	eb 08		 jmp	 SHORT $LN4@parse_rese
$LN12@parse_rese:
  00073	48 8b cb	 mov	 rcx, rbx
  00076	e8 00 00 00 00	 call	 Px_DecRef
$LN4@parse_rese:

; 774  :     self->fields = PyList_New(0);

  0007b	33 c9		 xor	 ecx, ecx
  0007d	e8 00 00 00 00	 call	 PyList_New
  00082	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax

; 775  :     if (self->fields == NULL)

  00086	48 85 c0	 test	 rax, rax
  00089	75 0e		 jne	 SHORT $LN1@parse_rese

; 776  :         return -1;

  0008b	83 c8 ff	 or	 eax, -1

; 777  :     self->field_len = 0;
; 778  :     self->state = START_RECORD;
; 779  :     self->numeric_field = 0;
; 780  :     return 0;
; 781  : }

  0008e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00093	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
$LN1@parse_rese:
  00099	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009e	33 c0		 xor	 eax, eax
  000a0	48 89 87 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rax
  000a7	89 47 78	 mov	 DWORD PTR [rdi+120], eax
  000aa	89 87 98 00 00
	00		 mov	 DWORD PTR [rdi+152], eax
  000b0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b4	5f		 pop	 rdi
  000b5	c3		 ret	 0
parse_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@ ; `string'
PUBLIC	??_C@_0FB@IOCKMCCD@iterator?5should?5return?5strings?0?5@ ; `string'
PUBLIC	??_C@_0BI@DKJAPDDK@line?5contains?5NULL?5byte?$AA@ ; `string'
EXTRN	PyIter_Next:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Reader_iternext DD imagerel Reader_iternext
	DD	imagerel Reader_iternext+34
	DD	imagerel $unwind$Reader_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$Reader_iternext DD imagerel Reader_iternext+34
	DD	imagerel Reader_iternext+465
	DD	imagerel $chain$5$Reader_iternext
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$Reader_iternext DD imagerel Reader_iternext+465
	DD	imagerel Reader_iternext+577
	DD	imagerel $chain$7$Reader_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$Reader_iternext DD 0c0021H
	DD	04d400H
	DD	05c400H
	DD	067400H
	DD	0c6400H
	DD	0b5400H
	DD	0a3400H
	DD	imagerel Reader_iternext
	DD	imagerel Reader_iternext+34
	DD	imagerel $unwind$Reader_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$Reader_iternext DD 0c1e21H
	DD	04d41eH
	DD	05c419H
	DD	067414H
	DD	0c640fH
	DD	0b540aH
	DD	0a3405H
	DD	imagerel Reader_iternext
	DD	imagerel Reader_iternext+34
	DD	imagerel $unwind$Reader_iternext
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Reader_iternext DD 030801H
	DD	0f0046208H
	DD	0e002H
xdata	ENDS
;	COMDAT ??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@
CONST	SEGMENT
??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@ DB 'unexpected end of d'
	DB	'ata', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@IOCKMCCD@iterator?5should?5return?5strings?0?5@
CONST	SEGMENT
??_C@_0FB@IOCKMCCD@iterator?5should?5return?5strings?0?5@ DB 'iterator sh'
	DB	'ould return strings, not %.200s (did you open the file in tex'
	DB	't mode?)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DKJAPDDK@line?5contains?5NULL?5byte?$AA@
CONST	SEGMENT
??_C@_0BI@DKJAPDDK@line?5contains?5NULL?5byte?$AA@ DB 'line contains NULL'
	DB	' byte', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Reader_iternext
_TEXT	SEGMENT
self$ = 80
Reader_iternext PROC					; COMDAT

; 785  : {

  00000	41 56		 push	 r14
  00002	41 57		 push	 r15
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	4c 8b f1	 mov	 r14, rcx

; 786  :     PyObject *fields = NULL;

  0000b	45 33 ff	 xor	 r15d, r15d

; 787  :     Py_UCS4 c;
; 788  :     Py_ssize_t pos, linelen;
; 789  :     unsigned int kind;
; 790  :     void *data;
; 791  :     PyObject *lineobj;
; 792  : 
; 793  :     if (parse_reset(self) < 0)

  0000e	e8 00 00 00 00	 call	 parse_reset
  00013	85 c0		 test	 eax, eax
  00015	79 0b		 jns	 SHORT $LN43@Reader_ite

; 794  :         return NULL;

  00017	33 c0		 xor	 eax, eax

; 851  : }

  00019	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001d	41 5f		 pop	 r15
  0001f	41 5e		 pop	 r14
  00021	c3		 ret	 0
$LN43@Reader_ite:
  00022	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00027	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0002c	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00031	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00036	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0003b	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
$LL16@Reader_ite:

; 795  :     do {
; 796  :         lineobj = PyIter_Next(self->input_iter);

  00040	49 8b 4e 60	 mov	 rcx, QWORD PTR [r14+96]
  00044	e8 00 00 00 00	 call	 PyIter_Next
  00049	48 8b f8	 mov	 rdi, rax

; 797  :         if (lineobj == NULL) {

  0004c	48 85 c0	 test	 rax, rax
  0004f	0f 84 7c 01 00
	00		 je	 $LN34@Reader_ite

; 808  :         }
; 809  :         if (!PyUnicode_Check(lineobj)) {

  00055	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00059	f7 81 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rcx+256], 268435456 ; 10000000H
  00063	0f 84 0c 01 00
	00		 je	 $LN35@Reader_ite

; 817  :             return NULL;
; 818  :         }
; 819  :         if (PyUnicode_READY(lineobj) == -1) {

  00069	f6 40 70 80	 test	 BYTE PTR [rax+112], 128	; 00000080H
  0006d	75 11		 jne	 SHORT $LN40@Reader_ite
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00077	83 f8 ff	 cmp	 eax, -1
  0007a	0f 84 20 01 00
	00		 je	 $LN36@Reader_ite
$LN40@Reader_ite:

; 820  :             Py_DECREF(lineobj);
; 821  :             return NULL;
; 822  :         }
; 823  :         ++self->line_num;

  00080	41 ff 86 9c 00
	00 00		 inc	 DWORD PTR [r14+156]

; 824  :         kind = PyUnicode_KIND(lineobj);

  00087	8b 47 70	 mov	 eax, DWORD PTR [rdi+112]
  0008a	44 8b e8	 mov	 r13d, eax
  0008d	41 c1 ed 02	 shr	 r13d, 2
  00091	41 83 e5 07	 and	 r13d, 7

; 825  :         data = PyUnicode_DATA(lineobj);

  00095	a8 20		 test	 al, 32			; 00000020H
  00097	74 16		 je	 SHORT $LN24@Reader_ite
  00099	a8 40		 test	 al, 64			; 00000040H
  0009b	74 09		 je	 SHORT $LN22@Reader_ite
  0009d	48 8d 9f 80 00
	00 00		 lea	 rbx, QWORD PTR [rdi+128]
  000a4	eb 10		 jmp	 SHORT $LN25@Reader_ite
$LN22@Reader_ite:
  000a6	48 8d 9f a0 00
	00 00		 lea	 rbx, QWORD PTR [rdi+160]
  000ad	eb 07		 jmp	 SHORT $LN25@Reader_ite
$LN24@Reader_ite:
  000af	48 8b 9f a0 00
	00 00		 mov	 rbx, QWORD PTR [rdi+160]
$LN25@Reader_ite:

; 827  :         linelen = PyUnicode_GET_LENGTH(lineobj);

  000b6	48 8b 77 60	 mov	 rsi, QWORD PTR [rdi+96]

; 828  :         while (linelen--) {

  000ba	48 85 f6	 test	 rsi, rsi
  000bd	74 44		 je	 SHORT $LN38@Reader_ite

; 826  :         pos = 0;

  000bf	48 8b eb	 mov	 rbp, rbx
  000c2	4c 8b e3	 mov	 r12, rbx
$LL5@Reader_ite:

; 828  :         while (linelen--) {

  000c5	48 ff ce	 dec	 rsi

; 829  :             c = PyUnicode_READ(kind, data, pos);

  000c8	41 83 fd 01	 cmp	 r13d, 1
  000cc	75 05		 jne	 SHORT $LN28@Reader_ite
  000ce	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  000d1	eb 10		 jmp	 SHORT $LN27@Reader_ite
$LN28@Reader_ite:
  000d3	41 83 fd 02	 cmp	 r13d, 2
  000d7	75 07		 jne	 SHORT $LN26@Reader_ite
  000d9	41 0f b7 14 24	 movzx	 edx, WORD PTR [r12]
  000de	eb 03		 jmp	 SHORT $LN27@Reader_ite
$LN26@Reader_ite:
  000e0	8b 55 00	 mov	 edx, DWORD PTR [rbp]
$LN27@Reader_ite:

; 830  :             if (c == '\0') {

  000e3	85 d2		 test	 edx, edx
  000e5	74 5e		 je	 SHORT $LN32@Reader_ite

; 834  :                 goto err;
; 835  :             }
; 836  :             if (parse_process_char(self, c) < 0) {

  000e7	49 8b ce	 mov	 rcx, r14
  000ea	e8 00 00 00 00	 call	 parse_process_char
  000ef	85 c0		 test	 eax, eax
  000f1	78 45		 js	 SHORT $LN33@Reader_ite

; 838  :                 goto err;
; 839  :             }
; 840  :             pos++;

  000f3	48 ff c3	 inc	 rbx
  000f6	49 83 c4 02	 add	 r12, 2
  000fa	48 83 c5 04	 add	 rbp, 4
  000fe	48 85 f6	 test	 rsi, rsi
  00101	75 c2		 jne	 SHORT $LL5@Reader_ite
$LN38@Reader_ite:

; 841  :         }
; 842  :         Py_DECREF(lineobj);

  00103	48 8b cf	 mov	 rcx, rdi
  00106	e8 00 00 00 00	 call	 _Py_DecRef

; 843  :         if (parse_process_char(self, 0) < 0)

  0010b	33 d2		 xor	 edx, edx
  0010d	49 8b ce	 mov	 rcx, r14
  00110	e8 00 00 00 00	 call	 parse_process_char
  00115	85 c0		 test	 eax, eax
  00117	0f 88 1c 01 00
	00		 js	 $err$21022

; 844  :             goto err;
; 845  :     } while (self->state != START_RECORD);

  0011d	45 39 7e 78	 cmp	 DWORD PTR [r14+120], r15d
  00121	0f 85 19 ff ff
	ff		 jne	 $LL16@Reader_ite

; 846  : 
; 847  :     fields = self->fields;

  00127	4d 8b 7e 70	 mov	 r15, QWORD PTR [r14+112]

; 848  :     self->fields = NULL;

  0012b	49 c7 46 70 00
	00 00 00	 mov	 QWORD PTR [r14+112], 0

; 849  : err:
; 850  :     return fields;

  00133	49 8b c7	 mov	 rax, r15
  00136	eb 72		 jmp	 SHORT $LN50@Reader_ite
$LN33@Reader_ite:

; 837  :                 Py_DECREF(lineobj);

  00138	48 8b cf	 mov	 rcx, rdi
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 849  : err:
; 850  :     return fields;

  00140	49 8b c7	 mov	 rax, r15
  00143	eb 65		 jmp	 SHORT $LN50@Reader_ite
$LN32@Reader_ite:

; 831  :                 Py_DECREF(lineobj);

  00145	48 8b cf	 mov	 rcx, rdi
  00148	e8 00 00 00 00	 call	 _Py_DecRef

; 832  :                 PyErr_Format(_csvstate_global->error_obj,
; 833  :                              "line contains NULL byte");

  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00154	e8 00 00 00 00	 call	 PyState_FindModule
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 PyModule_GetState
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DKJAPDDK@line?5contains?5NULL?5byte?$AA@
  00168	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016b	e8 00 00 00 00	 call	 PyErr_Format

; 849  : err:
; 850  :     return fields;

  00170	49 8b c7	 mov	 rax, r15
  00173	eb 35		 jmp	 SHORT $LN50@Reader_ite
$LN35@Reader_ite:

; 810  :             PyErr_Format(_csvstate_global->error_obj,
; 811  :                          "iterator should return strings, "
; 812  :                          "not %.200s "
; 813  :                          "(did you open the file in text mode?)",
; 814  :                          lineobj->ob_type->tp_name
; 815  :                 );

  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  0017c	e8 00 00 00 00	 call	 PyState_FindModule
  00181	48 8b c8	 mov	 rcx, rax
  00184	e8 00 00 00 00	 call	 PyModule_GetState
  00189	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FB@IOCKMCCD@iterator?5should?5return?5strings?0?5@
  00194	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00198	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0019b	e8 00 00 00 00	 call	 PyErr_Format
$LN36@Reader_ite:

; 816  :             Py_DECREF(lineobj);

  001a0	48 8b cf	 mov	 rcx, rdi
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@Reader_ite:

; 805  :                     break;
; 806  :             }
; 807  :             return NULL;

  001a8	33 c0		 xor	 eax, eax
$LN50@Reader_ite:
  001aa	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  001af	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  001b4	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  001b9	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001be	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001c3	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 851  : }

  001c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001cc	41 5f		 pop	 r15
  001ce	41 5e		 pop	 r14
  001d0	c3		 ret	 0
$LN34@Reader_ite:

; 798  :             /* End of input OR exception */
; 799  :             if (!PyErr_Occurred() && (self->field_len != 0 ||
; 800  :                                       self->state == IN_QUOTED_FIELD)) {

  001d1	e8 00 00 00 00	 call	 PyErr_Occurred
  001d6	48 85 c0	 test	 rax, rax
  001d9	75 cd		 jne	 SHORT $LN8@Reader_ite
  001db	4d 39 be 90 00
	00 00		 cmp	 QWORD PTR [r14+144], r15
  001e2	75 07		 jne	 SHORT $LN11@Reader_ite
  001e4	41 83 7e 78 04	 cmp	 DWORD PTR [r14+120], 4
  001e9	75 bd		 jne	 SHORT $LN8@Reader_ite
$LN11@Reader_ite:

; 801  :                 if (self->dialect->strict)

  001eb	49 8b 46 68	 mov	 rax, QWORD PTR [r14+104]
  001ef	44 39 b8 84 00
	00 00		 cmp	 DWORD PTR [rax+132], r15d
  001f6	74 25		 je	 SHORT $LN10@Reader_ite

; 802  :                     PyErr_SetString(_csvstate_global->error_obj,
; 803  :                                     "unexpected end of data");

  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  001ff	e8 00 00 00 00	 call	 PyState_FindModule
  00204	48 8b c8	 mov	 rcx, rax
  00207	e8 00 00 00 00	 call	 PyModule_GetState
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@OMKFHCNA@unexpected?5end?5of?5data?$AA@
  00213	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00216	e8 00 00 00 00	 call	 PyErr_SetString
  0021b	eb 8b		 jmp	 SHORT $LN8@Reader_ite
$LN10@Reader_ite:

; 804  :                 else if (parse_save_field(self) >= 0)

  0021d	49 8b ce	 mov	 rcx, r14
  00220	e8 00 00 00 00	 call	 parse_save_field
  00225	85 c0		 test	 eax, eax
  00227	0f 88 7b ff ff
	ff		 js	 $LN8@Reader_ite

; 846  : 
; 847  :     fields = self->fields;

  0022d	4d 8b 7e 70	 mov	 r15, QWORD PTR [r14+112]

; 848  :     self->fields = NULL;

  00231	49 c7 46 70 00
	00 00 00	 mov	 QWORD PTR [r14+112], 0
$err$21022:

; 849  : err:
; 850  :     return fields;

  00239	49 8b c7	 mov	 rax, r15
  0023c	e9 69 ff ff ff	 jmp	 $LN50@Reader_ite
Reader_iternext ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Reader_dealloc DD imagerel Reader_dealloc
	DD	imagerel Reader_dealloc+383
	DD	imagerel $unwind$Reader_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Reader_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT Reader_dealloc
_TEXT	SEGMENT
self$ = 64
Reader_dealloc PROC					; COMDAT

; 855  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 856  :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 857  :     Py_XDECREF(self->dialect);

  00012	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00016	48 85 db	 test	 rbx, rbx
  00019	74 65		 je	 SHORT $LN12@Reader_dea
  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	75 5c		 jne	 SHORT $LN12@Reader_dea
  00024	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00028	a8 20		 test	 al, 32			; 00000020H
  0002a	75 4c		 jne	 SHORT $LN20@Reader_dea
  0002c	84 c0		 test	 al, al
  0002e	78 48		 js	 SHORT $LN20@Reader_dea
  00030	a8 02		 test	 al, 2
  00032	75 4c		 jne	 SHORT $LN12@Reader_dea
  00034	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00038	75 46		 jne	 SHORT $LN12@Reader_dea
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00048	4c 8b cb	 mov	 r9, rbx
  0004b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00051	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	85 c0		 test	 eax, eax
  00063	74 07		 je	 SHORT $LN25@Reader_dea
  00065	e8 00 00 00 00	 call	 _Px_Dealloc
  0006a	eb 14		 jmp	 SHORT $LN12@Reader_dea
$LN25@Reader_dea:
  0006c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00070	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00076	eb 08		 jmp	 SHORT $LN12@Reader_dea
$LN20@Reader_dea:
  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 Px_DecRef
$LN12@Reader_dea:

; 858  :     Py_XDECREF(self->input_iter);

  00080	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 65		 je	 SHORT $LN8@Reader_dea
  00089	e8 00 00 00 00	 call	 _Py_PXCTX
  0008e	85 c0		 test	 eax, eax
  00090	75 5c		 jne	 SHORT $LN8@Reader_dea
  00092	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00096	a8 20		 test	 al, 32			; 00000020H
  00098	75 4c		 jne	 SHORT $LN31@Reader_dea
  0009a	84 c0		 test	 al, al
  0009c	78 48		 js	 SHORT $LN31@Reader_dea
  0009e	a8 02		 test	 al, 2
  000a0	75 4c		 jne	 SHORT $LN8@Reader_dea
  000a2	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a6	75 46		 jne	 SHORT $LN8@Reader_dea
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b6	4c 8b cb	 mov	 r9, rbx
  000b9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	85 c0		 test	 eax, eax
  000d1	74 07		 je	 SHORT $LN36@Reader_dea
  000d3	e8 00 00 00 00	 call	 _Px_Dealloc
  000d8	eb 14		 jmp	 SHORT $LN8@Reader_dea
$LN36@Reader_dea:
  000da	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000de	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e4	eb 08		 jmp	 SHORT $LN8@Reader_dea
$LN31@Reader_dea:
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	e8 00 00 00 00	 call	 Px_DecRef
$LN8@Reader_dea:

; 859  :     Py_XDECREF(self->fields);

  000ee	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  000f2	48 85 db	 test	 rbx, rbx
  000f5	74 65		 je	 SHORT $LN4@Reader_dea
  000f7	e8 00 00 00 00	 call	 _Py_PXCTX
  000fc	85 c0		 test	 eax, eax
  000fe	75 5c		 jne	 SHORT $LN4@Reader_dea
  00100	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00104	a8 20		 test	 al, 32			; 00000020H
  00106	75 4c		 jne	 SHORT $LN42@Reader_dea
  00108	84 c0		 test	 al, al
  0010a	78 48		 js	 SHORT $LN42@Reader_dea
  0010c	a8 02		 test	 al, 2
  0010e	75 4c		 jne	 SHORT $LN4@Reader_dea
  00110	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00114	75 46		 jne	 SHORT $LN4@Reader_dea
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00124	4c 8b cb	 mov	 r9, rbx
  00127	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0012d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00135	e8 00 00 00 00	 call	 _PyParallel_Guard
  0013a	48 8b cb	 mov	 rcx, rbx
  0013d	85 c0		 test	 eax, eax
  0013f	74 07		 je	 SHORT $LN47@Reader_dea
  00141	e8 00 00 00 00	 call	 _Px_Dealloc
  00146	eb 14		 jmp	 SHORT $LN4@Reader_dea
$LN47@Reader_dea:
  00148	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0014c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00152	eb 08		 jmp	 SHORT $LN4@Reader_dea
$LN42@Reader_dea:
  00154	48 8b cb	 mov	 rcx, rbx
  00157	e8 00 00 00 00	 call	 Px_DecRef
$LN4@Reader_dea:

; 860  :     if (self->field != NULL)

  0015c	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00163	48 85 c9	 test	 rcx, rcx
  00166	74 05		 je	 SHORT $LN1@Reader_dea

; 861  :         PyMem_Free(self->field);

  00168	e8 00 00 00 00	 call	 PyMem_Free
$LN1@Reader_dea:

; 862  :     PyObject_GC_Del(self);

  0016d	48 8b cf	 mov	 rcx, rdi

; 863  : }

  00170	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00175	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00179	5f		 pop	 rdi
  0017a	e9 00 00 00 00	 jmp	 PyObject_GC_Del
Reader_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Reader_traverse DD imagerel Reader_traverse
	DD	imagerel Reader_traverse+207
	DD	imagerel $unwind$Reader_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Reader_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@ DB 'Reader_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Reader_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
Reader_traverse PROC					; COMDAT

; 867  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 868  :     Py_VISIT(self->dialect);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN15@Reader_tra
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 64 03 00
	00		 mov	 r8d, 868		; 00000364H
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@Reader_tra:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN17@Reader_tra
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 70		 jne	 SHORT $LN19@Reader_tra
$LN17@Reader_tra:

; 869  :     Py_VISIT(self->input_iter);

  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	74 1c		 je	 SHORT $LN9@Reader_tra
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@
  00066	45 33 c9	 xor	 r9d, r9d
  00069	41 b8 65 03 00
	00		 mov	 r8d, 869		; 00000365H
  0006f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Reader_tra:
  00074	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00078	48 85 c9	 test	 rcx, rcx
  0007b	74 09		 je	 SHORT $LN11@Reader_tra
  0007d	48 8b d7	 mov	 rdx, rdi
  00080	ff d6		 call	 rsi
  00082	85 c0		 test	 eax, eax
  00084	75 39		 jne	 SHORT $LN19@Reader_tra
$LN11@Reader_tra:

; 870  :     Py_VISIT(self->fields);

  00086	e8 00 00 00 00	 call	 _Py_PXCTX
  0008b	85 c0		 test	 eax, eax
  0008d	74 1c		 je	 SHORT $LN3@Reader_tra
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@MBGFCFMF@Reader_traverse?$AA@
  0009d	45 33 c9	 xor	 r9d, r9d
  000a0	41 b8 66 03 00
	00		 mov	 r8d, 870		; 00000366H
  000a6	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Reader_tra:
  000ab	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  000af	48 85 c9	 test	 rcx, rcx
  000b2	74 09		 je	 SHORT $LN5@Reader_tra
  000b4	48 8b d7	 mov	 rdx, rdi
  000b7	ff d6		 call	 rsi
  000b9	85 c0		 test	 eax, eax
  000bb	75 02		 jne	 SHORT $LN19@Reader_tra
$LN5@Reader_tra:

; 871  :     return 0;

  000bd	33 c0		 xor	 eax, eax
$LN19@Reader_tra:

; 872  : }

  000bf	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000c9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
Reader_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@MHKAFMBP@Reader_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Reader_clear DD imagerel Reader_clear
	DD	imagerel Reader_clear+541
	DD	imagerel $unwind$Reader_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Reader_clear DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@MHKAFMBP@Reader_clear?$AA@
CONST	SEGMENT
??_C@_0N@MHKAFMBP@Reader_clear?$AA@ DB 'Reader_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT Reader_clear
_TEXT	SEGMENT
self$ = 64
Reader_clear PROC					; COMDAT

; 876  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 877  :     Py_CLEAR(self->dialect);

  0000a	4c 8b 49 68	 mov	 r9, QWORD PTR [rcx+104]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	4d 85 c9	 test	 r9, r9
  00014	0f 84 96 00 00
	00		 je	 $LN11@Reader_cle
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MHKAFMBP@Reader_clear?$AA@
  00028	41 b8 6d 03 00
	00		 mov	 r8d, 877		; 0000036dH
  0002e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 71		 jne	 SHORT $LN11@Reader_cle
  0003f	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00043	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 5c		 jne	 SHORT $LN11@Reader_cle
  00054	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00058	a8 20		 test	 al, 32			; 00000020H
  0005a	75 4c		 jne	 SHORT $LN19@Reader_cle
  0005c	84 c0		 test	 al, al
  0005e	78 48		 js	 SHORT $LN19@Reader_cle
  00060	a8 02		 test	 al, 2
  00062	75 4c		 jne	 SHORT $LN11@Reader_cle
  00064	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00068	75 46		 jne	 SHORT $LN11@Reader_cle
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00081	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	85 c0		 test	 eax, eax
  00093	74 07		 je	 SHORT $LN24@Reader_cle
  00095	e8 00 00 00 00	 call	 _Px_Dealloc
  0009a	eb 14		 jmp	 SHORT $LN11@Reader_cle
$LN24@Reader_cle:
  0009c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a6	eb 08		 jmp	 SHORT $LN11@Reader_cle
$LN19@Reader_cle:
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Reader_cle:

; 878  :     Py_CLEAR(self->input_iter);

  000b0	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  000b4	4d 85 c9	 test	 r9, r9
  000b7	0f 84 96 00 00
	00		 je	 $LN7@Reader_cle
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MHKAFMBP@Reader_clear?$AA@
  000cb	41 b8 6e 03 00
	00		 mov	 r8d, 878		; 0000036eH
  000d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	75 71		 jne	 SHORT $LN7@Reader_cle
  000e2	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  000e6	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  000ee	e8 00 00 00 00	 call	 _Py_PXCTX
  000f3	85 c0		 test	 eax, eax
  000f5	75 5c		 jne	 SHORT $LN7@Reader_cle
  000f7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000fb	a8 20		 test	 al, 32			; 00000020H
  000fd	75 4c		 jne	 SHORT $LN30@Reader_cle
  000ff	84 c0		 test	 al, al
  00101	78 48		 js	 SHORT $LN30@Reader_cle
  00103	a8 02		 test	 al, 2
  00105	75 4c		 jne	 SHORT $LN7@Reader_cle
  00107	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010b	75 46		 jne	 SHORT $LN7@Reader_cle
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011b	4c 8b cb	 mov	 r9, rbx
  0011e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00124	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00131	48 8b cb	 mov	 rcx, rbx
  00134	85 c0		 test	 eax, eax
  00136	74 07		 je	 SHORT $LN35@Reader_cle
  00138	e8 00 00 00 00	 call	 _Px_Dealloc
  0013d	eb 14		 jmp	 SHORT $LN7@Reader_cle
$LN35@Reader_cle:
  0013f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00143	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00149	eb 08		 jmp	 SHORT $LN7@Reader_cle
$LN30@Reader_cle:
  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 Px_DecRef
$LN7@Reader_cle:

; 879  :     Py_CLEAR(self->fields);

  00153	4c 8b 4f 70	 mov	 r9, QWORD PTR [rdi+112]
  00157	4d 85 c9	 test	 r9, r9
  0015a	0f 84 b0 00 00
	00		 je	 $LN50@Reader_cle
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MHKAFMBP@Reader_clear?$AA@
  0016e	41 b8 6f 03 00
	00		 mov	 r8d, 879		; 0000036fH
  00174	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00181	85 c0		 test	 eax, eax
  00183	0f 85 87 00 00
	00		 jne	 $LN50@Reader_cle
  00189	48 8b 5f 70	 mov	 rbx, QWORD PTR [rdi+112]
  0018d	48 c7 47 70 00
	00 00 00	 mov	 QWORD PTR [rdi+112], 0
  00195	e8 00 00 00 00	 call	 _Py_PXCTX
  0019a	85 c0		 test	 eax, eax
  0019c	75 72		 jne	 SHORT $LN50@Reader_cle
  0019e	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001a2	a8 20		 test	 al, 32			; 00000020H
  001a4	75 62		 jne	 SHORT $LN41@Reader_cle
  001a6	84 c0		 test	 al, al
  001a8	78 5e		 js	 SHORT $LN41@Reader_cle
  001aa	a8 02		 test	 al, 2
  001ac	75 62		 jne	 SHORT $LN50@Reader_cle
  001ae	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001b2	75 5c		 jne	 SHORT $LN50@Reader_cle
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001c2	4c 8b cb	 mov	 r9, rbx
  001c5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001cb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001d8	48 8b cb	 mov	 rcx, rbx
  001db	85 c0		 test	 eax, eax
  001dd	74 12		 je	 SHORT $LN46@Reader_cle
  001df	e8 00 00 00 00	 call	 _Px_Dealloc

; 880  :     return 0;

  001e4	33 c0		 xor	 eax, eax

; 881  : }

  001e6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001eb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ef	5f		 pop	 rdi
  001f0	c3		 ret	 0

; 879  :     Py_CLEAR(self->fields);

$LN46@Reader_cle:
  001f1	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001f5	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 880  :     return 0;

  001fb	33 c0		 xor	 eax, eax

; 881  : }

  001fd	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00202	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00206	5f		 pop	 rdi
  00207	c3		 ret	 0

; 879  :     Py_CLEAR(self->fields);

$LN41@Reader_cle:
  00208	48 8b cb	 mov	 rcx, rbx
  0020b	e8 00 00 00 00	 call	 Px_DecRef
$LN50@Reader_cle:

; 880  :     return 0;

  00210	33 c0		 xor	 eax, eax

; 881  : }

  00212	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00217	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0021b	5f		 pop	 rdi
  0021c	c3		 ret	 0
Reader_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@KNOECLE@argument?51?5must?5be?5an?5iterator?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyObject_GC_Track:PROC
EXTRN	PyObject_GetIter:PROC
EXTRN	PyArg_UnpackTuple:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_reader DD imagerel csv_reader
	DD	imagerel csv_reader+270
	DD	imagerel $unwind$csv_reader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_reader DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT ??_C@_0BP@KNOECLE@argument?51?5must?5be?5an?5iterator?$AA@
CONST	SEGMENT
??_C@_0BP@KNOECLE@argument?51?5must?5be?5an?5iterator?$AA@ DB 'argument 1'
	DB	' must be an iterator', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT csv_reader
_TEXT	SEGMENT
iterator$ = 48
module$ = 80
args$ = 88
keyword_args$ = 96
dialect$ = 104
csv_reader PROC						; COMDAT

; 940  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 941  :     PyObject * iterator, * dialect = NULL;

  00014	33 ed		 xor	 ebp, ebp
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	48 89 6c 24 68	 mov	 QWORD PTR dialect$[rsp], rbp

; 942  :     ReaderObj * self = PyObject_GC_New(ReaderObj, &Reader_Type);

  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Reader_Type
  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@csv_reader
  00031	e8 00 00 00 00	 call	 _PxObject_New
  00036	eb 05		 jmp	 SHORT $LN10@csv_reader
$LN8@csv_reader:
  00038	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN10@csv_reader:
  0003d	48 8b d8	 mov	 rbx, rax

; 943  : 
; 944  :     if (!self)

  00040	48 85 c0	 test	 rax, rax

; 945  :         return NULL;

  00043	0f 84 8b 00 00
	00		 je	 $LN11@csv_reader

; 946  : 
; 947  :     self->dialect = NULL;
; 948  :     self->fields = NULL;
; 949  :     self->input_iter = NULL;
; 950  :     self->field = NULL;
; 951  :     self->field_size = 0;
; 952  :     self->line_num = 0;
; 953  : 
; 954  :     if (parse_reset(self) < 0) {

  00049	48 8b c8	 mov	 rcx, rax
  0004c	48 89 68 68	 mov	 QWORD PTR [rax+104], rbp
  00050	48 89 68 70	 mov	 QWORD PTR [rax+112], rbp
  00054	48 89 68 60	 mov	 QWORD PTR [rax+96], rbp
  00058	48 89 a8 80 00
	00 00		 mov	 QWORD PTR [rax+128], rbp
  0005f	48 89 a8 88 00
	00 00		 mov	 QWORD PTR [rax+136], rbp
  00066	89 a8 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ebp
  0006c	e8 00 00 00 00	 call	 parse_reset
  00071	85 c0		 test	 eax, eax

; 955  :         Py_DECREF(self);
; 956  :         return NULL;

  00073	78 57		 js	 SHORT $LN12@csv_reader

; 957  :     }
; 958  : 
; 959  :     if (!PyArg_UnpackTuple(args, "", 1, 2, &iterator, &dialect)) {

  00075	48 8d 44 24 68	 lea	 rax, QWORD PTR dialect$[rsp]
  0007a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00087	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008c	48 8d 44 24 30	 lea	 rax, QWORD PTR iterator$[rsp]
  00091	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  00095	48 8b ce	 mov	 rcx, rsi
  00098	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  000a2	85 c0		 test	 eax, eax

; 960  :         Py_DECREF(self);
; 961  :         return NULL;

  000a4	74 26		 je	 SHORT $LN12@csv_reader

; 962  :     }
; 963  :     self->input_iter = PyObject_GetIter(iterator);

  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iterator$[rsp]
  000ab	e8 00 00 00 00	 call	 PyObject_GetIter
  000b0	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 964  :     if (self->input_iter == NULL) {

  000b4	48 85 c0	 test	 rax, rax
  000b7	75 1f		 jne	 SHORT $LN2@csv_reader

; 965  :         PyErr_SetString(PyExc_TypeError,
; 966  :                         "argument 1 must be an iterator");

  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@KNOECLE@argument?51?5must?5be?5an?5iterator?$AA@
  000c7	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@csv_reader:

; 967  :         Py_DECREF(self);

  000cc	48 8b cb	 mov	 rcx, rbx
$LN13@csv_reader:
  000cf	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@csv_reader:

; 968  :         return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 21		 jmp	 SHORT $LN6@csv_reader
$LN2@csv_reader:

; 969  :     }
; 970  :     self->dialect = (DialectObj *)_call_dialect(dialect, keyword_args);

  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dialect$[rsp]
  000dd	48 8b d7	 mov	 rdx, rdi
  000e0	e8 00 00 00 00	 call	 _call_dialect

; 971  :     if (self->dialect == NULL) {
; 972  :         Py_DECREF(self);

  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
  000ec	48 85 c0	 test	 rax, rax

; 973  :         return NULL;

  000ef	74 de		 je	 SHORT $LN13@csv_reader

; 974  :     }
; 975  : 
; 976  :     PyObject_GC_Track(self);

  000f1	e8 00 00 00 00	 call	 PyObject_GC_Track

; 977  :     return (PyObject *)self;

  000f6	48 8b c3	 mov	 rax, rbx
$LN6@csv_reader:

; 978  : }

  000f9	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000fe	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00103	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00108	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
csv_reader ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT join_reset
_TEXT	SEGMENT
self$ = 8
join_reset PROC						; COMDAT

; 987  :     self->rec_len = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 988  :     self->num_fields = 0;

  00009	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 989  : }

  0000f	c3		 ret	 0
join_reset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@HECEKHFI@single?5empty?5field?5record?5must?5b@ ; `string'
PUBLIC	??_C@_0CG@GPDPHFMF@need?5to?5escape?0?5but?5no?5escapecha@ ; `string'
EXTRN	PyUnicode_FindChar:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_append_data DD imagerel join_append_data
	DD	imagerel join_append_data+540
	DD	imagerel $unwind$join_append_data
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_append_data DD 0b7e01H
	DD	06f47eH
	DD	0107479H
	DD	0e0126216H
	DD	0c00ed010H
	DD	0500b600cH
	DD	0300aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@HECEKHFI@single?5empty?5field?5record?5must?5b@
CONST	SEGMENT
??_C@_0CJ@HECEKHFI@single?5empty?5field?5record?5must?5b@ DB 'single empt'
	DB	'y field record must be quoted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GPDPHFMF@need?5to?5escape?0?5but?5no?5escapecha@
CONST	SEGMENT
??_C@_0CG@GPDPHFMF@need?5to?5escape?0?5but?5no?5escapecha@ DB 'need to es'
	DB	'cape, but no escapechar set', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT join_append_data
_TEXT	SEGMENT
tv433 = 112
self$ = 112
field_kind$ = 120
field_data$ = 128
field_len$ = 136
quote_empty$ = 144
quoted$ = 152
copy_phase$ = 160
join_append_data PROC					; COMDAT

; 1000 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	53		 push	 rbx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1001 :     DialectObj *dialect = self->dialect;
; 1002 :     int i;
; 1003 :     Py_ssize_t rec_len;
; 1004 : 
; 1005 : #define ADDCH(c) \
; 1006 :     do {\
; 1007 :         if (copy_phase) \
; 1008 :             self->rec[rec_len] = c;\
; 1009 :         rec_len++;\
; 1010 :     } while(0)
; 1011 : 
; 1012 :     rec_len = self->rec_len;
; 1013 : 
; 1014 :     /* If this is not the first field we need a field separator */
; 1015 :     if (self->num_fields > 0)

  00016	83 b9 88 00 00
	00 00		 cmp	 DWORD PTR [rcx+136], 0
  0001d	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]
  00021	48 8b 99 80 00
	00 00		 mov	 rbx, QWORD PTR [rcx+128]
  00028	44 8b a4 24 a0
	00 00 00	 mov	 r12d, DWORD PTR copy_phase$[rsp]
  00030	4d 8b e8	 mov	 r13, r8
  00033	48 8b e9	 mov	 rbp, rcx
  00036	44 8b c2	 mov	 r8d, edx
  00039	7e 13		 jle	 SHORT $LN42@join_appen

; 1016 :         ADDCH(dialect->delimiter);

  0003b	45 85 e4	 test	 r12d, r12d
  0003e	74 0b		 je	 SHORT $LN41@join_appen
  00040	4c 8b 51 70	 mov	 r10, QWORD PTR [rcx+112]
  00044	8b 46 64	 mov	 eax, DWORD PTR [rsi+100]
  00047	41 89 04 9a	 mov	 DWORD PTR [r10+rbx*4], eax
$LN41@join_appen:
  0004b	48 ff c3	 inc	 rbx
$LN42@join_appen:

; 1017 : 
; 1018 :     /* Handle preceding quote */
; 1019 :     if (copy_phase && *quoted)

  0004e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR quoted$[rsp]
  00056	45 85 e4	 test	 r12d, r12d
  00059	74 13		 je	 SHORT $LN37@join_appen
  0005b	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  0005e	74 0e		 je	 SHORT $LN37@join_appen

; 1020 :         ADDCH(dialect->quotechar);

  00060	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00064	8b 46 68	 mov	 eax, DWORD PTR [rsi+104]
  00067	48 ff c3	 inc	 rbx
  0006a	89 44 99 fc	 mov	 DWORD PTR [rcx+rbx*4-4], eax
$LN37@join_appen:

; 1021 : 
; 1022 :     /* Copy/count field data */
; 1023 :     /* If field is null just pass over */
; 1024 :     for (i = 0; field_data && (i < field_len); i++) {

  0006e	45 33 f6	 xor	 r14d, r14d
  00071	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  00079	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0007e	4d 85 ed	 test	 r13, r13
  00081	0f 84 15 01 00
	00		 je	 $LN57@join_appen
  00087	4d 8b fd	 mov	 r15, r13
  0008a	49 8b cd	 mov	 rcx, r13
$LN62@join_appen:
  0008d	49 63 c6	 movsxd	 rax, r14d
  00090	48 89 4c 24 70	 mov	 QWORD PTR tv433[rsp], rcx
  00095	49 3b c1	 cmp	 rax, r9
  00098	0f 8d f9 00 00
	00		 jge	 $LN33@join_appen

; 1025 :         Py_UCS4 c = PyUnicode_READ(field_kind, field_data, i);

  0009e	41 83 f8 01	 cmp	 r8d, 1
  000a2	75 07		 jne	 SHORT $LN50@join_appen
  000a4	41 0f b6 7d 00	 movzx	 edi, BYTE PTR [r13]
  000a9	eb 0e		 jmp	 SHORT $LN49@join_appen
$LN50@join_appen:
  000ab	41 83 f8 02	 cmp	 r8d, 2
  000af	75 05		 jne	 SHORT $LN48@join_appen
  000b1	0f b7 39	 movzx	 edi, WORD PTR [rcx]
  000b4	eb 03		 jmp	 SHORT $LN49@join_appen
$LN48@join_appen:
  000b6	41 8b 3f	 mov	 edi, DWORD PTR [r15]
$LN49@join_appen:

; 1026 :         int want_escape = 0;
; 1027 : 
; 1028 :         if (c == dialect->delimiter ||
; 1029 :             c == dialect->escapechar ||
; 1030 :             c == dialect->quotechar  ||
; 1031 :             PyUnicode_FindChar(
; 1032 :                 dialect->lineterminator, c, 0,
; 1033 :                 PyUnicode_GET_LENGTH(dialect->lineterminator), 1) >= 0) {

  000b9	3b 7e 64	 cmp	 edi, DWORD PTR [rsi+100]
  000bc	74 29		 je	 SHORT $LN31@join_appen
  000be	3b 7e 6c	 cmp	 edi, DWORD PTR [rsi+108]
  000c1	74 24		 je	 SHORT $LN31@join_appen
  000c3	3b 7e 68	 cmp	 edi, DWORD PTR [rsi+104]
  000c6	74 1f		 je	 SHORT $LN31@join_appen
  000c8	48 8b 4e 78	 mov	 rcx, QWORD PTR [rsi+120]
  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	8b d7		 mov	 edx, edi
  000d1	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  000d5	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000dd	e8 00 00 00 00	 call	 PyUnicode_FindChar
  000e2	48 85 c0	 test	 rax, rax
  000e5	78 4b		 js	 SHORT $LN60@join_appen
$LN31@join_appen:

; 1034 :             if (dialect->quoting == QUOTE_NONE)

  000e7	83 be 80 00 00
	00 03		 cmp	 DWORD PTR [rsi+128], 3

; 1035 :                 want_escape = 1;
; 1036 :             else {

  000ee	74 2c		 je	 SHORT $LN56@join_appen

; 1037 :                 if (c == dialect->quotechar) {

  000f0	8b 4e 68	 mov	 ecx, DWORD PTR [rsi+104]
  000f3	3b f9		 cmp	 edi, ecx
  000f5	75 15		 jne	 SHORT $LN58@join_appen

; 1038 :                     if (dialect->doublequote)

  000f7	83 7e 60 00	 cmp	 DWORD PTR [rsi+96], 0
  000fb	74 1f		 je	 SHORT $LN56@join_appen

; 1039 :                         ADDCH(dialect->quotechar);

  000fd	45 85 e4	 test	 r12d, r12d
  00100	74 07		 je	 SHORT $LN23@join_appen
  00102	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00106	89 0c 98	 mov	 DWORD PTR [rax+rbx*4], ecx
$LN23@join_appen:
  00109	48 ff c3	 inc	 rbx
$LN58@join_appen:

; 1040 :                     else
; 1041 :                         want_escape = 1;
; 1042 :                 }
; 1043 :                 if (!want_escape)
; 1044 :                     *quoted = 1;

  0010c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR quoted$[rsp]
  00114	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 1045 :             }
; 1046 :             if (want_escape) {

  0011a	eb 1e		 jmp	 SHORT $LN16@join_appen
$LN56@join_appen:

; 1047 :                 if (!dialect->escapechar) {

  0011c	8b 4e 6c	 mov	 ecx, DWORD PTR [rsi+108]
  0011f	85 c9		 test	 ecx, ecx
  00121	74 4b		 je	 SHORT $LN53@join_appen

; 1051 :                 }
; 1052 :                 ADDCH(dialect->escapechar);

  00123	45 85 e4	 test	 r12d, r12d
  00126	74 07		 je	 SHORT $LN15@join_appen
  00128	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  0012c	89 0c 98	 mov	 DWORD PTR [rax+rbx*4], ecx
$LN15@join_appen:
  0012f	48 ff c3	 inc	 rbx
$LN60@join_appen:

; 1021 : 
; 1022 :     /* Copy/count field data */
; 1023 :     /* If field is null just pass over */
; 1024 :     for (i = 0; field_data && (i < field_len); i++) {

  00132	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR quoted$[rsp]
$LN16@join_appen:

; 1053 :             }
; 1054 :         }
; 1055 :         /* Copy field character into record buffer.
; 1056 :          */
; 1057 :         ADDCH(c);

  0013a	45 85 e4	 test	 r12d, r12d
  0013d	74 07		 je	 SHORT $LN11@join_appen
  0013f	48 8b 45 70	 mov	 rax, QWORD PTR [rbp+112]
  00143	89 3c 98	 mov	 DWORD PTR [rax+rbx*4], edi
$LN11@join_appen:

; 1021 : 
; 1022 :     /* Copy/count field data */
; 1023 :     /* If field is null just pass over */
; 1024 :     for (i = 0; field_data && (i < field_len); i++) {

  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv433[rsp]
  0014b	44 8b 44 24 78	 mov	 r8d, DWORD PTR field_kind$[rsp]
  00150	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR field_len$[rsp]
  00158	48 83 c1 02	 add	 rcx, 2

; 1053 :             }
; 1054 :         }
; 1055 :         /* Copy field character into record buffer.
; 1056 :          */
; 1057 :         ADDCH(c);

  0015c	48 ff c3	 inc	 rbx
  0015f	41 ff c6	 inc	 r14d
  00162	49 ff c5	 inc	 r13
  00165	49 83 c7 04	 add	 r15, 4
  00169	e9 1f ff ff ff	 jmp	 $LN62@join_appen
$LN53@join_appen:

; 1048 :                     PyErr_Format(_csvstate_global->error_obj,
; 1049 :                                  "need to escape, but no escapechar set");

  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00175	e8 00 00 00 00	 call	 PyState_FindModule
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	e8 00 00 00 00	 call	 PyModule_GetState
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@GPDPHFMF@need?5to?5escape?0?5but?5no?5escapecha@
  00189	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0018c	e8 00 00 00 00	 call	 PyErr_Format

; 1050 :                     return -1;

  00191	48 83 c8 ff	 or	 rax, -1
  00195	eb 6a		 jmp	 SHORT $LN46@join_appen
$LN33@join_appen:

; 1058 :     }
; 1059 : 
; 1060 :     /* If field is empty check if it needs to be quoted.
; 1061 :      */
; 1062 :     if (i == 0 && quote_empty) {

  00197	45 85 f6	 test	 r14d, r14d
  0019a	75 44		 jne	 SHORT $LN8@join_appen
$LN57@join_appen:
  0019c	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR quote_empty$[rsp], 0
  001a4	74 3a		 je	 SHORT $LN8@join_appen

; 1063 :         if (dialect->quoting == QUOTE_NONE) {

  001a6	83 be 80 00 00
	00 03		 cmp	 DWORD PTR [rsi+128], 3
  001ad	75 29		 jne	 SHORT $LN9@join_appen

; 1064 :             PyErr_Format(_csvstate_global->error_obj,
; 1065 :                 "single empty field record must be quoted");

  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  001b6	e8 00 00 00 00	 call	 PyState_FindModule
  001bb	48 8b c8	 mov	 rcx, rax
  001be	e8 00 00 00 00	 call	 PyModule_GetState
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@HECEKHFI@single?5empty?5field?5record?5must?5b@
  001ca	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001cd	e8 00 00 00 00	 call	 PyErr_Format

; 1066 :             return -1;

  001d2	48 83 c8 ff	 or	 rax, -1
  001d6	eb 29		 jmp	 SHORT $LN46@join_appen
$LN9@join_appen:

; 1067 :         }
; 1068 :         else
; 1069 :             *quoted = 1;

  001d8	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 1070 :     }
; 1071 : 
; 1072 :     if (*quoted) {

  001de	eb 05		 jmp	 SHORT $LN59@join_appen
$LN8@join_appen:
  001e0	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  001e3	74 19		 je	 SHORT $LN1@join_appen
$LN59@join_appen:

; 1073 :         if (copy_phase)

  001e5	45 85 e4	 test	 r12d, r12d
  001e8	74 10		 je	 SHORT $LN6@join_appen

; 1074 :             ADDCH(dialect->quotechar);

  001ea	48 8b 4d 70	 mov	 rcx, QWORD PTR [rbp+112]
  001ee	8b 46 68	 mov	 eax, DWORD PTR [rsi+104]
  001f1	48 ff c3	 inc	 rbx
  001f4	89 44 99 fc	 mov	 DWORD PTR [rcx+rbx*4-4], eax

; 1075 :         else

  001f8	eb 04		 jmp	 SHORT $LN1@join_appen
$LN6@join_appen:

; 1076 :             rec_len += 2;

  001fa	48 83 c3 02	 add	 rbx, 2
$LN1@join_appen:

; 1077 :     }
; 1078 :     return rec_len;

  001fe	48 8b c3	 mov	 rax, rbx
$LN46@join_appen:
  00201	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  00206	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 1079 : #undef ADDCH
; 1080 : }

  0020e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00212	41 5e		 pop	 r14
  00214	41 5d		 pop	 r13
  00216	41 5c		 pop	 r12
  00218	5e		 pop	 rsi
  00219	5d		 pop	 rbp
  0021a	5b		 pop	 rbx
  0021b	c3		 ret	 0
join_append_data ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_check_rec_size DD imagerel join_check_rec_size
	DD	imagerel join_check_rec_size+234
	DD	imagerel $unwind$join_check_rec_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_check_rec_size DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT join_check_rec_size
_TEXT	SEGMENT
self$ = 48
rec_len$ = 56
join_check_rec_size PROC				; COMDAT

; 1084 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1085 : 
; 1086 :     if (rec_len < 0 || rec_len > PY_SSIZE_T_MAX - MEM_INCR) {

  00006	48 b8 ff 7f ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854743039 ; 7fffffffffff7fffH
  00010	48 8b d9	 mov	 rbx, rcx
  00013	48 3b d0	 cmp	 rdx, rax
  00016	0f 87 c1 00 00
	00		 ja	 $LN7@join_check

; 1089 :     }
; 1090 : 
; 1091 :     if (rec_len > self->rec_size) {

  0001c	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  00020	48 3b d0	 cmp	 rdx, rax
  00023	0f 8e a9 00 00
	00		 jle	 $LN1@join_check

; 1092 :         if (self->rec_size == 0) {

  00029	48 85 c0	 test	 rax, rax

; 1093 :             self->rec_size = (rec_len / MEM_INCR + 1) * MEM_INCR;

  0002c	48 8b c2	 mov	 rax, rdx
  0002f	48 99		 cdq
  00031	75 50		 jne	 SHORT $LN5@join_check
  00033	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00039	48 03 c2	 add	 rax, rdx
  0003c	48 c1 f8 0f	 sar	 rax, 15
  00040	48 ff c0	 inc	 rax
  00043	48 c1 e0 0f	 shl	 rax, 15
  00047	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 1094 :             if (self->rec != NULL)

  0004b	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0004f	48 85 c9	 test	 rcx, rcx
  00052	74 05		 je	 SHORT $LN4@join_check

; 1095 :                 PyMem_Free(self->rec);

  00054	e8 00 00 00 00	 call	 PyMem_Free
$LN4@join_check:

; 1096 :             self->rec = PyMem_New(Py_UCS4, self->rec_size);

  00059	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0005d	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00067	48 3b c8	 cmp	 rcx, rax
  0006a	76 08		 jbe	 SHORT $LN11@join_check
  0006c	33 c0		 xor	 eax, eax
  0006e	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1097 :         }
; 1098 :         else {

  00072	eb 57		 jmp	 SHORT $LN2@join_check
$LN11@join_check:

; 1096 :             self->rec = PyMem_New(Py_UCS4, self->rec_size);

  00074	48 c1 e1 02	 shl	 rcx, 2
  00078	e8 00 00 00 00	 call	 PyMem_Malloc
  0007d	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1097 :         }
; 1098 :         else {

  00081	eb 48		 jmp	 SHORT $LN2@join_check
$LN5@join_check:

; 1099 :             Py_UCS4* old_rec = self->rec;
; 1100 : 
; 1101 :             self->rec_size = (rec_len / MEM_INCR + 1) * MEM_INCR;

  00083	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00089	48 03 d0	 add	 rdx, rax

; 1102 :             self->rec = PyMem_Resize(old_rec, Py_UCS4, self->rec_size);

  0008c	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00096	48 c1 fa 0f	 sar	 rdx, 15
  0009a	48 ff c2	 inc	 rdx
  0009d	48 c1 e2 0f	 shl	 rdx, 15
  000a1	48 89 51 78	 mov	 QWORD PTR [rcx+120], rdx
  000a5	48 3b d0	 cmp	 rdx, rax
  000a8	76 04		 jbe	 SHORT $LN13@join_check
  000aa	33 c0		 xor	 eax, eax
  000ac	eb 0d		 jmp	 SHORT $LN14@join_check
$LN13@join_check:
  000ae	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000b2	48 c1 e2 02	 shl	 rdx, 2
  000b6	e8 00 00 00 00	 call	 PyMem_Realloc
$LN14@join_check:
  000bb	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 1103 :             if (self->rec == NULL)

  000bf	48 85 c0	 test	 rax, rax
  000c2	75 07		 jne	 SHORT $LN2@join_check

; 1104 :                 PyMem_Free(old_rec);

  000c4	33 c9		 xor	 ecx, ecx
  000c6	e8 00 00 00 00	 call	 PyMem_Free
$LN2@join_check:

; 1105 :         }
; 1106 :         if (self->rec == NULL) {

  000cb	48 83 7b 70 00	 cmp	 QWORD PTR [rbx+112], 0

; 1107 :             PyErr_NoMemory();
; 1108 :             return 0;

  000d0	74 0b		 je	 SHORT $LN7@join_check
$LN1@join_check:

; 1109 :         }
; 1110 :     }
; 1111 :     return 1;

  000d2	b8 01 00 00 00	 mov	 eax, 1

; 1112 : }

  000d7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000db	5b		 pop	 rbx
  000dc	c3		 ret	 0
$LN7@join_check:

; 1087 :         PyErr_NoMemory();

  000dd	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1088 :         return 0;

  000e2	33 c0		 xor	 eax, eax

; 1112 : }

  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5b		 pop	 rbx
  000e9	c3		 ret	 0
join_check_rec_size ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_append DD imagerel join_append
	DD	imagerel join_append+268
	DD	imagerel $unwind$join_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_append DD 0c1e01H
	DD	0f741eH
	DD	0e641eH
	DD	0d541eH
	DD	0c341eH
	DD	0e01a721eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT join_append
_TEXT	SEGMENT
self$ = 96
field$ = 104
quoted$ = 112
quote_empty$ = 120
join_append PROC					; COMDAT

; 1116 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1117 :     unsigned int field_kind = -1;

  0001e	83 ce ff	 or	 esi, -1			; ffffffffH

; 1118 :     void *field_data = NULL;

  00021	33 ff		 xor	 edi, edi

; 1119 :     Py_ssize_t field_len = 0;

  00023	33 ed		 xor	 ebp, ebp
  00025	45 8b e9	 mov	 r13d, r9d
  00028	4d 8b f0	 mov	 r14, r8
  0002b	48 8b da	 mov	 rbx, rdx
  0002e	4c 8b e1	 mov	 r12, rcx

; 1120 :     Py_ssize_t rec_len;
; 1121 : 
; 1122 :     if (field != NULL) {

  00031	48 85 d2	 test	 rdx, rdx
  00034	74 4a		 je	 SHORT $LN4@join_appen@2

; 1123 :         if (PyUnicode_READY(field) == -1)

  00036	f6 42 70 80	 test	 BYTE PTR [rdx+112], 128	; 00000080H
  0003a	75 14		 jne	 SHORT $LN3@join_appen@2
  0003c	48 8b ca	 mov	 rcx, rdx
  0003f	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00044	83 f8 ff	 cmp	 eax, -1
  00047	75 07		 jne	 SHORT $LN3@join_appen@2
$LN13@join_appen@2:

; 1124 :             return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 9d 00 00 00	 jmp	 $LN5@join_appen@2
$LN3@join_appen@2:

; 1125 :         field_kind = PyUnicode_KIND(field);

  00050	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  00053	8b f0		 mov	 esi, eax
  00055	c1 ee 02	 shr	 esi, 2
  00058	83 e6 07	 and	 esi, 7

; 1126 :         field_data = PyUnicode_DATA(field);

  0005b	a8 20		 test	 al, 32			; 00000020H
  0005d	74 16		 je	 SHORT $LN11@join_appen@2
  0005f	a8 40		 test	 al, 64			; 00000040H
  00061	74 09		 je	 SHORT $LN9@join_appen@2
  00063	48 8d bb 80 00
	00 00		 lea	 rdi, QWORD PTR [rbx+128]
  0006a	eb 10		 jmp	 SHORT $LN12@join_appen@2
$LN9@join_appen@2:
  0006c	48 8d bb a0 00
	00 00		 lea	 rdi, QWORD PTR [rbx+160]
  00073	eb 07		 jmp	 SHORT $LN12@join_appen@2
$LN11@join_appen@2:
  00075	48 8b bb a0 00
	00 00		 mov	 rdi, QWORD PTR [rbx+160]
$LN12@join_appen@2:

; 1127 :         field_len = PyUnicode_GET_LENGTH(field);

  0007c	48 8b 6b 60	 mov	 rbp, QWORD PTR [rbx+96]
$LN4@join_appen@2:

; 1128 :     }
; 1129 :     rec_len = join_append_data(self, field_kind, field_data, field_len,
; 1130 :                                quote_empty, quoted, 0);

  00080	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00088	4c 8b cd	 mov	 r9, rbp
  0008b	4c 8b c7	 mov	 r8, rdi
  0008e	8b d6		 mov	 edx, esi
  00090	49 8b cc	 mov	 rcx, r12
  00093	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  00098	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  0009d	e8 00 00 00 00	 call	 join_append_data

; 1131 :     if (rec_len < 0)

  000a2	48 85 c0	 test	 rax, rax

; 1132 :         return 0;

  000a5	78 a2		 js	 SHORT $LN13@join_appen@2

; 1133 : 
; 1134 :     /* grow record buffer if necessary */
; 1135 :     if (!join_check_rec_size(self, rec_len))

  000a7	48 8b d0	 mov	 rdx, rax
  000aa	49 8b cc	 mov	 rcx, r12
  000ad	e8 00 00 00 00	 call	 join_check_rec_size
  000b2	85 c0		 test	 eax, eax

; 1136 :         return 0;

  000b4	74 93		 je	 SHORT $LN13@join_appen@2

; 1137 : 
; 1138 :     self->rec_len = join_append_data(self, field_kind, field_data, field_len,
; 1139 :                                      quote_empty, quoted, 1);

  000b6	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR [rsp+48], 1
  000be	4c 8b cd	 mov	 r9, rbp
  000c1	4c 8b c7	 mov	 r8, rdi
  000c4	8b d6		 mov	 edx, esi
  000c6	49 8b cc	 mov	 rcx, r12
  000c9	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  000ce	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  000d3	e8 00 00 00 00	 call	 join_append_data

; 1140 :     self->num_fields++;

  000d8	41 ff 84 24 88
	00 00 00	 inc	 DWORD PTR [r12+136]
  000e0	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax

; 1141 : 
; 1142 :     return 1;

  000e8	b8 01 00 00 00	 mov	 eax, 1
$LN5@join_appen@2:

; 1143 : }

  000ed	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000f2	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000f7	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000fc	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  00101	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00105	41 5e		 pop	 r14
  00107	41 5d		 pop	 r13
  00109	41 5c		 pop	 r12
  0010b	c3		 ret	 0
join_append ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_append_lineterminator DD imagerel join_append_lineterminator
	DD	imagerel join_append_lineterminator+208
	DD	imagerel $unwind$join_append_lineterminator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_append_lineterminator DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT join_append_lineterminator
_TEXT	SEGMENT
self$ = 48
join_append_lineterminator PROC				; COMDAT

; 1147 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1148 :     Py_ssize_t terminator_len, i;
; 1149 :     unsigned int term_kind;
; 1150 :     void *term_data;
; 1151 : 
; 1152 :     terminator_len = PyUnicode_GET_LENGTH(self->dialect->lineterminator);

  0000a	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00015	48 8b 7a 60	 mov	 rdi, QWORD PTR [rdx+96]

; 1153 :     if (terminator_len == -1)

  00019	48 83 ff ff	 cmp	 rdi, -1
  0001d	75 0d		 jne	 SHORT $LN5@join_appen@3
$LN18@join_appen@3:

; 1154 :         return 0;

  0001f	33 c0		 xor	 eax, eax

; 1165 : 
; 1166 :     return 1;
; 1167 : }

  00021	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5f		 pop	 rdi
  0002b	c3		 ret	 0
$LN5@join_appen@3:

; 1155 : 
; 1156 :     /* grow record buffer if necessary */
; 1157 :     if (!join_check_rec_size(self, self->rec_len + terminator_len))

  0002c	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00033	48 8d 14 07	 lea	 rdx, QWORD PTR [rdi+rax]
  00037	e8 00 00 00 00	 call	 join_check_rec_size
  0003c	85 c0		 test	 eax, eax

; 1158 :         return 0;

  0003e	74 df		 je	 SHORT $LN18@join_appen@3

; 1159 : 
; 1160 :     term_kind = PyUnicode_KIND(self->dialect->lineterminator);

  00040	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
  00044	48 8b 42 78	 mov	 rax, QWORD PTR [rdx+120]
  00048	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0004b	44 8b d1	 mov	 r10d, ecx
  0004e	41 c1 ea 02	 shr	 r10d, 2
  00052	41 83 e2 07	 and	 r10d, 7

; 1161 :     term_data = PyUnicode_DATA(self->dialect->lineterminator);

  00056	f6 c1 20	 test	 cl, 32			; 00000020H
  00059	74 17		 je	 SHORT $LN10@join_appen@3
  0005b	4c 8b c8	 mov	 r9, rax
  0005e	f6 c1 40	 test	 cl, 64			; 00000040H
  00061	74 06		 je	 SHORT $LN8@join_appen@3
  00063	49 83 e9 80	 sub	 r9, -128		; ffffffffffffff80H
  00067	eb 10		 jmp	 SHORT $LN11@join_appen@3
$LN8@join_appen@3:
  00069	49 81 c1 a0 00
	00 00		 add	 r9, 160			; 000000a0H
  00070	eb 07		 jmp	 SHORT $LN11@join_appen@3
$LN10@join_appen@3:
  00072	4c 8b 88 a0 00
	00 00		 mov	 r9, QWORD PTR [rax+160]
$LN11@join_appen@3:

; 1162 :     for (i = 0; i < terminator_len; i++)

  00079	33 d2		 xor	 edx, edx
  0007b	48 85 ff	 test	 rdi, rdi
  0007e	7e 39		 jle	 SHORT $LN1@join_appen@3
$LL3@join_appen@3:

; 1163 :         self->rec[self->rec_len + i] = PyUnicode_READ(term_kind, term_data, i);

  00080	41 83 fa 01	 cmp	 r10d, 1
  00084	75 07		 jne	 SHORT $LN14@join_appen@3
  00086	46 0f b6 04 0a	 movzx	 r8d, BYTE PTR [rdx+r9]
  0008b	eb 11		 jmp	 SHORT $LN13@join_appen@3
$LN14@join_appen@3:
  0008d	41 83 fa 02	 cmp	 r10d, 2
  00091	75 07		 jne	 SHORT $LN12@join_appen@3
  00093	45 0f b7 04 51	 movzx	 r8d, WORD PTR [r9+rdx*2]
  00098	eb 04		 jmp	 SHORT $LN13@join_appen@3
$LN12@join_appen@3:

; 1162 :     for (i = 0; i < terminator_len; i++)

  0009a	45 8b 04 91	 mov	 r8d, DWORD PTR [r9+rdx*4]
$LN13@join_appen@3:

; 1163 :         self->rec[self->rec_len + i] = PyUnicode_READ(term_kind, term_data, i);

  0009e	48 8b 83 80 00
	00 00		 mov	 rax, QWORD PTR [rbx+128]
  000a5	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]
  000a9	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  000ad	48 ff c2	 inc	 rdx
  000b0	44 89 04 88	 mov	 DWORD PTR [rax+rcx*4], r8d
  000b4	48 3b d7	 cmp	 rdx, rdi
  000b7	7c c7		 jl	 SHORT $LL3@join_appen@3
$LN1@join_appen@3:

; 1164 :     self->rec_len += terminator_len;

  000b9	48 01 bb 80 00
	00 00		 add	 QWORD PTR [rbx+128], rdi

; 1165 : 
; 1166 :     return 1;
; 1167 : }

  000c0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c5	b8 01 00 00 00	 mov	 eax, 1
  000ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ce	5f		 pop	 rdi
  000cf	c3		 ret	 0
join_append_lineterminator ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@BNLPKJHP@sequence?5expected?$AA@	; `string'
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyObject_Str:PROC
EXTRN	PyNumber_Check:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PySequence_Size:PROC
EXTRN	PySequence_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_writerow DD imagerel csv_writerow
	DD	imagerel csv_writerow+80
	DD	imagerel $unwind$csv_writerow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$csv_writerow DD imagerel csv_writerow+80
	DD	imagerel csv_writerow+116
	DD	imagerel $chain$0$csv_writerow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$csv_writerow DD imagerel csv_writerow+116
	DD	imagerel csv_writerow+520
	DD	imagerel $chain$6$csv_writerow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$csv_writerow DD 0a1721H
	DD	057417H
	DD	0d6412H
	DD	0c540aH
	DD	0b3405H
	DD	04d400H
	DD	imagerel csv_writerow
	DD	imagerel csv_writerow+80
	DD	imagerel $unwind$csv_writerow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$csv_writerow DD 020521H
	DD	04d405H
	DD	imagerel csv_writerow
	DD	imagerel csv_writerow+80
	DD	imagerel $unwind$csv_writerow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_writerow DD 040a01H
	DD	0f006520aH
	DD	0c002e004H
xdata	ENDS
;	COMDAT ??_C@_0BC@BNLPKJHP@sequence?5expected?$AA@
CONST	SEGMENT
??_C@_0BC@BNLPKJHP@sequence?5expected?$AA@ DB 'sequence expected', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT csv_writerow
_TEXT	SEGMENT
quoted$21402 = 80
self$ = 80
seq$ = 88
csv_writerow PROC					; COMDAT

; 1177 : {

  00000	41 54		 push	 r12
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1178 :     DialectObj *dialect = self->dialect;

  0000a	4c 8b 71 68	 mov	 r14, QWORD PTR [rcx+104]
  0000e	4c 8b e1	 mov	 r12, rcx

; 1179 :     Py_ssize_t len, i;
; 1180 :     PyObject *line, *result;
; 1181 : 
; 1182 :     if (!PySequence_Check(seq))

  00011	48 8b ca	 mov	 rcx, rdx
  00014	4c 8b fa	 mov	 r15, rdx
  00017	e8 00 00 00 00	 call	 PySequence_Check
  0001c	85 c0		 test	 eax, eax
  0001e	75 2d		 jne	 SHORT $LN19@csv_writer

; 1183 :         return PyErr_Format(_csvstate_global->error_obj, "sequence expected");

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00027	e8 00 00 00 00	 call	 PyState_FindModule
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 PyModule_GetState
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@BNLPKJHP@sequence?5expected?$AA@
  0003b	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1247 : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5f		 pop	 r15
  00044	41 5e		 pop	 r14
  00046	41 5c		 pop	 r12
  00048	e9 00 00 00 00	 jmp	 PyErr_Format
$LN19@csv_writer:

; 1184 : 
; 1185 :     len = PySequence_Length(seq);

  0004d	49 8b cf	 mov	 rcx, r15
  00050	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00055	e8 00 00 00 00	 call	 PySequence_Size
  0005a	4c 8b e8	 mov	 r13, rax

; 1186 :     if (len < 0)

  0005d	48 85 c0	 test	 rax, rax
  00060	79 12		 jns	 SHORT $LN18@csv_writer

; 1187 :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 1247 : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	41 5f		 pop	 r15
  0006f	41 5e		 pop	 r14
  00071	41 5c		 pop	 r12
  00073	c3		 ret	 0
$LN18@csv_writer:
  00074	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  00079	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp

; 1188 : 
; 1189 :     /* Join all fields in internal buffer.
; 1190 :      */
; 1191 :     join_reset(self);

  0007e	49 8b cc	 mov	 rcx, r12
  00081	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00086	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0008b	e8 00 00 00 00	 call	 join_reset

; 1192 :     for (i = 0; i < len; i++) {

  00090	33 ff		 xor	 edi, edi
  00092	4d 85 ed	 test	 r13, r13
  00095	0f 8e fc 00 00
	00		 jle	 $LN15@csv_writer
  0009b	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
$LL17@csv_writer:

; 1193 :         PyObject *field;
; 1194 :         int append_ok;
; 1195 :         int quoted;
; 1196 : 
; 1197 :         field = PySequence_GetItem(seq, i);

  000a2	48 8b d7	 mov	 rdx, rdi
  000a5	49 8b cf	 mov	 rcx, r15
  000a8	e8 00 00 00 00	 call	 PySequence_GetItem
  000ad	48 8b d8	 mov	 rbx, rax

; 1198 :         if (field == NULL)

  000b0	48 85 c0	 test	 rax, rax
  000b3	0f 84 09 01 00
	00		 je	 $LN33@csv_writer

; 1199 :             return NULL;
; 1200 : 
; 1201 :         switch (dialect->quoting) {

  000b9	41 8b 96 80 00
	00 00		 mov	 edx, DWORD PTR [r14+128]
  000c0	ff ca		 dec	 edx
  000c2	74 23		 je	 SHORT $LN10@csv_writer
  000c4	ff ca		 dec	 edx
  000c6	74 0a		 je	 SHORT $LN11@csv_writer

; 1207 :             break;
; 1208 :         default:
; 1209 :             quoted = 0;

  000c8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR quoted$21402[rsp], 0

; 1210 :             break;

  000d0	eb 1d		 jmp	 SHORT $LN12@csv_writer
$LN11@csv_writer:

; 1202 :         case QUOTE_NONNUMERIC:
; 1203 :             quoted = !PyNumber_Check(field);

  000d2	48 8b c8	 mov	 rcx, rax
  000d5	e8 00 00 00 00	 call	 PyNumber_Check
  000da	33 c9		 xor	 ecx, ecx
  000dc	85 c0		 test	 eax, eax
  000de	0f 94 c1	 sete	 cl
  000e1	89 4c 24 50	 mov	 DWORD PTR quoted$21402[rsp], ecx

; 1204 :             break;

  000e5	eb 08		 jmp	 SHORT $LN12@csv_writer
$LN10@csv_writer:

; 1205 :         case QUOTE_ALL:
; 1206 :             quoted = 1;

  000e7	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR quoted$21402[rsp], 1
$LN12@csv_writer:

; 1211 :         }
; 1212 : 
; 1213 :         if (PyUnicode_Check(field)) {

  000ef	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000f3	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000fd	74 20		 je	 SHORT $LN8@csv_writer

; 1214 :             append_ok = join_append(self, field, &quoted, len == 1);

  000ff	45 33 c9	 xor	 r9d, r9d
  00102	49 83 fd 01	 cmp	 r13, 1
  00106	4c 8d 44 24 50	 lea	 r8, QWORD PTR quoted$21402[rsp]
  0010b	48 8b d3	 mov	 rdx, rbx
  0010e	49 8b cc	 mov	 rcx, r12
  00111	41 0f 94 c1	 sete	 r9b
  00115	e8 00 00 00 00	 call	 join_append

; 1215 :             Py_DECREF(field);

  0011a	48 8b cb	 mov	 rcx, rbx
  0011d	eb 5a		 jmp	 SHORT $LN32@csv_writer
$LN8@csv_writer:

; 1216 :         }
; 1217 :         else if (field == Py_None) {

  0011f	48 3b de	 cmp	 rbx, rsi
  00122	75 1f		 jne	 SHORT $LN6@csv_writer

; 1218 :             append_ok = join_append(self, NULL, &quoted, len == 1);

  00124	45 33 c9	 xor	 r9d, r9d
  00127	49 83 fd 01	 cmp	 r13, 1
  0012b	4c 8d 44 24 50	 lea	 r8, QWORD PTR quoted$21402[rsp]
  00130	41 0f 94 c1	 sete	 r9b
  00134	33 d2		 xor	 edx, edx
  00136	49 8b cc	 mov	 rcx, r12
  00139	e8 00 00 00 00	 call	 join_append

; 1219 :             Py_DECREF(field);

  0013e	48 8b cb	 mov	 rcx, rbx

; 1220 :         }
; 1221 :         else {

  00141	eb 36		 jmp	 SHORT $LN32@csv_writer
$LN6@csv_writer:

; 1222 :             PyObject *str;
; 1223 : 
; 1224 :             str = PyObject_Str(field);

  00143	48 8b cb	 mov	 rcx, rbx
  00146	e8 00 00 00 00	 call	 PyObject_Str

; 1225 :             Py_DECREF(field);

  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	48 8b e8	 mov	 rbp, rax
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 1226 :             if (str == NULL)

  00156	48 85 ed	 test	 rbp, rbp
  00159	74 67		 je	 SHORT $LN33@csv_writer

; 1227 :                 return NULL;
; 1228 :             append_ok = join_append(self, str, &quoted, len == 1);

  0015b	45 33 c9	 xor	 r9d, r9d
  0015e	49 83 fd 01	 cmp	 r13, 1
  00162	4c 8d 44 24 50	 lea	 r8, QWORD PTR quoted$21402[rsp]
  00167	48 8b d5	 mov	 rdx, rbp
  0016a	49 8b cc	 mov	 rcx, r12
  0016d	41 0f 94 c1	 sete	 r9b
  00171	e8 00 00 00 00	 call	 join_append

; 1229 :             Py_DECREF(str);

  00176	48 8b cd	 mov	 rcx, rbp
$LN32@csv_writer:
  00179	8b f0		 mov	 esi, eax
  0017b	e8 00 00 00 00	 call	 _Py_DecRef

; 1230 :         }
; 1231 :         if (!append_ok)

  00180	85 f6		 test	 esi, esi
  00182	74 3e		 je	 SHORT $LN33@csv_writer

; 1192 :     for (i = 0; i < len; i++) {

  00184	48 ff c7	 inc	 rdi
  00187	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0018e	49 3b fd	 cmp	 rdi, r13
  00191	0f 8c 0b ff ff
	ff		 jl	 $LL17@csv_writer
$LN15@csv_writer:

; 1232 :             return NULL;
; 1233 :     }
; 1234 : 
; 1235 :     /* Add line terminator.
; 1236 :      */
; 1237 :     if (!join_append_lineterminator(self))

  00197	49 8b cc	 mov	 rcx, r12
  0019a	e8 00 00 00 00	 call	 join_append_lineterminator
  0019f	85 c0		 test	 eax, eax

; 1238 :         return 0;

  001a1	74 1f		 je	 SHORT $LN33@csv_writer

; 1239 : 
; 1240 :     line = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
; 1241 :                                      (void *) self->rec, self->rec_len);

  001a3	4d 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR [r12+128]
  001ab	49 8b 54 24 70	 mov	 rdx, QWORD PTR [r12+112]
  001b0	b9 04 00 00 00	 mov	 ecx, 4
  001b5	e8 00 00 00 00	 call	 PyUnicode_FromKindAndData
  001ba	48 8b f8	 mov	 rdi, rax

; 1242 :     if (line == NULL)

  001bd	48 85 c0	 test	 rax, rax
  001c0	75 04		 jne	 SHORT $LN1@csv_writer
$LN33@csv_writer:

; 1243 :         return NULL;

  001c2	33 c0		 xor	 eax, eax
  001c4	eb 1e		 jmp	 SHORT $LN31@csv_writer
$LN1@csv_writer:

; 1244 :     result = PyObject_CallFunctionObjArgs(self->writeline, line, NULL);

  001c6	49 8b 4c 24 60	 mov	 rcx, QWORD PTR [r12+96]
  001cb	45 33 c0	 xor	 r8d, r8d
  001ce	48 8b d0	 mov	 rdx, rax
  001d1	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 1245 :     Py_DECREF(line);

  001d6	48 8b cf	 mov	 rcx, rdi
  001d9	48 8b d8	 mov	 rbx, rax
  001dc	e8 00 00 00 00	 call	 _Py_DecRef

; 1246 :     return result;

  001e1	48 8b c3	 mov	 rax, rbx
$LN31@csv_writer:
  001e4	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  001e9	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  001ee	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  001f3	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  001f8	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]

; 1247 : }

  001fd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00201	41 5f		 pop	 r15
  00203	41 5e		 pop	 r14
  00205	41 5c		 pop	 r12
  00207	c3		 ret	 0
csv_writerow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@LBOMLBOD@writerows?$CI?$CJ?5argument?5must?5be?5ite@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$csv_writerows DD imagerel csv_writerows
	DD	imagerel csv_writerows+64
	DD	imagerel $unwind$csv_writerows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$csv_writerows DD imagerel csv_writerows+64
	DD	imagerel csv_writerows+456
	DD	imagerel $chain$1$csv_writerows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$csv_writerows DD imagerel csv_writerows+456
	DD	imagerel csv_writerows+468
	DD	imagerel $chain$3$csv_writerows
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$csv_writerows DD 040021H
	DD	097400H
	DD	083400H
	DD	imagerel csv_writerows
	DD	imagerel csv_writerows+64
	DD	imagerel $unwind$csv_writerows
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$csv_writerows DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel csv_writerows
	DD	imagerel csv_writerows+64
	DD	imagerel $unwind$csv_writerows
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_writerows DD 040a01H
	DD	0a540aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_0CG@LBOMLBOD@writerows?$CI?$CJ?5argument?5must?5be?5ite@
CONST	SEGMENT
??_C@_0CG@LBOMLBOD@writerows?$CI?$CJ?5argument?5must?5be?5ite@ DB 'writer'
	DB	'ows() argument must be iterable', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT csv_writerows
_TEXT	SEGMENT
self$ = 64
seqseq$ = 72
csv_writerows PROC					; COMDAT

; 1257 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b e9	 mov	 rbp, rcx

; 1258 :     PyObject *row_iter, *row_obj, *result;
; 1259 : 
; 1260 :     row_iter = PyObject_GetIter(seqseq);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 PyObject_GetIter
  00015	48 8b f0	 mov	 rsi, rax

; 1261 :     if (row_iter == NULL) {

  00018	48 85 c0	 test	 rax, rax
  0001b	75 20		 jne	 SHORT $LN35@csv_writer@2

; 1262 :         PyErr_SetString(PyExc_TypeError,
; 1263 :                         "writerows() argument must be iterable");

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@LBOMLBOD@writerows?$CI?$CJ?5argument?5must?5be?5ite@
  0002b	e8 00 00 00 00	 call	 PyErr_SetString

; 1264 :         return NULL;

  00030	33 c0		 xor	 eax, eax

; 1281 : }

  00032	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00037	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003b	5e		 pop	 rsi
  0003c	c3		 ret	 0
$LN35@csv_writer@2:

; 1265 :     }
; 1266 :     while ((row_obj = PyIter_Next(row_iter))) {

  0003d	48 8b c8	 mov	 rcx, rax
  00040	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00045	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0004a	e8 00 00 00 00	 call	 PyIter_Next
  0004f	48 8b d8	 mov	 rbx, rax
  00052	48 85 c0	 test	 rax, rax
  00055	0f 84 fa 00 00
	00		 je	 $LN4@csv_writer@2
  0005b	0f 1f 44 00 00	 npad	 5
$LL5@csv_writer@2:

; 1267 :         result = csv_writerow(self, row_obj);

  00060	48 8b d3	 mov	 rdx, rbx
  00063	48 8b cd	 mov	 rcx, rbp
  00066	e8 00 00 00 00	 call	 csv_writerow
  0006b	48 8b f8	 mov	 rdi, rax

; 1268 :         Py_DECREF(row_obj);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 5c		 jne	 SHORT $LN19@csv_writer@2
  00077	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0007b	a8 20		 test	 al, 32			; 00000020H
  0007d	75 4c		 jne	 SHORT $LN13@csv_writer@2
  0007f	84 c0		 test	 al, al
  00081	78 48		 js	 SHORT $LN13@csv_writer@2
  00083	a8 02		 test	 al, 2
  00085	75 4c		 jne	 SHORT $LN19@csv_writer@2
  00087	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0008b	75 46		 jne	 SHORT $LN19@csv_writer@2
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0009b	4c 8b cb	 mov	 r9, rbx
  0009e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b1	48 8b cb	 mov	 rcx, rbx
  000b4	85 c0		 test	 eax, eax
  000b6	74 07		 je	 SHORT $LN18@csv_writer@2
  000b8	e8 00 00 00 00	 call	 _Px_Dealloc
  000bd	eb 14		 jmp	 SHORT $LN19@csv_writer@2
$LN18@csv_writer@2:
  000bf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000c3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000c9	eb 08		 jmp	 SHORT $LN19@csv_writer@2
$LN13@csv_writer@2:
  000cb	48 8b cb	 mov	 rcx, rbx
  000ce	e8 00 00 00 00	 call	 Px_DecRef
$LN19@csv_writer@2:

; 1269 :         if (!result) {

  000d3	48 85 ff	 test	 rdi, rdi
  000d6	0f 84 ec 00 00
	00		 je	 $LN36@csv_writer@2

; 1272 :         }
; 1273 :         else
; 1274 :              Py_DECREF(result);

  000dc	e8 00 00 00 00	 call	 _Py_PXCTX
  000e1	85 c0		 test	 eax, eax
  000e3	75 5c		 jne	 SHORT $LN30@csv_writer@2
  000e5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000e9	a8 20		 test	 al, 32			; 00000020H
  000eb	75 4c		 jne	 SHORT $LN24@csv_writer@2
  000ed	84 c0		 test	 al, al
  000ef	78 48		 js	 SHORT $LN24@csv_writer@2
  000f1	a8 02		 test	 al, 2
  000f3	75 4c		 jne	 SHORT $LN30@csv_writer@2
  000f5	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000f9	75 46		 jne	 SHORT $LN30@csv_writer@2
  000fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00109	4c 8b cf	 mov	 r9, rdi
  0010c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00112	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0011a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011f	48 8b cf	 mov	 rcx, rdi
  00122	85 c0		 test	 eax, eax
  00124	74 07		 je	 SHORT $LN29@csv_writer@2
  00126	e8 00 00 00 00	 call	 _Px_Dealloc
  0012b	eb 14		 jmp	 SHORT $LN30@csv_writer@2
$LN29@csv_writer@2:
  0012d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00131	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00137	eb 08		 jmp	 SHORT $LN30@csv_writer@2
$LN24@csv_writer@2:
  00139	48 8b cf	 mov	 rcx, rdi
  0013c	e8 00 00 00 00	 call	 Px_DecRef
$LN30@csv_writer@2:

; 1265 :     }
; 1266 :     while ((row_obj = PyIter_Next(row_iter))) {

  00141	48 8b ce	 mov	 rcx, rsi
  00144	e8 00 00 00 00	 call	 PyIter_Next
  00149	48 8b d8	 mov	 rbx, rax
  0014c	48 85 c0	 test	 rax, rax
  0014f	0f 85 0b ff ff
	ff		 jne	 $LL5@csv_writer@2
$LN4@csv_writer@2:

; 1275 :     }
; 1276 :     Py_DECREF(row_iter);

  00155	48 8b ce	 mov	 rcx, rsi
  00158	e8 00 00 00 00	 call	 _Py_DecRef

; 1277 :     if (PyErr_Occurred())

  0015d	e8 00 00 00 00	 call	 PyErr_Occurred
  00162	48 85 c0	 test	 rax, rax

; 1278 :         return NULL;

  00165	75 69		 jne	 SHORT $LN39@csv_writer@2

; 1279 :     Py_INCREF(Py_None);

  00167	e8 00 00 00 00	 call	 _Py_PXCTX
  0016c	85 c0		 test	 eax, eax
  0016e	75 3c		 jne	 SHORT $LN32@csv_writer@2
  00170	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00185	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0018b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00193	e8 00 00 00 00	 call	 _PyParallel_Guard
  00198	85 c0		 test	 eax, eax
  0019a	75 09		 jne	 SHORT $LN31@csv_writer@2
  0019c	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  001a3	74 07		 je	 SHORT $LN32@csv_writer@2
$LN31@csv_writer@2:
  001a5	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN32@csv_writer@2:

; 1280 :     return Py_None;

  001ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN38@csv_writer@2:
  001b3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b8	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 1281 : }

  001bd	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001c2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001c6	5e		 pop	 rsi
  001c7	c3		 ret	 0
$LN36@csv_writer@2:

; 1270 :             Py_DECREF(row_iter);

  001c8	48 8b ce	 mov	 rcx, rsi
  001cb	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@csv_writer@2:

; 1271 :             return NULL;

  001d0	33 c0		 xor	 eax, eax
  001d2	eb df		 jmp	 SHORT $LN38@csv_writer@2
csv_writerows ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Writer_dealloc DD imagerel Writer_dealloc
	DD	imagerel Writer_dealloc+270
	DD	imagerel $unwind$Writer_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Writer_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT Writer_dealloc
_TEXT	SEGMENT
self$ = 64
Writer_dealloc PROC					; COMDAT

; 1298 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1299 :     PyObject_GC_UnTrack(self);

  0000d	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 1300 :     Py_XDECREF(self->dialect);

  00012	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00016	48 85 db	 test	 rbx, rbx
  00019	74 65		 je	 SHORT $LN8@Writer_dea
  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	75 5c		 jne	 SHORT $LN8@Writer_dea
  00024	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00028	a8 20		 test	 al, 32			; 00000020H
  0002a	75 4c		 jne	 SHORT $LN16@Writer_dea
  0002c	84 c0		 test	 al, al
  0002e	78 48		 js	 SHORT $LN16@Writer_dea
  00030	a8 02		 test	 al, 2
  00032	75 4c		 jne	 SHORT $LN8@Writer_dea
  00034	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00038	75 46		 jne	 SHORT $LN8@Writer_dea
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00048	4c 8b cb	 mov	 r9, rbx
  0004b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00051	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005e	48 8b cb	 mov	 rcx, rbx
  00061	85 c0		 test	 eax, eax
  00063	74 07		 je	 SHORT $LN21@Writer_dea
  00065	e8 00 00 00 00	 call	 _Px_Dealloc
  0006a	eb 14		 jmp	 SHORT $LN8@Writer_dea
$LN21@Writer_dea:
  0006c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00070	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00076	eb 08		 jmp	 SHORT $LN8@Writer_dea
$LN16@Writer_dea:
  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 Px_DecRef
$LN8@Writer_dea:

; 1301 :     Py_XDECREF(self->writeline);

  00080	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 65		 je	 SHORT $LN4@Writer_dea
  00089	e8 00 00 00 00	 call	 _Py_PXCTX
  0008e	85 c0		 test	 eax, eax
  00090	75 5c		 jne	 SHORT $LN4@Writer_dea
  00092	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00096	a8 20		 test	 al, 32			; 00000020H
  00098	75 4c		 jne	 SHORT $LN27@Writer_dea
  0009a	84 c0		 test	 al, al
  0009c	78 48		 js	 SHORT $LN27@Writer_dea
  0009e	a8 02		 test	 al, 2
  000a0	75 4c		 jne	 SHORT $LN4@Writer_dea
  000a2	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  000a6	75 46		 jne	 SHORT $LN4@Writer_dea
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000b6	4c 8b cb	 mov	 r9, rbx
  000b9	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000bf	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000c7	e8 00 00 00 00	 call	 _PyParallel_Guard
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	85 c0		 test	 eax, eax
  000d1	74 07		 je	 SHORT $LN32@Writer_dea
  000d3	e8 00 00 00 00	 call	 _Px_Dealloc
  000d8	eb 14		 jmp	 SHORT $LN4@Writer_dea
$LN32@Writer_dea:
  000da	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000de	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000e4	eb 08		 jmp	 SHORT $LN4@Writer_dea
$LN27@Writer_dea:
  000e6	48 8b cb	 mov	 rcx, rbx
  000e9	e8 00 00 00 00	 call	 Px_DecRef
$LN4@Writer_dea:

; 1302 :     if (self->rec != NULL)

  000ee	48 8b 4f 70	 mov	 rcx, QWORD PTR [rdi+112]
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	74 05		 je	 SHORT $LN1@Writer_dea

; 1303 :         PyMem_Free(self->rec);

  000f7	e8 00 00 00 00	 call	 PyMem_Free
$LN1@Writer_dea:

; 1304 :     PyObject_GC_Del(self);

  000fc	48 8b cf	 mov	 rcx, rdi

; 1305 : }

  000ff	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00104	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00108	5f		 pop	 rdi
  00109	e9 00 00 00 00	 jmp	 PyObject_GC_Del
Writer_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ODABNAGK@Writer_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Writer_traverse DD imagerel Writer_traverse
	DD	imagerel Writer_traverse+152
	DD	imagerel $unwind$Writer_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Writer_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BA@ODABNAGK@Writer_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@ODABNAGK@Writer_traverse?$AA@ DB 'Writer_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT Writer_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
Writer_traverse PROC					; COMDAT

; 1309 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 1310 :     Py_VISIT(self->dialect);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN9@Writer_tra
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ODABNAGK@Writer_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 1e 05 00
	00		 mov	 r8d, 1310		; 0000051eH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@Writer_tra:
  0003d	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN11@Writer_tra
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 39		 jne	 SHORT $LN13@Writer_tra
$LN11@Writer_tra:

; 1311 :     Py_VISIT(self->writeline);

  0004f	e8 00 00 00 00	 call	 _Py_PXCTX
  00054	85 c0		 test	 eax, eax
  00056	74 1c		 je	 SHORT $LN3@Writer_tra
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ODABNAGK@Writer_traverse?$AA@
  00066	45 33 c9	 xor	 r9d, r9d
  00069	41 b8 1f 05 00
	00		 mov	 r8d, 1311		; 0000051fH
  0006f	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@Writer_tra:
  00074	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00078	48 85 c9	 test	 rcx, rcx
  0007b	74 09		 je	 SHORT $LN5@Writer_tra
  0007d	48 8b d7	 mov	 rdx, rdi
  00080	ff d6		 call	 rsi
  00082	85 c0		 test	 eax, eax
  00084	75 02		 jne	 SHORT $LN13@Writer_tra
$LN5@Writer_tra:

; 1312 :     return 0;

  00086	33 c0		 xor	 eax, eax
$LN13@Writer_tra:

; 1313 : }

  00088	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00092	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00096	5f		 pop	 rdi
  00097	c3		 ret	 0
Writer_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DPGCILNC@Writer_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$Writer_clear DD imagerel Writer_clear
	DD	imagerel Writer_clear+378
	DD	imagerel $unwind$Writer_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Writer_clear DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0N@DPGCILNC@Writer_clear?$AA@
CONST	SEGMENT
??_C@_0N@DPGCILNC@Writer_clear?$AA@ DB 'Writer_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT Writer_clear
_TEXT	SEGMENT
self$ = 64
Writer_clear PROC					; COMDAT

; 1317 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1318 :     Py_CLEAR(self->dialect);

  0000a	4c 8b 49 68	 mov	 r9, QWORD PTR [rcx+104]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	4d 85 c9	 test	 r9, r9
  00014	0f 84 96 00 00
	00		 je	 $LN7@Writer_cle
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPGCILNC@Writer_clear?$AA@
  00028	41 b8 26 05 00
	00		 mov	 r8d, 1318		; 00000526H
  0002e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 71		 jne	 SHORT $LN7@Writer_cle
  0003f	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  00043	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 5c		 jne	 SHORT $LN7@Writer_cle
  00054	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00058	a8 20		 test	 al, 32			; 00000020H
  0005a	75 4c		 jne	 SHORT $LN15@Writer_cle
  0005c	84 c0		 test	 al, al
  0005e	78 48		 js	 SHORT $LN15@Writer_cle
  00060	a8 02		 test	 al, 2
  00062	75 4c		 jne	 SHORT $LN7@Writer_cle
  00064	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00068	75 46		 jne	 SHORT $LN7@Writer_cle
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00081	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	85 c0		 test	 eax, eax
  00093	74 07		 je	 SHORT $LN20@Writer_cle
  00095	e8 00 00 00 00	 call	 _Px_Dealloc
  0009a	eb 14		 jmp	 SHORT $LN7@Writer_cle
$LN20@Writer_cle:
  0009c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a6	eb 08		 jmp	 SHORT $LN7@Writer_cle
$LN15@Writer_cle:
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 Px_DecRef
$LN7@Writer_cle:

; 1319 :     Py_CLEAR(self->writeline);

  000b0	4c 8b 4f 60	 mov	 r9, QWORD PTR [rdi+96]
  000b4	4d 85 c9	 test	 r9, r9
  000b7	0f 84 b0 00 00
	00		 je	 $LN35@Writer_cle
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@DDBDDPGA@?4?4?2Modules?2_csv?4c?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPGCILNC@Writer_clear?$AA@
  000cb	41 b8 27 05 00
	00		 mov	 r8d, 1319		; 00000527H
  000d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	0f 85 87 00 00
	00		 jne	 $LN35@Writer_cle
  000e6	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  000ea	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  000f2	e8 00 00 00 00	 call	 _Py_PXCTX
  000f7	85 c0		 test	 eax, eax
  000f9	75 72		 jne	 SHORT $LN35@Writer_cle
  000fb	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000ff	a8 20		 test	 al, 32			; 00000020H
  00101	75 62		 jne	 SHORT $LN26@Writer_cle
  00103	84 c0		 test	 al, al
  00105	78 5e		 js	 SHORT $LN26@Writer_cle
  00107	a8 02		 test	 al, 2
  00109	75 62		 jne	 SHORT $LN35@Writer_cle
  0010b	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010f	75 5c		 jne	 SHORT $LN35@Writer_cle
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011f	4c 8b cb	 mov	 r9, rbx
  00122	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00128	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00130	e8 00 00 00 00	 call	 _PyParallel_Guard
  00135	48 8b cb	 mov	 rcx, rbx
  00138	85 c0		 test	 eax, eax
  0013a	74 12		 je	 SHORT $LN31@Writer_cle
  0013c	e8 00 00 00 00	 call	 _Px_Dealloc

; 1320 :     return 0;

  00141	33 c0		 xor	 eax, eax

; 1321 : }

  00143	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00148	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014c	5f		 pop	 rdi
  0014d	c3		 ret	 0

; 1319 :     Py_CLEAR(self->writeline);

$LN31@Writer_cle:
  0014e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00152	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1320 :     return 0;

  00158	33 c0		 xor	 eax, eax

; 1321 : }

  0015a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0015f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00163	5f		 pop	 rdi
  00164	c3		 ret	 0

; 1319 :     Py_CLEAR(self->writeline);

$LN26@Writer_cle:
  00165	48 8b cb	 mov	 rcx, rbx
  00168	e8 00 00 00 00	 call	 Px_DecRef
$LN35@Writer_cle:

; 1320 :     return 0;

  0016d	33 c0		 xor	 eax, eax

; 1321 : }

  0016f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00174	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
Writer_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@MLDPKAEK@argument?51?5must?5have?5a?5?$CCwrite?$CC?5m@ ; `string'
EXTRN	PyCallable_Check:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_writer DD imagerel csv_writer
	DD	imagerel csv_writer+291
	DD	imagerel $unwind$csv_writer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_writer DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT ??_C@_0CG@MLDPKAEK@argument?51?5must?5have?5a?5?$CCwrite?$CC?5m@
CONST	SEGMENT
??_C@_0CG@MLDPKAEK@argument?51?5must?5have?5a?5?$CCwrite?$CC?5m@ DB 'argu'
	DB	'ment 1 must have a "write" method', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT csv_writer
_TEXT	SEGMENT
output_file$ = 48
module$ = 80
args$ = 88
keyword_args$ = 96
dialect$ = 104
csv_writer PROC						; COMDAT

; 1367 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1368 :     PyObject * output_file, * dialect = NULL;

  00014	33 ed		 xor	 ebp, ebp
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b f2	 mov	 rsi, rdx
  0001c	48 89 6c 24 68	 mov	 QWORD PTR dialect$[rsp], rbp

; 1369 :     WriterObj * self = PyObject_GC_New(WriterObj, &Writer_Type);

  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Writer_Type
  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@csv_writer@3
  00031	e8 00 00 00 00	 call	 _PxObject_New
  00036	eb 05		 jmp	 SHORT $LN10@csv_writer@3
$LN8@csv_writer@3:
  00038	e8 00 00 00 00	 call	 _PyObject_GC_New
$LN10@csv_writer@3:
  0003d	48 8b d8	 mov	 rbx, rax

; 1370 :     _Py_IDENTIFIER(write);
; 1371 : 
; 1372 :     if (!self)

  00040	48 85 c0	 test	 rax, rax

; 1373 :         return NULL;

  00043	0f 84 c3 00 00
	00		 je	 $LN11@csv_writer@3

; 1374 : 
; 1375 :     self->dialect = NULL;

  00049	48 89 68 68	 mov	 QWORD PTR [rax+104], rbp

; 1376 :     self->writeline = NULL;

  0004d	48 89 68 60	 mov	 QWORD PTR [rax+96], rbp

; 1377 : 
; 1378 :     self->rec = NULL;

  00051	48 89 68 70	 mov	 QWORD PTR [rax+112], rbp

; 1379 :     self->rec_size = 0;

  00055	48 89 68 78	 mov	 QWORD PTR [rax+120], rbp

; 1380 :     self->rec_len = 0;

  00059	48 89 a8 80 00
	00 00		 mov	 QWORD PTR [rax+128], rbp

; 1381 :     self->num_fields = 0;

  00060	89 a8 88 00 00
	00		 mov	 DWORD PTR [rax+136], ebp

; 1382 : 
; 1383 :     if (!PyArg_UnpackTuple(args, "", 1, 2, &output_file, &dialect)) {

  00066	48 8d 44 24 68	 lea	 rax, QWORD PTR dialect$[rsp]
  0006b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00078	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007d	48 8d 44 24 30	 lea	 rax, QWORD PTR output_file$[rsp]
  00082	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  00086	48 8b ce	 mov	 rcx, rsi
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00093	85 c0		 test	 eax, eax

; 1384 :         Py_DECREF(self);
; 1385 :         return NULL;

  00095	74 6d		 je	 SHORT $LN12@csv_writer@3

; 1386 :     }
; 1387 :     self->writeline = _PyObject_GetAttrId(output_file, &PyId_write);

  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0009d	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  000a6	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_write@?1??csv_writer@@9@9
  000ab	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR output_file$[rsp]
  000b4	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000b9	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 1388 :     if (self->writeline == NULL || !PyCallable_Check(self->writeline)) {

  000bd	48 85 c0	 test	 rax, rax
  000c0	74 2f		 je	 SHORT $LN2@csv_writer@3
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	e8 00 00 00 00	 call	 PyCallable_Check
  000ca	85 c0		 test	 eax, eax
  000cc	74 23		 je	 SHORT $LN2@csv_writer@3

; 1393 :     }
; 1394 :     self->dialect = (DialectObj *)_call_dialect(dialect, keyword_args);

  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dialect$[rsp]
  000d3	48 8b d7	 mov	 rdx, rdi
  000d6	e8 00 00 00 00	 call	 _call_dialect

; 1395 :     if (self->dialect == NULL) {
; 1396 :         Py_DECREF(self);

  000db	48 8b cb	 mov	 rcx, rbx
  000de	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax
  000e2	48 85 c0	 test	 rax, rax

; 1397 :         return NULL;

  000e5	74 20		 je	 SHORT $LN13@csv_writer@3

; 1398 :     }
; 1399 :     PyObject_GC_Track(self);

  000e7	e8 00 00 00 00	 call	 PyObject_GC_Track

; 1400 :     return (PyObject *)self;

  000ec	48 8b c3	 mov	 rax, rbx
  000ef	eb 1d		 jmp	 SHORT $LN6@csv_writer@3
$LN2@csv_writer@3:

; 1389 :         PyErr_SetString(PyExc_TypeError,
; 1390 :                         "argument 1 must have a \"write\" method");

  000f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@MLDPKAEK@argument?51?5must?5have?5a?5?$CCwrite?$CC?5m@
  000ff	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@csv_writer@3:

; 1391 :         Py_DECREF(self);

  00104	48 8b cb	 mov	 rcx, rbx
$LN13@csv_writer@3:
  00107	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@csv_writer@3:

; 1392 :         return NULL;

  0010c	33 c0		 xor	 eax, eax
$LN6@csv_writer@3:

; 1401 : }

  0010e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00113	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00118	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00121	5f		 pop	 rdi
  00122	c3		 ret	 0
csv_writer ENDP
_TEXT	ENDS
EXTRN	PyDict_Keys:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_list_dialects DD imagerel csv_list_dialects
	DD	imagerel csv_list_dialects+37
	DD	imagerel $unwind$csv_list_dialects
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_list_dialects DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT csv_list_dialects
_TEXT	SEGMENT
module$ = 48
args$ = 56
csv_list_dialects PROC					; COMDAT

; 1408 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1409 :     return PyDict_Keys(_csvstate_global->dialects);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  0000b	e8 00 00 00 00	 call	 PyState_FindModule
  00010	48 8b c8	 mov	 rcx, rax
  00013	e8 00 00 00 00	 call	 PyModule_GetState
  00018	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 1410 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	e9 00 00 00 00	 jmp	 PyDict_Keys
csv_list_dialects ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@IGKDECPB@dialect?5name?5must?5be?5a?5string?$AA@ ; `string'
EXTRN	PyDict_SetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_register_dialect DD imagerel csv_register_dialect
	DD	imagerel csv_register_dialect+242
	DD	imagerel $unwind$csv_register_dialect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_register_dialect DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0BO@IGKDECPB@dialect?5name?5must?5be?5a?5string?$AA@
CONST	SEGMENT
??_C@_0BO@IGKDECPB@dialect?5name?5must?5be?5a?5string?$AA@ DB 'dialect na'
	DB	'me must be a string', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT csv_register_dialect
_TEXT	SEGMENT
name_obj$ = 48
module$ = 80
args$ = 88
kwargs$ = 96
dialect_obj$ = 104
csv_register_dialect PROC				; COMDAT

; 1414 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 1415 :     PyObject *name_obj, *dialect_obj = NULL;
; 1416 :     PyObject *dialect;
; 1417 : 
; 1418 :     if (!PyArg_UnpackTuple(args, "", 1, 2, &name_obj, &dialect_obj))

  00009	48 8d 4c 24 68	 lea	 rcx, QWORD PTR dialect_obj$[rsp]
  0000e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00014	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00019	48 8d 4c 24 30	 lea	 rcx, QWORD PTR name_obj$[rsp]
  0001e	49 8b d8	 mov	 rbx, r8
  00021	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00026	45 8d 41 ff	 lea	 r8d, QWORD PTR [r9-1]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00031	48 8b c8	 mov	 rcx, rax
  00034	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR dialect_obj$[rsp], 0
  0003d	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00042	85 c0		 test	 eax, eax

; 1419 :         return NULL;

  00044	74 28		 je	 SHORT $LN10@csv_regist

; 1420 :     if (!PyUnicode_Check(name_obj)) {

  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR name_obj$[rsp]
  0004b	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0004f	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00059	75 1b		 jne	 SHORT $LN4@csv_regist

; 1421 :         PyErr_SetString(PyExc_TypeError,
; 1422 :                         "dialect name must be a string");

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@IGKDECPB@dialect?5name?5must?5be?5a?5string?$AA@
  00069	e8 00 00 00 00	 call	 PyErr_SetString
$LN10@csv_regist:

; 1423 :         return NULL;

  0006e	33 c0		 xor	 eax, eax

; 1437 : }

  00070	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00074	5b		 pop	 rbx
  00075	c3		 ret	 0
$LN4@csv_regist:

; 1424 :     }
; 1425 :     if (PyUnicode_READY(name_obj) == -1)

  00076	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  0007a	75 0a		 jne	 SHORT $LN3@csv_regist
  0007c	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00081	83 f8 ff	 cmp	 eax, -1

; 1426 :         return NULL;

  00084	74 e8		 je	 SHORT $LN10@csv_regist
$LN3@csv_regist:

; 1427 :     dialect = _call_dialect(dialect_obj, kwargs);

  00086	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dialect_obj$[rsp]
  0008b	48 8b d3	 mov	 rdx, rbx
  0008e	e8 00 00 00 00	 call	 _call_dialect
  00093	48 8b d8	 mov	 rbx, rax

; 1428 :     if (dialect == NULL)

  00096	48 85 c0	 test	 rax, rax

; 1429 :         return NULL;

  00099	74 d3		 je	 SHORT $LN10@csv_regist

; 1430 :     if (PyDict_SetItem(_csvstate_global->dialects, name_obj, dialect) < 0) {

  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  000a2	e8 00 00 00 00	 call	 PyState_FindModule
  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 PyModule_GetState
  000af	48 8b 54 24 30	 mov	 rdx, QWORD PTR name_obj$[rsp]
  000b4	4c 8b c3	 mov	 r8, rbx
  000b7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000bb	e8 00 00 00 00	 call	 PyDict_SetItem

; 1431 :         Py_DECREF(dialect);

  000c0	48 8b cb	 mov	 rcx, rbx
  000c3	85 c0		 test	 eax, eax
  000c5	79 0d		 jns	 SHORT $LN1@csv_regist
  000c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1432 :         return NULL;

  000cc	33 c0		 xor	 eax, eax

; 1437 : }

  000ce	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
$LN1@csv_regist:

; 1433 :     }
; 1434 :     Py_DECREF(dialect);

  000d4	e8 00 00 00 00	 call	 _Py_DecRef

; 1435 :     Py_INCREF(Py_None);

  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000e0	e8 00 00 00 00	 call	 _Py_IncRef

; 1436 :     return Py_None;

  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1437 : }

  000ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f0	5b		 pop	 rbx
  000f1	c3		 ret	 0
csv_register_dialect ENDP
_TEXT	ENDS
EXTRN	PyDict_DelItem:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$csv_unregister_dialect DD imagerel csv_unregister_dialect
	DD	imagerel csv_unregister_dialect+167
	DD	imagerel $unwind$csv_unregister_dialect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_unregister_dialect DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
xdata	ENDS
;	COMDAT csv_unregister_dialect
_TEXT	SEGMENT
module$ = 64
name_obj$ = 72
csv_unregister_dialect PROC				; COMDAT

; 1441 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1442 :     if (PyDict_DelItem(_csvstate_global->dialects, name_obj) < 0)

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  0000d	48 8b da	 mov	 rbx, rdx
  00010	e8 00 00 00 00	 call	 PyState_FindModule
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	48 8b d3	 mov	 rdx, rbx
  00020	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00024	e8 00 00 00 00	 call	 PyDict_DelItem
  00029	85 c0		 test	 eax, eax
  0002b	79 28		 jns	 SHORT $LN1@csv_unregi

; 1443 :         return PyErr_Format(_csvstate_global->error_obj, "unknown dialect");

  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00034	e8 00 00 00 00	 call	 PyState_FindModule
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 PyModule_GetState
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DGBJMIAO@unknown?5dialect?$AA@
  00048	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1446 : }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5b		 pop	 rbx
  00050	e9 00 00 00 00	 jmp	 PyErr_Format
$LN1@csv_unregi:

; 1444 :     Py_INCREF(Py_None);

  00055	e8 00 00 00 00	 call	 _Py_PXCTX
  0005a	85 c0		 test	 eax, eax
  0005c	75 3c		 jne	 SHORT $LN5@csv_unregi
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00073	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00079	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00081	e8 00 00 00 00	 call	 _PyParallel_Guard
  00086	85 c0		 test	 eax, eax
  00088	75 09		 jne	 SHORT $LN4@csv_unregi
  0008a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00091	74 07		 je	 SHORT $LN5@csv_unregi
$LN4@csv_unregi:
  00093	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@csv_unregi:

; 1445 :     return Py_None;

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1446 : }

  000a1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0
csv_unregister_dialect ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT csv_get_dialect
_TEXT	SEGMENT
module$ = 8
name_obj$ = 16
csv_get_dialect PROC					; COMDAT

; 1451 :     return get_dialect_from_registry(name_obj);

  00000	48 8b ca	 mov	 rcx, rdx

; 1452 : }

  00003	e9 00 00 00 00	 jmp	 get_dialect_from_registry
csv_get_dialect ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@EOJGCLAC@limit?5must?5be?5an?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$csv_field_size_limit DD imagerel csv_field_size_limit
	DD	imagerel csv_field_size_limit+262
	DD	imagerel $unwind$csv_field_size_limit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$csv_field_size_limit DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BJ@EOJGCLAC@limit?5must?5be?5an?5integer?$AA@
CONST	SEGMENT
??_C@_0BJ@EOJGCLAC@limit?5must?5be?5an?5integer?$AA@ DB 'limit must be an'
	DB	' integer', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT csv_field_size_limit
_TEXT	SEGMENT
module$ = 64
args$ = 72
new_limit$ = 80
csv_field_size_limit PROC				; COMDAT

; 1456 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1457 :     PyObject *new_limit = NULL;
; 1458 :     long old_limit = _csvstate_global->field_limit;

  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR new_limit$[rsp], 0
  0001d	e8 00 00 00 00	 call	 PyState_FindModule
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 PyModule_GetState

; 1459 : 
; 1460 :     if (!PyArg_UnpackTuple(args, "field_size_limit", 0, 1, &new_limit))

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@BNOLCBNI@field_size_limit?$AA@
  00031	41 b9 01 00 00
	00		 mov	 r9d, 1
  00037	8b 78 10	 mov	 edi, DWORD PTR [rax+16]
  0003a	48 8d 44 24 50	 lea	 rax, QWORD PTR new_limit$[rsp]
  0003f	45 33 c0	 xor	 r8d, r8d
  00042	48 8b cb	 mov	 rcx, rbx
  00045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0004f	85 c0		 test	 eax, eax

; 1461 :         return NULL;

  00051	74 2e		 je	 SHORT $LN7@csv_field_

; 1462 :     if (new_limit != NULL) {

  00053	48 8b 4c 24 50	 mov	 rcx, QWORD PTR new_limit$[rsp]
  00058	48 85 c9	 test	 rcx, rcx
  0005b	0f 84 93 00 00
	00		 je	 $LN1@csv_field_

; 1463 :         if (!PyLong_CheckExact(new_limit)) {

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00068	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006c	74 20		 je	 SHORT $LN2@csv_field_

; 1464 :             PyErr_Format(PyExc_TypeError,
; 1465 :                          "limit must be an integer");

  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@EOJGCLAC@limit?5must?5be?5an?5integer?$AA@
  0007c	e8 00 00 00 00	 call	 PyErr_Format
$LN7@csv_field_:

; 1466 :             return NULL;

  00081	33 c0		 xor	 eax, eax

; 1475 : }

  00083	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00088	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
$LN2@csv_field_:

; 1467 :         }
; 1468 :         _csvstate_global->field_limit = PyLong_AsLong(new_limit);

  0008e	e8 00 00 00 00	 call	 PyLong_AsLong
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  0009a	8b d8		 mov	 ebx, eax
  0009c	e8 00 00 00 00	 call	 PyState_FindModule
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 PyModule_GetState

; 1469 :         if (_csvstate_global->field_limit == -1 && PyErr_Occurred()) {

  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  000b0	89 58 10	 mov	 DWORD PTR [rax+16], ebx
  000b3	e8 00 00 00 00	 call	 PyState_FindModule
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 PyModule_GetState
  000c0	83 78 10 ff	 cmp	 DWORD PTR [rax+16], -1
  000c4	75 2e		 jne	 SHORT $LN1@csv_field_
  000c6	e8 00 00 00 00	 call	 PyErr_Occurred
  000cb	48 85 c0	 test	 rax, rax
  000ce	74 24		 je	 SHORT $LN1@csv_field_

; 1470 :             _csvstate_global->field_limit = old_limit;

  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  000d7	e8 00 00 00 00	 call	 PyState_FindModule
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 PyModule_GetState
  000e4	89 78 10	 mov	 DWORD PTR [rax+16], edi

; 1471 :             return NULL;

  000e7	33 c0		 xor	 eax, eax

; 1475 : }

  000e9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ee	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
$LN1@csv_field_:

; 1472 :         }
; 1473 :     }
; 1474 :     return PyLong_FromLong(old_limit);

  000f4	8b cf		 mov	 ecx, edi
  000f6	e8 00 00 00 00	 call	 PyLong_FromLong

; 1475 : }

  000fb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00100	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
csv_field_size_limit ENDP
_TEXT	ENDS
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0L@DKEOCKEK@_csv?4Error?$AA@		; `string'
PUBLIC	??_C@_07LLHEGNLO@Dialect?$AA@			; `string'
PUBLIC	??_C@_09OHBNODGN@_dialects?$AA@			; `string'
PUBLIC	??_C@_0M@EKHGKOEI@__version__?$AA@		; `string'
PUBLIC	??_C@_03HLLJOCDO@1?40?$AA@			; `string'
PUBLIC	PyInit__csv
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_AddIntConstant:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyDict_New:PROC
EXTRN	PyModule_AddStringConstant:PROC
EXTRN	PyModule_Create2:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__csv DD imagerel $LN28
	DD	imagerel $LN28+71
	DD	imagerel $unwind$PyInit__csv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__csv DD imagerel $LN28+71
	DD	imagerel $LN28+128
	DD	imagerel $chain$0$PyInit__csv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyInit__csv DD imagerel $LN28+128
	DD	imagerel $LN28+447
	DD	imagerel $chain$3$PyInit__csv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyInit__csv DD imagerel $LN28+447
	DD	imagerel $LN28+507
	DD	imagerel $chain$5$PyInit__csv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyInit__csv DD 040021H
	DD	067400H
	DD	083400H
	DD	imagerel $LN28
	DD	imagerel $LN28+71
	DD	imagerel $unwind$PyInit__csv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyInit__csv DD 040821H
	DD	083408H
	DD	067400H
	DD	imagerel $LN28
	DD	imagerel $LN28+71
	DD	imagerel $unwind$PyInit__csv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__csv DD 020521H
	DD	067405H
	DD	imagerel $LN28
	DD	imagerel $LN28+71
	DD	imagerel $unwind$PyInit__csv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__csv DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DKEOCKEK@_csv?4Error?$AA@
CONST	SEGMENT
??_C@_0L@DKEOCKEK@_csv?4Error?$AA@ DB '_csv.Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLHEGNLO@Dialect?$AA@
CONST	SEGMENT
??_C@_07LLHEGNLO@Dialect?$AA@ DB 'Dialect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OHBNODGN@_dialects?$AA@
CONST	SEGMENT
??_C@_09OHBNODGN@_dialects?$AA@ DB '_dialects', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EKHGKOEI@__version__?$AA@
CONST	SEGMENT
??_C@_0M@EKHGKOEI@__version__?$AA@ DB '__version__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLLJOCDO@1?40?$AA@
CONST	SEGMENT
??_C@_03HLLJOCDO@1?40?$AA@ DB '1.0', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_csv.c
CONST	ENDS
;	COMDAT PyInit__csv
_TEXT	SEGMENT
PyInit__csv PROC					; COMDAT

; 1623 : {

$LN28:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1624 :     PyObject *module;
; 1625 :     StyleDesc *style;
; 1626 : 
; 1627 :     if (PyType_Ready(&Dialect_Type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Dialect_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	79 07		 jns	 SHORT $LN13@PyInit__cs
$LN27@PyInit__cs:

; 1628 :         return NULL;

  00014	33 c0		 xor	 eax, eax

; 1677 : }

  00016	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001a	c3		 ret	 0
$LN13@PyInit__cs:

; 1629 : 
; 1630 :     if (PyType_Ready(&Reader_Type) < 0)

  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Reader_Type
  00022	e8 00 00 00 00	 call	 PyType_Ready
  00027	85 c0		 test	 eax, eax

; 1631 :         return NULL;

  00029	78 e9		 js	 SHORT $LN27@PyInit__cs

; 1632 : 
; 1633 :     if (PyType_Ready(&Writer_Type) < 0)

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Writer_Type
  00032	e8 00 00 00 00	 call	 PyType_Ready
  00037	85 c0		 test	 eax, eax

; 1634 :         return NULL;

  00039	78 d9		 js	 SHORT $LN27@PyInit__cs

; 1635 : 
; 1636 :     /* Create the module and add the functions */
; 1637 :     module = PyModule_Create(&_csvmodule);

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_csvmodule
  00042	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00047	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0004c	e8 00 00 00 00	 call	 PyModule_Create2
  00051	48 8b f8	 mov	 rdi, rax

; 1638 :     if (module == NULL)

  00054	48 85 c0	 test	 rax, rax

; 1639 :         return NULL;

  00057	74 1b		 je	 SHORT $LN26@PyInit__cs

; 1640 : 
; 1641 :     /* Add version to the module. */
; 1642 :     if (PyModule_AddStringConstant(module, "__version__",
; 1643 :                                    MODULE_VERSION) == -1)

  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03HLLJOCDO@1?40?$AA@
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EKHGKOEI@__version__?$AA@
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 PyModule_AddStringConstant
  0006f	83 f8 ff	 cmp	 eax, -1
  00072	75 0c		 jne	 SHORT $LN9@PyInit__cs
$LN26@PyInit__cs:

; 1644 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1677 : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
$LN9@PyInit__cs:

; 1645 : 
; 1646 :     /* Set the field limit */
; 1647 :     _csvstate(module)->field_limit = 128 * 1024;

  00080	48 8b cf	 mov	 rcx, rdi
  00083	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00088	e8 00 00 00 00	 call	 PyModule_GetState
  0008d	c7 40 10 00 00
	02 00		 mov	 DWORD PTR [rax+16], 131072 ; 00020000H

; 1648 :     /* Do I still need to add this var to the Module Dict? */
; 1649 : 
; 1650 :     /* Add _dialects dictionary */
; 1651 :     _csvstate(module)->dialects = PyDict_New();

  00094	e8 00 00 00 00	 call	 PyDict_New
  00099	48 8b cf	 mov	 rcx, rdi
  0009c	48 8b d8	 mov	 rbx, rax
  0009f	e8 00 00 00 00	 call	 PyModule_GetState

; 1652 :     if (_csvstate(module)->dialects == NULL)

  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  000ab	e8 00 00 00 00	 call	 PyModule_GetState
  000b0	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0

; 1653 :         return NULL;

  000b5	0f 84 f3 00 00
	00		 je	 $LN25@PyInit__cs

; 1654 :     Py_INCREF(_csvstate(module)->dialects);

  000bb	48 8b cf	 mov	 rcx, rdi
  000be	e8 00 00 00 00	 call	 PyModule_GetState
  000c3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 1655 :     if (PyModule_AddObject(module, "_dialects", _csvstate(module)->dialects))

  000cc	48 8b cf	 mov	 rcx, rdi
  000cf	e8 00 00 00 00	 call	 PyModule_GetState
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OHBNODGN@_dialects?$AA@
  000db	48 8b cf	 mov	 rcx, rdi
  000de	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000e2	e8 00 00 00 00	 call	 PyModule_AddObject
  000e7	85 c0		 test	 eax, eax

; 1656 :         return NULL;

  000e9	0f 85 bf 00 00
	00		 jne	 $LN25@PyInit__cs

; 1657 : 
; 1658 :     /* Add quote styles into dictionary */
; 1659 :     for (style = quote_styles; style->name; style++) {

  000ef	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR quote_styles+8, 0
  000f7	74 29		 je	 SHORT $LN4@PyInit__cs
  000f9	48 8d 1d 08 00
	00 00		 lea	 rbx, OFFSET FLAT:quote_styles+8
$LL6@PyInit__cs:

; 1660 :         if (PyModule_AddIntConstant(module, style->name,
; 1661 :                                     style->style) == -1)

  00100	44 8b 43 f8	 mov	 r8d, DWORD PTR [rbx-8]
  00104	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00107	48 8b cf	 mov	 rcx, rdi
  0010a	e8 00 00 00 00	 call	 PyModule_AddIntConstant
  0010f	83 f8 ff	 cmp	 eax, -1
  00112	0f 84 96 00 00
	00		 je	 $LN25@PyInit__cs

; 1657 : 
; 1658 :     /* Add quote styles into dictionary */
; 1659 :     for (style = quote_styles; style->name; style++) {

  00118	48 83 c3 10	 add	 rbx, 16
  0011c	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00120	75 de		 jne	 SHORT $LL6@PyInit__cs
$LN4@PyInit__cs:

; 1662 :             return NULL;
; 1663 :     }
; 1664 : 
; 1665 :     /* Add the Dialect type */
; 1666 :     Py_INCREF(&Dialect_Type);

  00122	e8 00 00 00 00	 call	 _Py_PXCTX
  00127	85 c0		 test	 eax, eax
  00129	75 3c		 jne	 SHORT $LN17@PyInit__cs
  0012b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:Dialect_Type
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00140	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00146	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0014e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00153	85 c0		 test	 eax, eax
  00155	75 09		 jne	 SHORT $LN16@PyInit__cs
  00157	f6 05 20 00 00
	00 20		 test	 BYTE PTR Dialect_Type+32, 32 ; 00000020H
  0015e	74 07		 je	 SHORT $LN17@PyInit__cs
$LN16@PyInit__cs:
  00160	48 ff 05 50 00
	00 00		 inc	 QWORD PTR Dialect_Type+80
$LN17@PyInit__cs:

; 1667 :     if (PyModule_AddObject(module, "Dialect", (PyObject *)&Dialect_Type))

  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Dialect_Type
  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LLHEGNLO@Dialect?$AA@
  00175	48 8b cf	 mov	 rcx, rdi
  00178	e8 00 00 00 00	 call	 PyModule_AddObject
  0017d	85 c0		 test	 eax, eax

; 1668 :         return NULL;

  0017f	75 2d		 jne	 SHORT $LN25@PyInit__cs

; 1669 : 
; 1670 :     /* Add the CSV exception object to the module. */
; 1671 :     _csvstate(module)->error_obj = PyErr_NewException("_csv.Error", NULL, NULL);

  00181	48 8b cf	 mov	 rcx, rdi
  00184	e8 00 00 00 00	 call	 PyModule_GetState
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DKEOCKEK@_csv?4Error?$AA@
  00190	45 33 c0	 xor	 r8d, r8d
  00193	33 d2		 xor	 edx, edx
  00195	48 8b d8	 mov	 rbx, rax
  00198	e8 00 00 00 00	 call	 PyErr_NewException

; 1672 :     if (_csvstate(module)->error_obj == NULL)

  0019d	48 8b cf	 mov	 rcx, rdi
  001a0	48 89 03	 mov	 QWORD PTR [rbx], rax
  001a3	e8 00 00 00 00	 call	 PyModule_GetState
  001a8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001ac	75 11		 jne	 SHORT $LN1@PyInit__cs
$LN25@PyInit__cs:
  001ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001b3	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1673 :         return NULL;

  001b8	33 c0		 xor	 eax, eax

; 1677 : }

  001ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001be	c3		 ret	 0
$LN1@PyInit__cs:

; 1674 :     Py_INCREF(_csvstate(module)->error_obj);

  001bf	48 8b cf	 mov	 rcx, rdi
  001c2	e8 00 00 00 00	 call	 PyModule_GetState
  001c7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ca	e8 00 00 00 00	 call	 _Py_IncRef

; 1675 :     PyModule_AddObject(module, "Error", _csvstate(module)->error_obj);

  001cf	48 8b cf	 mov	 rcx, rdi
  001d2	e8 00 00 00 00	 call	 PyModule_GetState
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
  001de	48 8b cf	 mov	 rcx, rdi
  001e1	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  001e4	e8 00 00 00 00	 call	 PyModule_AddObject
  001e9	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1676 :     return module;

  001ee	48 8b c7	 mov	 rax, rdi
  001f1	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1677 : }

  001f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fa	c3		 ret	 0
PyInit__csv ENDP
_TEXT	ENDS
END
