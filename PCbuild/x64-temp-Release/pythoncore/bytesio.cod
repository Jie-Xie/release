; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@	; `string'
PUBLIC	??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@		; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_08ODLBJABI@getvalue?$AA@			; `string'
PUBLIC	??_C@_09NEMCKDC@getbuffer?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_09OBGGLHMH@readlines?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_08BPEKIGCI@readinto?$AA@			; `string'
PUBLIC	??_C@_05FDBMPOID@read1?$AA@			; `string'
PUBLIC	??_C@_0L@MKGKOOMC@writelines?$AA@		; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@ ; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	PyBytesIO_Type
PUBLIC	_PyBytesIOBuffer_Type
EXTRN	PyObject_SelfIter:PROC
;	COMDAT ??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@
CONST	SEGMENT
??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@ DB '_io._BytesIOBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@
CONST	SEGMENT
??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@ DB '_io.BytesIO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08ODLBJABI@getvalue?$AA@
CONST	SEGMENT
??_C@_08ODLBJABI@getvalue?$AA@ DB 'getvalue', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NEMCKDC@getbuffer?$AA@
CONST	SEGMENT
??_C@_09NEMCKDC@getbuffer?$AA@ DB 'getbuffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OBGGLHMH@readlines?$AA@
CONST	SEGMENT
??_C@_09OBGGLHMH@readlines?$AA@ DB 'readlines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEKIGCI@readinto?$AA@
CONST	SEGMENT
??_C@_08BPEKIGCI@readinto?$AA@ DB 'readinto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FDBMPOID@read1?$AA@
CONST	SEGMENT
??_C@_05FDBMPOID@read1?$AA@ DB 'read1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MKGKOOMC@writelines?$AA@
CONST	SEGMENT
??_C@_0L@MKGKOOMC@writelines?$AA@ DB 'writelines', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@
CONST	SEGMENT
??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@ DB 'True if the'
	DB	' file is closed.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
readable_doc DB	'readable() -> bool. Returns True if the IO object can be'
	DB	' read.', 00H
	ORG $+1
writable_doc DB	'writable() -> bool. Returns True if the IO object can be'
	DB	' written.', 00H
	ORG $+14
seekable_doc DB	'seekable() -> bool. Returns True if the IO object can be'
	DB	' seeked.', 00H
	ORG $+7
flush_doc DB	'flush() -> None.  Does nothing.', 00H
	ORG $+8
getbuffer_doc DB 'getbuffer() -> bytes.', 0aH, 0aH, 'Get a read-write vie'
	DB	'w over the contents of the BytesIO object.', 00H
	ORG $+10
getval_doc DB	'getvalue() -> bytes.', 0aH, 0aH, 'Retrieve the entire co'
	DB	'ntents of the BytesIO object.', 00H
	ORG $+6
isatty_doc DB	'isatty() -> False.', 0aH, 0aH, 'Always returns False sin'
	DB	'ce BytesIO objects are not connected', 0aH, 'to a tty-like de'
	DB	'vice.', 00H
	ORG $+1
tell_doc DB	'tell() -> current file position, an integer', 0aH, 00H
	ORG $+11
read_doc DB	'read([size]) -> read at most size bytes, returned as a s'
	DB	'tring.', 0aH, 0aH, 'If the size argument is negative, read un'
	DB	'til EOF is reached.', 0aH, 'Return an empty string at EOF.', 00H
	ORG $+4
read1_doc DB	'read1(size) -> read at most size bytes, returned as a st'
	DB	'ring.', 0aH, 0aH, 'If the size argument is negative or omitte'
	DB	'd, read until EOF is reached.', 0aH, 'Return an empty string '
	DB	'at EOF.', 00H
	ORG $+10
readline_doc DB	'readline([size]) -> next line from the file, as a string'
	DB	'.', 0aH, 0aH, 'Retain newline.  A non-negative size argument '
	DB	'limits the maximum', 0aH, 'number of bytes to return (an inco'
	DB	'mplete line may be returned then).', 0aH, 'Return an empty st'
	DB	'ring at EOF.', 0aH, 00H
	ORG $+15
readlines_doc DB 'readlines([size]) -> list of strings, each a line from '
	DB	'the file.', 0aH, 0aH, 'Call readline() repeatedly and return '
	DB	'a list of the lines so read.', 0aH, 'The optional size argume'
	DB	'nt, if given, is an approximate bound on the', 0aH, 'total nu'
	DB	'mber of bytes in the lines returned.', 0aH, 00H
	ORG $+8
readinto_doc DB	'readinto(bytearray) -> int.  Read up to len(b) bytes int'
	DB	'o b.', 0aH, 0aH, 'Returns number of bytes read (0 for EOF), o'
	DB	'r None if the object', 0aH, 'is set not to block as has no da'
	DB	'ta to read.', 00H
	ORG $+6
truncate_doc DB	'truncate([size]) -> int.  Truncate the file to at most s'
	DB	'ize bytes.', 0aH, 0aH, 'Size defaults to the current file pos'
	DB	'ition, as returned by tell().', 0aH, 'The current file positi'
	DB	'on is unchanged.  Returns the new size.', 0aH, 00H
	ORG $+9
seek_doc DB	'seek(pos, whence=0) -> int.  Change stream position.', 0aH
	DB	0aH, 'Seek to byte offset pos relative to position indicated b'
	DB	'y whence:', 0aH, '     0  Start of stream (the default).  pos'
	DB	' should be >= 0;', 0aH, '     1  Current position - pos may b'
	DB	'e negative;', 0aH, '     2  End of stream - pos usually negat'
	DB	'ive.', 0aH, 'Returns the new absolute position.', 00H
	ORG $+11
write_doc DB	'write(bytes) -> int.  Write bytes to file.', 0aH, 0aH, 'R'
	DB	'eturn the number of bytes written.', 00H
writelines_doc DB 'writelines(sequence_of_strings) -> None.  Write string'
	DB	's to the file.', 0aH, 0aH, 'Note that newlines are not added.'
	DB	'  The sequence can be any iterable', 0aH, 'object producing s'
	DB	'trings. This is equivalent to calling write() for', 0aH, 'eac'
	DB	'h string.', 00H
	ORG $+5
close_doc DB	'close() -> None.  Disable all I/O operations.', 00H
	ORG $+2
bytesio_getsetlist DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:bytesio_get_closed
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@LKDINMGD@True?5if?5the?5file?5is?5closed?4?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
bytesio_methods DQ FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:readable_doc
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:seekable_doc
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	FLAT:return_not_closed
	DD	04H
	ORG $+4
	DQ	FLAT:writable_doc
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:bytesio_close
	DD	04H
	ORG $+4
	DQ	FLAT:close_doc
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	FLAT:bytesio_flush
	DD	04H
	ORG $+4
	DQ	FLAT:flush_doc
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:bytesio_isatty
	DD	04H
	ORG $+4
	DQ	FLAT:isatty_doc
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:bytesio_tell
	DD	04H
	ORG $+4
	DQ	FLAT:tell_doc
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:bytesio_write
	DD	08H
	ORG $+4
	DQ	FLAT:write_doc
	DQ	FLAT:??_C@_0L@MKGKOOMC@writelines?$AA@
	DQ	FLAT:bytesio_writelines
	DD	08H
	ORG $+4
	DQ	FLAT:writelines_doc
	DQ	FLAT:??_C@_05FDBMPOID@read1?$AA@
	DQ	FLAT:bytesio_read1
	DD	08H
	ORG $+4
	DQ	FLAT:read1_doc
	DQ	FLAT:??_C@_08BPEKIGCI@readinto?$AA@
	DQ	FLAT:bytesio_readinto
	DD	08H
	ORG $+4
	DQ	FLAT:readinto_doc
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	FLAT:bytesio_readline
	DD	01H
	ORG $+4
	DQ	FLAT:readline_doc
	DQ	FLAT:??_C@_09OBGGLHMH@readlines?$AA@
	DQ	FLAT:bytesio_readlines
	DD	01H
	ORG $+4
	DQ	FLAT:readlines_doc
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:bytesio_read
	DD	01H
	ORG $+4
	DQ	FLAT:read_doc
	DQ	FLAT:??_C@_09NEMCKDC@getbuffer?$AA@
	DQ	FLAT:bytesio_getbuffer
	DD	04H
	ORG $+4
	DQ	FLAT:getbuffer_doc
	DQ	FLAT:??_C@_08ODLBJABI@getvalue?$AA@
	DQ	FLAT:bytesio_getvalue
	DD	04H
	ORG $+4
	DQ	FLAT:getval_doc
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:bytesio_seek
	DD	01H
	ORG $+4
	DQ	FLAT:seek_doc
	DQ	FLAT:??_C@_08MABILMFG@truncate?$AA@
	DQ	FLAT:bytesio_truncate
	DD	01H
	ORG $+4
	DQ	FLAT:truncate_doc
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	FLAT:bytesio_getstate
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:bytesio_setstate
	DD	08H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:bytesio_sizeof
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
bytesio_doc DB	'BytesIO([buffer]) -> object', 0aH, 0aH, 'Create a buffer'
	DB	'ed I/O implementation using an in-memory bytes', 0aH, 'buffer'
	DB	', ready for reading and writing.', 00H
	ORG $+14
PyBytesIO_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@CJIKFPOJ@_io?4BytesIO?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:bytesio_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:bytesio_doc
	DQ	FLAT:bytesio_traverse
	DQ	FLAT:bytesio_clear
	DQ	0000000000000000H
	DQ	0000000000000088H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:bytesio_iternext
	DQ	FLAT:bytesio_methods
	DQ	0000000000000000H
	DQ	FLAT:bytesio_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000080H
	DQ	FLAT:bytesio_init
	DQ	0000000000000000H
	DQ	FLAT:bytesio_new
	ORG $+72
bytesiobuf_as_buffer DQ FLAT:bytesiobuf_getbuffer
	DQ	FLAT:bytesiobuf_releasebuffer
_PyBytesIOBuffer_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@KIPLDHIL@_io?4_BytesIOBuffer?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_as_buffer
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:bytesiobuf_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+72
_DATA	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
_TEXT	ENDS
;	COMDAT get_line
_TEXT	SEGMENT
self$ = 8
output$ = 16
get_line PROC						; COMDAT

; 43   :     char *n;
; 44   :     const char *str_end;
; 45   :     Py_ssize_t len;
; 46   : 
; 47   :     assert(self->buf != NULL);
; 48   : 
; 49   :     /* Move to the end of the line, up to the end of the string, s. */
; 50   :     str_end = self->buf + self->string_size;

  00000	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  00004	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]

; 51   :     for (n = self->buf + self->pos;
; 52   :          n < str_end && *n != '\n';
; 53   :          n++);

  00008	4c 8b 51 68	 mov	 r10, QWORD PTR [rcx+104]
  0000c	4d 8d 04 01	 lea	 r8, QWORD PTR [r9+rax]
  00010	4f 8d 1c 0a	 lea	 r11, QWORD PTR [r10+r9]
  00014	49 8b c3	 mov	 rax, r11
  00017	4d 3b d8	 cmp	 r11, r8
  0001a	73 27		 jae	 SHORT $LN1@get_line
  0001c	0f 1f 40 00	 npad	 4
$LL4@get_line:
  00020	80 38 0a	 cmp	 BYTE PTR [rax], 10
  00023	74 16		 je	 SHORT $LN2@get_line
  00025	48 ff c0	 inc	 rax
  00028	49 3b c0	 cmp	 rax, r8
  0002b	72 f3		 jb	 SHORT $LL4@get_line

; 58   : 
; 59   :     /* Get the length from the current position to the end of the line. */
; 60   :     len = n - (self->buf + self->pos);

  0002d	49 2b c2	 sub	 rax, r10

; 61   :     *output = self->buf + self->pos;

  00030	4c 89 1a	 mov	 QWORD PTR [rdx], r11
  00033	49 2b c1	 sub	 rax, r9

; 62   : 
; 63   :     assert(len >= 0);
; 64   :     assert(self->pos < PY_SSIZE_T_MAX - len);
; 65   :     self->pos += len;

  00036	48 01 41 68	 add	 QWORD PTR [rcx+104], rax

; 66   : 
; 67   :     return len;
; 68   : }

  0003a	c3		 ret	 0
$LN2@get_line:

; 54   : 
; 55   :     /* Skip the newline character */
; 56   :     if (n < str_end)

  0003b	49 3b c0	 cmp	 rax, r8
  0003e	73 03		 jae	 SHORT $LN1@get_line

; 57   :         n++;

  00040	48 ff c0	 inc	 rax
$LN1@get_line:

; 58   : 
; 59   :     /* Get the length from the current position to the end of the line. */
; 60   :     len = n - (self->buf + self->pos);

  00043	49 2b c2	 sub	 rax, r10

; 61   :     *output = self->buf + self->pos;

  00046	4c 89 1a	 mov	 QWORD PTR [rdx], r11
  00049	49 2b c1	 sub	 rax, r9

; 62   : 
; 63   :     assert(len >= 0);
; 64   :     assert(self->pos < PY_SSIZE_T_MAX - len);
; 65   :     self->pos += len;

  0004c	48 01 41 68	 add	 QWORD PTR [rcx+104], rax

; 66   : 
; 67   :     return len;
; 68   : }

  00050	c3		 ret	 0
get_line ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@ ; `string'
PUBLIC	__real@3ff2000000000000
PUBLIC	__real@43f0000000000000
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$resize_buffer DD imagerel resize_buffer
	DD	imagerel resize_buffer+246
	DD	imagerel $unwind$resize_buffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$resize_buffer DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@ DB 'new buffer size'
	DB	' too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@3ff2000000000000
CONST	SEGMENT
__real@3ff2000000000000 DQ 03ff2000000000000r	; 1.125
CONST	ENDS
;	COMDAT __real@43f0000000000000
CONST	SEGMENT
__real@43f0000000000000 DQ 043f0000000000000r	; 1.84467e+019
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT resize_buffer
_TEXT	SEGMENT
self$ = 48
size$ = 56
resize_buffer PROC					; COMDAT

; 75   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 76   :     /* Here, unsigned types are used to avoid dealing with signed integer
; 77   :        overflow, which is undefined in C. */
; 78   :     size_t alloc = self->buf_size;

  0000a	4c 8b 41 78	 mov	 r8, QWORD PTR [rcx+120]

; 79   :     char *new_buf = NULL;
; 80   : 
; 81   :     assert(self->buf != NULL);
; 82   : 
; 83   :     /* For simplicity, stay in the range of the signed type. Anyway, Python
; 84   :        doesn't allow strings to be longer than this. */
; 85   :     if (size > PY_SSIZE_T_MAX)

  0000e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	48 3b d0	 cmp	 rdx, rax
  0001e	0f 87 b1 00 00
	00		 ja	 $overflow$20378

; 86   :         goto overflow;
; 87   : 
; 88   :     if (size < alloc / 2) {

  00024	49 8b c0	 mov	 rax, r8
  00027	48 d1 e8	 shr	 rax, 1
  0002a	48 3b d0	 cmp	 rdx, rax

; 89   :         /* Major downsize; resize down to exact size. */
; 90   :         alloc = size + 1;

  0002d	72 63		 jb	 SHORT $LN4@resize_buf

; 91   :     }
; 92   :     else if (size < alloc) {

  0002f	49 3b d0	 cmp	 rdx, r8

; 93   :         /* Within allocated size; quick exit */
; 94   :         return 0;

  00032	0f 82 90 00 00
	00		 jb	 $LN15@resize_buf

; 95   :     }
; 96   :     else if (size <= alloc * 1.125) {

  00038	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@43f0000000000000
  00040	66 0f ef c9	 pxor	 xmm1, xmm1
  00044	f2 48 0f 2a ca	 cvtsi2sd xmm1, rdx
  00049	48 85 d2	 test	 rdx, rdx
  0004c	79 04		 jns	 SHORT $LN13@resize_buf
  0004e	f2 0f 58 ca	 addsd	 xmm1, xmm2
$LN13@resize_buf:
  00052	66 0f ef c0	 pxor	 xmm0, xmm0
  00056	f2 49 0f 2a c0	 cvtsi2sd xmm0, r8
  0005b	4d 85 c0	 test	 r8, r8
  0005e	79 04		 jns	 SHORT $LN12@resize_buf
  00060	f2 0f 58 c2	 addsd	 xmm0, xmm2
$LN12@resize_buf:
  00064	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3ff2000000000000
  0006c	66 0f 2f c1	 comisd	 xmm0, xmm1
  00070	72 20		 jb	 SHORT $LN4@resize_buf

; 97   :         /* Moderate upsize; overallocate similar to list_resize() */
; 98   :         alloc = size + (size >> 3) + (size < 9 ? 3 : 6);

  00072	48 83 fa 09	 cmp	 rdx, 9
  00076	b8 06 00 00 00	 mov	 eax, 6
  0007b	b9 03 00 00 00	 mov	 ecx, 3
  00080	0f 42 c1	 cmovb	 eax, ecx
  00083	48 8b da	 mov	 rbx, rdx
  00086	48 03 c2	 add	 rax, rdx
  00089	48 c1 eb 03	 shr	 rbx, 3
  0008d	48 03 d8	 add	 rbx, rax

; 99   :     }
; 100  :     else {

  00090	eb 04		 jmp	 SHORT $LN3@resize_buf
$LN4@resize_buf:

; 101  :         /* Major upsize; resize up to exact size */
; 102  :         alloc = size + 1;

  00092	48 8d 5a 01	 lea	 rbx, QWORD PTR [rdx+1]
$LN3@resize_buf:

; 103  :     }
; 104  : 
; 105  :     if (alloc > ((size_t)-1) / sizeof(char))

  00096	48 83 fb ff	 cmp	 rbx, -1
  0009a	77 39		 ja	 SHORT $overflow$20378

; 106  :         goto overflow;
; 107  :     new_buf = (char *)PyMem_Realloc(self->buf, alloc * sizeof(char));

  0009c	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  000a0	48 8b d3	 mov	 rdx, rbx
  000a3	e8 00 00 00 00	 call	 PyMem_Realloc

; 108  :     if (new_buf == NULL) {

  000a8	48 85 c0	 test	 rax, rax
  000ab	75 13		 jne	 SHORT $LN1@resize_buf

; 109  :         PyErr_NoMemory();

  000ad	e8 00 00 00 00	 call	 PyErr_NoMemory

; 120  :     return -1;

  000b2	83 c8 ff	 or	 eax, -1

; 121  : }

  000b5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
$LN1@resize_buf:

; 110  :         return -1;
; 111  :     }
; 112  :     self->buf_size = alloc;

  000c0	48 89 5f 78	 mov	 QWORD PTR [rdi+120], rbx

; 113  :     self->buf = new_buf;

  000c4	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax
$LN15@resize_buf:

; 114  : 
; 115  :     return 0;

  000c8	33 c0		 xor	 eax, eax

; 121  : }

  000ca	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
$overflow$20378:

; 116  : 
; 117  :   overflow:
; 118  :     PyErr_SetString(PyExc_OverflowError,
; 119  :                     "new buffer size too large");

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PGPOMJCD@new?5buffer?5size?5too?5large?$AA@
  000e3	e8 00 00 00 00	 call	 PyErr_SetString

; 121  : }

  000e8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ed	83 c8 ff	 or	 eax, -1
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
resize_buffer ENDP
_TEXT	ENDS
EXTRN	memset:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_bytes DD imagerel write_bytes
	DD	imagerel write_bytes+150
	DD	imagerel $unwind$write_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_bytes DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT write_bytes
_TEXT	SEGMENT
self$ = 48
bytes$ = 56
len$ = 64
write_bytes PROC					; COMDAT

; 127  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 128  :     assert(self->buf != NULL);
; 129  :     assert(self->pos >= 0);
; 130  :     assert(len >= 0);
; 131  : 
; 132  :     if ((size_t)self->pos + len > self->buf_size) {

  0000f	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
  00013	48 8b f2	 mov	 rsi, rdx
  00016	49 8b f8	 mov	 rdi, r8
  00019	49 8d 14 00	 lea	 rdx, QWORD PTR [r8+rax]
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	48 3b 51 78	 cmp	 rdx, QWORD PTR [rcx+120]
  00024	76 1d		 jbe	 SHORT $LN3@write_byte

; 133  :         if (resize_buffer(self, (size_t)self->pos + len) < 0)

  00026	e8 00 00 00 00	 call	 resize_buffer
  0002b	85 c0		 test	 eax, eax
  0002d	79 14		 jns	 SHORT $LN3@write_byte

; 134  :             return -1;

  0002f	48 83 c8 ff	 or	 rax, -1

; 158  :     }
; 159  : 
; 160  :     return len;
; 161  : }

  00033	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN3@write_byte:

; 135  :     }
; 136  : 
; 137  :     if (self->pos > self->string_size) {

  00043	4c 8b 43 68	 mov	 r8, QWORD PTR [rbx+104]
  00047	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0004b	4c 3b c1	 cmp	 r8, rcx
  0004e	7e 0e		 jle	 SHORT $LN2@write_byte

; 138  :         /* In case of overseek, pad with null bytes the buffer region between
; 139  :            the end of stream and the current position.
; 140  : 
; 141  :           0   lo      string_size                           hi
; 142  :           |   |<---used--->|<----------available----------->|
; 143  :           |   |            <--to pad-->|<---to write--->    |
; 144  :           0   buf                   position
; 145  :         */
; 146  :         memset(self->buf + self->string_size, '\0',
; 147  :                (self->pos - self->string_size) * sizeof(char));

  00050	4c 2b c1	 sub	 r8, rcx
  00053	48 03 4b 60	 add	 rcx, QWORD PTR [rbx+96]
  00057	33 d2		 xor	 edx, edx
  00059	e8 00 00 00 00	 call	 memset
$LN2@write_byte:

; 148  :     }
; 149  : 
; 150  :     /* Copy the data to the internal buffer, overwriting some of the existing
; 151  :        data if self->pos < self->string_size. */
; 152  :     memcpy(self->buf + self->pos, bytes, len);

  0005e	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00062	4c 8b c7	 mov	 r8, rdi
  00065	48 8b d6	 mov	 rdx, rsi
  00068	48 03 4b 68	 add	 rcx, QWORD PTR [rbx+104]
  0006c	e8 00 00 00 00	 call	 memcpy

; 153  :     self->pos += len;

  00071	48 01 7b 68	 add	 QWORD PTR [rbx+104], rdi
  00075	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]

; 154  : 
; 155  :     /* Set the new length of the internal string if it has changed. */
; 156  :     if (self->string_size < self->pos) {

  00079	48 39 43 70	 cmp	 QWORD PTR [rbx+112], rax
  0007d	7d 04		 jge	 SHORT $LN1@write_byte

; 157  :         self->string_size = self->pos;

  0007f	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN1@write_byte:

; 158  :     }
; 159  : 
; 160  :     return len;
; 161  : }

  00083	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00088	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008d	48 8b c7	 mov	 rax, rdi
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
write_bytes ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_get_closed DD imagerel bytesio_get_closed
	DD	imagerel bytesio_get_closed+173
	DD	imagerel $unwind$bytesio_get_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_get_closed DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_get_closed
_TEXT	SEGMENT
self$ = 64
bytesio_get_closed PROC					; COMDAT

; 165  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 166  :     if (self->buf == NULL) {

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 51		 jne	 SHORT $LN2@bytesio_ge

; 167  :         Py_RETURN_TRUE;

  0000b	e8 00 00 00 00	 call	 _Py_PXCTX
  00010	85 c0		 test	 eax, eax
  00012	75 3c		 jne	 SHORT $LN6@bytesio_ge
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00029	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0002f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00037	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003c	85 c0		 test	 eax, eax
  0003e	75 09		 jne	 SHORT $LN5@bytesio_ge
  00040	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00047	74 07		 je	 SHORT $LN6@bytesio_ge
$LN5@bytesio_ge:
  00049	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN6@bytesio_ge:
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 171  :     }
; 172  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
$LN2@bytesio_ge:

; 168  :     }
; 169  :     else {
; 170  :         Py_RETURN_FALSE;

  0005c	e8 00 00 00 00	 call	 _Py_PXCTX
  00061	85 c0		 test	 eax, eax
  00063	75 3c		 jne	 SHORT $LN10@bytesio_ge
  00065	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0007a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00080	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00088	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008d	85 c0		 test	 eax, eax
  0008f	75 09		 jne	 SHORT $LN9@bytesio_ge
  00091	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00098	74 07		 je	 SHORT $LN10@bytesio_ge
$LN9@bytesio_ge:
  0009a	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN10@bytesio_ge:
  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 171  :     }
; 172  : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
bytesio_get_closed ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$return_not_closed DD imagerel return_not_closed
	DD	imagerel return_not_closed+118
	DD	imagerel $unwind$return_not_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$return_not_closed DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
CONST	SEGMENT
??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@ DB 'I/O opera'
	DB	'tion on closed file.', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
CONST	ENDS
;	COMDAT return_not_closed
_TEXT	SEGMENT
self$ = 64
return_not_closed PROC					; COMDAT

; 186  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 187  :     CHECK_CLOSED(self);

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 1a		 jne	 SHORT $LN1@return_not
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00019	e8 00 00 00 00	 call	 PyErr_SetString
  0001e	33 c0		 xor	 eax, eax

; 189  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
$LN1@return_not:

; 188  :     Py_RETURN_TRUE;

  00025	e8 00 00 00 00	 call	 _Py_PXCTX
  0002a	85 c0		 test	 eax, eax
  0002c	75 3c		 jne	 SHORT $LN5@return_not
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 09		 jne	 SHORT $LN4@return_not
  0005a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00061	74 07		 je	 SHORT $LN5@return_not
$LN4@return_not:
  00063	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN5@return_not:
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 189  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
return_not_closed ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_flush DD imagerel bytesio_flush
	DD	imagerel bytesio_flush+118
	DD	imagerel $unwind$bytesio_flush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_flush DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_flush
_TEXT	SEGMENT
self$ = 64
bytesio_flush PROC					; COMDAT

; 196  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 197  :     CHECK_CLOSED(self);

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 1a		 jne	 SHORT $LN1@bytesio_fl
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00019	e8 00 00 00 00	 call	 PyErr_SetString
  0001e	33 c0		 xor	 eax, eax

; 199  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
$LN1@bytesio_fl:

; 198  :     Py_RETURN_NONE;

  00025	e8 00 00 00 00	 call	 _Py_PXCTX
  0002a	85 c0		 test	 eax, eax
  0002c	75 3c		 jne	 SHORT $LN5@bytesio_fl
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 09		 jne	 SHORT $LN4@bytesio_fl
  0005a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00061	74 07		 je	 SHORT $LN5@bytesio_fl
$LN4@bytesio_fl:
  00063	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@bytesio_fl:
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 199  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
bytesio_flush ENDP
_TEXT	ENDS
EXTRN	PyMemoryView_FromObject:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_getbuffer DD imagerel bytesio_getbuffer
	DD	imagerel bytesio_getbuffer+52
	DD	imagerel $unwind$bytesio_getbuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_getbuffer DD imagerel bytesio_getbuffer+52
	DD	imagerel bytesio_getbuffer+82
	DD	imagerel $chain$0$bytesio_getbuffer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytesio_getbuffer DD imagerel bytesio_getbuffer+82
	DD	imagerel bytesio_getbuffer+178
	DD	imagerel $chain$2$bytesio_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytesio_getbuffer DD 020021H
	DD	087400H
	DD	imagerel bytesio_getbuffer
	DD	imagerel bytesio_getbuffer+52
	DD	imagerel $unwind$bytesio_getbuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_getbuffer DD 020521H
	DD	087405H
	DD	imagerel bytesio_getbuffer
	DD	imagerel bytesio_getbuffer+52
	DD	imagerel $unwind$bytesio_getbuffer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getbuffer DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_getbuffer
_TEXT	SEGMENT
self$ = 64
bytesio_getbuffer PROC					; COMDAT

; 208  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 209  :     PyTypeObject *type = &_PyBytesIOBuffer_Type;
; 210  :     bytesiobuf *buf;
; 211  :     PyObject *view;
; 212  : 
; 213  :     CHECK_CLOSED(self);

  00006	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	75 1b		 jne	 SHORT $LN2@bytesio_ge@2
  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString
  00023	33 c0		 xor	 eax, eax

; 223  : }

  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN2@bytesio_ge@2:

; 214  : 
; 215  :     buf = (bytesiobuf *) type->tp_alloc(type, 0);

  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyBytesIOBuffer_Type
  00032	33 d2		 xor	 edx, edx
  00034	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00039	ff 15 88 01 00
	00		 call	 QWORD PTR _PyBytesIOBuffer_Type+392
  0003f	48 8b f8	 mov	 rdi, rax

; 216  :     if (buf == NULL)

  00042	48 85 c0	 test	 rax, rax
  00045	75 0b		 jne	 SHORT $LN1@bytesio_ge@2
  00047	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 223  : }

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN1@bytesio_ge@2:

; 217  :         return NULL;
; 218  :     Py_INCREF(self);

  00052	e8 00 00 00 00	 call	 _Py_PXCTX
  00057	85 c0		 test	 eax, eax
  00059	75 32		 jne	 SHORT $LN6@bytesio_ge@2
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00069	4c 8b cb	 mov	 r9, rbx
  0006c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007f	85 c0		 test	 eax, eax
  00081	75 06		 jne	 SHORT $LN5@bytesio_ge@2
  00083	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00087	74 04		 je	 SHORT $LN6@bytesio_ge@2
$LN5@bytesio_ge@2:
  00089	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN6@bytesio_ge@2:

; 219  :     buf->source = self;
; 220  :     view = PyMemoryView_FromObject((PyObject *) buf);

  0008d	48 8b cf	 mov	 rcx, rdi
  00090	48 89 5f 60	 mov	 QWORD PTR [rdi+96], rbx
  00094	e8 00 00 00 00	 call	 PyMemoryView_FromObject

; 221  :     Py_DECREF(buf);

  00099	48 8b cf	 mov	 rcx, rdi
  0009c	48 8b d8	 mov	 rbx, rax
  0009f	e8 00 00 00 00	 call	 _Py_DecRef
  000a4	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 222  :     return view;

  000a9	48 8b c3	 mov	 rax, rbx

; 223  : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5b		 pop	 rbx
  000b1	c3		 ret	 0
bytesio_getbuffer ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_getvalue DD imagerel bytesio_getvalue
	DD	imagerel bytesio_getvalue+55
	DD	imagerel $unwind$bytesio_getvalue
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getvalue DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_getvalue
_TEXT	SEGMENT
self$ = 48
bytesio_getvalue PROC					; COMDAT

; 232  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 233  :     CHECK_CLOSED(self);

  00004	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00008	48 85 c0	 test	 rax, rax
  0000b	75 1a		 jne	 SHORT $LN1@bytesio_ge@3
  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001b	e8 00 00 00 00	 call	 PyErr_SetString
  00020	33 c0		 xor	 eax, eax

; 235  : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN1@bytesio_ge@3:

; 234  :     return PyBytes_FromStringAndSize(self->buf, self->string_size);

  00027	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  0002b	48 8b c8	 mov	 rcx, rax

; 235  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
bytesio_getvalue ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_isatty DD imagerel bytesio_isatty
	DD	imagerel bytesio_isatty+118
	DD	imagerel $unwind$bytesio_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_isatty DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_isatty
_TEXT	SEGMENT
self$ = 64
bytesio_isatty PROC					; COMDAT

; 245  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 246  :     CHECK_CLOSED(self);

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 1a		 jne	 SHORT $LN1@bytesio_is
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00019	e8 00 00 00 00	 call	 PyErr_SetString
  0001e	33 c0		 xor	 eax, eax

; 248  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
$LN1@bytesio_is:

; 247  :     Py_RETURN_FALSE;

  00025	e8 00 00 00 00	 call	 _Py_PXCTX
  0002a	85 c0		 test	 eax, eax
  0002c	75 3c		 jne	 SHORT $LN5@bytesio_is
  0002e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00043	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00049	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	75 09		 jne	 SHORT $LN4@bytesio_is
  0005a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  00061	74 07		 je	 SHORT $LN5@bytesio_is
$LN4@bytesio_is:
  00063	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN5@bytesio_is:
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 248  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
bytesio_isatty ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_tell DD imagerel bytesio_tell
	DD	imagerel bytesio_tell+50
	DD	imagerel $unwind$bytesio_tell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_tell DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_tell
_TEXT	SEGMENT
self$ = 48
bytesio_tell PROC					; COMDAT

; 255  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 256  :     CHECK_CLOSED(self);

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 1a		 jne	 SHORT $LN1@bytesio_te
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00019	e8 00 00 00 00	 call	 PyErr_SetString
  0001e	33 c0		 xor	 eax, eax

; 258  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
$LN1@bytesio_te:

; 257  :     return PyLong_FromSsize_t(self->pos);

  00025	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]

; 258  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytesio_tell ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@ ; `string'
PUBLIC	??_C@_07LBOODODI@?$HMO?3read?$AA@		; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_read DD imagerel bytesio_read
	DD	imagerel bytesio_read+270
	DD	imagerel $unwind$bytesio_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_read DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
CONST	SEGMENT
??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@ DB 'integer ar'
	DB	'gument expected, got ''%s''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBOODODI@?$HMO?3read?$AA@
CONST	SEGMENT
??_C@_07LBOODODI@?$HMO?3read?$AA@ DB '|O:read', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_read
_TEXT	SEGMENT
arg$ = 48
self$ = 48
args$ = 56
bytesio_read PROC					; COMDAT

; 268  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 269  :     Py_ssize_t size, n;
; 270  :     char *output;
; 271  :     PyObject *arg = Py_None;
; 272  : 
; 273  :     CHECK_CLOSED(self);

  0000a	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8b c2	 mov	 rax, rdx
  00019	48 89 5c 24 30	 mov	 QWORD PTR arg$[rsp], rbx
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	75 20		 jne	 SHORT $LN10@bytesio_re
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00031	e8 00 00 00 00	 call	 PyErr_SetString

; 290  :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 306  : }

  00038	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN10@bytesio_re:

; 274  : 
; 275  :     if (!PyArg_ParseTuple(args, "|O:read", &arg))

  00043	4c 8d 44 24 30	 lea	 r8, QWORD PTR arg$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LBOODODI@?$HMO?3read?$AA@
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00057	85 c0		 test	 eax, eax

; 276  :         return NULL;

  00059	0f 84 a2 00 00
	00		 je	 $LN13@bytesio_re

; 277  : 
; 278  :     if (PyLong_Check(arg)) {

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR arg$[rsp]
  00064	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00068	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  00073	74 28		 je	 SHORT $LN8@bytesio_re

; 279  :         size = PyLong_AsSsize_t(arg);

  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0007d	48 8b d8	 mov	 rbx, rax

; 280  :         if (size == -1 && PyErr_Occurred())

  00080	48 83 f8 ff	 cmp	 rax, -1
  00084	75 20		 jne	 SHORT $LN4@bytesio_re
  00086	e8 00 00 00 00	 call	 PyErr_Occurred
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 16		 je	 SHORT $LN4@bytesio_re

; 290  :         return NULL;

  00090	33 c0		 xor	 eax, eax

; 306  : }

  00092	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN8@bytesio_re:

; 281  :             return NULL;
; 282  :     }
; 283  :     else if (arg == Py_None) {

  0009d	48 3b c3	 cmp	 rax, rbx
  000a0	75 48		 jne	 SHORT $LN5@bytesio_re

; 284  :         /* Read until EOF is reached, by default. */
; 285  :         size = -1;

  000a2	48 83 cb ff	 or	 rbx, -1
$LN4@bytesio_re:

; 291  :     }
; 292  : 
; 293  :     /* adjust invalid sizes */
; 294  :     n = self->string_size - self->pos;

  000a6	48 8b 57 68	 mov	 rdx, QWORD PTR [rdi+104]
  000aa	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  000ae	48 2b c2	 sub	 rax, rdx

; 295  :     if (size < 0 || size > n) {

  000b1	48 85 db	 test	 rbx, rbx
  000b4	78 05		 js	 SHORT $LN2@bytesio_re
  000b6	48 3b d8	 cmp	 rbx, rax
  000b9	7e 0c		 jle	 SHORT $LN1@bytesio_re
$LN2@bytesio_re:

; 296  :         size = n;
; 297  :         if (size < 0)

  000bb	33 c9		 xor	 ecx, ecx
  000bd	48 8b d8	 mov	 rbx, rax
  000c0	48 85 c0	 test	 rax, rax
  000c3	48 0f 48 d9	 cmovs	 rbx, rcx
$LN1@bytesio_re:

; 298  :             size = 0;
; 299  :     }
; 300  : 
; 301  :     assert(self->buf != NULL);
; 302  :     output = self->buf + self->pos;

  000c7	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  000cb	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 303  :     self->pos += size;

  000cf	48 8d 04 1a	 lea	 rax, QWORD PTR [rdx+rbx]

; 304  : 
; 305  :     return PyBytes_FromStringAndSize(output, size);

  000d3	48 8b d3	 mov	 rdx, rbx
  000d6	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  000da	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 306  : }

  000df	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
$LN5@bytesio_re:

; 286  :     }
; 287  :     else {
; 288  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 289  :                      Py_TYPE(arg)->tp_name);

  000ea	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000fc	e8 00 00 00 00	 call	 PyErr_Format
$LN13@bytesio_re:

; 290  :         return NULL;

  00101	33 c0		 xor	 eax, eax

; 306  : }

  00103	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00108	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010c	5f		 pop	 rdi
  0010d	c3		 ret	 0
bytesio_read ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_read1 DD imagerel bytesio_read1
	DD	imagerel bytesio_read1+78
	DD	imagerel $unwind$bytesio_read1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_read1 DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_read1
_TEXT	SEGMENT
self$ = 48
n$ = 56
bytesio_read1 PROC					; COMDAT

; 317  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 318  :     PyObject *arg, *res;
; 319  : 
; 320  :     arg = PyTuple_Pack(1, n);

  0000d	b9 01 00 00 00	 mov	 ecx, 1
  00012	e8 00 00 00 00	 call	 PyTuple_Pack
  00017	48 8b f8	 mov	 rdi, rax

; 321  :     if (arg == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 0b		 jne	 SHORT $LN1@bytesio_re@2

; 326  : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
$LN1@bytesio_re@2:

; 322  :         return NULL;
; 323  :     res  = bytesio_read(self, arg);

  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8b cb	 mov	 rcx, rbx
  00030	e8 00 00 00 00	 call	 bytesio_read

; 324  :     Py_DECREF(arg);

  00035	48 8b cf	 mov	 rcx, rdi
  00038	48 8b d8	 mov	 rbx, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 325  :     return res;

  00040	48 8b c3	 mov	 rax, rbx

; 326  : }

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
bytesio_read1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readline DD imagerel bytesio_readline
	DD	imagerel bytesio_readline+262
	DD	imagerel $unwind$bytesio_readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readline DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@
CONST	SEGMENT
??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@ DB '|O:readline', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_readline
_TEXT	SEGMENT
arg$ = 48
self$ = 48
args$ = 56
output$ = 64
bytesio_readline PROC					; COMDAT

; 337  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 338  :     Py_ssize_t size, n;
; 339  :     char *output;
; 340  :     PyObject *arg = Py_None;
; 341  : 
; 342  :     CHECK_CLOSED(self);

  0000a	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8b c2	 mov	 rax, rdx
  00019	48 89 5c 24 30	 mov	 QWORD PTR arg$[rsp], rbx
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	75 20		 jne	 SHORT $LN8@bytesio_re@3
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00031	e8 00 00 00 00	 call	 PyErr_SetString

; 359  :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 371  : }

  00038	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN8@bytesio_re@3:

; 343  : 
; 344  :     if (!PyArg_ParseTuple(args, "|O:readline", &arg))

  00043	4c 8d 44 24 30	 lea	 r8, QWORD PTR arg$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CHNOBOKB@?$HMO?3readline?$AA@
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00057	85 c0		 test	 eax, eax

; 345  :         return NULL;

  00059	0f 84 9a 00 00
	00		 je	 $LN11@bytesio_re@3

; 346  : 
; 347  :     if (PyLong_Check(arg)) {

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR arg$[rsp]
  00064	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00068	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  00073	74 28		 je	 SHORT $LN6@bytesio_re@3

; 348  :         size = PyLong_AsSsize_t(arg);

  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0007d	48 8b d8	 mov	 rbx, rax

; 349  :         if (size == -1 && PyErr_Occurred())

  00080	48 83 f8 ff	 cmp	 rax, -1
  00084	75 20		 jne	 SHORT $LN2@bytesio_re@3
  00086	e8 00 00 00 00	 call	 PyErr_Occurred
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 16		 je	 SHORT $LN2@bytesio_re@3

; 359  :         return NULL;

  00090	33 c0		 xor	 eax, eax

; 371  : }

  00092	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN6@bytesio_re@3:

; 350  :             return NULL;
; 351  :     }
; 352  :     else if (arg == Py_None) {

  0009d	48 3b c3	 cmp	 rax, rbx
  000a0	75 40		 jne	 SHORT $LN3@bytesio_re@3

; 353  :         /* No size limit, by default. */
; 354  :         size = -1;

  000a2	48 83 cb ff	 or	 rbx, -1
$LN2@bytesio_re@3:

; 360  :     }
; 361  : 
; 362  :     n = get_line(self, &output);

  000a6	48 8d 54 24 40	 lea	 rdx, QWORD PTR output$[rsp]
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	e8 00 00 00 00	 call	 get_line

; 363  : 
; 364  :     if (size >= 0 && size < n) {

  000b3	48 85 db	 test	 rbx, rbx
  000b6	78 12		 js	 SHORT $LN1@bytesio_re@3
  000b8	48 3b d8	 cmp	 rbx, rax
  000bb	7d 0d		 jge	 SHORT $LN1@bytesio_re@3

; 365  :         size = n - size;

  000bd	48 8b c8	 mov	 rcx, rax
  000c0	48 2b cb	 sub	 rcx, rbx

; 366  :         n -= size;

  000c3	48 2b c1	 sub	 rax, rcx

; 367  :         self->pos -= size;

  000c6	48 29 4f 68	 sub	 QWORD PTR [rdi+104], rcx
$LN1@bytesio_re@3:

; 368  :     }
; 369  : 
; 370  :     return PyBytes_FromStringAndSize(output, n);

  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000cf	48 8b d0	 mov	 rdx, rax
  000d2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 371  : }

  000d7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
$LN3@bytesio_re@3:

; 355  :     }
; 356  :     else {
; 357  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 358  :                      Py_TYPE(arg)->tp_name);

  000e2	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  000f4	e8 00 00 00 00	 call	 PyErr_Format
$LN11@bytesio_re@3:

; 359  :         return NULL;

  000f9	33 c0		 xor	 eax, eax

; 371  : }

  000fb	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00100	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
bytesio_readline ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@		; `string'
EXTRN	PyList_Append:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readlines DD imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_readlines DD imagerel bytesio_readlines+91
	DD	imagerel bytesio_readlines+155
	DD	imagerel $chain$0$bytesio_readlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bytesio_readlines DD imagerel bytesio_readlines+155
	DD	imagerel bytesio_readlines+208
	DD	imagerel $chain$3$bytesio_readlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$bytesio_readlines DD imagerel bytesio_readlines+208
	DD	imagerel bytesio_readlines+350
	DD	imagerel $chain$7$bytesio_readlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$bytesio_readlines DD imagerel bytesio_readlines+350
	DD	imagerel bytesio_readlines+367
	DD	imagerel $chain$9$bytesio_readlines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$bytesio_readlines DD imagerel bytesio_readlines+367
	DD	imagerel bytesio_readlines+405
	DD	imagerel $chain$10$bytesio_readlines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$bytesio_readlines DD 020021H
	DD	057400H
	DD	imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$bytesio_readlines DD 080021H
	DD	04c400H
	DD	057400H
	DD	066400H
	DD	0b5400H
	DD	imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$bytesio_readlines DD 081221H
	DD	066412H
	DD	0b540dH
	DD	04c400H
	DD	057400H
	DD	imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bytesio_readlines DD 041421H
	DD	04c414H
	DD	057400H
	DD	imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_readlines DD 020521H
	DD	057405H
	DD	imagerel bytesio_readlines
	DD	imagerel bytesio_readlines+91
	DD	imagerel $unwind$bytesio_readlines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readlines DD 030801H
	DD	0d0046208H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@
CONST	SEGMENT
??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@ DB '|O:readlines', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_readlines
_TEXT	SEGMENT
arg$ = 80
self$ = 80
args$ = 88
output$ = 96
bytesio_readlines PROC					; COMDAT

; 382  : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 383  :     Py_ssize_t maxsize, size, n;
; 384  :     PyObject *result, *line;
; 385  :     char *output;
; 386  :     PyObject *arg = Py_None;
; 387  : 
; 388  :     CHECK_CLOSED(self);

  00008	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000d	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00014	48 8b c2	 mov	 rax, rdx
  00017	48 89 5c 24 50	 mov	 QWORD PTR arg$[rsp], rbx
  0001c	4c 8b e9	 mov	 r13, rcx
  0001f	75 1d		 jne	 SHORT $LN13@bytesio_re@4
  00021	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002f	e8 00 00 00 00	 call	 PyErr_SetString
$LN24@bytesio_re@4:
  00034	33 c0		 xor	 eax, eax

; 431  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	41 5d		 pop	 r13
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN13@bytesio_re@4:

; 389  : 
; 390  :     if (!PyArg_ParseTuple(args, "|O:readlines", &arg))

  0003e	4c 8d 44 24 50	 lea	 r8, QWORD PTR arg$[rsp]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KFOEGHFF@?$HMO?3readlines?$AA@
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00052	85 c0		 test	 eax, eax

; 391  :         return NULL;

  00054	74 de		 je	 SHORT $LN24@bytesio_re@4

; 392  : 
; 393  :     if (PyLong_Check(arg)) {

  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0005b	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00060	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00064	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  0006f	74 2a		 je	 SHORT $LN11@bytesio_re@4

; 394  :         maxsize = PyLong_AsSsize_t(arg);

  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00079	48 8b f8	 mov	 rdi, rax

; 395  :         if (maxsize == -1 && PyErr_Occurred())

  0007c	48 83 f8 ff	 cmp	 rax, -1
  00080	75 26		 jne	 SHORT $LN7@bytesio_re@4
  00082	e8 00 00 00 00	 call	 PyErr_Occurred
  00087	48 85 c0	 test	 rax, rax
  0008a	74 1c		 je	 SHORT $LN7@bytesio_re@4

; 396  :             return NULL;

  0008c	33 c0		 xor	 eax, eax
  0008e	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 431  : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	41 5d		 pop	 r13
  00099	5b		 pop	 rbx
  0009a	c3		 ret	 0
$LN11@bytesio_re@4:

; 397  :     }
; 398  :     else if (arg == Py_None) {

  0009b	48 3b c3	 cmp	 rax, rbx
  0009e	0f 85 cb 00 00
	00		 jne	 $LN8@bytesio_re@4

; 399  :         /* No size limit, by default. */
; 400  :         maxsize = -1;

  000a4	48 83 cf ff	 or	 rdi, -1
$LN7@bytesio_re@4:

; 406  :     }
; 407  : 
; 408  :     size = 0;
; 409  :     result = PyList_New(0);

  000a8	33 c9		 xor	 ecx, ecx
  000aa	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000af	33 db		 xor	 ebx, ebx
  000b1	e8 00 00 00 00	 call	 PyList_New
  000b6	4c 8b e0	 mov	 r12, rax

; 410  :     if (!result)

  000b9	48 85 c0	 test	 rax, rax
  000bc	75 12		 jne	 SHORT $LN16@bytesio_re@4
  000be	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
  000c3	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 431  : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	41 5d		 pop	 r13
  000ce	5b		 pop	 rbx
  000cf	c3		 ret	 0
$LN16@bytesio_re@4:

; 411  :         return NULL;
; 412  : 
; 413  :     while ((n = get_line(self, &output)) != 0) {

  000d0	48 8d 54 24 60	 lea	 rdx, QWORD PTR output$[rsp]
  000d5	49 8b cd	 mov	 rcx, r13
  000d8	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  000dd	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  000e2	e8 00 00 00 00	 call	 get_line
  000e7	48 8b f0	 mov	 rsi, rax
  000ea	48 85 c0	 test	 rax, rax
  000ed	74 50		 je	 SHORT $LN19@bytesio_re@4
  000ef	90		 npad	 1
$LL5@bytesio_re@4:

; 414  :         line = PyBytes_FromStringAndSize(output, n);

  000f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  000f5	48 8b d6	 mov	 rdx, rsi
  000f8	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000fd	48 8b e8	 mov	 rbp, rax

; 415  :         if (!line)

  00100	48 85 c0	 test	 rax, rax
  00103	74 5e		 je	 SHORT $on_error$20598

; 416  :             goto on_error;
; 417  :         if (PyList_Append(result, line) == -1) {

  00105	48 8b d0	 mov	 rdx, rax
  00108	49 8b cc	 mov	 rcx, r12
  0010b	e8 00 00 00 00	 call	 PyList_Append

; 419  :             goto on_error;
; 420  :         }
; 421  :         Py_DECREF(line);

  00110	48 8b cd	 mov	 rcx, rbp
  00113	83 f8 ff	 cmp	 eax, -1
  00116	74 46		 je	 SHORT $LN18@bytesio_re@4
  00118	e8 00 00 00 00	 call	 _Py_DecRef

; 422  :         size += n;

  0011d	48 03 de	 add	 rbx, rsi

; 423  :         if (maxsize > 0 && size >= maxsize)

  00120	48 85 ff	 test	 rdi, rdi
  00123	7e 05		 jle	 SHORT $LN1@bytesio_re@4
  00125	48 3b df	 cmp	 rbx, rdi
  00128	7d 15		 jge	 SHORT $LN19@bytesio_re@4
$LN1@bytesio_re@4:

; 411  :         return NULL;
; 412  : 
; 413  :     while ((n = get_line(self, &output)) != 0) {

  0012a	48 8d 54 24 60	 lea	 rdx, QWORD PTR output$[rsp]
  0012f	49 8b cd	 mov	 rcx, r13
  00132	e8 00 00 00 00	 call	 get_line
  00137	48 8b f0	 mov	 rsi, rax
  0013a	48 85 c0	 test	 rax, rax
  0013d	75 b1		 jne	 SHORT $LL5@bytesio_re@4
$LN19@bytesio_re@4:

; 424  :             break;
; 425  :     }
; 426  :     return result;

  0013f	49 8b c4	 mov	 rax, r12
$LN23@bytesio_re@4:
  00142	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00147	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0014c	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]
  00151	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 431  : }

  00156	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015a	41 5d		 pop	 r13
  0015c	5b		 pop	 rbx
  0015d	c3		 ret	 0
$LN18@bytesio_re@4:

; 418  :             Py_DECREF(line);

  0015e	e8 00 00 00 00	 call	 _Py_DecRef
$on_error$20598:

; 427  : 
; 428  :   on_error:
; 429  :     Py_DECREF(result);

  00163	49 8b cc	 mov	 rcx, r12
  00166	e8 00 00 00 00	 call	 _Py_DecRef

; 430  :     return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	eb d3		 jmp	 SHORT $LN23@bytesio_re@4
$LN8@bytesio_re@4:

; 401  :     }
; 402  :     else {
; 403  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 404  :                      Py_TYPE(arg)->tp_name);

  0016f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00173	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  00181	e8 00 00 00 00	 call	 PyErr_Format
  00186	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]

; 405  :         return NULL;

  0018b	33 c0		 xor	 eax, eax

; 431  : }

  0018d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00191	41 5d		 pop	 r13
  00193	5b		 pop	 rbx
  00194	c3		 ret	 0
bytesio_readlines ENDP
_TEXT	ENDS
EXTRN	PyObject_AsWriteBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_readinto DD imagerel bytesio_readinto
	DD	imagerel bytesio_readinto+145
	DD	imagerel $unwind$bytesio_readinto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_readinto DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_readinto
_TEXT	SEGMENT
len$ = 48
self$ = 48
buffer$ = 56
raw_buffer$ = 64
bytesio_readinto PROC					; COMDAT

; 441  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 442  :     void *raw_buffer;
; 443  :     Py_ssize_t len, n;
; 444  : 
; 445  :     CHECK_CLOSED(self);

  00006	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	75 1b		 jne	 SHORT $LN4@bytesio_re@5
  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00021	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@bytesio_re@5:
  00026	33 c0		 xor	 eax, eax

; 464  : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
$LN4@bytesio_re@5:

; 446  : 
; 447  :     if (PyObject_AsWriteBuffer(buffer, &raw_buffer, &len) == -1)

  0002e	4c 8d 44 24 30	 lea	 r8, QWORD PTR len$[rsp]
  00033	48 8d 54 24 40	 lea	 rdx, QWORD PTR raw_buffer$[rsp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 PyObject_AsWriteBuffer
  00040	83 f8 ff	 cmp	 eax, -1

; 448  :         return NULL;

  00043	74 e1		 je	 SHORT $LN7@bytesio_re@5

; 449  : 
; 450  :     /* adjust invalid sizes */
; 451  :     n = self->string_size - self->pos;

  00045	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00049	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 452  :     if (len > n) {

  0004d	4c 8b 44 24 30	 mov	 r8, QWORD PTR len$[rsp]
  00052	48 2b c1	 sub	 rax, rcx
  00055	4c 3b c0	 cmp	 r8, rax
  00058	7e 11		 jle	 SHORT $LN1@bytesio_re@5

; 453  :         len = n;
; 454  :         if (len < 0)

  0005a	33 d2		 xor	 edx, edx
  0005c	4c 8b c0	 mov	 r8, rax
  0005f	48 85 c0	 test	 rax, rax
  00062	4c 0f 48 c2	 cmovs	 r8, rdx
  00066	4c 89 44 24 30	 mov	 QWORD PTR len$[rsp], r8
$LN1@bytesio_re@5:

; 455  :             len = 0;
; 456  :     }
; 457  : 
; 458  :     memcpy(raw_buffer, self->buf + self->pos, len);

  0006b	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0006f	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR raw_buffer$[rsp]
  00078	e8 00 00 00 00	 call	 memcpy

; 459  :     assert(self->pos + len < PY_SSIZE_T_MAX);
; 460  :     assert(len >= 0);
; 461  :     self->pos += len;

  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  00082	48 01 4b 68	 add	 QWORD PTR [rbx+104], rcx

; 462  : 
; 463  :     return PyLong_FromSsize_t(len);

  00086	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 464  : }

  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5b		 pop	 rbx
  00090	c3		 ret	 0
bytesio_readinto ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@ ; `string'
PUBLIC	??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@		; `string'
PUBLIC	??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ ; `string'
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_truncate DD imagerel bytesio_truncate
	DD	imagerel bytesio_truncate+328
	DD	imagerel $unwind$bytesio_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_truncate DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@
CONST	SEGMENT
??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@ DB 'negative size v'
	DB	'alue %zd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
CONST	SEGMENT
??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@ DB '|O:truncate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
CONST	SEGMENT
??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@ DB 'Existing ex'
	DB	'ports of data: object cannot be re-sized', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_truncate
_TEXT	SEGMENT
arg$ = 48
self$ = 48
args$ = 56
bytesio_truncate PROC					; COMDAT

; 474  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 475  :     Py_ssize_t size;
; 476  :     PyObject *arg = Py_None;
; 477  : 
; 478  :     CHECK_CLOSED(self);

  0000a	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00016	48 8b c2	 mov	 rax, rdx
  00019	48 89 5c 24 30	 mov	 QWORD PTR arg$[rsp], rbx
  0001e	48 8b f9	 mov	 rdi, rcx
  00021	75 20		 jne	 SHORT $LN11@bytesio_tr
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00031	e8 00 00 00 00	 call	 PyErr_SetString

; 496  :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 512  : }

  00038	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
$LN11@bytesio_tr:

; 479  :     CHECK_EXPORTS(self);

  00043	48 83 b9 90 00
	00 00 00	 cmp	 QWORD PTR [rcx+144], 0
  0004b	7e 20		 jle	 SHORT $LN10@bytesio_tr
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  0005b	e8 00 00 00 00	 call	 PyErr_SetString

; 496  :         return NULL;

  00060	33 c0		 xor	 eax, eax

; 512  : }

  00062	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
$LN10@bytesio_tr:

; 480  : 
; 481  :     if (!PyArg_ParseTuple(args, "|O:truncate", &arg))

  0006d	4c 8d 44 24 30	 lea	 r8, QWORD PTR arg$[rsp]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@EGOFFNDK@?$HMO?3truncate?$AA@
  00079	48 8b c8	 mov	 rcx, rax
  0007c	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00081	85 c0		 test	 eax, eax

; 482  :         return NULL;

  00083	0f 84 b2 00 00
	00		 je	 $LN15@bytesio_tr

; 483  : 
; 484  :     if (PyLong_Check(arg)) {

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR arg$[rsp]
  0008e	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  00092	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  0009d	74 28		 je	 SHORT $LN8@bytesio_tr

; 485  :         size = PyLong_AsSsize_t(arg);

  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000a7	48 8b d8	 mov	 rbx, rax

; 486  :         if (size == -1 && PyErr_Occurred())

  000aa	48 83 f8 ff	 cmp	 rax, -1
  000ae	75 20		 jne	 SHORT $LN4@bytesio_tr
  000b0	e8 00 00 00 00	 call	 PyErr_Occurred
  000b5	48 85 c0	 test	 rax, rax
  000b8	74 1b		 je	 SHORT $LN14@bytesio_tr

; 496  :         return NULL;

  000ba	33 c0		 xor	 eax, eax

; 512  : }

  000bc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
$LN8@bytesio_tr:

; 487  :             return NULL;
; 488  :     }
; 489  :     else if (arg == Py_None) {

  000c7	48 3b c3	 cmp	 rax, rbx
  000ca	75 58		 jne	 SHORT $LN5@bytesio_tr

; 490  :         /* Truncate to current position if no argument is passed. */
; 491  :         size = self->pos;

  000cc	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
$LN4@bytesio_tr:

; 497  :     }
; 498  : 
; 499  :     if (size < 0) {

  000d0	48 85 db	 test	 rbx, rbx
  000d3	79 23		 jns	 SHORT $LN3@bytesio_tr
$LN14@bytesio_tr:

; 500  :         PyErr_Format(PyExc_ValueError,
; 501  :                      "negative size value %zd", size);

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@JOKLPDAF@negative?5size?5value?5?$CFzd?$AA@
  000e3	4c 8b c3	 mov	 r8, rbx
  000e6	e8 00 00 00 00	 call	 PyErr_Format
  000eb	33 c0		 xor	 eax, eax

; 512  : }

  000ed	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
$LN3@bytesio_tr:

; 502  :         return NULL;
; 503  :     }
; 504  : 
; 505  :     if (size < self->string_size) {

  000f8	48 3b 5f 70	 cmp	 rbx, QWORD PTR [rdi+112]
  000fc	7d 13		 jge	 SHORT $LN1@bytesio_tr

; 506  :         self->string_size = size;
; 507  :         if (resize_buffer(self, size) < 0)

  000fe	48 8b d3	 mov	 rdx, rbx
  00101	48 8b cf	 mov	 rcx, rdi
  00104	48 89 5f 70	 mov	 QWORD PTR [rdi+112], rbx
  00108	e8 00 00 00 00	 call	 resize_buffer
  0010d	85 c0		 test	 eax, eax

; 508  :             return NULL;

  0010f	78 2a		 js	 SHORT $LN15@bytesio_tr
$LN1@bytesio_tr:

; 509  :     }
; 510  : 
; 511  :     return PyLong_FromSsize_t(size);

  00111	48 8b cb	 mov	 rcx, rbx
  00114	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 512  : }

  00119	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0011e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
$LN5@bytesio_tr:

; 492  :     }
; 493  :     else {
; 494  :         PyErr_Format(PyExc_TypeError, "integer argument expected, got '%s'",
; 495  :                      Py_TYPE(arg)->tp_name);

  00124	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00128	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@MLFMOEKB@integer?5argument?5expected?0?5got?5?8@
  00136	e8 00 00 00 00	 call	 PyErr_Format
$LN15@bytesio_tr:

; 496  :         return NULL;

  0013b	33 c0		 xor	 eax, eax

; 512  : }

  0013d	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00142	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
bytesio_truncate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_iternext DD imagerel bytesio_iternext
	DD	imagerel bytesio_iternext+74
	DD	imagerel $unwind$bytesio_iternext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_iternext DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_iternext
_TEXT	SEGMENT
next$ = 48
self$ = 48
bytesio_iternext PROC					; COMDAT

; 516  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 517  :     char *next;
; 518  :     Py_ssize_t n;
; 519  : 
; 520  :     CHECK_CLOSED(self);

  00004	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  00009	75 1a		 jne	 SHORT $LN3@bytesio_it
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  00019	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@bytesio_it:

; 525  :         return NULL;

  0001e	33 c0		 xor	 eax, eax

; 528  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
$LN3@bytesio_it:

; 521  : 
; 522  :     n = get_line(self, &next);

  00025	48 8d 54 24 30	 lea	 rdx, QWORD PTR next$[rsp]
  0002a	e8 00 00 00 00	 call	 get_line

; 523  : 
; 524  :     if (!next || n == 0)

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  00034	48 85 c9	 test	 rcx, rcx
  00037	74 e5		 je	 SHORT $LN1@bytesio_it
  00039	48 85 c0	 test	 rax, rax
  0003c	74 e0		 je	 SHORT $LN1@bytesio_it

; 526  : 
; 527  :     return PyBytes_FromStringAndSize(next, n);

  0003e	48 8b d0	 mov	 rdx, rax

; 528  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	e9 00 00 00 00	 jmp	 PyBytes_FromStringAndSize
bytesio_iternext ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@ ; `string'
PUBLIC	??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@ ; `string'
PUBLIC	??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@ ; `string'
PUBLIC	??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_seek DD imagerel bytesio_seek
	DD	imagerel bytesio_seek+288
	DD	imagerel $unwind$bytesio_seek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_seek DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@
CONST	SEGMENT
??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@ DB 'inv'
	DB	'alid whence (%i, should be 0, 1 or 2)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@ DB 'new position too la'
	DB	'rge', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@
CONST	SEGMENT
??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@ DB 'negative seek v'
	DB	'alue %zd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
CONST	SEGMENT
??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@ DB 'n|i:seek', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_seek
_TEXT	SEGMENT
mode$ = 48
self$ = 48
args$ = 56
pos$ = 64
bytesio_seek PROC					; COMDAT

; 541  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 542  :     Py_ssize_t pos;
; 543  :     int mode = 0;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	89 7c 24 30	 mov	 DWORD PTR mode$[rsp], edi

; 544  : 
; 545  :     CHECK_CLOSED(self);

  00016	48 39 79 60	 cmp	 QWORD PTR [rcx+96], rdi
  0001a	75 20		 jne	 SHORT $LN11@bytesio_se
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002a	e8 00 00 00 00	 call	 PyErr_SetString
$LN14@bytesio_se:
  0002f	33 c0		 xor	 eax, eax

; 586  : }

  00031	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN11@bytesio_se:

; 546  : 
; 547  :     if (!PyArg_ParseTuple(args, "n|i:seek", &pos, &mode))

  0003c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR mode$[rsp]
  00041	4c 8d 44 24 40	 lea	 r8, QWORD PTR pos$[rsp]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00055	85 c0		 test	 eax, eax

; 548  :         return NULL;

  00057	74 d6		 je	 SHORT $LN14@bytesio_se

; 549  : 
; 550  :     if (pos < 0 && mode == 0) {

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pos$[rsp]
  0005e	44 8b 44 24 30	 mov	 r8d, DWORD PTR mode$[rsp]
  00063	48 85 c9	 test	 rcx, rcx
  00066	79 28		 jns	 SHORT $LN9@bytesio_se
  00068	45 85 c0	 test	 r8d, r8d
  0006b	75 23		 jne	 SHORT $LN9@bytesio_se

; 551  :         PyErr_Format(PyExc_ValueError,
; 552  :                      "negative seek value %zd", pos);

  0006d	4c 8b c1	 mov	 r8, rcx
  00070	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@MOBIMCNJ@negative?5seek?5value?5?$CFzd?$AA@
  0007e	e8 00 00 00 00	 call	 PyErr_Format

; 553  :         return NULL;

  00083	33 c0		 xor	 eax, eax

; 586  : }

  00085	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
$LN9@bytesio_se:

; 554  :     }
; 555  : 
; 556  :     /* mode 0: offset relative to beginning of the string.
; 557  :        mode 1: offset relative to current position.
; 558  :        mode 2: offset relative the end of the string. */
; 559  :     if (mode == 1) {

  00090	41 83 f8 01	 cmp	 r8d, 1
  00094	75 36		 jne	 SHORT $LN8@bytesio_se

; 560  :         if (pos > PY_SSIZE_T_MAX - self->pos) {

  00096	48 8b 53 68	 mov	 rdx, QWORD PTR [rbx+104]
$LN15@bytesio_se:
  0009a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a4	48 2b c2	 sub	 rax, rdx
  000a7	48 3b c8	 cmp	 rcx, rax
  000aa	7e 2c		 jle	 SHORT $LN4@bytesio_se

; 561  :             PyErr_SetString(PyExc_OverflowError,
; 562  :                             "new position too large");

  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LKHKGFCB@new?5position?5too?5large?$AA@
  000ba	e8 00 00 00 00	 call	 PyErr_SetString

; 563  :             return NULL;

  000bf	33 c0		 xor	 eax, eax

; 586  : }

  000c1	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
$LN8@bytesio_se:

; 564  :         }
; 565  :         pos += self->pos;
; 566  :     }
; 567  :     else if (mode == 2) {

  000cc	41 83 f8 02	 cmp	 r8d, 2
  000d0	75 29		 jne	 SHORT $LN5@bytesio_se

; 568  :         if (pos > PY_SSIZE_T_MAX - self->string_size) {

  000d2	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]

; 569  :             PyErr_SetString(PyExc_OverflowError,
; 570  :                             "new position too large");
; 571  :             return NULL;

  000d6	eb c2		 jmp	 SHORT $LN15@bytesio_se
$LN4@bytesio_se:

; 572  :         }
; 573  :         pos += self->string_size;

  000d8	48 03 ca	 add	 rcx, rdx
$LN2@bytesio_se:

; 578  :         return NULL;
; 579  :     }
; 580  : 
; 581  :     if (pos < 0)

  000db	48 85 c9	 test	 rcx, rcx
  000de	48 0f 48 cf	 cmovs	 rcx, rdi
  000e2	48 89 4c 24 40	 mov	 QWORD PTR pos$[rsp], rcx

; 582  :         pos = 0;
; 583  :     self->pos = pos;

  000e7	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 584  : 
; 585  :     return PyLong_FromSsize_t(self->pos);

  000eb	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 586  : }

  000f0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
$LN5@bytesio_se:

; 574  :     }
; 575  :     else if (mode != 0) {

  000fb	45 85 c0	 test	 r8d, r8d
  000fe	74 db		 je	 SHORT $LN2@bytesio_se

; 576  :         PyErr_Format(PyExc_ValueError,
; 577  :                      "invalid whence (%i, should be 0, 1 or 2)", mode);

  00100	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@DDLGNKCJ@invalid?5whence?5?$CI?$CFi?0?5should?5be?50?0@
  0010e	e8 00 00 00 00	 call	 PyErr_Format

; 586  : }

  00113	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00118	33 c0		 xor	 eax, eax
  0011a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
bytesio_seek ENDP
_TEXT	ENDS
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_write DD imagerel bytesio_write
	DD	imagerel bytesio_write+214
	DD	imagerel $unwind$bytesio_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_write DD 060f01H
	DD	011640fH
	DD	010340fH
	DD	0700bd20fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_write
_TEXT	SEGMENT
buf$ = 32
self$ = 128
obj$ = 136
bytesio_write PROC					; COMDAT

; 595  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 596  :     Py_ssize_t n = 0;

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b c2	 mov	 rax, rdx
  00014	48 8b f1	 mov	 rsi, rcx

; 597  :     Py_buffer buf;
; 598  :     PyObject *result = NULL;

  00017	8b fb		 mov	 edi, ebx

; 599  : 
; 600  :     CHECK_CLOSED(self);

  00019	48 39 59 60	 cmp	 QWORD PTR [rcx+96], rbx
  0001d	75 27		 jne	 SHORT $LN5@bytesio_wr
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0002d	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@bytesio_wr:
  00032	33 c0		 xor	 eax, eax

; 612  :     return result;
; 613  : }

  00034	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00039	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0003d	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00041	49 8b e3	 mov	 rsp, r11
  00044	5f		 pop	 rdi
  00045	c3		 ret	 0
$LN5@bytesio_wr:

; 601  :     CHECK_EXPORTS(self);

  00046	48 39 99 90 00
	00 00		 cmp	 QWORD PTR [rcx+144], rbx
  0004d	7e 27		 jle	 SHORT $LN4@bytesio_wr
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  0005d	e8 00 00 00 00	 call	 PyErr_SetString
  00062	33 c0		 xor	 eax, eax

; 612  :     return result;
; 613  : }

  00064	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00069	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0006d	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00071	49 8b e3	 mov	 rsp, r11
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
$LN4@bytesio_wr:

; 602  : 
; 603  :     if (PyObject_GetBuffer(obj, &buf, PyBUF_CONTIG_RO) < 0)

  00076	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  0007b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00081	48 8b c8	 mov	 rcx, rax
  00084	e8 00 00 00 00	 call	 PyObject_GetBuffer
  00089	85 c0		 test	 eax, eax

; 604  :         return NULL;

  0008b	78 a5		 js	 SHORT $LN9@bytesio_wr

; 605  : 
; 606  :     if (buf.len != 0)

  0008d	4c 8b 44 24 30	 mov	 r8, QWORD PTR buf$[rsp+16]
  00092	4d 85 c0	 test	 r8, r8
  00095	74 15		 je	 SHORT $LN8@bytesio_wr

; 607  :         n = write_bytes(self, buf.buf, buf.len);

  00097	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  0009c	48 8b ce	 mov	 rcx, rsi
  0009f	e8 00 00 00 00	 call	 write_bytes
  000a4	48 8b d8	 mov	 rbx, rax

; 608  :     if (n >= 0)

  000a7	48 85 c0	 test	 rax, rax
  000aa	78 0b		 js	 SHORT $LN1@bytesio_wr
$LN8@bytesio_wr:

; 609  :         result = PyLong_FromSsize_t(n);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000b4	48 8b f8	 mov	 rdi, rax
$LN1@bytesio_wr:

; 610  : 
; 611  :     PyBuffer_Release(&buf);

  000b7	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000bc	e8 00 00 00 00	 call	 PyBuffer_Release

; 612  :     return result;
; 613  : }

  000c1	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  000c6	48 8b c7	 mov	 rax, rdi
  000c9	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000cd	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  000d1	49 8b e3	 mov	 rsp, r11
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
bytesio_write ENDP
_TEXT	ENDS
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_writelines DD imagerel bytesio_writelines
	DD	imagerel bytesio_writelines+46
	DD	imagerel $unwind$bytesio_writelines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_writelines DD imagerel bytesio_writelines+46
	DD	imagerel bytesio_writelines+75
	DD	imagerel $chain$0$bytesio_writelines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytesio_writelines DD imagerel bytesio_writelines+75
	DD	imagerel bytesio_writelines+415
	DD	imagerel $chain$4$bytesio_writelines
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$bytesio_writelines DD imagerel bytesio_writelines+415
	DD	imagerel bytesio_writelines+427
	DD	imagerel $chain$6$bytesio_writelines
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$bytesio_writelines DD 060021H
	DD	0a7400H
	DD	096400H
	DD	083400H
	DD	imagerel bytesio_writelines
	DD	imagerel bytesio_writelines+46
	DD	imagerel $unwind$bytesio_writelines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytesio_writelines DD 060d21H
	DD	0a740dH
	DD	083408H
	DD	096400H
	DD	imagerel bytesio_writelines
	DD	imagerel bytesio_writelines+46
	DD	imagerel $unwind$bytesio_writelines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_writelines DD 020521H
	DD	096405H
	DD	imagerel bytesio_writelines
	DD	imagerel bytesio_writelines+46
	DD	imagerel $unwind$bytesio_writelines
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_writelines DD 020601H
	DD	050025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_writelines
_TEXT	SEGMENT
self$ = 64
v$ = 72
bytesio_writelines PROC					; COMDAT

; 624  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 625  :     PyObject *it, *item;
; 626  :     PyObject *ret;
; 627  : 
; 628  :     CHECK_CLOSED(self);

  00006	48 83 79 60 00	 cmp	 QWORD PTR [rcx+96], 0
  0000b	48 8b e9	 mov	 rbp, rcx
  0000e	75 1b		 jne	 SHORT $LN6@bytesio_wr@2
  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@NJELGIOK@I?1O?5operation?5on?5closed?5file?4?$AA@
  0001e	e8 00 00 00 00	 call	 PyErr_SetString
  00023	33 c0		 xor	 eax, eax

; 650  : }

  00025	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00029	5d		 pop	 rbp
  0002a	c3		 ret	 0
$LN6@bytesio_wr@2:

; 629  : 
; 630  :     it = PyObject_GetIter(v);

  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00033	e8 00 00 00 00	 call	 PyObject_GetIter
  00038	48 8b f0	 mov	 rsi, rax

; 631  :     if (it == NULL)

  0003b	48 85 c0	 test	 rax, rax
  0003e	75 0b		 jne	 SHORT $LN31@bytesio_wr@2
  00040	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 650  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5d		 pop	 rbp
  0004a	c3		 ret	 0
$LN31@bytesio_wr@2:

; 632  :         return NULL;
; 633  : 
; 634  :     while ((item = PyIter_Next(it)) != NULL) {

  0004b	48 8b c8	 mov	 rcx, rax
  0004e	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00053	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00058	e8 00 00 00 00	 call	 PyIter_Next
  0005d	48 8b d8	 mov	 rbx, rax
  00060	48 85 c0	 test	 rax, rax
  00063	0f 84 fc 00 00
	00		 je	 $LN3@bytesio_wr@2
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@bytesio_wr@2:

; 635  :         ret = bytesio_write(self, item);

  00070	48 8b d3	 mov	 rdx, rbx
  00073	48 8b cd	 mov	 rcx, rbp
  00076	e8 00 00 00 00	 call	 bytesio_write
  0007b	48 8b f8	 mov	 rdi, rax

; 636  :         Py_DECREF(item);

  0007e	e8 00 00 00 00	 call	 _Py_PXCTX
  00083	85 c0		 test	 eax, eax
  00085	75 5c		 jne	 SHORT $LN19@bytesio_wr@2
  00087	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0008b	a8 20		 test	 al, 32			; 00000020H
  0008d	75 4c		 jne	 SHORT $LN13@bytesio_wr@2
  0008f	84 c0		 test	 al, al
  00091	78 48		 js	 SHORT $LN13@bytesio_wr@2
  00093	a8 02		 test	 al, 2
  00095	75 4c		 jne	 SHORT $LN19@bytesio_wr@2
  00097	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0009b	75 46		 jne	 SHORT $LN19@bytesio_wr@2
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ab	4c 8b cb	 mov	 r9, rbx
  000ae	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  000b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000bc	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c1	48 8b cb	 mov	 rcx, rbx
  000c4	85 c0		 test	 eax, eax
  000c6	74 07		 je	 SHORT $LN18@bytesio_wr@2
  000c8	e8 00 00 00 00	 call	 _Px_Dealloc
  000cd	eb 14		 jmp	 SHORT $LN19@bytesio_wr@2
$LN18@bytesio_wr@2:
  000cf	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000d3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000d9	eb 08		 jmp	 SHORT $LN19@bytesio_wr@2
$LN13@bytesio_wr@2:
  000db	48 8b cb	 mov	 rcx, rbx
  000de	e8 00 00 00 00	 call	 Px_DecRef
$LN19@bytesio_wr@2:

; 637  :         if (ret == NULL) {

  000e3	48 85 ff	 test	 rdi, rdi
  000e6	0f 84 b3 00 00
	00		 je	 $LN32@bytesio_wr@2

; 640  :         }
; 641  :         Py_DECREF(ret);

  000ec	e8 00 00 00 00	 call	 _Py_PXCTX
  000f1	85 c0		 test	 eax, eax
  000f3	75 5c		 jne	 SHORT $LN30@bytesio_wr@2
  000f5	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  000f9	a8 20		 test	 al, 32			; 00000020H
  000fb	75 4c		 jne	 SHORT $LN24@bytesio_wr@2
  000fd	84 c0		 test	 al, al
  000ff	78 48		 js	 SHORT $LN24@bytesio_wr@2
  00101	a8 02		 test	 al, 2
  00103	75 4c		 jne	 SHORT $LN30@bytesio_wr@2
  00105	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  00109	75 46		 jne	 SHORT $LN30@bytesio_wr@2
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00119	4c 8b cf	 mov	 r9, rdi
  0011c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00122	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0012f	48 8b cf	 mov	 rcx, rdi
  00132	85 c0		 test	 eax, eax
  00134	74 07		 je	 SHORT $LN29@bytesio_wr@2
  00136	e8 00 00 00 00	 call	 _Px_Dealloc
  0013b	eb 14		 jmp	 SHORT $LN30@bytesio_wr@2
$LN29@bytesio_wr@2:
  0013d	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00141	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00147	eb 08		 jmp	 SHORT $LN30@bytesio_wr@2
$LN24@bytesio_wr@2:
  00149	48 8b cf	 mov	 rcx, rdi
  0014c	e8 00 00 00 00	 call	 Px_DecRef
$LN30@bytesio_wr@2:

; 632  :         return NULL;
; 633  : 
; 634  :     while ((item = PyIter_Next(it)) != NULL) {

  00151	48 8b ce	 mov	 rcx, rsi
  00154	e8 00 00 00 00	 call	 PyIter_Next
  00159	48 8b d8	 mov	 rbx, rax
  0015c	48 85 c0	 test	 rax, rax
  0015f	0f 85 0b ff ff
	ff		 jne	 $LL4@bytesio_wr@2
$LN3@bytesio_wr@2:

; 642  :     }
; 643  :     Py_DECREF(it);

  00165	48 8b ce	 mov	 rcx, rsi
  00168	e8 00 00 00 00	 call	 _Py_DecRef

; 644  : 
; 645  :     /* See if PyIter_Next failed */
; 646  :     if (PyErr_Occurred())

  0016d	e8 00 00 00 00	 call	 PyErr_Occurred
  00172	48 85 c0	 test	 rax, rax

; 647  :         return NULL;

  00175	75 30		 jne	 SHORT $LN36@bytesio_wr@2

; 648  : 
; 649  :     Py_RETURN_NONE;

  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0017e	e8 00 00 00 00	 call	 _Py_IncRef
  00183	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN35@bytesio_wr@2:
  0018a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0018f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00194	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 650  : }

  00199	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0019d	5d		 pop	 rbp
  0019e	c3		 ret	 0
$LN32@bytesio_wr@2:

; 638  :             Py_DECREF(it);

  0019f	48 8b ce	 mov	 rcx, rsi
  001a2	e8 00 00 00 00	 call	 _Py_DecRef
$LN36@bytesio_wr@2:

; 639  :             return NULL;

  001a7	33 c0		 xor	 eax, eax
  001a9	eb df		 jmp	 SHORT $LN35@bytesio_wr@2
bytesio_writelines ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_close DD imagerel bytesio_close
	DD	imagerel bytesio_close+125
	DD	imagerel $unwind$bytesio_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_close DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
xdata	ENDS
;	COMDAT bytesio_close
_TEXT	SEGMENT
self$ = 64
bytesio_close PROC					; COMDAT

; 657  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 658  :     if (self->buf != NULL) {

  00009	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 0d		 je	 SHORT $LN1@bytesio_cl

; 659  :         PyMem_Free(self->buf);

  00012	e8 00 00 00 00	 call	 PyMem_Free

; 660  :         self->buf = NULL;

  00017	48 c7 43 60 00
	00 00 00	 mov	 QWORD PTR [rbx+96], 0
$LN1@bytesio_cl:

; 661  :     }
; 662  :     Py_RETURN_NONE;

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 48		 jne	 SHORT $LN8@bytesio_cl
  00028	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00043	4c 8b cb	 mov	 r9, rbx
  00046	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN4@bytesio_cl
  00057	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0005e	74 07		 je	 SHORT $LN10@bytesio_cl
$LN4@bytesio_cl:
  00060	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN10@bytesio_cl:
  00067	48 8b c3	 mov	 rax, rbx

; 663  : }

  0006a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN8@bytesio_cl:

; 661  :     }
; 662  :     Py_RETURN_NONE;

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 663  : }

  00077	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
bytesio_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@		; `string'
EXTRN	PyDict_Copy:PROC
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_getstate DD imagerel bytesio_getstate
	DD	imagerel bytesio_getstate+44
	DD	imagerel $unwind$bytesio_getstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_getstate DD imagerel bytesio_getstate+44
	DD	imagerel bytesio_getstate+178
	DD	imagerel $chain$0$bytesio_getstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytesio_getstate DD imagerel bytesio_getstate+178
	DD	imagerel bytesio_getstate+217
	DD	imagerel $chain$2$bytesio_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytesio_getstate DD 020021H
	DD	083400H
	DD	imagerel bytesio_getstate
	DD	imagerel bytesio_getstate+44
	DD	imagerel $unwind$bytesio_getstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_getstate DD 020521H
	DD	083405H
	DD	imagerel bytesio_getstate
	DD	imagerel bytesio_getstate+44
	DD	imagerel $unwind$bytesio_getstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_getstate DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@
CONST	SEGMENT
??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@ DB '(OnN)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
CONST	ENDS
;	COMDAT bytesio_getstate
_TEXT	SEGMENT
self$ = 64
bytesio_getstate PROC					; COMDAT

; 682  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f1	 mov	 rsi, rcx

; 683  :     PyObject *initvalue = bytesio_getvalue(self);

  0000d	e8 00 00 00 00	 call	 bytesio_getvalue
  00012	48 8b f8	 mov	 rdi, rax

; 684  :     PyObject *dict;
; 685  :     PyObject *state;
; 686  : 
; 687  :     if (initvalue == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN4@bytesio_ge@4

; 704  : }

  0001a	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN4@bytesio_ge@4:

; 688  :         return NULL;
; 689  :     if (self->dict == NULL) {

  00025	48 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [rsi+128]
  0002c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00031	48 85 c9	 test	 rcx, rcx
  00034	75 7c		 jne	 SHORT $LN3@bytesio_ge@4

; 690  :         Py_INCREF(Py_None);

  00036	e8 00 00 00 00	 call	 _Py_PXCTX
  0003b	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
  00042	85 c0		 test	 eax, eax
  00044	75 38		 jne	 SHORT $LN1@bytesio_ge@4
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00054	4c 8b cb	 mov	 r9, rbx
  00057	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00065	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006a	85 c0		 test	 eax, eax
  0006c	75 09		 jne	 SHORT $LN7@bytesio_ge@4
  0006e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00075	74 07		 je	 SHORT $LN1@bytesio_ge@4
$LN7@bytesio_ge@4:
  00077	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN1@bytesio_ge@4:

; 697  :             return NULL;
; 698  :         }
; 699  :     }
; 700  : 
; 701  :     state = Py_BuildValue("(OnN)", initvalue, self->pos, dict);

  0007e	4c 8b 46 68	 mov	 r8, QWORD PTR [rsi+104]
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05JKNKKJIO@?$CIOnN?$CJ?$AA@
  00089	4c 8b cb	 mov	 r9, rbx
  0008c	48 8b d7	 mov	 rdx, rdi
  0008f	e8 00 00 00 00	 call	 Py_BuildValue

; 702  :     Py_DECREF(initvalue);

  00094	48 8b cf	 mov	 rcx, rdi
  00097	48 8b d8	 mov	 rbx, rax
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 703  :     return state;

  0009f	48 8b c3	 mov	 rax, rbx
  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 704  : }

  000a7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
$LN3@bytesio_ge@4:

; 691  :         dict = Py_None;
; 692  :     }
; 693  :     else {
; 694  :         dict = PyDict_Copy(self->dict);

  000b2	e8 00 00 00 00	 call	 PyDict_Copy
  000b7	48 8b d8	 mov	 rbx, rax

; 695  :         if (dict == NULL) {

  000ba	48 85 c0	 test	 rax, rax
  000bd	75 bf		 jne	 SHORT $LN1@bytesio_ge@4

; 696  :             Py_DECREF(initvalue);

  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	e8 00 00 00 00	 call	 _Py_DecRef
  000c7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 704  : }

  000cc	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000d1	33 c0		 xor	 eax, eax
  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
bytesio_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@ ; `string'
PUBLIC	??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@ ; `string'
PUBLIC	??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@ ; `string'
PUBLIC	??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@ ; `string'
EXTRN	PyDict_Update:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_setstate DD imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+261
	DD	imagerel $unwind$bytesio_setstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_setstate DD imagerel bytesio_setstate+261
	DD	imagerel bytesio_setstate+336
	DD	imagerel $chain$0$bytesio_setstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytesio_setstate DD imagerel bytesio_setstate+336
	DD	imagerel bytesio_setstate+378
	DD	imagerel $chain$2$bytesio_setstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytesio_setstate DD imagerel bytesio_setstate+378
	DD	imagerel bytesio_setstate+420
	DD	imagerel $chain$4$bytesio_setstate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$bytesio_setstate DD imagerel bytesio_setstate+420
	DD	imagerel bytesio_setstate+464
	DD	imagerel $chain$5$bytesio_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$bytesio_setstate DD 021H
	DD	imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+261
	DD	imagerel $unwind$bytesio_setstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytesio_setstate DD 020021H
	DD	066400H
	DD	imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+261
	DD	imagerel $unwind$bytesio_setstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytesio_setstate DD 020021H
	DD	066400H
	DD	imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+261
	DD	imagerel $unwind$bytesio_setstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_setstate DD 020521H
	DD	066405H
	DD	imagerel bytesio_setstate
	DD	imagerel bytesio_setstate+261
	DD	imagerel $unwind$bytesio_setstate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_setstate DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@
CONST	SEGMENT
??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@ DB '%.200s.__'
	DB	'setstate__ argument should be 3-tuple, got %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@
CONST	SEGMENT
??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@ DB 'third item'
	DB	' of state should be a dict, got a %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@
CONST	SEGMENT
??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@ DB 'position val'
	DB	'ue cannot be negative', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@
CONST	SEGMENT
??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@ DB 'second it'
	DB	'em of state must be an integer, not %.200s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_setstate
_TEXT	SEGMENT
self$ = 48
state$ = 56
bytesio_setstate PROC					; COMDAT

; 708  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 709  :     PyObject *result;
; 710  :     PyObject *position_obj;
; 711  :     PyObject *dict;
; 712  :     Py_ssize_t pos;
; 713  : 
; 714  :     assert(state != NULL);
; 715  : 
; 716  :     /* We allow the state tuple to be longer than 3, because we may need
; 717  :        someday to extend the object's state without breaking
; 718  :        backward-compatibility. */
; 719  :     if (!PyTuple_Check(state) || Py_SIZE(state) < 3) {

  0000a	4c 8b 4a 58	 mov	 r9, QWORD PTR [rdx+88]
  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx
  00014	41 f7 81 00 01
	00 00 00 00 00
	04		 test	 DWORD PTR [r9+256], 67108864 ; 04000000H
  0001f	0f 84 7f 01 00
	00		 je	 $LN11@bytesio_se@2
  00025	48 83 7a 60 03	 cmp	 QWORD PTR [rdx+96], 3
  0002a	0f 8c 74 01 00
	00		 jl	 $LN11@bytesio_se@2

; 723  :         return NULL;
; 724  :     }
; 725  :     CHECK_EXPORTS(self);

  00030	48 83 b9 90 00
	00 00 00	 cmp	 QWORD PTR [rcx+144], 0
  00038	7e 20		 jle	 SHORT $LN10@bytesio_se@2
  0003a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@NPKPJNBF@Existing?5exports?5of?5data?3?5object@
  00048	e8 00 00 00 00	 call	 PyErr_SetString
$LN18@bytesio_se@2:
  0004d	33 c0		 xor	 eax, eax

; 780  : }

  0004f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN10@bytesio_se@2:

; 726  :     /* Reset the object to its default state. This is only needed to handle
; 727  :        the case of repeated calls to __setstate__. */
; 728  :     self->string_size = 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 729  :     self->pos = 0;

  00060	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 730  : 
; 731  :     /* Set the value of the internal buffer. If state[0] does not support the
; 732  :        buffer protocol, bytesio_write will raise the appropriate TypeError. */
; 733  :     result = bytesio_write(self, PyTuple_GET_ITEM(state, 0));

  00064	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00068	e8 00 00 00 00	 call	 bytesio_write

; 734  :     if (result == NULL)

  0006d	48 85 c0	 test	 rax, rax

; 735  :         return NULL;

  00070	74 db		 je	 SHORT $LN18@bytesio_se@2

; 736  :     Py_DECREF(result);

  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 _Py_DecRef

; 737  : 
; 738  :     /* Set carefully the position value. Alternatively, we could use the seek
; 739  :        method instead of modifying self->pos directly to better protect the
; 740  :        object internal state against errneous (or malicious) inputs. */
; 741  :     position_obj = PyTuple_GET_ITEM(state, 1);

  0007a	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]

; 742  :     if (!PyLong_Check(position_obj)) {

  0007e	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  00082	41 f7 80 00 01
	00 00 00 00 00
	01		 test	 DWORD PTR [r8+256], 16777216 ; 01000000H
  0008d	75 24		 jne	 SHORT $LN8@bytesio_se@2

; 743  :         PyErr_Format(PyExc_TypeError,
; 744  :                      "second item of state must be an integer, not %.200s",
; 745  :                      Py_TYPE(position_obj)->tp_name);

  0008f	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00093	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GABJIGBE@second?5item?5of?5state?5must?5be?5an?5@
  000a1	e8 00 00 00 00	 call	 PyErr_Format

; 746  :         return NULL;

  000a6	33 c0		 xor	 eax, eax

; 780  : }

  000a8	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
$LN8@bytesio_se@2:

; 747  :     }
; 748  :     pos = PyLong_AsSsize_t(position_obj);

  000b3	e8 00 00 00 00	 call	 PyLong_AsSsize_t

; 749  :     if (pos == -1 && PyErr_Occurred())

  000b8	48 83 f8 ff	 cmp	 rax, -1
  000bc	75 17		 jne	 SHORT $LN7@bytesio_se@2
  000be	e8 00 00 00 00	 call	 PyErr_Occurred
  000c3	48 85 c0	 test	 rax, rax
  000c6	74 12		 je	 SHORT $LN15@bytesio_se@2

; 750  :         return NULL;

  000c8	33 c0		 xor	 eax, eax

; 780  : }

  000ca	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000cf	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
$LN7@bytesio_se@2:

; 751  :     if (pos < 0) {

  000d5	48 85 c0	 test	 rax, rax
  000d8	79 20		 jns	 SHORT $LN6@bytesio_se@2
$LN15@bytesio_se@2:

; 752  :         PyErr_SetString(PyExc_ValueError,
; 753  :                         "position value cannot be negative");

  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@PHIJAEHN@position?5value?5cannot?5be?5negativ@
  000e8	e8 00 00 00 00	 call	 PyErr_SetString

; 754  :         return NULL;

  000ed	33 c0		 xor	 eax, eax

; 780  : }

  000ef	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000f4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
$LN6@bytesio_se@2:

; 755  :     }
; 756  :     self->pos = pos;

  000fa	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 757  : 
; 758  :     /* Set the dictionary of the instance variables. */
; 759  :     dict = PyTuple_GET_ITEM(state, 2);

  000fe	48 8b bf 80 00
	00 00		 mov	 rdi, QWORD PTR [rdi+128]
  00105	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 760  :     if (dict != Py_None) {

  0010a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00111	48 3b fe	 cmp	 rdi, rsi
  00114	74 73		 je	 SHORT $LN1@bytesio_se@2

; 761  :         if (!PyDict_Check(dict)) {

  00116	4c 8b 47 58	 mov	 r8, QWORD PTR [rdi+88]
  0011a	41 f7 80 00 01
	00 00 00 00 00
	20		 test	 DWORD PTR [r8+256], 536870912 ; 20000000H
  00125	75 29		 jne	 SHORT $LN4@bytesio_se@2

; 762  :             PyErr_Format(PyExc_TypeError,
; 763  :                          "third item of state should be a dict, got a %.200s",
; 764  :                          Py_TYPE(dict)->tp_name);

  00127	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0012b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@LLMMLCL@third?5item?5of?5state?5should?5be?5a?5@
  00139	e8 00 00 00 00	 call	 PyErr_Format
  0013e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 765  :             return NULL;

  00143	33 c0		 xor	 eax, eax

; 780  : }

  00145	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0014a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0014e	5f		 pop	 rdi
  0014f	c3		 ret	 0
$LN4@bytesio_se@2:

; 766  :         }
; 767  :         if (self->dict) {

  00150	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00157	48 85 c9	 test	 rcx, rcx
  0015a	74 1e		 je	 SHORT $LN3@bytesio_se@2

; 768  :             /* Alternatively, we could replace the internal dictionary
; 769  :                completely. However, it seems more practical to just update it. */
; 770  :             if (PyDict_Update(self->dict, dict) < 0)

  0015c	48 8b d7	 mov	 rdx, rdi
  0015f	e8 00 00 00 00	 call	 PyDict_Update
  00164	85 c0		 test	 eax, eax
  00166	79 21		 jns	 SHORT $LN1@bytesio_se@2

; 765  :             return NULL;

  00168	33 c0		 xor	 eax, eax
  0016a	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 780  : }

  0016f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00174	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00178	5f		 pop	 rdi
  00179	c3		 ret	 0
$LN3@bytesio_se@2:

; 771  :                 return NULL;
; 772  :         }
; 773  :         else {
; 774  :             Py_INCREF(dict);

  0017a	48 8b cf	 mov	 rcx, rdi
  0017d	e8 00 00 00 00	 call	 _Py_IncRef

; 775  :             self->dict = dict;

  00182	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi
$LN1@bytesio_se@2:

; 776  :         }
; 777  :     }
; 778  : 
; 779  :     Py_RETURN_NONE;

  00189	48 8b ce	 mov	 rcx, rsi
  0018c	e8 00 00 00 00	 call	 _Py_IncRef
  00191	48 8b c6	 mov	 rax, rsi
  00194	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 780  : }

  00199	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0019e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a2	5f		 pop	 rdi
  001a3	c3		 ret	 0
$LN11@bytesio_se@2:

; 720  :         PyErr_Format(PyExc_TypeError,
; 721  :                      "%.200s.__setstate__ argument should be 3-tuple, got %.200s",
; 722  :                      Py_TYPE(self)->tp_name, Py_TYPE(state)->tp_name);

  001a4	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  001a8	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  001ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001b3	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  001b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@OPPOCNNE@?$CF?4200s?4__setstate__?5argument?5sho@
  001be	e8 00 00 00 00	 call	 PyErr_Format

; 780  : }

  001c3	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001c8	33 c0		 xor	 eax, eax
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5f		 pop	 rdi
  001cf	c3		 ret	 0
bytesio_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@ ; `string'
PUBLIC	??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@		; `string'
PUBLIC	??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@ ; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	PyErr_Print:PROC
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_dealloc DD imagerel bytesio_dealloc
	DD	imagerel bytesio_dealloc+246
	DD	imagerel $unwind$bytesio_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_dealloc DD imagerel bytesio_dealloc+246
	DD	imagerel bytesio_dealloc+375
	DD	imagerel $chain$0$bytesio_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytesio_dealloc DD imagerel bytesio_dealloc+375
	DD	imagerel bytesio_dealloc+412
	DD	imagerel $chain$1$bytesio_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytesio_dealloc DD 021H
	DD	imagerel bytesio_dealloc
	DD	imagerel bytesio_dealloc+246
	DD	imagerel $unwind$bytesio_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_dealloc DD 020521H
	DD	087405H
	DD	imagerel bytesio_dealloc
	DD	imagerel bytesio_dealloc+246
	DD	imagerel $unwind$bytesio_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_dealloc DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@
CONST	SEGMENT
??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@ DB 'deallocated '
	DB	'BytesIO object has exported buffers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
CONST	SEGMENT
??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@ DB 'bytesio_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@ DB '..\Modules\_io'
	DB	'\bytesio.c', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
CONST	ENDS
;	COMDAT bytesio_dealloc
_TEXT	SEGMENT
self$ = 64
bytesio_dealloc PROC					; COMDAT

; 784  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 785  :     _PyObject_GC_UNTRACK(self);

  00009	4c 8b c9	 mov	 r9, rcx
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  0001a	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  00020	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00028	e8 00 00 00 00	 call	 _PyParallel_Guard
  0002d	85 c0		 test	 eax, eax
  0002f	75 54		 jne	 SHORT $LN8@bytesio_de
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  0003f	4c 8b cb	 mov	 r9, rbx
  00042	41 b8 11 03 00
	00		 mov	 r8d, 785		; 00000311H
  00048	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	74 04		 je	 SHORT $LN14@bytesio_de
  00059	33 d2		 xor	 edx, edx
  0005b	eb 04		 jmp	 SHORT $LN15@bytesio_de
$LN14@bytesio_de:
  0005d	48 8d 53 e8	 lea	 rdx, QWORD PTR [rbx-24]
$LN15@bytesio_de:
  00061	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00064	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00068	48 c7 42 10 fe
	ff ff ff	 mov	 QWORD PTR [rdx+16], -2
  00070	48 89 01	 mov	 QWORD PTR [rcx], rax
  00073	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00076	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0007a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0007e	48 c7 02 00 00
	00 00		 mov	 QWORD PTR [rdx], 0
$LN8@bytesio_de:

; 786  :     if (self->exports > 0) {

  00085	48 83 bb 90 00
	00 00 00	 cmp	 QWORD PTR [rbx+144], 0
  0008d	7e 18		 jle	 SHORT $LN7@bytesio_de

; 787  :         PyErr_SetString(PyExc_SystemError,
; 788  :                         "deallocated BytesIO object has exported buffers");

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BICFODFJ@deallocated?5BytesIO?5object?5has?5e@
  0009d	e8 00 00 00 00	 call	 PyErr_SetString

; 789  :         PyErr_Print();

  000a2	e8 00 00 00 00	 call	 PyErr_Print
$LN7@bytesio_de:

; 790  :     }
; 791  :     if (self->buf != NULL) {

  000a7	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  000ab	48 85 c9	 test	 rcx, rcx
  000ae	74 0d		 je	 SHORT $LN5@bytesio_de

; 792  :         PyMem_Free(self->buf);

  000b0	e8 00 00 00 00	 call	 PyMem_Free

; 793  :         self->buf = NULL;

  000b5	48 c7 43 60 00
	00 00 00	 mov	 QWORD PTR [rbx+96], 0
$LN5@bytesio_de:

; 794  :     }
; 795  :     Py_CLEAR(self->dict);

  000bd	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  000c4	4d 85 c9	 test	 r9, r9
  000c7	0f 84 aa 00 00
	00		 je	 $LN4@bytesio_de
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KGDANJAP@bytesio_dealloc?$AA@
  000db	41 b8 1b 03 00
	00		 mov	 r8d, 795		; 0000031bH
  000e1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000e9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ee	85 c0		 test	 eax, eax
  000f0	0f 85 81 00 00
	00		 jne	 $LN4@bytesio_de
  000f6	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  000fb	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]
  00102	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0
  0010d	e8 00 00 00 00	 call	 _Py_PXCTX
  00112	85 c0		 test	 eax, eax
  00114	75 5c		 jne	 SHORT $LN27@bytesio_de
  00116	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  0011a	a8 20		 test	 al, 32			; 00000020H
  0011c	75 4c		 jne	 SHORT $LN20@bytesio_de
  0011e	84 c0		 test	 al, al
  00120	78 48		 js	 SHORT $LN20@bytesio_de
  00122	a8 02		 test	 al, 2
  00124	75 4c		 jne	 SHORT $LN27@bytesio_de
  00126	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  0012a	75 46		 jne	 SHORT $LN27@bytesio_de
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0013a	4c 8b cf	 mov	 r9, rdi
  0013d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00143	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0014b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00150	48 8b cf	 mov	 rcx, rdi
  00153	85 c0		 test	 eax, eax
  00155	74 07		 je	 SHORT $LN25@bytesio_de
  00157	e8 00 00 00 00	 call	 _Px_Dealloc
  0015c	eb 14		 jmp	 SHORT $LN27@bytesio_de
$LN25@bytesio_de:
  0015e	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00162	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00168	eb 08		 jmp	 SHORT $LN27@bytesio_de
$LN20@bytesio_de:
  0016a	48 8b cf	 mov	 rcx, rdi
  0016d	e8 00 00 00 00	 call	 Px_DecRef
$LN27@bytesio_de:
  00172	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
$LN4@bytesio_de:

; 796  :     if (self->weakreflist != NULL)

  00177	48 83 bb 88 00
	00 00 00	 cmp	 QWORD PTR [rbx+136], 0
  0017f	74 08		 je	 SHORT $LN1@bytesio_de

; 797  :         PyObject_ClearWeakRefs((PyObject *) self);

  00181	48 8b cb	 mov	 rcx, rbx
  00184	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN1@bytesio_de:

; 798  :     Py_TYPE(self)->tp_free(self);

  00189	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0018d	48 8b cb	 mov	 rcx, rbx

; 799  : }

  00190	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00194	5b		 pop	 rbx
  00195	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
bytesio_dealloc ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_new DD imagerel bytesio_new
	DD	imagerel bytesio_new+74
	DD	imagerel $unwind$bytesio_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_new DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesio_new
_TEXT	SEGMENT
type$ = 48
args$ = 56
kwds$ = 64
bytesio_new PROC					; COMDAT

; 803  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c1	 mov	 rax, rcx

; 804  :     bytesio *self;
; 805  : 
; 806  :     assert(type != NULL && type->tp_alloc != NULL);
; 807  :     self = (bytesio *)type->tp_alloc(type, 0);

  00009	33 d2		 xor	 edx, edx
  0000b	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00011	48 8b d8	 mov	 rbx, rax

; 808  :     if (self == NULL)

  00014	48 85 c0	 test	 rax, rax
  00017	75 06		 jne	 SHORT $LN2@bytesio_ne

; 821  : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@bytesio_ne:

; 809  :         return NULL;
; 810  : 
; 811  :     /* tp_alloc initializes all the fields to zero. So we don't have to
; 812  :        initialize them here. */
; 813  : 
; 814  :     self->buf = (char *)PyMem_Malloc(0);

  0001f	33 c9		 xor	 ecx, ecx
  00021	e8 00 00 00 00	 call	 PyMem_Malloc
  00026	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 815  :     if (self->buf == NULL) {

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 12		 jne	 SHORT $LN1@bytesio_ne

; 816  :         Py_DECREF(self);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 _Py_DecRef

; 821  : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN1@bytesio_ne:

; 817  :         return PyErr_NoMemory();
; 818  :     }
; 819  : 
; 820  :     return (PyObject *)self;

  00041	48 8b c3	 mov	 rax, rbx

; 821  : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
bytesio_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@		; `string'
PUBLIC	??_C@_0O@CIEEPJHK@initial_bytes?$AA@		; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_init DD imagerel bytesio_init
	DD	imagerel bytesio_init+158
	DD	imagerel $unwind$bytesio_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_init DD 040c01H
	DD	0a340cH
	DD	07008720cH
xdata	ENDS
;	COMDAT ??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@
CONST	SEGMENT
??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@ DB '|O:BytesIO', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CIEEPJHK@initial_bytes?$AA@
CONST	SEGMENT
??_C@_0O@CIEEPJHK@initial_bytes?$AA@ DB 'initial_bytes', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_init
_TEXT	SEGMENT
self$ = 80
args$ = 88
kwds$ = 96
initvalue$ = 104
bytesio_init PROC					; COMDAT

; 825  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 08	 mov	 QWORD PTR [r11+8], rbx
  00007	57		 push	 rdi
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	49 8b c0	 mov	 rax, r8
  00012	4c 8b d2	 mov	 r10, rdx

; 826  :     char *kwlist[] = {"initial_bytes", NULL};

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@CIEEPJHK@initial_bytes?$AA@
  0001c	33 ff		 xor	 edi, edi

; 827  :     PyObject *initvalue = NULL;
; 828  : 
; 829  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:BytesIO", kwlist,
; 830  :                                      &initvalue))

  0001e	4d 8d 4b e8	 lea	 r9, QWORD PTR [r11-24]
  00022	49 89 4b e8	 mov	 QWORD PTR [r11-24], rcx
  00026	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@BGOHJFDD@?$HMO?3BytesIO?$AA@
  00031	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00035	48 8b d0	 mov	 rdx, rax
  00038	49 8b ca	 mov	 rcx, r10
  0003b	49 89 7b f0	 mov	 QWORD PTR [r11-16], rdi
  0003f	49 89 7b 20	 mov	 QWORD PTR [r11+32], rdi
  00043	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00048	85 c0		 test	 eax, eax
  0004a	75 0e		 jne	 SHORT $LN3@bytesio_in
$LN6@bytesio_in:

; 831  :         return -1;

  0004c	83 c8 ff	 or	 eax, -1

; 847  : }

  0004f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00054	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN3@bytesio_in:

; 832  : 
; 833  :     /* In case, __init__ is called multiple times. */
; 834  :     self->string_size = 0;
; 835  :     self->pos = 0;
; 836  : 
; 837  :     if (initvalue && initvalue != Py_None) {

  0005a	48 8b 54 24 68	 mov	 rdx, QWORD PTR initvalue$[rsp]
  0005f	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi
  00063	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
  00067	48 85 d2	 test	 rdx, rdx
  0006a	74 25		 je	 SHORT $LN2@bytesio_in
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00073	48 3b d0	 cmp	 rdx, rax
  00076	74 19		 je	 SHORT $LN2@bytesio_in

; 838  :         PyObject *res;
; 839  :         res = bytesio_write(self, initvalue);

  00078	48 8b cb	 mov	 rcx, rbx
  0007b	e8 00 00 00 00	 call	 bytesio_write

; 840  :         if (res == NULL)

  00080	48 85 c0	 test	 rax, rax

; 841  :             return -1;

  00083	74 c7		 je	 SHORT $LN6@bytesio_in

; 842  :         Py_DECREF(res);

  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 843  :         self->pos = 0;

  0008d	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi
$LN2@bytesio_in:

; 844  :     }
; 845  : 
; 846  :     return 0;

  00091	33 c0		 xor	 eax, eax

; 847  : }

  00093	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00098	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
bytesio_init ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytesio_sizeof
_TEXT	SEGMENT
self$ = 8
unused$ = 16
bytesio_sizeof PROC					; COMDAT

; 851  : {

  00000	48 8b c1	 mov	 rax, rcx

; 852  :     Py_ssize_t res;
; 853  : 
; 854  :     res = sizeof(bytesio);

  00003	b9 a0 00 00 00	 mov	 ecx, 160		; 000000a0H

; 855  :     if (self->buf)

  00008	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0000d	74 07		 je	 SHORT $LN1@bytesio_si

; 856  :         res += self->buf_size;

  0000f	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00013	48 03 c8	 add	 rcx, rax
$LN1@bytesio_si:

; 857  :     return PyLong_FromSsize_t(res);
; 858  : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
bytesio_sizeof ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesio_traverse DD imagerel bytesio_traverse
	DD	imagerel bytesio_traverse+100
	DD	imagerel $unwind$bytesio_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@ DB 'bytesio_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesio_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
bytesio_traverse PROC					; COMDAT

; 862  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 863  :     Py_VISIT(self->dict);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@bytesio_tr@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@EDCFKHFH@bytesio_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 5f 03 00
	00		 mov	 r8d, 863		; 0000035fH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytesio_tr@2:
  0003d	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00044	48 85 c9	 test	 rcx, rcx
  00047	74 09		 je	 SHORT $LN5@bytesio_tr@2
  00049	48 8b d7	 mov	 rdx, rdi
  0004c	ff d6		 call	 rsi
  0004e	85 c0		 test	 eax, eax
  00050	75 02		 jne	 SHORT $LN7@bytesio_tr@2
$LN5@bytesio_tr@2:

; 864  :     return 0;

  00052	33 c0		 xor	 eax, eax
$LN7@bytesio_tr@2:

; 865  : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
bytesio_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MDPHEDOG@bytesio_clear?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesio_clear DD imagerel bytesio_clear
	DD	imagerel bytesio_clear+66
	DD	imagerel $unwind$bytesio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesio_clear DD imagerel bytesio_clear+66
	DD	imagerel bytesio_clear+181
	DD	imagerel $chain$0$bytesio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$bytesio_clear DD imagerel bytesio_clear+181
	DD	imagerel bytesio_clear+204
	DD	imagerel $chain$2$bytesio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bytesio_clear DD imagerel bytesio_clear+204
	DD	imagerel bytesio_clear+217
	DD	imagerel $chain$4$bytesio_clear
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$bytesio_clear DD imagerel bytesio_clear+217
	DD	imagerel bytesio_clear+225
	DD	imagerel $chain$5$bytesio_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$bytesio_clear DD 021H
	DD	imagerel bytesio_clear
	DD	imagerel bytesio_clear+66
	DD	imagerel $unwind$bytesio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bytesio_clear DD 020021H
	DD	083400H
	DD	imagerel bytesio_clear
	DD	imagerel bytesio_clear+66
	DD	imagerel $unwind$bytesio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$bytesio_clear DD 020021H
	DD	083400H
	DD	imagerel bytesio_clear
	DD	imagerel bytesio_clear+66
	DD	imagerel $unwind$bytesio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesio_clear DD 020521H
	DD	083405H
	DD	imagerel bytesio_clear
	DD	imagerel bytesio_clear+66
	DD	imagerel $unwind$bytesio_clear
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesio_clear DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0O@MDPHEDOG@bytesio_clear?$AA@
CONST	SEGMENT
??_C@_0O@MDPHEDOG@bytesio_clear?$AA@ DB 'bytesio_clear', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
CONST	ENDS
;	COMDAT bytesio_clear
_TEXT	SEGMENT
self$ = 64
bytesio_clear PROC					; COMDAT

; 869  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 870  :     Py_CLEAR(self->dict);

  00006	4c 8b 89 80 00
	00 00		 mov	 r9, QWORD PTR [rcx+128]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	4d 85 c9	 test	 r9, r9
  00013	0f 84 c0 00 00
	00		 je	 $LN21@bytesio_cl@2
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MDPHEDOG@bytesio_clear?$AA@
  00027	41 b8 66 03 00
	00		 mov	 r8d, 870		; 00000366H
  0002d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00035	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003a	85 c0		 test	 eax, eax
  0003c	0f 85 97 00 00
	00		 jne	 $LN21@bytesio_cl@2
  00042	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00047	48 8b 9f 80 00
	00 00		 mov	 rbx, QWORD PTR [rdi+128]
  0004e	48 c7 87 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rdi+128], 0
  00059	e8 00 00 00 00	 call	 _Py_PXCTX
  0005e	85 c0		 test	 eax, eax
  00060	75 72		 jne	 SHORT $LN22@bytesio_cl@2
  00062	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00066	a8 20		 test	 al, 32			; 00000020H
  00068	75 62		 jne	 SHORT $LN11@bytesio_cl@2
  0006a	84 c0		 test	 al, al
  0006c	78 5e		 js	 SHORT $LN11@bytesio_cl@2
  0006e	a8 02		 test	 al, 2
  00070	75 62		 jne	 SHORT $LN22@bytesio_cl@2
  00072	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00076	75 5c		 jne	 SHORT $LN22@bytesio_cl@2
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00086	4c 8b cb	 mov	 r9, rbx
  00089	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0008f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00097	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009c	48 8b cb	 mov	 rcx, rbx
  0009f	85 c0		 test	 eax, eax
  000a1	74 12		 je	 SHORT $LN16@bytesio_cl@2
  000a3	e8 00 00 00 00	 call	 _Px_Dealloc
  000a8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 871  :     return 0;

  000ad	33 c0		 xor	 eax, eax

; 872  : }

  000af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0

; 870  :     Py_CLEAR(self->dict);

$LN16@bytesio_cl@2:
  000b5	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000b9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000bf	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 871  :     return 0;

  000c4	33 c0		 xor	 eax, eax

; 872  : }

  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0

; 870  :     Py_CLEAR(self->dict);

$LN11@bytesio_cl@2:
  000cc	48 8b cb	 mov	 rcx, rbx
  000cf	e8 00 00 00 00	 call	 Px_DecRef
$LN22@bytesio_cl@2:
  000d4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN21@bytesio_cl@2:

; 871  :     return 0;

  000d9	33 c0		 xor	 eax, eax

; 872  : }

  000db	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
bytesio_clear ENDP
_TEXT	ENDS
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_getbuffer DD imagerel bytesiobuf_getbuffer
	DD	imagerel bytesiobuf_getbuffer+80
	DD	imagerel $unwind$bytesiobuf_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_getbuffer DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bytesiobuf_getbuffer
_TEXT	SEGMENT
obj$ = 64
view$ = 72
flags$ = 80
bytesiobuf_getbuffer PROC				; COMDAT

; 963  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 964  :     int ret;
; 965  :     bytesio *b = (bytesio *) obj->source;

  00006	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  0000a	48 8b c2	 mov	 rax, rdx

; 966  :     if (view == NULL) {

  0000d	48 85 d2	 test	 rdx, rdx
  00010	75 0d		 jne	 SHORT $LN2@bytesiobuf

; 967  :         b->exports++;

  00012	48 ff 83 90 00
	00 00		 inc	 QWORD PTR [rbx+144]

; 974  :     }
; 975  :     return ret;
; 976  : }

  00019	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@bytesiobuf:

; 968  :         return 0;
; 969  :     }
; 970  :     ret = PyBuffer_FillInfo(view, (PyObject*)obj, b->buf, b->string_size,
; 971  :                             0, flags);

  0001f	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  00023	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00028	4c 8b 43 60	 mov	 r8, QWORD PTR [rbx+96]
  0002c	48 8b d1	 mov	 rdx, rcx
  0002f	48 8b c8	 mov	 rcx, rax
  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0003a	e8 00 00 00 00	 call	 PyBuffer_FillInfo

; 972  :     if (ret >= 0) {

  0003f	85 c0		 test	 eax, eax
  00041	78 07		 js	 SHORT $LN1@bytesiobuf

; 973  :         b->exports++;

  00043	48 ff 83 90 00
	00 00		 inc	 QWORD PTR [rbx+144]
$LN1@bytesiobuf:

; 974  :     }
; 975  :     return ret;
; 976  : }

  0004a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
bytesiobuf_getbuffer ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT bytesiobuf_releasebuffer
_TEXT	SEGMENT
obj$ = 8
view$ = 16
bytesiobuf_releasebuffer PROC				; COMDAT

; 981  :     bytesio *b = (bytesio *) obj->source;

  00000	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 982  :     b->exports--;

  00004	48 ff 88 90 00
	00 00		 dec	 QWORD PTR [rax+144]

; 983  : }

  0000b	c3		 ret	 0
bytesiobuf_releasebuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bytesiobuf_traverse DD imagerel bytesiobuf_traverse
	DD	imagerel bytesiobuf_traverse+97
	DD	imagerel $unwind$bytesiobuf_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_traverse DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@
CONST	SEGMENT
??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@ DB 'bytesiobuf_traverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT bytesiobuf_traverse
_TEXT	SEGMENT
self$ = 48
visit$ = 56
arg$ = 64
bytesiobuf_traverse PROC				; COMDAT

; 987  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 988  :     Py_VISIT(self->source);

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN3@bytesiobuf@2
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@KBCMCEEL@bytesiobuf_traverse?$AA@
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 dc 03 00
	00		 mov	 r8d, 988		; 000003dcH
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@bytesiobuf@2:
  0003d	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00041	48 85 c9	 test	 rcx, rcx
  00044	74 09		 je	 SHORT $LN5@bytesiobuf@2
  00046	48 8b d7	 mov	 rdx, rdi
  00049	ff d6		 call	 rsi
  0004b	85 c0		 test	 eax, eax
  0004d	75 02		 jne	 SHORT $LN7@bytesiobuf@2
$LN5@bytesiobuf@2:

; 989  :     return 0;

  0004f	33 c0		 xor	 eax, eax
$LN7@bytesiobuf@2:

; 990  : }

  00051	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00056	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
bytesiobuf_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$bytesiobuf_dealloc DD imagerel bytesiobuf_dealloc
	DD	imagerel bytesiobuf_dealloc+59
	DD	imagerel $unwind$bytesiobuf_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$bytesiobuf_dealloc DD imagerel bytesiobuf_dealloc+59
	DD	imagerel bytesiobuf_dealloc+182
	DD	imagerel $chain$0$bytesiobuf_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bytesiobuf_dealloc DD imagerel bytesiobuf_dealloc+182
	DD	imagerel bytesiobuf_dealloc+201
	DD	imagerel $chain$1$bytesiobuf_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bytesiobuf_dealloc DD 021H
	DD	imagerel bytesiobuf_dealloc
	DD	imagerel bytesiobuf_dealloc+59
	DD	imagerel $unwind$bytesiobuf_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$bytesiobuf_dealloc DD 020521H
	DD	083405H
	DD	imagerel bytesiobuf_dealloc
	DD	imagerel bytesiobuf_dealloc+59
	DD	imagerel $unwind$bytesiobuf_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bytesiobuf_dealloc DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@
CONST	SEGMENT
??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@ DB 'bytesiobuf_dealloc', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_io\bytesio.c
CONST	ENDS
;	COMDAT bytesiobuf_dealloc
_TEXT	SEGMENT
self$ = 64
bytesiobuf_dealloc PROC					; COMDAT

; 994  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 995  :     Py_CLEAR(self->source);

  00006	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	4d 85 c9	 test	 r9, r9
  00010	0f 84 a0 00 00
	00		 je	 $LN3@bytesiobuf@3
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@KGBEFPOJ@?4?4?2Modules?2_io?2bytesio?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@BHMJNBMG@bytesiobuf_dealloc?$AA@
  00024	41 b8 e3 03 00
	00		 mov	 r8d, 995		; 000003e3H
  0002a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00032	e8 00 00 00 00	 call	 _PyParallel_Guard
  00037	85 c0		 test	 eax, eax
  00039	75 7b		 jne	 SHORT $LN3@bytesiobuf@3
  0003b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00040	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00044	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  0004c	e8 00 00 00 00	 call	 _Py_PXCTX
  00051	85 c0		 test	 eax, eax
  00053	75 5c		 jne	 SHORT $LN18@bytesiobuf@3
  00055	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00059	a8 20		 test	 al, 32			; 00000020H
  0005b	75 4c		 jne	 SHORT $LN11@bytesiobuf@3
  0005d	84 c0		 test	 al, al
  0005f	78 48		 js	 SHORT $LN11@bytesiobuf@3
  00061	a8 02		 test	 al, 2
  00063	75 4c		 jne	 SHORT $LN18@bytesiobuf@3
  00065	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00069	75 46		 jne	 SHORT $LN18@bytesiobuf@3
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00079	4c 8b cb	 mov	 r9, rbx
  0007c	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00082	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0008a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008f	48 8b cb	 mov	 rcx, rbx
  00092	85 c0		 test	 eax, eax
  00094	74 07		 je	 SHORT $LN16@bytesiobuf@3
  00096	e8 00 00 00 00	 call	 _Px_Dealloc
  0009b	eb 14		 jmp	 SHORT $LN18@bytesiobuf@3
$LN16@bytesiobuf@3:
  0009d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a1	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a7	eb 08		 jmp	 SHORT $LN18@bytesiobuf@3
$LN11@bytesiobuf@3:
  000a9	48 8b cb	 mov	 rcx, rbx
  000ac	e8 00 00 00 00	 call	 Px_DecRef
$LN18@bytesiobuf@3:
  000b1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN3@bytesiobuf@3:

; 996  :     Py_TYPE(self)->tp_free(self);

  000b6	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  000ba	48 8b cf	 mov	 rcx, rdi

; 997  : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
bytesiobuf_dealloc ENDP
_TEXT	ENDS
END
