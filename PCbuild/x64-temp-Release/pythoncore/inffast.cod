; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	inflate_fast
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\inffast.c
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN86
	DD	imagerel $LN86+1250
	DD	imagerel $unwind$inflate_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT inflate_fast
_TEXT	SEGMENT
whave$1$ = 0
dcode$1$ = 8
lcode$1$ = 16
beg$1$ = 24
window$1$ = 32
tv325 = 40
strm$ = 128
here$ = 136
start$ = 136
wsize$1$ = 144
dmask$1$ = 152
inflate_fast PROC					; COMDAT

; 70   : {

$LN86:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   :     struct inflate_state FAR *state;
; 72   :     unsigned char FAR *in;      /* local strm->next_in */
; 73   :     unsigned char FAR *last;    /* while in < last, enough input available */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 79 28	 mov	 r15, QWORD PTR [rcx+40]

; 99   :     in = strm->next_in - OFF;
; 100  :     last = in + (strm->avail_in - 5);

  00019	44 8b 71 08	 mov	 r14d, DWORD PTR [rcx+8]
  0001d	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 101  :     out = strm->next_out - OFF;

  00020	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 102  :     beg = out - (start - strm->avail_out);

  00024	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]

; 103  :     end = out + (strm->avail_out - 257);
; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;
; 108  :     whave = state->whave;
; 109  :     wnext = state->wnext;
; 110  :     window = state->window;
; 111  :     hold = state->hold;
; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  00027	4d 8b 4f 58	 mov	 r9, QWORD PTR [r15+88]

; 114  :     dcode = state->distcode;

  0002b	49 8b 7f 60	 mov	 rdi, QWORD PTR [r15+96]
  0002f	45 8b 67 34	 mov	 r12d, DWORD PTR [r15+52]
  00033	41 8b 5f 40	 mov	 ebx, DWORD PTR [r15+64]
  00037	45 8b 5f 44	 mov	 r11d, DWORD PTR [r15+68]
  0003b	2b d1		 sub	 edx, ecx
  0003d	49 ff c8	 dec	 r8
  00040	8b c2		 mov	 eax, edx
  00042	44 8d a9 ff fe
	ff ff		 lea	 r13d, DWORD PTR [rcx-257]

; 115  :     lmask = (1U << state->lenbits) - 1;

  00049	41 8b 4f 68	 mov	 ecx, DWORD PTR [r15+104]
  0004d	bd 01 00 00 00	 mov	 ebp, 1
  00052	49 8b d0	 mov	 rdx, r8
  00055	48 ff ce	 dec	 rsi
  00058	48 2b d0	 sub	 rdx, rax
  0005b	41 8b 47 2c	 mov	 eax, DWORD PTR [r15+44]
  0005f	41 83 c6 fb	 add	 r14d, -5
  00063	89 84 24 90 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  0006a	41 8b 47 30	 mov	 eax, DWORD PTR [r15+48]
  0006e	48 89 54 24 18	 mov	 QWORD PTR beg$1$[rsp], rdx
  00073	89 04 24	 mov	 DWORD PTR whave$1$[rsp], eax
  00076	49 8b 47 38	 mov	 rax, QWORD PTR [r15+56]

; 116  :     dmask = (1U << state->distbits) - 1;

  0007a	8b d5		 mov	 edx, ebp
  0007c	48 89 44 24 20	 mov	 QWORD PTR window$1$[rsp], rax
  00081	8b c5		 mov	 eax, ebp
  00083	4c 03 f6	 add	 r14, rsi
  00086	d3 e0		 shl	 eax, cl
  00088	41 8b 4f 6c	 mov	 ecx, DWORD PTR [r15+108]
  0008c	4d 03 e8	 add	 r13, r8
  0008f	d3 e2		 shl	 edx, cl
  00091	ff c8		 dec	 eax
  00093	4c 89 4c 24 10	 mov	 QWORD PTR lcode$1$[rsp], r9
  00098	ff ca		 dec	 edx
  0009a	48 89 7c 24 08	 mov	 QWORD PTR dcode$1$[rsp], rdi
  0009f	89 94 24 98 00
	00 00		 mov	 DWORD PTR dmask$1$[rsp], edx

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  000a6	8b d0		 mov	 edx, eax
  000a8	48 89 54 24 28	 mov	 QWORD PTR tv325[rsp], rdx
  000ad	0f 1f 00	 npad	 3
$LL55@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  000b0	41 83 fb 0f	 cmp	 r11d, 15
  000b4	73 1e		 jae	 SHORT $LN52@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  000b6	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  000ba	41 8b cb	 mov	 ecx, r11d

; 123  :             bits += 8;
; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  000bd	48 83 c6 02	 add	 rsi, 2
  000c1	d3 e0		 shl	 eax, cl
  000c3	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  000c7	03 d8		 add	 ebx, eax
  000c9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000cc	d3 e0		 shl	 eax, cl
  000ce	03 d8		 add	 ebx, eax

; 125  :             bits += 8;

  000d0	41 83 c3 10	 add	 r11d, 16
$LN52@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000d4	8b c3		 mov	 eax, ebx
  000d6	48 23 c2	 and	 rax, rdx
  000d9	45 8b 14 81	 mov	 r10d, DWORD PTR [r9+rax*4]

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);

  000dd	41 8b c2	 mov	 eax, r10d

; 130  :         hold >>= op;
; 131  :         bits -= op;
; 132  :         op = (unsigned)(here.op);

  000e0	41 0f b6 d2	 movzx	 edx, r10b
  000e4	c1 e8 08	 shr	 eax, 8
  000e7	0f b6 c8	 movzx	 ecx, al
  000ea	d3 eb		 shr	 ebx, cl
  000ec	44 2b d9	 sub	 r11d, ecx

; 133  :         if (op == 0) {                          /* literal */

  000ef	45 84 d2	 test	 r10b, r10b
  000f2	74 3a		 je	 SHORT $LN72@inflate_fa
$dolen$4886:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  000f4	f6 c2 10	 test	 dl, 16
  000f7	75 44		 jne	 SHORT $LN73@inflate_fa

; 291  :             }
; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  000f9	f6 c2 40	 test	 dl, 64			; 00000040H
  000fc	0f 85 19 03 00
	00		 jne	 $LN5@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  00102	8b ca		 mov	 ecx, edx
  00104	41 c1 ea 10	 shr	 r10d, 16
  00108	8b c5		 mov	 eax, ebp
  0010a	d3 e0		 shl	 eax, cl
  0010c	ff c8		 dec	 eax
  0010e	23 c3		 and	 eax, ebx
  00110	41 03 c2	 add	 eax, r10d
  00113	45 8b 14 81	 mov	 r10d, DWORD PTR [r9+rax*4]
  00117	41 8b c2	 mov	 eax, r10d
  0011a	41 0f b6 d2	 movzx	 edx, r10b
  0011e	c1 e8 08	 shr	 eax, 8
  00121	0f b6 c8	 movzx	 ecx, al
  00124	d3 eb		 shr	 ebx, cl
  00126	44 2b d9	 sub	 r11d, ecx
  00129	45 84 d2	 test	 r10b, r10b
  0012c	75 c6		 jne	 SHORT $dolen$4886
$LN72@inflate_fa:

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  0012e	49 ff c0	 inc	 r8
  00131	41 c1 ea 10	 shr	 r10d, 16
  00135	45 88 10	 mov	 BYTE PTR [r8], r10b
  00138	e9 ca 02 00 00	 jmp	 $LN54@inflate_fa
$LN73@inflate_fa:

; 140  :             len = (unsigned)(here.val);

  0013d	41 c1 ea 10	 shr	 r10d, 16

; 141  :             op &= 15;                           /* number of extra bits */

  00141	83 e2 0f	 and	 edx, 15

; 142  :             if (op) {

  00144	74 29		 je	 SHORT $LN48@inflate_fa

; 143  :                 if (bits < op) {

  00146	44 3b da	 cmp	 r11d, edx
  00149	73 12		 jae	 SHORT $LN47@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  0014b	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  0014f	48 ff c6	 inc	 rsi
  00152	41 8b cb	 mov	 ecx, r11d
  00155	d3 e0		 shl	 eax, cl
  00157	03 d8		 add	 ebx, eax

; 145  :                     bits += 8;

  00159	41 83 c3 08	 add	 r11d, 8
$LN47@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  0015d	8b ca		 mov	 ecx, edx
  0015f	8b c5		 mov	 eax, ebp
  00161	d3 e0		 shl	 eax, cl
  00163	ff c8		 dec	 eax
  00165	23 c3		 and	 eax, ebx

; 148  :                 hold >>= op;

  00167	d3 eb		 shr	 ebx, cl
  00169	44 03 d0	 add	 r10d, eax

; 149  :                 bits -= op;

  0016c	44 2b da	 sub	 r11d, edx
$LN48@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {

  0016f	41 83 fb 0f	 cmp	 r11d, 15
  00173	73 1e		 jae	 SHORT $LN46@inflate_fa

; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  00175	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00179	41 8b cb	 mov	 ecx, r11d

; 154  :                 bits += 8;
; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  0017c	48 83 c6 02	 add	 rsi, 2
  00180	d3 e0		 shl	 eax, cl
  00182	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  00186	03 d8		 add	 ebx, eax
  00188	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0018b	d3 e0		 shl	 eax, cl
  0018d	03 d8		 add	 ebx, eax

; 156  :                 bits += 8;

  0018f	41 83 c3 10	 add	 r11d, 16
$LN46@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  00193	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR dmask$1$[rsp]
  0019a	8b c3		 mov	 eax, ebx
  0019c	48 23 c8	 and	 rcx, rax
  0019f	8b 3c 8f	 mov	 edi, DWORD PTR [rdi+rcx*4]

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);

  001a2	8b c7		 mov	 eax, edi

; 161  :             hold >>= op;
; 162  :             bits -= op;
; 163  :             op = (unsigned)(here.op);

  001a4	40 0f b6 d7	 movzx	 edx, dil
  001a8	89 bc 24 88 00
	00 00		 mov	 DWORD PTR here$[rsp], edi
  001af	c1 e8 08	 shr	 eax, 8
  001b2	0f b6 c8	 movzx	 ecx, al
  001b5	d3 eb		 shr	 ebx, cl
  001b7	44 2b d9	 sub	 r11d, ecx

; 164  :             if (op & 16) {                      /* distance base */

  001ba	f6 c2 10	 test	 dl, 16
  001bd	75 43		 jne	 SHORT $LN74@inflate_fa
  001bf	90		 npad	 1
$dodist$4901:

; 280  :                     }
; 281  :                 }
; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001c0	f6 c2 40	 test	 dl, 64			; 00000040H
  001c3	0f 85 7c 02 00
	00		 jne	 $LN8@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001c9	0f b7 84 24 8a
	00 00 00	 movzx	 eax, WORD PTR here$[rsp+2]
  001d1	8b ca		 mov	 ecx, edx
  001d3	8b d5		 mov	 edx, ebp
  001d5	d3 e2		 shl	 edx, cl
  001d7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dcode$1$[rsp]
  001dc	ff ca		 dec	 edx
  001de	23 d3		 and	 edx, ebx
  001e0	03 d0		 add	 edx, eax
  001e2	8b 3c 91	 mov	 edi, DWORD PTR [rcx+rdx*4]
  001e5	8b c7		 mov	 eax, edi
  001e7	40 0f b6 d7	 movzx	 edx, dil
  001eb	89 bc 24 88 00
	00 00		 mov	 DWORD PTR here$[rsp], edi
  001f2	c1 e8 08	 shr	 eax, 8
  001f5	0f b6 c8	 movzx	 ecx, al
  001f8	d3 eb		 shr	 ebx, cl
  001fa	44 2b d9	 sub	 r11d, ecx
  001fd	f6 c2 10	 test	 dl, 16
  00200	74 be		 je	 SHORT $dodist$4901
$LN74@inflate_fa:

; 165  :                 dist = (unsigned)(here.val);
; 166  :                 op &= 15;                       /* number of extra bits */

  00202	83 e2 0f	 and	 edx, 15
  00205	c1 ef 10	 shr	 edi, 16

; 167  :                 if (bits < op) {

  00208	44 3b da	 cmp	 r11d, edx
  0020b	73 29		 jae	 SHORT $LN43@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  0020d	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00211	48 ff c6	 inc	 rsi
  00214	41 8b cb	 mov	 ecx, r11d
  00217	d3 e0		 shl	 eax, cl

; 169  :                     bits += 8;

  00219	41 83 c3 08	 add	 r11d, 8
  0021d	03 d8		 add	 ebx, eax

; 170  :                     if (bits < op) {

  0021f	44 3b da	 cmp	 r11d, edx
  00222	73 12		 jae	 SHORT $LN43@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  00224	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00228	48 ff c6	 inc	 rsi
  0022b	41 8b cb	 mov	 ecx, r11d
  0022e	d3 e0		 shl	 eax, cl
  00230	03 d8		 add	 ebx, eax

; 172  :                         bits += 8;

  00232	41 83 c3 08	 add	 r11d, 8
$LN43@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  00236	8b ca		 mov	 ecx, edx
  00238	8b c5		 mov	 eax, ebp

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;
; 184  :                 bits -= op;

  0023a	44 2b da	 sub	 r11d, edx
  0023d	d3 e0		 shl	 eax, cl
  0023f	ff c8		 dec	 eax
  00241	23 c3		 and	 eax, ebx
  00243	d3 eb		 shr	 ebx, cl
  00245	03 f8		 add	 edi, eax

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */

  00247	41 8b c0	 mov	 eax, r8d
  0024a	2b 44 24 18	 sub	 eax, DWORD PTR beg$1$[rsp]

; 187  :                 if (dist > op) {                /* see if copy from window */

  0024e	3b f8		 cmp	 edi, eax
  00250	0f 86 50 01 00
	00		 jbe	 $LN42@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00256	8b cf		 mov	 ecx, edi
  00258	2b c8		 sub	 ecx, eax

; 189  :                     if (op > whave) {

  0025a	3b 0c 24	 cmp	 ecx, DWORD PTR whave$1$[rsp]
  0025d	76 0e		 jbe	 SHORT $LN40@inflate_fa

; 190  :                         if (state->sane) {

  0025f	41 83 bf d8 1b
	00 00 00	 cmp	 DWORD PTR [r15+7128], 0
  00267	0f 85 f4 01 00
	00		 jne	 $LN75@inflate_fa
$LN40@inflate_fa:

; 194  :                             break;
; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  0026d	48 8b 54 24 20	 mov	 rdx, QWORD PTR window$1$[rsp]
  00272	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]

; 217  :                     if (wnext == 0) {           /* very common case */

  00276	45 85 e4	 test	 r12d, r12d
  00279	75 39		 jne	 SHORT $LN39@inflate_fa

; 218  :                         from += wsize - op;

  0027b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR wsize$1$[rsp]
  00282	2b c1		 sub	 eax, ecx
  00284	4c 03 c8	 add	 r9, rax

; 219  :                         if (op < len) {         /* some from window */

  00287	41 3b ca	 cmp	 ecx, r10d
  0028a	0f 83 aa 00 00
	00		 jae	 $LN69@inflate_fa

; 220  :                             len -= op;

  00290	44 2b d1	 sub	 r10d, ecx
  00293	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL37@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  002a0	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  002a5	49 ff c1	 inc	 r9
  002a8	49 ff c0	 inc	 r8

; 223  :                             } while (--op);

  002ab	ff c9		 dec	 ecx
  002ad	41 88 00	 mov	 BYTE PTR [r8], al
  002b0	75 ee		 jne	 SHORT $LL37@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */
; 225  :                         }

  002b2	eb 7e		 jmp	 SHORT $LN85@inflate_fa
$LN39@inflate_fa:

; 226  :                     }
; 227  :                     else if (wnext < op) {      /* wrap around window */
; 228  :                         from += wsize + wnext - op;

  002b4	41 8b c4	 mov	 eax, r12d
  002b7	2b c1		 sub	 eax, ecx
  002b9	44 3b e1	 cmp	 r12d, ecx
  002bc	73 56		 jae	 SHORT $LN33@inflate_fa
  002be	03 84 24 90 00
	00 00		 add	 eax, DWORD PTR wsize$1$[rsp]

; 229  :                         op -= wnext;

  002c5	41 2b cc	 sub	 ecx, r12d
  002c8	4c 03 c8	 add	 r9, rax

; 230  :                         if (op < len) {         /* some from end of window */

  002cb	41 3b ca	 cmp	 ecx, r10d
  002ce	73 6a		 jae	 SHORT $LN69@inflate_fa

; 231  :                             len -= op;

  002d0	44 2b d1	 sub	 r10d, ecx

; 234  :                             } while (--op);

  002d3	4d 2b c8	 sub	 r9, r8
  002d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL31@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  002e0	43 0f b6 44 01
	01		 movzx	 eax, BYTE PTR [r9+r8+1]
  002e6	49 ff c0	 inc	 r8

; 234  :                             } while (--op);

  002e9	ff c9		 dec	 ecx
  002eb	41 88 00	 mov	 BYTE PTR [r8], al
  002ee	75 f0		 jne	 SHORT $LL31@inflate_fa

; 235  :                             from = window - OFF;

  002f0	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]

; 236  :                             if (wnext < len) {  /* some from start of window */

  002f4	45 3b e2	 cmp	 r12d, r10d
  002f7	73 41		 jae	 SHORT $LN69@inflate_fa

; 237  :                                 op = wnext;

  002f9	41 8b cc	 mov	 ecx, r12d

; 238  :                                 len -= op;

  002fc	45 2b d4	 sub	 r10d, r12d
  002ff	90		 npad	 1
$LL27@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  00300	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00305	49 ff c1	 inc	 r9
  00308	49 ff c0	 inc	 r8

; 241  :                                 } while (--op);

  0030b	ff c9		 dec	 ecx
  0030d	41 88 00	 mov	 BYTE PTR [r8], al
  00310	75 ee		 jne	 SHORT $LL27@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */
; 243  :                             }
; 244  :                         }
; 245  :                     }
; 246  :                     else {                      /* contiguous in window */

  00312	eb 1e		 jmp	 SHORT $LN85@inflate_fa
$LN33@inflate_fa:

; 247  :                         from += wnext - op;

  00314	4c 03 c8	 add	 r9, rax

; 248  :                         if (op < len) {         /* some from window */

  00317	41 3b ca	 cmp	 ecx, r10d
  0031a	73 1e		 jae	 SHORT $LN69@inflate_fa

; 249  :                             len -= op;

  0031c	44 2b d1	 sub	 r10d, ecx
  0031f	90		 npad	 1
$LL22@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  00320	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00325	49 ff c1	 inc	 r9
  00328	49 ff c0	 inc	 r8

; 252  :                             } while (--op);

  0032b	ff c9		 dec	 ecx
  0032d	41 88 00	 mov	 BYTE PTR [r8], al
  00330	75 ee		 jne	 SHORT $LL22@inflate_fa
$LN85@inflate_fa:

; 253  :                             from = out - dist;  /* rest from output */

  00332	8b c7		 mov	 eax, edi
  00334	4d 8b c8	 mov	 r9, r8
  00337	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:

; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  0033a	41 83 fa 02	 cmp	 r10d, 2
  0033e	76 3a		 jbe	 SHORT $LN18@inflate_fa
  00340	41 8d 4a fd	 lea	 ecx, DWORD PTR [r10-3]
  00344	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00349	f7 e1		 mul	 ecx
  0034b	d1 ea		 shr	 edx, 1
  0034d	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
$LL19@inflate_fa:

; 257  :                         PUP(out) = PUP(from);

  00350	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 258  :                         PUP(out) = PUP(from);
; 259  :                         PUP(out) = PUP(from);

  00355	49 83 c1 03	 add	 r9, 3
  00359	49 83 c0 03	 add	 r8, 3
  0035d	41 88 40 fe	 mov	 BYTE PTR [r8-2], al
  00361	41 0f b6 41 ff	 movzx	 eax, BYTE PTR [r9-1]

; 260  :                         len -= 3;

  00366	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  0036a	48 ff c9	 dec	 rcx
  0036d	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  00371	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00375	41 88 00	 mov	 BYTE PTR [r8], al
  00378	75 d6		 jne	 SHORT $LL19@inflate_fa
$LN18@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  0037a	45 85 d2	 test	 r10d, r10d
  0037d	74 7e		 je	 SHORT $LN79@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  0037f	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 266  :                     }
; 267  :                 }
; 268  :                 else {

  00384	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  00389	49 ff c0	 inc	 r8
  0038c	41 88 00	 mov	 BYTE PTR [r8], al
  0038f	44 3b d5	 cmp	 r10d, ebp
  00392	76 0b		 jbe	 SHORT $LN80@inflate_fa

; 264  :                         if (len > 1)
; 265  :                             PUP(out) = PUP(from);

  00394	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00399	49 ff c0	 inc	 r8
  0039c	41 88 00	 mov	 BYTE PTR [r8], al
$LN80@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {

  0039f	4c 8b 4c 24 10	 mov	 r9, QWORD PTR lcode$1$[rsp]
  003a4	eb 61		 jmp	 SHORT $LN54@inflate_fa
$LN42@inflate_fa:

; 269  :                     from = out - dist;          /* copy direct from output */

  003a6	8b c7		 mov	 eax, edi
  003a8	49 8b c8	 mov	 rcx, r8
  003ab	48 2b c8	 sub	 rcx, rax
  003ae	66 90		 npad	 2
$LL14@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  003b0	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 272  :                         PUP(out) = PUP(from);
; 273  :                         PUP(out) = PUP(from);

  003b4	48 83 c1 03	 add	 rcx, 3
  003b8	49 83 c0 03	 add	 r8, 3
  003bc	41 88 40 fe	 mov	 BYTE PTR [r8-2], al
  003c0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]

; 274  :                         len -= 3;

  003c4	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  003c8	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  003cc	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  003cf	41 88 00	 mov	 BYTE PTR [r8], al

; 275  :                     } while (len > 2);

  003d2	41 83 fa 02	 cmp	 r10d, 2
  003d6	77 d8		 ja	 SHORT $LL14@inflate_fa

; 276  :                     if (len) {

  003d8	45 85 d2	 test	 r10d, r10d
  003db	74 25		 je	 SHORT $LN82@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  003dd	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 278  :                         if (len > 1)
; 279  :                             PUP(out) = PUP(from);

  003e1	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  003e6	49 ff c0	 inc	 r8
  003e9	41 88 00	 mov	 BYTE PTR [r8], al
  003ec	44 3b d5	 cmp	 r10d, ebp
  003ef	76 16		 jbe	 SHORT $LN54@inflate_fa
  003f1	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  003f5	49 ff c0	 inc	 r8
  003f8	41 88 00	 mov	 BYTE PTR [r8], al
  003fb	eb 0a		 jmp	 SHORT $LN54@inflate_fa
$LN79@inflate_fa:

; 103  :     end = out + (strm->avail_out - 257);
; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;
; 108  :     whave = state->whave;
; 109  :     wnext = state->wnext;
; 110  :     window = state->window;
; 111  :     hold = state->hold;
; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  003fd	4c 8b 4c 24 10	 mov	 r9, QWORD PTR lcode$1$[rsp]
$LN82@inflate_fa:
  00402	48 8b 7c 24 08	 mov	 rdi, QWORD PTR dcode$1$[rsp]
$LN54@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  00407	49 3b f6	 cmp	 rsi, r14
  0040a	73 71		 jae	 SHORT $LN84@inflate_fa
  0040c	4d 3b c5	 cmp	 r8, r13
  0040f	73 6c		 jae	 SHORT $LN84@inflate_fa
  00411	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv325[rsp]
  00416	e9 95 fc ff ff	 jmp	 $LL55@inflate_fa
$LN5@inflate_fa:

; 295  :             goto dolen;
; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */

  0041b	f6 c2 20	 test	 dl, 32			; 00000020H

; 300  :             break;

  0041e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00426	74 09		 je	 SHORT $LN3@inflate_fa

; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  00428	41 c7 07 0b 00
	00 00		 mov	 DWORD PTR [r15], 11

; 300  :             break;

  0042f	eb 54		 jmp	 SHORT $LN53@inflate_fa
$LN3@inflate_fa:

; 301  :         }
; 302  :         else {
; 303  :             strm->msg = (char *)"invalid literal/length code";

  00431	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00438	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 304  :             state->mode = BAD;

  0043c	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  00443	eb 40		 jmp	 SHORT $LN53@inflate_fa
$LN8@inflate_fa:

; 285  :                 goto dodist;
; 286  :             }
; 287  :             else {
; 288  :                 strm->msg = (char *)"invalid distance code";

  00445	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  0044d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00454	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 289  :                 state->mode = BAD;

  00458	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29

; 290  :                 break;

  0045f	eb 24		 jmp	 SHORT $LN53@inflate_fa
$LN75@inflate_fa:

; 191  :                             strm->msg =
; 192  :                                 (char *)"invalid distance too far back";

  00461	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00469	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  00470	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 193  :                             state->mode = BAD;

  00474	41 c7 07 1d 00
	00 00		 mov	 DWORD PTR [r15], 29
  0047b	eb 08		 jmp	 SHORT $LN53@inflate_fa
$LN84@inflate_fa:

; 278  :                         if (len > 1)
; 279  :                             PUP(out) = PUP(from);

  0047d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
$LN53@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;

  00485	41 8b cb	 mov	 ecx, r11d
  00488	c1 e9 03	 shr	 ecx, 3

; 311  :     in -= len;

  0048b	8b c1		 mov	 eax, ecx
  0048d	48 2b f0	 sub	 rsi, rax

; 312  :     bits -= len << 3;

  00490	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  00497	44 2b d8	 sub	 r11d, eax

; 313  :     hold &= (1U << bits) - 1;
; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  0049a	48 8d 46 01	 lea	 rax, QWORD PTR [rsi+1]

; 317  :     strm->next_out = out + OFF;
; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  0049e	4c 2b f6	 sub	 r14, rsi
  004a1	48 89 02	 mov	 QWORD PTR [rdx], rax
  004a4	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  004a8	41 8b cb	 mov	 ecx, r11d
  004ab	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
  004af	d3 e5		 shl	 ebp, cl
  004b1	49 8d 46 05	 lea	 rax, QWORD PTR [r14+5]
  004b5	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004b8	ff cd		 dec	 ebp
  004ba	23 dd		 and	 ebx, ebp

; 319  :     strm->avail_out = (unsigned)(out < end ?
; 320  :                                  257 + (end - out) : 257 - (out - end));

  004bc	4d 2b e8	 sub	 r13, r8
  004bf	49 8d 85 01 01
	00 00		 lea	 rax, QWORD PTR [r13+257]
  004c6	89 42 18	 mov	 DWORD PTR [rdx+24], eax

; 321  :     state->hold = hold;

  004c9	41 89 5f 40	 mov	 DWORD PTR [r15+64], ebx

; 322  :     state->bits = bits;

  004cd	45 89 5f 44	 mov	 DWORD PTR [r15+68], r11d

; 323  :     return;
; 324  : }

  004d1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004d5	41 5f		 pop	 r15
  004d7	41 5e		 pop	 r14
  004d9	41 5d		 pop	 r13
  004db	41 5c		 pop	 r12
  004dd	5f		 pop	 rdi
  004de	5e		 pop	 rsi
  004df	5d		 pop	 rbp
  004e0	5b		 pop	 rbx
  004e1	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
