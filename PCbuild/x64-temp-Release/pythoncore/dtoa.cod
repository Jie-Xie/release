; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
private_mem DQ	0120H DUP (?)
_BSS	ENDS
CONST	SEGMENT
tens	DQ	03ff0000000000000r		; 1
	DQ	04024000000000000r		; 10
	DQ	04059000000000000r		; 100
	DQ	0408f400000000000r		; 1000
	DQ	040c3880000000000r		; 10000
	DQ	040f86a0000000000r		; 100000
	DQ	0412e848000000000r		; 1e+006
	DQ	0416312d000000000r		; 1e+007
	DQ	04197d78400000000r		; 1e+008
	DQ	041cdcd6500000000r		; 1e+009
	DQ	04202a05f20000000r		; 1e+010
	DQ	042374876e8000000r		; 1e+011
	DQ	0426d1a94a2000000r		; 1e+012
	DQ	042a2309ce5400000r		; 1e+013
	DQ	042d6bcc41e900000r		; 1e+014
	DQ	0430c6bf526340000r		; 1e+015
	DQ	04341c37937e08000r		; 1e+016
	DQ	04376345785d8a000r		; 1e+017
	DQ	043abc16d674ec800r		; 1e+018
	DQ	043e158e460913d00r		; 1e+019
	DQ	04415af1d78b58c40r		; 1e+020
	DQ	0444b1ae4d6e2ef50r		; 1e+021
	DQ	04480f0cf064dd592r		; 1e+022
bigtens	DQ	04341c37937e08000r		; 1e+016
	DQ	04693b8b5b5056e17r		; 1e+032
	DQ	04d384f03e93ff9f5r		; 1e+064
	DQ	05a827748f9301d32r		; 1e+128
	DQ	075154fdd7f73bf3cr		; 1e+256
tinytens DQ	03c9cd2b297d889bcr		; 1e-016
	DQ	03949f623d5a8a733r		; 1e-032
	DQ	032a50ffd44f4a73dr		; 1e-064
	DQ	0255bba08cf8c979dr		; 1e-128
	DQ	01168062864ac6f43r		; 8.11296e-225
CONST	ENDS
_DATA	SEGMENT
pmem_next DQ	FLAT:private_mem
?p05@?1??pow5mult@@9@9 DD 05H				; `pow5mult'::`2'::p05
	DD	019H
	DD	07dH
_DATA	ENDS
EXTRN	PyMem_Malloc:PROC
_BSS	SEGMENT
freelist DQ	08H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\dtoa.c
pdata	SEGMENT
$pdata$Balloc DD imagerel Balloc
	DD	imagerel Balloc+180
	DD	imagerel $unwind$Balloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Balloc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Balloc
_TEXT	SEGMENT
k$ = 48
Balloc	PROC						; COMDAT

; 365  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 d9	 movsxd	 rbx, ecx

; 366  :     int x;
; 367  :     Bigint *rv;
; 368  :     unsigned int len;
; 369  : 
; 370  :     if (k <= Kmax && (rv = freelist[k]))

  0000d	83 fb 07	 cmp	 ebx, 7
  00010	7f 19		 jg	 SHORT $LN5@Balloc
  00012	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:freelist
  00019	49 8b 14 d8	 mov	 rdx, QWORD PTR [r8+rbx*8]
  0001d	48 85 d2	 test	 rdx, rdx
  00020	74 09		 je	 SHORT $LN5@Balloc

; 371  :         freelist[k] = rv->next;

  00022	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00025	49 89 04 d8	 mov	 QWORD PTR [r8+rbx*8], rax

; 372  :     else {

  00029	eb 57		 jmp	 SHORT $LN4@Balloc
$LN5@Balloc:

; 373  :         x = 1 << k;

  0002b	8b cb		 mov	 ecx, ebx
  0002d	bf 01 00 00 00	 mov	 edi, 1
  00032	d3 e7		 shl	 edi, cl

; 374  :         len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
; 375  :             /sizeof(double);

  00034	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
  00037	48 63 c8	 movsxd	 rcx, eax
  0003a	48 8d 0c 8d 27
	00 00 00	 lea	 rcx, QWORD PTR [rcx*4+39]
  00042	48 c1 e9 03	 shr	 rcx, 3

; 376  :         if (k <= Kmax && pmem_next - private_mem + len <= PRIVATE_mem) {

  00046	83 fb 07	 cmp	 ebx, 7
  00049	7f 4b		 jg	 SHORT $LN3@Balloc
  0004b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pmem_next
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:private_mem
  00059	44 8b c1	 mov	 r8d, ecx
  0005c	48 8b c2	 mov	 rax, rdx
  0005f	49 2b c1	 sub	 rax, r9
  00062	48 c1 f8 03	 sar	 rax, 3
  00066	49 03 c0	 add	 rax, r8
  00069	48 3d 20 01 00
	00		 cmp	 rax, 288		; 00000120H
  0006f	77 25		 ja	 SHORT $LN3@Balloc

; 377  :             rv = (Bigint*)pmem_next;
; 378  :             pmem_next += len;

  00071	4a 8d 04 c2	 lea	 rax, QWORD PTR [rdx+r8*8]
  00075	48 89 05 00 00
	00 00		 mov	 QWORD PTR pmem_next, rax
$LN1@Balloc:

; 383  :                 return NULL;
; 384  :         }
; 385  :         rv->k = k;

  0007c	89 5a 08	 mov	 DWORD PTR [rdx+8], ebx

; 386  :         rv->maxwds = x;

  0007f	89 7a 0c	 mov	 DWORD PTR [rdx+12], edi
$LN4@Balloc:

; 387  :     }
; 388  :     rv->sign = rv->wds = 0;

  00082	33 c0		 xor	 eax, eax
  00084	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 389  :     return rv;

  00088	48 8b c2	 mov	 rax, rdx

; 390  : }

  0008b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00090	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
$LN3@Balloc:

; 379  :         }
; 380  :         else {
; 381  :             rv = (Bigint*)MALLOC(len*sizeof(double));

  00096	8b c9		 mov	 ecx, ecx
  00098	48 c1 e1 03	 shl	 rcx, 3
  0009c	e8 00 00 00 00	 call	 PyMem_Malloc
  000a1	48 8b d0	 mov	 rdx, rax

; 382  :             if (rv == NULL)

  000a4	48 85 c0	 test	 rax, rax
  000a7	75 d3		 jne	 SHORT $LN1@Balloc

; 390  : }

  000a9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
Balloc	ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
; Function compile flags: /Ogtpy
;	COMDAT Bfree
_TEXT	SEGMENT
v$ = 8
Bfree	PROC						; COMDAT

; 396  : {

  00000	48 8b d1	 mov	 rdx, rcx

; 397  :     if (v) {

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 23		 je	 SHORT $LN1@Bfree

; 398  :         if (v->k > Kmax)

  00008	48 63 41 08	 movsxd	 rax, DWORD PTR [rcx+8]
  0000c	83 f8 07	 cmp	 eax, 7
  0000f	7e 05		 jle	 SHORT $LN2@Bfree

; 403  :         }
; 404  :     }
; 405  : }

  00011	e9 00 00 00 00	 jmp	 PyMem_Free
$LN2@Bfree:

; 399  :             FREE((void*)v);
; 400  :         else {
; 401  :             v->next = freelist[v->k];

  00016	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:freelist
  0001d	48 8b c8	 mov	 rcx, rax
  00020	49 8b 04 c0	 mov	 rax, QWORD PTR [r8+rax*8]
  00024	48 89 02	 mov	 QWORD PTR [rdx], rax

; 402  :             freelist[v->k] = v;

  00027	49 89 14 c8	 mov	 QWORD PTR [r8+rcx*8], rdx
$LN1@Bfree:

; 403  :         }
; 404  :     }
; 405  : }

  0002b	f3 c3		 fatret	 0
Bfree	ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$multadd DD imagerel multadd
	DD	imagerel multadd+194
	DD	imagerel $unwind$multadd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multadd DD 085401H
	DD	065454H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT multadd
_TEXT	SEGMENT
b$ = 48
m$ = 56
a$ = 64
multadd	PROC						; COMDAT

; 458  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 459  :     int i, wds;
; 460  : #ifdef ULLong
; 461  :     ULong *x;
; 462  :     ULLong carry, y;
; 463  : #else
; 464  :     ULong carry, *x, y;
; 465  :     ULong xi, z;
; 466  : #endif
; 467  :     Bigint *b1;
; 468  : 
; 469  :     wds = b->wds;

  0000f	48 63 79 14	 movsxd	 rdi, DWORD PTR [rcx+20]
  00013	48 8b d9	 mov	 rbx, rcx

; 470  :     x = b->x;
; 471  :     i = 0;
; 472  :     carry = a;

  00016	49 63 f0	 movsxd	 rsi, r8d
  00019	48 83 c1 18	 add	 rcx, 24

; 473  :     do {
; 474  : #ifdef ULLong
; 475  :         y = *x * (ULLong)m + carry;
; 476  :         carry = y >> 32;
; 477  :         *x++ = (ULong)(y & FFFFFFFF);
; 478  : #else
; 479  :         xi = *x;
; 480  :         y = (xi & 0xffff) * m + carry;
; 481  :         z = (xi >> 16) * m + (y >> 16);
; 482  :         carry = z >> 16;
; 483  :         *x++ = (z << 16) + (y & 0xffff);
; 484  : #endif
; 485  :     }
; 486  :     while(++i < wds);

  0001d	4c 63 c2	 movsxd	 r8, edx
  00020	45 33 c9	 xor	 r9d, r9d
  00023	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL6@multadd:
  00030	8b 01		 mov	 eax, DWORD PTR [rcx]
  00032	41 ff c1	 inc	 r9d
  00035	48 83 c1 04	 add	 rcx, 4
  00039	49 0f af c0	 imul	 rax, r8
  0003d	48 03 c6	 add	 rax, rsi
  00040	48 8b f0	 mov	 rsi, rax
  00043	89 41 fc	 mov	 DWORD PTR [rcx-4], eax
  00046	48 c1 ee 20	 shr	 rsi, 32			; 00000020H
  0004a	44 3b cf	 cmp	 r9d, edi
  0004d	7c e1		 jl	 SHORT $LL6@multadd

; 487  :     if (carry) {

  0004f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00054	48 85 f6	 test	 rsi, rsi
  00057	74 51		 je	 SHORT $LN3@multadd

; 488  :         if (wds >= b->maxwds) {

  00059	3b 7b 0c	 cmp	 edi, DWORD PTR [rbx+12]
  0005c	7c 42		 jl	 SHORT $LN2@multadd

; 489  :             b1 = Balloc(b->k+1);

  0005e	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  00061	ff c1		 inc	 ecx
  00063	e8 00 00 00 00	 call	 Balloc
  00068	48 8b e8	 mov	 rbp, rax

; 490  :             if (b1 == NULL){

  0006b	48 85 c0	 test	 rax, rax
  0006e	75 0c		 jne	 SHORT $LN1@multadd

; 491  :                 Bfree(b);

  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 Bfree

; 492  :                 return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 31		 jmp	 SHORT $LN7@multadd
$LN1@multadd:

; 493  :             }
; 494  :             Bcopy(b1, b);

  0007c	4c 63 43 14	 movsxd	 r8, DWORD PTR [rbx+20]
  00080	48 8d 53 10	 lea	 rdx, QWORD PTR [rbx+16]
  00084	48 8d 48 10	 lea	 rcx, QWORD PTR [rax+16]
  00088	4e 8d 04 85 08
	00 00 00	 lea	 r8, QWORD PTR [r8*4+8]
  00090	e8 00 00 00 00	 call	 memcpy

; 495  :             Bfree(b);

  00095	48 8b cb	 mov	 rcx, rbx
  00098	e8 00 00 00 00	 call	 Bfree

; 496  :             b = b1;

  0009d	48 8b dd	 mov	 rbx, rbp
$LN2@multadd:

; 497  :         }
; 498  :         b->x[wds++] = (ULong)carry;

  000a0	8d 47 01	 lea	 eax, DWORD PTR [rdi+1]
  000a3	89 74 bb 18	 mov	 DWORD PTR [rbx+rdi*4+24], esi

; 499  :         b->wds = wds;

  000a7	89 43 14	 mov	 DWORD PTR [rbx+20], eax
$LN3@multadd:

; 500  :     }
; 501  :     return b;

  000aa	48 8b c3	 mov	 rax, rbx
$LN7@multadd:
  000ad	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 502  : }

  000b2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
multadd	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s2b DD	imagerel s2b
	DD	imagerel s2b+220
	DD	imagerel $unwind$s2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s2b DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT s2b
_TEXT	SEGMENT
s$ = 48
nd0$ = 56
nd$ = 64
y9$ = 72
s2b	PROC						; COMDAT

; 512  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b ea		 mov	 ebp, edx

; 513  :     Bigint *b;
; 514  :     int i, k;
; 515  :     Long x, y;
; 516  : 
; 517  :     x = (nd + 8) / 9;

  00016	45 8d 50 08	 lea	 r10d, DWORD PTR [r8+8]
  0001a	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0001f	48 8b f9	 mov	 rdi, rcx

; 518  :     for(k = 0, y = 1; x > y; y <<= 1, k++) ;

  00022	33 c9		 xor	 ecx, ecx
  00024	41 8b d9	 mov	 ebx, r9d
  00027	41 f7 ea	 imul	 r10d
  0002a	d1 fa		 sar	 edx, 1
  0002c	41 8b f0	 mov	 esi, r8d
  0002f	8b c2		 mov	 eax, edx
  00031	c1 e8 1f	 shr	 eax, 31
  00034	03 d0		 add	 edx, eax
  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	3b d0		 cmp	 edx, eax
  0003d	7e 09		 jle	 SHORT $LN11@s2b
  0003f	90		 npad	 1
$LL13@s2b:
  00040	03 c0		 add	 eax, eax
  00042	ff c1		 inc	 ecx
  00044	3b d0		 cmp	 edx, eax
  00046	7f f8		 jg	 SHORT $LL13@s2b
$LN11@s2b:

; 519  :     b = Balloc(k);

  00048	e8 00 00 00 00	 call	 Balloc

; 520  :     if (b == NULL)

  0004d	48 85 c0	 test	 rax, rax

; 521  :         return NULL;

  00050	74 73		 je	 SHORT $LN20@s2b

; 522  :     b->x[0] = y9;

  00052	89 58 18	 mov	 DWORD PTR [rax+24], ebx

; 523  :     b->wds = 1;

  00055	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 524  : 
; 525  :     if (nd <= 9)

  0005c	83 fe 09	 cmp	 esi, 9

; 526  :       return b;

  0005f	7e 66		 jle	 SHORT $LN2@s2b

; 527  : 
; 528  :     s += 9;
; 529  :     for (i = 9; i < nd0; i++) {

  00061	bb 09 00 00 00	 mov	 ebx, 9
  00066	48 83 c7 09	 add	 rdi, 9
  0006a	3b eb		 cmp	 ebp, ebx
  0006c	7e 25		 jle	 SHORT $LN6@s2b
  0006e	66 90		 npad	 2
$LL8@s2b:

; 530  :         b = multadd(b, 10, *s++ - '0');

  00070	44 0f be 07	 movsx	 r8d, BYTE PTR [rdi]
  00074	ba 0a 00 00 00	 mov	 edx, 10
  00079	48 8b c8	 mov	 rcx, rax
  0007c	41 83 e8 30	 sub	 r8d, 48			; 00000030H
  00080	e8 00 00 00 00	 call	 multadd
  00085	48 ff c7	 inc	 rdi

; 531  :         if (b == NULL)

  00088	48 85 c0	 test	 rax, rax
  0008b	74 38		 je	 SHORT $LN20@s2b

; 527  : 
; 528  :     s += 9;
; 529  :     for (i = 9; i < nd0; i++) {

  0008d	ff c3		 inc	 ebx
  0008f	3b dd		 cmp	 ebx, ebp
  00091	7c dd		 jl	 SHORT $LL8@s2b
$LN6@s2b:

; 532  :             return NULL;
; 533  :     }
; 534  :     s++;

  00093	48 ff c7	 inc	 rdi

; 535  :     for(; i < nd; i++) {

  00096	3b de		 cmp	 ebx, esi
  00098	7d 2d		 jge	 SHORT $LN2@s2b
  0009a	66 0f 1f 44 00
	00		 npad	 6
$LL4@s2b:

; 536  :         b = multadd(b, 10, *s++ - '0');

  000a0	44 0f be 07	 movsx	 r8d, BYTE PTR [rdi]
  000a4	ba 0a 00 00 00	 mov	 edx, 10
  000a9	48 8b c8	 mov	 rcx, rax
  000ac	41 83 e8 30	 sub	 r8d, 48			; 00000030H
  000b0	e8 00 00 00 00	 call	 multadd
  000b5	48 ff c7	 inc	 rdi

; 537  :         if (b == NULL)

  000b8	48 85 c0	 test	 rax, rax
  000bb	74 08		 je	 SHORT $LN20@s2b

; 535  :     for(; i < nd; i++) {

  000bd	ff c3		 inc	 ebx
  000bf	3b de		 cmp	 ebx, esi
  000c1	7c dd		 jl	 SHORT $LL4@s2b

; 537  :         if (b == NULL)

  000c3	eb 02		 jmp	 SHORT $LN2@s2b
$LN20@s2b:

; 538  :             return NULL;

  000c5	33 c0		 xor	 eax, eax
$LN2@s2b:

; 539  :     }
; 540  :     return b;
; 541  : }

  000c7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cc	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000d1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
s2b	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT hi0bits
_TEXT	SEGMENT
x$ = 8
hi0bits	PROC						; COMDAT

; 548  :     int k = 0;

  00000	33 c0		 xor	 eax, eax

; 549  : 
; 550  :     if (!(x & 0xffff0000)) {

  00002	f7 c1 00 00 ff
	ff		 test	 ecx, -65536		; ffff0000H
  00008	75 08		 jne	 SHORT $LN6@hi0bits

; 551  :         k = 16;

  0000a	b8 10 00 00 00	 mov	 eax, 16

; 552  :         x <<= 16;

  0000f	c1 e1 10	 shl	 ecx, 16
$LN6@hi0bits:

; 553  :     }
; 554  :     if (!(x & 0xff000000)) {

  00012	f7 c1 00 00 00
	ff		 test	 ecx, -16777216		; ff000000H
  00018	75 06		 jne	 SHORT $LN5@hi0bits

; 555  :         k += 8;

  0001a	83 c0 08	 add	 eax, 8

; 556  :         x <<= 8;

  0001d	c1 e1 08	 shl	 ecx, 8
$LN5@hi0bits:

; 557  :     }
; 558  :     if (!(x & 0xf0000000)) {

  00020	f7 c1 00 00 00
	f0		 test	 ecx, -268435456		; f0000000H
  00026	75 06		 jne	 SHORT $LN4@hi0bits

; 559  :         k += 4;

  00028	83 c0 04	 add	 eax, 4

; 560  :         x <<= 4;

  0002b	c1 e1 04	 shl	 ecx, 4
$LN4@hi0bits:

; 561  :     }
; 562  :     if (!(x & 0xc0000000)) {

  0002e	f7 c1 00 00 00
	c0		 test	 ecx, -1073741824	; c0000000H
  00034	75 06		 jne	 SHORT $LN3@hi0bits

; 563  :         k += 2;

  00036	83 c0 02	 add	 eax, 2

; 564  :         x <<= 2;

  00039	c1 e1 02	 shl	 ecx, 2
$LN3@hi0bits:

; 565  :     }
; 566  :     if (!(x & 0x80000000)) {

  0003c	85 c9		 test	 ecx, ecx
  0003e	78 0d		 js	 SHORT $LN1@hi0bits

; 567  :         k++;

  00040	ff c0		 inc	 eax

; 568  :         if (!(x & 0x40000000))

  00042	0f ba e1 1e	 bt	 ecx, 30
  00046	72 05		 jb	 SHORT $LN1@hi0bits

; 569  :             return 32;

  00048	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
$LN1@hi0bits:

; 570  :     }
; 571  :     return k;
; 572  : }

  0004d	f3 c3		 fatret	 0
hi0bits	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT lo0bits
_TEXT	SEGMENT
y$ = 8
lo0bits	PROC						; COMDAT

; 580  :     int k;
; 581  :     ULong x = *y;

  00000	8b 11		 mov	 edx, DWORD PTR [rcx]
  00002	4c 8b c1	 mov	 r8, rcx

; 582  : 
; 583  :     if (x & 7) {

  00005	f6 c2 07	 test	 dl, 7
  00008	74 22		 je	 SHORT $LN9@lo0bits

; 584  :         if (x & 1)

  0000a	f6 c2 01	 test	 dl, 1
  0000d	74 03		 je	 SHORT $LN8@lo0bits

; 585  :             return 0;

  0000f	33 c0		 xor	 eax, eax

; 618  : }

  00011	c3		 ret	 0
$LN8@lo0bits:

; 586  :         if (x & 2) {

  00012	f6 c2 02	 test	 dl, 2
  00015	74 0a		 je	 SHORT $LN7@lo0bits

; 587  :             *y = x >> 1;

  00017	d1 ea		 shr	 edx, 1

; 588  :             return 1;

  00019	b8 01 00 00 00	 mov	 eax, 1
  0001e	89 11		 mov	 DWORD PTR [rcx], edx

; 618  : }

  00020	c3		 ret	 0
$LN7@lo0bits:

; 589  :         }
; 590  :         *y = x >> 2;

  00021	c1 ea 02	 shr	 edx, 2

; 591  :         return 2;

  00024	b8 02 00 00 00	 mov	 eax, 2
  00029	89 11		 mov	 DWORD PTR [rcx], edx

; 618  : }

  0002b	c3		 ret	 0
$LN9@lo0bits:

; 592  :     }
; 593  :     k = 0;

  0002c	33 c9		 xor	 ecx, ecx

; 594  :     if (!(x & 0xffff)) {

  0002e	66 85 d2	 test	 dx, dx
  00031	75 08		 jne	 SHORT $LN6@lo0bits

; 595  :         k = 16;

  00033	b9 10 00 00 00	 mov	 ecx, 16

; 596  :         x >>= 16;

  00038	c1 ea 10	 shr	 edx, 16
$LN6@lo0bits:

; 597  :     }
; 598  :     if (!(x & 0xff)) {

  0003b	84 d2		 test	 dl, dl
  0003d	75 06		 jne	 SHORT $LN5@lo0bits

; 599  :         k += 8;

  0003f	83 c1 08	 add	 ecx, 8

; 600  :         x >>= 8;

  00042	c1 ea 08	 shr	 edx, 8
$LN5@lo0bits:

; 601  :     }
; 602  :     if (!(x & 0xf)) {

  00045	f6 c2 0f	 test	 dl, 15
  00048	75 06		 jne	 SHORT $LN4@lo0bits

; 603  :         k += 4;

  0004a	83 c1 04	 add	 ecx, 4

; 604  :         x >>= 4;

  0004d	c1 ea 04	 shr	 edx, 4
$LN4@lo0bits:

; 605  :     }
; 606  :     if (!(x & 0x3)) {

  00050	f6 c2 03	 test	 dl, 3
  00053	75 06		 jne	 SHORT $LN3@lo0bits

; 607  :         k += 2;

  00055	83 c1 02	 add	 ecx, 2

; 608  :         x >>= 2;

  00058	c1 ea 02	 shr	 edx, 2
$LN3@lo0bits:

; 609  :     }
; 610  :     if (!(x & 1)) {

  0005b	f6 c2 01	 test	 dl, 1
  0005e	75 0c		 jne	 SHORT $LN1@lo0bits

; 611  :         k++;

  00060	ff c1		 inc	 ecx

; 612  :         x >>= 1;

  00062	d1 ea		 shr	 edx, 1

; 613  :         if (!x)

  00064	75 06		 jne	 SHORT $LN1@lo0bits

; 614  :             return 32;

  00066	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 618  : }

  0006b	c3		 ret	 0
$LN1@lo0bits:

; 615  :     }
; 616  :     *y = x;

  0006c	41 89 10	 mov	 DWORD PTR [r8], edx

; 617  :     return k;

  0006f	8b c1		 mov	 eax, ecx

; 618  : }

  00071	c3		 ret	 0
lo0bits	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$i2b DD	imagerel i2b
	DD	imagerel i2b+45
	DD	imagerel $unwind$i2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$i2b DD	020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT i2b
_TEXT	SEGMENT
i$ = 48
i2b	PROC						; COMDAT

; 624  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 625  :     Bigint *b;
; 626  : 
; 627  :     b = Balloc(1);

  00008	b9 01 00 00 00	 mov	 ecx, 1
  0000d	e8 00 00 00 00	 call	 Balloc

; 628  :     if (b == NULL)

  00012	48 85 c0	 test	 rax, rax
  00015	75 06		 jne	 SHORT $LN1@i2b

; 632  :     return b;
; 633  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN1@i2b:

; 629  :         return NULL;
; 630  :     b->x[0] = i;

  0001d	89 58 18	 mov	 DWORD PTR [rax+24], ebx

; 631  :     b->wds = 1;

  00020	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 632  :     return b;
; 633  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
i2b	ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mult DD	imagerel mult
	DD	imagerel mult+145
	DD	imagerel $unwind$mult
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$mult DD imagerel mult+145
	DD	imagerel mult+336
	DD	imagerel $chain$5$mult
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$mult DD imagerel mult+336
	DD	imagerel mult+385
	DD	imagerel $chain$6$mult
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$mult DD 021H
	DD	imagerel mult
	DD	imagerel mult+145
	DD	imagerel $unwind$mult
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$mult DD 041621H
	DD	04f416H
	DD	0b5405H
	DD	imagerel mult
	DD	imagerel mult+145
	DD	imagerel $unwind$mult
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mult DD	0b5e01H
	DD	05e45eH
	DD	06d459H
	DD	0cc454H
	DD	0a344fH
	DD	070036207H
	DD	06002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT mult
_TEXT	SEGMENT
a$ = 80
b$ = 88
mult	PROC						; COMDAT

; 640  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  :     Bigint *c;
; 642  :     int k, wa, wb, wc;
; 643  :     ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
; 644  :     ULong y;
; 645  : #ifdef ULLong
; 646  :     ULLong carry, z;
; 647  : #else
; 648  :     ULong carry, z;
; 649  :     ULong z2;
; 650  : #endif
; 651  : 
; 652  :     if ((!a->x[0] && a->wds == 1) || (!b->x[0] && b->wds == 1)) {

  00007	83 79 18 00	 cmp	 DWORD PTR [rcx+24], 0
  0000b	48 8b f2	 mov	 rsi, rdx
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	75 06		 jne	 SHORT $LN18@mult
  00013	83 79 14 01	 cmp	 DWORD PTR [rcx+20], 1
  00017	74 0c		 je	 SHORT $LN19@mult
$LN18@mult:
  00019	83 7a 18 00	 cmp	 DWORD PTR [rdx+24], 0
  0001d	75 28		 jne	 SHORT $LN20@mult
  0001f	83 7a 14 01	 cmp	 DWORD PTR [rdx+20], 1
  00023	75 22		 jne	 SHORT $LN20@mult
$LN19@mult:

; 653  :         c = Balloc(0);

  00025	33 c9		 xor	 ecx, ecx
  00027	e8 00 00 00 00	 call	 Balloc

; 654  :         if (c == NULL)

  0002c	48 85 c0	 test	 rax, rax
  0002f	75 07		 jne	 SHORT $LN17@mult

; 733  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	5f		 pop	 rdi
  00036	5e		 pop	 rsi
  00037	c3		 ret	 0
$LN17@mult:

; 655  :             return NULL;
; 656  :         c->wds = 1;

  00038	48 c7 40 14 01
	00 00 00	 mov	 QWORD PTR [rax+20], 1

; 733  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	5f		 pop	 rdi
  00045	5e		 pop	 rsi
  00046	c3		 ret	 0
$LN20@mult:

; 657  :         c->x[0] = 0;
; 658  :         return c;
; 659  :     }
; 660  : 
; 661  :     if (a->wds < b->wds) {

  00047	8b 42 14	 mov	 eax, DWORD PTR [rdx+20]
  0004a	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0004f	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00054	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00059	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0005e	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00061	7d 06		 jge	 SHORT $LN16@mult

; 662  :         c = a;
; 663  :         a = b;

  00063	48 8b fa	 mov	 rdi, rdx

; 664  :         b = c;

  00066	48 8b f1	 mov	 rsi, rcx
$LN16@mult:

; 665  :     }
; 666  :     k = a->k;
; 667  :     wa = a->wds;

  00069	4c 63 67 14	 movsxd	 r12, DWORD PTR [rdi+20]

; 668  :     wb = b->wds;

  0006d	4c 63 6e 14	 movsxd	 r13, DWORD PTR [rsi+20]
  00071	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]

; 669  :     wc = wa + wb;

  00074	43 8d 5c 25 00	 lea	 ebx, DWORD PTR [r13+r12]

; 670  :     if (wc > a->maxwds)

  00079	3b 5f 0c	 cmp	 ebx, DWORD PTR [rdi+12]
  0007c	7e 02		 jle	 SHORT $LN15@mult

; 671  :         k++;

  0007e	ff c1		 inc	 ecx
$LN15@mult:

; 672  :     c = Balloc(k);

  00080	e8 00 00 00 00	 call	 Balloc
  00085	4c 8b f0	 mov	 r14, rax

; 673  :     if (c == NULL)

  00088	48 85 c0	 test	 rax, rax
  0008b	0f 84 d5 00 00
	00		 je	 $LN34@mult
$LN14@mult:
  00091	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 674  :         return NULL;
; 675  :     for(x = c->x, xa = x + wc; x < xa; x++)

  00096	48 8d 68 18	 lea	 rbp, QWORD PTR [rax+24]
  0009a	48 63 c3	 movsxd	 rax, ebx
  0009d	4c 8d 44 85 00	 lea	 r8, QWORD PTR [rbp+rax*4]
  000a2	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000a7	49 3b e8	 cmp	 rbp, r8
  000aa	73 1b		 jae	 SHORT $LN13@mult
  000ac	4c 2b c5	 sub	 r8, rbp
  000af	33 d2		 xor	 edx, edx
  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	49 ff c8	 dec	 r8
  000b7	49 c1 e8 02	 shr	 r8, 2
  000bb	49 ff c0	 inc	 r8
  000be	49 c1 e0 02	 shl	 r8, 2
  000c2	e8 00 00 00 00	 call	 memset
$LN13@mult:

; 676  :         *x = 0;
; 677  :     xa = a->x;
; 678  :     xae = xa + wa;
; 679  :     xb = b->x;

  000c7	48 83 c6 18	 add	 rsi, 24
  000cb	4c 8d 7f 18	 lea	 r15, QWORD PTR [rdi+24]

; 680  :     xbe = xb + wb;

  000cf	4e 8d 1c ae	 lea	 r11, QWORD PTR [rsi+r13*4]
  000d3	4b 8d 3c a7	 lea	 rdi, QWORD PTR [r15+r12*4]

; 681  :     xc0 = c->x;
; 682  : #ifdef ULLong
; 683  :     for(; xb < xbe; xc0++) {

  000d7	49 3b f3	 cmp	 rsi, r11
  000da	73 57		 jae	 SHORT $LN8@mult
  000dc	0f 1f 40 00	 npad	 4
$LL10@mult:

; 684  :         if ((y = *xb++)) {

  000e0	8b 06		 mov	 eax, DWORD PTR [rsi]
  000e2	48 83 c6 04	 add	 rsi, 4
  000e6	85 c0		 test	 eax, eax
  000e8	74 40		 je	 SHORT $LN9@mult

; 692  :             }
; 693  :             while(x < xae);

  000ea	4d 8b c7	 mov	 r8, r15
  000ed	45 33 c9	 xor	 r9d, r9d
  000f0	48 8b d5	 mov	 rdx, rbp
  000f3	4c 2b c5	 sub	 r8, rbp

; 694  :             *xc = (ULong)carry;

  000f6	44 8b d0	 mov	 r10d, eax
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@mult:

; 685  :             x = xa;
; 686  :             xc = xc0;
; 687  :             carry = 0;
; 688  :             do {
; 689  :                 z = *x++ * (ULLong)y + *xc + carry;

  00100	41 8b 04 10	 mov	 eax, DWORD PTR [r8+rdx]
  00104	8b 0a		 mov	 ecx, DWORD PTR [rdx]

; 690  :                 carry = z >> 32;
; 691  :                 *xc++ = (ULong)(z & FFFFFFFF);

  00106	48 83 c2 04	 add	 rdx, 4
  0010a	49 0f af c2	 imul	 rax, r10
  0010e	49 03 c1	 add	 rax, r9
  00111	48 03 c8	 add	 rcx, rax

; 692  :             }
; 693  :             while(x < xae);

  00114	49 8d 04 10	 lea	 rax, QWORD PTR [r8+rdx]
  00118	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  0011b	4c 8b c9	 mov	 r9, rcx
  0011e	49 c1 e9 20	 shr	 r9, 32			; 00000020H
  00122	48 3b c7	 cmp	 rax, rdi
  00125	72 d9		 jb	 SHORT $LL6@mult

; 694  :             *xc = (ULong)carry;

  00127	44 89 0a	 mov	 DWORD PTR [rdx], r9d
$LN9@mult:

; 681  :     xc0 = c->x;
; 682  : #ifdef ULLong
; 683  :     for(; xb < xbe; xc0++) {

  0012a	48 83 c5 04	 add	 rbp, 4
  0012e	49 3b f3	 cmp	 rsi, r11
  00131	72 ad		 jb	 SHORT $LL10@mult
$LN8@mult:
  00133	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00138	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 695  :         }
; 696  :     }
; 697  : #else
; 698  :     for(; xb < xbe; xb++, xc0++) {
; 699  :         if (y = *xb & 0xffff) {
; 700  :             x = xa;
; 701  :             xc = xc0;
; 702  :             carry = 0;
; 703  :             do {
; 704  :                 z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
; 705  :                 carry = z >> 16;
; 706  :                 z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
; 707  :                 carry = z2 >> 16;
; 708  :                 Storeinc(xc, z2, z);
; 709  :             }
; 710  :             while(x < xae);
; 711  :             *xc = carry;
; 712  :         }
; 713  :         if (y = *xb >> 16) {
; 714  :             x = xa;
; 715  :             xc = xc0;
; 716  :             carry = 0;
; 717  :             z2 = *xc;
; 718  :             do {
; 719  :                 z = (*x & 0xffff) * y + (*xc >> 16) + carry;
; 720  :                 carry = z >> 16;
; 721  :                 Storeinc(xc, z, z2);
; 722  :                 z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
; 723  :                 carry = z2 >> 16;
; 724  :             }
; 725  :             while(x < xae);
; 726  :             *xc = z2;
; 727  :         }
; 728  :     }
; 729  : #endif
; 730  :     for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;

  0013d	48 63 c3	 movsxd	 rax, ebx
  00140	49 8d 44 86 18	 lea	 rax, QWORD PTR [r14+rax*4+24]
  00145	85 db		 test	 ebx, ebx
  00147	7e 16		 jle	 SHORT $LN30@mult
  00149	0f 1f 80 00 00
	00 00		 npad	 7
$LL3@mult:
  00150	48 83 e8 04	 sub	 rax, 4
  00154	83 38 00	 cmp	 DWORD PTR [rax], 0
  00157	75 06		 jne	 SHORT $LN30@mult
  00159	ff cb		 dec	 ebx
  0015b	85 db		 test	 ebx, ebx
  0015d	7f f1		 jg	 SHORT $LL3@mult
$LN30@mult:

; 731  :     c->wds = wc;

  0015f	41 89 5e 14	 mov	 DWORD PTR [r14+20], ebx

; 732  :     return c;

  00163	49 8b c6	 mov	 rax, r14
$LN34@mult:
  00166	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  0016b	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00170	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00175	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]

; 733  : }

  0017a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017e	5f		 pop	 rdi
  0017f	5e		 pop	 rsi
  00180	c3		 ret	 0
mult	ENDP
_TEXT	ENDS
_BSS	SEGMENT
p5s	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pow5mult DD imagerel pow5mult
	DD	imagerel pow5mult+151
	DD	imagerel $unwind$pow5mult
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pow5mult DD imagerel pow5mult+151
	DD	imagerel pow5mult+255
	DD	imagerel $chain$2$pow5mult
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pow5mult DD imagerel pow5mult+255
	DD	imagerel pow5mult+276
	DD	imagerel $chain$3$pow5mult
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pow5mult DD 021H
	DD	imagerel pow5mult
	DD	imagerel pow5mult+151
	DD	imagerel $unwind$pow5mult
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pow5mult DD 020521H
	DD	063405H
	DD	imagerel pow5mult
	DD	imagerel pow5mult+151
	DD	imagerel $unwind$pow5mult
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pow5mult DD 086701H
	DD	08c467H
	DD	07745bH
	DD	09540aH
	DD	06006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT pow5mult
_TEXT	SEGMENT
b$ = 48
k$ = 56
pow5mult PROC						; COMDAT

; 747  : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 748  :     Bigint *b1, *p5, *p51;
; 749  :     int i;
; 750  :     static int p05[3] = { 5, 25, 125 };
; 751  : 
; 752  :     if ((i = k & 3)) {

  0000a	8b c2		 mov	 eax, edx
  0000c	8b f2		 mov	 esi, edx
  0000e	48 8b e9	 mov	 rbp, rcx
  00011	83 e0 03	 and	 eax, 3
  00014	74 2b		 je	 SHORT $LN11@pow5mult

; 753  :         b = multadd(b, p05[i-1], 0);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?p05@?1??pow5mult@@9@9
  0001d	48 98		 cdqe
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	8b 54 81 fc	 mov	 edx, DWORD PTR [rcx+rax*4-4]
  00026	48 8b cd	 mov	 rcx, rbp
  00029	e8 00 00 00 00	 call	 multadd
  0002e	48 8b e8	 mov	 rbp, rax

; 754  :         if (b == NULL)

  00031	48 85 c0	 test	 rax, rax
  00034	75 0b		 jne	 SHORT $LN11@pow5mult

; 794  : }

  00036	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5e		 pop	 rsi
  00040	c3		 ret	 0
$LN11@pow5mult:

; 755  :             return NULL;
; 756  :     }
; 757  : 
; 758  :     if (!(k >>= 2))

  00041	c1 fe 02	 sar	 esi, 2
  00044	85 f6		 test	 esi, esi
  00046	75 0e		 jne	 SHORT $LN10@pow5mult

; 759  :         return b;

  00048	48 8b c5	 mov	 rax, rbp

; 794  : }

  0004b	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5e		 pop	 rsi
  00055	c3		 ret	 0
$LN10@pow5mult:
  00056	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 760  :     p5 = p5s;

  0005b	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR p5s
  00062	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12

; 761  :     if (!p5) {

  00067	45 33 e4	 xor	 r12d, r12d
  0006a	48 85 ff	 test	 rdi, rdi
  0006d	75 28		 jne	 SHORT $LN22@pow5mult

; 762  :         /* first time */
; 763  :         p5 = i2b(625);

  0006f	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  00074	e8 00 00 00 00	 call	 i2b
  00079	48 8b f8	 mov	 rdi, rax

; 764  :         if (p5 == NULL) {

  0007c	48 85 c0	 test	 rax, rax
  0007f	75 0c		 jne	 SHORT $LN8@pow5mult

; 765  :             Bfree(b);

  00081	48 8b cd	 mov	 rcx, rbp
  00084	e8 00 00 00 00	 call	 Bfree

; 766  :             return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 72		 jmp	 SHORT $LN24@pow5mult
$LN8@pow5mult:

; 767  :         }
; 768  :         p5s = p5;

  0008d	48 89 05 00 00
	00 00		 mov	 QWORD PTR p5s, rax

; 769  :         p5->next = 0;

  00094	4c 89 20	 mov	 QWORD PTR [rax], r12
$LN22@pow5mult:
  00097	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0009c	0f 1f 40 00	 npad	 4
$LL7@pow5mult:

; 770  :     }
; 771  :     for(;;) {
; 772  :         if (k & 1) {

  000a0	40 f6 c6 01	 test	 sil, 1
  000a4	74 1e		 je	 SHORT $LN4@pow5mult

; 773  :             b1 = mult(b, p5);

  000a6	48 8b d7	 mov	 rdx, rdi
  000a9	48 8b cd	 mov	 rcx, rbp
  000ac	e8 00 00 00 00	 call	 mult

; 774  :             Bfree(b);

  000b1	48 8b cd	 mov	 rcx, rbp
  000b4	48 8b d8	 mov	 rbx, rax
  000b7	e8 00 00 00 00	 call	 Bfree

; 775  :             b = b1;

  000bc	48 8b eb	 mov	 rbp, rbx

; 776  :             if (b == NULL)

  000bf	48 85 db	 test	 rbx, rbx
  000c2	74 2f		 je	 SHORT $LN17@pow5mult
$LN4@pow5mult:

; 777  :                 return NULL;
; 778  :         }
; 779  :         if (!(k >>= 1))

  000c4	d1 fe		 sar	 esi, 1
  000c6	74 2f		 je	 SHORT $LN18@pow5mult

; 780  :             break;
; 781  :         p51 = p5->next;

  000c8	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 782  :         if (!p51) {

  000cb	48 85 c0	 test	 rax, rax
  000ce	75 16		 jne	 SHORT $LN2@pow5mult

; 783  :             p51 = mult(p5,p5);

  000d0	48 8b d7	 mov	 rdx, rdi
  000d3	48 8b cf	 mov	 rcx, rdi
  000d6	e8 00 00 00 00	 call	 mult

; 784  :             if (p51 == NULL) {

  000db	48 85 c0	 test	 rax, rax
  000de	74 0b		 je	 SHORT $LN19@pow5mult

; 787  :             }
; 788  :             p51->next = 0;

  000e0	4c 89 20	 mov	 QWORD PTR [rax], r12

; 789  :             p5->next = p51;

  000e3	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN2@pow5mult:

; 790  :         }
; 791  :         p5 = p51;

  000e6	48 8b f8	 mov	 rdi, rax

; 792  :     }

  000e9	eb b5		 jmp	 SHORT $LL7@pow5mult
$LN19@pow5mult:

; 785  :                 Bfree(b);

  000eb	48 8b cd	 mov	 rcx, rbp
  000ee	e8 00 00 00 00	 call	 Bfree
$LN17@pow5mult:

; 786  :                 return NULL;

  000f3	33 c0		 xor	 eax, eax
  000f5	eb 03		 jmp	 SHORT $LN25@pow5mult
$LN18@pow5mult:

; 793  :     return b;

  000f7	48 8b c5	 mov	 rax, rbp
$LN25@pow5mult:
  000fa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN24@pow5mult:
  000ff	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00104	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]

; 794  : }

  00109	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	5e		 pop	 rsi
  00113	c3		 ret	 0
pow5mult ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lshift DD imagerel lshift
	DD	imagerel lshift+49
	DD	imagerel $unwind$lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$lshift DD imagerel lshift+49
	DD	imagerel lshift+138
	DD	imagerel $chain$2$lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$lshift DD imagerel lshift+138
	DD	imagerel lshift+320
	DD	imagerel $chain$5$lshift
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$lshift DD imagerel lshift+320
	DD	imagerel lshift+332
	DD	imagerel $chain$6$lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$lshift DD 021H
	DD	imagerel lshift
	DD	imagerel lshift+49
	DD	imagerel $unwind$lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$lshift DD 080521H
	DD	096405H
	DD	0be400H
	DD	0ac400H
	DD	083400H
	DD	imagerel lshift
	DD	imagerel lshift+49
	DD	imagerel $unwind$lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$lshift DD 061121H
	DD	0be411H
	DD	0ac40aH
	DD	083405H
	DD	imagerel lshift
	DD	imagerel lshift+49
	DD	imagerel $unwind$lshift
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lshift DD 040901H
	DD	0d0053209H
	DD	050027003H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT lshift
_TEXT	SEGMENT
b$ = 64
k$ = 72
lshift	PROC						; COMDAT

; 854  : {

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 55		 push	 r13
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	44 8b ea	 mov	 r13d, edx
  0000c	48 8b e9	 mov	 rbp, rcx

; 855  :     int i, k1, n, n1;
; 856  :     Bigint *b1;
; 857  :     ULong *x, *x1, *xe, z;
; 858  : 
; 859  :     if (!k || (!b->x[0] && b->wds == 1))

  0000f	85 d2		 test	 edx, edx
  00011	0f 84 29 01 00
	00		 je	 $LN17@lshift
  00017	83 79 18 00	 cmp	 DWORD PTR [rcx+24], 0
  0001b	48 8d 79 18	 lea	 rdi, QWORD PTR [rcx+24]
  0001f	75 0a		 jne	 SHORT $LN18@lshift
  00021	83 79 14 01	 cmp	 DWORD PTR [rcx+20], 1
  00025	0f 84 15 01 00
	00		 je	 $LN17@lshift
$LN18@lshift:

; 861  : 
; 862  :     n = k >> 5;
; 863  :     k1 = b->k;
; 864  :     n1 = n + b->wds + 1;

  0002b	8b 45 14	 mov	 eax, DWORD PTR [rbp+20]
  0002e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00031	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00036	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0003b	8b da		 mov	 ebx, edx
  0003d	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  00042	c1 fb 05	 sar	 ebx, 5
  00045	44 8d 64 18 01	 lea	 r12d, DWORD PTR [rax+rbx+1]

; 865  :     for(i = b->maxwds; n1 > i; i <<= 1)

  0004a	8b 45 0c	 mov	 eax, DWORD PTR [rbp+12]
  0004d	44 3b e0	 cmp	 r12d, eax
  00050	7e 09		 jle	 SHORT $LN14@lshift
$LL16@lshift:
  00052	03 c0		 add	 eax, eax

; 866  :         k1++;

  00054	ff c1		 inc	 ecx
  00056	44 3b e0	 cmp	 r12d, eax
  00059	7f f7		 jg	 SHORT $LL16@lshift
$LN14@lshift:

; 867  :     b1 = Balloc(k1);

  0005b	e8 00 00 00 00	 call	 Balloc
  00060	4c 8b f0	 mov	 r14, rax

; 868  :     if (b1 == NULL) {

  00063	48 85 c0	 test	 rax, rax
  00066	75 22		 jne	 SHORT $LN13@lshift

; 869  :         Bfree(b);

  00068	48 8b cd	 mov	 rcx, rbp
  0006b	e8 00 00 00 00	 call	 Bfree

; 870  :         return NULL;

  00070	33 c0		 xor	 eax, eax
$LN33@lshift:
  00072	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  00077	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007c	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 894  : }

  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	41 5d		 pop	 r13
  00087	5f		 pop	 rdi
  00088	5d		 pop	 rbp
  00089	c3		 ret	 0
$LN13@lshift:
  0008a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 871  :     }
; 872  :     x1 = b1->x;

  0008f	48 8d 70 18	 lea	 rsi, QWORD PTR [rax+24]

; 873  :     for(i = 0; i < n; i++)

  00093	85 db		 test	 ebx, ebx
  00095	7e 15		 jle	 SHORT $LN12@lshift

; 871  :     }
; 872  :     x1 = b1->x;

  00097	4c 8b c3	 mov	 r8, rbx
  0009a	33 d2		 xor	 edx, edx
  0009c	48 8b ce	 mov	 rcx, rsi
  0009f	49 c1 e0 02	 shl	 r8, 2
  000a3	e8 00 00 00 00	 call	 memset

; 873  :     for(i = 0; i < n; i++)

  000a8	48 8d 34 9e	 lea	 rsi, QWORD PTR [rsi+rbx*4]
$LN12@lshift:

; 874  :         *x1++ = 0;
; 875  :     x = b->x;
; 876  :     xe = x + b->wds;
; 877  :     if (k &= 0x1f) {

  000ac	41 83 e5 1f	 and	 r13d, 31
  000b0	48 63 45 14	 movsxd	 rax, DWORD PTR [rbp+20]
  000b4	48 8d 14 87	 lea	 rdx, QWORD PTR [rdi+rax*4]
  000b8	74 56		 je	 SHORT $LL3@lshift

; 878  :         k1 = 32 - k;

  000ba	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  000c0	45 2b cd	 sub	 r9d, r13d

; 879  :         z = 0;

  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL8@lshift:

; 880  :         do {
; 881  :             *x1++ = *x << k | z;

  000d0	8b 07		 mov	 eax, DWORD PTR [rdi]
  000d2	41 8b cd	 mov	 ecx, r13d

; 882  :             z = *x++ >> k1;

  000d5	48 83 c7 04	 add	 rdi, 4
  000d9	d3 e0		 shl	 eax, cl
  000db	41 8b c9	 mov	 ecx, r9d
  000de	48 83 c6 04	 add	 rsi, 4
  000e2	41 0b c0	 or	 eax, r8d
  000e5	89 46 fc	 mov	 DWORD PTR [rsi-4], eax
  000e8	44 8b 47 fc	 mov	 r8d, DWORD PTR [rdi-4]
  000ec	41 d3 e8	 shr	 r8d, cl

; 883  :         }
; 884  :         while(x < xe);

  000ef	48 3b fa	 cmp	 rdi, rdx
  000f2	72 dc		 jb	 SHORT $LL8@lshift

; 885  :         if ((*x1 = z))

  000f4	44 89 06	 mov	 DWORD PTR [rsi], r8d
  000f7	45 85 c0	 test	 r8d, r8d
  000fa	74 26		 je	 SHORT $LN1@lshift

; 886  :             ++n1;

  000fc	41 ff c4	 inc	 r12d

; 887  :     }
; 888  :     else do

  000ff	eb 21		 jmp	 SHORT $LN1@lshift
  00101	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL3@lshift:

; 889  :              *x1++ = *x++;

  00110	8b 07		 mov	 eax, DWORD PTR [rdi]
  00112	48 83 c7 04	 add	 rdi, 4
  00116	48 83 c6 04	 add	 rsi, 4
  0011a	89 46 fc	 mov	 DWORD PTR [rsi-4], eax

; 890  :         while(x < xe);

  0011d	48 3b fa	 cmp	 rdi, rdx
  00120	72 ee		 jb	 SHORT $LL3@lshift
$LN1@lshift:

; 891  :     b1->wds = n1 - 1;

  00122	41 8d 44 24 ff	 lea	 eax, DWORD PTR [r12-1]

; 892  :     Bfree(b);

  00127	48 8b cd	 mov	 rcx, rbp
  0012a	41 89 46 14	 mov	 DWORD PTR [r14+20], eax
  0012e	e8 00 00 00 00	 call	 Bfree
  00133	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 893  :     return b1;

  00138	49 8b c6	 mov	 rax, r14
  0013b	e9 32 ff ff ff	 jmp	 $LN33@lshift
$LN17@lshift:

; 860  :         return b;

  00140	48 8b c1	 mov	 rax, rcx

; 894  : }

  00143	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00147	41 5d		 pop	 r13
  00149	5f		 pop	 rdi
  0014a	5d		 pop	 rbp
  0014b	c3		 ret	 0
lshift	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT cmp
_TEXT	SEGMENT
a$ = 8
b$ = 16
cmp	PROC						; COMDAT

; 902  :     ULong *xa, *xa0, *xb, *xb0;
; 903  :     int i, j;
; 904  : 
; 905  :     i = a->wds;
; 906  :     j = b->wds;
; 907  : #ifdef DEBUG
; 908  :     if (i > 1 && !a->x[i-1])
; 909  :         Bug("cmp called with a->x[a->wds-1] == 0");
; 910  :     if (j > 1 && !b->x[j-1])
; 911  :         Bug("cmp called with b->x[b->wds-1] == 0");
; 912  : #endif
; 913  :     if (i -= j)

  00000	8b 41 14	 mov	 eax, DWORD PTR [rcx+20]
  00003	4c 8b ca	 mov	 r9, rdx
  00006	48 63 52 14	 movsxd	 rdx, DWORD PTR [rdx+20]
  0000a	2b c2		 sub	 eax, edx

; 914  :         return i;

  0000c	75 3f		 jne	 SHORT $LN6@cmp

; 915  :     xa0 = a->x;
; 916  :     xa = xa0 + j;
; 917  :     xb0 = b->x;
; 918  :     xb = xb0 + j;
; 919  :     for(;;) {
; 920  :         if (*--xa != *--xb)

  0000e	41 8b 44 91 14	 mov	 eax, DWORD PTR [r9+rdx*4+20]
  00013	4c 8d 41 18	 lea	 r8, QWORD PTR [rcx+24]
  00017	49 8d 4c 91 14	 lea	 rcx, QWORD PTR [r9+rdx*4+20]
  0001c	41 39 44 90 fc	 cmp	 DWORD PTR [r8+rdx*4-4], eax
  00021	49 8d 54 90 fc	 lea	 rdx, QWORD PTR [r8+rdx*4-4]
  00026	75 14		 jne	 SHORT $LN10@cmp
$LL4@cmp:

; 922  :         if (xa <= xa0)

  00028	49 3b d0	 cmp	 rdx, r8
  0002b	76 22		 jbe	 SHORT $LN11@cmp

; 915  :     xa0 = a->x;
; 916  :     xa = xa0 + j;
; 917  :     xb0 = b->x;
; 918  :     xb = xb0 + j;
; 919  :     for(;;) {
; 920  :         if (*--xa != *--xb)

  0002d	8b 41 fc	 mov	 eax, DWORD PTR [rcx-4]
  00030	48 83 e9 04	 sub	 rcx, 4
  00034	48 83 ea 04	 sub	 rdx, 4
  00038	39 02		 cmp	 DWORD PTR [rdx], eax
  0003a	74 ec		 je	 SHORT $LL4@cmp
$LN10@cmp:

; 921  :             return *xa < *xb ? -1 : 1;

  0003c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0003e	41 83 c8 ff	 or	 r8d, -1
  00042	b8 01 00 00 00	 mov	 eax, 1
  00047	39 0a		 cmp	 DWORD PTR [rdx], ecx
  00049	41 0f 42 c0	 cmovb	 eax, r8d
$LN6@cmp:

; 926  : }

  0004d	f3 c3		 fatret	 0
$LN11@cmp:

; 923  :             break;
; 924  :     }
; 925  :     return 0;

  0004f	33 c0		 xor	 eax, eax

; 926  : }

  00051	c3		 ret	 0
cmp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$diff DD	imagerel diff
	DD	imagerel diff+280
	DD	imagerel $unwind$diff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$diff DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT diff
_TEXT	SEGMENT
a$ = 48
b$ = 56
diff	PROC						; COMDAT

; 934  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b ea	 mov	 rbp, rdx
  00017	48 8b f1	 mov	 rsi, rcx

; 935  :     Bigint *c;
; 936  :     int i, wa, wb;
; 937  :     ULong *xa, *xae, *xb, *xbe, *xc;
; 938  : #ifdef ULLong
; 939  :     ULLong borrow, y;
; 940  : #else
; 941  :     ULong borrow, y;
; 942  :     ULong z;
; 943  : #endif
; 944  : 
; 945  :     i = cmp(a,b);

  0001a	e8 00 00 00 00	 call	 cmp

; 946  :     if (!i) {

  0001f	85 c0		 test	 eax, eax
  00021	75 20		 jne	 SHORT $LN12@diff

; 947  :         c = Balloc(0);

  00023	33 c9		 xor	 ecx, ecx
  00025	e8 00 00 00 00	 call	 Balloc

; 948  :         if (c == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 07		 jne	 SHORT $LN11@diff
$LN20@diff:

; 949  :             return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 cd 00 00 00	 jmp	 $LN13@diff
$LN11@diff:

; 950  :         c->wds = 1;

  00036	48 c7 40 14 01
	00 00 00	 mov	 QWORD PTR [rax+20], 1

; 951  :         c->x[0] = 0;
; 952  :         return c;

  0003e	e9 c0 00 00 00	 jmp	 $LN13@diff
$LN12@diff:

; 953  :     }
; 954  :     if (i < 0) {

  00043	33 db		 xor	 ebx, ebx
  00045	85 c0		 test	 eax, eax
  00047	79 0e		 jns	 SHORT $LN10@diff

; 955  :         c = a;

  00049	48 8b c6	 mov	 rax, rsi

; 956  :         a = b;

  0004c	48 8b f5	 mov	 rsi, rbp

; 957  :         b = c;
; 958  :         i = 1;

  0004f	8d 7b 01	 lea	 edi, QWORD PTR [rbx+1]
  00052	48 8b e8	 mov	 rbp, rax

; 959  :     }
; 960  :     else

  00055	eb 02		 jmp	 SHORT $LN9@diff
$LN10@diff:

; 961  :         i = 0;

  00057	8b fb		 mov	 edi, ebx
$LN9@diff:

; 962  :     c = Balloc(a->k);

  00059	8b 4e 08	 mov	 ecx, DWORD PTR [rsi+8]
  0005c	e8 00 00 00 00	 call	 Balloc
  00061	4c 8b d8	 mov	 r11, rax

; 963  :     if (c == NULL)

  00064	48 85 c0	 test	 rax, rax

; 964  :         return NULL;

  00067	74 c6		 je	 SHORT $LN20@diff

; 965  :     c->sign = i;

  00069	89 78 10	 mov	 DWORD PTR [rax+16], edi

; 966  :     wa = a->wds;

  0006c	4c 63 4e 14	 movsxd	 r9, DWORD PTR [rsi+20]

; 967  :     xa = a->x;
; 968  :     xae = xa + wa;
; 969  :     wb = b->wds;
; 970  :     xb = b->x;
; 971  :     xbe = xb + wb;

  00070	48 63 45 14	 movsxd	 rax, DWORD PTR [rbp+20]
  00074	4c 8d 46 18	 lea	 r8, QWORD PTR [rsi+24]

; 972  :     xc = c->x;

  00078	49 8d 53 18	 lea	 rdx, QWORD PTR [r11+24]
  0007c	48 8d 74 85 18	 lea	 rsi, QWORD PTR [rbp+rax*4+24]
  00081	4c 8b d2	 mov	 r10, rdx
  00084	4b 8d 3c 88	 lea	 rdi, QWORD PTR [r8+r9*4]
  00088	4d 2b d3	 sub	 r10, r11
  0008b	4c 03 d5	 add	 r10, rbp
  0008e	66 90		 npad	 2
$LL7@diff:

; 973  :     borrow = 0;
; 974  : #ifdef ULLong
; 975  :     do {
; 976  :         y = (ULLong)*xa++ - *xb++ - borrow;

  00090	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00093	41 8b 02	 mov	 eax, DWORD PTR [r10]

; 977  :         borrow = y >> 32 & (ULong)1;
; 978  :         *xc++ = (ULong)(y & FFFFFFFF);

  00096	49 83 c2 04	 add	 r10, 4
  0009a	48 2b c8	 sub	 rcx, rax
  0009d	49 83 c0 04	 add	 r8, 4
  000a1	48 83 c2 04	 add	 rdx, 4
  000a5	48 2b cb	 sub	 rcx, rbx
  000a8	48 8b d9	 mov	 rbx, rcx
  000ab	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  000ae	48 c1 eb 20	 shr	 rbx, 32			; 00000020H
  000b2	83 e3 01	 and	 ebx, 1

; 979  :     }
; 980  :     while(xb < xbe);

  000b5	4c 3b d6	 cmp	 r10, rsi
  000b8	72 d6		 jb	 SHORT $LL7@diff

; 981  :     while(xa < xae) {

  000ba	4c 3b c7	 cmp	 r8, rdi
  000bd	73 21		 jae	 SHORT $LN17@diff
  000bf	90		 npad	 1
$LL4@diff:

; 982  :         y = *xa++ - borrow;

  000c0	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000c3	49 83 c0 04	 add	 r8, 4

; 983  :         borrow = y >> 32 & (ULong)1;
; 984  :         *xc++ = (ULong)(y & FFFFFFFF);

  000c7	48 83 c2 04	 add	 rdx, 4
  000cb	48 2b c3	 sub	 rax, rbx
  000ce	48 8b d8	 mov	 rbx, rax
  000d1	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  000d4	48 c1 eb 20	 shr	 rbx, 32			; 00000020H
  000d8	83 e3 01	 and	 ebx, 1
  000db	4c 3b c7	 cmp	 r8, rdi
  000de	72 e0		 jb	 SHORT $LL4@diff
$LN17@diff:

; 985  :     }
; 986  : #else
; 987  :     do {
; 988  :         y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;
; 989  :         borrow = (y & 0x10000) >> 16;
; 990  :         z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;
; 991  :         borrow = (z & 0x10000) >> 16;
; 992  :         Storeinc(xc, z, y);
; 993  :     }
; 994  :     while(xb < xbe);
; 995  :     while(xa < xae) {
; 996  :         y = (*xa & 0xffff) - borrow;
; 997  :         borrow = (y & 0x10000) >> 16;
; 998  :         z = (*xa++ >> 16) - borrow;
; 999  :         borrow = (z & 0x10000) >> 16;
; 1000 :         Storeinc(xc, z, y);
; 1001 :     }
; 1002 : #endif
; 1003 :     while(!*--xc)

  000e0	48 83 ea 04	 sub	 rdx, 4
  000e4	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  000e7	75 13		 jne	 SHORT $LN1@diff
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@diff:
  000f0	48 83 ea 04	 sub	 rdx, 4

; 1004 :         wa--;

  000f4	41 ff c9	 dec	 r9d
  000f7	83 3a 00	 cmp	 DWORD PTR [rdx], 0
  000fa	74 f4		 je	 SHORT $LL2@diff
$LN1@diff:

; 1005 :     c->wds = wa;

  000fc	45 89 4b 14	 mov	 DWORD PTR [r11+20], r9d

; 1006 :     return c;

  00100	49 8b c3	 mov	 rax, r11
$LN13@diff:

; 1007 : }

  00103	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00108	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0010d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00112	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00116	5f		 pop	 rdi
  00117	c3		 ret	 0
diff	ENDP
_TEXT	ENDS
EXTRN	_fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ulp
_TEXT	SEGMENT
u$ = 8
x$ = 8
ulp	PROC						; COMDAT

; 1015 :     Long L;
; 1016 :     U u;
; 1017 : 
; 1018 :     L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;

  00000	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]

; 1019 :     word0(&u) = L;
; 1020 :     word1(&u) = 0;

  00003	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR u$[rsp], 0
  0000b	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00010	2d 00 00 40 03	 sub	 eax, 54525952		; 03400000H
  00015	89 44 24 0c	 mov	 DWORD PTR u$[rsp+4], eax

; 1021 :     return dval(&u);

  00019	f2 0f 10 44 24
	08		 movsdx	 xmm0, QWORD PTR u$[rsp]

; 1022 : }

  0001f	c3		 ret	 0
ulp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$b2d DD	imagerel b2d
	DD	imagerel b2d+260
	DD	imagerel $unwind$b2d
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$b2d DD	040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT b2d
_TEXT	SEGMENT
d$ = 48
a$ = 48
e$ = 56
b2d	PROC						; COMDAT

; 1028 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1029 :     ULong *xa, *xa0, w, y, z;
; 1030 :     int k;
; 1031 :     U d;
; 1032 : 
; 1033 :     xa0 = a->x;
; 1034 :     xa = xa0 + a->wds;
; 1035 :     y = *--xa;

  0000a	48 63 41 14	 movsxd	 rax, DWORD PTR [rcx+20]
  0000e	48 8d 59 18	 lea	 rbx, QWORD PTR [rcx+24]
  00012	44 8b 44 83 fc	 mov	 r8d, DWORD PTR [rbx+rax*4-4]
  00017	4c 8d 4c 83 fc	 lea	 r9, QWORD PTR [rbx+rax*4-4]

; 1036 : #ifdef DEBUG
; 1037 :     if (!y) Bug("zero y in b2d");
; 1038 : #endif
; 1039 :     k = hi0bits(y);

  0001c	41 8b c8	 mov	 ecx, r8d
  0001f	e8 00 00 00 00	 call	 hi0bits

; 1040 :     *e = 32 - k;

  00024	bf 20 00 00 00	 mov	 edi, 32			; 00000020H
  00029	8b cf		 mov	 ecx, edi
  0002b	44 8b d8	 mov	 r11d, eax
  0002e	2b c8		 sub	 ecx, eax
  00030	89 0a		 mov	 DWORD PTR [rdx], ecx

; 1041 :     if (k < Ebits) {

  00032	83 f8 0b	 cmp	 eax, 11
  00035	7d 4a		 jge	 SHORT $LN3@b2d

; 1042 :         word0(&d) = Exp_1 | y >> (Ebits - k);

  00037	b8 0b 00 00 00	 mov	 eax, 11
  0003c	41 8b d0	 mov	 edx, r8d
  0003f	41 2b c3	 sub	 eax, r11d
  00042	8b c8		 mov	 ecx, eax
  00044	d3 ea		 shr	 edx, cl
  00046	81 ca 00 00 f0
	3f		 or	 edx, 1072693248		; 3ff00000H
  0004c	89 54 24 34	 mov	 DWORD PTR d$[rsp+4], edx

; 1043 :         w = xa > xa0 ? *--xa : 0;

  00050	4c 3b cb	 cmp	 r9, rbx
  00053	76 06		 jbe	 SHORT $LN6@b2d
  00055	41 8b 51 fc	 mov	 edx, DWORD PTR [r9-4]
  00059	eb 02		 jmp	 SHORT $LN7@b2d
$LN6@b2d:
  0005b	33 d2		 xor	 edx, edx
$LN7@b2d:

; 1044 :         word1(&d) = y << ((32-Ebits) + k) | w >> (Ebits - k);

  0005d	41 8d 4b 15	 lea	 ecx, DWORD PTR [r11+21]
  00061	41 d3 e0	 shl	 r8d, cl
  00064	8b c8		 mov	 ecx, eax
  00066	d3 ea		 shr	 edx, cl
  00068	44 0b c2	 or	 r8d, edx
  0006b	44 89 44 24 30	 mov	 DWORD PTR d$[rsp], r8d

; 1052 :     }
; 1053 :     else {
; 1054 :         word0(&d) = Exp_1 | y;
; 1055 :         word1(&d) = z;
; 1056 :     }
; 1057 :   ret_d:
; 1058 :     return dval(&d);

  00070	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR d$[rsp]
$ret_d$20576:

; 1059 : }

  00076	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
$LN3@b2d:

; 1045 :         goto ret_d;
; 1046 :     }
; 1047 :     z = xa > xa0 ? *--xa : 0;

  00081	33 d2		 xor	 edx, edx
  00083	4c 3b cb	 cmp	 r9, rbx
  00086	76 0a		 jbe	 SHORT $LN8@b2d
  00088	45 8b 51 fc	 mov	 r10d, DWORD PTR [r9-4]
  0008c	49 83 e9 04	 sub	 r9, 4
  00090	eb 03		 jmp	 SHORT $LN9@b2d
$LN8@b2d:
  00092	44 8b d2	 mov	 r10d, edx
$LN9@b2d:

; 1048 :     if (k -= Ebits) {

  00095	41 83 eb 0b	 sub	 r11d, 11
  00099	74 47		 je	 SHORT $LN2@b2d

; 1049 :         word0(&d) = Exp_1 | y << k | z >> (32 - k);

  0009b	41 2b fb	 sub	 edi, r11d
  0009e	41 8b c2	 mov	 eax, r10d
  000a1	8b cf		 mov	 ecx, edi
  000a3	d3 e8		 shr	 eax, cl
  000a5	41 8b cb	 mov	 ecx, r11d
  000a8	41 d3 e0	 shl	 r8d, cl
  000ab	41 0b c0	 or	 eax, r8d
  000ae	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  000b3	89 44 24 34	 mov	 DWORD PTR d$[rsp+4], eax

; 1050 :         y = xa > xa0 ? *--xa : 0;

  000b7	4c 3b cb	 cmp	 r9, rbx
  000ba	76 04		 jbe	 SHORT $LN10@b2d
  000bc	41 8b 51 fc	 mov	 edx, DWORD PTR [r9-4]
$LN10@b2d:

; 1051 :         word1(&d) = z << k | y >> (32 - k);

  000c0	8b cf		 mov	 ecx, edi
  000c2	d3 ea		 shr	 edx, cl
  000c4	41 8b cb	 mov	 ecx, r11d
  000c7	41 d3 e2	 shl	 r10d, cl
  000ca	41 0b d2	 or	 edx, r10d
  000cd	89 54 24 30	 mov	 DWORD PTR d$[rsp], edx

; 1052 :     }
; 1053 :     else {
; 1054 :         word0(&d) = Exp_1 | y;
; 1055 :         word1(&d) = z;
; 1056 :     }
; 1057 :   ret_d:
; 1058 :     return dval(&d);

  000d1	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR d$[rsp]
$ret_d_1$20576:

; 1059 : }

  000d7	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
$LN2@b2d:
  000e2	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000e7	41 81 c8 00 00
	f0 3f		 or	 r8d, 1072693248		; 3ff00000H
  000ee	44 89 54 24 30	 mov	 DWORD PTR d$[rsp], r10d
  000f3	44 89 44 24 34	 mov	 DWORD PTR d$[rsp+4], r8d
$ret_d_2$20576:
  000f8	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR d$[rsp]
  000fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
b2d	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sd2b DD	imagerel sd2b
	DD	imagerel sd2b+271
	DD	imagerel $unwind$sd2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sd2b DD	060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT sd2b
_TEXT	SEGMENT
d$ = 48
scale$ = 56
e$ = 64
sd2b	PROC						; COMDAT

; 1084 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 1085 :     Bigint *b;
; 1086 : 
; 1087 :     b = Balloc(1);

  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	49 8b d8	 mov	 rbx, r8
  0001a	8b fa		 mov	 edi, edx
  0001c	e8 00 00 00 00	 call	 Balloc
  00021	4c 8b d8	 mov	 r11, rax

; 1088 :     if (b == NULL)

  00024	48 85 c0	 test	 rax, rax
  00027	75 10		 jne	 SHORT $LN9@sd2b

; 1127 : 
; 1128 :     return b;
; 1129 : }

  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
$LN9@sd2b:

; 1089 :         return NULL;
; 1090 :     
; 1091 :     /* First construct b and e assuming that scale == 0. */
; 1092 :     b->wds = 2;

  00039	c7 40 14 02 00
	00 00		 mov	 DWORD PTR [rax+20], 2

; 1093 :     b->x[0] = word1(d);

  00040	8b 06		 mov	 eax, DWORD PTR [rsi]
  00042	41 89 43 18	 mov	 DWORD PTR [r11+24], eax

; 1094 :     b->x[1] = word0(d) & Frac_mask;

  00046	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00049	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0004e	41 89 43 1c	 mov	 DWORD PTR [r11+28], eax

; 1095 :     *e = Etiny - 1 + (int)((word0(d) & Exp_mask) >> Exp_shift);

  00052	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  00055	c1 e8 14	 shr	 eax, 20
  00058	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0005d	05 cd fb ff ff	 add	 eax, -1075		; fffffffffffffbcdH
  00062	89 03		 mov	 DWORD PTR [rbx], eax

; 1096 :     if (*e < Etiny)

  00064	3d ce fb ff ff	 cmp	 eax, -1074		; fffffffffffffbceH
  00069	7d 08		 jge	 SHORT $LN8@sd2b

; 1097 :         *e = Etiny;

  0006b	c7 03 ce fb ff
	ff		 mov	 DWORD PTR [rbx], -1074	; fffffffffffffbceH

; 1098 :     else

  00071	eb 08		 jmp	 SHORT $LN7@sd2b
$LN8@sd2b:

; 1099 :         b->x[1] |= Exp_msk1;

  00073	41 81 4b 1c 00
	00 10 00	 or	 DWORD PTR [r11+28], 1048576 ; 00100000H
$LN7@sd2b:

; 1100 : 
; 1101 :     /* Now adjust for scale, provided that b != 0. */
; 1102 :     if (scale && (b->x[0] || b->x[1])) {

  0007b	85 ff		 test	 edi, edi
  0007d	74 6e		 je	 SHORT $LN2@sd2b
  0007f	41 83 7b 18 00	 cmp	 DWORD PTR [r11+24], 0
  00084	75 07		 jne	 SHORT $LN5@sd2b
  00086	41 83 7b 1c 00	 cmp	 DWORD PTR [r11+28], 0
  0008b	74 67		 je	 SHORT $LN13@sd2b
$LN5@sd2b:

; 1103 :         *e -= scale;

  0008d	29 3b		 sub	 DWORD PTR [rbx], edi
  0008f	8b 03		 mov	 eax, DWORD PTR [rbx]

; 1104 :         if (*e < Etiny) {

  00091	3d ce fb ff ff	 cmp	 eax, -1074		; fffffffffffffbceH
  00096	7d 55		 jge	 SHORT $LN2@sd2b

; 1105 :             scale = Etiny - *e;

  00098	41 b9 ce fb ff
	ff		 mov	 r9d, -1074		; fffffffffffffbceH

; 1106 :             *e = Etiny;

  0009e	c7 03 ce fb ff
	ff		 mov	 DWORD PTR [rbx], -1074	; fffffffffffffbceH
  000a4	44 2b c8	 sub	 r9d, eax

; 1107 :             /* We can't shift more than P-1 bits without shifting out a 1. */
; 1108 :             assert(0 < scale && scale <= P - 1);
; 1109 :             if (scale >= 32) {

  000a7	41 83 f9 20	 cmp	 r9d, 32			; 00000020H
  000ab	7c 14		 jl	 SHORT $LN3@sd2b

; 1110 :                 /* The bits shifted out should all be zero. */
; 1111 :                 assert(b->x[0] == 0);
; 1112 :                 b->x[0] = b->x[1];

  000ad	41 8b 43 1c	 mov	 eax, DWORD PTR [r11+28]

; 1113 :                 b->x[1] = 0;
; 1114 :                 scale -= 32;

  000b1	41 83 e9 20	 sub	 r9d, 32			; 00000020H
  000b5	41 c7 43 1c 00
	00 00 00	 mov	 DWORD PTR [r11+28], 0
  000bd	41 89 43 18	 mov	 DWORD PTR [r11+24], eax
$LN3@sd2b:

; 1115 :             }
; 1116 :             if (scale) {

  000c1	45 85 c9	 test	 r9d, r9d
  000c4	74 27		 je	 SHORT $LN2@sd2b

; 1117 :                 /* The bits shifted out should all be zero. */
; 1118 :                 assert(b->x[0] << (32 - scale) == 0);
; 1119 :                 b->x[0] = (b->x[0] >> scale) | (b->x[1] << (32 - scale));

  000c6	45 8b 43 1c	 mov	 r8d, DWORD PTR [r11+28]
  000ca	41 8b 43 18	 mov	 eax, DWORD PTR [r11+24]
  000ce	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000d3	41 2b c9	 sub	 ecx, r9d
  000d6	41 8b d0	 mov	 edx, r8d
  000d9	d3 e2		 shl	 edx, cl
  000db	41 8b c9	 mov	 ecx, r9d
  000de	d3 e8		 shr	 eax, cl
  000e0	0b d0		 or	 edx, eax

; 1120 :                 b->x[1] >>= scale;

  000e2	41 d3 e8	 shr	 r8d, cl
  000e5	45 89 43 1c	 mov	 DWORD PTR [r11+28], r8d
  000e9	41 89 53 18	 mov	 DWORD PTR [r11+24], edx
$LN2@sd2b:

; 1121 :             }
; 1122 :         }
; 1123 :     }
; 1124 :     /* Ensure b is normalized. */
; 1125 :     if (!b->x[1])

  000ed	41 83 7b 1c 00	 cmp	 DWORD PTR [r11+28], 0
  000f2	75 08		 jne	 SHORT $LN1@sd2b
$LN13@sd2b:

; 1126 :         b->wds = 1;

  000f4	41 c7 43 14 01
	00 00 00	 mov	 DWORD PTR [r11+20], 1
$LN1@sd2b:

; 1127 : 
; 1128 :     return b;
; 1129 : }

  000fc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00101	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00106	49 8b c3	 mov	 rax, r11
  00109	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
sd2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$d2b DD	imagerel d2b
	DD	imagerel d2b+307
	DD	imagerel $unwind$d2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$d2b DD	083d01H
	DD	0a743dH
	DD	0b340dH
	DD	0c009520dH
	DD	050066007H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT d2b
_TEXT	SEGMENT
z$ = 32
d$ = 80
e$ = 88
bits$ = 96
y$ = 104
d2b	PROC						; COMDAT

; 1142 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	41 54		 push	 r12
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8b f1	 mov	 rsi, rcx

; 1143 :     Bigint *b;
; 1144 :     int de, k;
; 1145 :     ULong *x, y, z;
; 1146 :     int i;
; 1147 : 
; 1148 :     b = Balloc(1);

  00010	bb 01 00 00 00	 mov	 ebx, 1
  00015	49 8b e8	 mov	 rbp, r8
  00018	8b cb		 mov	 ecx, ebx
  0001a	4c 8b e2	 mov	 r12, rdx
  0001d	e8 00 00 00 00	 call	 Balloc
  00022	4c 8b d8	 mov	 r11, rax

; 1149 :     if (b == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 0e		 jne	 SHORT $LN8@d2b

; 1181 :     }
; 1182 :     return b;
; 1183 : }

  0002a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	41 5c		 pop	 r12
  00035	5e		 pop	 rsi
  00036	5d		 pop	 rbp
  00037	c3		 ret	 0
$LN8@d2b:
  00038	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi

; 1150 :         return NULL;
; 1151 :     x = b->x;
; 1152 : 
; 1153 :     z = word0(d) & Frac_mask;

  0003d	8b 7e 04	 mov	 edi, DWORD PTR [rsi+4]
  00040	44 8b d7	 mov	 r10d, edi

; 1154 :     word0(d) &= 0x7fffffff;   /* clear sign bit, which we ignore */

  00043	0f ba f7 1f	 btr	 edi, 31
  00047	41 81 e2 ff ff
	0f 00		 and	 r10d, 1048575		; 000fffffH
  0004e	89 7e 04	 mov	 DWORD PTR [rsi+4], edi

; 1155 :     if ((de = (int)(word0(d) >> Exp_shift)))

  00051	c1 ef 14	 shr	 edi, 20
  00054	44 89 54 24 20	 mov	 DWORD PTR z$[rsp], r10d
  00059	85 ff		 test	 edi, edi
  0005b	74 0a		 je	 SHORT $LN7@d2b

; 1156 :         z |= Exp_msk1;

  0005d	41 0f ba ea 14	 bts	 r10d, 20
  00062	44 89 54 24 20	 mov	 DWORD PTR z$[rsp], r10d
$LN7@d2b:

; 1157 :     if ((y = word1(d))) {

  00067	8b 06		 mov	 eax, DWORD PTR [rsi]
  00069	89 44 24 68	 mov	 DWORD PTR y$[rsp], eax
  0006d	85 c0		 test	 eax, eax
  0006f	74 52		 je	 SHORT $LN6@d2b

; 1158 :         if ((k = lo0bits(&y))) {

  00071	48 8d 4c 24 68	 lea	 rcx, QWORD PTR y$[rsp]
  00076	e8 00 00 00 00	 call	 lo0bits
  0007b	44 8b c8	 mov	 r9d, eax
  0007e	85 c0		 test	 eax, eax
  00080	74 29		 je	 SHORT $LN5@d2b

; 1164 :         i =
; 1165 :             b->wds = (x[1] = z) ? 2 : 1;

  00082	33 db		 xor	 ebx, ebx
  00084	41 8b d2	 mov	 edx, r10d
  00087	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0008c	2b c8		 sub	 ecx, eax
  0008e	d3 e2		 shl	 edx, cl
  00090	8b c8		 mov	 ecx, eax
  00092	0b 54 24 68	 or	 edx, DWORD PTR y$[rsp]
  00096	41 d3 ea	 shr	 r10d, cl
  00099	45 85 d2	 test	 r10d, r10d
  0009c	41 89 53 18	 mov	 DWORD PTR [r11+24], edx
  000a0	45 89 53 1c	 mov	 DWORD PTR [r11+28], r10d
  000a4	0f 95 c3	 setne	 bl
  000a7	ff c3		 inc	 ebx

; 1166 :     }
; 1167 :     else {

  000a9	eb 31		 jmp	 SHORT $LN11@d2b
$LN5@d2b:

; 1159 :             x[0] = y | z << (32 - k);
; 1160 :             z >>= k;
; 1161 :         }
; 1162 :         else
; 1163 :             x[0] = y;

  000ab	8b 44 24 68	 mov	 eax, DWORD PTR y$[rsp]

; 1164 :         i =
; 1165 :             b->wds = (x[1] = z) ? 2 : 1;

  000af	33 db		 xor	 ebx, ebx
  000b1	45 85 d2	 test	 r10d, r10d
  000b4	0f 95 c3	 setne	 bl
  000b7	41 89 43 18	 mov	 DWORD PTR [r11+24], eax
  000bb	45 89 53 1c	 mov	 DWORD PTR [r11+28], r10d
  000bf	ff c3		 inc	 ebx

; 1166 :     }
; 1167 :     else {

  000c1	eb 19		 jmp	 SHORT $LN11@d2b
$LN6@d2b:

; 1168 :         k = lo0bits(&z);

  000c3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR z$[rsp]
  000c8	e8 00 00 00 00	 call	 lo0bits
  000cd	44 8b c8	 mov	 r9d, eax

; 1169 :         x[0] = z;

  000d0	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  000d4	41 89 43 18	 mov	 DWORD PTR [r11+24], eax

; 1170 :         i =
; 1171 :             b->wds = 1;
; 1172 :         k += 32;

  000d8	41 83 c1 20	 add	 r9d, 32			; 00000020H
$LN11@d2b:

; 1173 :     }
; 1174 :     if (de) {

  000dc	41 89 5b 14	 mov	 DWORD PTR [r11+20], ebx
  000e0	85 ff		 test	 edi, edi
  000e2	74 19		 je	 SHORT $LN2@d2b

; 1175 :         *e = de - Bias - (P-1) + k;

  000e4	41 8d 84 39 cd
	fb ff ff	 lea	 eax, DWORD PTR [r9+rdi-1075]
  000ec	41 89 04 24	 mov	 DWORD PTR [r12], eax

; 1176 :         *bits = P - k;

  000f0	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  000f5	41 2b c1	 sub	 eax, r9d
  000f8	89 45 00	 mov	 DWORD PTR [rbp], eax

; 1177 :     }
; 1178 :     else {

  000fb	eb 20		 jmp	 SHORT $LN1@d2b
$LN2@d2b:

; 1179 :         *e = de - Bias - (P-1) + 1 + k;

  000fd	41 8d 81 ce fb
	ff ff		 lea	 eax, DWORD PTR [r9-1074]
  00104	41 89 04 24	 mov	 DWORD PTR [r12], eax

; 1180 :         *bits = 32*i - hi0bits(x[i-1]);

  00108	48 63 c3	 movsxd	 rax, ebx
  0010b	41 8b 4c 83 14	 mov	 ecx, DWORD PTR [r11+rax*4+20]
  00110	e8 00 00 00 00	 call	 hi0bits
  00115	c1 e3 05	 shl	 ebx, 5
  00118	2b d8		 sub	 ebx, eax
  0011a	89 5d 00	 mov	 DWORD PTR [rbp], ebx
$LN1@d2b:

; 1181 :     }
; 1182 :     return b;
; 1183 : }

  0011d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00122	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00127	49 8b c3	 mov	 rax, r11
  0012a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012e	41 5c		 pop	 r12
  00130	5e		 pop	 rsi
  00131	5d		 pop	 rbp
  00132	c3		 ret	 0
d2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ratio DD	imagerel ratio
	DD	imagerel ratio+140
	DD	imagerel $unwind$ratio
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ratio DD 030701H
	DD	070034207H
	DD	03002H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ratio
_TEXT	SEGMENT
kb$ = 64
a$ = 64
ka$ = 72
b$ = 72
da$ = 80
db$ = 88
ratio	PROC						; COMDAT

; 1190 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00007	48 8b da	 mov	 rbx, rdx

; 1191 :     U da, db;
; 1192 :     int k, ka, kb;
; 1193 : 
; 1194 :     dval(&da) = b2d(a, &ka);

  0000a	48 8d 54 24 48	 lea	 rdx, QWORD PTR ka$[rsp]
  0000f	48 8b f9	 mov	 rdi, rcx
  00012	e8 00 00 00 00	 call	 b2d

; 1195 :     dval(&db) = b2d(b, &kb);

  00017	48 8d 54 24 40	 lea	 rdx, QWORD PTR kb$[rsp]
  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR da$[rsp], xmm0
  00025	66 0f 28 c8	 movapd	 xmm1, xmm0
  00029	e8 00 00 00 00	 call	 b2d

; 1196 :     k = ka - kb + 32*(a->wds - b->wds);

  0002e	8b 4f 14	 mov	 ecx, DWORD PTR [rdi+20]
  00031	2b 4b 14	 sub	 ecx, DWORD PTR [rbx+20]
  00034	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR db$[rsp], xmm0
  0003a	c1 e1 05	 shl	 ecx, 5
  0003d	2b 4c 24 40	 sub	 ecx, DWORD PTR kb$[rsp]
  00041	03 4c 24 48	 add	 ecx, DWORD PTR ka$[rsp]

; 1197 :     if (k > 0)

  00045	85 c9		 test	 ecx, ecx
  00047	7e 1c		 jle	 SHORT $LN2@ratio

; 1198 :         word0(&da) += k*Exp_msk1;

  00049	c1 e1 14	 shl	 ecx, 20
  0004c	01 4c 24 54	 add	 DWORD PTR da$[rsp+4], ecx

; 1199 :     else {

  00050	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR da$[rsp]

; 1202 :     }
; 1203 :     return dval(&da) / dval(&db);

  00056	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0005a	66 0f 28 c1	 movapd	 xmm0, xmm1

; 1204 : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	5f		 pop	 rdi
  00063	5b		 pop	 rbx
  00064	c3		 ret	 0
$LN2@ratio:

; 1200 :         k = -k;
; 1201 :         word0(&db) += k*Exp_msk1;

  00065	48 8b 44 24 58	 mov	 rax, QWORD PTR db$[rsp]
  0006a	c1 e1 14	 shl	 ecx, 20
  0006d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00071	2b c1		 sub	 eax, ecx
  00073	89 44 24 5c	 mov	 DWORD PTR db$[rsp+4], eax
  00077	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR db$[rsp]

; 1202 :     }
; 1203 :     return dval(&da) / dval(&db);

  0007d	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00081	66 0f 28 c1	 movapd	 xmm0, xmm1

; 1204 : }

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	5f		 pop	 rdi
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
ratio	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dshift DD imagerel dshift
	DD	imagerel dshift+34
	DD	imagerel $unwind$dshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dshift DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT dshift
_TEXT	SEGMENT
b$ = 48
p2$ = 56
dshift	PROC						; COMDAT

; 1231 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1232 :     int rv = hi0bits(b->x[b->wds-1]) - 4;

  00004	48 63 41 14	 movsxd	 rax, DWORD PTR [rcx+20]
  00008	8b 4c 81 14	 mov	 ecx, DWORD PTR [rcx+rax*4+20]
  0000c	e8 00 00 00 00	 call	 hi0bits
  00011	83 e8 04	 sub	 eax, 4

; 1233 :     if (p2 > 0)

  00014	85 d2		 test	 edx, edx
  00016	7e 02		 jle	 SHORT $LN1@dshift

; 1234 :         rv -= p2;

  00018	2b c2		 sub	 eax, edx
$LN1@dshift:

; 1235 :     return rv & kmask;

  0001a	83 e0 1f	 and	 eax, 31

; 1236 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
dshift	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$quorem DD imagerel quorem
	DD	imagerel quorem+53
	DD	imagerel $unwind$quorem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$quorem DD imagerel quorem+53
	DD	imagerel quorem+109
	DD	imagerel $chain$5$quorem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$quorem DD imagerel quorem+109
	DD	imagerel quorem+199
	DD	imagerel $chain$6$quorem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$quorem DD imagerel quorem+199
	DD	imagerel quorem+254
	DD	imagerel $chain$7$quorem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$quorem DD imagerel quorem+254
	DD	imagerel quorem+390
	DD	imagerel $chain$8$quorem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$quorem DD 020021H
	DD	05e400H
	DD	imagerel quorem
	DD	imagerel quorem+53
	DD	imagerel $unwind$quorem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$quorem DD 021H
	DD	imagerel quorem+53
	DD	imagerel quorem+109
	DD	imagerel $chain$5$quorem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$quorem DD 020521H
	DD	04f405H
	DD	imagerel quorem+53
	DD	imagerel quorem+109
	DD	imagerel $chain$5$quorem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$quorem DD 061721H
	DD	05e417H
	DD	06d40dH
	DD	07c405H
	DD	imagerel quorem
	DD	imagerel quorem+53
	DD	imagerel $unwind$quorem
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$quorem DD 082d01H
	DD	0c742dH
	DD	0b5428H
	DD	0a3423H
	DD	060027206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT quorem
_TEXT	SEGMENT
b$ = 80
S$ = 88
quorem	PROC						; COMDAT

; 1244 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1245 :     int n;
; 1246 :     ULong *bx, *bxe, q, *sx, *sxe;
; 1247 : #ifdef ULLong
; 1248 :     ULLong borrow, carry, y, ys;
; 1249 : #else
; 1250 :     ULong borrow, carry, y, ys;
; 1251 :     ULong si, z, zs;
; 1252 : #endif
; 1253 : 
; 1254 :     n = S->wds;

  00006	44 8b 52 14	 mov	 r10d, DWORD PTR [rdx+20]
  0000a	4c 8b ca	 mov	 r9, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 1255 : #ifdef DEBUG
; 1256 :     /*debug*/ if (b->wds > n)
; 1257 :         /*debug*/       Bug("oversize b in quorem");
; 1258 : #endif
; 1259 :     if (b->wds < n)

  00010	44 39 51 14	 cmp	 DWORD PTR [rcx+20], r10d
  00014	7d 08		 jge	 SHORT $LN15@quorem

; 1260 :         return 0;

  00016	33 c0		 xor	 eax, eax

; 1335 : }

  00018	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0001c	5e		 pop	 rsi
  0001d	c3		 ret	 0
$LN15@quorem:
  0001e	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00023	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00028	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi

; 1261 :     sx = S->x;

  0002d	48 8d 7a 18	 lea	 rdi, QWORD PTR [rdx+24]

; 1262 :     sxe = sx + --n;
; 1263 :     bx = b->x;

  00031	4c 8d 59 18	 lea	 r11, QWORD PTR [rcx+24]
  00035	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0003a	41 ff ca	 dec	 r10d
  0003d	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13

; 1264 :     bxe = bx + n;
; 1265 :     q = *bxe / (*sxe + 1);      /* ensure q <= true quotient */

  00042	33 d2		 xor	 edx, edx
  00044	49 63 c2	 movsxd	 rax, r10d
  00047	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14

; 1266 : #ifdef DEBUG
; 1267 :     /*debug*/ if (q > 9)
; 1268 :         /*debug*/       Bug("oversized quotient in quorem");
; 1269 : #endif
; 1270 :     if (q) {

  0004c	33 db		 xor	 ebx, ebx
  0004e	8b 0c 87	 mov	 ecx, DWORD PTR [rdi+rax*4]
  00051	4c 8d 34 87	 lea	 r14, QWORD PTR [rdi+rax*4]
  00055	4d 8d 04 83	 lea	 r8, QWORD PTR [r11+rax*4]
  00059	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]
  0005d	ff c1		 inc	 ecx
  0005f	4c 8b e7	 mov	 r12, rdi
  00062	f7 f1		 div	 ecx
  00064	4d 8b eb	 mov	 r13, r11
  00067	8b e8		 mov	 ebp, eax
  00069	85 c0		 test	 eax, eax
  0006b	74 78		 je	 SHORT $LN10@quorem

; 1271 :         borrow = 0;

  0006d	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  00072	8b d3		 mov	 edx, ebx

; 1272 :         carry = 0;

  00074	44 8b db	 mov	 r11d, ebx

; 1280 : #else
; 1281 :             si = *sx++;
; 1282 :             ys = (si & 0xffff) * q + carry;
; 1283 :             zs = (si >> 16) * q + (ys >> 16);
; 1284 :             carry = zs >> 16;
; 1285 :             y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
; 1286 :             borrow = (y & 0x10000) >> 16;
; 1287 :             z = (*bx >> 16) - (zs & 0xffff) - borrow;
; 1288 :             borrow = (z & 0x10000) >> 16;
; 1289 :             Storeinc(bx, z, y);
; 1290 : #endif
; 1291 :         }
; 1292 :         while(sx <= sxe);

  00077	44 8b fd	 mov	 r15d, ebp
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL13@quorem:

; 1273 :         do {
; 1274 : #ifdef ULLong
; 1275 :             ys = *sx++ * (ULLong)q + carry;

  00080	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]
  00084	49 83 c4 04	 add	 r12, 4

; 1276 :             carry = ys >> 32;
; 1277 :             y = *bx - (ys & FFFFFFFF) - borrow;
; 1278 :             borrow = y >> 32 & (ULong)1;
; 1279 :             *bx++ = (ULong)(y & FFFFFFFF);

  00088	49 83 c5 04	 add	 r13, 4
  0008c	49 0f af cf	 imul	 rcx, r15
  00090	49 03 cb	 add	 rcx, r11
  00093	4c 8b d9	 mov	 r11, rcx
  00096	8b c1		 mov	 eax, ecx
  00098	41 8b 4d fc	 mov	 ecx, DWORD PTR [r13-4]
  0009c	48 2b c8	 sub	 rcx, rax
  0009f	49 c1 eb 20	 shr	 r11, 32			; 00000020H
  000a3	48 2b ca	 sub	 rcx, rdx
  000a6	48 8b d1	 mov	 rdx, rcx
  000a9	41 89 4d fc	 mov	 DWORD PTR [r13-4], ecx
  000ad	48 c1 ea 20	 shr	 rdx, 32			; 00000020H
  000b1	83 e2 01	 and	 edx, 1

; 1280 : #else
; 1281 :             si = *sx++;
; 1282 :             ys = (si & 0xffff) * q + carry;
; 1283 :             zs = (si >> 16) * q + (ys >> 16);
; 1284 :             carry = zs >> 16;
; 1285 :             y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
; 1286 :             borrow = (y & 0x10000) >> 16;
; 1287 :             z = (*bx >> 16) - (zs & 0xffff) - borrow;
; 1288 :             borrow = (z & 0x10000) >> 16;
; 1289 :             Storeinc(bx, z, y);
; 1290 : #endif
; 1291 :         }
; 1292 :         while(sx <= sxe);

  000b4	4d 3b e6	 cmp	 r12, r14
  000b7	76 c7		 jbe	 SHORT $LL13@quorem

; 1293 :         if (!*bxe) {

  000b9	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  000be	4c 8d 5e 18	 lea	 r11, QWORD PTR [rsi+24]
  000c2	41 39 18	 cmp	 DWORD PTR [r8], ebx
  000c5	75 1e		 jne	 SHORT $LN10@quorem

; 1294 :             bx = b->x;
; 1295 :             while(--bxe > bx && !*bxe)

  000c7	49 83 e8 04	 sub	 r8, 4
  000cb	4d 3b c3	 cmp	 r8, r11
  000ce	76 11		 jbe	 SHORT $LN24@quorem
$LL9@quorem:
  000d0	41 39 18	 cmp	 DWORD PTR [r8], ebx
  000d3	75 0c		 jne	 SHORT $LN24@quorem
  000d5	49 83 e8 04	 sub	 r8, 4

; 1296 :                 --n;

  000d9	41 ff ca	 dec	 r10d
  000dc	4d 3b c3	 cmp	 r8, r11
  000df	77 ef		 ja	 SHORT $LL9@quorem
$LN24@quorem:

; 1297 :             b->wds = n;

  000e1	44 89 56 14	 mov	 DWORD PTR [rsi+20], r10d
$LN10@quorem:

; 1298 :         }
; 1299 :     }
; 1300 :     if (cmp(b, S) >= 0) {

  000e5	49 8b d1	 mov	 rdx, r9
  000e8	48 8b ce	 mov	 rcx, rsi
  000eb	e8 00 00 00 00	 call	 cmp
  000f0	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  000f5	4c 8b 64 24 38	 mov	 r12, QWORD PTR [rsp+56]
  000fa	85 c0		 test	 eax, eax
  000fc	78 6c		 js	 SHORT $LN3@quorem

; 1301 :         q++;

  000fe	ff c5		 inc	 ebp

; 1302 :         borrow = 0;
; 1303 :         carry = 0;

  00100	4c 8b c3	 mov	 r8, rbx

; 1304 :         bx = b->x;

  00103	49 8b d3	 mov	 rdx, r11
  00106	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL6@quorem:

; 1305 :         sx = S->x;
; 1306 :         do {
; 1307 : #ifdef ULLong
; 1308 :             ys = *sx++ + carry;

  00110	8b 07		 mov	 eax, DWORD PTR [rdi]

; 1309 :             carry = ys >> 32;
; 1310 :             y = *bx - (ys & FFFFFFFF) - borrow;

  00112	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00114	48 83 c7 04	 add	 rdi, 4
  00118	49 03 c0	 add	 rax, r8

; 1311 :             borrow = y >> 32 & (ULong)1;
; 1312 :             *bx++ = (ULong)(y & FFFFFFFF);

  0011b	48 83 c2 04	 add	 rdx, 4
  0011f	4c 8b c0	 mov	 r8, rax
  00122	8b c0		 mov	 eax, eax
  00124	48 2b c8	 sub	 rcx, rax
  00127	49 c1 e8 20	 shr	 r8, 32			; 00000020H
  0012b	48 2b cb	 sub	 rcx, rbx
  0012e	48 8b d9	 mov	 rbx, rcx
  00131	89 4a fc	 mov	 DWORD PTR [rdx-4], ecx
  00134	48 c1 eb 20	 shr	 rbx, 32			; 00000020H
  00138	83 e3 01	 and	 ebx, 1

; 1313 : #else
; 1314 :             si = *sx++;
; 1315 :             ys = (si & 0xffff) + carry;
; 1316 :             zs = (si >> 16) + (ys >> 16);
; 1317 :             carry = zs >> 16;
; 1318 :             y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
; 1319 :             borrow = (y & 0x10000) >> 16;
; 1320 :             z = (*bx >> 16) - (zs & 0xffff) - borrow;
; 1321 :             borrow = (z & 0x10000) >> 16;
; 1322 :             Storeinc(bx, z, y);
; 1323 : #endif
; 1324 :         }
; 1325 :         while(sx <= sxe);

  0013b	49 3b fe	 cmp	 rdi, r14
  0013e	76 d0		 jbe	 SHORT $LL6@quorem

; 1326 :         bx = b->x;
; 1327 :         bxe = bx + n;

  00140	49 63 c2	 movsxd	 rax, r10d
  00143	49 8d 0c 83	 lea	 rcx, QWORD PTR [r11+rax*4]

; 1328 :         if (!*bxe) {

  00147	83 39 00	 cmp	 DWORD PTR [rcx], 0
  0014a	75 1e		 jne	 SHORT $LN3@quorem

; 1329 :             while(--bxe > bx && !*bxe)

  0014c	48 83 e9 04	 sub	 rcx, 4
  00150	49 3b cb	 cmp	 rcx, r11
  00153	76 11		 jbe	 SHORT $LN25@quorem
$LL2@quorem:
  00155	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00158	75 0c		 jne	 SHORT $LN25@quorem
  0015a	48 83 e9 04	 sub	 rcx, 4

; 1330 :                 --n;

  0015e	41 ff ca	 dec	 r10d
  00161	49 3b cb	 cmp	 rcx, r11
  00164	77 ef		 ja	 SHORT $LL2@quorem
$LN25@quorem:

; 1331 :             b->wds = n;

  00166	44 89 56 14	 mov	 DWORD PTR [rsi+20], r10d
$LN3@quorem:
  0016a	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
  0016f	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00174	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1332 :         }
; 1333 :     }
; 1334 :     return q;

  00179	8b c5		 mov	 eax, ebp
  0017b	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 1335 : }

  00180	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00184	5e		 pop	 rsi
  00185	c3		 ret	 0
quorem	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT sulp
_TEXT	SEGMENT
x$ = 8
u$ = 16
bc$ = 16
sulp	PROC						; COMDAT

; 1346 :     U u;
; 1347 : 
; 1348 :     if (bc->scale && 2*P + 1 > (int)((word0(x) & Exp_mask) >> Exp_shift)) {

  00000	83 7a 0c 00	 cmp	 DWORD PTR [rdx+12], 0
  00004	74 27		 je	 SHORT $LN2@sulp
  00006	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00009	c1 e8 14	 shr	 eax, 20
  0000c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00011	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  00014	7d 17		 jge	 SHORT $LN2@sulp

; 1349 :         /* rv/2^bc->scale is subnormal */
; 1350 :         word0(&u) = (P+2)*Exp_msk1;

  00016	c7 44 24 14 00
	00 70 03	 mov	 DWORD PTR u$[rsp+4], 57671680 ; 03700000H

; 1351 :         word1(&u) = 0;

  0001e	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR u$[rsp], 0

; 1352 :         return u.d;

  00026	f2 0f 10 44 24
	10		 movsdx	 xmm0, QWORD PTR u$[rsp]

; 1353 :     }
; 1354 :     else {
; 1355 :         assert(word0(x) || word1(x)); /* x != 0.0 */
; 1356 :         return ulp(x);
; 1357 :     }
; 1358 : }

  0002c	c3		 ret	 0
$LN2@sulp:
  0002d	e9 00 00 00 00	 jmp	 ulp
sulp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bigcomp DD imagerel bigcomp
	DD	imagerel bigcomp+82
	DD	imagerel $unwind$bigcomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$bigcomp DD imagerel bigcomp+82
	DD	imagerel bigcomp+144
	DD	imagerel $chain$1$bigcomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$bigcomp DD imagerel bigcomp+144
	DD	imagerel bigcomp+480
	DD	imagerel $chain$3$bigcomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$bigcomp DD imagerel bigcomp+480
	DD	imagerel bigcomp+502
	DD	imagerel $chain$4$bigcomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$bigcomp DD imagerel bigcomp+502
	DD	imagerel bigcomp+586
	DD	imagerel $chain$6$bigcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$bigcomp DD 080021H
	DD	06f400H
	DD	077400H
	DD	085400H
	DD	0e3400H
	DD	imagerel bigcomp
	DD	imagerel bigcomp+82
	DD	imagerel $unwind$bigcomp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$bigcomp DD 021H
	DD	imagerel bigcomp+82
	DD	imagerel bigcomp+144
	DD	imagerel $chain$1$bigcomp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$bigcomp DD 040a21H
	DD	07740aH
	DD	085405H
	DD	imagerel bigcomp+82
	DD	imagerel bigcomp+144
	DD	imagerel $chain$1$bigcomp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$bigcomp DD 040a21H
	DD	06f40aH
	DD	0e3405H
	DD	imagerel bigcomp
	DD	imagerel bigcomp+82
	DD	imagerel $unwind$bigcomp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bigcomp DD 051501H
	DD	0e0118215H
	DD	0c00dd00fH
	DD	0600bH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT bigcomp
_TEXT	SEGMENT
nd$1$ = 32
p2$ = 36
rv$ = 112
s0$ = 120
bc$ = 128
odd$1$ = 136
bigcomp	PROC						; COMDAT

; 1408 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	56		 push	 rsi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1409 :     Bigint *b, *d;
; 1410 :     int b2, d2, dd, i, nd, nd0, odd, p2, p5;
; 1411 : 
; 1412 :     nd = bc->nd;
; 1413 :     nd0 = bc->nd0;
; 1414 :     p5 = nd + bc->e0;

  00015	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00018	4d 63 60 08	 movsxd	 r12, DWORD PTR [r8+8]
  0001c	4c 8b f1	 mov	 r14, rcx
  0001f	41 8b 48 04	 mov	 ecx, DWORD PTR [r8+4]
  00023	4d 8b e8	 mov	 r13, r8

; 1415 :     b = sd2b(rv, bc->scale, &p2);

  00026	4c 8d 44 24 24	 lea	 r8, QWORD PTR p2$[rsp]
  0002b	41 8b 55 0c	 mov	 edx, DWORD PTR [r13+12]
  0002f	8d 34 01	 lea	 esi, DWORD PTR [rcx+rax]
  00032	89 4c 24 20	 mov	 DWORD PTR nd$1$[rsp], ecx
  00036	49 8b ce	 mov	 rcx, r14
  00039	e8 00 00 00 00	 call	 sd2b

; 1416 :     if (b == NULL)

  0003e	48 85 c0	 test	 rax, rax
  00041	75 0f		 jne	 SHORT $LN24@bigcomp

; 1417 :         return -1;

  00043	83 c8 ff	 or	 eax, -1

; 1514 : }

  00046	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004a	41 5e		 pop	 r14
  0004c	41 5d		 pop	 r13
  0004e	41 5c		 pop	 r12
  00050	5e		 pop	 rsi
  00051	c3		 ret	 0
$LN24@bigcomp:
  00052	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00057	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15

; 1418 : 
; 1419 :     /* record whether the lsb of rv/2^(bc->scale) is odd:  in the exact halfway
; 1420 :        case, this is used for round to even. */
; 1421 :     odd = b->x[0] & 1;

  0005c	44 8b 78 18	 mov	 r15d, DWORD PTR [rax+24]
  00060	41 83 e7 01	 and	 r15d, 1

; 1422 : 
; 1423 :     /* left shift b by 1 bit and or a 1 into the least significant bit;
; 1424 :        this gives us b * 2**p2 = rv/2^(bc->scale) + 0.5 ulp. */
; 1425 :     b = lshift(b, 1);

  00064	ba 01 00 00 00	 mov	 edx, 1
  00069	48 8b c8	 mov	 rcx, rax
  0006c	44 89 bc 24 88
	00 00 00	 mov	 DWORD PTR odd$1$[rsp], r15d
  00074	e8 00 00 00 00	 call	 lshift
  00079	48 8b d8	 mov	 rbx, rax

; 1426 :     if (b == NULL)

  0007c	48 85 c0	 test	 rax, rax
  0007f	75 08		 jne	 SHORT $LN23@bigcomp

; 1427 :         return -1;

  00081	83 c8 ff	 or	 eax, -1
  00084	e9 57 01 00 00	 jmp	 $LN38@bigcomp
$LN23@bigcomp:

; 1428 :     b->x[0] |= 1;

  00089	83 48 18 01	 or	 DWORD PTR [rax+24], 1

; 1429 :     p2--;
; 1430 : 
; 1431 :     p2 -= p5;

  0008d	83 c8 ff	 or	 eax, -1
  00090	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00095	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0009a	8b 7c 24 24	 mov	 edi, DWORD PTR p2$[rsp]
  0009e	2b c6		 sub	 eax, esi

; 1432 :     d = i2b(1);

  000a0	b9 01 00 00 00	 mov	 ecx, 1
  000a5	03 f8		 add	 edi, eax
  000a7	e8 00 00 00 00	 call	 i2b
  000ac	48 8b e8	 mov	 rbp, rax

; 1433 :     if (d == NULL) {

  000af	48 85 c0	 test	 rax, rax

; 1434 :         Bfree(b);
; 1435 :         return -1;

  000b2	74 16		 je	 SHORT $LN43@bigcomp

; 1436 :     }
; 1437 :     /* Arrange for convenient computation of quotients:
; 1438 :      * shift left if necessary so divisor has 4 leading 0 bits.
; 1439 :      */
; 1440 :     if (p5 > 0) {

  000b4	85 f6		 test	 esi, esi
  000b6	7e 1a		 jle	 SHORT $LN42@bigcomp

; 1441 :         d = pow5mult(d, p5);

  000b8	8b d6		 mov	 edx, esi
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 pow5mult
  000c2	48 8b e8	 mov	 rbp, rax

; 1442 :         if (d == NULL) {

  000c5	48 85 c0	 test	 rax, rax
  000c8	75 22		 jne	 SHORT $LN17@bigcomp
$LN43@bigcomp:

; 1443 :             Bfree(b);

  000ca	48 8b cb	 mov	 rcx, rbx

; 1444 :             return -1;

  000cd	e9 fc 00 00 00	 jmp	 $LN41@bigcomp
$LN42@bigcomp:

; 1445 :         }
; 1446 :     }
; 1447 :     else if (p5 < 0) {

  000d2	79 18		 jns	 SHORT $LN17@bigcomp

; 1448 :         b = pow5mult(b, -p5);

  000d4	f7 de		 neg	 esi
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	8b d6		 mov	 edx, esi
  000db	e8 00 00 00 00	 call	 pow5mult
  000e0	48 8b d8	 mov	 rbx, rax

; 1449 :         if (b == NULL) {

  000e3	48 85 c0	 test	 rax, rax

; 1450 :             Bfree(d);
; 1451 :             return -1;

  000e6	0f 84 df 00 00
	00		 je	 $LN31@bigcomp
$LN17@bigcomp:

; 1452 :         }
; 1453 :     }
; 1454 :     if (p2 > 0) {

  000ec	85 ff		 test	 edi, edi
  000ee	7e 07		 jle	 SHORT $LN16@bigcomp

; 1455 :         b2 = p2;

  000f0	44 8b c7	 mov	 r8d, edi

; 1456 :         d2 = 0;

  000f3	33 ff		 xor	 edi, edi

; 1457 :     }
; 1458 :     else {

  000f5	eb 05		 jmp	 SHORT $LN15@bigcomp
$LN16@bigcomp:

; 1459 :         b2 = 0;

  000f7	45 33 c0	 xor	 r8d, r8d

; 1460 :         d2 = -p2;

  000fa	f7 df		 neg	 edi
$LN15@bigcomp:

; 1461 :     }
; 1462 :     i = dshift(d, d2);

  000fc	8b d7		 mov	 edx, edi
  000fe	48 8b cd	 mov	 rcx, rbp
  00101	e8 00 00 00 00	 call	 dshift

; 1463 :     if ((b2 += i) > 0) {

  00106	44 03 c0	 add	 r8d, eax
  00109	8b f0		 mov	 esi, eax
  0010b	45 85 c0	 test	 r8d, r8d
  0010e	7e 17		 jle	 SHORT $LN13@bigcomp

; 1464 :         b = lshift(b, b2);

  00110	41 8b d0	 mov	 edx, r8d
  00113	48 8b cb	 mov	 rcx, rbx
  00116	e8 00 00 00 00	 call	 lshift
  0011b	48 8b d8	 mov	 rbx, rax

; 1465 :         if (b == NULL) {

  0011e	48 85 c0	 test	 rax, rax

; 1466 :             Bfree(d);
; 1467 :             return -1;

  00121	0f 84 a4 00 00
	00		 je	 $LN31@bigcomp
$LN13@bigcomp:

; 1468 :         }
; 1469 :     }
; 1470 :     if ((d2 += i) > 0) {

  00127	03 fe		 add	 edi, esi
  00129	85 ff		 test	 edi, edi
  0012b	7e 12		 jle	 SHORT $LN11@bigcomp

; 1471 :         d = lshift(d, d2);

  0012d	8b d7		 mov	 edx, edi
  0012f	48 8b cd	 mov	 rcx, rbp
  00132	e8 00 00 00 00	 call	 lshift
  00137	48 8b e8	 mov	 rbp, rax

; 1472 :         if (d == NULL) {

  0013a	48 85 c0	 test	 rax, rax

; 1473 :             Bfree(b);
; 1474 :             return -1;

  0013d	74 8b		 je	 SHORT $LN43@bigcomp
$LN11@bigcomp:

; 1475 :         }
; 1476 :     }
; 1477 : 
; 1478 :     /* Compare s0 with b/d: set dd to -1, 0, or 1 according as s0 < b/d, s0 ==
; 1479 :      * b/d, or s0 > b/d.  Here the digits of s0 are thought of as representing
; 1480 :      * a number in the range [0.1, 1). */
; 1481 :     if (cmp(b, d) >= 0)

  0013f	48 8b d5	 mov	 rdx, rbp
  00142	48 8b cb	 mov	 rcx, rbx
  00145	e8 00 00 00 00	 call	 cmp
  0014a	85 c0		 test	 eax, eax
  0014c	78 08		 js	 SHORT $LN10@bigcomp

; 1482 :         /* b/d >= 1 */
; 1483 :         dd = -1;

  0014e	83 cf ff	 or	 edi, -1

; 1484 :     else {

  00151	e9 c0 00 00 00	 jmp	 $LN7@bigcomp
$LN10@bigcomp:

; 1485 :         i = 0;

  00156	45 33 ff	 xor	 r15d, r15d

; 1486 :         for(;;) {
; 1487 :             b = multadd(b, 10, 0);

  00159	45 33 c0	 xor	 r8d, r8d
  0015c	48 8b cb	 mov	 rcx, rbx
  0015f	41 8d 57 0a	 lea	 edx, QWORD PTR [r15+10]
  00163	e8 00 00 00 00	 call	 multadd

; 1501 :             }
; 1502 :             if (!(i < nd)) {

  00168	4c 63 6c 24 20	 movsxd	 r13, DWORD PTR nd$1$[rsp]
  0016d	33 f6		 xor	 esi, esi
  0016f	48 8b d8	 mov	 rbx, rax
  00172	48 85 c0	 test	 rax, rax
  00175	74 54		 je	 SHORT $LN31@bigcomp
$LL8@bigcomp:

; 1491 :             }
; 1492 :             dd = s0[i < nd0 ? i : i+1] - '0' - quorem(b, d);

  00177	48 8b fe	 mov	 rdi, rsi
  0017a	49 3b f4	 cmp	 rsi, r12
  0017d	7c 04		 jl	 SHORT $LN28@bigcomp
  0017f	48 8d 7e 01	 lea	 rdi, QWORD PTR [rsi+1]
$LN28@bigcomp:
  00183	48 8b d5	 mov	 rdx, rbp
  00186	48 8b cb	 mov	 rcx, rbx
  00189	e8 00 00 00 00	 call	 quorem
  0018e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s0$[rsp]

; 1493 :             i++;

  00193	41 ff c7	 inc	 r15d
  00196	0f be 3c 0f	 movsx	 edi, BYTE PTR [rdi+rcx]
  0019a	48 ff c6	 inc	 rsi
  0019d	2b f8		 sub	 edi, eax
  0019f	83 ef 30	 sub	 edi, 48			; 00000030H

; 1494 : 
; 1495 :             if (dd)

  001a2	75 62		 jne	 SHORT $LN36@bigcomp

; 1496 :                 break;
; 1497 :             if (!b->x[0] && b->wds == 1) {

  001a4	39 7b 18	 cmp	 DWORD PTR [rbx+24], edi
  001a7	75 06		 jne	 SHORT $LN4@bigcomp
  001a9	83 7b 14 01	 cmp	 DWORD PTR [rbx+20], 1
  001ad	74 47		 je	 SHORT $LN33@bigcomp
$LN4@bigcomp:

; 1501 :             }
; 1502 :             if (!(i < nd)) {

  001af	49 3b f5	 cmp	 rsi, r13
  001b2	7d 4f		 jge	 SHORT $LN34@bigcomp

; 1486 :         for(;;) {
; 1487 :             b = multadd(b, 10, 0);

  001b4	45 33 c0	 xor	 r8d, r8d
  001b7	48 8b cb	 mov	 rcx, rbx
  001ba	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  001be	e8 00 00 00 00	 call	 multadd
  001c3	48 8b d8	 mov	 rbx, rax

; 1488 :             if (b == NULL) {

  001c6	48 85 c0	 test	 rax, rax
  001c9	75 ac		 jne	 SHORT $LL8@bigcomp
$LN31@bigcomp:

; 1489 :                 Bfree(d);

  001cb	48 8b cd	 mov	 rcx, rbp
$LN41@bigcomp:
  001ce	e8 00 00 00 00	 call	 Bfree

; 1490 :                 return -1;

  001d3	83 c8 ff	 or	 eax, -1
$LN40@bigcomp:
  001d6	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  001db	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN38@bigcomp:
  001e0	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001e5	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]

; 1514 : }

  001ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ee	41 5e		 pop	 r14
  001f0	41 5d		 pop	 r13
  001f2	41 5c		 pop	 r12
  001f4	5e		 pop	 rsi
  001f5	c3		 ret	 0
$LN33@bigcomp:

; 1498 :                 /* b/d == 0 */
; 1499 :                 dd = i < nd;

  001f6	33 ff		 xor	 edi, edi
  001f8	44 3b 7c 24 20	 cmp	 r15d, DWORD PTR nd$1$[rsp]
  001fd	40 0f 9c c7	 setl	 dil

; 1500 :                 break;

  00201	eb 03		 jmp	 SHORT $LN36@bigcomp
$LN34@bigcomp:

; 1503 :                 /* b/d != 0, but digits of s0 exhausted */
; 1504 :                 dd = -1;

  00203	83 cf ff	 or	 edi, -1
$LN36@bigcomp:

; 1408 : {

  00206	4c 8b ac 24 80
	00 00 00	 mov	 r13, QWORD PTR bc$[rsp]
  0020e	44 8b bc 24 88
	00 00 00	 mov	 r15d, DWORD PTR odd$1$[rsp]
$LN7@bigcomp:

; 1505 :                 break;
; 1506 :             }
; 1507 :         }
; 1508 :     }
; 1509 :     Bfree(b);

  00216	48 8b cb	 mov	 rcx, rbx
  00219	e8 00 00 00 00	 call	 Bfree

; 1510 :     Bfree(d);

  0021e	48 8b cd	 mov	 rcx, rbp
  00221	e8 00 00 00 00	 call	 Bfree

; 1511 :     if (dd > 0 || (dd == 0 && odd))

  00226	85 ff		 test	 edi, edi
  00228	7f 07		 jg	 SHORT $LN1@bigcomp
  0022a	75 1a		 jne	 SHORT $LN2@bigcomp
  0022c	45 85 ff	 test	 r15d, r15d
  0022f	74 15		 je	 SHORT $LN2@bigcomp
$LN1@bigcomp:

; 1512 :         dval(rv) += sulp(rv, bc);

  00231	49 8b d5	 mov	 rdx, r13
  00234	49 8b ce	 mov	 rcx, r14
  00237	e8 00 00 00 00	 call	 sulp
  0023c	f2 41 0f 58 06	 addsd	 xmm0, QWORD PTR [r14]
  00241	f2 41 0f 11 06	 movsdx	 QWORD PTR [r14], xmm0
$LN2@bigcomp:

; 1513 :     return 0;

  00246	33 c0		 xor	 eax, eax
  00248	eb 8c		 jmp	 SHORT $LN40@bigcomp
bigcomp	ENDP
_TEXT	ENDS
PUBLIC	_Py_dg_stdnan
; Function compile flags: /Ogtpy
;	COMDAT _Py_dg_stdnan
_TEXT	SEGMENT
sign$ = 8
rv$ = 16
_Py_dg_stdnan PROC					; COMDAT

; 1526 :     U rv;
; 1527 :     word0(&rv) = NAN_WORD0;

  00000	b8 00 00 f8 7f	 mov	 eax, 2146959360		; 7ff80000H

; 1528 :     word1(&rv) = NAN_WORD1;
; 1529 :     if (sign)

  00005	ba 00 00 f8 ff	 mov	 edx, -524288		; fff80000H
  0000a	85 c9		 test	 ecx, ecx
  0000c	0f 45 c2	 cmovne	 eax, edx
  0000f	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0
  00017	89 44 24 14	 mov	 DWORD PTR rv$[rsp+4], eax

; 1530 :         word0(&rv) |= Sign_bit;
; 1531 :     return dval(&rv);

  0001b	f2 0f 10 44 24
	10		 movsdx	 xmm0, QWORD PTR rv$[rsp]

; 1532 : }

  00021	c3		 ret	 0
_Py_dg_stdnan ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	_Py_dg_infinity
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_dg_infinity
_TEXT	SEGMENT
sign$ = 8
rv$ = 16
_Py_dg_infinity PROC					; COMDAT

; 1540 :     U rv;
; 1541 :     word0(&rv) = POSINF_WORD0;

  00000	c7 44 24 14 00
	00 f0 7f	 mov	 DWORD PTR rv$[rsp+4], 2146435072 ; 7ff00000H

; 1542 :     word1(&rv) = POSINF_WORD1;

  00008	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0

; 1543 :     return sign ? -dval(&rv) : dval(&rv);

  00010	f2 0f 10 44 24
	10		 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00016	85 c9		 test	 ecx, ecx
  00018	74 08		 je	 SHORT $LN4@Py_dg_infi
  0001a	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
$LN4@Py_dg_infi:

; 1544 : }

  00022	f3 c3		 fatret	 0
_Py_dg_infinity ENDP
_TEXT	ENDS
PUBLIC	__real@8000000000000000
PUBLIC	__real@3fe0000035afe535
PUBLIC	__real@3fdfffff94a03595
PUBLIC	__real@3fcfffff94a03595
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	_Py_dg_strtod
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_strtod DD imagerel $LN300
	DD	imagerel $LN300+346
	DD	imagerel $unwind$_Py_dg_strtod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_Py_dg_strtod DD imagerel $LN300+346
	DD	imagerel $LN300+600
	DD	imagerel $chain$4$_Py_dg_strtod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$_Py_dg_strtod DD imagerel $LN300+600
	DD	imagerel $LN300+1109
	DD	imagerel $chain$12$_Py_dg_strtod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$_Py_dg_strtod DD imagerel $LN300+1109
	DD	imagerel $LN300+1130
	DD	imagerel $chain$13$_Py_dg_strtod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$_Py_dg_strtod DD imagerel $LN300+1130
	DD	imagerel $LN300+4039
	DD	imagerel $chain$14$_Py_dg_strtod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$_Py_dg_strtod DD 01a0021H
	DD	08f800H
	DD	09e800H
	DD	0ad800H
	DD	0bc800H
	DD	0cb800H
	DD	0da800H
	DD	0e9800H
	DD	0f8800H
	DD	0107800H
	DD	024f400H
	DD	025d400H
	DD	026c400H
	DD	02d6400H
	DD	imagerel $LN300
	DD	imagerel $LN300+346
	DD	imagerel $unwind$_Py_dg_strtod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$_Py_dg_strtod DD 021H
	DD	imagerel $LN300
	DD	imagerel $LN300+346
	DD	imagerel $unwind$_Py_dg_strtod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$_Py_dg_strtod DD 0104721H
	DD	09e847H
	DD	0ad83eH
	DD	0bc835H
	DD	0cb82cH
	DD	0da823H
	DD	0e981aH
	DD	0f8811H
	DD	0107808H
	DD	imagerel $LN300+346
	DD	imagerel $LN300+600
	DD	imagerel $chain$4$_Py_dg_strtod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_Py_dg_strtod DD 0afe21H
	DD	024f4feH
	DD	025d4f6H
	DD	08f822H
	DD	026c410H
	DD	02d6408H
	DD	imagerel $LN300
	DD	imagerel $LN300+346
	DD	imagerel $unwind$_Py_dg_strtod
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_strtod DD 082201H
	DD	0116822H
	DD	0270112H
	DD	07004e006H
	DD	050023003H
xdata	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@3fe0000035afe535
CONST	SEGMENT
__real@3fe0000035afe535 DQ 03fe0000035afe535r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdfffff94a03595
CONST	SEGMENT
__real@3fdfffff94a03595 DQ 03fdfffff94a03595r	; 0.5
CONST	ENDS
;	COMDAT __real@3fcfffff94a03595
CONST	SEGMENT
__real@3fcfffff94a03595 DQ 03fcfffff94a03595r	; 0.25
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_dg_strtod
_TEXT	SEGMENT
rv$ = 32
bc$ = 40
bb$1$ = 56
bd0$1$ = 64
bd$1$ = 72
rv0$ = 80
bs$1$ = 88
aadj2$ = 96
odd$1$ = 104
bbe$ = 108
s0$1$ = 112
nd$1$ = 352
s00$ = 352
se$ = 360
sign$1$ = 368
e$1$ = 376
_Py_dg_strtod PROC					; COMDAT

; 1548 : {

$LN300:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	48 8d 6c 24 c8	 lea	 rbp, QWORD PTR [rsp-56]
  0000b	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 1549 :     int bb2, bb5, bbe, bd2, bd5, bs2, c, dsign, e, e1, error;
; 1550 :     int esign, i, j, k, lz, nd, nd0, odd, sign;
; 1551 :     const char *s, *s0, *s1;
; 1552 :     double aadj, aadj1;
; 1553 :     U aadj2, adj, rv, rv0;
; 1554 :     ULong y, z, abs_exp;
; 1555 :     Long L;
; 1556 :     BCinfo bc;
; 1557 :     Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
; 1558 :     size_t ndigits, fraclen;
; 1559 : 
; 1560 :     dval(&rv) = 0.;
; 1561 : 
; 1562 :     /* Start parsing. */
; 1563 :     c = *(s = s00);

  00012	44 0f be 09	 movsx	 r9d, BYTE PTR [rcx]
  00016	66 0f 57 c9	 xorpd	 xmm1, xmm1
  0001a	0f 29 b4 24 10
	01 00 00	 movaps	 XMMWORD PTR [rsp+272], xmm6
  00022	48 8b da	 mov	 rbx, rdx
  00025	4c 8b d1	 mov	 r10, rcx
  00028	4c 8b c1	 mov	 r8, rcx

; 1564 : 
; 1565 :     /* Parse optional sign, if present. */
; 1566 :     sign = 0;

  0002b	c7 45 70 00 00
	00 00		 mov	 DWORD PTR sign$1$[rbp-256], 0

; 1567 :     switch (c) {

  00032	bf 01 00 00 00	 mov	 edi, 1
  00037	66 0f 28 f1	 movapd	 xmm6, xmm1
  0003b	41 83 f9 2b	 cmp	 r9d, 43			; 0000002bH
  0003f	74 09		 je	 SHORT $LN172@Py_dg_strt
  00041	41 83 f9 2d	 cmp	 r9d, 45			; 0000002dH
  00045	75 0c		 jne	 SHORT $LN174@Py_dg_strt

; 1568 :     case '-':
; 1569 :         sign = 1;

  00047	89 7d 70	 mov	 DWORD PTR sign$1$[rbp-256], edi
$LN172@Py_dg_strt:

; 1570 :         /* no break */
; 1571 :     case '+':
; 1572 :         c = *++s;

  0004a	44 0f be 49 01	 movsx	 r9d, BYTE PTR [rcx+1]
  0004f	4c 8d 41 01	 lea	 r8, QWORD PTR [rcx+1]
$LN174@Py_dg_strt:

; 1573 :     }
; 1574 : 
; 1575 :     /* Skip leading zeros: lz is true iff there were leading zeros. */
; 1576 :     s1 = s;

  00053	49 8b c0	 mov	 rax, r8

; 1577 :     while (c == '0')

  00056	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  0005a	75 12		 jne	 SHORT $LN170@Py_dg_strt
  0005c	0f 1f 40 00	 npad	 4
$LL171@Py_dg_strt:

; 1578 :         c = *++s;

  00060	45 0f be 48 01	 movsx	 r9d, BYTE PTR [r8+1]
  00065	49 ff c0	 inc	 r8
  00068	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  0006c	74 f2		 je	 SHORT $LL171@Py_dg_strt
$LN170@Py_dg_strt:

; 1579 :     lz = s != s1;

  0006e	45 33 db	 xor	 r11d, r11d
  00071	4c 3b c0	 cmp	 r8, rax

; 1580 : 
; 1581 :     /* Point s0 at the first nonzero digit (if any).  fraclen will be the
; 1582 :        number of digits between the decimal point and the end of the
; 1583 :        digit string.  ndigits will be the total number of digits ignoring
; 1584 :        leading zeros. */
; 1585 :     s0 = s1 = s;

  00074	4d 8b f0	 mov	 r14, r8
  00077	41 0f 95 c3	 setne	 r11b
  0007b	49 8b c0	 mov	 rax, r8
  0007e	4c 89 44 24 70	 mov	 QWORD PTR s0$1$[rsp], r8

; 1586 :     while ('0' <= c && c <= '9')

  00083	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  00087	7c 1b		 jl	 SHORT $LN256@Py_dg_strt
  00089	0f 1f 80 00 00
	00 00		 npad	 7
$LL169@Py_dg_strt:
  00090	41 83 f9 39	 cmp	 r9d, 57			; 00000039H
  00094	7f 0e		 jg	 SHORT $LN256@Py_dg_strt

; 1587 :         c = *++s;

  00096	45 0f be 48 01	 movsx	 r9d, BYTE PTR [r8+1]
  0009b	49 ff c0	 inc	 r8
  0009e	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  000a2	7d ec		 jge	 SHORT $LL169@Py_dg_strt
$LN256@Py_dg_strt:

; 1588 :     ndigits = s - s1;

  000a4	49 8b d0	 mov	 rdx, r8

; 1589 :     fraclen = 0;

  000a7	33 c9		 xor	 ecx, ecx
  000a9	48 2b d0	 sub	 rdx, rax

; 1590 : 
; 1591 :     /* Parse decimal point and following digits. */
; 1592 :     if (c == '.') {

  000ac	41 83 f9 2e	 cmp	 r9d, 46			; 0000002eH
  000b0	75 7b		 jne	 SHORT $LN167@Py_dg_strt

; 1593 :         c = *++s;

  000b2	45 0f be 48 01	 movsx	 r9d, BYTE PTR [r8+1]
  000b7	49 ff c0	 inc	 r8

; 1594 :         if (!ndigits) {

  000ba	48 85 d2	 test	 rdx, rdx
  000bd	75 3a		 jne	 SHORT $LN166@Py_dg_strt

; 1595 :             s1 = s;

  000bf	49 8b c0	 mov	 rax, r8

; 1596 :             while (c == '0')

  000c2	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  000c6	75 16		 jne	 SHORT $LN164@Py_dg_strt
  000c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL165@Py_dg_strt:

; 1597 :                 c = *++s;

  000d0	45 0f be 48 01	 movsx	 r9d, BYTE PTR [r8+1]
  000d5	49 ff c0	 inc	 r8
  000d8	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  000dc	74 f2		 je	 SHORT $LL165@Py_dg_strt
$LN164@Py_dg_strt:

; 1598 :             lz = lz || s != s1;

  000de	45 85 db	 test	 r11d, r11d
  000e1	75 05		 jne	 SHORT $LN178@Py_dg_strt
  000e3	4c 3b c0	 cmp	 r8, rax
  000e6	74 03		 je	 SHORT $LN179@Py_dg_strt
$LN178@Py_dg_strt:
  000e8	44 8b df	 mov	 r11d, edi
$LN179@Py_dg_strt:

; 1599 :             fraclen += (s - s1);

  000eb	49 8b c8	 mov	 rcx, r8

; 1600 :             s0 = s;

  000ee	4d 8b f0	 mov	 r14, r8
  000f1	4c 89 44 24 70	 mov	 QWORD PTR s0$1$[rsp], r8
  000f6	48 2b c8	 sub	 rcx, rax
$LN166@Py_dg_strt:

; 1601 :         }
; 1602 :         s1 = s;

  000f9	49 8b f8	 mov	 rdi, r8

; 1603 :         while ('0' <= c && c <= '9')

  000fc	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  00100	7c 14		 jl	 SHORT $LN257@Py_dg_strt
$LL163@Py_dg_strt:
  00102	41 83 f9 39	 cmp	 r9d, 57			; 00000039H
  00106	7f 0e		 jg	 SHORT $LN257@Py_dg_strt

; 1604 :             c = *++s;

  00108	45 0f be 48 01	 movsx	 r9d, BYTE PTR [r8+1]
  0010d	49 ff c0	 inc	 r8
  00110	41 83 f9 30	 cmp	 r9d, 48			; 00000030H
  00114	7d ec		 jge	 SHORT $LL163@Py_dg_strt
$LN257@Py_dg_strt:

; 1605 :         ndigits += s - s1;

  00116	49 8b c0	 mov	 rax, r8
  00119	48 2b c7	 sub	 rax, rdi
  0011c	48 03 d0	 add	 rdx, rax

; 1606 :         fraclen += s - s1;

  0011f	49 8b c0	 mov	 rax, r8
  00122	48 2b c7	 sub	 rax, rdi
  00125	bf 01 00 00 00	 mov	 edi, 1
  0012a	48 03 c8	 add	 rcx, rax
$LN167@Py_dg_strt:

; 1607 :     }
; 1608 : 
; 1609 :     /* Now lz is true if and only if there were leading zero digits, and
; 1610 :        ndigits gives the total number of digits ignoring leading zeros.  A
; 1611 :        valid input must have at least one digit. */
; 1612 :     if (!ndigits && !lz) {

  0012d	48 85 d2	 test	 rdx, rdx
  00130	75 16		 jne	 SHORT $LN161@Py_dg_strt
  00132	45 85 db	 test	 r11d, r11d
  00135	75 1a		 jne	 SHORT $LN246@Py_dg_strt
$LN158@Py_dg_strt:

; 1621 :         if (se)

  00137	48 85 db	 test	 rbx, rbx
  0013a	74 03		 je	 SHORT $parse_error$20838

; 1622 :             *se = (char *)s00;

  0013c	4c 89 13	 mov	 QWORD PTR [rbx], r10
$parse_error$20838:

; 2280 : 
; 2281 :   parse_error:
; 2282 :     return 0.0;

  0013f	66 0f 28 c1	 movapd	 xmm0, xmm1
  00143	e9 0d 03 00 00	 jmp	 $LN176@Py_dg_strt
$LN161@Py_dg_strt:

; 1613 :         if (se)
; 1614 :             *se = (char *)s00;
; 1615 :         goto parse_error;
; 1616 :     }
; 1617 : 
; 1618 :     /* Range check ndigits and fraclen to make sure that they, and values
; 1619 :        computed with them, can safely fit in an int. */
; 1620 :     if (ndigits > MAX_DIGITS || fraclen > MAX_DIGITS) {

  00148	48 81 fa 00 ca
	9a 3b		 cmp	 rdx, 1000000000		; 3b9aca00H
  0014f	77 e6		 ja	 SHORT $LN158@Py_dg_strt
$LN246@Py_dg_strt:
  00151	48 81 f9 00 ca
	9a 3b		 cmp	 rcx, 1000000000		; 3b9aca00H
  00158	77 dd		 ja	 SHORT $LN158@Py_dg_strt

; 1623 :         goto parse_error;
; 1624 :     }
; 1625 :     nd = (int)ndigits;
; 1626 :     nd0 = (int)ndigits - (int)fraclen;

  0015a	48 89 b4 24 68
	01 00 00	 mov	 QWORD PTR [rsp+360], rsi
  00162	4c 89 a4 24 30
	01 00 00	 mov	 QWORD PTR [rsp+304], r12
  0016a	44 8b da	 mov	 r11d, edx

; 1627 : 
; 1628 :     /* Parse exponent. */
; 1629 :     e = 0;

  0016d	45 33 e4	 xor	 r12d, r12d
  00170	44 2b d9	 sub	 r11d, ecx
  00173	44 0f 29 bc 24
	80 00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm15

; 1630 :     if (c == 'e' || c == 'E') {

  0017c	41 83 f9 65	 cmp	 r9d, 101		; 00000065H
  00180	74 0a		 je	 SHORT $LN155@Py_dg_strt
  00182	41 83 f9 45	 cmp	 r9d, 69			; 00000045H
  00186	0f 85 9c 00 00
	00		 jne	 $LN142@Py_dg_strt
$LN155@Py_dg_strt:

; 1631 :         s00 = s;
; 1632 :         c = *++s;

  0018c	41 0f be 48 01	 movsx	 ecx, BYTE PTR [r8+1]
  00191	49 8b f0	 mov	 rsi, r8
  00194	49 ff c0	 inc	 r8

; 1633 : 
; 1634 :         /* Exponent sign. */
; 1635 :         esign = 0;

  00197	45 33 d2	 xor	 r10d, r10d

; 1636 :         switch (c) {

  0019a	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0019d	74 08		 je	 SHORT $LN151@Py_dg_strt
  0019f	83 f9 2d	 cmp	 ecx, 45			; 0000002dH
  001a2	75 0b		 jne	 SHORT $LN153@Py_dg_strt

; 1637 :         case '-':
; 1638 :             esign = 1;

  001a4	44 8b d7	 mov	 r10d, edi
$LN151@Py_dg_strt:

; 1639 :             /* no break */
; 1640 :         case '+':
; 1641 :             c = *++s;

  001a7	41 0f be 48 01	 movsx	 ecx, BYTE PTR [r8+1]
  001ac	49 ff c0	 inc	 r8
$LN153@Py_dg_strt:

; 1642 :         }
; 1643 : 
; 1644 :         /* Skip zeros.  lz is true iff there are leading zeros. */
; 1645 :         s1 = s;

  001af	49 8b c0	 mov	 rax, r8

; 1646 :         while (c == '0')

  001b2	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001b5	75 16		 jne	 SHORT $LN149@Py_dg_strt
  001b7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL150@Py_dg_strt:

; 1647 :             c = *++s;

  001c0	41 0f be 48 01	 movsx	 ecx, BYTE PTR [r8+1]
  001c5	49 ff c0	 inc	 r8
  001c8	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001cb	74 f3		 je	 SHORT $LL150@Py_dg_strt
$LN149@Py_dg_strt:

; 1648 :         lz = s != s1;

  001cd	33 ff		 xor	 edi, edi
  001cf	4c 3b c0	 cmp	 r8, rax

; 1649 : 
; 1650 :         /* Get absolute value of the exponent. */
; 1651 :         s1 = s;

  001d2	4d 8b c8	 mov	 r9, r8
  001d5	40 0f 95 c7	 setne	 dil

; 1652 :         abs_exp = 0;
; 1653 :         while ('0' <= c && c <= '9') {

  001d9	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001dc	7c 1c		 jl	 SHORT $LN258@Py_dg_strt
  001de	66 90		 npad	 2
$LL148@Py_dg_strt:
  001e0	83 f9 39	 cmp	 ecx, 57			; 00000039H
  001e3	7f 15		 jg	 SHORT $LN258@Py_dg_strt

; 1654 :             abs_exp = 10*abs_exp + (c - '0');
; 1655 :             c = *++s;

  001e5	49 ff c0	 inc	 r8
  001e8	43 8d 04 a4	 lea	 eax, DWORD PTR [r12+r12*4]
  001ec	44 8d 64 41 d0	 lea	 r12d, DWORD PTR [rcx+rax*2-48]
  001f1	41 0f be 08	 movsx	 ecx, BYTE PTR [r8]
  001f5	83 f9 30	 cmp	 ecx, 48			; 00000030H
  001f8	7d e6		 jge	 SHORT $LL148@Py_dg_strt
$LN258@Py_dg_strt:

; 1656 :         }
; 1657 : 
; 1658 :         /* abs_exp will be correct modulo 2**32.  But 10**9 < 2**32, so if
; 1659 :            there are at most 9 significant exponent digits then overflow is
; 1660 :            impossible. */
; 1661 :         if (s - s1 > 9 || abs_exp > MAX_ABS_EXP)

  001fa	49 8b c0	 mov	 rax, r8
  001fd	49 2b c1	 sub	 rax, r9
  00200	48 83 f8 09	 cmp	 rax, 9
  00204	7f 09		 jg	 SHORT $LN145@Py_dg_strt
  00206	41 81 fc 00 ab
	90 41		 cmp	 r12d, 1100000000	; 4190ab00H
  0020d	76 06		 jbe	 SHORT $LN144@Py_dg_strt
$LN145@Py_dg_strt:

; 1662 :             e = (int)MAX_ABS_EXP;

  0020f	41 bc 00 ab 90
	41		 mov	 r12d, 1100000000	; 4190ab00H
$LN144@Py_dg_strt:

; 1663 :         else
; 1664 :             e = (int)abs_exp;
; 1665 :         if (esign)

  00215	45 85 d2	 test	 r10d, r10d
  00218	74 03		 je	 SHORT $LN143@Py_dg_strt

; 1666 :             e = -e;

  0021a	41 f7 dc	 neg	 r12d
$LN143@Py_dg_strt:

; 1667 : 
; 1668 :         /* A valid exponent must have at least one digit. */
; 1669 :         if (s == s1 && !lz)

  0021d	4d 3b c1	 cmp	 r8, r9
  00220	75 06		 jne	 SHORT $LN142@Py_dg_strt
  00222	85 ff		 test	 edi, edi
  00224	4c 0f 44 c6	 cmove	 r8, rsi
$LN142@Py_dg_strt:

; 1670 :             s = s00;
; 1671 :     }
; 1672 : 
; 1673 :     /* Adjust exponent to take into account position of the point. */
; 1674 :     e -= nd - nd0;

  00228	41 8b c3	 mov	 eax, r11d
  0022b	2b c2		 sub	 eax, edx
  0022d	44 03 e0	 add	 r12d, eax

; 1675 :     if (nd0 <= 0)

  00230	45 85 db	 test	 r11d, r11d
  00233	44 0f 4e da	 cmovle	 r11d, edx

; 1676 :         nd0 = nd;
; 1677 : 
; 1678 :     /* Finished parsing.  Set se to indicate how far we parsed */
; 1679 :     if (se)

  00237	48 85 db	 test	 rbx, rbx
  0023a	74 03		 je	 SHORT $LN140@Py_dg_strt

; 1680 :         *se = (char *)s;

  0023c	4c 89 03	 mov	 QWORD PTR [rbx], r8
$LN140@Py_dg_strt:

; 1681 : 
; 1682 :     /* If all digits were zero, exit with return value +-0.0.  Otherwise,
; 1683 :        strip trailing zeros: scan back until we hit a nonzero digit. */
; 1684 :     if (!nd)

  0023f	f2 44 0f 10 3d
	00 00 00 00	 movsdx	 xmm15, QWORD PTR __mask@@NegDouble@
  00248	4c 89 ac 24 28
	01 00 00	 mov	 QWORD PTR [rsp+296], r13
  00250	4c 89 bc 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], r15
  00258	0f 29 bc 24 00
	01 00 00	 movaps	 XMMWORD PTR [rsp+256], xmm7
  00260	44 0f 29 84 24
	f0 00 00 00	 movaps	 XMMWORD PTR [rsp+240], xmm8
  00269	44 0f 29 8c 24
	e0 00 00 00	 movaps	 XMMWORD PTR [rsp+224], xmm9
  00272	44 0f 29 94 24
	d0 00 00 00	 movaps	 XMMWORD PTR [rsp+208], xmm10
  0027b	44 0f 29 9c 24
	c0 00 00 00	 movaps	 XMMWORD PTR [rsp+192], xmm11
  00284	44 0f 29 a4 24
	b0 00 00 00	 movaps	 XMMWORD PTR [rsp+176], xmm12
  0028d	44 0f 29 ac 24
	a0 00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm13
  00296	44 0f 29 b4 24
	90 00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm14
  0029f	85 d2		 test	 edx, edx
  002a1	0f 84 2f 01 00
	00		 je	 $ret$20871

; 1685 :         goto ret;
; 1686 :     for (i = nd; i > 0; ) {

  002a7	44 8b ea	 mov	 r13d, edx
  002aa	89 55 60	 mov	 DWORD PTR nd$1$[rbp-256], edx
  002ad	48 63 c2	 movsxd	 rax, edx

; 1688 :         if (s0[i < nd0 ? i : i+1] != '0') {

  002b0	4d 63 c3	 movsxd	 r8, r11d
  002b3	7e 36		 jle	 SHORT $LN137@Py_dg_strt
  002b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL138@Py_dg_strt:

; 1687 :         --i;

  002c0	48 ff c8	 dec	 rax
  002c3	41 ff cd	 dec	 r13d
  002c6	44 89 6d 60	 mov	 DWORD PTR nd$1$[rbp-256], r13d

; 1688 :         if (s0[i < nd0 ? i : i+1] != '0') {

  002ca	48 8b c8	 mov	 rcx, rax
  002cd	49 3b c0	 cmp	 rax, r8
  002d0	7c 04		 jl	 SHORT $LN181@Py_dg_strt

; 1685 :         goto ret;
; 1686 :     for (i = nd; i > 0; ) {

  002d2	48 8d 48 01	 lea	 rcx, QWORD PTR [rax+1]
$LN181@Py_dg_strt:

; 1688 :         if (s0[i < nd0 ? i : i+1] != '0') {

  002d6	42 80 3c 31 30	 cmp	 BYTE PTR [rcx+r14], 48	; 00000030H
  002db	75 07		 jne	 SHORT $LN214@Py_dg_strt

; 1685 :         goto ret;
; 1686 :     for (i = nd; i > 0; ) {

  002dd	45 85 ed	 test	 r13d, r13d
  002e0	7f de		 jg	 SHORT $LL138@Py_dg_strt

; 2248 :                         if (aadj < .4999999 || aadj > .5000001)

  002e2	eb 07		 jmp	 SHORT $LN137@Py_dg_strt
$LN214@Py_dg_strt:

; 1689 :             ++i;

  002e4	41 ff c5	 inc	 r13d
  002e7	44 89 6d 60	 mov	 DWORD PTR nd$1$[rbp-256], r13d
$LN137@Py_dg_strt:

; 1690 :             break;
; 1691 :         }
; 1692 :     }
; 1693 :     e += nd - i;

  002eb	41 2b d5	 sub	 edx, r13d

; 1694 :     nd = i;
; 1695 :     if (nd0 > nd)
; 1696 :         nd0 = nd;
; 1697 : 
; 1698 :     /* Summary of parsing results.  After parsing, and dealing with zero
; 1699 :      * inputs, we have values s0, nd0, nd, e, sign, where:
; 1700 :      *
; 1701 :      *  - s0 points to the first significant digit of the input string
; 1702 :      *
; 1703 :      *  - nd is the total number of significant digits (here, and
; 1704 :      *    below, 'significant digits' means the set of digits of the
; 1705 :      *    significand of the input that remain after ignoring leading
; 1706 :      *    and trailing zeros).
; 1707 :      *
; 1708 :      *  - nd0 indicates the position of the decimal point, if present; it
; 1709 :      *    satisfies 1 <= nd0 <= nd.  The nd significant digits are in
; 1710 :      *    s0[0:nd0] and s0[nd0+1:nd+1] using the usual Python half-open slice
; 1711 :      *    notation.  (If nd0 < nd, then s0[nd0] contains a '.'  character; if
; 1712 :      *    nd0 == nd, then s0[nd0] could be any non-digit character.)
; 1713 :      *
; 1714 :      *  - e is the adjusted exponent: the absolute value of the number
; 1715 :      *    represented by the original input string is n * 10**e, where
; 1716 :      *    n is the integer represented by the concatenation of
; 1717 :      *    s0[0:nd0] and s0[nd0+1:nd+1]
; 1718 :      *
; 1719 :      *  - sign gives the sign of the input:  1 for negative, 0 for positive
; 1720 :      *
; 1721 :      *  - the first and last significant digits are nonzero
; 1722 :      */
; 1723 : 
; 1724 :     /* put first DBL_DIG+1 digits into integer y and z.
; 1725 :      *
; 1726 :      *  - y contains the value represented by the first min(9, nd)
; 1727 :      *    significant digits
; 1728 :      *
; 1729 :      *  - if nd > 9, z contains the value represented by significant digits
; 1730 :      *    with indices in [9, min(16, nd)).  So y * 10**(min(16, nd) - 9) + z
; 1731 :      *    gives the value represented by the first min(16, nd) sig. digits.
; 1732 :      */
; 1733 : 
; 1734 :     bc.e0 = e1 = e;
; 1735 :     y = z = 0;
; 1736 :     for (i = 0; i < nd; i++) {

  002ee	49 63 dd	 movsxd	 rbx, r13d
  002f1	44 03 e2	 add	 r12d, edx
  002f4	45 3b dd	 cmp	 r11d, r13d
  002f7	45 0f 4f dd	 cmovg	 r11d, r13d
  002fb	45 33 d2	 xor	 r10d, r10d
  002fe	45 33 c9	 xor	 r9d, r9d
  00301	45 33 c0	 xor	 r8d, r8d
  00304	33 d2		 xor	 edx, edx

; 1738 :             y = 10*y + s0[i < nd0 ? i : i+1] - '0';

  00306	49 63 fb	 movsxd	 rdi, r11d
  00309	44 89 65 78	 mov	 DWORD PTR e$1$[rbp-256], r12d
  0030d	44 89 64 24 28	 mov	 DWORD PTR bc$[rsp], r12d
  00312	45 85 ed	 test	 r13d, r13d
  00315	7e 4d		 jle	 SHORT $LN259@Py_dg_strt
$LL134@Py_dg_strt:

; 1737 :         if (i < 9)

  00317	41 83 f8 09	 cmp	 r8d, 9
  0031b	7d 1c		 jge	 SHORT $LN131@Py_dg_strt

; 1738 :             y = 10*y + s0[i < nd0 ? i : i+1] - '0';

  0031d	48 8b c2	 mov	 rax, rdx
  00320	48 3b d7	 cmp	 rdx, rdi
  00323	7c 04		 jl	 SHORT $LN183@Py_dg_strt
  00325	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
$LN183@Py_dg_strt:
  00329	42 0f be 0c 30	 movsx	 ecx, BYTE PTR [rax+r14]
  0032e	43 8d 04 89	 lea	 eax, DWORD PTR [r9+r9*4]
  00332	44 8d 4c 41 d0	 lea	 r9d, DWORD PTR [rcx+rax*2-48]
  00337	eb 20		 jmp	 SHORT $LN133@Py_dg_strt
$LN131@Py_dg_strt:

; 1739 :         else if (i < DBL_DIG+1)

  00339	41 83 f8 10	 cmp	 r8d, 16
  0033d	7d 25		 jge	 SHORT $LN259@Py_dg_strt

; 1740 :             z = 10*z + s0[i < nd0 ? i : i+1] - '0';

  0033f	48 8b c2	 mov	 rax, rdx
  00342	48 3b d7	 cmp	 rdx, rdi
  00345	7c 04		 jl	 SHORT $LN185@Py_dg_strt
  00347	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
$LN185@Py_dg_strt:
  0034b	42 0f be 0c 30	 movsx	 ecx, BYTE PTR [rax+r14]
  00350	43 8d 04 92	 lea	 eax, DWORD PTR [r10+r10*4]
  00354	44 8d 54 41 d0	 lea	 r10d, DWORD PTR [rcx+rax*2-48]
$LN133@Py_dg_strt:

; 1694 :     nd = i;
; 1695 :     if (nd0 > nd)
; 1696 :         nd0 = nd;
; 1697 : 
; 1698 :     /* Summary of parsing results.  After parsing, and dealing with zero
; 1699 :      * inputs, we have values s0, nd0, nd, e, sign, where:
; 1700 :      *
; 1701 :      *  - s0 points to the first significant digit of the input string
; 1702 :      *
; 1703 :      *  - nd is the total number of significant digits (here, and
; 1704 :      *    below, 'significant digits' means the set of digits of the
; 1705 :      *    significand of the input that remain after ignoring leading
; 1706 :      *    and trailing zeros).
; 1707 :      *
; 1708 :      *  - nd0 indicates the position of the decimal point, if present; it
; 1709 :      *    satisfies 1 <= nd0 <= nd.  The nd significant digits are in
; 1710 :      *    s0[0:nd0] and s0[nd0+1:nd+1] using the usual Python half-open slice
; 1711 :      *    notation.  (If nd0 < nd, then s0[nd0] contains a '.'  character; if
; 1712 :      *    nd0 == nd, then s0[nd0] could be any non-digit character.)
; 1713 :      *
; 1714 :      *  - e is the adjusted exponent: the absolute value of the number
; 1715 :      *    represented by the original input string is n * 10**e, where
; 1716 :      *    n is the integer represented by the concatenation of
; 1717 :      *    s0[0:nd0] and s0[nd0+1:nd+1]
; 1718 :      *
; 1719 :      *  - sign gives the sign of the input:  1 for negative, 0 for positive
; 1720 :      *
; 1721 :      *  - the first and last significant digits are nonzero
; 1722 :      */
; 1723 : 
; 1724 :     /* put first DBL_DIG+1 digits into integer y and z.
; 1725 :      *
; 1726 :      *  - y contains the value represented by the first min(9, nd)
; 1727 :      *    significant digits
; 1728 :      *
; 1729 :      *  - if nd > 9, z contains the value represented by significant digits
; 1730 :      *    with indices in [9, min(16, nd)).  So y * 10**(min(16, nd) - 9) + z
; 1731 :      *    gives the value represented by the first min(16, nd) sig. digits.
; 1732 :      */
; 1733 : 
; 1734 :     bc.e0 = e1 = e;
; 1735 :     y = z = 0;
; 1736 :     for (i = 0; i < nd; i++) {

  00359	48 ff c2	 inc	 rdx
  0035c	41 ff c0	 inc	 r8d
  0035f	48 3b d3	 cmp	 rdx, rbx
  00362	7c b3		 jl	 SHORT $LL134@Py_dg_strt
$LN259@Py_dg_strt:

; 1741 :         else
; 1742 :             break;
; 1743 :     }
; 1744 : 
; 1745 :     k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;

  00364	41 b8 10 00 00
	00		 mov	 r8d, 16

; 1746 :     dval(&rv) = y;

  0036a	66 0f ef f6	 pxor	 xmm6, xmm6
  0036e	41 8b c1	 mov	 eax, r9d
  00371	45 3b e8	 cmp	 r13d, r8d
  00374	f2 48 0f 2a f0	 cvtsi2sd xmm6, rax

; 1747 :     if (k > 9) {

  00379	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tens
  00380	45 0f 4c c5	 cmovl	 r8d, r13d
  00384	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
  0038a	41 83 f8 09	 cmp	 r8d, 9
  0038e	7e 1f		 jle	 SHORT $LN127@Py_dg_strt

; 1748 :         dval(&rv) = tens[k - 9] * dval(&rv) + z;

  00390	49 63 c0	 movsxd	 rax, r8d
  00393	66 0f ef c0	 pxor	 xmm0, xmm0
  00397	f2 0f 59 74 c2
	b8		 mulsd	 xmm6, QWORD PTR [rdx+rax*8-72]
  0039d	41 8b c2	 mov	 eax, r10d
  003a0	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  003a5	f2 0f 58 f0	 addsd	 xmm6, xmm0
  003a9	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
$LN127@Py_dg_strt:

; 1749 :     }
; 1750 :     bd0 = 0;
; 1751 :     if (nd <= DBL_DIG
; 1752 :         && Flt_Rounds == 1
; 1753 :         ) {

  003af	41 83 fd 0f	 cmp	 r13d, 15
  003b3	0f 8f f2 00 00
	00		 jg	 $LN120@Py_dg_strt

; 1754 :         if (!e)

  003b9	45 85 e4	 test	 r12d, r12d
  003bc	74 18		 je	 SHORT $ret$20871

; 1755 :             goto ret;
; 1756 :         if (e > 0) {

  003be	0f 8e ce 00 00
	00		 jle	 $LN124@Py_dg_strt

; 1757 :             if (e <= Ten_pmax) {

  003c4	41 83 fc 16	 cmp	 r12d, 22
  003c8	0f 8f 9c 00 00
	00		 jg	 $LN123@Py_dg_strt

; 1758 :                 dval(&rv) *= tens[e];

  003ce	49 63 c4	 movsxd	 rax, r12d
  003d1	f2 0f 59 34 c2	 mulsd	 xmm6, QWORD PTR [rdx+rax*8]
$ret$20871:

; 2276 :     }
; 2277 : 
; 2278 :   ret:
; 2279 :     return sign ? -dval(&rv) : dval(&rv);

  003d6	83 7d 70 00	 cmp	 DWORD PTR sign$1$[rbp-256], 0
  003da	74 05		 je	 SHORT $LN194@Py_dg_strt
  003dc	66 41 0f 57 f7	 xorpd	 xmm6, xmm15
$LN194@Py_dg_strt:
  003e1	66 0f 28 c6	 movapd	 xmm0, xmm6
$LN289@Py_dg_strt:
  003e5	44 0f 28 b4 24
	90 00 00 00	 movaps	 xmm14, XMMWORD PTR [rsp+144]
  003ee	44 0f 28 ac 24
	a0 00 00 00	 movaps	 xmm13, XMMWORD PTR [rsp+160]
  003f7	44 0f 28 a4 24
	b0 00 00 00	 movaps	 xmm12, XMMWORD PTR [rsp+176]
  00400	4c 8b bc 24 20
	01 00 00	 mov	 r15, QWORD PTR [rsp+288]
  00408	4c 8b ac 24 28
	01 00 00	 mov	 r13, QWORD PTR [rsp+296]
  00410	4c 8b a4 24 30
	01 00 00	 mov	 r12, QWORD PTR [rsp+304]
  00418	48 8b b4 24 68
	01 00 00	 mov	 rsi, QWORD PTR [rsp+360]
  00420	44 0f 28 9c 24
	c0 00 00 00	 movaps	 xmm11, XMMWORD PTR [rsp+192]
  00429	44 0f 28 94 24
	d0 00 00 00	 movaps	 xmm10, XMMWORD PTR [rsp+208]
  00432	44 0f 28 8c 24
	e0 00 00 00	 movaps	 xmm9, XMMWORD PTR [rsp+224]
  0043b	44 0f 28 84 24
	f0 00 00 00	 movaps	 xmm8, XMMWORD PTR [rsp+240]
  00444	0f 28 bc 24 00
	01 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+256]
  0044c	44 0f 28 bc 24
	80 00 00 00	 movaps	 xmm15, XMMWORD PTR [rsp+128]
$LN176@Py_dg_strt:

; 2297 : 
; 2298 : }

  00455	0f 28 b4 24 10
	01 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+272]
  0045d	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00464	41 5e		 pop	 r14
  00466	5f		 pop	 rdi
  00467	5b		 pop	 rbx
  00468	5d		 pop	 rbp
  00469	c3		 ret	 0
$LN123@Py_dg_strt:

; 1759 :                 goto ret;
; 1760 :             }
; 1761 :             i = DBL_DIG - nd;

  0046a	b9 0f 00 00 00	 mov	 ecx, 15
  0046f	41 2b cd	 sub	 ecx, r13d

; 1762 :             if (e <= Ten_pmax + i) {

  00472	8d 41 16	 lea	 eax, DWORD PTR [rcx+22]
  00475	44 3b e0	 cmp	 r12d, eax
  00478	7f 31		 jg	 SHORT $LN120@Py_dg_strt

; 1763 :                 /* A fancier test would sometimes let us do
; 1764 :                  * this for larger i values.
; 1765 :                  */
; 1766 :                 e -= i;
; 1767 :                 dval(&rv) *= tens[i];
; 1768 :                 dval(&rv) *= tens[e];

  0047a	48 63 c1	 movsxd	 rax, ecx
  0047d	49 63 cc	 movsxd	 rcx, r12d
  00480	48 2b c8	 sub	 rcx, rax
  00483	f2 0f 59 34 c2	 mulsd	 xmm6, QWORD PTR [rdx+rax*8]
  00488	f2 0f 59 34 ca	 mulsd	 xmm6, QWORD PTR [rdx+rcx*8]

; 1769 :                 goto ret;

  0048d	e9 44 ff ff ff	 jmp	 $ret$20871
$LN124@Py_dg_strt:

; 1770 :             }
; 1771 :         }
; 1772 :         else if (e >= -Ten_pmax) {

  00492	41 83 fc ea	 cmp	 r12d, -22
  00496	7c 13		 jl	 SHORT $LN120@Py_dg_strt

; 1773 :             dval(&rv) /= tens[-e];

  00498	49 63 c4	 movsxd	 rax, r12d
  0049b	48 c1 e0 03	 shl	 rax, 3
  0049f	48 2b d0	 sub	 rdx, rax
  004a2	f2 0f 5e 32	 divsd	 xmm6, QWORD PTR [rdx]

; 1774 :             goto ret;

  004a6	e9 2b ff ff ff	 jmp	 $ret$20871
$LN120@Py_dg_strt:

; 1775 :         }
; 1776 :     }
; 1777 :     e1 += nd - k;
; 1778 : 
; 1779 :     bc.scale = 0;

  004ab	33 db		 xor	 ebx, ebx
  004ad	41 8b cc	 mov	 ecx, r12d
  004b0	41 2b c8	 sub	 ecx, r8d

; 1780 : 
; 1781 :     /* Get starting approximation = rv * 10**e1 */
; 1782 : 
; 1783 :     if (e1 > 0) {

  004b3	41 83 c8 ff	 or	 r8d, -1			; ffffffffH
  004b7	89 5c 24 34	 mov	 DWORD PTR bc$[rsp+12], ebx
  004bb	41 03 cd	 add	 ecx, r13d
  004be	85 c9		 test	 ecx, ecx
  004c0	0f 8e d5 00 00
	00		 jle	 $LN291@Py_dg_strt

; 1784 :         if ((i = e1 & 15))

  004c6	8b c1		 mov	 eax, ecx
  004c8	83 e0 0f	 and	 eax, 15
  004cb	74 0d		 je	 SHORT $LN118@Py_dg_strt

; 1785 :             dval(&rv) *= tens[i];

  004cd	48 98		 cdqe
  004cf	f2 0f 59 34 c2	 mulsd	 xmm6, QWORD PTR [rdx+rax*8]
  004d4	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
$LN118@Py_dg_strt:

; 1786 :         if (e1 &= ~15) {

  004da	83 e1 f0	 and	 ecx, -16
  004dd	0f 84 a9 01 00
	00		 je	 $LN252@Py_dg_strt

; 1787 :             if (e1 > DBL_MAX_10_EXP)

  004e3	81 f9 34 01 00
	00		 cmp	 ecx, 308		; 00000134H
  004e9	0f 8f 8b 08 00
	00		 jg	 $ovfl$20896

; 1788 :                 goto ovfl;
; 1789 :             e1 >>= 4;

  004ef	c1 f9 04	 sar	 ecx, 4

; 1790 :             for(j = 0; e1 > 1; j++, e1 >>= 1)

  004f2	33 d2		 xor	 edx, edx
  004f4	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:bigtens
  004fb	83 f9 01	 cmp	 ecx, 1
  004fe	7e 1f		 jle	 SHORT $LN113@Py_dg_strt

; 1788 :                 goto ovfl;
; 1789 :             e1 >>= 4;

  00500	49 8b c2	 mov	 rax, r10
$LL115@Py_dg_strt:

; 1791 :                 if (e1 & 1)

  00503	f6 c1 01	 test	 cl, 1
  00506	74 0a		 je	 SHORT $LN114@Py_dg_strt

; 1792 :                     dval(&rv) *= bigtens[j];

  00508	f2 0f 59 30	 mulsd	 xmm6, QWORD PTR [rax]
  0050c	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
$LN114@Py_dg_strt:

; 1790 :             for(j = 0; e1 > 1; j++, e1 >>= 1)

  00512	d1 f9		 sar	 ecx, 1
  00514	ff c2		 inc	 edx
  00516	48 83 c0 08	 add	 rax, 8
  0051a	83 f9 01	 cmp	 ecx, 1
  0051d	7f e4		 jg	 SHORT $LL115@Py_dg_strt
$LN113@Py_dg_strt:

; 1793 :             /* The last multiplication could overflow. */
; 1794 :             word0(&rv) -= P*Exp_msk1;

  0051f	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  00524	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00528	2d 00 00 50 03	 sub	 eax, 55574528		; 03500000H
  0052d	89 44 24 24	 mov	 DWORD PTR rv$[rsp+4], eax

; 1795 :             dval(&rv) *= bigtens[j];

  00531	48 63 c2	 movsxd	 rax, edx
  00534	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR rv$[rsp]
  0053a	f2 41 0f 59 04
	c2		 mulsd	 xmm0, QWORD PTR [r10+rax*8]
  00540	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1796 :             if ((z = word0(&rv) & Exp_mask)
; 1797 :                 > Exp_msk1*(DBL_MAX_EXP+Bias-P))

  00546	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  0054b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0054f	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00554	3d 00 00 a0 7c	 cmp	 eax, 2090860544		; 7ca00000H
  00559	0f 87 1b 08 00
	00		 ja	 $ovfl$20896

; 1798 :                 goto ovfl;
; 1799 :             if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {

  0055f	3d 00 00 90 7c	 cmp	 eax, 2089811968		; 7c900000H
  00564	76 1c		 jbe	 SHORT $LN110@Py_dg_strt

; 1800 :                 /* set to largest number */
; 1801 :                 /* (Can't trust DBL_MAX) */
; 1802 :                 word0(&rv) = Big0;

  00566	be ff ff ef 7f	 mov	 esi, 2146435071		; 7fefffffH

; 1803 :                 word1(&rv) = Big1;

  0056b	44 89 44 24 20	 mov	 DWORD PTR rv$[rsp], r8d
  00570	45 8b f8	 mov	 r15d, r8d
  00573	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 1804 :             }
; 1805 :             else

  00577	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  0057d	e9 13 01 00 00	 jmp	 $LN249@Py_dg_strt
$LN110@Py_dg_strt:

; 1806 :                 word0(&rv) += P*Exp_msk1;

  00582	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]
  00586	81 c6 00 00 50
	03		 add	 esi, 55574528		; 03500000H
  0058c	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 1807 :         }

  00590	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00596	e9 f5 00 00 00	 jmp	 $LN292@Py_dg_strt
$LN291@Py_dg_strt:

; 1808 :     }
; 1809 :     else if (e1 < 0) {

  0059b	0f 89 eb 00 00
	00		 jns	 $LN252@Py_dg_strt

; 1810 :         /* The input decimal value lies in [10**e1, 10**(e1+16)).
; 1811 : 
; 1812 :            If e1 <= -512, underflow immediately.
; 1813 :            If e1 <= -256, set bc.scale to 2*P.
; 1814 : 
; 1815 :            So for input value < 1e-256, bc.scale is always set;
; 1816 :            for input value >= 1e-240, bc.scale is never set.
; 1817 :            For input values in [1e-256, 1e-240), bc.scale may or may
; 1818 :            not be set. */
; 1819 : 
; 1820 :         e1 = -e1;

  005a1	f7 d9		 neg	 ecx

; 1821 :         if ((i = e1 & 15))

  005a3	8b c1		 mov	 eax, ecx
  005a5	83 e0 0f	 and	 eax, 15
  005a8	74 0d		 je	 SHORT $LN106@Py_dg_strt

; 1822 :             dval(&rv) /= tens[i];

  005aa	48 98		 cdqe
  005ac	f2 0f 5e 34 c2	 divsd	 xmm6, QWORD PTR [rdx+rax*8]
  005b1	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
$LN106@Py_dg_strt:

; 1823 :         if (e1 >>= 4) {

  005b7	c1 f9 04	 sar	 ecx, 4
  005ba	85 c9		 test	 ecx, ecx
  005bc	0f 84 ca 00 00
	00		 je	 $LN252@Py_dg_strt

; 1824 :             if (e1 >= 1 << n_bigtens)

  005c2	83 f9 20	 cmp	 ecx, 32			; 00000020H
  005c5	0f 8d 73 09 00
	00		 jge	 $undfl$20909

; 1825 :                 goto undfl;
; 1826 :             if (e1 & Scale_Bit)

  005cb	f6 c1 10	 test	 cl, 16
  005ce	b8 6a 00 00 00	 mov	 eax, 106		; 0000006aH
  005d3	0f 45 d8	 cmovne	 ebx, eax
  005d6	89 5c 24 34	 mov	 DWORD PTR bc$[rsp+12], ebx

; 1827 :                 bc.scale = 2*P;
; 1828 :             for(j = 0; e1 > 0; j++, e1 >>= 1)

  005da	85 c9		 test	 ecx, ecx
  005dc	7e 20		 jle	 SHORT $LN100@Py_dg_strt

; 1830 :                     dval(&rv) *= tinytens[j];

  005de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tinytens
$LL102@Py_dg_strt:

; 1829 :                 if (e1 & 1)

  005e5	f6 c1 01	 test	 cl, 1
  005e8	74 0a		 je	 SHORT $LN101@Py_dg_strt

; 1830 :                     dval(&rv) *= tinytens[j];

  005ea	f2 0f 59 30	 mulsd	 xmm6, QWORD PTR [rax]
  005ee	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
$LN101@Py_dg_strt:

; 1827 :                 bc.scale = 2*P;
; 1828 :             for(j = 0; e1 > 0; j++, e1 >>= 1)

  005f4	d1 f9		 sar	 ecx, 1
  005f6	48 83 c0 08	 add	 rax, 8
  005fa	85 c9		 test	 ecx, ecx
  005fc	7f e7		 jg	 SHORT $LL102@Py_dg_strt
$LN100@Py_dg_strt:

; 1831 :             if (bc.scale && (j = 2*P + 1 - ((word0(&rv) & Exp_mask)
; 1832 :                                             >> Exp_shift)) > 0) {

  005fe	85 db		 test	 ebx, ebx
  00600	74 73		 je	 SHORT $LN250@Py_dg_strt
  00602	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  00607	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  0060c	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00610	c1 e8 14	 shr	 eax, 20
  00613	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00618	2b c8		 sub	 ecx, eax
  0061a	85 c9		 test	 ecx, ecx
  0061c	7e 57		 jle	 SHORT $LN250@Py_dg_strt

; 1833 :                 /* scaled rv is denormal; clear j low bits */
; 1834 :                 if (j >= 32) {

  0061e	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00621	7c 38		 jl	 SHORT $LN97@Py_dg_strt

; 1835 :                     word1(&rv) = 0;

  00623	45 33 ff	 xor	 r15d, r15d
  00626	44 89 7c 24 20	 mov	 DWORD PTR rv$[rsp], r15d

; 1836 :                     if (j >= 53)

  0062b	83 f9 35	 cmp	 ecx, 53			; 00000035H
  0062e	7c 11		 jl	 SHORT $LN96@Py_dg_strt

; 1837 :                         word0(&rv) = (P+2)*Exp_msk1;

  00630	be 00 00 70 03	 mov	 esi, 57671680		; 03700000H
  00635	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 1838 :                     else

  00639	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  0063f	eb 3d		 jmp	 SHORT $LN94@Py_dg_strt
$LN96@Py_dg_strt:

; 1839 :                         word0(&rv) &= 0xffffffff << (j-32);

  00641	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]
  00645	83 c1 e0	 add	 ecx, -32		; ffffffffffffffe0H
  00648	41 8b c0	 mov	 eax, r8d
  0064b	d3 e0		 shl	 eax, cl
  0064d	23 f0		 and	 esi, eax
  0064f	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 1840 :                 }
; 1841 :                 else

  00653	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00659	eb 23		 jmp	 SHORT $LN94@Py_dg_strt
$LN97@Py_dg_strt:

; 1842 :                     word1(&rv) &= 0xffffffff << j;

  0065b	44 8b 7c 24 20	 mov	 r15d, DWORD PTR rv$[rsp]
  00660	41 8b c0	 mov	 eax, r8d
  00663	d3 e0		 shl	 eax, cl
  00665	44 23 f8	 and	 r15d, eax
  00668	44 89 7c 24 20	 mov	 DWORD PTR rv$[rsp], r15d
  0066d	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00673	eb 05		 jmp	 SHORT $LN293@Py_dg_strt
$LN250@Py_dg_strt:

; 1840 :                 }
; 1841 :                 else

  00675	44 8b 7c 24 20	 mov	 r15d, DWORD PTR rv$[rsp]
$LN293@Py_dg_strt:
  0067a	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]
$LN94@Py_dg_strt:

; 1843 :             }
; 1844 :             if (!dval(&rv))

  0067e	66 0f 2e f1	 ucomisd xmm6, xmm1
  00682	7a 11		 jp	 SHORT $LN249@Py_dg_strt
  00684	0f 84 b4 08 00
	00		 je	 $undfl$20909
  0068a	eb 09		 jmp	 SHORT $LN249@Py_dg_strt
$LN252@Py_dg_strt:
  0068c	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]
$LN292@Py_dg_strt:
  00690	44 8b 7c 24 20	 mov	 r15d, DWORD PTR rv$[rsp]
$LN249@Py_dg_strt:

; 1845 :                 goto undfl;
; 1846 :         }
; 1847 :     }
; 1848 : 
; 1849 :     /* Now the hard part -- adjusting rv to the correct value.*/
; 1850 : 
; 1851 :     /* Put digits into bd: true value = bd * 10^e */
; 1852 : 
; 1853 :     bc.nd = nd;

  00695	44 89 6c 24 2c	 mov	 DWORD PTR bc$[rsp+4], r13d

; 1854 :     bc.nd0 = nd0;       /* Only needed if nd > STRTOD_DIGLIM, but done here */

  0069a	44 89 5c 24 30	 mov	 DWORD PTR bc$[rsp+8], r11d

; 1855 :                         /* to silence an erroneous warning about bc.nd0 */
; 1856 :                         /* possibly not being initialized. */
; 1857 :     if (nd > STRTOD_DIGLIM) {

  0069f	41 83 fd 28	 cmp	 r13d, 40		; 00000028H
  006a3	0f 8e 8e 00 00
	00		 jle	 $LN81@Py_dg_strt

; 1858 :         /* ASSERT(STRTOD_DIGLIM >= 18); 18 == one more than the */
; 1859 :         /* minimum number of decimal digits to distinguish double values */
; 1860 :         /* in IEEE arithmetic. */
; 1861 : 
; 1862 :         /* Truncate input to 18 significant digits, then discard any trailing
; 1863 :            zeros on the result by updating nd, nd0, e and y suitably. (There's
; 1864 :            no need to update z; it's not reused beyond this point.) */
; 1865 :         for (i = 18; i > 0; ) {

  006a9	b9 12 00 00 00	 mov	 ecx, 18
  006ae	8b c1		 mov	 eax, ecx
$LL91@Py_dg_strt:

; 1866 :             /* scan back until we hit a nonzero digit.  significant digit 'i'
; 1867 :             is s0[i] if i < nd0, s0[i+1] if i >= nd0. */
; 1868 :             --i;

  006b0	48 ff c8	 dec	 rax
  006b3	ff c9		 dec	 ecx

; 1869 :             if (s0[i < nd0 ? i : i+1] != '0') {

  006b5	48 8b d0	 mov	 rdx, rax
  006b8	48 3b c7	 cmp	 rax, rdi
  006bb	7c 04		 jl	 SHORT $LN187@Py_dg_strt
  006bd	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
$LN187@Py_dg_strt:
  006c1	42 80 3c 32 30	 cmp	 BYTE PTR [rdx+r14], 48	; 00000030H
  006c6	75 06		 jne	 SHORT $LN215@Py_dg_strt

; 1858 :         /* ASSERT(STRTOD_DIGLIM >= 18); 18 == one more than the */
; 1859 :         /* minimum number of decimal digits to distinguish double values */
; 1860 :         /* in IEEE arithmetic. */
; 1861 : 
; 1862 :         /* Truncate input to 18 significant digits, then discard any trailing
; 1863 :            zeros on the result by updating nd, nd0, e and y suitably. (There's
; 1864 :            no need to update z; it's not reused beyond this point.) */
; 1865 :         for (i = 18; i > 0; ) {

  006c8	85 c9		 test	 ecx, ecx
  006ca	7f e4		 jg	 SHORT $LL91@Py_dg_strt

; 2248 :                         if (aadj < .4999999 || aadj > .5000001)

  006cc	eb 02		 jmp	 SHORT $LN90@Py_dg_strt
$LN215@Py_dg_strt:

; 1870 :                 ++i;

  006ce	ff c1		 inc	 ecx
$LN90@Py_dg_strt:

; 1871 :                 break;
; 1872 :             }
; 1873 :         }
; 1874 :         e += nd - i;

  006d0	44 2b e9	 sub	 r13d, ecx
  006d3	45 03 e5	 add	 r12d, r13d

; 1875 :         nd = i;
; 1876 :         if (nd0 > nd)

  006d6	44 3b d9	 cmp	 r11d, ecx
  006d9	4c 63 e9	 movsxd	 r13, ecx
  006dc	44 0f 4f d9	 cmovg	 r11d, ecx
  006e0	44 89 65 78	 mov	 DWORD PTR e$1$[rbp-256], r12d
  006e4	44 89 6d 60	 mov	 DWORD PTR nd$1$[rbp-256], r13d

; 1877 :             nd0 = nd;
; 1878 :         if (nd < 9) { /* must recompute y */

  006e8	83 f9 09	 cmp	 ecx, 9
  006eb	7d 4a		 jge	 SHORT $LN81@Py_dg_strt

; 1879 :             y = 0;

  006ed	45 33 c9	 xor	 r9d, r9d

; 1880 :             for(i = 0; i < nd0; ++i)

  006f0	45 33 d2	 xor	 r10d, r10d
  006f3	33 d2		 xor	 edx, edx
  006f5	4d 63 c3	 movsxd	 r8, r11d
  006f8	45 85 db	 test	 r11d, r11d
  006fb	7e 19		 jle	 SHORT $LN84@Py_dg_strt

; 1879 :             y = 0;

  006fd	45 8b d0	 mov	 r10d, r8d
$LL86@Py_dg_strt:

; 1881 :                 y = 10*y + s0[i] - '0';

  00700	42 0f be 0c 32	 movsx	 ecx, BYTE PTR [rdx+r14]
  00705	43 8d 04 89	 lea	 eax, DWORD PTR [r9+r9*4]
  00709	48 ff c2	 inc	 rdx
  0070c	44 8d 4c 41 d0	 lea	 r9d, DWORD PTR [rcx+rax*2-48]
  00711	49 3b d0	 cmp	 rdx, r8
  00714	7c ea		 jl	 SHORT $LL86@Py_dg_strt
$LN84@Py_dg_strt:

; 1880 :             for(i = 0; i < nd0; ++i)

  00716	4d 63 c2	 movsxd	 r8, r10d

; 1882 :             for(; i < nd; ++i)

  00719	4d 3b c5	 cmp	 r8, r13
  0071c	7d 19		 jge	 SHORT $LN81@Py_dg_strt
  0071e	66 90		 npad	 2
$LL83@Py_dg_strt:

; 1883 :                 y = 10*y + s0[i+1] - '0';

  00720	43 0f be 4c 30
	01		 movsx	 ecx, BYTE PTR [r8+r14+1]
  00726	43 8d 04 89	 lea	 eax, DWORD PTR [r9+r9*4]
  0072a	49 ff c0	 inc	 r8
  0072d	44 8d 4c 41 d0	 lea	 r9d, DWORD PTR [rcx+rax*2-48]
  00732	4d 3b c5	 cmp	 r8, r13
  00735	7c e9		 jl	 SHORT $LL83@Py_dg_strt
$LN81@Py_dg_strt:

; 1884 :         }
; 1885 :     }
; 1886 :     bd0 = s2b(s0, nd0, nd, y);

  00737	45 8b c5	 mov	 r8d, r13d
  0073a	41 8b d3	 mov	 edx, r11d
  0073d	49 8b ce	 mov	 rcx, r14
  00740	e8 00 00 00 00	 call	 s2b
  00745	4c 8b e8	 mov	 r13, rax
  00748	48 89 44 24 40	 mov	 QWORD PTR bd0$1$[rsp], rax

; 1887 :     if (bd0 == NULL)

  0074d	f2 44 0f 10 35
	00 00 00 00	 movsdx	 xmm14, QWORD PTR __real@bff0000000000000
  00756	48 85 c0	 test	 rax, rax
  00759	0f 84 52 08 00
	00		 je	 $failed_malloc$20936

; 1888 :         goto failed_malloc;
; 1889 : 
; 1890 :     /* Notation for the comments below.  Write:
; 1891 : 
; 1892 :          - dv for the absolute value of the number represented by the original
; 1893 :            decimal input string.
; 1894 : 
; 1895 :          - if we've truncated dv, write tdv for the truncated value.
; 1896 :            Otherwise, set tdv == dv.
; 1897 : 
; 1898 :          - srv for the quantity rv/2^bc.scale; so srv is the current binary
; 1899 :            approximation to tdv (and dv).  It should be exactly representable
; 1900 :            in an IEEE 754 double.
; 1901 :     */
; 1902 : 
; 1903 :     for(;;) {
; 1904 : 
; 1905 :         /* This is the main correction loop for _Py_dg_strtod.
; 1906 : 
; 1907 :            We've got a decimal value tdv, and a floating-point approximation
; 1908 :            srv=rv/2^bc.scale to tdv.  The aim is to determine whether srv is
; 1909 :            close enough (i.e., within 0.5 ulps) to tdv, and to compute a new
; 1910 :            approximation if not.
; 1911 : 
; 1912 :            To determine whether srv is close enough to tdv, compute integers
; 1913 :            bd, bb and bs proportional to tdv, srv and 0.5 ulp(srv)
; 1914 :            respectively, and then use integer arithmetic to determine whether
; 1915 :            |tdv - srv| is less than, equal to, or greater than 0.5 ulp(srv).
; 1916 :         */
; 1917 : 
; 1918 :         bd = Balloc(bd0->k);

  0075f	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00762	e8 00 00 00 00	 call	 Balloc
  00767	48 8b f8	 mov	 rdi, rax
  0076a	48 89 44 24 48	 mov	 QWORD PTR bd$1$[rsp], rax

; 1919 :         if (bd == NULL) {

  0076f	48 85 c0	 test	 rax, rax
  00772	0f 84 31 08 00
	00		 je	 $LN216@Py_dg_strt
  00778	f2 44 0f 10 2d
	00 00 00 00	 movsdx	 xmm13, QWORD PTR __real@4000000000000000
  00781	f2 0f 10 3d 00
	00 00 00	 movsdx	 xmm7, QWORD PTR __real@3ff0000000000000
  00789	f2 44 0f 10 05
	00 00 00 00	 movsdx	 xmm8, QWORD PTR __real@3fe0000000000000
  00792	f2 44 0f 10 25
	00 00 00 00	 movsdx	 xmm12, QWORD PTR __real@41dfffffffc00000
  0079b	f2 44 0f 10 15
	00 00 00 00	 movsdx	 xmm10, QWORD PTR __real@3fcfffff94a03595
  007a4	f2 44 0f 10 1d
	00 00 00 00	 movsdx	 xmm11, QWORD PTR __real@3fdfffff94a03595
  007ad	f2 44 0f 10 0d
	00 00 00 00	 movsdx	 xmm9, QWORD PTR __real@3fe0000035afe535
$LN294@Py_dg_strt:

; 1921 :             goto failed_malloc;
; 1922 :         }
; 1923 :         Bcopy(bd, bd0);

  007b6	4d 63 45 14	 movsxd	 r8, DWORD PTR [r13+20]
  007ba	49 8d 45 10	 lea	 rax, QWORD PTR [r13+16]
  007be	48 8d 4f 10	 lea	 rcx, QWORD PTR [rdi+16]
  007c2	4e 8d 04 85 08
	00 00 00	 lea	 r8, QWORD PTR [r8*4+8]
  007ca	48 8b d0	 mov	 rdx, rax
  007cd	e8 00 00 00 00	 call	 memcpy

; 1924 :         bb = sd2b(&rv, bc.scale, &bbe);   /* srv = bb * 2^bbe */

  007d2	4c 8d 44 24 6c	 lea	 r8, QWORD PTR bbe$[rsp]
  007d7	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  007dc	8b d3		 mov	 edx, ebx
  007de	e8 00 00 00 00	 call	 sd2b
  007e3	4c 8b f0	 mov	 r14, rax
  007e6	48 89 44 24 38	 mov	 QWORD PTR bb$1$[rsp], rax

; 1925 :         if (bb == NULL) {

  007eb	48 85 c0	 test	 rax, rax
  007ee	0f 84 ad 07 00
	00		 je	 $LN217@Py_dg_strt

; 1927 :             Bfree(bd0);
; 1928 :             goto failed_malloc;
; 1929 :         }
; 1930 :         /* Record whether lsb of bb is odd, in case we need this
; 1931 :            for the round-to-even step later. */
; 1932 :         odd = bb->x[0] & 1;

  007f4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]

; 1933 : 
; 1934 :         /* tdv = bd * 10**e;  srv = bb * 2**bbe */
; 1935 :         bs = i2b(1);

  007f7	b9 01 00 00 00	 mov	 ecx, 1
  007fc	83 e0 01	 and	 eax, 1
  007ff	89 44 24 68	 mov	 DWORD PTR odd$1$[rsp], eax
  00803	e8 00 00 00 00	 call	 i2b
  00808	48 8b d8	 mov	 rbx, rax
  0080b	48 89 44 24 58	 mov	 QWORD PTR bs$1$[rsp], rax

; 1936 :         if (bs == NULL) {

  00810	48 85 c0	 test	 rax, rax
  00813	0f 84 80 07 00
	00		 je	 $LN218@Py_dg_strt

; 1938 :             Bfree(bd);
; 1939 :             Bfree(bd0);
; 1940 :             goto failed_malloc;
; 1941 :         }
; 1942 : 
; 1943 :         if (e >= 0) {

  00819	45 85 e4	 test	 r12d, r12d
  0081c	78 09		 js	 SHORT $LN74@Py_dg_strt

; 1944 :             bb2 = bb5 = 0;

  0081e	33 d2		 xor	 edx, edx

; 1945 :             bd2 = bd5 = e;

  00820	45 8b f4	 mov	 r14d, r12d
  00823	33 ff		 xor	 edi, edi

; 1946 :         }
; 1947 :         else {

  00825	eb 0d		 jmp	 SHORT $LN73@Py_dg_strt
$LN74@Py_dg_strt:

; 1948 :             bb2 = bb5 = -e;

  00827	41 8b d4	 mov	 edx, r12d

; 1949 :             bd2 = bd5 = 0;

  0082a	45 33 f6	 xor	 r14d, r14d
  0082d	f7 da		 neg	 edx
  0082f	45 33 e4	 xor	 r12d, r12d
  00832	8b fa		 mov	 edi, edx
$LN73@Py_dg_strt:

; 1950 :         }
; 1951 :         if (bbe >= 0)

  00834	8b 44 24 6c	 mov	 eax, DWORD PTR bbe$[rsp]
  00838	85 c0		 test	 eax, eax
  0083a	78 04		 js	 SHORT $LN72@Py_dg_strt

; 1952 :             bb2 += bbe;

  0083c	03 f8		 add	 edi, eax

; 1953 :         else

  0083e	eb 03		 jmp	 SHORT $LN71@Py_dg_strt
$LN72@Py_dg_strt:

; 1954 :             bd2 -= bbe;

  00840	44 2b e0	 sub	 r12d, eax
$LN71@Py_dg_strt:

; 1955 :         bs2 = bb2;
; 1956 :         bb2++;
; 1957 :         bd2++;

  00843	41 ff c4	 inc	 r12d
  00846	44 8b ef	 mov	 r13d, edi
  00849	ff c7		 inc	 edi

; 1958 : 
; 1959 :         /* At this stage bd5 - bb5 == e == bd2 - bb2 + bbe, bb2 - bs2 == 1,
; 1960 :            and bs == 1, so:
; 1961 : 
; 1962 :               tdv == bd * 10**e = bd * 2**(bbe - bb2 + bd2) * 5**(bd5 - bb5)
; 1963 :               srv == bb * 2**bbe = bb * 2**(bbe - bb2 + bb2)
; 1964 :               0.5 ulp(srv) == 2**(bbe-1) = bs * 2**(bbe - bb2 + bs2)
; 1965 : 
; 1966 :            It follows that:
; 1967 : 
; 1968 :               M * tdv = bd * 2**bd2 * 5**bd5
; 1969 :               M * srv = bb * 2**bb2 * 5**bb5
; 1970 :               M * 0.5 ulp(srv) = bs * 2**bs2 * 5**bb5
; 1971 : 
; 1972 :            for some constant M.  (Actually, M == 2**(bb2 - bbe) * 5**bb5, but
; 1973 :            this fact is not needed below.)
; 1974 :         */
; 1975 : 
; 1976 :         /* Remove factor of 2**i, where i = min(bb2, bd2, bs2). */
; 1977 :         i = bb2 < bd2 ? bb2 : bd2;

  0084b	41 3b fc	 cmp	 edi, r12d
  0084e	41 8b c4	 mov	 eax, r12d
  00851	0f 4c c7	 cmovl	 eax, edi

; 1978 :         if (i > bs2)

  00854	41 3b c5	 cmp	 eax, r13d
  00857	41 0f 4f c5	 cmovg	 eax, r13d

; 1979 :             i = bs2;
; 1980 :         if (i > 0) {

  0085b	85 c0		 test	 eax, eax
  0085d	7e 08		 jle	 SHORT $LN69@Py_dg_strt

; 1981 :             bb2 -= i;

  0085f	2b f8		 sub	 edi, eax

; 1982 :             bd2 -= i;

  00861	44 2b e0	 sub	 r12d, eax

; 1983 :             bs2 -= i;

  00864	44 2b e8	 sub	 r13d, eax
$LN69@Py_dg_strt:

; 1984 :         }
; 1985 : 
; 1986 :         /* Scale bb, bd, bs by the appropriate powers of 2 and 5. */
; 1987 :         if (bb5 > 0) {

  00867	85 d2		 test	 edx, edx
  00869	7e 48		 jle	 SHORT $LN261@Py_dg_strt

; 1988 :             bs = pow5mult(bs, bb5);

  0086b	48 8b cb	 mov	 rcx, rbx
  0086e	e8 00 00 00 00	 call	 pow5mult
  00873	48 89 44 24 58	 mov	 QWORD PTR bs$1$[rsp], rax

; 1989 :             if (bs == NULL) {

  00878	48 85 c0	 test	 rax, rax
  0087b	0f 84 3e 04 00
	00		 je	 $LN219@Py_dg_strt

; 1994 :             }
; 1995 :             bb1 = mult(bs, bb);

  00881	48 8b 54 24 38	 mov	 rdx, QWORD PTR bb$1$[rsp]
  00886	48 8b c8	 mov	 rcx, rax
  00889	e8 00 00 00 00	 call	 mult

; 1996 :             Bfree(bb);

  0088e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00893	48 8b d8	 mov	 rbx, rax
  00896	e8 00 00 00 00	 call	 Bfree

; 1997 :             bb = bb1;

  0089b	48 8b c3	 mov	 rax, rbx
  0089e	48 89 5c 24 38	 mov	 QWORD PTR bb$1$[rsp], rbx

; 1998 :             if (bb == NULL) {

  008a3	48 85 db	 test	 rbx, rbx
  008a6	0f 84 f5 03 00
	00		 je	 $LN220@Py_dg_strt
  008ac	48 8b 5c 24 58	 mov	 rbx, QWORD PTR bs$1$[rsp]

; 2006 :             bb = lshift(bb, bb2);

  008b1	eb 05		 jmp	 SHORT $LN66@Py_dg_strt
$LN261@Py_dg_strt:
  008b3	48 8b 44 24 38	 mov	 rax, QWORD PTR bb$1$[rsp]
$LN66@Py_dg_strt:

; 2003 :             }
; 2004 :         }
; 2005 :         if (bb2 > 0) {

  008b8	85 ff		 test	 edi, edi
  008ba	7e 18		 jle	 SHORT $LN64@Py_dg_strt

; 2006 :             bb = lshift(bb, bb2);

  008bc	8b d7		 mov	 edx, edi
  008be	48 8b c8	 mov	 rcx, rax
  008c1	e8 00 00 00 00	 call	 lshift
  008c6	48 89 44 24 38	 mov	 QWORD PTR bb$1$[rsp], rax

; 2007 :             if (bb == NULL) {

  008cb	48 85 c0	 test	 rax, rax
  008ce	0f 84 f2 03 00
	00		 je	 $LN221@Py_dg_strt
$LN64@Py_dg_strt:

; 2012 :             }
; 2013 :         }
; 2014 :         if (bd5 > 0) {

  008d4	45 85 f6	 test	 r14d, r14d
  008d7	7e 31		 jle	 SHORT $LN260@Py_dg_strt

; 2015 :             bd = pow5mult(bd, bd5);

  008d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bd$1$[rsp]
  008de	41 8b d6	 mov	 edx, r14d
  008e1	e8 00 00 00 00	 call	 pow5mult
  008e6	4c 8b f0	 mov	 r14, rax

; 2016 :             if (bd == NULL) {

  008e9	48 85 c0	 test	 rax, rax
  008ec	75 21		 jne	 SHORT $LN62@Py_dg_strt
$LN222@Py_dg_strt:

; 2017 :                 Bfree(bb);

  008ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  008f3	e8 00 00 00 00	 call	 Bfree

; 2018 :                 Bfree(bs);

  008f8	48 8b cb	 mov	 rcx, rbx
  008fb	e8 00 00 00 00	 call	 Bfree
  00900	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00905	e9 a2 06 00 00	 jmp	 $LN295@Py_dg_strt
$LN260@Py_dg_strt:

; 1888 :         goto failed_malloc;
; 1889 : 
; 1890 :     /* Notation for the comments below.  Write:
; 1891 : 
; 1892 :          - dv for the absolute value of the number represented by the original
; 1893 :            decimal input string.
; 1894 : 
; 1895 :          - if we've truncated dv, write tdv for the truncated value.
; 1896 :            Otherwise, set tdv == dv.
; 1897 : 
; 1898 :          - srv for the quantity rv/2^bc.scale; so srv is the current binary
; 1899 :            approximation to tdv (and dv).  It should be exactly representable
; 1900 :            in an IEEE 754 double.
; 1901 :     */
; 1902 : 
; 1903 :     for(;;) {
; 1904 : 
; 1905 :         /* This is the main correction loop for _Py_dg_strtod.
; 1906 : 
; 1907 :            We've got a decimal value tdv, and a floating-point approximation
; 1908 :            srv=rv/2^bc.scale to tdv.  The aim is to determine whether srv is
; 1909 :            close enough (i.e., within 0.5 ulps) to tdv, and to compute a new
; 1910 :            approximation if not.
; 1911 : 
; 1912 :            To determine whether srv is close enough to tdv, compute integers
; 1913 :            bd, bb and bs proportional to tdv, srv and 0.5 ulp(srv)
; 1914 :            respectively, and then use integer arithmetic to determine whether
; 1915 :            |tdv - srv| is less than, equal to, or greater than 0.5 ulp(srv).
; 1916 :         */
; 1917 : 
; 1918 :         bd = Balloc(bd0->k);

  0090a	4c 8b 74 24 48	 mov	 r14, QWORD PTR bd$1$[rsp]
$LN62@Py_dg_strt:

; 2019 :                 Bfree(bd0);
; 2020 :                 goto failed_malloc;
; 2021 :             }
; 2022 :         }
; 2023 :         if (bd2 > 0) {

  0090f	45 85 e4	 test	 r12d, r12d
  00912	7e 13		 jle	 SHORT $LN60@Py_dg_strt

; 2024 :             bd = lshift(bd, bd2);

  00914	41 8b d4	 mov	 edx, r12d
  00917	49 8b ce	 mov	 rcx, r14
  0091a	e8 00 00 00 00	 call	 lshift
  0091f	4c 8b f0	 mov	 r14, rax

; 2025 :             if (bd == NULL) {

  00922	48 85 c0	 test	 rax, rax
  00925	74 c7		 je	 SHORT $LN222@Py_dg_strt
$LN60@Py_dg_strt:

; 2026 :                 Bfree(bb);
; 2027 :                 Bfree(bs);
; 2028 :                 Bfree(bd0);
; 2029 :                 goto failed_malloc;
; 2030 :             }
; 2031 :         }
; 2032 :         if (bs2 > 0) {

  00927	45 85 ed	 test	 r13d, r13d
  0092a	7e 1c		 jle	 SHORT $LN58@Py_dg_strt

; 2033 :             bs = lshift(bs, bs2);

  0092c	41 8b d5	 mov	 edx, r13d
  0092f	48 8b cb	 mov	 rcx, rbx
  00932	e8 00 00 00 00	 call	 lshift
  00937	48 8b d8	 mov	 rbx, rax
  0093a	48 89 44 24 58	 mov	 QWORD PTR bs$1$[rsp], rax

; 2034 :             if (bs == NULL) {

  0093f	48 85 c0	 test	 rax, rax
  00942	0f 84 83 03 00
	00		 je	 $LN224@Py_dg_strt
$LN58@Py_dg_strt:

; 2037 :                 Bfree(bd0);
; 2038 :                 goto failed_malloc;
; 2039 :             }
; 2040 :         }
; 2041 : 
; 2042 :         /* Now bd, bb and bs are scaled versions of tdv, srv and 0.5 ulp(srv),
; 2043 :            respectively.  Compute the difference |tdv - srv|, and compare
; 2044 :            with 0.5 ulp(srv). */
; 2045 : 
; 2046 :         delta = diff(bb, bd);

  00948	4c 8b 64 24 38	 mov	 r12, QWORD PTR bb$1$[rsp]
  0094d	49 8b d6	 mov	 rdx, r14
  00950	49 8b cc	 mov	 rcx, r12
  00953	e8 00 00 00 00	 call	 diff
  00958	48 8b f8	 mov	 rdi, rax

; 2047 :         if (delta == NULL) {

  0095b	48 85 c0	 test	 rax, rax
  0095e	0f 84 16 06 00
	00		 je	 $LN225@Py_dg_strt

; 2051 :             Bfree(bd0);
; 2052 :             goto failed_malloc;
; 2053 :         }
; 2054 :         dsign = delta->sign;

  00964	8b 58 10	 mov	 ebx, DWORD PTR [rax+16]

; 2055 :         delta->sign = 0;
; 2056 :         i = cmp(delta, bs);

  00967	4c 8b 64 24 58	 mov	 r12, QWORD PTR bs$1$[rsp]
  0096c	45 33 d2	 xor	 r10d, r10d
  0096f	48 8b c8	 mov	 rcx, rax
  00972	49 8b d4	 mov	 rdx, r12
  00975	44 89 50 10	 mov	 DWORD PTR [rax+16], r10d
  00979	e8 00 00 00 00	 call	 cmp

; 2057 :         if (bc.nd > nd && i <= 0) {

  0097e	44 8b 6d 60	 mov	 r13d, DWORD PTR nd$1$[rbp-256]
  00982	44 8b 44 24 2c	 mov	 r8d, DWORD PTR bc$[rsp+4]
  00987	45 3b c5	 cmp	 r8d, r13d
  0098a	7e 08		 jle	 SHORT $LN56@Py_dg_strt
  0098c	85 c0		 test	 eax, eax
  0098e	0f 8e 53 03 00
	00		 jle	 $LN248@Py_dg_strt
$LN56@Py_dg_strt:

; 2086 :                 i = -1; /* Discarded digits make delta smaller. */
; 2087 :             }
; 2088 :         }
; 2089 : 
; 2090 :         if (i < 0) {

  00994	85 c0		 test	 eax, eax
  00996	0f 88 de 04 00
	00		 js	 $LN228@Py_dg_strt

; 2112 :                 goto drop_down;
; 2113 :             break;
; 2114 :         }
; 2115 :         if (i == 0) {

  0099c	0f 84 0e 04 00
	00		 je	 $LN229@Py_dg_strt

; 2164 :                 }
; 2165 :             }
; 2166 :             /* dsign = 1 - dsign; */
; 2167 :             break;
; 2168 :         }
; 2169 :         if ((aadj = ratio(delta, bs)) <= 2.) {

  009a2	49 8b d4	 mov	 rdx, r12
  009a5	48 8b cf	 mov	 rcx, rdi
  009a8	e8 00 00 00 00	 call	 ratio
  009ad	66 44 0f 2f e8	 comisd	 xmm13, xmm0
  009b2	66 0f 28 d0	 movapd	 xmm2, xmm0
  009b6	0f 82 ea 00 00
	00		 jb	 $LN32@Py_dg_strt

; 2170 :             if (dsign)

  009bc	85 db		 test	 ebx, ebx
  009be	74 0a		 je	 SHORT $LN31@Py_dg_strt

; 2171 :                 aadj = aadj1 = 1.;

  009c0	66 0f 28 cf	 movapd	 xmm1, xmm7
  009c4	66 0f 28 d7	 movapd	 xmm2, xmm7
  009c8	eb 2d		 jmp	 SHORT $LN191@Py_dg_strt
$LN31@Py_dg_strt:

; 2172 :             else if (word1(&rv) || word0(&rv) & Bndry_mask) {

  009ca	45 85 ff	 test	 r15d, r15d
  009cd	0f 85 b7 00 00
	00		 jne	 $LN28@Py_dg_strt
  009d3	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  009d9	0f 85 b9 00 00
	00		 jne	 $LN27@Py_dg_strt

; 2180 :             }
; 2181 :             else {
; 2182 :                 /* special case -- power of FLT_RADIX to be */
; 2183 :                 /* rounded down... */
; 2184 : 
; 2185 :                 if (aadj < 2./FLT_RADIX)

  009df	66 0f 2f f8	 comisd	 xmm7, xmm0
  009e3	0f 86 97 00 00
	00		 jbe	 $LN24@Py_dg_strt

; 2186 :                     aadj = 1./FLT_RADIX;

  009e9	66 41 0f 28 d0	 movapd	 xmm2, xmm8
$LN190@Py_dg_strt:

; 2194 :             aadj1 = dsign ? aadj : -aadj;

  009ee	66 0f 28 ca	 movapd	 xmm1, xmm2
  009f2	66 41 0f 57 cf	 xorpd	 xmm1, xmm15
$LN191@Py_dg_strt:

; 2195 :             if (Flt_Rounds == 0)
; 2196 :                 aadj1 += 0.5;
; 2197 :         }
; 2198 :         y = word0(&rv) & Exp_mask;

  009f7	8b d6		 mov	 edx, esi
  009f9	81 e2 00 00 f0
	7f		 and	 edx, 2146435072		; 7ff00000H

; 2199 : 
; 2200 :         /* Check for overflow */
; 2201 : 
; 2202 :         if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {

  009ff	81 fa 00 00 e0
	7f		 cmp	 edx, 2145386496		; 7fe00000H
  00a05	0f 85 cc 00 00
	00		 jne	 $LN20@Py_dg_strt

; 2203 :             dval(&rv0) = dval(&rv);
; 2204 :             word0(&rv) -= P*Exp_msk1;
; 2205 :             adj.d = aadj1 * ulp(&rv);

  00a0b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  00a10	81 c6 00 00 b0
	fc		 add	 esi, -55574528		; fcb00000H
  00a16	f2 0f 11 74 24
	50		 movsdx	 QWORD PTR rv0$[rsp], xmm6
  00a1c	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi
  00a20	e8 00 00 00 00	 call	 ulp
  00a25	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 2206 :             dval(&rv) += adj.d;

  00a29	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR rv$[rsp]
  00a2f	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00a33	f2 0f 11 4c 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm1

; 2207 :             if ((word0(&rv) & Exp_mask) >=
; 2208 :                 Exp_msk1*(DBL_MAX_EXP+Bias-P)) {

  00a39	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  00a3e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00a42	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00a47	3d 00 00 a0 7c	 cmp	 eax, 2090860544		; 7ca00000H
  00a4c	72 6e		 jb	 SHORT $LN19@Py_dg_strt

; 2209 :                 if (word0(&rv0) == Big0 && word1(&rv0) == Big1) {

  00a4e	81 7c 24 54 ff
	ff ef 7f	 cmp	 DWORD PTR rv0$[rsp+4], 2146435071 ; 7fefffffH
  00a56	75 0b		 jne	 SHORT $LN18@Py_dg_strt
  00a58	83 7c 24 50 ff	 cmp	 DWORD PTR rv0$[rsp], -1	; ffffffffH
  00a5d	0f 84 eb 02 00
	00		 je	 $LN231@Py_dg_strt
$LN18@Py_dg_strt:

; 2215 :                     goto ovfl;
; 2216 :                 }
; 2217 :                 word0(&rv) = Big0;

  00a63	be ff ff ef 7f	 mov	 esi, 2146435071		; 7fefffffH

; 2218 :                 word1(&rv) = Big1;

  00a68	41 83 cf ff	 or	 r15d, -1		; ffffffffH
  00a6c	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi
  00a70	44 89 7c 24 20	 mov	 DWORD PTR rv$[rsp], r15d

; 2219 :                 goto cont;

  00a75	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00a7b	e9 d3 01 00 00	 jmp	 $cont$21017
$LN24@Py_dg_strt:

; 2187 :                 else
; 2188 :                     aadj *= 0.5;

  00a80	f2 41 0f 59 d0	 mulsd	 xmm2, xmm8

; 2189 :                 aadj1 = -aadj;

  00a85	e9 64 ff ff ff	 jmp	 $LN190@Py_dg_strt
$LN28@Py_dg_strt:

; 2173 :                 if (word1(&rv) == Tiny1 && !word0(&rv)) {

  00a8a	41 83 ff 01	 cmp	 r15d, 1
  00a8e	75 08		 jne	 SHORT $LN27@Py_dg_strt
  00a90	85 f6		 test	 esi, esi
  00a92	0f 84 a6 02 00
	00		 je	 $LN230@Py_dg_strt
$LN27@Py_dg_strt:

; 2175 :                         break;
; 2176 :                     goto undfl;
; 2177 :                 }
; 2178 :                 aadj = 1.;

  00a98	66 0f 28 d7	 movapd	 xmm2, xmm7

; 2179 :                 aadj1 = -1.;

  00a9c	66 41 0f 28 ce	 movapd	 xmm1, xmm14

; 2190 :             }
; 2191 :         }
; 2192 :         else {

  00aa1	e9 51 ff ff ff	 jmp	 $LN191@Py_dg_strt
$LN32@Py_dg_strt:

; 2193 :             aadj *= 0.5;

  00aa6	f2 41 0f 59 d0	 mulsd	 xmm2, xmm8

; 2194 :             aadj1 = dsign ? aadj : -aadj;

  00aab	85 db		 test	 ebx, ebx
  00aad	0f 84 3b ff ff
	ff		 je	 $LN190@Py_dg_strt
  00ab3	66 0f 28 ca	 movapd	 xmm1, xmm2
  00ab7	e9 3b ff ff ff	 jmp	 $LN191@Py_dg_strt
$LN19@Py_dg_strt:

; 2220 :             }
; 2221 :             else
; 2222 :                 word0(&rv) += P*Exp_msk1;

  00abc	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]

; 2223 :         }
; 2224 :         else {

  00ac0	44 8b 44 24 34	 mov	 r8d, DWORD PTR bc$[rsp+12]
  00ac5	81 c6 00 00 50
	03		 add	 esi, 55574528		; 03500000H
  00acb	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi
  00acf	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00ad5	eb 7a		 jmp	 SHORT $LN16@Py_dg_strt
$LN20@Py_dg_strt:

; 2225 :             if (bc.scale && y <= 2*P*Exp_msk1) {

  00ad7	44 8b 44 24 34	 mov	 r8d, DWORD PTR bc$[rsp+12]
  00adc	45 85 c0	 test	 r8d, r8d
  00adf	74 54		 je	 SHORT $LN15@Py_dg_strt
  00ae1	81 fa 00 00 a0
	06		 cmp	 edx, 111149056		; 06a00000H
  00ae7	77 4c		 ja	 SHORT $LN15@Py_dg_strt

; 2226 :                 if (aadj <= 0x7fffffff) {

  00ae9	66 44 0f 2f e2	 comisd	 xmm12, xmm2
  00aee	72 25		 jb	 SHORT $LN193@Py_dg_strt

; 2227 :                     if ((z = (ULong)aadj) <= 0)

  00af0	f2 48 0f 2c c2	 cvttsd2si rax, xmm2
  00af5	b9 01 00 00 00	 mov	 ecx, 1

; 2228 :                         z = 1;
; 2229 :                     aadj = z;

  00afa	66 0f ef d2	 pxor	 xmm2, xmm2
  00afe	85 c0		 test	 eax, eax
  00b00	0f 44 c1	 cmove	 eax, ecx
  00b03	f2 48 0f 2a d0	 cvtsi2sd xmm2, rax

; 2230 :                     aadj1 = dsign ? aadj : -aadj;

  00b08	66 0f 28 ca	 movapd	 xmm1, xmm2
  00b0c	85 db		 test	 ebx, ebx
  00b0e	75 05		 jne	 SHORT $LN193@Py_dg_strt
  00b10	66 41 0f 57 cf	 xorpd	 xmm1, xmm15
$LN193@Py_dg_strt:

; 2231 :                 }
; 2232 :                 dval(&aadj2) = aadj1;

  00b15	f2 0f 11 4c 24
	60		 movsdx	 QWORD PTR aadj2$[rsp], xmm1

; 2233 :                 word0(&aadj2) += (2*P+1)*Exp_msk1 - y;

  00b1b	48 8b 44 24 60	 mov	 rax, QWORD PTR aadj2$[rsp]
  00b20	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00b24	2b c2		 sub	 eax, edx
  00b26	05 00 00 b0 06	 add	 eax, 112197632		; 06b00000H
  00b2b	89 44 24 64	 mov	 DWORD PTR aadj2$[rsp+4], eax

; 2234 :                 aadj1 = dval(&aadj2);

  00b2f	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR aadj2$[rsp]
$LN15@Py_dg_strt:

; 2235 :             }
; 2236 :             adj.d = aadj1 * ulp(&rv);

  00b35	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  00b3a	e8 00 00 00 00	 call	 ulp
  00b3f	f2 0f 59 c1	 mulsd	 xmm0, xmm1

; 2237 :             dval(&rv) += adj.d;

  00b43	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00b47	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
  00b4d	8b 74 24 24	 mov	 esi, DWORD PTR rv$[rsp+4]
$LN16@Py_dg_strt:

; 2238 :         }
; 2239 :         z = word0(&rv) & Exp_mask;
; 2240 :         if (bc.nd == nd) {

  00b51	44 39 6c 24 2c	 cmp	 DWORD PTR bc$[rsp+4], r13d
  00b56	0f 85 f2 00 00
	00		 jne	 $LN254@Py_dg_strt

; 2241 :             if (!bc.scale)

  00b5c	45 85 c0	 test	 r8d, r8d
  00b5f	0f 85 e9 00 00
	00		 jne	 $LN254@Py_dg_strt

; 2246 :                     /* The tolerances below are conservative. */
; 2247 :                     if (dsign || word1(&rv) || word0(&rv) & Bndry_mask) {

  00b65	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rv$[rsp]
  00b6a	44 8b 7c 24 20	 mov	 r15d, DWORD PTR rv$[rsp]
  00b6f	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00b73	8b c1		 mov	 eax, ecx
  00b75	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00b7a	3b d0		 cmp	 edx, eax
  00b7c	0f 85 d1 00 00
	00		 jne	 $cont$21017

; 2242 :                 if (y == z) {
; 2243 :                     /* Can we stop now? */
; 2244 :                     L = (Long)aadj;
; 2245 :                     aadj -= L;

  00b82	f2 0f 2c c2	 cvttsd2si eax, xmm2
  00b86	66 0f 6e c0	 movd	 xmm0, eax
  00b8a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00b8e	f2 0f 5c d0	 subsd	 xmm2, xmm0

; 2246 :                     /* The tolerances below are conservative. */
; 2247 :                     if (dsign || word1(&rv) || word0(&rv) & Bndry_mask) {

  00b92	85 db		 test	 ebx, ebx
  00b94	0f 85 9c 00 00
	00		 jne	 $LN8@Py_dg_strt
  00b9a	45 85 ff	 test	 r15d, r15d
  00b9d	0f 85 93 00 00
	00		 jne	 $LN8@Py_dg_strt
  00ba3	f7 c1 ff ff 0f
	00		 test	 ecx, 1048575		; 000fffffH
  00ba9	0f 85 87 00 00
	00		 jne	 $LN8@Py_dg_strt

; 2249 :                             break;
; 2250 :                     }
; 2251 :                     else if (aadj < .4999999/FLT_RADIX)

  00baf	66 44 0f 2f d2	 comisd	 xmm10, xmm2
  00bb4	0f 86 99 00 00
	00		 jbe	 $cont$21017
$LN276@Py_dg_strt:

; 2129 :                     /* dsign = 0; */
; 2130 :                     break;

  00bba	8b 5c 24 34	 mov	 ebx, DWORD PTR bc$[rsp+12]
$LN232@Py_dg_strt:

; 2260 :     }
; 2261 :     Bfree(bb);

  00bbe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00bc3	e8 00 00 00 00	 call	 Bfree

; 2262 :     Bfree(bd);

  00bc8	49 8b ce	 mov	 rcx, r14
  00bcb	e8 00 00 00 00	 call	 Bfree

; 2263 :     Bfree(bs);

  00bd0	49 8b cc	 mov	 rcx, r12
  00bd3	e8 00 00 00 00	 call	 Bfree

; 2264 :     Bfree(bd0);

  00bd8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00bdd	e8 00 00 00 00	 call	 Bfree

; 2265 :     Bfree(delta);

  00be2	48 8b cf	 mov	 rcx, rdi
  00be5	e8 00 00 00 00	 call	 Bfree

; 2266 :     if (bc.nd > nd) {

  00bea	44 39 6c 24 2c	 cmp	 DWORD PTR bc$[rsp+4], r13d
  00bef	7e 22		 jle	 SHORT $LN2@Py_dg_strt

; 2267 :         error = bigcomp(&rv, s0, &bc);

  00bf1	48 8b 54 24 70	 mov	 rdx, QWORD PTR s0$1$[rsp]
  00bf6	4c 8d 44 24 28	 lea	 r8, QWORD PTR bc$[rsp]
  00bfb	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  00c00	e8 00 00 00 00	 call	 bigcomp

; 2268 :         if (error)

  00c05	85 c0		 test	 eax, eax
  00c07	0f 85 a4 03 00
	00		 jne	 $failed_malloc$20936

; 2286 :     return -1.0;

  00c0d	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
$LN2@Py_dg_strt:

; 2269 :             goto failed_malloc;
; 2270 :     }
; 2271 : 
; 2272 :     if (bc.scale) {

  00c13	85 db		 test	 ebx, ebx
  00c15	0f 84 bb f7 ff
	ff		 je	 $ret$20871

; 2273 :         word0(&rv0) = Exp_1 - 2*P*Exp_msk1;

  00c1b	c7 44 24 54 00
	00 50 39	 mov	 DWORD PTR rv0$[rsp+4], 961544192 ; 39500000H

; 2274 :         word1(&rv0) = 0;

  00c23	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rv0$[rsp], 0

; 2275 :         dval(&rv) *= dval(&rv0);

  00c2b	f2 0f 59 74 24
	50		 mulsd	 xmm6, QWORD PTR rv0$[rsp]
  00c31	e9 a0 f7 ff ff	 jmp	 $ret$20871
$LN8@Py_dg_strt:

; 2248 :                         if (aadj < .4999999 || aadj > .5000001)

  00c36	66 44 0f 2f da	 comisd	 xmm11, xmm2
  00c3b	0f 87 79 ff ff
	ff		 ja	 $LN276@Py_dg_strt
  00c41	66 41 0f 2f d1	 comisd	 xmm2, xmm9
  00c46	0f 87 6e ff ff
	ff		 ja	 $LN276@Py_dg_strt
  00c4c	eb 05		 jmp	 SHORT $cont$21017
$LN254@Py_dg_strt:

; 2219 :                 goto cont;

  00c4e	44 8b 7c 24 20	 mov	 r15d, DWORD PTR rv$[rsp]
$cont$21017:

; 2252 :                         break;
; 2253 :                 }
; 2254 :         }
; 2255 :       cont:
; 2256 :         Bfree(bb);

  00c53	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00c58	e8 00 00 00 00	 call	 Bfree

; 2257 :         Bfree(bd);

  00c5d	49 8b ce	 mov	 rcx, r14
  00c60	e8 00 00 00 00	 call	 Bfree

; 2258 :         Bfree(bs);

  00c65	49 8b cc	 mov	 rcx, r12
  00c68	e8 00 00 00 00	 call	 Bfree

; 2259 :         Bfree(delta);

  00c6d	48 8b cf	 mov	 rcx, rdi
  00c70	e8 00 00 00 00	 call	 Bfree
  00c75	4c 8b 6c 24 40	 mov	 r13, QWORD PTR bd0$1$[rsp]
  00c7a	41 8b 4d 08	 mov	 ecx, DWORD PTR [r13+8]
  00c7e	e8 00 00 00 00	 call	 Balloc
  00c83	48 8b f8	 mov	 rdi, rax
  00c86	48 89 44 24 48	 mov	 QWORD PTR bd$1$[rsp], rax
  00c8b	48 85 c0	 test	 rax, rax
  00c8e	0f 84 15 03 00
	00		 je	 $LN216@Py_dg_strt

; 1919 :         if (bd == NULL) {

  00c94	44 8b 65 78	 mov	 r12d, DWORD PTR e$1$[rbp-256]
  00c98	8b 5c 24 34	 mov	 ebx, DWORD PTR bc$[rsp+12]
  00c9c	e9 15 fb ff ff	 jmp	 $LN294@Py_dg_strt
$LN220@Py_dg_strt:

; 1999 :                 Bfree(bs);

  00ca1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bs$1$[rsp]
$LN298@Py_dg_strt:
  00ca6	e8 00 00 00 00	 call	 Bfree

; 2000 :                 Bfree(bd);

  00cab	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bd$1$[rsp]
  00cb0	e8 00 00 00 00	 call	 Bfree

; 2001 :                 Bfree(bd0);

  00cb5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]

; 2002 :                 goto failed_malloc;

  00cba	e9 ed 02 00 00	 jmp	 $LN295@Py_dg_strt
$LN219@Py_dg_strt:

; 1990 :                 Bfree(bb);

  00cbf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]

; 1991 :                 Bfree(bd);
; 1992 :                 Bfree(bd0);
; 1993 :                 goto failed_malloc;

  00cc4	eb e0		 jmp	 SHORT $LN298@Py_dg_strt
$LN221@Py_dg_strt:

; 2008 :                 Bfree(bs);

  00cc6	48 8b cb	 mov	 rcx, rbx

; 2009 :                 Bfree(bd);
; 2010 :                 Bfree(bd0);
; 2011 :                 goto failed_malloc;

  00cc9	eb db		 jmp	 SHORT $LN298@Py_dg_strt
$LN224@Py_dg_strt:

; 2035 :                 Bfree(bb);

  00ccb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00cd0	e8 00 00 00 00	 call	 Bfree

; 2036 :                 Bfree(bd);

  00cd5	49 8b ce	 mov	 rcx, r14
  00cd8	e8 00 00 00 00	 call	 Bfree
  00cdd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00ce2	e9 c5 02 00 00	 jmp	 $LN295@Py_dg_strt
$LN248@Py_dg_strt:

; 2058 :             if (dsign)

  00ce7	85 db		 test	 ebx, ebx
  00ce9	0f 85 cb fe ff
	ff		 jne	 $LN276@Py_dg_strt

; 2059 :                 break;  /* Must use bigcomp(). */
; 2060 : 
; 2061 :             /* Here rv overestimates the truncated decimal value by at most
; 2062 :                0.5 ulp(rv).  Hence rv either overestimates the true decimal
; 2063 :                value by <= 0.5 ulp(rv), or underestimates it by some small
; 2064 :                amount (< 0.1 ulp(rv)); either way, rv is within 0.5 ulps of
; 2065 :                the true decimal value, so it's possible to exit.
; 2066 : 
; 2067 :                Exception: if scaled rv is a normal exact power of 2, but not
; 2068 :                DBL_MIN, then rv - 0.5 ulp(rv) takes us all the way down to the
; 2069 :                next double, so the correctly rounded result is either rv - 0.5
; 2070 :                ulp(rv) or rv; in this case, use bigcomp to distinguish. */
; 2071 : 
; 2072 :             if (!word1(&rv) && !(word0(&rv) & Bndry_mask)) {

  00cef	45 85 ff	 test	 r15d, r15d
  00cf2	75 40		 jne	 SHORT $LN53@Py_dg_strt
  00cf4	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00cfa	75 38		 jne	 SHORT $LN53@Py_dg_strt

; 2073 :                 /* rv can't be 0, since it's an overestimate for some
; 2074 :                    nonzero value.  So rv is a normal power of 2. */
; 2075 :                 j = (int)(word0(&rv) & Exp_mask) >> Exp_shift;
; 2076 :                 /* rv / 2^bc.scale = 2^(j - 1023 - bc.scale); use bigcomp if
; 2077 :                    rv / 2^bc.scale >= 2^-1021. */
; 2078 :                 if (j - bc.scale >= 2) {

  00cfc	8b 5c 24 34	 mov	 ebx, DWORD PTR bc$[rsp+12]
  00d00	8b c6		 mov	 eax, esi
  00d02	c1 f8 14	 sar	 eax, 20
  00d05	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00d0a	2b c3		 sub	 eax, ebx
  00d0c	83 f8 02	 cmp	 eax, 2
  00d0f	7c 23		 jl	 SHORT $LN53@Py_dg_strt

; 2079 :                     dval(&rv) -= 0.5 * sulp(&rv, &bc);

  00d11	48 8d 54 24 28	 lea	 rdx, QWORD PTR bc$[rsp]
  00d16	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  00d1b	e8 00 00 00 00	 call	 sulp
  00d20	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8
  00d25	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00d29	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6

; 2080 :                     break; /* Use bigcomp. */

  00d2f	e9 8a fe ff ff	 jmp	 $LN232@Py_dg_strt
$LN53@Py_dg_strt:

; 2081 :                 }
; 2082 :             }
; 2083 : 
; 2084 :             {
; 2085 :                 bc.nd = nd;

  00d34	44 89 6c 24 2c	 mov	 DWORD PTR bc$[rsp+4], r13d

; 2086 :                 i = -1; /* Discarded digits make delta smaller. */
; 2087 :             }
; 2088 :         }
; 2089 : 
; 2090 :         if (i < 0) {

  00d39	e9 44 01 00 00	 jmp	 $LN247@Py_dg_strt
$LN230@Py_dg_strt:

; 2174 :                     if (bc.nd >nd)

  00d3e	44 39 6c 24 2c	 cmp	 DWORD PTR bc$[rsp+4], r13d
  00d43	0f 8f 71 fe ff
	ff		 jg	 $LN276@Py_dg_strt
  00d49	e9 ec 01 00 00	 jmp	 $LN296@Py_dg_strt
$LN231@Py_dg_strt:

; 2210 :                     Bfree(bb);

  00d4e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00d53	e8 00 00 00 00	 call	 Bfree

; 2211 :                     Bfree(bd);

  00d58	49 8b ce	 mov	 rcx, r14
  00d5b	e8 00 00 00 00	 call	 Bfree

; 2212 :                     Bfree(bs);

  00d60	49 8b cc	 mov	 rcx, r12
  00d63	e8 00 00 00 00	 call	 Bfree

; 2213 :                     Bfree(bd0);

  00d68	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00d6d	e8 00 00 00 00	 call	 Bfree

; 2214 :                     Bfree(delta);

  00d72	48 8b cf	 mov	 rcx, rdi
  00d75	e8 00 00 00 00	 call	 Bfree
$ovfl$20896:

; 2290 : 
; 2291 :   ovfl:
; 2292 :     errno = ERANGE;

  00d7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 2293 :     /* Can't trust HUGE_VAL */
; 2294 :     word0(&rv) = Exp_mask;
; 2295 :     word1(&rv) = 0;
; 2296 :     return sign ? -dval(&rv) : dval(&rv);

  00d80	83 7d 70 00	 cmp	 DWORD PTR sign$1$[rbp-256], 0
  00d84	c7 44 24 24 00
	00 f0 7f	 mov	 DWORD PTR rv$[rsp+4], 2146435072 ; 7ff00000H
  00d8c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rv$[rsp], 0
  00d94	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  00d9a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00da0	0f 84 3f f6 ff
	ff		 je	 $LN289@Py_dg_strt
  00da6	66 41 0f 57 c7	 xorpd	 xmm0, xmm15
  00dab	e9 35 f6 ff ff	 jmp	 $LN289@Py_dg_strt
$LN229@Py_dg_strt:

; 2116 :             /* exactly half-way between */
; 2117 :             if (dsign) {

  00db0	85 db		 test	 ebx, ebx
  00db2	74 5c		 je	 SHORT $LN45@Py_dg_strt

; 2118 :                 if ((word0(&rv) & Bndry_mask1) == Bndry_mask1
; 2119 :                     &&  word1(&rv) == (
; 2120 :                         (bc.scale &&
; 2121 :                          (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1) ?
; 2122 :                         (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
; 2123 :                         0xffffffff)) {

  00db4	8b c6		 mov	 eax, esi
  00db6	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  00dbb	3d ff ff 0f 00	 cmp	 eax, 1048575		; 000fffffH
  00dc0	75 5f		 jne	 SHORT $LN42@Py_dg_strt
  00dc2	44 39 54 24 34	 cmp	 DWORD PTR bc$[rsp+12], r10d
  00dc7	74 1f		 je	 SHORT $LN188@Py_dg_strt
  00dc9	8b c6		 mov	 eax, esi
  00dcb	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00dd0	3d 00 00 a0 06	 cmp	 eax, 111149056		; 06a00000H
  00dd5	77 11		 ja	 SHORT $LN188@Py_dg_strt
  00dd7	c1 e8 14	 shr	 eax, 20
  00dda	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00ddf	2b c8		 sub	 ecx, eax
  00de1	83 c8 ff	 or	 eax, -1			; ffffffffH
  00de4	d3 e0		 shl	 eax, cl
  00de6	eb 03		 jmp	 SHORT $LN189@Py_dg_strt
$LN188@Py_dg_strt:
  00de8	83 c8 ff	 or	 eax, -1			; ffffffffH
$LN189@Py_dg_strt:
  00deb	44 3b f8	 cmp	 r15d, eax
  00dee	75 31		 jne	 SHORT $LN42@Py_dg_strt

; 2124 :                     /*boundary case -- increment exponent*/
; 2125 :                     word0(&rv) = (word0(&rv) & Exp_mask)
; 2126 :                         + Exp_msk1
; 2127 :                         ;

  00df0	81 e6 00 00 f0
	7f		 and	 esi, 2146435072		; 7ff00000H

; 2128 :                     word1(&rv) = 0;

  00df6	44 89 54 24 20	 mov	 DWORD PTR rv$[rsp], r10d
  00dfb	81 c6 00 00 10
	00		 add	 esi, 1048576		; 00100000H
  00e01	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 2129 :                     /* dsign = 0; */
; 2130 :                     break;

  00e05	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00e0b	e9 aa fd ff ff	 jmp	 $LN276@Py_dg_strt
$LN45@Py_dg_strt:

; 2131 :                 }
; 2132 :             }
; 2133 :             else if (!(word0(&rv) & Bndry_mask) && !word1(&rv)) {

  00e10	f7 c6 ff ff 0f
	00		 test	 esi, 1048575		; 000fffffH
  00e16	75 09		 jne	 SHORT $LN42@Py_dg_strt
  00e18	45 85 ff	 test	 r15d, r15d
  00e1b	0f 84 ef 00 00
	00		 je	 $drop_down$20987
$LN42@Py_dg_strt:

; 2153 :             }
; 2154 :             if (!odd)

  00e21	44 39 54 24 68	 cmp	 DWORD PTR odd$1$[rsp], r10d
  00e26	0f 84 8e fd ff
	ff		 je	 $LN276@Py_dg_strt

; 2155 :                 break;
; 2156 :             if (dsign)
; 2157 :                 dval(&rv) += sulp(&rv, &bc);

  00e2c	48 8d 54 24 28	 lea	 rdx, QWORD PTR bc$[rsp]
  00e31	48 8d 4c 24 20	 lea	 rcx, QWORD PTR rv$[rsp]
  00e36	e8 00 00 00 00	 call	 sulp
  00e3b	85 db		 test	 ebx, ebx
  00e3d	74 0f		 je	 SHORT $LN36@Py_dg_strt
  00e3f	f2 0f 58 f0	 addsd	 xmm6, xmm0
  00e43	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6

; 2158 :             else {

  00e49	e9 6c fd ff ff	 jmp	 $LN276@Py_dg_strt
$LN36@Py_dg_strt:

; 2159 :                 dval(&rv) -= sulp(&rv, &bc);
; 2160 :                 if (!dval(&rv)) {

  00e4e	66 0f 57 c9	 xorpd	 xmm1, xmm1
  00e52	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00e56	66 0f 2e f1	 ucomisd xmm6, xmm1
  00e5a	f2 0f 11 74 24
	20		 movsdx	 QWORD PTR rv$[rsp], xmm6
  00e60	0f 8a 54 fd ff
	ff		 jp	 $LN276@Py_dg_strt
  00e66	0f 85 4e fd ff
	ff		 jne	 $LN276@Py_dg_strt

; 2161 :                     if (bc.nd >nd)

  00e6c	45 3b c5	 cmp	 r8d, r13d
  00e6f	0f 8f 45 fd ff
	ff		 jg	 $LN276@Py_dg_strt

; 2162 :                         break;
; 2163 :                     goto undfl;

  00e75	e9 c4 00 00 00	 jmp	 $undfl$20909
$LN228@Py_dg_strt:

; 2091 :             /* Error is less than half an ulp -- check for
; 2092 :              * special case of mantissa a power of two.
; 2093 :              */
; 2094 :             if (dsign || word1(&rv) || word0(&rv) & Bndry_mask
; 2095 :                 || (word0(&rv) & Exp_mask) <= (2*P+1)*Exp_msk1
; 2096 :                 ) {

  00e7a	85 db		 test	 ebx, ebx
  00e7c	0f 85 38 fd ff
	ff		 jne	 $LN276@Py_dg_strt
$LN247@Py_dg_strt:
  00e82	45 85 ff	 test	 r15d, r15d
  00e85	0f 85 2f fd ff
	ff		 jne	 $LN276@Py_dg_strt
  00e8b	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  00e90	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00e94	a9 ff ff 0f 00	 test	 eax, 1048575		; 000fffffH
  00e99	0f 85 1b fd ff
	ff		 jne	 $LN276@Py_dg_strt
  00e9f	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00ea4	3d 00 00 b0 06	 cmp	 eax, 112197632		; 06b00000H
  00ea9	0f 86 0b fd ff
	ff		 jbe	 $LN276@Py_dg_strt

; 2097 :                 break;
; 2098 :             }
; 2099 :             if (!delta->x[0] && delta->wds <= 1) {

  00eaf	44 39 57 18	 cmp	 DWORD PTR [rdi+24], r10d
  00eb3	75 0a		 jne	 SHORT $LN49@Py_dg_strt
  00eb5	83 7f 14 01	 cmp	 DWORD PTR [rdi+20], 1
  00eb9	0f 8e fb fc ff
	ff		 jle	 $LN276@Py_dg_strt
$LN49@Py_dg_strt:

; 2100 :                 /* exact result */
; 2101 :                 break;
; 2102 :             }
; 2103 :             delta = lshift(delta,Log2P);

  00ebf	ba 01 00 00 00	 mov	 edx, 1
  00ec4	48 8b cf	 mov	 rcx, rdi
  00ec7	e8 00 00 00 00	 call	 lshift
  00ecc	48 8b f8	 mov	 rdi, rax

; 2104 :             if (delta == NULL) {

  00ecf	48 85 c0	 test	 rax, rax
  00ed2	75 24		 jne	 SHORT $LN48@Py_dg_strt

; 2105 :                 Bfree(bb);

  00ed4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$1$[rsp]
  00ed9	e8 00 00 00 00	 call	 Bfree

; 2106 :                 Bfree(bs);

  00ede	49 8b cc	 mov	 rcx, r12
  00ee1	e8 00 00 00 00	 call	 Bfree

; 2107 :                 Bfree(bd);

  00ee6	49 8b ce	 mov	 rcx, r14
  00ee9	e8 00 00 00 00	 call	 Bfree
  00eee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00ef3	e9 b4 00 00 00	 jmp	 $LN295@Py_dg_strt
$LN48@Py_dg_strt:

; 2108 :                 Bfree(bd0);
; 2109 :                 goto failed_malloc;
; 2110 :             }
; 2111 :             if (cmp(delta, bs) > 0)

  00ef8	49 8b d4	 mov	 rdx, r12
  00efb	48 8b c8	 mov	 rcx, rax
  00efe	e8 00 00 00 00	 call	 cmp
  00f03	85 c0		 test	 eax, eax
  00f05	0f 8e af fc ff
	ff		 jle	 $LN276@Py_dg_strt
  00f0b	44 8b 44 24 2c	 mov	 r8d, DWORD PTR bc$[rsp+4]
$drop_down$20987:

; 2134 :               drop_down:
; 2135 :                 /* boundary case -- decrement exponent */
; 2136 :                 if (bc.scale) {

  00f10	8b 5c 24 34	 mov	 ebx, DWORD PTR bc$[rsp+12]
  00f14	85 db		 test	 ebx, ebx
  00f16	74 3d		 je	 SHORT $LN40@Py_dg_strt

; 2137 :                     L = word0(&rv) & Exp_mask;

  00f18	8b c6		 mov	 eax, esi
  00f1a	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H

; 2138 :                     if (L <= (2*P+1)*Exp_msk1) {

  00f1f	3d 00 00 b0 06	 cmp	 eax, 112197632		; 06b00000H
  00f24	7f 2f		 jg	 SHORT $LN40@Py_dg_strt

; 2139 :                         if (L > (P+2)*Exp_msk1)

  00f26	3d 00 00 70 03	 cmp	 eax, 57671680		; 03700000H
  00f2b	0f 8f 8d fc ff
	ff		 jg	 $LN232@Py_dg_strt

; 2140 :                             /* round even ==> */
; 2141 :                             /* accept rv */
; 2142 :                             break;
; 2143 :                         /* rv = smallest denormal */
; 2144 :                         if (bc.nd > nd)

  00f31	45 3b c5	 cmp	 r8d, r13d
  00f34	0f 8f 84 fc ff
	ff		 jg	 $LN232@Py_dg_strt
$LN296@Py_dg_strt:
  00f3a	66 0f 57 c9	 xorpd	 xmm1, xmm1
$undfl$20909:

; 2287 : 
; 2288 :   undfl:
; 2289 :     return sign ? -0.0 : 0.0;

  00f3e	83 7d 70 00	 cmp	 DWORD PTR sign$1$[rbp-256], 0
  00f42	74 08		 je	 SHORT $LN196@Py_dg_strt
  00f44	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@8000000000000000
$LN196@Py_dg_strt:
  00f4c	66 0f 28 c1	 movapd	 xmm0, xmm1
  00f50	e9 90 f4 ff ff	 jmp	 $LN289@Py_dg_strt
$LN40@Py_dg_strt:

; 2145 :                             break;
; 2146 :                         goto undfl;
; 2147 :                     }
; 2148 :                 }
; 2149 :                 L = (word0(&rv) & Exp_mask) - Exp_msk1;

  00f55	81 e6 00 00 f0
	7f		 and	 esi, 2146435072		; 7ff00000H

; 2150 :                 word0(&rv) = L | Bndry_mask1;
; 2151 :                 word1(&rv) = 0xffffffff;

  00f5b	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR rv$[rsp], -1	; ffffffffH
  00f63	ff ce		 dec	 esi
  00f65	81 ce ff ff 0f
	00		 or	 esi, 1048575		; 000fffffH
  00f6b	89 74 24 24	 mov	 DWORD PTR rv$[rsp+4], esi

; 2152 :                 break;

  00f6f	f2 0f 10 74 24
	20		 movsdx	 xmm6, QWORD PTR rv$[rsp]
  00f75	e9 44 fc ff ff	 jmp	 $LN232@Py_dg_strt
$LN225@Py_dg_strt:

; 2048 :             Bfree(bb);

  00f7a	49 8b cc	 mov	 rcx, r12
  00f7d	e8 00 00 00 00	 call	 Bfree

; 2049 :             Bfree(bs);

  00f82	48 8b cb	 mov	 rcx, rbx
  00f85	e8 00 00 00 00	 call	 Bfree

; 2050 :             Bfree(bd);

  00f8a	49 8b ce	 mov	 rcx, r14
  00f8d	e8 00 00 00 00	 call	 Bfree
  00f92	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bd0$1$[rsp]
  00f97	eb 13		 jmp	 SHORT $LN295@Py_dg_strt
$LN218@Py_dg_strt:

; 1937 :             Bfree(bb);

  00f99	49 8b ce	 mov	 rcx, r14
  00f9c	e8 00 00 00 00	 call	 Bfree
$LN217@Py_dg_strt:

; 1926 :             Bfree(bd);

  00fa1	48 8b cf	 mov	 rcx, rdi
  00fa4	e8 00 00 00 00	 call	 Bfree
$LN216@Py_dg_strt:

; 1920 :             Bfree(bd0);

  00fa9	49 8b cd	 mov	 rcx, r13
$LN295@Py_dg_strt:
  00fac	e8 00 00 00 00	 call	 Bfree
$failed_malloc$20936:

; 2283 : 
; 2284 :   failed_malloc:
; 2285 :     errno = ENOMEM;

  00fb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 2286 :     return -1.0;

  00fb7	66 41 0f 28 c6	 movapd	 xmm0, xmm14
  00fbc	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12
  00fc2	e9 1e f4 ff ff	 jmp	 $LN289@Py_dg_strt
_Py_dg_strtod ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rv_alloc DD imagerel rv_alloc
	DD	imagerel rv_alloc+78
	DD	imagerel $unwind$rv_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rv_alloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT rv_alloc
_TEXT	SEGMENT
i$ = 48
rv_alloc PROC						; COMDAT

; 2302 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2303 :     int j, k, *r;
; 2304 : 
; 2305 :     j = sizeof(ULong);
; 2306 :     for(k = 0;
; 2307 :         sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= (unsigned)i;
; 2308 :         j <<= 1)

  00006	44 8b c1	 mov	 r8d, ecx
  00009	33 db		 xor	 ebx, ebx
  0000b	ba 04 00 00 00	 mov	 edx, 4
  00010	49 83 f8 1c	 cmp	 r8, 28
  00014	72 1a		 jb	 SHORT $LN2@rv_alloc
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@rv_alloc:
  00020	03 d2		 add	 edx, edx

; 2309 :         k++;

  00022	ff c3		 inc	 ebx
  00024	48 63 c2	 movsxd	 rax, edx
  00027	48 83 c0 18	 add	 rax, 24
  0002b	49 3b c0	 cmp	 rax, r8
  0002e	76 f0		 jbe	 SHORT $LL4@rv_alloc
$LN2@rv_alloc:

; 2310 :     r = (int*)Balloc(k);

  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 Balloc

; 2311 :     if (r == NULL)

  00037	48 85 c0	 test	 rax, rax
  0003a	75 06		 jne	 SHORT $LN1@rv_alloc

; 2315 : }

  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5b		 pop	 rbx
  00041	c3		 ret	 0
$LN1@rv_alloc:

; 2312 :         return NULL;
; 2313 :     *r = k;

  00042	89 18		 mov	 DWORD PTR [rax], ebx

; 2314 :     return (char *)(r+1);

  00044	48 83 c0 04	 add	 rax, 4

; 2315 : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
rv_alloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nrv_alloc DD imagerel nrv_alloc
	DD	imagerel nrv_alloc+100
	DD	imagerel $unwind$nrv_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nrv_alloc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT nrv_alloc
_TEXT	SEGMENT
s$ = 48
rve$ = 56
n$ = 64
nrv_alloc PROC						; COMDAT

; 2319 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2320 :     char *rv, *t;
; 2321 : 
; 2322 :     rv = rv_alloc(n);

  0000d	41 8b c8	 mov	 ecx, r8d
  00010	48 8b fa	 mov	 rdi, rdx
  00013	e8 00 00 00 00	 call	 rv_alloc
  00018	4c 8b d8	 mov	 r11, rax

; 2323 :     if (rv == NULL)

  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0b		 jne	 SHORT $LN4@nrv_alloc

; 2330 : }

  00020	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
$LN4@nrv_alloc:

; 2324 :         return NULL;
; 2325 :     t = rv;

  0002b	48 8b c8	 mov	 rcx, rax

; 2326 :     while((*t = *s++)) t++;

  0002e	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00031	41 88 03	 mov	 BYTE PTR [r11], al
  00034	84 c0		 test	 al, al
  00036	74 16		 je	 SHORT $LN8@nrv_alloc
  00038	49 2b db	 sub	 rbx, r11
  0003b	0f 1f 44 00 00	 npad	 5
$LL3@nrv_alloc:
  00040	0f b6 44 0b 01	 movzx	 eax, BYTE PTR [rbx+rcx+1]
  00045	48 ff c1	 inc	 rcx
  00048	88 01		 mov	 BYTE PTR [rcx], al
  0004a	84 c0		 test	 al, al
  0004c	75 f2		 jne	 SHORT $LL3@nrv_alloc
$LN8@nrv_alloc:

; 2327 :     if (rve)

  0004e	48 85 ff	 test	 rdi, rdi
  00051	74 03		 je	 SHORT $LN1@nrv_alloc

; 2328 :         *rve = t;

  00053	48 89 0f	 mov	 QWORD PTR [rdi], rcx
$LN1@nrv_alloc:

; 2329 :     return rv;

  00056	49 8b c3	 mov	 rax, r11

; 2330 : }

  00059	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
nrv_alloc ENDP
_TEXT	ENDS
PUBLIC	_Py_dg_freedtoa
; Function compile flags: /Ogtpy
;	COMDAT _Py_dg_freedtoa
_TEXT	SEGMENT
s$ = 8
_Py_dg_freedtoa PROC					; COMDAT

; 2341 :     Bigint *b = (Bigint *)((int *)s - 1);

  00000	48 8d 51 fc	 lea	 rdx, QWORD PTR [rcx-4]

; 2342 :     b->maxwds = 1 << (b->k = *(int*)b);

  00004	b8 01 00 00 00	 mov	 eax, 1
  00009	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  0000b	d3 e0		 shl	 eax, cl
  0000d	89 4a 08	 mov	 DWORD PTR [rdx+8], ecx

; 2343 :     Bfree(b);

  00010	48 8b ca	 mov	 rcx, rdx
  00013	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 2344 : }

  00016	e9 00 00 00 00	 jmp	 Bfree
_Py_dg_freedtoa ENDP
_TEXT	ENDS
PUBLIC	__real@401c000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fc68a288b60c8b3
PUBLIC	__real@3fd34413509f79fb
PUBLIC	__real@3fd287a7636f4361
PUBLIC	__real@3ff8000000000000
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	??_C@_08KEBCLIFP@Infinity?$AA@			; `string'
PUBLIC	_Py_dg_dtoa
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_dtoa DD imagerel $LN273
	DD	imagerel $LN273+202
	DD	imagerel $unwind$_Py_dg_dtoa
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Py_dg_dtoa DD imagerel $LN273+202
	DD	imagerel $LN273+250
	DD	imagerel $chain$0$_Py_dg_dtoa
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_Py_dg_dtoa DD imagerel $LN273+250
	DD	imagerel $LN273+3191
	DD	imagerel $chain$5$_Py_dg_dtoa
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_Py_dg_dtoa DD imagerel $LN273+3191
	DD	imagerel $LN273+3209
	DD	imagerel $chain$6$_Py_dg_dtoa
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$_Py_dg_dtoa DD imagerel $LN273+3209
	DD	imagerel $LN273+3628
	DD	imagerel $chain$8$_Py_dg_dtoa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$_Py_dg_dtoa DD 0c0021H
	DD	077800H
	DD	086800H
	DD	013f400H
	DD	014e400H
	DD	015d400H
	DD	0166400H
	DD	imagerel $LN273
	DD	imagerel $LN273+202
	DD	imagerel $unwind$_Py_dg_dtoa
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_Py_dg_dtoa DD 021H
	DD	imagerel $LN273+202
	DD	imagerel $LN273+250
	DD	imagerel $chain$0$_Py_dg_dtoa
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_Py_dg_dtoa DD 0a3721H
	DD	086837H
	DD	013f42fH
	DD	014e418H
	DD	015d410H
	DD	0166408H
	DD	imagerel $LN273+202
	DD	imagerel $LN273+250
	DD	imagerel $chain$0$_Py_dg_dtoa
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Py_dg_dtoa DD 020521H
	DD	077805H
	DD	imagerel $LN273
	DD	imagerel $LN273+202
	DD	imagerel $unwind$_Py_dg_dtoa
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_dtoa DD 061a01H
	DD	017011aH
	DD	07011c013H
	DD	0300f5010H
xdata	ENDS
;	COMDAT __real@401c000000000000
CONST	SEGMENT
__real@401c000000000000 DQ 0401c000000000000r	; 7
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fc68a288b60c8b3
CONST	SEGMENT
__real@3fc68a288b60c8b3 DQ 03fc68a288b60c8b3r	; 0.176091
CONST	ENDS
;	COMDAT __real@3fd34413509f79fb
CONST	SEGMENT
__real@3fd34413509f79fb DQ 03fd34413509f79fbr	; 0.30103
CONST	ENDS
;	COMDAT __real@3fd287a7636f4361
CONST	SEGMENT
__real@3fd287a7636f4361 DQ 03fd287a7636f4361r	; 0.28953
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity?$AA@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity?$AA@ DB 'Infinity', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_dg_dtoa
_TEXT	SEGMENT
k$1$ = 32
b2$1$ = 36
s0$1$ = 40
leftright$1$ = 48
u$ = 56
ilim$1$ = 64
eps$ = 64
ilim1$1$ = 72
$T22437 = 80
spec_case$1$ = 80
s5$1$ = 80
k_check$1$ = 88
bbits$ = 92
be$ = 96
b5$1$ = 100
denorm$1$ = 104
s2$1$ = 224
i$9$ = 224
d2$ = 224
dd$ = 224
mode$ = 232
ndigits$ = 240
decpt$ = 248
sign$ = 256
rve$ = 264
_Py_dg_dtoa PROC					; COMDAT

; 2387 : {

$LN273:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	53		 push	 rbx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2388 :     /*  Arguments ndigits, decpt, sign are similar to those
; 2389 :         of ecvt and fcvt; trailing zeros are suppressed from
; 2390 :         the returned string.  If not null, *rve is set to point
; 2391 :         to the end of the return value.  If d is +-Infinity or NaN,
; 2392 :         then *decpt is set to 9999.
; 2393 : 
; 2394 :         mode:
; 2395 :         0 ==> shortest string that yields d when read in
; 2396 :         and rounded to nearest.
; 2397 :         1 ==> like 0, but with Steele & White stopping rule;
; 2398 :         e.g. with IEEE P754 arithmetic , mode 0 gives
; 2399 :         1e23 whereas mode 1 gives 9.999999999999999e22.
; 2400 :         2 ==> max(1,ndigits) significant digits.  This gives a
; 2401 :         return value similar to that of ecvt, except
; 2402 :         that trailing zeros are suppressed.
; 2403 :         3 ==> through ndigits past the decimal point.  This
; 2404 :         gives a return value similar to that from fcvt,
; 2405 :         except that trailing zeros are suppressed, and
; 2406 :         ndigits can be negative.
; 2407 :         4,5 ==> similar to 2 and 3, respectively, but (in
; 2408 :         round-nearest mode) with the tests of mode 0 to
; 2409 :         possibly return a shorter string that rounds to d.
; 2410 :         With IEEE arithmetic and compilation with
; 2411 :         -DHonor_FLT_ROUNDS, modes 4 and 5 behave the same
; 2412 :         as modes 2 and 3 when FLT_ROUNDS != 1.
; 2413 :         6-9 ==> Debugging modes similar to mode - 4:  don't try
; 2414 :         fast floating-point estimate (if applicable).
; 2415 : 
; 2416 :         Values of mode other than 0-9 are treated as mode 0.
; 2417 : 
; 2418 :         Sufficient space is allocated to the return value
; 2419 :         to hold the suppressed trailing zeros.
; 2420 :     */
; 2421 : 
; 2422 :     int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,
; 2423 :         j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
; 2424 :         spec_case, try_quick;
; 2425 :     Long L;
; 2426 :     int denorm;
; 2427 :     ULong x;
; 2428 :     Bigint *b, *b1, *delta, *mlo, *mhi, *S;
; 2429 :     U d2, eps, u;
; 2430 :     double ds;
; 2431 :     char *s, *s0;
; 2432 : 
; 2433 :     /* set pointers to NULL, to silence gcc compiler warnings and make
; 2434 :        cleanup easier on error */
; 2435 :     mlo = mhi = S = 0;
; 2436 :     s0 = 0;
; 2437 : 
; 2438 :     u.d = dd;
; 2439 :     if (word0(&u) & Sign_bit) {
; 2440 :         /* set sign for everything, including 0's and NaNs */
; 2441 :         *sign = 1;

  0001a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  00022	45 33 e4	 xor	 r12d, r12d
  00025	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR u$[rsp], xmm0
  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR u$[rsp]
  00030	8b fa		 mov	 edi, edx
  00032	41 8b ec	 mov	 ebp, r12d
  00035	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00039	41 8d 5c 24 01	 lea	 ebx, QWORD PTR [r12+1]
  0003e	85 c9		 test	 ecx, ecx
  00040	79 12		 jns	 SHORT $LN163@Py_dg_dtoa

; 2442 :         word0(&u) &= ~Sign_bit; /* clear sign bit */

  00042	0f ba f1 1f	 btr	 ecx, 31
  00046	89 18		 mov	 DWORD PTR [rax], ebx
  00048	89 4c 24 3c	 mov	 DWORD PTR u$[rsp+4], ecx

; 2443 :     }
; 2444 :     else

  0004c	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00052	eb 07		 jmp	 SHORT $LN162@Py_dg_dtoa
$LN163@Py_dg_dtoa:

; 2445 :         *sign = 0;

  00054	8b 4c 24 3c	 mov	 ecx, DWORD PTR u$[rsp+4]
  00058	44 89 20	 mov	 DWORD PTR [rax], r12d
$LN162@Py_dg_dtoa:

; 2446 : 
; 2447 :     /* quick return for Infinities, NaNs and zeros */
; 2448 :     if ((word0(&u) & Exp_mask) == Exp_mask)

  0005b	8b c1		 mov	 eax, ecx
  0005d	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00062	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  00067	75 61		 jne	 SHORT $LN161@Py_dg_dtoa

; 2449 :     {
; 2450 :         /* Infinity or NaN */
; 2451 :         *decpt = 9999;

  00069	41 c7 01 0f 27
	00 00		 mov	 DWORD PTR [r9], 9999	; 0000270fH

; 2452 :         if (!word1(&u) && !(word0(&u) & 0xfffff))

  00070	39 6c 24 38	 cmp	 DWORD PTR u$[rsp], ebp
  00074	75 2e		 jne	 SHORT $LN160@Py_dg_dtoa
  00076	f7 c1 ff ff 0f
	00		 test	 ecx, 1048575		; 000fffffH
  0007c	75 26		 jne	 SHORT $LN160@Py_dg_dtoa

; 2453 :             return nrv_alloc("Infinity", rve, 8);

  0007e	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity?$AA@
  0008d	41 b8 08 00 00
	00		 mov	 r8d, 8

; 2984 : }

  00093	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0009a	41 5c		 pop	 r12
  0009c	5f		 pop	 rdi
  0009d	5d		 pop	 rbp
  0009e	5b		 pop	 rbx
  0009f	e9 00 00 00 00	 jmp	 nrv_alloc
$LN160@Py_dg_dtoa:

; 2454 :         return nrv_alloc("NaN", rve, 3);

  000a4	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03ICJPMMHB@NaN?$AA@
  000b3	41 b8 03 00 00
	00		 mov	 r8d, 3

; 2984 : }

  000b9	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  000c0	41 5c		 pop	 r12
  000c2	5f		 pop	 rdi
  000c3	5d		 pop	 rbp
  000c4	5b		 pop	 rbx
  000c5	e9 00 00 00 00	 jmp	 nrv_alloc
$LN161@Py_dg_dtoa:
  000ca	0f 29 7c 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm7

; 2455 :     }
; 2456 :     if (!dval(&u)) {

  000cf	66 0f 57 ff	 xorpd	 xmm7, xmm7
  000d3	66 0f 2e c7	 ucomisd xmm0, xmm7
  000d7	7a 21		 jp	 SHORT $LN159@Py_dg_dtoa
  000d9	75 1f		 jne	 SHORT $LN159@Py_dg_dtoa

; 2457 :         *decpt = 1;
; 2458 :         return nrv_alloc("0", rve, 1);

  000db	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  000ea	44 8b c3	 mov	 r8d, ebx
  000ed	41 89 19	 mov	 DWORD PTR [r9], ebx
  000f0	e8 00 00 00 00	 call	 nrv_alloc
  000f5	e9 7d 0b 00 00	 jmp	 $LN258@Py_dg_dtoa
$LN159@Py_dg_dtoa:
  000fa	48 89 b4 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rsi
  00102	4c 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], r13
  0010a	4c 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r14

; 2459 :     }
; 2460 : 
; 2461 :     /* compute k = floor(log10(d)).  The computation may leave k
; 2462 :        one too large, but should never leave k too small. */
; 2463 :     b = d2b(&u, &be, &bbits);

  00112	4c 8d 44 24 5c	 lea	 r8, QWORD PTR bbits$[rsp]
  00117	48 8d 54 24 60	 lea	 rdx, QWORD PTR be$[rsp]
  0011c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR u$[rsp]
  00121	4c 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], r15
  00129	0f 29 b4 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm6
  00131	e8 00 00 00 00	 call	 d2b
  00136	48 8b f0	 mov	 rsi, rax

; 2464 :     if (b == NULL)

  00139	48 85 c0	 test	 rax, rax
  0013c	0f 84 0b 0b 00
	00		 je	 $LN1@Py_dg_dtoa

; 2465 :         goto failed_malloc;
; 2466 :     if ((i = (int)(word0(&u) >> Exp_shift1 & (Exp_mask>>Exp_shift1)))) {

  00142	44 8b 44 24 3c	 mov	 r8d, DWORD PTR u$[rsp+4]
  00147	f2 0f 10 74 24
	38		 movsdx	 xmm6, QWORD PTR u$[rsp]

; 2495 :     }
; 2496 :     else {

  0014d	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR bbits$[rsp]
  00152	41 8b d0	 mov	 edx, r8d
  00155	c1 ea 14	 shr	 edx, 20
  00158	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0015e	74 2c		 je	 SHORT $LN157@Py_dg_dtoa

; 2467 :         dval(&d2) = dval(&u);
; 2468 :         word0(&d2) &= Frac_mask1;
; 2469 :         word0(&d2) |= Exp_11;
; 2470 : 
; 2471 :         /* log(x)       ~=~ log(1.5) + (x-1.5)/1.5
; 2472 :          * log10(x)      =  log(x) / log(10)
; 2473 :          *              ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
; 2474 :          * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
; 2475 :          *
; 2476 :          * This suggests computing an approximation k to log10(d) by
; 2477 :          *
; 2478 :          * k = (i - Bias)*0.301029995663981
; 2479 :          *      + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
; 2480 :          *
; 2481 :          * We want k to be too large rather than too small.
; 2482 :          * The error in the first-order Taylor series approximation
; 2483 :          * is in our favor, so we just round up the constant enough
; 2484 :          * to compensate for any error in the multiplication of
; 2485 :          * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,
; 2486 :          * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
; 2487 :          * adding 1e-13 to the constant term more than suffices.
; 2488 :          * Hence we adjust the constant term to 0.1760912590558.
; 2489 :          * (We could get a more accurate k by invoking log10,
; 2490 :          *  but this is probably not worthwhile.)
; 2491 :          */
; 2492 : 
; 2493 :         i -= Bias;
; 2494 :         denorm = 0;

  00160	f2 0f 11 b4 24
	e0 00 00 00	 movsdx	 QWORD PTR d2$[rsp], xmm6
  00169	44 89 64 24 68	 mov	 DWORD PTR denorm$1$[rsp], r12d
  0016e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR d2$[rsp]
  00176	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0017a	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0017f	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  00184	81 ea ff 03 00
	00		 sub	 edx, 1023		; 000003ffH

; 2495 :     }
; 2496 :     else {

  0018a	eb 68		 jmp	 SHORT $LN264@Py_dg_dtoa
$LN157@Py_dg_dtoa:

; 2497 :         /* d is denormalized */
; 2498 : 
; 2499 :         i = bbits + be + (Bias + (P-1) - 1);

  0018c	8b 44 24 60	 mov	 eax, DWORD PTR be$[rsp]
  00190	42 8d 94 08 32
	04 00 00	 lea	 edx, DWORD PTR [rax+r9+1074]

; 2500 :         x = i > 32  ? word0(&u) << (64 - i) | word1(&u) >> (i - 32)
; 2501 :             : word1(&u) << (32 - i);

  00198	83 fa 20	 cmp	 edx, 32			; 00000020H
  0019b	7e 18		 jle	 SHORT $LN166@Py_dg_dtoa
  0019d	8b 44 24 38	 mov	 eax, DWORD PTR u$[rsp]
  001a1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001a6	2b ca		 sub	 ecx, edx
  001a8	41 d3 e0	 shl	 r8d, cl
  001ab	8d 4a e0	 lea	 ecx, DWORD PTR [rdx-32]
  001ae	d3 e8		 shr	 eax, cl
  001b0	44 0b c0	 or	 r8d, eax
  001b3	eb 0f		 jmp	 SHORT $LN167@Py_dg_dtoa
$LN166@Py_dg_dtoa:
  001b5	44 8b 44 24 38	 mov	 r8d, DWORD PTR u$[rsp]
  001ba	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001bf	2b ca		 sub	 ecx, edx
  001c1	41 d3 e0	 shl	 r8d, cl
$LN167@Py_dg_dtoa:

; 2502 :         dval(&d2) = x;

  001c4	41 8b c0	 mov	 eax, r8d
  001c7	66 0f ef c0	 pxor	 xmm0, xmm0

; 2503 :         word0(&d2) -= 31*Exp_msk1; /* adjust exponent */
; 2504 :         i -= (Bias + (P-1) - 1) + 1;
; 2505 :         denorm = 1;

  001cb	89 5c 24 68	 mov	 DWORD PTR denorm$1$[rsp], ebx
  001cf	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  001d4	f2 0f 11 84 24
	e0 00 00 00	 movsdx	 QWORD PTR d2$[rsp], xmm0
  001dd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR d2$[rsp]
  001e5	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  001e9	2d 00 00 f0 01	 sub	 eax, 32505856		; 01f00000H
  001ee	81 ea 33 04 00
	00		 sub	 edx, 1075		; 00000433H
$LN264@Py_dg_dtoa:

; 2506 :     }
; 2507 :     ds = (dval(&d2)-1.5)*0.289529654602168 + 0.1760912590558 +
; 2508 :         i*0.301029995663981;

  001f4	89 84 24 e4 00
	00 00		 mov	 DWORD PTR d2$[rsp+4], eax
  001fb	66 0f 6e c2	 movd	 xmm0, edx
  001ff	f2 0f 10 8c 24
	e0 00 00 00	 movsdx	 xmm1, QWORD PTR d2$[rsp]
  00208	f2 0f 5c 0d 00
	00 00 00	 subsd	 xmm1, QWORD PTR __real@3ff8000000000000
  00210	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00214	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd287a7636f4361
  0021c	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd34413509f79fb
  00224	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR __real@3fc68a288b60c8b3
  0022c	f2 0f 58 c8	 addsd	 xmm1, xmm0

; 2509 :     k = (int)ds;
; 2510 :     if (ds < 0. && ds != k)

  00230	66 0f 2f f9	 comisd	 xmm7, xmm1
  00234	f2 44 0f 2c f1	 cvttsd2si r14d, xmm1
  00239	44 89 74 24 20	 mov	 DWORD PTR k$1$[rsp], r14d
  0023e	76 19		 jbe	 SHORT $LN155@Py_dg_dtoa
  00240	66 41 0f 6e c6	 movd	 xmm0, r14d
  00245	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00249	66 0f 2e c8	 ucomisd xmm1, xmm0
  0024d	7a 02		 jp	 SHORT $LN217@Py_dg_dtoa
  0024f	74 08		 je	 SHORT $LN155@Py_dg_dtoa
$LN217@Py_dg_dtoa:

; 2511 :         k--;    /* want k = floor(ds) */

  00251	41 ff ce	 dec	 r14d
  00254	44 89 74 24 20	 mov	 DWORD PTR k$1$[rsp], r14d
$LN155@Py_dg_dtoa:

; 2512 :     k_check = 1;

  00259	89 5c 24 58	 mov	 DWORD PTR k_check$1$[rsp], ebx

; 2513 :     if (k >= 0 && k <= Ten_pmax) {

  0025d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00264	41 83 fe 16	 cmp	 r14d, 22
  00268	77 20		 ja	 SHORT $LN154@Py_dg_dtoa

; 2514 :         if (dval(&u) < tens[k])

  0026a	49 63 c6	 movsxd	 rax, r14d
  0026d	f2 41 0f 10 84
	c0 00 00 00 00	 movsdx	 xmm0, QWORD PTR tens[r8+rax*8]
  00277	66 0f 2f c6	 comisd	 xmm0, xmm6
  0027b	76 08		 jbe	 SHORT $LN153@Py_dg_dtoa

; 2515 :             k--;

  0027d	41 ff ce	 dec	 r14d
  00280	44 89 74 24 20	 mov	 DWORD PTR k$1$[rsp], r14d
$LN153@Py_dg_dtoa:

; 2516 :         k_check = 0;

  00285	44 89 64 24 58	 mov	 DWORD PTR k_check$1$[rsp], r12d
$LN154@Py_dg_dtoa:

; 2517 :     }
; 2518 :     j = bbits - i - 1;

  0028a	41 8b c1	 mov	 eax, r9d
  0028d	2b c2		 sub	 eax, edx
  0028f	ff c8		 dec	 eax
  00291	89 84 24 e0 00
	00 00		 mov	 DWORD PTR s2$1$[rsp], eax

; 2519 :     if (j >= 0) {

  00298	78 05		 js	 SHORT $LN152@Py_dg_dtoa

; 2520 :         b2 = 0;

  0029a	41 8b cc	 mov	 ecx, r12d

; 2521 :         s2 = j;
; 2522 :     }
; 2523 :     else {

  0029d	eb 0e		 jmp	 SHORT $LN265@Py_dg_dtoa
$LN152@Py_dg_dtoa:

; 2524 :         b2 = -j;

  0029f	8b c8		 mov	 ecx, eax

; 2525 :         s2 = 0;

  002a1	41 8b c4	 mov	 eax, r12d
  002a4	89 84 24 e0 00
	00 00		 mov	 DWORD PTR s2$1$[rsp], eax
  002ab	f7 d9		 neg	 ecx
$LN265@Py_dg_dtoa:

; 2526 :     }
; 2527 :     if (k >= 0) {

  002ad	89 4c 24 24	 mov	 DWORD PTR b2$1$[rsp], ecx
  002b1	45 85 f6	 test	 r14d, r14d
  002b4	78 16		 js	 SHORT $LN150@Py_dg_dtoa

; 2528 :         b5 = 0;
; 2529 :         s5 = k;
; 2530 :         s2 += k;

  002b6	41 03 c6	 add	 eax, r14d
  002b9	44 89 64 24 64	 mov	 DWORD PTR b5$1$[rsp], r12d
  002be	44 89 74 24 50	 mov	 DWORD PTR s5$1$[rsp], r14d
  002c3	89 84 24 e0 00
	00 00		 mov	 DWORD PTR s2$1$[rsp], eax

; 2531 :     }
; 2532 :     else {

  002ca	eb 15		 jmp	 SHORT $LN149@Py_dg_dtoa
$LN150@Py_dg_dtoa:

; 2533 :         b2 -= k;

  002cc	41 2b ce	 sub	 ecx, r14d

; 2535 :         s5 = 0;

  002cf	44 89 64 24 50	 mov	 DWORD PTR s5$1$[rsp], r12d
  002d4	89 4c 24 24	 mov	 DWORD PTR b2$1$[rsp], ecx
  002d8	41 8b ce	 mov	 ecx, r14d
  002db	f7 d9		 neg	 ecx
  002dd	89 4c 24 64	 mov	 DWORD PTR b5$1$[rsp], ecx
$LN149@Py_dg_dtoa:

; 2536 :     }
; 2537 :     if (mode < 0 || mode > 9)

  002e1	85 ff		 test	 edi, edi
  002e3	78 05		 js	 SHORT $LN147@Py_dg_dtoa
  002e5	83 ff 09	 cmp	 edi, 9
  002e8	7e 0b		 jle	 SHORT $LN148@Py_dg_dtoa
$LN147@Py_dg_dtoa:

; 2538 :         mode = 0;

  002ea	41 8b fc	 mov	 edi, r12d
  002ed	44 89 a4 24 e8
	00 00 00	 mov	 DWORD PTR mode$[rsp], r12d
$LN148@Py_dg_dtoa:

; 2539 : 
; 2540 :     try_quick = 1;

  002f5	44 8b eb	 mov	 r13d, ebx

; 2541 : 
; 2542 :     if (mode > 5) {

  002f8	83 ff 05	 cmp	 edi, 5
  002fb	7e 0d		 jle	 SHORT $LN146@Py_dg_dtoa

; 2543 :         mode -= 4;

  002fd	83 ef 04	 sub	 edi, 4

; 2544 :         try_quick = 0;

  00300	45 8b ec	 mov	 r13d, r12d
  00303	89 bc 24 e8 00
	00 00		 mov	 DWORD PTR mode$[rsp], edi
$LN146@Py_dg_dtoa:

; 2545 :     }
; 2546 :     leftright = 1;
; 2547 :     ilim = ilim1 = -1;  /* Values for cases 0 and 1; done here to */

  0030a	41 83 cf ff	 or	 r15d, -1
  0030e	89 5c 24 30	 mov	 DWORD PTR leftright$1$[rsp], ebx
  00312	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR ilim1$1$[rsp], -1
  0031a	44 89 7c 24 40	 mov	 DWORD PTR ilim$1$[rsp], r15d

; 2548 :     /* silence erroneous "gcc -Wall" warning. */
; 2549 :     switch(mode) {

  0031f	83 ff 05	 cmp	 edi, 5
  00322	77 6a		 ja	 SHORT $LN137@Py_dg_dtoa
  00324	48 63 c7	 movsxd	 rax, edi
  00327	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN216@Py_dg_dtoa[r8+rax*4]
  0032f	49 03 c8	 add	 rcx, r8
  00332	ff e1		 jmp	 rcx
$LN143@Py_dg_dtoa:

; 2550 :     case 0:
; 2551 :     case 1:
; 2552 :         i = 18;

  00334	ba 12 00 00 00	 mov	 edx, 18

; 2553 :         ndigits = 0;

  00339	44 89 a4 24 f0
	00 00 00	 mov	 DWORD PTR ndigits$[rsp], r12d

; 2554 :         break;

  00341	eb 4b		 jmp	 SHORT $LN137@Py_dg_dtoa
$LN142@Py_dg_dtoa:

; 2555 :     case 2:
; 2556 :         leftright = 0;

  00343	44 89 64 24 30	 mov	 DWORD PTR leftright$1$[rsp], r12d
$LN141@Py_dg_dtoa:

; 2557 :         /* no break */
; 2558 :     case 4:
; 2559 :         if (ndigits <= 0)

  00348	8b bc 24 f0 00
	00 00		 mov	 edi, DWORD PTR ndigits$[rsp]
  0034f	85 ff		 test	 edi, edi
  00351	0f 4e fb	 cmovle	 edi, ebx
  00354	89 bc 24 f0 00
	00 00		 mov	 DWORD PTR ndigits$[rsp], edi

; 2560 :             ndigits = 1;
; 2561 :         ilim = ilim1 = i = ndigits;

  0035b	8b d7		 mov	 edx, edi
  0035d	89 7c 24 48	 mov	 DWORD PTR ilim1$1$[rsp], edi
  00361	44 8b ff	 mov	 r15d, edi
  00364	89 7c 24 40	 mov	 DWORD PTR ilim$1$[rsp], edi

; 2562 :         break;

  00368	eb 24		 jmp	 SHORT $LN137@Py_dg_dtoa
$LN139@Py_dg_dtoa:

; 2563 :     case 3:
; 2564 :         leftright = 0;

  0036a	44 89 64 24 30	 mov	 DWORD PTR leftright$1$[rsp], r12d
$LN138@Py_dg_dtoa:

; 2565 :         /* no break */
; 2566 :     case 5:
; 2567 :         i = ndigits + k + 1;

  0036f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
  00376	41 8d 54 06 01	 lea	 edx, DWORD PTR [r14+rax+1]

; 2568 :         ilim = i;
; 2569 :         ilim1 = i - 1;
; 2570 :         if (i <= 0)

  0037b	85 d2		 test	 edx, edx
  0037d	44 8b fa	 mov	 r15d, edx
  00380	89 54 24 40	 mov	 DWORD PTR ilim$1$[rsp], edx
  00384	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00387	0f 4e d3	 cmovle	 edx, ebx
  0038a	89 44 24 48	 mov	 DWORD PTR ilim1$1$[rsp], eax
$LN137@Py_dg_dtoa:

; 2571 :             i = 1;
; 2572 :     }
; 2573 :     s0 = rv_alloc(i);

  0038e	8b ca		 mov	 ecx, edx
  00390	e8 00 00 00 00	 call	 rv_alloc
  00395	4c 8b c0	 mov	 r8, rax
  00398	48 89 44 24 28	 mov	 QWORD PTR s0$1$[rsp], rax

; 2574 :     if (s0 == NULL)

  0039d	48 85 c0	 test	 rax, rax
  003a0	0f 84 88 08 00
	00		 je	 $LN3@Py_dg_dtoa

; 2575 :         goto failed_malloc;
; 2576 :     s = s0;
; 2577 : 
; 2578 : 
; 2579 :     if (ilim >= 0 && ilim <= Quick_max && try_quick) {

  003a6	f2 0f 10 1d 00
	00 00 00	 movsdx	 xmm3, QWORD PTR __real@4024000000000000
  003ae	f2 0f 10 25 00
	00 00 00	 movsdx	 xmm4, QWORD PTR __real@4014000000000000
  003b6	48 8b f8	 mov	 rdi, rax
  003b9	41 83 ff 0e	 cmp	 r15d, 14
  003bd	0f 87 a4 02 00
	00		 ja	 $LN250@Py_dg_dtoa
  003c3	45 85 ed	 test	 r13d, r13d
  003c6	0f 84 9b 02 00
	00		 je	 $LN250@Py_dg_dtoa

; 2580 : 
; 2581 :         /* Try to get by with floating-point arithmetic. */
; 2582 : 
; 2583 :         i = 0;
; 2584 :         dval(&d2) = dval(&u);

  003cc	66 0f 28 ee	 movapd	 xmm5, xmm6

; 2585 :         k0 = k;

  003d0	45 8b ce	 mov	 r9d, r14d

; 2586 :         ilim0 = ilim;

  003d3	45 8b d7	 mov	 r10d, r15d

; 2587 :         ieps = 2; /* conservative */

  003d6	ba 02 00 00 00	 mov	 edx, 2

; 2588 :         if (k > 0) {
; 2589 :             ds = tens[k&0xf];
; 2590 :             j = k >> 4;

  003db	41 8b ce	 mov	 ecx, r14d
  003de	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  003e5	45 85 f6	 test	 r14d, r14d
  003e8	7e 4e		 jle	 SHORT $LN134@Py_dg_dtoa
  003ea	41 8b c6	 mov	 eax, r14d
  003ed	c1 f9 04	 sar	 ecx, 4
  003f0	83 e0 0f	 and	 eax, 15
  003f3	f2 41 0f 10 84
	c3 00 00 00 00	 movsdx	 xmm0, QWORD PTR tens[r11+rax*8]

; 2591 :             if (j & Bletch) {

  003fd	f6 c1 10	 test	 cl, 16
  00400	74 10		 je	 SHORT $LN133@Py_dg_dtoa

; 2592 :                 /* prevent overflows */
; 2593 :                 j &= Bletch - 1;
; 2594 :                 dval(&u) /= bigtens[n_bigtens-1];

  00402	f2 0f 5e 35 20
	00 00 00	 divsd	 xmm6, QWORD PTR bigtens+32
  0040a	83 e1 0f	 and	 ecx, 15

; 2595 :                 ieps++;

  0040d	ba 03 00 00 00	 mov	 edx, 3
$LN133@Py_dg_dtoa:

; 2596 :             }
; 2597 :             for(; j; j >>= 1, i++)

  00412	85 c9		 test	 ecx, ecx
  00414	74 1c		 je	 SHORT $LN130@Py_dg_dtoa
  00416	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigtens
  0041d	0f 1f 00	 npad	 3
$LL132@Py_dg_dtoa:

; 2598 :                 if (j & 1) {

  00420	84 cb		 test	 cl, bl
  00422	74 06		 je	 SHORT $LN131@Py_dg_dtoa

; 2599 :                     ieps++;
; 2600 :                     ds *= bigtens[i];

  00424	f2 0f 59 00	 mulsd	 xmm0, QWORD PTR [rax]
  00428	ff c2		 inc	 edx
$LN131@Py_dg_dtoa:

; 2596 :             }
; 2597 :             for(; j; j >>= 1, i++)

  0042a	48 83 c0 08	 add	 rax, 8
  0042e	d1 f9		 sar	 ecx, 1
  00430	75 ee		 jne	 SHORT $LL132@Py_dg_dtoa
$LN130@Py_dg_dtoa:

; 2601 :                 }
; 2602 :             dval(&u) /= ds;

  00432	f2 0f 5e f0	 divsd	 xmm6, xmm0
  00436	eb 3a		 jmp	 SHORT $LN124@Py_dg_dtoa
$LN134@Py_dg_dtoa:

; 2603 :         }
; 2604 :         else if ((j1 = -k)) {

  00438	f7 d9		 neg	 ecx
  0043a	74 36		 je	 SHORT $LN124@Py_dg_dtoa

; 2605 :             dval(&u) *= tens[j1 & 0xf];

  0043c	8b c1		 mov	 eax, ecx

; 2606 :             for(j = j1 >> 4; j; j >>= 1, i++)

  0043e	c1 f9 04	 sar	 ecx, 4
  00441	83 e0 0f	 and	 eax, 15
  00444	f2 41 0f 59 b4
	c3 00 00 00 00	 mulsd	 xmm6, QWORD PTR tens[r11+rax*8]
  0044e	85 c9		 test	 ecx, ecx
  00450	74 20		 je	 SHORT $LN124@Py_dg_dtoa

; 2605 :             dval(&u) *= tens[j1 & 0xf];

  00452	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bigtens
  00459	0f 1f 80 00 00
	00 00		 npad	 7
$LL126@Py_dg_dtoa:

; 2607 :                 if (j & 1) {

  00460	84 cb		 test	 cl, bl
  00462	74 06		 je	 SHORT $LN125@Py_dg_dtoa

; 2608 :                     ieps++;
; 2609 :                     dval(&u) *= bigtens[i];

  00464	f2 0f 59 30	 mulsd	 xmm6, QWORD PTR [rax]
  00468	ff c2		 inc	 edx
$LN125@Py_dg_dtoa:

; 2606 :             for(j = j1 >> 4; j; j >>= 1, i++)

  0046a	48 83 c0 08	 add	 rax, 8
  0046e	d1 f9		 sar	 ecx, 1
  00470	75 ee		 jne	 SHORT $LL126@Py_dg_dtoa
$LN124@Py_dg_dtoa:

; 2610 :                 }
; 2611 :         }
; 2612 :         if (k_check && dval(&u) < 1. && ilim > 0) {

  00472	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3ff0000000000000
  0047a	39 6c 24 58	 cmp	 DWORD PTR k_check$1$[rsp], ebp
  0047e	74 1f		 je	 SHORT $LN122@Py_dg_dtoa
  00480	66 0f 2f d6	 comisd	 xmm2, xmm6
  00484	76 19		 jbe	 SHORT $LN122@Py_dg_dtoa
  00486	45 85 ff	 test	 r15d, r15d
  00489	7e 14		 jle	 SHORT $LN122@Py_dg_dtoa

; 2613 :             if (ilim1 <= 0)

  0048b	8b 44 24 48	 mov	 eax, DWORD PTR ilim1$1$[rsp]
  0048f	85 c0		 test	 eax, eax
  00491	7e 66		 jle	 SHORT $fast_failed$21184

; 2614 :                 goto fast_failed;
; 2615 :             ilim = ilim1;
; 2616 :             k--;

  00493	41 ff ce	 dec	 r14d
  00496	44 8b f8	 mov	 r15d, eax

; 2617 :             dval(&u) *= 10.;

  00499	f2 0f 59 f3	 mulsd	 xmm6, xmm3

; 2618 :             ieps++;

  0049d	ff c2		 inc	 edx
$LN122@Py_dg_dtoa:

; 2619 :         }
; 2620 :         dval(&eps) = ieps*dval(&u) + 7.;

  0049f	66 0f 6e c2	 movd	 xmm0, edx
  004a3	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  004a7	f2 0f 59 c6	 mulsd	 xmm0, xmm6
  004ab	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@401c000000000000
  004b3	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR eps$[rsp], xmm0

; 2621 :         word0(&eps) -= (P-1)*Exp_msk1;

  004b9	48 8b 44 24 40	 mov	 rax, QWORD PTR eps$[rsp]
  004be	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  004c2	2d 00 00 40 03	 sub	 eax, 54525952		; 03400000H
  004c7	89 44 24 44	 mov	 DWORD PTR eps$[rsp+4], eax

; 2622 :         if (ilim == 0) {

  004cb	45 85 ff	 test	 r15d, r15d
  004ce	75 4b		 jne	 SHORT $LN120@Py_dg_dtoa

; 2623 :             S = mhi = 0;
; 2624 :             dval(&u) -= 5.;
; 2625 :             if (dval(&u) > dval(&eps))

  004d0	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR eps$[rsp]
  004d6	f2 0f 5c f4	 subsd	 xmm6, xmm4
  004da	4d 8b ec	 mov	 r13, r12
  004dd	66 0f 2f f0	 comisd	 xmm6, xmm0
  004e1	0f 87 27 05 00
	00		 ja	 $one_digit$21187

; 2626 :                 goto one_digit;
; 2627 :             if (dval(&u) < -dval(&eps))

  004e7	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  004ef	66 0f 2f c6	 comisd	 xmm0, xmm6
  004f3	0f 87 25 05 00
	00		 ja	 $LN248@Py_dg_dtoa
$fast_failed$21184:

; 2663 :                         s++;
; 2664 :                         goto ret1;
; 2665 :                     }
; 2666 :                     break;
; 2667 :                 }
; 2668 :             }
; 2669 :         }
; 2670 :       fast_failed:
; 2671 :         s = s0;
; 2672 :         dval(&u) = dval(&d2);

  004f9	f2 0f 11 6c 24
	38		 movsdx	 QWORD PTR u$[rsp], xmm5
  004ff	49 8b f8	 mov	 rdi, r8
  00502	66 0f 28 f5	 movapd	 xmm6, xmm5

; 2673 :         k = k0;

  00506	45 8b f1	 mov	 r14d, r9d
  00509	44 89 4c 24 20	 mov	 DWORD PTR k$1$[rsp], r9d

; 2674 :         ilim = ilim0;

  0050e	45 8b fa	 mov	 r15d, r10d
  00511	44 89 54 24 40	 mov	 DWORD PTR ilim$1$[rsp], r10d
  00516	e9 53 01 00 00	 jmp	 $LN135@Py_dg_dtoa
$LN120@Py_dg_dtoa:

; 2628 :                 goto no_digits;
; 2629 :             goto fast_failed;
; 2630 :         }
; 2631 :         if (leftright) {
; 2632 :             /* Use Steele & White method of only
; 2633 :              * generating digits needed.
; 2634 :              */
; 2635 :             dval(&eps) = 0.5/tens[ilim-1] - dval(&eps);

  0051b	49 63 c7	 movsxd	 rax, r15d
  0051e	39 6c 24 30	 cmp	 DWORD PTR leftright$1$[rsp], ebp
  00522	0f 84 8d 00 00
	00		 je	 $LN117@Py_dg_dtoa
  00528	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3fe0000000000000

; 2636 :             for(i = 0;;) {

  00530	41 8b cc	 mov	 ecx, r12d

; 2637 :                 L = (Long)dval(&u);
; 2638 :                 dval(&u) -= L;
; 2639 :                 *s++ = '0' + (int)L;

  00533	49 8d 78 01	 lea	 rdi, QWORD PTR [r8+1]
  00537	f2 41 0f 5e 8c
	c3 f8 ff ff ff	 divsd	 xmm1, QWORD PTR tens[r11+rax*8-8]
  00541	f2 0f 2c c6	 cvttsd2si eax, xmm6
  00545	66 0f 6e c0	 movd	 xmm0, eax
  00549	04 30		 add	 al, 48			; 00000030H
  0054b	41 88 00	 mov	 BYTE PTR [r8], al
  0054e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00552	f2 0f 5c 4c 24
	40		 subsd	 xmm1, QWORD PTR eps$[rsp]
  00558	f2 0f 5c f0	 subsd	 xmm6, xmm0

; 2640 :                 if (dval(&u) < dval(&eps))

  0055c	66 0f 2f ce	 comisd	 xmm1, xmm6
  00560	0f 87 cd 00 00
	00		 ja	 $LN244@Py_dg_dtoa
  00566	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL116@Py_dg_dtoa:

; 2642 :                 if (1. - dval(&u) < dval(&eps))

  00570	66 0f 28 c2	 movapd	 xmm0, xmm2
  00574	f2 0f 5c c6	 subsd	 xmm0, xmm6
  00578	66 0f 2f c8	 comisd	 xmm1, xmm0
  0057c	0f 87 de 01 00
	00		 ja	 $bump_up$21199

; 2643 :                     goto bump_up;
; 2644 :                 if (++i >= ilim)

  00582	ff c1		 inc	 ecx
  00584	41 3b cf	 cmp	 ecx, r15d
  00587	0f 8d 6c ff ff
	ff		 jge	 $fast_failed$21184

; 2645 :                     break;
; 2646 :                 dval(&eps) *= 10.;
; 2647 :                 dval(&u) *= 10.;

  0058d	f2 0f 59 f3	 mulsd	 xmm6, xmm3
  00591	f2 0f 59 cb	 mulsd	 xmm1, xmm3
  00595	48 ff c7	 inc	 rdi
  00598	f2 0f 2c c6	 cvttsd2si eax, xmm6
  0059c	66 0f 6e c0	 movd	 xmm0, eax
  005a0	04 30		 add	 al, 48			; 00000030H
  005a2	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  005a5	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  005a9	f2 0f 5c f0	 subsd	 xmm6, xmm0
  005ad	66 0f 2f ce	 comisd	 xmm1, xmm6
  005b1	76 bd		 jbe	 SHORT $LL116@Py_dg_dtoa

; 2641 :                     goto ret1;

  005b3	eb 7e		 jmp	 SHORT $LN244@Py_dg_dtoa
$LN117@Py_dg_dtoa:

; 2648 :             }
; 2649 :         }
; 2650 :         else {
; 2651 :             /* Generate ilim digits, then fix them up. */
; 2652 :             dval(&eps) *= tens[ilim-1];

  005b5	f2 0f 10 54 24
	40		 movsdx	 xmm2, QWORD PTR eps$[rsp]

; 2653 :             for(i = 1;; i++, dval(&u) *= 10.) {

  005bb	8b cb		 mov	 ecx, ebx
  005bd	f2 41 0f 59 94
	c3 f8 ff ff ff	 mulsd	 xmm2, QWORD PTR tens[r11+rax*8-8]
  005c7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL110@Py_dg_dtoa:

; 2654 :                 L = (Long)(dval(&u));

  005d0	f2 0f 2c c6	 cvttsd2si eax, xmm6

; 2655 :                 if (!(dval(&u) -= L))

  005d4	66 0f 6e c0	 movd	 xmm0, eax
  005d8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  005dc	f2 0f 5c f0	 subsd	 xmm6, xmm0
  005e0	66 0f 2e f7	 ucomisd xmm6, xmm7
  005e4	7a 05		 jp	 SHORT $LN107@Py_dg_dtoa
  005e6	75 03		 jne	 SHORT $LN107@Py_dg_dtoa

; 2656 :                     ilim = i;

  005e8	44 8b f9	 mov	 r15d, ecx
$LN107@Py_dg_dtoa:

; 2657 :                 *s++ = '0' + (int)L;

  005eb	04 30		 add	 al, 48			; 00000030H
  005ed	48 ff c7	 inc	 rdi
  005f0	88 47 ff	 mov	 BYTE PTR [rdi-1], al

; 2658 :                 if (i == ilim) {

  005f3	41 3b cf	 cmp	 ecx, r15d
  005f6	74 08		 je	 SHORT $LN187@Py_dg_dtoa

; 2653 :             for(i = 1;; i++, dval(&u) *= 10.) {

  005f8	ff c1		 inc	 ecx
  005fa	f2 0f 59 f3	 mulsd	 xmm6, xmm3
  005fe	eb d0		 jmp	 SHORT $LL110@Py_dg_dtoa
$LN187@Py_dg_dtoa:

; 2659 :                     if (dval(&u) > 0.5 + dval(&eps))

  00600	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3fe0000000000000
  00608	66 0f 28 c2	 movapd	 xmm0, xmm2
  0060c	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00610	66 0f 2f f0	 comisd	 xmm6, xmm0
  00614	0f 87 46 01 00
	00		 ja	 $bump_up$21199

; 2660 :                         goto bump_up;
; 2661 :                     else if (dval(&u) < 0.5 - dval(&eps)) {

  0061a	f2 0f 5c ca	 subsd	 xmm1, xmm2
  0061e	66 0f 2f ce	 comisd	 xmm1, xmm6
  00622	0f 86 d1 fe ff
	ff		 jbe	 $fast_failed$21184
$LL102@Py_dg_dtoa:

; 2662 :                         while(*--s == '0');

  00628	48 ff cf	 dec	 rdi
  0062b	80 3f 30	 cmp	 BYTE PTR [rdi], 48	; 00000030H
  0062e	74 f8		 je	 SHORT $LL102@Py_dg_dtoa
$LN271@Py_dg_dtoa:

; 2703 :                             break;
; 2704 :                         }
; 2705 :                     ++*s++;

  00630	48 ff c7	 inc	 rdi
$LN244@Py_dg_dtoa:

; 2693 :                 break;

  00633	49 8b d8	 mov	 rbx, r8
$ret1$21197:

; 2964 :     }
; 2965 :   ret1:
; 2966 :     Bfree(b);

  00636	48 8b ce	 mov	 rcx, rsi
  00639	e8 00 00 00 00	 call	 Bfree

; 2967 :     *s = 0;
; 2968 :     *decpt = k + 1;

  0063e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR decpt$[rsp]
  00646	41 8d 46 01	 lea	 eax, DWORD PTR [r14+1]
  0064a	c6 07 00	 mov	 BYTE PTR [rdi], 0
  0064d	89 01		 mov	 DWORD PTR [rcx], eax

; 2969 :     if (rve)

  0064f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR rve$[rsp]
  00657	48 85 c0	 test	 rax, rax
  0065a	74 03		 je	 SHORT $LN6@Py_dg_dtoa

; 2970 :         *rve = s;

  0065c	48 89 38	 mov	 QWORD PTR [rax], rdi
$LN6@Py_dg_dtoa:

; 2971 :     return s0;

  0065f	48 8b c3	 mov	 rax, rbx
  00662	e9 e8 05 00 00	 jmp	 $LN263@Py_dg_dtoa
$LN250@Py_dg_dtoa:

; 2674 :         ilim = ilim0;

  00667	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
$LN135@Py_dg_dtoa:

; 2675 :     }
; 2676 : 
; 2677 :     /* Do we have a "small" integer? */
; 2678 : 
; 2679 :     if (be >= 0 && k <= Int_max) {

  0066e	8b 4c 24 60	 mov	 ecx, DWORD PTR be$[rsp]
  00672	85 c9		 test	 ecx, ecx
  00674	0f 88 0f 01 00
	00		 js	 $LN100@Py_dg_dtoa
  0067a	41 83 fe 0e	 cmp	 r14d, 14
  0067e	0f 8f 05 01 00
	00		 jg	 $LN100@Py_dg_dtoa

; 2680 :         /* Yes. */
; 2681 :         ds = tens[k];

  00684	49 63 c6	 movsxd	 rax, r14d
  00687	f2 41 0f 10 94
	c3 00 00 00 00	 movsdx	 xmm2, QWORD PTR tens[r11+rax*8]

; 2682 :         if (ndigits < 0 && ilim <= 0) {

  00691	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
  00698	85 c0		 test	 eax, eax
  0069a	79 2b		 jns	 SHORT $LN99@Py_dg_dtoa
  0069c	45 85 ff	 test	 r15d, r15d
  0069f	7f 26		 jg	 SHORT $LN99@Py_dg_dtoa

; 2683 :             S = mhi = 0;

  006a1	49 8b ec	 mov	 rbp, r12
  006a4	4d 8b ec	 mov	 r13, r12

; 2684 :             if (ilim < 0 || dval(&u) <= 5*ds)

  006a7	0f 88 78 03 00
	00		 js	 $no_digits$21189
  006ad	f2 0f 59 d4	 mulsd	 xmm2, xmm4
  006b1	66 0f 2f d6	 comisd	 xmm2, xmm6
  006b5	0f 82 53 03 00
	00		 jb	 $one_digit$21187

; 2817 :             /* no digits, fcvt style */
; 2818 :           no_digits:
; 2819 :             k = -1 - ndigits;

  006bb	41 83 ce ff	 or	 r14d, -1
  006bf	44 2b f0	 sub	 r14d, eax

; 2820 :             goto ret;

  006c2	e9 dc 05 00 00	 jmp	 $LN266@Py_dg_dtoa
$LN99@Py_dg_dtoa:

; 2689 :             L = (Long)(dval(&u) / ds);

  006c7	66 0f 28 c6	 movapd	 xmm0, xmm6

; 2690 :             dval(&u) -= L*ds;
; 2691 :             *s++ = '0' + (int)L;

  006cb	49 8d 78 01	 lea	 rdi, QWORD PTR [r8+1]
  006cf	f2 0f 5e c2	 divsd	 xmm0, xmm2
  006d3	f2 0f 2c c8	 cvttsd2si ecx, xmm0
  006d7	66 0f 6e c9	 movd	 xmm1, ecx
  006db	8d 41 30	 lea	 eax, DWORD PTR [rcx+48]
  006de	41 88 00	 mov	 BYTE PTR [r8], al
  006e1	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  006e5	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  006e9	f2 0f 5c f1	 subsd	 xmm6, xmm1

; 2692 :             if (!dval(&u)) {

  006ed	66 0f 2e f7	 ucomisd xmm6, xmm7
  006f1	7a 0d		 jp	 SHORT $LL224@Py_dg_dtoa
  006f3	0f 84 3a ff ff
	ff		 je	 $LN244@Py_dg_dtoa
  006f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL224@Py_dg_dtoa:

; 2694 :             }
; 2695 :             if (i == ilim) {

  00700	41 3b df	 cmp	 ebx, r15d
  00703	74 38		 je	 SHORT $LN189@Py_dg_dtoa

; 2685 :                 goto no_digits;
; 2686 :             goto one_digit;
; 2687 :         }
; 2688 :         for(i = 1;; i++, dval(&u) *= 10.) {

  00705	f2 0f 59 f3	 mulsd	 xmm6, xmm3
  00709	ff c3		 inc	 ebx

; 2690 :             dval(&u) -= L*ds;
; 2691 :             *s++ = '0' + (int)L;

  0070b	48 ff c7	 inc	 rdi
  0070e	66 0f 28 c6	 movapd	 xmm0, xmm6
  00712	f2 0f 5e c2	 divsd	 xmm0, xmm2
  00716	f2 0f 2c c8	 cvttsd2si ecx, xmm0
  0071a	66 0f 6e c9	 movd	 xmm1, ecx
  0071e	8d 41 30	 lea	 eax, DWORD PTR [rcx+48]
  00721	88 47 ff	 mov	 BYTE PTR [rdi-1], al
  00724	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00728	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0072c	f2 0f 5c f1	 subsd	 xmm6, xmm1

; 2692 :             if (!dval(&u)) {

  00730	66 0f 2e f7	 ucomisd xmm6, xmm7
  00734	7a ca		 jp	 SHORT $LL224@Py_dg_dtoa
  00736	75 c8		 jne	 SHORT $LL224@Py_dg_dtoa

; 2693 :                 break;

  00738	e9 f6 fe ff ff	 jmp	 $LN244@Py_dg_dtoa
$LN189@Py_dg_dtoa:

; 2696 :                 dval(&u) += dval(&u);

  0073d	f2 0f 58 f6	 addsd	 xmm6, xmm6

; 2697 :                 if (dval(&u) > ds || (dval(&u) == ds && L & 1)) {

  00741	66 0f 2f f2	 comisd	 xmm6, xmm2
  00745	77 19		 ja	 SHORT $bump_up$21199
  00747	66 0f 2e f2	 ucomisd xmm6, xmm2
  0074b	0f 8a e2 fe ff
	ff		 jp	 $LN244@Py_dg_dtoa
  00751	0f 85 dc fe ff
	ff		 jne	 $LN244@Py_dg_dtoa
  00757	f6 c1 01	 test	 cl, 1
  0075a	0f 84 d3 fe ff
	ff		 je	 $LN244@Py_dg_dtoa
$bump_up$21199:

; 2698 :                   bump_up:
; 2699 :                     while(*--s == '9')

  00760	48 ff cf	 dec	 rdi
  00763	80 3f 39	 cmp	 BYTE PTR [rdi], 57	; 00000039H
  00766	75 1a		 jne	 SHORT $LN88@Py_dg_dtoa
$LL89@Py_dg_dtoa:

; 2700 :                         if (s == s0) {

  00768	49 3b f8	 cmp	 rdi, r8
  0076b	74 0f		 je	 SHORT $LN190@Py_dg_dtoa

; 2698 :                   bump_up:
; 2699 :                     while(*--s == '9')

  0076d	48 ff cf	 dec	 rdi
  00770	80 3f 39	 cmp	 BYTE PTR [rdi], 57	; 00000039H
  00773	74 f3		 je	 SHORT $LL89@Py_dg_dtoa

; 2703 :                             break;
; 2704 :                         }
; 2705 :                     ++*s++;

  00775	fe 07		 inc	 BYTE PTR [rdi]

; 2706 :                 }
; 2707 :                 break;
; 2708 :             }
; 2709 :         }
; 2710 :         goto ret1;

  00777	e9 b4 fe ff ff	 jmp	 $LN271@Py_dg_dtoa
$LN190@Py_dg_dtoa:

; 2701 :                             k++;

  0077c	41 ff c6	 inc	 r14d

; 2702 :                             *s = '0';

  0077f	c6 07 30	 mov	 BYTE PTR [rdi], 48	; 00000030H
$LN88@Py_dg_dtoa:

; 2703 :                             break;
; 2704 :                         }
; 2705 :                     ++*s++;

  00782	fe 07		 inc	 BYTE PTR [rdi]

; 2706 :                 }
; 2707 :                 break;
; 2708 :             }
; 2709 :         }
; 2710 :         goto ret1;

  00784	e9 a7 fe ff ff	 jmp	 $LN271@Py_dg_dtoa
$LN100@Py_dg_dtoa:

; 2711 :     }
; 2712 : 
; 2713 :     m2 = b2;
; 2714 :     m5 = b5;
; 2715 :     if (leftright) {

  00789	8b 44 24 30	 mov	 eax, DWORD PTR leftright$1$[rsp]
  0078d	8b 54 24 24	 mov	 edx, DWORD PTR b2$1$[rsp]
  00791	44 8b f2	 mov	 r14d, edx
  00794	85 c0		 test	 eax, eax
  00796	0f 84 bf 00 00
	00		 je	 $LN237@Py_dg_dtoa

; 2716 :         i =
; 2717 :             denorm ? be + (Bias + (P-1) - 1 + 1) :
; 2718 :             1 + P - bbits;

  0079c	44 39 64 24 68	 cmp	 DWORD PTR denorm$1$[rsp], r12d
  007a1	74 08		 je	 SHORT $LN168@Py_dg_dtoa
  007a3	8d 81 33 04 00
	00		 lea	 eax, DWORD PTR [rcx+1075]
  007a9	eb 09		 jmp	 SHORT $LN169@Py_dg_dtoa
$LN168@Py_dg_dtoa:
  007ab	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  007b0	2b 44 24 5c	 sub	 eax, DWORD PTR bbits$[rsp]
$LN169@Py_dg_dtoa:

; 2719 :         b2 += i;
; 2720 :         s2 += i;

  007b4	44 8b ac 24 e0
	00 00 00	 mov	 r13d, DWORD PTR s2$1$[rsp]
  007bc	03 d0		 add	 edx, eax

; 2721 :         mhi = i2b(1);

  007be	8b cb		 mov	 ecx, ebx
  007c0	44 03 e8	 add	 r13d, eax
  007c3	89 54 24 24	 mov	 DWORD PTR b2$1$[rsp], edx
  007c7	44 89 ac 24 e0
	00 00 00	 mov	 DWORD PTR s2$1$[rsp], r13d
  007cf	e8 00 00 00 00	 call	 i2b
  007d4	48 8b e8	 mov	 rbp, rax

; 2722 :         if (mhi == NULL)

  007d7	48 85 c0	 test	 rax, rax
  007da	0f 84 4e 04 00
	00		 je	 $LN3@Py_dg_dtoa

; 2727 :         b2 -= i;

  007e0	8b 54 24 24	 mov	 edx, DWORD PTR b2$1$[rsp]
  007e4	8b 44 24 30	 mov	 eax, DWORD PTR leftright$1$[rsp]
$LN85@Py_dg_dtoa:

; 2723 :             goto failed_malloc;
; 2724 :     }
; 2725 :     if (m2 > 0 && s2 > 0) {

  007e8	45 85 f6	 test	 r14d, r14d
  007eb	7e 23		 jle	 SHORT $LN84@Py_dg_dtoa
  007ed	45 85 ed	 test	 r13d, r13d
  007f0	7e 1e		 jle	 SHORT $LN84@Py_dg_dtoa

; 2726 :         i = m2 < s2 ? m2 : s2;

  007f2	45 3b f5	 cmp	 r14d, r13d
  007f5	41 8b cd	 mov	 ecx, r13d
  007f8	41 0f 4c ce	 cmovl	 ecx, r14d

; 2727 :         b2 -= i;

  007fc	2b d1		 sub	 edx, ecx

; 2728 :         m2 -= i;

  007fe	44 2b f1	 sub	 r14d, ecx

; 2729 :         s2 -= i;

  00801	44 2b e9	 sub	 r13d, ecx
  00804	44 89 ac 24 e0
	00 00 00	 mov	 DWORD PTR s2$1$[rsp], r13d
  0080c	89 54 24 24	 mov	 DWORD PTR b2$1$[rsp], edx
$LN84@Py_dg_dtoa:

; 2730 :     }
; 2731 :     if (b5 > 0) {

  00810	8b 4c 24 64	 mov	 ecx, DWORD PTR b5$1$[rsp]
  00814	85 c9		 test	 ecx, ecx
  00816	7e 61		 jle	 SHORT $LN75@Py_dg_dtoa

; 2732 :         if (leftright) {
; 2733 :             if (m5 > 0) {
; 2734 :                 mhi = pow5mult(mhi, m5);

  00818	8b d1		 mov	 edx, ecx
  0081a	85 c0		 test	 eax, eax
  0081c	74 47		 je	 SHORT $LN82@Py_dg_dtoa
  0081e	48 8b cd	 mov	 rcx, rbp
  00821	e8 00 00 00 00	 call	 pow5mult
  00826	48 8b e8	 mov	 rbp, rax

; 2735 :                 if (mhi == NULL)

  00829	48 85 c0	 test	 rax, rax
  0082c	0f 84 fc 03 00
	00		 je	 $LN3@Py_dg_dtoa

; 2736 :                     goto failed_malloc;
; 2737 :                 b1 = mult(mhi, b);

  00832	48 8b d6	 mov	 rdx, rsi
  00835	48 8b c8	 mov	 rcx, rax
  00838	e8 00 00 00 00	 call	 mult

; 2738 :                 Bfree(b);

  0083d	48 8b ce	 mov	 rcx, rsi
  00840	48 8b d8	 mov	 rbx, rax
  00843	e8 00 00 00 00	 call	 Bfree

; 2739 :                 b = b1;

  00848	48 8b f3	 mov	 rsi, rbx

; 2740 :                 if (b == NULL)

  0084b	48 85 db	 test	 rbx, rbx
  0084e	0f 84 cd 03 00
	00		 je	 $LN4@Py_dg_dtoa

; 2741 :                     goto failed_malloc;
; 2742 :             }
; 2743 :             if ((j = b5 - m5)) {
; 2744 :                 b = pow5mult(b, j);
; 2745 :                 if (b == NULL)
; 2746 :                     goto failed_malloc;
; 2747 :             }
; 2748 :         }
; 2749 :         else {

  00854	bb 01 00 00 00	 mov	 ebx, 1
  00859	eb 1e		 jmp	 SHORT $LN75@Py_dg_dtoa
$LN237@Py_dg_dtoa:

; 2729 :         s2 -= i;

  0085b	44 8b ac 24 e0
	00 00 00	 mov	 r13d, DWORD PTR s2$1$[rsp]
  00863	eb 83		 jmp	 SHORT $LN85@Py_dg_dtoa
$LN82@Py_dg_dtoa:

; 2750 :             b = pow5mult(b, b5);

  00865	48 8b ce	 mov	 rcx, rsi
  00868	e8 00 00 00 00	 call	 pow5mult
  0086d	48 8b f0	 mov	 rsi, rax

; 2751 :             if (b == NULL)

  00870	48 85 c0	 test	 rax, rax
  00873	0f 84 a8 03 00
	00		 je	 $LN4@Py_dg_dtoa
$LN75@Py_dg_dtoa:

; 2752 :                 goto failed_malloc;
; 2753 :         }
; 2754 :     }
; 2755 :     S = i2b(1);

  00879	8b cb		 mov	 ecx, ebx
  0087b	e8 00 00 00 00	 call	 i2b
  00880	4c 8b e8	 mov	 r13, rax

; 2756 :     if (S == NULL)

  00883	48 85 c0	 test	 rax, rax
  00886	0f 84 95 03 00
	00		 je	 $LN4@Py_dg_dtoa

; 2757 :         goto failed_malloc;
; 2758 :     if (s5 > 0) {

  0088c	8b 44 24 50	 mov	 eax, DWORD PTR s5$1$[rsp]
  00890	85 c0		 test	 eax, eax
  00892	7e 16		 jle	 SHORT $LN72@Py_dg_dtoa

; 2759 :         S = pow5mult(S, s5);

  00894	8b d0		 mov	 edx, eax
  00896	49 8b cd	 mov	 rcx, r13
  00899	e8 00 00 00 00	 call	 pow5mult
  0089e	4c 8b e8	 mov	 r13, rax

; 2760 :         if (S == NULL)

  008a1	48 85 c0	 test	 rax, rax
  008a4	0f 84 77 03 00
	00		 je	 $LN4@Py_dg_dtoa
$LN72@Py_dg_dtoa:

; 2761 :             goto failed_malloc;
; 2762 :     }
; 2763 : 
; 2764 :     /* Check for special case that d is a normalized power of 2. */
; 2765 : 
; 2766 :     spec_case = 0;
; 2767 :     if ((mode < 2 || leftright)
; 2768 :         ) {

  008aa	83 bc 24 e8 00
	00 00 02	 cmp	 DWORD PTR mode$[rsp], 2
  008b2	44 89 64 24 50	 mov	 DWORD PTR spec_case$1$[rsp], r12d
  008b7	7c 07		 jl	 SHORT $LN70@Py_dg_dtoa
  008b9	44 39 64 24 30	 cmp	 DWORD PTR leftright$1$[rsp], r12d
  008be	74 37		 je	 SHORT $LN233@Py_dg_dtoa
$LN70@Py_dg_dtoa:

; 2772 :             /* The special case */
; 2773 :             b2 += Log2P;

  008c0	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$1$[rsp]

; 2774 :             s2 += Log2P;

  008c5	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR s2$1$[rsp]
  008cc	44 39 64 24 38	 cmp	 DWORD PTR u$[rsp], r12d
  008d1	75 30		 jne	 SHORT $LN69@Py_dg_dtoa

; 2769 :         if (!word1(&u) && !(word0(&u) & Bndry_mask)
; 2770 :             && word0(&u) & (Exp_mask & ~Exp_msk1)
; 2771 :             ) {

  008d3	8b 44 24 3c	 mov	 eax, DWORD PTR u$[rsp+4]
  008d7	a9 ff ff 0f 00	 test	 eax, 1048575		; 000fffffH
  008dc	75 25		 jne	 SHORT $LN69@Py_dg_dtoa
  008de	a9 00 00 e0 7f	 test	 eax, 2145386496		; 7fe00000H
  008e3	74 1e		 je	 SHORT $LN69@Py_dg_dtoa

; 2772 :             /* The special case */
; 2773 :             b2 += Log2P;

  008e5	41 ff c0	 inc	 r8d

; 2774 :             s2 += Log2P;

  008e8	ff c2		 inc	 edx

; 2775 :             spec_case = 1;

  008ea	89 5c 24 50	 mov	 DWORD PTR spec_case$1$[rsp], ebx
  008ee	89 94 24 e0 00
	00 00		 mov	 DWORD PTR s2$1$[rsp], edx
  008f5	eb 0c		 jmp	 SHORT $LN69@Py_dg_dtoa
$LN233@Py_dg_dtoa:

; 2774 :             s2 += Log2P;

  008f7	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR s2$1$[rsp]
  008fe	44 8b 44 24 24	 mov	 r8d, DWORD PTR b2$1$[rsp]
$LN69@Py_dg_dtoa:

; 2776 :         }
; 2777 :     }
; 2778 : 
; 2779 :     /* Arrange for convenient computation of quotients:
; 2780 :      * shift left if necessary so divisor has 4 leading 0 bits.
; 2781 :      *
; 2782 :      * Perhaps we should just compute leading 28 bits of S once
; 2783 :      * and for all and pass them and a shift to quorem, so it
; 2784 :      * can do shifts and ors to compute the numerator for q.
; 2785 :      */
; 2786 : #define iInc 28
; 2787 :     i = dshift(S, s2);

  00903	49 8b cd	 mov	 rcx, r13
  00906	e8 00 00 00 00	 call	 dshift

; 2788 :     b2 += i;
; 2789 :     m2 += i;
; 2790 :     s2 += i;

  0090b	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR s2$1$[rsp]
  00912	03 c8		 add	 ecx, eax
  00914	44 03 c0	 add	 r8d, eax
  00917	44 03 f0	 add	 r14d, eax
  0091a	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR s2$1$[rsp], ecx

; 2791 :     if (b2 > 0) {

  00921	45 85 c0	 test	 r8d, r8d
  00924	7e 1e		 jle	 SHORT $LN67@Py_dg_dtoa

; 2792 :         b = lshift(b, b2);

  00926	41 8b d0	 mov	 edx, r8d
  00929	48 8b ce	 mov	 rcx, rsi
  0092c	e8 00 00 00 00	 call	 lshift
  00931	48 8b f0	 mov	 rsi, rax

; 2793 :         if (b == NULL)

  00934	48 85 c0	 test	 rax, rax
  00937	0f 84 c5 02 00
	00		 je	 $failed_malloc$21141
  0093d	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR s2$1$[rsp]
$LN67@Py_dg_dtoa:

; 2794 :             goto failed_malloc;
; 2795 :     }
; 2796 :     if (s2 > 0) {

  00944	85 c9		 test	 ecx, ecx
  00946	7e 16		 jle	 SHORT $LN65@Py_dg_dtoa

; 2797 :         S = lshift(S, s2);

  00948	8b d1		 mov	 edx, ecx
  0094a	49 8b cd	 mov	 rcx, r13
  0094d	e8 00 00 00 00	 call	 lshift
  00952	4c 8b e8	 mov	 r13, rax

; 2798 :         if (S == NULL)

  00955	48 85 c0	 test	 rax, rax
  00958	0f 84 c3 02 00
	00		 je	 $LN4@Py_dg_dtoa
$LN65@Py_dg_dtoa:

; 2799 :             goto failed_malloc;
; 2800 :     }
; 2801 :     if (k_check) {

  0095e	44 39 64 24 58	 cmp	 DWORD PTR k_check$1$[rsp], r12d
  00963	74 5a		 je	 SHORT $LN63@Py_dg_dtoa

; 2802 :         if (cmp(b,S) < 0) {

  00965	49 8b d5	 mov	 rdx, r13
  00968	48 8b ce	 mov	 rcx, rsi
  0096b	e8 00 00 00 00	 call	 cmp
  00970	85 c0		 test	 eax, eax
  00972	79 4b		 jns	 SHORT $LN63@Py_dg_dtoa

; 2803 :             k--;

  00974	ff 4c 24 20	 dec	 DWORD PTR k$1$[rsp]

; 2804 :             b = multadd(b, 10, 0);      /* we botched the k estimate */

  00978	45 33 c0	 xor	 r8d, r8d
  0097b	48 8b ce	 mov	 rcx, rsi
  0097e	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  00982	e8 00 00 00 00	 call	 multadd
  00987	48 8b f0	 mov	 rsi, rax

; 2805 :             if (b == NULL)

  0098a	48 85 c0	 test	 rax, rax
  0098d	0f 84 6f 02 00
	00		 je	 $failed_malloc$21141

; 2806 :                 goto failed_malloc;
; 2807 :             if (leftright) {

  00993	44 39 64 24 30	 cmp	 DWORD PTR leftright$1$[rsp], r12d
  00998	74 1b		 je	 SHORT $LN60@Py_dg_dtoa

; 2808 :                 mhi = multadd(mhi, 10, 0);

  0099a	45 33 c0	 xor	 r8d, r8d
  0099d	48 8b cd	 mov	 rcx, rbp
  009a0	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  009a4	e8 00 00 00 00	 call	 multadd
  009a9	48 8b e8	 mov	 rbp, rax

; 2809 :                 if (mhi == NULL)

  009ac	48 85 c0	 test	 rax, rax
  009af	0f 84 4d 02 00
	00		 je	 $failed_malloc$21141
$LN60@Py_dg_dtoa:

; 2810 :                     goto failed_malloc;
; 2811 :             }
; 2812 :             ilim = ilim1;

  009b5	44 8b 7c 24 48	 mov	 r15d, DWORD PTR ilim1$1$[rsp]
  009ba	44 89 7c 24 40	 mov	 DWORD PTR ilim$1$[rsp], r15d
$LN63@Py_dg_dtoa:

; 2813 :         }
; 2814 :     }
; 2815 :     if (ilim <= 0 && (mode == 3 || mode == 5)) {

  009bf	45 85 ff	 test	 r15d, r15d
  009c2	7f 6d		 jg	 SHORT $LN59@Py_dg_dtoa
  009c4	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  009cb	83 f8 03	 cmp	 eax, 3
  009ce	74 05		 je	 SHORT $LN58@Py_dg_dtoa
  009d0	83 f8 05	 cmp	 eax, 5
  009d3	75 5c		 jne	 SHORT $LN59@Py_dg_dtoa
$LN58@Py_dg_dtoa:

; 2816 :         if (ilim < 0) {

  009d5	45 85 ff	 test	 r15d, r15d
  009d8	78 44		 js	 SHORT $LN248@Py_dg_dtoa

; 2821 :         }
; 2822 :         else {
; 2823 :             S = multadd(S, 5, 0);

  009da	45 33 c0	 xor	 r8d, r8d
  009dd	49 8b cd	 mov	 rcx, r13
  009e0	41 8d 50 05	 lea	 edx, QWORD PTR [r8+5]
  009e4	e8 00 00 00 00	 call	 multadd
  009e9	4c 8b e8	 mov	 r13, rax

; 2824 :             if (S == NULL)

  009ec	48 85 c0	 test	 rax, rax
  009ef	0f 84 2c 02 00
	00		 je	 $LN4@Py_dg_dtoa

; 2825 :                 goto failed_malloc;
; 2826 :             if (cmp(b, S) <= 0)

  009f5	48 8b d0	 mov	 rdx, rax
  009f8	48 8b ce	 mov	 rcx, rsi
  009fb	e8 00 00 00 00	 call	 cmp
  00a00	85 c0		 test	 eax, eax
  00a02	7e 1a		 jle	 SHORT $LN248@Py_dg_dtoa
  00a04	44 8b 74 24 20	 mov	 r14d, DWORD PTR k$1$[rsp]
  00a09	4c 8b 44 24 28	 mov	 r8, QWORD PTR s0$1$[rsp]
$one_digit$21187:

; 2827 :                 goto no_digits;
; 2828 :         }
; 2829 :       one_digit:
; 2830 :         *s++ = '1';

  00a0e	41 c6 00 31	 mov	 BYTE PTR [r8], 49	; 00000031H
  00a12	49 8d 78 01	 lea	 rdi, QWORD PTR [r8+1]

; 2831 :         k++;

  00a16	41 ff c6	 inc	 r14d

; 2832 :         goto ret;

  00a19	e9 85 02 00 00	 jmp	 $LN266@Py_dg_dtoa
$LN248@Py_dg_dtoa:

; 2534 :         b5 = -k;

  00a1e	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
$no_digits$21189:

; 2817 :             /* no digits, fcvt style */
; 2818 :           no_digits:
; 2819 :             k = -1 - ndigits;

  00a25	41 83 ce ff	 or	 r14d, -1
  00a29	44 2b f0	 sub	 r14d, eax

; 2820 :             goto ret;

  00a2c	e9 72 02 00 00	 jmp	 $LN266@Py_dg_dtoa
$LN59@Py_dg_dtoa:

; 2833 :     }
; 2834 :     if (leftright) {

  00a31	44 39 64 24 30	 cmp	 DWORD PTR leftright$1$[rsp], r12d
  00a36	0f 84 34 03 00
	00		 je	 $LN53@Py_dg_dtoa

; 2835 :         if (m2 > 0) {

  00a3c	45 85 f6	 test	 r14d, r14d
  00a3f	7e 17		 jle	 SHORT $LN51@Py_dg_dtoa

; 2836 :             mhi = lshift(mhi, m2);

  00a41	41 8b d6	 mov	 edx, r14d
  00a44	48 8b cd	 mov	 rcx, rbp
  00a47	e8 00 00 00 00	 call	 lshift
  00a4c	48 8b e8	 mov	 rbp, rax

; 2837 :             if (mhi == NULL)

  00a4f	48 85 c0	 test	 rax, rax
  00a52	0f 84 aa 01 00
	00		 je	 $failed_malloc$21141
$LN51@Py_dg_dtoa:

; 2838 :                 goto failed_malloc;
; 2839 :         }
; 2840 : 
; 2841 :         /* Compute mlo -- check for special case
; 2842 :          * that d is a normalized power of 2.
; 2843 :          */
; 2844 : 
; 2845 :         mlo = mhi;
; 2846 :         if (spec_case) {

  00a58	83 7c 24 50 00	 cmp	 DWORD PTR spec_case$1$[rsp], 0
  00a5d	4c 8b e5	 mov	 r12, rbp
  00a60	74 45		 je	 SHORT $LN48@Py_dg_dtoa

; 2847 :             mhi = Balloc(mhi->k);

  00a62	8b 4d 08	 mov	 ecx, DWORD PTR [rbp+8]
  00a65	e8 00 00 00 00	 call	 Balloc
  00a6a	48 8b e8	 mov	 rbp, rax

; 2848 :             if (mhi == NULL)

  00a6d	48 85 c0	 test	 rax, rax
  00a70	0f 84 8c 01 00
	00		 je	 $failed_malloc$21141

; 2849 :                 goto failed_malloc;
; 2850 :             Bcopy(mhi, mlo);

  00a76	4d 63 44 24 14	 movsxd	 r8, DWORD PTR [r12+20]
  00a7b	49 8d 54 24 10	 lea	 rdx, QWORD PTR [r12+16]
  00a80	48 8d 48 10	 lea	 rcx, QWORD PTR [rax+16]
  00a84	4e 8d 04 85 08
	00 00 00	 lea	 r8, QWORD PTR [r8*4+8]
  00a8c	e8 00 00 00 00	 call	 memcpy

; 2851 :             mhi = lshift(mhi, Log2P);

  00a91	8b d3		 mov	 edx, ebx
  00a93	48 8b cd	 mov	 rcx, rbp
  00a96	e8 00 00 00 00	 call	 lshift
  00a9b	48 8b e8	 mov	 rbp, rax

; 2852 :             if (mhi == NULL)

  00a9e	48 85 c0	 test	 rax, rax
  00aa1	0f 84 5b 01 00
	00		 je	 $failed_malloc$21141
$LN48@Py_dg_dtoa:

; 2853 :                 goto failed_malloc;
; 2854 :         }
; 2855 : 
; 2856 :         for(i = 1;;i++) {
; 2857 :             dig = quorem(b,S) + '0';

  00aa7	49 8b d5	 mov	 rdx, r13
  00aaa	48 8b ce	 mov	 rcx, rsi
  00aad	89 9c 24 e0 00
	00 00		 mov	 DWORD PTR i$9$[rsp], ebx
  00ab4	e8 00 00 00 00	 call	 quorem

; 2858 :             /* Do we yet have the shortest decimal string
; 2859 :              * that will round to d?
; 2860 :              */
; 2861 :             j = cmp(b, mlo);

  00ab9	49 8b d4	 mov	 rdx, r12
  00abc	48 8b ce	 mov	 rcx, rsi
  00abf	8d 58 30	 lea	 ebx, DWORD PTR [rax+48]
  00ac2	e8 00 00 00 00	 call	 cmp

; 2862 :             delta = diff(S, mhi);

  00ac7	48 8b d5	 mov	 rdx, rbp
  00aca	49 8b cd	 mov	 rcx, r13
  00acd	44 8b f8	 mov	 r15d, eax
  00ad0	e8 00 00 00 00	 call	 diff
  00ad5	4c 8b d8	 mov	 r11, rax

; 2867 :             if (j1 == 0 && mode != 1 && !(word1(&u) & 1)
; 2868 :                 ) {

  00ad8	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR mode$[rsp]
  00ae0	48 89 44 24 50	 mov	 QWORD PTR $T22437[rsp], rax
  00ae5	4d 85 db	 test	 r11, r11
  00ae8	0f 84 14 01 00
	00		 je	 $failed_malloc$21141
  00aee	66 90		 npad	 2
$LL47@Py_dg_dtoa:

; 2864 :                 goto failed_malloc;
; 2865 :             j1 = delta->sign ? 1 : cmp(b, delta);

  00af0	41 83 7b 10 00	 cmp	 DWORD PTR [r11+16], 0
  00af5	74 08		 je	 SHORT $LN170@Py_dg_dtoa
  00af7	41 be 01 00 00
	00		 mov	 r14d, 1
  00afd	eb 0e		 jmp	 SHORT $LN171@Py_dg_dtoa
$LN170@Py_dg_dtoa:
  00aff	49 8b d3	 mov	 rdx, r11
  00b02	48 8b ce	 mov	 rcx, rsi
  00b05	e8 00 00 00 00	 call	 cmp
  00b0a	44 8b f0	 mov	 r14d, eax
$LN171@Py_dg_dtoa:

; 2866 :             Bfree(delta);

  00b0d	49 8b cb	 mov	 rcx, r11
  00b10	e8 00 00 00 00	 call	 Bfree

; 2867 :             if (j1 == 0 && mode != 1 && !(word1(&u) & 1)
; 2868 :                 ) {

  00b15	48 8b 44 24 50	 mov	 rax, QWORD PTR $T22437[rsp]
  00b1a	8b 4c 24 38	 mov	 ecx, DWORD PTR u$[rsp]
  00b1e	45 85 f6	 test	 r14d, r14d
  00b21	75 0f		 jne	 SHORT $LN43@Py_dg_dtoa
  00b23	48 83 f8 01	 cmp	 rax, 1
  00b27	74 09		 je	 SHORT $LN43@Py_dg_dtoa
  00b29	f6 c1 01	 test	 cl, 1
  00b2c	0f 84 57 01 00
	00		 je	 $LN192@Py_dg_dtoa
$LN43@Py_dg_dtoa:

; 2873 :                 *s++ = dig;
; 2874 :                 goto ret;
; 2875 :             }
; 2876 :             if (j < 0 || (j == 0 && mode != 1
; 2877 :                           && !(word1(&u) & 1)
; 2878 :                     )) {

  00b32	45 85 ff	 test	 r15d, r15d
  00b35	0f 88 a6 01 00
	00		 js	 $LN39@Py_dg_dtoa
  00b3b	75 0f		 jne	 SHORT $LN40@Py_dg_dtoa
  00b3d	48 83 f8 01	 cmp	 rax, 1
  00b41	74 09		 je	 SHORT $LN40@Py_dg_dtoa
  00b43	f6 c1 01	 test	 cl, 1
  00b46	0f 84 95 01 00
	00		 je	 $LN39@Py_dg_dtoa
$LN40@Py_dg_dtoa:

; 2889 :                         goto round_9_up;
; 2890 :                 }
; 2891 :               accept_dig:
; 2892 :                 *s++ = dig;
; 2893 :                 goto ret;
; 2894 :             }
; 2895 :             if (j1 > 0) {

  00b4c	45 85 f6	 test	 r14d, r14d
  00b4f	0f 8f 83 01 00
	00		 jg	 $LN194@Py_dg_dtoa

; 2903 :             }
; 2904 :             *s++ = dig;
; 2905 :             if (i == ilim)

  00b55	44 8b b4 24 e0
	00 00 00	 mov	 r14d, DWORD PTR i$9$[rsp]
  00b5d	88 1f		 mov	 BYTE PTR [rdi], bl
  00b5f	48 ff c7	 inc	 rdi
  00b62	44 3b 74 24 40	 cmp	 r14d, DWORD PTR ilim$1$[rsp]
  00b67	0f 84 4f 02 00
	00		 je	 $LN201@Py_dg_dtoa

; 2906 :                 break;
; 2907 :             b = multadd(b, 10, 0);

  00b6d	45 33 c0	 xor	 r8d, r8d
  00b70	48 8b ce	 mov	 rcx, rsi
  00b73	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  00b77	e8 00 00 00 00	 call	 multadd
  00b7c	48 8b f0	 mov	 rsi, rax

; 2908 :             if (b == NULL)

  00b7f	48 85 c0	 test	 rax, rax
  00b82	74 7e		 je	 SHORT $failed_malloc$21141

; 2909 :                 goto failed_malloc;
; 2910 :             if (mlo == mhi) {
; 2911 :                 mlo = mhi = multadd(mhi, 10, 0);

  00b84	45 33 c0	 xor	 r8d, r8d
  00b87	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  00b8b	4c 3b e5	 cmp	 r12, rbp
  00b8e	75 0d		 jne	 SHORT $LN29@Py_dg_dtoa
  00b90	48 8b cd	 mov	 rcx, rbp
  00b93	e8 00 00 00 00	 call	 multadd
  00b98	4c 8b e0	 mov	 r12, rax

; 2912 :                 if (mlo == NULL)
; 2913 :                     goto failed_malloc;
; 2914 :             }
; 2915 :             else {

  00b9b	eb 1f		 jmp	 SHORT $LN268@Py_dg_dtoa
$LN29@Py_dg_dtoa:

; 2916 :                 mlo = multadd(mlo, 10, 0);

  00b9d	49 8b cc	 mov	 rcx, r12
  00ba0	e8 00 00 00 00	 call	 multadd
  00ba5	4c 8b e0	 mov	 r12, rax

; 2917 :                 if (mlo == NULL)

  00ba8	48 85 c0	 test	 rax, rax
  00bab	74 55		 je	 SHORT $failed_malloc$21141

; 2918 :                     goto failed_malloc;
; 2919 :                 mhi = multadd(mhi, 10, 0);

  00bad	45 33 c0	 xor	 r8d, r8d
  00bb0	48 8b cd	 mov	 rcx, rbp
  00bb3	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  00bb7	e8 00 00 00 00	 call	 multadd
$LN268@Py_dg_dtoa:
  00bbc	48 8b e8	 mov	 rbp, rax

; 2920 :                 if (mhi == NULL)

  00bbf	48 85 c0	 test	 rax, rax
  00bc2	74 3e		 je	 SHORT $failed_malloc$21141

; 2853 :                 goto failed_malloc;
; 2854 :         }
; 2855 : 
; 2856 :         for(i = 1;;i++) {
; 2857 :             dig = quorem(b,S) + '0';

  00bc4	41 ff c6	 inc	 r14d
  00bc7	49 8b d5	 mov	 rdx, r13
  00bca	48 8b ce	 mov	 rcx, rsi
  00bcd	44 89 b4 24 e0
	00 00 00	 mov	 DWORD PTR i$9$[rsp], r14d
  00bd5	e8 00 00 00 00	 call	 quorem

; 2858 :             /* Do we yet have the shortest decimal string
; 2859 :              * that will round to d?
; 2860 :              */
; 2861 :             j = cmp(b, mlo);

  00bda	49 8b d4	 mov	 rdx, r12
  00bdd	48 8b ce	 mov	 rcx, rsi
  00be0	8d 58 30	 lea	 ebx, DWORD PTR [rax+48]
  00be3	e8 00 00 00 00	 call	 cmp

; 2862 :             delta = diff(S, mhi);

  00be8	48 8b d5	 mov	 rdx, rbp
  00beb	49 8b cd	 mov	 rcx, r13
  00bee	44 8b f8	 mov	 r15d, eax
  00bf1	e8 00 00 00 00	 call	 diff
  00bf6	4c 8b d8	 mov	 r11, rax

; 2863 :             if (delta == NULL)

  00bf9	48 85 c0	 test	 rax, rax
  00bfc	0f 85 ee fe ff
	ff		 jne	 $LL47@Py_dg_dtoa
$failed_malloc$21141:

; 2972 :   failed_malloc:
; 2973 :     if (S)

  00c02	4d 85 ed	 test	 r13, r13
  00c05	74 08		 je	 SHORT $LN5@Py_dg_dtoa

; 2974 :         Bfree(S);

  00c07	49 8b cd	 mov	 rcx, r13
  00c0a	e8 00 00 00 00	 call	 Bfree
$LN5@Py_dg_dtoa:

; 2975 :     if (mlo && mlo != mhi)

  00c0f	4d 85 e4	 test	 r12, r12
  00c12	74 0d		 je	 SHORT $LN4@Py_dg_dtoa
  00c14	4c 3b e5	 cmp	 r12, rbp
  00c17	74 08		 je	 SHORT $LN4@Py_dg_dtoa

; 2976 :         Bfree(mlo);

  00c19	49 8b cc	 mov	 rcx, r12
  00c1c	e8 00 00 00 00	 call	 Bfree
$LN4@Py_dg_dtoa:

; 2977 :     if (mhi)

  00c21	48 85 ed	 test	 rbp, rbp
  00c24	74 08		 je	 SHORT $LN3@Py_dg_dtoa

; 2978 :         Bfree(mhi);

  00c26	48 8b cd	 mov	 rcx, rbp
  00c29	e8 00 00 00 00	 call	 Bfree
$LN3@Py_dg_dtoa:

; 2979 :     if (b)

  00c2e	48 85 f6	 test	 rsi, rsi
  00c31	74 08		 je	 SHORT $LN2@Py_dg_dtoa

; 2980 :         Bfree(b);

  00c33	48 8b ce	 mov	 rcx, rsi
  00c36	e8 00 00 00 00	 call	 Bfree
$LN2@Py_dg_dtoa:

; 2981 :     if (s0)

  00c3b	48 8b 5c 24 28	 mov	 rbx, QWORD PTR s0$1$[rsp]
  00c40	48 85 db	 test	 rbx, rbx
  00c43	74 08		 je	 SHORT $LN1@Py_dg_dtoa

; 2982 :         _Py_dg_freedtoa(s0);

  00c45	48 8b cb	 mov	 rcx, rbx
  00c48	e8 00 00 00 00	 call	 _Py_dg_freedtoa
$LN1@Py_dg_dtoa:

; 2983 :     return NULL;

  00c4d	33 c0		 xor	 eax, eax
$LN263@Py_dg_dtoa:
  00c4f	0f 28 b4 24 80
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+128]
  00c57	4c 8b bc 24 98
	00 00 00	 mov	 r15, QWORD PTR [rsp+152]
  00c5f	4c 8b b4 24 a0
	00 00 00	 mov	 r14, QWORD PTR [rsp+160]
  00c67	4c 8b ac 24 a8
	00 00 00	 mov	 r13, QWORD PTR [rsp+168]
  00c6f	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+176]
$LN258@Py_dg_dtoa:
  00c77	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]

; 2984 : }

  00c7c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00c83	41 5c		 pop	 r12
  00c85	5f		 pop	 rdi
  00c86	5d		 pop	 rbp
  00c87	5b		 pop	 rbx
  00c88	c3		 ret	 0
$LN192@Py_dg_dtoa:

; 2869 :                 if (dig == '9')

  00c89	83 fb 39	 cmp	 ebx, 57			; 00000039H
  00c8c	0f 84 a4 00 00
	00		 je	 $round_9_up$21299

; 2870 :                     goto round_9_up;
; 2871 :                 if (j > 0)

  00c92	45 85 ff	 test	 r15d, r15d
  00c95	7e 02		 jle	 SHORT $LN269@Py_dg_dtoa

; 2872 :                     dig++;

  00c97	ff c3		 inc	 ebx
$accept_dig$21304:
$LN269@Py_dg_dtoa:

; 2899 :                     goto roundoff;
; 2900 :                 }
; 2901 :                 *s++ = dig + 1;

  00c99	88 1f		 mov	 BYTE PTR [rdi], bl
$LN272@Py_dg_dtoa:
  00c9b	48 ff c7	 inc	 rdi
$LN232@Py_dg_dtoa:

; 2673 :         k = k0;

  00c9e	44 8b 74 24 20	 mov	 r14d, DWORD PTR k$1$[rsp]
$LN266@Py_dg_dtoa:
  00ca3	48 8b 5c 24 28	 mov	 rbx, QWORD PTR s0$1$[rsp]
$ret$21274:

; 2957 :     }
; 2958 :   ret:
; 2959 :     Bfree(S);

  00ca8	49 8b cd	 mov	 rcx, r13
  00cab	e8 00 00 00 00	 call	 Bfree

; 2960 :     if (mhi) {

  00cb0	48 85 ed	 test	 rbp, rbp
  00cb3	0f 84 7d f9 ff
	ff		 je	 $ret1$21197

; 2961 :         if (mlo && mlo != mhi)

  00cb9	4d 85 e4	 test	 r12, r12
  00cbc	74 0d		 je	 SHORT $LN7@Py_dg_dtoa
  00cbe	4c 3b e5	 cmp	 r12, rbp
  00cc1	74 08		 je	 SHORT $LN7@Py_dg_dtoa

; 2962 :             Bfree(mlo);

  00cc3	49 8b cc	 mov	 rcx, r12
  00cc6	e8 00 00 00 00	 call	 Bfree
$LN7@Py_dg_dtoa:

; 2963 :         Bfree(mhi);

  00ccb	48 8b cd	 mov	 rcx, rbp
  00cce	e8 00 00 00 00	 call	 Bfree

; 2981 :     if (s0)

  00cd3	e9 5e f9 ff ff	 jmp	 $ret1$21197
$LN194@Py_dg_dtoa:

; 2896 :                 if (dig == '9') { /* possible if i == 1 */

  00cd8	83 fb 39	 cmp	 ebx, 57			; 00000039H
  00cdb	74 59		 je	 SHORT $round_9_up$21299

; 2899 :                     goto roundoff;
; 2900 :                 }
; 2901 :                 *s++ = dig + 1;

  00cdd	fe c3		 inc	 bl

; 2902 :                 goto ret;

  00cdf	eb b8		 jmp	 SHORT $LN269@Py_dg_dtoa
$LN39@Py_dg_dtoa:

; 2879 :                 if (!b->x[0] && b->wds <= 1) {

  00ce1	83 7e 18 00	 cmp	 DWORD PTR [rsi+24], 0
  00ce5	75 06		 jne	 SHORT $LN38@Py_dg_dtoa
  00ce7	83 7e 14 01	 cmp	 DWORD PTR [rsi+20], 1
  00ceb	7e ac		 jle	 SHORT $LN269@Py_dg_dtoa
$LN38@Py_dg_dtoa:

; 2880 :                     goto accept_dig;
; 2881 :                 }
; 2882 :                 if (j1 > 0) {

  00ced	45 85 f6	 test	 r14d, r14d
  00cf0	7e a7		 jle	 SHORT $LN269@Py_dg_dtoa

; 2883 :                     b = lshift(b, 1);

  00cf2	ba 01 00 00 00	 mov	 edx, 1
  00cf7	48 8b ce	 mov	 rcx, rsi
  00cfa	e8 00 00 00 00	 call	 lshift
  00cff	48 8b f0	 mov	 rsi, rax

; 2884 :                     if (b == NULL)

  00d02	48 85 c0	 test	 rax, rax
  00d05	0f 84 f7 fe ff
	ff		 je	 $failed_malloc$21141

; 2885 :                         goto failed_malloc;
; 2886 :                     j1 = cmp(b, S);

  00d0b	49 8b d5	 mov	 rdx, r13
  00d0e	48 8b c8	 mov	 rcx, rax
  00d11	e8 00 00 00 00	 call	 cmp

; 2887 :                     if ((j1 > 0 || (j1 == 0 && dig & 1))
; 2888 :                         && dig++ == '9')

  00d16	85 c0		 test	 eax, eax
  00d18	7f 0f		 jg	 SHORT $LN34@Py_dg_dtoa
  00d1a	0f 85 79 ff ff
	ff		 jne	 $LN269@Py_dg_dtoa
  00d20	f6 c3 01	 test	 bl, 1
  00d23	0f 84 70 ff ff
	ff		 je	 $LN269@Py_dg_dtoa
$LN34@Py_dg_dtoa:
  00d29	8b c3		 mov	 eax, ebx
  00d2b	ff c3		 inc	 ebx
  00d2d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00d30	0f 85 63 ff ff
	ff		 jne	 $LN269@Py_dg_dtoa
$round_9_up$21299:

; 2897 :                   round_9_up:
; 2898 :                     *s++ = '9';

  00d36	c6 07 39	 mov	 BYTE PTR [rdi], 57	; 00000039H
  00d39	48 ff c7	 inc	 rdi
$roundoff$21312:

; 2945 :       roundoff:
; 2946 :         while(*--s == '9')

  00d3c	48 8b 5c 24 28	 mov	 rbx, QWORD PTR s0$1$[rsp]
  00d41	48 ff cf	 dec	 rdi
  00d44	80 3f 39	 cmp	 BYTE PTR [rdi], 57	; 00000039H
  00d47	75 18		 jne	 SHORT $LN13@Py_dg_dtoa
  00d49	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@Py_dg_dtoa:

; 2947 :             if (s == s0) {

  00d50	48 3b fb	 cmp	 rdi, rbx
  00d53	0f 84 a7 00 00
	00		 je	 $LN203@Py_dg_dtoa

; 2945 :       roundoff:
; 2946 :         while(*--s == '9')

  00d59	48 ff cf	 dec	 rdi
  00d5c	80 3f 39	 cmp	 BYTE PTR [rdi], 57	; 00000039H
  00d5f	74 ef		 je	 SHORT $LL14@Py_dg_dtoa
$LN13@Py_dg_dtoa:

; 2951 :             }
; 2952 :         ++*s++;

  00d61	fe 07		 inc	 BYTE PTR [rdi]
  00d63	44 8b 74 24 20	 mov	 r14d, DWORD PTR k$1$[rsp]
  00d68	48 ff c7	 inc	 rdi
  00d6b	e9 38 ff ff ff	 jmp	 $ret$21274
$LN53@Py_dg_dtoa:

; 2921 :                     goto failed_malloc;
; 2922 :             }
; 2923 :         }
; 2924 :     }
; 2925 :     else
; 2926 :         for(i = 1;; i++) {

  00d70	44 8b f3	 mov	 r14d, ebx
$LL23@Py_dg_dtoa:

; 2927 :             *s++ = dig = quorem(b,S) + '0';

  00d73	49 8b d5	 mov	 rdx, r13
  00d76	48 8b ce	 mov	 rcx, rsi
  00d79	e8 00 00 00 00	 call	 quorem
  00d7e	48 ff c7	 inc	 rdi
  00d81	8d 58 30	 lea	 ebx, DWORD PTR [rax+48]
  00d84	88 5f ff	 mov	 BYTE PTR [rdi-1], bl

; 2928 :             if (!b->x[0] && b->wds <= 1) {

  00d87	44 39 66 18	 cmp	 DWORD PTR [rsi+24], r12d
  00d8b	75 0a		 jne	 SHORT $LN20@Py_dg_dtoa
  00d8d	83 7e 14 01	 cmp	 DWORD PTR [rsi+20], 1
  00d91	0f 8e 07 ff ff
	ff		 jle	 $LN232@Py_dg_dtoa
$LN20@Py_dg_dtoa:

; 2929 :                 goto ret;
; 2930 :             }
; 2931 :             if (i >= ilim)

  00d97	45 3b f7	 cmp	 r14d, r15d
  00d9a	7d 20		 jge	 SHORT $LN201@Py_dg_dtoa

; 2932 :                 break;
; 2933 :             b = multadd(b, 10, 0);

  00d9c	45 33 c0	 xor	 r8d, r8d
  00d9f	48 8b ce	 mov	 rcx, rsi
  00da2	41 8d 50 0a	 lea	 edx, QWORD PTR [r8+10]
  00da6	e8 00 00 00 00	 call	 multadd
  00dab	48 8b f0	 mov	 rsi, rax

; 2934 :             if (b == NULL)

  00dae	48 85 c0	 test	 rax, rax
  00db1	0f 84 4b fe ff
	ff		 je	 $failed_malloc$21141

; 2921 :                     goto failed_malloc;
; 2922 :             }
; 2923 :         }
; 2924 :     }
; 2925 :     else
; 2926 :         for(i = 1;; i++) {

  00db7	41 ff c6	 inc	 r14d
  00dba	eb b7		 jmp	 SHORT $LL23@Py_dg_dtoa
$LN201@Py_dg_dtoa:

; 2935 :                 goto failed_malloc;
; 2936 :         }
; 2937 : 
; 2938 :     /* Round off last digit */
; 2939 : 
; 2940 :     b = lshift(b, 1);

  00dbc	ba 01 00 00 00	 mov	 edx, 1
  00dc1	48 8b ce	 mov	 rcx, rsi
  00dc4	e8 00 00 00 00	 call	 lshift
  00dc9	48 8b f0	 mov	 rsi, rax

; 2941 :     if (b == NULL)

  00dcc	48 85 c0	 test	 rax, rax
  00dcf	0f 84 2d fe ff
	ff		 je	 $failed_malloc$21141

; 2942 :         goto failed_malloc;
; 2943 :     j = cmp(b, S);

  00dd5	49 8b d5	 mov	 rdx, r13
  00dd8	48 8b c8	 mov	 rcx, rax
  00ddb	e8 00 00 00 00	 call	 cmp

; 2944 :     if (j > 0 || (j == 0 && dig & 1)) {

  00de0	85 c0		 test	 eax, eax
  00de2	0f 8f 54 ff ff
	ff		 jg	 $roundoff$21312
  00de8	75 09		 jne	 SHORT $LL10@Py_dg_dtoa
  00dea	f6 c3 01	 test	 bl, 1
  00ded	0f 85 49 ff ff
	ff		 jne	 $roundoff$21312
$LL10@Py_dg_dtoa:

; 2953 :     }
; 2954 :     else {
; 2955 :         while(*--s == '0');

  00df3	48 ff cf	 dec	 rdi
  00df6	80 3f 30	 cmp	 BYTE PTR [rdi], 48	; 00000030H
  00df9	74 f8		 je	 SHORT $LL10@Py_dg_dtoa

; 2956 :         s++;

  00dfb	e9 9b fe ff ff	 jmp	 $LN272@Py_dg_dtoa
$LN203@Py_dg_dtoa:

; 2948 :                 k++;

  00e00	44 8b 74 24 20	 mov	 r14d, DWORD PTR k$1$[rsp]

; 2949 :                 *s++ = '1';

  00e05	c6 07 31	 mov	 BYTE PTR [rdi], 49	; 00000031H
  00e08	41 ff c6	 inc	 r14d
  00e0b	48 ff c7	 inc	 rdi

; 2950 :                 goto ret;

  00e0e	e9 95 fe ff ff	 jmp	 $ret$21274
  00e13	90		 npad	 1
$LN216@Py_dg_dtoa:

; 2984 : }

  00e14	00 00 00 00	 DD	 $LN143@Py_dg_dtoa
  00e18	00 00 00 00	 DD	 $LN143@Py_dg_dtoa
  00e1c	00 00 00 00	 DD	 $LN142@Py_dg_dtoa
  00e20	00 00 00 00	 DD	 $LN139@Py_dg_dtoa
  00e24	00 00 00 00	 DD	 $LN141@Py_dg_dtoa
  00e28	00 00 00 00	 DD	 $LN138@Py_dg_dtoa
_Py_dg_dtoa ENDP
_TEXT	ENDS
END
