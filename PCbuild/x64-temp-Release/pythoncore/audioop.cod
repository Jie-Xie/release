; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07DAHKDFPB@audioop?$AA@			; `string'
PUBLIC	??_C@_06OJJCNHEL@ratecv?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_09FMFCHLIO@getsample?$AA@			; `string'
PUBLIC	??_C@_08MMNMKAHH@tostereo?$AA@			; `string'
PUBLIC	??_C@_06CBNNKMNN@tomono?$AA@			; `string'
PUBLIC	??_C@_09IDBEIPAH@lin2adpcm?$AA@			; `string'
PUBLIC	??_C@_09JHNCOGNI@adpcm2lin?$AA@			; `string'
PUBLIC	??_C@_07CHCAOHKF@lin2lin?$AA@			; `string'
PUBLIC	??_C@_08CPHOLAP@lin2alaw?$AA@			; `string'
PUBLIC	??_C@_08PICFKELB@alaw2lin?$AA@			; `string'
PUBLIC	??_C@_08JHJHNKEN@lin2ulaw?$AA@			; `string'
PUBLIC	??_C@_08JAJLHMM@ulaw2lin?$AA@			; `string'
PUBLIC	??_C@_04NBAGBPGE@bias?$AA@			; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_03IMIFIBCN@mul?$AA@			; `string'
PUBLIC	??_C@_05HCKPILGO@cross?$AA@			; `string'
PUBLIC	??_C@_0L@IOGIMBLK@findfactor?$AA@		; `string'
PUBLIC	??_C@_07KLIEECAM@findmax?$AA@			; `string'
PUBLIC	??_C@_07NOCDNLLJ@findfit?$AA@			; `string'
PUBLIC	??_C@_03FLJADKLC@rms?$AA@			; `string'
PUBLIC	??_C@_05CGDIEJNA@avgpp?$AA@			; `string'
PUBLIC	??_C@_05ILEAIFPA@maxpp?$AA@			; `string'
PUBLIC	??_C@_03CHOBFJAH@avg?$AA@			; `string'
PUBLIC	??_C@_06OGLEOHCN@minmax?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
;	COMDAT ??_C@_07DAHKDFPB@audioop?$AA@
CONST	SEGMENT
??_C@_07DAHKDFPB@audioop?$AA@ DB 'audioop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJJCNHEL@ratecv?$AA@
CONST	SEGMENT
??_C@_06OJJCNHEL@ratecv?$AA@ DB 'ratecv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMFCHLIO@getsample?$AA@
CONST	SEGMENT
??_C@_09FMFCHLIO@getsample?$AA@ DB 'getsample', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMNMKAHH@tostereo?$AA@
CONST	SEGMENT
??_C@_08MMNMKAHH@tostereo?$AA@ DB 'tostereo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBNNKMNN@tomono?$AA@
CONST	SEGMENT
??_C@_06CBNNKMNN@tomono?$AA@ DB 'tomono', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDBEIPAH@lin2adpcm?$AA@
CONST	SEGMENT
??_C@_09IDBEIPAH@lin2adpcm?$AA@ DB 'lin2adpcm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHNCOGNI@adpcm2lin?$AA@
CONST	SEGMENT
??_C@_09JHNCOGNI@adpcm2lin?$AA@ DB 'adpcm2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHCAOHKF@lin2lin?$AA@
CONST	SEGMENT
??_C@_07CHCAOHKF@lin2lin?$AA@ DB 'lin2lin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPHOLAP@lin2alaw?$AA@
CONST	SEGMENT
??_C@_08CPHOLAP@lin2alaw?$AA@ DB 'lin2alaw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICFKELB@alaw2lin?$AA@
CONST	SEGMENT
??_C@_08PICFKELB@alaw2lin?$AA@ DB 'alaw2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHJHNKEN@lin2ulaw?$AA@
CONST	SEGMENT
??_C@_08JHJHNKEN@lin2ulaw?$AA@ DB 'lin2ulaw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAJLHMM@ulaw2lin?$AA@
CONST	SEGMENT
??_C@_08JAJLHMM@ulaw2lin?$AA@ DB 'ulaw2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBAGBPGE@bias?$AA@
CONST	SEGMENT
??_C@_04NBAGBPGE@bias?$AA@ DB 'bias', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IMIFIBCN@mul?$AA@
CONST	SEGMENT
??_C@_03IMIFIBCN@mul?$AA@ DB 'mul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HCKPILGO@cross?$AA@
CONST	SEGMENT
??_C@_05HCKPILGO@cross?$AA@ DB 'cross', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOGIMBLK@findfactor?$AA@
CONST	SEGMENT
??_C@_0L@IOGIMBLK@findfactor?$AA@ DB 'findfactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLIEECAM@findmax?$AA@
CONST	SEGMENT
??_C@_07KLIEECAM@findmax?$AA@ DB 'findmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NOCDNLLJ@findfit?$AA@
CONST	SEGMENT
??_C@_07NOCDNLLJ@findfit?$AA@ DB 'findfit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLJADKLC@rms?$AA@
CONST	SEGMENT
??_C@_03FLJADKLC@rms?$AA@ DB 'rms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CGDIEJNA@avgpp?$AA@
CONST	SEGMENT
??_C@_05CGDIEJNA@avgpp?$AA@ DB 'avgpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ILEAIFPA@maxpp?$AA@
CONST	SEGMENT
??_C@_05ILEAIFPA@maxpp?$AA@ DB 'maxpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHOBFJAH@avg?$AA@
CONST	SEGMENT
??_C@_03CHOBFJAH@avg?$AA@ DB 'avg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGLEOHCN@minmax?$AA@
CONST	SEGMENT
??_C@_06OGLEOHCN@minmax?$AA@ DB 'minmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
seg_aend DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
seg_uend DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
_st_ulaw2linear16 DW 08284H
	DW	08684H
	DW	08a84H
	DW	08e84H
	DW	09284H
	DW	09684H
	DW	09a84H
	DW	09e84H
	DW	0a284H
	DW	0a684H
	DW	0aa84H
	DW	0ae84H
	DW	0b284H
	DW	0b684H
	DW	0ba84H
	DW	0be84H
	DW	0c184H
	DW	0c384H
	DW	0c584H
	DW	0c784H
	DW	0c984H
	DW	0cb84H
	DW	0cd84H
	DW	0cf84H
	DW	0d184H
	DW	0d384H
	DW	0d584H
	DW	0d784H
	DW	0d984H
	DW	0db84H
	DW	0dd84H
	DW	0df84H
	DW	0e104H
	DW	0e204H
	DW	0e304H
	DW	0e404H
	DW	0e504H
	DW	0e604H
	DW	0e704H
	DW	0e804H
	DW	0e904H
	DW	0ea04H
	DW	0eb04H
	DW	0ec04H
	DW	0ed04H
	DW	0ee04H
	DW	0ef04H
	DW	0f004H
	DW	0f0c4H
	DW	0f144H
	DW	0f1c4H
	DW	0f244H
	DW	0f2c4H
	DW	0f344H
	DW	0f3c4H
	DW	0f444H
	DW	0f4c4H
	DW	0f544H
	DW	0f5c4H
	DW	0f644H
	DW	0f6c4H
	DW	0f744H
	DW	0f7c4H
	DW	0f844H
	DW	0f8a4H
	DW	0f8e4H
	DW	0f924H
	DW	0f964H
	DW	0f9a4H
	DW	0f9e4H
	DW	0fa24H
	DW	0fa64H
	DW	0faa4H
	DW	0fae4H
	DW	0fb24H
	DW	0fb64H
	DW	0fba4H
	DW	0fbe4H
	DW	0fc24H
	DW	0fc64H
	DW	0fc94H
	DW	0fcb4H
	DW	0fcd4H
	DW	0fcf4H
	DW	0fd14H
	DW	0fd34H
	DW	0fd54H
	DW	0fd74H
	DW	0fd94H
	DW	0fdb4H
	DW	0fdd4H
	DW	0fdf4H
	DW	0fe14H
	DW	0fe34H
	DW	0fe54H
	DW	0fe74H
	DW	0fe8cH
	DW	0fe9cH
	DW	0feacH
	DW	0febcH
	DW	0feccH
	DW	0fedcH
	DW	0feecH
	DW	0fefcH
	DW	0ff0cH
	DW	0ff1cH
	DW	0ff2cH
	DW	0ff3cH
	DW	0ff4cH
	DW	0ff5cH
	DW	0ff6cH
	DW	0ff7cH
	DW	0ff88H
	DW	0ff90H
	DW	0ff98H
	DW	0ffa0H
	DW	0ffa8H
	DW	0ffb0H
	DW	0ffb8H
	DW	0ffc0H
	DW	0ffc8H
	DW	0ffd0H
	DW	0ffd8H
	DW	0ffe0H
	DW	0ffe8H
	DW	0fff0H
	DW	0fff8H
	DW	00H
	DW	07d7cH
	DW	0797cH
	DW	0757cH
	DW	0717cH
	DW	06d7cH
	DW	0697cH
	DW	0657cH
	DW	0617cH
	DW	05d7cH
	DW	0597cH
	DW	0557cH
	DW	0517cH
	DW	04d7cH
	DW	0497cH
	DW	0457cH
	DW	0417cH
	DW	03e7cH
	DW	03c7cH
	DW	03a7cH
	DW	0387cH
	DW	0367cH
	DW	0347cH
	DW	0327cH
	DW	0307cH
	DW	02e7cH
	DW	02c7cH
	DW	02a7cH
	DW	0287cH
	DW	0267cH
	DW	0247cH
	DW	0227cH
	DW	0207cH
	DW	01efcH
	DW	01dfcH
	DW	01cfcH
	DW	01bfcH
	DW	01afcH
	DW	019fcH
	DW	018fcH
	DW	017fcH
	DW	016fcH
	DW	015fcH
	DW	014fcH
	DW	013fcH
	DW	012fcH
	DW	011fcH
	DW	010fcH
	DW	0ffcH
	DW	0f3cH
	DW	0ebcH
	DW	0e3cH
	DW	0dbcH
	DW	0d3cH
	DW	0cbcH
	DW	0c3cH
	DW	0bbcH
	DW	0b3cH
	DW	0abcH
	DW	0a3cH
	DW	09bcH
	DW	093cH
	DW	08bcH
	DW	083cH
	DW	07bcH
	DW	075cH
	DW	071cH
	DW	06dcH
	DW	069cH
	DW	065cH
	DW	061cH
	DW	05dcH
	DW	059cH
	DW	055cH
	DW	051cH
	DW	04dcH
	DW	049cH
	DW	045cH
	DW	041cH
	DW	03dcH
	DW	039cH
	DW	036cH
	DW	034cH
	DW	032cH
	DW	030cH
	DW	02ecH
	DW	02ccH
	DW	02acH
	DW	028cH
	DW	026cH
	DW	024cH
	DW	022cH
	DW	020cH
	DW	01ecH
	DW	01ccH
	DW	01acH
	DW	018cH
	DW	0174H
	DW	0164H
	DW	0154H
	DW	0144H
	DW	0134H
	DW	0124H
	DW	0114H
	DW	0104H
	DW	0f4H
	DW	0e4H
	DW	0d4H
	DW	0c4H
	DW	0b4H
	DW	0a4H
	DW	094H
	DW	084H
	DW	078H
	DW	070H
	DW	068H
	DW	060H
	DW	058H
	DW	050H
	DW	048H
	DW	040H
	DW	038H
	DW	030H
	DW	028H
	DW	020H
	DW	018H
	DW	010H
	DW	08H
	DW	00H
_st_alaw2linear16 DW 0ea80H
	DW	0eb80H
	DW	0e880H
	DW	0e980H
	DW	0ee80H
	DW	0ef80H
	DW	0ec80H
	DW	0ed80H
	DW	0e280H
	DW	0e380H
	DW	0e080H
	DW	0e180H
	DW	0e680H
	DW	0e780H
	DW	0e480H
	DW	0e580H
	DW	0f540H
	DW	0f5c0H
	DW	0f440H
	DW	0f4c0H
	DW	0f740H
	DW	0f7c0H
	DW	0f640H
	DW	0f6c0H
	DW	0f140H
	DW	0f1c0H
	DW	0f040H
	DW	0f0c0H
	DW	0f340H
	DW	0f3c0H
	DW	0f240H
	DW	0f2c0H
	DW	0aa00H
	DW	0ae00H
	DW	0a200H
	DW	0a600H
	DW	0ba00H
	DW	0be00H
	DW	0b200H
	DW	0b600H
	DW	08a00H
	DW	08e00H
	DW	08200H
	DW	08600H
	DW	09a00H
	DW	09e00H
	DW	09200H
	DW	09600H
	DW	0d500H
	DW	0d700H
	DW	0d100H
	DW	0d300H
	DW	0dd00H
	DW	0df00H
	DW	0d900H
	DW	0db00H
	DW	0c500H
	DW	0c700H
	DW	0c100H
	DW	0c300H
	DW	0cd00H
	DW	0cf00H
	DW	0c900H
	DW	0cb00H
	DW	0fea8H
	DW	0feb8H
	DW	0fe88H
	DW	0fe98H
	DW	0fee8H
	DW	0fef8H
	DW	0fec8H
	DW	0fed8H
	DW	0fe28H
	DW	0fe38H
	DW	0fe08H
	DW	0fe18H
	DW	0fe68H
	DW	0fe78H
	DW	0fe48H
	DW	0fe58H
	DW	0ffa8H
	DW	0ffb8H
	DW	0ff88H
	DW	0ff98H
	DW	0ffe8H
	DW	0fff8H
	DW	0ffc8H
	DW	0ffd8H
	DW	0ff28H
	DW	0ff38H
	DW	0ff08H
	DW	0ff18H
	DW	0ff68H
	DW	0ff78H
	DW	0ff48H
	DW	0ff58H
	DW	0faa0H
	DW	0fae0H
	DW	0fa20H
	DW	0fa60H
	DW	0fba0H
	DW	0fbe0H
	DW	0fb20H
	DW	0fb60H
	DW	0f8a0H
	DW	0f8e0H
	DW	0f820H
	DW	0f860H
	DW	0f9a0H
	DW	0f9e0H
	DW	0f920H
	DW	0f960H
	DW	0fd50H
	DW	0fd70H
	DW	0fd10H
	DW	0fd30H
	DW	0fdd0H
	DW	0fdf0H
	DW	0fd90H
	DW	0fdb0H
	DW	0fc50H
	DW	0fc70H
	DW	0fc10H
	DW	0fc30H
	DW	0fcd0H
	DW	0fcf0H
	DW	0fc90H
	DW	0fcb0H
	DW	01580H
	DW	01480H
	DW	01780H
	DW	01680H
	DW	01180H
	DW	01080H
	DW	01380H
	DW	01280H
	DW	01d80H
	DW	01c80H
	DW	01f80H
	DW	01e80H
	DW	01980H
	DW	01880H
	DW	01b80H
	DW	01a80H
	DW	0ac0H
	DW	0a40H
	DW	0bc0H
	DW	0b40H
	DW	08c0H
	DW	0840H
	DW	09c0H
	DW	0940H
	DW	0ec0H
	DW	0e40H
	DW	0fc0H
	DW	0f40H
	DW	0cc0H
	DW	0c40H
	DW	0dc0H
	DW	0d40H
	DW	05600H
	DW	05200H
	DW	05e00H
	DW	05a00H
	DW	04600H
	DW	04200H
	DW	04e00H
	DW	04a00H
	DW	07600H
	DW	07200H
	DW	07e00H
	DW	07a00H
	DW	06600H
	DW	06200H
	DW	06e00H
	DW	06a00H
	DW	02b00H
	DW	02900H
	DW	02f00H
	DW	02d00H
	DW	02300H
	DW	02100H
	DW	02700H
	DW	02500H
	DW	03b00H
	DW	03900H
	DW	03f00H
	DW	03d00H
	DW	03300H
	DW	03100H
	DW	03700H
	DW	03500H
	DW	0158H
	DW	0148H
	DW	0178H
	DW	0168H
	DW	0118H
	DW	0108H
	DW	0138H
	DW	0128H
	DW	01d8H
	DW	01c8H
	DW	01f8H
	DW	01e8H
	DW	0198H
	DW	0188H
	DW	01b8H
	DW	01a8H
	DW	058H
	DW	048H
	DW	078H
	DW	068H
	DW	018H
	DW	08H
	DW	038H
	DW	028H
	DW	0d8H
	DW	0c8H
	DW	0f8H
	DW	0e8H
	DW	098H
	DW	088H
	DW	0b8H
	DW	0a8H
	DW	0560H
	DW	0520H
	DW	05e0H
	DW	05a0H
	DW	0460H
	DW	0420H
	DW	04e0H
	DW	04a0H
	DW	0760H
	DW	0720H
	DW	07e0H
	DW	07a0H
	DW	0660H
	DW	0620H
	DW	06e0H
	DW	06a0H
	DW	02b0H
	DW	0290H
	DW	02f0H
	DW	02d0H
	DW	0230H
	DW	0210H
	DW	0270H
	DW	0250H
	DW	03b0H
	DW	0390H
	DW	03f0H
	DW	03d0H
	DW	0330H
	DW	0310H
	DW	0370H
	DW	0350H
indexTable DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	04H
	DD	06H
	DD	08H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	04H
	DD	06H
	DD	08H
stepsizeTable DD 07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	010H
	DD	011H
	DD	013H
	DD	015H
	DD	017H
	DD	019H
	DD	01cH
	DD	01fH
	DD	022H
	DD	025H
	DD	029H
	DD	02dH
	DD	032H
	DD	037H
	DD	03cH
	DD	042H
	DD	049H
	DD	050H
	DD	058H
	DD	061H
	DD	06bH
	DD	076H
	DD	082H
	DD	08fH
	DD	09dH
	DD	0adH
	DD	0beH
	DD	0d1H
	DD	0e6H
	DD	0fdH
	DD	0117H
	DD	0133H
	DD	0151H
	DD	0173H
	DD	0198H
	DD	01c1H
	DD	01eeH
	DD	0220H
	DD	0256H
	DD	0292H
	DD	02d4H
	DD	031cH
	DD	036cH
	DD	03c3H
	DD	0424H
	DD	048eH
	DD	0502H
	DD	0583H
	DD	0610H
	DD	06abH
	DD	0756H
	DD	0812H
	DD	08e0H
	DD	09c3H
	DD	0abdH
	DD	0bd0H
	DD	0cffH
	DD	0e4cH
	DD	0fbaH
	DD	0114cH
	DD	01307H
	DD	014eeH
	DD	01706H
	DD	01954H
	DD	01bdcH
	DD	01ea5H
	DD	021b6H
	DD	02515H
	DD	028caH
	DD	02cdfH
	DD	0315bH
	DD	0364bH
	DD	03bb9H
	DD	041b2H
	DD	04844H
	DD	04f7eH
	DD	05771H
	DD	0602fH
	DD	069ceH
	DD	07462H
	DD	07fffH
	ORG $+12
audioop_methods DQ FLAT:??_C@_03LJAEFNNE@max?$AA@
	DQ	FLAT:audioop_max
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06OGLEOHCN@minmax?$AA@
	DQ	FLAT:audioop_minmax
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03CHOBFJAH@avg?$AA@
	DQ	FLAT:audioop_avg
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05ILEAIFPA@maxpp?$AA@
	DQ	FLAT:audioop_maxpp
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05CGDIEJNA@avgpp?$AA@
	DQ	FLAT:audioop_avgpp
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03FLJADKLC@rms?$AA@
	DQ	FLAT:audioop_rms
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07NOCDNLLJ@findfit?$AA@
	DQ	FLAT:audioop_findfit
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07KLIEECAM@findmax?$AA@
	DQ	FLAT:audioop_findmax
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@IOGIMBLK@findfactor?$AA@
	DQ	FLAT:audioop_findfactor
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05HCKPILGO@cross?$AA@
	DQ	FLAT:audioop_cross
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03IMIFIBCN@mul?$AA@
	DQ	FLAT:audioop_mul
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03BDGOHNNK@add?$AA@
	DQ	FLAT:audioop_add
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04NBAGBPGE@bias?$AA@
	DQ	FLAT:audioop_bias
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08JAJLHMM@ulaw2lin?$AA@
	DQ	FLAT:audioop_ulaw2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08JHJHNKEN@lin2ulaw?$AA@
	DQ	FLAT:audioop_lin2ulaw
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08PICFKELB@alaw2lin?$AA@
	DQ	FLAT:audioop_alaw2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08CPHOLAP@lin2alaw?$AA@
	DQ	FLAT:audioop_lin2alaw
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07CHCAOHKF@lin2lin?$AA@
	DQ	FLAT:audioop_lin2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09JHNCOGNI@adpcm2lin?$AA@
	DQ	FLAT:audioop_adpcm2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09IDBEIPAH@lin2adpcm?$AA@
	DQ	FLAT:audioop_lin2adpcm
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06CBNNKMNN@tomono?$AA@
	DQ	FLAT:audioop_tomono
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MMNMKAHH@tostereo?$AA@
	DQ	FLAT:audioop_tostereo
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09FMFCHLIO@getsample?$AA@
	DQ	FLAT:audioop_getsample
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:audioop_reverse
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06OJJCNHEL@ratecv?$AA@
	DQ	FLAT:audioop_ratecv
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
audioopmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07DAHKDFPB@audioop?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:audioop_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
maxvals	DD	00H
	DD	07fH
	DD	07fffH
	DD	07fffffH
	DD	07fffffffH
	ORG $+4
minvals	DD	00H
	DD	0ffffff80H
	DD	0ffff8000H
	DD	0ff800000H
	DD	080000000H
	ORG $+4
masks	DD	00H
	DD	0ffH
	DD	0ffffH
	DD	0ffffffH
	DD	0ffffffffH
CONST	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
EXTRN	_fltused:DWORD
;	COMDAT __real@3ff0000000000000
; File c:\src\pyparallel\modules\audioop.c
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT fbound
_TEXT	SEGMENT
val$ = 8
minval$ = 16
maxval$ = 24
fbound	PROC						; COMDAT

; 37   :     if (val > maxval)

  00000	66 0f 2f c2	 comisd	 xmm0, xmm2
  00004	66 0f 28 d8	 movapd	 xmm3, xmm0
  00008	76 05		 jbe	 SHORT $LN3@fbound

; 40   :         val = minval;
; 41   :     return val;

  0000a	f2 0f 2c c2	 cvttsd2si eax, xmm2

; 42   : }

  0000e	c3		 ret	 0
$LN3@fbound:

; 38   :         val = maxval;
; 39   :     else if (val < minval + 1)

  0000f	66 0f 28 c1	 movapd	 xmm0, xmm1

; 40   :         val = minval;
; 41   :     return val;

  00013	f2 0f 2c c1	 cvttsd2si eax, xmm1
  00017	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0001f	66 0f 2f c3	 comisd	 xmm0, xmm3
  00023	77 04		 ja	 SHORT $LN1@fbound
  00025	f2 0f 2c c3	 cvttsd2si eax, xmm3
$LN1@fbound:

; 42   : }

  00029	f3 c3		 fatret	 0
fbound	ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT search
_TEXT	SEGMENT
val$ = 8
table$ = 16
size$ = 24
search	PROC						; COMDAT

; 74   :     int i;
; 75   : 
; 76   :     for (i = 0; i < size; i++) {

  00000	45 33 c9	 xor	 r9d, r9d
  00003	45 85 c0	 test	 r8d, r8d
  00006	7e 1c		 jle	 SHORT $LN2@search
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@search:

; 77   :         if (val <= *table++)

  00010	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00013	48 83 c2 02	 add	 rdx, 2
  00017	66 3b c8	 cmp	 cx, ax
  0001a	7e 0d		 jle	 SHORT $LN8@search

; 74   :     int i;
; 75   : 
; 76   :     for (i = 0; i < size; i++) {

  0001c	41 ff c1	 inc	 r9d
  0001f	45 3b c8	 cmp	 r9d, r8d
  00022	7c ec		 jl	 SHORT $LL4@search
$LN2@search:

; 79   :     }
; 80   :     return (size);

  00024	41 0f b7 c0	 movzx	 eax, r8w

; 81   : }

  00028	c3		 ret	 0
$LN8@search:

; 78   :             return (i);

  00029	41 0f b7 c1	 movzx	 eax, r9w

; 81   : }

  0002d	c3		 ret	 0
search	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$st_14linear2ulaw DD imagerel st_14linear2ulaw
	DD	imagerel st_14linear2ulaw+134
	DD	imagerel $unwind$st_14linear2ulaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$st_14linear2ulaw DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT st_14linear2ulaw
_TEXT	SEGMENT
pcm_val$ = 48
st_14linear2ulaw PROC					; COMDAT

; 159  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 0f b7 d1	 movzx	 r10d, cx

; 160  :     PyInt16         mask;
; 161  :     PyInt16         seg;
; 162  :     unsigned char   uval;
; 163  : 
; 164  :     /* The original sox code does this in the calling function, not here */
; 165  :     pcm_val = pcm_val >> 2;

  00008	66 41 c1 fa 02	 sar	 r10w, 2

; 166  : 
; 167  :     /* u-law inverts all bits */
; 168  :     /* Get the sign and the magnitude of the value. */
; 169  :     if (pcm_val < 0) {

  0000d	66 45 85 d2	 test	 r10w, r10w
  00011	79 0c		 jns	 SHORT $LN5@st_14linea

; 170  :         pcm_val = -pcm_val;

  00013	66 41 f7 da	 neg	 r10w

; 171  :         mask = 0x7F;

  00017	41 bb 7f 00 00
	00		 mov	 r11d, 127		; 0000007fH

; 172  :     } else {

  0001d	eb 06		 jmp	 SHORT $LN4@st_14linea
$LN5@st_14linea:

; 173  :         mask = 0xFF;

  0001f	41 bb ff 00 00
	00		 mov	 r11d, 255		; 000000ffH
$LN4@st_14linea:

; 174  :     }
; 175  :     if ( pcm_val > CLIP ) pcm_val = CLIP;           /* clip the magnitude */

  00025	b8 7b 7f 00 00	 mov	 eax, 32635		; 00007f7bH
  0002a	66 44 3b d0	 cmp	 r10w, ax
  0002e	7e 03		 jle	 SHORT $LN3@st_14linea
  00030	44 8b d0	 mov	 r10d, eax
$LN3@st_14linea:

; 176  :     pcm_val += (BIAS >> 2);

  00033	66 41 83 c2 21	 add	 r10w, 33		; 00000021H

; 177  : 
; 178  :     /* Convert the scaled magnitude to segment number. */
; 179  :     seg = search(pcm_val, seg_uend, 8);

  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:seg_uend
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	41 0f b7 ca	 movzx	 ecx, r10w
  00049	e8 00 00 00 00	 call	 search
  0004e	44 0f b7 c0	 movzx	 r8d, ax

; 180  : 
; 181  :     /*
; 182  :      * Combine the sign, segment, quantization bits;
; 183  :      * and complement the code word.
; 184  :      */
; 185  :     if (seg >= 8)           /* out of range, return maximum value. */

  00052	66 83 f8 08	 cmp	 ax, 8
  00056	7c 0c		 jl	 SHORT $LN2@st_14linea

; 186  :         return (unsigned char) (0x7F ^ mask);

  00058	41 0f bf c3	 movsx	 eax, r11w
  0005c	83 f0 7f	 xor	 eax, 127		; 0000007fH

; 190  :     }
; 191  : 
; 192  : }

  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
$LN2@st_14linea:

; 187  :     else {
; 188  :         uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);

  00064	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  00068	41 0f b7 c2	 movzx	 eax, r10w
  0006c	66 d3 f8	 sar	 ax, cl
  0006f	41 0f b6 c8	 movzx	 ecx, r8b
  00073	c0 e1 04	 shl	 cl, 4
  00076	83 e0 0f	 and	 eax, 15
  00079	0b c1		 or	 eax, ecx

; 189  :         return (uval ^ mask);

  0007b	41 0f bf cb	 movsx	 ecx, r11w
  0007f	33 c1		 xor	 eax, ecx

; 190  :     }
; 191  : 
; 192  : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
st_14linear2ulaw ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$st_linear2alaw DD imagerel st_linear2alaw
	DD	imagerel st_linear2alaw+129
	DD	imagerel $unwind$st_linear2alaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$st_linear2alaw DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT st_linear2alaw
_TEXT	SEGMENT
pcm_val$ = 48
st_linear2alaw PROC					; COMDAT

; 256  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	44 0f b7 d1	 movzx	 r10d, cx

; 257  :     PyInt16         mask;
; 258  :     short           seg;
; 259  :     unsigned char   aval;
; 260  : 
; 261  :     /* The original sox code does this in the calling function, not here */
; 262  :     pcm_val = pcm_val >> 3;

  00008	66 41 c1 fa 03	 sar	 r10w, 3

; 263  : 
; 264  :     /* A-law using even bit inversion */
; 265  :     if (pcm_val >= 0) {

  0000d	66 45 85 d2	 test	 r10w, r10w
  00011	78 08		 js	 SHORT $LN6@st_linear2

; 266  :         mask = 0xD5;            /* sign (7th) bit = 1 */

  00013	41 bb d5 00 00
	00		 mov	 r11d, 213		; 000000d5H

; 267  :     } else {

  00019	eb 11		 jmp	 SHORT $LN5@st_linear2
$LN6@st_linear2:

; 268  :         mask = 0x55;            /* sign bit = 0 */
; 269  :         pcm_val = -pcm_val - 1;

  0001b	83 c8 ff	 or	 eax, -1
  0001e	41 bb 55 00 00
	00		 mov	 r11d, 85		; 00000055H
  00024	66 41 2b c2	 sub	 ax, r10w
  00028	44 0f b7 d0	 movzx	 r10d, ax
$LN5@st_linear2:

; 270  :     }
; 271  : 
; 272  :     /* Convert the scaled magnitude to segment number. */
; 273  :     seg = search(pcm_val, seg_aend, 8);

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:seg_aend
  00033	41 b8 08 00 00
	00		 mov	 r8d, 8
  00039	41 0f b7 ca	 movzx	 ecx, r10w
  0003d	e8 00 00 00 00	 call	 search
  00042	0f b7 c8	 movzx	 ecx, ax

; 274  : 
; 275  :     /* Combine the sign, segment, and quantization bits. */
; 276  : 
; 277  :     if (seg >= 8)           /* out of range, return maximum value. */

  00045	66 41 3b c0	 cmp	 ax, r8w
  00049	7c 0c		 jl	 SHORT $LN4@st_linear2

; 278  :         return (unsigned char) (0x7F ^ mask);

  0004b	41 0f bf c3	 movsx	 eax, r11w
  0004f	83 f0 7f	 xor	 eax, 127		; 0000007fH

; 286  :     }
; 287  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
$LN4@st_linear2:

; 279  :     else {
; 280  :         aval = (unsigned char) seg << SEG_SHIFT;

  00057	0f b6 c1	 movzx	 eax, cl
  0005a	c0 e0 04	 shl	 al, 4

; 281  :         if (seg < 2)

  0005d	66 83 f9 02	 cmp	 cx, 2
  00061	7d 05		 jge	 SHORT $LN2@st_linear2

; 282  :             aval |= (pcm_val >> 1) & QUANT_MASK;

  00063	41 d0 fa	 sar	 r10b, 1

; 283  :         else

  00066	eb 04		 jmp	 SHORT $LN9@st_linear2
$LN2@st_linear2:

; 284  :             aval |= (pcm_val >> seg) & QUANT_MASK;

  00068	66 41 d3 fa	 sar	 r10w, cl
$LN9@st_linear2:
  0006c	41 80 e2 0f	 and	 r10b, 15

; 285  :         return (aval ^ mask);

  00070	41 0f bf cb	 movsx	 ecx, r11w
  00074	41 0a c2	 or	 al, r10b
  00077	0f b6 c0	 movzx	 eax, al
  0007a	33 c1		 xor	 eax, ecx

; 286  :     }
; 287  : }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	c3		 ret	 0
st_linear2alaw ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
_BSS	SEGMENT
AudioopError DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_check_size DD imagerel audioop_check_size
	DD	imagerel audioop_check_size+55
	DD	imagerel $unwind$audioop_check_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_check_size DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@
CONST	SEGMENT
??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@ DB 'Size should be'
	DB	' 1, 2 or 4', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_check_size
_TEXT	SEGMENT
size$ = 48
audioop_check_size PROC					; COMDAT

; 318  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 319  :     if (size != 1 && size != 2 && size != 4) {

  00004	83 f9 01	 cmp	 ecx, 1
  00007	74 24		 je	 SHORT $LN2@audioop_ch
  00009	83 f9 02	 cmp	 ecx, 2
  0000c	74 1f		 je	 SHORT $LN2@audioop_ch
  0000e	83 f9 04	 cmp	 ecx, 4
  00011	74 1a		 je	 SHORT $LN2@audioop_ch

; 320  :         PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");

  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@
  00021	e8 00 00 00 00	 call	 PyErr_SetString

; 321  :         return 0;

  00026	33 c0		 xor	 eax, eax

; 325  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN2@audioop_ch:

; 322  :     }
; 323  :     else
; 324  :         return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1

; 325  : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
audioop_check_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_check_parameters DD imagerel audioop_check_parameters
	DD	imagerel audioop_check_parameters+88
	DD	imagerel $unwind$audioop_check_parameters
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_check_parameters DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
CONST	SEGMENT
??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@ DB 'not a whole'
	DB	' number of frames', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_check_parameters
_TEXT	SEGMENT
len$ = 48
size$ = 56
audioop_check_parameters PROC				; COMDAT

; 329  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 da	 movsxd	 rbx, edx
  0000d	48 8b f9	 mov	 rdi, rcx

; 330  :     if (!audioop_check_size(size))

  00010	8b cb		 mov	 ecx, ebx
  00012	e8 00 00 00 00	 call	 audioop_check_size
  00017	85 c0		 test	 eax, eax

; 331  :         return 0;

  00019	74 20		 je	 SHORT $LN5@audioop_ch@2

; 332  :     if (len % size != 0) {

  0001b	48 8b c7	 mov	 rax, rdi
  0001e	48 99		 cdq
  00020	48 f7 fb	 idiv	 rbx
  00023	48 85 d2	 test	 rdx, rdx
  00026	74 20		 je	 SHORT $LN1@audioop_ch@2

; 333  :         PyErr_SetString(AudioopError, "not a whole number of frames");

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  00036	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@audioop_ch@2:

; 334  :         return 0;

  0003b	33 c0		 xor	 eax, eax

; 337  : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
$LN1@audioop_ch@2:

; 335  :     }
; 336  :     return 1;

  00048	b8 01 00 00 00	 mov	 eax, 1

; 337  : }

  0004d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00052	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
audioop_check_parameters ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_getsample DD imagerel audioop_getsample
	DD	imagerel audioop_getsample+229
	DD	imagerel $unwind$audioop_getsample
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_getsample DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@ DB 'Index out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@
CONST	SEGMENT
??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@ DB 's#in:getsample', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_getsample
_TEXT	SEGMENT
len$ = 48
i$ = 56
self$ = 80
args$ = 88
size$ = 96
cp$ = 104
audioop_getsample PROC					; COMDAT

; 341  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 342  :     signed char *cp;
; 343  :     Py_ssize_t len, i;
; 344  :     int size, val = 0;
; 345  : 
; 346  :     if ( !PyArg_ParseTuple(args, "s#in:getsample", &cp, &len, &size, &i) )

  00009	48 8d 4c 24 38	 lea	 rcx, QWORD PTR i$[rsp]
  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00018	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0001d	4c 8d 44 24 68	 lea	 r8, QWORD PTR cp$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@
  0002e	48 8b c8	 mov	 rcx, rax
  00031	33 db		 xor	 ebx, ebx
  00033	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00038	85 c0		 test	 eax, eax

; 347  :         return 0;

  0003a	0f 84 9d 00 00
	00		 je	 $LN12@audioop_ge

; 348  :     if (!audioop_check_parameters(len, size))

  00040	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  00049	e8 00 00 00 00	 call	 audioop_check_parameters
  0004e	85 c0		 test	 eax, eax

; 349  :         return NULL;

  00050	0f 84 87 00 00
	00		 je	 $LN12@audioop_ge

; 350  :     if ( i < 0 || i >= len/size ) {

  00056	4c 8b 44 24 38	 mov	 r8, QWORD PTR i$[rsp]
  0005b	4d 85 c0	 test	 r8, r8
  0005e	78 6a		 js	 SHORT $LN6@audioop_ge
  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00065	4c 63 4c 24 60	 movsxd	 r9, DWORD PTR size$[rsp]
  0006a	48 99		 cdq
  0006c	49 f7 f9	 idiv	 r9
  0006f	4c 3b c0	 cmp	 r8, rax
  00072	7d 56		 jge	 SHORT $LN6@audioop_ge

; 353  :     }
; 354  :     if ( size == 1 )      val = (int)*CHARP(cp, i);

  00074	41 83 f9 01	 cmp	 r9d, 1
  00078	75 17		 jne	 SHORT $LN5@audioop_ge
  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR cp$[rsp]
  0007f	42 0f be 1c 00	 movsx	 ebx, BYTE PTR [rax+r8]

; 357  :     return PyLong_FromLong(val);

  00084	8b cb		 mov	 ecx, ebx
  00086	e8 00 00 00 00	 call	 PyLong_FromLong

; 358  : }

  0008b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008f	5b		 pop	 rbx
  00090	c3		 ret	 0
$LN5@audioop_ge:

; 355  :     else if ( size == 2 ) val = (int)*SHORTP(cp, i*2);

  00091	41 83 f9 02	 cmp	 r9d, 2
  00095	75 17		 jne	 SHORT $LN3@audioop_ge
  00097	48 8b 44 24 68	 mov	 rax, QWORD PTR cp$[rsp]
  0009c	42 0f bf 1c 40	 movsx	 ebx, WORD PTR [rax+r8*2]

; 357  :     return PyLong_FromLong(val);

  000a1	8b cb		 mov	 ecx, ebx
  000a3	e8 00 00 00 00	 call	 PyLong_FromLong

; 358  : }

  000a8	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ac	5b		 pop	 rbx
  000ad	c3		 ret	 0
$LN3@audioop_ge:

; 356  :     else if ( size == 4 ) val = (int)*LONGP(cp, i*4);

  000ae	41 83 f9 04	 cmp	 r9d, 4
  000b2	75 09		 jne	 SHORT $LN1@audioop_ge
  000b4	48 8b 44 24 68	 mov	 rax, QWORD PTR cp$[rsp]
  000b9	42 8b 1c 80	 mov	 ebx, DWORD PTR [rax+r8*4]
$LN1@audioop_ge:

; 357  :     return PyLong_FromLong(val);

  000bd	8b cb		 mov	 ecx, ebx
  000bf	e8 00 00 00 00	 call	 PyLong_FromLong

; 358  : }

  000c4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c8	5b		 pop	 rbx
  000c9	c3		 ret	 0
$LN6@audioop_ge:

; 351  :         PyErr_SetString(AudioopError, "Index out of range");

  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
  000d8	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@audioop_ge:

; 352  :         return 0;

  000dd	33 c0		 xor	 eax, eax

; 358  : }

  000df	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000e3	5b		 pop	 rbx
  000e4	c3		 ret	 0
audioop_getsample ENDP
_TEXT	ENDS
PUBLIC	??_C@_07OFICBGGG@s?$CDi?3max?$AA@		; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_max DD imagerel audioop_max
	DD	imagerel audioop_max+183
	DD	imagerel $unwind$audioop_max
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_max DD 040a01H
	DD	0a340aH
	DD	07006720aH
xdata	ENDS
;	COMDAT ??_C@_07OFICBGGG@s?$CDi?3max?$AA@
CONST	SEGMENT
??_C@_07OFICBGGG@s?$CDi?3max?$AA@ DB 's#i:max', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_max
_TEXT	SEGMENT
cp$ = 48
self$ = 80
args$ = 88
size$ = 96
len$ = 104
audioop_max PROC					; COMDAT

; 362  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b c2	 mov	 rax, rdx

; 363  :     signed char *cp;
; 364  :     Py_ssize_t len, i;
; 365  :     int size, val = 0;
; 366  :     unsigned int absval, max = 0;
; 367  : 
; 368  :     if ( !PyArg_ParseTuple(args, "s#i:max", &cp, &len, &size) )

  0000d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  00012	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  00017	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OFICBGGG@s?$CDi?3max?$AA@
  00028	33 db		 xor	 ebx, ebx
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	8b fb		 mov	 edi, ebx
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax
  00036	75 0d		 jne	 SHORT $LN13@audioop_ma
$LN18@audioop_ma:

; 369  :         return 0;

  00038	33 c0		 xor	 eax, eax

; 381  : }

  0003a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0003f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN13@audioop_ma:

; 370  :     if (!audioop_check_parameters(len, size))

  00045	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00049	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  0004e	e8 00 00 00 00	 call	 audioop_check_parameters
  00053	85 c0		 test	 eax, eax

; 371  :         return NULL;

  00055	74 e1		 je	 SHORT $LN18@audioop_ma

; 372  :     for ( i=0; i<len; i+= size) {

  00057	4c 8b 44 24 68	 mov	 r8, QWORD PTR len$[rsp]
  0005c	4d 85 c0	 test	 r8, r8
  0005f	7e 44		 jle	 SHORT $LN9@audioop_ma
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00066	48 63 54 24 60	 movsxd	 rdx, DWORD PTR size$[rsp]
  0006b	4c 8b c9	 mov	 r9, rcx
  0006e	49 f7 d9	 neg	 r9
$LL11@audioop_ma:

; 373  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00071	83 fa 01	 cmp	 edx, 1
  00074	75 05		 jne	 SHORT $LN8@audioop_ma
  00076	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  00079	eb 11		 jmp	 SHORT $LN4@audioop_ma
$LN8@audioop_ma:

; 374  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0007b	83 fa 02	 cmp	 edx, 2
  0007e	75 05		 jne	 SHORT $LN6@audioop_ma
  00080	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  00083	eb 07		 jmp	 SHORT $LN4@audioop_ma
$LN6@audioop_ma:

; 375  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00085	83 fa 04	 cmp	 edx, 4
  00088	75 02		 jne	 SHORT $LN4@audioop_ma
  0008a	8b 19		 mov	 ebx, DWORD PTR [rcx]
$LN4@audioop_ma:

; 376  :         if (val < 0) absval = (-val);

  0008c	8b c3		 mov	 eax, ebx
  0008e	85 db		 test	 ebx, ebx
  00090	79 02		 jns	 SHORT $LN2@audioop_ma
  00092	f7 d8		 neg	 eax
$LN2@audioop_ma:

; 377  :         else absval = val;
; 378  :         if (absval > max) max = absval;

  00094	3b c7		 cmp	 eax, edi
  00096	0f 47 f8	 cmova	 edi, eax
  00099	48 03 ca	 add	 rcx, rdx
  0009c	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  000a0	49 3b c0	 cmp	 rax, r8
  000a3	7c cc		 jl	 SHORT $LL11@audioop_ma
$LN9@audioop_ma:

; 379  :     }
; 380  :     return PyLong_FromUnsignedLong(max);

  000a5	8b cf		 mov	 ecx, edi
  000a7	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 381  : }

  000ac	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000b1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
audioop_max ENDP
_TEXT	ENDS
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_minmax DD imagerel audioop_minmax
	DD	imagerel audioop_minmax+213
	DD	imagerel $unwind$audioop_minmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_minmax DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
xdata	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ?$AA@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@
CONST	SEGMENT
??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@ DB 's#i:minmax', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_minmax
_TEXT	SEGMENT
cp$ = 48
self$ = 80
args$ = 88
size$ = 96
len$ = 104
audioop_minmax PROC					; COMDAT

; 385  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b c2	 mov	 rax, rdx

; 386  :     signed char *cp;
; 387  :     Py_ssize_t len, i;
; 388  :     int size, val = 0;
; 389  :     /* -1 trick below is needed on Windows to support -0x80000000 without
; 390  :     a warning */
; 391  :     int min = 0x7fffffff, max = -0x7FFFFFFF-1;
; 392  : 
; 393  :     if (!PyArg_ParseTuple(args, "s#i:minmax", &cp, &len, &size))

  00012	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  00017	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  0001c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00021	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@
  0002d	48 8b c8	 mov	 rcx, rax
  00030	33 db		 xor	 ebx, ebx
  00032	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00037	be 00 00 00 80	 mov	 esi, -2147483648	; ffffffff80000000H
  0003c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00041	85 c0		 test	 eax, eax
  00043	75 12		 jne	 SHORT $LN12@audioop_mi
$LN17@audioop_mi:

; 394  :         return NULL;

  00045	33 c0		 xor	 eax, eax

; 405  : }

  00047	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004c	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00051	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN12@audioop_mi:

; 395  :     if (!audioop_check_parameters(len, size))

  00057	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00060	e8 00 00 00 00	 call	 audioop_check_parameters
  00065	85 c0		 test	 eax, eax

; 396  :         return NULL;

  00067	74 dc		 je	 SHORT $LN17@audioop_mi

; 397  :     for (i = 0; i < len; i += size) {

  00069	4c 8b 44 24 68	 mov	 r8, QWORD PTR len$[rsp]
  0006e	4d 85 c0	 test	 r8, r8
  00071	7e 41		 jle	 SHORT $LN8@audioop_mi
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00078	48 63 54 24 60	 movsxd	 rdx, DWORD PTR size$[rsp]
  0007d	4c 8b c9	 mov	 r9, rcx
  00080	49 f7 d9	 neg	 r9
$LL10@audioop_mi:

; 398  :         if (size == 1) val = (int) *CHARP(cp, i);

  00083	83 fa 01	 cmp	 edx, 1
  00086	75 05		 jne	 SHORT $LN7@audioop_mi
  00088	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  0008b	eb 11		 jmp	 SHORT $LN3@audioop_mi
$LN7@audioop_mi:

; 399  :         else if (size == 2) val = (int) *SHORTP(cp, i);

  0008d	83 fa 02	 cmp	 edx, 2
  00090	75 05		 jne	 SHORT $LN5@audioop_mi
  00092	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  00095	eb 07		 jmp	 SHORT $LN3@audioop_mi
$LN5@audioop_mi:

; 400  :         else if (size == 4) val = (int) *LONGP(cp, i);

  00097	83 fa 04	 cmp	 edx, 4
  0009a	75 02		 jne	 SHORT $LN3@audioop_mi
  0009c	8b 19		 mov	 ebx, DWORD PTR [rcx]
$LN3@audioop_mi:

; 401  :         if (val > max) max = val;

  0009e	3b de		 cmp	 ebx, esi
  000a0	0f 4f f3	 cmovg	 esi, ebx

; 402  :         if (val < min) min = val;

  000a3	3b df		 cmp	 ebx, edi
  000a5	0f 4c fb	 cmovl	 edi, ebx
  000a8	48 03 ca	 add	 rcx, rdx
  000ab	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  000af	49 3b c0	 cmp	 rax, r8
  000b2	7c cf		 jl	 SHORT $LL10@audioop_mi
$LN8@audioop_mi:

; 403  :     }
; 404  :     return Py_BuildValue("(ii)", min, max);

  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  000bb	44 8b c6	 mov	 r8d, esi
  000be	8b d7		 mov	 edx, edi
  000c0	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 405  : }

  000c5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ca	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  000cf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d3	5f		 pop	 rdi
  000d4	c3		 ret	 0
audioop_minmax ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@		; `string'
EXTRN	floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_avg DD imagerel audioop_avg
	DD	imagerel audioop_avg+244
	DD	imagerel $unwind$audioop_avg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_avg DD 062d01H
	DD	04682dH
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT ??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@
CONST	SEGMENT
??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@ DB 's#i:avg', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_avg
_TEXT	SEGMENT
cp$ = 48
self$ = 96
args$ = 104
size$ = 112
len$ = 120
audioop_avg PROC					; COMDAT

; 409  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b c2	 mov	 rax, rdx

; 410  :     signed char *cp;
; 411  :     Py_ssize_t len, i;
; 412  :     int size, val = 0;
; 413  :     double avg = 0.0;
; 414  : 
; 415  :     if ( !PyArg_ParseTuple(args, "s#i:avg", &cp, &len, &size) )

  0000d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR size$[rsp]
  00012	4c 8d 4c 24 78	 lea	 r9, QWORD PTR len$[rsp]
  00017	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@
  00028	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  0002d	66 0f 57 f6	 xorpd	 xmm6, xmm6
  00031	33 ff		 xor	 edi, edi
  00033	48 8b c8	 mov	 rcx, rax
  00036	8b df		 mov	 ebx, edi
  00038	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003d	85 c0		 test	 eax, eax
  0003f	75 12		 jne	 SHORT $LN12@audioop_av
$LN18@audioop_av:

; 416  :         return 0;

  00041	33 c0		 xor	 eax, eax

; 430  : }

  00043	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00048	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0004d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN12@audioop_av:

; 417  :     if (!audioop_check_parameters(len, size))

  00053	8b 54 24 70	 mov	 edx, DWORD PTR size$[rsp]
  00057	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  0005c	e8 00 00 00 00	 call	 audioop_check_parameters
  00061	85 c0		 test	 eax, eax

; 418  :         return NULL;

  00063	74 dc		 je	 SHORT $LN18@audioop_av

; 419  :     for ( i=0; i<len; i+= size) {

  00065	4c 8b 44 24 78	 mov	 r8, QWORD PTR len$[rsp]
  0006a	48 63 54 24 70	 movsxd	 rdx, DWORD PTR size$[rsp]
  0006f	4d 85 c0	 test	 r8, r8
  00072	7e 42		 jle	 SHORT $LN17@audioop_av
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00079	4c 8b c9	 mov	 r9, rcx
  0007c	49 f7 d9	 neg	 r9
  0007f	90		 npad	 1
$LL10@audioop_av:

; 420  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00080	83 fa 01	 cmp	 edx, 1
  00083	75 05		 jne	 SHORT $LN7@audioop_av
  00085	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  00088	eb 11		 jmp	 SHORT $LN3@audioop_av
$LN7@audioop_av:

; 421  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0008a	83 fa 02	 cmp	 edx, 2
  0008d	75 05		 jne	 SHORT $LN5@audioop_av
  0008f	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  00092	eb 07		 jmp	 SHORT $LN3@audioop_av
$LN5@audioop_av:

; 422  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00094	83 fa 04	 cmp	 edx, 4
  00097	75 02		 jne	 SHORT $LN3@audioop_av
  00099	8b 19		 mov	 ebx, DWORD PTR [rcx]
$LN3@audioop_av:

; 419  :     for ( i=0; i<len; i+= size) {

  0009b	48 03 ca	 add	 rcx, rdx

; 423  :         avg += val;

  0009e	66 0f 6e c3	 movd	 xmm0, ebx
  000a2	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  000a6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000aa	f2 0f 58 f0	 addsd	 xmm6, xmm0
  000ae	49 3b c0	 cmp	 rax, r8
  000b1	7c cd		 jl	 SHORT $LL10@audioop_av

; 424  :     }
; 425  :     if ( len == 0 )

  000b3	4d 85 c0	 test	 r8, r8
$LN17@audioop_av:
  000b6	74 25		 je	 SHORT $LN1@audioop_av

; 426  :         val = 0;
; 427  :     else
; 428  :         val = (int)floor(avg / (double)(len/size));

  000b8	48 8b ca	 mov	 rcx, rdx
  000bb	49 8b c0	 mov	 rax, r8
  000be	66 0f ef c9	 pxor	 xmm1, xmm1
  000c2	48 99		 cdq
  000c4	48 f7 f9	 idiv	 rcx
  000c7	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000cc	f2 0f 5e f1	 divsd	 xmm6, xmm1
  000d0	66 0f 28 c6	 movapd	 xmm0, xmm6
  000d4	e8 00 00 00 00	 call	 floor
  000d9	f2 0f 2c f8	 cvttsd2si edi, xmm0
$LN1@audioop_av:

; 429  :     return PyLong_FromLong(val);

  000dd	8b cf		 mov	 ecx, edi
  000df	e8 00 00 00 00	 call	 PyLong_FromLong

; 430  : }

  000e4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000e9	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000ee	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
audioop_avg ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HBGHBAA@s?$CDi?3rms?$AA@		; `string'
EXTRN	sqrt:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_rms DD imagerel audioop_rms
	DD	imagerel audioop_rms+249
	DD	imagerel $unwind$audioop_rms
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_rms DD 062d01H
	DD	04682dH
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT ??_C@_07HBGHBAA@s?$CDi?3rms?$AA@
CONST	SEGMENT
??_C@_07HBGHBAA@s?$CDi?3rms?$AA@ DB 's#i:rms', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_rms
_TEXT	SEGMENT
cp$ = 48
self$ = 96
args$ = 104
size$ = 112
len$ = 120
audioop_rms PROC					; COMDAT

; 434  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b c2	 mov	 rax, rdx

; 435  :     signed char *cp;
; 436  :     Py_ssize_t len, i;
; 437  :     int size, val = 0;
; 438  :     unsigned int res;
; 439  :     double sum_squares = 0.0;
; 440  : 
; 441  :     if ( !PyArg_ParseTuple(args, "s#i:rms", &cp, &len, &size) )

  0000d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR size$[rsp]
  00012	4c 8d 4c 24 78	 lea	 r9, QWORD PTR len$[rsp]
  00017	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HBGHBAA@s?$CDi?3rms?$AA@
  00028	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  0002d	66 0f 57 f6	 xorpd	 xmm6, xmm6
  00031	33 ff		 xor	 edi, edi
  00033	48 8b c8	 mov	 rcx, rax
  00036	8b df		 mov	 ebx, edi
  00038	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003d	85 c0		 test	 eax, eax
  0003f	75 12		 jne	 SHORT $LN12@audioop_rm
$LN18@audioop_rm:

; 442  :         return 0;

  00041	33 c0		 xor	 eax, eax

; 456  : }

  00043	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00048	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0004d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN12@audioop_rm:

; 443  :     if (!audioop_check_parameters(len, size))

  00053	8b 54 24 70	 mov	 edx, DWORD PTR size$[rsp]
  00057	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  0005c	e8 00 00 00 00	 call	 audioop_check_parameters
  00061	85 c0		 test	 eax, eax

; 444  :         return NULL;

  00063	74 dc		 je	 SHORT $LN18@audioop_rm

; 445  :     for ( i=0; i<len; i+= size) {

  00065	4c 8b 44 24 78	 mov	 r8, QWORD PTR len$[rsp]
  0006a	48 63 54 24 70	 movsxd	 rdx, DWORD PTR size$[rsp]
  0006f	4d 85 c0	 test	 r8, r8
  00072	7e 46		 jle	 SHORT $LN17@audioop_rm
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00079	4c 8b c9	 mov	 r9, rcx
  0007c	49 f7 d9	 neg	 r9
  0007f	90		 npad	 1
$LL10@audioop_rm:

; 446  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00080	83 fa 01	 cmp	 edx, 1
  00083	75 05		 jne	 SHORT $LN7@audioop_rm
  00085	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  00088	eb 11		 jmp	 SHORT $LN3@audioop_rm
$LN7@audioop_rm:

; 447  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0008a	83 fa 02	 cmp	 edx, 2
  0008d	75 05		 jne	 SHORT $LN5@audioop_rm
  0008f	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  00092	eb 07		 jmp	 SHORT $LN3@audioop_rm
$LN5@audioop_rm:

; 448  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00094	83 fa 04	 cmp	 edx, 4
  00097	75 02		 jne	 SHORT $LN3@audioop_rm
  00099	8b 19		 mov	 ebx, DWORD PTR [rcx]
$LN3@audioop_rm:

; 445  :     for ( i=0; i<len; i+= size) {

  0009b	48 03 ca	 add	 rcx, rdx

; 449  :         sum_squares += (double)val*(double)val;

  0009e	66 0f 6e c3	 movd	 xmm0, ebx
  000a2	49 8d 04 09	 lea	 rax, QWORD PTR [r9+rcx]
  000a6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000aa	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  000ae	f2 0f 58 f0	 addsd	 xmm6, xmm0
  000b2	49 3b c0	 cmp	 rax, r8
  000b5	7c c9		 jl	 SHORT $LL10@audioop_rm

; 450  :     }
; 451  :     if ( len == 0 )

  000b7	4d 85 c0	 test	 r8, r8
$LN17@audioop_rm:
  000ba	74 26		 je	 SHORT $LN1@audioop_rm

; 452  :         res = 0;
; 453  :     else
; 454  :         res = (unsigned int)sqrt(sum_squares / (double)(len/size));

  000bc	48 8b ca	 mov	 rcx, rdx
  000bf	49 8b c0	 mov	 rax, r8
  000c2	66 0f ef c9	 pxor	 xmm1, xmm1
  000c6	48 99		 cdq
  000c8	48 f7 f9	 idiv	 rcx
  000cb	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000d0	f2 0f 5e f1	 divsd	 xmm6, xmm1
  000d4	66 0f 28 c6	 movapd	 xmm0, xmm6
  000d8	e8 00 00 00 00	 call	 sqrt
  000dd	f2 48 0f 2c f8	 cvttsd2si rdi, xmm0
$LN1@audioop_rm:

; 455  :     return PyLong_FromUnsignedLong(res);

  000e2	8b cf		 mov	 ecx, edi
  000e4	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 456  : }

  000e9	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ee	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  000f3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000f7	5f		 pop	 rdi
  000f8	c3		 ret	 0
audioop_rms ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_sum2 DD	imagerel _sum2
	DD	imagerel _sum2+31
	DD	imagerel $unwind$_sum2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_sum2 DD imagerel _sum2+31
	DD	imagerel _sum2+221
	DD	imagerel $chain$0$_sum2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_sum2 DD imagerel _sum2+221
	DD	imagerel _sum2+287
	DD	imagerel $chain$1$_sum2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_sum2 DD 021H
	DD	imagerel _sum2
	DD	imagerel _sum2+31
	DD	imagerel $unwind$_sum2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_sum2 DD 020421H
	DD	03404H
	DD	imagerel _sum2
	DD	imagerel _sum2+31
	DD	imagerel $unwind$_sum2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_sum2 DD 010401H
	DD	0204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT _sum2
_TEXT	SEGMENT
a$ = 16
b$ = 24
len$ = 32
_sum2	PROC						; COMDAT

; 459  : {

  00000	48 83 ec 08	 sub	 rsp, 8

; 460  :     Py_ssize_t i;
; 461  :     double sum = 0.0;

  00004	66 0f 57 db	 xorpd	 xmm3, xmm3

; 462  : 
; 463  :     for( i=0; i<len; i++) {

  00008	45 33 d2	 xor	 r10d, r10d
  0000b	4c 8b c9	 mov	 r9, rcx
  0000e	49 83 f8 04	 cmp	 r8, 4
  00012	0f 8c c5 00 00
	00		 jl	 $LC9@sum2

; 464  :         sum = sum + (double)a[i]*(double)b[i];

  00018	4c 8b d9	 mov	 r11, rcx
  0001b	49 8d 48 fc	 lea	 rcx, QWORD PTR [r8-4]
  0001f	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  00023	48 c1 e9 02	 shr	 rcx, 2
  00027	4c 2b da	 sub	 r11, rdx
  0002a	48 8d 5a 02	 lea	 rbx, QWORD PTR [rdx+2]
  0002e	48 ff c1	 inc	 rcx
  00031	4c 8d 14 8d 00
	00 00 00	 lea	 r10, QWORD PTR [rcx*4]
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@sum2:
  00040	41 0f bf 44 1b
	fe		 movsx	 eax, WORD PTR [r11+rbx-2]
  00046	48 83 c3 08	 add	 rbx, 8
  0004a	48 ff c9	 dec	 rcx
  0004d	66 0f 6e d0	 movd	 xmm2, eax
  00051	0f bf 43 f6	 movsx	 eax, WORD PTR [rbx-10]
  00055	66 0f 6e c0	 movd	 xmm0, eax
  00059	41 0f bf 44 1b
	f8		 movsx	 eax, WORD PTR [r11+rbx-8]
  0005f	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00063	66 0f 6e c8	 movd	 xmm1, eax
  00067	0f bf 43 f8	 movsx	 eax, WORD PTR [rbx-8]
  0006b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006f	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  00073	66 0f 6e c0	 movd	 xmm0, eax
  00077	41 0f bf 44 1b
	fa		 movsx	 eax, WORD PTR [r11+rbx-6]
  0007d	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00081	f2 0f 58 d3	 addsd	 xmm2, xmm3
  00085	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00089	66 0f 28 da	 movapd	 xmm3, xmm2
  0008d	66 0f 6e d0	 movd	 xmm2, eax
  00091	0f bf 43 fa	 movsx	 eax, WORD PTR [rbx-6]
  00095	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00099	66 0f 6e c0	 movd	 xmm0, eax
  0009d	41 0f bf 44 1b
	fc		 movsx	 eax, WORD PTR [r11+rbx-4]
  000a3	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  000a7	f2 0f 58 d9	 addsd	 xmm3, xmm1
  000ab	66 0f 6e c8	 movd	 xmm1, eax
  000af	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000b3	0f bf 43 fc	 movsx	 eax, WORD PTR [rbx-4]
  000b7	f2 0f 59 d0	 mulsd	 xmm2, xmm0
  000bb	66 0f 6e c0	 movd	 xmm0, eax
  000bf	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000c3	f2 0f 58 da	 addsd	 xmm3, xmm2
  000c7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000cb	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000cf	f2 0f 58 d9	 addsd	 xmm3, xmm1
  000d3	0f 85 67 ff ff
	ff		 jne	 $LL10@sum2
  000d9	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LC9@sum2:

; 462  : 
; 463  :     for( i=0; i<len; i++) {

  000dd	4d 3b d0	 cmp	 r10, r8
  000e0	7d 34		 jge	 SHORT $LN11@sum2
  000e2	4c 2b ca	 sub	 r9, rdx
  000e5	4a 8d 0c 52	 lea	 rcx, QWORD PTR [rdx+r10*2]
  000e9	4d 2b c2	 sub	 r8, r10
$LC3@sum2:

; 464  :         sum = sum + (double)a[i]*(double)b[i];

  000ec	42 0f bf 04 09	 movsx	 eax, WORD PTR [rcx+r9]
  000f1	48 83 c1 02	 add	 rcx, 2
  000f5	49 ff c8	 dec	 r8
  000f8	66 0f 6e d0	 movd	 xmm2, eax
  000fc	0f bf 41 fe	 movsx	 eax, WORD PTR [rcx-2]
  00100	66 0f 6e c8	 movd	 xmm1, eax
  00104	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00108	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0010c	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  00110	f2 0f 58 da	 addsd	 xmm3, xmm2
  00114	75 d6		 jne	 SHORT $LC3@sum2
$LN11@sum2:

; 465  :     }
; 466  :     return sum;

  00116	66 0f 28 c3	 movapd	 xmm0, xmm3

; 467  : }

  0011a	48 83 c4 08	 add	 rsp, 8
  0011e	c3		 ret	 0
_sum2	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@ ; `string'
PUBLIC	??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@ ; `string'
PUBLIC	??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findfit DD imagerel audioop_findfit
	DD	imagerel audioop_findfit+154
	DD	imagerel $unwind$audioop_findfit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_findfit DD imagerel audioop_findfit+154
	DD	imagerel audioop_findfit+287
	DD	imagerel $chain$7$audioop_findfit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$audioop_findfit DD imagerel audioop_findfit+287
	DD	imagerel audioop_findfit+417
	DD	imagerel $chain$8$audioop_findfit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$audioop_findfit DD imagerel audioop_findfit+417
	DD	imagerel audioop_findfit+496
	DD	imagerel $chain$9$audioop_findfit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$audioop_findfit DD imagerel audioop_findfit+496
	DD	imagerel audioop_findfit+538
	DD	imagerel $chain$10$audioop_findfit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$audioop_findfit DD 021H
	DD	imagerel audioop_findfit
	DD	imagerel audioop_findfit+154
	DD	imagerel $unwind$audioop_findfit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$audioop_findfit DD 021H
	DD	imagerel audioop_findfit+154
	DD	imagerel audioop_findfit+287
	DD	imagerel $chain$7$audioop_findfit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$audioop_findfit DD 020821H
	DD	0135408H
	DD	imagerel audioop_findfit+154
	DD	imagerel audioop_findfit+287
	DD	imagerel $chain$7$audioop_findfit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_findfit DD 0c2921H
	DD	047829H
	DD	056824H
	DD	0ce417H
	DD	0dd412H
	DD	0ec40dH
	DD	0123408H
	DD	imagerel audioop_findfit
	DD	imagerel audioop_findfit+154
	DD	imagerel $unwind$audioop_findfit
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findfit DD 064f01H
	DD	0f744fH
	DD	010644aH
	DD	011010aH
xdata	ENDS
;	COMDAT ??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
CONST	SEGMENT
??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@ DB 'Strings shou'
	DB	'ld be even-sized', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@
CONST	SEGMENT
??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@ DB '(nf)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@
CONST	SEGMENT
??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@ DB 'First sampl'
	DB	'e should be longer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@
CONST	SEGMENT
??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@ DB 's#s#:findfit', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_findfit
_TEXT	SEGMENT
cp2$ = 48
cp1$ = 56
self$ = 144
args$ = 152
len1$ = 160
len2$ = 168
audioop_findfit PROC					; COMDAT

; 503  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 504  :     short *cp1, *cp2;
; 505  :     Py_ssize_t len1, len2;
; 506  :     Py_ssize_t j, best_j;
; 507  :     double aj_m1, aj_lm1;
; 508  :     double sum_ri_2, sum_aij_2, sum_aij_ri, result, best_result, factor;
; 509  : 
; 510  :     /* Passing a short** for an 's' argument is correct only
; 511  :        if the string contents is aligned for interpretation
; 512  :        as short[]. Due to the definition of PyBytesObject,
; 513  :        this is currently (Python 2.6) the case. */
; 514  :     if ( !PyArg_ParseTuple(args, "s#s#:findfit",
; 515  :                            (char**)&cp1, &len1, (char**)&cp2, &len2) )

  0000a	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000e	48 8b c2	 mov	 rax, rdx
  00011	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00015	49 89 4b a0	 mov	 QWORD PTR [r11-96], rcx
  00019	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0001d	4d 8d 43 b0	 lea	 r8, QWORD PTR [r11-80]
  00021	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax
  00036	75 0a		 jne	 SHORT $LN8@audioop_fi

; 516  :         return 0;

  00038	33 c0		 xor	 eax, eax

; 557  : }

  0003a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00041	c3		 ret	 0
$LN8@audioop_fi:
  00042	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  0004a	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi

; 517  :     if ( len1 & 1 || len2 & 1 ) {

  0004f	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR len1$[rsp]
  00057	40 f6 c7 01	 test	 dil, 1
  0005b	0f 85 8f 01 00
	00		 jne	 $LN6@audioop_fi
  00061	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR len2$[rsp]
  00069	40 f6 c6 01	 test	 sil, 1
  0006d	0f 85 7d 01 00
	00		 jne	 $LN6@audioop_fi

; 520  :     }
; 521  :     len1 >>= 1;

  00073	48 d1 ff	 sar	 rdi, 1

; 522  :     len2 >>= 1;

  00076	48 d1 fe	 sar	 rsi, 1
  00079	48 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR len1$[rsp], rdi
  00081	48 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR len2$[rsp], rsi

; 523  : 
; 524  :     if ( len1 < len2 ) {

  00089	48 3b fe	 cmp	 rdi, rsi
  0008c	7d 0c		 jge	 SHORT $LN5@audioop_fi

; 525  :         PyErr_SetString(AudioopError, "First sample should be longer");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@

; 526  :         return 0;

  00095	e9 5d 01 00 00	 jmp	 $LN15@audioop_fi
$LN5@audioop_fi:
  0009a	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  000a2	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  000a7	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  000ac	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14

; 527  :     }
; 528  :     sum_ri_2 = _sum2(cp2, cp2, len2);

  000b1	4c 8b 74 24 30	 mov	 r14, QWORD PTR cp2$[rsp]
  000b6	4c 8b c6	 mov	 r8, rsi
  000b9	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  000be	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  000c3	49 8b d6	 mov	 rdx, r14
  000c6	49 8b ce	 mov	 rcx, r14
  000c9	e8 00 00 00 00	 call	 _sum2

; 529  :     sum_aij_2 = _sum2(cp1, cp1, len2);

  000ce	4c 8b 6c 24 38	 mov	 r13, QWORD PTR cp1$[rsp]
  000d3	4c 8b c6	 mov	 r8, rsi
  000d6	49 8b d5	 mov	 rdx, r13
  000d9	49 8b cd	 mov	 rcx, r13
  000dc	66 0f 28 f0	 movapd	 xmm6, xmm0
  000e0	e8 00 00 00 00	 call	 _sum2

; 530  :     sum_aij_ri = _sum2(cp1, cp2, len2);

  000e5	4c 8b c6	 mov	 r8, rsi
  000e8	49 8b d6	 mov	 rdx, r14
  000eb	49 8b cd	 mov	 rcx, r13
  000ee	66 0f 28 f8	 movapd	 xmm7, xmm0
  000f2	e8 00 00 00 00	 call	 _sum2

; 531  : 
; 532  :     result = (sum_ri_2*sum_aij_2 - sum_aij_ri*sum_aij_ri) / sum_aij_2;
; 533  : 
; 534  :     best_result = result;
; 535  :     best_j = 0;
; 536  : 
; 537  :     for ( j=1; j<=len1-len2; j++) {

  000f7	bb 01 00 00 00	 mov	 ebx, 1
  000fc	48 2b fe	 sub	 rdi, rsi
  000ff	45 33 e4	 xor	 r12d, r12d
  00102	66 0f 28 ef	 movapd	 xmm5, xmm7
  00106	f2 0f 59 ee	 mulsd	 xmm5, xmm6
  0010a	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0010e	f2 0f 5c e8	 subsd	 xmm5, xmm0
  00112	f2 0f 5e ef	 divsd	 xmm5, xmm7
  00116	48 3b df	 cmp	 rbx, rdi
  00119	0f 8f 82 00 00
	00		 jg	 $LN2@audioop_fi

; 527  :     }
; 528  :     sum_ri_2 = _sum2(cp2, cp2, len2);

  0011f	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  00127	49 8b ed	 mov	 rbp, r13
  0012a	66 0f 1f 44 00
	00		 npad	 6
$LL4@audioop_fi:

; 538  :         aj_m1 = (double)cp1[j-1];

  00130	0f bf 45 00	 movsx	 eax, WORD PTR [rbp]

; 539  :         aj_lm1 = (double)cp1[j+len2-1];
; 540  : 
; 541  :         sum_aij_2 = sum_aij_2 + aj_lm1*aj_lm1 - aj_m1*aj_m1;
; 542  :         sum_aij_ri = _sum2(cp1+j, cp2, len2);

  00134	48 8d 4d 02	 lea	 rcx, QWORD PTR [rbp+2]
  00138	4c 8b c6	 mov	 r8, rsi
  0013b	49 8b d6	 mov	 rdx, r14
  0013e	66 0f 6e c8	 movd	 xmm1, eax
  00142	0f bf 44 75 00	 movsx	 eax, WORD PTR [rbp+rsi*2]
  00147	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0014b	66 0f 6e c0	 movd	 xmm0, eax
  0014f	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00153	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00157	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0015b	f2 0f 58 c7	 addsd	 xmm0, xmm7
  0015f	66 0f 28 f8	 movapd	 xmm7, xmm0
  00163	f2 0f 5c f9	 subsd	 xmm7, xmm1
  00167	e8 00 00 00 00	 call	 _sum2

; 543  : 
; 544  :         result = (sum_ri_2*sum_aij_2 - sum_aij_ri*sum_aij_ri)
; 545  :             / sum_aij_2;

  0016c	66 0f 28 e7	 movapd	 xmm4, xmm7
  00170	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00174	f2 0f 59 e6	 mulsd	 xmm4, xmm6
  00178	f2 0f 5c e0	 subsd	 xmm4, xmm0
  0017c	f2 0f 5e e7	 divsd	 xmm4, xmm7

; 546  : 
; 547  :         if ( result < best_result ) {

  00180	66 0f 2f ec	 comisd	 xmm5, xmm4
  00184	76 07		 jbe	 SHORT $LN3@audioop_fi

; 548  :             best_result = result;

  00186	66 0f 28 ec	 movapd	 xmm5, xmm4

; 549  :             best_j = j;

  0018a	4c 8b e3	 mov	 r12, rbx
$LN3@audioop_fi:

; 531  : 
; 532  :     result = (sum_ri_2*sum_aij_2 - sum_aij_ri*sum_aij_ri) / sum_aij_2;
; 533  : 
; 534  :     best_result = result;
; 535  :     best_j = 0;
; 536  : 
; 537  :     for ( j=1; j<=len1-len2; j++) {

  0018d	48 ff c3	 inc	 rbx
  00190	48 83 c5 02	 add	 rbp, 2
  00194	48 3b df	 cmp	 rbx, rdi
  00197	7e 97		 jle	 SHORT $LL4@audioop_fi
  00199	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
$LN2@audioop_fi:

; 550  :         }
; 551  : 
; 552  :     }
; 553  : 
; 554  :     factor = _sum2(cp1+best_j, cp2, len2) / sum_ri_2;

  001a1	4b 8d 4c 65 00	 lea	 rcx, QWORD PTR [r13+r12*2]
  001a6	4c 8b c6	 mov	 r8, rsi
  001a9	49 8b d6	 mov	 rdx, r14
  001ac	e8 00 00 00 00	 call	 _sum2

; 555  : 
; 556  :     return Py_BuildValue("(nf)", best_j, factor);

  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@
  001b8	49 8b d4	 mov	 rdx, r12
  001bb	f2 0f 5e c6	 divsd	 xmm0, xmm6
  001bf	66 0f 28 d0	 movapd	 xmm2, xmm0
  001c3	66 49 0f 7e d0	 movd	 r8, xmm2
  001c8	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  001cd	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]
  001d2	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  001d7	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  001dc	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  001e1	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  001e6	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  001ee	eb 15		 jmp	 SHORT $LN14@audioop_fi
$LN6@audioop_fi:

; 518  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  001f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
$LN15@audioop_fi:
  001f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  001fe	e8 00 00 00 00	 call	 PyErr_SetString

; 519  :         return 0;

  00203	33 c0		 xor	 eax, eax
$LN14@audioop_fi:
  00205	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0020d	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 557  : }

  00212	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00219	c3		 ret	 0
audioop_findfit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@ ; `string'
PUBLIC	??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@	; `string'
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findfactor DD imagerel audioop_findfactor
	DD	imagerel audioop_findfactor+68
	DD	imagerel $unwind$audioop_findfactor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_findfactor DD imagerel audioop_findfactor+68
	DD	imagerel audioop_findfactor+165
	DD	imagerel $chain$0$audioop_findfactor
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_findfactor DD imagerel audioop_findfactor+165
	DD	imagerel audioop_findfactor+196
	DD	imagerel $chain$2$audioop_findfactor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_findfactor DD 020021H
	DD	083400H
	DD	imagerel audioop_findfactor
	DD	imagerel audioop_findfactor+68
	DD	imagerel $unwind$audioop_findfactor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_findfactor DD 020521H
	DD	083405H
	DD	imagerel audioop_findfactor
	DD	imagerel audioop_findfactor+68
	DD	imagerel $unwind$audioop_findfactor
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findfactor DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@
CONST	SEGMENT
??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@ DB 'Samples shoul'
	DB	'd be same size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@
CONST	SEGMENT
??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@ DB 's#s#:findfactor', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_findfactor
_TEXT	SEGMENT
cp2$ = 48
cp1$ = 56
self$ = 80
args$ = 88
len2$ = 96
len1$ = 104
audioop_findfactor PROC					; COMDAT

; 565  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 566  :     short *cp1, *cp2;
; 567  :     Py_ssize_t len1, len2;
; 568  :     double sum_ri_2, sum_aij_ri, result;
; 569  : 
; 570  :     if ( !PyArg_ParseTuple(args, "s#s#:findfactor",
; 571  :                            (char**)&cp1, &len1, (char**)&cp2, &len2) )

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR len2$[rsp]
  0000c	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len1$[rsp]
  00011	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00016	48 8d 4c 24 30	 lea	 rcx, QWORD PTR cp2$[rsp]
  0001b	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp1$[rsp]
  00020	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN4@audioop_fi@2

; 572  :         return 0;

  00038	33 c0		 xor	 eax, eax

; 588  : }

  0003a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003e	c3		 ret	 0
$LN4@audioop_fi@2:

; 573  :     if ( len1 & 1 || len2 & 1 ) {

  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR len1$[rsp]
  00044	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00049	a8 01		 test	 al, 1
  0004b	75 58		 jne	 SHORT $LN2@audioop_fi@2
  0004d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR len2$[rsp]
  00052	f6 c3 01	 test	 bl, 1
  00055	75 4e		 jne	 SHORT $LN2@audioop_fi@2

; 576  :     }
; 577  :     if ( len1 != len2 ) {

  00057	48 3b c3	 cmp	 rax, rbx
  0005a	74 09		 je	 SHORT $LN1@audioop_fi@2

; 578  :         PyErr_SetString(AudioopError, "Samples should be same size");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@

; 579  :         return 0;

  00063	eb 47		 jmp	 SHORT $LN8@audioop_fi@2
$LN1@audioop_fi@2:

; 580  :     }
; 581  :     len2 >>= 1;
; 582  :     sum_ri_2 = _sum2(cp2, cp2, len2);
; 583  :     sum_aij_ri = _sum2(cp1, cp2, len2);

  00065	48 8b 54 24 30	 mov	 rdx, QWORD PTR cp2$[rsp]
  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp1$[rsp]
  0006f	48 d1 fb	 sar	 rbx, 1
  00072	4c 8b c3	 mov	 r8, rbx
  00075	48 89 5c 24 60	 mov	 QWORD PTR len2$[rsp], rbx
  0007a	e8 00 00 00 00	 call	 _sum2
  0007f	4c 8b c3	 mov	 r8, rbx
  00082	48 8b ca	 mov	 rcx, rdx
  00085	66 0f 28 e0	 movapd	 xmm4, xmm0
  00089	e8 00 00 00 00	 call	 _sum2

; 584  : 
; 585  :     result = sum_aij_ri / sum_ri_2;

  0008e	f2 0f 5e e0	 divsd	 xmm4, xmm0

; 586  : 
; 587  :     return PyFloat_FromDouble(result);

  00092	66 0f 28 c4	 movapd	 xmm0, xmm4
  00096	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0009b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 588  : }

  000a0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a4	c3		 ret	 0
$LN2@audioop_fi@2:

; 574  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
$LN8@audioop_fi@2:
  000ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000b3	e8 00 00 00 00	 call	 PyErr_SetString
  000b8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 575  :         return 0;

  000bd	33 c0		 xor	 eax, eax

; 588  : }

  000bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c3	c3		 ret	 0
audioop_findfactor ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@ ; `string'
PUBLIC	??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@		; `string'
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findmax DD imagerel audioop_findmax
	DD	imagerel audioop_findmax+53
	DD	imagerel $unwind$audioop_findmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_findmax DD imagerel audioop_findmax+53
	DD	imagerel audioop_findmax+99
	DD	imagerel $chain$0$audioop_findmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_findmax DD imagerel audioop_findmax+99
	DD	imagerel audioop_findmax+185
	DD	imagerel $chain$4$audioop_findmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_findmax DD imagerel audioop_findmax+185
	DD	imagerel audioop_findmax+489
	DD	imagerel $chain$6$audioop_findmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_findmax DD imagerel audioop_findmax+489
	DD	imagerel audioop_findmax+594
	DD	imagerel $chain$7$audioop_findmax
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$audioop_findmax DD imagerel audioop_findmax+594
	DD	imagerel audioop_findmax+630
	DD	imagerel $chain$9$audioop_findmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$audioop_findmax DD 040021H
	DD	097400H
	DD	0c3400H
	DD	imagerel audioop_findmax
	DD	imagerel audioop_findmax+53
	DD	imagerel $unwind$audioop_findmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_findmax DD 021H
	DD	imagerel audioop_findmax+99
	DD	imagerel audioop_findmax+185
	DD	imagerel $chain$4$audioop_findmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_findmax DD 041521H
	DD	08c415H
	DD	0d5405H
	DD	imagerel audioop_findmax+99
	DD	imagerel audioop_findmax+185
	DD	imagerel $chain$4$audioop_findmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_findmax DD 062921H
	DD	0a6429H
	DD	097408H
	DD	0c3400H
	DD	imagerel audioop_findmax
	DD	imagerel audioop_findmax+53
	DD	imagerel $unwind$audioop_findmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_findmax DD 020521H
	DD	0c3405H
	DD	imagerel audioop_findmax
	DD	imagerel audioop_findmax+53
	DD	imagerel $unwind$audioop_findmax
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findmax DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@
CONST	SEGMENT
??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@ DB 'Input sampl'
	DB	'e should be longer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@
CONST	SEGMENT
??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@ DB 's#n:findmax', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_findmax
_TEXT	SEGMENT
cp1$ = 48
self$ = 96
args$ = 104
len1$ = 112
len2$ = 120
audioop_findmax PROC					; COMDAT

; 596  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b c2	 mov	 rax, rdx

; 597  :     short *cp1;
; 598  :     Py_ssize_t len1, len2;
; 599  :     Py_ssize_t j, best_j;
; 600  :     double aj_m1, aj_lm1;
; 601  :     double result, best_result;
; 602  : 
; 603  :     if ( !PyArg_ParseTuple(args, "s#n:findmax",
; 604  :                            (char**)&cp1, &len1, &len2) )

  00007	48 8d 4c 24 78	 lea	 rcx, QWORD PTR len2$[rsp]
  0000c	4c 8d 4c 24 70	 lea	 r9, QWORD PTR len1$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp1$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN8@audioop_fi@3

; 605  :         return 0;

  0002e	33 c0		 xor	 eax, eax

; 636  : }

  00030	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00034	c3		 ret	 0
$LN8@audioop_fi@3:
  00035	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx

; 606  :     if ( len1 & 1 ) {

  0003a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR len1$[rsp]
  0003f	f6 c3 01	 test	 bl, 1
  00042	74 1f		 je	 SHORT $LN7@audioop_fi@3

; 607  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
  00052	e8 00 00 00 00	 call	 PyErr_SetString
  00057	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 608  :         return 0;

  0005c	33 c0		 xor	 eax, eax

; 636  : }

  0005e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00062	c3		 ret	 0
$LN7@audioop_fi@3:

; 609  :     }
; 610  :     len1 >>= 1;

  00063	48 d1 fb	 sar	 rbx, 1
  00066	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 611  : 
; 612  :     if ( len2 < 0 || len1 < len2 ) {

  0006b	48 8b 7c 24 78	 mov	 rdi, QWORD PTR len2$[rsp]
  00070	48 89 5c 24 70	 mov	 QWORD PTR len1$[rsp], rbx
  00075	48 85 ff	 test	 rdi, rdi
  00078	0f 88 d4 01 00
	00		 js	 $LN5@audioop_fi@3
  0007e	48 3b df	 cmp	 rbx, rdi
  00081	0f 8c cb 01 00
	00		 jl	 $LN5@audioop_fi@3

; 615  :     }
; 616  : 
; 617  :     result = _sum2(cp1, cp1, len2);

  00087	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0008c	48 8b 74 24 30	 mov	 rsi, QWORD PTR cp1$[rsp]
  00091	4c 8b c7	 mov	 r8, rdi
  00094	48 8b d6	 mov	 rdx, rsi
  00097	48 8b ce	 mov	 rcx, rsi
  0009a	e8 00 00 00 00	 call	 _sum2

; 618  : 
; 619  :     best_result = result;
; 620  :     best_j = 0;

  0009f	33 c9		 xor	 ecx, ecx

; 621  : 
; 622  :     for ( j=1; j<=len1-len2; j++) {

  000a1	48 2b df	 sub	 rbx, rdi
  000a4	8d 51 01	 lea	 edx, QWORD PTR [rcx+1]
  000a7	66 0f 28 e0	 movapd	 xmm4, xmm0
  000ab	66 0f 28 e8	 movapd	 xmm5, xmm0
  000af	48 83 fb 04	 cmp	 rbx, 4
  000b3	0f 8c 30 01 00
	00		 jl	 $LC14@audioop_fi@3

; 615  :     }
; 616  : 
; 617  :     result = _sum2(cp1, cp1, len2);

  000b9	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  000be	49 c7 c2 fe ff
	ff ff		 mov	 r10, -2
  000c5	48 8d 04 3f	 lea	 rax, QWORD PTR [rdi+rdi]
  000c9	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  000ce	4d 8b da	 mov	 r11, r10
  000d1	48 8b ef	 mov	 rbp, rdi
  000d4	41 bc 02 00 00
	00		 mov	 r12d, 2
  000da	4c 2b df	 sub	 r11, rdi
  000dd	48 f7 dd	 neg	 rbp
  000e0	4c 2b e0	 sub	 r12, rax
  000e3	4c 8d 4b fd	 lea	 r9, QWORD PTR [rbx-3]
  000e7	4c 8d 44 7e 04	 lea	 r8, QWORD PTR [rsi+rdi*2+4]
  000ec	4c 2b d0	 sub	 r10, rax
  000ef	90		 npad	 1

; 621  : 
; 622  :     for ( j=1; j<=len1-len2; j++) {

$LL19@audioop_fi@3:

; 623  :         aj_m1 = (double)cp1[j-1];

  000f0	43 0f bf 04 58	 movsx	 eax, WORD PTR [r8+r11*2]
  000f5	66 0f 6e c0	 movd	 xmm0, eax

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  000f9	41 0f bf 40 fc	 movsx	 eax, WORD PTR [r8-4]
  000fe	66 0f 6e c8	 movd	 xmm1, eax
  00102	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  00106	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  0010a	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0010e	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00112	f2 0f 58 cc	 addsd	 xmm1, xmm4
  00116	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 627  : 
; 628  :         if ( result > best_result ) {

  0011a	66 0f 2f cd	 comisd	 xmm1, xmm5
  0011e	76 07		 jbe	 SHORT $LN15@audioop_fi@3

; 629  :             best_result = result;

  00120	66 0f 28 e9	 movapd	 xmm5, xmm1

; 630  :             best_j = j;

  00124	48 8b ca	 mov	 rcx, rdx
$LN15@audioop_fi@3:

; 623  :         aj_m1 = (double)cp1[j-1];

  00127	43 0f bf 04 02	 movsx	 eax, WORD PTR [r10+r8]
  0012c	66 0f 6e c0	 movd	 xmm0, eax

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  00130	41 0f bf 40 fe	 movsx	 eax, WORD PTR [r8-2]
  00135	66 0f 6e d0	 movd	 xmm2, eax
  00139	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  0013d	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00141	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00145	f2 0f 59 d2	 mulsd	 xmm2, xmm2
  00149	f2 0f 58 d1	 addsd	 xmm2, xmm1
  0014d	f2 0f 5c d0	 subsd	 xmm2, xmm0

; 627  : 
; 628  :         if ( result > best_result ) {

  00151	66 0f 2f d5	 comisd	 xmm2, xmm5
  00155	76 08		 jbe	 SHORT $LN16@audioop_fi@3

; 629  :             best_result = result;

  00157	66 0f 28 ea	 movapd	 xmm5, xmm2
  0015b	48 8d 4a 01	 lea	 rcx, QWORD PTR [rdx+1]
$LN16@audioop_fi@3:

; 623  :         aj_m1 = (double)cp1[j-1];

  0015f	41 0f bf 04 68	 movsx	 eax, WORD PTR [r8+rbp*2]
  00164	66 0f 6e c0	 movd	 xmm0, eax

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  00168	41 0f bf 00	 movsx	 eax, WORD PTR [r8]
  0016c	66 0f 6e c8	 movd	 xmm1, eax
  00170	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  00174	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00178	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0017c	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  00180	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00184	f2 0f 5c c8	 subsd	 xmm1, xmm0

; 627  : 
; 628  :         if ( result > best_result ) {

  00188	66 0f 2f cd	 comisd	 xmm1, xmm5
  0018c	76 08		 jbe	 SHORT $LN17@audioop_fi@3

; 629  :             best_result = result;

  0018e	66 0f 28 e9	 movapd	 xmm5, xmm1
  00192	48 8d 4a 02	 lea	 rcx, QWORD PTR [rdx+2]
$LN17@audioop_fi@3:

; 623  :         aj_m1 = (double)cp1[j-1];

  00196	43 0f bf 04 04	 movsx	 eax, WORD PTR [r12+r8]
  0019b	66 0f 6e c0	 movd	 xmm0, eax

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  0019f	41 0f bf 40 02	 movsx	 eax, WORD PTR [r8+2]
  001a4	66 0f 6e e0	 movd	 xmm4, eax
  001a8	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  001ac	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  001b0	f3 0f e6 e4	 cvtdq2pd xmm4, xmm4
  001b4	f2 0f 59 e4	 mulsd	 xmm4, xmm4
  001b8	f2 0f 58 e1	 addsd	 xmm4, xmm1
  001bc	f2 0f 5c e0	 subsd	 xmm4, xmm0

; 627  : 
; 628  :         if ( result > best_result ) {

  001c0	66 0f 2f e5	 comisd	 xmm4, xmm5
  001c4	76 08		 jbe	 SHORT $LN18@audioop_fi@3

; 629  :             best_result = result;

  001c6	66 0f 28 ec	 movapd	 xmm5, xmm4
  001ca	48 8d 4a 03	 lea	 rcx, QWORD PTR [rdx+3]
$LN18@audioop_fi@3:

; 615  :     }
; 616  : 
; 617  :     result = _sum2(cp1, cp1, len2);

  001ce	48 83 c2 04	 add	 rdx, 4
  001d2	49 83 c0 08	 add	 r8, 8
  001d6	49 3b d1	 cmp	 rdx, r9
  001d9	0f 8e 11 ff ff
	ff		 jle	 $LL19@audioop_fi@3
  001df	4c 8b 64 24 40	 mov	 r12, QWORD PTR [rsp+64]
  001e4	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
$LC14@audioop_fi@3:

; 621  : 
; 622  :     for ( j=1; j<=len1-len2; j++) {

  001e9	48 3b d3	 cmp	 rdx, rbx
  001ec	7f 4b		 jg	 SHORT $LN13@audioop_fi@3
  001ee	4c 8d 44 56 fe	 lea	 r8, QWORD PTR [rsi+rdx*2-2]
$LC4@audioop_fi@3:

; 623  :         aj_m1 = (double)cp1[j-1];

  001f3	41 0f bf 00	 movsx	 eax, WORD PTR [r8]
  001f7	66 0f 6e c8	 movd	 xmm1, eax

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  001fb	41 0f bf 04 78	 movsx	 eax, WORD PTR [r8+rdi*2]
  00200	66 0f 6e c0	 movd	 xmm0, eax
  00204	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  00208	f2 0f 59 c9	 mulsd	 xmm1, xmm1
  0020c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00210	f2 0f 59 c0	 mulsd	 xmm0, xmm0
  00214	f2 0f 58 c4	 addsd	 xmm0, xmm4
  00218	66 0f 28 e0	 movapd	 xmm4, xmm0
  0021c	f2 0f 5c e1	 subsd	 xmm4, xmm1

; 627  : 
; 628  :         if ( result > best_result ) {

  00220	66 0f 2f e5	 comisd	 xmm4, xmm5
  00224	76 07		 jbe	 SHORT $LN3@audioop_fi@3

; 629  :             best_result = result;

  00226	66 0f 28 ec	 movapd	 xmm5, xmm4

; 630  :             best_j = j;

  0022a	48 8b ca	 mov	 rcx, rdx
$LN3@audioop_fi@3:

; 621  : 
; 622  :     for ( j=1; j<=len1-len2; j++) {

  0022d	48 ff c2	 inc	 rdx
  00230	49 83 c0 02	 add	 r8, 2
  00234	48 3b d3	 cmp	 rdx, rbx
  00237	7e ba		 jle	 SHORT $LC4@audioop_fi@3
$LN13@audioop_fi@3:

; 631  :         }
; 632  : 
; 633  :     }
; 634  : 
; 635  :     return PyLong_FromSsize_t(best_j);

  00239	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0023e	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00243	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00248	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 636  : }

  0024d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00251	c3		 ret	 0
$LN5@audioop_fi@3:

; 613  :         PyErr_SetString(AudioopError, "Input sample should be longer");

  00252	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@
  00260	e8 00 00 00 00	 call	 PyErr_SetString
  00265	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0026a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 614  :         return 0;

  0026f	33 c0		 xor	 eax, eax

; 636  : }

  00271	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00275	c3		 ret	 0
audioop_findmax ENDP
_TEXT	ENDS
PUBLIC	__mask@@AbsDouble@
PUBLIC	??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_avgpp DD imagerel audioop_avgpp
	DD	imagerel audioop_avgpp+393
	DD	imagerel $unwind$audioop_avgpp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_avgpp DD 0a8101H
	DD	010c481H
	DD	04682cH
	DD	0d009920dH
	DD	060067007H
	DD	030045005H
xdata	ENDS
;	COMDAT __mask@@AbsDouble@
CONST	SEGMENT
__mask@@AbsDouble@ DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH, 0ffH
	DB	0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT ??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@
CONST	SEGMENT
??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@ DB 's#i:avgpp', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_avgpp
_TEXT	SEGMENT
cp$ = 48
self$ = 128
args$ = 136
size$ = 144
len$ = 152
audioop_avgpp PROC					; COMDAT

; 640  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	55		 push	 rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 55		 push	 r13
  00009	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 641  :     signed char *cp;
; 642  :     Py_ssize_t len, i;
; 643  :     int size, val = 0, prevval = 0, prevextremevalid = 0,
; 644  :         prevextreme = 0;
; 645  :     double sum = 0.0;
; 646  :     unsigned int avg;
; 647  :     int diff, prevdiff, nextreme = 0;
; 648  : 
; 649  :     if ( !PyArg_ParseTuple(args, "s#i:avgpp", &cp, &len, &size) )

  0000d	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00011	48 8b c2	 mov	 rax, rdx
  00014	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00018	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  0001c	4d 8d 43 b8	 lea	 r8, QWORD PTR [r11-72]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@
  00027	0f 29 74 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm6
  0002c	66 0f 57 f6	 xorpd	 xmm6, xmm6
  00030	48 8b c8	 mov	 rcx, rax
  00033	33 db		 xor	 ebx, ebx
  00035	33 ff		 xor	 edi, edi
  00037	33 f6		 xor	 esi, esi
  00039	45 33 ed	 xor	 r13d, r13d
  0003c	33 ed		 xor	 ebp, ebp
  0003e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00043	85 c0		 test	 eax, eax
  00045	75 12		 jne	 SHORT $LN21@audioop_av@2
$LN28@audioop_av@2:

; 650  :         return 0;

  00047	33 c0		 xor	 eax, eax

; 685  : }

  00049	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0004e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00052	41 5d		 pop	 r13
  00054	5f		 pop	 rdi
  00055	5e		 pop	 rsi
  00056	5d		 pop	 rbp
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN21@audioop_av@2:

; 651  :     if (!audioop_check_parameters(len, size))

  00059	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00060	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00068	e8 00 00 00 00	 call	 audioop_check_parameters
  0006d	85 c0		 test	 eax, eax

; 652  :         return NULL;

  0006f	74 d6		 je	 SHORT $LN28@audioop_av@2

; 653  :     if (len <= size)

  00071	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR size$[rsp]
  00079	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12
  00081	4c 8b a4 24 98
	00 00 00	 mov	 r12, QWORD PTR len$[rsp]
  00089	4c 3b e2	 cmp	 r12, rdx
  0008c	7f 0c		 jg	 SHORT $LN19@audioop_av@2

; 654  :         return PyLong_FromLong(0);

  0008e	33 c9		 xor	 ecx, ecx
  00090	e8 00 00 00 00	 call	 PyLong_FromLong
  00095	e9 d7 00 00 00	 jmp	 $LN27@audioop_av@2
$LN19@audioop_av@2:

; 655  :     if ( size == 1 )      prevval = (int)*CHARP(cp, 0);

  0009a	4c 8b 54 24 30	 mov	 r10, QWORD PTR cp$[rsp]
  0009f	83 fa 01	 cmp	 edx, 1
  000a2	75 06		 jne	 SHORT $LN18@audioop_av@2
  000a4	41 0f be 3a	 movsx	 edi, BYTE PTR [r10]
  000a8	eb 13		 jmp	 SHORT $LN14@audioop_av@2
$LN18@audioop_av@2:

; 656  :     else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);

  000aa	83 fa 02	 cmp	 edx, 2
  000ad	75 06		 jne	 SHORT $LN16@audioop_av@2
  000af	41 0f bf 3a	 movsx	 edi, WORD PTR [r10]
  000b3	eb 08		 jmp	 SHORT $LN14@audioop_av@2
$LN16@audioop_av@2:

; 657  :     else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);

  000b5	83 fa 04	 cmp	 edx, 4
  000b8	75 03		 jne	 SHORT $LN14@audioop_av@2
  000ba	41 8b 3a	 mov	 edi, DWORD PTR [r10]
$LN14@audioop_av@2:

; 658  :     prevdiff = 17; /* Anything != 0, 1 */

  000bd	41 b9 11 00 00
	00		 mov	 r9d, 17

; 659  :     for ( i=size; i<len; i+= size) {

  000c3	49 3b d4	 cmp	 rdx, r12
  000c6	0f 8d 9c 00 00
	00		 jge	 $LN26@audioop_av@2
  000cc	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __mask@@AbsDouble@
  000d4	4a 8d 0c 12	 lea	 rcx, QWORD PTR [rdx+r10]
  000d8	49 f7 da	 neg	 r10
  000db	0f 1f 44 00 00	 npad	 5
$LL13@audioop_av@2:

; 660  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  000e0	83 fa 01	 cmp	 edx, 1
  000e3	75 05		 jne	 SHORT $LN10@audioop_av@2
  000e5	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  000e8	eb 11		 jmp	 SHORT $LN6@audioop_av@2
$LN10@audioop_av@2:

; 661  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000ea	83 fa 02	 cmp	 edx, 2
  000ed	75 05		 jne	 SHORT $LN8@audioop_av@2
  000ef	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  000f2	eb 07		 jmp	 SHORT $LN6@audioop_av@2
$LN8@audioop_av@2:

; 662  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000f4	83 fa 04	 cmp	 edx, 4
  000f7	75 02		 jne	 SHORT $LN6@audioop_av@2
  000f9	8b 19		 mov	 ebx, DWORD PTR [rcx]
$LN6@audioop_av@2:

; 663  :         if (val != prevval) {

  000fb	3b df		 cmp	 ebx, edi
  000fd	74 46		 je	 SHORT $LN12@audioop_av@2

; 664  :             diff = val < prevval;

  000ff	45 33 c0	 xor	 r8d, r8d
  00102	3b df		 cmp	 ebx, edi
  00104	41 0f 9c c0	 setl	 r8b

; 665  :             if (prevdiff == !diff) {

  00108	33 c0		 xor	 eax, eax
  0010a	45 85 c0	 test	 r8d, r8d
  0010d	0f 94 c0	 sete	 al
  00110	44 3b c8	 cmp	 r9d, eax
  00113	75 2b		 jne	 SHORT $LN4@audioop_av@2

; 666  :                 /* Derivative changed sign. Compute difference to last
; 667  :                 ** extreme value and remember.
; 668  :                 */
; 669  :                 if (prevextremevalid) {

  00115	85 f6		 test	 esi, esi
  00117	74 1f		 je	 SHORT $LN3@audioop_av@2

; 670  :                     sum += fabs((double)prevval - (double)prevextreme);

  00119	66 0f 6e cf	 movd	 xmm1, edi
  0011d	66 41 0f 6e c5	 movd	 xmm0, r13d

; 671  :                     nextreme++;

  00122	ff c5		 inc	 ebp
  00124	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00128	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0012c	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00130	66 0f 54 ca	 andpd	 xmm1, xmm2
  00134	f2 0f 58 f1	 addsd	 xmm6, xmm1
$LN3@audioop_av@2:

; 672  :                 }
; 673  :                 prevextremevalid = 1;

  00138	be 01 00 00 00	 mov	 esi, 1

; 674  :                 prevextreme = prevval;

  0013d	44 8b ef	 mov	 r13d, edi
$LN4@audioop_av@2:

; 675  :             }
; 676  :             prevval = val;

  00140	8b fb		 mov	 edi, ebx

; 677  :             prevdiff = diff;

  00142	45 8b c8	 mov	 r9d, r8d
$LN12@audioop_av@2:

; 659  :     for ( i=size; i<len; i+= size) {

  00145	48 03 ca	 add	 rcx, rdx
  00148	49 8d 04 0a	 lea	 rax, QWORD PTR [r10+rcx]
  0014c	49 3b c4	 cmp	 rax, r12
  0014f	7c 8f		 jl	 SHORT $LL13@audioop_av@2

; 678  :         }
; 679  :     }
; 680  :     if ( nextreme == 0 )

  00151	85 ed		 test	 ebp, ebp
  00153	74 13		 je	 SHORT $LN26@audioop_av@2

; 682  :     else
; 683  :         avg = (unsigned int)(sum / (double)nextreme);

  00155	66 0f 6e c5	 movd	 xmm0, ebp
  00159	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0015d	f2 0f 5e f0	 divsd	 xmm6, xmm0
  00161	f2 48 0f 2c c6	 cvttsd2si rax, xmm6
  00166	eb 02		 jmp	 SHORT $LN1@audioop_av@2
$LN26@audioop_av@2:

; 681  :         avg = 0;

  00168	33 c0		 xor	 eax, eax
$LN1@audioop_av@2:

; 684  :     return PyLong_FromUnsignedLong(avg);

  0016a	8b c8		 mov	 ecx, eax
  0016c	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN27@audioop_av@2:
  00171	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]

; 685  : }

  00179	0f 28 74 24 40	 movaps	 xmm6, XMMWORD PTR [rsp+64]
  0017e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00182	41 5d		 pop	 r13
  00184	5f		 pop	 rdi
  00185	5e		 pop	 rsi
  00186	5d		 pop	 rbp
  00187	5b		 pop	 rbx
  00188	c3		 ret	 0
audioop_avgpp ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_maxpp DD imagerel audioop_maxpp
	DD	imagerel audioop_maxpp+107
	DD	imagerel $unwind$audioop_maxpp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_maxpp DD imagerel audioop_maxpp+107
	DD	imagerel audioop_maxpp+148
	DD	imagerel $chain$0$audioop_maxpp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_maxpp DD imagerel audioop_maxpp+148
	DD	imagerel audioop_maxpp+334
	DD	imagerel $chain$2$audioop_maxpp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_maxpp DD 020021H
	DD	0ed400H
	DD	imagerel audioop_maxpp
	DD	imagerel audioop_maxpp+107
	DD	imagerel $unwind$audioop_maxpp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_maxpp DD 020521H
	DD	0ed405H
	DD	imagerel audioop_maxpp
	DD	imagerel audioop_maxpp+107
	DD	imagerel $unwind$audioop_maxpp
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_maxpp DD 060d01H
	DD	0c009720dH
	DD	060067007H
	DD	030045005H
xdata	ENDS
;	COMDAT ??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@
CONST	SEGMENT
??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@ DB 's#i:maxpp', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_maxpp
_TEXT	SEGMENT
cp$ = 48
self$ = 112
args$ = 120
size$ = 128
len$ = 136
audioop_maxpp PROC					; COMDAT

; 689  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	55		 push	 rbp
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 690  :     signed char *cp;
; 691  :     Py_ssize_t len, i;
; 692  :     int size, val = 0, prevval = 0, prevextremevalid = 0,
; 693  :         prevextreme = 0;
; 694  :     unsigned int max = 0, extremediff;
; 695  :     int diff, prevdiff;
; 696  : 
; 697  :     if ( !PyArg_ParseTuple(args, "s#i:maxpp", &cp, &len, &size) )

  0000d	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00011	48 8b c2	 mov	 rax, rdx
  00014	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00018	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  0001c	4d 8d 43 c8	 lea	 r8, QWORD PTR [r11-56]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@
  00027	48 8b c8	 mov	 rcx, rax
  0002a	33 f6		 xor	 esi, esi
  0002c	33 db		 xor	 ebx, ebx
  0002e	33 ed		 xor	 ebp, ebp
  00030	33 ff		 xor	 edi, edi
  00032	45 33 e4	 xor	 r12d, r12d
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003a	85 c0		 test	 eax, eax
  0003c	75 0d		 jne	 SHORT $LN22@audioop_ma@2
$LN28@audioop_ma@2:

; 698  :         return 0;

  0003e	33 c0		 xor	 eax, eax

; 735  : }

  00040	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00044	41 5c		 pop	 r12
  00046	5f		 pop	 rdi
  00047	5e		 pop	 rsi
  00048	5d		 pop	 rbp
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN22@audioop_ma@2:

; 699  :     if (!audioop_check_parameters(len, size))

  0004b	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00052	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  0005a	e8 00 00 00 00	 call	 audioop_check_parameters
  0005f	85 c0		 test	 eax, eax

; 700  :         return NULL;

  00061	74 db		 je	 SHORT $LN28@audioop_ma@2

; 701  :     if (len <= size)

  00063	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR size$[rsp]
  0006b	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  00070	4c 8b ac 24 88
	00 00 00	 mov	 r13, QWORD PTR len$[rsp]
  00078	4c 3b ea	 cmp	 r13, rdx
  0007b	7f 17		 jg	 SHORT $LN20@audioop_ma@2

; 702  :         return PyLong_FromLong(0);

  0007d	33 c9		 xor	 ecx, ecx
  0007f	e8 00 00 00 00	 call	 PyLong_FromLong
  00084	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]

; 735  : }

  00089	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0008d	41 5c		 pop	 r12
  0008f	5f		 pop	 rdi
  00090	5e		 pop	 rsi
  00091	5d		 pop	 rbp
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
$LN20@audioop_ma@2:

; 703  :     if ( size == 1 )      prevval = (int)*CHARP(cp, 0);

  00094	4c 8b 54 24 30	 mov	 r10, QWORD PTR cp$[rsp]
  00099	83 fa 01	 cmp	 edx, 1
  0009c	75 06		 jne	 SHORT $LN19@audioop_ma@2
  0009e	41 0f be 1a	 movsx	 ebx, BYTE PTR [r10]
  000a2	eb 13		 jmp	 SHORT $LN15@audioop_ma@2
$LN19@audioop_ma@2:

; 704  :     else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);

  000a4	83 fa 02	 cmp	 edx, 2
  000a7	75 06		 jne	 SHORT $LN17@audioop_ma@2
  000a9	41 0f bf 1a	 movsx	 ebx, WORD PTR [r10]
  000ad	eb 08		 jmp	 SHORT $LN15@audioop_ma@2
$LN17@audioop_ma@2:

; 705  :     else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);

  000af	83 fa 04	 cmp	 edx, 4
  000b2	75 03		 jne	 SHORT $LN15@audioop_ma@2
  000b4	41 8b 1a	 mov	 ebx, DWORD PTR [r10]
$LN15@audioop_ma@2:

; 706  :     prevdiff = 17; /* Anything != 0, 1 */

  000b7	41 b9 11 00 00
	00		 mov	 r9d, 17

; 707  :     for ( i=size; i<len; i+= size) {

  000bd	49 3b d5	 cmp	 rdx, r13
  000c0	7d 74		 jge	 SHORT $LN12@audioop_ma@2
  000c2	4a 8d 0c 12	 lea	 rcx, QWORD PTR [rdx+r10]
  000c6	49 f7 da	 neg	 r10
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL14@audioop_ma@2:

; 708  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  000d0	83 fa 01	 cmp	 edx, 1
  000d3	75 05		 jne	 SHORT $LN11@audioop_ma@2
  000d5	0f be 31	 movsx	 esi, BYTE PTR [rcx]
  000d8	eb 11		 jmp	 SHORT $LN7@audioop_ma@2
$LN11@audioop_ma@2:

; 709  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000da	83 fa 02	 cmp	 edx, 2
  000dd	75 05		 jne	 SHORT $LN9@audioop_ma@2
  000df	0f bf 31	 movsx	 esi, WORD PTR [rcx]
  000e2	eb 07		 jmp	 SHORT $LN7@audioop_ma@2
$LN9@audioop_ma@2:

; 710  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000e4	83 fa 04	 cmp	 edx, 4
  000e7	75 02		 jne	 SHORT $LN7@audioop_ma@2
  000e9	8b 31		 mov	 esi, DWORD PTR [rcx]
$LN7@audioop_ma@2:

; 711  :         if (val != prevval) {

  000eb	3b f3		 cmp	 esi, ebx
  000ed	74 3b		 je	 SHORT $LN13@audioop_ma@2

; 712  :             diff = val < prevval;

  000ef	45 33 c0	 xor	 r8d, r8d
  000f2	3b f3		 cmp	 esi, ebx
  000f4	41 0f 9c c0	 setl	 r8b

; 713  :             if (prevdiff == !diff) {

  000f8	33 c0		 xor	 eax, eax
  000fa	45 85 c0	 test	 r8d, r8d
  000fd	0f 94 c0	 sete	 al
  00100	44 3b c8	 cmp	 r9d, eax
  00103	75 20		 jne	 SHORT $LN5@audioop_ma@2

; 714  :                 /* Derivative changed sign. Compute difference to
; 715  :                 ** last extreme value and remember.
; 716  :                 */
; 717  :                 if (prevextremevalid) {

  00105	85 ed		 test	 ebp, ebp
  00107	74 15		 je	 SHORT $LN1@audioop_ma@2

; 718  :                     if (prevval < prevextreme)

  00109	3b df		 cmp	 ebx, edi
  0010b	7d 04		 jge	 SHORT $LN3@audioop_ma@2

; 719  :                         extremediff = (unsigned int)prevextreme -
; 720  :                                       (unsigned int)prevval;

  0010d	2b fb		 sub	 edi, ebx

; 721  :                     else

  0010f	eb 06		 jmp	 SHORT $LN2@audioop_ma@2
$LN3@audioop_ma@2:

; 722  :                         extremediff = (unsigned int)prevval -
; 723  :                                       (unsigned int)prevextreme;

  00111	8b c3		 mov	 eax, ebx
  00113	2b c7		 sub	 eax, edi
  00115	8b f8		 mov	 edi, eax
$LN2@audioop_ma@2:

; 724  :                     if ( extremediff > max )

  00117	41 3b fc	 cmp	 edi, r12d
  0011a	44 0f 47 e7	 cmova	 r12d, edi
$LN1@audioop_ma@2:

; 725  :                         max = extremediff;
; 726  :                 }
; 727  :                 prevextremevalid = 1;

  0011e	bd 01 00 00 00	 mov	 ebp, 1

; 728  :                 prevextreme = prevval;

  00123	8b fb		 mov	 edi, ebx
$LN5@audioop_ma@2:

; 729  :             }
; 730  :             prevval = val;

  00125	8b de		 mov	 ebx, esi

; 731  :             prevdiff = diff;

  00127	45 8b c8	 mov	 r9d, r8d
$LN13@audioop_ma@2:

; 707  :     for ( i=size; i<len; i+= size) {

  0012a	48 03 ca	 add	 rcx, rdx
  0012d	49 8d 04 0a	 lea	 rax, QWORD PTR [r10+rcx]
  00131	49 3b c5	 cmp	 rax, r13
  00134	7c 9a		 jl	 SHORT $LL14@audioop_ma@2
$LN12@audioop_ma@2:

; 732  :         }
; 733  :     }
; 734  :     return PyLong_FromUnsignedLong(max);

  00136	41 8b cc	 mov	 ecx, r12d
  00139	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0013e	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]

; 735  : }

  00143	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00147	41 5c		 pop	 r12
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	5d		 pop	 rbp
  0014c	5b		 pop	 rbx
  0014d	c3		 ret	 0
audioop_maxpp ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_cross DD imagerel audioop_cross
	DD	imagerel audioop_cross+104
	DD	imagerel $unwind$audioop_cross
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_cross DD imagerel audioop_cross+104
	DD	imagerel audioop_cross+182
	DD	imagerel $chain$0$audioop_cross
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$audioop_cross DD imagerel audioop_cross+182
	DD	imagerel audioop_cross+196
	DD	imagerel $chain$1$audioop_cross
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$audioop_cross DD 021H
	DD	imagerel audioop_cross
	DD	imagerel audioop_cross+104
	DD	imagerel $unwind$audioop_cross
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_cross DD 020521H
	DD	0a7405H
	DD	imagerel audioop_cross
	DD	imagerel audioop_cross+104
	DD	imagerel $unwind$audioop_cross
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_cross DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@
CONST	SEGMENT
??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@ DB 's#i:cross', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_cross
_TEXT	SEGMENT
cp$ = 48
self$ = 80
args$ = 88
size$ = 96
len$ = 104
audioop_cross PROC					; COMDAT

; 739  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 740  :     signed char *cp;
; 741  :     Py_ssize_t len, i;
; 742  :     int size, val = 0;
; 743  :     int prevval;
; 744  :     Py_ssize_t ncross;
; 745  : 
; 746  :     if ( !PyArg_ParseTuple(args, "s#i:cross", &cp, &len, &size) )

  00009	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0000e	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@
  00024	48 8b c8	 mov	 rcx, rax
  00027	33 db		 xor	 ebx, ebx
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 08		 jne	 SHORT $LN11@audioop_cr
$LN16@audioop_cr:

; 747  :         return 0;

  00032	33 c0		 xor	 eax, eax

; 761  : }

  00034	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN11@audioop_cr:

; 748  :     if (!audioop_check_parameters(len, size))

  0003a	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00043	e8 00 00 00 00	 call	 audioop_check_parameters
  00048	85 c0		 test	 eax, eax

; 749  :         return NULL;

  0004a	74 e6		 je	 SHORT $LN16@audioop_cr

; 750  :     ncross = -1;
; 751  :     prevval = 17; /* Anything <> 0,1 */
; 752  :     for ( i=0; i<len; i+= size) {

  0004c	4c 8b 54 24 68	 mov	 r10, QWORD PTR len$[rsp]
  00051	49 83 c8 ff	 or	 r8, -1
  00055	45 8d 48 12	 lea	 r9d, QWORD PTR [r8+18]
  00059	4d 85 d2	 test	 r10, r10
  0005c	7e 58		 jle	 SHORT $LN7@audioop_cr
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00063	48 63 54 24 60	 movsxd	 rdx, DWORD PTR size$[rsp]
  00068	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0006d	4c 8b d9	 mov	 r11, rcx
  00070	49 f7 db	 neg	 r11
$LL9@audioop_cr:

; 753  :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) >> 7;

  00073	83 fa 01	 cmp	 edx, 1
  00076	75 08		 jne	 SHORT $LN6@audioop_cr
  00078	0f be 19	 movsx	 ebx, BYTE PTR [rcx]
  0007b	c1 fb 07	 sar	 ebx, 7
  0007e	eb 17		 jmp	 SHORT $LN2@audioop_cr
$LN6@audioop_cr:

; 754  :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) >> 15;

  00080	83 fa 02	 cmp	 edx, 2
  00083	75 08		 jne	 SHORT $LN4@audioop_cr
  00085	0f bf 19	 movsx	 ebx, WORD PTR [rcx]
  00088	c1 fb 0f	 sar	 ebx, 15
  0008b	eb 0a		 jmp	 SHORT $LN2@audioop_cr
$LN4@audioop_cr:

; 755  :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 31;

  0008d	83 fa 04	 cmp	 edx, 4
  00090	75 05		 jne	 SHORT $LN2@audioop_cr
  00092	8b 19		 mov	 ebx, DWORD PTR [rcx]
  00094	c1 fb 1f	 sar	 ebx, 31
$LN2@audioop_cr:

; 756  :         val = val & 1;

  00097	83 e3 01	 and	 ebx, 1

; 757  :         if ( val != prevval ) ncross++;

  0009a	41 3b d9	 cmp	 ebx, r9d
  0009d	74 03		 je	 SHORT $LN1@audioop_cr
  0009f	49 ff c0	 inc	 r8
$LN1@audioop_cr:

; 750  :     ncross = -1;
; 751  :     prevval = 17; /* Anything <> 0,1 */
; 752  :     for ( i=0; i<len; i+= size) {

  000a2	48 03 ca	 add	 rcx, rdx

; 758  :         prevval = val;

  000a5	44 8b cb	 mov	 r9d, ebx
  000a8	49 8d 04 0b	 lea	 rax, QWORD PTR [r11+rcx]
  000ac	49 3b c2	 cmp	 rax, r10
  000af	7c c2		 jl	 SHORT $LL9@audioop_cr
  000b1	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
$LN7@audioop_cr:

; 759  :     }
; 760  :     return PyLong_FromSsize_t(ncross);

  000b6	49 8b c8	 mov	 rcx, r8
  000b9	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 761  : }

  000be	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c2	5b		 pop	 rbx
  000c3	c3		 ret	 0
audioop_cross ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@		; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_mul DD imagerel audioop_mul
	DD	imagerel audioop_mul+174
	DD	imagerel $unwind$audioop_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_mul DD imagerel audioop_mul+174
	DD	imagerel audioop_mul+212
	DD	imagerel $chain$4$audioop_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$audioop_mul DD imagerel audioop_mul+212
	DD	imagerel audioop_mul+381
	DD	imagerel $chain$5$audioop_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_mul DD imagerel audioop_mul+381
	DD	imagerel audioop_mul+397
	DD	imagerel $chain$6$audioop_mul
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_mul DD imagerel audioop_mul+397
	DD	imagerel audioop_mul+418
	DD	imagerel $chain$7$audioop_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_mul DD 021H
	DD	imagerel audioop_mul
	DD	imagerel audioop_mul+174
	DD	imagerel $unwind$audioop_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_mul DD 021H
	DD	imagerel audioop_mul+174
	DD	imagerel audioop_mul+212
	DD	imagerel $chain$4$audioop_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$audioop_mul DD 020821H
	DD	0103408H
	DD	imagerel audioop_mul+174
	DD	imagerel audioop_mul+212
	DD	imagerel $chain$4$audioop_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_mul DD 040d21H
	DD	0d740dH
	DD	0115408H
	DD	imagerel audioop_mul
	DD	imagerel audioop_mul+174
	DD	imagerel $unwind$audioop_mul
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_mul DD 088701H
	DD	047887H
	DD	056879H
	DD	0cc474H
	DD	06004d208H
xdata	ENDS
;	COMDAT ??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@
CONST	SEGMENT
??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@ DB 's#id:mul', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_mul
_TEXT	SEGMENT
cp$ = 48
factor$ = 56
self$ = 128
args$ = 136
size$ = 144
len$ = 152
audioop_mul PROC					; COMDAT

; 765  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	56		 push	 rsi
  00004	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 766  :     signed char *cp, *ncp;
; 767  :     Py_ssize_t len, i;
; 768  :     int size, val = 0;
; 769  :     double factor, fval, maxval, minval;
; 770  :     PyObject *rv;
; 771  : 
; 772  :     if ( !PyArg_ParseTuple(args, "s#id:mul", &cp, &len, &size, &factor ) )

  00008	49 8d 4b c0	 lea	 rcx, QWORD PTR [r11-64]
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00013	49 89 4b b0	 mov	 QWORD PTR [r11-80], rcx
  00017	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0001b	4d 8d 43 b8	 lea	 r8, QWORD PTR [r11-72]
  0001f	49 89 4b a8	 mov	 QWORD PTR [r11-88], rcx
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	33 f6		 xor	 esi, esi
  0002f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00034	85 c0		 test	 eax, eax
  00036	75 08		 jne	 SHORT $LN16@audioop_mu
$LN25@audioop_mu:

; 773  :         return 0;

  00038	33 c0		 xor	 eax, eax

; 797  : }

  0003a	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0003e	5e		 pop	 rsi
  0003f	c3		 ret	 0
$LN16@audioop_mu:

; 774  :     if (!audioop_check_parameters(len, size))

  00040	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00047	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  0004f	e8 00 00 00 00	 call	 audioop_check_parameters
  00054	85 c0		 test	 eax, eax

; 775  :         return NULL;

  00056	74 e0		 je	 SHORT $LN25@audioop_mu

; 776  : 
; 777  :     maxval = (double) maxvals[size];

  00058	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]

; 778  :     minval = (double) minvals[size];
; 779  : 
; 780  :     rv = PyBytes_FromStringAndSize(NULL, len);

  00060	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0006f	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00074	0f 29 74 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm6
  00079	66 0f 6e b4 81
	00 00 00 00	 movd	 xmm6, DWORD PTR maxvals[rcx+rax*4]
  00082	0f 29 7c 24 40	 movaps	 XMMWORD PTR [rsp+64], xmm7
  00087	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  0008b	66 0f 6e bc 81
	00 00 00 00	 movd	 xmm7, DWORD PTR minvals[rcx+rax*4]
  00094	33 c9		 xor	 ecx, ecx
  00096	f3 0f e6 ff	 cvtdq2pd xmm7, xmm7
  0009a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0009f	4c 8b e0	 mov	 r12, rax

; 781  :     if ( rv == 0 )

  000a2	48 85 c0	 test	 rax, rax
  000a5	0f 84 e2 00 00
	00		 je	 $LN23@audioop_mu
$LN14@audioop_mu:

; 782  :         return 0;
; 783  :     ncp = (signed char *)PyBytes_AsString(rv);

  000ab	48 8b c8	 mov	 rcx, rax
  000ae	48 89 ac 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rbp
  000b6	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  000bb	e8 00 00 00 00	 call	 PyBytes_AsString

; 784  : 
; 785  : 
; 786  :     for ( i=0; i < len; i += size ) {

  000c0	48 8b fe	 mov	 rdi, rsi
  000c3	48 8b e8	 mov	 rbp, rax
  000c6	48 39 b4 24 98
	00 00 00	 cmp	 QWORD PTR len$[rsp], rsi
  000ce	0f 8e a9 00 00
	00		 jle	 $LN11@audioop_mu
  000d4	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  000dc	8b 9c 24 90 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LL13@audioop_mu:

; 787  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  000e3	83 fb 01	 cmp	 ebx, 1
  000e6	75 0b		 jne	 SHORT $LN10@audioop_mu
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000ed	0f be 34 0f	 movsx	 esi, BYTE PTR [rdi+rcx]
  000f1	eb 1d		 jmp	 SHORT $LN6@audioop_mu
$LN10@audioop_mu:

; 788  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000f3	83 fb 02	 cmp	 ebx, 2
  000f6	75 0b		 jne	 SHORT $LN8@audioop_mu
  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000fd	0f bf 34 07	 movsx	 esi, WORD PTR [rdi+rax]
  00101	eb 0d		 jmp	 SHORT $LN6@audioop_mu
$LN8@audioop_mu:

; 789  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00103	83 fb 04	 cmp	 ebx, 4
  00106	75 08		 jne	 SHORT $LN6@audioop_mu
  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  0010d	8b 34 07	 mov	 esi, DWORD PTR [rdi+rax]
$LN6@audioop_mu:

; 790  :         fval = (double)val*factor;
; 791  :         val = (int)floor(fbound(fval, minval, maxval));

  00110	66 0f 6e c6	 movd	 xmm0, esi
  00114	66 0f 28 d6	 movapd	 xmm2, xmm6
  00118	66 0f 28 cf	 movapd	 xmm1, xmm7
  0011c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00120	f2 0f 59 44 24
	38		 mulsd	 xmm0, QWORD PTR factor$[rsp]
  00126	e8 00 00 00 00	 call	 fbound
  0012b	66 0f 6e c0	 movd	 xmm0, eax
  0012f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00133	e8 00 00 00 00	 call	 floor
  00138	f2 0f 2c f0	 cvttsd2si esi, xmm0

; 792  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)val;

  0013c	83 fb 01	 cmp	 ebx, 1
  0013f	75 06		 jne	 SHORT $LN5@audioop_mu
  00141	40 88 34 2f	 mov	 BYTE PTR [rdi+rbp], sil
  00145	eb 13		 jmp	 SHORT $LN24@audioop_mu
$LN5@audioop_mu:

; 793  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)val;

  00147	83 fb 02	 cmp	 ebx, 2
  0014a	75 06		 jne	 SHORT $LN3@audioop_mu
  0014c	66 89 34 2f	 mov	 WORD PTR [rdi+rbp], si
  00150	eb 08		 jmp	 SHORT $LN24@audioop_mu
$LN3@audioop_mu:

; 794  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)val;

  00152	83 fb 04	 cmp	 ebx, 4
  00155	75 0a		 jne	 SHORT $LN12@audioop_mu
  00157	89 34 2f	 mov	 DWORD PTR [rdi+rbp], esi
$LN24@audioop_mu:
  0015a	8b 9c 24 90 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LN12@audioop_mu:

; 784  : 
; 785  : 
; 786  :     for ( i=0; i < len; i += size ) {

  00161	48 63 c3	 movsxd	 rax, ebx
  00164	48 03 f8	 add	 rdi, rax
  00167	48 3b bc 24 98
	00 00 00	 cmp	 rdi, QWORD PTR len$[rsp]
  0016f	0f 8c 6e ff ff
	ff		 jl	 $LL13@audioop_mu
  00175	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
$LN11@audioop_mu:
  0017d	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  00182	48 8b ac 24 88
	00 00 00	 mov	 rbp, QWORD PTR [rsp+136]

; 795  :     }
; 796  :     return rv;

  0018a	49 8b c4	 mov	 rax, r12
$LN23@audioop_mu:
  0018d	0f 28 74 24 50	 movaps	 xmm6, XMMWORD PTR [rsp+80]
  00192	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  00197	0f 28 7c 24 40	 movaps	 xmm7, XMMWORD PTR [rsp+64]

; 797  : }

  0019c	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001a0	5e		 pop	 rsi
  001a1	c3		 ret	 0
audioop_mul ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@		; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_tomono DD imagerel audioop_tomono
	DD	imagerel audioop_tomono+189
	DD	imagerel $unwind$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_tomono DD imagerel audioop_tomono+189
	DD	imagerel audioop_tomono+288
	DD	imagerel $chain$4$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_tomono DD imagerel audioop_tomono+288
	DD	imagerel audioop_tomono+324
	DD	imagerel $chain$6$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_tomono DD imagerel audioop_tomono+324
	DD	imagerel audioop_tomono+550
	DD	imagerel $chain$7$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$audioop_tomono DD imagerel audioop_tomono+550
	DD	imagerel audioop_tomono+579
	DD	imagerel $chain$8$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$audioop_tomono DD imagerel audioop_tomono+579
	DD	imagerel audioop_tomono+603
	DD	imagerel $chain$9$audioop_tomono
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$audioop_tomono DD imagerel audioop_tomono+603
	DD	imagerel audioop_tomono+630
	DD	imagerel $chain$10$audioop_tomono
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$audioop_tomono DD 021H
	DD	imagerel audioop_tomono
	DD	imagerel audioop_tomono+189
	DD	imagerel $unwind$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$audioop_tomono DD 021H
	DD	imagerel audioop_tomono+189
	DD	imagerel audioop_tomono+288
	DD	imagerel $chain$4$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$audioop_tomono DD 021H
	DD	imagerel audioop_tomono+288
	DD	imagerel audioop_tomono+324
	DD	imagerel $chain$6$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_tomono DD 020821H
	DD	0197408H
	DD	imagerel audioop_tomono+288
	DD	imagerel audioop_tomono+324
	DD	imagerel $chain$6$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_tomono DD 041021H
	DD	018d410H
	DD	01e3408H
	DD	imagerel audioop_tomono+189
	DD	imagerel audioop_tomono+288
	DD	imagerel $chain$4$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_tomono DD 061821H
	DD	097818H
	DD	0a6810H
	DD	016f408H
	DD	imagerel audioop_tomono
	DD	imagerel audioop_tomono+189
	DD	imagerel $unwind$audioop_tomono
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_tomono DD 086d01H
	DD	017e46dH
	DD	01a6460H
	DD	01b010dH
	DD	05004c006H
xdata	ENDS
;	COMDAT ??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@
CONST	SEGMENT
??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@ DB 's*idd:tomono', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_tomono
_TEXT	SEGMENT
fac2$ = 48
pcp$ = 64
self$ = 240
args$ = 248
size$ = 256
fac1$ = 264
audioop_tomono PROC					; COMDAT

; 801  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000d	48 8b c2	 mov	 rax, rdx

; 802  :     Py_buffer pcp;
; 803  :     signed char *cp, *ncp;
; 804  :     Py_ssize_t len, i;
; 805  :     int size, val1 = 0, val2 = 0;
; 806  :     double fac1, fac2, fval, maxval, minval;
; 807  :     PyObject *rv;
; 808  : 
; 809  :     if ( !PyArg_ParseTuple(args, "s*idd:tomono",
; 810  :                            &pcp, &size, &fac1, &fac2 ) )

  00010	48 8d 4c 24 30	 lea	 rcx, QWORD PTR fac2$[rsp]
  00015	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00019	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001e	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00022	4c 8d 44 24 40	 lea	 r8, QWORD PTR pcp$[rsp]
  00027	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@
  00033	33 ed		 xor	 ebp, ebp
  00035	48 8b c8	 mov	 rcx, rax
  00038	44 8b e5	 mov	 r12d, ebp
  0003b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00040	85 c0		 test	 eax, eax
  00042	75 0d		 jne	 SHORT $LN22@audioop_to

; 811  :         return 0;

  00044	33 c0		 xor	 eax, eax

; 850  : }

  00046	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0004d	41 5c		 pop	 r12
  0004f	5d		 pop	 rbp
  00050	c3		 ret	 0
$LN22@audioop_to:

; 812  :     cp = pcp.buf;
; 813  :     len = pcp.len;
; 814  :     if (!audioop_check_parameters(len, size)) {

  00051	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00058	48 89 b4 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rsi
  00060	48 8b 74 24 40	 mov	 rsi, QWORD PTR pcp$[rsp]
  00065	4c 89 b4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r14
  0006d	4c 8b 74 24 50	 mov	 r14, QWORD PTR pcp$[rsp+16]
  00072	49 8b ce	 mov	 rcx, r14
  00075	e8 00 00 00 00	 call	 audioop_check_parameters
  0007a	85 c0		 test	 eax, eax

; 815  :         PyBuffer_Release(&pcp);
; 816  :         return NULL;

  0007c	74 27		 je	 SHORT $LN36@audioop_to

; 817  :     }
; 818  :     if (((len / size) & 1) != 0) {

  0007e	48 63 8c 24 00
	01 00 00	 movsxd	 rcx, DWORD PTR size$[rsp]
  00086	49 8b c6	 mov	 rax, r14
  00089	48 99		 cdq
  0008b	48 f7 f9	 idiv	 rcx
  0008e	a8 01		 test	 al, 1
  00090	74 24		 je	 SHORT $LN20@audioop_to

; 819  :         PyErr_SetString(AudioopError, "not a whole number of frames");

  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  000a0	e8 00 00 00 00	 call	 PyErr_SetString
$LN36@audioop_to:

; 820  :         PyBuffer_Release(&pcp);

  000a5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pcp$[rsp]
  000aa	e8 00 00 00 00	 call	 PyBuffer_Release

; 821  :         return NULL;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 a5 01 00 00	 jmp	 $LN31@audioop_to
$LN20@audioop_to:

; 822  :     }
; 823  : 
; 824  :     maxval = (double) maxvals[size];

  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000bd	4c 89 bc 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r15
  000c5	0f 29 b4 24 a0
	00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm6
  000cd	0f 29 bc 24 90
	00 00 00	 movaps	 XMMWORD PTR [rsp+144], xmm7
  000d5	66 0f 6e b4 88
	00 00 00 00	 movd	 xmm6, DWORD PTR maxvals[rax+rcx*4]

; 825  :     minval = (double) minvals[size];

  000de	66 0f 6e bc 88
	00 00 00 00	 movd	 xmm7, DWORD PTR minvals[rax+rcx*4]

; 826  : 
; 827  :     rv = PyBytes_FromStringAndSize(NULL, len/2);

  000e7	49 8b c6	 mov	 rax, r14
  000ea	48 99		 cdq
  000ec	33 c9		 xor	 ecx, ecx
  000ee	48 2b c2	 sub	 rax, rdx
  000f1	48 d1 f8	 sar	 rax, 1
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  000fb	f3 0f e6 ff	 cvtdq2pd xmm7, xmm7
  000ff	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00104	4c 8b f8	 mov	 r15, rax

; 828  :     if ( rv == 0 ) {

  00107	48 85 c0	 test	 rax, rax
  0010a	75 11		 jne	 SHORT $LN19@audioop_to

; 829  :         PyBuffer_Release(&pcp);

  0010c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pcp$[rsp]
  00111	e8 00 00 00 00	 call	 PyBuffer_Release

; 830  :         return 0;

  00116	33 c0		 xor	 eax, eax
  00118	e9 26 01 00 00	 jmp	 $LN34@audioop_to
$LN19@audioop_to:

; 831  :     }
; 832  :     ncp = (signed char *)PyBytes_AsString(rv);

  0011d	48 8b c8	 mov	 rcx, rax
  00120	48 89 9c 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], rbx
  00128	4c 89 ac 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], r13
  00130	e8 00 00 00 00	 call	 PyBytes_AsString

; 833  : 
; 834  : 
; 835  :     for ( i=0; i < len; i += size*2 ) {

  00135	48 8b dd	 mov	 rbx, rbp
  00138	4c 8b e8	 mov	 r13, rax
  0013b	4d 85 f6	 test	 r14, r14
  0013e	0f 8e e2 00 00
	00		 jle	 $LN16@audioop_to
  00144	48 89 bc 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rdi
  0014c	8b bc 24 00 01
	00 00		 mov	 edi, DWORD PTR size$[rsp]
$LL18@audioop_to:

; 836  :         if ( size == 1 )      val1 = (int)*CHARP(cp, i);

  00153	83 ff 01	 cmp	 edi, 1
  00156	75 0c		 jne	 SHORT $LN15@audioop_to
  00158	0f be 2c 33	 movsx	 ebp, BYTE PTR [rbx+rsi]

; 839  :         if ( size == 1 )      val2 = (int)*CHARP(cp, i+1);

  0015c	44 0f be 64 33
	01		 movsx	 r12d, BYTE PTR [rbx+rsi+1]
  00162	eb 1e		 jmp	 SHORT $LN6@audioop_to
$LN15@audioop_to:

; 837  :         else if ( size == 2 ) val1 = (int)*SHORTP(cp, i);

  00164	83 ff 02	 cmp	 edi, 2
  00167	75 0c		 jne	 SHORT $LN13@audioop_to
  00169	0f bf 2c 33	 movsx	 ebp, WORD PTR [rbx+rsi]

; 840  :         else if ( size == 2 ) val2 = (int)*SHORTP(cp, i+2);

  0016d	44 0f bf 64 33
	02		 movsx	 r12d, WORD PTR [rbx+rsi+2]
  00173	eb 0d		 jmp	 SHORT $LN6@audioop_to
$LN13@audioop_to:

; 838  :         else if ( size == 4 ) val1 = (int)*LONGP(cp, i);

  00175	83 ff 04	 cmp	 edi, 4
  00178	75 08		 jne	 SHORT $LN6@audioop_to
  0017a	8b 2c 33	 mov	 ebp, DWORD PTR [rbx+rsi]

; 841  :         else if ( size == 4 ) val2 = (int)*LONGP(cp, i+4);

  0017d	44 8b 64 33 04	 mov	 r12d, DWORD PTR [rbx+rsi+4]
$LN6@audioop_to:

; 842  :         fval = (double)val1*fac1 + (double)val2*fac2;
; 843  :         val1 = (int)floor(fbound(fval, minval, maxval));

  00182	66 0f 6e c5	 movd	 xmm0, ebp
  00186	66 41 0f 6e cc	 movd	 xmm1, r12d
  0018b	66 0f 28 d6	 movapd	 xmm2, xmm6
  0018f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00193	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00197	f2 0f 59 84 24
	08 01 00 00	 mulsd	 xmm0, QWORD PTR fac1$[rsp]
  001a0	f2 0f 59 4c 24
	30		 mulsd	 xmm1, QWORD PTR fac2$[rsp]
  001a6	f2 0f 58 c1	 addsd	 xmm0, xmm1
  001aa	66 0f 28 cf	 movapd	 xmm1, xmm7
  001ae	e8 00 00 00 00	 call	 fbound
  001b3	66 0f 6e c0	 movd	 xmm0, eax
  001b7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001bb	e8 00 00 00 00	 call	 floor
  001c0	f2 0f 2c e8	 cvttsd2si ebp, xmm0

; 844  :         if ( size == 1 )      *CHARP(ncp, i/2) = (signed char)val1;

  001c4	83 ff 01	 cmp	 edi, 1
  001c7	75 11		 jne	 SHORT $LN5@audioop_to
  001c9	48 8b c3	 mov	 rax, rbx
  001cc	48 99		 cdq
  001ce	48 2b c2	 sub	 rax, rdx
  001d1	48 d1 f8	 sar	 rax, 1
  001d4	42 88 2c 28	 mov	 BYTE PTR [rax+r13], bpl
  001d8	eb 2b		 jmp	 SHORT $LN35@audioop_to
$LN5@audioop_to:

; 845  :         else if ( size == 2 ) *SHORTP(ncp, i/2) = (short)val1;

  001da	83 ff 02	 cmp	 edi, 2
  001dd	75 12		 jne	 SHORT $LN3@audioop_to
  001df	48 8b c3	 mov	 rax, rbx
  001e2	48 99		 cdq
  001e4	48 2b c2	 sub	 rax, rdx
  001e7	48 d1 f8	 sar	 rax, 1
  001ea	66 42 89 2c 28	 mov	 WORD PTR [rax+r13], bp
  001ef	eb 14		 jmp	 SHORT $LN35@audioop_to
$LN3@audioop_to:

; 846  :         else if ( size == 4 ) *LONGP(ncp, i/2)= (Py_Int32)val1;

  001f1	83 ff 04	 cmp	 edi, 4
  001f4	75 16		 jne	 SHORT $LN17@audioop_to
  001f6	48 8b c3	 mov	 rax, rbx
  001f9	48 99		 cdq
  001fb	48 2b c2	 sub	 rax, rdx
  001fe	48 d1 f8	 sar	 rax, 1
  00201	42 89 2c 28	 mov	 DWORD PTR [rax+r13], ebp
$LN35@audioop_to:
  00205	8b bc 24 00 01
	00 00		 mov	 edi, DWORD PTR size$[rsp]
$LN17@audioop_to:

; 833  : 
; 834  : 
; 835  :     for ( i=0; i < len; i += size*2 ) {

  0020c	8d 04 3f	 lea	 eax, DWORD PTR [rdi+rdi]
  0020f	48 63 c8	 movsxd	 rcx, eax
  00212	48 03 d9	 add	 rbx, rcx
  00215	49 3b de	 cmp	 rbx, r14
  00218	0f 8c 35 ff ff
	ff		 jl	 $LL18@audioop_to
  0021e	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR [rsp+200]
$LN16@audioop_to:

; 847  :     }
; 848  :     PyBuffer_Release(&pcp);

  00226	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pcp$[rsp]
  0022b	e8 00 00 00 00	 call	 PyBuffer_Release
  00230	4c 8b ac 24 c0
	00 00 00	 mov	 r13, QWORD PTR [rsp+192]
  00238	48 8b 9c 24 f0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+240]

; 849  :     return rv;

  00240	49 8b c7	 mov	 rax, r15
$LN34@audioop_to:
  00243	0f 28 b4 24 a0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+160]
  0024b	4c 8b bc 24 b0
	00 00 00	 mov	 r15, QWORD PTR [rsp+176]
  00253	0f 28 bc 24 90
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+144]
$LN31@audioop_to:
  0025b	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+208]
  00263	4c 8b b4 24 b8
	00 00 00	 mov	 r14, QWORD PTR [rsp+184]

; 850  : }

  0026b	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00272	41 5c		 pop	 r12
  00274	5d		 pop	 rbp
  00275	c3		 ret	 0
audioop_tomono ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@ ; `string'
PUBLIC	??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@	; `string'
EXTRN	PyExc_MemoryError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_tostereo DD imagerel audioop_tostereo
	DD	imagerel audioop_tostereo+216
	DD	imagerel $unwind$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_tostereo DD imagerel audioop_tostereo+216
	DD	imagerel audioop_tostereo+244
	DD	imagerel $chain$2$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_tostereo DD imagerel audioop_tostereo+244
	DD	imagerel audioop_tostereo+285
	DD	imagerel $chain$4$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_tostereo DD imagerel audioop_tostereo+285
	DD	imagerel audioop_tostereo+579
	DD	imagerel $chain$7$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$audioop_tostereo DD imagerel audioop_tostereo+579
	DD	imagerel audioop_tostereo+598
	DD	imagerel $chain$8$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$audioop_tostereo DD imagerel audioop_tostereo+598
	DD	imagerel audioop_tostereo+606
	DD	imagerel $chain$9$audioop_tostereo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$audioop_tostereo DD imagerel audioop_tostereo+606
	DD	imagerel audioop_tostereo+627
	DD	imagerel $chain$10$audioop_tostereo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$audioop_tostereo DD 021H
	DD	imagerel audioop_tostereo
	DD	imagerel audioop_tostereo+216
	DD	imagerel $unwind$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$audioop_tostereo DD 021H
	DD	imagerel audioop_tostereo+216
	DD	imagerel audioop_tostereo+244
	DD	imagerel $chain$2$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$audioop_tostereo DD 021H
	DD	imagerel audioop_tostereo+244
	DD	imagerel audioop_tostereo+285
	DD	imagerel $chain$4$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_tostereo DD 061f21H
	DD	08681fH
	DD	0155417H
	DD	0183408H
	DD	imagerel audioop_tostereo+244
	DD	imagerel audioop_tostereo+285
	DD	imagerel $chain$4$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_tostereo DD 041021H
	DD	0137410H
	DD	0146408H
	DD	imagerel audioop_tostereo+216
	DD	imagerel audioop_tostereo+244
	DD	imagerel $chain$2$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_tostereo DD 020821H
	DD	012d408H
	DD	imagerel audioop_tostereo
	DD	imagerel audioop_tostereo+216
	DD	imagerel $unwind$audioop_tostereo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_tostereo DD 078e01H
	DD	06888eH
	DD	077881H
	DD	016010cH
	DD	0c005H
xdata	ENDS
;	COMDAT ??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
CONST	SEGMENT
??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@ DB 'not enough '
	DB	'memory for output buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@
CONST	SEGMENT
??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@ DB 's#idd:tostereo', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_tostereo
_TEXT	SEGMENT
cp$ = 64
fac1$ = 72
fac2$ = 80
self$ = 192
args$ = 200
size$ = 208
len$ = 216
audioop_tostereo PROC					; COMDAT

; 854  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	41 54		 push	 r12
  00005	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H

; 855  :     signed char *cp, *ncp;
; 856  :     Py_ssize_t len, i;
; 857  :     int size, val1, val2, val = 0;
; 858  :     double fac1, fac2, fval, maxval, minval;
; 859  :     PyObject *rv;
; 860  : 
; 861  :     if ( !PyArg_ParseTuple(args, "s#idd:tostereo",
; 862  :                            &cp, &len, &size, &fac1, &fac2 ) )

  0000c	49 8d 4b 98	 lea	 rcx, QWORD PTR [r11-104]
  00010	48 8b c2	 mov	 rax, rdx
  00013	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00017	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001c	49 8d 4b 90	 lea	 rcx, QWORD PTR [r11-112]
  00020	4d 8d 43 88	 lea	 r8, QWORD PTR [r11-120]
  00024	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00029	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	48 8b c8	 mov	 rcx, rax
  0003c	45 33 e4	 xor	 r12d, r12d
  0003f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00044	85 c0		 test	 eax, eax
  00046	75 0c		 jne	 SHORT $LN22@audioop_to@2
$LN32@audioop_to@2:

; 863  :         return 0;

  00048	33 c0		 xor	 eax, eax

; 902  : }

  0004a	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00051	41 5c		 pop	 r12
  00053	c3		 ret	 0
$LN22@audioop_to@2:

; 864  :     if (!audioop_check_parameters(len, size))

  00054	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  0005b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00063	e8 00 00 00 00	 call	 audioop_check_parameters
  00068	85 c0		 test	 eax, eax

; 865  :         return NULL;

  0006a	74 dc		 je	 SHORT $LN32@audioop_to@2

; 866  : 
; 867  :     maxval = (double) maxvals[size];

  0006c	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]

; 868  :     minval = (double) minvals[size];
; 869  : 
; 870  :     if (len > PY_SSIZE_T_MAX/2) {

  00074	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  0007c	0f 29 7c 24 70	 movaps	 XMMWORD PTR [rsp+112], xmm7
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00088	44 0f 29 44 24
	60		 movaps	 XMMWORD PTR [rsp+96], xmm8
  0008e	66 0f 6e bc 81
	00 00 00 00	 movd	 xmm7, DWORD PTR maxvals[rcx+rax*4]
  00097	66 44 0f 6e 84
	81 00 00 00 00	 movd	 xmm8, DWORD PTR minvals[rcx+rax*4]
  000a1	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000ab	f3 0f e6 ff	 cvtdq2pd xmm7, xmm7
  000af	f3 45 0f e6 c0	 cvtdq2pd xmm8, xmm8
  000b4	48 3b d0	 cmp	 rdx, rax
  000b7	7e 1a		 jle	 SHORT $LN20@audioop_to@2

; 871  :         PyErr_SetString(PyExc_MemoryError,
; 872  :                         "not enough memory for output buffer");

  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  000c7	e8 00 00 00 00	 call	 PyErr_SetString

; 873  :         return 0;

  000cc	33 c0		 xor	 eax, eax
  000ce	e9 8b 01 00 00	 jmp	 $LN28@audioop_to@2
$LN20@audioop_to@2:

; 874  :     }
; 875  : 
; 876  :     rv = PyBytes_FromStringAndSize(NULL, len*2);

  000d3	48 03 d2	 add	 rdx, rdx
  000d6	33 c9		 xor	 ecx, ecx
  000d8	4c 89 ac 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], r13
  000e0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e5	4c 8b e8	 mov	 r13, rax

; 877  :     if ( rv == 0 )

  000e8	48 85 c0	 test	 rax, rax
  000eb	0f 84 65 01 00
	00		 je	 $LN29@audioop_to@2
$LN19@audioop_to@2:

; 878  :         return 0;
; 879  :     ncp = (signed char *)PyBytes_AsString(rv);

  000f1	48 8b c8	 mov	 rcx, rax
  000f4	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi
  000fc	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  00104	e8 00 00 00 00	 call	 PyBytes_AsString

; 880  : 
; 881  : 
; 882  :     for ( i=0; i < len; i += size ) {

  00109	49 8b fc	 mov	 rdi, r12
  0010c	48 8b f0	 mov	 rsi, rax
  0010f	4c 39 a4 24 d8
	00 00 00	 cmp	 QWORD PTR len$[rsp], r12
  00117	0f 8e 26 01 00
	00		 jle	 $LN16@audioop_to@2
  0011d	48 89 9c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rbx
  00125	8b 9c 24 d0 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
  0012c	48 89 ac 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rbp
  00134	0f 29 b4 24 80
	00 00 00	 movaps	 XMMWORD PTR [rsp+128], xmm6
  0013c	0f 1f 40 00	 npad	 4
$LL18@audioop_to@2:

; 883  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00140	83 fb 01	 cmp	 ebx, 1
  00143	75 0c		 jne	 SHORT $LN15@audioop_to@2
  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp$[rsp]
  0014a	44 0f be 24 0f	 movsx	 r12d, BYTE PTR [rdi+rcx]
  0014f	eb 1f		 jmp	 SHORT $LN11@audioop_to@2
$LN15@audioop_to@2:

; 884  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  00151	83 fb 02	 cmp	 ebx, 2
  00154	75 0c		 jne	 SHORT $LN13@audioop_to@2
  00156	48 8b 44 24 40	 mov	 rax, QWORD PTR cp$[rsp]
  0015b	44 0f bf 24 07	 movsx	 r12d, WORD PTR [rdi+rax]
  00160	eb 0e		 jmp	 SHORT $LN11@audioop_to@2
$LN13@audioop_to@2:

; 885  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00162	83 fb 04	 cmp	 ebx, 4
  00165	75 09		 jne	 SHORT $LN11@audioop_to@2
  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR cp$[rsp]
  0016c	44 8b 24 07	 mov	 r12d, DWORD PTR [rdi+rax]
$LN11@audioop_to@2:

; 886  : 
; 887  :         fval = (double)val*fac1;
; 888  :         val1 = (int)floor(fbound(fval, minval, maxval));

  00170	66 41 0f 6e f4	 movd	 xmm6, r12d
  00175	66 0f 28 d7	 movapd	 xmm2, xmm7
  00179	66 41 0f 28 c8	 movapd	 xmm1, xmm8
  0017e	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  00182	66 0f 28 c6	 movapd	 xmm0, xmm6
  00186	f2 0f 59 44 24
	48		 mulsd	 xmm0, QWORD PTR fac1$[rsp]
  0018c	e8 00 00 00 00	 call	 fbound
  00191	66 0f 6e c0	 movd	 xmm0, eax
  00195	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00199	e8 00 00 00 00	 call	 floor

; 889  : 
; 890  :         fval = (double)val*fac2;

  0019e	f2 0f 59 74 24
	50		 mulsd	 xmm6, QWORD PTR fac2$[rsp]

; 891  :         val2 = (int)floor(fbound(fval, minval, maxval));

  001a4	66 0f 28 d7	 movapd	 xmm2, xmm7
  001a8	66 41 0f 28 c8	 movapd	 xmm1, xmm8
  001ad	f2 0f 2c e8	 cvttsd2si ebp, xmm0
  001b1	66 0f 28 c6	 movapd	 xmm0, xmm6
  001b5	e8 00 00 00 00	 call	 fbound
  001ba	66 0f 6e c0	 movd	 xmm0, eax
  001be	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001c2	e8 00 00 00 00	 call	 floor
  001c7	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 892  : 
; 893  :         if ( size == 1 )      *CHARP(ncp, i*2) = (signed char)val1;

  001cb	83 fb 01	 cmp	 ebx, 1
  001ce	75 06		 jne	 SHORT $LN10@audioop_to@2
  001d0	40 88 2c 7e	 mov	 BYTE PTR [rsi+rdi*2], bpl
  001d4	eb 13		 jmp	 SHORT $LN30@audioop_to@2
$LN10@audioop_to@2:

; 894  :         else if ( size == 2 ) *SHORTP(ncp, i*2) = (short)val1;

  001d6	83 fb 02	 cmp	 ebx, 2
  001d9	75 06		 jne	 SHORT $LN8@audioop_to@2
  001db	66 89 2c 7e	 mov	 WORD PTR [rsi+rdi*2], bp
  001df	eb 08		 jmp	 SHORT $LN30@audioop_to@2
$LN8@audioop_to@2:

; 895  :         else if ( size == 4 ) *LONGP(ncp, i*2) = (Py_Int32)val1;

  001e1	83 fb 04	 cmp	 ebx, 4
  001e4	75 0a		 jne	 SHORT $LN6@audioop_to@2
  001e6	89 2c 7e	 mov	 DWORD PTR [rsi+rdi*2], ebp
$LN30@audioop_to@2:
  001e9	8b 9c 24 d0 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LN6@audioop_to@2:

; 896  : 
; 897  :         if ( size == 1 )      *CHARP(ncp, i*2+1) = (signed char)val2;

  001f0	83 fb 01	 cmp	 ebx, 1
  001f3	75 06		 jne	 SHORT $LN5@audioop_to@2
  001f5	88 44 7e 01	 mov	 BYTE PTR [rsi+rdi*2+1], al
  001f9	eb 15		 jmp	 SHORT $LN31@audioop_to@2
$LN5@audioop_to@2:

; 898  :         else if ( size == 2 ) *SHORTP(ncp, i*2+2) = (short)val2;

  001fb	83 fb 02	 cmp	 ebx, 2
  001fe	75 07		 jne	 SHORT $LN3@audioop_to@2
  00200	66 89 44 7e 02	 mov	 WORD PTR [rsi+rdi*2+2], ax
  00205	eb 09		 jmp	 SHORT $LN31@audioop_to@2
$LN3@audioop_to@2:

; 899  :         else if ( size == 4 ) *LONGP(ncp, i*2+4) = (Py_Int32)val2;

  00207	83 fb 04	 cmp	 ebx, 4
  0020a	75 0b		 jne	 SHORT $LN17@audioop_to@2
  0020c	89 44 7e 04	 mov	 DWORD PTR [rsi+rdi*2+4], eax
$LN31@audioop_to@2:
  00210	8b 9c 24 d0 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LN17@audioop_to@2:

; 880  : 
; 881  : 
; 882  :     for ( i=0; i < len; i += size ) {

  00217	48 63 c3	 movsxd	 rax, ebx
  0021a	48 03 f8	 add	 rdi, rax
  0021d	48 3b bc 24 d8
	00 00 00	 cmp	 rdi, QWORD PTR len$[rsp]
  00225	0f 8c 15 ff ff
	ff		 jl	 $LL18@audioop_to@2
  0022b	0f 28 b4 24 80
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+128]
  00233	48 8b ac 24 a8
	00 00 00	 mov	 rbp, QWORD PTR [rsp+168]
  0023b	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
$LN16@audioop_to@2:
  00243	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]
  0024b	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]

; 900  :     }
; 901  :     return rv;

  00253	49 8b c5	 mov	 rax, r13
$LN29@audioop_to@2:
  00256	4c 8b ac 24 90
	00 00 00	 mov	 r13, QWORD PTR [rsp+144]
$LN28@audioop_to@2:
  0025e	0f 28 7c 24 70	 movaps	 xmm7, XMMWORD PTR [rsp+112]
  00263	44 0f 28 44 24
	60		 movaps	 xmm8, XMMWORD PTR [rsp+96]

; 902  : }

  00269	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00270	41 5c		 pop	 r12
  00272	c3		 ret	 0
audioop_tostereo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@ ; `string'
PUBLIC	??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_add DD imagerel audioop_add
	DD	imagerel audioop_add+208
	DD	imagerel $unwind$audioop_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_add DD imagerel audioop_add+208
	DD	imagerel audioop_add+246
	DD	imagerel $chain$4$audioop_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$audioop_add DD imagerel audioop_add+246
	DD	imagerel audioop_add+485
	DD	imagerel $chain$5$audioop_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_add DD imagerel audioop_add+485
	DD	imagerel audioop_add+501
	DD	imagerel $chain$6$audioop_add
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_add DD imagerel audioop_add+501
	DD	imagerel audioop_add+526
	DD	imagerel $chain$7$audioop_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_add DD 021H
	DD	imagerel audioop_add
	DD	imagerel audioop_add+208
	DD	imagerel $unwind$audioop_add
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_add DD 021H
	DD	imagerel audioop_add+208
	DD	imagerel audioop_add+246
	DD	imagerel $chain$4$audioop_add
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$audioop_add DD 020821H
	DD	0143408H
	DD	imagerel audioop_add+208
	DD	imagerel audioop_add+246
	DD	imagerel $chain$4$audioop_add
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_add DD 040d21H
	DD	0fc40dH
	DD	0107408H
	DD	imagerel audioop_add
	DD	imagerel audioop_add+208
	DD	imagerel $unwind$audioop_add
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_add DD 0abc01H
	DD	0cf4bcH
	DD	0de4adH
	DD	0ed4a0H
	DD	011010cH
	DD	050046005H
xdata	ENDS
;	COMDAT ??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@
CONST	SEGMENT
??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@ DB 'Lengths should'
	DB	' be the same', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@
CONST	SEGMENT
??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@ DB 's#s#i:add', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_add
_TEXT	SEGMENT
cp1$ = 64
cp2$ = 72
len2$ = 80
self$ = 160
args$ = 168
size$ = 176
len1$ = 184
audioop_add PROC					; COMDAT

; 906  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	55		 push	 rbp
  00004	56		 push	 rsi
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 907  :     signed char *cp1, *cp2, *ncp;
; 908  :     Py_ssize_t len1, len2, i;
; 909  :     int size, val1 = 0, val2 = 0, minval, maxval, newval;
; 910  :     PyObject *rv;
; 911  : 
; 912  :     if ( !PyArg_ParseTuple(args, "s#s#i:add",
; 913  :                       &cp1, &len1, &cp2, &len2, &size ) )

  0000c	49 8d 4b 18	 lea	 rcx, QWORD PTR [r11+24]
  00010	48 8b c2	 mov	 rax, rdx
  00013	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00017	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0001b	49 8d 4b b8	 lea	 rcx, QWORD PTR [r11-72]
  0001f	4d 8d 43 a8	 lea	 r8, QWORD PTR [r11-88]
  00023	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  00027	49 8d 4b b0	 lea	 rcx, QWORD PTR [r11-80]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@
  00032	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00036	33 f6		 xor	 esi, esi
  00038	48 8b c8	 mov	 rcx, rax
  0003b	8b ee		 mov	 ebp, esi
  0003d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00042	85 c0		 test	 eax, eax

; 914  :         return 0;

  00044	74 3a		 je	 SHORT $LN41@audioop_ad

; 915  :     if (!audioop_check_parameters(len1, size))

  00046	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  0004d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len1$[rsp]
  00055	e8 00 00 00 00	 call	 audioop_check_parameters
  0005a	85 c0		 test	 eax, eax

; 916  :         return NULL;

  0005c	74 22		 je	 SHORT $LN41@audioop_ad

; 917  :     if ( len1 != len2 ) {

  0005e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR len1$[rsp]
  00066	48 3b 54 24 50	 cmp	 rdx, QWORD PTR len2$[rsp]
  0006b	74 1f		 je	 SHORT $LN25@audioop_ad

; 918  :         PyErr_SetString(AudioopError, "Lengths should be the same");

  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@
  0007b	e8 00 00 00 00	 call	 PyErr_SetString
$LN41@audioop_ad:

; 919  :         return 0;

  00080	33 c0		 xor	 eax, eax

; 958  : }

  00082	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00089	5e		 pop	 rsi
  0008a	5d		 pop	 rbp
  0008b	c3		 ret	 0
$LN25@audioop_ad:

; 920  :     }
; 921  : 
; 922  :     maxval = maxvals[size];

  0008c	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0009b	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  000a0	44 8b ac 81 00
	00 00 00	 mov	 r13d, DWORD PTR maxvals[rcx+rax*4]
  000a8	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14

; 923  :     minval = minvals[size];

  000ad	44 8b b4 81 00
	00 00 00	 mov	 r14d, DWORD PTR minvals[rcx+rax*4]

; 924  : 
; 925  :     rv = PyBytes_FromStringAndSize(NULL, len1);

  000b5	33 c9		 xor	 ecx, ecx
  000b7	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  000bc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c1	4c 8b f8	 mov	 r15, rax

; 926  :     if ( rv == 0 )

  000c4	48 85 c0	 test	 rax, rax
  000c7	0f 84 28 01 00
	00		 je	 $LN38@audioop_ad
$LN24@audioop_ad:

; 927  :         return 0;
; 928  :     ncp = (signed char *)PyBytes_AsString(rv);

  000cd	48 8b c8	 mov	 rcx, rax
  000d0	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rdi
  000d8	4c 89 64 24 78	 mov	 QWORD PTR [rsp+120], r12
  000dd	e8 00 00 00 00	 call	 PyBytes_AsString

; 929  : 
; 930  :     for ( i=0; i < len1; i += size ) {

  000e2	48 8b fe	 mov	 rdi, rsi
  000e5	4c 8b e0	 mov	 r12, rax
  000e8	48 39 b4 24 b8
	00 00 00	 cmp	 QWORD PTR len1$[rsp], rsi
  000f0	0f 8e ef 00 00
	00		 jle	 $LN21@audioop_ad
  000f6	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  000fe	8b 9c 24 b0 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LL23@audioop_ad:

; 931  :         if ( size == 1 )      val1 = (int)*CHARP(cp1, i);

  00105	83 fb 01	 cmp	 ebx, 1
  00108	75 14		 jne	 SHORT $LN20@audioop_ad
  0010a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp1$[rsp]
  0010f	0f be 34 0f	 movsx	 esi, BYTE PTR [rdi+rcx]

; 934  : 
; 935  :         if ( size == 1 )      val2 = (int)*CHARP(cp2, i);

  00113	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp2$[rsp]
  00118	0f be 2c 0f	 movsx	 ebp, BYTE PTR [rdi+rcx]
  0011c	eb 77		 jmp	 SHORT $LN35@audioop_ad
$LN20@audioop_ad:

; 932  :         else if ( size == 2 ) val1 = (int)*SHORTP(cp1, i);

  0011e	83 fb 02	 cmp	 ebx, 2
  00121	75 14		 jne	 SHORT $LN18@audioop_ad
  00123	48 8b 44 24 40	 mov	 rax, QWORD PTR cp1$[rsp]
  00128	0f bf 34 07	 movsx	 esi, WORD PTR [rdi+rax]

; 936  :         else if ( size == 2 ) val2 = (int)*SHORTP(cp2, i);

  0012c	48 8b 44 24 48	 mov	 rax, QWORD PTR cp2$[rsp]
  00131	0f bf 2c 07	 movsx	 ebp, WORD PTR [rdi+rax]
  00135	eb 5e		 jmp	 SHORT $LN35@audioop_ad
$LN18@audioop_ad:

; 933  :         else if ( size == 4 ) val1 = (int)*LONGP(cp1, i);

  00137	83 fb 04	 cmp	 ebx, 4
  0013a	75 57		 jne	 SHORT $LN39@audioop_ad
  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR cp1$[rsp]
  00141	8b 34 07	 mov	 esi, DWORD PTR [rdi+rax]

; 937  :         else if ( size == 4 ) val2 = (int)*LONGP(cp2, i);

  00144	48 8b 44 24 48	 mov	 rax, QWORD PTR cp2$[rsp]
  00149	8b 2c 07	 mov	 ebp, DWORD PTR [rdi+rax]
$LN10@audioop_ad:

; 948  :             double fval = (double)val1 + (double)val2;
; 949  :             /* truncate in case of overflow */
; 950  :             newval = (int)floor(fbound(fval, minval, maxval));

  0014c	66 0f 6e c5	 movd	 xmm0, ebp
  00150	66 0f 6e de	 movd	 xmm3, esi
  00154	66 41 0f 6e d5	 movd	 xmm2, r13d
  00159	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0015d	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
  00161	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00165	f2 0f 58 c3	 addsd	 xmm0, xmm3
  00169	66 41 0f 6e ce	 movd	 xmm1, r14d
  0016e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00172	e8 00 00 00 00	 call	 fbound
  00177	66 0f 6e c0	 movd	 xmm0, eax
  0017b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0017f	e8 00 00 00 00	 call	 floor
  00184	f2 0f 2c c0	 cvttsd2si eax, xmm0
$LN6@audioop_ad:

; 951  :         }
; 952  : 
; 953  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)newval;

  00188	83 fb 01	 cmp	 ebx, 1
  0018b	75 20		 jne	 SHORT $LN5@audioop_ad
  0018d	42 88 04 27	 mov	 BYTE PTR [rdi+r12], al
  00191	eb 2f		 jmp	 SHORT $LN40@audioop_ad
$LN39@audioop_ad:

; 938  : 
; 939  :         if (size < 4) {

  00193	7d b7		 jge	 SHORT $LN10@audioop_ad
$LN35@audioop_ad:

; 940  :             newval = val1 + val2;

  00195	8d 44 35 00	 lea	 eax, DWORD PTR [rbp+rsi]

; 941  :             /* truncate in case of overflow */
; 942  :             if (newval > maxval)

  00199	41 3b c5	 cmp	 eax, r13d
  0019c	7e 05		 jle	 SHORT $LN9@audioop_ad

; 943  :                 newval = maxval;

  0019e	41 8b c5	 mov	 eax, r13d
  001a1	eb e5		 jmp	 SHORT $LN6@audioop_ad
$LN9@audioop_ad:

; 944  :             else if (newval < minval)

  001a3	41 3b c6	 cmp	 eax, r14d
  001a6	7d e0		 jge	 SHORT $LN6@audioop_ad

; 945  :                 newval = minval;

  001a8	41 8b c6	 mov	 eax, r14d

; 946  :         }
; 947  :         else {

  001ab	eb db		 jmp	 SHORT $LN6@audioop_ad
$LN5@audioop_ad:

; 954  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)newval;

  001ad	83 fb 02	 cmp	 ebx, 2
  001b0	75 07		 jne	 SHORT $LN3@audioop_ad
  001b2	66 42 89 04 27	 mov	 WORD PTR [rdi+r12], ax
  001b7	eb 09		 jmp	 SHORT $LN40@audioop_ad
$LN3@audioop_ad:

; 955  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)newval;

  001b9	83 fb 04	 cmp	 ebx, 4
  001bc	75 0b		 jne	 SHORT $LN22@audioop_ad
  001be	42 89 04 27	 mov	 DWORD PTR [rdi+r12], eax
$LN40@audioop_ad:
  001c2	8b 9c 24 b0 00
	00 00		 mov	 ebx, DWORD PTR size$[rsp]
$LN22@audioop_ad:

; 929  : 
; 930  :     for ( i=0; i < len1; i += size ) {

  001c9	48 63 c3	 movsxd	 rax, ebx
  001cc	48 03 f8	 add	 rdi, rax
  001cf	48 3b bc 24 b8
	00 00 00	 cmp	 rdi, QWORD PTR len1$[rsp]
  001d7	0f 8c 28 ff ff
	ff		 jl	 $LL23@audioop_ad
  001dd	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
$LN21@audioop_ad:
  001e5	4c 8b 64 24 78	 mov	 r12, QWORD PTR [rsp+120]
  001ea	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR [rsp+128]

; 956  :     }
; 957  :     return rv;

  001f2	49 8b c7	 mov	 rax, r15
$LN38@audioop_ad:
  001f5	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  001fa	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  001ff	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 958  : }

  00204	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0020b	5e		 pop	 rsi
  0020c	5d		 pop	 rbp
  0020d	c3		 ret	 0
audioop_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_bias DD imagerel audioop_bias
	DD	imagerel audioop_bias+93
	DD	imagerel $unwind$audioop_bias
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_bias DD imagerel audioop_bias+93
	DD	imagerel audioop_bias+122
	DD	imagerel $chain$0$audioop_bias
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_bias DD imagerel audioop_bias+122
	DD	imagerel audioop_bias+282
	DD	imagerel $chain$2$audioop_bias
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_bias DD 020021H
	DD	0a7400H
	DD	imagerel audioop_bias
	DD	imagerel audioop_bias+93
	DD	imagerel $unwind$audioop_bias
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_bias DD 020521H
	DD	0a7405H
	DD	imagerel audioop_bias
	DD	imagerel audioop_bias+93
	DD	imagerel $unwind$audioop_bias
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_bias DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@
CONST	SEGMENT
??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@ DB 's#ii:bias', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_bias
_TEXT	SEGMENT
len$ = 48
cp$ = 56
self$ = 80
args$ = 88
size$ = 96
bias$ = 104
audioop_bias PROC					; COMDAT

; 962  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 963  :     signed char *cp, *ncp;
; 964  :     Py_ssize_t len, i;
; 965  :     int size, bias;
; 966  :     unsigned int val = 0, mask;
; 967  :     PyObject *rv;
; 968  : 
; 969  :     if ( !PyArg_ParseTuple(args, "s#ii:bias",
; 970  :                       &cp, &len, &size , &bias) )

  00009	48 8d 4c 24 68	 lea	 rcx, QWORD PTR bias$[rsp]
  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00018	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@
  0002e	48 8b c8	 mov	 rcx, rax
  00031	33 db		 xor	 ebx, ebx
  00033	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00038	85 c0		 test	 eax, eax
  0003a	75 08		 jne	 SHORT $LN16@audioop_bi
$LN23@audioop_bi:

; 971  :         return 0;

  0003c	33 c0		 xor	 eax, eax

; 997  : }

  0003e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN16@audioop_bi:

; 972  : 
; 973  :     if (!audioop_check_parameters(len, size))

  00044	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00048	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  0004d	e8 00 00 00 00	 call	 audioop_check_parameters
  00052	85 c0		 test	 eax, eax

; 974  :         return NULL;

  00054	74 e6		 je	 SHORT $LN23@audioop_bi

; 975  : 
; 976  :     rv = PyBytes_FromStringAndSize(NULL, len);

  00056	48 8b 54 24 30	 mov	 rdx, QWORD PTR len$[rsp]
  0005b	33 c9		 xor	 ecx, ecx
  0005d	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00062	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00067	48 8b f8	 mov	 rdi, rax

; 977  :     if ( rv == 0 )

  0006a	48 85 c0	 test	 rax, rax
  0006d	75 0b		 jne	 SHORT $LN14@audioop_bi
  0006f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 997  : }

  00074	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00078	5b		 pop	 rbx
  00079	c3		 ret	 0
$LN14@audioop_bi:

; 978  :         return 0;
; 979  :     ncp = (signed char *)PyBytes_AsString(rv);

  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 PyBytes_AsString

; 980  : 
; 981  :     mask = masks[size];

  00082	48 63 54 24 60	 movsxd	 rdx, DWORD PTR size$[rsp]

; 982  : 
; 983  :     for ( i=0; i < len; i += size ) {

  00087	4c 8b c3	 mov	 r8, rbx
  0008a	4c 8b d8	 mov	 r11, rax
  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:masks
  00094	44 8b 0c 90	 mov	 r9d, DWORD PTR [rax+rdx*4]
  00098	48 39 5c 24 30	 cmp	 QWORD PTR len$[rsp], rbx
  0009d	7e 6d		 jle	 SHORT $LN11@audioop_bi
  0009f	90		 npad	 1
$LL13@audioop_bi:

; 984  :         if ( size == 1 )      val = (unsigned int)(unsigned char)*CHARP(cp, i);

  000a0	83 fa 01	 cmp	 edx, 1
  000a3	75 0c		 jne	 SHORT $LN10@audioop_bi
  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  000aa	41 0f b6 1c 08	 movzx	 ebx, BYTE PTR [r8+rcx]
  000af	eb 1f		 jmp	 SHORT $LN6@audioop_bi
$LN10@audioop_bi:

; 985  :         else if ( size == 2 ) val = (unsigned int)(unsigned short)*SHORTP(cp, i);

  000b1	83 fa 02	 cmp	 edx, 2
  000b4	75 0c		 jne	 SHORT $LN8@audioop_bi
  000b6	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  000bb	41 0f b7 1c 00	 movzx	 ebx, WORD PTR [r8+rax]
  000c0	eb 0e		 jmp	 SHORT $LN6@audioop_bi
$LN8@audioop_bi:

; 986  :         else if ( size == 4 ) val = (unsigned int)(Py_UInt32)*LONGP(cp, i);

  000c2	83 fa 04	 cmp	 edx, 4
  000c5	75 09		 jne	 SHORT $LN6@audioop_bi
  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  000cc	41 8b 1c 00	 mov	 ebx, DWORD PTR [r8+rax]
$LN6@audioop_bi:

; 987  : 
; 988  :         val += (unsigned int)bias;

  000d0	8b 4c 24 68	 mov	 ecx, DWORD PTR bias$[rsp]
  000d4	03 cb		 add	 ecx, ebx

; 989  :         /* wrap around in case of overflow */
; 990  :         val &= mask;

  000d6	41 23 c9	 and	 ecx, r9d
  000d9	8b d9		 mov	 ebx, ecx

; 991  : 
; 992  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(unsigned char)val;

  000db	83 fa 01	 cmp	 edx, 1
  000de	75 06		 jne	 SHORT $LN5@audioop_bi
  000e0	43 88 0c 18	 mov	 BYTE PTR [r8+r11], cl
  000e4	eb 15		 jmp	 SHORT $LN22@audioop_bi
$LN5@audioop_bi:

; 993  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(unsigned short)val;

  000e6	83 fa 02	 cmp	 edx, 2
  000e9	75 07		 jne	 SHORT $LN3@audioop_bi
  000eb	66 43 89 0c 18	 mov	 WORD PTR [r8+r11], cx
  000f0	eb 09		 jmp	 SHORT $LN22@audioop_bi
$LN3@audioop_bi:

; 994  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(Py_UInt32)val;

  000f2	83 fa 04	 cmp	 edx, 4
  000f5	75 08		 jne	 SHORT $LN12@audioop_bi
  000f7	43 89 0c 18	 mov	 DWORD PTR [r8+r11], ecx
$LN22@audioop_bi:
  000fb	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
$LN12@audioop_bi:

; 982  : 
; 983  :     for ( i=0; i < len; i += size ) {

  000ff	48 63 c2	 movsxd	 rax, edx
  00102	4c 03 c0	 add	 r8, rax
  00105	4c 3b 44 24 30	 cmp	 r8, QWORD PTR len$[rsp]
  0010a	7c 94		 jl	 SHORT $LL13@audioop_bi
$LN11@audioop_bi:

; 995  :     }
; 996  :     return rv;

  0010c	48 8b c7	 mov	 rax, rdi
  0010f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 997  : }

  00114	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00118	5b		 pop	 rbx
  00119	c3		 ret	 0
audioop_bias ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_reverse DD imagerel audioop_reverse
	DD	imagerel audioop_reverse+83
	DD	imagerel $unwind$audioop_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_reverse DD imagerel audioop_reverse+83
	DD	imagerel audioop_reverse+112
	DD	imagerel $chain$0$audioop_reverse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_reverse DD imagerel audioop_reverse+112
	DD	imagerel audioop_reverse+296
	DD	imagerel $chain$2$audioop_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_reverse DD 020021H
	DD	0a7400H
	DD	imagerel audioop_reverse
	DD	imagerel audioop_reverse+83
	DD	imagerel $unwind$audioop_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_reverse DD 020521H
	DD	0a7405H
	DD	imagerel audioop_reverse
	DD	imagerel audioop_reverse+83
	DD	imagerel $unwind$audioop_reverse
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_reverse DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@
CONST	SEGMENT
??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@ DB 's#i:reverse', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_reverse
_TEXT	SEGMENT
cp$ = 48
self$ = 80
args$ = 88
size$ = 96
len$ = 104
audioop_reverse PROC					; COMDAT

; 1001 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 1002 :     signed char *cp;
; 1003 :     unsigned char *ncp;
; 1004 :     Py_ssize_t len, i, j;
; 1005 :     int size, val = 0;
; 1006 :     PyObject *rv;
; 1007 : 
; 1008 :     if ( !PyArg_ParseTuple(args, "s#i:reverse",
; 1009 :                       &cp, &len, &size) )

  00009	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0000e	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@
  00024	48 8b c8	 mov	 rcx, rax
  00027	33 db		 xor	 ebx, ebx
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 08		 jne	 SHORT $LN16@audioop_re
$LN23@audioop_re:

; 1010 :         return 0;

  00032	33 c0		 xor	 eax, eax

; 1032 : }

  00034	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN16@audioop_re:

; 1011 : 
; 1012 :     if (!audioop_check_parameters(len, size))

  0003a	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00043	e8 00 00 00 00	 call	 audioop_check_parameters
  00048	85 c0		 test	 eax, eax

; 1013 :         return NULL;

  0004a	74 e6		 je	 SHORT $LN23@audioop_re

; 1014 : 
; 1015 :     rv = PyBytes_FromStringAndSize(NULL, len);

  0004c	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00051	33 c9		 xor	 ecx, ecx
  00053	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00058	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0005d	48 8b f8	 mov	 rdi, rax

; 1016 :     if ( rv == 0 )

  00060	48 85 c0	 test	 rax, rax
  00063	75 0b		 jne	 SHORT $LN14@audioop_re
  00065	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1032 : }

  0006a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN14@audioop_re:

; 1017 :         return 0;
; 1018 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 PyBytes_AsString

; 1019 : 
; 1020 :     for ( i=0; i < len; i += size ) {

  00078	4c 8b cb	 mov	 r9, rbx
  0007b	4c 8b d8	 mov	 r11, rax
  0007e	48 39 5c 24 68	 cmp	 QWORD PTR len$[rsp], rbx
  00083	0f 8e 91 00 00
	00		 jle	 $LN11@audioop_re
  00089	44 8b 44 24 60	 mov	 r8d, DWORD PTR size$[rsp]
  0008e	66 90		 npad	 2
$LL13@audioop_re:

; 1021 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 24;

  00090	41 83 f8 01	 cmp	 r8d, 1
  00094	75 0f		 jne	 SHORT $LN10@audioop_re
  00096	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0009b	41 0f be 1c 09	 movsx	 ebx, BYTE PTR [r9+rcx]
  000a0	c1 e3 18	 shl	 ebx, 24
  000a3	eb 24		 jmp	 SHORT $LN6@audioop_re
$LN10@audioop_re:

; 1022 :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) << 16;

  000a5	41 83 f8 02	 cmp	 r8d, 2
  000a9	75 0f		 jne	 SHORT $LN8@audioop_re
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000b0	41 0f bf 1c 01	 movsx	 ebx, WORD PTR [r9+rax]
  000b5	c1 e3 10	 shl	 ebx, 16
  000b8	eb 0f		 jmp	 SHORT $LN6@audioop_re
$LN8@audioop_re:

; 1023 :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000ba	41 83 f8 04	 cmp	 r8d, 4
  000be	75 09		 jne	 SHORT $LN6@audioop_re
  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000c5	41 8b 1c 01	 mov	 ebx, DWORD PTR [r9+rax]
$LN6@audioop_re:

; 1024 : 
; 1025 :         j = len - i - size;

  000c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  000ce	49 63 c0	 movsxd	 rax, r8d
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	49 2b c9	 sub	 rcx, r9

; 1026 : 
; 1027 :         if ( size == 1 )      *CHARP(ncp, j) = (signed char)(val >> 24);

  000d7	41 83 f8 01	 cmp	 r8d, 1
  000db	75 0b		 jne	 SHORT $LN5@audioop_re
  000dd	8b c3		 mov	 eax, ebx
  000df	c1 f8 18	 sar	 eax, 24
  000e2	42 88 04 19	 mov	 BYTE PTR [rcx+r11], al
  000e6	eb 1c		 jmp	 SHORT $LN22@audioop_re
$LN5@audioop_re:

; 1028 :         else if ( size == 2 ) *SHORTP(ncp, j) = (short)(val >> 16);

  000e8	41 83 f8 02	 cmp	 r8d, 2
  000ec	75 0c		 jne	 SHORT $LN3@audioop_re
  000ee	8b c3		 mov	 eax, ebx
  000f0	c1 f8 10	 sar	 eax, 16
  000f3	66 42 89 04 19	 mov	 WORD PTR [rcx+r11], ax
  000f8	eb 0a		 jmp	 SHORT $LN22@audioop_re
$LN3@audioop_re:

; 1029 :         else if ( size == 4 ) *LONGP(ncp, j) = (Py_Int32)val;

  000fa	41 83 f8 04	 cmp	 r8d, 4
  000fe	75 09		 jne	 SHORT $LN12@audioop_re
  00100	42 89 1c 19	 mov	 DWORD PTR [rcx+r11], ebx
$LN22@audioop_re:
  00104	44 8b 44 24 60	 mov	 r8d, DWORD PTR size$[rsp]
$LN12@audioop_re:

; 1019 : 
; 1020 :     for ( i=0; i < len; i += size ) {

  00109	49 63 c0	 movsxd	 rax, r8d
  0010c	4c 03 c8	 add	 r9, rax
  0010f	4c 3b 4c 24 68	 cmp	 r9, QWORD PTR len$[rsp]
  00114	0f 8c 76 ff ff
	ff		 jl	 $LL13@audioop_re
$LN11@audioop_re:

; 1030 :     }
; 1031 :     return rv;

  0011a	48 8b c7	 mov	 rax, rdi
  0011d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1032 : }

  00122	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
audioop_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2lin DD imagerel audioop_lin2lin
	DD	imagerel audioop_lin2lin+165
	DD	imagerel $unwind$audioop_lin2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_lin2lin DD imagerel audioop_lin2lin+165
	DD	imagerel audioop_lin2lin+199
	DD	imagerel $chain$0$audioop_lin2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_lin2lin DD imagerel audioop_lin2lin+199
	DD	imagerel audioop_lin2lin+381
	DD	imagerel $chain$2$audioop_lin2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_lin2lin DD 020021H
	DD	0a7400H
	DD	imagerel audioop_lin2lin
	DD	imagerel audioop_lin2lin+165
	DD	imagerel $unwind$audioop_lin2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_lin2lin DD 020521H
	DD	0a7405H
	DD	imagerel audioop_lin2lin
	DD	imagerel audioop_lin2lin+165
	DD	imagerel $unwind$audioop_lin2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2lin DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@
CONST	SEGMENT
??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@ DB 's#ii:lin2lin', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_lin2lin
_TEXT	SEGMENT
len$ = 48
cp$ = 56
self$ = 80
args$ = 88
size2$ = 96
size$ = 104
audioop_lin2lin PROC					; COMDAT

; 1036 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 8b c2	 mov	 rax, rdx

; 1037 :     signed char *cp;
; 1038 :     unsigned char *ncp;
; 1039 :     Py_ssize_t len, i, j;
; 1040 :     int size, size2, val = 0;
; 1041 :     PyObject *rv;
; 1042 : 
; 1043 :     if ( !PyArg_ParseTuple(args, "s#ii:lin2lin",
; 1044 :                       &cp, &len, &size, &size2) )

  00009	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size2$[rsp]
  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00018	48 8d 4c 24 68	 lea	 rcx, QWORD PTR size$[rsp]
  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@
  0002e	48 8b c8	 mov	 rcx, rax
  00031	33 db		 xor	 ebx, ebx
  00033	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00038	85 c0		 test	 eax, eax

; 1045 :         return 0;

  0003a	74 5d		 je	 SHORT $LN25@audioop_li

; 1046 : 
; 1047 :     if (!audioop_check_parameters(len, size))

  0003c	8b 54 24 68	 mov	 edx, DWORD PTR size$[rsp]
  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  00045	e8 00 00 00 00	 call	 audioop_check_parameters
  0004a	85 c0		 test	 eax, eax

; 1048 :         return NULL;

  0004c	74 4b		 je	 SHORT $LN25@audioop_li

; 1049 :     if (!audioop_check_size(size2))

  0004e	8b 4c 24 60	 mov	 ecx, DWORD PTR size2$[rsp]
  00052	e8 00 00 00 00	 call	 audioop_check_size
  00057	85 c0		 test	 eax, eax

; 1050 :         return NULL;

  00059	74 3e		 je	 SHORT $LN25@audioop_li

; 1051 : 
; 1052 :     if (len/size > PY_SSIZE_T_MAX/size2) {

  0005b	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR size$[rsp]
  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00065	48 99		 cdq
  00067	48 f7 f9	 idiv	 rcx
  0006a	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR size2$[rsp]
  0006f	4c 8b c0	 mov	 r8, rax
  00072	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0007c	48 99		 cdq
  0007e	48 f7 f9	 idiv	 rcx
  00081	4c 3b c0	 cmp	 r8, rax
  00084	7e 1b		 jle	 SHORT $LN15@audioop_li

; 1053 :         PyErr_SetString(PyExc_MemoryError,
; 1054 :                         "not enough memory for output buffer");

  00086	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00094	e8 00 00 00 00	 call	 PyErr_SetString
$LN25@audioop_li:

; 1055 :         return 0;

  00099	33 c0		 xor	 eax, eax

; 1072 : }

  0009b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
$LN15@audioop_li:

; 1056 :     }
; 1057 :     rv = PyBytes_FromStringAndSize(NULL, (len/size)*size2);

  000a1	49 0f af c8	 imul	 rcx, r8
  000a5	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  000aa	48 8b d1	 mov	 rdx, rcx
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b4	48 8b f8	 mov	 rdi, rax

; 1058 :     if ( rv == 0 )

  000b7	48 85 c0	 test	 rax, rax
  000ba	75 0b		 jne	 SHORT $LN14@audioop_li
  000bc	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1072 : }

  000c1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c5	5b		 pop	 rbx
  000c6	c3		 ret	 0
$LN14@audioop_li:

; 1059 :         return 0;
; 1060 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 PyBytes_AsString

; 1061 : 
; 1062 :     for ( i=0, j=0; i < len; i += size, j += size2 ) {

  000cf	4c 8b cb	 mov	 r9, rbx
  000d2	4c 8b d3	 mov	 r10, rbx
  000d5	4c 8b d8	 mov	 r11, rax
  000d8	48 39 5c 24 30	 cmp	 QWORD PTR len$[rsp], rbx
  000dd	0f 8e 8c 00 00
	00		 jle	 $LN11@audioop_li
  000e3	8b 54 24 60	 mov	 edx, DWORD PTR size2$[rsp]
  000e7	44 8b 44 24 68	 mov	 r8d, DWORD PTR size$[rsp]
  000ec	0f 1f 40 00	 npad	 4
$LL13@audioop_li:

; 1063 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 24;

  000f0	41 83 f8 01	 cmp	 r8d, 1
  000f4	75 0f		 jne	 SHORT $LN10@audioop_li
  000f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  000fb	41 0f be 1c 09	 movsx	 ebx, BYTE PTR [r9+rcx]
  00100	c1 e3 18	 shl	 ebx, 24
  00103	eb 24		 jmp	 SHORT $LN6@audioop_li
$LN10@audioop_li:

; 1064 :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) << 16;

  00105	41 83 f8 02	 cmp	 r8d, 2
  00109	75 0f		 jne	 SHORT $LN8@audioop_li
  0010b	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  00110	41 0f bf 1c 01	 movsx	 ebx, WORD PTR [r9+rax]
  00115	c1 e3 10	 shl	 ebx, 16
  00118	eb 0f		 jmp	 SHORT $LN6@audioop_li
$LN8@audioop_li:

; 1065 :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  0011a	41 83 f8 04	 cmp	 r8d, 4
  0011e	75 09		 jne	 SHORT $LN6@audioop_li
  00120	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  00125	41 8b 1c 01	 mov	 ebx, DWORD PTR [r9+rax]
$LN6@audioop_li:

; 1066 : 
; 1067 :         if ( size2 == 1 )  *CHARP(ncp, j) = (signed char)(val >> 24);

  00129	83 fa 01	 cmp	 edx, 1
  0012c	75 0b		 jne	 SHORT $LN5@audioop_li
  0012e	8b c3		 mov	 eax, ebx
  00130	c1 f8 18	 sar	 eax, 24
  00133	43 88 04 1a	 mov	 BYTE PTR [r10+r11], al
  00137	eb 1a		 jmp	 SHORT $LN24@audioop_li
$LN5@audioop_li:

; 1068 :         else if ( size2 == 2 ) *SHORTP(ncp, j) = (short)(val >> 16);

  00139	83 fa 02	 cmp	 edx, 2
  0013c	75 0c		 jne	 SHORT $LN3@audioop_li
  0013e	8b c3		 mov	 eax, ebx
  00140	c1 f8 10	 sar	 eax, 16
  00143	66 43 89 04 1a	 mov	 WORD PTR [r10+r11], ax
  00148	eb 09		 jmp	 SHORT $LN24@audioop_li
$LN3@audioop_li:

; 1069 :         else if ( size2 == 4 ) *LONGP(ncp, j) = (Py_Int32)val;

  0014a	83 fa 04	 cmp	 edx, 4
  0014d	75 0d		 jne	 SHORT $LN12@audioop_li
  0014f	43 89 1c 1a	 mov	 DWORD PTR [r10+r11], ebx
$LN24@audioop_li:
  00153	8b 54 24 60	 mov	 edx, DWORD PTR size2$[rsp]
  00157	44 8b 44 24 68	 mov	 r8d, DWORD PTR size$[rsp]
$LN12@audioop_li:

; 1061 : 
; 1062 :     for ( i=0, j=0; i < len; i += size, j += size2 ) {

  0015c	49 63 c0	 movsxd	 rax, r8d
  0015f	4c 03 c8	 add	 r9, rax
  00162	48 63 c2	 movsxd	 rax, edx
  00165	4c 03 d0	 add	 r10, rax
  00168	4c 3b 4c 24 30	 cmp	 r9, QWORD PTR len$[rsp]
  0016d	7c 81		 jl	 SHORT $LL13@audioop_li
$LN11@audioop_li:

; 1070 :     }
; 1071 :     return rv;

  0016f	48 8b c7	 mov	 rax, rdi
  00172	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 1072 : }

  00177	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0017b	5b		 pop	 rbx
  0017c	c3		 ret	 0
audioop_lin2lin ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT gcd
_TEXT	SEGMENT
a$ = 8
b$ = 16
gcd	PROC						; COMDAT

; 1076 : {

  00000	44 8b c2	 mov	 r8d, edx

; 1077 :     while (b > 0) {

  00003	85 d2		 test	 edx, edx
  00005	7e 19		 jle	 SHORT $LN7@gcd
  00007	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@gcd:

; 1078 :         int tmp = a % b;

  00010	8b c1		 mov	 eax, ecx

; 1079 :         a = b;

  00012	41 8b c8	 mov	 ecx, r8d
  00015	99		 cdq
  00016	41 f7 f8	 idiv	 r8d

; 1080 :         b = tmp;

  00019	44 8b c2	 mov	 r8d, edx
  0001c	85 d2		 test	 edx, edx
  0001e	7f f0		 jg	 SHORT $LL2@gcd
$LN7@gcd:

; 1081 :     }
; 1082 :     return a;

  00020	8b c1		 mov	 eax, ecx

; 1083 : }

  00022	c3		 ret	 0
gcd	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@ ; `string'
PUBLIC	??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@ ; `string'
PUBLIC	??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@	; `string'
PUBLIC	??_C@_09FOELDHLD@ii?3ratecv?$AA@		; `string'
PUBLIC	??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@ ; `string'
PUBLIC	??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@ ; `string'
PUBLIC	??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@ ; `string'
PUBLIC	??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@ ; `string'
PUBLIC	??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyTuple_SetItem:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyTuple_Type:BYTE
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__imp_malloc:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_ratecv DD imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_ratecv DD imagerel audioop_ratecv+144
	DD	imagerel audioop_ratecv+199
	DD	imagerel $chain$0$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_ratecv DD imagerel audioop_ratecv+199
	DD	imagerel audioop_ratecv+252
	DD	imagerel $chain$2$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$audioop_ratecv DD imagerel audioop_ratecv+252
	DD	imagerel audioop_ratecv+294
	DD	imagerel $chain$5$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_ratecv DD imagerel audioop_ratecv+294
	DD	imagerel audioop_ratecv+356
	DD	imagerel $chain$7$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$audioop_ratecv DD imagerel audioop_ratecv+356
	DD	imagerel audioop_ratecv+389
	DD	imagerel $chain$8$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$audioop_ratecv DD imagerel audioop_ratecv+389
	DD	imagerel audioop_ratecv+505
	DD	imagerel $chain$9$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$audioop_ratecv DD imagerel audioop_ratecv+505
	DD	imagerel audioop_ratecv+513
	DD	imagerel $chain$10$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$audioop_ratecv DD imagerel audioop_ratecv+513
	DD	imagerel audioop_ratecv+529
	DD	imagerel $chain$11$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$audioop_ratecv DD imagerel audioop_ratecv+529
	DD	imagerel audioop_ratecv+554
	DD	imagerel $chain$12$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$14$audioop_ratecv DD imagerel audioop_ratecv+554
	DD	imagerel audioop_ratecv+558
	DD	imagerel $chain$14$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$audioop_ratecv DD imagerel audioop_ratecv+558
	DD	imagerel audioop_ratecv+1633
	DD	imagerel $chain$15$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$audioop_ratecv DD imagerel audioop_ratecv+1633
	DD	imagerel audioop_ratecv+1659
	DD	imagerel $chain$17$audioop_ratecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$18$audioop_ratecv DD imagerel audioop_ratecv+1659
	DD	imagerel audioop_ratecv+1685
	DD	imagerel $chain$18$audioop_ratecv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$18$audioop_ratecv DD 040021H
	DD	016d400H
	DD	0196400H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$audioop_ratecv DD 0a0021H
	DD	015e400H
	DD	016d400H
	DD	0187400H
	DD	0196400H
	DD	01c3400H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$audioop_ratecv DD 020821H
	DD	014f408H
	DD	imagerel audioop_ratecv+554
	DD	imagerel audioop_ratecv+558
	DD	imagerel $chain$14$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$14$audioop_ratecv DD 0c0021H
	DD	015e400H
	DD	016d400H
	DD	017c400H
	DD	0187400H
	DD	0196400H
	DD	01c3400H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$audioop_ratecv DD 021H
	DD	imagerel audioop_ratecv+252
	DD	imagerel audioop_ratecv+294
	DD	imagerel $chain$5$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$audioop_ratecv DD 021H
	DD	imagerel audioop_ratecv+294
	DD	imagerel audioop_ratecv+356
	DD	imagerel $chain$7$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$audioop_ratecv DD 021H
	DD	imagerel audioop_ratecv+356
	DD	imagerel audioop_ratecv+389
	DD	imagerel $chain$8$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$audioop_ratecv DD 020821H
	DD	017c408H
	DD	imagerel audioop_ratecv+356
	DD	imagerel audioop_ratecv+389
	DD	imagerel $chain$8$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$audioop_ratecv DD 020821H
	DD	01c3408H
	DD	imagerel audioop_ratecv+294
	DD	imagerel audioop_ratecv+356
	DD	imagerel $chain$7$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_ratecv DD 041021H
	DD	015e410H
	DD	0187408H
	DD	imagerel audioop_ratecv+252
	DD	imagerel audioop_ratecv+294
	DD	imagerel $chain$5$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$audioop_ratecv DD 040821H
	DD	016d408H
	DD	0196400H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_ratecv DD 020021H
	DD	0196400H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_ratecv DD 020821H
	DD	0196408H
	DD	imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+144
	DD	imagerel $unwind$audioop_ratecv
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_ratecv DD 030e01H
	DD	01a010eH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@
CONST	SEGMENT
??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@ DB 'wei'
	DB	'ghtA should be >= 1, weightB should be >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@ DB 'sampling rate no'
	DB	't > 0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@ DB '(O(iO))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOELDHLD@ii?3ratecv?$AA@
CONST	SEGMENT
??_C@_09FOELDHLD@ii?3ratecv?$AA@ DB 'ii:ratecv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@
CONST	SEGMENT
??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@ DB 'illegal state argume'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@
CONST	SEGMENT
??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@ DB 'iO!;au'
	DB	'dioop.ratecv: illegal state argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@
CONST	SEGMENT
??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@ DB 'width '
	DB	'* nchannels too big for a C int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@
CONST	SEGMENT
??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@ DB '#'
	DB	' of channels should be >= 1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@
CONST	SEGMENT
??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@ DB 's#iiiiO|ii:ratecv', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_ratecv
_TEXT	SEGMENT
d$ = 96
outrate$ = 100
weightA$ = 104
inrate$ = 108
len$ = 112
weightB$ = 120
samps$ = 128
cp$ = 136
state$ = 144
self$ = 224
args$ = 232
size$ = 240
nchannels$ = 248
audioop_ratecv PROC					; COMDAT

; 1087 : {

  00000	40 55		 push	 rbp
  00002	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00007	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 1088 :     char *cp, *ncp;
; 1089 :     Py_ssize_t len;
; 1090 :     int size, nchannels, inrate, outrate, weightA, weightB;
; 1091 :     int chan, d, *prev_i, *cur_i, cur_o;
; 1092 :     PyObject *state, *samps, *str, *rv = NULL;
; 1093 :     int bytes_per_frame;
; 1094 : 
; 1095 :     weightA = 1;
; 1096 :     weightB = 0;
; 1097 :     if (!PyArg_ParseTuple(args, "s#iiiiO|ii:ratecv", &cp, &len, &size,
; 1098 :                           &nchannels, &inrate, &outrate, &state,
; 1099 :                           &weightA, &weightB))

  0000e	48 8d 4d ff	 lea	 rcx, QWORD PTR weightB$[rbp-121]
  00012	48 8b c2	 mov	 rax, rdx
  00015	4c 8d 4d f7	 lea	 r9, QWORD PTR len$[rbp-121]
  00019	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0001e	48 8d 4d ef	 lea	 rcx, QWORD PTR weightA$[rbp-121]
  00022	4c 8d 45 0f	 lea	 r8, QWORD PTR cp$[rbp-121]
  00026	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0002b	48 8d 4d 17	 lea	 rcx, QWORD PTR state$[rbp-121]
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@
  00036	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0003b	48 8d 4d eb	 lea	 rcx, QWORD PTR outrate$[rbp-121]
  0003f	c7 45 ef 01 00
	00 00		 mov	 DWORD PTR weightA$[rbp-121], 1
  00046	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0004b	48 8d 4d f3	 lea	 rcx, QWORD PTR inrate$[rbp-121]
  0004f	c7 45 ff 00 00
	00 00		 mov	 DWORD PTR weightB$[rbp-121], 0
  00056	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005b	48 8d 4d 7f	 lea	 rcx, QWORD PTR nchannels$[rbp-121]
  0005f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00064	48 8d 4d 77	 lea	 rcx, QWORD PTR size$[rbp-121]
  00068	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00075	85 c0		 test	 eax, eax
  00077	75 0b		 jne	 SHORT $LN59@audioop_ra
$LN113@audioop_ra:

; 1100 :         return NULL;

  00079	33 c0		 xor	 eax, eax

; 1268 : }

  0007b	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00082	5d		 pop	 rbp
  00083	c3		 ret	 0
$LN59@audioop_ra:

; 1101 :     if (!audioop_check_size(size))

  00084	8b 4d 77	 mov	 ecx, DWORD PTR size$[rbp-121]
  00087	e8 00 00 00 00	 call	 audioop_check_size
  0008c	85 c0		 test	 eax, eax

; 1102 :         return NULL;

  0008e	74 e9		 je	 SHORT $LN113@audioop_ra

; 1103 :     if (nchannels < 1) {

  00090	48 89 b4 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rsi
  00098	48 63 75 7f	 movsxd	 rsi, DWORD PTR nchannels$[rbp-121]
  0009c	83 fe 01	 cmp	 esi, 1
  0009f	7d 26		 jge	 SHORT $LN57@audioop_ra

; 1104 :         PyErr_SetString(AudioopError, "# of channels should be >= 1");

  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@
  000af	e8 00 00 00 00	 call	 PyErr_SetString
  000b4	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]

; 1105 :         return NULL;

  000bc	33 c0		 xor	 eax, eax

; 1268 : }

  000be	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  000c5	5d		 pop	 rbp
  000c6	c3		 ret	 0
$LN57@audioop_ra:

; 1106 :     }
; 1107 :     if (size > INT_MAX / nchannels) {

  000c7	8b 4d 77	 mov	 ecx, DWORD PTR size$[rbp-121]
  000ca	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000cf	99		 cdq
  000d0	f7 fe		 idiv	 esi
  000d2	3b c8		 cmp	 ecx, eax
  000d4	7e 26		 jle	 SHORT $LN56@audioop_ra

; 1108 :         /* This overflow test is rigorously correct because
; 1109 :            both multiplicands are >= 1.  Use the argument names
; 1110 :            from the docs for the error msg. */
; 1111 :         PyErr_SetString(PyExc_OverflowError,
; 1112 :                         "width * nchannels too big for a C int");

  000d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@
  000e4	e8 00 00 00 00	 call	 PyErr_SetString
  000e9	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]

; 1113 :         return NULL;

  000f1	33 c0		 xor	 eax, eax

; 1268 : }

  000f3	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  000fa	5d		 pop	 rbp
  000fb	c3		 ret	 0
$LN56@audioop_ra:
  000fc	4c 89 ac 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], r13

; 1114 :     }
; 1115 :     bytes_per_frame = size * nchannels;
; 1116 :     if (weightA < 1 || weightB < 0) {

  00104	44 8b 6d ef	 mov	 r13d, DWORD PTR weightA$[rbp-121]
  00108	0f af ce	 imul	 ecx, esi
  0010b	41 83 fd 01	 cmp	 r13d, 1
  0010f	0f 8c 66 05 00
	00		 jl	 $LN54@audioop_ra
  00115	44 8b 55 ff	 mov	 r10d, DWORD PTR weightB$[rbp-121]
  00119	45 85 d2	 test	 r10d, r10d
  0011c	0f 88 59 05 00
	00		 js	 $LN54@audioop_ra

; 1120 :     }
; 1121 :     if (len % bytes_per_frame != 0) {

  00122	48 8b 45 f7	 mov	 rax, QWORD PTR len$[rbp-121]
  00126	48 89 bc 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rdi
  0012e	4c 89 b4 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], r14
  00136	48 99		 cdq
  00138	4c 63 f1	 movsxd	 r14, ecx
  0013b	49 f7 fe	 idiv	 r14
  0013e	48 8b f8	 mov	 rdi, rax
  00141	48 85 d2	 test	 rdx, rdx
  00144	74 1a		 je	 SHORT $LN53@audioop_ra

; 1122 :         PyErr_SetString(AudioopError, "not a whole number of frames");

  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  00154	e8 00 00 00 00	 call	 PyErr_SetString

; 1123 :         return NULL;

  00159	33 c0		 xor	 eax, eax
  0015b	e9 a1 00 00 00	 jmp	 $LN106@audioop_ra
$LN53@audioop_ra:

; 1124 :     }
; 1125 :     if (inrate <= 0 || outrate <= 0) {

  00160	44 8b 5d f3	 mov	 r11d, DWORD PTR inrate$[rbp-121]
  00164	48 89 9c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rbx
  0016c	45 85 db	 test	 r11d, r11d
  0016f	0f 8e ec 04 00
	00		 jle	 $LN51@audioop_ra
  00175	8b 5d eb	 mov	 ebx, DWORD PTR outrate$[rbp-121]
  00178	85 db		 test	 ebx, ebx
  0017a	0f 8e e1 04 00
	00		 jle	 $LN51@audioop_ra

; 1128 :     }
; 1129 :     /* divide inrate and outrate by their greatest common divisor */
; 1130 :     d = gcd(inrate, outrate);

  00180	8b d3		 mov	 edx, ebx
  00182	41 8b cb	 mov	 ecx, r11d
  00185	4c 89 a4 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], r12
  0018d	e8 00 00 00 00	 call	 gcd

; 1131 :     inrate /= d;
; 1132 :     outrate /= d;
; 1133 :     /* divide weightA and weightB by their greatest common divisor */
; 1134 :     d = gcd(weightA, weightB);

  00192	41 8b cd	 mov	 ecx, r13d
  00195	44 8b c8	 mov	 r9d, eax
  00198	41 8b c3	 mov	 eax, r11d
  0019b	99		 cdq
  0019c	41 f7 f9	 idiv	 r9d
  0019f	89 45 f3	 mov	 DWORD PTR inrate$[rbp-121], eax
  001a2	8b c3		 mov	 eax, ebx
  001a4	99		 cdq
  001a5	41 f7 f9	 idiv	 r9d
  001a8	41 8b d2	 mov	 edx, r10d
  001ab	44 8b e0	 mov	 r12d, eax
  001ae	89 45 eb	 mov	 DWORD PTR outrate$[rbp-121], eax
  001b1	e8 00 00 00 00	 call	 gcd
  001b6	44 8b c8	 mov	 r9d, eax
  001b9	89 45 e7	 mov	 DWORD PTR d$[rbp-121], eax

; 1135 :     weightA /= d;

  001bc	41 8b c5	 mov	 eax, r13d
  001bf	99		 cdq

; 1136 :     weightA /= d;
; 1137 : 
; 1138 :     if ((size_t)nchannels > PY_SIZE_MAX/sizeof(int)) {

  001c0	48 8b de	 mov	 rbx, rsi
  001c3	41 f7 f9	 idiv	 r9d
  001c6	99		 cdq
  001c7	41 f7 f9	 idiv	 r9d
  001ca	89 45 ef	 mov	 DWORD PTR weightA$[rbp-121], eax
  001cd	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  001d7	48 3b f0	 cmp	 rsi, rax
  001da	76 4e		 jbe	 SHORT $LN50@audioop_ra

; 1139 :         PyErr_SetString(PyExc_MemoryError,
; 1140 :                         "not enough memory for output buffer");

  001dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  001ea	e8 00 00 00 00	 call	 PyErr_SetString

; 1141 :         return 0;

  001ef	33 c0		 xor	 eax, eax
$LN108@audioop_ra:
  001f1	4c 8b a4 24 b8
	00 00 00	 mov	 r12, QWORD PTR [rsp+184]
$LN107@audioop_ra:
  001f9	48 8b 9c 24 e0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+224]
$LN106@audioop_ra:
  00201	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+192]
  00209	4c 8b b4 24 a8
	00 00 00	 mov	 r14, QWORD PTR [rsp+168]
$LN104@audioop_ra:
  00211	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR [rsp+176]
  00219	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]

; 1268 : }

  00221	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00228	5d		 pop	 rbp
  00229	c3		 ret	 0
$LN50@audioop_ra:

; 1142 :     }
; 1143 :     prev_i = (int *) malloc(nchannels * sizeof(int));

  0022a	48 c1 e3 02	 shl	 rbx, 2
  0022e	4c 89 bc 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], r15
  00236	48 8b cb	 mov	 rcx, rbx
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 1144 :     cur_i = (int *) malloc(nchannels * sizeof(int));

  0023f	48 8b cb	 mov	 rcx, rbx
  00242	4c 8b e8	 mov	 r13, rax
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0024b	4c 8b f8	 mov	 r15, rax

; 1145 :     if (prev_i == NULL || cur_i == NULL) {

  0024e	4d 85 ed	 test	 r13, r13
  00251	0f 84 d7 03 00
	00		 je	 $LN48@audioop_ra
  00257	48 85 c0	 test	 rax, rax
  0025a	0f 84 ce 03 00
	00		 je	 $LN48@audioop_ra

; 1147 :         goto exit;
; 1148 :     }
; 1149 : 
; 1150 :     len /= bytes_per_frame; /* # of frames */
; 1151 : 
; 1152 :     if (state == Py_None) {

  00260	48 8b 4d 17	 mov	 rcx, QWORD PTR state$[rbp-121]
  00264	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0026b	48 89 7d f7	 mov	 QWORD PTR len$[rbp-121], rdi
  0026f	48 3b c8	 cmp	 rcx, rax
  00272	75 3a		 jne	 SHORT $LN47@audioop_ra

; 1153 :         d = -outrate;

  00274	41 8b cc	 mov	 ecx, r12d
  00277	f7 d9		 neg	 ecx
  00279	89 4d e7	 mov	 DWORD PTR d$[rbp-121], ecx

; 1154 :         for (chan = 0; chan < nchannels; chan++)

  0027c	33 c9		 xor	 ecx, ecx
  0027e	85 f6		 test	 esi, esi
  00280	0f 8e cb 00 00
	00		 jle	 $LN99@audioop_ra
  00286	49 8b d7	 mov	 rdx, r15
  00289	49 8b c5	 mov	 rax, r13
  0028c	49 2b d5	 sub	 rdx, r13
  0028f	33 f6		 xor	 esi, esi
$LL46@audioop_ra:

; 1155 :             prev_i[chan] = cur_i[chan] = 0;

  00291	89 34 02	 mov	 DWORD PTR [rdx+rax], esi
  00294	89 30		 mov	 DWORD PTR [rax], esi
  00296	ff c1		 inc	 ecx
  00298	48 83 c0 04	 add	 rax, 4
  0029c	3b 4d 7f	 cmp	 ecx, DWORD PTR nchannels$[rbp-121]
  0029f	7c f0		 jl	 SHORT $LL46@audioop_ra

; 1156 :     }
; 1157 :     else {

  002a1	44 8b 65 eb	 mov	 r12d, DWORD PTR outrate$[rbp-121]
  002a5	48 8b 7d f7	 mov	 rdi, QWORD PTR len$[rbp-121]
  002a9	e9 a5 00 00 00	 jmp	 $LN38@audioop_ra
$LN47@audioop_ra:

; 1158 :         if (!PyArg_ParseTuple(state,
; 1159 :                         "iO!;audioop.ratecv: illegal state argument",
; 1160 :                         &d, &PyTuple_Type, &samps))

  002ae	48 8d 45 07	 lea	 rax, QWORD PTR samps$[rbp-121]
  002b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyTuple_Type
  002b9	4c 8d 45 e7	 lea	 r8, QWORD PTR d$[rbp-121]
  002bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@
  002c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c9	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 5d 03 00
	00		 je	 $LN98@audioop_ra

; 1161 :             goto exit;
; 1162 :         if (PyTuple_Size(samps) != nchannels) {

  002d6	48 8b 4d 07	 mov	 rcx, QWORD PTR samps$[rbp-121]
  002da	e8 00 00 00 00	 call	 PyTuple_Size
  002df	48 63 55 7f	 movsxd	 rdx, DWORD PTR nchannels$[rbp-121]
  002e3	48 3b c2	 cmp	 rax, rdx
  002e6	74 18		 je	 SHORT $LN41@audioop_ra

; 1163 :             PyErr_SetString(AudioopError,
; 1164 :                             "illegal state argument");

  002e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@
  002f6	e8 00 00 00 00	 call	 PyErr_SetString

; 1165 :             goto exit;

  002fb	e9 33 03 00 00	 jmp	 $LN98@audioop_ra
$LN41@audioop_ra:

; 1166 :         }
; 1167 :         for (chan = 0; chan < nchannels; chan++) {

  00300	33 f6		 xor	 esi, esi
  00302	85 d2		 test	 edx, edx
  00304	7e 43		 jle	 SHORT $LN92@audioop_ra
  00306	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL40@audioop_ra:

; 1168 :             if (!PyArg_ParseTuple(PyTuple_GetItem(samps, chan),
; 1169 :                                   "ii:ratecv", &prev_i[chan],
; 1170 :                                                &cur_i[chan]))

  00310	48 8b 4d 07	 mov	 rcx, QWORD PTR samps$[rbp-121]
  00314	48 63 d6	 movsxd	 rdx, esi
  00317	49 8d 1c 97	 lea	 rbx, QWORD PTR [r15+rdx*4]
  0031b	49 8d 7c 95 00	 lea	 rdi, QWORD PTR [r13+rdx*4]
  00320	e8 00 00 00 00	 call	 PyTuple_GetItem
  00325	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FOELDHLD@ii?3ratecv?$AA@
  0032c	4c 8b cb	 mov	 r9, rbx
  0032f	4c 8b c7	 mov	 r8, rdi
  00332	48 8b c8	 mov	 rcx, rax
  00335	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0033a	85 c0		 test	 eax, eax
  0033c	0f 84 f1 02 00
	00		 je	 $LN98@audioop_ra

; 1166 :         }
; 1167 :         for (chan = 0; chan < nchannels; chan++) {

  00342	ff c6		 inc	 esi
  00344	3b 75 7f	 cmp	 esi, DWORD PTR nchannels$[rbp-121]
  00347	7c c7		 jl	 SHORT $LL40@audioop_ra
$LN92@audioop_ra:
  00349	44 8b 65 eb	 mov	 r12d, DWORD PTR outrate$[rbp-121]
  0034d	48 8b 7d f7	 mov	 rdi, QWORD PTR len$[rbp-121]
$LN99@audioop_ra:

; 1156 :     }
; 1157 :     else {

  00351	33 f6		 xor	 esi, esi
$LN38@audioop_ra:

; 1171 :                 goto exit;
; 1172 :         }
; 1173 :     }
; 1174 : 
; 1175 :     /* str <- Space for the output buffer. */
; 1176 :     if (len == 0)

  00353	48 85 ff	 test	 rdi, rdi
  00356	75 04		 jne	 SHORT $LN109@audioop_ra

; 1177 :         str = PyBytes_FromStringAndSize(NULL, 0);

  00358	33 d2		 xor	 edx, edx

; 1178 :     else {

  0035a	eb 43		 jmp	 SHORT $LN110@audioop_ra
$LN109@audioop_ra:

; 1179 :         /* There are len input frames, so we need (mathematically)
; 1180 :            ceiling(len*outrate/inrate) output frames, and each frame
; 1181 :            requires bytes_per_frame bytes.  Computing this
; 1182 :            without spurious overflow is the challenge; we can
; 1183 :            settle for a reasonable upper bound, though, in this
; 1184 :            case ceiling(len/inrate) * outrate. */
; 1185 : 
; 1186 :         /* compute ceiling(len/inrate) without overflow */
; 1187 :         Py_ssize_t q = len > 0 ? 1 + (len - 1) / inrate : 0;

  0035c	7e 13		 jle	 SHORT $LN62@audioop_ra
  0035e	48 63 4d f3	 movsxd	 rcx, DWORD PTR inrate$[rbp-121]
  00362	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]
  00366	48 99		 cdq
  00368	48 f7 f9	 idiv	 rcx
  0036b	4c 8d 40 01	 lea	 r8, QWORD PTR [rax+1]
  0036f	eb 03		 jmp	 SHORT $LN63@audioop_ra
$LN62@audioop_ra:
  00371	4c 8b c6	 mov	 r8, rsi
$LN63@audioop_ra:

; 1188 :         if (outrate > PY_SSIZE_T_MAX / q / bytes_per_frame)

  00374	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0037e	49 63 cc	 movsxd	 rcx, r12d
  00381	48 99		 cdq
  00383	49 f7 f8	 idiv	 r8
  00386	48 99		 cdq
  00388	49 f7 fe	 idiv	 r14
  0038b	48 3b c8	 cmp	 rcx, rax

; 1189 :             str = NULL;
; 1190 :         else

  0038e	0f 8f 85 02 00
	00		 jg	 $LN85@audioop_ra

; 1191 :             str = PyBytes_FromStringAndSize(NULL,
; 1192 :                                             q * outrate * bytes_per_frame);

  00394	49 0f af ce	 imul	 rcx, r14
  00398	49 0f af c8	 imul	 rcx, r8
  0039c	48 8b d1	 mov	 rdx, rcx
$LN110@audioop_ra:
  0039f	33 c9		 xor	 ecx, ecx
  003a1	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  003a6	4c 8b f0	 mov	 r14, rax

; 1193 :     }
; 1194 :     if (str == NULL) {

  003a9	48 85 c0	 test	 rax, rax
  003ac	0f 84 67 02 00
	00		 je	 $LN85@audioop_ra

; 1198 :     }
; 1199 :     ncp = PyBytes_AsString(str);

  003b2	48 8b c8	 mov	 rcx, rax
  003b5	e8 00 00 00 00	 call	 PyBytes_AsString
  003ba	44 8b 45 77	 mov	 r8d, DWORD PTR size$[rbp-121]
  003be	48 8b d8	 mov	 rbx, rax
$LL31@audioop_ra:

; 1200 : 
; 1201 :     for (;;) {
; 1202 :         while (d < 0) {

  003c1	83 7d e7 00	 cmp	 DWORD PTR d$[rbp-121], 0
  003c5	0f 8d d5 00 00
	00		 jge	 $LL12@audioop_ra
  003cb	48 8b 4d f7	 mov	 rcx, QWORD PTR len$[rbp-121]
  003cf	90		 npad	 1
$LL29@audioop_ra:

; 1203 :             if (len == 0) {

  003d0	48 85 c9	 test	 rcx, rcx
  003d3	0f 84 7f 01 00
	00		 je	 $LN73@audioop_ra

; 1227 :             }
; 1228 :             for (chan = 0; chan < nchannels; chan++) {

  003d9	83 7d 7f 00	 cmp	 DWORD PTR nchannels$[rbp-121], 0
  003dd	44 8b ce	 mov	 r9d, esi
  003e0	0f 8e a3 00 00
	00		 jle	 $LN18@audioop_ra
  003e6	4d 8b c5	 mov	 r8, r13
  003e9	49 8b d7	 mov	 rdx, r15
  003ec	4d 2b c7	 sub	 r8, r15
  003ef	90		 npad	 1
$LL20@audioop_ra:

; 1229 :                 prev_i[chan] = cur_i[chan];

  003f0	8b 02		 mov	 eax, DWORD PTR [rdx]
  003f2	41 89 04 10	 mov	 DWORD PTR [r8+rdx], eax

; 1230 :                 if (size == 1)

  003f6	8b 45 77	 mov	 eax, DWORD PTR size$[rbp-121]
  003f9	83 f8 01	 cmp	 eax, 1
  003fc	75 0c		 jne	 SHORT $LN17@audioop_ra

; 1231 :                     cur_i[chan] = ((int)*CHARP(cp, 0)) << 24;

  003fe	48 8b 45 0f	 mov	 rax, QWORD PTR cp$[rbp-121]
  00402	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00405	c1 e1 18	 shl	 ecx, 24
  00408	eb 1c		 jmp	 SHORT $LN111@audioop_ra
$LN17@audioop_ra:

; 1232 :                 else if (size == 2)

  0040a	83 f8 02	 cmp	 eax, 2
  0040d	75 0c		 jne	 SHORT $LN15@audioop_ra

; 1233 :                     cur_i[chan] = ((int)*SHORTP(cp, 0)) << 16;

  0040f	48 8b 45 0f	 mov	 rax, QWORD PTR cp$[rbp-121]
  00413	0f bf 08	 movsx	 ecx, WORD PTR [rax]
  00416	c1 e1 10	 shl	 ecx, 16
  00419	eb 0b		 jmp	 SHORT $LN111@audioop_ra
$LN15@audioop_ra:

; 1234 :                 else if (size == 4)

  0041b	83 f8 04	 cmp	 eax, 4
  0041e	75 0b		 jne	 SHORT $LN13@audioop_ra

; 1235 :                     cur_i[chan] = (int)*LONGP(cp, 0);

  00420	48 8b 45 0f	 mov	 rax, QWORD PTR cp$[rbp-121]
  00424	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN111@audioop_ra:
  00426	89 0a		 mov	 DWORD PTR [rdx], ecx
  00428	8b 45 77	 mov	 eax, DWORD PTR size$[rbp-121]
$LN13@audioop_ra:

; 1236 :                 cp += size;
; 1237 :                 /* implements a simple digital filter */
; 1238 :                 cur_i[chan] = (int)(
; 1239 :                     ((double)weightA * (double)cur_i[chan] +
; 1240 :                      (double)weightB * (double)prev_i[chan]) /
; 1241 :                     ((double)weightA + (double)weightB));

  0042b	66 0f 6e 4d ef	 movd	 xmm1, DWORD PTR weightA$[rbp-121]
  00430	66 0f 6e 55 ff	 movd	 xmm2, DWORD PTR weightB$[rbp-121]
  00435	48 98		 cdqe
  00437	48 01 45 0f	 add	 QWORD PTR cp$[rbp-121], rax
  0043b	41 ff c1	 inc	 r9d
  0043e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00442	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  00446	66 0f 6e 1a	 movd	 xmm3, DWORD PTR [rdx]
  0044a	66 41 0f 6e 04
	10		 movd	 xmm0, DWORD PTR [r8+rdx]
  00450	48 83 c2 04	 add	 rdx, 4
  00454	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
  00458	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0045c	f2 0f 59 d9	 mulsd	 xmm3, xmm1
  00460	f2 0f 59 c2	 mulsd	 xmm0, xmm2
  00464	f2 0f 58 d8	 addsd	 xmm3, xmm0
  00468	f2 0f 58 d1	 addsd	 xmm2, xmm1
  0046c	f2 0f 5e da	 divsd	 xmm3, xmm2
  00470	f2 0f 2c c3	 cvttsd2si eax, xmm3
  00474	89 42 fc	 mov	 DWORD PTR [rdx-4], eax
  00477	44 3b 4d 7f	 cmp	 r9d, DWORD PTR nchannels$[rbp-121]
  0047b	0f 8c 6f ff ff
	ff		 jl	 $LL20@audioop_ra

; 1227 :             }
; 1228 :             for (chan = 0; chan < nchannels; chan++) {

  00481	44 8b 45 77	 mov	 r8d, DWORD PTR size$[rbp-121]
  00485	48 8b 4d f7	 mov	 rcx, QWORD PTR len$[rbp-121]
$LN18@audioop_ra:

; 1242 :             }
; 1243 :             len--;
; 1244 :             d += outrate;

  00489	8b 45 eb	 mov	 eax, DWORD PTR outrate$[rbp-121]
  0048c	48 ff c9	 dec	 rcx
  0048f	01 45 e7	 add	 DWORD PTR d$[rbp-121], eax
  00492	48 89 4d f7	 mov	 QWORD PTR len$[rbp-121], rcx
  00496	0f 88 34 ff ff
	ff		 js	 $LL29@audioop_ra
  0049c	0f 1f 40 00	 npad	 4
$LL12@audioop_ra:

; 1245 :         }
; 1246 :         while (d >= 0) {
; 1247 :             for (chan = 0; chan < nchannels; chan++) {

  004a0	83 7d 7f 00	 cmp	 DWORD PTR nchannels$[rbp-121], 0
  004a4	44 8b d6	 mov	 r10d, esi
  004a7	0f 8e 9a 00 00
	00		 jle	 $LN8@audioop_ra
  004ad	4d 8b df	 mov	 r11, r15
  004b0	4d 8b cd	 mov	 r9, r13
  004b3	4d 2b dd	 sub	 r11, r13
  004b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL10@audioop_ra:

; 1248 :                 cur_o = (int)(((double)prev_i[chan] * (double)d +
; 1249 :                          (double)cur_i[chan] * (double)(outrate - d)) /
; 1250 :                     (double)outrate);

  004c0	8b 55 eb	 mov	 edx, DWORD PTR outrate$[rbp-121]
  004c3	8b 4d e7	 mov	 ecx, DWORD PTR d$[rbp-121]
  004c6	66 43 0f 6e 1c
	19		 movd	 xmm3, DWORD PTR [r9+r11]
  004cc	66 41 0f 6e 11	 movd	 xmm2, DWORD PTR [r9]
  004d1	8b c2		 mov	 eax, edx
  004d3	66 0f 6e c9	 movd	 xmm1, ecx
  004d7	2b c1		 sub	 eax, ecx
  004d9	f3 0f e6 db	 cvtdq2pd xmm3, xmm3
  004dd	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  004e1	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  004e5	66 0f 6e c0	 movd	 xmm0, eax
  004e9	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  004ed	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  004f1	f2 0f 59 d8	 mulsd	 xmm3, xmm0
  004f5	66 0f 6e c2	 movd	 xmm0, edx
  004f9	f2 0f 58 da	 addsd	 xmm3, xmm2
  004fd	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00501	f2 0f 5e d8	 divsd	 xmm3, xmm0
  00505	f2 0f 2c c3	 cvttsd2si eax, xmm3

; 1251 :                 if (size == 1)

  00509	41 83 f8 01	 cmp	 r8d, 1
  0050d	75 07		 jne	 SHORT $LN7@audioop_ra

; 1252 :                     *CHARP(ncp, 0) = (signed char)(cur_o >> 24);

  0050f	c1 f8 18	 sar	 eax, 24
  00512	88 03		 mov	 BYTE PTR [rbx], al
  00514	eb 16		 jmp	 SHORT $LN112@audioop_ra
$LN7@audioop_ra:

; 1253 :                 else if (size == 2)

  00516	41 83 f8 02	 cmp	 r8d, 2
  0051a	75 08		 jne	 SHORT $LN5@audioop_ra

; 1254 :                     *SHORTP(ncp, 0) = (short)(cur_o >> 16);

  0051c	c1 f8 10	 sar	 eax, 16
  0051f	66 89 03	 mov	 WORD PTR [rbx], ax
  00522	eb 08		 jmp	 SHORT $LN112@audioop_ra
$LN5@audioop_ra:

; 1255 :                 else if (size == 4)

  00524	41 83 f8 04	 cmp	 r8d, 4
  00528	75 06		 jne	 SHORT $LN3@audioop_ra

; 1256 :                     *LONGP(ncp, 0) = (Py_Int32)(cur_o);

  0052a	89 03		 mov	 DWORD PTR [rbx], eax
$LN112@audioop_ra:
  0052c	44 8b 45 77	 mov	 r8d, DWORD PTR size$[rbp-121]
$LN3@audioop_ra:

; 1257 :                 ncp += size;

  00530	49 63 c0	 movsxd	 rax, r8d
  00533	41 ff c2	 inc	 r10d
  00536	49 83 c1 04	 add	 r9, 4
  0053a	48 03 d8	 add	 rbx, rax
  0053d	44 3b 55 7f	 cmp	 r10d, DWORD PTR nchannels$[rbp-121]
  00541	0f 8c 79 ff ff
	ff		 jl	 $LL10@audioop_ra
$LN8@audioop_ra:

; 1258 :             }
; 1259 :             d -= inrate;

  00547	8b 45 f3	 mov	 eax, DWORD PTR inrate$[rbp-121]
  0054a	29 45 e7	 sub	 DWORD PTR d$[rbp-121], eax
  0054d	0f 89 4d ff ff
	ff		 jns	 $LL12@audioop_ra

; 1260 :         }
; 1261 :     }

  00553	e9 69 fe ff ff	 jmp	 $LL31@audioop_ra
$LN73@audioop_ra:

; 1204 :                 samps = PyTuple_New(nchannels);

  00558	48 63 4d 7f	 movsxd	 rcx, DWORD PTR nchannels$[rbp-121]
  0055c	e8 00 00 00 00	 call	 PyTuple_New
  00561	48 89 45 07	 mov	 QWORD PTR samps$[rbp-121], rax

; 1205 :                 if (samps == NULL)

  00565	48 85 c0	 test	 rax, rax
  00568	0f 84 c5 00 00
	00		 je	 $LN98@audioop_ra

; 1206 :                     goto exit;
; 1207 :                 for (chan = 0; chan < nchannels; chan++)

  0056e	83 7d 7f 00	 cmp	 DWORD PTR nchannels$[rbp-121], 0
  00572	8b fe		 mov	 edi, esi
  00574	7e 36		 jle	 SHORT $LN23@audioop_ra
  00576	4d 8b e7	 mov	 r12, r15
  00579	49 8b f5	 mov	 rsi, r13
  0057c	4d 2b e5	 sub	 r12, r13
  0057f	90		 npad	 1
$LL25@audioop_ra:

; 1208 :                     PyTuple_SetItem(samps, chan,
; 1209 :                         Py_BuildValue("(ii)",
; 1210 :                                       prev_i[chan],
; 1211 :                                       cur_i[chan]));

  00580	46 8b 04 26	 mov	 r8d, DWORD PTR [rsi+r12]
  00584	8b 16		 mov	 edx, DWORD PTR [rsi]
  00586	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  0058d	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00592	48 8b 4d 07	 mov	 rcx, QWORD PTR samps$[rbp-121]
  00596	48 63 d7	 movsxd	 rdx, edi
  00599	4c 8b c0	 mov	 r8, rax
  0059c	e8 00 00 00 00	 call	 PyTuple_SetItem
  005a1	ff c7		 inc	 edi
  005a3	48 83 c6 04	 add	 rsi, 4
  005a7	3b 7d 7f	 cmp	 edi, DWORD PTR nchannels$[rbp-121]
  005aa	7c d4		 jl	 SHORT $LL25@audioop_ra
$LN23@audioop_ra:

; 1212 :                 if (PyErr_Occurred())

  005ac	e8 00 00 00 00	 call	 PyErr_Occurred
  005b1	48 85 c0	 test	 rax, rax
  005b4	75 7d		 jne	 SHORT $LN98@audioop_ra

; 1213 :                     goto exit;
; 1214 :                 /* We have checked before that the length
; 1215 :                  * of the string fits into int. */
; 1216 :                 len = (Py_ssize_t)(ncp - PyBytes_AsString(str));

  005b6	49 8b ce	 mov	 rcx, r14
  005b9	e8 00 00 00 00	 call	 PyBytes_AsString

; 1217 :                 rv = PyBytes_FromStringAndSize
; 1218 :                     (PyBytes_AsString(str), len);

  005be	49 8b ce	 mov	 rcx, r14
  005c1	48 2b d8	 sub	 rbx, rax
  005c4	48 89 5d f7	 mov	 QWORD PTR len$[rbp-121], rbx
  005c8	e8 00 00 00 00	 call	 PyBytes_AsString
  005cd	48 8b 55 f7	 mov	 rdx, QWORD PTR len$[rbp-121]
  005d1	48 8b c8	 mov	 rcx, rax
  005d4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1219 :                 Py_DECREF(str);

  005d9	49 8b ce	 mov	 rcx, r14
  005dc	48 8b f8	 mov	 rdi, rax
  005df	e8 00 00 00 00	 call	 _Py_DecRef

; 1220 :                 str = rv;

  005e4	48 8b df	 mov	 rbx, rdi

; 1221 :                 if (str == NULL)

  005e7	48 85 ff	 test	 rdi, rdi
  005ea	74 49		 je	 SHORT $exit$21182

; 1222 :                     goto exit;
; 1223 :                 rv = Py_BuildValue("(O(iO))", str, d, samps);

  005ec	4c 8b 4d 07	 mov	 r9, QWORD PTR samps$[rbp-121]
  005f0	44 8b 45 e7	 mov	 r8d, DWORD PTR d$[rbp-121]
  005f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@
  005fb	48 8b d7	 mov	 rdx, rdi
  005fe	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1224 :                 Py_DECREF(samps);

  00603	48 8b 4d 07	 mov	 rcx, QWORD PTR samps$[rbp-121]
  00607	48 8b f8	 mov	 rdi, rax
  0060a	e8 00 00 00 00	 call	 _Py_DecRef

; 1225 :                 Py_DECREF(str);

  0060f	48 8b cb	 mov	 rcx, rbx
  00612	e8 00 00 00 00	 call	 _Py_DecRef

; 1226 :                 goto exit; /* return rv */

  00617	eb 1c		 jmp	 SHORT $exit$21182
$LN85@audioop_ra:

; 1195 :         PyErr_SetString(PyExc_MemoryError,
; 1196 :             "not enough memory for output buffer");

  00619	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00620	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00627	e8 00 00 00 00	 call	 PyErr_SetString

; 1197 :         goto exit;

  0062c	eb 05		 jmp	 SHORT $LN98@audioop_ra
$LN48@audioop_ra:

; 1146 :         (void) PyErr_NoMemory();

  0062e	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN98@audioop_ra:

; 1156 :     }
; 1157 :     else {

  00633	33 ff		 xor	 edi, edi
$exit$21182:

; 1262 :   exit:
; 1263 :     if (prev_i != NULL)

  00635	4d 85 ed	 test	 r13, r13
  00638	74 09		 je	 SHORT $LN2@audioop_ra

; 1264 :         free(prev_i);

  0063a	49 8b cd	 mov	 rcx, r13
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@audioop_ra:

; 1265 :     if (cur_i != NULL)

  00643	4d 85 ff	 test	 r15, r15
  00646	74 09		 je	 SHORT $LN1@audioop_ra

; 1266 :         free(cur_i);

  00648	49 8b cf	 mov	 rcx, r15
  0064b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@audioop_ra:

; 1267 :     return rv;

  00651	4c 8b bc 24 a0
	00 00 00	 mov	 r15, QWORD PTR [rsp+160]
  00659	48 8b c7	 mov	 rax, rdi
  0065c	e9 90 fb ff ff	 jmp	 $LN108@audioop_ra
$LN51@audioop_ra:

; 1126 :         PyErr_SetString(AudioopError, "sampling rate not > 0");

  00661	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00668	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@
  0066f	e8 00 00 00 00	 call	 PyErr_SetString

; 1127 :         return NULL;

  00674	33 c0		 xor	 eax, eax
  00676	e9 7e fb ff ff	 jmp	 $LN107@audioop_ra
$LN54@audioop_ra:

; 1117 :         PyErr_SetString(AudioopError,
; 1118 :             "weightA should be >= 1, weightB should be >= 0");

  0067b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@
  00689	e8 00 00 00 00	 call	 PyErr_SetString

; 1119 :         return NULL;

  0068e	33 c0		 xor	 eax, eax
  00690	e9 7c fb ff ff	 jmp	 $LN104@audioop_ra
audioop_ratecv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2ulaw DD imagerel audioop_lin2ulaw
	DD	imagerel audioop_lin2ulaw+86
	DD	imagerel $unwind$audioop_lin2ulaw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_lin2ulaw DD imagerel audioop_lin2ulaw+86
	DD	imagerel audioop_lin2ulaw+125
	DD	imagerel $chain$0$audioop_lin2ulaw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_lin2ulaw DD imagerel audioop_lin2ulaw+125
	DD	imagerel audioop_lin2ulaw+263
	DD	imagerel $chain$4$audioop_lin2ulaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_lin2ulaw DD 060d21H
	DD	08640dH
	DD	0c3408H
	DD	095400H
	DD	imagerel audioop_lin2ulaw
	DD	imagerel audioop_lin2ulaw+86
	DD	imagerel $unwind$audioop_lin2ulaw
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_lin2ulaw DD 020521H
	DD	095405H
	DD	imagerel audioop_lin2ulaw
	DD	imagerel audioop_lin2ulaw+86
	DD	imagerel $unwind$audioop_lin2ulaw
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2ulaw DD 020601H
	DD	070029206H
xdata	ENDS
;	COMDAT ??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@
CONST	SEGMENT
??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@ DB 's#i:lin2ulaw', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_lin2ulaw
_TEXT	SEGMENT
cp$ = 48
self$ = 96
args$ = 104
size$ = 112
len$ = 120
audioop_lin2ulaw PROC					; COMDAT

; 1272 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b c2	 mov	 rax, rdx

; 1273 :     signed char *cp;
; 1274 :     unsigned char *ncp;
; 1275 :     Py_ssize_t len, i;
; 1276 :     int size, val = 0;
; 1277 :     PyObject *rv;
; 1278 : 
; 1279 :     if ( !PyArg_ParseTuple(args, "s#i:lin2ulaw",
; 1280 :                            &cp, &len, &size) )

  00009	48 8d 4c 24 70	 lea	 rcx, QWORD PTR size$[rsp]
  0000e	4c 8d 4c 24 78	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@
  00024	48 8b c8	 mov	 rcx, rax
  00027	33 ff		 xor	 edi, edi
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 08		 jne	 SHORT $LN11@audioop_li@2
$LN17@audioop_li@2:

; 1281 :         return 0 ;

  00032	33 c0		 xor	 eax, eax

; 1299 : }

  00034	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
$LN11@audioop_li@2:

; 1282 : 
; 1283 :     if (!audioop_check_parameters(len, size))

  0003a	8b 54 24 70	 mov	 edx, DWORD PTR size$[rsp]
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  00043	e8 00 00 00 00	 call	 audioop_check_parameters
  00048	85 c0		 test	 eax, eax

; 1284 :         return NULL;

  0004a	74 e6		 je	 SHORT $LN17@audioop_li@2

; 1285 : 
; 1286 :     rv = PyBytes_FromStringAndSize(NULL, len/size);

  0004c	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR size$[rsp]
  00051	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  00056	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0005b	48 99		 cdq
  0005d	48 f7 f9	 idiv	 rcx
  00060	33 c9		 xor	 ecx, ecx
  00062	48 8b d0	 mov	 rdx, rax
  00065	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0006a	48 8b e8	 mov	 rbp, rax

; 1287 :     if ( rv == 0 )

  0006d	48 85 c0	 test	 rax, rax
  00070	75 0b		 jne	 SHORT $LN9@audioop_li@2
  00072	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1299 : }

  00077	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN9@audioop_li@2:

; 1288 :         return 0;
; 1289 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  0007d	48 8b c8	 mov	 rcx, rax
  00080	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00085	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0008a	e8 00 00 00 00	 call	 PyBytes_AsString

; 1290 : 
; 1291 :     for ( i=0; i < len; i += size ) {

  0008f	48 8b df	 mov	 rbx, rdi
  00092	48 8b f0	 mov	 rsi, rax
  00095	48 39 5c 24 78	 cmp	 QWORD PTR len$[rsp], rbx
  0009a	7e 53		 jle	 SHORT $LN6@audioop_li@2
  0009c	8b 4c 24 70	 mov	 ecx, DWORD PTR size$[rsp]
$LL8@audioop_li@2:

; 1292 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  000a0	83 f9 01	 cmp	 ecx, 1
  000a3	75 0e		 jne	 SHORT $LN5@audioop_li@2
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000aa	0f be 3c 0b	 movsx	 edi, BYTE PTR [rbx+rcx]
  000ae	c1 e7 08	 shl	 edi, 8
  000b1	eb 1f		 jmp	 SHORT $LN1@audioop_li@2
$LN5@audioop_li@2:

; 1293 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000b3	83 f9 02	 cmp	 ecx, 2
  000b6	75 0b		 jne	 SHORT $LN3@audioop_li@2
  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000bd	0f bf 3c 03	 movsx	 edi, WORD PTR [rbx+rax]
  000c1	eb 0f		 jmp	 SHORT $LN1@audioop_li@2
$LN3@audioop_li@2:

; 1294 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  000c3	83 f9 04	 cmp	 ecx, 4
  000c6	75 0a		 jne	 SHORT $LN1@audioop_li@2
  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000cd	0f bf 7c 03 02	 movsx	 edi, WORD PTR [rbx+rax+2]
$LN1@audioop_li@2:

; 1295 : 
; 1296 :         *ncp++ = st_14linear2ulaw(val);

  000d2	0f b7 cf	 movzx	 ecx, di
  000d5	e8 00 00 00 00	 call	 st_14linear2ulaw
  000da	48 ff c6	 inc	 rsi
  000dd	88 46 ff	 mov	 BYTE PTR [rsi-1], al
  000e0	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR size$[rsp]
  000e5	48 03 d9	 add	 rbx, rcx
  000e8	48 3b 5c 24 78	 cmp	 rbx, QWORD PTR len$[rsp]
  000ed	7c b1		 jl	 SHORT $LL8@audioop_li@2
$LN6@audioop_li@2:
  000ef	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 1297 :     }
; 1298 :     return rv;

  000f9	48 8b c5	 mov	 rax, rbp
  000fc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1299 : }

  00101	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
audioop_lin2ulaw ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_ulaw2lin DD imagerel audioop_ulaw2lin
	DD	imagerel audioop_ulaw2lin+121
	DD	imagerel $unwind$audioop_ulaw2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_ulaw2lin DD imagerel audioop_ulaw2lin+121
	DD	imagerel audioop_ulaw2lin+149
	DD	imagerel $chain$0$audioop_ulaw2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_ulaw2lin DD imagerel audioop_ulaw2lin+149
	DD	imagerel audioop_ulaw2lin+286
	DD	imagerel $chain$2$audioop_ulaw2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_ulaw2lin DD 020021H
	DD	083400H
	DD	imagerel audioop_ulaw2lin
	DD	imagerel audioop_ulaw2lin+121
	DD	imagerel $unwind$audioop_ulaw2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_ulaw2lin DD 020521H
	DD	083405H
	DD	imagerel audioop_ulaw2lin
	DD	imagerel audioop_ulaw2lin+121
	DD	imagerel $unwind$audioop_ulaw2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_ulaw2lin DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@
CONST	SEGMENT
??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@ DB 's#i:ulaw2lin', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_ulaw2lin
_TEXT	SEGMENT
len$ = 48
self$ = 80
args$ = 88
size$ = 96
cp$ = 104
audioop_ulaw2lin PROC					; COMDAT

; 1303 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 1304 :     unsigned char *cp;
; 1305 :     unsigned char cval;
; 1306 :     signed char *ncp;
; 1307 :     Py_ssize_t len, i;
; 1308 :     int size, val;
; 1309 :     PyObject *rv;
; 1310 : 
; 1311 :     if ( !PyArg_ParseTuple(args, "s#i:ulaw2lin",
; 1312 :                            &cp, &len, &size) )

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0000c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 44 24 68	 lea	 r8, QWORD PTR cp$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax

; 1313 :         return 0;

  0002c	74 3e		 je	 SHORT $LN19@audioop_ul

; 1314 : 
; 1315 :     if (!audioop_check_size(size))

  0002e	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  00032	e8 00 00 00 00	 call	 audioop_check_size
  00037	85 c0		 test	 eax, eax

; 1316 :         return NULL;

  00039	74 31		 je	 SHORT $LN19@audioop_ul

; 1317 : 
; 1318 :     if (len > PY_SSIZE_T_MAX/size) {

  0003b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR size$[rsp]
  00040	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004a	48 99		 cdq
  0004c	48 f7 f9	 idiv	 rcx
  0004f	48 8b 54 24 30	 mov	 rdx, QWORD PTR len$[rsp]
  00054	48 3b d0	 cmp	 rdx, rax
  00057	7e 1a		 jle	 SHORT $LN10@audioop_ul

; 1319 :         PyErr_SetString(PyExc_MemoryError,
; 1320 :                         "not enough memory for output buffer");

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00067	e8 00 00 00 00	 call	 PyErr_SetString
$LN19@audioop_ul:

; 1321 :         return 0;

  0006c	33 c0		 xor	 eax, eax

; 1337 : }

  0006e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00072	c3		 ret	 0
$LN10@audioop_ul:

; 1322 :     }
; 1323 :     rv = PyBytes_FromStringAndSize(NULL, len*size);

  00073	48 0f af d1	 imul	 rdx, rcx
  00077	33 c9		 xor	 ecx, ecx
  00079	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0007e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00083	48 8b d8	 mov	 rbx, rax

; 1324 :     if ( rv == 0 )

  00086	48 85 c0	 test	 rax, rax
  00089	75 0a		 jne	 SHORT $LN9@audioop_ul
  0008b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1337 : }

  00090	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00094	c3		 ret	 0
$LN9@audioop_ul:

; 1325 :         return 0;
; 1326 :     ncp = (signed char *)PyBytes_AsString(rv);

  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 PyBytes_AsString

; 1327 : 
; 1328 :     for ( i=0; i < len*size; i += size ) {

  0009d	4c 63 44 24 60	 movsxd	 r8, DWORD PTR size$[rsp]
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	49 8b c8	 mov	 rcx, r8
  000a8	4c 8b d8	 mov	 r11, rax
  000ab	48 0f af 4c 24
	30		 imul	 rcx, QWORD PTR len$[rsp]
  000b1	48 85 c9	 test	 rcx, rcx
  000b4	7e 5b		 jle	 SHORT $LN6@audioop_ul
  000b6	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_st_ulaw2linear16
  000bd	0f 1f 00	 npad	 3
$LL8@audioop_ul:

; 1329 :         cval = *cp++;

  000c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cp$[rsp]
  000c5	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  000c8	48 ff 44 24 68	 inc	 QWORD PTR cp$[rsp]

; 1330 :         val = st_ulaw2linear16(cval);

  000cd	41 0f bf 0c 52	 movsx	 ecx, WORD PTR [r10+rdx*2]

; 1331 : 
; 1332 :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);

  000d2	41 83 f8 01	 cmp	 r8d, 1
  000d6	75 09		 jne	 SHORT $LN5@audioop_ul
  000d8	c1 f9 08	 sar	 ecx, 8
  000db	43 88 0c 19	 mov	 BYTE PTR [r9+r11], cl
  000df	eb 1a		 jmp	 SHORT $LN18@audioop_ul
$LN5@audioop_ul:

; 1333 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);

  000e1	41 83 f8 02	 cmp	 r8d, 2
  000e5	75 07		 jne	 SHORT $LN3@audioop_ul
  000e7	66 43 89 0c 19	 mov	 WORD PTR [r9+r11], cx
  000ec	eb 0d		 jmp	 SHORT $LN18@audioop_ul
$LN3@audioop_ul:

; 1334 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);

  000ee	41 83 f8 04	 cmp	 r8d, 4
  000f2	75 0c		 jne	 SHORT $LN7@audioop_ul
  000f4	c1 e1 10	 shl	 ecx, 16
  000f7	43 89 0c 19	 mov	 DWORD PTR [r9+r11], ecx
$LN18@audioop_ul:
  000fb	44 8b 44 24 60	 mov	 r8d, DWORD PTR size$[rsp]
$LN7@audioop_ul:

; 1327 : 
; 1328 :     for ( i=0; i < len*size; i += size ) {

  00100	49 63 c0	 movsxd	 rax, r8d
  00103	4c 03 c8	 add	 r9, rax
  00106	48 0f af 44 24
	30		 imul	 rax, QWORD PTR len$[rsp]
  0010c	4c 3b c8	 cmp	 r9, rax
  0010f	7c af		 jl	 SHORT $LL8@audioop_ul
$LN6@audioop_ul:

; 1335 :     }
; 1336 :     return rv;

  00111	48 8b c3	 mov	 rax, rbx
  00114	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1337 : }

  00119	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011d	c3		 ret	 0
audioop_ulaw2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2alaw DD imagerel audioop_lin2alaw
	DD	imagerel audioop_lin2alaw+86
	DD	imagerel $unwind$audioop_lin2alaw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_lin2alaw DD imagerel audioop_lin2alaw+86
	DD	imagerel audioop_lin2alaw+125
	DD	imagerel $chain$0$audioop_lin2alaw
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_lin2alaw DD imagerel audioop_lin2alaw+125
	DD	imagerel audioop_lin2alaw+263
	DD	imagerel $chain$4$audioop_lin2alaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_lin2alaw DD 060d21H
	DD	08640dH
	DD	0c3408H
	DD	095400H
	DD	imagerel audioop_lin2alaw
	DD	imagerel audioop_lin2alaw+86
	DD	imagerel $unwind$audioop_lin2alaw
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_lin2alaw DD 020521H
	DD	095405H
	DD	imagerel audioop_lin2alaw
	DD	imagerel audioop_lin2alaw+86
	DD	imagerel $unwind$audioop_lin2alaw
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2alaw DD 020601H
	DD	070029206H
xdata	ENDS
;	COMDAT ??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@
CONST	SEGMENT
??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@ DB 's#i:lin2alaw', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_lin2alaw
_TEXT	SEGMENT
cp$ = 48
self$ = 96
args$ = 104
size$ = 112
len$ = 120
audioop_lin2alaw PROC					; COMDAT

; 1341 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b c2	 mov	 rax, rdx

; 1342 :     signed char *cp;
; 1343 :     unsigned char *ncp;
; 1344 :     Py_ssize_t len, i;
; 1345 :     int size, val = 0;
; 1346 :     PyObject *rv;
; 1347 : 
; 1348 :     if ( !PyArg_ParseTuple(args, "s#i:lin2alaw",
; 1349 :                            &cp, &len, &size) )

  00009	48 8d 4c 24 70	 lea	 rcx, QWORD PTR size$[rsp]
  0000e	4c 8d 4c 24 78	 lea	 r9, QWORD PTR len$[rsp]
  00013	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@
  00024	48 8b c8	 mov	 rcx, rax
  00027	33 ff		 xor	 edi, edi
  00029	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 08		 jne	 SHORT $LN11@audioop_li@3
$LN17@audioop_li@3:

; 1350 :         return 0;

  00032	33 c0		 xor	 eax, eax

; 1368 : }

  00034	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
$LN11@audioop_li@3:

; 1351 : 
; 1352 :     if (!audioop_check_parameters(len, size))

  0003a	8b 54 24 70	 mov	 edx, DWORD PTR size$[rsp]
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  00043	e8 00 00 00 00	 call	 audioop_check_parameters
  00048	85 c0		 test	 eax, eax

; 1353 :         return NULL;

  0004a	74 e6		 je	 SHORT $LN17@audioop_li@3

; 1354 : 
; 1355 :     rv = PyBytes_FromStringAndSize(NULL, len/size);

  0004c	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR size$[rsp]
  00051	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  00056	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0005b	48 99		 cdq
  0005d	48 f7 f9	 idiv	 rcx
  00060	33 c9		 xor	 ecx, ecx
  00062	48 8b d0	 mov	 rdx, rax
  00065	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0006a	48 8b e8	 mov	 rbp, rax

; 1356 :     if ( rv == 0 )

  0006d	48 85 c0	 test	 rax, rax
  00070	75 0b		 jne	 SHORT $LN9@audioop_li@3
  00072	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1368 : }

  00077	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
$LN9@audioop_li@3:

; 1357 :         return 0;
; 1358 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  0007d	48 8b c8	 mov	 rcx, rax
  00080	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00085	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0008a	e8 00 00 00 00	 call	 PyBytes_AsString

; 1359 : 
; 1360 :     for ( i=0; i < len; i += size ) {

  0008f	48 8b df	 mov	 rbx, rdi
  00092	48 8b f0	 mov	 rsi, rax
  00095	48 39 5c 24 78	 cmp	 QWORD PTR len$[rsp], rbx
  0009a	7e 53		 jle	 SHORT $LN6@audioop_li@3
  0009c	8b 4c 24 70	 mov	 ecx, DWORD PTR size$[rsp]
$LL8@audioop_li@3:

; 1361 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  000a0	83 f9 01	 cmp	 ecx, 1
  000a3	75 0e		 jne	 SHORT $LN5@audioop_li@3
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000aa	0f be 3c 0b	 movsx	 edi, BYTE PTR [rbx+rcx]
  000ae	c1 e7 08	 shl	 edi, 8
  000b1	eb 1f		 jmp	 SHORT $LN1@audioop_li@3
$LN5@audioop_li@3:

; 1362 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000b3	83 f9 02	 cmp	 ecx, 2
  000b6	75 0b		 jne	 SHORT $LN3@audioop_li@3
  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000bd	0f bf 3c 03	 movsx	 edi, WORD PTR [rbx+rax]
  000c1	eb 0f		 jmp	 SHORT $LN1@audioop_li@3
$LN3@audioop_li@3:

; 1363 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  000c3	83 f9 04	 cmp	 ecx, 4
  000c6	75 0a		 jne	 SHORT $LN1@audioop_li@3
  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000cd	0f bf 7c 03 02	 movsx	 edi, WORD PTR [rbx+rax+2]
$LN1@audioop_li@3:

; 1364 : 
; 1365 :         *ncp++ = st_linear2alaw(val);

  000d2	0f b7 cf	 movzx	 ecx, di
  000d5	e8 00 00 00 00	 call	 st_linear2alaw
  000da	48 ff c6	 inc	 rsi
  000dd	88 46 ff	 mov	 BYTE PTR [rsi-1], al
  000e0	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR size$[rsp]
  000e5	48 03 d9	 add	 rbx, rcx
  000e8	48 3b 5c 24 78	 cmp	 rbx, QWORD PTR len$[rsp]
  000ed	7c b1		 jl	 SHORT $LL8@audioop_li@3
$LN6@audioop_li@3:
  000ef	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 1366 :     }
; 1367 :     return rv;

  000f9	48 8b c5	 mov	 rax, rbp
  000fc	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 1368 : }

  00101	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
audioop_lin2alaw ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_alaw2lin DD imagerel audioop_alaw2lin
	DD	imagerel audioop_alaw2lin+121
	DD	imagerel $unwind$audioop_alaw2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_alaw2lin DD imagerel audioop_alaw2lin+121
	DD	imagerel audioop_alaw2lin+149
	DD	imagerel $chain$0$audioop_alaw2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$audioop_alaw2lin DD imagerel audioop_alaw2lin+149
	DD	imagerel audioop_alaw2lin+286
	DD	imagerel $chain$2$audioop_alaw2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$audioop_alaw2lin DD 020021H
	DD	083400H
	DD	imagerel audioop_alaw2lin
	DD	imagerel audioop_alaw2lin+121
	DD	imagerel $unwind$audioop_alaw2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_alaw2lin DD 020521H
	DD	083405H
	DD	imagerel audioop_alaw2lin
	DD	imagerel audioop_alaw2lin+121
	DD	imagerel $unwind$audioop_alaw2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_alaw2lin DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@
CONST	SEGMENT
??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@ DB 's#i:alaw2lin', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_alaw2lin
_TEXT	SEGMENT
len$ = 48
self$ = 80
args$ = 88
size$ = 96
cp$ = 104
audioop_alaw2lin PROC					; COMDAT

; 1372 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00004	48 8b c2	 mov	 rax, rdx

; 1373 :     unsigned char *cp;
; 1374 :     unsigned char cval;
; 1375 :     signed char *ncp;
; 1376 :     Py_ssize_t len, i;
; 1377 :     int size, val;
; 1378 :     PyObject *rv;
; 1379 : 
; 1380 :     if ( !PyArg_ParseTuple(args, "s#i:alaw2lin",
; 1381 :                            &cp, &len, &size) )

  00007	48 8d 4c 24 60	 lea	 rcx, QWORD PTR size$[rsp]
  0000c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	4c 8d 44 24 68	 lea	 r8, QWORD PTR cp$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax

; 1382 :         return 0;

  0002c	74 3e		 je	 SHORT $LN19@audioop_al

; 1383 : 
; 1384 :     if (!audioop_check_size(size))

  0002e	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  00032	e8 00 00 00 00	 call	 audioop_check_size
  00037	85 c0		 test	 eax, eax

; 1385 :         return NULL;

  00039	74 31		 je	 SHORT $LN19@audioop_al

; 1386 : 
; 1387 :     if (len > PY_SSIZE_T_MAX/size) {

  0003b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR size$[rsp]
  00040	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004a	48 99		 cdq
  0004c	48 f7 f9	 idiv	 rcx
  0004f	48 8b 54 24 30	 mov	 rdx, QWORD PTR len$[rsp]
  00054	48 3b d0	 cmp	 rdx, rax
  00057	7e 1a		 jle	 SHORT $LN10@audioop_al

; 1388 :         PyErr_SetString(PyExc_MemoryError,
; 1389 :                         "not enough memory for output buffer");

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00067	e8 00 00 00 00	 call	 PyErr_SetString
$LN19@audioop_al:

; 1390 :         return 0;

  0006c	33 c0		 xor	 eax, eax

; 1406 : }

  0006e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00072	c3		 ret	 0
$LN10@audioop_al:

; 1391 :     }
; 1392 :     rv = PyBytes_FromStringAndSize(NULL, len*size);

  00073	48 0f af d1	 imul	 rdx, rcx
  00077	33 c9		 xor	 ecx, ecx
  00079	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  0007e	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00083	48 8b d8	 mov	 rbx, rax

; 1393 :     if ( rv == 0 )

  00086	48 85 c0	 test	 rax, rax
  00089	75 0a		 jne	 SHORT $LN9@audioop_al
  0008b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1406 : }

  00090	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00094	c3		 ret	 0
$LN9@audioop_al:

; 1394 :         return 0;
; 1395 :     ncp = (signed char *)PyBytes_AsString(rv);

  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 PyBytes_AsString

; 1396 : 
; 1397 :     for ( i=0; i < len*size; i += size ) {

  0009d	4c 63 44 24 60	 movsxd	 r8, DWORD PTR size$[rsp]
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	49 8b c8	 mov	 rcx, r8
  000a8	4c 8b d8	 mov	 r11, rax
  000ab	48 0f af 4c 24
	30		 imul	 rcx, QWORD PTR len$[rsp]
  000b1	48 85 c9	 test	 rcx, rcx
  000b4	7e 5b		 jle	 SHORT $LN6@audioop_al
  000b6	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_st_alaw2linear16
  000bd	0f 1f 00	 npad	 3
$LL8@audioop_al:

; 1398 :         cval = *cp++;

  000c0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cp$[rsp]
  000c5	0f b6 11	 movzx	 edx, BYTE PTR [rcx]
  000c8	48 ff 44 24 68	 inc	 QWORD PTR cp$[rsp]

; 1399 :         val = st_alaw2linear16(cval);

  000cd	41 0f bf 0c 52	 movsx	 ecx, WORD PTR [r10+rdx*2]

; 1400 : 
; 1401 :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);

  000d2	41 83 f8 01	 cmp	 r8d, 1
  000d6	75 09		 jne	 SHORT $LN5@audioop_al
  000d8	c1 f9 08	 sar	 ecx, 8
  000db	43 88 0c 19	 mov	 BYTE PTR [r9+r11], cl
  000df	eb 1a		 jmp	 SHORT $LN18@audioop_al
$LN5@audioop_al:

; 1402 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);

  000e1	41 83 f8 02	 cmp	 r8d, 2
  000e5	75 07		 jne	 SHORT $LN3@audioop_al
  000e7	66 43 89 0c 19	 mov	 WORD PTR [r9+r11], cx
  000ec	eb 0d		 jmp	 SHORT $LN18@audioop_al
$LN3@audioop_al:

; 1403 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);

  000ee	41 83 f8 04	 cmp	 r8d, 4
  000f2	75 0c		 jne	 SHORT $LN7@audioop_al
  000f4	c1 e1 10	 shl	 ecx, 16
  000f7	43 89 0c 19	 mov	 DWORD PTR [r9+r11], ecx
$LN18@audioop_al:
  000fb	44 8b 44 24 60	 mov	 r8d, DWORD PTR size$[rsp]
$LN7@audioop_al:

; 1396 : 
; 1397 :     for ( i=0; i < len*size; i += size ) {

  00100	49 63 c0	 movsxd	 rax, r8d
  00103	4c 03 c8	 add	 r9, rax
  00106	48 0f af 44 24
	30		 imul	 rax, QWORD PTR len$[rsp]
  0010c	4c 3b c8	 cmp	 r9, rax
  0010f	7c af		 jl	 SHORT $LL8@audioop_al
$LN6@audioop_al:

; 1404 :     }
; 1405 :     return rv;

  00111	48 8b c3	 mov	 rax, rbx
  00114	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 1406 : }

  00119	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011d	c3		 ret	 0
audioop_alaw2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@	; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
PUBLIC	??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2adpcm DD imagerel audioop_lin2adpcm
	DD	imagerel audioop_lin2adpcm+101
	DD	imagerel $unwind$audioop_lin2adpcm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_lin2adpcm DD imagerel audioop_lin2adpcm+101
	DD	imagerel audioop_lin2adpcm+229
	DD	imagerel $chain$0$audioop_lin2adpcm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$audioop_lin2adpcm DD imagerel audioop_lin2adpcm+229
	DD	imagerel audioop_lin2adpcm+290
	DD	imagerel $chain$4$audioop_lin2adpcm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_lin2adpcm DD imagerel audioop_lin2adpcm+290
	DD	imagerel audioop_lin2adpcm+636
	DD	imagerel $chain$6$audioop_lin2adpcm
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$audioop_lin2adpcm DD imagerel audioop_lin2adpcm+636
	DD	imagerel audioop_lin2adpcm+698
	DD	imagerel $chain$7$audioop_lin2adpcm
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$audioop_lin2adpcm DD 021H
	DD	imagerel audioop_lin2adpcm+229
	DD	imagerel audioop_lin2adpcm+290
	DD	imagerel $chain$4$audioop_lin2adpcm
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_lin2adpcm DD 040d21H
	DD	0ec40dH
	DD	0f7405H
	DD	imagerel audioop_lin2adpcm+229
	DD	imagerel audioop_lin2adpcm+290
	DD	imagerel $chain$4$audioop_lin2adpcm
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$audioop_lin2adpcm DD 061521H
	DD	0de415H
	DD	0146410H
	DD	0cf400H
	DD	imagerel audioop_lin2adpcm
	DD	imagerel audioop_lin2adpcm+101
	DD	imagerel $unwind$audioop_lin2adpcm
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_lin2adpcm DD 020521H
	DD	0cf405H
	DD	imagerel audioop_lin2adpcm
	DD	imagerel audioop_lin2adpcm+101
	DD	imagerel $unwind$audioop_lin2adpcm
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2adpcm DD 040f01H
	DD	0d005f20fH
	DD	050023003H
xdata	ENDS
;	COMDAT ??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@ DB '(O(ii))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@
CONST	SEGMENT
??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@ DB 's#iO:lin2adpcm', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_lin2adpcm
_TEXT	SEGMENT
size$ = 48
bufferstep$1$ = 52
len$ = 56
ncp$1$ = 64
cp$ = 72
state$ = 80
str$1$ = 88
self$ = 160
args$ = 168
valpred$ = 176
index$ = 184
audioop_lin2adpcm PROC					; COMDAT

; 1410 : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	41 55		 push	 r13
  00005	48 8b ec	 mov	 rbp, rsp
  00008	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000f	48 8b c2	 mov	 rax, rdx

; 1411 :     signed char *cp;
; 1412 :     signed char *ncp;
; 1413 :     Py_ssize_t len, i;
; 1414 :     int size, val = 0, step, valpred, delta,
; 1415 :         index, sign, vpdiff, diff;
; 1416 :     PyObject *rv, *state, *str;
; 1417 :     int outputbuffer = 0, bufferstep;
; 1418 : 
; 1419 :     if ( !PyArg_ParseTuple(args, "s#iO:lin2adpcm",
; 1420 :                            &cp, &len, &size, &state) )

  00012	48 8d 4d d0	 lea	 rcx, QWORD PTR state$[rbp-128]
  00016	4c 8d 4d b8	 lea	 r9, QWORD PTR len$[rbp-128]
  0001a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001f	48 8d 4d b0	 lea	 rcx, QWORD PTR size$[rbp-128]
  00023	4c 8d 45 c8	 lea	 r8, QWORD PTR cp$[rbp-128]
  00027	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@
  00033	48 8b c8	 mov	 rcx, rax
  00036	33 db		 xor	 ebx, ebx
  00038	45 33 ed	 xor	 r13d, r13d
  0003b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00040	85 c0		 test	 eax, eax
  00042	75 0e		 jne	 SHORT $LN27@audioop_li@4
$LN37@audioop_li@4:

; 1421 :         return 0;

  00044	33 c0		 xor	 eax, eax

; 1512 : }

  00046	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0004d	41 5d		 pop	 r13
  0004f	5b		 pop	 rbx
  00050	5d		 pop	 rbp
  00051	c3		 ret	 0
$LN27@audioop_li@4:

; 1422 : 
; 1423 :     if (!audioop_check_parameters(len, size))

  00052	8b 55 b0	 mov	 edx, DWORD PTR size$[rbp-128]
  00055	48 8b 4d b8	 mov	 rcx, QWORD PTR len$[rbp-128]
  00059	e8 00 00 00 00	 call	 audioop_check_parameters
  0005e	85 c0		 test	 eax, eax

; 1424 :         return NULL;

  00060	74 e2		 je	 SHORT $LN37@audioop_li@4

; 1425 : 
; 1426 :     str = PyBytes_FromStringAndSize(NULL, len/(size*2));

  00062	8b 45 b0	 mov	 eax, DWORD PTR size$[rbp-128]
  00065	4c 89 7c 24 60	 mov	 QWORD PTR [rsp+96], r15
  0006a	03 c0		 add	 eax, eax
  0006c	48 63 c8	 movsxd	 rcx, eax
  0006f	48 8b 45 b8	 mov	 rax, QWORD PTR len$[rbp-128]
  00073	48 99		 cdq
  00075	48 f7 f9	 idiv	 rcx
  00078	33 c9		 xor	 ecx, ecx
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00082	4c 8b f8	 mov	 r15, rax
  00085	48 89 45 d8	 mov	 QWORD PTR str$1$[rbp-128], rax

; 1427 :     if ( str == 0 )

  00089	48 85 c0	 test	 rax, rax

; 1428 :         return 0;

  0008c	74 44		 je	 SHORT $LN36@audioop_li@4

; 1429 :     ncp = (signed char *)PyBytes_AsString(str);

  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 PyBytes_AsString

; 1430 : 
; 1431 :     /* Decode state, should have (value, step) */
; 1432 :     if ( state == Py_None ) {

  00096	48 8b 4d d0	 mov	 rcx, QWORD PTR state$[rbp-128]
  0009a	48 89 45 c0	 mov	 QWORD PTR ncp$1$[rbp-128], rax
  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a5	48 3b c8	 cmp	 rcx, rax
  000a8	75 10		 jne	 SHORT $LN24@audioop_li@4

; 1433 :         /* First time, it seems. Set defaults */
; 1434 :         valpred = 0;

  000aa	45 33 c0	 xor	 r8d, r8d

; 1435 :         index = 0;

  000ad	45 33 d2	 xor	 r10d, r10d
  000b0	44 89 55 38	 mov	 DWORD PTR index$[rbp-128], r10d
  000b4	44 89 45 30	 mov	 DWORD PTR valpred$[rbp-128], r8d
  000b8	eb 33		 jmp	 SHORT $LN22@audioop_li@4
$LN24@audioop_li@4:

; 1436 :     } else if ( !PyArg_ParseTuple(state, "ii", &valpred, &index) )

  000ba	4c 8d 4d 38	 lea	 r9, QWORD PTR index$[rbp-128]
  000be	4c 8d 45 30	 lea	 r8, QWORD PTR valpred$[rbp-128]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  000c9	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000ce	85 c0		 test	 eax, eax
  000d0	75 13		 jne	 SHORT $LN32@audioop_li@4
$LN36@audioop_li@4:

; 1437 :         return 0;

  000d2	33 c0		 xor	 eax, eax
  000d4	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 1512 : }

  000d9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000e0	41 5d		 pop	 r13
  000e2	5b		 pop	 rbx
  000e3	5d		 pop	 rbp
  000e4	c3		 ret	 0
$LN32@audioop_li@4:

; 1437 :         return 0;

  000e5	44 8b 45 30	 mov	 r8d, DWORD PTR valpred$[rbp-128]
  000e9	44 8b 55 38	 mov	 r10d, DWORD PTR index$[rbp-128]
$LN22@audioop_li@4:

; 1438 : 
; 1439 :     step = stepsizeTable[index];
; 1440 :     bufferstep = 1;
; 1441 : 
; 1442 :     for ( i=0; i < len; i += size ) {

  000ed	48 89 b4 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rsi
  000f5	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  000fa	4c 8b 75 b8	 mov	 r14, QWORD PTR len$[rbp-128]
  000fe	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  00105	49 63 c2	 movsxd	 rax, r10d
  00108	33 f6		 xor	 esi, esi
  0010a	45 8b 8c 83 00
	00 00 00	 mov	 r9d, DWORD PTR stepsizeTable[r11+rax*4]
  00112	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR bufferstep$1$[rbp-128], 1
  00119	4d 85 f6	 test	 r14, r14
  0011c	0f 8e 5a 01 00
	00		 jle	 $LN19@audioop_li@4
  00122	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  00127	8b 7d b0	 mov	 edi, DWORD PTR size$[rbp-128]
  0012a	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  0012f	4c 8b 65 c8	 mov	 r12, QWORD PTR cp$[rbp-128]
  00133	8d 4e 08	 lea	 ecx, QWORD PTR [rsi+8]
  00136	41 bf 00 80 ff
	ff		 mov	 r15d, -32768		; ffffffffffff8000H
  0013c	0f 1f 40 00	 npad	 4
$LL21@audioop_li@4:

; 1443 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  00140	83 ff 01	 cmp	 edi, 1
  00143	75 0a		 jne	 SHORT $LN18@audioop_li@4
  00145	42 0f be 1c 26	 movsx	 ebx, BYTE PTR [rsi+r12]
  0014a	c1 e3 08	 shl	 ebx, 8
  0014d	eb 17		 jmp	 SHORT $LN14@audioop_li@4
$LN18@audioop_li@4:

; 1444 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0014f	83 ff 02	 cmp	 edi, 2
  00152	75 07		 jne	 SHORT $LN16@audioop_li@4
  00154	42 0f bf 1c 26	 movsx	 ebx, WORD PTR [rsi+r12]
  00159	eb 0b		 jmp	 SHORT $LN14@audioop_li@4
$LN16@audioop_li@4:

; 1445 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  0015b	83 ff 04	 cmp	 edi, 4
  0015e	75 06		 jne	 SHORT $LN14@audioop_li@4
  00160	42 0f bf 5c 26
	02		 movsx	 ebx, WORD PTR [rsi+r12+2]
$LN14@audioop_li@4:

; 1446 : 
; 1447 :         /* Step 1 - compute difference with previous value */
; 1448 :         diff = val - valpred;

  00166	8b c3		 mov	 eax, ebx

; 1449 :         sign = (diff < 0) ? 8 : 0;

  00168	41 bb 00 00 00
	00		 mov	 r11d, 0
  0016e	41 2b c0	 sub	 eax, r8d
  00171	44 0f 48 d9	 cmovs	 r11d, ecx

; 1450 :         if ( sign ) diff = (-diff);

  00175	45 85 db	 test	 r11d, r11d
  00178	74 02		 je	 SHORT $LN13@audioop_li@4
  0017a	f7 d8		 neg	 eax
$LN13@audioop_li@4:

; 1451 : 
; 1452 :         /* Step 2 - Divide and clamp */
; 1453 :         /* Note:
; 1454 :         ** This code *approximately* computes:
; 1455 :         **    delta = diff*4/step;
; 1456 :         **    vpdiff = (delta+0.5)*step/4;
; 1457 :         ** but in shift step bits are dropped. The net result of this
; 1458 :         ** is that even if you have fast mul/div hardware you cannot
; 1459 :         ** put it to good use since the fixup would be too expensive.
; 1460 :         */
; 1461 :         delta = 0;
; 1462 :         vpdiff = (step >> 3);

  0017c	41 8b c9	 mov	 ecx, r9d
  0017f	33 d2		 xor	 edx, edx
  00181	c1 f9 03	 sar	 ecx, 3

; 1463 : 
; 1464 :         if ( diff >= step ) {

  00184	41 3b c1	 cmp	 eax, r9d
  00187	7c 0b		 jl	 SHORT $LN12@audioop_li@4

; 1465 :             delta = 4;
; 1466 :             diff -= step;

  00189	41 2b c1	 sub	 eax, r9d
  0018c	ba 04 00 00 00	 mov	 edx, 4

; 1467 :             vpdiff += step;

  00191	41 03 c9	 add	 ecx, r9d
$LN12@audioop_li@4:

; 1468 :         }
; 1469 :         step >>= 1;

  00194	41 d1 f9	 sar	 r9d, 1

; 1470 :         if ( diff >= step  ) {

  00197	41 3b c1	 cmp	 eax, r9d
  0019a	7c 09		 jl	 SHORT $LN11@audioop_li@4

; 1471 :             delta |= 2;

  0019c	83 ca 02	 or	 edx, 2

; 1472 :             diff -= step;

  0019f	41 2b c1	 sub	 eax, r9d

; 1473 :             vpdiff += step;

  001a2	41 03 c9	 add	 ecx, r9d
$LN11@audioop_li@4:

; 1474 :         }
; 1475 :         step >>= 1;

  001a5	41 d1 f9	 sar	 r9d, 1

; 1476 :         if ( diff >= step ) {

  001a8	41 3b c1	 cmp	 eax, r9d
  001ab	7c 06		 jl	 SHORT $LN10@audioop_li@4

; 1477 :             delta |= 1;

  001ad	83 ca 01	 or	 edx, 1

; 1478 :             vpdiff += step;

  001b0	41 03 c9	 add	 ecx, r9d
$LN10@audioop_li@4:

; 1479 :         }
; 1480 : 
; 1481 :         /* Step 3 - Update previous value */
; 1482 :         if ( sign )

  001b3	45 85 db	 test	 r11d, r11d
  001b6	74 05		 je	 SHORT $LN9@audioop_li@4

; 1483 :             valpred -= vpdiff;

  001b8	44 2b c1	 sub	 r8d, ecx

; 1484 :         else

  001bb	eb 03		 jmp	 SHORT $LN8@audioop_li@4
$LN9@audioop_li@4:

; 1485 :             valpred += vpdiff;

  001bd	44 03 c1	 add	 r8d, ecx
$LN8@audioop_li@4:

; 1486 : 
; 1487 :         /* Step 4 - Clamp previous value to 16 bits */
; 1488 :         if ( valpred > 32767 )

  001c0	41 81 f8 ff 7f
	00 00		 cmp	 r8d, 32767		; 00007fffH
  001c7	7e 08		 jle	 SHORT $LN7@audioop_li@4

; 1489 :             valpred = 32767;

  001c9	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  001cf	eb 07		 jmp	 SHORT $LN34@audioop_li@4
$LN7@audioop_li@4:

; 1490 :         else if ( valpred < -32768 )

  001d1	45 3b c7	 cmp	 r8d, r15d
  001d4	45 0f 4c c7	 cmovl	 r8d, r15d
$LN34@audioop_li@4:

; 1491 :             valpred = -32768;
; 1492 : 
; 1493 :         /* Step 5 - Assemble value, update index and step values */
; 1494 :         delta |= sign;

  001d8	41 0b d3	 or	 edx, r11d

; 1495 : 
; 1496 :         index += indexTable[delta];

  001db	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  001e2	44 89 45 30	 mov	 DWORD PTR valpred$[rbp-128], r8d
  001e6	48 63 c2	 movsxd	 rax, edx
  001e9	45 03 94 83 00
	00 00 00	 add	 r10d, DWORD PTR indexTable[r11+rax*4]

; 1497 :         if ( index < 0 ) index = 0;

  001f1	79 05		 jns	 SHORT $LN4@audioop_li@4
  001f3	45 33 d2	 xor	 r10d, r10d

; 1498 :         if ( index > 88 ) index = 88;

  001f6	eb 0d		 jmp	 SHORT $LN35@audioop_li@4
$LN4@audioop_li@4:
  001f8	41 83 fa 58	 cmp	 r10d, 88		; 00000058H
  001fc	b8 58 00 00 00	 mov	 eax, 88			; 00000058H
  00201	44 0f 4f d0	 cmovg	 r10d, eax
$LN35@audioop_li@4:

; 1499 :         step = stepsizeTable[index];
; 1500 : 
; 1501 :         /* Step 6 - Output value */
; 1502 :         if ( bufferstep ) {

  00205	8b 4d b4	 mov	 ecx, DWORD PTR bufferstep$1$[rbp-128]
  00208	49 63 c2	 movsxd	 rax, r10d
  0020b	44 89 55 38	 mov	 DWORD PTR index$[rbp-128], r10d
  0020f	45 8b 8c 83 00
	00 00 00	 mov	 r9d, DWORD PTR stepsizeTable[r11+rax*4]
  00217	85 c9		 test	 ecx, ecx
  00219	74 0d		 je	 SHORT $LN2@audioop_li@4

; 1503 :             outputbuffer = (delta << 4) & 0xf0;

  0021b	44 8b ea	 mov	 r13d, edx
  0021e	41 83 e5 0f	 and	 r13d, 15
  00222	41 c1 e5 04	 shl	 r13d, 4

; 1504 :         } else {

  00226	eb 28		 jmp	 SHORT $LN1@audioop_li@4
$LN2@audioop_li@4:

; 1505 :             *ncp++ = (delta & 0x0f) | outputbuffer;

  00228	4c 8b 5d c0	 mov	 r11, QWORD PTR ncp$1$[rbp-128]
  0022c	80 e2 0f	 and	 dl, 15
  0022f	41 0a d5	 or	 dl, r13b
  00232	49 ff c3	 inc	 r11
  00235	41 88 53 ff	 mov	 BYTE PTR [r11-1], dl
  00239	8b 7d b0	 mov	 edi, DWORD PTR size$[rbp-128]
  0023c	4c 8b 75 b8	 mov	 r14, QWORD PTR len$[rbp-128]
  00240	4c 8b 65 c8	 mov	 r12, QWORD PTR cp$[rbp-128]
  00244	44 8b 45 30	 mov	 r8d, DWORD PTR valpred$[rbp-128]
  00248	44 8b 55 38	 mov	 r10d, DWORD PTR index$[rbp-128]
  0024c	4c 89 5d c0	 mov	 QWORD PTR ncp$1$[rbp-128], r11
$LN1@audioop_li@4:

; 1506 :         }
; 1507 :         bufferstep = !bufferstep;

  00250	33 c0		 xor	 eax, eax
  00252	85 c9		 test	 ecx, ecx
  00254	b9 08 00 00 00	 mov	 ecx, 8
  00259	0f 94 c0	 sete	 al
  0025c	89 45 b4	 mov	 DWORD PTR bufferstep$1$[rbp-128], eax
  0025f	48 63 c7	 movsxd	 rax, edi
  00262	48 03 f0	 add	 rsi, rax
  00265	49 3b f6	 cmp	 rsi, r14
  00268	0f 8c d2 fe ff
	ff		 jl	 $LL21@audioop_li@4
  0026e	4c 8b 7d d8	 mov	 r15, QWORD PTR str$1$[rbp-128]
  00272	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00277	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
$LN19@audioop_li@4:

; 1508 :     }
; 1509 :     rv = Py_BuildValue("(O(ii))", str, valpred, index);

  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
  00283	45 8b ca	 mov	 r9d, r10d
  00286	49 8b d7	 mov	 rdx, r15
  00289	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1510 :     Py_DECREF(str);

  0028e	49 8b cf	 mov	 rcx, r15
  00291	48 8b d8	 mov	 rbx, rax
  00294	e8 00 00 00 00	 call	 _Py_DecRef
  00299	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
  0029e	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+160]
  002a6	4c 8b 7c 24 60	 mov	 r15, QWORD PTR [rsp+96]

; 1511 :     return rv;

  002ab	48 8b c3	 mov	 rax, rbx

; 1512 : }

  002ae	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  002b5	41 5d		 pop	 r13
  002b7	5b		 pop	 rbx
  002b8	5d		 pop	 rbp
  002b9	c3		 ret	 0
audioop_lin2adpcm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_adpcm2lin DD imagerel audioop_adpcm2lin
	DD	imagerel audioop_adpcm2lin+185
	DD	imagerel $unwind$audioop_adpcm2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$audioop_adpcm2lin DD imagerel audioop_adpcm2lin+185
	DD	imagerel audioop_adpcm2lin+226
	DD	imagerel $chain$0$audioop_adpcm2lin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$audioop_adpcm2lin DD imagerel audioop_adpcm2lin+226
	DD	imagerel audioop_adpcm2lin+648
	DD	imagerel $chain$6$audioop_adpcm2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$audioop_adpcm2lin DD 0a1d21H
	DD	0dd41dH
	DD	0e7418H
	DD	0136410H
	DD	0123408H
	DD	0ce400H
	DD	imagerel audioop_adpcm2lin
	DD	imagerel audioop_adpcm2lin+185
	DD	imagerel $unwind$audioop_adpcm2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$audioop_adpcm2lin DD 020521H
	DD	0ce405H
	DD	imagerel audioop_adpcm2lin
	DD	imagerel audioop_adpcm2lin+185
	DD	imagerel $unwind$audioop_adpcm2lin
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_adpcm2lin DD 030b01H
	DD	0c004e20bH
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@
CONST	SEGMENT
??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@ DB 's#iO:adpcm2lin', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT audioop_adpcm2lin
_TEXT	SEGMENT
size$ = 48
cp$ = 56
len$ = 64
state$ = 72
str$1$ = 80
self$ = 144
args$ = 152
valpred$ = 160
index$ = 168
audioop_adpcm2lin PROC					; COMDAT

; 1516 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	48 8b ec	 mov	 rbp, rsp
  00007	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0000b	48 8b c2	 mov	 rax, rdx

; 1517 :     signed char *cp;
; 1518 :     signed char *ncp;
; 1519 :     Py_ssize_t len, i;
; 1520 :     int size, valpred, step, delta, index, sign, vpdiff;
; 1521 :     PyObject *rv, *str, *state;
; 1522 :     int inputbuffer = 0, bufferstep;
; 1523 : 
; 1524 :     if ( !PyArg_ParseTuple(args, "s#iO:adpcm2lin",
; 1525 :                            &cp, &len, &size, &state) )

  0000e	48 8d 4d d0	 lea	 rcx, QWORD PTR state$[rbp-120]
  00012	4c 8d 4d c8	 lea	 r9, QWORD PTR len$[rbp-120]
  00016	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0001b	48 8d 4d b8	 lea	 rcx, QWORD PTR size$[rbp-120]
  0001f	4c 8d 45 c0	 lea	 r8, QWORD PTR cp$[rbp-120]
  00023	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@
  0002f	48 8b c8	 mov	 rcx, rax
  00032	45 33 e4	 xor	 r12d, r12d
  00035	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003a	85 c0		 test	 eax, eax

; 1526 :         return 0;

  0003c	74 6d		 je	 SHORT $LN38@audioop_ad@2

; 1527 : 
; 1528 :     if (!audioop_check_size(size))

  0003e	8b 4d b8	 mov	 ecx, DWORD PTR size$[rbp-120]
  00041	e8 00 00 00 00	 call	 audioop_check_size
  00046	85 c0		 test	 eax, eax

; 1529 :         return NULL;

  00048	74 61		 je	 SHORT $LN38@audioop_ad@2

; 1530 : 
; 1531 :     /* Decode state, should have (value, step) */
; 1532 :     if ( state == Py_None ) {

  0004a	48 8b 4d d0	 mov	 rcx, QWORD PTR state$[rbp-120]
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00055	48 3b c8	 cmp	 rcx, rax
  00058	75 0a		 jne	 SHORT $LN25@audioop_ad@2

; 1533 :         /* First time, it seems. Set defaults */
; 1534 :         valpred = 0;

  0005a	44 89 65 28	 mov	 DWORD PTR valpred$[rbp-120], r12d

; 1535 :         index = 0;

  0005e	44 89 65 30	 mov	 DWORD PTR index$[rbp-120], r12d
  00062	eb 18		 jmp	 SHORT $LN23@audioop_ad@2
$LN25@audioop_ad@2:

; 1536 :     } else if ( !PyArg_ParseTuple(state, "ii", &valpred, &index) )

  00064	4c 8d 4d 30	 lea	 r9, QWORD PTR index$[rbp-120]
  00068	4c 8d 45 28	 lea	 r8, QWORD PTR valpred$[rbp-120]
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  00073	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00078	85 c0		 test	 eax, eax

; 1537 :         return 0;

  0007a	74 2f		 je	 SHORT $LN38@audioop_ad@2
$LN23@audioop_ad@2:

; 1538 : 
; 1539 :     if (len > (PY_SSIZE_T_MAX/2)/size) {

  0007c	48 63 4d b8	 movsxd	 rcx, DWORD PTR size$[rbp-120]
  00080	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  0008a	48 99		 cdq
  0008c	48 f7 f9	 idiv	 rcx
  0008f	48 8b 55 c8	 mov	 rdx, QWORD PTR len$[rbp-120]
  00093	48 3b d0	 cmp	 rdx, rax
  00096	7e 1d		 jle	 SHORT $LN22@audioop_ad@2

; 1540 :         PyErr_SetString(PyExc_MemoryError,
; 1541 :                         "not enough memory for output buffer");

  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  000a6	e8 00 00 00 00	 call	 PyErr_SetString
$LN38@audioop_ad@2:

; 1542 :         return 0;

  000ab	33 c0		 xor	 eax, eax

; 1605 : }

  000ad	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000b1	41 5c		 pop	 r12
  000b3	5d		 pop	 rbp
  000b4	c3		 ret	 0
$LN22@audioop_ad@2:

; 1543 :     }
; 1544 :     str = PyBytes_FromStringAndSize(NULL, len*size*2);

  000b5	48 0f af ca	 imul	 rcx, rdx
  000b9	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  000be	48 8d 14 09	 lea	 rdx, QWORD PTR [rcx+rcx]
  000c2	33 c9		 xor	 ecx, ecx
  000c4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c9	4c 8b f0	 mov	 r14, rax
  000cc	48 89 45 d8	 mov	 QWORD PTR str$1$[rbp-120], rax

; 1545 :     if ( str == 0 )

  000d0	48 85 c0	 test	 rax, rax
  000d3	75 0d		 jne	 SHORT $LN21@audioop_ad@2
  000d5	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 1605 : }

  000da	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000de	41 5c		 pop	 r12
  000e0	5d		 pop	 rbp
  000e1	c3		 ret	 0
$LN21@audioop_ad@2:
  000e2	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  000ea	48 89 b4 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rsi

; 1546 :         return 0;
; 1547 :     ncp = (signed char *)PyBytes_AsString(str);

  000f2	48 8b c8	 mov	 rcx, rax
  000f5	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  000fa	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  000ff	e8 00 00 00 00	 call	 PyBytes_AsString

; 1548 : 
; 1549 :     step = stepsizeTable[index];
; 1550 :     bufferstep = 0;
; 1551 : 
; 1552 :     for ( i=0; i < len*size*2; i += size ) {

  00104	4c 63 55 b8	 movsxd	 r10, DWORD PTR size$[rbp-120]
  00108	4c 63 4d 30	 movsxd	 r9, DWORD PTR index$[rbp-120]
  0010c	44 8b 45 28	 mov	 r8d, DWORD PTR valpred$[rbp-120]
  00110	49 8b ca	 mov	 rcx, r10
  00113	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  0011a	45 33 ed	 xor	 r13d, r13d
  0011d	43 8b 9c 8b 00
	00 00 00	 mov	 ebx, DWORD PTR stepsizeTable[r11+r9*4]
  00125	33 ff		 xor	 edi, edi
  00127	48 8b f0	 mov	 rsi, rax
  0012a	48 0f af 4d c8	 imul	 rcx, QWORD PTR len$[rbp-120]
  0012f	48 03 c9	 add	 rcx, rcx
  00132	48 85 c9	 test	 rcx, rcx
  00135	0f 8e 09 01 00
	00		 jle	 $LN18@audioop_ad@2
  0013b	45 8d 75 58	 lea	 r14d, QWORD PTR [r13+88]
  0013f	90		 npad	 1
$LL20@audioop_ad@2:

; 1553 :         /* Step 1 - get the delta value and compute next index */
; 1554 :         if ( bufferstep ) {

  00140	45 85 ed	 test	 r13d, r13d
  00143	74 05		 je	 SHORT $LN17@audioop_ad@2

; 1555 :             delta = inputbuffer & 0xf;

  00145	41 8b d4	 mov	 edx, r12d

; 1556 :         } else {

  00148	eb 12		 jmp	 SHORT $LN34@audioop_ad@2
$LN17@audioop_ad@2:

; 1557 :             inputbuffer = *cp++;

  0014a	48 8b 45 c0	 mov	 rax, QWORD PTR cp$[rbp-120]
  0014e	44 0f be 20	 movsx	 r12d, BYTE PTR [rax]
  00152	48 ff 45 c0	 inc	 QWORD PTR cp$[rbp-120]

; 1558 :             delta = (inputbuffer >> 4) & 0xf;

  00156	41 8b d4	 mov	 edx, r12d
  00159	c1 fa 04	 sar	 edx, 4
$LN34@audioop_ad@2:

; 1559 :         }
; 1560 : 
; 1561 :         bufferstep = !bufferstep;

  0015c	33 c0		 xor	 eax, eax
  0015e	83 e2 0f	 and	 edx, 15
  00161	45 85 ed	 test	 r13d, r13d
  00164	0f 94 c0	 sete	 al
  00167	44 8b e8	 mov	 r13d, eax

; 1562 : 
; 1563 :         /* Step 2 - Find new index value (for later) */
; 1564 :         index += indexTable[delta];

  0016a	48 63 c2	 movsxd	 rax, edx
  0016d	45 03 8c 83 00
	00 00 00	 add	 r9d, DWORD PTR indexTable[r11+rax*4]

; 1565 :         if ( index < 0 ) index = 0;

  00175	79 05		 jns	 SHORT $LN15@audioop_ad@2
  00177	45 33 c9	 xor	 r9d, r9d

; 1566 :         if ( index > 88 ) index = 88;

  0017a	eb 07		 jmp	 SHORT $LN35@audioop_ad@2
$LN15@audioop_ad@2:
  0017c	45 3b ce	 cmp	 r9d, r14d
  0017f	45 0f 4f ce	 cmovg	 r9d, r14d
$LN35@audioop_ad@2:

; 1567 : 
; 1568 :         /* Step 3 - Separate sign and magnitude */
; 1569 :         sign = delta & 8;

  00183	44 8b da	 mov	 r11d, edx

; 1570 :         delta = delta & 7;
; 1571 : 
; 1572 :         /* Step 4 - Compute difference and new predicted value */
; 1573 :         /*
; 1574 :         ** Computes 'vpdiff = (delta+0.5)*step/4', but see comment
; 1575 :         ** in adpcm_coder.
; 1576 :         */
; 1577 :         vpdiff = step >> 3;

  00186	8b cb		 mov	 ecx, ebx
  00188	83 e2 07	 and	 edx, 7
  0018b	41 83 e3 08	 and	 r11d, 8
  0018f	c1 f9 03	 sar	 ecx, 3
  00192	44 89 4d 30	 mov	 DWORD PTR index$[rbp-120], r9d

; 1578 :         if ( delta & 4 ) vpdiff += step;

  00196	f6 c2 04	 test	 dl, 4
  00199	74 02		 je	 SHORT $LN13@audioop_ad@2
  0019b	03 cb		 add	 ecx, ebx
$LN13@audioop_ad@2:

; 1579 :         if ( delta & 2 ) vpdiff += step>>1;

  0019d	f6 c2 02	 test	 dl, 2
  001a0	74 06		 je	 SHORT $LN12@audioop_ad@2
  001a2	8b c3		 mov	 eax, ebx
  001a4	d1 f8		 sar	 eax, 1
  001a6	03 c8		 add	 ecx, eax
$LN12@audioop_ad@2:

; 1580 :         if ( delta & 1 ) vpdiff += step>>2;

  001a8	f6 c2 01	 test	 dl, 1
  001ab	74 05		 je	 SHORT $LN11@audioop_ad@2
  001ad	c1 fb 02	 sar	 ebx, 2
  001b0	03 cb		 add	 ecx, ebx
$LN11@audioop_ad@2:

; 1581 : 
; 1582 :         if ( sign )

  001b2	45 85 db	 test	 r11d, r11d
  001b5	74 05		 je	 SHORT $LN10@audioop_ad@2

; 1583 :             valpred -= vpdiff;

  001b7	44 2b c1	 sub	 r8d, ecx

; 1584 :         else

  001ba	eb 03		 jmp	 SHORT $LN9@audioop_ad@2
$LN10@audioop_ad@2:

; 1585 :             valpred += vpdiff;

  001bc	44 03 c1	 add	 r8d, ecx
$LN9@audioop_ad@2:

; 1586 : 
; 1587 :         /* Step 5 - clamp output value */
; 1588 :         if ( valpred > 32767 )

  001bf	41 81 f8 ff 7f
	00 00		 cmp	 r8d, 32767		; 00007fffH
  001c6	7e 08		 jle	 SHORT $LN8@audioop_ad@2

; 1589 :             valpred = 32767;

  001c8	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  001ce	eb 0c		 jmp	 SHORT $LN36@audioop_ad@2
$LN8@audioop_ad@2:

; 1590 :         else if ( valpred < -32768 )

  001d0	b9 00 80 ff ff	 mov	 ecx, -32768		; ffffffffffff8000H
  001d5	44 3b c1	 cmp	 r8d, ecx
  001d8	44 0f 4c c1	 cmovl	 r8d, ecx
$LN36@audioop_ad@2:

; 1591 :             valpred = -32768;
; 1592 : 
; 1593 :         /* Step 6 - Update step value */
; 1594 :         step = stepsizeTable[index];

  001dc	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  001e3	49 63 c1	 movsxd	 rax, r9d
  001e6	44 89 45 28	 mov	 DWORD PTR valpred$[rbp-120], r8d
  001ea	41 8b 9c 83 00
	00 00 00	 mov	 ebx, DWORD PTR stepsizeTable[r11+rax*4]

; 1595 : 
; 1596 :         /* Step 6 - Output value */
; 1597 :         if ( size == 1 ) *CHARP(ncp, i) = (signed char)(valpred >> 8);

  001f2	41 83 fa 01	 cmp	 r10d, 1
  001f6	75 0a		 jne	 SHORT $LN5@audioop_ad@2
  001f8	41 c1 f8 08	 sar	 r8d, 8
  001fc	44 88 04 37	 mov	 BYTE PTR [rdi+rsi], r8b
  00200	eb 1b		 jmp	 SHORT $LN37@audioop_ad@2
$LN5@audioop_ad@2:

; 1598 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(valpred);

  00202	41 83 fa 02	 cmp	 r10d, 2
  00206	75 07		 jne	 SHORT $LN3@audioop_ad@2
  00208	66 44 89 04 37	 mov	 WORD PTR [rdi+rsi], r8w
  0020d	eb 0e		 jmp	 SHORT $LN37@audioop_ad@2
$LN3@audioop_ad@2:

; 1599 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(valpred<<16);

  0020f	41 83 fa 04	 cmp	 r10d, 4
  00213	75 14		 jne	 SHORT $LN19@audioop_ad@2
  00215	41 c1 e0 10	 shl	 r8d, 16
  00219	44 89 04 37	 mov	 DWORD PTR [rdi+rsi], r8d
$LN37@audioop_ad@2:
  0021d	44 8b 55 b8	 mov	 r10d, DWORD PTR size$[rbp-120]
  00221	44 8b 45 28	 mov	 r8d, DWORD PTR valpred$[rbp-120]
  00225	44 8b 4d 30	 mov	 r9d, DWORD PTR index$[rbp-120]
$LN19@audioop_ad@2:

; 1548 : 
; 1549 :     step = stepsizeTable[index];
; 1550 :     bufferstep = 0;
; 1551 : 
; 1552 :     for ( i=0; i < len*size*2; i += size ) {

  00229	49 63 c2	 movsxd	 rax, r10d
  0022c	48 03 f8	 add	 rdi, rax
  0022f	48 0f af 45 c8	 imul	 rax, QWORD PTR len$[rbp-120]
  00234	48 03 c0	 add	 rax, rax
  00237	48 3b f8	 cmp	 rdi, rax
  0023a	0f 8c 00 ff ff
	ff		 jl	 $LL20@audioop_ad@2
  00240	4c 8b 75 d8	 mov	 r14, QWORD PTR str$1$[rbp-120]
$LN18@audioop_ad@2:

; 1600 :     }
; 1601 : 
; 1602 :     rv = Py_BuildValue("(O(ii))", str, valpred, index);

  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
  0024b	49 8b d6	 mov	 rdx, r14
  0024e	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1603 :     Py_DECREF(str);

  00253	49 8b ce	 mov	 rcx, r14
  00256	48 8b d8	 mov	 rbx, rax
  00259	e8 00 00 00 00	 call	 _Py_DecRef
  0025e	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  00263	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
  00268	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR [rsp+152]
  00270	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]

; 1604 :     return rv;

  00275	48 8b c3	 mov	 rax, rbx
  00278	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 1605 : }

  00280	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00284	41 5c		 pop	 r12
  00286	5d		 pop	 rbp
  00287	c3		 ret	 0
audioop_adpcm2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0O@EMPLMINL@audioop?4error?$AA@		; `string'
PUBLIC	PyInit_audioop
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_audioop DD imagerel $LN7
	DD	imagerel $LN7+40
	DD	imagerel $unwind$PyInit_audioop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit_audioop DD imagerel $LN7+40
	DD	imagerel $LN7+69
	DD	imagerel $chain$0$PyInit_audioop
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyInit_audioop DD imagerel $LN7+69
	DD	imagerel $LN7+130
	DD	imagerel $chain$2$PyInit_audioop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyInit_audioop DD 020021H
	DD	067400H
	DD	imagerel $LN7
	DD	imagerel $LN7+40
	DD	imagerel $unwind$PyInit_audioop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit_audioop DD 020521H
	DD	067405H
	DD	imagerel $LN7
	DD	imagerel $LN7+40
	DD	imagerel $unwind$PyInit_audioop
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_audioop DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EMPLMINL@audioop?4error?$AA@
CONST	SEGMENT
??_C@_0O@EMPLMINL@audioop?4error?$AA@ DB 'audioop.error', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyInit_audioop
_TEXT	SEGMENT
PyInit_audioop PROC					; COMDAT

; 1651 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1652 :     PyObject *m, *d;
; 1653 :     m = PyModule_Create(&audioopmodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:audioopmodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 1654 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 06		 jne	 SHORT $LN3@PyInit_aud

; 1663 : }

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN3@PyInit_aud:

; 1655 :         return NULL;
; 1656 :     d = PyModule_GetDict(m);

  00025	48 8b c8	 mov	 rcx, rax
  00028	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0002d	e8 00 00 00 00	 call	 PyModule_GetDict
  00032	48 8b f8	 mov	 rdi, rax

; 1657 :     if (d == NULL)

  00035	48 85 c0	 test	 rax, rax
  00038	75 0b		 jne	 SHORT $LN2@PyInit_aud
  0003a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1663 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN2@PyInit_aud:

; 1658 :         return NULL;
; 1659 :     AudioopError = PyErr_NewException("audioop.error", NULL, NULL);

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EMPLMINL@audioop?4error?$AA@
  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	33 d2		 xor	 edx, edx
  00051	e8 00 00 00 00	 call	 PyErr_NewException
  00056	48 89 05 00 00
	00 00		 mov	 QWORD PTR AudioopError, rax

; 1660 :     if (AudioopError != NULL)

  0005d	48 85 c0	 test	 rax, rax
  00060	74 12		 je	 SHORT $LN1@PyInit_aud

; 1661 :          PyDict_SetItemString(d,"error",AudioopError);

  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00069	4c 8b c0	 mov	 r8, rax
  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN1@PyInit_aud:

; 1662 :     return m;

  00074	48 8b c3	 mov	 rax, rbx
  00077	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1663 : }

  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
PyInit_audioop ENDP
_TEXT	ENDS
END
