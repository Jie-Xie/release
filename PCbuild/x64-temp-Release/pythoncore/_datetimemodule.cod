; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@ ; `string'
PUBLIC	??_C@_09BLEDGJAH@_datetime?$AA@			; `string'
PUBLIC	??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@	; `string'
PUBLIC	??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@ ; `string'
PUBLIC	??_C@_0L@ECALMFAG@astimezone?$AA@		; `string'
PUBLIC	??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@ ; `string'
PUBLIC	??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@ ; `string'
PUBLIC	??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@ ; `string'
PUBLIC	??_C@_0N@LHNBNFDP@utctimetuple?$AA@		; `string'
PUBLIC	??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@ ; `string'
PUBLIC	??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@ ; `string'
PUBLIC	??_C@_06LODNGPBG@timetz?$AA@			; `string'
PUBLIC	??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@ ; `string'
PUBLIC	??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@ ; `string'
PUBLIC	??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@ ; `string'
PUBLIC	??_C@_07PCDCECCK@combine?$AA@			; `string'
PUBLIC	??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@ ; `string'
PUBLIC	??_C@_08JKOOHOPP@strptime?$AA@			; `string'
PUBLIC	??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@ ; `string'
PUBLIC	??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@	; `string'
PUBLIC	??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@ ; `string'
PUBLIC	??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@ ; `string'
PUBLIC	??_C@_06GKOOHOFL@utcnow?$AA@			; `string'
PUBLIC	??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@ ; `string'
PUBLIC	??_C@_03CGLHMDPP@now?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_04JNIHBGGH@date?$AA@			; `string'
PUBLIC	??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@	; `string'
PUBLIC	??_C@_09OMDJNLDP@timestamp?$AA@			; `string'
PUBLIC	??_C@_02IGJGHHBN@tz?$AA@			; `string'
PUBLIC	??_C@_0O@NMMCJMEE@datetime?4time?$AA@		; `string'
PUBLIC	??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@ ; `string'
PUBLIC	??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@ ; `string'
PUBLIC	??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@ ; `string'
PUBLIC	??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@ ; `string'
PUBLIC	??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@ ; `string'
PUBLIC	??_C@_06DBOJKPOI@tzinfo?$AA@			; `string'
PUBLIC	??_C@_0M@IPLGOMOC@microsecond?$AA@		; `string'
PUBLIC	??_C@_06BJCFNGJP@second?$AA@			; `string'
PUBLIC	??_C@_06JGJIJFNK@minute?$AA@			; `string'
PUBLIC	??_C@_04LMOJGCPE@hour?$AA@			; `string'
PUBLIC	??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@	; `string'
PUBLIC	??_C@_0P@BIOPACEL@pickle?5support?$AA@		; `string'
PUBLIC	??_C@_0N@BDGMCEOD@Return?5None?4?$AA@		; `string'
PUBLIC	??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@	; `string'
PUBLIC	??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset?$AA@			; `string'
PUBLIC	??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@	; `string'
PUBLIC	??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@ ; `string'
PUBLIC	??_C@_07COGHOOJN@fromutc?$AA@			; `string'
PUBLIC	??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@ ; `string'
PUBLIC	??_C@_03HHBLCKEM@dst?$AA@			; `string'
PUBLIC	??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@ ; `string'
PUBLIC	??_C@_09DGNKAEDJ@utcoffset?$AA@			; `string'
PUBLIC	??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@ ; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_0BA@NHLJJDN@__getinitargs__?$AA@		; `string'
PUBLIC	??_C@_0O@GKGBLLNG@datetime?4date?$AA@		; `string'
PUBLIC	??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@ ; `string'
PUBLIC	??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@ ; `string'
PUBLIC	??_C@_07FALBAABE@weekday?$AA@			; `string'
PUBLIC	??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@ ; `string'
PUBLIC	??_C@_09EONCNCPH@toordinal?$AA@			; `string'
PUBLIC	??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@ ; `string'
PUBLIC	??_C@_0L@OLCJLGMC@isoweekday?$AA@		; `string'
PUBLIC	??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@ ; `string'
PUBLIC	??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@ ; `string'
PUBLIC	??_C@_0M@NNCHLCCB@isocalendar?$AA@		; `string'
PUBLIC	??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@ ; `string'
PUBLIC	??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@ ; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@ ; `string'
PUBLIC	??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@ ; `string'
PUBLIC	??_C@_05NCKEBKLP@ctime?$AA@			; `string'
PUBLIC	??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@ ; `string'
PUBLIC	??_C@_05MGEAPCOL@today?$AA@			; `string'
PUBLIC	??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@ ; `string'
PUBLIC	??_C@_0M@EGBEAMKN@fromordinal?$AA@		; `string'
PUBLIC	??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@ ; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_09BCIOHOOO@timetuple?$AA@			; `string'
PUBLIC	??_C@_09KILOLAPA@isoformat?$AA@			; `string'
PUBLIC	??_C@_0O@LBDJOPJI@fromtimestamp?$AA@		; `string'
PUBLIC	??_C@_03NNBHCDBP@day?$AA@			; `string'
PUBLIC	??_C@_05MEBAADFH@month?$AA@			; `string'
PUBLIC	??_C@_04JFPLDHAO@year?$AA@			; `string'
PUBLIC	??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@	; `string'
PUBLIC	??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@ ; `string'
PUBLIC	??_C@_0O@NKEEINIH@total_seconds?$AA@		; `string'
PUBLIC	??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@ ; `string'
PUBLIC	??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@ ; `string'
PUBLIC	??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@	; `string'
PUBLIC	??_C@_05EFKAJCNN@weeks?$AA@			; `string'
PUBLIC	??_C@_05LOHOPFFC@hours?$AA@			; `string'
PUBLIC	??_C@_07GCICIJGK@minutes?$AA@			; `string'
PUBLIC	??_C@_0N@JDBMCDJK@milliseconds?$AA@		; `string'
PUBLIC	??_C@_0N@EKJJBPIN@microseconds?$AA@		; `string'
PUBLIC	??_C@_07GELLIBDG@seconds?$AA@			; `string'
PUBLIC	??_C@_04IJMHDAOD@days?$AA@			; `string'
PUBLIC	??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@	; `string'
PUBLIC	??_C@_0M@HIOPEIIP@struct_time?$AA@		; `string'
PUBLIC	??_C@_04CLCEDBPF@time?$AA@			; `string'
PUBLIC	??_C@_08EPGBJPHJ@strftime?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_03MKABNOCG@Dec?$AA@			; `string'
PUBLIC	??_C@_03JPJOFNIA@Nov?$AA@			; `string'
PUBLIC	??_C@_03BMAOKBAD@Oct?$AA@			; `string'
PUBLIC	??_C@_03GGCAPAJC@Sep?$AA@			; `string'
PUBLIC	??_C@_03IFJFEIGA@Aug?$AA@			; `string'
PUBLIC	??_C@_03LBGABGKK@Jul?$AA@			; `string'
PUBLIC	??_C@_03IDFGHECI@Jun?$AA@			; `string'
PUBLIC	??_C@_03CNMDKL@May?$AA@				; `string'
PUBLIC	??_C@_03LEOLGMJP@Apr?$AA@			; `string'
PUBLIC	??_C@_03ODNJBKGA@Mar?$AA@			; `string'
PUBLIC	??_C@_03HJBDCHOM@Feb?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_03KOEHGMDN@Sun?$AA@			; `string'
PUBLIC	??_C@_03FEFJNEK@Sat?$AA@			; `string'
PUBLIC	??_C@_03IDIOELNC@Fri?$AA@			; `string'
PUBLIC	??_C@_03IOFIKPDN@Thu?$AA@			; `string'
PUBLIC	??_C@_03MHOMLAJA@Wed?$AA@			; `string'
PUBLIC	??_C@_03NAGEINEP@Tue?$AA@			; `string'
PUBLIC	??_C@_03PDAGKDH@Mon?$AA@			; `string'
PUBLIC	??_C@_06CNBAGEMF@tzname?$AA@			; `string'
EXTRN	PyType_GenericNew:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
us_per_us DQ	01H DUP (?)
us_per_ms DQ	01H DUP (?)
us_per_second DQ 01H DUP (?)
us_per_minute DQ 01H DUP (?)
us_per_hour DQ	01H DUP (?)
us_per_day DQ	01H DUP (?)
us_per_week DQ	01H DUP (?)
seconds_per_day DQ 01H DUP (?)
?module@?1??datetime_strptime@@9@9 DQ 01H DUP (?)	; `datetime_strptime'::`2'::module
module_methods DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@
CONST	SEGMENT
??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@ DB 'Fast impleme'
	DB	'ntation of the datetime type.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLEDGJAH@_datetime?$AA@
CONST	SEGMENT
??_C@_09BLEDGJAH@_datetime?$AA@ DB '_datetime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@
CONST	SEGMENT
??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@ DB 'datetime.datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@
CONST	SEGMENT
??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@ DB 'tz ->'
	DB	' convert to local time in new timezone tz', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECALMFAG@astimezone?$AA@
CONST	SEGMENT
??_C@_0L@ECALMFAG@astimezone?$AA@ DB 'astimezone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@
CONST	SEGMENT
??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@ DB 'Return datet'
	DB	'ime with new specified fields.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@
CONST	SEGMENT
??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@ DB '['
	DB	'sep] -> string in ISO 8601 format, YYYY-MM-DDTHH:MM:SS[.mmmmm'
	DB	'm][+HH:MM].', 0aH, 0aH, 'sep is used to separate the year fro'
	DB	'm the time, and defaults to ''T''.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@
CONST	SEGMENT
??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@ DB 'Return UTC '
	DB	'time tuple, compatible with time.localtime().', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHNBNFDP@utctimetuple?$AA@
CONST	SEGMENT
??_C@_0N@LHNBNFDP@utctimetuple?$AA@ DB 'utctimetuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@
CONST	SEGMENT
??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@ DB 'Return POSI'
	DB	'X timestamp as float.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@
CONST	SEGMENT
??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@ DB 'Return time'
	DB	' object with same time and tzinfo.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LODNGPBG@timetz?$AA@
CONST	SEGMENT
??_C@_06LODNGPBG@timetz?$AA@ DB 'timetz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@
CONST	SEGMENT
??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@ DB 'Return time'
	DB	' object with same time but with tzinfo=None.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@
CONST	SEGMENT
??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@ DB 'Return date'
	DB	' object with same year, month and day.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@
CONST	SEGMENT
??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@ DB 'date, '
	DB	'time -> datetime with same date and time fields', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCDCECCK@combine?$AA@
CONST	SEGMENT
??_C@_07PCDCECCK@combine?$AA@ DB 'combine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@
CONST	SEGMENT
??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@ DB 'string'
	DB	', format -> new datetime parsed from a string (like time.strp'
	DB	'time()).', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKOOHOPP@strptime?$AA@
CONST	SEGMENT
??_C@_08JKOOHOPP@strptime?$AA@ DB 'strptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@
CONST	SEGMENT
??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@ DB 'timesta'
	DB	'mp -> UTC datetime from a POSIX timestamp (like time.time()).'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@ DB 'utcfromtimestamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@
CONST	SEGMENT
??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@ DB 't'
	DB	'imestamp[, tz] -> tz''s local time from POSIX timestamp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@
CONST	SEGMENT
??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@ DB 'Return a new'
	DB	' datetime representing UTC day and time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKOOHOFL@utcnow?$AA@
CONST	SEGMENT
??_C@_06GKOOHOFL@utcnow?$AA@ DB 'utcnow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@
CONST	SEGMENT
??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@ DB '['
	DB	'tz] -> new datetime with tz''s local day and time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGLHMDPP@now?$AA@
CONST	SEGMENT
??_C@_03CGLHMDPP@now?$AA@ DB 'now', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNIHBGGH@date?$AA@
CONST	SEGMENT
??_C@_04JNIHBGGH@date?$AA@ DB 'date', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@
CONST	SEGMENT
??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@ DB '_strptime_datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMDJNLDP@timestamp?$AA@
CONST	SEGMENT
??_C@_09OMDJNLDP@timestamp?$AA@ DB 'timestamp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGJGHHBN@tz?$AA@
CONST	SEGMENT
??_C@_02IGJGHHBN@tz?$AA@ DB 'tz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMMCJMEE@datetime?4time?$AA@
CONST	SEGMENT
??_C@_0O@NMMCJMEE@datetime?4time?$AA@ DB 'datetime.time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@
CONST	SEGMENT
??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@ DB 'Return time'
	DB	' with new specified fields.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
CONST	SEGMENT
??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@ DB 'Retur'
	DB	'n self.tzinfo.dst(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
CONST	SEGMENT
??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@ DB 'Return'
	DB	' self.tzinfo.tzname(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
CONST	SEGMENT
??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@ DB 'Return sel'
	DB	'f.tzinfo.utcoffset(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@
CONST	SEGMENT
??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@ DB 'Return strin'
	DB	'g in ISO 8601 format, HH:MM:SS[.mmmmmm][+HH:MM].', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBOJKPOI@tzinfo?$AA@
CONST	SEGMENT
??_C@_06DBOJKPOI@tzinfo?$AA@ DB 'tzinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPLGOMOC@microsecond?$AA@
CONST	SEGMENT
??_C@_0M@IPLGOMOC@microsecond?$AA@ DB 'microsecond', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJCFNGJP@second?$AA@
CONST	SEGMENT
??_C@_06BJCFNGJP@second?$AA@ DB 'second', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGJIJFNK@minute?$AA@
CONST	SEGMENT
??_C@_06JGJIJFNK@minute?$AA@ DB 'minute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LMOJGCPE@hour?$AA@
CONST	SEGMENT
??_C@_04LMOJGCPE@hour?$AA@ DB 'hour', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@
CONST	SEGMENT
??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@ DB 'datetime.timezone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BIOPACEL@pickle?5support?$AA@
CONST	SEGMENT
??_C@_0P@BIOPACEL@pickle?5support?$AA@ DB 'pickle support', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDGMCEOD@Return?5None?4?$AA@
CONST	SEGMENT
??_C@_0N@BDGMCEOD@Return?5None?4?$AA@ DB 'Return None.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@
CONST	SEGMENT
??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@ DB 'Return fixed offset.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@
CONST	SEGMENT
??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@ DB 'If name is '
	DB	'specified when timezone is created, returns the name.  Otherw'
	DB	'ise returns offset as ''UTC(+|-)HH:MM''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset?$AA@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset?$AA@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@
CONST	SEGMENT
??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@ DB 'datetime.tzinfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ DB '-> (cls, state)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
CONST	SEGMENT
??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@ DB 'dateti'
	DB	'me in UTC -> datetime in local time.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07COGHOOJN@fromutc?$AA@
CONST	SEGMENT
??_C@_07COGHOOJN@fromutc?$AA@ DB 'fromutc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@
CONST	SEGMENT
??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@ DB 'datetim'
	DB	'e -> DST offset in minutes east of UTC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHBLCKEM@dst?$AA@
CONST	SEGMENT
??_C@_03HHBLCKEM@dst?$AA@ DB 'dst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@
CONST	SEGMENT
??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@ DB 'datetime'
	DB	' -> timedelta showing offset from UTC, negative values indica'
	DB	'ting West of UTC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGNKAEDJ@utcoffset?$AA@
CONST	SEGMENT
??_C@_09DGNKAEDJ@utcoffset?$AA@ DB 'utcoffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@
CONST	SEGMENT
??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@ DB 'datetim'
	DB	'e -> string name of time zone.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
CONST	SEGMENT
??_C@_0BA@NHLJJDN@__getinitargs__?$AA@ DB '__getinitargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKGBLLNG@datetime?4date?$AA@
CONST	SEGMENT
??_C@_0O@GKGBLLNG@datetime?4date?$AA@ DB 'datetime.date', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@
CONST	SEGMENT
??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@ DB 'Return date'
	DB	' with new specified fields.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@
CONST	SEGMENT
??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@ DB 'Return the'
	DB	' day of the week represented by the date.', 0aH, 'Monday == 0'
	DB	' ... Sunday == 6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FALBAABE@weekday?$AA@
CONST	SEGMENT
??_C@_07FALBAABE@weekday?$AA@ DB 'weekday', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@
CONST	SEGMENT
??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@ DB 'Return prolep'
	DB	'tic Gregorian ordinal.  January 1 of year 1 is day 1.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EONCNCPH@toordinal?$AA@
CONST	SEGMENT
??_C@_09EONCNCPH@toordinal?$AA@ DB 'toordinal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@
CONST	SEGMENT
??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@ DB 'Return the'
	DB	' day of the week represented by the date.', 0aH, 'Monday == 1'
	DB	' ... Sunday == 7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLCJLGMC@isoweekday?$AA@
CONST	SEGMENT
??_C@_0L@OLCJLGMC@isoweekday?$AA@ DB 'isoweekday', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@
CONST	SEGMENT
??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@ DB 'Return stri'
	DB	'ng in ISO 8601 format, YYYY-MM-DD.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@
CONST	SEGMENT
??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@ DB 'Return a 3'
	DB	'-tuple containing ISO year, week number, and weekday.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNCHLCCB@isocalendar?$AA@
CONST	SEGMENT
??_C@_0M@NNCHLCCB@isocalendar?$AA@ DB 'isocalendar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
CONST	SEGMENT
??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@ DB 'Return time'
	DB	' tuple, compatible with time.localtime().', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
CONST	SEGMENT
??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@ DB 'Formats self '
	DB	'with strftime.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
CONST	SEGMENT
??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@ DB 'fo'
	DB	'rmat -> strftime() style string.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
CONST	SEGMENT
??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@ DB 'Return'
	DB	' ctime() style string.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCKEBKLP@ctime?$AA@
CONST	SEGMENT
??_C@_05NCKEBKLP@ctime?$AA@ DB 'ctime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@
CONST	SEGMENT
??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@ DB 'Current d'
	DB	'ate or datetime:  same as self.__class__.fromtimestamp(time.t'
	DB	'ime()).', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGEAPCOL@today?$AA@
CONST	SEGMENT
??_C@_05MGEAPCOL@today?$AA@ DB 'today', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@
CONST	SEGMENT
??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@ DB 'int ->'
	DB	' date corresponding to a proleptic Gregorian ordinal.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGBEAMKN@fromordinal?$AA@
CONST	SEGMENT
??_C@_0M@EGBEAMKN@fromordinal?$AA@ DB 'fromordinal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@
CONST	SEGMENT
??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@ DB 'timest'
	DB	'amp -> local date from a POSIX timestamp (like time.time()).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCIOHOOO@timetuple?$AA@
CONST	SEGMENT
??_C@_09BCIOHOOO@timetuple?$AA@ DB 'timetuple', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KILOLAPA@isoformat?$AA@
CONST	SEGMENT
??_C@_09KILOLAPA@isoformat?$AA@ DB 'isoformat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0O@LBDJOPJI@fromtimestamp?$AA@ DB 'fromtimestamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNBHCDBP@day?$AA@
CONST	SEGMENT
??_C@_03NNBHCDBP@day?$AA@ DB 'day', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEBAADFH@month?$AA@
CONST	SEGMENT
??_C@_05MEBAADFH@month?$AA@ DB 'month', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFPLDHAO@year?$AA@
CONST	SEGMENT
??_C@_04JFPLDHAO@year?$AA@ DB 'year', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@
CONST	SEGMENT
??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@ DB 'datetime.timedelta', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ DB '_'
	DB	'_reduce__() -> (cls, state)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@
CONST	SEGMENT
??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@ DB 'Total sec'
	DB	'onds in the duration.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKEEINIH@total_seconds?$AA@
CONST	SEGMENT
??_C@_0O@NKEEINIH@total_seconds?$AA@ DB 'total_seconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@
CONST	SEGMENT
??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@ DB 'Nu'
	DB	'mber of microseconds (>= 0 and less than 1 second).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@
CONST	SEGMENT
??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@ DB 'N'
	DB	'umber of seconds (>= 0 and less than 1 day).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@
CONST	SEGMENT
??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@ DB 'Number of days.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFKAJCNN@weeks?$AA@
CONST	SEGMENT
??_C@_05EFKAJCNN@weeks?$AA@ DB 'weeks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOHOPFFC@hours?$AA@
CONST	SEGMENT
??_C@_05LOHOPFFC@hours?$AA@ DB 'hours', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GCICIJGK@minutes?$AA@
CONST	SEGMENT
??_C@_07GCICIJGK@minutes?$AA@ DB 'minutes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDBMCDJK@milliseconds?$AA@
CONST	SEGMENT
??_C@_0N@JDBMCDJK@milliseconds?$AA@ DB 'milliseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKJJBPIN@microseconds?$AA@
CONST	SEGMENT
??_C@_0N@EKJJBPIN@microseconds?$AA@ DB 'microseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GELLIBDG@seconds?$AA@
CONST	SEGMENT
??_C@_07GELLIBDG@seconds?$AA@ DB 'seconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJMHDAOD@days?$AA@
CONST	SEGMENT
??_C@_04IJMHDAOD@days?$AA@ DB 'days', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
CONST	SEGMENT
??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@ DB 'as_integer_ratio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIOPEIIP@struct_time?$AA@
CONST	SEGMENT
??_C@_0M@HIOPEIIP@struct_time?$AA@ DB 'struct_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time?$AA@
CONST	SEGMENT
??_C@_04CLCEDBPF@time?$AA@ DB 'time', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPGBJPHJ@strftime?$AA@
CONST	SEGMENT
??_C@_08EPGBJPHJ@strftime?$AA@ DB 'strftime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MKABNOCG@Dec?$AA@
CONST	SEGMENT
??_C@_03MKABNOCG@Dec?$AA@ DB 'Dec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JPJOFNIA@Nov?$AA@
CONST	SEGMENT
??_C@_03JPJOFNIA@Nov?$AA@ DB 'Nov', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMAOKBAD@Oct?$AA@
CONST	SEGMENT
??_C@_03BMAOKBAD@Oct?$AA@ DB 'Oct', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GGCAPAJC@Sep?$AA@
CONST	SEGMENT
??_C@_03GGCAPAJC@Sep?$AA@ DB 'Sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFJFEIGA@Aug?$AA@
CONST	SEGMENT
??_C@_03IFJFEIGA@Aug?$AA@ DB 'Aug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBGABGKK@Jul?$AA@
CONST	SEGMENT
??_C@_03LBGABGKK@Jul?$AA@ DB 'Jul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDFGHECI@Jun?$AA@
CONST	SEGMENT
??_C@_03IDFGHECI@Jun?$AA@ DB 'Jun', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNMDKL@May?$AA@
CONST	SEGMENT
??_C@_03CNMDKL@May?$AA@ DB 'May', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEOLGMJP@Apr?$AA@
CONST	SEGMENT
??_C@_03LEOLGMJP@Apr?$AA@ DB 'Apr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ODNJBKGA@Mar?$AA@
CONST	SEGMENT
??_C@_03ODNJBKGA@Mar?$AA@ DB 'Mar', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJBDCHOM@Feb?$AA@
CONST	SEGMENT
??_C@_03HJBDCHOM@Feb?$AA@ DB 'Feb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KOEHGMDN@Sun?$AA@
CONST	SEGMENT
??_C@_03KOEHGMDN@Sun?$AA@ DB 'Sun', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEFJNEK@Sat?$AA@
CONST	SEGMENT
??_C@_03FEFJNEK@Sat?$AA@ DB 'Sat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDIOELNC@Fri?$AA@
CONST	SEGMENT
??_C@_03IDIOELNC@Fri?$AA@ DB 'Fri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IOFIKPDN@Thu?$AA@
CONST	SEGMENT
??_C@_03IOFIKPDN@Thu?$AA@ DB 'Thu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHOMLAJA@Wed?$AA@
CONST	SEGMENT
??_C@_03MHOMLAJA@Wed?$AA@ DB 'Wed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NAGEINEP@Tue?$AA@
CONST	SEGMENT
??_C@_03NAGEINEP@Tue?$AA@ DB 'Tue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDAGKDH@Mon?$AA@
CONST	SEGMENT
??_C@_03PDAGKDH@Mon?$AA@ DB 'Mon', 00H			; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_fromutc@?1??datetime_astimezone@@9@9 DQ 0000000000000000H ; `datetime_astimezone'::`2'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??datetime_str@@9@9 DQ 0000000000000000H ; `datetime_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId__strptime_datetime@?1??datetime_strptime@@9@9 DQ 0000000000000000H ; `datetime_strptime'::`2'::PyId__strptime_datetime
	DQ	FLAT:??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@
	DQ	0000000000000000H
?PyId_fromutc@?2??datetime_fromtimestamp@@9@9 DQ 0000000000000000H ; `datetime_fromtimestamp'::`3'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_fromutc@?2??datetime_now@@9@9 DQ 0000000000000000H ; `datetime_now'::`3'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??time_str@@9@9 DQ 0000000000000000H	; `time_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId___getstate__@?1??tzinfo_reduce@@9@9 DQ 0000000000000000H ; `tzinfo_reduce'::`2'::PyId___getstate__
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	0000000000000000H
?PyId___getinitargs__@?1??tzinfo_reduce@@9@9 DQ 0000000000000000H ; `tzinfo_reduce'::`2'::PyId___getinitargs__
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	0000000000000000H
?PyId_strftime@?1??date_format@@9@9 DQ 0000000000000000H ; `date_format'::`2'::PyId_strftime
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	0000000000000000H
?PyId_timetuple@?1??date_strftime@@9@9 DQ 0000000000000000H ; `date_strftime'::`2'::PyId_timetuple
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??date_str@@9@9 DQ 0000000000000000H	; `date_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId_fromtimestamp@?1??date_today@@9@9 DQ 0000000000000000H ; `date_today'::`2'::PyId_fromtimestamp
	DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	0000000000000000H
?PyId_as_integer_ratio@?1??truedivide_timedelta_float@@9@9 DQ 0000000000000000H ; `truedivide_timedelta_float'::`2'::PyId_as_integer_ratio
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	0000000000000000H
?PyId_as_integer_ratio@?1??multiply_float_timedelta@@9@9 DQ 0000000000000000H ; `multiply_float_timedelta'::`2'::PyId_as_integer_ratio
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	0000000000000000H
?PyId_struct_time@?2??build_struct_time@@9@9 DQ 0000000000000000H ; `build_struct_time'::`3'::PyId_struct_time
	DQ	FLAT:??_C@_0M@HIOPEIIP@struct_time?$AA@
	DQ	0000000000000000H
?PyId_time@?2??time_time@@9@9 DQ 0000000000000000H	; `time_time'::`3'::PyId_time
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	0000000000000000H
?PyId_strftime@?BC@??wrap_strftime@@9@9 DQ 0000000000000000H ; `wrap_strftime'::`18'::PyId_strftime
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	0000000000000000H
?PyId_replace@?1??make_Zreplacement@@9@9 DQ 0000000000000000H ; `make_Zreplacement'::`2'::PyId_replace
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	0000000000000000H
?PyId_tzname@?1??call_tzname@@9@9 DQ 0000000000000000H	; `call_tzname'::`2'::PyId_tzname
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06CNBAGEMF@tzname?$AA@
CONST	SEGMENT
??_C@_06CNBAGEMF@tzname?$AA@ DB 'tzname', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_days_in_month DD 00H
	DD	01fH
	DD	01cH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	ORG $+4
_days_before_month DD 00H
	DD	00H
	DD	01fH
	DD	03bH
	DD	05aH
	DD	078H
	DD	097H
	DD	0b5H
	DD	0d4H
	DD	0f3H
	DD	0111H
	DD	0130H
	DD	014eH
	ORG $+4
?DayNames@?1??format_ctime@@9@9 DQ FLAT:??_C@_03PDAGKDH@Mon?$AA@ ; `format_ctime'::`2'::DayNames
	DQ	FLAT:??_C@_03NAGEINEP@Tue?$AA@
	DQ	FLAT:??_C@_03MHOMLAJA@Wed?$AA@
	DQ	FLAT:??_C@_03IOFIKPDN@Thu?$AA@
	DQ	FLAT:??_C@_03IDIOELNC@Fri?$AA@
	DQ	FLAT:??_C@_03FEFJNEK@Sat?$AA@
	DQ	FLAT:??_C@_03KOEHGMDN@Sun?$AA@
	ORG $+8
?MonthNames@?1??format_ctime@@9@9 DQ FLAT:??_C@_03JIHJHPIE@Jan?$AA@ ; `format_ctime'::`2'::MonthNames
	DQ	FLAT:??_C@_03HJBDCHOM@Feb?$AA@
	DQ	FLAT:??_C@_03ODNJBKGA@Mar?$AA@
	DQ	FLAT:??_C@_03LEOLGMJP@Apr?$AA@
	DQ	FLAT:??_C@_03CNMDKL@May?$AA@
	DQ	FLAT:??_C@_03IDFGHECI@Jun?$AA@
	DQ	FLAT:??_C@_03LBGABGKK@Jul?$AA@
	DQ	FLAT:??_C@_03IFJFEIGA@Aug?$AA@
	DQ	FLAT:??_C@_03GGCAPAJC@Sep?$AA@
	DQ	FLAT:??_C@_03BMAOKBAD@Oct?$AA@
	DQ	FLAT:??_C@_03JPJOFNIA@Nov?$AA@
	DQ	FLAT:??_C@_03MKABNOCG@Dec?$AA@
?keywords@?1??delta_new@@9@9 DQ FLAT:??_C@_04IJMHDAOD@days?$AA@ ; `delta_new'::`2'::keywords
	DQ	FLAT:??_C@_07GELLIBDG@seconds?$AA@
	DQ	FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
	DQ	FLAT:??_C@_0N@JDBMCDJK@milliseconds?$AA@
	DQ	FLAT:??_C@_07GCICIJGK@minutes?$AA@
	DQ	FLAT:??_C@_05LOHOPFFC@hours?$AA@
	DQ	FLAT:??_C@_05EFKAJCNN@weeks?$AA@
	DQ	0000000000000000H
delta_members DQ FLAT:??_C@_04IJMHDAOD@days?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@
	DQ	FLAT:??_C@_07GELLIBDG@seconds?$AA@
	DD	01H
	ORG $+4
	DQ	000000000000006cH
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@
	DQ	FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@
	DQ	0000000000000000H
	ORG $+32
delta_methods DQ FLAT:??_C@_0O@NKEEINIH@total_seconds?$AA@
	DQ	FLAT:delta_total_seconds
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:delta_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
delta_doc DB	'Difference between two datetime values.', 00H
	ORG $+8
delta_as_number DQ FLAT:delta_add
	DQ	FLAT:delta_subtract
	DQ	FLAT:delta_multiply
	DQ	FLAT:delta_remainder
	DQ	FLAT:delta_divmod
	DQ	0000000000000000H
	DQ	FLAT:delta_negative
	DQ	FLAT:delta_positive
	DQ	FLAT:delta_abs
	DQ	FLAT:delta_bool
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_divide
	DQ	FLAT:delta_truedivide
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
PyDateTime_DeltaType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_repr
	DQ	FLAT:delta_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_hash
	DQ	0000000000000000H
	DQ	FLAT:delta_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:delta_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_methods
	DQ	FLAT:delta_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_new
	DQ	0000000000000000H
	ORG $+64
date_getset DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:date_year
	ORG $+24
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:date_month
	ORG $+24
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	FLAT:date_day
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
date_kws DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	0000000000000000H
?keywords@?1??date_strftime@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `date_strftime'::`2'::keywords
	DQ	0000000000000000H
date_methods DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	FLAT:date_fromtimestamp
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@
	DQ	FLAT:??_C@_0M@EGBEAMKN@fromordinal?$AA@
	DQ	FLAT:date_fromordinal
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@
	DQ	FLAT:??_C@_05MGEAPCOL@today?$AA@
	DQ	FLAT:date_today
	DD	014H
	ORG $+4
	DQ	FLAT:??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@
	DQ	FLAT:??_C@_05NCKEBKLP@ctime?$AA@
	DQ	FLAT:date_ctime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	FLAT:date_strftime
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:date_format
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	FLAT:date_timetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
	DQ	FLAT:??_C@_0M@NNCHLCCB@isocalendar?$AA@
	DQ	FLAT:date_isocalendar
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:date_isoformat
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@
	DQ	FLAT:??_C@_0L@OLCJLGMC@isoweekday?$AA@
	DQ	FLAT:date_isoweekday
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@
	DQ	FLAT:??_C@_09EONCNCPH@toordinal?$AA@
	DQ	FLAT:date_toordinal
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@
	DQ	FLAT:??_C@_07FALBAABE@weekday?$AA@
	DQ	FLAT:date_weekday
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:date_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:date_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
date_doc DB	'date(year, month, day) --> date object', 00H
	ORG $+9
date_as_number DQ FLAT:date_add
	DQ	FLAT:date_subtract
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+192
PyDateTime_DateType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@GKGBLLNG@datetime?4date?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_repr
	DQ	FLAT:date_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_hash
	DQ	0000000000000000H
	DQ	FLAT:date_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:date_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_methods
	DQ	0000000000000000H
	DQ	FLAT:date_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_new
	DQ	0000000000000000H
	ORG $+64
tzinfo_methods DQ FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:tzinfo_tzname
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:tzinfo_utcoffset
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:tzinfo_dst
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	FLAT:tzinfo_fromutc
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:tzinfo_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
tzinfo_doc DB	'Abstract base class for time zone info objects.', 00H
PyDateTime_TZInfoType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@
	DQ	0000000000000060H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:tzinfo_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:tzinfo_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericNew
	DQ	0000000000000000H
	ORG $+64
timezone_kws DQ	FLAT:??_C@_06KLHHMIGM@offset?$AA@
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	0000000000000000H
	ORG $+8
timezone_methods DQ FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:timezone_tzname
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:timezone_utcoffset
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:timezone_dst
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0N@BDGMCEOD@Return?5None?4?$AA@
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	FLAT:timezone_fromutc
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	FLAT:timezone_getinitargs
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0P@BIOPACEL@pickle?5support?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
timezone_doc DB	'Fixed offset from UTC implementation of tzinfo.', 00H
PyDateTime_TimeZoneType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:timezone_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_hash
	DQ	0000000000000000H
	DQ	FLAT:timezone_str
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:timezone_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyDateTime_TZInfoType
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_new
	ORG $+72
time_getset DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:time_hour
	ORG $+24
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:time_minute
	ORG $+24
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:py_time_second
	ORG $+24
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:time_microsecond
	ORG $+24
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	FLAT:time_tzinfo
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
time_kws DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	0000000000000000H
?keywords@?1??time_strftime@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `time_strftime'::`2'::keywords
	DQ	0000000000000000H
time_methods DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:time_isoformat
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	FLAT:time_strftime
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:date_format
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:time_utcoffset
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:time_tzname
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:time_dst
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:time_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:time_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
time_doc DB	'time([hour[, minute[, second[, microsecond[, tzinfo]]]]]'
	DB	') --> a time object', 0aH, 0aH, 'All arguments are optional. '
	DB	'tzinfo may be None, or an instance of', 0aH, 'a tzinfo subcla'
	DB	'ss. The remaining arguments may be ints.', 0aH, 00H
	ORG $+8
time_as_number DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_bool
	ORG $+192
PyDateTime_TimeType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@NMMCJMEE@datetime?4time?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:time_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_repr
	DQ	FLAT:time_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_hash
	DQ	0000000000000000H
	DQ	FLAT:time_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:time_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_methods
	DQ	0000000000000000H
	DQ	FLAT:time_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_alloc
	DQ	FLAT:time_new
	DQ	0000000000000000H
	ORG $+64
datetime_getset DQ FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:datetime_hour
	ORG $+24
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:datetime_minute
	ORG $+24
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:datetime_second
	ORG $+24
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:datetime_microsecond
	ORG $+24
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	FLAT:datetime_tzinfo
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
datetime_kws DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_now@@9@9 DQ FLAT:??_C@_02IGJGHHBN@tz?$AA@ ; `datetime_now'::`2'::keywords
	DQ	0000000000000000H
?keywords@?1??datetime_fromtimestamp@@9@9 DQ FLAT:??_C@_09OMDJNLDP@timestamp?$AA@ ; `datetime_fromtimestamp'::`2'::keywords
	DQ	FLAT:??_C@_02IGJGHHBN@tz?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_combine@@9@9 DQ FLAT:??_C@_04JNIHBGGH@date?$AA@ ; `datetime_combine'::`2'::keywords
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_isoformat@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `datetime_isoformat'::`2'::keywords
	DQ	0000000000000000H
?keywords@?1??datetime_astimezone@@9@9 DQ FLAT:??_C@_02IGJGHHBN@tz?$AA@ ; `datetime_astimezone'::`2'::keywords
	DQ	0000000000000000H
	ORG $+8
datetime_methods DQ FLAT:??_C@_03CGLHMDPP@now?$AA@
	DQ	FLAT:datetime_now
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@
	DQ	FLAT:??_C@_06GKOOHOFL@utcnow?$AA@
	DQ	FLAT:datetime_utcnow
	DD	014H
	ORG $+4
	DQ	FLAT:??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@
	DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	FLAT:datetime_fromtimestamp
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@
	DQ	FLAT:??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@
	DQ	FLAT:datetime_utcfromtimestamp
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@
	DQ	FLAT:??_C@_08JKOOHOPP@strptime?$AA@
	DQ	FLAT:datetime_strptime
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@
	DQ	FLAT:??_C@_07PCDCECCK@combine?$AA@
	DQ	FLAT:datetime_combine
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@
	DQ	FLAT:??_C@_04JNIHBGGH@date?$AA@
	DQ	FLAT:datetime_getdate
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	FLAT:datetime_gettime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@
	DQ	FLAT:??_C@_06LODNGPBG@timetz?$AA@
	DQ	FLAT:datetime_gettimetz
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@
	DQ	FLAT:??_C@_05NCKEBKLP@ctime?$AA@
	DQ	FLAT:datetime_ctime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	FLAT:datetime_timetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
	DQ	FLAT:??_C@_09OMDJNLDP@timestamp?$AA@
	DQ	FLAT:datetime_timestamp
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@
	DQ	FLAT:??_C@_0N@LHNBNFDP@utctimetuple?$AA@
	DQ	FLAT:datetime_utctimetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:datetime_isoformat
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:datetime_utcoffset
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:datetime_tzname
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:datetime_dst
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:datetime_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@
	DQ	FLAT:??_C@_0L@ECALMFAG@astimezone?$AA@
	DQ	FLAT:datetime_astimezone
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:datetime_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
datetime_doc DB	'datetime(year, month, day[, hour[, minute[, second[, mic'
	DB	'rosecond[,tzinfo]]]]])', 0aH, 0aH, 'The year, month and day a'
	DB	'rguments are required. tzinfo may be None, or an', 0aH, 'inst'
	DB	'ance of a tzinfo subclass. The remaining arguments may be int'
	DB	's.', 0aH, 00H
	ORG $+1
datetime_as_number DQ FLAT:datetime_add
	DQ	FLAT:datetime_subtract
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+192
PyDateTime_DateTimeType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:datetime_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_repr
	DQ	FLAT:datetime_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_hash
	DQ	0000000000000000H
	DQ	FLAT:datetime_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:datetime_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_methods
	DQ	0000000000000000H
	DQ	FLAT:datetime_getset
	DQ	FLAT:PyDateTime_DateType
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_alloc
	DQ	FLAT:datetime_new
	DQ	0000000000000000H
	ORG $+64
CAPI	DQ	FLAT:PyDateTime_DateType
	DQ	FLAT:PyDateTime_DateTimeType
	DQ	FLAT:PyDateTime_TimeType
	DQ	FLAT:PyDateTime_DeltaType
	DQ	FLAT:PyDateTime_TZInfoType
	DQ	FLAT:new_date_ex
	DQ	FLAT:new_datetime_ex
	DQ	FLAT:new_time_ex
	DQ	FLAT:new_delta_ex
	DQ	FLAT:datetime_fromtimestamp
	DQ	FLAT:date_fromtimestamp
	ORG $+8
datetimemodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09BLEDGJAH@_datetime?$AA@
	DQ	FLAT:??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@
	DQ	ffffffffffffffffH
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	__imp__gmtime64:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT gmtime
_TEXT	SEGMENT
_Time$ = 8
gmtime	PROC						; COMDAT

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);
; 104  : #pragma warning( pop )
; 105  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__gmtime64
gmtime	ENDP
_TEXT	ENDS
EXTRN	__imp__localtime64:PROC
; Function compile flags: /Ogtpy
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 8
localtime PROC						; COMDAT

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);
; 117  : #pragma warning( pop )
; 118  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__localtime64
localtime ENDP
_TEXT	ENDS
EXTRN	__imp__mktime64:PROC
; Function compile flags: /Ogtpy
;	COMDAT mktime
_TEXT	SEGMENT
_Tm$ = 8
mktime	PROC						; COMDAT

; 125  :     return _mktime64(_Tm);
; 126  : }

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__mktime64
mktime	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_IncRef
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 32		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 04		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;
; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00040	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\include\objimpl.h
_TEXT	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 8
_PyObject_InitHead PROC					; COMDAT

; 216  :     assert(Py_TYPE(op));
; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00000	48 ba 78 56 ef
	be 34 12 ad de	 mov	 rdx, -2401243008567650696 ; dead1234beef5678H

; 218  :     op->px    = _Py_NOT_PARALLEL;
; 219  :     op->slist_entry.Next = NULL;

  0000a	33 c0		 xor	 eax, eax

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  0000c	48 c7 41 20 01
	00 00 00	 mov	 QWORD PTR [rcx+32], 1
  00014	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00017	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  0001b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 221  :     op->srw_lock  = NULL;

  0001f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 222  :     op->event     = NULL;

  00023	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 223  :     op->orig_type = NULL;

  00027	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;
; 226  :     op->_ob_prev = NULL;
; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;

  0002b	48 89 51 40	 mov	 QWORD PTR [rcx+64], rdx

; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;

  0002f	48 89 51 48	 mov	 QWORD PTR [rcx+72], rdx

; 230  : #endif
; 231  : }

  00033	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@JKHPLOII@PyObject_INIT?$AA@		; `string'
PUBLIC	??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ ; `string'
EXTRN	_Px_NewReference:PROC
EXTRN	_PxObject_Init:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+185
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
CONST	SEGMENT
??_C@_0O@JKHPLOII@PyObject_INIT?$AA@ DB 'PyObject_INIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
CONST	SEGMENT
??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@ DB 'c:\src\pypa'
	DB	'rallel\include\objimpl.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 64
tp$ = 72
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	74 15		 je	 SHORT $LN1@PyObject_I
  00019	48 8b d7	 mov	 rdx, rdi
  0001c	48 8b cb	 mov	 rcx, rbx

; 242  : }

  0001f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 _PxObject_Init
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;
; 239  :     _PyObject_InitHead(op);

  0002e	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00038	33 c0		 xor	 eax, eax

; 240  :     _Py_NewReference(op);

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FGBBJFKA@c?3?2src?2pyparallel?2include?2objimp@
  00041	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  00044	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  00048	48 89 4b 40	 mov	 QWORD PTR [rbx+64], rcx
  0004c	48 89 4b 48	 mov	 QWORD PTR [rbx+72], rcx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@JKHPLOII@PyObject_INIT?$AA@
  00057	4c 8b cb	 mov	 r9, rbx
  0005a	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  00060	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  00064	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
  00068	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  00070	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  00074	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax
  0007c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00084	e8 00 00 00 00	 call	 _PyParallel_Guard
  00089	85 c0		 test	 eax, eax
  0008b	74 16		 je	 SHORT $LN4@PyObject_I
  0008d	48 8b cb	 mov	 rcx, rbx
  00090	e8 00 00 00 00	 call	 _Px_NewReference

; 241  :     return op;

  00095	48 8b c3	 mov	 rax, rbx

; 242  : }

  00098	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
$LN4@PyObject_I:

; 240  :     _Py_NewReference(op);

  000a3	48 c7 43 50 01
	00 00 00	 mov	 QWORD PTR [rbx+80], 1

; 241  :     return op;

  000ab	48 8b c3	 mov	 rax, rbx

; 242  : }

  000ae	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
PyObject_INIT ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
_TEXT	ENDS
;	COMDAT divmod
_TEXT	SEGMENT
x$ = 8
y$ = 16
r$ = 24
divmod	PROC						; COMDAT

; 129  : {

  00000	44 8b d2	 mov	 r10d, edx

; 130  :     int quo;
; 131  : 
; 132  :     assert(y > 0);
; 133  :     quo = x / y;

  00003	8b c1		 mov	 eax, ecx
  00005	99		 cdq
  00006	41 f7 fa	 idiv	 r10d

; 134  :     *r = x - quo * y;

  00009	44 8b c8	 mov	 r9d, eax
  0000c	45 0f af ca	 imul	 r9d, r10d
  00010	41 2b c9	 sub	 ecx, r9d
  00013	41 89 08	 mov	 DWORD PTR [r8], ecx

; 135  :     if (*r < 0) {

  00016	79 05		 jns	 SHORT $LN4@divmod

; 136  :         --quo;

  00018	ff c8		 dec	 eax

; 137  :         *r += y;

  0001a	45 01 10	 add	 DWORD PTR [r8], r10d
$LN4@divmod:

; 138  :     }
; 139  :     assert(0 <= *r && *r < y);
; 140  :     return quo;
; 141  : }

  0001d	f3 c3		 fatret	 0
divmod	ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
EXTRN	_fltused:DWORD
EXTRN	floor:PROC
EXTRN	ceil:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$round_to_long DD imagerel round_to_long
	DD	imagerel round_to_long+58
	DD	imagerel $unwind$round_to_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$round_to_long DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT round_to_long
_TEXT	SEGMENT
x$ = 48
round_to_long PROC					; COMDAT

; 148  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 149  :     if (x >= 0.0)

  00004	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0000c	72 16		 jb	 SHORT $LN2@round_to_l

; 150  :         x = floor(x + 0.5);

  0000e	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00016	e8 00 00 00 00	 call	 floor

; 153  :     return (long)x;

  0001b	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 154  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN2@round_to_l:

; 151  :     else
; 152  :         x = ceil(x - 0.5);

  00024	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  0002c	e8 00 00 00 00	 call	 ceil

; 153  :     return (long)x;

  00031	f2 0f 2c c0	 cvttsd2si eax, xmm0

; 154  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
round_to_long ENDP
_TEXT	ENDS
EXTRN	_PyLong_DivmodNear:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$divide_nearest DD imagerel divide_nearest
	DD	imagerel divide_nearest+115
	DD	imagerel $unwind$divide_nearest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_nearest DD 041e01H
	DD	08341eH
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT divide_nearest
_TEXT	SEGMENT
m$ = 64
n$ = 72
divide_nearest PROC					; COMDAT

; 161  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 162  :     PyObject *result;
; 163  :     PyObject *temp;
; 164  : 
; 165  :     temp = _PyLong_DivmodNear(m, n);

  00006	e8 00 00 00 00	 call	 _PyLong_DivmodNear
  0000b	48 8b f8	 mov	 rdi, rax

; 166  :     if (temp == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@divide_nea

; 173  : }

  00013	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN1@divide_nea:
  00019	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 167  :         return NULL;
; 168  :     result = PyTuple_GET_ITEM(temp, 0);

  0001e	48 8b 58 70	 mov	 rbx, QWORD PTR [rax+112]

; 169  :     Py_INCREF(result);

  00022	e8 00 00 00 00	 call	 _Py_PXCTX
  00027	85 c0		 test	 eax, eax
  00029	75 32		 jne	 SHORT $LN5@divide_nea
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00039	4c 8b cb	 mov	 r9, rbx
  0003c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00042	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004f	85 c0		 test	 eax, eax
  00051	75 06		 jne	 SHORT $LN4@divide_nea
  00053	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00057	74 04		 je	 SHORT $LN5@divide_nea
$LN4@divide_nea:
  00059	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@divide_nea:

; 170  :     Py_DECREF(temp);

  0005d	48 8b cf	 mov	 rcx, rdi
  00060	e8 00 00 00 00	 call	 _Py_DecRef

; 171  : 
; 172  :     return result;

  00065	48 8b c3	 mov	 rax, rbx
  00068	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 173  : }

  0006d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
divide_nearest ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT is_leap
_TEXT	SEGMENT
year$ = 8
is_leap	PROC						; COMDAT

; 197  :     /* Cast year to unsigned.  The result is the same either way, but
; 198  :      * C can generate faster code for unsigned mod than for signed
; 199  :      * mod (especially for % 4 -- a good compiler should just grab
; 200  :      * the last 2 bits when the LHS is unsigned).
; 201  :      */
; 202  :     const unsigned int ayear = (unsigned int)year;
; 203  :     return ayear % 4 == 0 && (ayear % 100 != 0 || ayear % 400 == 0);

  00000	f6 c1 03	 test	 cl, 3
  00003	75 2b		 jne	 SHORT $LN4@is_leap
  00005	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0000a	f7 e1		 mul	 ecx
  0000c	c1 ea 05	 shr	 edx, 5
  0000f	6b d2 64	 imul	 edx, 100		; 00000064H
  00012	3b ca		 cmp	 ecx, edx
  00014	75 14		 jne	 SHORT $LN3@is_leap
  00016	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0001b	f7 e1		 mul	 ecx
  0001d	c1 ea 07	 shr	 edx, 7
  00020	69 d2 90 01 00
	00		 imul	 edx, 400		; 00000190H
  00026	3b ca		 cmp	 ecx, edx
  00028	75 06		 jne	 SHORT $LN4@is_leap
$LN3@is_leap:
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 204  : }

  0002f	c3		 ret	 0
$LN4@is_leap:

; 197  :     /* Cast year to unsigned.  The result is the same either way, but
; 198  :      * C can generate faster code for unsigned mod than for signed
; 199  :      * mod (especially for % 4 -- a good compiler should just grab
; 200  :      * the last 2 bits when the LHS is unsigned).
; 201  :      */
; 202  :     const unsigned int ayear = (unsigned int)year;
; 203  :     return ayear % 4 == 0 && (ayear % 100 != 0 || ayear % 400 == 0);

  00030	33 c0		 xor	 eax, eax

; 204  : }

  00032	c3		 ret	 0
is_leap	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$days_in_month DD imagerel days_in_month
	DD	imagerel days_in_month+47
	DD	imagerel $unwind$days_in_month
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$days_in_month DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT days_in_month
_TEXT	SEGMENT
year$ = 48
month$ = 56
days_in_month PROC					; COMDAT

; 209  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 63 c2	 movsxd	 r8, edx

; 210  :     assert(month >= 1);
; 211  :     assert(month <= 12);
; 212  :     if (month == 2 && is_leap(year))

  00007	41 83 f8 02	 cmp	 r8d, 2
  0000b	75 12		 jne	 SHORT $LN2@days_in_mo
  0000d	e8 00 00 00 00	 call	 is_leap
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $LN2@days_in_mo

; 213  :         return 29;

  00016	41 8d 40 1b	 lea	 eax, QWORD PTR [r8+27]

; 216  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
$LN2@days_in_mo:

; 214  :     else
; 215  :         return _days_in_month[month];

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_days_in_month
  00026	42 8b 04 81	 mov	 eax, DWORD PTR [rcx+r8*4]

; 216  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
days_in_month ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$days_before_month DD imagerel days_before_month
	DD	imagerel days_before_month+44
	DD	imagerel $unwind$days_before_month
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$days_before_month DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT days_before_month
_TEXT	SEGMENT
year$ = 48
month$ = 56
days_before_month PROC					; COMDAT

; 221  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 222  :     int days;
; 223  : 
; 224  :     assert(month >= 1);
; 225  :     assert(month <= 12);
; 226  :     days = _days_before_month[month];

  00004	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_days_before_month
  0000b	48 63 c2	 movsxd	 rax, edx
  0000e	45 8b 04 80	 mov	 r8d, DWORD PTR [r8+rax*4]

; 227  :     if (month > 2 && is_leap(year))

  00012	83 fa 02	 cmp	 edx, 2
  00015	7e 0d		 jle	 SHORT $LN4@days_befor
  00017	e8 00 00 00 00	 call	 is_leap
  0001c	85 c0		 test	 eax, eax

; 228  :         ++days;
; 229  :     return days;

  0001e	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  00022	75 03		 jne	 SHORT $LN1@days_befor
$LN4@days_befor:
  00024	41 8b c0	 mov	 eax, r8d
$LN1@days_befor:

; 230  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
days_before_month ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT days_before_year
_TEXT	SEGMENT
year$ = 8
days_before_year PROC					; COMDAT

; 238  :     int y = year - 1;

  00000	44 8d 41 ff	 lea	 r8d, DWORD PTR [rcx-1]

; 239  :     /* This is incorrect if year <= 0; we really want the floor
; 240  :      * here.  But so long as MINYEAR is 1, the smallest year this
; 241  :      * can see is 1.
; 242  :      */
; 243  :     assert (year >= 1);
; 244  :     return y*365 + y/4 - y/100 + y/400;

  00004	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  00009	41 8b c8	 mov	 ecx, r8d
  0000c	41 f7 e8	 imul	 r8d
  0000f	44 8b ca	 mov	 r9d, edx
  00012	41 c1 f9 07	 sar	 r9d, 7
  00016	69 c9 6d 01 00
	00		 imul	 ecx, 365		; 0000016dH
  0001c	41 8b c1	 mov	 eax, r9d
  0001f	c1 e8 1f	 shr	 eax, 31
  00022	44 03 c8	 add	 r9d, eax
  00025	b8 1f 85 eb 51	 mov	 eax, 1374389535		; 51eb851fH
  0002a	44 03 c9	 add	 r9d, ecx
  0002d	41 f7 e8	 imul	 r8d
  00030	c1 fa 05	 sar	 edx, 5
  00033	41 8b c0	 mov	 eax, r8d
  00036	8b ca		 mov	 ecx, edx
  00038	c1 e9 1f	 shr	 ecx, 31
  0003b	03 d1		 add	 edx, ecx
  0003d	44 2b ca	 sub	 r9d, edx
  00040	99		 cdq
  00041	83 e2 03	 and	 edx, 3
  00044	03 c2		 add	 eax, edx
  00046	c1 f8 02	 sar	 eax, 2
  00049	41 03 c1	 add	 eax, r9d

; 245  : }

  0004c	c3		 ret	 0
days_before_year ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ord_to_ymd DD imagerel ord_to_ymd
	DD	imagerel ord_to_ymd+318
	DD	imagerel $unwind$ord_to_ymd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ord_to_ymd DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ord_to_ymd
_TEXT	SEGMENT
ordinal$ = 48
year$ = 56
month$ = 64
day$ = 72
ord_to_ymd PROC						; COMDAT

; 257  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 258  :     int n, n1, n4, n100, n400, leapyear, preceding;
; 259  : 
; 260  :     /* ordinal is a 1-based index, starting at 1-Jan-1.  The pattern of
; 261  :      * leap years repeats exactly every 400 years.  The basic strategy is
; 262  :      * to find the closest 400-year boundary at or before ordinal, then
; 263  :      * work with the offset from that boundary to ordinal.  Life is much
; 264  :      * clearer if we subtract 1 from ordinal first -- then the values
; 265  :      * of ordinal at 400-year boundaries are exactly those divisible
; 266  :      * by DI400Y:
; 267  :      *
; 268  :      *    D  M   Y            n              n-1
; 269  :      *    -- --- ----        ----------     ----------------
; 270  :      *    31 Dec -400        -DI400Y       -DI400Y -1
; 271  :      *     1 Jan -399         -DI400Y +1   -DI400Y      400-year boundary
; 272  :      *    ...
; 273  :      *    30 Dec  000        -1             -2
; 274  :      *    31 Dec  000         0             -1
; 275  :      *     1 Jan  001         1              0          400-year boundary
; 276  :      *     2 Jan  001         2              1
; 277  :      *     3 Jan  001         3              2
; 278  :      *    ...
; 279  :      *    31 Dec  400         DI400Y        DI400Y -1
; 280  :      *     1 Jan  401         DI400Y +1     DI400Y      400-year boundary
; 281  :      */
; 282  :     assert(ordinal >= 1);
; 283  :     --ordinal;

  0000d	44 8d 51 ff	 lea	 r10d, DWORD PTR [rcx-1]
  00011	4d 8b d9	 mov	 r11, r9

; 284  :     n400 = ordinal / DI400Y;
; 285  :     n = ordinal % DI400Y;

  00014	b8 bd 06 6b 39	 mov	 eax, 963315389		; 396b06bdH
  00019	41 f7 ea	 imul	 r10d
  0001c	c1 fa 0f	 sar	 edx, 15
  0001f	8b c2		 mov	 eax, edx
  00021	c1 e8 1f	 shr	 eax, 31
  00024	03 d0		 add	 edx, eax
  00026	8b c2		 mov	 eax, edx

; 286  :     *year = n400 * 400 + 1;

  00028	69 d2 90 01 00
	00		 imul	 edx, 400		; 00000190H
  0002e	69 c0 b1 3a 02
	00		 imul	 eax, 146097		; 00023ab1H
  00034	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
  00037	44 2b d0	 sub	 r10d, eax

; 287  : 
; 288  :     /* Now n is the (non-negative) offset, in days, from January 1 of
; 289  :      * year, to the desired date.  Now compute how many 100-year cycles
; 290  :      * precede n.
; 291  :      * Note that it's possible for n100 to equal 4!  In that case 4 full
; 292  :      * 100-year cycles precede the desired day, which implies the
; 293  :      * desired day is December 31 at the end of a 400-year cycle.
; 294  :      */
; 295  :     n100 = n / DI100Y;

  0003a	b8 fb 81 ac e5	 mov	 eax, -441679365		; ffffffffe5ac81fbH
  0003f	41 f7 ea	 imul	 r10d
  00042	45 8d 0c 12	 lea	 r9d, DWORD PTR [r10+rdx]
  00046	41 c1 f9 0f	 sar	 r9d, 15
  0004a	41 8b c1	 mov	 eax, r9d
  0004d	c1 e8 1f	 shr	 eax, 31
  00050	44 03 c8	 add	 r9d, eax

; 296  :     n = n % DI100Y;

  00053	41 8b c1	 mov	 eax, r9d
  00056	69 c0 54 71 ff
	ff		 imul	 eax, -36524		; ffffffffffff7154H
  0005c	44 03 d0	 add	 r10d, eax

; 297  : 
; 298  :     /* Now compute how many 4-year cycles precede it. */
; 299  :     n4 = n / DI4Y;

  0005f	b8 73 b0 6d 16	 mov	 eax, 376287347		; 166db073H
  00064	41 f7 ea	 imul	 r10d
  00067	8b fa		 mov	 edi, edx
  00069	c1 ff 07	 sar	 edi, 7
  0006c	8b c7		 mov	 eax, edi
  0006e	c1 e8 1f	 shr	 eax, 31
  00071	03 f8		 add	 edi, eax

; 300  :     n = n % DI4Y;

  00073	8b c7		 mov	 eax, edi
  00075	69 c0 4b fa ff
	ff		 imul	 eax, -1461		; fffffffffffffa4bH
  0007b	44 03 d0	 add	 r10d, eax

; 301  : 
; 302  :     /* And now how many single years.  Again n1 can be 4, and again
; 303  :      * meaning that the desired day is December 31 at the end of the
; 304  :      * 4-year cycle.
; 305  :      */
; 306  :     n1 = n / 365;

  0007e	b8 b1 f9 8c b3	 mov	 eax, -1282606671	; ffffffffb38cf9b1H
  00083	41 f7 ea	 imul	 r10d
  00086	41 03 d2	 add	 edx, r10d
  00089	c1 fa 08	 sar	 edx, 8
  0008c	8b c2		 mov	 eax, edx
  0008e	c1 e8 1f	 shr	 eax, 31
  00091	03 d0		 add	 edx, eax

; 307  :     n = n % 365;

  00093	8b c2		 mov	 eax, edx
  00095	69 c0 93 fe ff
	ff		 imul	 eax, -365		; fffffffffffffe93H
  0009b	44 03 d0	 add	 r10d, eax

; 308  : 
; 309  :     *year += n100 * 100 + n4 * 4 + n1;

  0009e	41 8b c1	 mov	 eax, r9d
  000a1	6b c0 19	 imul	 eax, 25
  000a4	03 c7		 add	 eax, edi
  000a6	8d 04 81	 lea	 eax, DWORD PTR [rcx+rax*4]
  000a9	03 c2		 add	 eax, edx
  000ab	89 03		 mov	 DWORD PTR [rbx], eax

; 310  :     if (n1 == 4 || n100 == 4) {

  000ad	83 fa 04	 cmp	 edx, 4
  000b0	74 6f		 je	 SHORT $LN2@ord_to_ymd
  000b2	41 83 f9 04	 cmp	 r9d, 4
  000b6	74 69		 je	 SHORT $LN2@ord_to_ymd

; 313  :         *month = 12;
; 314  :         *day = 31;
; 315  :         return;
; 316  :     }
; 317  : 
; 318  :     /* Now the year is correct, and n is the offset from January 1.  We
; 319  :      * find the month via an estimate that's either exact or one too
; 320  :      * large.
; 321  :      */
; 322  :     leapyear = n1 == 3 && (n4 != 24 || n100 == 3);

  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	83 fa 03	 cmp	 edx, 3
  000c0	75 0e		 jne	 SHORT $LN7@ord_to_ymd
  000c2	83 ff 18	 cmp	 edi, 24
  000c5	75 05		 jne	 SHORT $LN6@ord_to_ymd
  000c7	44 3b ca	 cmp	 r9d, edx
  000ca	75 04		 jne	 SHORT $LN7@ord_to_ymd
$LN6@ord_to_ymd:
  000cc	8b c1		 mov	 eax, ecx
  000ce	eb 02		 jmp	 SHORT $LN8@ord_to_ymd
$LN7@ord_to_ymd:
  000d0	33 c0		 xor	 eax, eax
$LN8@ord_to_ymd:

; 323  :     assert(leapyear == is_leap(*year));
; 324  :     *month = (n + 50) >> 5;

  000d2	41 8d 52 32	 lea	 edx, DWORD PTR [r10+50]
  000d6	c1 fa 05	 sar	 edx, 5
  000d9	41 89 10	 mov	 DWORD PTR [r8], edx

; 325  :     preceding = (_days_before_month[*month] + (*month > 2 && leapyear));

  000dc	83 fa 02	 cmp	 edx, 2
  000df	7e 04		 jle	 SHORT $LN9@ord_to_ymd
  000e1	85 c0		 test	 eax, eax
  000e3	75 02		 jne	 SHORT $LN10@ord_to_ymd
$LN9@ord_to_ymd:
  000e5	33 c9		 xor	 ecx, ecx
$LN10@ord_to_ymd:
  000e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_days_before_month
  000ee	48 63 c2	 movsxd	 rax, edx
  000f1	41 8b 04 81	 mov	 eax, DWORD PTR [r9+rax*4]
  000f5	44 8d 0c 01	 lea	 r9d, DWORD PTR [rcx+rax]

; 326  :     if (preceding > n) {

  000f9	45 3b ca	 cmp	 r9d, r10d
  000fc	7e 0f		 jle	 SHORT $LN1@ord_to_ymd

; 327  :         /* estimate is too large */
; 328  :         *month -= 1;

  000fe	ff ca		 dec	 edx
  00100	41 89 10	 mov	 DWORD PTR [r8], edx

; 329  :         preceding -= days_in_month(*year, *month);

  00103	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00105	e8 00 00 00 00	 call	 days_in_month
  0010a	44 2b c8	 sub	 r9d, eax
$LN1@ord_to_ymd:

; 330  :     }
; 331  :     n -= preceding;
; 332  :     assert(0 <= n);
; 333  :     assert(n < days_in_month(*year, *month));
; 334  : 
; 335  :     *day = n + 1;

  0010d	45 2b d1	 sub	 r10d, r9d
  00110	41 ff c2	 inc	 r10d
  00113	45 89 13	 mov	 DWORD PTR [r11], r10d

; 336  : }

  00116	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011f	5f		 pop	 rdi
  00120	c3		 ret	 0
$LN2@ord_to_ymd:

; 311  :         assert(n == 0);
; 312  :         *year -= 1;

  00121	ff c8		 dec	 eax
  00123	89 03		 mov	 DWORD PTR [rbx], eax

; 336  : }

  00125	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012a	41 c7 00 0c 00
	00 00		 mov	 DWORD PTR [r8], 12
  00131	41 c7 03 1f 00
	00 00		 mov	 DWORD PTR [r11], 31
  00138	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013c	5f		 pop	 rdi
  0013d	c3		 ret	 0
ord_to_ymd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ymd_to_ord DD imagerel ymd_to_ord
	DD	imagerel ymd_to_ord+31
	DD	imagerel $unwind$ymd_to_ord
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ymd_to_ord DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT ymd_to_ord
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
ymd_to_ord PROC						; COMDAT

; 341  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	45 8b d8	 mov	 r11d, r8d

; 342  :     return days_before_year(year) + days_before_month(year, month) + day;

  00007	e8 00 00 00 00	 call	 days_before_month
  0000c	44 8b d0	 mov	 r10d, eax
  0000f	e8 00 00 00 00	 call	 days_before_year
  00014	43 8d 0c 13	 lea	 ecx, DWORD PTR [r11+r10]
  00018	03 c1		 add	 eax, ecx

; 343  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
ymd_to_ord ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$weekday DD imagerel weekday
	DD	imagerel weekday+48
	DD	imagerel $unwind$weekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$weekday DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT weekday
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
weekday	PROC						; COMDAT

; 348  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 349  :     return (ymd_to_ord(year, month, day) + 6) % 7;

  00004	e8 00 00 00 00	 call	 ymd_to_ord
  00009	44 8d 58 06	 lea	 r11d, DWORD PTR [rax+6]
  0000d	b8 93 24 49 92	 mov	 eax, -1840700269	; ffffffff92492493H
  00012	41 f7 eb	 imul	 r11d
  00015	41 03 d3	 add	 edx, r11d
  00018	c1 fa 02	 sar	 edx, 2
  0001b	8b ca		 mov	 ecx, edx
  0001d	c1 e9 1f	 shr	 ecx, 31
  00020	03 d1		 add	 edx, ecx
  00022	6b d2 07	 imul	 edx, 7
  00025	44 2b da	 sub	 r11d, edx
  00028	41 8b c3	 mov	 eax, r11d

; 350  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
weekday	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso_week1_monday DD imagerel iso_week1_monday
	DD	imagerel iso_week1_monday+72
	DD	imagerel $unwind$iso_week1_monday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso_week1_monday DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT iso_week1_monday
_TEXT	SEGMENT
year$ = 48
iso_week1_monday PROC					; COMDAT

; 357  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 358  :     int first_day = ymd_to_ord(year, 1, 1);     /* ord of 1/1 */

  00004	ba 01 00 00 00	 mov	 edx, 1
  00009	44 8b c2	 mov	 r8d, edx
  0000c	e8 00 00 00 00	 call	 ymd_to_ord
  00011	44 8b d8	 mov	 r11d, eax

; 359  :     /* 0 if 1/1 is a Monday, 1 if a Tue, etc. */
; 360  :     int first_weekday = (first_day + 6) % 7;

  00014	44 8d 40 06	 lea	 r8d, DWORD PTR [rax+6]
  00018	b8 93 24 49 92	 mov	 eax, -1840700269	; ffffffff92492493H
  0001d	41 f7 e8	 imul	 r8d
  00020	41 03 d0	 add	 edx, r8d
  00023	c1 fa 02	 sar	 edx, 2
  00026	8b ca		 mov	 ecx, edx
  00028	c1 e9 1f	 shr	 ecx, 31
  0002b	03 d1		 add	 edx, ecx
  0002d	6b d2 07	 imul	 edx, 7
  00030	44 2b c2	 sub	 r8d, edx

; 361  :     /* ordinal of closest Monday at or before 1/1 */
; 362  :     int week1_monday  = first_day - first_weekday;

  00033	45 2b d8	 sub	 r11d, r8d

; 363  : 
; 364  :     if (first_weekday > 3)      /* if 1/1 was Fri, Sat, Sun */
; 365  :         week1_monday += 7;
; 366  :     return week1_monday;

  00036	41 8d 43 07	 lea	 eax, DWORD PTR [r11+7]
  0003a	41 83 f8 03	 cmp	 r8d, 3
  0003e	7f 03		 jg	 SHORT $LN1@iso_week1_
  00040	41 8b c3	 mov	 eax, r11d
$LN1@iso_week1_:

; 367  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
iso_week1_monday ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_delta_day_range DD imagerel check_delta_day_range
	DD	imagerel check_delta_day_range+60
	DD	imagerel $unwind$check_delta_day_range
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_delta_day_range DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@
CONST	SEGMENT
??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@ DB 'd'
	DB	'ays=%d; must have magnitude <= %d', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_delta_day_range
_TEXT	SEGMENT
days$ = 48
check_delta_day_range PROC				; COMDAT

; 378  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 379  :     if (-MAX_DELTA_DAYS <= days && days <= MAX_DELTA_DAYS)

  00004	8d 81 ff c9 9a
	3b		 lea	 eax, DWORD PTR [rcx+999999999]
  0000a	3d fe 93 35 77	 cmp	 eax, 1999999998		; 773593feH
  0000f	77 07		 ja	 SHORT $LN1@check_delt

; 380  :         return 0;

  00011	33 c0		 xor	 eax, eax

; 385  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN1@check_delt:

; 381  :     PyErr_Format(PyExc_OverflowError,
; 382  :                  "days=%d; must have magnitude <= %d",
; 383  :                  days, MAX_DELTA_DAYS);

  00018	44 8b c1	 mov	 r8d, ecx
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@
  00029	41 b9 ff c9 9a
	3b		 mov	 r9d, 999999999		; 3b9ac9ffH
  0002f	e8 00 00 00 00	 call	 PyErr_Format

; 384  :     return -1;

  00034	83 c8 ff	 or	 eax, -1

; 385  : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
check_delta_day_range ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@ ; `string'
PUBLIC	??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_date_args DD imagerel check_date_args
	DD	imagerel check_date_args+129
	DD	imagerel $unwind$check_date_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_date_args DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@ DB 'year is out of range'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@
CONST	SEGMENT
??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@ DB 'month must be in'
	DB	' 1..12', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@
CONST	SEGMENT
??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@ DB 'day is ou'
	DB	't of range for month', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_date_args
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
check_date_args PROC					; COMDAT

; 392  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 393  : 
; 394  :     if (year < MINYEAR || year > MAXYEAR) {

  00004	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  00007	45 8b c8	 mov	 r9d, r8d
  0000a	3d 0e 27 00 00	 cmp	 eax, 9998		; 0000270eH
  0000f	77 55		 ja	 SHORT $LN5@check_date

; 398  :     }
; 399  :     if (month < 1 || month > 12) {

  00011	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00014	83 f8 0b	 cmp	 eax, 11
  00017	77 32		 ja	 SHORT $LN3@check_date

; 402  :         return -1;
; 403  :     }
; 404  :     if (day < 1 || day > days_in_month(year, month)) {

  00019	41 83 f8 01	 cmp	 r8d, 1
  0001d	7c 11		 jl	 SHORT $LN1@check_date
  0001f	e8 00 00 00 00	 call	 days_in_month
  00024	44 3b c8	 cmp	 r9d, eax
  00027	7f 07		 jg	 SHORT $LN1@check_date

; 407  :         return -1;
; 408  :     }
; 409  :     return 0;

  00029	33 c0		 xor	 eax, eax

; 410  : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN1@check_date:

; 395  :         PyErr_SetString(PyExc_ValueError,
; 396  :                         "year is out of range");

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 405  :         PyErr_SetString(PyExc_ValueError,
; 406  :                         "day is out of range for month");

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@
  0003e	e8 00 00 00 00	 call	 PyErr_SetString
  00043	83 c8 ff	 or	 eax, -1

; 410  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
$LN3@check_date:

; 395  :         PyErr_SetString(PyExc_ValueError,
; 396  :                         "year is out of range");

  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 400  :         PyErr_SetString(PyExc_ValueError,
; 401  :                         "month must be in 1..12");

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@
  00059	e8 00 00 00 00	 call	 PyErr_SetString
  0005e	83 c8 ff	 or	 eax, -1

; 410  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
$LN5@check_date:

; 395  :         PyErr_SetString(PyExc_ValueError,
; 396  :                         "year is out of range");

  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@
  00074	e8 00 00 00 00	 call	 PyErr_SetString

; 397  :         return -1;

  00079	83 c8 ff	 or	 eax, -1

; 410  : }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	c3		 ret	 0
check_date_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@ ; `string'
PUBLIC	??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@ ; `string'
PUBLIC	??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@ ; `string'
PUBLIC	??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_time_args DD imagerel check_time_args
	DD	imagerel check_time_args+144
	DD	imagerel $unwind$check_time_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_time_args DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@
CONST	SEGMENT
??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@ DB 'hour must be in 0'
	DB	'..23', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@
CONST	SEGMENT
??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@ DB 'minute must be '
	DB	'in 0..59', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@
CONST	SEGMENT
??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@ DB 'second must be '
	DB	'in 0..59', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@
CONST	SEGMENT
??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@ DB 'microsecon'
	DB	'd must be in 0..999999', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_time_args
_TEXT	SEGMENT
h$ = 48
m$ = 56
s$ = 64
us$ = 72
check_time_args PROC					; COMDAT

; 417  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     if (h < 0 || h > 23) {

  00004	83 f9 17	 cmp	 ecx, 23
  00007	77 6c		 ja	 SHORT $LN7@check_time

; 422  :     }
; 423  :     if (m < 0 || m > 59) {

  00009	83 fa 3b	 cmp	 edx, 59			; 0000003bH
  0000c	77 4c		 ja	 SHORT $LN5@check_time

; 426  :         return -1;
; 427  :     }
; 428  :     if (s < 0 || s > 59) {

  0000e	41 83 f8 3b	 cmp	 r8d, 59			; 0000003bH
  00012	77 2b		 ja	 SHORT $LN3@check_time

; 431  :         return -1;
; 432  :     }
; 433  :     if (us < 0 || us > 999999) {

  00014	41 81 f9 3f 42
	0f 00		 cmp	 r9d, 999999		; 000f423fH
  0001b	77 07		 ja	 SHORT $LN1@check_time

; 436  :         return -1;
; 437  :     }
; 438  :     return 0;

  0001d	33 c0		 xor	 eax, eax

; 439  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN1@check_time:

; 419  :         PyErr_SetString(PyExc_ValueError,
; 420  :                         "hour must be in 0..23");

  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 434  :         PyErr_SetString(PyExc_ValueError,
; 435  :                         "microsecond must be in 0..999999");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@
  00032	e8 00 00 00 00	 call	 PyErr_SetString
  00037	83 c8 ff	 or	 eax, -1

; 439  : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
$LN3@check_time:

; 419  :         PyErr_SetString(PyExc_ValueError,
; 420  :                         "hour must be in 0..23");

  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 429  :         PyErr_SetString(PyExc_ValueError,
; 430  :                         "second must be in 0..59");

  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@
  0004d	e8 00 00 00 00	 call	 PyErr_SetString
  00052	83 c8 ff	 or	 eax, -1

; 439  : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
$LN5@check_time:

; 419  :         PyErr_SetString(PyExc_ValueError,
; 420  :                         "hour must be in 0..23");

  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError

; 424  :         PyErr_SetString(PyExc_ValueError,
; 425  :                         "minute must be in 0..59");

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@
  00068	e8 00 00 00 00	 call	 PyErr_SetString
  0006d	83 c8 ff	 or	 eax, -1

; 439  : }

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00074	c3		 ret	 0
$LN7@check_time:

; 419  :         PyErr_SetString(PyExc_ValueError,
; 420  :                         "hour must be in 0..23");

  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@
  00083	e8 00 00 00 00	 call	 PyErr_SetString

; 421  :         return -1;

  00088	83 c8 ff	 or	 eax, -1

; 439  : }

  0008b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008f	c3		 ret	 0
check_time_args ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_pair DD imagerel normalize_pair
	DD	imagerel normalize_pair+38
	DD	imagerel $unwind$normalize_pair
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_pair DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT normalize_pair
_TEXT	SEGMENT
hi$ = 48
lo$ = 56
factor$ = 64
normalize_pair PROC					; COMDAT

; 453  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b d9	 mov	 r11, rcx

; 454  :     assert(factor > 0);
; 455  :     assert(lo != hi);
; 456  :     if (*lo < 0 || *lo >= factor) {

  00007	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00009	41 8b c0	 mov	 eax, r8d
  0000c	85 c9		 test	 ecx, ecx
  0000e	78 04		 js	 SHORT $LN1@normalize_
  00010	3b c8		 cmp	 ecx, eax
  00012	7c 0d		 jl	 SHORT $LN2@normalize_
$LN1@normalize_:

; 457  :         const int num_hi = divmod(*lo, factor, lo);

  00014	4c 8b c2	 mov	 r8, rdx
  00017	8b d0		 mov	 edx, eax
  00019	e8 00 00 00 00	 call	 divmod

; 458  :         const int new_hi = *hi + num_hi;
; 459  :         assert(! SIGNED_ADD_OVERFLOWED(new_hi, *hi, num_hi));
; 460  :         *hi = new_hi;

  0001e	41 01 03	 add	 DWORD PTR [r11], eax
$LN2@normalize_:

; 461  :     }
; 462  :     assert(0 <= *lo && *lo < factor);
; 463  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
normalize_pair ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_d_s_us DD imagerel normalize_d_s_us
	DD	imagerel normalize_d_s_us+91
	DD	imagerel $unwind$normalize_d_s_us
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_d_s_us DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT normalize_d_s_us
_TEXT	SEGMENT
d$ = 48
s$ = 56
us$ = 64
normalize_d_s_us PROC					; COMDAT

; 473  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 474  :     if (*us < 0 || *us >= 1000000) {

  0000a	41 8b 00	 mov	 eax, DWORD PTR [r8]
  0000d	4d 8b c8	 mov	 r9, r8
  00010	48 8b da	 mov	 rbx, rdx
  00013	48 8b f9	 mov	 rdi, rcx
  00016	85 c0		 test	 eax, eax
  00018	78 07		 js	 SHORT $LN3@normalize_@2
  0001a	3d 40 42 0f 00	 cmp	 eax, 1000000		; 000f4240H
  0001f	7c 11		 jl	 SHORT $LN4@normalize_@2
$LN3@normalize_@2:

; 475  :         normalize_pair(s, us, 1000000);

  00021	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  00027	49 8b d1	 mov	 rdx, r9
  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 normalize_pair
$LN4@normalize_@2:

; 476  :         /* |s| can't be bigger than about
; 477  :          * |original s| + |original us|/1000000 now.
; 478  :          */
; 479  : 
; 480  :     }
; 481  :     if (*s < 0 || *s >= 24*3600) {

  00032	8b 03		 mov	 eax, DWORD PTR [rbx]
  00034	85 c0		 test	 eax, eax
  00036	78 07		 js	 SHORT $LN1@normalize_@2
  00038	3d 80 51 01 00	 cmp	 eax, 86400		; 00015180H
  0003d	7c 11		 jl	 SHORT $LN2@normalize_@2
$LN1@normalize_@2:

; 482  :         normalize_pair(d, s, 24*3600);

  0003f	41 b8 80 51 01
	00		 mov	 r8d, 86400		; 00015180H
  00045	48 8b d3	 mov	 rdx, rbx
  00048	48 8b cf	 mov	 rcx, rdi
  0004b	e8 00 00 00 00	 call	 normalize_pair
$LN2@normalize_@2:

; 483  :         /* |d| can't be bigger than about
; 484  :          * |original d| +
; 485  :          * (|original s| + |original us|/1000000) / (24*3600) now.
; 486  :          */
; 487  :     }
; 488  :     assert(0 <= *s && *s < 24*3600);
; 489  :     assert(0 <= *us && *us < 1000000);
; 490  : }

  00050	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
normalize_d_s_us ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_y_m_d DD imagerel normalize_y_m_d
	DD	imagerel normalize_y_m_d+239
	DD	imagerel $unwind$normalize_y_m_d
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_y_m_d DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT ??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@ DB 'date value out of'
	DB	' range', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT normalize_y_m_d
_TEXT	SEGMENT
y$ = 48
m$ = 56
d$ = 64
normalize_y_m_d PROC					; COMDAT

; 500  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 501  :     int dim;            /* # of days in month */
; 502  : 
; 503  :     /* In actual use, m is always the month component extracted from a
; 504  :      * date/datetime object.  Therefore it is always in [1, 12] range.
; 505  :      */
; 506  : 
; 507  :     assert(1 <= *m && *m <= 12);
; 508  : 
; 509  :     /* Now only day can be out of bounds (year may also be out of bounds
; 510  :      * for a datetime object, but we don't care about that here).
; 511  :      * If day is out of bounds, what to do is arguable, but at least the
; 512  :      * method here is principled and explainable.
; 513  :      */
; 514  :     dim = days_in_month(*y, *m);

  00014	44 8b 0a	 mov	 r9d, DWORD PTR [rdx]
  00017	44 8b 11	 mov	 r10d, DWORD PTR [rcx]
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	41 8b d1	 mov	 edx, r9d
  00023	41 8b ca	 mov	 ecx, r10d
  00026	49 8b f0	 mov	 rsi, r8
  00029	e8 00 00 00 00	 call	 days_in_month

; 515  :     if (*d < 1 || *d > dim) {

  0002e	8b 2e		 mov	 ebp, DWORD PTR [rsi]
  00030	83 fd 01	 cmp	 ebp, 1
  00033	7c 04		 jl	 SHORT $LN12@normalize_@3
  00035	3b e8		 cmp	 ebp, eax
  00037	7e 48		 jle	 SHORT $LN6@normalize_@3
$LN12@normalize_@3:

; 516  :         /* Move day-1 days from the first of the month.  First try to
; 517  :          * get off cheap if we're only one day out of range
; 518  :          * (adjustments for timezone alone can't be worse than that).
; 519  :          */
; 520  :         if (*d == 0) {

  00039	85 ed		 test	 ebp, ebp
  0003b	75 25		 jne	 SHORT $LN11@normalize_@3

; 521  :             --*m;

  0003d	41 8d 51 ff	 lea	 edx, DWORD PTR [r9-1]
  00041	89 17		 mov	 DWORD PTR [rdi], edx

; 522  :             if (*m > 0)

  00043	85 d2		 test	 edx, edx
  00045	7e 0b		 jle	 SHORT $LN10@normalize_@3

; 523  :                 *d = days_in_month(*y, *m);

  00047	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00049	e8 00 00 00 00	 call	 days_in_month
  0004e	89 06		 mov	 DWORD PTR [rsi], eax

; 524  :             else {

  00050	eb 2f		 jmp	 SHORT $LN6@normalize_@3
$LN10@normalize_@3:

; 525  :                 --*y;

  00052	ff 0b		 dec	 DWORD PTR [rbx]

; 526  :                 *m = 12;

  00054	c7 07 0c 00 00
	00		 mov	 DWORD PTR [rdi], 12

; 527  :                 *d = 31;

  0005a	c7 06 1f 00 00
	00		 mov	 DWORD PTR [rsi], 31

; 528  :             }

  00060	eb 1f		 jmp	 SHORT $LN6@normalize_@3
$LN11@normalize_@3:

; 529  :         }
; 530  :         else if (*d == dim + 1) {

  00062	ff c0		 inc	 eax
  00064	3b e8		 cmp	 ebp, eax
  00066	75 2b		 jne	 SHORT $LN7@normalize_@3

; 531  :             /* move forward a day */
; 532  :             ++*m;

  00068	41 8d 41 01	 lea	 eax, DWORD PTR [r9+1]
  0006c	89 07		 mov	 DWORD PTR [rdi], eax

; 533  :             *d = 1;

  0006e	c7 06 01 00 00
	00		 mov	 DWORD PTR [rsi], 1

; 534  :             if (*m > 12) {

  00074	83 3f 0c	 cmp	 DWORD PTR [rdi], 12
  00077	7e 08		 jle	 SHORT $LN6@normalize_@3

; 535  :                 *m = 1;

  00079	c7 07 01 00 00
	00		 mov	 DWORD PTR [rdi], 1

; 536  :                 ++*y;

  0007f	ff 03		 inc	 DWORD PTR [rbx]
$LN6@normalize_@3:

; 547  :             }
; 548  :         }
; 549  :     }
; 550  :     assert(*m > 0);
; 551  :     assert(*d > 0);
; 552  :     if (MINYEAR <= *y && *y <= MAXYEAR)

  00081	8b 03		 mov	 eax, DWORD PTR [rbx]
  00083	83 f8 01	 cmp	 eax, 1
  00086	7c 3c		 jl	 SHORT $error$20598
  00088	3d 0f 27 00 00	 cmp	 eax, 9999		; 0000270fH
  0008d	7f 35		 jg	 SHORT $error$20598

; 553  :         return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	eb 47		 jmp	 SHORT $LN14@normalize_@3
$LN7@normalize_@3:

; 537  :             }
; 538  :         }
; 539  :         else {
; 540  :             int ordinal = ymd_to_ord(*y, *m, 1) +
; 541  :                                       *d - 1;

  00093	41 b8 01 00 00
	00		 mov	 r8d, 1
  00099	41 8b d1	 mov	 edx, r9d
  0009c	41 8b ca	 mov	 ecx, r10d
  0009f	e8 00 00 00 00	 call	 ymd_to_ord
  000a4	8d 4c 28 ff	 lea	 ecx, DWORD PTR [rax+rbp-1]

; 542  :             if (ordinal < 1 || ordinal > MAXORDINAL) {

  000a8	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]
  000ab	3d da b9 37 00	 cmp	 eax, 3652058		; 0037b9daH
  000b0	77 12		 ja	 SHORT $error$20598

; 543  :                 goto error;
; 544  :             } else {
; 545  :                 ord_to_ymd(ordinal, y, m, d);

  000b2	4c 8b ce	 mov	 r9, rsi
  000b5	4c 8b c7	 mov	 r8, rdi
  000b8	48 8b d3	 mov	 rdx, rbx
  000bb	e8 00 00 00 00	 call	 ord_to_ymd

; 546  :                 return 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	eb 16		 jmp	 SHORT $LN14@normalize_@3
$error$20598:

; 554  :  error:
; 555  :     PyErr_SetString(PyExc_OverflowError,
; 556  :             "date value out of range");

  000c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@
  000d2	e8 00 00 00 00	 call	 PyErr_SetString

; 557  :     return -1;

  000d7	83 c8 ff	 or	 eax, -1
$LN14@normalize_@3:

; 558  : 
; 559  : }

  000da	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000df	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000e4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000e9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ed	5f		 pop	 rdi
  000ee	c3		 ret	 0
normalize_y_m_d ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT normalize_date
_TEXT	SEGMENT
year$ = 8
month$ = 16
day$ = 24
normalize_date PROC					; COMDAT

; 568  :     return normalize_y_m_d(year, month, day);
; 569  : }

  00000	e9 00 00 00 00	 jmp	 normalize_y_m_d
normalize_date ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_datetime DD imagerel normalize_datetime
	DD	imagerel normalize_datetime+146
	DD	imagerel $unwind$normalize_datetime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_datetime DD 081501H
	DD	087415H
	DD	076415H
	DD	065415H
	DD	0c0113215H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT normalize_datetime
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
hour$ = 72
minute$ = 80
second$ = 88
microsecond$ = 96
normalize_datetime PROC					; COMDAT

; 578  : {

  00000	48 89 6c 24 08	 mov	 QWORD PTR [rsp+8], rbp
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	48 8b ea	 mov	 rbp, rdx

; 579  :     normalize_pair(second, microsecond, 1000000);

  00018	48 8b 54 24 60	 mov	 rdx, QWORD PTR microsecond$[rsp]
  0001d	4c 8b e1	 mov	 r12, rcx
  00020	48 8b 4c 24 58	 mov	 rcx, QWORD PTR second$[rsp]
  00025	49 8b f0	 mov	 rsi, r8
  00028	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  0002e	49 8b f9	 mov	 rdi, r9
  00031	e8 00 00 00 00	 call	 normalize_pair

; 580  :     normalize_pair(minute, second, 60);

  00036	48 8b 54 24 58	 mov	 rdx, QWORD PTR second$[rsp]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR minute$[rsp]
  00040	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  00046	e8 00 00 00 00	 call	 normalize_pair

; 581  :     normalize_pair(hour, minute, 60);

  0004b	48 8b 54 24 50	 mov	 rdx, QWORD PTR minute$[rsp]
  00050	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  00056	48 8b cf	 mov	 rcx, rdi
  00059	e8 00 00 00 00	 call	 normalize_pair

; 582  :     normalize_pair(day, hour, 24);

  0005e	41 b8 18 00 00
	00		 mov	 r8d, 24
  00064	48 8b d7	 mov	 rdx, rdi
  00067	48 8b ce	 mov	 rcx, rsi
  0006a	e8 00 00 00 00	 call	 normalize_pair

; 583  :     return normalize_date(year, month, day);

  0006f	4c 8b c6	 mov	 r8, rsi
  00072	48 8b d5	 mov	 rdx, rbp
  00075	49 8b cc	 mov	 rcx, r12

; 584  : }

  00078	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0007d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00082	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	41 5c		 pop	 r12
  0008d	e9 00 00 00 00	 jmp	 normalize_date
normalize_datetime ENDP
_TEXT	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyObject_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_alloc DD imagerel time_alloc
	DD	imagerel time_alloc+82
	DD	imagerel $unwind$time_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_alloc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT time_alloc
_TEXT	SEGMENT
type$ = 48
aware$ = 56
time_alloc PROC						; COMDAT

; 609  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 610  :     PyObject *self;
; 611  : 
; 612  :     self = (PyObject *)
; 613  :         PyObject_MALLOC(aware ?
; 614  :                         sizeof(PyDateTime_Time) :
; 615  :                 sizeof(_PyDateTime_BaseTime));

  0000d	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00012	48 85 d2	 test	 rdx, rdx
  00015	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0001a	0f 45 c8	 cmovne	 ecx, eax
  0001d	e8 00 00 00 00	 call	 PyObject_Malloc
  00022	48 8b d8	 mov	 rbx, rax

; 616  :     if (self == NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	75 0f		 jne	 SHORT $LN1@time_alloc

; 620  : }

  0002a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN1@time_alloc:

; 617  :         return (PyObject *)PyErr_NoMemory();
; 618  :     PyObject_INIT(self, type);

  00039	48 8b d7	 mov	 rdx, rdi
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 PyObject_INIT

; 619  :     return self;

  00044	48 8b c3	 mov	 rax, rbx

; 620  : }

  00047	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
time_alloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_alloc DD imagerel datetime_alloc
	DD	imagerel datetime_alloc+71
	DD	imagerel $unwind$datetime_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_alloc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_alloc
_TEXT	SEGMENT
type$ = 48
aware$ = 56
datetime_alloc PROC					; COMDAT

; 624  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 625  :     PyObject *self;
; 626  : 
; 627  :     self = (PyObject *)
; 628  :         PyObject_MALLOC(aware ?
; 629  :                         sizeof(PyDateTime_DateTime) :
; 630  :                 sizeof(_PyDateTime_BaseDateTime));

  0000d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00012	e8 00 00 00 00	 call	 PyObject_Malloc
  00017	48 8b d8	 mov	 rbx, rax

; 631  :     if (self == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 0f		 jne	 SHORT $LN1@datetime_a

; 635  : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	e9 00 00 00 00	 jmp	 PyErr_NoMemory
$LN1@datetime_a:

; 632  :         return (PyObject *)PyErr_NoMemory();
; 633  :     PyObject_INIT(self, type);

  0002e	48 8b d7	 mov	 rdx, rdi
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 PyObject_INIT

; 634  :     return self;

  00039	48 8b c3	 mov	 rax, rbx

; 635  : }

  0003c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
datetime_alloc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT set_date_fields
_TEXT	SEGMENT
self$ = 8
y$ = 16
m$ = 24
d$ = 32
set_date_fields PROC					; COMDAT

; 646  :     self->hashcode = -1;
; 647  :     SET_YEAR(self, y);

  00000	8b c2		 mov	 eax, edx
  00002	48 c7 41 60 ff
	ff ff ff	 mov	 QWORD PTR [rcx+96], -1
  0000a	88 51 6a	 mov	 BYTE PTR [rcx+106], dl
  0000d	c1 f8 08	 sar	 eax, 8

; 648  :     SET_MONTH(self, m);

  00010	44 88 41 6b	 mov	 BYTE PTR [rcx+107], r8b

; 649  :     SET_DAY(self, d);

  00014	44 88 49 6c	 mov	 BYTE PTR [rcx+108], r9b
  00018	88 41 69	 mov	 BYTE PTR [rcx+105], al

; 650  : }

  0001b	c3		 ret	 0
set_date_fields ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_date_ex DD imagerel new_date_ex
	DD	imagerel new_date_ex+74
	DD	imagerel $unwind$new_date_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_date_ex DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT new_date_ex
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
type$ = 72
new_date_ex PROC					; COMDAT

; 659  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b fa		 mov	 edi, edx
  00011	8b f1		 mov	 esi, ecx

; 660  :     PyDateTime_Date *self;
; 661  : 
; 662  :     self = (PyDateTime_Date *) (type->tp_alloc(type, 0));

  00013	33 d2		 xor	 edx, edx
  00015	49 8b c9	 mov	 rcx, r9
  00018	41 8b d8	 mov	 ebx, r8d
  0001b	41 ff 91 88 01
	00 00		 call	 QWORD PTR [r9+392]
  00022	48 8b c8	 mov	 rcx, rax

; 663  :     if (self != NULL)

  00025	48 85 c0	 test	 rax, rax
  00028	74 10		 je	 SHORT $LN1@new_date_e

; 664  :         set_date_fields(self, year, month, day);

  0002a	44 8b cb	 mov	 r9d, ebx
  0002d	44 8b c7	 mov	 r8d, edi
  00030	8b d6		 mov	 edx, esi
  00032	e8 00 00 00 00	 call	 set_date_fields

; 665  :     return (PyObject *) self;

  00037	48 8b c1	 mov	 rax, rcx
$LN1@new_date_e:

; 666  : }

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi
  00049	c3		 ret	 0
new_date_ex ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$new_datetime_ex DD imagerel new_datetime_ex
	DD	imagerel new_datetime_ex+266
	DD	imagerel $unwind$new_datetime_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_datetime_ex DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0e01a521eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT new_datetime_ex
_TEXT	SEGMENT
year$ = 80
month$ = 88
day$ = 96
hour$ = 104
minute$ = 112
second$ = 120
usecond$ = 128
tzinfo$ = 136
type$ = 144
new_datetime_ex PROC					; COMDAT

; 675  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 676  :     PyDateTime_DateTime *self;
; 677  :     char aware = tzinfo != Py_None;

  0001e	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR tzinfo$[rsp]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002d	44 8b ea	 mov	 r13d, edx
  00030	48 3b f8	 cmp	 rdi, rax

; 678  : 
; 679  :     self = (PyDateTime_DateTime *) (type->tp_alloc(type, aware));

  00033	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0003b	44 8b f1	 mov	 r14d, ecx
  0003e	40 0f 95 c6	 setne	 sil
  00042	48 8b c8	 mov	 rcx, rax
  00045	41 8b e9	 mov	 ebp, r9d
  00048	48 0f be d6	 movsx	 rdx, sil
  0004c	45 8b e0	 mov	 r12d, r8d
  0004f	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00055	48 8b d8	 mov	 rbx, rax

; 680  :     if (self != NULL) {

  00058	48 85 c0	 test	 rax, rax
  0005b	0f 84 8a 00 00
	00		 je	 $LN1@new_dateti

; 681  :         self->hastzinfo = aware;
; 682  :         set_date_fields((PyDateTime_Date *)self, year, month, day);

  00061	45 8b cc	 mov	 r9d, r12d
  00064	45 8b c5	 mov	 r8d, r13d
  00067	41 8b d6	 mov	 edx, r14d
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	40 88 70 68	 mov	 BYTE PTR [rax+104], sil
  00071	e8 00 00 00 00	 call	 set_date_fields

; 683  :         DATE_SET_HOUR(self, hour);

  00076	40 88 69 6d	 mov	 BYTE PTR [rcx+109], bpl

; 684  :         DATE_SET_MINUTE(self, minute);

  0007a	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR minute$[rsp]
  0007f	88 4b 6e	 mov	 BYTE PTR [rbx+110], cl

; 685  :         DATE_SET_SECOND(self, second);

  00082	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR second$[rsp]
  00087	88 4b 6f	 mov	 BYTE PTR [rbx+111], cl

; 686  :         DATE_SET_MICROSECOND(self, usecond);

  0008a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR usecond$[rsp]
  00091	8b c1		 mov	 eax, ecx
  00093	88 4b 72	 mov	 BYTE PTR [rbx+114], cl
  00096	c1 f8 10	 sar	 eax, 16
  00099	88 43 70	 mov	 BYTE PTR [rbx+112], al
  0009c	8b c1		 mov	 eax, ecx
  0009e	c1 f8 08	 sar	 eax, 8
  000a1	88 43 71	 mov	 BYTE PTR [rbx+113], al

; 687  :         if (aware) {

  000a4	40 84 f6	 test	 sil, sil
  000a7	74 3f		 je	 SHORT $LN9@new_dateti

; 688  :             Py_INCREF(tzinfo);

  000a9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ae	85 c0		 test	 eax, eax
  000b0	75 32		 jne	 SHORT $LN6@new_dateti
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c0	4c 8b cf	 mov	 r9, rdi
  000c3	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000c9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d6	85 c0		 test	 eax, eax
  000d8	75 06		 jne	 SHORT $LN5@new_dateti
  000da	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000de	74 04		 je	 SHORT $LN6@new_dateti
$LN5@new_dateti:
  000e0	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN6@new_dateti:

; 689  :             self->tzinfo = tzinfo;

  000e4	48 89 7b 78	 mov	 QWORD PTR [rbx+120], rdi
$LN9@new_dateti:

; 690  :         }
; 691  :     }
; 692  :     return (PyObject *)self;

  000e8	48 8b c3	 mov	 rax, rbx
$LN1@new_dateti:

; 693  : }

  000eb	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f0	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000f5	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000fa	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000ff	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00103	41 5e		 pop	 r14
  00105	41 5d		 pop	 r13
  00107	41 5c		 pop	 r12
  00109	c3		 ret	 0
new_datetime_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$new_time_ex DD imagerel new_time_ex
	DD	imagerel new_time_ex+233
	DD	imagerel $unwind$new_time_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_time_ex DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0e01a521eH
	DD	0c016d018H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT new_time_ex
_TEXT	SEGMENT
hour$ = 80
minute$ = 88
second$ = 96
usecond$ = 104
tzinfo$ = 112
type$ = 120
new_time_ex PROC					; COMDAT

; 703  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 704  :     PyDateTime_Time *self;
; 705  :     char aware = tzinfo != Py_None;

  0001e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR tzinfo$[rsp]
  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002a	44 8b ea	 mov	 r13d, edx
  0002d	48 3b f8	 cmp	 rdi, rax

; 706  : 
; 707  :     self = (PyDateTime_Time *) (type->tp_alloc(type, aware));

  00030	48 8b 44 24 78	 mov	 rax, QWORD PTR type$[rsp]
  00035	44 8b f1	 mov	 r14d, ecx
  00038	40 0f 95 c5	 setne	 bpl
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	41 8b f1	 mov	 esi, r9d
  00042	48 0f be d5	 movsx	 rdx, bpl
  00046	45 8b e0	 mov	 r12d, r8d
  00049	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0004f	48 8b d8	 mov	 rbx, rax

; 708  :     if (self != NULL) {

  00052	48 85 c0	 test	 rax, rax
  00055	74 73		 je	 SHORT $LN1@new_time_e

; 709  :         self->hastzinfo = aware;
; 710  :         self->hashcode = -1;
; 711  :         TIME_SET_HOUR(self, hour);
; 712  :         TIME_SET_MINUTE(self, minute);
; 713  :         TIME_SET_SECOND(self, second);
; 714  :         TIME_SET_MICROSECOND(self, usecond);

  00057	8b ce		 mov	 ecx, esi
  00059	40 88 68 68	 mov	 BYTE PTR [rax+104], bpl
  0005d	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1
  00065	c1 f9 10	 sar	 ecx, 16
  00068	44 88 70 69	 mov	 BYTE PTR [rax+105], r14b
  0006c	44 88 68 6a	 mov	 BYTE PTR [rax+106], r13b
  00070	88 48 6c	 mov	 BYTE PTR [rax+108], cl
  00073	8b ce		 mov	 ecx, esi
  00075	44 88 60 6b	 mov	 BYTE PTR [rax+107], r12b
  00079	c1 f9 08	 sar	 ecx, 8
  0007c	40 88 70 6e	 mov	 BYTE PTR [rax+110], sil
  00080	88 48 6d	 mov	 BYTE PTR [rax+109], cl

; 715  :         if (aware) {

  00083	40 84 ed	 test	 bpl, bpl
  00086	74 42		 je	 SHORT $LN1@new_time_e

; 716  :             Py_INCREF(tzinfo);

  00088	e8 00 00 00 00	 call	 _Py_PXCTX
  0008d	85 c0		 test	 eax, eax
  0008f	75 32		 jne	 SHORT $LN6@new_time_e
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009f	4c 8b cf	 mov	 r9, rdi
  000a2	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a8	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b5	85 c0		 test	 eax, eax
  000b7	75 06		 jne	 SHORT $LN5@new_time_e
  000b9	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000bd	74 04		 je	 SHORT $LN6@new_time_e
$LN5@new_time_e:
  000bf	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN6@new_time_e:

; 717  :             self->tzinfo = tzinfo;

  000c3	48 89 7b 70	 mov	 QWORD PTR [rbx+112], rdi

; 718  :         }
; 719  :     }
; 720  :     return (PyObject *)self;

  000c7	48 8b c3	 mov	 rax, rbx
$LN1@new_time_e:

; 721  : }

  000ca	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000cf	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000d4	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  000d9	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	41 5e		 pop	 r14
  000e4	41 5d		 pop	 r13
  000e6	41 5c		 pop	 r12
  000e8	c3		 ret	 0
new_time_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_delta_ex DD imagerel new_delta_ex
	DD	imagerel new_delta_ex+131
	DD	imagerel $unwind$new_delta_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_delta_ex DD 041401H
	DD	070103214H
	DD	0300e600fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT new_delta_ex
_TEXT	SEGMENT
days$ = 64
seconds$ = 72
microseconds$ = 80
normalize$ = 88
type$ = 96
new_delta_ex PROC					; COMDAT

; 735  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	53		 push	 rbx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f8	 mov	 edi, r8d
  00017	8b f2		 mov	 esi, edx
  00019	8b d9		 mov	 ebx, ecx

; 736  :     PyDateTime_Delta *self;
; 737  : 
; 738  :     if (normalize)

  0001b	45 85 c9	 test	 r9d, r9d
  0001e	74 20		 je	 SHORT $LN3@new_delta_

; 739  :         normalize_d_s_us(&days, &seconds, &microseconds);

  00020	4c 8d 44 24 50	 lea	 r8, QWORD PTR microseconds$[rsp]
  00025	48 8d 54 24 48	 lea	 rdx, QWORD PTR seconds$[rsp]
  0002a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR days$[rsp]
  0002f	e8 00 00 00 00	 call	 normalize_d_s_us
  00034	8b 7c 24 50	 mov	 edi, DWORD PTR microseconds$[rsp]
  00038	8b 74 24 48	 mov	 esi, DWORD PTR seconds$[rsp]
  0003c	8b 5c 24 40	 mov	 ebx, DWORD PTR days$[rsp]
$LN3@new_delta_:

; 740  :     assert(0 <= seconds && seconds < 24*3600);
; 741  :     assert(0 <= microseconds && microseconds < 1000000);
; 742  : 
; 743  :     if (check_delta_day_range(days) < 0)

  00040	8b cb		 mov	 ecx, ebx
  00042	e8 00 00 00 00	 call	 check_delta_day_range
  00047	85 c0		 test	 eax, eax
  00049	79 0a		 jns	 SHORT $LN2@new_delta_

; 744  :         return NULL;

  0004b	33 c0		 xor	 eax, eax

; 752  :     }
; 753  :     return (PyObject *) self;
; 754  : }

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	5e		 pop	 rsi
  00053	5b		 pop	 rbx
  00054	c3		 ret	 0
$LN2@new_delta_:

; 745  : 
; 746  :     self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0005a	33 d2		 xor	 edx, edx
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]

; 747  :     if (self != NULL) {

  00065	48 85 c0	 test	 rax, rax
  00068	74 11		 je	 SHORT $LN1@new_delta_

; 748  :         self->hashcode = -1;

  0006a	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 749  :         SET_TD_DAYS(self, days);

  00072	89 58 68	 mov	 DWORD PTR [rax+104], ebx

; 750  :         SET_TD_SECONDS(self, seconds);

  00075	89 70 6c	 mov	 DWORD PTR [rax+108], esi

; 751  :         SET_TD_MICROSECONDS(self, microseconds);

  00078	89 78 70	 mov	 DWORD PTR [rax+112], edi
$LN1@new_delta_:

; 752  :     }
; 753  :     return (PyObject *) self;
; 754  : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	5e		 pop	 rsi
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
new_delta_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$create_timezone DD imagerel create_timezone
	DD	imagerel create_timezone+210
	DD	imagerel $unwind$create_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create_timezone DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT create_timezone
_TEXT	SEGMENT
offset$ = 64
name$ = 72
create_timezone PROC					; COMDAT

; 778  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f1	 mov	 rsi, rcx
  00012	48 8b da	 mov	 rbx, rdx

; 779  :     PyDateTime_TimeZone *self;
; 780  :     PyTypeObject *type = &PyDateTime_TimeZoneType;
; 781  : 
; 782  :     assert(offset != NULL);
; 783  :     assert(PyDelta_Check(offset));
; 784  :     assert(name == NULL || PyUnicode_Check(name));
; 785  : 
; 786  :     self = (PyDateTime_TimeZone *)(type->tp_alloc(type, 0));

  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeZoneType
  0001c	33 d2		 xor	 edx, edx
  0001e	ff 15 88 01 00
	00		 call	 QWORD PTR PyDateTime_TimeZoneType+392
  00024	48 8b f8	 mov	 rdi, rax

; 787  :     if (self == NULL) {

  00027	48 85 c0	 test	 rax, rax
  0002a	75 10		 jne	 SHORT $LN5@create_tim

; 793  :     self->name = name;
; 794  :     return (PyObject *)self;
; 795  : }

  0002c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00031	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00036	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN5@create_tim:

; 788  :         return NULL;
; 789  :     }
; 790  :     Py_INCREF(offset);

  0003c	e8 00 00 00 00	 call	 _Py_PXCTX
  00041	85 c0		 test	 eax, eax
  00043	75 32		 jne	 SHORT $LN9@create_tim
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00053	4c 8b ce	 mov	 r9, rsi
  00056	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	e8 00 00 00 00	 call	 _PyParallel_Guard
  00069	85 c0		 test	 eax, eax
  0006b	75 06		 jne	 SHORT $LN8@create_tim
  0006d	f6 46 20 20	 test	 BYTE PTR [rsi+32], 32	; 00000020H
  00071	74 04		 je	 SHORT $LN9@create_tim
$LN8@create_tim:
  00073	48 ff 46 50	 inc	 QWORD PTR [rsi+80]
$LN9@create_tim:

; 791  :     self->offset = offset;

  00077	48 89 77 60	 mov	 QWORD PTR [rdi+96], rsi

; 792  :     Py_XINCREF(name);

  0007b	48 85 db	 test	 rbx, rbx
  0007e	74 3b		 je	 SHORT $LN3@create_tim
  00080	e8 00 00 00 00	 call	 _Py_PXCTX
  00085	85 c0		 test	 eax, eax
  00087	75 32		 jne	 SHORT $LN3@create_tim
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00097	4c 8b cb	 mov	 r9, rbx
  0009a	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a8	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ad	85 c0		 test	 eax, eax
  000af	75 06		 jne	 SHORT $LN12@create_tim
  000b1	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b5	74 04		 je	 SHORT $LN3@create_tim
$LN12@create_tim:
  000b7	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN3@create_tim:

; 793  :     self->name = name;
; 794  :     return (PyObject *)self;
; 795  : }

  000bb	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c0	48 89 5f 68	 mov	 QWORD PTR [rdi+104], rbx
  000c4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c9	48 8b c7	 mov	 rax, rdi
  000cc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
create_timezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_tzinfo_subclass DD imagerel check_tzinfo_subclass
	DD	imagerel check_tzinfo_subclass+90
	DD	imagerel $unwind$check_tzinfo_subclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_tzinfo_subclass DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@
CONST	SEGMENT
??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@ DB 'tzinfo arg'
	DB	'ument must be None or of a tzinfo subclass, not type ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT check_tzinfo_subclass
_TEXT	SEGMENT
p$ = 48
check_tzinfo_subclass PROC				; COMDAT

; 837  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 838  :     if (p == Py_None || PyTZInfo_Check(p))

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 3b c8	 cmp	 rcx, rax
  00013	74 3d		 je	 SHORT $LN1@check_tzin
  00015	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TZInfoType
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	74 2d		 je	 SHORT $LN1@check_tzin
  00025	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002a	85 c0		 test	 eax, eax
  0002c	75 24		 jne	 SHORT $LN1@check_tzin

; 840  :     PyErr_Format(PyExc_TypeError,
; 841  :                  "tzinfo argument must be None or of a tzinfo subclass, "
; 842  :                  "not type '%s'",
; 843  :                  Py_TYPE(p)->tp_name);

  0002e	4c 8b 43 58	 mov	 r8, QWORD PTR [rbx+88]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@
  00040	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00044	e8 00 00 00 00	 call	 PyErr_Format

; 844  :     return -1;

  00049	83 c8 ff	 or	 eax, -1

; 845  : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
$LN1@check_tzin:

; 839  :         return 0;

  00052	33 c0		 xor	 eax, eax

; 845  : }

  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
check_tzinfo_subclass ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_tzinfo_member DD imagerel get_tzinfo_member
	DD	imagerel get_tzinfo_member+99
	DD	imagerel $unwind$get_tzinfo_member
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_tzinfo_member DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT get_tzinfo_member
_TEXT	SEGMENT
self$ = 48
get_tzinfo_member PROC					; COMDAT

; 853  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 854  :     PyObject *tzinfo = NULL;
; 855  : 
; 856  :     if (PyDateTime_Check(self) && HASTZINFO(self))

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 09		 je	 SHORT $LN4@get_tzinfo
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	74 10		 je	 SHORT $LN5@get_tzinfo
$LN4@get_tzinfo:
  00022	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00026	74 0a		 je	 SHORT $LN5@get_tzinfo

; 859  :         tzinfo = ((PyDateTime_Time *)self)->tzinfo;
; 860  : 
; 861  :     return tzinfo;

  00028	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 862  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
$LN5@get_tzinfo:

; 857  :         tzinfo = ((PyDateTime_DateTime *)self)->tzinfo;
; 858  :     else if (PyTime_Check(self) && HASTZINFO(self))

  00032	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  0003d	48 3b ca	 cmp	 rcx, rdx
  00040	74 09		 je	 SHORT $LN1@get_tzinfo
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	74 10		 je	 SHORT $LN9@get_tzinfo
$LN1@get_tzinfo:
  0004b	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  0004f	74 0a		 je	 SHORT $LN9@get_tzinfo

; 859  :         tzinfo = ((PyDateTime_Time *)self)->tzinfo;
; 860  : 
; 861  :     return tzinfo;

  00051	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]

; 862  : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5b		 pop	 rbx
  0005a	c3		 ret	 0
$LN9@get_tzinfo:

; 859  :         tzinfo = ((PyDateTime_Time *)self)->tzinfo;
; 860  : 
; 861  :     return tzinfo;

  0005b	33 c0		 xor	 eax, eax

; 862  : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
get_tzinfo_member ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@ ; `string'
PUBLIC	??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@ ; `string'
PUBLIC	??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@ ; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	PyObject_CallMethod:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_tzinfo_method DD imagerel call_tzinfo_method
	DD	imagerel call_tzinfo_method+114
	DD	imagerel $unwind$call_tzinfo_method
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$call_tzinfo_method DD imagerel call_tzinfo_method+114
	DD	imagerel call_tzinfo_method+226
	DD	imagerel $chain$0$call_tzinfo_method
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$call_tzinfo_method DD imagerel call_tzinfo_method+226
	DD	imagerel call_tzinfo_method+301
	DD	imagerel $chain$2$call_tzinfo_method
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$call_tzinfo_method DD imagerel call_tzinfo_method+301
	DD	imagerel call_tzinfo_method+363
	DD	imagerel $chain$4$call_tzinfo_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$call_tzinfo_method DD 020021H
	DD	083400H
	DD	imagerel call_tzinfo_method
	DD	imagerel call_tzinfo_method+114
	DD	imagerel $unwind$call_tzinfo_method
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$call_tzinfo_method DD 020021H
	DD	083400H
	DD	imagerel call_tzinfo_method
	DD	imagerel call_tzinfo_method+114
	DD	imagerel $unwind$call_tzinfo_method
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$call_tzinfo_method DD 020521H
	DD	083405H
	DD	imagerel call_tzinfo_method
	DD	imagerel call_tzinfo_method+114
	DD	imagerel $unwind$call_tzinfo_method
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_tzinfo_method DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@
CONST	SEGMENT
??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@ DB 'offset must'
	DB	' be a timedelta representing a whole number of minutes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@
CONST	SEGMENT
??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@ DB 'offset must'
	DB	' be a timedelta strictly between -timedelta(hours=24) and tim'
	DB	'edelta(hours=24).', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@
CONST	SEGMENT
??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@ DB 't'
	DB	'zinfo.%s() must return None or timedelta, not ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT call_tzinfo_method
_TEXT	SEGMENT
tzinfo$ = 64
name$ = 72
tzinfoarg$ = 80
call_tzinfo_method PROC					; COMDAT

; 873  : {

  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 874  :     PyObject *offset;
; 875  : 
; 876  :     assert(tzinfo != NULL);
; 877  :     assert(PyTZInfo_Check(tzinfo) || tzinfo == Py_None);
; 878  :     assert(tzinfoarg != NULL);
; 879  : 
; 880  :     if (tzinfo == Py_None)

  0000a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 3b ce	 cmp	 rcx, rsi
  00017	75 4f		 jne	 SHORT $LN11@call_tzinf

; 881  :         Py_RETURN_NONE;

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 38		 jne	 SHORT $LN15@call_tzinf
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00030	4c 8b ce	 mov	 r9, rsi
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 09		 jne	 SHORT $LN14@call_tzinf
  0004a	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00051	74 07		 je	 SHORT $LN15@call_tzinf
$LN14@call_tzinf:
  00053	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN15@call_tzinf:
  0005a	48 8b c6	 mov	 rax, rsi

; 911  : }

  0005d	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00062	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN11@call_tzinf:

; 882  :     offset = PyObject_CallMethod(tzinfo, name, "O", tzinfoarg);

  00068	4d 8b c8	 mov	 r9, r8
  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  00072	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00077	e8 00 00 00 00	 call	 PyObject_CallMethod
  0007c	48 8b d8	 mov	 rbx, rax

; 883  :     if (offset == Py_None || offset == NULL)

  0007f	48 3b c6	 cmp	 rax, rsi
  00082	0f 84 d3 00 00
	00		 je	 $LN18@call_tzinf
  00088	48 85 c0	 test	 rax, rax
  0008b	0f 84 ca 00 00
	00		 je	 $LN18@call_tzinf

; 884  :         return offset;
; 885  :     if (PyDelta_Check(offset)) {

  00091	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0009c	48 3b ca	 cmp	 rcx, rdx
  0009f	74 41		 je	 SHORT $LN7@call_tzinf
  000a1	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a6	85 c0		 test	 eax, eax
  000a8	75 38		 jne	 SHORT $LN7@call_tzinf

; 899  :         }
; 900  :     }
; 901  :     else {
; 902  :         Py_DECREF(offset);

  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 _Py_DecRef

; 903  :         PyErr_Format(PyExc_TypeError,
; 904  :                      "tzinfo.%s() must return None or "
; 905  :                      "timedelta, not '%.200s'",
; 906  :                      name, Py_TYPE(offset)->tp_name);

  000b2	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  000b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bd	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@
  000c8	4c 8b c7	 mov	 r8, rdi
  000cb	e8 00 00 00 00	 call	 PyErr_Format
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d5	33 c0		 xor	 eax, eax

; 911  : }

  000d7	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5f		 pop	 rdi
  000e1	c3		 ret	 0
$LN7@call_tzinf:

; 886  :         if (GET_TD_MICROSECONDS(offset) != 0 || GET_TD_SECONDS(offset) % 60 != 0) {

  000e2	83 7b 70 00	 cmp	 DWORD PTR [rbx+112], 0
  000e6	75 56		 jne	 SHORT $LN5@call_tzinf
  000e8	8b 4b 6c	 mov	 ecx, DWORD PTR [rbx+108]
  000eb	b8 89 88 88 88	 mov	 eax, -2004318071	; ffffffff88888889H
  000f0	f7 e9		 imul	 ecx
  000f2	03 d1		 add	 edx, ecx
  000f4	c1 fa 05	 sar	 edx, 5
  000f7	8b c2		 mov	 eax, edx
  000f9	c1 e8 1f	 shr	 eax, 31
  000fc	03 d0		 add	 edx, eax
  000fe	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00101	3b ca		 cmp	 ecx, edx
  00103	75 39		 jne	 SHORT $LN5@call_tzinf

; 891  :         }
; 892  :         if ((GET_TD_DAYS(offset) == -1 && GET_TD_SECONDS(offset) == 0) ||
; 893  :             GET_TD_DAYS(offset) < -1 || GET_TD_DAYS(offset) >= 1) {

  00105	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
  00108	83 f8 ff	 cmp	 eax, -1
  0010b	75 06		 jne	 SHORT $LN19@call_tzinf
  0010d	85 c9		 test	 ecx, ecx
  0010f	74 1c		 je	 SHORT $LN3@call_tzinf
  00111	3b c0		 cmp	 eax, eax
$LN19@call_tzinf:
  00113	7c 18		 jl	 SHORT $LN3@call_tzinf
  00115	83 f8 01	 cmp	 eax, 1
  00118	7d 13		 jge	 SHORT $LN3@call_tzinf

; 907  :         return NULL;
; 908  :     }
; 909  : 
; 910  :     return offset;

  0011a	48 8b c3	 mov	 rax, rbx
  0011d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 911  : }

  00122	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00127	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
$LN3@call_tzinf:

; 894  :             Py_DECREF(offset);

  0012d	48 8b cb	 mov	 rcx, rbx
  00130	e8 00 00 00 00	 call	 _Py_DecRef

; 895  :             PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 896  :                          " strictly between -timedelta(hours=24) and"
; 897  :                          " timedelta(hours=24).");

  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@

; 898  :             return NULL;

  0013c	eb 0f		 jmp	 SHORT $LN21@call_tzinf
$LN5@call_tzinf:

; 887  :             Py_DECREF(offset);

  0013e	48 8b cb	 mov	 rcx, rbx
  00141	e8 00 00 00 00	 call	 _Py_DecRef

; 888  :             PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 889  :                          " representing a whole number of minutes");

  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@
$LN21@call_tzinf:
  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00154	e8 00 00 00 00	 call	 PyErr_Format

; 890  :             return NULL;

  00159	33 c0		 xor	 eax, eax
$LN18@call_tzinf:
  0015b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 911  : }

  00160	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00165	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00169	5f		 pop	 rdi
  0016a	c3		 ret	 0
call_tzinfo_method ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT call_utcoffset
_TEXT	SEGMENT
tzinfo$ = 8
tzinfoarg$ = 16
call_utcoffset PROC					; COMDAT

; 924  :     return call_tzinfo_method(tzinfo, "utcoffset", tzinfoarg);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@

; 925  : }

  0000a	e9 00 00 00 00	 jmp	 call_tzinfo_method
call_utcoffset ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT call_dst
_TEXT	SEGMENT
tzinfo$ = 8
tzinfoarg$ = 16
call_dst PROC						; COMDAT

; 938  :     return call_tzinfo_method(tzinfo, "dst", tzinfoarg);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@

; 939  : }

  0000a	e9 00 00 00 00	 jmp	 call_tzinfo_method
call_dst ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@ ; `string'
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$call_tzname DD imagerel call_tzname
	DD	imagerel call_tzname+219
	DD	imagerel $unwind$call_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_tzname DD 048901H
	DD	083489H
	DD	070025206H
xdata	ENDS
;	COMDAT ??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@
CONST	SEGMENT
??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@ DB 'tzinfo'
	DB	'.tzname() must return None or a string, not ''%s''', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT call_tzname
_TEXT	SEGMENT
tzinfo$ = 64
tzinfoarg$ = 72
call_tzname PROC					; COMDAT

; 949  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 950  :     PyObject *result;
; 951  :     _Py_IDENTIFIER(tzname);
; 952  : 
; 953  :     assert(tzinfo != NULL);
; 954  :     assert(check_tzinfo_subclass(tzinfo) >= 0);
; 955  :     assert(tzinfoarg != NULL);
; 956  : 
; 957  :     if (tzinfo == Py_None)

  00006	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  0000d	4c 8b ca	 mov	 r9, rdx
  00010	4c 8b d1	 mov	 r10, rcx
  00013	48 3b cf	 cmp	 rcx, rdi
  00016	75 4a		 jne	 SHORT $LN4@call_tznam

; 958  :         Py_RETURN_NONE;

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	75 38		 jne	 SHORT $LN8@call_tznam
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002f	4c 8b cf	 mov	 r9, rdi
  00032	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00038	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00040	e8 00 00 00 00	 call	 _PyParallel_Guard
  00045	85 c0		 test	 eax, eax
  00047	75 09		 jne	 SHORT $LN7@call_tznam
  00049	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  00050	74 07		 je	 SHORT $LN8@call_tznam
$LN7@call_tznam:
  00052	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN8@call_tznam:
  00059	48 8b c7	 mov	 rax, rdi

; 974  : }

  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
$LN4@call_tznam:

; 959  : 
; 960  :     result = _PyObject_CallMethodId(tzinfo, &PyId_tzname, "O", tzinfoarg);

  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00068	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00071	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_tzname@?1??call_tzname@@9@9
  00076	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0007a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  00081	49 8b ca	 mov	 rcx, r10
  00084	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00089	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0008e	48 8b d8	 mov	 rbx, rax

; 961  : 
; 962  :     if (result == NULL || result == Py_None)

  00091	48 85 c0	 test	 rax, rax
  00094	74 3a		 je	 SHORT $LN11@call_tznam
  00096	48 3b c7	 cmp	 rax, rdi
  00099	74 35		 je	 SHORT $LN11@call_tznam

; 963  :         return result;
; 964  : 
; 965  :     if (!PyUnicode_Check(result)) {

  0009b	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0009f	41 f7 80 00 01
	00 00 00 00 00
	10		 test	 DWORD PTR [r8+256], 268435456 ; 10000000H
  000aa	75 21		 jne	 SHORT $LN1@call_tznam

; 966  :         PyErr_Format(PyExc_TypeError, "tzinfo.tzname() must "
; 967  :                      "return None or a string, not '%s'",
; 968  :                      Py_TYPE(result)->tp_name);

  000ac	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@
  000be	e8 00 00 00 00	 call	 PyErr_Format

; 969  :         Py_DECREF(result);

  000c3	48 8b cb	 mov	 rcx, rbx
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 970  :         result = NULL;

  000cb	33 db		 xor	 ebx, ebx
$LN1@call_tznam:

; 971  :     }
; 972  : 
; 973  :     return result;

  000cd	48 8b c3	 mov	 rax, rbx
$LN11@call_tznam:
  000d0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 974  : }

  000d5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d9	5f		 pop	 rdi
  000da	c3		 ret	 0
call_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyUnicode_Substring:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$append_keyword_tzinfo DD imagerel append_keyword_tzinfo
	DD	imagerel append_keyword_tzinfo+48
	DD	imagerel $unwind$append_keyword_tzinfo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$append_keyword_tzinfo DD imagerel append_keyword_tzinfo+48
	DD	imagerel append_keyword_tzinfo+95
	DD	imagerel $chain$0$append_keyword_tzinfo
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$append_keyword_tzinfo DD imagerel append_keyword_tzinfo+95
	DD	imagerel append_keyword_tzinfo+143
	DD	imagerel $chain$2$append_keyword_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$append_keyword_tzinfo DD 020021H
	DD	066400H
	DD	imagerel append_keyword_tzinfo
	DD	imagerel append_keyword_tzinfo+48
	DD	imagerel $unwind$append_keyword_tzinfo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$append_keyword_tzinfo DD 020521H
	DD	066405H
	DD	imagerel append_keyword_tzinfo
	DD	imagerel append_keyword_tzinfo+48
	DD	imagerel $unwind$append_keyword_tzinfo
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$append_keyword_tzinfo DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@ DB '%U, tzinfo=%R)', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT append_keyword_tzinfo
_TEXT	SEGMENT
repr$ = 48
tzinfo$ = 56
append_keyword_tzinfo PROC				; COMDAT

; 983  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 984  :     PyObject *temp;
; 985  : 
; 986  :     assert(PyUnicode_Check(repr));
; 987  :     assert(tzinfo);
; 988  :     if (tzinfo == Py_None)

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	48 3b d0	 cmp	 rdx, rax
  0001a	75 0e		 jne	 SHORT $LN2@append_key

; 989  :         return repr;

  0001c	48 8b c1	 mov	 rax, rcx

; 999  : }

  0001f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
$LN2@append_key:

; 990  :     /* Get rid of the trailing ')'. */
; 991  :     assert(PyUnicode_READ_CHAR(repr, PyUnicode_GET_LENGTH(repr)-1) == ')');
; 992  :     temp = PyUnicode_Substring(repr, 0, PyUnicode_GET_LENGTH(repr) - 1);

  0002a	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  0002e	33 d2		 xor	 edx, edx
  00030	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00035	49 ff c8	 dec	 r8
  00038	e8 00 00 00 00	 call	 PyUnicode_Substring

; 993  :     Py_DECREF(repr);

  0003d	48 8b cb	 mov	 rcx, rbx
  00040	48 8b f0	 mov	 rsi, rax
  00043	e8 00 00 00 00	 call	 _Py_DecRef

; 994  :     if (temp == NULL)

  00048	48 85 f6	 test	 rsi, rsi
  0004b	75 12		 jne	 SHORT $LN1@append_key

; 995  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 999  : }

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN1@append_key:

; 996  :     repr = PyUnicode_FromFormat("%U, tzinfo=%R)", temp, tzinfo);

  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@
  00066	4c 8b c7	 mov	 r8, rdi
  00069	48 8b d6	 mov	 rdx, rsi
  0006c	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 997  :     Py_DECREF(temp);

  00071	48 8b ce	 mov	 rcx, rsi
  00074	48 8b d8	 mov	 rbx, rax
  00077	e8 00 00 00 00	 call	 _Py_DecRef
  0007c	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 998  :     return repr;

  00081	48 8b c3	 mov	 rax, rbx

; 999  : }

  00084	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
append_keyword_tzinfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@ ; `string'
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_ctime DD imagerel format_ctime
	DD	imagerel format_ctime+150
	DD	imagerel $unwind$format_ctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_ctime DD 0a1801H
	DD	0e6418H
	DD	0d5418H
	DD	0c3418H
	DD	0d0147218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@
CONST	SEGMENT
??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@ DB '%'
	DB	's %s %2d %02d:%02d:%02d %04d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_ctime
_TEXT	SEGMENT
date$ = 96
hours$ = 104
minutes$ = 112
seconds$ = 120
format_ctime PROC					; COMDAT

; 1007 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1008 :     static const char *DayNames[] = {
; 1009 :         "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"
; 1010 :     };
; 1011 :     static const char *MonthNames[] = {
; 1012 :         "Jan", "Feb", "Mar", "Apr", "May", "Jun",
; 1013 :         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
; 1014 :     };
; 1015 : 
; 1016 :     int wday = weekday(GET_YEAR(date), GET_MONTH(date), GET_DAY(date));

  00018	0f b6 59 69	 movzx	 ebx, BYTE PTR [rcx+105]
  0001c	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00020	0f b6 79 6c	 movzx	 edi, BYTE PTR [rcx+108]
  00024	0f b6 71 6b	 movzx	 esi, BYTE PTR [rcx+107]
  00028	45 8b e0	 mov	 r12d, r8d
  0002b	44 8b ea	 mov	 r13d, edx
  0002e	c1 e3 08	 shl	 ebx, 8
  00031	44 8b c7	 mov	 r8d, edi
  00034	8b d6		 mov	 edx, esi
  00036	0b d8		 or	 ebx, eax
  00038	41 8b e9	 mov	 ebp, r9d
  0003b	8b cb		 mov	 ecx, ebx
  0003d	e8 00 00 00 00	 call	 weekday

; 1017 : 
; 1018 :     return PyUnicode_FromFormat("%s %s %2d %02d:%02d:%02d %04d",
; 1019 :                                 DayNames[wday], MonthNames[GET_MONTH(date)-1],
; 1020 :                                 GET_DAY(date), hours, minutes, seconds,
; 1021 :                                 GET_YEAR(date));

  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00049	89 5c 24 38	 mov	 DWORD PTR [rsp+56], ebx
  0004d	4c 8b 84 f1 f8
	ff ff ff	 mov	 r8, QWORD PTR ?MonthNames@?1??format_ctime@@9@9[rcx+rsi*8-8]
  00055	48 63 d0	 movsxd	 rdx, eax
  00058	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  0005c	48 8b 94 d1 00
	00 00 00	 mov	 rdx, QWORD PTR ?DayNames@?1??format_ctime@@9@9[rcx+rdx*8]
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@
  0006b	44 8b cf	 mov	 r9d, edi
  0006e	44 89 64 24 28	 mov	 DWORD PTR [rsp+40], r12d
  00073	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  00078	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 1022 : }

  0007d	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00082	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00087	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  0008c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00090	41 5d		 pop	 r13
  00092	41 5c		 pop	 r12
  00094	5f		 pop	 rdi
  00095	c3		 ret	 0
format_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@ ; `string'
PUBLIC	??_C@_02NGMLHCAB@?$CF?$CF?$AA@			; `string'
PUBLIC	??_C@_02FCBLNKNB@ss?$AA@			; `string'
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_Zreplacement DD imagerel make_Zreplacement
	DD	imagerel make_Zreplacement+282
	DD	imagerel $unwind$make_Zreplacement
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_Zreplacement DD 084001H
	DD	085440H
	DD	0a640fH
	DD	09340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT ??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@
CONST	SEGMENT
??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@ DB 'tznam'
	DB	'e.replace() did not return a string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02NGMLHCAB@?$CF?$CF?$AA@
CONST	SEGMENT
??_C@_02NGMLHCAB@?$CF?$CF?$AA@ DB '%%', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FCBLNKNB@ss?$AA@
CONST	SEGMENT
??_C@_02FCBLNKNB@ss?$AA@ DB 'ss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT make_Zreplacement
_TEXT	SEGMENT
object$ = 64
tzinfoarg$ = 72
make_Zreplacement PROC					; COMDAT

; 1080 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f2	 mov	 rsi, rdx

; 1081 :     PyObject *temp;
; 1082 :     PyObject *tzinfo = get_tzinfo_member(object);

  00012	e8 00 00 00 00	 call	 get_tzinfo_member

; 1083 :     PyObject *Zreplacement = PyUnicode_FromStringAndSize(NULL, 0);

  00017	33 d2		 xor	 edx, edx
  00019	33 c9		 xor	 ecx, ecx
  0001b	48 8b f8	 mov	 rdi, rax
  0001e	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00023	48 8b d8	 mov	 rbx, rax

; 1084 :     _Py_IDENTIFIER(replace);
; 1085 : 
; 1086 :     if (Zreplacement == NULL)

  00026	48 85 c0	 test	 rax, rax
  00029	75 10		 jne	 SHORT $LN7@make_Zrepl

; 1120 : }

  0002b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00030	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00035	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
$LN7@make_Zrepl:
  0003b	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1087 :         return NULL;
; 1088 :     if (tzinfo == Py_None || tzinfo == NULL)

  00040	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NoneStruct
  00047	48 3b fd	 cmp	 rdi, rbp
  0004a	0f 84 b5 00 00
	00		 je	 $LN10@make_Zrepl
  00050	48 85 ff	 test	 rdi, rdi
  00053	0f 84 ac 00 00
	00		 je	 $LN10@make_Zrepl

; 1089 :         return Zreplacement;
; 1090 : 
; 1091 :     assert(tzinfoarg != NULL);
; 1092 :     temp = call_tzname(tzinfo, tzinfoarg);

  00059	48 8b d6	 mov	 rdx, rsi
  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	e8 00 00 00 00	 call	 call_tzname
  00064	48 8b f8	 mov	 rdi, rax

; 1093 :     if (temp == NULL)

  00067	48 85 c0	 test	 rax, rax
  0006a	0f 84 8b 00 00
	00		 je	 $Error$21058

; 1094 :         goto Error;
; 1095 :     if (temp == Py_None) {

  00070	48 3b c5	 cmp	 rax, rbp
  00073	75 10		 jne	 SHORT $LN3@make_Zrepl

; 1096 :         Py_DECREF(temp);

  00075	48 8b c8	 mov	 rcx, rax
  00078	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@make_Zrepl:

; 1097 :         return Zreplacement;

  0007d	48 8b c3	 mov	 rax, rbx
  00080	e9 80 00 00 00	 jmp	 $LN10@make_Zrepl
$LN3@make_Zrepl:

; 1098 :     }
; 1099 : 
; 1100 :     assert(PyUnicode_Check(temp));
; 1101 :     /* Since the tzname is getting stuffed into the
; 1102 :      * format, we have to double any % signs so that
; 1103 :      * strftime doesn't treat them as format codes.
; 1104 :      */
; 1105 :     Py_DECREF(Zreplacement);

  00085	48 8b cb	 mov	 rcx, rbx
  00088	e8 00 00 00 00	 call	 _Py_DecRef

; 1106 :     Zreplacement = _PyObject_CallMethodId(temp, &PyId_replace, "ss", "%", "%%");

  0008d	44 8b 1d 00 00
	00 00		 mov	 r11d, DWORD PTR _tls_index
  00094	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0009d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_replace@?1??make_Zreplacement@@9@9
  000a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01FGNFDNOH@?$CF?$AA@
  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FCBLNKNB@ss?$AA@
  000b0	4a 03 14 d8	 add	 rdx, QWORD PTR [rax+r11*8]
  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02NGMLHCAB@?$CF?$CF?$AA@
  000bb	48 8b cf	 mov	 rcx, rdi
  000be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c3	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 1107 :     Py_DECREF(temp);

  000c8	48 8b cf	 mov	 rcx, rdi
  000cb	48 8b d8	 mov	 rbx, rax
  000ce	e8 00 00 00 00	 call	 _Py_DecRef

; 1108 :     if (Zreplacement == NULL)

  000d3	48 85 db	 test	 rbx, rbx

; 1109 :         return NULL;

  000d6	74 2b		 je	 SHORT $LN11@make_Zrepl

; 1110 :     if (!PyUnicode_Check(Zreplacement)) {

  000d8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000dc	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  000e6	75 95		 jne	 SHORT $LN1@make_Zrepl

; 1111 :         PyErr_SetString(PyExc_TypeError,
; 1112 :                         "tzname.replace() did not return a string");

  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@
  000f6	e8 00 00 00 00	 call	 PyErr_SetString
$Error$21058:

; 1113 :         goto Error;
; 1114 :     }
; 1115 :     return Zreplacement;
; 1116 : 
; 1117 :   Error:
; 1118 :     Py_DECREF(Zreplacement);

  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@make_Zrepl:

; 1119 :     return NULL;

  00103	33 c0		 xor	 eax, eax
$LN10@make_Zrepl:
  00105	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1120 : }

  0010a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0010f	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00114	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00118	5f		 pop	 rdi
  00119	c3		 ret	 0
make_Zreplacement ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OBKAGHLG@?$CF06d?$AA@			; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_freplacement DD imagerel make_freplacement
	DD	imagerel make_freplacement+185
	DD	imagerel $unwind$make_freplacement
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_freplacement DD 020601H
	DD	07002b206H
xdata	ENDS
;	COMDAT ??_C@_04OBKAGHLG@?$CF06d?$AA@
CONST	SEGMENT
??_C@_04OBKAGHLG@?$CF06d?$AA@ DB '%06d', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT make_freplacement
_TEXT	SEGMENT
freplacement$ = 32
object$ = 112
make_freplacement PROC					; COMDAT

; 1124 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00006	48 8b f9	 mov	 rdi, rcx

; 1125 :     char freplacement[64];
; 1126 :     if (PyTime_Check(object))

  00009	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  00014	48 3b ca	 cmp	 rcx, rdx
  00017	74 4f		 je	 SHORT $LN5@make_frepl
  00019	e8 00 00 00 00	 call	 PyType_IsSubtype
  0001e	85 c0		 test	 eax, eax
  00020	75 46		 jne	 SHORT $LN5@make_frepl

; 1128 :     else if (PyDateTime_Check(object))

  00022	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0002d	48 3b ca	 cmp	 rcx, rdx
  00030	74 20		 je	 SHORT $LN2@make_frepl
  00032	e8 00 00 00 00	 call	 PyType_IsSubtype
  00037	85 c0		 test	 eax, eax
  00039	75 17		 jne	 SHORT $LN2@make_frepl

; 1131 :         sprintf(freplacement, "%06d", 0);

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OBKAGHLG@?$CF06d?$AA@
  00042	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  00050	eb 43		 jmp	 SHORT $LN1@make_frepl
$LN2@make_frepl:

; 1129 :         sprintf(freplacement, "%06d", DATE_GET_MICROSECOND(object));

  00052	0f b6 47 71	 movzx	 eax, BYTE PTR [rdi+113]
  00056	44 0f b6 47 70	 movzx	 r8d, BYTE PTR [rdi+112]
  0005b	41 c1 e0 08	 shl	 r8d, 8
  0005f	44 0b c0	 or	 r8d, eax
  00062	0f b6 47 72	 movzx	 eax, BYTE PTR [rdi+114]

; 1130 :     else

  00066	eb 14		 jmp	 SHORT $LN9@make_frepl
$LN5@make_frepl:

; 1127 :         sprintf(freplacement, "%06d", TIME_GET_MICROSECOND(object));

  00068	0f b6 47 6d	 movzx	 eax, BYTE PTR [rdi+109]
  0006c	44 0f b6 47 6c	 movzx	 r8d, BYTE PTR [rdi+108]
  00071	41 c1 e0 08	 shl	 r8d, 8
  00075	44 0b c0	 or	 r8d, eax
  00078	0f b6 47 6e	 movzx	 eax, BYTE PTR [rdi+110]
$LN9@make_frepl:
  0007c	41 c1 e0 08	 shl	 r8d, 8
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OBKAGHLG@?$CF06d?$AA@
  00087	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  0008c	44 0b c0	 or	 r8d, eax
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
$LN1@make_frepl:

; 1132 : 
; 1133 :     return PyBytes_FromStringAndSize(freplacement, strlen(freplacement));

  00095	48 83 c9 ff	 or	 rcx, -1
  00099	33 c0		 xor	 eax, eax
  0009b	48 8d 7c 24 20	 lea	 rdi, QWORD PTR freplacement$[rsp]
  000a0	f2 ae		 repne scasb
  000a2	48 f7 d1	 not	 rcx
  000a5	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  000a9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  000ae	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1134 : }

  000b3	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
make_freplacement ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_time DD imagerel time_time
	DD	imagerel time_time+60
	DD	imagerel $unwind$time_time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_time DD imagerel time_time+60
	DD	imagerel time_time+95
	DD	imagerel $chain$0$time_time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$time_time DD imagerel time_time+95
	DD	imagerel time_time+101
	DD	imagerel $chain$1$time_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$time_time DD 021H
	DD	imagerel time_time
	DD	imagerel time_time+60
	DD	imagerel $unwind$time_time
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_time DD 020521H
	DD	063405H
	DD	imagerel time_time
	DD	imagerel time_time+60
	DD	imagerel $unwind$time_time
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_time DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_time
_TEXT	SEGMENT
time_time PROC						; COMDAT

; 1317 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1318 :     PyObject *result = NULL;
; 1319 :     PyObject *time = PyImport_ImportModuleNoBlock("time");

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  0000d	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00012	48 8b f8	 mov	 rdi, rax

; 1320 : 
; 1321 :     if (time != NULL) {

  00015	48 85 c0	 test	 rax, rax
  00018	74 45		 je	 SHORT $LN4@time_time

; 1322 :         _Py_IDENTIFIER(time);
; 1323 : 
; 1324 :         result = _PyObject_CallMethodId(time, &PyId_time, "()");

  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00020	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00029	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_time@?2??time_time@@9@9
  0002e	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00039	48 8b cf	 mov	 rcx, rdi
  0003c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00041	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 1325 :         Py_DECREF(time);

  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 8b d8	 mov	 rbx, rax
  0004c	e8 00 00 00 00	 call	 _Py_DecRef

; 1326 :     }
; 1327 :     return result;

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1328 : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN4@time_time:
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
time_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_struct_time DD imagerel build_struct_time
	DD	imagerel build_struct_time+59
	DD	imagerel $unwind$build_struct_time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$build_struct_time DD imagerel build_struct_time+59
	DD	imagerel build_struct_time+207
	DD	imagerel $chain$0$build_struct_time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$build_struct_time DD imagerel build_struct_time+207
	DD	imagerel build_struct_time+229
	DD	imagerel $chain$1$build_struct_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$build_struct_time DD 021H
	DD	imagerel build_struct_time
	DD	imagerel build_struct_time+59
	DD	imagerel $unwind$build_struct_time
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$build_struct_time DD 020821H
	DD	0103408H
	DD	imagerel build_struct_time
	DD	imagerel build_struct_time+59
	DD	imagerel $unwind$build_struct_time
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_struct_time DD 081301H
	DD	0126413H
	DD	0115413H
	DD	0d00fb213H
	DD	0700bc00dH
xdata	ENDS
;	COMDAT ??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@ DB '((iiiiiiiii))', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT build_struct_time
_TEXT	SEGMENT
y$ = 128
m$ = 136
d$ = 144
hh$ = 152
mm$ = 160
ss$ = 168
dstflag$ = 176
build_struct_time PROC					; COMDAT

; 1335 : {

  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	44 8b e1	 mov	 r12d, ecx

; 1336 :     PyObject *time;
; 1337 :     PyObject *result = NULL;
; 1338 : 
; 1339 :     time = PyImport_ImportModuleNoBlock("time");

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  0001d	45 8b e9	 mov	 r13d, r9d
  00020	41 8b f0	 mov	 esi, r8d
  00023	8b ea		 mov	 ebp, edx
  00025	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  0002a	48 8b f8	 mov	 rdi, rax

; 1340 :     if (time != NULL) {

  0002d	48 85 c0	 test	 rax, rax
  00030	0f 84 99 00 00
	00		 je	 $LN1@build_stru

; 1341 :         _Py_IDENTIFIER(struct_time);
; 1342 : 
; 1343 :         result = _PyObject_CallMethodId(time, &PyId_struct_time,
; 1344 :                                         "((iiiiiiiii))",
; 1345 :                                         y, m, d,
; 1346 :                                         hh, mm, ss,
; 1347 :                                         weekday(y, m, d),
; 1348 :                                         days_before_month(y, m) + d,
; 1349 :                                         dstflag);

  00036	8b d5		 mov	 edx, ebp
  00038	41 8b cc	 mov	 ecx, r12d
  0003b	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00043	e8 00 00 00 00	 call	 days_before_month
  00048	44 8b c6	 mov	 r8d, esi
  0004b	8b d5		 mov	 edx, ebp
  0004d	8d 1c 06	 lea	 ebx, DWORD PTR [rsi+rax]
  00050	e8 00 00 00 00	 call	 weekday
  00055	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0005b	44 8b d8	 mov	 r11d, eax
  0005e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00067	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_struct_time@?2??build_struct_time@@9@9
  0006c	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00070	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR dstflag$[rsp]
  00077	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@
  0007e	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00082	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ss$[rsp]
  00089	89 5c 24 50	 mov	 DWORD PTR [rsp+80], ebx
  0008d	44 89 5c 24 48	 mov	 DWORD PTR [rsp+72], r11d
  00092	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00096	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR mm$[rsp]
  0009d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000a1	44 89 6c 24 30	 mov	 DWORD PTR [rsp+48], r13d
  000a6	45 8b cc	 mov	 r9d, r12d
  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	89 74 24 28	 mov	 DWORD PTR [rsp+40], esi
  000b0	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  000b4	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 1350 :         Py_DECREF(time);

  000b9	48 8b cf	 mov	 rcx, rdi
  000bc	48 8b d8	 mov	 rbx, rax
  000bf	e8 00 00 00 00	 call	 _Py_DecRef

; 1351 :     }
; 1352 :     return result;

  000c4	48 8b c3	 mov	 rax, rbx
  000c7	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
$LN1@build_stru:

; 1353 : }

  000cf	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000d4	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  000d8	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  000dc	49 8b e3	 mov	 rsp, r11
  000df	41 5d		 pop	 r13
  000e1	41 5c		 pop	 r12
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
build_struct_time ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$diff_to_bool DD imagerel diff_to_bool
	DD	imagerel diff_to_bool+204
	DD	imagerel $unwind$diff_to_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$diff_to_bool DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT diff_to_bool
_TEXT	SEGMENT
diff$ = 64
op$ = 72
diff_to_bool PROC					; COMDAT

; 1365 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1366 :     PyObject *result;
; 1367 :     int istrue;
; 1368 : 
; 1369 :     switch (op) {

  00006	83 fa 05	 cmp	 edx, 5
  00009	77 4d		 ja	 SHORT $LN1@diff_to_bo
  0000b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  00012	48 63 c2	 movsxd	 rax, edx
  00015	41 8b 94 80 00
	00 00 00	 mov	 edx, DWORD PTR $LN16@diff_to_bo[r8+rax*4]
  0001d	49 03 d0	 add	 rdx, r8
  00020	ff e2		 jmp	 rdx
$LN7@diff_to_bo:

; 1370 :         case Py_EQ: istrue = diff == 0; break;

  00022	33 c0		 xor	 eax, eax
  00024	85 c9		 test	 ecx, ecx
  00026	0f 94 c0	 sete	 al
  00029	eb 2f		 jmp	 SHORT $LN8@diff_to_bo
$LN6@diff_to_bo:

; 1371 :         case Py_NE: istrue = diff != 0; break;

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c9		 test	 ecx, ecx
  0002f	0f 95 c0	 setne	 al
  00032	eb 26		 jmp	 SHORT $LN8@diff_to_bo
$LN5@diff_to_bo:

; 1372 :         case Py_LE: istrue = diff <= 0; break;

  00034	33 c0		 xor	 eax, eax
  00036	85 c9		 test	 ecx, ecx
  00038	0f 9e c0	 setle	 al
  0003b	eb 1d		 jmp	 SHORT $LN8@diff_to_bo
$LN4@diff_to_bo:

; 1373 :         case Py_GE: istrue = diff >= 0; break;

  0003d	33 c0		 xor	 eax, eax
  0003f	85 c9		 test	 ecx, ecx
  00041	0f 99 c0	 setns	 al
  00044	eb 14		 jmp	 SHORT $LN8@diff_to_bo
$LN3@diff_to_bo:

; 1374 :         case Py_LT: istrue = diff < 0; break;

  00046	33 c0		 xor	 eax, eax
  00048	85 c9		 test	 ecx, ecx
  0004a	0f 98 c0	 sets	 al
  0004d	eb 0b		 jmp	 SHORT $LN8@diff_to_bo
$LN2@diff_to_bo:

; 1375 :         case Py_GT: istrue = diff > 0; break;

  0004f	33 c0		 xor	 eax, eax
  00051	85 c9		 test	 ecx, ecx
  00053	0f 9f c0	 setg	 al
  00056	eb 02		 jmp	 SHORT $LN8@diff_to_bo
$LN1@diff_to_bo:

; 1376 :         default:
; 1377 :             assert(! "op unknown");
; 1378 :             istrue = 0; /* To shut up compiler */

  00058	33 c0		 xor	 eax, eax
$LN8@diff_to_bo:

; 1379 :     }
; 1380 :     result = istrue ? Py_True : Py_False;

  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00061	85 c0		 test	 eax, eax
  00063	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  0006a	48 0f 45 d9	 cmovne	 rbx, rcx

; 1381 :     Py_INCREF(result);

  0006e	e8 00 00 00 00	 call	 _Py_PXCTX
  00073	85 c0		 test	 eax, eax
  00075	75 32		 jne	 SHORT $LN17@diff_to_bo
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00085	4c 8b cb	 mov	 r9, rbx
  00088	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0008e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00096	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009b	85 c0		 test	 eax, eax
  0009d	75 06		 jne	 SHORT $LN12@diff_to_bo
  0009f	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000a3	74 04		 je	 SHORT $LN17@diff_to_bo
$LN12@diff_to_bo:
  000a5	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@diff_to_bo:

; 1382 :     return result;

  000a9	48 8b c3	 mov	 rax, rbx

; 1383 : }

  000ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b0	5b		 pop	 rbx
  000b1	c3		 ret	 0
  000b2	66 90		 npad	 2
$LN16@diff_to_bo:
  000b4	00 00 00 00	 DD	 $LN3@diff_to_bo
  000b8	00 00 00 00	 DD	 $LN5@diff_to_bo
  000bc	00 00 00 00	 DD	 $LN7@diff_to_bo
  000c0	00 00 00 00	 DD	 $LN6@diff_to_bo
  000c4	00 00 00 00	 DD	 $LN2@diff_to_bo
  000c8	00 00 00 00	 DD	 $LN4@diff_to_bo
diff_to_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmperror DD imagerel cmperror
	DD	imagerel cmperror+46
	DD	imagerel $unwind$cmperror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmperror DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@ DB 'can''t comp'
	DB	'are %s to %s', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT cmperror
_TEXT	SEGMENT
a$ = 48
b$ = 56
cmperror PROC						; COMDAT

; 1388 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1389 :     PyErr_Format(PyExc_TypeError,
; 1390 :                  "can't compare %s to %s",
; 1391 :                  Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);

  00004	4c 8b 4a 58	 mov	 r9, QWORD PTR [rdx+88]
  00008	4c 8b 41 58	 mov	 r8, QWORD PTR [rcx+88]
  0000c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00013	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  00017	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@
  00022	e8 00 00 00 00	 call	 PyErr_Format

; 1392 :     return NULL;

  00027	33 c0		 xor	 eax, eax

; 1393 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
cmperror ENDP
_TEXT	ENDS
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_to_microseconds DD imagerel delta_to_microseconds
	DD	imagerel delta_to_microseconds+58
	DD	imagerel $unwind$delta_to_microseconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$delta_to_microseconds DD imagerel delta_to_microseconds+58
	DD	imagerel delta_to_microseconds+431
	DD	imagerel $chain$0$delta_to_microseconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$delta_to_microseconds DD imagerel delta_to_microseconds+431
	DD	imagerel delta_to_microseconds+557
	DD	imagerel $chain$1$delta_to_microseconds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$delta_to_microseconds DD 021H
	DD	imagerel delta_to_microseconds
	DD	imagerel delta_to_microseconds+58
	DD	imagerel $unwind$delta_to_microseconds
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$delta_to_microseconds DD 020521H
	DD	085405H
	DD	imagerel delta_to_microseconds
	DD	imagerel delta_to_microseconds+58
	DD	imagerel $unwind$delta_to_microseconds
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_to_microseconds DD 081501H
	DD	0b7415H
	DD	0a6415H
	DD	093415H
	DD	0c0115215H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_to_microseconds
_TEXT	SEGMENT
self$ = 64
delta_to_microseconds PROC				; COMDAT

; 1425 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00015	4c 8b e1	 mov	 r12, rcx

; 1426 :     PyObject *x1 = NULL;
; 1427 :     PyObject *x2 = NULL;
; 1428 :     PyObject *x3 = NULL;
; 1429 :     PyObject *result = NULL;
; 1430 : 
; 1431 :     x1 = PyLong_FromLong(GET_TD_DAYS(self));

  00018	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0001b	33 db		 xor	 ebx, ebx
  0001d	8b fb		 mov	 edi, ebx
  0001f	e8 00 00 00 00	 call	 PyLong_FromLong
  00024	48 8b f0	 mov	 rsi, rax

; 1432 :     if (x1 == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	0f 84 e4 01 00
	00		 je	 $LN58@delta_to_m

; 1433 :         goto Done;
; 1434 :     x2 = PyNumber_Multiply(x1, seconds_per_day);        /* days in seconds */

  00030	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR seconds_per_day
  00037	48 8b c8	 mov	 rcx, rax
  0003a	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0003f	e8 00 00 00 00	 call	 PyNumber_Multiply
  00044	48 8b e8	 mov	 rbp, rax

; 1435 :     if (x2 == NULL)

  00047	48 85 c0	 test	 rax, rax
  0004a	0f 84 86 00 00
	00		 je	 $Done$21335

; 1436 :         goto Done;
; 1437 :     Py_DECREF(x1);

  00050	48 8b ce	 mov	 rcx, rsi
  00053	e8 00 00 00 00	 call	 _Py_DecRef

; 1438 :     x1 = NULL;
; 1439 : 
; 1440 :     /* x2 has days in seconds */
; 1441 :     x1 = PyLong_FromLong(GET_TD_SECONDS(self));         /* seconds */

  00058	41 8b 4c 24 6c	 mov	 ecx, DWORD PTR [r12+108]
  0005d	e8 00 00 00 00	 call	 PyLong_FromLong
  00062	48 8b f0	 mov	 rsi, rax

; 1442 :     if (x1 == NULL)

  00065	48 85 c0	 test	 rax, rax
  00068	0f 84 cd 00 00
	00		 je	 $LN11@delta_to_m

; 1443 :         goto Done;
; 1444 :     x3 = PyNumber_Add(x1, x2);          /* days and seconds in seconds */

  0006e	48 8b d5	 mov	 rdx, rbp
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 PyNumber_Add
  00079	48 8b f8	 mov	 rdi, rax

; 1445 :     if (x3 == NULL)

  0007c	48 85 c0	 test	 rax, rax
  0007f	74 55		 je	 SHORT $Done$21335

; 1446 :         goto Done;
; 1447 :     Py_DECREF(x1);

  00081	48 8b ce	 mov	 rcx, rsi
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 1448 :     Py_DECREF(x2);

  00089	48 8b cd	 mov	 rcx, rbp
  0008c	e8 00 00 00 00	 call	 _Py_DecRef

; 1449 :     /* x1 = */ x2 = NULL;
; 1450 : 
; 1451 :     /* x3 has days+seconds in seconds */
; 1452 :     x1 = PyNumber_Multiply(x3, us_per_second);          /* us */

  00091	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR us_per_second
  00098	48 8b cf	 mov	 rcx, rdi
  0009b	e8 00 00 00 00	 call	 PyNumber_Multiply
  000a0	48 8b f0	 mov	 rsi, rax

; 1453 :     if (x1 == NULL)

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 f9 00 00
	00		 je	 $LN7@delta_to_m

; 1454 :         goto Done;
; 1455 :     Py_DECREF(x3);

  000ac	48 8b cf	 mov	 rcx, rdi
  000af	e8 00 00 00 00	 call	 _Py_DecRef

; 1456 :     x3 = NULL;
; 1457 : 
; 1458 :     /* x1 has days+seconds in us */
; 1459 :     x2 = PyLong_FromLong(GET_TD_MICROSECONDS(self));

  000b4	41 8b 4c 24 70	 mov	 ecx, DWORD PTR [r12+112]
  000b9	8b fb		 mov	 edi, ebx
  000bb	e8 00 00 00 00	 call	 PyLong_FromLong
  000c0	48 8b e8	 mov	 rbp, rax

; 1460 :     if (x2 == NULL)

  000c3	48 85 c0	 test	 rax, rax
  000c6	74 0e		 je	 SHORT $Done$21335

; 1461 :         goto Done;
; 1462 :     result = PyNumber_Add(x1, x2);

  000c8	48 8b d0	 mov	 rdx, rax
  000cb	48 8b ce	 mov	 rcx, rsi
  000ce	e8 00 00 00 00	 call	 PyNumber_Add
  000d3	48 8b d8	 mov	 rbx, rax
$Done$21335:

; 1463 : 
; 1464 : Done:
; 1465 :     Py_XDECREF(x1);

  000d6	e8 00 00 00 00	 call	 _Py_PXCTX
  000db	85 c0		 test	 eax, eax
  000dd	75 5c		 jne	 SHORT $LN11@delta_to_m
  000df	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  000e3	a8 20		 test	 al, 32			; 00000020H
  000e5	75 4c		 jne	 SHORT $LN25@delta_to_m
  000e7	84 c0		 test	 al, al
  000e9	78 48		 js	 SHORT $LN25@delta_to_m
  000eb	a8 02		 test	 al, 2
  000ed	75 4c		 jne	 SHORT $LN11@delta_to_m
  000ef	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  000f3	75 46		 jne	 SHORT $LN11@delta_to_m
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00103	4c 8b ce	 mov	 r9, rsi
  00106	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0010c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00114	e8 00 00 00 00	 call	 _PyParallel_Guard
  00119	48 8b ce	 mov	 rcx, rsi
  0011c	85 c0		 test	 eax, eax
  0011e	74 07		 je	 SHORT $LN30@delta_to_m
  00120	e8 00 00 00 00	 call	 _Px_Dealloc
  00125	eb 14		 jmp	 SHORT $LN11@delta_to_m
$LN30@delta_to_m:
  00127	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0012b	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00131	eb 08		 jmp	 SHORT $LN11@delta_to_m
$LN25@delta_to_m:
  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 Px_DecRef
$LN11@delta_to_m:

; 1466 :     Py_XDECREF(x2);

  0013b	48 85 ed	 test	 rbp, rbp
  0013e	74 65		 je	 SHORT $LN7@delta_to_m
  00140	e8 00 00 00 00	 call	 _Py_PXCTX
  00145	85 c0		 test	 eax, eax
  00147	75 5c		 jne	 SHORT $LN7@delta_to_m
  00149	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  0014d	a8 20		 test	 al, 32			; 00000020H
  0014f	75 4c		 jne	 SHORT $LN36@delta_to_m
  00151	84 c0		 test	 al, al
  00153	78 48		 js	 SHORT $LN36@delta_to_m
  00155	a8 02		 test	 al, 2
  00157	75 4c		 jne	 SHORT $LN7@delta_to_m
  00159	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  0015d	75 46		 jne	 SHORT $LN7@delta_to_m
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0016d	4c 8b cd	 mov	 r9, rbp
  00170	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00176	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00183	48 8b cd	 mov	 rcx, rbp
  00186	85 c0		 test	 eax, eax
  00188	74 07		 je	 SHORT $LN41@delta_to_m
  0018a	e8 00 00 00 00	 call	 _Px_Dealloc
  0018f	eb 14		 jmp	 SHORT $LN7@delta_to_m
$LN41@delta_to_m:
  00191	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00195	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0019b	eb 08		 jmp	 SHORT $LN7@delta_to_m
$LN36@delta_to_m:
  0019d	48 8b cd	 mov	 rcx, rbp
  001a0	e8 00 00 00 00	 call	 Px_DecRef
$LN7@delta_to_m:

; 1467 :     Py_XDECREF(x3);

  001a5	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  001aa	48 85 ff	 test	 rdi, rdi
  001ad	74 65		 je	 SHORT $LN58@delta_to_m
  001af	e8 00 00 00 00	 call	 _Py_PXCTX
  001b4	85 c0		 test	 eax, eax
  001b6	75 5c		 jne	 SHORT $LN58@delta_to_m
  001b8	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  001bc	a8 20		 test	 al, 32			; 00000020H
  001be	75 4c		 jne	 SHORT $LN47@delta_to_m
  001c0	84 c0		 test	 al, al
  001c2	78 48		 js	 SHORT $LN47@delta_to_m
  001c4	a8 02		 test	 al, 2
  001c6	75 4c		 jne	 SHORT $LN58@delta_to_m
  001c8	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  001cc	75 46		 jne	 SHORT $LN58@delta_to_m
  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001dc	4c 8b cf	 mov	 r9, rdi
  001df	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001e5	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001ed	e8 00 00 00 00	 call	 _PyParallel_Guard
  001f2	48 8b cf	 mov	 rcx, rdi
  001f5	85 c0		 test	 eax, eax
  001f7	74 07		 je	 SHORT $LN52@delta_to_m
  001f9	e8 00 00 00 00	 call	 _Px_Dealloc
  001fe	eb 14		 jmp	 SHORT $LN58@delta_to_m
$LN52@delta_to_m:
  00200	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00204	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0020a	eb 08		 jmp	 SHORT $LN58@delta_to_m
$LN47@delta_to_m:
  0020c	48 8b cf	 mov	 rcx, rdi
  0020f	e8 00 00 00 00	 call	 Px_DecRef
$LN58@delta_to_m:

; 1468 :     return result;
; 1469 : }

  00214	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00219	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0021e	48 8b c3	 mov	 rax, rbx
  00221	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00226	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0022a	41 5c		 pop	 r12
  0022c	c3		 ret	 0
delta_to_microseconds ENDP
_TEXT	ENDS
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyNumber_Divmod:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel $unwind$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+44
	DD	imagerel microseconds_to_delta_ex+49
	DD	imagerel $chain$0$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+49
	DD	imagerel microseconds_to_delta_ex+213
	DD	imagerel $chain$1$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+213
	DD	imagerel microseconds_to_delta_ex+268
	DD	imagerel $chain$2$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+268
	DD	imagerel microseconds_to_delta_ex+333
	DD	imagerel $chain$3$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+333
	DD	imagerel microseconds_to_delta_ex+338
	DD	imagerel $chain$4$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+338
	DD	imagerel microseconds_to_delta_ex+453
	DD	imagerel $chain$5$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+453
	DD	imagerel microseconds_to_delta_ex+549
	DD	imagerel $chain$6$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+549
	DD	imagerel microseconds_to_delta_ex+576
	DD	imagerel $chain$8$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+576
	DD	imagerel microseconds_to_delta_ex+589
	DD	imagerel $chain$10$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex+589
	DD	imagerel microseconds_to_delta_ex+601
	DD	imagerel $chain$11$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$microseconds_to_delta_ex DD 021H
	DD	imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel $unwind$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$microseconds_to_delta_ex DD 020021H
	DD	0a3400H
	DD	imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel $unwind$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$microseconds_to_delta_ex DD 020021H
	DD	0a3400H
	DD	imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel $unwind$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$microseconds_to_delta_ex DD 021H
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel microseconds_to_delta_ex+49
	DD	imagerel $chain$0$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$microseconds_to_delta_ex DD 021H
	DD	imagerel microseconds_to_delta_ex+49
	DD	imagerel microseconds_to_delta_ex+213
	DD	imagerel $chain$1$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$microseconds_to_delta_ex DD 021H
	DD	imagerel microseconds_to_delta_ex+213
	DD	imagerel microseconds_to_delta_ex+268
	DD	imagerel $chain$2$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$microseconds_to_delta_ex DD 020521H
	DD	0cc405H
	DD	imagerel microseconds_to_delta_ex+213
	DD	imagerel microseconds_to_delta_ex+268
	DD	imagerel $chain$2$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$microseconds_to_delta_ex DD 020521H
	DD	0b5405H
	DD	imagerel microseconds_to_delta_ex+49
	DD	imagerel microseconds_to_delta_ex+213
	DD	imagerel $chain$1$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$microseconds_to_delta_ex DD 020521H
	DD	0dd405H
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel microseconds_to_delta_ex+49
	DD	imagerel $chain$0$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$microseconds_to_delta_ex DD 020521H
	DD	0a3405H
	DD	imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+44
	DD	imagerel $unwind$microseconds_to_delta_ex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$microseconds_to_delta_ex DD 040901H
	DD	0e0055209H
	DD	060027003H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT microseconds_to_delta_ex
_TEXT	SEGMENT
pyus$ = 80
type$ = 88
microseconds_to_delta_ex PROC				; COMDAT

; 1475 : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	4c 8b f2	 mov	 r14, rdx

; 1476 :     int us;
; 1477 :     int s;
; 1478 :     int d;
; 1479 :     long temp;
; 1480 : 
; 1481 :     PyObject *tuple = NULL;
; 1482 :     PyObject *num = NULL;
; 1483 :     PyObject *result = NULL;
; 1484 : 
; 1485 :     tuple = PyNumber_Divmod(pyus, us_per_second);

  0000c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR us_per_second
  00013	33 ff		 xor	 edi, edi
  00015	e8 00 00 00 00	 call	 PyNumber_Divmod
  0001a	48 8b f0	 mov	 rsi, rax

; 1486 :     if (tuple == NULL)

  0001d	48 85 c0	 test	 rax, rax
  00020	0f 84 27 02 00
	00		 je	 $LN49@microsecon

; 1487 :         goto Done;
; 1488 : 
; 1489 :     num = PyTuple_GetItem(tuple, 1);            /* us */

  00026	8d 57 01	 lea	 edx, QWORD PTR [rdi+1]
  00029	48 8b c8	 mov	 rcx, rax
  0002c	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00031	4c 89 6c 24 68	 mov	 QWORD PTR [rsp+104], r13
  00036	e8 00 00 00 00	 call	 PyTuple_GetItem
  0003b	48 8b d8	 mov	 rbx, rax

; 1490 :     if (num == NULL)

  0003e	48 85 c0	 test	 rax, rax
  00041	0f 84 0b 01 00
	00		 je	 $Done$21388

; 1491 :         goto Done;
; 1492 :     temp = PyLong_AsLong(num);

  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 PyLong_AsLong

; 1493 :     num = NULL;

  0004f	8b df		 mov	 ebx, edi
  00051	44 8b e8	 mov	 r13d, eax

; 1494 :     if (temp == -1 && PyErr_Occurred())

  00054	83 f8 ff	 cmp	 eax, -1
  00057	75 0e		 jne	 SHORT $LN18@microsecon
  00059	e8 00 00 00 00	 call	 PyErr_Occurred
  0005e	48 85 c0	 test	 rax, rax
  00061	0f 85 eb 00 00
	00		 jne	 $Done$21388
$LN18@microsecon:

; 1495 :         goto Done;
; 1496 :     assert(0 <= temp && temp < 1000000);
; 1497 :     us = (int)temp;
; 1498 :     if (us < 0) {

  00067	45 85 ed	 test	 r13d, r13d
  0006a	0f 88 e2 00 00
	00		 js	 $Done$21388

; 1499 :         /* The divisor was positive, so this must be an error. */
; 1500 :         assert(PyErr_Occurred());
; 1501 :         goto Done;
; 1502 :     }
; 1503 : 
; 1504 :     num = PyTuple_GetItem(tuple, 0);            /* leftover seconds */

  00070	33 d2		 xor	 edx, edx
  00072	48 8b ce	 mov	 rcx, rsi
  00075	e8 00 00 00 00	 call	 PyTuple_GetItem
  0007a	48 8b d8	 mov	 rbx, rax

; 1505 :     if (num == NULL)

  0007d	48 85 c0	 test	 rax, rax
  00080	0f 84 cc 00 00
	00		 je	 $Done$21388

; 1506 :         goto Done;
; 1507 :     Py_INCREF(num);

  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 _Py_IncRef

; 1508 :     Py_DECREF(tuple);

  0008e	48 8b ce	 mov	 rcx, rsi
  00091	e8 00 00 00 00	 call	 _Py_DecRef

; 1509 : 
; 1510 :     tuple = PyNumber_Divmod(num, seconds_per_day);

  00096	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR seconds_per_day
  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 PyNumber_Divmod
  000a5	48 8b f0	 mov	 rsi, rax

; 1511 :     if (tuple == NULL)

  000a8	48 85 c0	 test	 rax, rax
  000ab	0f 84 06 01 00
	00		 je	 $LN7@microsecon

; 1512 :         goto Done;
; 1513 :     Py_DECREF(num);

  000b1	48 8b cb	 mov	 rcx, rbx
  000b4	e8 00 00 00 00	 call	 _Py_DecRef

; 1514 : 
; 1515 :     num = PyTuple_GetItem(tuple, 1);            /* seconds */

  000b9	ba 01 00 00 00	 mov	 edx, 1
  000be	48 8b ce	 mov	 rcx, rsi
  000c1	e8 00 00 00 00	 call	 PyTuple_GetItem
  000c6	48 8b d8	 mov	 rbx, rax

; 1516 :     if (num == NULL)

  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 84 80 00 00
	00		 je	 $Done$21388

; 1517 :         goto Done;
; 1518 :     temp = PyLong_AsLong(num);

  000d2	48 8b c8	 mov	 rcx, rax
  000d5	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  000da	e8 00 00 00 00	 call	 PyLong_AsLong

; 1519 :     num = NULL;

  000df	48 8b df	 mov	 rbx, rdi
  000e2	8b e8		 mov	 ebp, eax

; 1520 :     if (temp == -1 && PyErr_Occurred())

  000e4	83 f8 ff	 cmp	 eax, -1
  000e7	75 0a		 jne	 SHORT $LN13@microsecon
  000e9	e8 00 00 00 00	 call	 PyErr_Occurred
  000ee	48 85 c0	 test	 rax, rax
  000f1	75 5a		 jne	 SHORT $LN51@microsecon
$LN13@microsecon:

; 1521 :         goto Done;
; 1522 :     assert(0 <= temp && temp < 24*3600);
; 1523 :     s = (int)temp;
; 1524 : 
; 1525 :     if (s < 0) {

  000f3	85 ed		 test	 ebp, ebp
  000f5	78 56		 js	 SHORT $LN51@microsecon

; 1526 :         /* The divisor was positive, so this must be an error. */
; 1527 :         assert(PyErr_Occurred());
; 1528 :         goto Done;
; 1529 :     }
; 1530 : 
; 1531 :     num = PyTuple_GetItem(tuple, 0);            /* leftover days */

  000f7	33 d2		 xor	 edx, edx
  000f9	48 8b ce	 mov	 rcx, rsi
  000fc	e8 00 00 00 00	 call	 PyTuple_GetItem
  00101	48 8b d8	 mov	 rbx, rax

; 1532 :     if (num == NULL)

  00104	48 85 c0	 test	 rax, rax
  00107	74 44		 je	 SHORT $LN51@microsecon

; 1533 :         goto Done;
; 1534 :     Py_INCREF(num);

  00109	48 8b c8	 mov	 rcx, rax
  0010c	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00111	e8 00 00 00 00	 call	 _Py_IncRef

; 1535 :     temp = PyLong_AsLong(num);

  00116	48 8b cb	 mov	 rcx, rbx
  00119	e8 00 00 00 00	 call	 PyLong_AsLong
  0011e	44 8b e0	 mov	 r12d, eax

; 1536 :     if (temp == -1 && PyErr_Occurred())

  00121	83 f8 ff	 cmp	 eax, -1
  00124	75 0a		 jne	 SHORT $LN10@microsecon
  00126	e8 00 00 00 00	 call	 PyErr_Occurred
  0012b	48 85 c0	 test	 rax, rax
  0012e	75 18		 jne	 SHORT $LN52@microsecon
$LN10@microsecon:

; 1537 :         goto Done;
; 1538 :     d = (int)temp;
; 1539 :     if ((long)d != temp) {
; 1540 :         PyErr_SetString(PyExc_OverflowError, "normalized days too "
; 1541 :                         "large to fit in a C int");
; 1542 :         goto Done;
; 1543 :     }
; 1544 :     result = new_delta_ex(d, s, us, 0, type);

  00130	45 33 c9	 xor	 r9d, r9d
  00133	45 8b c5	 mov	 r8d, r13d
  00136	8b d5		 mov	 edx, ebp
  00138	41 8b cc	 mov	 ecx, r12d
  0013b	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00140	e8 00 00 00 00	 call	 new_delta_ex
  00145	48 8b f8	 mov	 rdi, rax
$LN52@microsecon:
  00148	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
$LN51@microsecon:
  0014d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
$Done$21388:

; 1545 : 
; 1546 : Done:
; 1547 :     Py_XDECREF(tuple);

  00152	e8 00 00 00 00	 call	 _Py_PXCTX
  00157	85 c0		 test	 eax, eax
  00159	75 5c		 jne	 SHORT $LN7@microsecon
  0015b	48 8b 46 20	 mov	 rax, QWORD PTR [rsi+32]
  0015f	a8 20		 test	 al, 32			; 00000020H
  00161	75 4c		 jne	 SHORT $LN27@microsecon
  00163	84 c0		 test	 al, al
  00165	78 48		 js	 SHORT $LN27@microsecon
  00167	a8 02		 test	 al, 2
  00169	75 4c		 jne	 SHORT $LN7@microsecon
  0016b	48 ff 4e 50	 dec	 QWORD PTR [rsi+80]
  0016f	75 46		 jne	 SHORT $LN7@microsecon
  00171	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0017f	4c 8b ce	 mov	 r9, rsi
  00182	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00188	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00190	e8 00 00 00 00	 call	 _PyParallel_Guard
  00195	48 8b ce	 mov	 rcx, rsi
  00198	85 c0		 test	 eax, eax
  0019a	74 07		 je	 SHORT $LN32@microsecon
  0019c	e8 00 00 00 00	 call	 _Px_Dealloc
  001a1	eb 14		 jmp	 SHORT $LN7@microsecon
$LN32@microsecon:
  001a3	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  001a7	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  001ad	eb 08		 jmp	 SHORT $LN7@microsecon
$LN27@microsecon:
  001af	48 8b ce	 mov	 rcx, rsi
  001b2	e8 00 00 00 00	 call	 Px_DecRef
$LN7@microsecon:

; 1548 :     Py_XDECREF(num);

  001b7	4c 8b 6c 24 68	 mov	 r13, QWORD PTR [rsp+104]
  001bc	48 85 db	 test	 rbx, rbx
  001bf	0f 84 83 00 00
	00		 je	 $LN48@microsecon
  001c5	e8 00 00 00 00	 call	 _Py_PXCTX
  001ca	85 c0		 test	 eax, eax
  001cc	75 7a		 jne	 SHORT $LN48@microsecon
  001ce	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  001d2	a8 20		 test	 al, 32			; 00000020H
  001d4	75 6a		 jne	 SHORT $LN38@microsecon
  001d6	84 c0		 test	 al, al
  001d8	78 66		 js	 SHORT $LN38@microsecon
  001da	a8 02		 test	 al, 2
  001dc	75 6a		 jne	 SHORT $LN48@microsecon
  001de	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  001e2	75 64		 jne	 SHORT $LN48@microsecon
  001e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  001eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  001f2	4c 8b cb	 mov	 r9, rbx
  001f5	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  001fb	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00203	e8 00 00 00 00	 call	 _PyParallel_Guard
  00208	48 8b cb	 mov	 rcx, rbx
  0020b	85 c0		 test	 eax, eax
  0020d	74 16		 je	 SHORT $LN43@microsecon
  0020f	e8 00 00 00 00	 call	 _Px_Dealloc
  00214	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1549 :     return result;

  00219	48 8b c7	 mov	 rax, rdi

; 1550 : }

  0021c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00220	41 5e		 pop	 r14
  00222	5f		 pop	 rdi
  00223	5e		 pop	 rsi
  00224	c3		 ret	 0

; 1548 :     Py_XDECREF(num);

$LN43@microsecon:
  00225	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00229	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0022f	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 1549 :     return result;

  00234	48 8b c7	 mov	 rax, rdi

; 1550 : }

  00237	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0023b	41 5e		 pop	 r14
  0023d	5f		 pop	 rdi
  0023e	5e		 pop	 rsi
  0023f	c3		 ret	 0

; 1548 :     Py_XDECREF(num);

$LN38@microsecon:
  00240	48 8b cb	 mov	 rcx, rbx
  00243	e8 00 00 00 00	 call	 Px_DecRef
$LN48@microsecon:
  00248	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN49@microsecon:

; 1549 :     return result;

  0024d	48 8b c7	 mov	 rax, rdi

; 1550 : }

  00250	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00254	41 5e		 pop	 r14
  00256	5f		 pop	 rdi
  00257	5e		 pop	 rsi
  00258	c3		 ret	 0
microseconds_to_delta_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$multiply_int_timedelta DD imagerel multiply_int_timedelta
	DD	imagerel multiply_int_timedelta+109
	DD	imagerel $unwind$multiply_int_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multiply_int_timedelta DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT multiply_int_timedelta
_TEXT	SEGMENT
intobj$ = 48
delta$ = 56
multiply_int_timedelta PROC				; COMDAT

; 1557 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 1558 :     PyObject *pyus_in;
; 1559 :     PyObject *pyus_out;
; 1560 :     PyObject *result;
; 1561 : 
; 1562 :     pyus_in = delta_to_microseconds(delta);

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 delta_to_microseconds
  00015	48 8b d8	 mov	 rbx, rax

; 1563 :     if (pyus_in == NULL)

  00018	48 85 c0	 test	 rax, rax
  0001b	75 0d		 jne	 SHORT $LN2@multiply_i
$LN5@multiply_i:

; 1564 :         return NULL;

  0001d	33 c0		 xor	 eax, eax

; 1574 : }

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
$LN2@multiply_i:

; 1565 : 
; 1566 :     pyus_out = PyNumber_Multiply(pyus_in, intobj);

  0002a	48 8b d7	 mov	 rdx, rdi
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1567 :     Py_DECREF(pyus_in);

  00035	48 8b cb	 mov	 rcx, rbx
  00038	48 8b f8	 mov	 rdi, rax
  0003b	e8 00 00 00 00	 call	 _Py_DecRef

; 1568 :     if (pyus_out == NULL)

  00040	48 85 ff	 test	 rdi, rdi

; 1569 :         return NULL;

  00043	74 d8		 je	 SHORT $LN5@multiply_i

; 1570 : 
; 1571 :     result = microseconds_to_delta(pyus_out);

  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1572 :     Py_DECREF(pyus_out);

  00054	48 8b cf	 mov	 rcx, rdi
  00057	48 8b d8	 mov	 rbx, rax
  0005a	e8 00 00 00 00	 call	 _Py_DecRef

; 1573 :     return result;

  0005f	48 8b c3	 mov	 rax, rbx

; 1574 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	c3		 ret	 0
multiply_int_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$multiply_float_timedelta DD imagerel multiply_float_timedelta
	DD	imagerel multiply_float_timedelta+106
	DD	imagerel $unwind$multiply_float_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$multiply_float_timedelta DD imagerel multiply_float_timedelta+106
	DD	imagerel multiply_float_timedelta+204
	DD	imagerel $chain$0$multiply_float_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$multiply_float_timedelta DD imagerel multiply_float_timedelta+204
	DD	imagerel multiply_float_timedelta+471
	DD	imagerel $chain$1$multiply_float_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$multiply_float_timedelta DD 021H
	DD	imagerel multiply_float_timedelta
	DD	imagerel multiply_float_timedelta+106
	DD	imagerel $unwind$multiply_float_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$multiply_float_timedelta DD 020521H
	DD	086405H
	DD	imagerel multiply_float_timedelta
	DD	imagerel multiply_float_timedelta+106
	DD	imagerel $unwind$multiply_float_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multiply_float_timedelta DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT multiply_float_timedelta
_TEXT	SEGMENT
floatobj$ = 64
delta$ = 72
multiply_float_timedelta PROC				; COMDAT

; 1578 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f9	 mov	 rdi, rcx

; 1579 :     PyObject *result = NULL;
; 1580 :     PyObject *pyus_in = NULL, *temp, *pyus_out;
; 1581 :     PyObject *ratio = NULL;
; 1582 :     _Py_IDENTIFIER(as_integer_ratio);
; 1583 : 
; 1584 :     pyus_in = delta_to_microseconds(delta);

  00012	48 8b ca	 mov	 rcx, rdx
  00015	33 ed		 xor	 ebp, ebp
  00017	e8 00 00 00 00	 call	 delta_to_microseconds
  0001c	48 8b d8	 mov	 rbx, rax

; 1585 :     if (pyus_in == NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	75 10		 jne	 SHORT $LN12@multiply_f

; 1606 : }

  00024	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00029	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0002e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
$LN12@multiply_f:

; 1586 :         return NULL;
; 1587 :     ratio = _PyObject_CallMethodId(floatobj, &PyId_as_integer_ratio, NULL);

  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0003a	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00043	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_as_integer_ratio@?1??multiply_float_timedelta@@9@9
  00048	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0004c	45 33 c0	 xor	 r8d, r8d
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00057	48 8b f8	 mov	 rdi, rax

; 1588 :     if (ratio == NULL)

  0005a	48 85 c0	 test	 rax, rax
  0005d	0f 84 ee 00 00
	00		 je	 $error$21471

; 1589 :         goto error;
; 1590 :     temp = PyNumber_Multiply(pyus_in, PyTuple_GET_ITEM(ratio, 0));

  00063	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00067	48 8b cb	 mov	 rcx, rbx
  0006a	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0006f	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1591 :     Py_DECREF(pyus_in);

  00074	48 8b cb	 mov	 rcx, rbx
  00077	48 8b f0	 mov	 rsi, rax
  0007a	e8 00 00 00 00	 call	 _Py_DecRef

; 1592 :     pyus_in = NULL;
; 1593 :     if (temp == NULL)

  0007f	48 85 f6	 test	 rsi, rsi
  00082	74 36		 je	 SHORT $LN7@multiply_f

; 1594 :         goto error;
; 1595 :     pyus_out = divide_nearest(temp, PyTuple_GET_ITEM(ratio, 1));

  00084	48 8b 57 78	 mov	 rdx, QWORD PTR [rdi+120]
  00088	48 8b ce	 mov	 rcx, rsi
  0008b	e8 00 00 00 00	 call	 divide_nearest

; 1596 :     Py_DECREF(temp);

  00090	48 8b ce	 mov	 rcx, rsi
  00093	48 8b d8	 mov	 rbx, rax
  00096	e8 00 00 00 00	 call	 _Py_DecRef

; 1597 :     if (pyus_out == NULL)

  0009b	48 85 db	 test	 rbx, rbx
  0009e	74 1a		 je	 SHORT $LN7@multiply_f

; 1598 :         goto error;
; 1599 :     result = microseconds_to_delta(pyus_out);

  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1600 :     Py_DECREF(pyus_out);

  000af	48 8b cb	 mov	 rcx, rbx
  000b2	48 8b e8	 mov	 rbp, rax
  000b5	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@multiply_f:

; 1603 :     Py_XDECREF(ratio);

  000ba	e8 00 00 00 00	 call	 _Py_PXCTX
  000bf	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c4	85 c0		 test	 eax, eax
  000c6	0f 85 f8 00 00
	00		 jne	 $LN3@multiply_f
  000cc	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000d0	f6 c1 20	 test	 cl, 32			; 00000020H
  000d3	75 77		 jne	 SHORT $LN30@multiply_f
  000d5	84 c9		 test	 cl, cl
  000d7	78 73		 js	 SHORT $LN30@multiply_f
  000d9	f6 c1 02	 test	 cl, 2
  000dc	0f 85 e2 00 00
	00		 jne	 $LN3@multiply_f
  000e2	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000e6	0f 85 d8 00 00
	00		 jne	 $LN3@multiply_f
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000fa	4c 8b cf	 mov	 r9, rdi
  000fd	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00103	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0010b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00110	48 8b cf	 mov	 rcx, rdi
  00113	85 c0		 test	 eax, eax
  00115	74 18		 je	 SHORT $LN35@multiply_f
$LN38@multiply_f:
  00117	e8 00 00 00 00	 call	 _Px_Dealloc

; 1604 : 
; 1605 :     return result;

  0011c	48 8b c5	 mov	 rax, rbp

; 1606 : }

  0011f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00124	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00129	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012d	5f		 pop	 rdi
  0012e	c3		 ret	 0

; 1603 :     Py_XDECREF(ratio);

$LN35@multiply_f:
  0012f	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00133	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1604 : 
; 1605 :     return result;

  00139	48 8b c5	 mov	 rax, rbp

; 1606 : }

  0013c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00141	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00146	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014a	5f		 pop	 rdi
  0014b	c3		 ret	 0

; 1603 :     Py_XDECREF(ratio);

$LN30@multiply_f:
  0014c	48 8b cf	 mov	 rcx, rdi
  0014f	eb 6e		 jmp	 SHORT $LN37@multiply_f
$error$21471:

; 1601 :  error:
; 1602 :     Py_XDECREF(pyus_in);

  00151	e8 00 00 00 00	 call	 _Py_PXCTX
  00156	85 c0		 test	 eax, eax
  00158	75 6a		 jne	 SHORT $LN3@multiply_f
  0015a	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0015e	a8 20		 test	 al, 32			; 00000020H
  00160	75 5a		 jne	 SHORT $LN19@multiply_f
  00162	84 c0		 test	 al, al
  00164	78 56		 js	 SHORT $LN19@multiply_f
  00166	a8 02		 test	 al, 2
  00168	75 5a		 jne	 SHORT $LN3@multiply_f
  0016a	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0016e	75 54		 jne	 SHORT $LN3@multiply_f
  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0017e	4c 8b cb	 mov	 r9, rbx
  00181	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00187	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00194	48 8b cb	 mov	 rcx, rbx
  00197	85 c0		 test	 eax, eax
  00199	0f 85 78 ff ff
	ff		 jne	 $LN38@multiply_f
  0019f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001a3	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1604 : 
; 1605 :     return result;

  001a9	48 8b c5	 mov	 rax, rbp

; 1606 : }

  001ac	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001b1	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001b6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001ba	5f		 pop	 rdi
  001bb	c3		 ret	 0

; 1601 :  error:
; 1602 :     Py_XDECREF(pyus_in);

$LN19@multiply_f:
  001bc	48 8b cb	 mov	 rcx, rbx
$LN37@multiply_f:
  001bf	e8 00 00 00 00	 call	 Px_DecRef
$LN3@multiply_f:

; 1606 : }

  001c4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001c9	48 8b c5	 mov	 rax, rbp
  001cc	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001d5	5f		 pop	 rdi
  001d6	c3		 ret	 0
multiply_float_timedelta ENDP
_TEXT	ENDS
EXTRN	PyNumber_FloorDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$divide_timedelta_int DD imagerel divide_timedelta_int
	DD	imagerel divide_timedelta_int+106
	DD	imagerel $unwind$divide_timedelta_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_timedelta_int DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT divide_timedelta_int
_TEXT	SEGMENT
delta$ = 48
intobj$ = 56
divide_timedelta_int PROC				; COMDAT

; 1610 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 1611 :     PyObject *pyus_in;
; 1612 :     PyObject *pyus_out;
; 1613 :     PyObject *result;
; 1614 : 
; 1615 :     pyus_in = delta_to_microseconds(delta);

  0000d	e8 00 00 00 00	 call	 delta_to_microseconds
  00012	48 8b d8	 mov	 rbx, rax

; 1616 :     if (pyus_in == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0d		 jne	 SHORT $LN2@divide_tim
$LN5@divide_tim:

; 1617 :         return NULL;

  0001a	33 c0		 xor	 eax, eax

; 1627 : }

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN2@divide_tim:

; 1618 : 
; 1619 :     pyus_out = PyNumber_FloorDivide(pyus_in, intobj);

  00027	48 8b d7	 mov	 rdx, rdi
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 PyNumber_FloorDivide

; 1620 :     Py_DECREF(pyus_in);

  00032	48 8b cb	 mov	 rcx, rbx
  00035	48 8b f8	 mov	 rdi, rax
  00038	e8 00 00 00 00	 call	 _Py_DecRef

; 1621 :     if (pyus_out == NULL)

  0003d	48 85 ff	 test	 rdi, rdi

; 1622 :         return NULL;

  00040	74 d8		 je	 SHORT $LN5@divide_tim

; 1623 : 
; 1624 :     result = microseconds_to_delta(pyus_out);

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1625 :     Py_DECREF(pyus_out);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	48 8b d8	 mov	 rbx, rax
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1626 :     return result;

  0005c	48 8b c3	 mov	 rax, rbx

; 1627 : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
divide_timedelta_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$divide_timedelta_timedelta DD imagerel divide_timedelta_timedelta
	DD	imagerel divide_timedelta_timedelta+40
	DD	imagerel $unwind$divide_timedelta_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$divide_timedelta_timedelta DD imagerel divide_timedelta_timedelta+40
	DD	imagerel divide_timedelta_timedelta+84
	DD	imagerel $chain$0$divide_timedelta_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$divide_timedelta_timedelta DD imagerel divide_timedelta_timedelta+84
	DD	imagerel divide_timedelta_timedelta+130
	DD	imagerel $chain$2$divide_timedelta_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$divide_timedelta_timedelta DD 020021H
	DD	066400H
	DD	imagerel divide_timedelta_timedelta
	DD	imagerel divide_timedelta_timedelta+40
	DD	imagerel $unwind$divide_timedelta_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$divide_timedelta_timedelta DD 020521H
	DD	066405H
	DD	imagerel divide_timedelta_timedelta
	DD	imagerel divide_timedelta_timedelta+40
	DD	imagerel $unwind$divide_timedelta_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_timedelta_timedelta DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT divide_timedelta_timedelta
_TEXT	SEGMENT
left$ = 48
right$ = 56
divide_timedelta_timedelta PROC				; COMDAT

; 1631 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1632 :     PyObject *pyus_left;
; 1633 :     PyObject *pyus_right;
; 1634 :     PyObject *result;
; 1635 : 
; 1636 :     pyus_left = delta_to_microseconds(left);

  0000d	e8 00 00 00 00	 call	 delta_to_microseconds
  00012	48 8b f8	 mov	 rdi, rax

; 1637 :     if (pyus_left == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN2@divide_tim@2

; 1650 : }

  0001a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN2@divide_tim@2:

; 1638 :         return NULL;
; 1639 : 
; 1640 :     pyus_right = delta_to_microseconds(right);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002d	e8 00 00 00 00	 call	 delta_to_microseconds

; 1641 :     if (pyus_right == NULL)     {
; 1642 :         Py_DECREF(pyus_left);

  00032	48 8b cf	 mov	 rcx, rdi
  00035	48 8b f0	 mov	 rsi, rax
  00038	48 85 c0	 test	 rax, rax
  0003b	75 17		 jne	 SHORT $LN1@divide_tim@2
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
  00042	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1643 :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 1650 : }

  00049	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN1@divide_tim@2:

; 1644 :     }
; 1645 : 
; 1646 :     result = PyNumber_FloorDivide(pyus_left, pyus_right);

  00054	48 8b d0	 mov	 rdx, rax
  00057	e8 00 00 00 00	 call	 PyNumber_FloorDivide

; 1647 :     Py_DECREF(pyus_left);

  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	48 8b d8	 mov	 rbx, rax
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 1648 :     Py_DECREF(pyus_right);

  00067	48 8b ce	 mov	 rcx, rsi
  0006a	e8 00 00 00 00	 call	 _Py_DecRef
  0006f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1649 :     return result;

  00074	48 8b c3	 mov	 rax, rbx

; 1650 : }

  00077	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
divide_timedelta_timedelta ENDP
_TEXT	ENDS
EXTRN	PyNumber_TrueDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$truedivide_timedelta_timedelta DD imagerel truedivide_timedelta_timedelta
	DD	imagerel truedivide_timedelta_timedelta+40
	DD	imagerel $unwind$truedivide_timedelta_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$truedivide_timedelta_timedelta DD imagerel truedivide_timedelta_timedelta+40
	DD	imagerel truedivide_timedelta_timedelta+84
	DD	imagerel $chain$0$truedivide_timedelta_timedelta
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$truedivide_timedelta_timedelta DD imagerel truedivide_timedelta_timedelta+84
	DD	imagerel truedivide_timedelta_timedelta+130
	DD	imagerel $chain$2$truedivide_timedelta_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$truedivide_timedelta_timedelta DD 020021H
	DD	066400H
	DD	imagerel truedivide_timedelta_timedelta
	DD	imagerel truedivide_timedelta_timedelta+40
	DD	imagerel $unwind$truedivide_timedelta_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$truedivide_timedelta_timedelta DD 020521H
	DD	066405H
	DD	imagerel truedivide_timedelta_timedelta
	DD	imagerel truedivide_timedelta_timedelta+40
	DD	imagerel $unwind$truedivide_timedelta_timedelta
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_timedelta DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT truedivide_timedelta_timedelta
_TEXT	SEGMENT
left$ = 48
right$ = 56
truedivide_timedelta_timedelta PROC			; COMDAT

; 1654 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 1655 :     PyObject *pyus_left;
; 1656 :     PyObject *pyus_right;
; 1657 :     PyObject *result;
; 1658 : 
; 1659 :     pyus_left = delta_to_microseconds(left);

  0000d	e8 00 00 00 00	 call	 delta_to_microseconds
  00012	48 8b f8	 mov	 rdi, rax

; 1660 :     if (pyus_left == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN2@truedivide

; 1673 : }

  0001a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN2@truedivide:

; 1661 :         return NULL;
; 1662 : 
; 1663 :     pyus_right = delta_to_microseconds(right);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0002d	e8 00 00 00 00	 call	 delta_to_microseconds

; 1664 :     if (pyus_right == NULL)     {
; 1665 :         Py_DECREF(pyus_left);

  00032	48 8b cf	 mov	 rcx, rdi
  00035	48 8b f0	 mov	 rsi, rax
  00038	48 85 c0	 test	 rax, rax
  0003b	75 17		 jne	 SHORT $LN1@truedivide
  0003d	e8 00 00 00 00	 call	 _Py_DecRef
  00042	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1666 :         return NULL;

  00047	33 c0		 xor	 eax, eax

; 1673 : }

  00049	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
$LN1@truedivide:

; 1667 :     }
; 1668 : 
; 1669 :     result = PyNumber_TrueDivide(pyus_left, pyus_right);

  00054	48 8b d0	 mov	 rdx, rax
  00057	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 1670 :     Py_DECREF(pyus_left);

  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	48 8b d8	 mov	 rbx, rax
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 1671 :     Py_DECREF(pyus_right);

  00067	48 8b ce	 mov	 rcx, rsi
  0006a	e8 00 00 00 00	 call	 _Py_DecRef
  0006f	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 1672 :     return result;

  00074	48 8b c3	 mov	 rax, rbx

; 1673 : }

  00077	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
  00081	c3		 ret	 0
truedivide_timedelta_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$truedivide_timedelta_float DD imagerel truedivide_timedelta_float
	DD	imagerel truedivide_timedelta_float+103
	DD	imagerel $unwind$truedivide_timedelta_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$truedivide_timedelta_float DD imagerel truedivide_timedelta_float+103
	DD	imagerel truedivide_timedelta_float+201
	DD	imagerel $chain$0$truedivide_timedelta_float
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$truedivide_timedelta_float DD imagerel truedivide_timedelta_float+201
	DD	imagerel truedivide_timedelta_float+468
	DD	imagerel $chain$1$truedivide_timedelta_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$truedivide_timedelta_float DD 021H
	DD	imagerel truedivide_timedelta_float
	DD	imagerel truedivide_timedelta_float+103
	DD	imagerel $unwind$truedivide_timedelta_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$truedivide_timedelta_float DD 020521H
	DD	086405H
	DD	imagerel truedivide_timedelta_float
	DD	imagerel truedivide_timedelta_float+103
	DD	imagerel $unwind$truedivide_timedelta_float
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_float DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT truedivide_timedelta_float
_TEXT	SEGMENT
delta$ = 64
f$ = 72
truedivide_timedelta_float PROC				; COMDAT

; 1677 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fa	 mov	 rdi, rdx

; 1678 :     PyObject *result = NULL;

  00012	33 ed		 xor	 ebp, ebp

; 1679 :     PyObject *pyus_in = NULL, *temp, *pyus_out;
; 1680 :     PyObject *ratio = NULL;
; 1681 :     _Py_IDENTIFIER(as_integer_ratio);
; 1682 : 
; 1683 :     pyus_in = delta_to_microseconds(delta);

  00014	e8 00 00 00 00	 call	 delta_to_microseconds
  00019	48 8b d8	 mov	 rbx, rax

; 1684 :     if (pyus_in == NULL)

  0001c	48 85 c0	 test	 rax, rax
  0001f	75 10		 jne	 SHORT $LN12@truedivide@2

; 1705 : }

  00021	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00026	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0002b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
$LN12@truedivide@2:

; 1685 :         return NULL;
; 1686 :     ratio = _PyObject_CallMethodId(f, &PyId_as_integer_ratio, NULL);

  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00037	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00040	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_as_integer_ratio@?1??truedivide_timedelta_float@@9@9
  00045	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00049	45 33 c0	 xor	 r8d, r8d
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00054	48 8b f8	 mov	 rdi, rax

; 1687 :     if (ratio == NULL)

  00057	48 85 c0	 test	 rax, rax
  0005a	0f 84 ee 00 00
	00		 je	 $error$21567

; 1688 :         goto error;
; 1689 :     temp = PyNumber_Multiply(pyus_in, PyTuple_GET_ITEM(ratio, 1));

  00060	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00064	48 8b cb	 mov	 rcx, rbx
  00067	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  0006c	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1690 :     Py_DECREF(pyus_in);

  00071	48 8b cb	 mov	 rcx, rbx
  00074	48 8b f0	 mov	 rsi, rax
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 1691 :     pyus_in = NULL;
; 1692 :     if (temp == NULL)

  0007c	48 85 f6	 test	 rsi, rsi
  0007f	74 36		 je	 SHORT $LN7@truedivide@2

; 1693 :         goto error;
; 1694 :     pyus_out = divide_nearest(temp, PyTuple_GET_ITEM(ratio, 0));

  00081	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  00085	48 8b ce	 mov	 rcx, rsi
  00088	e8 00 00 00 00	 call	 divide_nearest

; 1695 :     Py_DECREF(temp);

  0008d	48 8b ce	 mov	 rcx, rsi
  00090	48 8b d8	 mov	 rbx, rax
  00093	e8 00 00 00 00	 call	 _Py_DecRef

; 1696 :     if (pyus_out == NULL)

  00098	48 85 db	 test	 rbx, rbx
  0009b	74 1a		 je	 SHORT $LN7@truedivide@2

; 1697 :         goto error;
; 1698 :     result = microseconds_to_delta(pyus_out);

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1699 :     Py_DECREF(pyus_out);

  000ac	48 8b cb	 mov	 rcx, rbx
  000af	48 8b e8	 mov	 rbp, rax
  000b2	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@truedivide@2:

; 1702 :     Py_XDECREF(ratio);

  000b7	e8 00 00 00 00	 call	 _Py_PXCTX
  000bc	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c1	85 c0		 test	 eax, eax
  000c3	0f 85 f8 00 00
	00		 jne	 $LN3@truedivide@2
  000c9	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000cd	f6 c1 20	 test	 cl, 32			; 00000020H
  000d0	75 77		 jne	 SHORT $LN30@truedivide@2
  000d2	84 c9		 test	 cl, cl
  000d4	78 73		 js	 SHORT $LN30@truedivide@2
  000d6	f6 c1 02	 test	 cl, 2
  000d9	0f 85 e2 00 00
	00		 jne	 $LN3@truedivide@2
  000df	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000e3	0f 85 d8 00 00
	00		 jne	 $LN3@truedivide@2
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000f7	4c 8b cf	 mov	 r9, rdi
  000fa	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00100	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00108	e8 00 00 00 00	 call	 _PyParallel_Guard
  0010d	48 8b cf	 mov	 rcx, rdi
  00110	85 c0		 test	 eax, eax
  00112	74 18		 je	 SHORT $LN35@truedivide@2
$LN38@truedivide@2:
  00114	e8 00 00 00 00	 call	 _Px_Dealloc

; 1703 : 
; 1704 :     return result;

  00119	48 8b c5	 mov	 rax, rbp

; 1705 : }

  0011c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00121	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00126	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012a	5f		 pop	 rdi
  0012b	c3		 ret	 0

; 1702 :     Py_XDECREF(ratio);

$LN35@truedivide@2:
  0012c	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00130	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1703 : 
; 1704 :     return result;

  00136	48 8b c5	 mov	 rax, rbp

; 1705 : }

  00139	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0013e	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00143	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00147	5f		 pop	 rdi
  00148	c3		 ret	 0

; 1702 :     Py_XDECREF(ratio);

$LN30@truedivide@2:
  00149	48 8b cf	 mov	 rcx, rdi
  0014c	eb 6e		 jmp	 SHORT $LN37@truedivide@2
$error$21567:

; 1700 :  error:
; 1701 :     Py_XDECREF(pyus_in);

  0014e	e8 00 00 00 00	 call	 _Py_PXCTX
  00153	85 c0		 test	 eax, eax
  00155	75 6a		 jne	 SHORT $LN3@truedivide@2
  00157	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0015b	a8 20		 test	 al, 32			; 00000020H
  0015d	75 5a		 jne	 SHORT $LN19@truedivide@2
  0015f	84 c0		 test	 al, al
  00161	78 56		 js	 SHORT $LN19@truedivide@2
  00163	a8 02		 test	 al, 2
  00165	75 5a		 jne	 SHORT $LN3@truedivide@2
  00167	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0016b	75 54		 jne	 SHORT $LN3@truedivide@2
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0017b	4c 8b cb	 mov	 r9, rbx
  0017e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00184	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0018c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00191	48 8b cb	 mov	 rcx, rbx
  00194	85 c0		 test	 eax, eax
  00196	0f 85 78 ff ff
	ff		 jne	 $LN38@truedivide@2
  0019c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001a0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1703 : 
; 1704 :     return result;

  001a6	48 8b c5	 mov	 rax, rbp

; 1705 : }

  001a9	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001ae	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001b3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b7	5f		 pop	 rdi
  001b8	c3		 ret	 0

; 1700 :  error:
; 1701 :     Py_XDECREF(pyus_in);

$LN19@truedivide@2:
  001b9	48 8b cb	 mov	 rcx, rbx
$LN37@truedivide@2:
  001bc	e8 00 00 00 00	 call	 Px_DecRef
$LN3@truedivide@2:

; 1705 : }

  001c1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  001c6	48 8b c5	 mov	 rax, rbp
  001c9	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001d2	5f		 pop	 rdi
  001d3	c3		 ret	 0
truedivide_timedelta_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$truedivide_timedelta_int DD imagerel truedivide_timedelta_int
	DD	imagerel truedivide_timedelta_int+106
	DD	imagerel $unwind$truedivide_timedelta_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_int DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT truedivide_timedelta_int
_TEXT	SEGMENT
delta$ = 48
i$ = 56
truedivide_timedelta_int PROC				; COMDAT

; 1709 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 1710 :     PyObject *result;
; 1711 :     PyObject *pyus_in, *pyus_out;
; 1712 :     pyus_in = delta_to_microseconds(delta);

  0000d	e8 00 00 00 00	 call	 delta_to_microseconds
  00012	48 8b d8	 mov	 rbx, rax

; 1713 :     if (pyus_in == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0d		 jne	 SHORT $LN2@truedivide@3
$LN5@truedivide@3:

; 1714 :         return NULL;

  0001a	33 c0		 xor	 eax, eax

; 1723 : }

  0001c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN2@truedivide@3:

; 1715 :     pyus_out = divide_nearest(pyus_in, i);

  00027	48 8b d7	 mov	 rdx, rdi
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 divide_nearest

; 1716 :     Py_DECREF(pyus_in);

  00032	48 8b cb	 mov	 rcx, rbx
  00035	48 8b f8	 mov	 rdi, rax
  00038	e8 00 00 00 00	 call	 _Py_DecRef

; 1717 :     if (pyus_out == NULL)

  0003d	48 85 ff	 test	 rdi, rdi

; 1718 :         return NULL;

  00040	74 d8		 je	 SHORT $LN5@truedivide@3

; 1719 :     result = microseconds_to_delta(pyus_out);

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1720 :     Py_DECREF(pyus_out);

  00051	48 8b cf	 mov	 rcx, rdi
  00054	48 8b d8	 mov	 rbx, rax
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1721 : 
; 1722 :     return result;

  0005c	48 8b c3	 mov	 rax, rbx

; 1723 : }

  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00064	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00068	5f		 pop	 rdi
  00069	c3		 ret	 0
truedivide_timedelta_int ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_add DD imagerel delta_add
	DD	imagerel delta_add+224
	DD	imagerel $unwind$delta_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_add DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_add
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_add PROC						; COMDAT

; 1727 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 1728 :     PyObject *result = Py_NotImplemented;
; 1729 : 
; 1730 :     if (PyDelta_Check(left) && PyDelta_Check(right)) {

  0001d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00021	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  00028	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NotImplementedStruct
  0002f	48 8b fa	 mov	 rdi, rdx
  00032	49 8b dc	 mov	 rbx, r12
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 0c		 je	 SHORT $LN3@delta_add
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN11@delta_add
$LN3@delta_add:
  00046	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0004a	48 3b cd	 cmp	 rcx, rbp
  0004d	74 0c		 je	 SHORT $LN2@delta_add
  0004f	48 8b d5	 mov	 rdx, rbp
  00052	e8 00 00 00 00	 call	 PyType_IsSubtype
  00057	85 c0		 test	 eax, eax
  00059	74 2c		 je	 SHORT $LN11@delta_add
$LN2@delta_add:

; 1731 :         /* delta + delta */
; 1732 :         /* The C-level additions can't overflow because of the
; 1733 :          * invariant bounds.
; 1734 :          */
; 1735 :         int days = GET_TD_DAYS(left) + GET_TD_DAYS(right);

  0005b	8b 4e 68	 mov	 ecx, DWORD PTR [rsi+104]

; 1736 :         int seconds = GET_TD_SECONDS(left) + GET_TD_SECONDS(right);

  0005e	8b 56 6c	 mov	 edx, DWORD PTR [rsi+108]

; 1737 :         int microseconds = GET_TD_MICROSECONDS(left) +
; 1738 :                            GET_TD_MICROSECONDS(right);

  00061	44 8b 46 70	 mov	 r8d, DWORD PTR [rsi+112]
  00065	03 4f 68	 add	 ecx, DWORD PTR [rdi+104]
  00068	03 57 6c	 add	 edx, DWORD PTR [rdi+108]
  0006b	44 03 47 70	 add	 r8d, DWORD PTR [rdi+112]

; 1739 :         result = new_delta(days, seconds, microseconds, 1);

  0006f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00075	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0007a	e8 00 00 00 00	 call	 new_delta_ex
  0007f	48 8b d8	 mov	 rbx, rax

; 1740 :     }
; 1741 : 
; 1742 :     if (result == Py_NotImplemented)

  00082	49 3b c4	 cmp	 rax, r12
  00085	75 3e		 jne	 SHORT $LN8@delta_add
$LN11@delta_add:

; 1743 :         Py_INCREF(result);

  00087	e8 00 00 00 00	 call	 _Py_PXCTX
  0008c	85 c0		 test	 eax, eax
  0008e	75 32		 jne	 SHORT $LN12@delta_add
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009e	4c 8b cb	 mov	 r9, rbx
  000a1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	75 06		 jne	 SHORT $LN7@delta_add
  000b8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bc	74 04		 je	 SHORT $LN12@delta_add
$LN7@delta_add:
  000be	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@delta_add:

; 1744 :     return result;

  000c2	48 8b c3	 mov	 rax, rbx

; 1743 :         Py_INCREF(result);

$LN8@delta_add:

; 1745 : }

  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cf	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	41 5c		 pop	 r12
  000df	c3		 ret	 0
delta_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_negative DD imagerel delta_negative
	DD	imagerel delta_negative+49
	DD	imagerel $unwind$delta_negative
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_negative DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT delta_negative
_TEXT	SEGMENT
self$ = 64
delta_negative PROC					; COMDAT

; 1749 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1750 :     return new_delta(-GET_TD_DAYS(self),
; 1751 :                      -GET_TD_SECONDS(self),
; 1752 :                      -GET_TD_MICROSECONDS(self),
; 1753 :                      1);

  00004	44 8b 41 70	 mov	 r8d, DWORD PTR [rcx+112]
  00008	8b 51 6c	 mov	 edx, DWORD PTR [rcx+108]
  0000b	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00015	f7 d9		 neg	 ecx
  00017	41 f7 d8	 neg	 r8d
  0001a	f7 da		 neg	 edx
  0001c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	e8 00 00 00 00	 call	 new_delta_ex

; 1754 : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
delta_negative ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_positive DD imagerel delta_positive
	DD	imagerel delta_positive+39
	DD	imagerel $unwind$delta_positive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_positive DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT delta_positive
_TEXT	SEGMENT
self$ = 64
delta_positive PROC					; COMDAT

; 1758 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1759 :     /* Could optimize this (by returning self) if this isn't a
; 1760 :      * subclass -- but who uses unary + ?  Approximately nobody.
; 1761 :      */
; 1762 :     return new_delta(GET_TD_DAYS(self),
; 1763 :                      GET_TD_SECONDS(self),
; 1764 :                      GET_TD_MICROSECONDS(self),
; 1765 :                      0);

  00004	44 8b 41 70	 mov	 r8d, DWORD PTR [rcx+112]
  00008	8b 51 6c	 mov	 edx, DWORD PTR [rcx+108]
  0000b	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00015	45 33 c9	 xor	 r9d, r9d
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	e8 00 00 00 00	 call	 new_delta_ex

; 1766 : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
delta_positive ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT delta_abs
_TEXT	SEGMENT
self$ = 8
delta_abs PROC						; COMDAT

; 1771 :     PyObject *result;
; 1772 : 
; 1773 :     assert(GET_TD_MICROSECONDS(self) >= 0);
; 1774 :     assert(GET_TD_SECONDS(self) >= 0);
; 1775 : 
; 1776 :     if (GET_TD_DAYS(self) < 0)

  00000	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00004	7d 05		 jge	 SHORT $LN2@delta_abs

; 1777 :         result = delta_negative(self);
; 1778 :     else
; 1779 :         result = delta_positive(self);
; 1780 : 
; 1781 :     return result;
; 1782 : }

  00006	e9 00 00 00 00	 jmp	 delta_negative
$LN2@delta_abs:
  0000b	e9 00 00 00 00	 jmp	 delta_positive
delta_abs ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_subtract DD imagerel delta_subtract
	DD	imagerel delta_subtract+224
	DD	imagerel $unwind$delta_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_subtract DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_subtract
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_subtract PROC					; COMDAT

; 1786 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 1787 :     PyObject *result = Py_NotImplemented;
; 1788 : 
; 1789 :     if (PyDelta_Check(left) && PyDelta_Check(right)) {

  0001d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00021	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  00028	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NotImplementedStruct
  0002f	48 8b fa	 mov	 rdi, rdx
  00032	49 8b dc	 mov	 rbx, r12
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 0c		 je	 SHORT $LN3@delta_subt
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN11@delta_subt
$LN3@delta_subt:
  00046	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0004a	48 3b cd	 cmp	 rcx, rbp
  0004d	74 0c		 je	 SHORT $LN2@delta_subt
  0004f	48 8b d5	 mov	 rdx, rbp
  00052	e8 00 00 00 00	 call	 PyType_IsSubtype
  00057	85 c0		 test	 eax, eax
  00059	74 2c		 je	 SHORT $LN11@delta_subt
$LN2@delta_subt:

; 1790 :         /* delta - delta */
; 1791 :         /* The C-level additions can't overflow because of the
; 1792 :          * invariant bounds.
; 1793 :          */
; 1794 :         int days = GET_TD_DAYS(left) - GET_TD_DAYS(right);

  0005b	8b 4e 68	 mov	 ecx, DWORD PTR [rsi+104]

; 1795 :         int seconds = GET_TD_SECONDS(left) - GET_TD_SECONDS(right);

  0005e	8b 56 6c	 mov	 edx, DWORD PTR [rsi+108]

; 1796 :         int microseconds = GET_TD_MICROSECONDS(left) -
; 1797 :                            GET_TD_MICROSECONDS(right);

  00061	44 8b 46 70	 mov	 r8d, DWORD PTR [rsi+112]
  00065	2b 4f 68	 sub	 ecx, DWORD PTR [rdi+104]
  00068	2b 57 6c	 sub	 edx, DWORD PTR [rdi+108]
  0006b	44 2b 47 70	 sub	 r8d, DWORD PTR [rdi+112]

; 1798 :         result = new_delta(days, seconds, microseconds, 1);

  0006f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00075	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0007a	e8 00 00 00 00	 call	 new_delta_ex
  0007f	48 8b d8	 mov	 rbx, rax

; 1799 :     }
; 1800 : 
; 1801 :     if (result == Py_NotImplemented)

  00082	49 3b c4	 cmp	 rax, r12
  00085	75 3e		 jne	 SHORT $LN8@delta_subt
$LN11@delta_subt:

; 1802 :         Py_INCREF(result);

  00087	e8 00 00 00 00	 call	 _Py_PXCTX
  0008c	85 c0		 test	 eax, eax
  0008e	75 32		 jne	 SHORT $LN12@delta_subt
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009e	4c 8b cb	 mov	 r9, rbx
  000a1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	75 06		 jne	 SHORT $LN7@delta_subt
  000b8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bc	74 04		 je	 SHORT $LN12@delta_subt
$LN7@delta_subt:
  000be	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN12@delta_subt:

; 1803 :     return result;

  000c2	48 8b c3	 mov	 rax, rbx

; 1802 :         Py_INCREF(result);

$LN8@delta_subt:

; 1804 : }

  000c5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ca	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000cf	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000d4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	41 5c		 pop	 r12
  000df	c3		 ret	 0
delta_subtract ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT delta_cmp
_TEXT	SEGMENT
self$ = 8
other$ = 16
delta_cmp PROC						; COMDAT

; 1809 :     int diff = GET_TD_DAYS(self) - GET_TD_DAYS(other);

  00000	8b 41 68	 mov	 eax, DWORD PTR [rcx+104]
  00003	2b 42 68	 sub	 eax, DWORD PTR [rdx+104]

; 1810 :     if (diff == 0) {

  00006	75 0e		 jne	 SHORT $LN6@delta_cmp

; 1811 :         diff = GET_TD_SECONDS(self) - GET_TD_SECONDS(other);

  00008	8b 41 6c	 mov	 eax, DWORD PTR [rcx+108]
  0000b	2b 42 6c	 sub	 eax, DWORD PTR [rdx+108]

; 1812 :         if (diff == 0)

  0000e	75 06		 jne	 SHORT $LN6@delta_cmp

; 1813 :             diff = GET_TD_MICROSECONDS(self) -
; 1814 :                 GET_TD_MICROSECONDS(other);

  00010	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  00013	2b 42 70	 sub	 eax, DWORD PTR [rdx+112]
$LN6@delta_cmp:

; 1815 :     }
; 1816 :     return diff;
; 1817 : }

  00016	f3 c3		 fatret	 0
delta_cmp ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_richcompare DD imagerel delta_richcompare
	DD	imagerel delta_richcompare+176
	DD	imagerel $unwind$delta_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_richcompare DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
delta_richcompare PROC					; COMDAT

; 1821 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f1	 mov	 rsi, rcx

; 1822 :     if (PyDelta_Check(other)) {

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00020	41 8b f8	 mov	 edi, r8d
  00023	48 3b ca	 cmp	 rcx, rdx
  00026	74 65		 je	 SHORT $LN2@delta_rich
  00028	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002d	85 c0		 test	 eax, eax
  0002f	75 5c		 jne	 SHORT $LN2@delta_rich

; 1825 :     }
; 1826 :     else {
; 1827 :         Py_RETURN_NOTIMPLEMENTED;

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	75 3c		 jne	 SHORT $LN7@delta_rich
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00055	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	85 c0		 test	 eax, eax
  00064	75 09		 jne	 SHORT $LN6@delta_rich
  00066	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0006d	74 07		 je	 SHORT $LN7@delta_rich
$LN6@delta_rich:
  0006f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@delta_rich:
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1828 :     }
; 1829 : }

  0007d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN2@delta_rich:

; 1823 :         int diff = delta_cmp(self, other);

  0008d	48 8b d3	 mov	 rdx, rbx
  00090	48 8b ce	 mov	 rcx, rsi
  00093	e8 00 00 00 00	 call	 delta_cmp

; 1824 :         return diff_to_bool(diff, op);

  00098	8b d7		 mov	 edx, edi
  0009a	8b c8		 mov	 ecx, eax

; 1828 :     }
; 1829 : }

  0009c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	e9 00 00 00 00	 jmp	 diff_to_bool
delta_richcompare ENDP
_TEXT	ENDS
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_multiply DD imagerel delta_multiply
	DD	imagerel delta_multiply+271
	DD	imagerel $unwind$delta_multiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_multiply DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_multiply
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_multiply PROC					; COMDAT

; 1848 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 1849 :     PyObject *result = Py_NotImplemented;
; 1850 : 
; 1851 :     if (PyDelta_Check(left)) {

  00017	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00025	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NotImplementedStruct
  0002c	48 8b dd	 mov	 rbx, rbp
  0002f	48 3b ca	 cmp	 rcx, rdx
  00032	74 43		 je	 SHORT $LN11@delta_mult
  00034	e8 00 00 00 00	 call	 PyType_IsSubtype
  00039	85 c0		 test	 eax, eax
  0003b	75 3a		 jne	 SHORT $LN11@delta_mult

; 1859 :     }
; 1860 :     else if (PyLong_Check(left))

  0003d	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00041	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  0004b	74 0d		 je	 SHORT $LN5@delta_mult

; 1861 :         result = multiply_int_timedelta(left,
; 1862 :                         (PyDateTime_Delta *) right);

  0004d	48 8b d6	 mov	 rdx, rsi
  00050	48 8b cf	 mov	 rcx, rdi
  00053	e8 00 00 00 00	 call	 multiply_int_timedelta
  00058	eb 5a		 jmp	 SHORT $LN23@delta_mult
$LN5@delta_mult:

; 1863 :     else if (PyFloat_Check(left))

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00061	48 3b ca	 cmp	 rcx, rdx
  00064	74 09		 je	 SHORT $LN2@delta_mult
  00066	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006b	85 c0		 test	 eax, eax
  0006d	74 4d		 je	 SHORT $LN19@delta_mult
$LN2@delta_mult:

; 1864 :         result = multiply_float_timedelta(left,
; 1865 :                         (PyDateTime_Delta *) right);

  0006f	48 8b d6	 mov	 rdx, rsi
  00072	48 8b cf	 mov	 rcx, rdi
  00075	eb 38		 jmp	 SHORT $LN24@delta_mult
$LN11@delta_mult:

; 1852 :         /* delta * ??? */
; 1853 :         if (PyLong_Check(right))

  00077	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0007b	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00085	74 0d		 je	 SHORT $LN10@delta_mult

; 1854 :             result = multiply_int_timedelta(right,
; 1855 :                             (PyDateTime_Delta *) left);

  00087	48 8b d7	 mov	 rdx, rdi
  0008a	48 8b ce	 mov	 rcx, rsi
  0008d	e8 00 00 00 00	 call	 multiply_int_timedelta
  00092	eb 20		 jmp	 SHORT $LN23@delta_mult
$LN10@delta_mult:

; 1856 :         else if (PyFloat_Check(right))

  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0009b	48 3b ca	 cmp	 rcx, rdx
  0009e	74 09		 je	 SHORT $LN7@delta_mult
  000a0	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a5	85 c0		 test	 eax, eax
  000a7	74 13		 je	 SHORT $LN19@delta_mult
$LN7@delta_mult:

; 1857 :             result = multiply_float_timedelta(right,
; 1858 :                             (PyDateTime_Delta *) left);

  000a9	48 8b d7	 mov	 rdx, rdi
  000ac	48 8b ce	 mov	 rcx, rsi
$LN24@delta_mult:
  000af	e8 00 00 00 00	 call	 multiply_float_timedelta
$LN23@delta_mult:
  000b4	48 8b d8	 mov	 rbx, rax

; 1866 : 
; 1867 :     if (result == Py_NotImplemented)

  000b7	48 3b c5	 cmp	 rax, rbp
  000ba	75 3b		 jne	 SHORT $LN22@delta_mult
$LN19@delta_mult:

; 1868 :         Py_INCREF(result);

  000bc	e8 00 00 00 00	 call	 _Py_PXCTX
  000c1	85 c0		 test	 eax, eax
  000c3	75 32		 jne	 SHORT $LN22@delta_mult
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000d3	4c 8b cb	 mov	 r9, rbx
  000d6	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000dc	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000e9	85 c0		 test	 eax, eax
  000eb	75 06		 jne	 SHORT $LN15@delta_mult
  000ed	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000f1	74 04		 je	 SHORT $LN22@delta_mult
$LN15@delta_mult:
  000f3	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN22@delta_mult:

; 1869 :     return result;
; 1870 : }

  000f7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000fc	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00101	48 8b c3	 mov	 rax, rbx
  00104	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00109	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
delta_multiply ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_divide DD imagerel delta_divide
	DD	imagerel delta_divide+224
	DD	imagerel $unwind$delta_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_divide DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_divide
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_divide PROC					; COMDAT

; 1874 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 1875 :     PyObject *result = Py_NotImplemented;
; 1876 : 
; 1877 :     if (PyDelta_Check(left)) {

  0001d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00021	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  00028	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NotImplementedStruct
  0002f	48 8b fa	 mov	 rdi, rdx
  00032	49 8b dc	 mov	 rbx, r12
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 0c		 je	 SHORT $LN6@delta_divi
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	74 41		 je	 SHORT $LN14@delta_divi
$LN6@delta_divi:

; 1878 :         /* delta * ??? */
; 1879 :         if (PyLong_Check(right))

  00046	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0004a	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00054	74 0d		 je	 SHORT $LN5@delta_divi

; 1880 :             result = divide_timedelta_int(
; 1881 :                             (PyDateTime_Delta *)left,
; 1882 :                             right);

  00056	48 8b d7	 mov	 rdx, rdi
  00059	48 8b ce	 mov	 rcx, rsi
  0005c	e8 00 00 00 00	 call	 divide_timedelta_int
  00061	eb 1c		 jmp	 SHORT $LN18@delta_divi
$LN5@delta_divi:

; 1883 :         else if (PyDelta_Check(right))

  00063	48 3b cd	 cmp	 rcx, rbp
  00066	74 0c		 je	 SHORT $LN2@delta_divi
  00068	48 8b d5	 mov	 rdx, rbp
  0006b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00070	85 c0		 test	 eax, eax
  00072	74 13		 je	 SHORT $LN14@delta_divi
$LN2@delta_divi:

; 1884 :             result = divide_timedelta_timedelta(
; 1885 :                             (PyDateTime_Delta *)left,
; 1886 :                             (PyDateTime_Delta *)right);

  00074	48 8b d7	 mov	 rdx, rdi
  00077	48 8b ce	 mov	 rcx, rsi
  0007a	e8 00 00 00 00	 call	 divide_timedelta_timedelta
$LN18@delta_divi:
  0007f	48 8b d8	 mov	 rbx, rax

; 1887 :     }
; 1888 : 
; 1889 :     if (result == Py_NotImplemented)

  00082	49 3b c4	 cmp	 rax, r12
  00085	75 3b		 jne	 SHORT $LN17@delta_divi
$LN14@delta_divi:

; 1890 :         Py_INCREF(result);

  00087	e8 00 00 00 00	 call	 _Py_PXCTX
  0008c	85 c0		 test	 eax, eax
  0008e	75 32		 jne	 SHORT $LN17@delta_divi
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0009e	4c 8b cb	 mov	 r9, rbx
  000a1	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a7	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000af	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b4	85 c0		 test	 eax, eax
  000b6	75 06		 jne	 SHORT $LN10@delta_divi
  000b8	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000bc	74 04		 je	 SHORT $LN17@delta_divi
$LN10@delta_divi:
  000be	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN17@delta_divi:

; 1891 :     return result;
; 1892 : }

  000c2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000c7	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000cc	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d1	48 8b c3	 mov	 rax, rbx
  000d4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	41 5c		 pop	 r12
  000df	c3		 ret	 0
delta_divide ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_truedivide DD imagerel delta_truedivide
	DD	imagerel delta_truedivide+266
	DD	imagerel $unwind$delta_truedivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_truedivide DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_truedivide
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_truedivide PROC					; COMDAT

; 1896 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b f1	 mov	 rsi, rcx

; 1897 :     PyObject *result = Py_NotImplemented;
; 1898 : 
; 1899 :     if (PyDelta_Check(left)) {

  0001d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00021	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  00028	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NotImplementedStruct
  0002f	48 8b fa	 mov	 rdi, rdx
  00032	49 8b dc	 mov	 rbx, r12
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 0c		 je	 SHORT $LN9@delta_true
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	74 6b		 je	 SHORT $LN17@delta_true
$LN9@delta_true:

; 1900 :         if (PyDelta_Check(right))

  00046	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0004a	48 3b cd	 cmp	 rcx, rbp
  0004d	74 4f		 je	 SHORT $LN7@delta_true
  0004f	48 8b d5	 mov	 rdx, rbp
  00052	e8 00 00 00 00	 call	 PyType_IsSubtype
  00057	85 c0		 test	 eax, eax
  00059	75 43		 jne	 SHORT $LN7@delta_true

; 1904 :         else if (PyFloat_Check(right))

  0005b	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00066	48 3b ca	 cmp	 rcx, rdx
  00069	74 26		 je	 SHORT $LN4@delta_true
  0006b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00070	85 c0		 test	 eax, eax
  00072	75 1d		 jne	 SHORT $LN4@delta_true

; 1907 :         else if (PyLong_Check(right))

  00074	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00078	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  00082	74 2d		 je	 SHORT $LN17@delta_true

; 1908 :             result = truedivide_timedelta_int(
; 1909 :                             (PyDateTime_Delta *)left, right);

  00084	48 8b d7	 mov	 rdx, rdi
  00087	48 8b ce	 mov	 rcx, rsi
  0008a	e8 00 00 00 00	 call	 truedivide_timedelta_int
  0008f	eb 18		 jmp	 SHORT $LN21@delta_true
$LN4@delta_true:

; 1905 :             result = truedivide_timedelta_float(
; 1906 :                             (PyDateTime_Delta *)left, right);

  00091	48 8b d7	 mov	 rdx, rdi
  00094	48 8b ce	 mov	 rcx, rsi
  00097	e8 00 00 00 00	 call	 truedivide_timedelta_float
  0009c	eb 0b		 jmp	 SHORT $LN21@delta_true
$LN7@delta_true:

; 1901 :             result = truedivide_timedelta_timedelta(
; 1902 :                             (PyDateTime_Delta *)left,
; 1903 :                             (PyDateTime_Delta *)right);

  0009e	48 8b d7	 mov	 rdx, rdi
  000a1	48 8b ce	 mov	 rcx, rsi
  000a4	e8 00 00 00 00	 call	 truedivide_timedelta_timedelta
$LN21@delta_true:
  000a9	48 8b d8	 mov	 rbx, rax

; 1910 :     }
; 1911 : 
; 1912 :     if (result == Py_NotImplemented)

  000ac	49 3b c4	 cmp	 rax, r12
  000af	75 3b		 jne	 SHORT $LN20@delta_true
$LN17@delta_true:

; 1913 :         Py_INCREF(result);

  000b1	e8 00 00 00 00	 call	 _Py_PXCTX
  000b6	85 c0		 test	 eax, eax
  000b8	75 32		 jne	 SHORT $LN20@delta_true
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000c8	4c 8b cb	 mov	 r9, rbx
  000cb	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000d1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	75 06		 jne	 SHORT $LN13@delta_true
  000e2	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000e6	74 04		 je	 SHORT $LN20@delta_true
$LN13@delta_true:
  000e8	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN20@delta_true:

; 1914 :     return result;
; 1915 : }

  000ec	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f1	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000f6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000fb	48 8b c3	 mov	 rax, rbx
  000fe	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00103	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00107	41 5c		 pop	 r12
  00109	c3		 ret	 0
delta_truedivide ENDP
_TEXT	ENDS
EXTRN	PyNumber_Remainder:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_remainder DD imagerel delta_remainder
	DD	imagerel delta_remainder+307
	DD	imagerel $unwind$delta_remainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_remainder DD 08e401H
	DD	0864e4H
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_remainder
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_remainder PROC					; COMDAT

; 1919 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1920 :     PyObject *pyus_left;
; 1921 :     PyObject *pyus_right;
; 1922 :     PyObject *pyus_remainder;
; 1923 :     PyObject *remainder;
; 1924 : 
; 1925 :     if (!PyDelta_Check(left) || !PyDelta_Check(right))

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	48 3b cd	 cmp	 rcx, rbp
  00023	74 0c		 je	 SHORT $LN5@delta_rema
  00025	48 8b d5	 mov	 rdx, rbp
  00028	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN6@delta_rema
$LN5@delta_rema:
  00031	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 68		 je	 SHORT $LN7@delta_rema
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	75 5c		 jne	 SHORT $LN7@delta_rema
$LN6@delta_rema:

; 1926 :         Py_RETURN_NOTIMPLEMENTED;

  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 3c		 jne	 SHORT $LN11@delta_rema
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00064	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00072	e8 00 00 00 00	 call	 _PyParallel_Guard
  00077	85 c0		 test	 eax, eax
  00079	75 09		 jne	 SHORT $LN10@delta_rema
  0007b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00082	74 07		 je	 SHORT $LN11@delta_rema
$LN10@delta_rema:
  00084	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN11@delta_rema:
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1947 :         return NULL;
; 1948 : 
; 1949 :     return remainder;
; 1950 : }

  00092	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00097	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
$LN7@delta_rema:

; 1927 : 
; 1928 :     pyus_left = delta_to_microseconds((PyDateTime_Delta *)left);

  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	e8 00 00 00 00	 call	 delta_to_microseconds
  000aa	48 8b d8	 mov	 rbx, rax

; 1929 :     if (pyus_left == NULL)

  000ad	48 85 c0	 test	 rax, rax

; 1930 :         return NULL;

  000b0	74 18		 je	 SHORT $LN15@delta_rema

; 1931 : 
; 1932 :     pyus_right = delta_to_microseconds((PyDateTime_Delta *)right);

  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	e8 00 00 00 00	 call	 delta_to_microseconds

; 1933 :     if (pyus_right == NULL) {
; 1934 :         Py_DECREF(pyus_left);

  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	48 8b f8	 mov	 rdi, rax
  000c0	48 85 c0	 test	 rax, rax
  000c3	75 17		 jne	 SHORT $LN3@delta_rema
  000c5	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@delta_rema:

; 1935 :         return NULL;

  000ca	33 c0		 xor	 eax, eax

; 1947 :         return NULL;
; 1948 : 
; 1949 :     return remainder;
; 1950 : }

  000cc	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d1	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000d6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
$LN3@delta_rema:

; 1936 :     }
; 1937 : 
; 1938 :     pyus_remainder = PyNumber_Remainder(pyus_left, pyus_right);

  000dc	48 8b d0	 mov	 rdx, rax
  000df	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000e4	e8 00 00 00 00	 call	 PyNumber_Remainder

; 1939 :     Py_DECREF(pyus_left);

  000e9	48 8b cb	 mov	 rcx, rbx
  000ec	48 8b f0	 mov	 rsi, rax
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 1940 :     Py_DECREF(pyus_right);

  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 _Py_DecRef

; 1941 :     if (pyus_remainder == NULL)

  000fc	48 85 f6	 test	 rsi, rsi
  000ff	75 04		 jne	 SHORT $LN2@delta_rema

; 1942 :         return NULL;

  00101	33 c0		 xor	 eax, eax
  00103	eb 19		 jmp	 SHORT $LN14@delta_rema
$LN2@delta_rema:

; 1943 : 
; 1944 :     remainder = microseconds_to_delta(pyus_remainder);

  00105	48 8b d5	 mov	 rdx, rbp
  00108	48 8b ce	 mov	 rcx, rsi
  0010b	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 1945 :     Py_DECREF(pyus_remainder);

  00110	48 8b ce	 mov	 rcx, rsi
  00113	48 8b d8	 mov	 rbx, rax
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 1946 :     if (remainder == NULL)

  0011b	48 8b c3	 mov	 rax, rbx
$LN14@delta_rema:

; 1947 :         return NULL;
; 1948 : 
; 1949 :     return remainder;
; 1950 : }

  0011e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00123	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00128	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0012d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
delta_remainder ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$delta_divmod DD imagerel delta_divmod
	DD	imagerel delta_divmod+342
	DD	imagerel $unwind$delta_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_divmod DD 08ca01H
	DD	0864caH
	DD	0a540fH
	DD	09340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT delta_divmod
_TEXT	SEGMENT
left$ = 64
right$ = 72
delta_divmod PROC					; COMDAT

; 1954 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 1955 :     PyObject *pyus_left;
; 1956 :     PyObject *pyus_right;
; 1957 :     PyObject *divmod;
; 1958 :     PyObject *delta;
; 1959 :     PyObject *result;
; 1960 : 
; 1961 :     if (!PyDelta_Check(left) || !PyDelta_Check(right))

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:PyDateTime_DeltaType
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	48 3b cd	 cmp	 rcx, rbp
  00023	74 0c		 je	 SHORT $LN5@delta_divm
  00025	48 8b d5	 mov	 rdx, rbp
  00028	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002d	85 c0		 test	 eax, eax
  0002f	74 15		 je	 SHORT $LN6@delta_divm
$LN5@delta_divm:
  00031	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00035	48 3b cd	 cmp	 rcx, rbp
  00038	74 68		 je	 SHORT $LN7@delta_divm
  0003a	48 8b d5	 mov	 rdx, rbp
  0003d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00042	85 c0		 test	 eax, eax
  00044	75 5c		 jne	 SHORT $LN7@delta_divm
$LN6@delta_divm:

; 1962 :         Py_RETURN_NOTIMPLEMENTED;

  00046	e8 00 00 00 00	 call	 _Py_PXCTX
  0004b	85 c0		 test	 eax, eax
  0004d	75 3c		 jne	 SHORT $LN11@delta_divm
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00064	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0006a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00072	e8 00 00 00 00	 call	 _PyParallel_Guard
  00077	85 c0		 test	 eax, eax
  00079	75 09		 jne	 SHORT $LN10@delta_divm
  0007b	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00082	74 07		 je	 SHORT $LN11@delta_divm
$LN10@delta_divm:
  00084	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN11@delta_divm:
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 1990 : }

  00092	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00097	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5f		 pop	 rdi
  000a1	c3		 ret	 0
$LN7@delta_divm:

; 1963 : 
; 1964 :     pyus_left = delta_to_microseconds((PyDateTime_Delta *)left);

  000a2	48 8b cb	 mov	 rcx, rbx
  000a5	e8 00 00 00 00	 call	 delta_to_microseconds
  000aa	48 8b d8	 mov	 rbx, rax

; 1965 :     if (pyus_left == NULL)

  000ad	48 85 c0	 test	 rax, rax
  000b0	75 10		 jne	 SHORT $LN4@delta_divm

; 1990 : }

  000b2	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b7	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000bc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
$LN4@delta_divm:

; 1966 :         return NULL;
; 1967 : 
; 1968 :     pyus_right = delta_to_microseconds((PyDateTime_Delta *)right);

  000c2	48 8b cf	 mov	 rcx, rdi
  000c5	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000ca	e8 00 00 00 00	 call	 delta_to_microseconds

; 1969 :     if (pyus_right == NULL) {
; 1970 :         Py_DECREF(pyus_left);

  000cf	48 8b cb	 mov	 rcx, rbx
  000d2	48 8b f0	 mov	 rsi, rax
  000d5	48 85 c0	 test	 rax, rax

; 1971 :         return NULL;

  000d8	74 37		 je	 SHORT $LN16@delta_divm

; 1972 :     }
; 1973 : 
; 1974 :     divmod = PyNumber_Divmod(pyus_left, pyus_right);

  000da	48 8b d0	 mov	 rdx, rax
  000dd	e8 00 00 00 00	 call	 PyNumber_Divmod

; 1975 :     Py_DECREF(pyus_left);

  000e2	48 8b cb	 mov	 rcx, rbx
  000e5	48 8b f8	 mov	 rdi, rax
  000e8	e8 00 00 00 00	 call	 _Py_DecRef

; 1976 :     Py_DECREF(pyus_right);

  000ed	48 8b ce	 mov	 rcx, rsi
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 1977 :     if (divmod == NULL)

  000f5	48 85 ff	 test	 rdi, rdi

; 1978 :         return NULL;

  000f8	74 1c		 je	 SHORT $LN15@delta_divm

; 1979 : 
; 1980 :     assert(PyTuple_Size(divmod) == 2);
; 1981 :     delta = microseconds_to_delta(PyTuple_GET_ITEM(divmod, 1));

  000fa	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  000fe	48 8b d5	 mov	 rdx, rbp
  00101	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  00106	48 8b f0	 mov	 rsi, rax

; 1982 :     if (delta == NULL) {

  00109	48 85 c0	 test	 rax, rax
  0010c	75 0c		 jne	 SHORT $LN1@delta_divm

; 1983 :         Py_DECREF(divmod);

  0010e	48 8b cf	 mov	 rcx, rdi
$LN16@delta_divm:
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@delta_divm:

; 1984 :         return NULL;

  00116	33 c0		 xor	 eax, eax
  00118	eb 27		 jmp	 SHORT $LN14@delta_divm
$LN1@delta_divm:

; 1985 :     }
; 1986 :     result = PyTuple_Pack(2, PyTuple_GET_ITEM(divmod, 0), delta);

  0011a	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  0011e	4c 8b c0	 mov	 r8, rax
  00121	b9 02 00 00 00	 mov	 ecx, 2
  00126	e8 00 00 00 00	 call	 PyTuple_Pack

; 1987 :     Py_DECREF(delta);

  0012b	48 8b ce	 mov	 rcx, rsi
  0012e	48 8b d8	 mov	 rbx, rax
  00131	e8 00 00 00 00	 call	 _Py_DecRef

; 1988 :     Py_DECREF(divmod);

  00136	48 8b cf	 mov	 rcx, rdi
  00139	e8 00 00 00 00	 call	 _Py_DecRef

; 1989 :     return result;

  0013e	48 8b c3	 mov	 rax, rbx
$LN14@delta_divm:

; 1990 : }

  00141	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00146	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0014b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00150	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00154	5f		 pop	 rdi
  00155	c3		 ret	 0
delta_divmod ENDP
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@ ; `string'
EXTRN	PyLong_AsDouble:PROC
EXTRN	PyLong_FromDouble:PROC
EXTRN	__imp_modf:PROC
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$accum DD	imagerel accum
	DD	imagerel accum+158
	DD	imagerel $unwind$accum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$accum DD imagerel accum+158
	DD	imagerel accum+413
	DD	imagerel $chain$0$accum
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$accum DD imagerel accum+413
	DD	imagerel accum+434
	DD	imagerel $chain$1$accum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$accum DD 021H
	DD	imagerel accum
	DD	imagerel accum+158
	DD	imagerel $unwind$accum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$accum DD 020521H
	DD	026805H
	DD	imagerel accum
	DD	imagerel accum+158
	DD	imagerel $unwind$accum
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accum DD 081401H
	DD	0b6414H
	DD	095414H
	DD	083414H
	DD	070105214H
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@
CONST	SEGMENT
??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@ DB 'unsupport'
	DB	'ed type for timedelta %s component: %s', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT accum
_TEXT	SEGMENT
tag$ = 64
sofar$ = 72
intpart$21909 = 80
num$ = 80
factor$ = 88
leftover$ = 96
accum	PROC						; COMDAT

; 2004 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b f9	 mov	 rdi, rcx

; 2005 :     PyObject *prod;
; 2006 :     PyObject *sum;
; 2007 : 
; 2008 :     assert(num != NULL);
; 2009 : 
; 2010 :     if (PyLong_Check(num)) {

  00017	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  0001b	49 8b f1	 mov	 rsi, r9
  0001e	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00028	49 8b d8	 mov	 rbx, r8
  0002b	48 8b ea	 mov	 rbp, rdx
  0002e	74 31		 je	 SHORT $LN10@accum

; 2011 :         prod = PyNumber_Multiply(num, factor);

  00030	49 8b d1	 mov	 rdx, r9
  00033	48 8b cb	 mov	 rcx, rbx
  00036	e8 00 00 00 00	 call	 PyNumber_Multiply
  0003b	48 8b f8	 mov	 rdi, rax

; 2012 :         if (prod == NULL)

  0003e	48 85 c0	 test	 rax, rax

; 2013 :             return NULL;

  00041	74 51		 je	 SHORT $LN15@accum

; 2014 :         sum = PyNumber_Add(sofar, prod);

  00043	48 8b d0	 mov	 rdx, rax
  00046	48 8b cd	 mov	 rcx, rbp
  00049	e8 00 00 00 00	 call	 PyNumber_Add

; 2015 :         Py_DECREF(prod);

  0004e	48 8b cf	 mov	 rcx, rdi
  00051	48 8b d8	 mov	 rbx, rax
  00054	e8 00 00 00 00	 call	 _Py_DecRef

; 2016 :         return sum;

  00059	48 8b c3	 mov	 rax, rbx
  0005c	e9 3c 01 00 00	 jmp	 $LN11@accum
$LN10@accum:

; 2017 :     }
; 2018 : 
; 2019 :     if (PyFloat_Check(num)) {

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00068	48 3b ca	 cmp	 rcx, rdx
  0006b	74 2e		 je	 SHORT $LN7@accum
  0006d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00072	85 c0		 test	 eax, eax
  00074	75 25		 jne	 SHORT $LN7@accum

; 2074 :     }
; 2075 : 
; 2076 :     PyErr_Format(PyExc_TypeError,
; 2077 :                  "unsupported type for timedelta %s component: %s",
; 2078 :                  tag, Py_TYPE(num)->tp_name);

  00076	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@
  00088	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0008c	4c 8b c7	 mov	 r8, rdi
  0008f	e8 00 00 00 00	 call	 PyErr_Format
$LN15@accum:

; 2079 :     return NULL;

  00094	33 c0		 xor	 eax, eax
  00096	e9 02 01 00 00	 jmp	 $LN11@accum
$LN7@accum:

; 2020 :         double dnum;
; 2021 :         double fracpart;
; 2022 :         double intpart;
; 2023 :         PyObject *x;
; 2024 :         PyObject *y;
; 2025 : 
; 2026 :         /* The Plan:  decompose num into an integer part and a
; 2027 :          * fractional part, num = intpart + fracpart.
; 2028 :          * Then num * factor ==
; 2029 :          *      intpart * factor + fracpart * factor
; 2030 :          * and the LHS can be computed exactly in long arithmetic.
; 2031 :          * The RHS is again broken into an int part and frac part.
; 2032 :          * and the frac part is added into *leftover.
; 2033 :          */
; 2034 :         dnum = PyFloat_AsDouble(num);

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	0f 29 74 24 20	 movaps	 XMMWORD PTR [rsp+32], xmm6
  000a3	e8 00 00 00 00	 call	 PyFloat_AsDouble

; 2035 :         if (dnum == -1.0 && PyErr_Occurred())

  000a8	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000b0	66 0f 28 f0	 movapd	 xmm6, xmm0
  000b4	7a 10		 jp	 SHORT $LN6@accum
  000b6	75 0e		 jne	 SHORT $LN6@accum
  000b8	e8 00 00 00 00	 call	 PyErr_Occurred
  000bd	48 85 c0	 test	 rax, rax

; 2036 :             return NULL;

  000c0	0f 85 a3 00 00
	00		 jne	 $LN14@accum
$LN6@accum:

; 2037 :         fracpart = modf(dnum, &intpart);

  000c6	48 8d 54 24 50	 lea	 rdx, QWORD PTR intpart$21909[rsp]
  000cb	66 0f 28 c6	 movapd	 xmm0, xmm6
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  000d5	66 0f 28 f0	 movapd	 xmm6, xmm0

; 2038 :         x = PyLong_FromDouble(intpart);

  000d9	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR intpart$21909[rsp]
  000df	e8 00 00 00 00	 call	 PyLong_FromDouble
  000e4	48 8b f8	 mov	 rdi, rax

; 2039 :         if (x == NULL)

  000e7	48 85 c0	 test	 rax, rax

; 2040 :             return NULL;

  000ea	74 7d		 je	 SHORT $LN14@accum

; 2041 : 
; 2042 :         prod = PyNumber_Multiply(x, factor);

  000ec	48 8b d6	 mov	 rdx, rsi
  000ef	48 8b c8	 mov	 rcx, rax
  000f2	e8 00 00 00 00	 call	 PyNumber_Multiply

; 2043 :         Py_DECREF(x);

  000f7	48 8b cf	 mov	 rcx, rdi
  000fa	48 8b d8	 mov	 rbx, rax
  000fd	e8 00 00 00 00	 call	 _Py_DecRef

; 2044 :         if (prod == NULL)

  00102	48 85 db	 test	 rbx, rbx

; 2045 :             return NULL;

  00105	74 62		 je	 SHORT $LN14@accum

; 2046 : 
; 2047 :         sum = PyNumber_Add(sofar, prod);

  00107	48 8b d3	 mov	 rdx, rbx
  0010a	48 8b cd	 mov	 rcx, rbp
  0010d	e8 00 00 00 00	 call	 PyNumber_Add

; 2048 :         Py_DECREF(prod);

  00112	48 8b cb	 mov	 rcx, rbx
  00115	48 8b f8	 mov	 rdi, rax
  00118	e8 00 00 00 00	 call	 _Py_DecRef

; 2049 :         if (sum == NULL)

  0011d	48 85 ff	 test	 rdi, rdi

; 2050 :             return NULL;

  00120	74 47		 je	 SHORT $LN14@accum

; 2051 : 
; 2052 :         if (fracpart == 0.0)

  00122	66 0f 2e 35 00
	00 00 00	 ucomisd xmm6, QWORD PTR __real@0000000000000000
  0012a	7a 07		 jp	 SHORT $LN2@accum
  0012c	75 05		 jne	 SHORT $LN2@accum

; 2053 :             return sum;

  0012e	48 8b c7	 mov	 rax, rdi
  00131	eb 65		 jmp	 SHORT $LN13@accum
$LN2@accum:

; 2054 :         /* So far we've lost no information.  Dealing with the
; 2055 :          * fractional part requires float arithmetic, and may
; 2056 :          * lose a little info.
; 2057 :          */
; 2058 :         assert(PyLong_Check(factor));
; 2059 :         dnum = PyLong_AsDouble(factor);

  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 PyLong_AsDouble

; 2060 : 
; 2061 :         dnum *= fracpart;
; 2062 :         fracpart = modf(dnum, &intpart);

  0013b	48 8d 54 24 50	 lea	 rdx, QWORD PTR intpart$21909[rsp]
  00140	f2 0f 59 c6	 mulsd	 xmm0, xmm6
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  0014a	66 0f 28 f0	 movapd	 xmm6, xmm0

; 2063 :         x = PyLong_FromDouble(intpart);

  0014e	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR intpart$21909[rsp]
  00154	e8 00 00 00 00	 call	 PyLong_FromDouble

; 2064 :         if (x == NULL) {
; 2065 :             Py_DECREF(sum);

  00159	48 8b cf	 mov	 rcx, rdi
  0015c	48 8b f0	 mov	 rsi, rax
  0015f	48 85 c0	 test	 rax, rax
  00162	75 09		 jne	 SHORT $LN1@accum
  00164	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@accum:

; 2066 :             return NULL;

  00169	33 c0		 xor	 eax, eax
  0016b	eb 2b		 jmp	 SHORT $LN13@accum
$LN1@accum:

; 2067 :         }
; 2068 : 
; 2069 :         y = PyNumber_Add(sum, x);

  0016d	48 8b d0	 mov	 rdx, rax
  00170	e8 00 00 00 00	 call	 PyNumber_Add

; 2070 :         Py_DECREF(sum);

  00175	48 8b cf	 mov	 rcx, rdi
  00178	48 8b d8	 mov	 rbx, rax
  0017b	e8 00 00 00 00	 call	 _Py_DecRef

; 2071 :         Py_DECREF(x);

  00180	48 8b ce	 mov	 rcx, rsi
  00183	e8 00 00 00 00	 call	 _Py_DecRef

; 2072 :         *leftover += fracpart;

  00188	48 8b 4c 24 60	 mov	 rcx, QWORD PTR leftover$[rsp]

; 2073 :         return y;

  0018d	48 8b c3	 mov	 rax, rbx
  00190	f2 0f 58 31	 addsd	 xmm6, QWORD PTR [rcx]
  00194	f2 0f 11 31	 movsdx	 QWORD PTR [rcx], xmm6
$LN13@accum:
  00198	0f 28 74 24 20	 movaps	 xmm6, XMMWORD PTR [rsp+32]
$LN11@accum:

; 2080 : }

  0019d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  001a2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  001a7	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  001ac	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001b0	5f		 pop	 rdi
  001b1	c3		 ret	 0
accum	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@	; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_new DD imagerel delta_new
	DD	imagerel delta_new+173
	DD	imagerel $unwind$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$delta_new DD imagerel delta_new+173
	DD	imagerel delta_new+202
	DD	imagerel $chain$0$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$delta_new DD imagerel delta_new+202
	DD	imagerel delta_new+648
	DD	imagerel $chain$1$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$delta_new DD imagerel delta_new+648
	DD	imagerel delta_new+757
	DD	imagerel $chain$2$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$delta_new DD imagerel delta_new+757
	DD	imagerel delta_new+765
	DD	imagerel $chain$3$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$delta_new DD imagerel delta_new+765
	DD	imagerel delta_new+773
	DD	imagerel $chain$4$delta_new
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$delta_new DD imagerel delta_new+773
	DD	imagerel delta_new+797
	DD	imagerel $chain$5$delta_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$delta_new DD 021H
	DD	imagerel delta_new
	DD	imagerel delta_new+173
	DD	imagerel $unwind$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$delta_new DD 021H
	DD	imagerel delta_new+173
	DD	imagerel delta_new+202
	DD	imagerel $chain$0$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$delta_new DD 021H
	DD	imagerel delta_new+202
	DD	imagerel delta_new+648
	DD	imagerel $chain$1$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$delta_new DD 020821H
	DD	01b6408H
	DD	imagerel delta_new+202
	DD	imagerel delta_new+648
	DD	imagerel $chain$1$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$delta_new DD 020821H
	DD	01a3408H
	DD	imagerel delta_new+173
	DD	imagerel delta_new+202
	DD	imagerel $chain$0$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$delta_new DD 020821H
	DD	01c7408H
	DD	imagerel delta_new
	DD	imagerel delta_new+173
	DD	imagerel $unwind$delta_new
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_new DD 073001H
	DD	0a6830H
	DD	0160112H
	DD	0c004d006H
	DD	05002H
xdata	ENDS
;	COMDAT ??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@
CONST	SEGMENT
??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@ DB '|OOOOOOO:__new__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT delta_new
_TEXT	SEGMENT
us$ = 96
ms$ = 104
second$ = 112
minute$ = 120
hour$ = 128
day$ = 136
week$ = 144
type$ = 208
args$ = 216
kw$ = 224
leftover_us$ = 232
delta_new PROC						; COMDAT

; 2084 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	48 8d 6c 24 b9	 lea	 rbp, QWORD PTR [rsp-71]
  0000b	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00012	4c 8b e9	 mov	 r13, rcx

; 2085 :     PyObject *self = NULL;

  00015	45 33 e4	 xor	 r12d, r12d

; 2086 : 
; 2087 :     /* Argument objects. */
; 2088 :     PyObject *day = NULL;
; 2089 :     PyObject *second = NULL;
; 2090 :     PyObject *us = NULL;
; 2091 :     PyObject *ms = NULL;
; 2092 :     PyObject *minute = NULL;
; 2093 :     PyObject *hour = NULL;
; 2094 :     PyObject *week = NULL;
; 2095 : 
; 2096 :     PyObject *x = NULL;         /* running sum of microseconds */
; 2097 :     PyObject *y = NULL;         /* temp sum of microseconds */
; 2098 :     double leftover_us = 0.0;
; 2099 : 
; 2100 :     static char *keywords[] = {
; 2101 :         "days", "seconds", "microseconds", "milliseconds",
; 2102 :         "minutes", "hours", "weeks", NULL
; 2103 :     };
; 2104 : 
; 2105 :     if (PyArg_ParseTupleAndKeywords(args, kw, "|OOOOOOO:__new__",
; 2106 :                                     keywords,
; 2107 :                                     &day, &second, &us,
; 2108 :                                     &ms, &minute, &hour, &week) == 0)

  00018	48 8d 4d 27	 lea	 rcx, QWORD PTR week$[rbp-105]
  0001c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00021	48 8d 4d 17	 lea	 rcx, QWORD PTR hour$[rbp-105]
  00025	49 8b c0	 mov	 rax, r8
  00028	0f 29 b4 24 a0
	00 00 00	 movaps	 XMMWORD PTR [rsp+160], xmm6
  00030	66 0f 57 f6	 xorpd	 xmm6, xmm6
  00034	f2 0f 11 75 7f	 movsdx	 QWORD PTR leftover_us$[rbp-105], xmm6
  00039	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0003e	4c 8b d2	 mov	 r10, rdx
  00041	48 8d 4d 0f	 lea	 rcx, QWORD PTR minute$[rbp-105]
  00045	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0004a	48 8d 4d ff	 lea	 rcx, QWORD PTR ms$[rbp-105]
  0004e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??delta_new@@9@9
  00055	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0005a	48 8d 4d f7	 lea	 rcx, QWORD PTR us$[rbp-105]
  0005e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@
  00065	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006a	48 8d 4d 07	 lea	 rcx, QWORD PTR second$[rbp-105]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00076	48 8d 4d 1f	 lea	 rcx, QWORD PTR day$[rbp-105]
  0007a	4c 89 65 1f	 mov	 QWORD PTR day$[rbp-105], r12
  0007e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00083	49 8b ca	 mov	 rcx, r10
  00086	4c 89 65 07	 mov	 QWORD PTR second$[rbp-105], r12
  0008a	4c 89 65 f7	 mov	 QWORD PTR us$[rbp-105], r12
  0008e	4c 89 65 ff	 mov	 QWORD PTR ms$[rbp-105], r12
  00092	4c 89 65 0f	 mov	 QWORD PTR minute$[rbp-105], r12
  00096	4c 89 65 17	 mov	 QWORD PTR hour$[rbp-105], r12
  0009a	4c 89 65 27	 mov	 QWORD PTR week$[rbp-105], r12
  0009e	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000a3	85 c0		 test	 eax, eax
  000a5	0f 84 5a 02 00
	00		 je	 $Done$21977

; 2109 :         goto Done;
; 2110 : 
; 2111 :     x = PyLong_FromLong(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	48 89 bc 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rdi
  000b5	e8 00 00 00 00	 call	 PyLong_FromLong
  000ba	48 8b f8	 mov	 rdi, rax

; 2112 :     if (x == NULL)

  000bd	48 85 c0	 test	 rax, rax
  000c0	0f 84 37 02 00
	00		 je	 $LN23@delta_new

; 2113 :         goto Done;
; 2114 : 
; 2115 : #define CLEANUP         \
; 2116 :     Py_DECREF(x);       \
; 2117 :     x = y;              \
; 2118 :     if (x == NULL)      \
; 2119 :         goto Done
; 2120 : 
; 2121 :     if (us) {

  000c6	4c 8b 45 f7	 mov	 r8, QWORD PTR us$[rbp-105]
  000ca	48 89 9c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rbx
  000d2	4d 85 c0	 test	 r8, r8
  000d5	74 36		 je	 SHORT $LN16@delta_new

; 2122 :         y = accum("microseconds", x, us, us_per_us, &leftover_us);

  000d7	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_us
  000de	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
  000e9	48 8b d7	 mov	 rdx, rdi
  000ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f1	e8 00 00 00 00	 call	 accum

; 2123 :         CLEANUP;

  000f6	48 8b cf	 mov	 rcx, rdi
  000f9	48 8b d8	 mov	 rbx, rax
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
  00101	48 8b fb	 mov	 rdi, rbx
  00104	48 85 db	 test	 rbx, rbx
  00107	0f 84 e8 01 00
	00		 je	 $LN24@delta_new
$LN16@delta_new:

; 2124 :     }
; 2125 :     if (ms) {

  0010d	4c 8b 45 ff	 mov	 r8, QWORD PTR ms$[rbp-105]
  00111	4d 85 c0	 test	 r8, r8
  00114	74 36		 je	 SHORT $LN14@delta_new

; 2126 :         y = accum("milliseconds", x, ms, us_per_ms, &leftover_us);

  00116	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_ms
  0011d	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JDBMCDJK@milliseconds?$AA@
  00128	48 8b d7	 mov	 rdx, rdi
  0012b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00130	e8 00 00 00 00	 call	 accum

; 2127 :         CLEANUP;

  00135	48 8b cf	 mov	 rcx, rdi
  00138	48 8b d8	 mov	 rbx, rax
  0013b	e8 00 00 00 00	 call	 _Py_DecRef
  00140	48 8b fb	 mov	 rdi, rbx
  00143	48 85 db	 test	 rbx, rbx
  00146	0f 84 a9 01 00
	00		 je	 $LN24@delta_new
$LN14@delta_new:

; 2128 :     }
; 2129 :     if (second) {

  0014c	4c 8b 45 07	 mov	 r8, QWORD PTR second$[rbp-105]
  00150	4d 85 c0	 test	 r8, r8
  00153	74 36		 je	 SHORT $LN12@delta_new

; 2130 :         y = accum("seconds", x, second, us_per_second, &leftover_us);

  00155	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_second
  0015c	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07GELLIBDG@seconds?$AA@
  00167	48 8b d7	 mov	 rdx, rdi
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	e8 00 00 00 00	 call	 accum

; 2131 :         CLEANUP;

  00174	48 8b cf	 mov	 rcx, rdi
  00177	48 8b d8	 mov	 rbx, rax
  0017a	e8 00 00 00 00	 call	 _Py_DecRef
  0017f	48 8b fb	 mov	 rdi, rbx
  00182	48 85 db	 test	 rbx, rbx
  00185	0f 84 6a 01 00
	00		 je	 $LN24@delta_new
$LN12@delta_new:

; 2132 :     }
; 2133 :     if (minute) {

  0018b	4c 8b 45 0f	 mov	 r8, QWORD PTR minute$[rbp-105]
  0018f	4d 85 c0	 test	 r8, r8
  00192	74 36		 je	 SHORT $LN10@delta_new

; 2134 :         y = accum("minutes", x, minute, us_per_minute, &leftover_us);

  00194	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_minute
  0019b	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07GCICIJGK@minutes?$AA@
  001a6	48 8b d7	 mov	 rdx, rdi
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	e8 00 00 00 00	 call	 accum

; 2135 :         CLEANUP;

  001b3	48 8b cf	 mov	 rcx, rdi
  001b6	48 8b d8	 mov	 rbx, rax
  001b9	e8 00 00 00 00	 call	 _Py_DecRef
  001be	48 8b fb	 mov	 rdi, rbx
  001c1	48 85 db	 test	 rbx, rbx
  001c4	0f 84 2b 01 00
	00		 je	 $LN24@delta_new
$LN10@delta_new:

; 2136 :     }
; 2137 :     if (hour) {

  001ca	4c 8b 45 17	 mov	 r8, QWORD PTR hour$[rbp-105]
  001ce	4d 85 c0	 test	 r8, r8
  001d1	74 36		 je	 SHORT $LN8@delta_new

; 2138 :         y = accum("hours", x, hour, us_per_hour, &leftover_us);

  001d3	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_hour
  001da	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LOHOPFFC@hours?$AA@
  001e5	48 8b d7	 mov	 rdx, rdi
  001e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ed	e8 00 00 00 00	 call	 accum

; 2139 :         CLEANUP;

  001f2	48 8b cf	 mov	 rcx, rdi
  001f5	48 8b d8	 mov	 rbx, rax
  001f8	e8 00 00 00 00	 call	 _Py_DecRef
  001fd	48 8b fb	 mov	 rdi, rbx
  00200	48 85 db	 test	 rbx, rbx
  00203	0f 84 ec 00 00
	00		 je	 $LN24@delta_new
$LN8@delta_new:

; 2140 :     }
; 2141 :     if (day) {

  00209	4c 8b 45 1f	 mov	 r8, QWORD PTR day$[rbp-105]
  0020d	4d 85 c0	 test	 r8, r8
  00210	74 36		 je	 SHORT $LN6@delta_new

; 2142 :         y = accum("days", x, day, us_per_day, &leftover_us);

  00212	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_day
  00219	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IJMHDAOD@days?$AA@
  00224	48 8b d7	 mov	 rdx, rdi
  00227	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022c	e8 00 00 00 00	 call	 accum

; 2143 :         CLEANUP;

  00231	48 8b cf	 mov	 rcx, rdi
  00234	48 8b d8	 mov	 rbx, rax
  00237	e8 00 00 00 00	 call	 _Py_DecRef
  0023c	48 8b fb	 mov	 rdi, rbx
  0023f	48 85 db	 test	 rbx, rbx
  00242	0f 84 ad 00 00
	00		 je	 $LN24@delta_new
$LN6@delta_new:

; 2144 :     }
; 2145 :     if (week) {

  00248	4c 8b 45 27	 mov	 r8, QWORD PTR week$[rbp-105]
  0024c	4d 85 c0	 test	 r8, r8
  0024f	74 32		 je	 SHORT $LN4@delta_new

; 2146 :         y = accum("weeks", x, week, us_per_week, &leftover_us);

  00251	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_week
  00258	48 8d 45 7f	 lea	 rax, QWORD PTR leftover_us$[rbp-105]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EFKAJCNN@weeks?$AA@
  00263	48 8b d7	 mov	 rdx, rdi
  00266	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026b	e8 00 00 00 00	 call	 accum

; 2147 :         CLEANUP;

  00270	48 8b cf	 mov	 rcx, rdi
  00273	48 8b d8	 mov	 rbx, rax
  00276	e8 00 00 00 00	 call	 _Py_DecRef
  0027b	48 8b fb	 mov	 rdi, rbx
  0027e	48 85 db	 test	 rbx, rbx
  00281	74 72		 je	 SHORT $LN24@delta_new
$LN4@delta_new:

; 2148 :     }
; 2149 :     if (leftover_us) {

  00283	f2 0f 10 45 7f	 movsdx	 xmm0, QWORD PTR leftover_us$[rbp-105]
  00288	48 89 b4 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rsi
  00290	66 0f 2e c6	 ucomisd xmm0, xmm6
  00294	7a 02		 jp	 SHORT $LN22@delta_new
  00296	74 3f		 je	 SHORT $LN1@delta_new
$LN22@delta_new:

; 2150 :         /* Round to nearest whole # of us, and add into x. */
; 2151 :         PyObject *temp = PyLong_FromLong(round_to_long(leftover_us));

  00298	f2 0f 10 45 7f	 movsdx	 xmm0, QWORD PTR leftover_us$[rbp-105]
  0029d	e8 00 00 00 00	 call	 round_to_long
  002a2	8b c8		 mov	 ecx, eax
  002a4	e8 00 00 00 00	 call	 PyLong_FromLong

; 2152 :         if (temp == NULL) {
; 2153 :             Py_DECREF(x);

  002a9	48 8b cf	 mov	 rcx, rdi
  002ac	48 8b f0	 mov	 rsi, rax
  002af	48 85 c0	 test	 rax, rax

; 2154 :             goto Done;

  002b2	74 34		 je	 SHORT $LN26@delta_new

; 2155 :         }
; 2156 :         y = PyNumber_Add(x, temp);

  002b4	48 8b d0	 mov	 rdx, rax
  002b7	e8 00 00 00 00	 call	 PyNumber_Add

; 2157 :         Py_DECREF(temp);

  002bc	48 8b ce	 mov	 rcx, rsi
  002bf	48 8b d8	 mov	 rbx, rax
  002c2	e8 00 00 00 00	 call	 _Py_DecRef

; 2158 :         CLEANUP;

  002c7	48 8b cf	 mov	 rcx, rdi
  002ca	e8 00 00 00 00	 call	 _Py_DecRef
  002cf	48 8b fb	 mov	 rdi, rbx
  002d2	48 85 db	 test	 rbx, rbx
  002d5	74 16		 je	 SHORT $LN25@delta_new
$LN1@delta_new:

; 2159 :     }
; 2160 : 
; 2161 :     self = microseconds_to_delta_ex(x, type);

  002d7	49 8b d5	 mov	 rdx, r13
  002da	48 8b cf	 mov	 rcx, rdi
  002dd	e8 00 00 00 00	 call	 microseconds_to_delta_ex

; 2162 :     Py_DECREF(x);

  002e2	48 8b cf	 mov	 rcx, rdi
  002e5	4c 8b e0	 mov	 r12, rax
$LN26@delta_new:
  002e8	e8 00 00 00 00	 call	 _Py_DecRef
$LN25@delta_new:
  002ed	48 8b b4 24 d8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+216]
$LN24@delta_new:
  002f5	48 8b 9c 24 d0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+208]
$LN23@delta_new:
  002fd	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+224]
$Done$21977:

; 2163 : Done:
; 2164 :     return self;

  00305	49 8b c4	 mov	 rax, r12

; 2165 : 
; 2166 : #undef CLEANUP
; 2167 : }

  00308	0f 28 b4 24 a0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+160]
  00310	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00317	41 5d		 pop	 r13
  00319	41 5c		 pop	 r12
  0031b	5d		 pop	 rbp
  0031c	c3		 ret	 0
delta_new ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT delta_bool
_TEXT	SEGMENT
self$ = 8
delta_bool PROC						; COMDAT

; 2172 :     return (GET_TD_DAYS(self) != 0
; 2173 :         || GET_TD_SECONDS(self) != 0
; 2174 :         || GET_TD_MICROSECONDS(self) != 0);

  00000	83 79 68 00	 cmp	 DWORD PTR [rcx+104], 0
  00004	75 0f		 jne	 SHORT $LN3@delta_bool
  00006	83 79 6c 00	 cmp	 DWORD PTR [rcx+108], 0
  0000a	75 09		 jne	 SHORT $LN3@delta_bool
  0000c	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00010	75 03		 jne	 SHORT $LN3@delta_bool
  00012	33 c0		 xor	 eax, eax

; 2175 : }

  00014	c3		 ret	 0
$LN3@delta_bool:

; 2172 :     return (GET_TD_DAYS(self) != 0
; 2173 :         || GET_TD_SECONDS(self) != 0
; 2174 :         || GET_TD_MICROSECONDS(self) != 0);

  00015	b8 01 00 00 00	 mov	 eax, 1

; 2175 : }

  0001a	c3		 ret	 0
delta_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_repr DD imagerel delta_repr
	DD	imagerel delta_repr+85
	DD	imagerel $unwind$delta_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_repr DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@ DB '%s(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@ DB '%s(%d, %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%s(%d, %d'
	DB	', %d)', 00H					; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT delta_repr
_TEXT	SEGMENT
self$ = 64
delta_repr PROC						; COMDAT

; 2179 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2180 :     if (GET_TD_MICROSECONDS(self) != 0)

  00004	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]

; 2181 :         return PyUnicode_FromFormat("%s(%d, %d, %d)",
; 2182 :                                     Py_TYPE(self)->tp_name,
; 2183 :                                     GET_TD_DAYS(self),
; 2184 :                                     GET_TD_SECONDS(self),
; 2185 :                                     GET_TD_MICROSECONDS(self));

  00007	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  0000b	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  0000f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00013	44 8b 41 68	 mov	 r8d, DWORD PTR [rcx+104]
  00017	85 c0		 test	 eax, eax
  00019	74 15		 je	 SHORT $LN2@delta_repr
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  00022	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00026	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2195 : }

  0002b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002f	c3		 ret	 0
$LN2@delta_repr:

; 2186 :     if (GET_TD_SECONDS(self) != 0)

  00030	45 85 c9	 test	 r9d, r9d
  00033	74 10		 je	 SHORT $LN1@delta_repr

; 2187 :         return PyUnicode_FromFormat("%s(%d, %d)",
; 2188 :                                     Py_TYPE(self)->tp_name,
; 2189 :                                     GET_TD_DAYS(self),
; 2190 :                                     GET_TD_SECONDS(self));

  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@

; 2195 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN1@delta_repr:

; 2191 : 
; 2192 :     return PyUnicode_FromFormat("%s(%d)",
; 2193 :                                 Py_TYPE(self)->tp_name,
; 2194 :                                 GET_TD_DAYS(self));

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@

; 2195 : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
delta_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
PUBLIC	??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_str DD imagerel delta_str
	DD	imagerel delta_str+255
	DD	imagerel $unwind$delta_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_str DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@ DB '%d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%d:%02d:%02d'
	DB	'.%06d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@ DB '%d'
	DB	' day%s, %d:%02d:%02d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%'
	DB	'd day%s, %d:%02d:%02d.%06d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT delta_str
_TEXT	SEGMENT
seconds$ = 80
self$ = 80
minutes$ = 88
delta_str PROC						; COMDAT

; 2199 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2200 :     int us = GET_TD_MICROSECONDS(self);

  00006	8b 59 70	 mov	 ebx, DWORD PTR [rcx+112]
  00009	4c 8b d9	 mov	 r11, rcx

; 2201 :     int seconds = GET_TD_SECONDS(self);

  0000c	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]

; 2202 :     int minutes = divmod(seconds, 60, &seconds);

  0000f	4c 8d 44 24 50	 lea	 r8, QWORD PTR seconds$[rsp]
  00014	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00019	89 4c 24 50	 mov	 DWORD PTR seconds$[rsp], ecx
  0001d	e8 00 00 00 00	 call	 divmod

; 2203 :     int hours = divmod(minutes, 60, &minutes);

  00022	4c 8d 44 24 58	 lea	 r8, QWORD PTR minutes$[rsp]
  00027	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  0002c	8b c8		 mov	 ecx, eax
  0002e	89 44 24 58	 mov	 DWORD PTR minutes$[rsp], eax
  00032	e8 00 00 00 00	 call	 divmod

; 2204 :     int days = GET_TD_DAYS(self);

  00037	41 8b 53 68	 mov	 edx, DWORD PTR [r11+104]
  0003b	44 8b d0	 mov	 r10d, eax

; 2205 : 
; 2206 :     if (days) {

  0003e	85 d2		 test	 edx, edx
  00040	0f 84 82 00 00
	00		 je	 $LN6@delta_str

; 2207 :         if (us)

  00046	85 db		 test	 ebx, ebx
  00048	74 41		 je	 SHORT $LN5@delta_str

; 2208 :             return PyUnicode_FromFormat("%d day%s, %d:%02d:%02d.%06d",
; 2209 :                                         days, (days == 1 || days == -1) ? "" : "s",
; 2210 :                                         hours, minutes, seconds, us);

  0004a	83 fa 01	 cmp	 edx, 1
  0004d	74 0c		 je	 SHORT $LN9@delta_str
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00056	83 fa ff	 cmp	 edx, -1
  00059	75 07		 jne	 SHORT $LN10@delta_str
$LN9@delta_str:
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$LN10@delta_str:
  00062	8b 44 24 50	 mov	 eax, DWORD PTR seconds$[rsp]
  00066	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  00071	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00075	8b 44 24 58	 mov	 eax, DWORD PTR minutes$[rsp]
  00079	45 8b ca	 mov	 r9d, r10d
  0007c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00080	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2222 :     }
; 2223 : 
; 2224 : }

  00085	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00089	5b		 pop	 rbx
  0008a	c3		 ret	 0
$LN5@delta_str:

; 2211 :         else
; 2212 :             return PyUnicode_FromFormat("%d day%s, %d:%02d:%02d",
; 2213 :                                         days, (days == 1 || days == -1) ? "" : "s",
; 2214 :                                         hours, minutes, seconds);

  0008b	83 fa 01	 cmp	 edx, 1
  0008e	74 0c		 je	 SHORT $LN11@delta_str
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00097	83 fa ff	 cmp	 edx, -1
  0009a	75 07		 jne	 SHORT $LN12@delta_str
$LN11@delta_str:
  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$LN12@delta_str:
  000a3	8b 44 24 50	 mov	 eax, DWORD PTR seconds$[rsp]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@
  000ae	45 8b ca	 mov	 r9d, r10d
  000b1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b5	8b 44 24 58	 mov	 eax, DWORD PTR minutes$[rsp]
  000b9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bd	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2222 :     }
; 2223 : 
; 2224 : }

  000c2	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c6	5b		 pop	 rbx
  000c7	c3		 ret	 0
$LN6@delta_str:

; 2215 :     } else {
; 2216 :         if (us)
; 2217 :             return PyUnicode_FromFormat("%d:%02d:%02d.%06d",
; 2218 :                                         hours, minutes, seconds, us);

  000c8	44 8b 4c 24 50	 mov	 r9d, DWORD PTR seconds$[rsp]
  000cd	44 8b 44 24 58	 mov	 r8d, DWORD PTR minutes$[rsp]
  000d2	8b d0		 mov	 edx, eax
  000d4	85 db		 test	 ebx, ebx
  000d6	74 16		 je	 SHORT $LN2@delta_str
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  000df	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  000e3	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2222 :     }
; 2223 : 
; 2224 : }

  000e8	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ec	5b		 pop	 rbx
  000ed	c3		 ret	 0
$LN2@delta_str:

; 2219 :         else
; 2220 :             return PyUnicode_FromFormat("%d:%02d:%02d",
; 2221 :                                         hours, minutes, seconds);

  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@

; 2222 :     }
; 2223 : 
; 2224 : }

  000f5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f9	5b		 pop	 rbx
  000fa	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
delta_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GLKMLICL@iii?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT ??_C@_03GLKMLICL@iii?$AA@
CONST	SEGMENT
??_C@_03GLKMLICL@iii?$AA@ DB 'iii', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT delta_getstate
_TEXT	SEGMENT
self$ = 8
delta_getstate PROC					; COMDAT

; 2232 :     return Py_BuildValue("iii", GET_TD_DAYS(self),
; 2233 :                                 GET_TD_SECONDS(self),
; 2234 :                                 GET_TD_MICROSECONDS(self));

  00000	44 8b 49 70	 mov	 r9d, DWORD PTR [rcx+112]
  00004	44 8b 41 6c	 mov	 r8d, DWORD PTR [rcx+108]
  00008	8b 51 68	 mov	 edx, DWORD PTR [rcx+104]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@

; 2235 : }

  00012	e9 00 00 00 00	 jmp	 Py_BuildValue
delta_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_total_seconds DD imagerel delta_total_seconds
	DD	imagerel delta_total_seconds+30
	DD	imagerel $unwind$delta_total_seconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$delta_total_seconds DD imagerel delta_total_seconds+30
	DD	imagerel delta_total_seconds+69
	DD	imagerel $chain$0$delta_total_seconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$delta_total_seconds DD imagerel delta_total_seconds+69
	DD	imagerel delta_total_seconds+120
	DD	imagerel $chain$3$delta_total_seconds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$delta_total_seconds DD 040821H
	DD	063408H
	DD	076400H
	DD	imagerel delta_total_seconds
	DD	imagerel delta_total_seconds+30
	DD	imagerel $unwind$delta_total_seconds
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$delta_total_seconds DD 020521H
	DD	076405H
	DD	imagerel delta_total_seconds
	DD	imagerel delta_total_seconds+30
	DD	imagerel $unwind$delta_total_seconds
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_total_seconds DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT delta_total_seconds
_TEXT	SEGMENT
self$ = 48
delta_total_seconds PROC				; COMDAT

; 2239 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2240 :     PyObject *total_seconds;
; 2241 :     PyObject *total_microseconds;
; 2242 :     PyObject *one_million;
; 2243 : 
; 2244 :     total_microseconds = delta_to_microseconds((PyDateTime_Delta *)self);

  00006	e8 00 00 00 00	 call	 delta_to_microseconds
  0000b	48 8b f8	 mov	 rdi, rax

; 2245 :     if (total_microseconds == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN2@delta_tota

; 2259 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN2@delta_tota:

; 2246 :         return NULL;
; 2247 : 
; 2248 :     one_million = PyLong_FromLong(1000000L);

  00019	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0001e	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00023	e8 00 00 00 00	 call	 PyLong_FromLong

; 2249 :     if (one_million == NULL) {
; 2250 :         Py_DECREF(total_microseconds);

  00028	48 8b cf	 mov	 rcx, rdi
  0002b	48 8b f0	 mov	 rsi, rax
  0002e	48 85 c0	 test	 rax, rax
  00031	75 12		 jne	 SHORT $LN1@delta_tota
  00033	e8 00 00 00 00	 call	 _Py_DecRef
  00038	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2251 :         return NULL;

  0003d	33 c0		 xor	 eax, eax

; 2259 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN1@delta_tota:

; 2252 :     }
; 2253 : 
; 2254 :     total_seconds = PyNumber_TrueDivide(total_microseconds, one_million);

  00045	48 8b d0	 mov	 rdx, rax
  00048	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004d	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 2255 : 
; 2256 :     Py_DECREF(total_microseconds);

  00052	48 8b cf	 mov	 rcx, rdi
  00055	48 8b d8	 mov	 rbx, rax
  00058	e8 00 00 00 00	 call	 _Py_DecRef

; 2257 :     Py_DECREF(one_million);

  0005d	48 8b ce	 mov	 rcx, rsi
  00060	e8 00 00 00 00	 call	 _Py_DecRef
  00065	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2258 :     return total_seconds;

  0006a	48 8b c3	 mov	 rax, rbx
  0006d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 2259 : }

  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
delta_total_seconds ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BFICIOJL@ON?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_reduce DD imagerel delta_reduce
	DD	imagerel delta_reduce+38
	DD	imagerel $unwind$delta_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_reduce DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_02BFICIOJL@ON?$AA@
CONST	SEGMENT
??_C@_02BFICIOJL@ON?$AA@ DB 'ON', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT delta_reduce
_TEXT	SEGMENT
self$ = 48
delta_reduce PROC					; COMDAT

; 2263 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2264 :     return Py_BuildValue("ON", Py_TYPE(self), delta_getstate(self));

  00009	e8 00 00 00 00	 call	 delta_getstate
  0000e	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02BFICIOJL@ON?$AA@
  00019	4c 8b c0	 mov	 r8, rax

; 2265 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	e9 00 00 00 00	 jmp	 Py_BuildValue
delta_reduce ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT date_year
_TEXT	SEGMENT
self$ = 8
unused$ = 16
date_year PROC						; COMDAT

; 2382 :     return PyLong_FromLong(GET_YEAR(self));

  00000	0f b6 51 69	 movzx	 edx, BYTE PTR [rcx+105]
  00004	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00008	c1 e2 08	 shl	 edx, 8
  0000b	0b ca		 or	 ecx, edx

; 2383 : }

  0000d	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_year ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT date_month
_TEXT	SEGMENT
self$ = 8
unused$ = 16
date_month PROC						; COMDAT

; 2388 :     return PyLong_FromLong(GET_MONTH(self));

  00000	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]

; 2389 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_month ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT date_day
_TEXT	SEGMENT
self$ = 8
unused$ = 16
date_day PROC						; COMDAT

; 2394 :     return PyLong_FromLong(GET_DAY(self));

  00000	0f b6 49 6c	 movzx	 ecx, BYTE PTR [rcx+108]

; 2395 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_day ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_new DD imagerel date_new
	DD	imagerel date_new+263
	DD	imagerel $unwind$date_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_new DD 060f01H
	DD	0e640fH
	DD	0c340fH
	DD	0700b920fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_new
_TEXT	SEGMENT
year$ = 64
type$ = 96
day$ = 104
args$ = 104
kw$ = 112
month$ = 120
date_new PROC						; COMDAT

; 2410 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2411 :     PyObject *self = NULL;

  0000f	33 f6		 xor	 esi, esi

; 2412 :     PyObject *state;
; 2413 :     int year;
; 2414 :     int month;
; 2415 :     int day;
; 2416 : 
; 2417 :     /* Check for invocation from pickle with __getstate__ state */
; 2418 :     if (PyTuple_GET_SIZE(args) == 1 &&
; 2419 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 2420 :         PyBytes_GET_SIZE(state) == _PyDateTime_DATE_DATASIZE &&
; 2421 :         MONTH_IS_SANE(PyBytes_AS_STRING(state)[2]))

  00011	48 83 7a 60 01	 cmp	 QWORD PTR [rdx+96], 1
  00016	4d 8b d8	 mov	 r11, r8
  00019	4c 8b d2	 mov	 r10, rdx
  0001c	48 8b f9	 mov	 rdi, rcx
  0001f	75 58		 jne	 SHORT $LN4@date_new
  00021	48 8b 5a 70	 mov	 rbx, QWORD PTR [rdx+112]
  00025	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00029	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00033	74 44		 je	 SHORT $LN4@date_new
  00035	48 83 7b 60 04	 cmp	 QWORD PTR [rbx+96], 4
  0003a	75 3d		 jne	 SHORT $LN4@date_new
  0003c	0f be 43 7a	 movsx	 eax, BYTE PTR [rbx+122]
  00040	ff c8		 dec	 eax
  00042	83 f8 0c	 cmp	 eax, 12
  00045	73 32		 jae	 SHORT $LN4@date_new

; 2422 :     {
; 2423 :         PyDateTime_Date *me;
; 2424 : 
; 2425 :         me = (PyDateTime_Date *) (type->tp_alloc(type, 0));

  00047	33 d2		 xor	 edx, edx
  00049	ff 97 88 01 00
	00		 call	 QWORD PTR [rdi+392]
  0004f	4c 8b d8	 mov	 r11, rax

; 2426 :         if (me != NULL) {

  00052	48 85 c0	 test	 rax, rax
  00055	74 0f		 je	 SHORT $LN3@date_new

; 2427 :             char *pdata = PyBytes_AS_STRING(state);
; 2428 :             memcpy(me->data, pdata, _PyDateTime_DATE_DATASIZE);

  00057	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]

; 2429 :             me->hashcode = -1;

  0005a	49 c7 43 60 ff
	ff ff ff	 mov	 QWORD PTR [r11+96], -1
  00062	41 89 43 69	 mov	 DWORD PTR [r11+105], eax
$LN3@date_new:

; 2430 :         }
; 2431 :         return (PyObject *)me;

  00066	49 8b c3	 mov	 rax, r11

; 2439 :     }
; 2440 :     return self;
; 2441 : }

  00069	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0006e	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00073	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
$LN4@date_new:

; 2432 :     }
; 2433 : 
; 2434 :     if (PyArg_ParseTupleAndKeywords(args, kw, "iii", date_kws,
; 2435 :                                     &year, &month, &day)) {

  00079	48 8d 44 24 68	 lea	 rax, QWORD PTR day$[rsp]
  0007e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:date_kws
  00085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0008c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00091	48 8d 44 24 78	 lea	 rax, QWORD PTR month$[rsp]
  00096	49 8b d3	 mov	 rdx, r11
  00099	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009e	48 8d 44 24 40	 lea	 rax, QWORD PTR year$[rsp]
  000a3	49 8b ca	 mov	 rcx, r10
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000b0	85 c0		 test	 eax, eax
  000b2	74 40		 je	 SHORT $LN2@date_new

; 2436 :         if (check_date_args(year, month, day) < 0)

  000b4	44 8b 44 24 68	 mov	 r8d, DWORD PTR day$[rsp]
  000b9	8b 54 24 78	 mov	 edx, DWORD PTR month$[rsp]
  000bd	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  000c1	e8 00 00 00 00	 call	 check_date_args
  000c6	85 c0		 test	 eax, eax
  000c8	79 12		 jns	 SHORT $LN1@date_new

; 2437 :             return NULL;

  000ca	33 c0		 xor	 eax, eax

; 2439 :     }
; 2440 :     return self;
; 2441 : }

  000cc	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000d1	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000d6	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
$LN1@date_new:

; 2438 :         self = new_date_ex(year, month, day, type);

  000dc	44 8b 44 24 68	 mov	 r8d, DWORD PTR day$[rsp]
  000e1	8b 54 24 78	 mov	 edx, DWORD PTR month$[rsp]
  000e5	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  000e9	4c 8b cf	 mov	 r9, rdi
  000ec	e8 00 00 00 00	 call	 new_date_ex
  000f1	48 8b f0	 mov	 rsi, rax
$LN2@date_new:

; 2439 :     }
; 2440 :     return self;
; 2441 : }

  000f4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000f9	48 8b c6	 mov	 rax, rsi
  000fc	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  00101	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
date_new ENDP
_TEXT	ENDS
EXTRN	PyObject_CallFunction:PROC
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp__errno:PROC
EXTRN	_PyTime_ObjectToTime_t:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$date_local_from_object DD imagerel date_local_from_object
	DD	imagerel date_local_from_object+135
	DD	imagerel $unwind$date_local_from_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_local_from_object DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT date_local_from_object
_TEXT	SEGMENT
cls$ = 64
obj$ = 72
t$ = 80
date_local_from_object PROC				; COMDAT

; 2446 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2447 :     struct tm *tm;
; 2448 :     time_t t;
; 2449 : 
; 2450 :     if (_PyTime_ObjectToTime_t(obj, &t) == -1)

  0000c	48 8d 54 24 50	 lea	 rdx, QWORD PTR t$[rsp]
  00011	48 8b c8	 mov	 rcx, rax
  00014	e8 00 00 00 00	 call	 _PyTime_ObjectToTime_t
  00019	83 f8 ff	 cmp	 eax, -1

; 2451 :         return NULL;

  0001c	74 33		 je	 SHORT $LN8@date_local

; 2452 : 
; 2453 :     tm = localtime(&t);

  0001e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR t$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 2454 :     if (tm == NULL) {

  00029	48 85 c0	 test	 rax, rax
  0002c	75 2b		 jne	 SHORT $LN2@date_local

; 2455 :         /* unconvertible time */
; 2456 : #ifdef EINVAL
; 2457 :         if (errno == 0)

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00034	83 38 00	 cmp	 DWORD PTR [rax], 0
  00037	75 0c		 jne	 SHORT $LN1@date_local

; 2458 :             errno = EINVAL;

  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003f	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN1@date_local:

; 2459 : #endif
; 2460 :         PyErr_SetFromErrno(PyExc_OSError);

  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  0004c	e8 00 00 00 00	 call	 PyErr_SetFromErrno
$LN8@date_local:

; 2461 :         return NULL;

  00051	33 c0		 xor	 eax, eax

; 2468 : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
$LN2@date_local:

; 2462 :     }
; 2463 : 
; 2464 :     return PyObject_CallFunction(cls, "iii",
; 2465 :                                  tm->tm_year + 1900,
; 2466 :                                  tm->tm_mon + 1,
; 2467 :                                  tm->tm_mday);

  00059	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  0005d	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00061	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0006b	41 ff c1	 inc	 r9d
  0006e	41 81 c0 6c 07
	00 00		 add	 r8d, 1900		; 0000076cH
  00075	48 8b cb	 mov	 rcx, rbx
  00078	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007c	e8 00 00 00 00	 call	 PyObject_CallFunction

; 2468 : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
date_local_from_object ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_today DD imagerel date_today
	DD	imagerel date_today+104
	DD	imagerel $unwind$date_today
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_today DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_today
_TEXT	SEGMENT
cls$ = 48
dummy$ = 56
date_today PROC						; COMDAT

; 2477 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2478 :     PyObject *time;
; 2479 :     PyObject *result;
; 2480 :     _Py_IDENTIFIER(fromtimestamp);
; 2481 : 
; 2482 :     time = time_time();

  0000d	e8 00 00 00 00	 call	 time_time
  00012	48 8b f8	 mov	 rdi, rax

; 2483 :     if (time == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 0b		 jne	 SHORT $LN1@date_today

; 2495 : }

  0001a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
$LN1@date_today:

; 2484 :         return NULL;
; 2485 : 
; 2486 :     /* Note well:  today() is a class method, so this may not call
; 2487 :      * date.fromtimestamp.  For example, it may call
; 2488 :      * datetime.fromtimestamp.  That's why we need all the accuracy
; 2489 :      * time.time() delivers; if someone were gonzo about optimization,
; 2490 :      * date.today() could get away with plain C time().
; 2491 :      */
; 2492 :     result = _PyObject_CallMethodId(cls, &PyId_fromtimestamp, "O", time);

  00025	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002b	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00034	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_fromtimestamp@?1??date_today@@9@9
  00039	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  00044	4c 8b cf	 mov	 r9, rdi
  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 2493 :     Py_DECREF(time);

  0004f	48 8b cf	 mov	 rcx, rdi
  00052	48 8b d8	 mov	 rbx, rax
  00055	e8 00 00 00 00	 call	 _Py_DecRef

; 2494 :     return result;

  0005a	48 8b c3	 mov	 rax, rbx

; 2495 : }

  0005d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
date_today ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@	; `string'
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_fromtimestamp DD imagerel date_fromtimestamp
	DD	imagerel date_fromtimestamp+63
	DD	imagerel $unwind$date_fromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_fromtimestamp DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@ DB 'O:fromtimestamp', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_fromtimestamp
_TEXT	SEGMENT
cls$ = 48
args$ = 56
timestamp$ = 64
date_fromtimestamp PROC					; COMDAT

; 2500 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2501 :     PyObject *timestamp;
; 2502 :     PyObject *result = NULL;
; 2503 : 
; 2504 :     if (PyArg_ParseTuple(args, "O:fromtimestamp", &timestamp))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR timestamp$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	74 13		 je	 SHORT $LN4@date_fromt

; 2505 :         result = date_local_from_object(cls, timestamp);

  00024	48 8b 54 24 40	 mov	 rdx, QWORD PTR timestamp$[rsp]
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 date_local_from_object

; 2507 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
$LN4@date_fromt:

; 2506 :     return result;

  00037	33 c0		 xor	 eax, eax

; 2507 : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
date_fromtimestamp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@ ; `string'
PUBLIC	??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_fromordinal DD imagerel date_fromordinal
	DD	imagerel date_fromordinal+133
	DD	imagerel $unwind$date_fromordinal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_fromordinal DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT ??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@
CONST	SEGMENT
??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@ DB 'ordinal must b'
	DB	'e >= 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@
CONST	SEGMENT
??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@ DB 'i:fromordinal', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_fromordinal
_TEXT	SEGMENT
month$22264 = 48
year$22263 = 52
cls$ = 80
args$ = 88
ordinal$ = 96
day$22265 = 104
date_fromordinal PROC					; COMDAT

; 2514 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	4c 8b ca	 mov	 r9, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2515 :     PyObject *result = NULL;
; 2516 :     int ordinal;
; 2517 : 
; 2518 :     if (PyArg_ParseTuple(args, "i:fromordinal", &ordinal)) {

  0000c	4c 8d 44 24 60	 lea	 r8, QWORD PTR ordinal$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@
  00018	49 8b c9	 mov	 rcx, r9
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	74 1c		 je	 SHORT $LN6@date_fromo

; 2519 :         int year;
; 2520 :         int month;
; 2521 :         int day;
; 2522 : 
; 2523 :         if (ordinal < 1)

  00024	8b 4c 24 60	 mov	 ecx, DWORD PTR ordinal$[rsp]
  00028	83 f9 01	 cmp	 ecx, 1
  0002b	7d 1b		 jge	 SHORT $LN2@date_fromo

; 2524 :             PyErr_SetString(PyExc_ValueError, "ordinal must be "
; 2525 :                                               ">= 1");

  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@
  0003b	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@date_fromo:

; 2530 :         }
; 2531 :     }
; 2532 :     return result;

  00040	33 c0		 xor	 eax, eax

; 2533 : }

  00042	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN2@date_fromo:

; 2526 :         else {
; 2527 :             ord_to_ymd(ordinal, &year, &month, &day);

  00048	4c 8d 4c 24 68	 lea	 r9, QWORD PTR day$22265[rsp]
  0004d	4c 8d 44 24 30	 lea	 r8, QWORD PTR month$22264[rsp]
  00052	48 8d 54 24 34	 lea	 rdx, QWORD PTR year$22263[rsp]
  00057	e8 00 00 00 00	 call	 ord_to_ymd

; 2528 :             result = PyObject_CallFunction(cls, "iii",
; 2529 :                                            year, month, day);

  0005c	44 8b 5c 24 68	 mov	 r11d, DWORD PTR day$22265[rsp]
  00061	44 8b 4c 24 30	 mov	 r9d, DWORD PTR month$22264[rsp]
  00066	44 8b 44 24 34	 mov	 r8d, DWORD PTR year$22263[rsp]
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  00072	48 8b cb	 mov	 rcx, rbx
  00075	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  0007a	e8 00 00 00 00	 call	 PyObject_CallFunction

; 2533 : }

  0007f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00083	5b		 pop	 rbx
  00084	c3		 ret	 0
date_fromordinal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_date_timedelta DD imagerel add_date_timedelta
	DD	imagerel add_date_timedelta+116
	DD	imagerel $unwind$add_date_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_date_timedelta DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_date_timedelta
_TEXT	SEGMENT
month$ = 48
date$ = 48
year$ = 56
delta$ = 56
day$ = 64
negate$ = 64
add_date_timedelta PROC					; COMDAT

; 2544 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2545 :     PyObject *result = NULL;
; 2546 :     int year = GET_YEAR(date);

  00004	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00008	44 0f b6 49 69	 movzx	 r9d, BYTE PTR [rcx+105]
  0000d	41 c1 e1 08	 shl	 r9d, 8
  00011	44 0b c8	 or	 r9d, eax

; 2547 :     int month = GET_MONTH(date);

  00014	0f b6 41 6b	 movzx	 eax, BYTE PTR [rcx+107]
  00018	44 89 4c 24 38	 mov	 DWORD PTR year$[rsp], r9d

; 2548 :     int deltadays = GET_TD_DAYS(delta);

  0001d	44 8b 4a 68	 mov	 r9d, DWORD PTR [rdx+104]
  00021	89 44 24 30	 mov	 DWORD PTR month$[rsp], eax

; 2549 :     /* C-level overflow is impossible because |deltadays| < 1e9. */
; 2550 :     int day = GET_DAY(date) + (negate ? -deltadays : deltadays);

  00025	45 85 c0	 test	 r8d, r8d
  00028	74 03		 je	 SHORT $LN4@add_date_t
  0002a	41 f7 d9	 neg	 r9d
$LN4@add_date_t:
  0002d	0f b6 41 6c	 movzx	 eax, BYTE PTR [rcx+108]

; 2551 : 
; 2552 :     if (normalize_date(&year, &month, &day) >= 0)

  00031	4c 8d 44 24 40	 lea	 r8, QWORD PTR day$[rsp]
  00036	48 8d 54 24 30	 lea	 rdx, QWORD PTR month$[rsp]
  0003b	41 03 c1	 add	 eax, r9d
  0003e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR year$[rsp]
  00043	89 44 24 40	 mov	 DWORD PTR day$[rsp], eax
  00047	e8 00 00 00 00	 call	 normalize_date
  0004c	85 c0		 test	 eax, eax
  0004e	78 1d		 js	 SHORT $LN6@add_date_t

; 2553 :         result = new_date(year, month, day);

  00050	44 8b 44 24 40	 mov	 r8d, DWORD PTR day$[rsp]
  00055	8b 54 24 30	 mov	 edx, DWORD PTR month$[rsp]
  00059	8b 4c 24 38	 mov	 ecx, DWORD PTR year$[rsp]
  0005d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType

; 2555 : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	e9 00 00 00 00	 jmp	 new_date_ex
$LN6@add_date_t:

; 2554 :     return result;

  0006d	33 c0		 xor	 eax, eax

; 2555 : }

  0006f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00073	c3		 ret	 0
add_date_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$date_add DD imagerel date_add
	DD	imagerel date_add+325
	DD	imagerel $unwind$date_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_add DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT date_add
_TEXT	SEGMENT
left$ = 64
right$ = 72
date_add PROC						; COMDAT

; 2559 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 2560 :     if (PyDateTime_Check(left) || PyDateTime_Check(right))

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyDateTime_DateTimeType
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	48 3b ce	 cmp	 rcx, rsi
  00023	0f 84 c0 00 00
	00		 je	 $LN8@date_add
  00029	48 8b d6	 mov	 rdx, rsi
  0002c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00031	85 c0		 test	 eax, eax
  00033	0f 85 b0 00 00
	00		 jne	 $LN8@date_add
  00039	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003d	48 3b ce	 cmp	 rcx, rsi
  00040	0f 84 a3 00 00
	00		 je	 $LN8@date_add
  00046	48 8b d6	 mov	 rdx, rsi
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 93 00 00
	00		 jne	 $LN8@date_add

; 2562 : 
; 2563 :     if (PyDate_Check(left)) {

  00056	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00061	48 3b ca	 cmp	 rcx, rdx
  00064	74 3f		 je	 SHORT $LN6@date_add
  00066	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006b	85 c0		 test	 eax, eax
  0006d	75 36		 jne	 SHORT $LN6@date_add

; 2570 :     }
; 2571 :     else {
; 2572 :         /* ??? + date
; 2573 :          * 'right' must be one of us, or we wouldn't have been called
; 2574 :          */
; 2575 :         if (PyDelta_Check(left))

  0006f	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0007a	48 3b ca	 cmp	 rcx, rdx
  0007d	74 09		 je	 SHORT $LN1@date_add
  0007f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00084	85 c0		 test	 eax, eax
  00086	74 36		 je	 SHORT $LN5@date_add
$LN1@date_add:

; 2576 :             /* delta + date */
; 2577 :             return add_date_timedelta((PyDateTime_Date *) right,
; 2578 :                                       (PyDateTime_Delta *) left,
; 2579 :                                       0);

  00088	45 33 c0	 xor	 r8d, r8d
  0008b	48 8b d3	 mov	 rdx, rbx
  0008e	48 8b cf	 mov	 rcx, rdi

; 2582 : }

  00091	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00096	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0009b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009f	5f		 pop	 rdi
  000a0	e9 00 00 00 00	 jmp	 add_date_timedelta
$LN6@date_add:

; 2564 :         /* date + ??? */
; 2565 :         if (PyDelta_Check(right))

  000a5	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000b0	48 3b ca	 cmp	 rcx, rdx
  000b3	74 17		 je	 SHORT $LN4@date_add
  000b5	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ba	85 c0		 test	 eax, eax
  000bc	75 0e		 jne	 SHORT $LN4@date_add
$LN5@date_add:

; 2580 :     }
; 2581 :     Py_RETURN_NOTIMPLEMENTED;

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c5	e8 00 00 00 00	 call	 _Py_IncRef
  000ca	eb 62		 jmp	 SHORT $LN14@date_add
$LN4@date_add:

; 2566 :             /* date + delta */
; 2567 :             return add_date_timedelta((PyDateTime_Date *) left,
; 2568 :                                       (PyDateTime_Delta *) right,
; 2569 :                                       0);

  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	48 8b d7	 mov	 rdx, rdi
  000d2	48 8b cb	 mov	 rcx, rbx

; 2582 : }

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	e9 00 00 00 00	 jmp	 add_date_timedelta
$LN8@date_add:

; 2561 :         Py_RETURN_NOTIMPLEMENTED;

  000e9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ee	85 c0		 test	 eax, eax
  000f0	75 3c		 jne	 SHORT $LN14@date_add
  000f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00107	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0010d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00115	e8 00 00 00 00	 call	 _PyParallel_Guard
  0011a	85 c0		 test	 eax, eax
  0011c	75 09		 jne	 SHORT $LN13@date_add
  0011e	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00125	74 07		 je	 SHORT $LN14@date_add
$LN13@date_add:
  00127	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN14@date_add:

; 2582 : }

  0012e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00133	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00138	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0013f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00143	5f		 pop	 rdi
  00144	c3		 ret	 0
date_add ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$date_subtract DD imagerel date_subtract
	DD	imagerel date_subtract+407
	DD	imagerel $unwind$date_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_subtract DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT date_subtract
_TEXT	SEGMENT
left$ = 64
right$ = 72
date_subtract PROC					; COMDAT

; 2586 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 2587 :     if (PyDateTime_Check(left) || PyDateTime_Check(right))

  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyDateTime_DateTimeType
  0001d	48 8b fa	 mov	 rdi, rdx
  00020	48 3b ce	 cmp	 rcx, rsi
  00023	0f 84 12 01 00
	00		 je	 $LN7@date_subtr
  00029	48 8b d6	 mov	 rdx, rsi
  0002c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00031	85 c0		 test	 eax, eax
  00033	0f 85 02 01 00
	00		 jne	 $LN7@date_subtr
  00039	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0003d	48 3b ce	 cmp	 rcx, rsi
  00040	0f 84 f5 00 00
	00		 je	 $LN7@date_subtr
  00046	48 8b d6	 mov	 rdx, rsi
  00049	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 e5 00 00
	00		 jne	 $LN7@date_subtr

; 2589 : 
; 2590 :     if (PyDate_Check(left)) {

  00056	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0005a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:PyDateTime_DateType
  00061	48 3b ce	 cmp	 rcx, rsi
  00064	74 0c		 je	 SHORT $LN5@date_subtr
  00066	48 8b d6	 mov	 rdx, rsi
  00069	e8 00 00 00 00	 call	 PyType_IsSubtype
  0006e	85 c0		 test	 eax, eax
  00070	74 31		 je	 SHORT $LN2@date_subtr
$LN5@date_subtr:

; 2591 :         if (PyDate_Check(right)) {

  00072	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  00076	48 3b ce	 cmp	 rcx, rsi
  00079	74 59		 je	 SHORT $LN3@date_subtr
  0007b	48 8b d6	 mov	 rdx, rsi
  0007e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00083	85 c0		 test	 eax, eax
  00085	75 4d		 jne	 SHORT $LN3@date_subtr

; 2600 :         }
; 2601 :         if (PyDelta_Check(right)) {

  00087	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00092	48 3b c8	 cmp	 rcx, rax
  00095	74 1d		 je	 SHORT $LN1@date_subtr
  00097	48 8b d0	 mov	 rdx, rax
  0009a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009f	85 c0		 test	 eax, eax
  000a1	75 11		 jne	 SHORT $LN1@date_subtr
$LN2@date_subtr:

; 2606 :         }
; 2607 :     }
; 2608 :     Py_RETURN_NOTIMPLEMENTED;

  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000aa	e8 00 00 00 00	 call	 _Py_IncRef
  000af	e9 cc 00 00 00	 jmp	 $LN13@date_subtr
$LN1@date_subtr:

; 2602 :             /* date - delta */
; 2603 :             return add_date_timedelta((PyDateTime_Date *) left,
; 2604 :                                       (PyDateTime_Delta *) right,
; 2605 :                                       1);

  000b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ba	48 8b d7	 mov	 rdx, rdi
  000bd	48 8b cb	 mov	 rcx, rbx

; 2609 : }

  000c0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c5	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5f		 pop	 rdi
  000cf	e9 00 00 00 00	 jmp	 add_date_timedelta
$LN3@date_subtr:

; 2592 :             /* date - date */
; 2593 :             int left_ord = ymd_to_ord(GET_YEAR(left),
; 2594 :                                       GET_MONTH(left),
; 2595 :                                       GET_DAY(left));

  000d4	0f b6 4b 69	 movzx	 ecx, BYTE PTR [rbx+105]
  000d8	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  000dc	44 0f b6 43 6c	 movzx	 r8d, BYTE PTR [rbx+108]
  000e1	0f b6 53 6b	 movzx	 edx, BYTE PTR [rbx+107]
  000e5	c1 e1 08	 shl	 ecx, 8
  000e8	0b c8		 or	 ecx, eax
  000ea	e8 00 00 00 00	 call	 ymd_to_ord

; 2596 :             int right_ord = ymd_to_ord(GET_YEAR(right),
; 2597 :                                        GET_MONTH(right),
; 2598 :                                        GET_DAY(right));

  000ef	0f b6 4f 69	 movzx	 ecx, BYTE PTR [rdi+105]
  000f3	44 0f b6 4f 6a	 movzx	 r9d, BYTE PTR [rdi+106]
  000f8	44 0f b6 47 6c	 movzx	 r8d, BYTE PTR [rdi+108]
  000fd	0f b6 57 6b	 movzx	 edx, BYTE PTR [rdi+107]
  00101	c1 e1 08	 shl	 ecx, 8
  00104	41 0b c9	 or	 ecx, r9d
  00107	8b d8		 mov	 ebx, eax
  00109	e8 00 00 00 00	 call	 ymd_to_ord

; 2599 :             return new_delta(left_ord - right_ord, 0, 0, 0);

  0010e	45 33 c9	 xor	 r9d, r9d
  00111	45 33 c0	 xor	 r8d, r8d
  00114	2b d8		 sub	 ebx, eax
  00116	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0011d	33 d2		 xor	 edx, edx
  0011f	8b cb		 mov	 ecx, ebx
  00121	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00126	e8 00 00 00 00	 call	 new_delta_ex

; 2609 : }

  0012b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00130	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00135	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00139	5f		 pop	 rdi
  0013a	c3		 ret	 0
$LN7@date_subtr:

; 2588 :         Py_RETURN_NOTIMPLEMENTED;

  0013b	e8 00 00 00 00	 call	 _Py_PXCTX
  00140	85 c0		 test	 eax, eax
  00142	75 3c		 jne	 SHORT $LN13@date_subtr
  00144	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00159	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0015f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00167	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016c	85 c0		 test	 eax, eax
  0016e	75 09		 jne	 SHORT $LN12@date_subtr
  00170	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  00177	74 07		 je	 SHORT $LN13@date_subtr
$LN12@date_subtr:
  00179	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN13@date_subtr:

; 2609 : }

  00180	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00185	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00191	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00195	5f		 pop	 rdi
  00196	c3		 ret	 0
date_subtract ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_repr DD imagerel date_repr
	DD	imagerel date_repr+60
	DD	imagerel $unwind$date_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_repr DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_repr
_TEXT	SEGMENT
self$ = 64
date_repr PROC						; COMDAT

; 2616 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2617 :     return PyUnicode_FromFormat("%s(%d, %d, %d)",
; 2618 :                                 Py_TYPE(self)->tp_name,
; 2619 :                                 GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00004	48 8b 51 58	 mov	 rdx, QWORD PTR [rcx+88]
  00008	44 0f b6 41 69	 movzx	 r8d, BYTE PTR [rcx+105]
  0000d	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00011	44 0f b6 51 6c	 movzx	 r10d, BYTE PTR [rcx+108]
  00016	44 0f b6 49 6b	 movzx	 r9d, BYTE PTR [rcx+107]
  0001b	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0001f	41 c1 e0 08	 shl	 r8d, 8
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  0002a	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  0002f	44 0b c0	 or	 r8d, eax
  00032	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2620 : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
date_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@ ; `string'
;	COMDAT ??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@ DB '%04d-%02d-%02d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_isoformat
_TEXT	SEGMENT
self$ = 8
date_isoformat PROC					; COMDAT

; 2625 :     return PyUnicode_FromFormat("%04d-%02d-%02d",
; 2626 :                                 GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00000	0f b6 51 69	 movzx	 edx, BYTE PTR [rcx+105]
  00004	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00008	44 0f b6 49 6c	 movzx	 r9d, BYTE PTR [rcx+108]
  0000d	44 0f b6 41 6b	 movzx	 r8d, BYTE PTR [rcx+107]
  00012	c1 e2 08	 shl	 edx, 8
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@
  0001c	0b d0		 or	 edx, eax

; 2627 : }

  0001e	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
date_isoformat ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT date_str
_TEXT	SEGMENT
self$ = 8
date_str PROC						; COMDAT

; 2633 :     _Py_IDENTIFIER(isoformat);
; 2634 : 
; 2635 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "()");

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_isoformat@?1??date_str@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 2636 : }

  00020	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId
date_str ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT date_ctime
_TEXT	SEGMENT
self$ = 8
date_ctime PROC						; COMDAT

; 2642 :     return format_ctime(self, 0, 0, 0);

  00000	45 33 c9	 xor	 r9d, r9d
  00003	45 33 c0	 xor	 r8d, r8d
  00006	33 d2		 xor	 edx, edx

; 2643 : }

  00008	e9 00 00 00 00	 jmp	 format_ctime
date_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	PyObject_Str:PROC
EXTRN	PyUnicode_GetLength:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_format DD imagerel date_format
	DD	imagerel date_format+123
	DD	imagerel $unwind$date_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_format DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_format
_TEXT	SEGMENT
self$ = 48
args$ = 56
format$ = 64
date_format PROC					; COMDAT

; 2672 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 2673 :     PyObject *format;
; 2674 :     _Py_IDENTIFIER(strftime);
; 2675 : 
; 2676 :     if (!PyArg_ParseTuple(args, "U:__format__", &format))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR format$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	75 08		 jne	 SHORT $LN2@date_forma

; 2677 :         return NULL;

  00024	33 c0		 xor	 eax, eax

; 2684 : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
$LN2@date_forma:

; 2678 : 
; 2679 :     /* if the format is zero length, return str(self) */
; 2680 :     if (PyUnicode_GetLength(format) == 0)

  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR format$[rsp]
  00031	e8 00 00 00 00	 call	 PyUnicode_GetLength
  00036	48 85 c0	 test	 rax, rax
  00039	75 0e		 jne	 SHORT $LN1@date_forma

; 2681 :         return PyObject_Str((PyObject *)self);

  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	e8 00 00 00 00	 call	 PyObject_Str

; 2684 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
$LN1@date_forma:

; 2682 : 
; 2683 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_strftime, "O", format);

  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00058	4c 8b 4c 24 40	 mov	 r9, QWORD PTR format$[rsp]
  0005d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_strftime@?1??date_format@@9@9
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  00069	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 2684 : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
date_format ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_isoweekday DD imagerel date_isoweekday
	DD	imagerel date_isoweekday+43
	DD	imagerel $unwind$date_isoweekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_isoweekday DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_isoweekday
_TEXT	SEGMENT
self$ = 48
date_isoweekday PROC					; COMDAT

; 2690 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2691 :     int dow = weekday(GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00004	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00008	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0000d	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00011	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]
  00015	c1 e1 08	 shl	 ecx, 8
  00018	0b c8		 or	 ecx, eax
  0001a	e8 00 00 00 00	 call	 weekday

; 2692 : 
; 2693 :     return PyLong_FromLong(dow + 1);

  0001f	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]

; 2694 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_isoweekday ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_isocalendar DD imagerel date_isocalendar
	DD	imagerel date_isocalendar+118
	DD	imagerel $unwind$date_isocalendar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$date_isocalendar DD imagerel date_isocalendar+118
	DD	imagerel date_isocalendar+141
	DD	imagerel $chain$0$date_isocalendar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$date_isocalendar DD imagerel date_isocalendar+141
	DD	imagerel date_isocalendar+182
	DD	imagerel $chain$1$date_isocalendar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$date_isocalendar DD 021H
	DD	imagerel date_isocalendar
	DD	imagerel date_isocalendar+118
	DD	imagerel $unwind$date_isocalendar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$date_isocalendar DD 020521H
	DD	076405H
	DD	imagerel date_isocalendar
	DD	imagerel date_isocalendar+118
	DD	imagerel $unwind$date_isocalendar
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_isocalendar DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_isocalendar
_TEXT	SEGMENT
day$ = 48
self$ = 48
date_isocalendar PROC					; COMDAT

; 2698 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2699 :     int  year         = GET_YEAR(self);

  0000f	0f b6 59 69	 movzx	 ebx, BYTE PTR [rcx+105]
  00013	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]

; 2700 :     int  week1_monday = iso_week1_monday(year);
; 2701 :     int today         = ymd_to_ord(year, GET_MONTH(self), GET_DAY(self));

  00017	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0001c	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00020	c1 e3 08	 shl	 ebx, 8
  00023	0b d8		 or	 ebx, eax
  00025	8b cb		 mov	 ecx, ebx
  00027	e8 00 00 00 00	 call	 ymd_to_ord
  0002c	8b cb		 mov	 ecx, ebx
  0002e	8b e8		 mov	 ebp, eax
  00030	e8 00 00 00 00	 call	 iso_week1_monday

; 2702 :     int  week;
; 2703 :     int  day;
; 2704 : 
; 2705 :     week = divmod(today - week1_monday, 7, &day);

  00035	8b cd		 mov	 ecx, ebp
  00037	4c 8d 44 24 30	 lea	 r8, QWORD PTR day$[rsp]
  0003c	ba 07 00 00 00	 mov	 edx, 7
  00041	2b c8		 sub	 ecx, eax
  00043	e8 00 00 00 00	 call	 divmod
  00048	8b f8		 mov	 edi, eax

; 2706 :     if (week < 0) {

  0004a	85 c0		 test	 eax, eax
  0004c	79 20		 jns	 SHORT $LN3@date_isoca

; 2707 :         --year;

  0004e	ff cb		 dec	 ebx

; 2708 :         week1_monday = iso_week1_monday(year);

  00050	8b cb		 mov	 ecx, ebx
  00052	e8 00 00 00 00	 call	 iso_week1_monday

; 2709 :         week = divmod(today - week1_monday, 7, &day);

  00057	4c 8d 44 24 30	 lea	 r8, QWORD PTR day$[rsp]
  0005c	ba 07 00 00 00	 mov	 edx, 7
  00061	2b e8		 sub	 ebp, eax
  00063	8b cd		 mov	 ecx, ebp
  00065	e8 00 00 00 00	 call	 divmod
  0006a	8b f8		 mov	 edi, eax
  0006c	eb 1f		 jmp	 SHORT $LN1@date_isoca
$LN3@date_isoca:

; 2710 :     }
; 2711 :     else if (week >= 52 && today >= iso_week1_monday(year + 1)) {

  0006e	83 f8 34	 cmp	 eax, 52			; 00000034H
  00071	7c 1a		 jl	 SHORT $LN1@date_isoca
  00073	8d 4b 01	 lea	 ecx, DWORD PTR [rbx+1]
  00076	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0007b	e8 00 00 00 00	 call	 iso_week1_monday
  00080	3b e8		 cmp	 ebp, eax
  00082	7c 04		 jl	 SHORT $LN6@date_isoca

; 2712 :         ++year;

  00084	ff c3		 inc	 ebx

; 2713 :         week = 0;

  00086	33 ff		 xor	 edi, edi
$LN6@date_isoca:
  00088	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN1@date_isoca:

; 2714 :     }
; 2715 :     return Py_BuildValue("iii", year, week + 1, day + 1);

  0008d	44 8b 4c 24 30	 mov	 r9d, DWORD PTR day$[rsp]
  00092	44 8d 47 01	 lea	 r8d, DWORD PTR [rdi+1]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0009d	41 ff c1	 inc	 r9d
  000a0	8b d3		 mov	 edx, ebx

; 2716 : }

  000a2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a7	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 Py_BuildValue
date_isocalendar ENDP
_TEXT	ENDS
EXTRN	memcmp:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$date_richcompare DD imagerel date_richcompare
	DD	imagerel date_richcompare+184
	DD	imagerel $unwind$date_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_richcompare DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT date_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
date_richcompare PROC					; COMDAT

; 2722 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b f1	 mov	 rsi, rcx

; 2723 :     if (PyDate_Check(other)) {

  00012	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00020	41 8b f8	 mov	 edi, r8d
  00023	48 3b ca	 cmp	 rcx, rdx
  00026	74 65		 je	 SHORT $LN2@date_richc
  00028	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002d	85 c0		 test	 eax, eax
  0002f	75 5c		 jne	 SHORT $LN2@date_richc

; 2728 :     }
; 2729 :     else
; 2730 :         Py_RETURN_NOTIMPLEMENTED;

  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	75 3c		 jne	 SHORT $LN7@date_richc
  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00055	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00062	85 c0		 test	 eax, eax
  00064	75 09		 jne	 SHORT $LN6@date_richc
  00066	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0006d	74 07		 je	 SHORT $LN7@date_richc
$LN6@date_richc:
  0006f	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN7@date_richc:
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 2731 : }

  0007d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN2@date_richc:

; 2724 :         int diff = memcmp(((PyDateTime_Date *)self)->data,
; 2725 :                           ((PyDateTime_Date *)other)->data,
; 2726 :                           _PyDateTime_DATE_DATASIZE);

  0008d	48 8d 53 69	 lea	 rdx, QWORD PTR [rbx+105]
  00091	48 8d 4e 69	 lea	 rcx, QWORD PTR [rsi+105]
  00095	41 b8 04 00 00
	00		 mov	 r8d, 4
  0009b	e8 00 00 00 00	 call	 memcmp

; 2727 :         return diff_to_bool(diff, op);

  000a0	8b d7		 mov	 edx, edi
  000a2	8b c8		 mov	 ecx, eax

; 2731 : }

  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ae	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b2	5f		 pop	 rdi
  000b3	e9 00 00 00 00	 jmp	 diff_to_bool
date_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_timetuple DD imagerel date_timetuple
	DD	imagerel date_timetuple+60
	DD	imagerel $unwind$date_timetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_timetuple DD 010401H
	DD	08204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_timetuple
_TEXT	SEGMENT
self$ = 80
date_timetuple PROC					; COMDAT

; 2735 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2736 :     return build_struct_time(GET_YEAR(self),
; 2737 :                              GET_MONTH(self),
; 2738 :                              GET_DAY(self),
; 2739 :                              0, 0, 0, -1);

  00004	44 0f b6 51 69	 movzx	 r10d, BYTE PTR [rcx+105]
  00009	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0000e	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00012	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00016	33 c0		 xor	 eax, eax
  00018	41 c1 e2 08	 shl	 r10d, 8
  0001c	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR [rsp+48], -1
  00024	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00028	45 33 c9	 xor	 r9d, r9d
  0002b	41 0b ca	 or	 ecx, r10d
  0002e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00032	e8 00 00 00 00	 call	 build_struct_time

; 2740 : }

  00037	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003b	c3		 ret	 0
date_timetuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_replace DD imagerel date_replace
	DD	imagerel date_replace+140
	DD	imagerel $unwind$date_replace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$date_replace DD imagerel date_replace+140
	DD	imagerel date_replace+169
	DD	imagerel $chain$0$date_replace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$date_replace DD imagerel date_replace+169
	DD	imagerel date_replace+209
	DD	imagerel $chain$2$date_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$date_replace DD 020021H
	DD	0d7400H
	DD	imagerel date_replace
	DD	imagerel date_replace+140
	DD	imagerel $unwind$date_replace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$date_replace DD 020521H
	DD	0d7405H
	DD	imagerel date_replace
	DD	imagerel date_replace+140
	DD	imagerel $unwind$date_replace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_replace DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT ??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@
CONST	SEGMENT
??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@ DB '|iii:replace', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_replace
_TEXT	SEGMENT
year$ = 64
day$ = 96
self$ = 96
args$ = 104
kw$ = 112
month$ = 120
date_replace PROC					; COMDAT

; 2744 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2745 :     PyObject *clone;
; 2746 :     PyObject *tuple;
; 2747 :     int year = GET_YEAR(self);

  00006	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  0000a	44 0f b6 49 69	 movzx	 r9d, BYTE PTR [rcx+105]
  0000f	4d 8b d0	 mov	 r10, r8
  00012	41 c1 e1 08	 shl	 r9d, 8
  00016	4c 8b da	 mov	 r11, rdx
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	44 0b c8	 or	 r9d, eax

; 2748 :     int month = GET_MONTH(self);

  0001f	0f b6 41 6b	 movzx	 eax, BYTE PTR [rcx+107]

; 2749 :     int day = GET_DAY(self);
; 2750 : 
; 2751 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iii:replace", date_kws,
; 2752 :                                       &year, &month, &day))

  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@
  0002a	89 44 24 78	 mov	 DWORD PTR month$[rsp], eax
  0002e	0f b6 41 6c	 movzx	 eax, BYTE PTR [rcx+108]
  00032	44 89 4c 24 40	 mov	 DWORD PTR year$[rsp], r9d
  00037	89 44 24 60	 mov	 DWORD PTR day$[rsp], eax
  0003b	48 8d 44 24 60	 lea	 rax, QWORD PTR day$[rsp]
  00040	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:date_kws
  00047	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004c	48 8d 44 24 78	 lea	 rax, QWORD PTR month$[rsp]
  00051	49 8b d2	 mov	 rdx, r10
  00054	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00059	48 8d 44 24 40	 lea	 rax, QWORD PTR year$[rsp]
  0005e	49 8b cb	 mov	 rcx, r11
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0006b	85 c0		 test	 eax, eax
  0006d	75 08		 jne	 SHORT $LN2@date_repla

; 2753 :         return NULL;

  0006f	33 c0		 xor	 eax, eax

; 2760 : }

  00071	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
$LN2@date_repla:

; 2754 :     tuple = Py_BuildValue("iii", year, month, day);

  00077	44 8b 4c 24 60	 mov	 r9d, DWORD PTR day$[rsp]
  0007c	44 8b 44 24 78	 mov	 r8d, DWORD PTR month$[rsp]
  00081	8b 54 24 40	 mov	 edx, DWORD PTR year$[rsp]
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0008c	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00091	e8 00 00 00 00	 call	 Py_BuildValue
  00096	48 8b f8	 mov	 rdi, rax

; 2755 :     if (tuple == NULL)

  00099	48 85 c0	 test	 rax, rax
  0009c	75 0b		 jne	 SHORT $LN1@date_repla
  0009e	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 2760 : }

  000a3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
$LN1@date_repla:

; 2756 :         return NULL;
; 2757 :     clone = date_new(Py_TYPE(self), tuple, NULL);

  000a9	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  000ad	45 33 c0	 xor	 r8d, r8d
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	e8 00 00 00 00	 call	 date_new

; 2758 :     Py_DECREF(tuple);

  000b8	48 8b cf	 mov	 rcx, rdi
  000bb	48 8b d8	 mov	 rbx, rax
  000be	e8 00 00 00 00	 call	 _Py_DecRef
  000c3	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]

; 2759 :     return clone;

  000c8	48 8b c3	 mov	 rax, rbx

; 2760 : }

  000cb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000cf	5b		 pop	 rbx
  000d0	c3		 ret	 0
date_replace ENDP
_TEXT	ENDS
EXTRN	_Py_HashBytes:PROC
; Function compile flags: /Ogtpy
;	COMDAT generic_hash
_TEXT	SEGMENT
data$ = 8
len$ = 16
generic_hash PROC					; COMDAT

; 2765 :     return _Py_HashBytes(data, len);

  00000	48 63 d2	 movsxd	 rdx, edx

; 2766 : }

  00003	e9 00 00 00 00	 jmp	 _Py_HashBytes
generic_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_hash DD imagerel date_hash
	DD	imagerel date_hash+50
	DD	imagerel $unwind$date_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_hash DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_hash
_TEXT	SEGMENT
self$ = 48
date_hash PROC						; COMDAT

; 2773 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2774 :     if (self->hashcode == -1)

  00006	48 83 79 60 ff	 cmp	 QWORD PTR [rcx+96], -1
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	75 18		 jne	 SHORT $LN4@date_hash

; 2775 :         self->hashcode = generic_hash(
; 2776 :             (unsigned char *)self->data, _PyDateTime_DATE_DATASIZE);

  00010	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00014	ba 04 00 00 00	 mov	 edx, 4
  00019	e8 00 00 00 00	 call	 generic_hash
  0001e	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 2779 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN4@date_hash:

; 2777 : 
; 2778 :     return self->hashcode;

  00028	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 2779 : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
date_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_toordinal DD imagerel date_toordinal
	DD	imagerel date_toordinal+42
	DD	imagerel $unwind$date_toordinal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_toordinal DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_toordinal
_TEXT	SEGMENT
self$ = 48
date_toordinal PROC					; COMDAT

; 2783 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2784 :     return PyLong_FromLong(ymd_to_ord(GET_YEAR(self), GET_MONTH(self),
; 2785 :                                      GET_DAY(self)));

  00004	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00008	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0000d	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00011	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]
  00015	c1 e1 08	 shl	 ecx, 8
  00018	0b c8		 or	 ecx, eax
  0001a	e8 00 00 00 00	 call	 ymd_to_ord
  0001f	8b c8		 mov	 ecx, eax

; 2786 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_toordinal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_weekday DD imagerel date_weekday
	DD	imagerel date_weekday+42
	DD	imagerel $unwind$date_weekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_weekday DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT date_weekday
_TEXT	SEGMENT
self$ = 48
date_weekday PROC					; COMDAT

; 2790 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2791 :     int dow = weekday(GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00004	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00008	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0000d	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00011	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]
  00015	c1 e1 08	 shl	 ecx, 8
  00018	0b c8		 or	 ecx, eax
  0001a	e8 00 00 00 00	 call	 weekday

; 2792 : 
; 2793 :     return PyLong_FromLong(dow);

  0001f	8b c8		 mov	 ecx, eax

; 2794 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	e9 00 00 00 00	 jmp	 PyLong_FromLong
date_weekday ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_getstate DD imagerel date_getstate
	DD	imagerel date_getstate+37
	DD	imagerel $unwind$date_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_getstate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@ DB '(N)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_getstate
_TEXT	SEGMENT
self$ = 48
date_getstate PROC					; COMDAT

; 2801 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2802 :     PyObject* field;
; 2803 :     field = PyBytes_FromStringAndSize((char*)self->data,
; 2804 :                                        _PyDateTime_DATE_DATASIZE);

  00004	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00008	ba 04 00 00 00	 mov	 edx, 4
  0000d	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 2805 :     return Py_BuildValue("(N)", field);

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
  00019	48 8b d0	 mov	 rdx, rax

; 2806 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	e9 00 00 00 00	 jmp	 Py_BuildValue
date_getstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DFFJBLGN@?$CION?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_reduce DD imagerel date_reduce
	DD	imagerel date_reduce+38
	DD	imagerel $unwind$date_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_reduce DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
CONST	SEGMENT
??_C@_04DFFJBLGN@?$CION?$CJ?$AA@ DB '(ON)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
date_reduce PROC					; COMDAT

; 2810 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2811 :     return Py_BuildValue("(ON)", Py_TYPE(self), date_getstate(self));

  00009	e8 00 00 00 00	 call	 date_getstate
  0000e	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  00019	4c 8b c0	 mov	 r8, rax

; 2812 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	e9 00 00 00 00	 jmp	 Py_BuildValue
date_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_nogo DD imagerel tzinfo_nogo
	DD	imagerel tzinfo_nogo+33
	DD	imagerel $unwind$tzinfo_nogo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_nogo DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@
CONST	SEGMENT
??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@ DB 'a tzinfo sub'
	DB	'class must implement %s()', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tzinfo_nogo
_TEXT	SEGMENT
methodname$ = 48
tzinfo_nogo PROC					; COMDAT

; 2951 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2952 :     PyErr_Format(PyExc_NotImplementedError,
; 2953 :                  "a tzinfo subclass must implement %s()",
; 2954 :                  methodname);

  00004	4c 8b c1	 mov	 r8, rcx
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@
  00015	e8 00 00 00 00	 call	 PyErr_Format

; 2955 :     return NULL;

  0001a	33 c0		 xor	 eax, eax

; 2956 : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
tzinfo_nogo ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT tzinfo_tzname
_TEXT	SEGMENT
self$ = 8
dt$ = 16
tzinfo_tzname PROC					; COMDAT

; 2963 :     return tzinfo_nogo("tzname");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CNBAGEMF@tzname?$AA@

; 2964 : }

  00007	e9 00 00 00 00	 jmp	 tzinfo_nogo
tzinfo_tzname ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT tzinfo_utcoffset
_TEXT	SEGMENT
self$ = 8
dt$ = 16
tzinfo_utcoffset PROC					; COMDAT

; 2969 :     return tzinfo_nogo("utcoffset");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@

; 2970 : }

  00007	e9 00 00 00 00	 jmp	 tzinfo_nogo
tzinfo_utcoffset ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT tzinfo_dst
_TEXT	SEGMENT
self$ = 8
dt$ = 16
tzinfo_dst PROC						; COMDAT

; 2975 :     return tzinfo_nogo("dst");

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@

; 2976 : }

  00007	e9 00 00 00 00	 jmp	 tzinfo_nogo
tzinfo_dst ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@		; `string'
EXTRN	PyDict_Size:PROC
EXTRN	_PyObject_GetDictPtr:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyObject_CallObject:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$tzinfo_reduce DD imagerel tzinfo_reduce
	DD	imagerel tzinfo_reduce+209
	DD	imagerel $unwind$tzinfo_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$tzinfo_reduce DD imagerel tzinfo_reduce+209
	DD	imagerel tzinfo_reduce+408
	DD	imagerel $chain$3$tzinfo_reduce
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$tzinfo_reduce DD imagerel tzinfo_reduce+408
	DD	imagerel tzinfo_reduce+431
	DD	imagerel $chain$4$tzinfo_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$tzinfo_reduce DD 021H
	DD	imagerel tzinfo_reduce
	DD	imagerel tzinfo_reduce+209
	DD	imagerel $unwind$tzinfo_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$tzinfo_reduce DD 020521H
	DD	06d405H
	DD	imagerel tzinfo_reduce
	DD	imagerel tzinfo_reduce+209
	DD	imagerel $unwind$tzinfo_reduce
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_reduce DD 094f01H
	DD	0c744fH
	DD	0b643bH
	DD	0a5436H
	DD	0c0046208H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@
CONST	SEGMENT
??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@ DB '(ONN)', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT tzinfo_reduce
_TEXT	SEGMENT
self$ = 80
tzinfo_reduce PROC					; COMDAT

; 3067 : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00008	4c 8b e1	 mov	 r12, rcx

; 3068 :     PyObject *args, *state, *tmp;
; 3069 :     PyObject *getinitargs, *getstate;
; 3070 :     _Py_IDENTIFIER(__getinitargs__);
; 3071 :     _Py_IDENTIFIER(__getstate__);
; 3072 : 
; 3073 :     tmp = PyTuple_New(0);

  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 PyTuple_New
  00012	48 8b d8	 mov	 rbx, rax

; 3074 :     if (tmp == NULL)

  00015	48 85 c0	 test	 rax, rax
  00018	75 08		 jne	 SHORT $LN10@tzinfo_red

; 3120 : }

  0001a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001e	41 5c		 pop	 r12
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN10@tzinfo_red:

; 3075 :         return NULL;
; 3076 : 
; 3077 :     getinitargs = _PyObject_GetAttrId(self, &PyId___getinitargs__);

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00028	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00031	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00036	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0003b	48 8b 34 c8	 mov	 rsi, QWORD PTR [rax+rcx*8]
  0003f	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getinitargs__@?1??tzinfo_reduce@@9@9
  00044	48 03 d6	 add	 rdx, rsi
  00047	49 8b cc	 mov	 rcx, r12
  0004a	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0004f	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00054	48 8b f8	 mov	 rdi, rax

; 3078 :     if (getinitargs != NULL) {

  00057	48 85 c0	 test	 rax, rax
  0005a	74 2a		 je	 SHORT $LN9@tzinfo_red

; 3079 :         args = PyObject_CallObject(getinitargs, tmp);

  0005c	48 8b d3	 mov	 rdx, rbx
  0005f	48 8b c8	 mov	 rcx, rax
  00062	e8 00 00 00 00	 call	 PyObject_CallObject

; 3080 :         Py_DECREF(getinitargs);

  00067	48 8b cf	 mov	 rcx, rdi
  0006a	48 8b e8	 mov	 rbp, rax
  0006d	e8 00 00 00 00	 call	 _Py_DecRef

; 3081 :         if (args == NULL) {

  00072	48 85 ed	 test	 rbp, rbp
  00075	75 52		 jne	 SHORT $LN14@tzinfo_red

; 3082 :             Py_DECREF(tmp);

  00077	48 8b cb	 mov	 rcx, rbx
  0007a	e8 00 00 00 00	 call	 _Py_DecRef

; 3083 :             return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 12 01 00 00	 jmp	 $LN19@tzinfo_red
$LN9@tzinfo_red:

; 3084 :         }
; 3085 :     }
; 3086 :     else {
; 3087 :         PyErr_Clear();

  00086	e8 00 00 00 00	 call	 PyErr_Clear

; 3088 :         args = tmp;

  0008b	48 8b eb	 mov	 rbp, rbx

; 3089 :         Py_INCREF(args);

  0008e	e8 00 00 00 00	 call	 _Py_PXCTX
  00093	85 c0		 test	 eax, eax
  00095	75 32		 jne	 SHORT $LN14@tzinfo_red
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000a5	4c 8b cb	 mov	 r9, rbx
  000a8	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ae	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000bb	85 c0		 test	 eax, eax
  000bd	75 06		 jne	 SHORT $LN13@tzinfo_red
  000bf	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000c3	74 04		 je	 SHORT $LN14@tzinfo_red
$LN13@tzinfo_red:
  000c5	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN14@tzinfo_red:

; 3090 :     }
; 3091 : 
; 3092 :     getstate = _PyObject_GetAttrId(self, &PyId___getstate__);

  000c9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___getstate__@?1??tzinfo_reduce@@9@9
  000ce	49 8b cc	 mov	 rcx, r12
  000d1	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  000d6	48 03 d6	 add	 rdx, rsi
  000d9	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 3093 :     if (getstate != NULL) {

  000de	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  000e5	48 8b f0	 mov	 rsi, rax
  000e8	48 85 c0	 test	 rax, rax
  000eb	74 2f		 je	 SHORT $LN6@tzinfo_red

; 3094 :         state = PyObject_CallObject(getstate, tmp);

  000ed	48 8b d3	 mov	 rdx, rbx
  000f0	48 8b c8	 mov	 rcx, rax
  000f3	e8 00 00 00 00	 call	 PyObject_CallObject

; 3095 :         Py_DECREF(getstate);

  000f8	48 8b ce	 mov	 rcx, rsi
  000fb	48 8b f8	 mov	 rdi, rax
  000fe	e8 00 00 00 00	 call	 _Py_DecRef

; 3096 :         if (state == NULL) {

  00103	48 85 ff	 test	 rdi, rdi
  00106	75 49		 jne	 SHORT $LN4@tzinfo_red

; 3097 :             Py_DECREF(args);

  00108	48 8b cd	 mov	 rcx, rbp
  0010b	e8 00 00 00 00	 call	 _Py_DecRef

; 3098 :             Py_DECREF(tmp);

  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 _Py_DecRef

; 3099 :             return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	eb 77		 jmp	 SHORT $LN20@tzinfo_red
$LN6@tzinfo_red:

; 3100 :         }
; 3101 :     }
; 3102 :     else {
; 3103 :         PyObject **dictptr;
; 3104 :         PyErr_Clear();

  0011c	e8 00 00 00 00	 call	 PyErr_Clear

; 3105 :         state = Py_None;
; 3106 :         dictptr = _PyObject_GetDictPtr(self);

  00121	49 8b cc	 mov	 rcx, r12
  00124	49 8b fd	 mov	 rdi, r13
  00127	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  0012c	48 8b f0	 mov	 rsi, rax

; 3107 :         if (dictptr && *dictptr && PyDict_Size(*dictptr))

  0012f	48 85 c0	 test	 rax, rax
  00132	74 15		 je	 SHORT $LN3@tzinfo_red
  00134	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00137	48 85 c9	 test	 rcx, rcx
  0013a	74 0d		 je	 SHORT $LN3@tzinfo_red
  0013c	e8 00 00 00 00	 call	 PyDict_Size
  00141	48 85 c0	 test	 rax, rax
  00144	74 03		 je	 SHORT $LN3@tzinfo_red

; 3108 :             state = *dictptr;

  00146	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]
$LN3@tzinfo_red:

; 3109 :         Py_INCREF(state);

  00149	48 8b cf	 mov	 rcx, rdi
  0014c	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@tzinfo_red:

; 3110 :     }
; 3111 : 
; 3112 :     Py_DECREF(tmp);

  00151	48 8b cb	 mov	 rcx, rbx
  00154	e8 00 00 00 00	 call	 _Py_DecRef

; 3113 : 
; 3114 :     if (state == Py_None) {

  00159	49 3b fd	 cmp	 rdi, r13
  0015c	75 1e		 jne	 SHORT $LN2@tzinfo_red

; 3115 :         Py_DECREF(state);

  0015e	48 8b cf	 mov	 rcx, rdi
  00161	e8 00 00 00 00	 call	 _Py_DecRef

; 3116 :         return Py_BuildValue("(ON)", Py_TYPE(self), args);

  00166	49 8b 54 24 58	 mov	 rdx, QWORD PTR [r12+88]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  00172	4c 8b c5	 mov	 r8, rbp
  00175	e8 00 00 00 00	 call	 Py_BuildValue
  0017a	eb 17		 jmp	 SHORT $LN20@tzinfo_red
$LN2@tzinfo_red:

; 3117 :     }
; 3118 :     else
; 3119 :         return Py_BuildValue("(ONN)", Py_TYPE(self), args, state);

  0017c	49 8b 54 24 58	 mov	 rdx, QWORD PTR [r12+88]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@
  00188	4c 8b cf	 mov	 r9, rdi
  0018b	4c 8b c5	 mov	 r8, rbp
  0018e	e8 00 00 00 00	 call	 Py_BuildValue
$LN20@tzinfo_red:
  00193	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
$LN19@tzinfo_red:
  00198	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0019d	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  001a2	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 3120 : }

  001a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ab	41 5c		 pop	 r12
  001ad	5b		 pop	 rbx
  001ae	c3		 ret	 0
tzinfo_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@	; `string'
PUBLIC	??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$timezone_dealloc DD imagerel timezone_dealloc
	DD	imagerel timezone_dealloc+363
	DD	imagerel $unwind$timezone_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_dealloc DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
CONST	SEGMENT
??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@ DB 'timezone_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
CONST	SEGMENT
??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@ DB '..\Modules\'
	DB	'_datetimemodule.c', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT timezone_dealloc
_TEXT	SEGMENT
self$ = 64
timezone_dealloc PROC					; COMDAT

; 3205 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3206 :     Py_CLEAR(self->offset);

  0000a	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	4d 85 c9	 test	 r9, r9
  00014	0f 84 96 00 00
	00		 je	 $LN7@timezone_d
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
  00028	41 b8 86 0c 00
	00		 mov	 r8d, 3206		; 00000c86H
  0002e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00036	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003b	85 c0		 test	 eax, eax
  0003d	75 71		 jne	 SHORT $LN7@timezone_d
  0003f	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00043	48 c7 47 60 00
	00 00 00	 mov	 QWORD PTR [rdi+96], 0
  0004b	e8 00 00 00 00	 call	 _Py_PXCTX
  00050	85 c0		 test	 eax, eax
  00052	75 5c		 jne	 SHORT $LN7@timezone_d
  00054	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00058	a8 20		 test	 al, 32			; 00000020H
  0005a	75 4c		 jne	 SHORT $LN15@timezone_d
  0005c	84 c0		 test	 al, al
  0005e	78 48		 js	 SHORT $LN15@timezone_d
  00060	a8 02		 test	 al, 2
  00062	75 4c		 jne	 SHORT $LN7@timezone_d
  00064	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00068	75 46		 jne	 SHORT $LN7@timezone_d
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00078	4c 8b cb	 mov	 r9, rbx
  0007b	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00081	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00089	e8 00 00 00 00	 call	 _PyParallel_Guard
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	85 c0		 test	 eax, eax
  00093	74 07		 je	 SHORT $LN20@timezone_d
  00095	e8 00 00 00 00	 call	 _Px_Dealloc
  0009a	eb 14		 jmp	 SHORT $LN7@timezone_d
$LN20@timezone_d:
  0009c	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  000a0	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  000a6	eb 08		 jmp	 SHORT $LN7@timezone_d
$LN15@timezone_d:
  000a8	48 8b cb	 mov	 rcx, rbx
  000ab	e8 00 00 00 00	 call	 Px_DecRef
$LN7@timezone_d:

; 3207 :     Py_CLEAR(self->name);

  000b0	4c 8b 4f 68	 mov	 r9, QWORD PTR [rdi+104]
  000b4	4d 85 c9	 test	 r9, r9
  000b7	0f 84 96 00 00
	00		 je	 $LN3@timezone_d
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
  000cb	41 b8 87 0c 00
	00		 mov	 r8d, 3207		; 00000c87H
  000d1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d9	e8 00 00 00 00	 call	 _PyParallel_Guard
  000de	85 c0		 test	 eax, eax
  000e0	75 71		 jne	 SHORT $LN3@timezone_d
  000e2	48 8b 5f 68	 mov	 rbx, QWORD PTR [rdi+104]
  000e6	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
  000ee	e8 00 00 00 00	 call	 _Py_PXCTX
  000f3	85 c0		 test	 eax, eax
  000f5	75 5c		 jne	 SHORT $LN3@timezone_d
  000f7	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000fb	a8 20		 test	 al, 32			; 00000020H
  000fd	75 4c		 jne	 SHORT $LN26@timezone_d
  000ff	84 c0		 test	 al, al
  00101	78 48		 js	 SHORT $LN26@timezone_d
  00103	a8 02		 test	 al, 2
  00105	75 4c		 jne	 SHORT $LN3@timezone_d
  00107	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0010b	75 46		 jne	 SHORT $LN3@timezone_d
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0011b	4c 8b cb	 mov	 r9, rbx
  0011e	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00124	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0012c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00131	48 8b cb	 mov	 rcx, rbx
  00134	85 c0		 test	 eax, eax
  00136	74 07		 je	 SHORT $LN31@timezone_d
  00138	e8 00 00 00 00	 call	 _Px_Dealloc
  0013d	eb 14		 jmp	 SHORT $LN3@timezone_d
$LN31@timezone_d:
  0013f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00143	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00149	eb 08		 jmp	 SHORT $LN3@timezone_d
$LN26@timezone_d:
  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 Px_DecRef
$LN3@timezone_d:

; 3208 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00153	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00157	48 8b cf	 mov	 rcx, rdi

; 3209 : }

  0015a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0015f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00163	5f		 pop	 rdi
  00164	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
timezone_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$timezone_richcompare DD imagerel timezone_richcompare
	DD	imagerel timezone_richcompare+299
	DD	imagerel $unwind$timezone_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_richcompare DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT timezone_richcompare
_TEXT	SEGMENT
self$ = 64
other$ = 72
op$ = 80
timezone_richcompare PROC				; COMDAT

; 3214 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3215 :     if (op != Py_EQ && op != Py_NE)

  00004	41 83 f8 02	 cmp	 r8d, 2
  00008	74 57		 je	 SHORT $LN4@timezone_r
  0000a	41 83 f8 03	 cmp	 r8d, 3
  0000e	74 51		 je	 SHORT $LN4@timezone_r

; 3216 :         Py_RETURN_NOTIMPLEMENTED;

  00010	e8 00 00 00 00	 call	 _Py_PXCTX
  00015	85 c0		 test	 eax, eax
  00017	75 3c		 jne	 SHORT $LN8@timezone_r
  00019	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002e	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00034	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003c	e8 00 00 00 00	 call	 _PyParallel_Guard
  00041	85 c0		 test	 eax, eax
  00043	75 09		 jne	 SHORT $LN7@timezone_r
  00045	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0004c	74 07		 je	 SHORT $LN8@timezone_r
$LN7@timezone_r:
  0004e	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN8@timezone_r:
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3224 : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
$LN4@timezone_r:

; 3217 :     if (Py_TYPE(other) != &PyDateTime_TimeZoneType) {

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeZoneType
  00068	48 39 42 58	 cmp	 QWORD PTR [rdx+88], rax
  0006c	0f 84 a8 00 00
	00		 je	 $LN1@timezone_r

; 3218 : 	if (op == Py_EQ)

  00072	41 83 f8 02	 cmp	 r8d, 2
  00076	75 51		 jne	 SHORT $LN2@timezone_r

; 3219 : 	    Py_RETURN_FALSE;

  00078	e8 00 00 00 00	 call	 _Py_PXCTX
  0007d	85 c0		 test	 eax, eax
  0007f	75 3c		 jne	 SHORT $LN12@timezone_r
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_FalseStruct
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00096	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0009c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000a4	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a9	85 c0		 test	 eax, eax
  000ab	75 09		 jne	 SHORT $LN11@timezone_r
  000ad	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000b4	74 07		 je	 SHORT $LN12@timezone_r
$LN11@timezone_r:
  000b6	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN12@timezone_r:
  000bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 3224 : }

  000c4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c8	c3		 ret	 0
$LN2@timezone_r:

; 3220 : 	else
; 3221 : 	    Py_RETURN_TRUE;

  000c9	e8 00 00 00 00	 call	 _Py_PXCTX
  000ce	85 c0		 test	 eax, eax
  000d0	75 3c		 jne	 SHORT $LN16@timezone_r
  000d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_TrueStruct
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e7	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000ed	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000f5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fa	85 c0		 test	 eax, eax
  000fc	75 09		 jne	 SHORT $LN15@timezone_r
  000fe	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_TrueStruct+32, 32 ; 00000020H
  00105	74 07		 je	 SHORT $LN16@timezone_r
$LN15@timezone_r:
  00107	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_TrueStruct+80
$LN16@timezone_r:
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 3224 : }

  00115	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00119	c3		 ret	 0
$LN1@timezone_r:

; 3222 :     }
; 3223 :     return delta_richcompare(self->offset, other->offset, op);

  0011a	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  0011e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]

; 3224 : }

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	e9 00 00 00 00	 jmp	 delta_richcompare
timezone_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_timezone_check_argument DD imagerel _timezone_check_argument
	DD	imagerel _timezone_check_argument+110
	DD	imagerel $unwind$_timezone_check_argument
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_timezone_check_argument DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@
CONST	SEGMENT
??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@ DB '%s'
	DB	'(dt) argument must be a datetime instance or None, not %.200s'
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _timezone_check_argument
_TEXT	SEGMENT
dt$ = 48
meth$ = 56
_timezone_check_argument PROC				; COMDAT

; 3238 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3239 :     if (dt == Py_None || PyDateTime_Check(dt))

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8b d9	 mov	 rbx, rcx
  00017	48 3b c8	 cmp	 rcx, rax
  0001a	74 45		 je	 SHORT $LN1@timezone_c
  0001c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00027	48 3b ca	 cmp	 rcx, rdx
  0002a	74 35		 je	 SHORT $LN1@timezone_c
  0002c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00031	85 c0		 test	 eax, eax
  00033	75 2c		 jne	 SHORT $LN1@timezone_c

; 3241 :     PyErr_Format(PyExc_TypeError, "%s(dt) argument must be a datetime instance"
; 3242 :                  " or None, not %.200s", meth, Py_TYPE(dt)->tp_name);

  00035	4c 8b 4b 58	 mov	 r9, QWORD PTR [rbx+88]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@
  00047	4d 8b 49 70	 mov	 r9, QWORD PTR [r9+112]
  0004b	4c 8b c7	 mov	 r8, rdi
  0004e	e8 00 00 00 00	 call	 PyErr_Format

; 3243 :     return -1;

  00053	83 c8 ff	 or	 eax, -1

; 3244 : }

  00056	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
$LN1@timezone_c:

; 3240 :         return 0;

  00061	33 c0		 xor	 eax, eax

; 3244 : }

  00063	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
_timezone_check_argument ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@	; `string'
PUBLIC	??_C@_06ENJIHAPG@?$CFs?4utc?$AA@		; `string'
_BSS	SEGMENT
PyDateTime_TimeZone_UTC DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@ DB '%s(%R, %R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@ DB '%s(%R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENJIHAPG@?$CFs?4utc?$AA@
CONST	SEGMENT
??_C@_06ENJIHAPG@?$CFs?4utc?$AA@ DB '%s.utc', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT timezone_repr
_TEXT	SEGMENT
self$ = 8
timezone_repr PROC					; COMDAT

; 3249 :     /* Note that although timezone is not subclassable, it is convenient
; 3250 :        to use Py_TYPE(self)->tp_name here. */
; 3251 :     const char *type_name = Py_TYPE(self)->tp_name;
; 3252 : 
; 3253 :     if (((PyObject *)self) == PyDateTime_TimeZone_UTC)

  00000	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR PyDateTime_TimeZone_UTC
  00007	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0000b	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0000f	75 0c		 jne	 SHORT $LN2@timezone_r@2

; 3254 :         return PyUnicode_FromFormat("%s.utc", type_name);

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06ENJIHAPG@?$CFs?4utc?$AA@

; 3261 : }

  00018	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN2@timezone_r@2:

; 3255 : 
; 3256 :     if (self->name == NULL)

  0001d	4c 8b 49 68	 mov	 r9, QWORD PTR [rcx+104]

; 3257 :         return PyUnicode_FromFormat("%s(%R)", type_name, self->offset);

  00021	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00025	4d 85 c9	 test	 r9, r9
  00028	75 0c		 jne	 SHORT $LN1@timezone_r@2
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@

; 3261 : }

  00031	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
$LN1@timezone_r@2:

; 3258 : 
; 3259 :     return PyUnicode_FromFormat("%s(%R, %R)", type_name, self->offset,
; 3260 :                                 self->name);

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@

; 3261 : }

  0003d	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
timezone_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$timezone_str DD imagerel timezone_str
	DD	imagerel timezone_str+100
	DD	imagerel $unwind$timezone_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$timezone_str DD imagerel timezone_str+100
	DD	imagerel timezone_str+146
	DD	imagerel $chain$0$timezone_str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$timezone_str DD imagerel timezone_str+146
	DD	imagerel timezone_str+300
	DD	imagerel $chain$2$timezone_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$timezone_str DD 020021H
	DD	096400H
	DD	imagerel timezone_str
	DD	imagerel timezone_str+100
	DD	imagerel $unwind$timezone_str
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$timezone_str DD 020521H
	DD	096405H
	DD	imagerel timezone_str
	DD	imagerel timezone_str+100
	DD	imagerel $unwind$timezone_str
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_str DD 040a01H
	DD	0a340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT ??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@ DB 'UTC%c%02d:%02d', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT timezone_str
_TEXT	SEGMENT
minutes$ = 64
seconds$ = 64
self$ = 64
timezone_str PROC					; COMDAT

; 3266 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3267 :     int hours, minutes, seconds;
; 3268 :     PyObject *offset;
; 3269 :     char sign;
; 3270 : 
; 3271 :     if (self->name != NULL) {

  0000a	48 8b 59 68	 mov	 rbx, QWORD PTR [rcx+104]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 4a		 je	 SHORT $LN4@timezone_s

; 3272 :         Py_INCREF(self->name);

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	75 32		 jne	 SHORT $LN8@timezone_s
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0002d	4c 8b cb	 mov	 r9, rbx
  00030	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00036	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0003e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00043	85 c0		 test	 eax, eax
  00045	75 06		 jne	 SHORT $LN7@timezone_s
  00047	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004b	74 04		 je	 SHORT $LN8@timezone_s
$LN7@timezone_s:
  0004d	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN8@timezone_s:

; 3273 :         return self->name;

  00051	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]

; 3295 : }

  00055	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
$LN4@timezone_s:

; 3274 :     }
; 3275 :     /* Offset is normalized, so it is negative if days < 0 */
; 3276 :     if (GET_TD_DAYS(self->offset) < 0) {

  00060	48 8b 79 60	 mov	 rdi, QWORD PTR [rcx+96]
  00064	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00069	83 7f 68 00	 cmp	 DWORD PTR [rdi+104], 0
  0006d	7d 23		 jge	 SHORT $LN3@timezone_s

; 3277 :         sign = '-';
; 3278 :         offset = delta_negative((PyDateTime_Delta *)self->offset);

  0006f	48 8b cf	 mov	 rcx, rdi
  00072	40 b6 2d	 mov	 sil, 45			; 0000002dH
  00075	e8 00 00 00 00	 call	 delta_negative
  0007a	48 8b f8	 mov	 rdi, rax

; 3279 :         if (offset == NULL)

  0007d	48 85 c0	 test	 rax, rax
  00080	75 4e		 jne	 SHORT $LN12@timezone_s
  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 3295 : }

  00087	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
$LN3@timezone_s:

; 3280 :             return NULL;
; 3281 :     }
; 3282 :     else {
; 3283 :         sign = '+';

  00092	40 b6 2b	 mov	 sil, 43			; 0000002bH

; 3284 :         offset = self->offset;
; 3285 :         Py_INCREF(offset);

  00095	e8 00 00 00 00	 call	 _Py_PXCTX
  0009a	85 c0		 test	 eax, eax
  0009c	75 32		 jne	 SHORT $LN12@timezone_s
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000ac	4c 8b cf	 mov	 r9, rdi
  000af	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c2	85 c0		 test	 eax, eax
  000c4	75 06		 jne	 SHORT $LN11@timezone_s
  000c6	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  000ca	74 04		 je	 SHORT $LN12@timezone_s
$LN11@timezone_s:
  000cc	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN12@timezone_s:

; 3286 :     }
; 3287 :     /* Offset is not negative here. */
; 3288 :     seconds = GET_TD_SECONDS(offset);

  000d0	8b 5f 6c	 mov	 ebx, DWORD PTR [rdi+108]

; 3289 :     Py_DECREF(offset);

  000d3	48 8b cf	 mov	 rcx, rdi
  000d6	89 5c 24 40	 mov	 DWORD PTR seconds$[rsp], ebx
  000da	e8 00 00 00 00	 call	 _Py_DecRef

; 3290 :     minutes = divmod(seconds, 60, &seconds);

  000df	4c 8d 44 24 40	 lea	 r8, QWORD PTR seconds$[rsp]
  000e4	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000e9	8b cb		 mov	 ecx, ebx
  000eb	e8 00 00 00 00	 call	 divmod

; 3291 :     hours = divmod(minutes, 60, &minutes);

  000f0	4c 8d 44 24 40	 lea	 r8, QWORD PTR minutes$[rsp]
  000f5	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000fa	8b c8		 mov	 ecx, eax
  000fc	89 44 24 40	 mov	 DWORD PTR minutes$[rsp], eax
  00100	e8 00 00 00 00	 call	 divmod

; 3292 :     /* XXX ignore sub-minute data, curently not allowed. */
; 3293 :     assert(seconds == 0);
; 3294 :     return PyUnicode_FromFormat("UTC%c%02d:%02d", sign, hours, minutes);

  00105	44 8b 4c 24 40	 mov	 r9d, DWORD PTR minutes$[rsp]
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@
  00111	44 8b c0	 mov	 r8d, eax
  00114	40 0f be d6	 movsx	 edx, sil
  00118	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 3295 : }

  0011d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00122	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00126	5f		 pop	 rdi
  00127	e9 00 00 00 00	 jmp	 PyUnicode_FromFormat
timezone_str ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_tzname DD imagerel timezone_tzname
	DD	imagerel timezone_tzname+53
	DD	imagerel $unwind$timezone_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_tzname DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT timezone_tzname
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_tzname PROC					; COMDAT

; 3299 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 3300 :     if (_timezone_check_argument(dt, "tzname") == -1)

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CNBAGEMF@tzname?$AA@
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 _timezone_check_argument
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	75 08		 jne	 SHORT $LN1@timezone_t

; 3301 :         return NULL;

  00020	33 c0		 xor	 eax, eax

; 3304 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN1@timezone_t:

; 3302 : 
; 3303 :     return timezone_str(self);

  00028	48 8b cb	 mov	 rcx, rbx

; 3304 : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	e9 00 00 00 00	 jmp	 timezone_str
timezone_tzname ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$timezone_utcoffset DD imagerel timezone_utcoffset
	DD	imagerel timezone_utcoffset+123
	DD	imagerel $unwind$timezone_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_utcoffset DD 042d01H
	DD	08342dH
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT timezone_utcoffset
_TEXT	SEGMENT
self$ = 64
dt$ = 72
timezone_utcoffset PROC					; COMDAT

; 3308 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b f9	 mov	 rdi, rcx

; 3309 :     if (_timezone_check_argument(dt, "utcoffset") == -1)

  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
  00013	48 8b c8	 mov	 rcx, rax
  00016	e8 00 00 00 00	 call	 _timezone_check_argument
  0001b	83 f8 ff	 cmp	 eax, -1
  0001e	75 08		 jne	 SHORT $LN1@timezone_u

; 3310 :         return NULL;

  00020	33 c0		 xor	 eax, eax

; 3314 : }

  00022	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
$LN1@timezone_u:
  00028	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 3311 : 
; 3312 :     Py_INCREF(self->offset);

  0002d	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  00031	e8 00 00 00 00	 call	 _Py_PXCTX
  00036	85 c0		 test	 eax, eax
  00038	75 32		 jne	 SHORT $LN5@timezone_u
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00048	4c 8b cb	 mov	 r9, rbx
  0004b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	e8 00 00 00 00	 call	 _PyParallel_Guard
  0005e	85 c0		 test	 eax, eax
  00060	75 06		 jne	 SHORT $LN4@timezone_u
  00062	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00066	74 04		 je	 SHORT $LN5@timezone_u
$LN4@timezone_u:
  00068	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN5@timezone_u:

; 3313 :     return self->offset;

  0006c	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00070	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 3314 : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
timezone_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$timezone_dst DD imagerel timezone_dst
	DD	imagerel timezone_dst+112
	DD	imagerel $unwind$timezone_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_dst DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT timezone_dst
_TEXT	SEGMENT
self$ = 64
dt$ = 72
timezone_dst PROC					; COMDAT

; 3318 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3319 :     if (_timezone_check_argument(dt, "dst") == -1)

  00004	48 8b ca	 mov	 rcx, rdx
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  0000e	e8 00 00 00 00	 call	 _timezone_check_argument
  00013	83 f8 ff	 cmp	 eax, -1
  00016	75 07		 jne	 SHORT $LN1@timezone_d@2

; 3320 :         return NULL;

  00018	33 c0		 xor	 eax, eax

; 3323 : }

  0001a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001e	c3		 ret	 0
$LN1@timezone_d@2:

; 3321 : 
; 3322 :     Py_RETURN_NONE;

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	75 3c		 jne	 SHORT $LN5@timezone_d@2
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0003d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00043	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0004b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00050	85 c0		 test	 eax, eax
  00052	75 09		 jne	 SHORT $LN4@timezone_d@2
  00054	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0005b	74 07		 je	 SHORT $LN5@timezone_d@2
$LN4@timezone_d@2:
  0005d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN5@timezone_d@2:
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3323 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
timezone_dst ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@		; `string'
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
;	COMDAT ??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@ DB '(OO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT timezone_getinitargs
_TEXT	SEGMENT
self$ = 8
timezone_getinitargs PROC				; COMDAT

; 3345 :     if (self->name == NULL)

  00000	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]

; 3346 :         return Py_BuildValue("(O)", self->offset);

  00004	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00008	4d 85 c0	 test	 r8, r8
  0000b	75 0c		 jne	 SHORT $LN1@timezone_g
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@

; 3348 : }

  00014	e9 00 00 00 00	 jmp	 Py_BuildValue
$LN1@timezone_g:

; 3347 :     return Py_BuildValue("(OO)", self->offset, self->name);

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@

; 3348 : }

  00020	e9 00 00 00 00	 jmp	 Py_BuildValue
timezone_getinitargs ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_hour
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_hour PROC						; COMDAT

; 3424 :     return PyLong_FromLong(TIME_GET_HOUR(self));

  00000	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]

; 3425 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
time_hour ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_minute
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_minute PROC					; COMDAT

; 3430 :     return PyLong_FromLong(TIME_GET_MINUTE(self));

  00000	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]

; 3431 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
time_minute ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT py_time_second
_TEXT	SEGMENT
self$ = 8
unused$ = 16
py_time_second PROC					; COMDAT

; 3437 :     return PyLong_FromLong(TIME_GET_SECOND(self));

  00000	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]

; 3438 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
py_time_second ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_microsecond
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_microsecond PROC					; COMDAT

; 3443 :     return PyLong_FromLong(TIME_GET_MICROSECOND(self));

  00000	0f b6 51 6c	 movzx	 edx, BYTE PTR [rcx+108]
  00004	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  00008	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  0000c	c1 e2 08	 shl	 edx, 8
  0000f	0b d0		 or	 edx, eax
  00011	c1 e2 08	 shl	 edx, 8
  00014	0b ca		 or	 ecx, edx

; 3444 : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromLong
time_microsecond ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$time_tzinfo DD imagerel time_tzinfo
	DD	imagerel time_tzinfo+93
	DD	imagerel $unwind$time_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_tzinfo DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT time_tzinfo
_TEXT	SEGMENT
self$ = 64
unused$ = 72
time_tzinfo PROC					; COMDAT

; 3448 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3449 :     PyObject *result = HASTZINFO(self) ? self->tzinfo : Py_None;

  00006	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0000a	74 06		 je	 SHORT $LN3@time_tzinf
  0000c	48 8b 59 70	 mov	 rbx, QWORD PTR [rcx+112]
  00010	eb 07		 jmp	 SHORT $LN4@time_tzinf
$LN3@time_tzinf:
  00012	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
$LN4@time_tzinf:

; 3450 :     Py_INCREF(result);

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 32		 jne	 SHORT $LN9@time_tzinf
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00030	4c 8b cb	 mov	 r9, rbx
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 06		 jne	 SHORT $LN5@time_tzinf
  0004a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004e	74 04		 je	 SHORT $LN9@time_tzinf
$LN5@time_tzinf:
  00050	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@time_tzinf:

; 3451 :     return result;

  00054	48 8b c3	 mov	 rax, rbx

; 3452 : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
time_tzinfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_06IEELMKJM@?$HMiiiiO?$AA@			; `string'
PUBLIC	??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_new DD imagerel time_new
	DD	imagerel time_new+446
	DD	imagerel $unwind$time_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_new DD 081301H
	DD	0123413H
	DD	0d00cb213H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_06IEELMKJM@?$HMiiiiO?$AA@
CONST	SEGMENT
??_C@_06IEELMKJM@?$HMiiiiO?$AA@ DB '|iiiiO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
CONST	SEGMENT
??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@ DB 'bad tzinfo state arg', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_new
_TEXT	SEGMENT
minute$ = 80
hour$ = 84
tzinfo$ = 88
type$ = 144
usecond$ = 152
args$ = 152
kw$ = 160
second$ = 168
time_new PROC						; COMDAT

; 3472 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 3473 :     PyObject *self = NULL;
; 3474 :     PyObject *state;
; 3475 :     int hour = 0;
; 3476 :     int minute = 0;
; 3477 :     int second = 0;
; 3478 :     int usecond = 0;
; 3479 :     PyObject *tzinfo = Py_None;
; 3480 : 
; 3481 :     /* Check for invocation from pickle with __getstate__ state */
; 3482 :     if (PyTuple_GET_SIZE(args) >= 1 &&
; 3483 :         PyTuple_GET_SIZE(args) <= 2 &&
; 3484 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 3485 :         PyBytes_GET_SIZE(state) == _PyDateTime_TIME_DATASIZE &&
; 3486 :         ((unsigned char) (PyBytes_AS_STRING(state)[0])) < 24)

  00013	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  00017	33 db		 xor	 ebx, ebx
  00019	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00020	49 8b f0	 mov	 rsi, r8
  00023	4c 8b da	 mov	 r11, rdx
  00026	4c 8b e1	 mov	 r12, rcx
  00029	89 5d f4	 mov	 DWORD PTR hour$[rbp-96], ebx
  0002c	89 5d f0	 mov	 DWORD PTR minute$[rbp-96], ebx
  0002f	89 5d 48	 mov	 DWORD PTR second$[rbp-96], ebx
  00032	89 5d 38	 mov	 DWORD PTR usecond$[rbp-96], ebx
  00035	4d 8b d5	 mov	 r10, r13
  00038	4c 89 6d f8	 mov	 QWORD PTR tzinfo$[rbp-96], r13
  0003c	49 83 f9 01	 cmp	 r9, 1
  00040	0f 8c c7 00 00
	00		 jl	 $LN8@time_new
  00046	49 83 f9 02	 cmp	 r9, 2
  0004a	0f 8f bd 00 00
	00		 jg	 $LN8@time_new
  00050	48 8b 7a 70	 mov	 rdi, QWORD PTR [rdx+112]
  00054	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00058	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00062	0f 84 a5 00 00
	00		 je	 $LN8@time_new
  00068	48 83 7f 60 06	 cmp	 QWORD PTR [rdi+96], 6
  0006d	0f 85 9a 00 00
	00		 jne	 $LN8@time_new
  00073	80 7f 78 18	 cmp	 BYTE PTR [rdi+120], 24
  00077	0f 83 90 00 00
	00		 jae	 $LN8@time_new

; 3487 :     {
; 3488 :         PyDateTime_Time *me;
; 3489 :         char aware;
; 3490 : 
; 3491 :         if (PyTuple_GET_SIZE(args) == 2) {

  0007d	49 83 f9 02	 cmp	 r9, 2
  00081	75 2f		 jne	 SHORT $LN6@time_new

; 3492 :             tzinfo = PyTuple_GET_ITEM(args, 1);

  00083	48 8b 4a 78	 mov	 rcx, QWORD PTR [rdx+120]
  00087	48 89 4d f8	 mov	 QWORD PTR tzinfo$[rbp-96], rcx

; 3493 :             if (check_tzinfo_subclass(tzinfo) < 0) {

  0008b	e8 00 00 00 00	 call	 check_tzinfo_subclass
  00090	85 c0		 test	 eax, eax
  00092	79 1a		 jns	 SHORT $LN11@time_new

; 3494 :                 PyErr_SetString(PyExc_TypeError, "bad "
; 3495 :                     "tzinfo state arg");

  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
  000a2	e8 00 00 00 00	 call	 PyErr_SetString
$LN12@time_new:

; 3496 :                 return NULL;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 fc 00 00 00	 jmp	 $LN9@time_new
$LN11@time_new:
  000ae	4c 8b 55 f8	 mov	 r10, QWORD PTR tzinfo$[rbp-96]
$LN6@time_new:

; 3497 :             }
; 3498 :         }
; 3499 :         aware = (char)(tzinfo != Py_None);

  000b2	4d 3b d5	 cmp	 r10, r13

; 3500 :         me = (PyDateTime_Time *) (type->tp_alloc(type, aware));

  000b5	49 8b cc	 mov	 rcx, r12
  000b8	40 0f 95 c6	 setne	 sil
  000bc	48 0f be d6	 movsx	 rdx, sil
  000c0	41 ff 94 24 88
	01 00 00	 call	 QWORD PTR [r12+392]
  000c8	48 8b d8	 mov	 rbx, rax

; 3501 :         if (me != NULL) {

  000cb	48 85 c0	 test	 rax, rax
  000ce	0f 84 d3 00 00
	00		 je	 $LN3@time_new

; 3502 :             char *pdata = PyBytes_AS_STRING(state);
; 3503 : 
; 3504 :             memcpy(me->data, pdata, _PyDateTime_TIME_DATASIZE);

  000d4	8b 4f 78	 mov	 ecx, DWORD PTR [rdi+120]
  000d7	89 48 69	 mov	 DWORD PTR [rax+105], ecx
  000da	0f b7 4f 7c	 movzx	 ecx, WORD PTR [rdi+124]

; 3505 :             me->hashcode = -1;

  000de	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 3506 :             me->hastzinfo = aware;

  000e6	40 88 70 68	 mov	 BYTE PTR [rax+104], sil
  000ea	66 89 48 6d	 mov	 WORD PTR [rax+109], cx

; 3507 :             if (aware) {

  000ee	40 84 f6	 test	 sil, sil
  000f1	0f 84 b0 00 00
	00		 je	 $LN3@time_new

; 3508 :                 Py_INCREF(tzinfo);

  000f7	48 8b 4d f8	 mov	 rcx, QWORD PTR tzinfo$[rbp-96]
  000fb	e8 00 00 00 00	 call	 _Py_IncRef

; 3509 :                 me->tzinfo = tzinfo;

  00100	4c 8b 5d f8	 mov	 r11, QWORD PTR tzinfo$[rbp-96]
  00104	4c 89 5b 70	 mov	 QWORD PTR [rbx+112], r11

; 3510 :             }
; 3511 :         }
; 3512 :         return (PyObject *)me;

  00108	e9 9a 00 00 00	 jmp	 $LN3@time_new
$LN8@time_new:

; 3513 :     }
; 3514 : 
; 3515 :     if (PyArg_ParseTupleAndKeywords(args, kw, "|iiiiO", time_kws,
; 3516 :                                     &hour, &minute, &second, &usecond,
; 3517 :                                     &tzinfo)) {

  0010d	48 8d 45 f8	 lea	 rax, QWORD PTR tzinfo$[rbp-96]
  00111	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:time_kws
  00118	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IEELMKJM@?$HMiiiiO?$AA@
  0011f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00124	48 8d 45 38	 lea	 rax, QWORD PTR usecond$[rbp-96]
  00128	48 8b d6	 mov	 rdx, rsi
  0012b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00130	48 8d 45 48	 lea	 rax, QWORD PTR second$[rbp-96]
  00134	49 8b cb	 mov	 rcx, r11
  00137	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0013c	48 8d 45 f0	 lea	 rax, QWORD PTR minute$[rbp-96]
  00140	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00145	48 8d 45 f4	 lea	 rax, QWORD PTR hour$[rbp-96]
  00149	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014e	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00153	85 c0		 test	 eax, eax
  00155	74 50		 je	 SHORT $LN3@time_new

; 3518 :         if (check_time_args(hour, minute, second, usecond) < 0)

  00157	44 8b 4d 38	 mov	 r9d, DWORD PTR usecond$[rbp-96]
  0015b	44 8b 45 48	 mov	 r8d, DWORD PTR second$[rbp-96]
  0015f	8b 55 f0	 mov	 edx, DWORD PTR minute$[rbp-96]
  00162	8b 4d f4	 mov	 ecx, DWORD PTR hour$[rbp-96]
  00165	e8 00 00 00 00	 call	 check_time_args
  0016a	85 c0		 test	 eax, eax

; 3519 :             return NULL;

  0016c	0f 88 35 ff ff
	ff		 js	 $LN12@time_new

; 3520 :         if (check_tzinfo_subclass(tzinfo) < 0)

  00172	48 8b 4d f8	 mov	 rcx, QWORD PTR tzinfo$[rbp-96]
  00176	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0017b	85 c0		 test	 eax, eax

; 3521 :             return NULL;

  0017d	0f 88 24 ff ff
	ff		 js	 $LN12@time_new

; 3522 :         self = new_time_ex(hour, minute, second, usecond, tzinfo,
; 3523 :                            type);

  00183	48 8b 45 f8	 mov	 rax, QWORD PTR tzinfo$[rbp-96]
  00187	44 8b 4d 38	 mov	 r9d, DWORD PTR usecond$[rbp-96]
  0018b	44 8b 45 48	 mov	 r8d, DWORD PTR second$[rbp-96]
  0018f	8b 55 f0	 mov	 edx, DWORD PTR minute$[rbp-96]
  00192	8b 4d f4	 mov	 ecx, DWORD PTR hour$[rbp-96]
  00195	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0019a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019f	e8 00 00 00 00	 call	 new_time_ex
  001a4	48 8b d8	 mov	 rbx, rax
$LN3@time_new:

; 3524 :     }
; 3525 :     return self;

  001a7	48 8b c3	 mov	 rax, rbx
$LN9@time_new:

; 3526 : }

  001aa	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  001b2	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001b6	41 5d		 pop	 r13
  001b8	41 5c		 pop	 r12
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	5d		 pop	 rbp
  001bd	c3		 ret	 0
time_new ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$time_dealloc DD imagerel time_dealloc
	DD	imagerel time_dealloc+15
	DD	imagerel $unwind$time_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_dealloc DD imagerel time_dealloc+15
	DD	imagerel time_dealloc+135
	DD	imagerel $chain$0$time_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$time_dealloc DD imagerel time_dealloc+135
	DD	imagerel time_dealloc+154
	DD	imagerel $chain$1$time_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$time_dealloc DD 021H
	DD	imagerel time_dealloc
	DD	imagerel time_dealloc+15
	DD	imagerel $unwind$time_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_dealloc DD 020521H
	DD	083405H
	DD	imagerel time_dealloc
	DD	imagerel time_dealloc+15
	DD	imagerel $unwind$time_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_dealloc DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT time_dealloc
_TEXT	SEGMENT
self$ = 64
time_dealloc PROC					; COMDAT

; 3534 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3535 :     if (HASTZINFO(self)) {

  00006	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	74 78		 je	 SHORT $LN2@time_deall

; 3536 :         Py_XDECREF(self->tzinfo);

  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b 59 70	 mov	 rbx, QWORD PTR [rcx+112]
  00018	48 85 db	 test	 rbx, rbx
  0001b	74 65		 je	 SHORT $LN3@time_deall
  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	75 5c		 jne	 SHORT $LN3@time_deall
  00026	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002a	a8 20		 test	 al, 32			; 00000020H
  0002c	75 4c		 jne	 SHORT $LN12@time_deall
  0002e	84 c0		 test	 al, al
  00030	78 48		 js	 SHORT $LN12@time_deall
  00032	a8 02		 test	 al, 2
  00034	75 4c		 jne	 SHORT $LN3@time_deall
  00036	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003a	75 46		 jne	 SHORT $LN3@time_deall
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004a	4c 8b cb	 mov	 r9, rbx
  0004d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00053	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00060	48 8b cb	 mov	 rcx, rbx
  00063	85 c0		 test	 eax, eax
  00065	74 07		 je	 SHORT $LN17@time_deall
  00067	e8 00 00 00 00	 call	 _Px_Dealloc
  0006c	eb 14		 jmp	 SHORT $LN3@time_deall
$LN17@time_deall:
  0006e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00072	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00078	eb 08		 jmp	 SHORT $LN3@time_deall
$LN12@time_deall:
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@time_deall:
  00082	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN2@time_deall:

; 3537 :     }
; 3538 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00087	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0008b	48 8b cf	 mov	 rcx, rdi

; 3539 : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
time_dealloc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_utcoffset
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_utcoffset PROC					; COMDAT

; 3548 :     return call_utcoffset(GET_TIME_TZINFO(self), Py_None);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 10		 je	 SHORT $LN3@time_utcof
  00006	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3549 : }

  00011	e9 00 00 00 00	 jmp	 call_utcoffset
$LN3@time_utcof:

; 3548 :     return call_utcoffset(GET_TIME_TZINFO(self), Py_None);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3549 : }

  00024	e9 00 00 00 00	 jmp	 call_utcoffset
time_utcoffset ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_dst
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_dst PROC						; COMDAT

; 3553 :     return call_dst(GET_TIME_TZINFO(self), Py_None);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 10		 je	 SHORT $LN3@time_dst
  00006	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3554 : }

  00011	e9 00 00 00 00	 jmp	 call_dst
$LN3@time_dst:

; 3553 :     return call_dst(GET_TIME_TZINFO(self), Py_None);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3554 : }

  00024	e9 00 00 00 00	 jmp	 call_dst
time_dst ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_tzname
_TEXT	SEGMENT
self$ = 8
unused$ = 16
time_tzname PROC					; COMDAT

; 3558 :     return call_tzname(GET_TIME_TZINFO(self), Py_None);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 10		 je	 SHORT $LN3@time_tznam
  00006	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3559 : }

  00011	e9 00 00 00 00	 jmp	 call_tzname
$LN3@time_tznam:

; 3558 :     return call_tzname(GET_TIME_TZINFO(self), Py_None);

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct

; 3559 : }

  00024	e9 00 00 00 00	 jmp	 call_tzname
time_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_repr DD imagerel time_repr
	DD	imagerel time_repr+146
	DD	imagerel $unwind$time_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_repr DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d)', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_repr
_TEXT	SEGMENT
self$ = 64
time_repr PROC						; COMDAT

; 3567 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3568 :     const char *type_name = Py_TYPE(self)->tp_name;

  00006	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 3569 :     int h = TIME_GET_HOUR(self);

  0000a	44 0f b6 41 69	 movzx	 r8d, BYTE PTR [rcx+105]

; 3570 :     int m = TIME_GET_MINUTE(self);

  0000f	44 0f b6 49 6a	 movzx	 r9d, BYTE PTR [rcx+106]
  00014	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00018	48 8b d9	 mov	 rbx, rcx

; 3571 :     int s = TIME_GET_SECOND(self);

  0001b	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]

; 3572 :     int us = TIME_GET_MICROSECOND(self);

  0001f	0f b6 43 6d	 movzx	 eax, BYTE PTR [rbx+109]
  00023	44 0f b6 53 6c	 movzx	 r10d, BYTE PTR [rbx+108]
  00028	41 c1 e2 08	 shl	 r10d, 8
  0002c	44 0b d0	 or	 r10d, eax
  0002f	0f b6 43 6e	 movzx	 eax, BYTE PTR [rbx+110]
  00033	41 c1 e2 08	 shl	 r10d, 8
  00037	44 0b d0	 or	 r10d, eax

; 3573 :     PyObject *result = NULL;
; 3574 : 
; 3575 :     if (us)

  0003a	74 17		 je	 SHORT $LN5@time_repr

; 3576 :         result = PyUnicode_FromFormat("%s(%d, %d, %d, %d)",
; 3577 :                                       type_name, h, m, s, us);

  0003c	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  00041	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  0004c	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00051	eb 22		 jmp	 SHORT $LN2@time_repr
$LN5@time_repr:

; 3578 :     else if (s)

  00053	85 c9		 test	 ecx, ecx
  00055	74 12		 je	 SHORT $LN3@time_repr

; 3579 :         result = PyUnicode_FromFormat("%s(%d, %d, %d)",
; 3580 :                                       type_name, h, m, s);

  00057	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  00062	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 3581 :     else

  00067	eb 0c		 jmp	 SHORT $LN2@time_repr
$LN3@time_repr:

; 3582 :         result = PyUnicode_FromFormat("%s(%d, %d)", type_name, h, m);

  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@
  00070	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN2@time_repr:

; 3583 :     if (result != NULL && HASTZINFO(self))

  00075	48 85 c0	 test	 rax, rax
  00078	74 12		 je	 SHORT $LN8@time_repr
  0007a	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  0007e	74 0c		 je	 SHORT $LN8@time_repr

; 3584 :         result = append_keyword_tzinfo(result, self->tzinfo);

  00080	48 8b 53 70	 mov	 rdx, QWORD PTR [rbx+112]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 append_keyword_tzinfo
$LN8@time_repr:

; 3585 :     return result;
; 3586 : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
time_repr ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT time_str
_TEXT	SEGMENT
self$ = 8
time_str PROC						; COMDAT

; 3591 :     _Py_IDENTIFIER(isoformat);
; 3592 : 
; 3593 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "()");

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_isoformat@?1??time_str@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 3594 : }

  00020	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId
time_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$time_richcompare DD imagerel time_richcompare
	DD	imagerel time_richcompare+134
	DD	imagerel $unwind$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_richcompare DD imagerel time_richcompare+134
	DD	imagerel time_richcompare+228
	DD	imagerel $chain$0$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$time_richcompare DD imagerel time_richcompare+228
	DD	imagerel time_richcompare+260
	DD	imagerel $chain$3$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$time_richcompare DD imagerel time_richcompare+260
	DD	imagerel time_richcompare+282
	DD	imagerel $chain$4$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$time_richcompare DD imagerel time_richcompare+282
	DD	imagerel time_richcompare+609
	DD	imagerel $chain$5$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$time_richcompare DD imagerel time_richcompare+609
	DD	imagerel time_richcompare+638
	DD	imagerel $chain$6$time_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$time_richcompare DD imagerel time_richcompare+638
	DD	imagerel time_richcompare+659
	DD	imagerel $chain$7$time_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$time_richcompare DD 021H
	DD	imagerel time_richcompare+228
	DD	imagerel time_richcompare+260
	DD	imagerel $chain$3$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$time_richcompare DD 021H
	DD	imagerel time_richcompare+260
	DD	imagerel time_richcompare+282
	DD	imagerel $chain$4$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$time_richcompare DD 020521H
	DD	06f405H
	DD	imagerel time_richcompare+260
	DD	imagerel time_richcompare+282
	DD	imagerel $chain$4$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$time_richcompare DD 020521H
	DD	0c3405H
	DD	imagerel time_richcompare+228
	DD	imagerel time_richcompare+260
	DD	imagerel $chain$3$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$time_richcompare DD 040a21H
	DD	0d540aH
	DD	0ee400H
	DD	imagerel time_richcompare
	DD	imagerel time_richcompare+134
	DD	imagerel $unwind$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_richcompare DD 020521H
	DD	0ee405H
	DD	imagerel time_richcompare
	DD	imagerel time_richcompare+134
	DD	imagerel $unwind$time_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_richcompare DD 050b01H
	DD	0d007620bH
	DD	07003c005H
	DD	06002H
xdata	ENDS
;	COMDAT ??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@
CONST	SEGMENT
??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@ DB 'can''t com'
	DB	'pare offset-naive and offset-aware times', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT time_richcompare
_TEXT	SEGMENT
self$ = 96
other$ = 104
op$ = 112
time_richcompare PROC					; COMDAT

; 3665 : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000b	4c 8b e1	 mov	 r12, rcx

; 3666 :     PyObject *result = NULL;
; 3667 :     PyObject *offset1, *offset2;
; 3668 :     int diff;
; 3669 : 
; 3670 :     if (! PyTime_Check(other))

  0000e	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  0001c	33 ff		 xor	 edi, edi
  0001e	45 8b e8	 mov	 r13d, r8d
  00021	48 3b ca	 cmp	 rcx, rdx
  00024	74 60		 je	 SHORT $LN20@time_richc
  00026	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002b	85 c0		 test	 eax, eax
  0002d	75 57		 jne	 SHORT $LN20@time_richc

; 3671 :         Py_RETURN_NOTIMPLEMENTED;

  0002f	e8 00 00 00 00	 call	 _Py_PXCTX
  00034	85 c0		 test	 eax, eax
  00036	75 3c		 jne	 SHORT $LN28@time_richc
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0004d	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00053	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0005b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00060	85 c0		 test	 eax, eax
  00062	75 09		 jne	 SHORT $LN27@time_richc
  00064	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0006b	74 07		 je	 SHORT $LN28@time_richc
$LN27@time_richc:
  0006d	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN28@time_richc:
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 3734 : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	41 5d		 pop	 r13
  00081	41 5c		 pop	 r12
  00083	5f		 pop	 rdi
  00084	5e		 pop	 rsi
  00085	c3		 ret	 0
$LN20@time_richc:
  00086	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14

; 3672 : 
; 3673 :     if (GET_TIME_TZINFO(self) == GET_TIME_TZINFO(other)) {

  0008b	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct
  00092	41 38 7c 24 68	 cmp	 BYTE PTR [r12+104], dil
  00097	74 07		 je	 SHORT $LN23@time_richc
  00099	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  0009e	eb 03		 jmp	 SHORT $LN24@time_richc
$LN23@time_richc:
  000a0	49 8b ce	 mov	 rcx, r14
$LN24@time_richc:
  000a3	40 38 7e 68	 cmp	 BYTE PTR [rsi+104], dil
  000a7	74 06		 je	 SHORT $LN25@time_richc
  000a9	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  000ad	eb 03		 jmp	 SHORT $LN26@time_richc
$LN25@time_richc:
  000af	49 8b c6	 mov	 rax, r14
$LN26@time_richc:
  000b2	48 3b c8	 cmp	 rcx, rax
  000b5	75 2d		 jne	 SHORT $LN19@time_richc

; 3674 :         diff = memcmp(((PyDateTime_Time *)self)->data,
; 3675 :                       ((PyDateTime_Time *)other)->data,
; 3676 :                       _PyDateTime_TIME_DATASIZE);

  000b7	48 8d 56 69	 lea	 rdx, QWORD PTR [rsi+105]
  000bb	49 8d 4c 24 69	 lea	 rcx, QWORD PTR [r12+105]
  000c0	41 b8 06 00 00
	00		 mov	 r8d, 6
  000c6	e8 00 00 00 00	 call	 memcmp

; 3677 :         return diff_to_bool(diff, op);

  000cb	41 8b d5	 mov	 edx, r13d
  000ce	8b c8		 mov	 ecx, eax
  000d0	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]

; 3734 : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	41 5d		 pop	 r13
  000db	41 5c		 pop	 r12
  000dd	5f		 pop	 rdi
  000de	5e		 pop	 rsi
  000df	e9 00 00 00 00	 jmp	 diff_to_bool
$LN19@time_richc:

; 3678 :     }
; 3679 :     offset1 = time_utcoffset(self, NULL);

  000e4	33 d2		 xor	 edx, edx
  000e6	49 8b cc	 mov	 rcx, r12
  000e9	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  000ee	e8 00 00 00 00	 call	 time_utcoffset
  000f3	48 8b e8	 mov	 rbp, rax

; 3680 :     if (offset1 == NULL)

  000f6	48 85 c0	 test	 rax, rax
  000f9	0f 84 7f 01 00
	00		 je	 $LN32@time_richc
$LN18@time_richc:

; 3681 :         return NULL;
; 3682 :     offset2 = time_utcoffset(other, NULL);

  000ff	33 d2		 xor	 edx, edx
  00101	48 8b ce	 mov	 rcx, rsi
  00104	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00109	e8 00 00 00 00	 call	 time_utcoffset
  0010e	48 8b d8	 mov	 rbx, rax

; 3683 :     if (offset2 == NULL)

  00111	48 85 c0	 test	 rax, rax
  00114	0f 84 47 01 00
	00		 je	 $done$23270

; 3684 :         goto done;
; 3685 :     /* If they're both naive, or both aware and have the same offsets,
; 3686 :      * we get off cheap.  Note that if they're both naive, offset1 ==
; 3687 :      * offset2 == Py_None at this point.
; 3688 :      */
; 3689 :     if ((offset1 == offset2) ||
; 3690 :         (PyDelta_Check(offset1) && PyDelta_Check(offset2) &&
; 3691 :          delta_cmp(offset1, offset2) == 0)) {

  0011a	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0011f	48 3b e8	 cmp	 rbp, rax
  00122	0f 84 13 01 00
	00		 je	 $LN15@time_richc
  00128	48 8b 4d 58	 mov	 rcx, QWORD PTR [rbp+88]
  0012c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:PyDateTime_DeltaType
  00133	49 3b cf	 cmp	 rcx, r15
  00136	74 0c		 je	 SHORT $LN14@time_richc
  00138	49 8b d7	 mov	 rdx, r15
  0013b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00140	85 c0		 test	 eax, eax
  00142	74 28		 je	 SHORT $LN16@time_richc
$LN14@time_richc:
  00144	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00148	49 3b cf	 cmp	 rcx, r15
  0014b	74 0c		 je	 SHORT $LN13@time_richc
  0014d	49 8b d7	 mov	 rdx, r15
  00150	e8 00 00 00 00	 call	 PyType_IsSubtype
  00155	85 c0		 test	 eax, eax
  00157	74 13		 je	 SHORT $LN16@time_richc
$LN13@time_richc:
  00159	48 8b d3	 mov	 rdx, rbx
  0015c	48 8b cd	 mov	 rcx, rbp
  0015f	e8 00 00 00 00	 call	 delta_cmp
  00164	85 c0		 test	 eax, eax
  00166	0f 84 cf 00 00
	00		 je	 $LN15@time_richc
$LN16@time_richc:

; 3696 :     }
; 3697 :     /* The hard case: both aware with different UTC offsets */
; 3698 :     else if (offset1 != Py_None && offset2 != Py_None) {

  0016c	49 3b ee	 cmp	 rbp, r14
  0016f	0f 84 83 00 00
	00		 je	 $LN11@time_richc
  00175	49 3b de	 cmp	 rbx, r14
  00178	74 7e		 je	 SHORT $LN11@time_richc

; 3699 :         int offsecs1, offsecs2;
; 3700 :         assert(offset1 != offset2); /* else last "if" handled it */
; 3701 :         offsecs1 = TIME_GET_HOUR(self) * 3600 +
; 3702 :                    TIME_GET_MINUTE(self) * 60 +
; 3703 :                    TIME_GET_SECOND(self) -
; 3704 :                    GET_TD_DAYS(offset1) * 86400 -
; 3705 :                    GET_TD_SECONDS(offset1);
; 3706 :         offsecs2 = TIME_GET_HOUR(other) * 3600 +
; 3707 :                    TIME_GET_MINUTE(other) * 60 +
; 3708 :                    TIME_GET_SECOND(other) -
; 3709 :                    GET_TD_DAYS(offset2) * 86400 -
; 3710 :                    GET_TD_SECONDS(offset2);
; 3711 :         diff = offsecs1 - offsecs2;

  0017a	8b 43 68	 mov	 eax, DWORD PTR [rbx+104]
  0017d	2b 45 68	 sub	 eax, DWORD PTR [rbp+104]
  00180	8d 0c 40	 lea	 ecx, DWORD PTR [rax+rax*2]
  00183	0f b6 46 69	 movzx	 eax, BYTE PTR [rsi+105]
  00187	c1 e1 03	 shl	 ecx, 3
  0018a	2b c8		 sub	 ecx, eax
  0018c	41 0f b6 44 24
	69		 movzx	 eax, BYTE PTR [r12+105]
  00192	03 c8		 add	 ecx, eax
  00194	0f b6 46 6a	 movzx	 eax, BYTE PTR [rsi+106]
  00198	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0019b	2b c8		 sub	 ecx, eax
  0019d	41 0f b6 44 24
	6a		 movzx	 eax, BYTE PTR [r12+106]
  001a3	03 c8		 add	 ecx, eax
  001a5	0f b6 46 6b	 movzx	 eax, BYTE PTR [rsi+107]
  001a9	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  001ac	2b c8		 sub	 ecx, eax
  001ae	41 0f b6 44 24
	6b		 movzx	 eax, BYTE PTR [r12+107]
  001b4	2b 4d 6c	 sub	 ecx, DWORD PTR [rbp+108]
  001b7	03 c8		 add	 ecx, eax
  001b9	03 4b 6c	 add	 ecx, DWORD PTR [rbx+108]

; 3712 :         if (diff == 0)

  001bc	0f 85 8f 00 00
	00		 jne	 $LN10@time_richc

; 3713 :             diff = TIME_GET_MICROSECOND(self) -
; 3714 :                    TIME_GET_MICROSECOND(other);

  001c2	41 0f b6 44 24
	6d		 movzx	 eax, BYTE PTR [r12+109]
  001c8	41 0f b6 4c 24
	6c		 movzx	 ecx, BYTE PTR [r12+108]
  001ce	0f b6 56 6c	 movzx	 edx, BYTE PTR [rsi+108]
  001d2	c1 e1 08	 shl	 ecx, 8
  001d5	c1 e2 08	 shl	 edx, 8
  001d8	0b c8		 or	 ecx, eax
  001da	41 0f b6 44 24
	6e		 movzx	 eax, BYTE PTR [r12+110]
  001e0	c1 e1 08	 shl	 ecx, 8
  001e3	0b c8		 or	 ecx, eax
  001e5	0f b6 46 6d	 movzx	 eax, BYTE PTR [rsi+109]
  001e9	0b d0		 or	 edx, eax
  001eb	0f b6 46 6e	 movzx	 eax, BYTE PTR [rsi+110]
  001ef	c1 e2 08	 shl	 edx, 8
  001f2	0b d0		 or	 edx, eax
  001f4	2b ca		 sub	 ecx, edx

; 3715 :         result = diff_to_bool(diff, op);

  001f6	eb 59		 jmp	 SHORT $LN10@time_richc
$LN11@time_richc:

; 3716 :     }
; 3717 :     else if (op == Py_EQ) {

  001f8	41 83 fd 02	 cmp	 r13d, 2
  001fc	75 11		 jne	 SHORT $LN8@time_richc

; 3718 :         result = Py_False;

  001fe	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_FalseStruct

; 3719 :         Py_INCREF(result);

  00205	48 8b cf	 mov	 rcx, rdi
  00208	e8 00 00 00 00	 call	 _Py_IncRef
  0020d	eb 4d		 jmp	 SHORT $LN33@time_richc
$LN8@time_richc:

; 3720 :     }
; 3721 :     else if (op == Py_NE) {

  0020f	41 83 fd 03	 cmp	 r13d, 3
  00213	75 11		 jne	 SHORT $LN6@time_richc

; 3722 :         result = Py_True;

  00215	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_TrueStruct

; 3723 :         Py_INCREF(result);

  0021c	48 8b cf	 mov	 rcx, rdi
  0021f	e8 00 00 00 00	 call	 _Py_IncRef

; 3724 :     }
; 3725 :     else {

  00224	eb 36		 jmp	 SHORT $LN33@time_richc
$LN6@time_richc:

; 3726 :         PyErr_SetString(PyExc_TypeError,
; 3727 :                         "can't compare offset-naive and "
; 3728 :                         "offset-aware times");

  00226	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@
  00234	e8 00 00 00 00	 call	 PyErr_SetString
  00239	eb 21		 jmp	 SHORT $LN33@time_richc
$LN15@time_richc:

; 3692 :         diff = memcmp(((PyDateTime_Time *)self)->data,
; 3693 :                       ((PyDateTime_Time *)other)->data,
; 3694 :                       _PyDateTime_TIME_DATASIZE);

  0023b	48 8d 56 69	 lea	 rdx, QWORD PTR [rsi+105]
  0023f	49 8d 4c 24 69	 lea	 rcx, QWORD PTR [r12+105]
  00244	41 b8 06 00 00
	00		 mov	 r8d, 6
  0024a	e8 00 00 00 00	 call	 memcmp

; 3695 :         result = diff_to_bool(diff, op);

  0024f	8b c8		 mov	 ecx, eax
$LN10@time_richc:
  00251	41 8b d5	 mov	 edx, r13d
  00254	e8 00 00 00 00	 call	 diff_to_bool
  00259	48 8b f8	 mov	 rdi, rax
$LN33@time_richc:
  0025c	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
$done$23270:

; 3729 :     }
; 3730 :  done:
; 3731 :     Py_DECREF(offset1);

  00261	48 8b cd	 mov	 rcx, rbp
  00264	e8 00 00 00 00	 call	 _Py_DecRef

; 3732 :     Py_XDECREF(offset2);

  00269	48 85 db	 test	 rbx, rbx
  0026c	74 08		 je	 SHORT $LN3@time_richc
  0026e	48 8b cb	 mov	 rcx, rbx
  00271	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@time_richc:

; 3733 :     return result;

  00276	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0027b	48 8b c7	 mov	 rax, rdi
$LN32@time_richc:
  0027e	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  00283	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]

; 3734 : }

  00288	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0028c	41 5d		 pop	 r13
  0028e	41 5c		 pop	 r12
  00290	5f		 pop	 rdi
  00291	5e		 pop	 rsi
  00292	c3		 ret	 0
time_richcompare ENDP
_TEXT	ENDS
EXTRN	PyObject_Hash:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_hash DD imagerel time_hash
	DD	imagerel time_hash+258
	DD	imagerel $unwind$time_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_hash DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT time_hash
_TEXT	SEGMENT
self$ = 64
time_hash PROC						; COMDAT

; 3738 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3739 :     if (self->hashcode == -1) {

  00014	48 83 79 60 ff	 cmp	 QWORD PTR [rcx+96], -1
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	0f 85 c7 00 00
	00		 jne	 $LN6@time_hash

; 3740 :         PyObject *offset;
; 3741 : 
; 3742 :         offset = time_utcoffset((PyObject *)self, NULL);

  00022	33 d2		 xor	 edx, edx
  00024	e8 00 00 00 00	 call	 time_utcoffset
  00029	48 8b f8	 mov	 rdi, rax

; 3743 : 
; 3744 :         if (offset == NULL)

  0002c	48 85 c0	 test	 rax, rax

; 3745 :             return -1;

  0002f	74 7b		 je	 SHORT $LN9@time_hash

; 3746 : 
; 3747 :         /* Reduce this to a hash of another object. */
; 3748 :         if (offset == Py_None)

  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00038	48 3b f8	 cmp	 rdi, rax
  0003b	75 17		 jne	 SHORT $LN4@time_hash

; 3749 :             self->hashcode = generic_hash(
; 3750 :                 (unsigned char *)self->data, _PyDateTime_TIME_DATASIZE);

  0003d	48 8d 4b 69	 lea	 rcx, QWORD PTR [rbx+105]
  00041	ba 06 00 00 00	 mov	 edx, 6
  00046	e8 00 00 00 00	 call	 generic_hash
  0004b	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 3751 :         else {

  0004f	e9 8d 00 00 00	 jmp	 $LN3@time_hash
$LN4@time_hash:

; 3752 :             PyObject *temp1, *temp2;
; 3753 :             int seconds, microseconds;
; 3754 :             assert(HASTZINFO(self));
; 3755 :             seconds = TIME_GET_HOUR(self) * 3600 +
; 3756 :                       TIME_GET_MINUTE(self) * 60 +
; 3757 :                       TIME_GET_SECOND(self);

  00054	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  00058	0f b6 53 69	 movzx	 edx, BYTE PTR [rbx+105]

; 3758 :             microseconds = TIME_GET_MICROSECOND(self);

  0005c	44 0f b6 43 6c	 movzx	 r8d, BYTE PTR [rbx+108]
  00061	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00064	03 d0		 add	 edx, eax
  00066	0f b6 43 6b	 movzx	 eax, BYTE PTR [rbx+107]
  0006a	41 c1 e0 08	 shl	 r8d, 8

; 3759 :             temp1 = new_delta(0, seconds, microseconds, 1);

  0006e	33 c9		 xor	 ecx, ecx
  00070	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00073	03 d0		 add	 edx, eax
  00075	0f b6 43 6d	 movzx	 eax, BYTE PTR [rbx+109]
  00079	44 0b c0	 or	 r8d, eax
  0007c	0f b6 43 6e	 movzx	 eax, BYTE PTR [rbx+110]
  00080	44 8d 49 01	 lea	 r9d, QWORD PTR [rcx+1]
  00084	41 c1 e0 08	 shl	 r8d, 8
  00088	44 0b c0	 or	 r8d, eax
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00092	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00097	e8 00 00 00 00	 call	 new_delta_ex
  0009c	48 8b e8	 mov	 rbp, rax

; 3760 :             if (temp1 == NULL) {

  0009f	48 85 c0	 test	 rax, rax
  000a2	75 0e		 jne	 SHORT $LN2@time_hash
$LN10@time_hash:

; 3761 :                 Py_DECREF(offset);

  000a4	48 8b cf	 mov	 rcx, rdi
  000a7	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@time_hash:

; 3762 :                 return -1;

  000ac	48 83 c8 ff	 or	 rax, -1
  000b0	eb 3b		 jmp	 SHORT $LN7@time_hash
$LN2@time_hash:

; 3763 :             }
; 3764 :             temp2 = delta_subtract(temp1, offset);

  000b2	48 8b d7	 mov	 rdx, rdi
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 delta_subtract

; 3765 :             Py_DECREF(temp1);

  000bd	48 8b cd	 mov	 rcx, rbp
  000c0	48 8b f0	 mov	 rsi, rax
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 3766 :             if (temp2 == NULL) {

  000c8	48 85 f6	 test	 rsi, rsi

; 3767 :                 Py_DECREF(offset);
; 3768 :                 return -1;

  000cb	74 d7		 je	 SHORT $LN10@time_hash

; 3769 :             }
; 3770 :             self->hashcode = PyObject_Hash(temp2);

  000cd	48 8b ce	 mov	 rcx, rsi
  000d0	e8 00 00 00 00	 call	 PyObject_Hash

; 3771 :             Py_DECREF(temp2);

  000d5	48 8b ce	 mov	 rcx, rsi
  000d8	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  000dc	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@time_hash:

; 3772 :         }
; 3773 :         Py_DECREF(offset);

  000e1	48 8b cf	 mov	 rcx, rdi
  000e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@time_hash:

; 3774 :     }
; 3775 :     return self->hashcode;

  000e9	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
$LN7@time_hash:

; 3776 : }

  000ed	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000f2	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f7	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000fc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00100	5f		 pop	 rdi
  00101	c3		 ret	 0
time_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_05IDCNAOBO@iiiiO?$AA@			; `string'
PUBLIC	??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_replace DD imagerel time_replace
	DD	imagerel time_replace+230
	DD	imagerel $unwind$time_replace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_replace DD imagerel time_replace+230
	DD	imagerel time_replace+259
	DD	imagerel $chain$0$time_replace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$time_replace DD imagerel time_replace+259
	DD	imagerel time_replace+299
	DD	imagerel $chain$2$time_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$time_replace DD 020021H
	DD	0f7400H
	DD	imagerel time_replace
	DD	imagerel time_replace+230
	DD	imagerel $unwind$time_replace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_replace DD 020521H
	DD	0f7405H
	DD	imagerel time_replace
	DD	imagerel time_replace+230
	DD	imagerel $unwind$time_replace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_replace DD 020601H
	DD	03002b206H
xdata	ENDS
;	COMDAT ??_C@_05IDCNAOBO@iiiiO?$AA@
CONST	SEGMENT
??_C@_05IDCNAOBO@iiiiO?$AA@ DB 'iiiiO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@
CONST	SEGMENT
??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@ DB '|iiiiO:replace', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_replace
_TEXT	SEGMENT
mm$ = 80
hh$ = 84
tzinfo$ = 88
us$ = 112
self$ = 112
args$ = 120
kw$ = 128
ss$ = 136
time_replace PROC					; COMDAT

; 3780 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 3781 :     PyObject *clone;
; 3782 :     PyObject *tuple;
; 3783 :     int hh = TIME_GET_HOUR(self);

  00006	0f b6 41 69	 movzx	 eax, BYTE PTR [rcx+105]

; 3784 :     int mm = TIME_GET_MINUTE(self);
; 3785 :     int ss = TIME_GET_SECOND(self);
; 3786 :     int us = TIME_GET_MICROSECOND(self);

  0000a	44 0f b6 49 6c	 movzx	 r9d, BYTE PTR [rcx+108]
  0000f	4d 8b d0	 mov	 r10, r8
  00012	89 44 24 54	 mov	 DWORD PTR hh$[rsp], eax
  00016	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  0001a	41 c1 e1 08	 shl	 r9d, 8
  0001e	89 44 24 50	 mov	 DWORD PTR mm$[rsp], eax
  00022	0f b6 41 6b	 movzx	 eax, BYTE PTR [rcx+107]
  00026	4c 8b da	 mov	 r11, rdx
  00029	89 84 24 88 00
	00 00		 mov	 DWORD PTR ss$[rsp], eax
  00030	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  00034	48 8b d9	 mov	 rbx, rcx
  00037	44 0b c8	 or	 r9d, eax
  0003a	0f b6 41 6e	 movzx	 eax, BYTE PTR [rcx+110]
  0003e	41 c1 e1 08	 shl	 r9d, 8
  00042	44 0b c8	 or	 r9d, eax

; 3787 :     PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;

  00045	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00049	44 89 4c 24 70	 mov	 DWORD PTR us$[rsp], r9d
  0004e	74 06		 je	 SHORT $LN5@time_repla
  00050	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00054	eb 07		 jmp	 SHORT $LN8@time_repla
$LN5@time_repla:
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@time_repla:
  0005d	48 89 44 24 58	 mov	 QWORD PTR tzinfo$[rsp], rax

; 3788 : 
; 3789 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iiiiO:replace",
; 3790 :                                       time_kws,
; 3791 :                                       &hh, &mm, &ss, &us, &tzinfo))

  00062	48 8d 44 24 58	 lea	 rax, QWORD PTR tzinfo$[rsp]
  00067	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:time_kws
  0006e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00073	48 8d 44 24 70	 lea	 rax, QWORD PTR us$[rsp]
  00078	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@
  0007f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00084	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR ss$[rsp]
  0008c	49 8b d2	 mov	 rdx, r10
  0008f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00094	48 8d 44 24 50	 lea	 rax, QWORD PTR mm$[rsp]
  00099	49 8b cb	 mov	 rcx, r11
  0009c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a1	48 8d 44 24 54	 lea	 rax, QWORD PTR hh$[rsp]
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000b0	85 c0		 test	 eax, eax
  000b2	75 08		 jne	 SHORT $LN2@time_repla

; 3792 :         return NULL;

  000b4	33 c0		 xor	 eax, eax

; 3799 : }

  000b6	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000ba	5b		 pop	 rbx
  000bb	c3		 ret	 0
$LN2@time_repla:

; 3793 :     tuple = Py_BuildValue("iiiiO", hh, mm, ss, us, tzinfo);

  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR tzinfo$[rsp]
  000c1	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR ss$[rsp]
  000c9	44 8b 44 24 50	 mov	 r8d, DWORD PTR mm$[rsp]
  000ce	8b 54 24 54	 mov	 edx, DWORD PTR hh$[rsp]
  000d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d7	8b 44 24 70	 mov	 eax, DWORD PTR us$[rsp]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IDCNAOBO@iiiiO?$AA@
  000e2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e6	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  000eb	e8 00 00 00 00	 call	 Py_BuildValue
  000f0	48 8b f8	 mov	 rdi, rax

; 3794 :     if (tuple == NULL)

  000f3	48 85 c0	 test	 rax, rax
  000f6	75 0b		 jne	 SHORT $LN1@time_repla
  000f8	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 3799 : }

  000fd	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00101	5b		 pop	 rbx
  00102	c3		 ret	 0
$LN1@time_repla:

; 3795 :         return NULL;
; 3796 :     clone = time_new(Py_TYPE(self), tuple, NULL);

  00103	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00107	45 33 c0	 xor	 r8d, r8d
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	e8 00 00 00 00	 call	 time_new

; 3797 :     Py_DECREF(tuple);

  00112	48 8b cf	 mov	 rcx, rdi
  00115	48 8b d8	 mov	 rbx, rax
  00118	e8 00 00 00 00	 call	 _Py_DecRef
  0011d	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]

; 3798 :     return clone;

  00122	48 8b c3	 mov	 rax, rbx

; 3799 : }

  00125	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00129	5b		 pop	 rbx
  0012a	c3		 ret	 0
time_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_bool DD imagerel time_bool
	DD	imagerel time_bool+188
	DD	imagerel $unwind$time_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_bool DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT time_bool
_TEXT	SEGMENT
self$ = 48
time_bool PROC						; COMDAT

; 3803 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3804 :     PyObject *offset, *tzinfo;
; 3805 :     int offsecs = 0;

  0000f	33 f6		 xor	 esi, esi
  00011	48 8b d9	 mov	 rbx, rcx
  00014	8b fe		 mov	 edi, esi

; 3806 : 
; 3807 :     if (TIME_GET_SECOND(self) || TIME_GET_MICROSECOND(self)) {

  00016	40 38 71 6b	 cmp	 BYTE PTR [rcx+107], sil
  0001a	0f 85 87 00 00
	00		 jne	 $LN3@time_bool
  00020	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  00024	0f b6 51 6c	 movzx	 edx, BYTE PTR [rcx+108]
  00028	c1 e2 08	 shl	 edx, 8
  0002b	0b d0		 or	 edx, eax
  0002d	0f b6 41 6e	 movzx	 eax, BYTE PTR [rcx+110]
  00031	c1 e2 08	 shl	 edx, 8
  00034	0b d0		 or	 edx, eax
  00036	75 6f		 jne	 SHORT $LN3@time_bool

; 3808 :         /* Since utcoffset is in whole minutes, nothing can
; 3809 :          * alter the conclusion that this is nonzero.
; 3810 :          */
; 3811 :         return 1;
; 3812 :     }
; 3813 :     tzinfo = GET_TIME_TZINFO(self);

  00038	40 38 71 68	 cmp	 BYTE PTR [rcx+104], sil
  0003c	74 41		 je	 SHORT $LN2@time_bool
  0003e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]

; 3814 :     if (tzinfo != Py_None) {

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00049	48 3b ca	 cmp	 rcx, rdx
  0004c	74 31		 je	 SHORT $LN2@time_bool

; 3815 :         offset = call_utcoffset(tzinfo, Py_None);

  0004e	e8 00 00 00 00	 call	 call_utcoffset

; 3816 :         if (offset == NULL)

  00053	48 85 c0	 test	 rax, rax
  00056	75 13		 jne	 SHORT $LN1@time_bool

; 3817 :             return -1;

  00058	83 c8 ff	 or	 eax, -1

; 3822 : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN1@time_bool:

; 3818 :         offsecs = GET_TD_DAYS(offset)*86400 + GET_TD_SECONDS(offset);

  0006b	8b 78 68	 mov	 edi, DWORD PTR [rax+104]

; 3819 :         Py_DECREF(offset);

  0006e	48 8b c8	 mov	 rcx, rax
  00071	69 ff 80 51 01
	00		 imul	 edi, 86400		; 00015180H
  00077	03 78 6c	 add	 edi, DWORD PTR [rax+108]
  0007a	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@time_bool:

; 3820 :     }
; 3821 :     return (TIME_GET_MINUTE(self)*60 - offsecs + TIME_GET_HOUR(self)*3600) != 0;

  0007f	0f b6 53 69	 movzx	 edx, BYTE PTR [rbx+105]
  00083	0f b6 4b 6a	 movzx	 ecx, BYTE PTR [rbx+106]
  00087	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0008a	03 d1		 add	 edx, ecx
  0008c	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0008f	3b d7		 cmp	 edx, edi
  00091	40 0f 95 c6	 setne	 sil
  00095	8b c6		 mov	 eax, esi

; 3822 : }

  00097	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5f		 pop	 rdi
  000a6	c3		 ret	 0
$LN3@time_bool:
  000a7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ac	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
time_bool ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_getstate DD imagerel time_getstate
	DD	imagerel time_getstate+144
	DD	imagerel $unwind$time_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_getstate DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT time_getstate
_TEXT	SEGMENT
self$ = 48
time_getstate PROC					; COMDAT

; 3833 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 3834 :     PyObject *basestate;
; 3835 :     PyObject *result = NULL;
; 3836 : 
; 3837 :     basestate =  PyBytes_FromStringAndSize((char *)self->data,
; 3838 :                                             _PyDateTime_TIME_DATASIZE);

  0000d	ba 06 00 00 00	 mov	 edx, 6
  00012	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00016	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0001b	48 8b f8	 mov	 rdi, rax

; 3839 :     if (basestate != NULL) {

  0001e	48 85 c0	 test	 rax, rax
  00021	74 62		 je	 SHORT $LN7@time_getst

; 3840 :         if (! HASTZINFO(self) || self->tzinfo == Py_None)

  00023	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00027	74 36		 je	 SHORT $LN2@time_getst
  00029	4c 8b 43 70	 mov	 r8, QWORD PTR [rbx+112]
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00034	4c 3b c0	 cmp	 r8, rax
  00037	74 26		 je	 SHORT $LN2@time_getst

; 3842 :         else
; 3843 :             result = PyTuple_Pack(2, basestate, self->tzinfo);

  00039	48 8b d7	 mov	 rdx, rdi
  0003c	b9 02 00 00 00	 mov	 ecx, 2
  00041	e8 00 00 00 00	 call	 PyTuple_Pack

; 3844 :         Py_DECREF(basestate);

  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 8b d8	 mov	 rbx, rax
  0004c	e8 00 00 00 00	 call	 _Py_DecRef

; 3845 :     }
; 3846 :     return result;

  00051	48 8b c3	 mov	 rax, rbx

; 3847 : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN2@time_getst:

; 3841 :             result = PyTuple_Pack(1, basestate);

  0005f	48 8b d7	 mov	 rdx, rdi
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	e8 00 00 00 00	 call	 PyTuple_Pack

; 3844 :         Py_DECREF(basestate);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 8b d8	 mov	 rbx, rax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 3845 :     }
; 3846 :     return result;

  00077	48 8b c3	 mov	 rax, rbx

; 3847 : }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN7@time_getst:
  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
time_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_reduce DD imagerel time_reduce
	DD	imagerel time_reduce+38
	DD	imagerel $unwind$time_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_reduce DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT time_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
time_reduce PROC					; COMDAT

; 3851 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3852 :     return Py_BuildValue("(ON)", Py_TYPE(self), time_getstate(self));

  00009	e8 00 00 00 00	 call	 time_getstate
  0000e	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  00019	4c 8b c0	 mov	 r8, rax

; 3853 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	e9 00 00 00 00	 jmp	 Py_BuildValue
time_reduce ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_hour
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_hour PROC					; COMDAT

; 3957 :     return PyLong_FromLong(DATE_GET_HOUR(self));

  00000	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]

; 3958 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
datetime_hour ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_minute
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_minute PROC					; COMDAT

; 3963 :     return PyLong_FromLong(DATE_GET_MINUTE(self));

  00000	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]

; 3964 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
datetime_minute ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_second
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_second PROC					; COMDAT

; 3969 :     return PyLong_FromLong(DATE_GET_SECOND(self));

  00000	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]

; 3970 : }

  00004	e9 00 00 00 00	 jmp	 PyLong_FromLong
datetime_second ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_microsecond
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_microsecond PROC				; COMDAT

; 3975 :     return PyLong_FromLong(DATE_GET_MICROSECOND(self));

  00000	0f b6 51 70	 movzx	 edx, BYTE PTR [rcx+112]
  00004	0f b6 41 71	 movzx	 eax, BYTE PTR [rcx+113]
  00008	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0000c	c1 e2 08	 shl	 edx, 8
  0000f	0b d0		 or	 edx, eax
  00011	c1 e2 08	 shl	 edx, 8
  00014	0b ca		 or	 ecx, edx

; 3976 : }

  00016	e9 00 00 00 00	 jmp	 PyLong_FromLong
datetime_microsecond ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_tzinfo DD imagerel datetime_tzinfo
	DD	imagerel datetime_tzinfo+93
	DD	imagerel $unwind$datetime_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_tzinfo DD 020601H
	DD	030025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT datetime_tzinfo
_TEXT	SEGMENT
self$ = 64
unused$ = 72
datetime_tzinfo PROC					; COMDAT

; 3980 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3981 :     PyObject *result = HASTZINFO(self) ? self->tzinfo : Py_None;

  00006	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0000a	74 06		 je	 SHORT $LN3@datetime_t
  0000c	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  00010	eb 07		 jmp	 SHORT $LN4@datetime_t
$LN3@datetime_t:
  00012	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_NoneStruct
$LN4@datetime_t:

; 3982 :     Py_INCREF(result);

  00019	e8 00 00 00 00	 call	 _Py_PXCTX
  0001e	85 c0		 test	 eax, eax
  00020	75 32		 jne	 SHORT $LN9@datetime_t
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00030	4c 8b cb	 mov	 r9, rbx
  00033	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00039	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00041	e8 00 00 00 00	 call	 _PyParallel_Guard
  00046	85 c0		 test	 eax, eax
  00048	75 06		 jne	 SHORT $LN5@datetime_t
  0004a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0004e	74 04		 je	 SHORT $LN9@datetime_t
$LN5@datetime_t:
  00050	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN9@datetime_t:

; 3983 :     return result;

  00054	48 8b c3	 mov	 rax, rbx

; 3984 : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
datetime_tzinfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_new DD imagerel datetime_new
	DD	imagerel datetime_new+533
	DD	imagerel $unwind$datetime_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_new DD 081601H
	DD	0163416H
	DD	0d00cf216H
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@
CONST	SEGMENT
??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@ DB 'iii|iiiiO', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_new
_TEXT	SEGMENT
minute$ = 96
hour$ = 100
day$ = 104
month$ = 108
year$ = 112
tzinfo$ = 120
type$ = 176
usecond$ = 184
args$ = 184
kw$ = 192
second$ = 200
datetime_new PROC					; COMDAT

; 4006 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	48 8b ec	 mov	 rbp, rsp
  0000f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 4007 :     PyObject *self = NULL;
; 4008 :     PyObject *state;
; 4009 :     int year;
; 4010 :     int month;
; 4011 :     int day;
; 4012 :     int hour = 0;
; 4013 :     int minute = 0;
; 4014 :     int second = 0;
; 4015 :     int usecond = 0;
; 4016 :     PyObject *tzinfo = Py_None;
; 4017 : 
; 4018 :     /* Check for invocation from pickle with __getstate__ state */
; 4019 :     if (PyTuple_GET_SIZE(args) >= 1 &&
; 4020 :         PyTuple_GET_SIZE(args) <= 2 &&
; 4021 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 4022 :         PyBytes_GET_SIZE(state) == _PyDateTime_DATETIME_DATASIZE &&
; 4023 :         MONTH_IS_SANE(PyBytes_AS_STRING(state)[2]))

  00016	4c 8b 4a 60	 mov	 r9, QWORD PTR [rdx+96]
  0001a	33 db		 xor	 ebx, ebx
  0001c	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  00023	49 8b f0	 mov	 rsi, r8
  00026	4c 8b da	 mov	 r11, rdx
  00029	4c 8b e1	 mov	 r12, rcx
  0002c	89 5d e4	 mov	 DWORD PTR hour$[rbp-128], ebx
  0002f	89 5d e0	 mov	 DWORD PTR minute$[rbp-128], ebx
  00032	89 5d 48	 mov	 DWORD PTR second$[rbp-128], ebx
  00035	89 5d 38	 mov	 DWORD PTR usecond$[rbp-128], ebx
  00038	4d 8b d5	 mov	 r10, r13
  0003b	4c 89 6d f8	 mov	 QWORD PTR tzinfo$[rbp-128], r13
  0003f	49 83 f9 01	 cmp	 r9, 1
  00043	0f 8c d1 00 00
	00		 jl	 $LN9@datetime_n
  00049	49 83 f9 02	 cmp	 r9, 2
  0004d	0f 8f c7 00 00
	00		 jg	 $LN9@datetime_n
  00053	48 8b 7a 70	 mov	 rdi, QWORD PTR [rdx+112]
  00057	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0005b	f7 80 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rax+256], 134217728 ; 08000000H
  00065	0f 84 af 00 00
	00		 je	 $LN9@datetime_n
  0006b	48 83 7f 60 0a	 cmp	 QWORD PTR [rdi+96], 10
  00070	0f 85 a4 00 00
	00		 jne	 $LN9@datetime_n
  00076	0f be 47 7a	 movsx	 eax, BYTE PTR [rdi+122]
  0007a	ff c8		 dec	 eax
  0007c	83 f8 0c	 cmp	 eax, 12
  0007f	0f 83 95 00 00
	00		 jae	 $LN9@datetime_n

; 4024 :     {
; 4025 :         PyDateTime_DateTime *me;
; 4026 :         char aware;
; 4027 : 
; 4028 :         if (PyTuple_GET_SIZE(args) == 2) {

  00085	49 83 f9 02	 cmp	 r9, 2
  00089	75 2f		 jne	 SHORT $LN7@datetime_n

; 4029 :             tzinfo = PyTuple_GET_ITEM(args, 1);

  0008b	48 8b 4a 78	 mov	 rcx, QWORD PTR [rdx+120]
  0008f	48 89 4d f8	 mov	 QWORD PTR tzinfo$[rbp-128], rcx

; 4030 :             if (check_tzinfo_subclass(tzinfo) < 0) {

  00093	e8 00 00 00 00	 call	 check_tzinfo_subclass
  00098	85 c0		 test	 eax, eax
  0009a	79 1a		 jns	 SHORT $LN12@datetime_n

; 4031 :                 PyErr_SetString(PyExc_TypeError, "bad "
; 4032 :                     "tzinfo state arg");

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
  000aa	e8 00 00 00 00	 call	 PyErr_SetString
$LN13@datetime_n:

; 4033 :                 return NULL;

  000af	33 c0		 xor	 eax, eax
  000b1	e9 48 01 00 00	 jmp	 $LN10@datetime_n
$LN12@datetime_n:
  000b6	4c 8b 55 f8	 mov	 r10, QWORD PTR tzinfo$[rbp-128]
$LN7@datetime_n:

; 4034 :             }
; 4035 :         }
; 4036 :         aware = (char)(tzinfo != Py_None);

  000ba	4d 3b d5	 cmp	 r10, r13

; 4037 :         me = (PyDateTime_DateTime *) (type->tp_alloc(type , aware));

  000bd	49 8b cc	 mov	 rcx, r12
  000c0	40 0f 95 c6	 setne	 sil
  000c4	48 0f be d6	 movsx	 rdx, sil
  000c8	41 ff 94 24 88
	01 00 00	 call	 QWORD PTR [r12+392]
  000d0	48 8b d8	 mov	 rbx, rax

; 4038 :         if (me != NULL) {

  000d3	48 85 c0	 test	 rax, rax
  000d6	0f 84 1f 01 00
	00		 je	 $LN4@datetime_n

; 4039 :             char *pdata = PyBytes_AS_STRING(state);
; 4040 : 
; 4041 :             memcpy(me->data, pdata, _PyDateTime_DATETIME_DATASIZE);

  000dc	48 8b 4f 78	 mov	 rcx, QWORD PTR [rdi+120]
  000e0	48 89 48 69	 mov	 QWORD PTR [rax+105], rcx
  000e4	0f b7 8f 80 00
	00 00		 movzx	 ecx, WORD PTR [rdi+128]

; 4042 :             me->hashcode = -1;

  000eb	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 4043 :             me->hastzinfo = aware;

  000f3	40 88 70 68	 mov	 BYTE PTR [rax+104], sil
  000f7	66 89 48 71	 mov	 WORD PTR [rax+113], cx

; 4044 :             if (aware) {

  000fb	40 84 f6	 test	 sil, sil
  000fe	0f 84 f7 00 00
	00		 je	 $LN4@datetime_n

; 4045 :                 Py_INCREF(tzinfo);

  00104	48 8b 4d f8	 mov	 rcx, QWORD PTR tzinfo$[rbp-128]
  00108	e8 00 00 00 00	 call	 _Py_IncRef

; 4046 :                 me->tzinfo = tzinfo;

  0010d	4c 8b 5d f8	 mov	 r11, QWORD PTR tzinfo$[rbp-128]
  00111	4c 89 5b 78	 mov	 QWORD PTR [rbx+120], r11

; 4047 :             }
; 4048 :         }
; 4049 :         return (PyObject *)me;

  00115	e9 e1 00 00 00	 jmp	 $LN4@datetime_n
$LN9@datetime_n:

; 4050 :     }
; 4051 : 
; 4052 :     if (PyArg_ParseTupleAndKeywords(args, kw, "iii|iiiiO", datetime_kws,
; 4053 :                                     &year, &month, &day, &hour, &minute,
; 4054 :                                     &second, &usecond, &tzinfo)) {

  0011a	48 8d 45 f8	 lea	 rax, QWORD PTR tzinfo$[rbp-128]
  0011e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:datetime_kws
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@
  0012c	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00131	48 8d 45 38	 lea	 rax, QWORD PTR usecond$[rbp-128]
  00135	48 8b d6	 mov	 rdx, rsi
  00138	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0013d	48 8d 45 48	 lea	 rax, QWORD PTR second$[rbp-128]
  00141	49 8b cb	 mov	 rcx, r11
  00144	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00149	48 8d 45 e0	 lea	 rax, QWORD PTR minute$[rbp-128]
  0014d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00152	48 8d 45 e4	 lea	 rax, QWORD PTR hour$[rbp-128]
  00156	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0015b	48 8d 45 e8	 lea	 rax, QWORD PTR day$[rbp-128]
  0015f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00164	48 8d 45 ec	 lea	 rax, QWORD PTR month$[rbp-128]
  00168	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016d	48 8d 45 f0	 lea	 rax, QWORD PTR year$[rbp-128]
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0017b	85 c0		 test	 eax, eax
  0017d	74 7c		 je	 SHORT $LN4@datetime_n

; 4055 :         if (check_date_args(year, month, day) < 0)

  0017f	44 8b 45 e8	 mov	 r8d, DWORD PTR day$[rbp-128]
  00183	8b 55 ec	 mov	 edx, DWORD PTR month$[rbp-128]
  00186	8b 4d f0	 mov	 ecx, DWORD PTR year$[rbp-128]
  00189	e8 00 00 00 00	 call	 check_date_args
  0018e	85 c0		 test	 eax, eax

; 4056 :             return NULL;

  00190	0f 88 19 ff ff
	ff		 js	 $LN13@datetime_n

; 4057 :         if (check_time_args(hour, minute, second, usecond) < 0)

  00196	44 8b 4d 38	 mov	 r9d, DWORD PTR usecond$[rbp-128]
  0019a	44 8b 45 48	 mov	 r8d, DWORD PTR second$[rbp-128]
  0019e	8b 55 e0	 mov	 edx, DWORD PTR minute$[rbp-128]
  001a1	8b 4d e4	 mov	 ecx, DWORD PTR hour$[rbp-128]
  001a4	e8 00 00 00 00	 call	 check_time_args
  001a9	85 c0		 test	 eax, eax

; 4058 :             return NULL;

  001ab	0f 88 fe fe ff
	ff		 js	 $LN13@datetime_n

; 4059 :         if (check_tzinfo_subclass(tzinfo) < 0)

  001b1	48 8b 4d f8	 mov	 rcx, QWORD PTR tzinfo$[rbp-128]
  001b5	e8 00 00 00 00	 call	 check_tzinfo_subclass
  001ba	85 c0		 test	 eax, eax

; 4060 :             return NULL;

  001bc	0f 88 ed fe ff
	ff		 js	 $LN13@datetime_n

; 4061 :         self = new_datetime_ex(year, month, day,
; 4062 :                                 hour, minute, second, usecond,
; 4063 :                                 tzinfo, type);

  001c2	48 8b 45 f8	 mov	 rax, QWORD PTR tzinfo$[rbp-128]
  001c6	44 8b 4d e4	 mov	 r9d, DWORD PTR hour$[rbp-128]
  001ca	44 8b 45 e8	 mov	 r8d, DWORD PTR day$[rbp-128]
  001ce	8b 55 ec	 mov	 edx, DWORD PTR month$[rbp-128]
  001d1	8b 4d f0	 mov	 ecx, DWORD PTR year$[rbp-128]
  001d4	4c 89 64 24 40	 mov	 QWORD PTR [rsp+64], r12
  001d9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001de	8b 45 38	 mov	 eax, DWORD PTR usecond$[rbp-128]
  001e1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001e5	8b 45 48	 mov	 eax, DWORD PTR second$[rbp-128]
  001e8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001ec	8b 45 e0	 mov	 eax, DWORD PTR minute$[rbp-128]
  001ef	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f3	e8 00 00 00 00	 call	 new_datetime_ex
  001f8	48 8b d8	 mov	 rbx, rax
$LN4@datetime_n:

; 4064 :     }
; 4065 :     return self;

  001fb	48 8b c3	 mov	 rax, rbx
$LN10@datetime_n:

; 4066 : }

  001fe	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  00206	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0020d	41 5d		 pop	 r13
  0020f	41 5c		 pop	 r12
  00211	5f		 pop	 rdi
  00212	5e		 pop	 rsi
  00213	5d		 pop	 rbp
  00214	c3		 ret	 0
datetime_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PFKMDOEK@iiiiiiiO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_from_timet_and_us DD imagerel datetime_from_timet_and_us
	DD	imagerel datetime_from_timet_and_us+189
	DD	imagerel $unwind$datetime_from_timet_and_us
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_from_timet_and_us DD 040f01H
	DD	0c340fH
	DD	0700b920fH
xdata	ENDS
;	COMDAT ??_C@_08PFKMDOEK@iiiiiiiO?$AA@
CONST	SEGMENT
??_C@_08PFKMDOEK@iiiiiiiO?$AA@ DB 'iiiiiiiO', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_from_timet_and_us
_TEXT	SEGMENT
cls$ = 96
f$ = 104
timet$ = 112
us$ = 120
tzinfo$ = 128
datetime_from_timet_and_us PROC				; COMDAT

; 4078 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b f9	 mov	 rdi, rcx

; 4079 :     struct tm *tm;
; 4080 : 
; 4081 :     tm = f(&timet);

  00012	48 8d 4c 24 70	 lea	 rcx, QWORD PTR timet$[rsp]
  00017	41 8b d9	 mov	 ebx, r9d
  0001a	ff d2		 call	 rdx
  0001c	4c 8b d8	 mov	 r11, rax

; 4082 :     if (tm == NULL) {

  0001f	48 85 c0	 test	 rax, rax
  00022	75 2e		 jne	 SHORT $LN3@datetime_f

; 4083 : #ifdef EINVAL
; 4084 :         if (errno == 0)

  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0002a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002d	75 0c		 jne	 SHORT $LN2@datetime_f

; 4085 :             errno = EINVAL;

  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00035	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN2@datetime_f:

; 4086 : #endif
; 4087 :         return PyErr_SetFromErrno(PyExc_OSError);

  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00042	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 4107 : }

  00047	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0004c	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00050	5f		 pop	 rdi
  00051	c3		 ret	 0
$LN3@datetime_f:

; 4088 :     }
; 4089 : 
; 4090 :     /* The platform localtime/gmtime may insert leap seconds,
; 4091 :      * indicated by tm->tm_sec > 59.  We don't care about them,
; 4092 :      * except to the extent that passing them on to the datetime
; 4093 :      * constructor would raise ValueError for a reason that
; 4094 :      * made no sense to the user.
; 4095 :      */
; 4096 :     if (tm->tm_sec > 59)

  00052	8b 00		 mov	 eax, DWORD PTR [rax]

; 4097 :         tm->tm_sec = 59;
; 4098 :     return PyObject_CallFunction(cls, "iiiiiiiO",
; 4099 :                                  tm->tm_year + 1900,
; 4100 :                                  tm->tm_mon + 1,
; 4101 :                                  tm->tm_mday,
; 4102 :                                  tm->tm_hour,
; 4103 :                                  tm->tm_min,
; 4104 :                                  tm->tm_sec,
; 4105 :                                  us,
; 4106 :                                  tzinfo);

  00054	45 8b 4b 10	 mov	 r9d, DWORD PTR [r11+16]
  00058	45 8b 43 14	 mov	 r8d, DWORD PTR [r11+20]
  0005c	b9 3b 00 00 00	 mov	 ecx, 59			; 0000003bH
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  00068	3b c1		 cmp	 eax, ecx
  0006a	0f 4f c1	 cmovg	 eax, ecx
  0006d	41 ff c1	 inc	 r9d
  00070	41 81 c0 6c 07
	00 00		 add	 r8d, 1900		; 0000076cH
  00077	41 89 03	 mov	 DWORD PTR [r11], eax
  0007a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tzinfo$[rsp]
  00082	48 8b cf	 mov	 rcx, rdi
  00085	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0008a	41 8b 03	 mov	 eax, DWORD PTR [r11]
  0008d	89 5c 24 40	 mov	 DWORD PTR [rsp+64], ebx
  00091	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00095	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  00099	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0009d	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  000a1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a5	41 8b 43 0c	 mov	 eax, DWORD PTR [r11+12]
  000a9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ad	e8 00 00 00 00	 call	 PyObject_CallFunction

; 4107 : }

  000b2	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
datetime_from_timet_and_us ENDP
_TEXT	ENDS
EXTRN	_PyTime_ObjectToTimeval:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_from_timestamp DD imagerel datetime_from_timestamp
	DD	imagerel datetime_from_timestamp+110
	DD	imagerel $unwind$datetime_from_timestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_from_timestamp DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_from_timestamp
_TEXT	SEGMENT
us$ = 48
timet$ = 56
cls$ = 80
f$ = 88
timestamp$ = 96
tzinfo$ = 104
datetime_from_timestamp PROC				; COMDAT

; 4119 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	49 8b c0	 mov	 rax, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 4120 :     time_t timet;
; 4121 :     long us;
; 4122 : 
; 4123 :     if (_PyTime_ObjectToTimeval(timestamp, &timet, &us) == -1)

  00018	4c 8d 44 24 30	 lea	 r8, QWORD PTR us$[rsp]
  0001d	48 8d 54 24 38	 lea	 rdx, QWORD PTR timet$[rsp]
  00022	48 8b c8	 mov	 rcx, rax
  00025	49 8b d9	 mov	 rbx, r9
  00028	e8 00 00 00 00	 call	 _PyTime_ObjectToTimeval
  0002d	83 f8 ff	 cmp	 eax, -1
  00030	75 12		 jne	 SHORT $LN1@datetime_f@2

; 4124 :         return NULL;

  00032	33 c0		 xor	 eax, eax

; 4126 : }

  00034	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00039	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0003e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN1@datetime_f@2:

; 4125 :     return datetime_from_timet_and_us(cls, f, timet, (int)us, tzinfo);

  00044	44 8b 4c 24 30	 mov	 r9d, DWORD PTR us$[rsp]
  00049	4c 8b 44 24 38	 mov	 r8, QWORD PTR timet$[rsp]
  0004e	48 8b d7	 mov	 rdx, rdi
  00051	48 8b ce	 mov	 rcx, rsi
  00054	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00059	e8 00 00 00 00	 call	 datetime_from_timet_and_us

; 4126 : }

  0005e	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00063	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00068	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
datetime_from_timestamp ENDP
_TEXT	ENDS
EXTRN	_PyTime_gettimeofday:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_best_possible DD imagerel datetime_best_possible
	DD	imagerel datetime_best_possible+76
	DD	imagerel $unwind$datetime_best_possible
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_best_possible DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_best_possible
_TEXT	SEGMENT
t$ = 48
cls$ = 80
f$ = 88
tzinfo$ = 96
datetime_best_possible PROC				; COMDAT

; 4134 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b f1	 mov	 rsi, rcx

; 4135 :     _PyTime_timeval t;
; 4136 :     _PyTime_gettimeofday(&t);

  00012	48 8d 4c 24 30	 lea	 rcx, QWORD PTR t$[rsp]
  00017	49 8b d8	 mov	 rbx, r8
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	e8 00 00 00 00	 call	 _PyTime_gettimeofday

; 4137 :     return datetime_from_timet_and_us(cls, f, t.tv_sec, (int)t.tv_usec,
; 4138 :                                       tzinfo);

  00022	44 8b 4c 24 38	 mov	 r9d, DWORD PTR t$[rsp+8]
  00027	4c 8b 44 24 30	 mov	 r8, QWORD PTR t$[rsp]
  0002c	48 8b d7	 mov	 rdx, rdi
  0002f	48 8b ce	 mov	 rcx, rsi
  00032	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00037	e8 00 00 00 00	 call	 datetime_from_timet_and_us

; 4139 : }

  0003c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00041	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00046	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0004a	5f		 pop	 rdi
  0004b	c3		 ret	 0
datetime_best_possible ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KEMIGBFM@?$HMO?3now?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_now DD imagerel datetime_now
	DD	imagerel datetime_now+227
	DD	imagerel $unwind$datetime_now
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_now DD 067f01H
	DD	08747fH
	DD	09340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT ??_C@_06KEMIGBFM@?$HMO?3now?$AA@
CONST	SEGMENT
??_C@_06KEMIGBFM@?$HMO?3now?$AA@ DB '|O:now', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_now
_TEXT	SEGMENT
cls$ = 64
args$ = 72
kw$ = 80
tzinfo$ = 88
datetime_now PROC					; COMDAT

; 4146 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	49 8b c0	 mov	 rax, r8
  00010	4c 8b d2	 mov	 r10, rdx

; 4147 :     PyObject *self;
; 4148 :     PyObject *tzinfo = Py_None;
; 4149 :     static char *keywords[] = {"tz", NULL};
; 4150 : 
; 4151 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|O:now", keywords,
; 4152 :                                       &tzinfo))

  00013	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tzinfo$[rsp]
  00018	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0001f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_now@@9@9
  00026	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KEMIGBFM@?$HMO?3now?$AA@
  00032	48 8b d0	 mov	 rdx, rax
  00035	49 8b ca	 mov	 rcx, r10
  00038	48 89 74 24 58	 mov	 QWORD PTR tzinfo$[rsp], rsi
  0003d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00042	85 c0		 test	 eax, eax
  00044	75 0d		 jne	 SHORT $LN3@datetime_n@2
$LN6@datetime_n@2:

; 4153 :         return NULL;

  00046	33 c0		 xor	 eax, eax

; 4167 :     }
; 4168 :     return self;
; 4169 : }

  00048	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5e		 pop	 rsi
  00052	c3		 ret	 0
$LN3@datetime_n@2:

; 4154 :     if (check_tzinfo_subclass(tzinfo) < 0)

  00053	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00058	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0005d	85 c0		 test	 eax, eax

; 4155 :         return NULL;

  0005f	78 e5		 js	 SHORT $LN6@datetime_n@2

; 4156 : 
; 4157 :     self = datetime_best_possible(cls,
; 4158 :                                   tzinfo == Py_None ? localtime : gmtime,
; 4159 :                                   tzinfo);

  00061	4c 8b 44 24 58	 mov	 r8, QWORD PTR tzinfo$[rsp]
  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtime
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime
  00074	4c 3b c6	 cmp	 r8, rsi
  00077	48 8b cb	 mov	 rcx, rbx
  0007a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0007f	48 0f 44 d0	 cmove	 rdx, rax
  00083	e8 00 00 00 00	 call	 datetime_best_possible
  00088	48 8b f8	 mov	 rdi, rax

; 4160 :     if (self != NULL && tzinfo != Py_None) {

  0008b	48 85 c0	 test	 rax, rax
  0008e	74 40		 je	 SHORT $LN1@datetime_n@2
  00090	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00095	48 3b ce	 cmp	 rcx, rsi
  00098	74 36		 je	 SHORT $LN1@datetime_n@2

; 4161 :         /* Convert UTC to tzinfo's zone. */
; 4162 :         PyObject *temp = self;
; 4163 :         _Py_IDENTIFIER(fromutc);
; 4164 : 
; 4165 :         self = _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", self);

  0009a	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  000a1	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  000aa	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_fromutc@?2??datetime_now@@9@9
  000af	4b 03 14 c8	 add	 rdx, QWORD PTR [r8+r9*8]
  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000ba	4c 8b c8	 mov	 r9, rax
  000bd	48 8b d8	 mov	 rbx, rax
  000c0	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 4166 :         Py_DECREF(temp);

  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	48 8b f8	 mov	 rdi, rax
  000cb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_n@2:

; 4167 :     }
; 4168 :     return self;
; 4169 : }

  000d0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000d5	48 8b c7	 mov	 rax, rdi
  000d8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000dd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e1	5e		 pop	 rsi
  000e2	c3		 ret	 0
datetime_now ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_utcnow
_TEXT	SEGMENT
cls$ = 8
dummy$ = 16
datetime_utcnow PROC					; COMDAT

; 4177 :     return datetime_best_possible(cls, gmtime, Py_None);

  00000	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime

; 4178 : }

  0000e	e9 00 00 00 00	 jmp	 datetime_best_possible
datetime_utcnow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_fromtimestamp DD imagerel datetime_fromtimestamp
	DD	imagerel datetime_fromtimestamp+242
	DD	imagerel $unwind$datetime_fromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_fromtimestamp DD 069201H
	DD	0a7492H
	DD	0b340aH
	DD	06006720aH
xdata	ENDS
;	COMDAT ??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@ DB 'O|O:fromtimestamp', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_fromtimestamp
_TEXT	SEGMENT
timestamp$ = 48
cls$ = 80
args$ = 88
kw$ = 96
tzinfo$ = 104
datetime_fromtimestamp PROC				; COMDAT

; 4183 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	49 8b c0	 mov	 rax, r8
  00010	4c 8b d2	 mov	 r10, rdx

; 4184 :     PyObject *self;
; 4185 :     PyObject *timestamp;
; 4186 :     PyObject *tzinfo = Py_None;
; 4187 :     static char *keywords[] = {"timestamp", "tz", NULL};
; 4188 : 
; 4189 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "O|O:fromtimestamp",
; 4190 :                                       keywords, &timestamp, &tzinfo))

  00013	48 8d 4c 24 68	 lea	 rcx, QWORD PTR tzinfo$[rsp]
  00018	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  0001f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_fromtimestamp@@9@9
  00026	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR timestamp$[rsp]
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	48 8b d0	 mov	 rdx, rax
  0003f	49 8b ca	 mov	 rcx, r10
  00042	48 89 74 24 68	 mov	 QWORD PTR tzinfo$[rsp], rsi
  00047	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0004c	85 c0		 test	 eax, eax
  0004e	75 0d		 jne	 SHORT $LN3@datetime_f@3
$LN6@datetime_f@3:

; 4191 :         return NULL;

  00050	33 c0		 xor	 eax, eax

; 4206 :     }
; 4207 :     return self;
; 4208 : }

  00052	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00057	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0005b	5e		 pop	 rsi
  0005c	c3		 ret	 0
$LN3@datetime_f@3:

; 4192 :     if (check_tzinfo_subclass(tzinfo) < 0)

  0005d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00062	e8 00 00 00 00	 call	 check_tzinfo_subclass
  00067	85 c0		 test	 eax, eax

; 4193 :         return NULL;

  00069	78 e5		 js	 SHORT $LN6@datetime_f@3

; 4194 : 
; 4195 :     self = datetime_from_timestamp(cls,
; 4196 :                                    tzinfo == Py_None ? localtime : gmtime,
; 4197 :                                    timestamp,
; 4198 :                                    tzinfo);

  0006b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR tzinfo$[rsp]
  00070	4c 8b 44 24 30	 mov	 r8, QWORD PTR timestamp$[rsp]
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtime
  0007c	4c 3b ce	 cmp	 r9, rsi
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime
  00086	48 8b cb	 mov	 rcx, rbx
  00089	48 0f 44 d0	 cmove	 rdx, rax
  0008d	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00092	e8 00 00 00 00	 call	 datetime_from_timestamp
  00097	48 8b f8	 mov	 rdi, rax

; 4199 :     if (self != NULL && tzinfo != Py_None) {

  0009a	48 85 c0	 test	 rax, rax
  0009d	74 40		 je	 SHORT $LN1@datetime_f@3
  0009f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  000a4	48 3b ce	 cmp	 rcx, rsi
  000a7	74 36		 je	 SHORT $LN1@datetime_f@3

; 4200 :         /* Convert UTC to tzinfo's zone. */
; 4201 :         PyObject *temp = self;
; 4202 :         _Py_IDENTIFIER(fromutc);
; 4203 : 
; 4204 :         self = _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", self);

  000a9	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR _tls_index
  000b0	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  000b9	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_fromutc@?2??datetime_fromtimestamp@@9@9
  000be	4b 03 14 c8	 add	 rdx, QWORD PTR [r8+r9*8]
  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000c9	4c 8b c8	 mov	 r9, rax
  000cc	48 8b d8	 mov	 rbx, rax
  000cf	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 4205 :         Py_DECREF(temp);

  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	48 8b f8	 mov	 rdi, rax
  000da	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_f@3:

; 4206 :     }
; 4207 :     return self;
; 4208 : }

  000df	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000e4	48 8b c7	 mov	 rax, rdi
  000e7	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000ec	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f0	5e		 pop	 rsi
  000f1	c3		 ret	 0
datetime_fromtimestamp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_utcfromtimestamp DD imagerel datetime_utcfromtimestamp
	DD	imagerel datetime_utcfromtimestamp+77
	DD	imagerel $unwind$datetime_utcfromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utcfromtimestamp DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@ DB 'O:utcfromtimestamp', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_utcfromtimestamp
_TEXT	SEGMENT
cls$ = 48
args$ = 56
timestamp$ = 64
datetime_utcfromtimestamp PROC				; COMDAT

; 4213 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 4214 :     PyObject *timestamp;
; 4215 :     PyObject *result = NULL;
; 4216 : 
; 4217 :     if (PyArg_ParseTuple(args, "O:utcfromtimestamp", &timestamp))

  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR timestamp$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00020	85 c0		 test	 eax, eax
  00022	74 21		 je	 SHORT $LN4@datetime_u

; 4218 :         result = datetime_from_timestamp(cls, gmtime, timestamp,
; 4219 :                                          Py_None);

  00024	4c 8b 44 24 40	 mov	 r8, QWORD PTR timestamp$[rsp]
  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 datetime_from_timestamp

; 4221 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN4@datetime_u:

; 4220 :     return result;

  00045	33 c0		 xor	 eax, eax

; 4221 : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
datetime_utcfromtimestamp ENDP
_TEXT	ENDS
PUBLIC	??_C@_03BBOLPBLP@OOO?$AA@			; `string'
PUBLIC	??_C@_09NHHCNPOC@_strptime?$AA@			; `string'
PUBLIC	??_C@_0M@NFNCOCLF@UU?3strptime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_strptime DD imagerel datetime_strptime
	DD	imagerel datetime_strptime+156
	DD	imagerel $unwind$datetime_strptime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_strptime DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_03BBOLPBLP@OOO?$AA@
CONST	SEGMENT
??_C@_03BBOLPBLP@OOO?$AA@ DB 'OOO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NHHCNPOC@_strptime?$AA@
CONST	SEGMENT
??_C@_09NHHCNPOC@_strptime?$AA@ DB '_strptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFNCOCLF@UU?3strptime?$AA@
CONST	SEGMENT
??_C@_0M@NFNCOCLF@UU?3strptime?$AA@ DB 'UU:strptime', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_strptime
_TEXT	SEGMENT
cls$ = 64
args$ = 72
format$ = 80
string$ = 88
datetime_strptime PROC					; COMDAT

; 4226 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 4227 :     static PyObject *module = NULL;
; 4228 :     PyObject *string, *format;
; 4229 :     _Py_IDENTIFIER(_strptime_datetime);
; 4230 : 
; 4231 :     if (!PyArg_ParseTuple(args, "UU:strptime", &string, &format))

  0000c	4c 8d 4c 24 50	 lea	 r9, QWORD PTR format$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NFNCOCLF@UU?3strptime?$AA@
  00018	4c 8d 44 24 58	 lea	 r8, QWORD PTR string$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00025	85 c0		 test	 eax, eax
  00027	75 08		 jne	 SHORT $LN3@datetime_s
$LN6@datetime_s:

; 4232 :         return NULL;

  00029	33 c0		 xor	 eax, eax

; 4241 : }

  0002b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
$LN3@datetime_s:

; 4233 : 
; 4234 :     if (module == NULL) {

  00031	4c 8b 15 00 00
	00 00		 mov	 r10, QWORD PTR ?module@?1??datetime_strptime@@9@9
  00038	4d 85 d2	 test	 r10, r10
  0003b	75 1b		 jne	 SHORT $LN1@datetime_s

; 4235 :         module = PyImport_ImportModuleNoBlock("_strptime");

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09NHHCNPOC@_strptime?$AA@
  00044	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00049	4c 8b d0	 mov	 r10, rax
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module@?1??datetime_strptime@@9@9, rax

; 4236 :         if (module == NULL)

  00053	48 85 c0	 test	 rax, rax

; 4237 :             return NULL;

  00056	74 d1		 je	 SHORT $LN6@datetime_s
$LN1@datetime_s:

; 4238 :     }
; 4239 :     return _PyObject_CallMethodId(module, &PyId__strptime_datetime, "OOO",
; 4240 :                                  cls, string, format);

  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0005e	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00067	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__strptime_datetime@?1??datetime_strptime@@9@9
  0006c	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR format$[rsp]
  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03BBOLPBLP@OOO?$AA@
  0007c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00081	48 8b 44 24 58	 mov	 rax, QWORD PTR string$[rsp]
  00086	4c 8b cb	 mov	 r9, rbx
  00089	49 8b ca	 mov	 rcx, r10
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 4241 : }

  00096	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009a	5b		 pop	 rbx
  0009b	c3		 ret	 0
datetime_strptime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_combine DD imagerel datetime_combine
	DD	imagerel datetime_combine+96
	DD	imagerel $unwind$datetime_combine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$datetime_combine DD imagerel datetime_combine+96
	DD	imagerel datetime_combine+247
	DD	imagerel $chain$1$datetime_combine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$datetime_combine DD imagerel datetime_combine+247
	DD	imagerel datetime_combine+255
	DD	imagerel $chain$2$datetime_combine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$datetime_combine DD 021H
	DD	imagerel datetime_combine
	DD	imagerel datetime_combine+96
	DD	imagerel $unwind$datetime_combine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$datetime_combine DD 040a21H
	DD	0f740aH
	DD	0e3405H
	DD	imagerel datetime_combine
	DD	imagerel datetime_combine+96
	DD	imagerel $unwind$datetime_combine
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_combine DD 020801H
	DD	06004b208H
xdata	ENDS
;	COMDAT ??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@
CONST	SEGMENT
??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@ DB 'O!O!:combine', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_combine
_TEXT	SEGMENT
date$ = 80
cls$ = 112
args$ = 120
kw$ = 128
time$ = 136
datetime_combine PROC					; COMDAT

; 4246 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	56		 push	 rsi
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	48 8b f1	 mov	 rsi, rcx

; 4247 :     static char *keywords[] = {"date", "time", NULL};
; 4248 :     PyObject *date;
; 4249 :     PyObject *time;
; 4250 :     PyObject *result = NULL;
; 4251 : 
; 4252 :     if (PyArg_ParseTupleAndKeywords(args, kw, "O!O!:combine", keywords,
; 4253 :                                     &PyDateTime_DateType, &date,
; 4254 :                                     &PyDateTime_TimeType, &time)) {

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00016	4c 8b d2	 mov	 r10, rdx
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeType
  00020	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00024	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  00028	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_combine@@9@9
  0002f	49 89 4b c0	 mov	 QWORD PTR [r11-64], rcx
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateType
  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@
  00041	49 89 4b b8	 mov	 QWORD PTR [r11-72], rcx
  00045	49 8b ca	 mov	 rcx, r10
  00048	48 8b d0	 mov	 rdx, rax
  0004b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00050	85 c0		 test	 eax, eax
  00052	0f 84 9f 00 00
	00		 je	 $LN5@datetime_c

; 4255 :         PyObject *tzinfo = Py_None;
; 4256 : 
; 4257 :         if (HASTZINFO(time))

  00058	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR time$[rsp]
  00060	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00065	48 89 7c 24 78	 mov	 QWORD PTR [rsp+120], rdi
  0006a	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0006e	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00075	74 04		 je	 SHORT $LN1@datetime_c

; 4258 :             tzinfo = ((PyDateTime_Time *)time)->tzinfo;

  00077	48 8b 79 70	 mov	 rdi, QWORD PTR [rcx+112]
$LN1@datetime_c:

; 4259 :         result = PyObject_CallFunction(cls, "iiiiiiiO",
; 4260 :                                         GET_YEAR(date),
; 4261 :                                         GET_MONTH(date),
; 4262 :                                         GET_DAY(date),
; 4263 :                                         TIME_GET_HOUR(time),
; 4264 :                                         TIME_GET_MINUTE(time),
; 4265 :                                         TIME_GET_SECOND(time),
; 4266 :                                         TIME_GET_MICROSECOND(time),
; 4267 :                                         tzinfo);

  0007b	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  0007f	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  00083	0f b6 59 6c	 movzx	 ebx, BYTE PTR [rcx+108]
  00087	44 0f b6 51 6a	 movzx	 r10d, BYTE PTR [rcx+106]
  0008c	44 0f b6 59 69	 movzx	 r11d, BYTE PTR [rcx+105]
  00091	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  00096	c1 e3 08	 shl	 ebx, 8
  00099	0b d8		 or	 ebx, eax
  0009b	0f b6 41 6e	 movzx	 eax, BYTE PTR [rcx+110]
  0009f	c1 e3 08	 shl	 ebx, 8
  000a2	0b d8		 or	 ebx, eax
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR date$[rsp]
  000a9	0f b6 48 6c	 movzx	 ecx, BYTE PTR [rax+108]
  000ad	44 0f b6 40 69	 movzx	 r8d, BYTE PTR [rax+105]
  000b2	44 0f b6 48 6b	 movzx	 r9d, BYTE PTR [rax+107]
  000b7	0f b6 40 6a	 movzx	 eax, BYTE PTR [rax+106]
  000bb	89 5c 24 40	 mov	 DWORD PTR [rsp+64], ebx
  000bf	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000c3	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  000c8	41 c1 e0 08	 shl	 r8d, 8
  000cc	44 89 5c 24 28	 mov	 DWORD PTR [rsp+40], r11d
  000d1	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  000dc	44 0b c0	 or	 r8d, eax
  000df	48 8b ce	 mov	 rcx, rsi
  000e2	e8 00 00 00 00	 call	 PyObject_CallFunction
  000e7	48 8b 7c 24 78	 mov	 rdi, QWORD PTR [rsp+120]
  000ec	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 4270 : }

  000f1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000f5	5e		 pop	 rsi
  000f6	c3		 ret	 0
$LN5@datetime_c:

; 4268 :     }
; 4269 :     return result;

  000f7	33 c0		 xor	 eax, eax

; 4270 : }

  000f9	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000fd	5e		 pop	 rsi
  000fe	c3		 ret	 0
datetime_combine ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_dealloc DD imagerel datetime_dealloc
	DD	imagerel datetime_dealloc+15
	DD	imagerel $unwind$datetime_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$datetime_dealloc DD imagerel datetime_dealloc+15
	DD	imagerel datetime_dealloc+135
	DD	imagerel $chain$0$datetime_dealloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$datetime_dealloc DD imagerel datetime_dealloc+135
	DD	imagerel datetime_dealloc+154
	DD	imagerel $chain$1$datetime_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$datetime_dealloc DD 021H
	DD	imagerel datetime_dealloc
	DD	imagerel datetime_dealloc+15
	DD	imagerel $unwind$datetime_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$datetime_dealloc DD 020521H
	DD	083405H
	DD	imagerel datetime_dealloc
	DD	imagerel datetime_dealloc+15
	DD	imagerel $unwind$datetime_dealloc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_dealloc DD 020601H
	DD	070025206H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT datetime_dealloc
_TEXT	SEGMENT
self$ = 64
datetime_dealloc PROC					; COMDAT

; 4278 : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4279 :     if (HASTZINFO(self)) {

  00006	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	74 78		 je	 SHORT $LN2@datetime_d

; 4280 :         Py_XDECREF(self->tzinfo);

  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b 59 78	 mov	 rbx, QWORD PTR [rcx+120]
  00018	48 85 db	 test	 rbx, rbx
  0001b	74 65		 je	 SHORT $LN3@datetime_d
  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	75 5c		 jne	 SHORT $LN3@datetime_d
  00026	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0002a	a8 20		 test	 al, 32			; 00000020H
  0002c	75 4c		 jne	 SHORT $LN12@datetime_d
  0002e	84 c0		 test	 al, al
  00030	78 48		 js	 SHORT $LN12@datetime_d
  00032	a8 02		 test	 al, 2
  00034	75 4c		 jne	 SHORT $LN3@datetime_d
  00036	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003a	75 46		 jne	 SHORT $LN3@datetime_d
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004a	4c 8b cb	 mov	 r9, rbx
  0004d	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00053	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00060	48 8b cb	 mov	 rcx, rbx
  00063	85 c0		 test	 eax, eax
  00065	74 07		 je	 SHORT $LN17@datetime_d
  00067	e8 00 00 00 00	 call	 _Px_Dealloc
  0006c	eb 14		 jmp	 SHORT $LN3@datetime_d
$LN17@datetime_d:
  0006e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00072	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00078	eb 08		 jmp	 SHORT $LN3@datetime_d
$LN12@datetime_d:
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	e8 00 00 00 00	 call	 Px_DecRef
$LN3@datetime_d:
  00082	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN2@datetime_d:

; 4281 :     }
; 4282 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00087	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0008b	48 8b cf	 mov	 rcx, rdi

; 4283 : }

  0008e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00092	5f		 pop	 rdi
  00093	48 ff a0 98 01
	00 00		 rex_jmp QWORD PTR [rax+408]
datetime_dealloc ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_utcoffset
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_utcoffset PROC					; COMDAT

; 4292 :     return call_utcoffset(GET_DT_TZINFO(self), self);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 0f		 je	 SHORT $LN3@datetime_u@2
  00006	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0000a	48 8b d1	 mov	 rdx, rcx
  0000d	48 8b c8	 mov	 rcx, rax

; 4293 : }

  00010	e9 00 00 00 00	 jmp	 call_utcoffset
$LN3@datetime_u@2:

; 4292 :     return call_utcoffset(GET_DT_TZINFO(self), self);

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001c	48 8b d1	 mov	 rdx, rcx
  0001f	48 8b c8	 mov	 rcx, rax

; 4293 : }

  00022	e9 00 00 00 00	 jmp	 call_utcoffset
datetime_utcoffset ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_dst
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_dst PROC					; COMDAT

; 4297 :     return call_dst(GET_DT_TZINFO(self), self);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 0f		 je	 SHORT $LN3@datetime_d@2
  00006	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0000a	48 8b d1	 mov	 rdx, rcx
  0000d	48 8b c8	 mov	 rcx, rax

; 4298 : }

  00010	e9 00 00 00 00	 jmp	 call_dst
$LN3@datetime_d@2:

; 4297 :     return call_dst(GET_DT_TZINFO(self), self);

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001c	48 8b d1	 mov	 rdx, rcx
  0001f	48 8b c8	 mov	 rcx, rax

; 4298 : }

  00022	e9 00 00 00 00	 jmp	 call_dst
datetime_dst ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_tzname
_TEXT	SEGMENT
self$ = 8
unused$ = 16
datetime_tzname PROC					; COMDAT

; 4302 :     return call_tzname(GET_DT_TZINFO(self), self);

  00000	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00004	74 0f		 je	 SHORT $LN3@datetime_t@2
  00006	48 8b 41 78	 mov	 rax, QWORD PTR [rcx+120]
  0000a	48 8b d1	 mov	 rdx, rcx
  0000d	48 8b c8	 mov	 rcx, rax

; 4303 : }

  00010	e9 00 00 00 00	 jmp	 call_tzname
$LN3@datetime_t@2:

; 4302 :     return call_tzname(GET_DT_TZINFO(self), self);

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001c	48 8b d1	 mov	 rdx, rcx
  0001f	48 8b c8	 mov	 rcx, rax

; 4303 : }

  00022	e9 00 00 00 00	 jmp	 call_tzname
datetime_tzname ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_datetime_timedelta DD imagerel add_datetime_timedelta
	DD	imagerel add_datetime_timedelta+278
	DD	imagerel $unwind$add_datetime_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_datetime_timedelta DD 020801H
	DD	03004b208H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT add_datetime_timedelta
_TEXT	SEGMENT
day$ = 80
month$ = 84
year$ = 88
second$ = 112
date$ = 112
minute$ = 120
delta$ = 120
microsecond$ = 128
factor$ = 128
hour$ = 136
add_datetime_timedelta PROC				; COMDAT

; 4315 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 4316 :     /* Note that the C-level additions can't overflow, because of
; 4317 :      * invariant bounds on the member values.
; 4318 :      */
; 4319 :     int year = GET_YEAR(date);

  00008	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  0000c	44 0f b6 49 69	 movzx	 r9d, BYTE PTR [rcx+105]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	41 c1 e1 08	 shl	 r9d, 8
  00018	44 0b c8	 or	 r9d, eax

; 4320 :     int month = GET_MONTH(date);

  0001b	0f b6 41 6b	 movzx	 eax, BYTE PTR [rcx+107]
  0001f	89 44 24 54	 mov	 DWORD PTR month$[rsp], eax

; 4321 :     int day = GET_DAY(date) + GET_TD_DAYS(delta) * factor;

  00023	0f b6 41 6c	 movzx	 eax, BYTE PTR [rcx+108]
  00027	45 89 4b f0	 mov	 DWORD PTR [r11-16], r9d
  0002b	44 8b 4a 68	 mov	 r9d, DWORD PTR [rdx+104]
  0002f	45 0f af c8	 imul	 r9d, r8d
  00033	44 03 c8	 add	 r9d, eax

; 4322 :     int hour = DATE_GET_HOUR(date);

  00036	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  0003a	41 89 43 20	 mov	 DWORD PTR [r11+32], eax

; 4323 :     int minute = DATE_GET_MINUTE(date);

  0003e	0f b6 41 6e	 movzx	 eax, BYTE PTR [rcx+110]

; 4324 :     int second = DATE_GET_SECOND(date) + GET_TD_SECONDS(delta) * factor;

  00042	8b 4a 6c	 mov	 ecx, DWORD PTR [rdx+108]
  00045	41 0f af c8	 imul	 ecx, r8d
  00049	89 44 24 78	 mov	 DWORD PTR minute$[rsp], eax
  0004d	0f b6 43 6f	 movzx	 eax, BYTE PTR [rbx+111]
  00051	03 c8		 add	 ecx, eax

; 4325 :     int microsecond = DATE_GET_MICROSECOND(date) +
; 4326 :                       GET_TD_MICROSECONDS(delta) * factor;

  00053	0f b6 43 71	 movzx	 eax, BYTE PTR [rbx+113]
  00057	45 89 4b e8	 mov	 DWORD PTR [r11-24], r9d
  0005b	89 4c 24 70	 mov	 DWORD PTR second$[rsp], ecx
  0005f	0f b6 4b 70	 movzx	 ecx, BYTE PTR [rbx+112]

; 4327 : 
; 4328 :     assert(factor == 1 || factor == -1);
; 4329 :     if (normalize_datetime(&year, &month, &day,
; 4330 :                            &hour, &minute, &second, &microsecond) < 0)

  00063	4d 8d 4b 20	 lea	 r9, QWORD PTR [r11+32]
  00067	c1 e1 08	 shl	 ecx, 8
  0006a	0b c8		 or	 ecx, eax
  0006c	0f b6 43 72	 movzx	 eax, BYTE PTR [rbx+114]
  00070	c1 e1 08	 shl	 ecx, 8
  00073	0b c8		 or	 ecx, eax
  00075	8b 42 70	 mov	 eax, DWORD PTR [rdx+112]
  00078	49 8d 53 ec	 lea	 rdx, QWORD PTR [r11-20]
  0007c	41 0f af c0	 imul	 eax, r8d
  00080	03 c8		 add	 ecx, eax
  00082	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  00086	49 89 43 c8	 mov	 QWORD PTR [r11-56], rax
  0008a	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  0008e	41 89 4b 18	 mov	 DWORD PTR [r11+24], ecx
  00092	49 89 43 c0	 mov	 QWORD PTR [r11-64], rax
  00096	49 8d 43 10	 lea	 rax, QWORD PTR [r11+16]
  0009a	4d 8d 43 e8	 lea	 r8, QWORD PTR [r11-24]
  0009e	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  000a2	49 89 43 b8	 mov	 QWORD PTR [r11-72], rax
  000a6	e8 00 00 00 00	 call	 normalize_datetime
  000ab	85 c0		 test	 eax, eax
  000ad	79 08		 jns	 SHORT $LN2@add_dateti

; 4331 :         return NULL;

  000af	33 c0		 xor	 eax, eax

; 4336 : }

  000b1	48 83 c4 60	 add	 rsp, 96			; 00000060H
  000b5	5b		 pop	 rbx
  000b6	c3		 ret	 0
$LN2@add_dateti:

; 4332 :     else
; 4333 :         return new_datetime(year, month, day,
; 4334 :                             hour, minute, second, microsecond,
; 4335 :                             HASTZINFO(date) ? date->tzinfo : Py_None);

  000b7	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  000bb	74 06		 je	 SHORT $LN5@add_dateti
  000bd	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  000c1	eb 07		 jmp	 SHORT $LN6@add_dateti
$LN5@add_dateti:
  000c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@add_dateti:
  000ca	44 8b 8c 24 88
	00 00 00	 mov	 r9d, DWORD PTR hour$[rsp]
  000d2	44 8b 44 24 50	 mov	 r8d, DWORD PTR day$[rsp]
  000d7	8b 54 24 54	 mov	 edx, DWORD PTR month$[rsp]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateTimeType
  000e2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e7	8b 4c 24 58	 mov	 ecx, DWORD PTR year$[rsp]
  000eb	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000f0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR microsecond$[rsp]
  000f7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000fb	8b 44 24 70	 mov	 eax, DWORD PTR second$[rsp]
  000ff	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00103	8b 44 24 78	 mov	 eax, DWORD PTR minute$[rsp]
  00107	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0010b	e8 00 00 00 00	 call	 new_datetime_ex

; 4336 : }

  00110	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00114	5b		 pop	 rbx
  00115	c3		 ret	 0
add_datetime_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_add DD imagerel datetime_add
	DD	imagerel datetime_add+213
	DD	imagerel $unwind$datetime_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_add DD 040a01H
	DD	08340aH
	DD	07006520aH
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT datetime_add
_TEXT	SEGMENT
left$ = 64
right$ = 72
datetime_add PROC					; COMDAT

; 4340 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx

; 4341 :     if (PyDateTime_Check(left)) {

  0000d	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 2a		 je	 SHORT $LN6@datetime_a@2
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 21		 jne	 SHORT $LN6@datetime_a@2

; 4349 :     }
; 4350 :     else if (PyDelta_Check(left)) {

  00029	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00034	48 3b ca	 cmp	 rcx, rdx
  00037	74 09		 je	 SHORT $LN1@datetime_a@2
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	74 21		 je	 SHORT $LN5@datetime_a@2
$LN1@datetime_a@2:

; 4351 :         /* delta + datetime */
; 4352 :         return add_datetime_timedelta((PyDateTime_DateTime *) right,
; 4353 :                                       (PyDateTime_Delta *) left,
; 4354 :                                       1);

  00042	48 8b d3	 mov	 rdx, rbx
  00045	48 8b cf	 mov	 rcx, rdi
  00048	eb 76		 jmp	 SHORT $LN14@datetime_a@2
$LN6@datetime_a@2:

; 4342 :         /* datetime + ??? */
; 4343 :         if (PyDelta_Check(right))

  0004a	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00055	48 3b ca	 cmp	 rcx, rdx
  00058	74 60		 je	 SHORT $LN4@datetime_a@2
  0005a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005f	85 c0		 test	 eax, eax
  00061	75 57		 jne	 SHORT $LN4@datetime_a@2
$LN5@datetime_a@2:

; 4355 :     }
; 4356 :     Py_RETURN_NOTIMPLEMENTED;

  00063	e8 00 00 00 00	 call	 _Py_PXCTX
  00068	85 c0		 test	 eax, eax
  0006a	75 3c		 jne	 SHORT $LN11@datetime_a@2
  0006c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NotImplementedStruct
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00081	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00087	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00094	85 c0		 test	 eax, eax
  00096	75 09		 jne	 SHORT $LN10@datetime_a@2
  00098	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NotImplementedStruct+32, 32 ; 00000020H
  0009f	74 07		 je	 SHORT $LN11@datetime_a@2
$LN10@datetime_a@2:
  000a1	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NotImplementedStruct+80
$LN11@datetime_a@2:
  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4357 : }

  000af	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN4@datetime_a@2:

; 4344 :             /* datetime + delta */
; 4345 :             return add_datetime_timedelta(
; 4346 :                             (PyDateTime_DateTime *)left,
; 4347 :                             (PyDateTime_Delta *)right,
; 4348 :                             1);

  000ba	48 8b d7	 mov	 rdx, rdi
  000bd	48 8b cb	 mov	 rcx, rbx
$LN14@datetime_a@2:
  000c0	41 b8 01 00 00
	00		 mov	 r8d, 1

; 4357 : }

  000c6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	e9 00 00 00 00	 jmp	 add_datetime_timedelta
datetime_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_subtract DD imagerel datetime_subtract
	DD	imagerel datetime_subtract+855
	DD	imagerel $unwind$datetime_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_subtract DD 0c1e01H
	DD	0d741eH
	DD	0c641eH
	DD	0b541eH
	DD	0a341eH
	DD	0e01a521eH
	DD	0c016d018H
xdata	ENDS
;	COMDAT ??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@
CONST	SEGMENT
??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@ DB 'can''t sub'
	DB	'tract offset-naive and offset-aware datetimes', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT datetime_subtract
_TEXT	SEGMENT
left$ = 80
right$ = 88
datetime_subtract PROC					; COMDAT

; 4361 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001e	4c 8b e1	 mov	 r12, rcx

; 4362 :     PyObject *result = Py_NotImplemented;
; 4363 : 
; 4364 :     if (PyDateTime_Check(left)) {

  00021	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00025	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:PyDateTime_DateTimeType
  0002c	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NotImplementedStruct
  00033	48 8b f2	 mov	 rsi, rdx
  00036	49 8b fe	 mov	 rdi, r14
  00039	48 3b cb	 cmp	 rcx, rbx
  0003c	74 10		 je	 SHORT $LN15@datetime_s@2
  0003e	48 8b d3	 mov	 rdx, rbx
  00041	e8 00 00 00 00	 call	 PyType_IsSubtype
  00046	85 c0		 test	 eax, eax
  00048	0f 84 ac 02 00
	00		 je	 $LN35@datetime_s@2
$LN15@datetime_s@2:

; 4365 :         /* datetime - ??? */
; 4366 :         if (PyDateTime_Check(right)) {

  0004e	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00052	48 3b cb	 cmp	 rcx, rbx
  00055	74 43		 je	 SHORT $LN13@datetime_s@2
  00057	48 8b d3	 mov	 rdx, rbx
  0005a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005f	85 c0		 test	 eax, eax
  00061	75 37		 jne	 SHORT $LN13@datetime_s@2

; 4429 :             }
; 4430 :         }
; 4431 :         else if (PyDelta_Check(right)) {

  00063	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0006e	48 3b c8	 cmp	 rcx, rax
  00071	74 10		 je	 SHORT $LN2@datetime_s@2
  00073	48 8b d0	 mov	 rdx, rax
  00076	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007b	85 c0		 test	 eax, eax
  0007d	0f 84 77 02 00
	00		 je	 $LN35@datetime_s@2
$LN2@datetime_s@2:

; 4432 :             /* datetime - delta */
; 4433 :             result = add_datetime_timedelta(
; 4434 :                             (PyDateTime_DateTime *)left,
; 4435 :                             (PyDateTime_Delta *)right,
; 4436 :                             -1);

  00083	41 83 c8 ff	 or	 r8d, -1
  00087	48 8b d6	 mov	 rdx, rsi
  0008a	49 8b cc	 mov	 rcx, r12
  0008d	e8 00 00 00 00	 call	 add_datetime_timedelta
  00092	48 8b f8	 mov	 rdi, rax
  00095	e9 5b 02 00 00	 jmp	 $LN5@datetime_s@2
$LN13@datetime_s@2:

; 4367 :             /* datetime - datetime */
; 4368 :             PyObject *offset1, *offset2, *offdiff = NULL;

  0009a	33 ed		 xor	 ebp, ebp

; 4369 :             int delta_d, delta_s, delta_us;
; 4370 : 
; 4371 :             if (GET_DT_TZINFO(left) == GET_DT_TZINFO(right)) {

  0009c	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  000a3	41 38 6c 24 68	 cmp	 BYTE PTR [r12+104], bpl
  000a8	74 07		 je	 SHORT $LN19@datetime_s@2
  000aa	49 8b 4c 24 78	 mov	 rcx, QWORD PTR [r12+120]
  000af	eb 03		 jmp	 SHORT $LN20@datetime_s@2
$LN19@datetime_s@2:
  000b1	49 8b cd	 mov	 rcx, r13
$LN20@datetime_s@2:
  000b4	40 38 6e 68	 cmp	 BYTE PTR [rsi+104], bpl
  000b8	74 06		 je	 SHORT $LN21@datetime_s@2
  000ba	48 8b 46 78	 mov	 rax, QWORD PTR [rsi+120]
  000be	eb 03		 jmp	 SHORT $LN22@datetime_s@2
$LN21@datetime_s@2:
  000c0	49 8b c5	 mov	 rax, r13
$LN22@datetime_s@2:
  000c3	48 3b c8	 cmp	 rcx, rax
  000c6	0f 85 95 00 00
	00		 jne	 $LN12@datetime_s@2

; 4372 :                 offset2 = offset1 = Py_None;

  000cc	49 8b dd	 mov	 rbx, r13
  000cf	49 8b fd	 mov	 rdi, r13

; 4373 :                 Py_INCREF(offset1);

  000d2	e8 00 00 00 00	 call	 _Py_PXCTX
  000d7	85 c0		 test	 eax, eax
  000d9	75 38		 jne	 SHORT $LN24@datetime_s@2
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  000e9	4d 8b cd	 mov	 r9, r13
  000ec	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000f2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000fa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ff	85 c0		 test	 eax, eax
  00101	75 09		 jne	 SHORT $LN23@datetime_s@2
  00103	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0010a	74 07		 je	 SHORT $LN24@datetime_s@2
$LN23@datetime_s@2:
  0010c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80
$LN24@datetime_s@2:

; 4374 :                 Py_INCREF(offset2);

  00113	e8 00 00 00 00	 call	 _Py_PXCTX
  00118	85 c0		 test	 eax, eax
  0011a	0f 85 d3 00 00
	00		 jne	 $LN6@datetime_s@2
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0012e	4d 8b cd	 mov	 r9, r13
  00131	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00137	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0013f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00144	85 c0		 test	 eax, eax
  00146	75 0d		 jne	 SHORT $LN27@datetime_s@2
  00148	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_NoneStruct+32, 32 ; 00000020H
  0014f	0f 84 9e 00 00
	00		 je	 $LN6@datetime_s@2
$LN27@datetime_s@2:
  00155	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_NoneStruct+80

; 4375 :             }
; 4376 :             else {

  0015c	e9 92 00 00 00	 jmp	 $LN6@datetime_s@2
$LN12@datetime_s@2:

; 4377 :                 offset1 = datetime_utcoffset(left, NULL);

  00161	33 d2		 xor	 edx, edx
  00163	49 8b cc	 mov	 rcx, r12
  00166	e8 00 00 00 00	 call	 datetime_utcoffset
  0016b	48 8b d8	 mov	 rbx, rax

; 4378 :                 if (offset1 == NULL)

  0016e	48 85 c0	 test	 rax, rax

; 4379 :                     return NULL;

  00171	74 1a		 je	 SHORT $LN36@datetime_s@2

; 4380 :                 offset2 = datetime_utcoffset(right, NULL);

  00173	33 d2		 xor	 edx, edx
  00175	48 8b ce	 mov	 rcx, rsi
  00178	e8 00 00 00 00	 call	 datetime_utcoffset
  0017d	48 8b f8	 mov	 rdi, rax

; 4381 :                 if (offset2 == NULL) {

  00180	48 85 c0	 test	 rax, rax
  00183	75 0f		 jne	 SHORT $LN9@datetime_s@2

; 4382 :                     Py_DECREF(offset1);

  00185	48 8b cb	 mov	 rcx, rbx
  00188	e8 00 00 00 00	 call	 _Py_DecRef
$LN36@datetime_s@2:

; 4383 :                     return NULL;

  0018d	33 c0		 xor	 eax, eax
  0018f	e9 a4 01 00 00	 jmp	 $LN17@datetime_s@2
$LN9@datetime_s@2:

; 4384 :                 }
; 4385 :                 if ((offset1 != Py_None) != (offset2 != Py_None)) {

  00194	49 3b dd	 cmp	 rbx, r13
  00197	8b cd		 mov	 ecx, ebp
  00199	8b c5		 mov	 eax, ebp
  0019b	0f 95 c1	 setne	 cl
  0019e	49 3b fd	 cmp	 rdi, r13
  001a1	0f 95 c0	 setne	 al
  001a4	3b c8		 cmp	 ecx, eax
  001a6	74 2a		 je	 SHORT $LN8@datetime_s@2

; 4386 :                     PyErr_SetString(PyExc_TypeError,
; 4387 :                                     "can't subtract offset-naive and "
; 4388 :                                     "offset-aware datetimes");

  001a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@
  001b6	e8 00 00 00 00	 call	 PyErr_SetString
$LN37@datetime_s@2:

; 4389 :                     Py_DECREF(offset1);

  001bb	48 8b cb	 mov	 rcx, rbx
  001be	e8 00 00 00 00	 call	 _Py_DecRef

; 4390 :                     Py_DECREF(offset2);

  001c3	48 8b cf	 mov	 rcx, rdi
  001c6	e8 00 00 00 00	 call	 _Py_DecRef

; 4391 :                     return NULL;

  001cb	33 c0		 xor	 eax, eax
  001cd	e9 66 01 00 00	 jmp	 $LN17@datetime_s@2
$LN8@datetime_s@2:

; 4392 :                 }
; 4393 :             }
; 4394 :             if ((offset1 != offset2) &&
; 4395 :                 delta_cmp(offset1, offset2) != 0) {

  001d2	48 3b df	 cmp	 rbx, rdi
  001d5	74 1c		 je	 SHORT $LN6@datetime_s@2
  001d7	48 8b d7	 mov	 rdx, rdi
  001da	48 8b cb	 mov	 rcx, rbx
  001dd	e8 00 00 00 00	 call	 delta_cmp
  001e2	85 c0		 test	 eax, eax
  001e4	74 0d		 je	 SHORT $LN6@datetime_s@2

; 4396 :                 offdiff = delta_subtract(offset1, offset2);

  001e6	e8 00 00 00 00	 call	 delta_subtract
  001eb	48 8b e8	 mov	 rbp, rax

; 4397 :                 if (offdiff == NULL) {

  001ee	48 85 c0	 test	 rax, rax

; 4398 :                     Py_DECREF(offset1);
; 4399 :                     Py_DECREF(offset2);
; 4400 :                     return NULL;

  001f1	74 c8		 je	 SHORT $LN37@datetime_s@2
$LN6@datetime_s@2:

; 4401 :                 }
; 4402 :             }
; 4403 :             Py_DECREF(offset1);

  001f3	48 8b cb	 mov	 rcx, rbx
  001f6	e8 00 00 00 00	 call	 _Py_DecRef

; 4404 :             Py_DECREF(offset2);

  001fb	48 8b cf	 mov	 rcx, rdi
  001fe	e8 00 00 00 00	 call	 _Py_DecRef

; 4405 :             delta_d = ymd_to_ord(GET_YEAR(left),
; 4406 :                                  GET_MONTH(left),
; 4407 :                                  GET_DAY(left)) -
; 4408 :                       ymd_to_ord(GET_YEAR(right),
; 4409 :                                  GET_MONTH(right),
; 4410 :                                  GET_DAY(right));

  00203	41 0f b6 4c 24
	69		 movzx	 ecx, BYTE PTR [r12+105]
  00209	41 0f b6 44 24
	6a		 movzx	 eax, BYTE PTR [r12+106]
  0020f	45 0f b6 44 24
	6c		 movzx	 r8d, BYTE PTR [r12+108]
  00215	41 0f b6 54 24
	6b		 movzx	 edx, BYTE PTR [r12+107]
  0021b	c1 e1 08	 shl	 ecx, 8
  0021e	0b c8		 or	 ecx, eax
  00220	e8 00 00 00 00	 call	 ymd_to_ord
  00225	0f b6 4e 69	 movzx	 ecx, BYTE PTR [rsi+105]
  00229	44 0f b6 46 6c	 movzx	 r8d, BYTE PTR [rsi+108]
  0022e	0f b6 56 6b	 movzx	 edx, BYTE PTR [rsi+107]
  00232	8b d8		 mov	 ebx, eax
  00234	0f b6 46 6a	 movzx	 eax, BYTE PTR [rsi+106]
  00238	c1 e1 08	 shl	 ecx, 8
  0023b	0b c8		 or	 ecx, eax
  0023d	e8 00 00 00 00	 call	 ymd_to_ord

; 4411 :             /* These can't overflow, since the values are
; 4412 :              * normalized.  At most this gives the number of
; 4413 :              * seconds in one day.
; 4414 :              */
; 4415 :             delta_s = (DATE_GET_HOUR(left) -
; 4416 :                        DATE_GET_HOUR(right)) * 3600 +
; 4417 :                       (DATE_GET_MINUTE(left) -
; 4418 :                        DATE_GET_MINUTE(right)) * 60 +
; 4419 :                       (DATE_GET_SECOND(left) -
; 4420 :                        DATE_GET_SECOND(right));

  00242	41 0f b6 54 24
	6d		 movzx	 edx, BYTE PTR [r12+109]

; 4421 :             delta_us = DATE_GET_MICROSECOND(left) -
; 4422 :                        DATE_GET_MICROSECOND(right);

  00248	45 0f b6 54 24
	70		 movzx	 r10d, BYTE PTR [r12+112]
  0024e	44 0f b6 46 70	 movzx	 r8d, BYTE PTR [rsi+112]
  00253	2b d8		 sub	 ebx, eax
  00255	0f b6 46 6d	 movzx	 eax, BYTE PTR [rsi+109]
  00259	2b d0		 sub	 edx, eax
  0025b	0f b6 46 6e	 movzx	 eax, BYTE PTR [rsi+110]
  0025f	41 c1 e2 08	 shl	 r10d, 8
  00263	41 c1 e0 08	 shl	 r8d, 8

; 4423 :             result = new_delta(delta_d, delta_s, delta_us, 1);

  00267	41 b9 01 00 00
	00		 mov	 r9d, 1
  0026d	8b cb		 mov	 ecx, ebx
  0026f	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00272	2b d0		 sub	 edx, eax
  00274	41 0f b6 44 24
	6e		 movzx	 eax, BYTE PTR [r12+110]
  0027a	03 d0		 add	 edx, eax
  0027c	0f b6 46 6f	 movzx	 eax, BYTE PTR [rsi+111]
  00280	6b d2 3c	 imul	 edx, 60			; 0000003cH
  00283	2b d0		 sub	 edx, eax
  00285	41 0f b6 44 24
	6f		 movzx	 eax, BYTE PTR [r12+111]
  0028b	03 d0		 add	 edx, eax
  0028d	41 0f b6 44 24
	71		 movzx	 eax, BYTE PTR [r12+113]
  00293	44 0b d0	 or	 r10d, eax
  00296	41 0f b6 44 24
	72		 movzx	 eax, BYTE PTR [r12+114]
  0029c	41 c1 e2 08	 shl	 r10d, 8
  002a0	44 0b d0	 or	 r10d, eax
  002a3	0f b6 46 71	 movzx	 eax, BYTE PTR [rsi+113]
  002a7	44 0b c0	 or	 r8d, eax
  002aa	0f b6 46 72	 movzx	 eax, BYTE PTR [rsi+114]
  002ae	41 c1 e0 08	 shl	 r8d, 8
  002b2	44 0b c0	 or	 r8d, eax
  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  002bc	45 2b d0	 sub	 r10d, r8d
  002bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c4	45 8b c2	 mov	 r8d, r10d
  002c7	e8 00 00 00 00	 call	 new_delta_ex
  002cc	48 8b f8	 mov	 rdi, rax

; 4424 :             if (offdiff != NULL) {

  002cf	48 85 ed	 test	 rbp, rbp
  002d2	74 21		 je	 SHORT $LN5@datetime_s@2

; 4425 :                 PyObject *temp = result;
; 4426 :                 result = delta_subtract(result, offdiff);

  002d4	48 8b d5	 mov	 rdx, rbp
  002d7	48 8b c8	 mov	 rcx, rax
  002da	48 8b d8	 mov	 rbx, rax
  002dd	e8 00 00 00 00	 call	 delta_subtract

; 4427 :                 Py_DECREF(temp);

  002e2	48 8b cb	 mov	 rcx, rbx
  002e5	48 8b f8	 mov	 rdi, rax
  002e8	e8 00 00 00 00	 call	 _Py_DecRef

; 4428 :                 Py_DECREF(offdiff);

  002ed	48 8b cd	 mov	 rcx, rbp
  002f0	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@datetime_s@2:

; 4437 :         }
; 4438 :     }
; 4439 : 
; 4440 :     if (result == Py_NotImplemented)

  002f5	49 3b fe	 cmp	 rdi, r14
  002f8	75 3b		 jne	 SHORT $LN32@datetime_s@2
$LN35@datetime_s@2:

; 4441 :         Py_INCREF(result);

  002fa	e8 00 00 00 00	 call	 _Py_PXCTX
  002ff	85 c0		 test	 eax, eax
  00301	75 32		 jne	 SHORT $LN32@datetime_s@2
  00303	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0030a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00311	4c 8b cf	 mov	 r9, rdi
  00314	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0031a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00322	e8 00 00 00 00	 call	 _PyParallel_Guard
  00327	85 c0		 test	 eax, eax
  00329	75 06		 jne	 SHORT $LN31@datetime_s@2
  0032b	f6 47 20 20	 test	 BYTE PTR [rdi+32], 32	; 00000020H
  0032f	74 04		 je	 SHORT $LN32@datetime_s@2
$LN31@datetime_s@2:
  00331	48 ff 47 50	 inc	 QWORD PTR [rdi+80]
$LN32@datetime_s@2:

; 4442 :     return result;

  00335	48 8b c7	 mov	 rax, rdi
$LN17@datetime_s@2:

; 4443 : }

  00338	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0033d	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00342	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00347	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0034c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00350	41 5e		 pop	 r14
  00352	41 5d		 pop	 r13
  00354	41 5c		 pop	 r12
  00356	c3		 ret	 0
datetime_subtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_repr DD imagerel datetime_repr
	DD	imagerel datetime_repr+282
	DD	imagerel $unwind$datetime_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_repr DD 060f01H
	DD	0d640fH
	DD	0c340fH
	DD	0700b920fH
xdata	ENDS
;	COMDAT ??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d, %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d, %d, %d)', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_repr
_TEXT	SEGMENT
self$ = 96
datetime_repr PROC					; COMDAT

; 4449 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4450 :     const char *type_name = Py_TYPE(self)->tp_name;

  0000f	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]

; 4451 :     PyObject *baserepr;
; 4452 : 
; 4453 :     if (DATE_GET_MICROSECOND(self)) {

  00013	0f b6 79 70	 movzx	 edi, BYTE PTR [rcx+112]

; 4454 :         baserepr = PyUnicode_FromFormat(
; 4455 :                       "%s(%d, %d, %d, %d, %d, %d, %d)",
; 4456 :                       type_name,
; 4457 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4458 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4459 :                       DATE_GET_SECOND(self),
; 4460 :                       DATE_GET_MICROSECOND(self));

  00017	44 0f b6 41 69	 movzx	 r8d, BYTE PTR [rcx+105]
  0001c	48 8b 70 70	 mov	 rsi, QWORD PTR [rax+112]
  00020	0f b6 41 71	 movzx	 eax, BYTE PTR [rcx+113]
  00024	44 0f b6 49 6b	 movzx	 r9d, BYTE PTR [rcx+107]
  00029	c1 e7 08	 shl	 edi, 8
  0002c	41 c1 e0 08	 shl	 r8d, 8
  00030	48 8b d9	 mov	 rbx, rcx
  00033	0b f8		 or	 edi, eax
  00035	0f b6 41 72	 movzx	 eax, BYTE PTR [rcx+114]
  00039	c1 e7 08	 shl	 edi, 8
  0003c	0b f8		 or	 edi, eax
  0003e	74 40		 je	 SHORT $LN6@datetime_r
  00040	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  00044	0f b6 53 6c	 movzx	 edx, BYTE PTR [rbx+108]
  00048	44 0f b6 53 6e	 movzx	 r10d, BYTE PTR [rbx+110]
  0004d	44 0f b6 5b 6d	 movzx	 r11d, BYTE PTR [rbx+109]
  00052	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  00056	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0005a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0005e	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  00063	44 89 5c 24 28	 mov	 DWORD PTR [rsp+40], r11d
  00068	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  00073	44 0b c0	 or	 r8d, eax
  00076	48 8b d6	 mov	 rdx, rsi
  00079	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0007e	eb 73		 jmp	 SHORT $LN3@datetime_r
$LN6@datetime_r:

; 4461 :     }
; 4462 :     else if (DATE_GET_SECOND(self)) {

  00080	0f b6 41 6f	 movzx	 eax, BYTE PTR [rcx+111]
  00084	84 c0		 test	 al, al
  00086	74 3b		 je	 SHORT $LN4@datetime_r

; 4463 :         baserepr = PyUnicode_FromFormat(
; 4464 :                       "%s(%d, %d, %d, %d, %d, %d)",
; 4465 :                       type_name,
; 4466 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4467 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4468 :                       DATE_GET_SECOND(self));

  00088	0f b6 53 6e	 movzx	 edx, BYTE PTR [rbx+110]
  0008c	44 0f b6 53 6d	 movzx	 r10d, BYTE PTR [rbx+109]
  00091	44 0f b6 5b 6c	 movzx	 r11d, BYTE PTR [rbx+108]
  00096	0f b6 c8	 movzx	 ecx, al
  00099	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  0009d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a1	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  000a5	44 89 54 24 28	 mov	 DWORD PTR [rsp+40], r10d
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  000b1	44 0b c0	 or	 r8d, eax
  000b4	48 8b d6	 mov	 rdx, rsi
  000b7	44 89 5c 24 20	 mov	 DWORD PTR [rsp+32], r11d
  000bc	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 4469 :     }
; 4470 :     else {

  000c1	eb 30		 jmp	 SHORT $LN3@datetime_r
$LN4@datetime_r:

; 4471 :         baserepr = PyUnicode_FromFormat(
; 4472 :                       "%s(%d, %d, %d, %d, %d)",
; 4473 :                       type_name,
; 4474 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4475 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self));

  000c3	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  000c7	0f b6 53 6d	 movzx	 edx, BYTE PTR [rbx+109]
  000cb	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  000cf	44 0f b6 53 6c	 movzx	 r10d, BYTE PTR [rbx+108]
  000d4	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000d8	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  000e3	44 0b c0	 or	 r8d, eax
  000e6	48 8b d6	 mov	 rdx, rsi
  000e9	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  000ee	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN3@datetime_r:

; 4476 :     }
; 4477 :     if (baserepr == NULL || ! HASTZINFO(self))

  000f3	48 85 c0	 test	 rax, rax
  000f6	74 12		 je	 SHORT $LN1@datetime_r
  000f8	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  000fc	74 0c		 je	 SHORT $LN1@datetime_r

; 4478 :         return baserepr;
; 4479 :     return append_keyword_tzinfo(baserepr, self->tzinfo);

  000fe	48 8b 53 78	 mov	 rdx, QWORD PTR [rbx+120]
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 append_keyword_tzinfo
$LN1@datetime_r:

; 4480 : }

  0010a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0010f	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00114	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00118	5f		 pop	 rdi
  00119	c3		 ret	 0
datetime_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_03KJMMOONA@?$CIs?$CJ?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
;	COMDAT ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_03KJMMOONA@?$CIs?$CJ?$AA@ DB '(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_str
_TEXT	SEGMENT
self$ = 8
datetime_str PROC					; COMDAT

; 4485 :     _Py_IDENTIFIER(isoformat);
; 4486 : 
; 4487 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "(s)", " ");

  00000	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00007	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00010	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_isoformat@?1??datetime_str@@9@9
  00015	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00019	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
  00020	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03KJMMOONA@?$CIs?$CJ?$AA@

; 4488 : }

  00027	e9 00 00 00 00	 jmp	 _PyObject_CallMethodId
datetime_str ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_ctime
_TEXT	SEGMENT
self$ = 8
datetime_ctime PROC					; COMDAT

; 4530 :     return format_ctime((PyDateTime_Date *)self,
; 4531 :                         DATE_GET_HOUR(self),
; 4532 :                         DATE_GET_MINUTE(self),
; 4533 :                         DATE_GET_SECOND(self));

  00000	44 0f b6 49 6f	 movzx	 r9d, BYTE PTR [rcx+111]
  00005	44 0f b6 41 6e	 movzx	 r8d, BYTE PTR [rcx+110]
  0000a	0f b6 51 6d	 movzx	 edx, BYTE PTR [rcx+109]

; 4534 : }

  0000e	e9 00 00 00 00	 jmp	 format_ctime
datetime_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_richcompare DD imagerel datetime_richcompare
	DD	imagerel datetime_richcompare+247
	DD	imagerel $unwind$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$datetime_richcompare DD imagerel datetime_richcompare+247
	DD	imagerel datetime_richcompare+335
	DD	imagerel $chain$0$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$datetime_richcompare DD imagerel datetime_richcompare+335
	DD	imagerel datetime_richcompare+367
	DD	imagerel $chain$3$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$datetime_richcompare DD imagerel datetime_richcompare+367
	DD	imagerel datetime_richcompare+389
	DD	imagerel $chain$4$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$datetime_richcompare DD imagerel datetime_richcompare+389
	DD	imagerel datetime_richcompare+620
	DD	imagerel $chain$5$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$datetime_richcompare DD imagerel datetime_richcompare+620
	DD	imagerel datetime_richcompare+649
	DD	imagerel $chain$6$datetime_richcompare
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$datetime_richcompare DD imagerel datetime_richcompare+649
	DD	imagerel datetime_richcompare+669
	DD	imagerel $chain$7$datetime_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$datetime_richcompare DD 021H
	DD	imagerel datetime_richcompare+335
	DD	imagerel datetime_richcompare+367
	DD	imagerel $chain$3$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$datetime_richcompare DD 021H
	DD	imagerel datetime_richcompare+367
	DD	imagerel datetime_richcompare+389
	DD	imagerel $chain$4$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$datetime_richcompare DD 020521H
	DD	06f405H
	DD	imagerel datetime_richcompare+367
	DD	imagerel datetime_richcompare+389
	DD	imagerel $chain$4$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$datetime_richcompare DD 020521H
	DD	0c7405H
	DD	imagerel datetime_richcompare+335
	DD	imagerel datetime_richcompare+367
	DD	imagerel $chain$3$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$datetime_richcompare DD 040a21H
	DD	0dc40aH
	DD	0ee400H
	DD	imagerel datetime_richcompare
	DD	imagerel datetime_richcompare+247
	DD	imagerel $unwind$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$datetime_richcompare DD 020521H
	DD	0ee405H
	DD	imagerel datetime_richcompare
	DD	imagerel datetime_richcompare+247
	DD	imagerel $unwind$datetime_richcompare
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_richcompare DD 050a01H
	DD	0d006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@
CONST	SEGMENT
??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@ DB 'can''t com'
	DB	'pare offset-naive and offset-aware datetimes', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT datetime_richcompare
_TEXT	SEGMENT
self$ = 96
other$ = 104
op$ = 112
datetime_richcompare PROC				; COMDAT

; 4540 : {

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	41 55		 push	 r13
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000a	4c 8b e9	 mov	 r13, rcx

; 4541 :     PyObject *result = NULL;
; 4542 :     PyObject *offset1, *offset2;
; 4543 :     int diff;
; 4544 : 
; 4545 :     if (! PyDateTime_Check(other)) {

  0000d	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00011	48 8b f2	 mov	 rsi, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0001b	33 db		 xor	 ebx, ebx
  0001d	41 8b e8	 mov	 ebp, r8d
  00020	48 3b ca	 cmp	 rcx, rdx
  00023	0f 84 ce 00 00
	00		 je	 $LN25@datetime_r@2
  00029	e8 00 00 00 00	 call	 PyType_IsSubtype
  0002e	85 c0		 test	 eax, eax
  00030	0f 85 c1 00 00
	00		 jne	 $LN25@datetime_r@2

; 4546 :         if (PyDate_Check(other)) {

  00036	48 8b 4e 58	 mov	 rcx, QWORD PTR [rsi+88]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00041	48 3b ca	 cmp	 rcx, rdx
  00044	74 26		 je	 SHORT $LN23@datetime_r@2
  00046	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004b	85 c0		 test	 eax, eax
  0004d	75 1d		 jne	 SHORT $LN23@datetime_r@2

; 4559 :         }
; 4560 :         Py_RETURN_NOTIMPLEMENTED;

  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00056	e8 00 00 00 00	 call	 _Py_IncRef
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct

; 4619 : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	41 5d		 pop	 r13
  00068	5e		 pop	 rsi
  00069	5d		 pop	 rbp
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN23@datetime_r@2:

; 4547 :             /* Prevent invocation of date_richcompare.  We want to
; 4548 :                return NotImplemented here to give the other object
; 4549 :                a chance.  But since DateTime is a subclass of
; 4550 :                Date, if the other object is a Date, it would
; 4551 :                compute an ordering based on the date part alone,
; 4552 :                and we don't want that.  So force unequal or
; 4553 :                uncomparable here in that case. */
; 4554 :             if (op == Py_EQ)

  0006c	83 fd 02	 cmp	 ebp, 2
  0006f	75 51		 jne	 SHORT $LN22@datetime_r@2

; 4555 :                 Py_RETURN_FALSE;

  00071	e8 00 00 00 00	 call	 _Py_PXCTX
  00076	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  0007d	85 c0		 test	 eax, eax
  0007f	75 34		 jne	 SHORT $LN33@datetime_r@2
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0008f	4c 8b cb	 mov	 r9, rbx
  00092	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00098	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  0009c	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a1	85 c0		 test	 eax, eax
  000a3	75 09		 jne	 SHORT $LN32@datetime_r@2
  000a5	f6 05 20 00 00
	00 20		 test	 BYTE PTR _Py_FalseStruct+32, 32 ; 00000020H
  000ac	74 07		 je	 SHORT $LN33@datetime_r@2
$LN32@datetime_r@2:
  000ae	48 ff 05 50 00
	00 00		 inc	 QWORD PTR _Py_FalseStruct+80
$LN33@datetime_r@2:
  000b5	48 8b c3	 mov	 rax, rbx

; 4619 : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	41 5d		 pop	 r13
  000be	5e		 pop	 rsi
  000bf	5d		 pop	 rbp
  000c0	5b		 pop	 rbx
  000c1	c3		 ret	 0
$LN22@datetime_r@2:

; 4556 :             if (op == Py_NE)

  000c2	83 fd 03	 cmp	 ebp, 3
  000c5	75 1c		 jne	 SHORT $LN21@datetime_r@2

; 4557 :                 Py_RETURN_TRUE;

  000c7	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 _Py_IncRef
  000d6	48 8b c3	 mov	 rax, rbx

; 4619 : }

  000d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dd	41 5d		 pop	 r13
  000df	5e		 pop	 rsi
  000e0	5d		 pop	 rbp
  000e1	5b		 pop	 rbx
  000e2	c3		 ret	 0
$LN21@datetime_r@2:

; 4558 :             return cmperror(self, other);

  000e3	48 8b d6	 mov	 rdx, rsi
  000e6	49 8b cd	 mov	 rcx, r13

; 4619 : }

  000e9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ed	41 5d		 pop	 r13
  000ef	5e		 pop	 rsi
  000f0	5d		 pop	 rbp
  000f1	5b		 pop	 rbx
  000f2	e9 00 00 00 00	 jmp	 cmperror
$LN25@datetime_r@2:
  000f7	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14

; 4561 :     }
; 4562 : 
; 4563 :     if (GET_DT_TZINFO(self) == GET_DT_TZINFO(other)) {

  000fc	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:_Py_NoneStruct
  00103	41 38 5d 68	 cmp	 BYTE PTR [r13+104], bl
  00107	74 06		 je	 SHORT $LN28@datetime_r@2
  00109	49 8b 4d 78	 mov	 rcx, QWORD PTR [r13+120]
  0010d	eb 03		 jmp	 SHORT $LN29@datetime_r@2
$LN28@datetime_r@2:
  0010f	49 8b ce	 mov	 rcx, r14
$LN29@datetime_r@2:
  00112	38 5e 68	 cmp	 BYTE PTR [rsi+104], bl
  00115	74 06		 je	 SHORT $LN30@datetime_r@2
  00117	48 8b 46 78	 mov	 rax, QWORD PTR [rsi+120]
  0011b	eb 03		 jmp	 SHORT $LN31@datetime_r@2
$LN30@datetime_r@2:
  0011d	49 8b c6	 mov	 rax, r14
$LN31@datetime_r@2:
  00120	48 3b c8	 cmp	 rcx, rax
  00123	75 2a		 jne	 SHORT $LN20@datetime_r@2

; 4564 :         diff = memcmp(((PyDateTime_DateTime *)self)->data,
; 4565 :                       ((PyDateTime_DateTime *)other)->data,
; 4566 :                       _PyDateTime_DATETIME_DATASIZE);

  00125	48 8d 56 69	 lea	 rdx, QWORD PTR [rsi+105]
  00129	49 8d 4d 69	 lea	 rcx, QWORD PTR [r13+105]
  0012d	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00133	e8 00 00 00 00	 call	 memcmp

; 4567 :         return diff_to_bool(diff, op);

  00138	8b d5		 mov	 edx, ebp
  0013a	8b c8		 mov	 ecx, eax
  0013c	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]

; 4619 : }

  00141	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00145	41 5d		 pop	 r13
  00147	5e		 pop	 rsi
  00148	5d		 pop	 rbp
  00149	5b		 pop	 rbx
  0014a	e9 00 00 00 00	 jmp	 diff_to_bool
$LN20@datetime_r@2:

; 4568 :     }
; 4569 :     offset1 = datetime_utcoffset(self, NULL);

  0014f	33 d2		 xor	 edx, edx
  00151	49 8b cd	 mov	 rcx, r13
  00154	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  00159	e8 00 00 00 00	 call	 datetime_utcoffset
  0015e	4c 8b e0	 mov	 r12, rax

; 4570 :     if (offset1 == NULL)

  00161	48 85 c0	 test	 rax, rax
  00164	0f 84 1f 01 00
	00		 je	 $LN37@datetime_r@2
$LN19@datetime_r@2:

; 4571 :         return NULL;
; 4572 :     offset2 = datetime_utcoffset(other, NULL);

  0016a	33 d2		 xor	 edx, edx
  0016c	48 8b ce	 mov	 rcx, rsi
  0016f	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00174	e8 00 00 00 00	 call	 datetime_utcoffset
  00179	48 8b f8	 mov	 rdi, rax

; 4573 :     if (offset2 == NULL)

  0017c	48 85 c0	 test	 rax, rax
  0017f	0f 84 e7 00 00
	00		 je	 $done$24070

; 4574 :         goto done;
; 4575 :     /* If they're both naive, or both aware and have the same offsets,
; 4576 :      * we get off cheap.  Note that if they're both naive, offset1 ==
; 4577 :      * offset2 == Py_None at this point.
; 4578 :      */
; 4579 :     if ((offset1 == offset2) ||
; 4580 :         (PyDelta_Check(offset1) && PyDelta_Check(offset2) &&
; 4581 :          delta_cmp(offset1, offset2) == 0)) {

  00185	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0018a	4c 3b e0	 cmp	 r12, rax
  0018d	0f 84 b5 00 00
	00		 je	 $LN16@datetime_r@2
  00193	49 8b 4c 24 58	 mov	 rcx, QWORD PTR [r12+88]
  00198	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:PyDateTime_DeltaType
  0019f	49 3b cf	 cmp	 rcx, r15
  001a2	74 0c		 je	 SHORT $LN15@datetime_r@2
  001a4	49 8b d7	 mov	 rdx, r15
  001a7	e8 00 00 00 00	 call	 PyType_IsSubtype
  001ac	85 c0		 test	 eax, eax
  001ae	74 24		 je	 SHORT $LN17@datetime_r@2
$LN15@datetime_r@2:
  001b0	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  001b4	49 3b cf	 cmp	 rcx, r15
  001b7	74 0c		 je	 SHORT $LN14@datetime_r@2
  001b9	49 8b d7	 mov	 rdx, r15
  001bc	e8 00 00 00 00	 call	 PyType_IsSubtype
  001c1	85 c0		 test	 eax, eax
  001c3	74 0f		 je	 SHORT $LN17@datetime_r@2
$LN14@datetime_r@2:
  001c5	48 8b d7	 mov	 rdx, rdi
  001c8	49 8b cc	 mov	 rcx, r12
  001cb	e8 00 00 00 00	 call	 delta_cmp
  001d0	85 c0		 test	 eax, eax
  001d2	74 74		 je	 SHORT $LN16@datetime_r@2
$LN17@datetime_r@2:

; 4586 :     }
; 4587 :     else if (offset1 != Py_None && offset2 != Py_None) {

  001d4	4d 3b e6	 cmp	 r12, r14
  001d7	74 2e		 je	 SHORT $LN12@datetime_r@2
  001d9	49 3b fe	 cmp	 rdi, r14
  001dc	74 29		 je	 SHORT $LN12@datetime_r@2

; 4588 :         PyDateTime_Delta *delta;
; 4589 : 
; 4590 :         assert(offset1 != offset2); /* else last "if" handled it */
; 4591 :         delta = (PyDateTime_Delta *)datetime_subtract((PyObject *)self,
; 4592 :                                                        other);

  001de	48 8b d6	 mov	 rdx, rsi
  001e1	49 8b cd	 mov	 rcx, r13
  001e4	e8 00 00 00 00	 call	 datetime_subtract

; 4593 :         if (delta == NULL)

  001e9	48 85 c0	 test	 rax, rax
  001ec	74 79		 je	 SHORT $LN38@datetime_r@2

; 4594 :             goto done;
; 4595 :         diff = GET_TD_DAYS(delta);

  001ee	8b 58 68	 mov	 ebx, DWORD PTR [rax+104]

; 4596 :         if (diff == 0)

  001f1	85 db		 test	 ebx, ebx
  001f3	75 06		 jne	 SHORT $LN10@datetime_r@2

; 4597 :             diff = GET_TD_SECONDS(delta) |
; 4598 :                    GET_TD_MICROSECONDS(delta);

  001f5	8b 58 70	 mov	 ebx, DWORD PTR [rax+112]
  001f8	0b 58 6c	 or	 ebx, DWORD PTR [rax+108]
$LN10@datetime_r@2:

; 4599 :         Py_DECREF(delta);

  001fb	48 8b c8	 mov	 rcx, rax
  001fe	e8 00 00 00 00	 call	 _Py_DecRef

; 4600 :         result = diff_to_bool(diff, op);

  00203	8b cb		 mov	 ecx, ebx
  00205	eb 56		 jmp	 SHORT $LN39@datetime_r@2
$LN12@datetime_r@2:

; 4601 :     }
; 4602 :     else if (op == Py_EQ) {

  00207	83 fd 02	 cmp	 ebp, 2
  0020a	75 11		 jne	 SHORT $LN8@datetime_r@2

; 4603 :         result = Py_False;

  0020c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct

; 4604 :         Py_INCREF(result);

  00213	48 8b cb	 mov	 rcx, rbx
  00216	e8 00 00 00 00	 call	 _Py_IncRef
  0021b	eb 4a		 jmp	 SHORT $LN38@datetime_r@2
$LN8@datetime_r@2:

; 4605 :     }
; 4606 :     else if (op == Py_NE) {

  0021d	83 fd 03	 cmp	 ebp, 3
  00220	75 11		 jne	 SHORT $LN6@datetime_r@2

; 4607 :         result = Py_True;

  00222	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct

; 4608 :         Py_INCREF(result);

  00229	48 8b cb	 mov	 rcx, rbx
  0022c	e8 00 00 00 00	 call	 _Py_IncRef

; 4609 :     }
; 4610 :     else {

  00231	eb 34		 jmp	 SHORT $LN38@datetime_r@2
$LN6@datetime_r@2:

; 4611 :         PyErr_SetString(PyExc_TypeError,
; 4612 :                         "can't compare offset-naive and "
; 4613 :                         "offset-aware datetimes");

  00233	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@
  00241	e8 00 00 00 00	 call	 PyErr_SetString
  00246	eb 1f		 jmp	 SHORT $LN38@datetime_r@2
$LN16@datetime_r@2:

; 4582 :         diff = memcmp(((PyDateTime_DateTime *)self)->data,
; 4583 :                       ((PyDateTime_DateTime *)other)->data,
; 4584 :                       _PyDateTime_DATETIME_DATASIZE);

  00248	48 8d 56 69	 lea	 rdx, QWORD PTR [rsi+105]
  0024c	49 8d 4d 69	 lea	 rcx, QWORD PTR [r13+105]
  00250	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00256	e8 00 00 00 00	 call	 memcmp

; 4585 :         result = diff_to_bool(diff, op);

  0025b	8b c8		 mov	 ecx, eax
$LN39@datetime_r@2:
  0025d	8b d5		 mov	 edx, ebp
  0025f	e8 00 00 00 00	 call	 diff_to_bool
  00264	48 8b d8	 mov	 rbx, rax
$LN38@datetime_r@2:
  00267	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
$done$24070:

; 4614 :     }
; 4615 :  done:
; 4616 :     Py_DECREF(offset1);

  0026c	49 8b cc	 mov	 rcx, r12
  0026f	e8 00 00 00 00	 call	 _Py_DecRef

; 4617 :     Py_XDECREF(offset2);

  00274	48 85 ff	 test	 rdi, rdi
  00277	74 08		 je	 SHORT $LN3@datetime_r@2
  00279	48 8b cf	 mov	 rcx, rdi
  0027c	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@datetime_r@2:

; 4618 :     return result;

  00281	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00286	48 8b c3	 mov	 rax, rbx
$LN37@datetime_r@2:
  00289	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  0028e	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]

; 4619 : }

  00293	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00297	41 5d		 pop	 r13
  00299	5e		 pop	 rsi
  0029a	5d		 pop	 rbp
  0029b	5b		 pop	 rbx
  0029c	c3		 ret	 0
datetime_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_hash DD imagerel datetime_hash
	DD	imagerel datetime_hash+295
	DD	imagerel $unwind$datetime_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_hash DD 081401H
	DD	0a6414H
	DD	095414H
	DD	083414H
	DD	070105214H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_hash
_TEXT	SEGMENT
self$ = 64
datetime_hash PROC					; COMDAT

; 4623 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4624 :     if (self->hashcode == -1) {

  00014	48 83 79 60 ff	 cmp	 QWORD PTR [rcx+96], -1
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	0f 85 ec 00 00
	00		 jne	 $LN6@datetime_h

; 4625 :         PyObject *offset;
; 4626 : 
; 4627 :         offset = datetime_utcoffset((PyObject *)self, NULL);

  00022	33 d2		 xor	 edx, edx
  00024	e8 00 00 00 00	 call	 datetime_utcoffset
  00029	48 8b f8	 mov	 rdi, rax

; 4628 : 
; 4629 :         if (offset == NULL)

  0002c	48 85 c0	 test	 rax, rax

; 4630 :             return -1;

  0002f	0f 84 9c 00 00
	00		 je	 $LN9@datetime_h

; 4631 : 
; 4632 :         /* Reduce this to a hash of another object. */
; 4633 :         if (offset == Py_None)

  00035	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003c	48 3b f8	 cmp	 rdi, rax
  0003f	75 17		 jne	 SHORT $LN4@datetime_h

; 4634 :             self->hashcode = generic_hash(
; 4635 :                 (unsigned char *)self->data, _PyDateTime_DATETIME_DATASIZE);

  00041	48 8d 4b 69	 lea	 rcx, QWORD PTR [rbx+105]
  00045	ba 0a 00 00 00	 mov	 edx, 10
  0004a	e8 00 00 00 00	 call	 generic_hash
  0004f	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax

; 4636 :         else {

  00053	e9 ae 00 00 00	 jmp	 $LN3@datetime_h
$LN4@datetime_h:

; 4637 :             PyObject *temp1, *temp2;
; 4638 :             int days, seconds;
; 4639 : 
; 4640 :             assert(HASTZINFO(self));
; 4641 :             days = ymd_to_ord(GET_YEAR(self),
; 4642 :                               GET_MONTH(self),
; 4643 :                               GET_DAY(self));

  00058	0f b6 4b 69	 movzx	 ecx, BYTE PTR [rbx+105]
  0005c	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  00060	44 0f b6 43 6c	 movzx	 r8d, BYTE PTR [rbx+108]
  00065	0f b6 53 6b	 movzx	 edx, BYTE PTR [rbx+107]
  00069	c1 e1 08	 shl	 ecx, 8
  0006c	0b c8		 or	 ecx, eax
  0006e	e8 00 00 00 00	 call	 ymd_to_ord

; 4644 :             seconds = DATE_GET_HOUR(self) * 3600 +
; 4645 :                       DATE_GET_MINUTE(self) * 60 +
; 4646 :                       DATE_GET_SECOND(self);

  00073	0f b6 4b 6e	 movzx	 ecx, BYTE PTR [rbx+110]
  00077	0f b6 53 6d	 movzx	 edx, BYTE PTR [rbx+109]
  0007b	6b d2 3c	 imul	 edx, 60			; 0000003cH

; 4647 :             temp1 = new_delta(days, seconds,
; 4648 :                               DATE_GET_MICROSECOND(self),
; 4649 :                               1);

  0007e	44 0f b6 43 70	 movzx	 r8d, BYTE PTR [rbx+112]
  00083	03 d1		 add	 edx, ecx
  00085	0f b6 4b 6f	 movzx	 ecx, BYTE PTR [rbx+111]
  00089	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0008c	41 c1 e0 08	 shl	 r8d, 8
  00090	44 8b d8	 mov	 r11d, eax
  00093	0f b6 43 72	 movzx	 eax, BYTE PTR [rbx+114]
  00097	03 d1		 add	 edx, ecx
  00099	0f b6 4b 71	 movzx	 ecx, BYTE PTR [rbx+113]
  0009d	41 b9 01 00 00
	00		 mov	 r9d, 1
  000a3	44 0b c1	 or	 r8d, ecx
  000a6	41 8b cb	 mov	 ecx, r11d
  000a9	41 c1 e0 08	 shl	 r8d, 8
  000ad	44 0b c0	 or	 r8d, eax
  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bc	e8 00 00 00 00	 call	 new_delta_ex
  000c1	48 8b e8	 mov	 rbp, rax

; 4650 :             if (temp1 == NULL) {

  000c4	48 85 c0	 test	 rax, rax
  000c7	75 0e		 jne	 SHORT $LN2@datetime_h
$LN10@datetime_h:

; 4651 :                 Py_DECREF(offset);

  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@datetime_h:

; 4652 :                 return -1;

  000d1	48 83 c8 ff	 or	 rax, -1
  000d5	eb 3b		 jmp	 SHORT $LN7@datetime_h
$LN2@datetime_h:

; 4653 :             }
; 4654 :             temp2 = delta_subtract(temp1, offset);

  000d7	48 8b d7	 mov	 rdx, rdi
  000da	48 8b c8	 mov	 rcx, rax
  000dd	e8 00 00 00 00	 call	 delta_subtract

; 4655 :             Py_DECREF(temp1);

  000e2	48 8b cd	 mov	 rcx, rbp
  000e5	48 8b f0	 mov	 rsi, rax
  000e8	e8 00 00 00 00	 call	 _Py_DecRef

; 4656 :             if (temp2 == NULL) {

  000ed	48 85 f6	 test	 rsi, rsi

; 4657 :                 Py_DECREF(offset);
; 4658 :                 return -1;

  000f0	74 d7		 je	 SHORT $LN10@datetime_h

; 4659 :             }
; 4660 :             self->hashcode = PyObject_Hash(temp2);

  000f2	48 8b ce	 mov	 rcx, rsi
  000f5	e8 00 00 00 00	 call	 PyObject_Hash

; 4661 :             Py_DECREF(temp2);

  000fa	48 8b ce	 mov	 rcx, rsi
  000fd	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  00101	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@datetime_h:

; 4662 :         }
; 4663 :         Py_DECREF(offset);

  00106	48 8b cf	 mov	 rcx, rdi
  00109	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@datetime_h:

; 4664 :     }
; 4665 :     return self->hashcode;

  0010e	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
$LN7@datetime_h:

; 4666 : }

  00112	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00117	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0011c	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00121	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00125	5f		 pop	 rdi
  00126	c3		 ret	 0
datetime_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_replace DD imagerel datetime_replace
	DD	imagerel datetime_replace+292
	DD	imagerel $unwind$datetime_replace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$datetime_replace DD imagerel datetime_replace+292
	DD	imagerel datetime_replace+378
	DD	imagerel $chain$0$datetime_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$datetime_replace DD 020821H
	DD	0137408H
	DD	imagerel datetime_replace
	DD	imagerel datetime_replace+292
	DD	imagerel $unwind$datetime_replace
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_replace DD 041001H
	DD	0143410H
	DD	05006f210H
xdata	ENDS
;	COMDAT ??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@
CONST	SEGMENT
??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@ DB '|iiiiiiiO:replace', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_replace
_TEXT	SEGMENT
mm$ = 96
hh$ = 100
d$ = 104
m$ = 108
y$ = 112
tzinfo$ = 120
us$ = 144
self$ = 144
args$ = 152
kw$ = 160
ss$ = 168
datetime_replace PROC					; COMDAT

; 4670 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 8b ec	 mov	 rbp, rsp
  00009	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 4671 :     PyObject *clone;
; 4672 :     PyObject *tuple;
; 4673 :     int y = GET_YEAR(self);

  00010	0f b6 41 6a	 movzx	 eax, BYTE PTR [rcx+106]
  00014	44 0f b6 49 69	 movzx	 r9d, BYTE PTR [rcx+105]
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	41 c1 e1 08	 shl	 r9d, 8
  00020	4d 8b d0	 mov	 r10, r8
  00023	4c 8b da	 mov	 r11, rdx
  00026	44 0b c8	 or	 r9d, eax

; 4674 :     int m = GET_MONTH(self);

  00029	0f b6 41 6b	 movzx	 eax, BYTE PTR [rcx+107]
  0002d	89 45 ec	 mov	 DWORD PTR m$[rbp-128], eax

; 4675 :     int d = GET_DAY(self);

  00030	0f b6 41 6c	 movzx	 eax, BYTE PTR [rcx+108]
  00034	44 89 4d f0	 mov	 DWORD PTR y$[rbp-128], r9d
  00038	89 45 e8	 mov	 DWORD PTR d$[rbp-128], eax

; 4676 :     int hh = DATE_GET_HOUR(self);

  0003b	0f b6 41 6d	 movzx	 eax, BYTE PTR [rcx+109]
  0003f	89 45 e4	 mov	 DWORD PTR hh$[rbp-128], eax

; 4677 :     int mm = DATE_GET_MINUTE(self);

  00042	0f b6 41 6e	 movzx	 eax, BYTE PTR [rcx+110]
  00046	89 45 e0	 mov	 DWORD PTR mm$[rbp-128], eax

; 4678 :     int ss = DATE_GET_SECOND(self);

  00049	0f b6 41 6f	 movzx	 eax, BYTE PTR [rcx+111]

; 4679 :     int us = DATE_GET_MICROSECOND(self);

  0004d	0f b6 49 70	 movzx	 ecx, BYTE PTR [rcx+112]
  00051	c1 e1 08	 shl	 ecx, 8
  00054	89 45 28	 mov	 DWORD PTR ss$[rbp-128], eax
  00057	0f b6 43 71	 movzx	 eax, BYTE PTR [rbx+113]
  0005b	0b c8		 or	 ecx, eax
  0005d	0f b6 43 72	 movzx	 eax, BYTE PTR [rbx+114]
  00061	c1 e1 08	 shl	 ecx, 8
  00064	0b c8		 or	 ecx, eax

; 4680 :     PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;

  00066	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  0006a	89 4d 10	 mov	 DWORD PTR us$[rbp-128], ecx
  0006d	74 06		 je	 SHORT $LN5@datetime_r@3
  0006f	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00073	eb 07		 jmp	 SHORT $LN8@datetime_r@3
$LN5@datetime_r@3:
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@datetime_r@3:
  0007c	48 89 45 f8	 mov	 QWORD PTR tzinfo$[rbp-128], rax

; 4681 : 
; 4682 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iiiiiiiO:replace",
; 4683 :                                       datetime_kws,
; 4684 :                                       &y, &m, &d, &hh, &mm, &ss, &us,
; 4685 :                                       &tzinfo))

  00080	48 8d 45 f8	 lea	 rax, QWORD PTR tzinfo$[rbp-128]
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:datetime_kws
  0008b	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00090	48 8d 45 10	 lea	 rax, QWORD PTR us$[rbp-128]
  00094	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@
  0009b	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  000a0	48 8d 45 28	 lea	 rax, QWORD PTR ss$[rbp-128]
  000a4	49 8b d2	 mov	 rdx, r10
  000a7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000ac	48 8d 45 e0	 lea	 rax, QWORD PTR mm$[rbp-128]
  000b0	49 8b cb	 mov	 rcx, r11
  000b3	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000b8	48 8d 45 e4	 lea	 rax, QWORD PTR hh$[rbp-128]
  000bc	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c1	48 8d 45 e8	 lea	 rax, QWORD PTR d$[rbp-128]
  000c5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ca	48 8d 45 ec	 lea	 rax, QWORD PTR m$[rbp-128]
  000ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d3	48 8d 45 f0	 lea	 rax, QWORD PTR y$[rbp-128]
  000d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000dc	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  000e1	85 c0		 test	 eax, eax
  000e3	75 13		 jne	 SHORT $LN2@datetime_r@3

; 4686 :         return NULL;

  000e5	33 c0		 xor	 eax, eax

; 4693 : }

  000e7	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  000ef	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000f6	5d		 pop	 rbp
  000f7	c3		 ret	 0
$LN2@datetime_r@3:

; 4687 :     tuple = Py_BuildValue("iiiiiiiO", y, m, d, hh, mm, ss, us, tzinfo);

  000f8	48 8b 45 f8	 mov	 rax, QWORD PTR tzinfo$[rbp-128]
  000fc	44 8b 4d e8	 mov	 r9d, DWORD PTR d$[rbp-128]
  00100	44 8b 45 ec	 mov	 r8d, DWORD PTR m$[rbp-128]
  00104	8b 55 f0	 mov	 edx, DWORD PTR y$[rbp-128]
  00107	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0010c	8b 45 10	 mov	 eax, DWORD PTR us$[rbp-128]
  0010f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00113	8b 45 28	 mov	 eax, DWORD PTR ss$[rbp-128]
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  0011d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00121	8b 45 e0	 mov	 eax, DWORD PTR mm$[rbp-128]
  00124	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  0012c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00130	8b 45 e4	 mov	 eax, DWORD PTR hh$[rbp-128]
  00133	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00137	e8 00 00 00 00	 call	 Py_BuildValue
  0013c	48 8b f8	 mov	 rdi, rax

; 4688 :     if (tuple == NULL)

  0013f	48 85 c0	 test	 rax, rax
  00142	74 1d		 je	 SHORT $LN7@datetime_r@3
$LN1@datetime_r@3:

; 4689 :         return NULL;
; 4690 :     clone = datetime_new(Py_TYPE(self), tuple, NULL);

  00144	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  00148	45 33 c0	 xor	 r8d, r8d
  0014b	48 8b d0	 mov	 rdx, rax
  0014e	e8 00 00 00 00	 call	 datetime_new

; 4691 :     Py_DECREF(tuple);

  00153	48 8b cf	 mov	 rcx, rdi
  00156	48 8b d8	 mov	 rbx, rax
  00159	e8 00 00 00 00	 call	 _Py_DecRef

; 4692 :     return clone;

  0015e	48 8b c3	 mov	 rax, rbx
$LN7@datetime_r@3:
  00161	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]

; 4693 : }

  00169	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00171	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00178	5d		 pop	 rbp
  00179	c3		 ret	 0
datetime_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_timetuple DD imagerel datetime_timetuple
	DD	imagerel datetime_timetuple+164
	DD	imagerel $unwind$datetime_timetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_timetuple DD 060f01H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_timetuple
_TEXT	SEGMENT
self$ = 80
datetime_timetuple PROC					; COMDAT

; 4827 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4828 :     int dstflag = -1;

  0000f	83 cf ff	 or	 edi, -1

; 4829 : 
; 4830 :     if (HASTZINFO(self) && self->tzinfo != Py_None) {

  00012	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00016	48 8b d9	 mov	 rbx, rcx
  00019	74 41		 je	 SHORT $LN3@datetime_t@3
  0001b	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0001f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00026	48 3b ce	 cmp	 rcx, rsi
  00029	74 31		 je	 SHORT $LN3@datetime_t@3

; 4831 :         PyObject * dst;
; 4832 : 
; 4833 :         dst = call_dst(self->tzinfo, (PyObject *)self);

  0002b	48 8b d3	 mov	 rdx, rbx
  0002e	e8 00 00 00 00	 call	 call_dst
  00033	48 8b c8	 mov	 rcx, rax

; 4834 :         if (dst == NULL)

  00036	48 85 c0	 test	 rax, rax
  00039	75 10		 jne	 SHORT $LN2@datetime_t@3

; 4848 : }

  0003b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00040	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00045	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN2@datetime_t@3:

; 4835 :             return NULL;
; 4836 : 
; 4837 :         if (dst != Py_None)

  0004b	48 3b c6	 cmp	 rax, rsi
  0004e	74 07		 je	 SHORT $LN1@datetime_t@3

; 4838 :             dstflag = delta_bool((PyDateTime_Delta *)dst);

  00050	e8 00 00 00 00	 call	 delta_bool
  00055	8b f8		 mov	 edi, eax
$LN1@datetime_t@3:

; 4839 :         Py_DECREF(dst);

  00057	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@datetime_t@3:

; 4840 :     }
; 4841 :     return build_struct_time(GET_YEAR(self),
; 4842 :                              GET_MONTH(self),
; 4843 :                              GET_DAY(self),
; 4844 :                              DATE_GET_HOUR(self),
; 4845 :                              DATE_GET_MINUTE(self),
; 4846 :                              DATE_GET_SECOND(self),
; 4847 :                              dstflag);

  0005c	0f b6 4b 69	 movzx	 ecx, BYTE PTR [rbx+105]
  00060	44 0f b6 53 6a	 movzx	 r10d, BYTE PTR [rbx+106]
  00065	44 0f b6 5b 6f	 movzx	 r11d, BYTE PTR [rbx+111]
  0006a	0f b6 43 6e	 movzx	 eax, BYTE PTR [rbx+110]
  0006e	44 0f b6 4b 6d	 movzx	 r9d, BYTE PTR [rbx+109]
  00073	44 0f b6 43 6c	 movzx	 r8d, BYTE PTR [rbx+108]
  00078	0f b6 53 6b	 movzx	 edx, BYTE PTR [rbx+107]
  0007c	c1 e1 08	 shl	 ecx, 8
  0007f	89 7c 24 30	 mov	 DWORD PTR [rsp+48], edi
  00083	44 89 5c 24 28	 mov	 DWORD PTR [rsp+40], r11d
  00088	41 0b ca	 or	 ecx, r10d
  0008b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008f	e8 00 00 00 00	 call	 build_struct_time

; 4848 : }

  00094	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00099	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0009e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
datetime_timetuple ENDP
_TEXT	ENDS
PUBLIC	__real@412e848000000000
PUBLIC	??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@ ; `string'
EXTRN	PyFloat_FromDouble:PROC
_BSS	SEGMENT
PyDateTime_Epoch DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$datetime_timestamp DD imagerel datetime_timestamp
	DD	imagerel datetime_timestamp+324
	DD	imagerel $unwind$datetime_timestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_timestamp DD 040a01H
	DD	0c340aH
	DD	07006920aH
xdata	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT ??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@ DB 'timestamp out of ra'
	DB	'nge', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT datetime_timestamp
_TEXT	SEGMENT
time$24323 = 32
self$ = 96
datetime_timestamp PROC					; COMDAT

; 4852 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4853 :     PyObject *result;
; 4854 : 
; 4855 :     if (HASTZINFO(self) && self->tzinfo != Py_None) {

  0000a	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 46		 je	 SHORT $LN4@datetime_t@4
  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  0001e	74 39		 je	 SHORT $LN4@datetime_t@4

; 4856 :         PyObject *delta;
; 4857 :         delta = datetime_subtract((PyObject *)self, PyDateTime_Epoch);

  00020	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyDateTime_Epoch
  00027	e8 00 00 00 00	 call	 datetime_subtract
  0002c	48 8b d8	 mov	 rbx, rax

; 4858 :         if (delta == NULL)

  0002f	48 85 c0	 test	 rax, rax

; 4859 :             return NULL;

  00032	0f 84 b9 00 00
	00		 je	 $LN9@datetime_t@4

; 4860 :         result = delta_total_seconds(delta);

  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 delta_total_seconds

; 4861 :         Py_DECREF(delta);

  00040	48 8b cb	 mov	 rcx, rbx
  00043	48 8b f8	 mov	 rdi, rax
  00046	e8 00 00 00 00	 call	 _Py_DecRef

; 4884 :     }
; 4885 :     return result;

  0004b	48 8b c7	 mov	 rax, rdi

; 4886 : }

  0004e	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00053	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN4@datetime_t@4:

; 4862 :     }
; 4863 :     else {
; 4864 :         struct tm time;
; 4865 :         time_t timestamp;
; 4866 :         memset((void *) &time, '\0', sizeof(struct tm));
; 4867 :         time.tm_year = GET_YEAR(self) - 1900;

  00059	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]
  0005d	33 c0		 xor	 eax, eax
  0005f	48 89 44 24 20	 mov	 QWORD PTR time$24323[rsp], rax
  00064	48 89 44 24 28	 mov	 QWORD PTR time$24323[rsp+8], rax
  00069	48 89 44 24 30	 mov	 QWORD PTR time$24323[rsp+16], rax
  0006e	48 89 44 24 38	 mov	 QWORD PTR time$24323[rsp+24], rax
  00073	89 44 24 40	 mov	 DWORD PTR time$24323[rsp+32], eax
  00077	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  0007b	c1 e1 08	 shl	 ecx, 8

; 4868 :         time.tm_mon = GET_MONTH(self) - 1;
; 4869 :         time.tm_mday = GET_DAY(self);
; 4870 :         time.tm_hour = DATE_GET_HOUR(self);
; 4871 :         time.tm_min = DATE_GET_MINUTE(self);
; 4872 :         time.tm_sec = DATE_GET_SECOND(self);
; 4873 :         time.tm_wday = -1;

  0007e	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR time$24323[rsp+24], -1

; 4874 :         time.tm_isdst = -1;

  00086	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR time$24323[rsp+32], -1
  0008e	0b c8		 or	 ecx, eax
  00090	0f b6 43 6b	 movzx	 eax, BYTE PTR [rbx+107]
  00094	ff c8		 dec	 eax
  00096	81 e9 6c 07 00
	00		 sub	 ecx, 1900		; 0000076cH
  0009c	89 44 24 30	 mov	 DWORD PTR time$24323[rsp+16], eax
  000a0	0f b6 43 6c	 movzx	 eax, BYTE PTR [rbx+108]
  000a4	89 4c 24 34	 mov	 DWORD PTR time$24323[rsp+20], ecx
  000a8	89 44 24 2c	 mov	 DWORD PTR time$24323[rsp+12], eax
  000ac	0f b6 43 6d	 movzx	 eax, BYTE PTR [rbx+109]

; 4875 :         timestamp = mktime(&time);

  000b0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR time$24323[rsp]
  000b5	89 44 24 28	 mov	 DWORD PTR time$24323[rsp+8], eax
  000b9	0f b6 43 6e	 movzx	 eax, BYTE PTR [rbx+110]
  000bd	89 44 24 24	 mov	 DWORD PTR time$24323[rsp+4], eax
  000c1	0f b6 43 6f	 movzx	 eax, BYTE PTR [rbx+111]
  000c5	89 44 24 20	 mov	 DWORD PTR time$24323[rsp], eax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mktime64
  000cf	4c 8b d8	 mov	 r11, rax

; 4876 :         /* Return value of -1 does not necessarily mean an error, but tm_wday
; 4877 :          * cannot remain set to -1 if mktime succeeded. */
; 4878 :         if (timestamp == (time_t)(-1) && time.tm_wday == -1) {

  000d2	48 83 f8 ff	 cmp	 rax, -1
  000d6	75 26		 jne	 SHORT $LN1@datetime_t@4
  000d8	39 44 24 38	 cmp	 DWORD PTR time$24323[rsp+24], eax
  000dc	75 20		 jne	 SHORT $LN1@datetime_t@4

; 4879 :             PyErr_SetString(PyExc_OverflowError,
; 4880 :                             "timestamp out of range");

  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@
  000ec	e8 00 00 00 00	 call	 PyErr_SetString
$LN9@datetime_t@4:

; 4881 :             return NULL;

  000f1	33 c0		 xor	 eax, eax

; 4886 : }

  000f3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000f8	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
$LN1@datetime_t@4:

; 4882 :         }
; 4883 :         result = PyFloat_FromDouble(timestamp + DATE_GET_MICROSECOND(self) / 1e6);

  000fe	0f b6 43 71	 movzx	 eax, BYTE PTR [rbx+113]
  00102	0f b6 4b 70	 movzx	 ecx, BYTE PTR [rbx+112]
  00106	66 0f ef c9	 pxor	 xmm1, xmm1
  0010a	c1 e1 08	 shl	 ecx, 8
  0010d	f2 49 0f 2a cb	 cvtsi2sd xmm1, r11
  00112	0b c8		 or	 ecx, eax
  00114	0f b6 43 72	 movzx	 eax, BYTE PTR [rbx+114]
  00118	c1 e1 08	 shl	 ecx, 8
  0011b	0b c8		 or	 ecx, eax
  0011d	66 0f 6e c1	 movd	 xmm0, ecx
  00121	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00125	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@412e848000000000
  0012d	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00131	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 4886 : }

  00136	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0013b	48 8b f8	 mov	 rdi, rax
  0013e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00142	5f		 pop	 rdi
  00143	c3		 ret	 0
datetime_timestamp ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT datetime_getdate
_TEXT	SEGMENT
self$ = 8
datetime_getdate PROC					; COMDAT

; 4891 :     return new_date(GET_YEAR(self),
; 4892 :                     GET_MONTH(self),
; 4893 :                     GET_DAY(self));

  00000	44 0f b6 51 69	 movzx	 r10d, BYTE PTR [rcx+105]
  00005	44 0f b6 41 6c	 movzx	 r8d, BYTE PTR [rcx+108]
  0000a	0f b6 51 6b	 movzx	 edx, BYTE PTR [rcx+107]
  0000e	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00012	41 c1 e2 08	 shl	 r10d, 8
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  0001d	41 0b ca	 or	 ecx, r10d

; 4894 : }

  00020	e9 00 00 00 00	 jmp	 new_date_ex
datetime_getdate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_gettime DD imagerel datetime_gettime
	DD	imagerel datetime_gettime+78
	DD	imagerel $unwind$datetime_gettime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_gettime DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_gettime
_TEXT	SEGMENT
self$ = 64
datetime_gettime PROC					; COMDAT

; 4898 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4899 :     return new_time(DATE_GET_HOUR(self),
; 4900 :                     DATE_GET_MINUTE(self),
; 4901 :                     DATE_GET_SECOND(self),
; 4902 :                     DATE_GET_MICROSECOND(self),
; 4903 :                     Py_None);

  00004	0f b6 41 71	 movzx	 eax, BYTE PTR [rcx+113]
  00008	44 0f b6 49 70	 movzx	 r9d, BYTE PTR [rcx+112]
  0000d	44 0f b6 41 6f	 movzx	 r8d, BYTE PTR [rcx+111]
  00012	0f b6 51 6e	 movzx	 edx, BYTE PTR [rcx+110]
  00016	41 c1 e1 08	 shl	 r9d, 8
  0001a	44 0b c8	 or	 r9d, eax
  0001d	0f b6 41 72	 movzx	 eax, BYTE PTR [rcx+114]
  00021	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00025	41 c1 e1 08	 shl	 r9d, 8
  00029	44 0b c8	 or	 r9d, eax
  0002c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	e8 00 00 00 00	 call	 new_time_ex

; 4904 : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
datetime_gettime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_gettimetz DD imagerel datetime_gettimetz
	DD	imagerel datetime_gettimetz+90
	DD	imagerel $unwind$datetime_gettimetz
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_gettimetz DD 010401H
	DD	06204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_gettimetz
_TEXT	SEGMENT
self$ = 64
datetime_gettimetz PROC					; COMDAT

; 4908 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4909 :     return new_time(DATE_GET_HOUR(self),
; 4910 :                     DATE_GET_MINUTE(self),
; 4911 :                     DATE_GET_SECOND(self),
; 4912 :                     DATE_GET_MICROSECOND(self),
; 4913 :                     GET_DT_TZINFO(self));

  00004	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00008	74 06		 je	 SHORT $LN3@datetime_g
  0000a	4c 8b 51 78	 mov	 r10, QWORD PTR [rcx+120]
  0000e	eb 07		 jmp	 SHORT $LN4@datetime_g
$LN3@datetime_g:
  00010	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:_Py_NoneStruct
$LN4@datetime_g:
  00017	0f b6 41 71	 movzx	 eax, BYTE PTR [rcx+113]
  0001b	44 0f b6 49 70	 movzx	 r9d, BYTE PTR [rcx+112]
  00020	44 0f b6 41 6f	 movzx	 r8d, BYTE PTR [rcx+111]
  00025	0f b6 51 6e	 movzx	 edx, BYTE PTR [rcx+110]
  00029	41 c1 e1 08	 shl	 r9d, 8
  0002d	44 0b c8	 or	 r9d, eax
  00030	0f b6 41 72	 movzx	 eax, BYTE PTR [rcx+114]
  00034	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00038	41 c1 e1 08	 shl	 r9d, 8
  0003c	44 0b c8	 or	 r9d, eax
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  00050	e8 00 00 00 00	 call	 new_time_ex

; 4914 : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
datetime_gettimetz ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$datetime_utctimetuple DD imagerel datetime_utctimetuple
	DD	imagerel datetime_utctimetuple+316
	DD	imagerel $unwind$datetime_utctimetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utctimetuple DD 0cea01H
	DD	0ed4eaH
	DD	0dc4e0H
	DD	0c54d6H
	DD	0f340dH
	DD	0e009720dH
	DD	060067007H
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
xdata	ENDS
;	COMDAT datetime_utctimetuple
_TEXT	SEGMENT
self$ = 96
datetime_utctimetuple PROC				; COMDAT

; 4918 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4919 :     int y, m, d, hh, mm, ss;
; 4920 :     PyObject *tzinfo;
; 4921 :     PyDateTime_DateTime *utcself;
; 4922 : 
; 4923 :     tzinfo = GET_DT_TZINFO(self);

  0000d	80 79 68 00	 cmp	 BYTE PTR [rcx+104], 0
  00011	48 8b d9	 mov	 rbx, rcx
  00014	74 69		 je	 SHORT $LN15@datetime_u@3
  00016	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]

; 4924 :     if (tzinfo == Py_None) {

  0001a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:_Py_NoneStruct
  00021	48 3b ce	 cmp	 rcx, rsi
  00024	74 59		 je	 SHORT $LN15@datetime_u@3

; 4927 :     }
; 4928 :     else {
; 4929 :         PyObject *offset;
; 4930 :         offset = call_utcoffset(tzinfo, (PyObject *)self);

  00026	48 8b d3	 mov	 rdx, rbx
  00029	e8 00 00 00 00	 call	 call_utcoffset
  0002e	48 8b f8	 mov	 rdi, rax

; 4931 :         if (offset == NULL)

  00031	48 85 c0	 test	 rax, rax

; 4932 :             return NULL;

  00034	74 39		 je	 SHORT $LN16@datetime_u@3

; 4933 :         if (offset == Py_None) {

  00036	48 3b c6	 cmp	 rax, rsi
  00039	75 15		 jne	 SHORT $LN3@datetime_u@3

; 4934 :             Py_DECREF(offset);

  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 _Py_DecRef

; 4935 :             utcself = self;
; 4936 :             Py_INCREF(utcself);

  00043	48 8b cb	 mov	 rcx, rbx
  00046	4c 8b f3	 mov	 r14, rbx
  00049	e8 00 00 00 00	 call	 _Py_IncRef

; 4937 :         }
; 4938 :         else {

  0004e	eb 6d		 jmp	 SHORT $LN1@datetime_u@3
$LN3@datetime_u@3:

; 4939 :             utcself = (PyDateTime_DateTime *)add_datetime_timedelta(self,
; 4940 :                                                 (PyDateTime_Delta *)offset, -1);

  00050	41 83 c8 ff	 or	 r8d, -1
  00054	48 8b d0	 mov	 rdx, rax
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	e8 00 00 00 00	 call	 add_datetime_timedelta

; 4941 :             Py_DECREF(offset);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	4c 8b f0	 mov	 r14, rax
  00065	e8 00 00 00 00	 call	 _Py_DecRef

; 4942 :             if (utcself == NULL)

  0006a	4d 85 f6	 test	 r14, r14
  0006d	75 4e		 jne	 SHORT $LN1@datetime_u@3
$LN16@datetime_u@3:

; 4943 :                 return NULL;

  0006f	33 c0		 xor	 eax, eax

; 4955 : }

  00071	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00076	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007a	41 5e		 pop	 r14
  0007c	5f		 pop	 rdi
  0007d	5e		 pop	 rsi
  0007e	c3		 ret	 0
$LN15@datetime_u@3:

; 4925 :         utcself = self;

  0007f	4c 8b f3	 mov	 r14, rbx

; 4926 :         Py_INCREF(utcself);

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	85 c0		 test	 eax, eax
  00089	75 32		 jne	 SHORT $LN1@datetime_u@3
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00099	4c 8b cb	 mov	 r9, rbx
  0009c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  000a2	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000aa	e8 00 00 00 00	 call	 _PyParallel_Guard
  000af	85 c0		 test	 eax, eax
  000b1	75 06		 jne	 SHORT $LN11@datetime_u@3
  000b3	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  000b7	74 04		 je	 SHORT $LN1@datetime_u@3
$LN11@datetime_u@3:
  000b9	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN1@datetime_u@3:

; 4944 :         }
; 4945 :     }
; 4946 :     y = GET_YEAR(utcself);

  000bd	41 0f b6 46 6a	 movzx	 eax, BYTE PTR [r14+106]

; 4947 :     m = GET_MONTH(utcself);
; 4948 :     d = GET_DAY(utcself);
; 4949 :     hh = DATE_GET_HOUR(utcself);

  000c2	41 0f b6 76 6d	 movzx	 esi, BYTE PTR [r14+109]

; 4950 :     mm = DATE_GET_MINUTE(utcself);

  000c7	41 0f b6 7e 6e	 movzx	 edi, BYTE PTR [r14+110]

; 4951 :     ss = DATE_GET_SECOND(utcself);

  000cc	41 0f b6 5e 6f	 movzx	 ebx, BYTE PTR [r14+111]
  000d1	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  000d6	41 0f b6 6e 6c	 movzx	 ebp, BYTE PTR [r14+108]
  000db	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  000e0	45 0f b6 66 6b	 movzx	 r12d, BYTE PTR [r14+107]
  000e5	4c 89 6c 24 70	 mov	 QWORD PTR [rsp+112], r13
  000ea	45 0f b6 6e 69	 movzx	 r13d, BYTE PTR [r14+105]

; 4952 : 
; 4953 :     Py_DECREF(utcself);

  000ef	49 8b ce	 mov	 rcx, r14
  000f2	41 c1 e5 08	 shl	 r13d, 8
  000f6	44 0b e8	 or	 r13d, eax
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 4954 :     return build_struct_time(y, m, d, hh, mm, ss, 0);

  000fe	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00106	44 8b ce	 mov	 r9d, esi
  00109	44 8b c5	 mov	 r8d, ebp
  0010c	41 8b d4	 mov	 edx, r12d
  0010f	41 8b cd	 mov	 ecx, r13d
  00112	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  00116	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  0011a	e8 00 00 00 00	 call	 build_struct_time
  0011f	4c 8b 6c 24 70	 mov	 r13, QWORD PTR [rsp+112]
  00124	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00129	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 4955 : }

  0012e	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00133	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00137	41 5e		 pop	 r14
  00139	5f		 pop	 rdi
  0013a	5e		 pop	 rsi
  0013b	c3		 ret	 0
datetime_utctimetuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_getstate DD imagerel datetime_getstate
	DD	imagerel datetime_getstate+144
	DD	imagerel $unwind$datetime_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_getstate DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_getstate
_TEXT	SEGMENT
self$ = 48
datetime_getstate PROC					; COMDAT

; 4966 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 4967 :     PyObject *basestate;
; 4968 :     PyObject *result = NULL;
; 4969 : 
; 4970 :     basestate = PyBytes_FromStringAndSize((char *)self->data,
; 4971 :                                            _PyDateTime_DATETIME_DATASIZE);

  0000d	ba 0a 00 00 00	 mov	 edx, 10
  00012	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00016	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0001b	48 8b f8	 mov	 rdi, rax

; 4972 :     if (basestate != NULL) {

  0001e	48 85 c0	 test	 rax, rax
  00021	74 62		 je	 SHORT $LN7@datetime_g@2

; 4973 :         if (! HASTZINFO(self) || self->tzinfo == Py_None)

  00023	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00027	74 36		 je	 SHORT $LN2@datetime_g@2
  00029	4c 8b 43 78	 mov	 r8, QWORD PTR [rbx+120]
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00034	4c 3b c0	 cmp	 r8, rax
  00037	74 26		 je	 SHORT $LN2@datetime_g@2

; 4975 :         else
; 4976 :             result = PyTuple_Pack(2, basestate, self->tzinfo);

  00039	48 8b d7	 mov	 rdx, rdi
  0003c	b9 02 00 00 00	 mov	 ecx, 2
  00041	e8 00 00 00 00	 call	 PyTuple_Pack

; 4977 :         Py_DECREF(basestate);

  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 8b d8	 mov	 rbx, rax
  0004c	e8 00 00 00 00	 call	 _Py_DecRef

; 4978 :     }
; 4979 :     return result;

  00051	48 8b c3	 mov	 rax, rbx

; 4980 : }

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
$LN2@datetime_g@2:

; 4974 :             result = PyTuple_Pack(1, basestate);

  0005f	48 8b d7	 mov	 rdx, rdi
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	e8 00 00 00 00	 call	 PyTuple_Pack

; 4977 :         Py_DECREF(basestate);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 8b d8	 mov	 rbx, rax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 4978 :     }
; 4979 :     return result;

  00077	48 8b c3	 mov	 rax, rbx

; 4980 : }

  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
  00084	c3		 ret	 0
$LN7@datetime_g@2:
  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
datetime_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_reduce DD imagerel datetime_reduce
	DD	imagerel datetime_reduce+38
	DD	imagerel $unwind$datetime_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_reduce DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT datetime_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
datetime_reduce PROC					; COMDAT

; 4984 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 4985 :     return Py_BuildValue("(ON)", Py_TYPE(self), datetime_getstate(self));

  00009	e8 00 00 00 00	 call	 datetime_getstate
  0000e	48 8b 53 58	 mov	 rdx, QWORD PTR [rbx+88]
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  00019	4c 8b c0	 mov	 r8, rax

; 4986 : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	e9 00 00 00 00	 jmp	 Py_BuildValue
datetime_reduce ENDP
_TEXT	ENDS
PUBLIC	__real@42619a1c74000000
PUBLIC	__real@42341dd760000000
PUBLIC	__real@41ead27480000000
PUBLIC	??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@		; `string'
PUBLIC	??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@	; `string'
PUBLIC	??_C@_08EDKBBHCH@timezone?$AA@			; `string'
PUBLIC	??_C@_09BNCODEBM@timedelta?$AA@			; `string'
PUBLIC	??_C@_08FGNPMIBK@datetime?$AA@			; `string'
PUBLIC	??_C@_07EKPINOGJ@MAXYEAR?$AA@			; `string'
PUBLIC	??_C@_07KMJIHBII@MINYEAR?$AA@			; `string'
PUBLIC	??_C@_03JPHCIIKF@utc?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_0L@CAGNKJED@resolution?$AA@		; `string'
PUBLIC	PyInit__datetime
EXTRN	PyCapsule_New:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_AddIntConstant:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyModule_Create2:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$PyInit__datetime DD imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__datetime DD imagerel $LN82+55
	DD	imagerel $LN82+92
	DD	imagerel $chain$0$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyInit__datetime DD imagerel $LN82+92
	DD	imagerel $LN82+134
	DD	imagerel $chain$3$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$PyInit__datetime DD imagerel $LN82+134
	DD	imagerel $LN82+200
	DD	imagerel $chain$6$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$PyInit__datetime DD imagerel $LN82+200
	DD	imagerel $LN82+640
	DD	imagerel $chain$8$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$PyInit__datetime DD imagerel $LN82+640
	DD	imagerel $LN82+878
	DD	imagerel $chain$9$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$PyInit__datetime DD imagerel $LN82+878
	DD	imagerel $LN82+2374
	DD	imagerel $chain$10$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$11$PyInit__datetime DD imagerel $LN82+2374
	DD	imagerel $LN82+2382
	DD	imagerel $chain$11$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$12$PyInit__datetime DD imagerel $LN82+2382
	DD	imagerel $LN82+2398
	DD	imagerel $chain$12$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$13$PyInit__datetime DD imagerel $LN82+2398
	DD	imagerel $LN82+2419
	DD	imagerel $chain$13$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$15$PyInit__datetime DD imagerel $LN82+2419
	DD	imagerel $LN82+2423
	DD	imagerel $chain$15$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$16$PyInit__datetime DD imagerel $LN82+2423
	DD	imagerel $LN82+2427
	DD	imagerel $chain$16$PyInit__datetime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$17$PyInit__datetime DD imagerel $LN82+2427
	DD	imagerel $LN82+2431
	DD	imagerel $chain$17$PyInit__datetime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$17$PyInit__datetime DD 0a0021H
	DD	0af400H
	DD	0be400H
	DD	0dc400H
	DD	0127400H
	DD	0116400H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$16$PyInit__datetime DD 0c0021H
	DD	0af400H
	DD	0be400H
	DD	0dc400H
	DD	0127400H
	DD	0116400H
	DD	0105400H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$15$PyInit__datetime DD 0e0021H
	DD	0af400H
	DD	0be400H
	DD	0cd400H
	DD	0dc400H
	DD	0127400H
	DD	0116400H
	DD	0105400H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$13$PyInit__datetime DD 021H
	DD	imagerel $LN82+134
	DD	imagerel $LN82+200
	DD	imagerel $chain$6$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$12$PyInit__datetime DD 021H
	DD	imagerel $LN82+200
	DD	imagerel $LN82+640
	DD	imagerel $chain$8$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$11$PyInit__datetime DD 021H
	DD	imagerel $LN82+640
	DD	imagerel $LN82+878
	DD	imagerel $chain$9$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$PyInit__datetime DD 020521H
	DD	0cd405H
	DD	imagerel $LN82+640
	DD	imagerel $LN82+878
	DD	imagerel $chain$9$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$PyInit__datetime DD 020821H
	DD	0105408H
	DD	imagerel $LN82+200
	DD	imagerel $LN82+640
	DD	imagerel $chain$8$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$PyInit__datetime DD 041f21H
	DD	012741fH
	DD	0116408H
	DD	imagerel $LN82+134
	DD	imagerel $LN82+200
	DD	imagerel $chain$6$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$PyInit__datetime DD 060521H
	DD	0af405H
	DD	0be400H
	DD	0dc400H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyInit__datetime DD 040521H
	DD	0dc405H
	DD	0be400H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__datetime DD 020521H
	DD	0be405H
	DD	imagerel $LN82
	DD	imagerel $LN82+55
	DD	imagerel $unwind$PyInit__datetime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__datetime DD 020601H
	DD	03002d206H
xdata	ENDS
;	COMDAT __real@42619a1c74000000
CONST	SEGMENT
__real@42619a1c74000000 DQ 042619a1c74000000r	; 6.048e+011
CONST	ENDS
;	COMDAT __real@42341dd760000000
CONST	SEGMENT
__real@42341dd760000000 DQ 042341dd760000000r	; 8.64e+010
CONST	ENDS
;	COMDAT __real@41ead27480000000
CONST	SEGMENT
__real@41ead27480000000 DQ 041ead27480000000r	; 3.6e+009
CONST	ENDS
;	COMDAT ??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@
CONST	SEGMENT
??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@ DB 'datetime_CAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@
CONST	SEGMENT
??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@ DB 'datetime.datetime_CAP'
	DB	'I', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDKBBHCH@timezone?$AA@
CONST	SEGMENT
??_C@_08EDKBBHCH@timezone?$AA@ DB 'timezone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNCODEBM@timedelta?$AA@
CONST	SEGMENT
??_C@_09BNCODEBM@timedelta?$AA@ DB 'timedelta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGNPMIBK@datetime?$AA@
CONST	SEGMENT
??_C@_08FGNPMIBK@datetime?$AA@ DB 'datetime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKPINOGJ@MAXYEAR?$AA@
CONST	SEGMENT
??_C@_07EKPINOGJ@MAXYEAR?$AA@ DB 'MAXYEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJIHBII@MINYEAR?$AA@
CONST	SEGMENT
??_C@_07KMJIHBII@MINYEAR?$AA@ DB 'MINYEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JPHCIIKF@utc?$AA@
CONST	SEGMENT
??_C@_03JPHCIIKF@utc?$AA@ DB 'utc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CAGNKJED@resolution?$AA@
CONST	SEGMENT
??_C@_0L@CAGNKJED@resolution?$AA@ DB 'resolution', 00H	; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT PyInit__datetime
_TEXT	SEGMENT
PyInit__datetime PROC					; COMDAT

; 5170 : {

$LN82:
  00000	40 53		 push	 rbx
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 5171 :     PyObject *m;        /* a module object */
; 5172 :     PyObject *d;        /* its dict */
; 5173 :     PyObject *x;
; 5174 :     PyObject *delta;
; 5175 : 
; 5176 :     m = PyModule_Create(&datetimemodule);

  00006	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:datetimemodule
  0000d	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00012	e8 00 00 00 00	 call	 PyModule_Create2
  00017	48 8b d8	 mov	 rbx, rax

; 5177 :     if (m == NULL)

  0001a	48 85 c0	 test	 rax, rax
  0001d	75 08		 jne	 SHORT $LN46@PyInit__da
$LN81@PyInit__da:

; 5178 :         return NULL;

  0001f	33 c0		 xor	 eax, eax

; 5365 : }

  00021	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
$LN46@PyInit__da:

; 5179 : 
; 5180 :     if (PyType_Ready(&PyDateTime_DateType) < 0)

  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateType
  0002e	e8 00 00 00 00	 call	 PyType_Ready
  00033	85 c0		 test	 eax, eax

; 5181 :         return NULL;

  00035	78 e8		 js	 SHORT $LN81@PyInit__da

; 5182 :     if (PyType_Ready(&PyDateTime_DateTimeType) < 0)

  00037	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  0003c	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:PyDateTime_DateTimeType
  00043	49 8b ce	 mov	 rcx, r14
  00046	e8 00 00 00 00	 call	 PyType_Ready
  0004b	85 c0		 test	 eax, eax
  0004d	79 0d		 jns	 SHORT $LN44@PyInit__da

; 5183 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 5365 : }

  00056	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN44@PyInit__da:
  0005c	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12

; 5184 :     if (PyType_Ready(&PyDateTime_DeltaType) < 0)

  00061	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:PyDateTime_DeltaType
  00068	49 8b cc	 mov	 rcx, r12
  0006b	e8 00 00 00 00	 call	 PyType_Ready
  00070	85 c0		 test	 eax, eax
  00072	79 12		 jns	 SHORT $LN43@PyInit__da

; 5185 :         return NULL;

  00074	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00079	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  0007e	33 c0		 xor	 eax, eax

; 5365 : }

  00080	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00084	5b		 pop	 rbx
  00085	c3		 ret	 0
$LN43@PyInit__da:
  00086	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15

; 5186 :     if (PyType_Ready(&PyDateTime_TimeType) < 0)

  0008b	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:PyDateTime_TimeType
  00092	49 8b cf	 mov	 rcx, r15
  00095	e8 00 00 00 00	 call	 PyType_Ready
  0009a	85 c0		 test	 eax, eax

; 5187 :         return NULL;

  0009c	78 20		 js	 SHORT $LN80@PyInit__da

; 5188 :     if (PyType_Ready(&PyDateTime_TZInfoType) < 0)

  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TZInfoType
  000a5	e8 00 00 00 00	 call	 PyType_Ready
  000aa	85 c0		 test	 eax, eax

; 5189 :         return NULL;

  000ac	78 10		 js	 SHORT $LN80@PyInit__da

; 5190 :     if (PyType_Ready(&PyDateTime_TimeZoneType) < 0)

  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeZoneType
  000b5	e8 00 00 00 00	 call	 PyType_Ready
  000ba	85 c0		 test	 eax, eax
  000bc	79 07		 jns	 SHORT $LN40@PyInit__da
$LN80@PyInit__da:

; 5191 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 99 08 00 00	 jmp	 $LN75@PyInit__da
$LN40@PyInit__da:

; 5192 : 
; 5193 :     /* timedelta values */
; 5194 :     d = PyDateTime_DeltaType.tp_dict;
; 5195 : 
; 5196 :     x = new_delta(0, 0, 1, 0);

  000c5	45 33 c9	 xor	 r9d, r9d
  000c8	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rsi
  000d0	48 8b 35 60 01
	00 00		 mov	 rsi, QWORD PTR PyDateTime_DeltaType+352
  000d7	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000db	33 d2		 xor	 edx, edx
  000dd	33 c9		 xor	 ecx, ecx
  000df	48 89 bc 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rdi
  000e7	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000ec	e8 00 00 00 00	 call	 new_delta_ex
  000f1	48 8b f8	 mov	 rdi, rax

; 5197 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  000f4	48 85 c0	 test	 rax, rax
  000f7	0f 84 7e 08 00
	00		 je	 $LN38@PyInit__da
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  00104	4c 8b c0	 mov	 r8, rax
  00107	48 8b ce	 mov	 rcx, rsi
  0010a	e8 00 00 00 00	 call	 PyDict_SetItemString
  0010f	85 c0		 test	 eax, eax
  00111	0f 88 64 08 00
	00		 js	 $LN38@PyInit__da

; 5199 :     Py_DECREF(x);

  00117	48 8b cf	 mov	 rcx, rdi
  0011a	e8 00 00 00 00	 call	 _Py_DecRef

; 5200 : 
; 5201 :     x = new_delta(-MAX_DELTA_DAYS, 0, 0, 0);

  0011f	45 33 c9	 xor	 r9d, r9d
  00122	45 33 c0	 xor	 r8d, r8d
  00125	33 d2		 xor	 edx, edx
  00127	b9 01 36 65 c4	 mov	 ecx, -999999999		; ffffffffc4653601H
  0012c	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00131	e8 00 00 00 00	 call	 new_delta_ex
  00136	48 8b f8	 mov	 rdi, rax

; 5202 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00139	48 85 c0	 test	 rax, rax
  0013c	0f 84 39 08 00
	00		 je	 $LN38@PyInit__da
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  00149	4c 8b c0	 mov	 r8, rax
  0014c	48 8b ce	 mov	 rcx, rsi
  0014f	e8 00 00 00 00	 call	 PyDict_SetItemString
  00154	85 c0		 test	 eax, eax
  00156	0f 88 1f 08 00
	00		 js	 $LN38@PyInit__da

; 5203 :         return NULL;
; 5204 :     Py_DECREF(x);

  0015c	48 8b cf	 mov	 rcx, rdi
  0015f	e8 00 00 00 00	 call	 _Py_DecRef

; 5205 : 
; 5206 :     x = new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0);

  00164	45 33 c9	 xor	 r9d, r9d
  00167	ba 7f 51 01 00	 mov	 edx, 86399		; 0001517fH
  0016c	b9 ff c9 9a 3b	 mov	 ecx, 999999999		; 3b9ac9ffH
  00171	41 b8 3f 42 0f
	00		 mov	 r8d, 999999		; 000f423fH
  00177	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0017c	e8 00 00 00 00	 call	 new_delta_ex
  00181	48 8b f8	 mov	 rdi, rax

; 5207 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00184	48 85 c0	 test	 rax, rax
  00187	0f 84 ee 07 00
	00		 je	 $LN38@PyInit__da
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00194	4c 8b c0	 mov	 r8, rax
  00197	48 8b ce	 mov	 rcx, rsi
  0019a	e8 00 00 00 00	 call	 PyDict_SetItemString
  0019f	85 c0		 test	 eax, eax
  001a1	0f 88 d4 07 00
	00		 js	 $LN38@PyInit__da

; 5208 :         return NULL;
; 5209 :     Py_DECREF(x);

  001a7	48 8b cf	 mov	 rcx, rdi
  001aa	e8 00 00 00 00	 call	 _Py_DecRef

; 5210 : 
; 5211 :     /* date values */
; 5212 :     d = PyDateTime_DateType.tp_dict;

  001af	48 8b 35 60 01
	00 00		 mov	 rsi, QWORD PTR PyDateTime_DateType+352

; 5213 : 
; 5214 :     x = new_date(1, 1, 1);

  001b6	ba 01 00 00 00	 mov	 edx, 1
  001bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  001c2	8b ca		 mov	 ecx, edx
  001c4	44 8b c2	 mov	 r8d, edx
  001c7	e8 00 00 00 00	 call	 new_date_ex
  001cc	48 8b f8	 mov	 rdi, rax

; 5215 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  001cf	48 85 c0	 test	 rax, rax
  001d2	0f 84 a3 07 00
	00		 je	 $LN38@PyInit__da
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  001df	4c 8b c0	 mov	 r8, rax
  001e2	48 8b ce	 mov	 rcx, rsi
  001e5	e8 00 00 00 00	 call	 PyDict_SetItemString
  001ea	85 c0		 test	 eax, eax
  001ec	0f 88 89 07 00
	00		 js	 $LN38@PyInit__da

; 5216 :         return NULL;
; 5217 :     Py_DECREF(x);

  001f2	48 8b cf	 mov	 rcx, rdi
  001f5	e8 00 00 00 00	 call	 _Py_DecRef

; 5218 : 
; 5219 :     x = new_date(MAXYEAR, 12, 31);

  001fa	ba 0c 00 00 00	 mov	 edx, 12
  001ff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  00206	44 8d 42 13	 lea	 r8d, QWORD PTR [rdx+19]
  0020a	b9 0f 27 00 00	 mov	 ecx, 9999		; 0000270fH
  0020f	e8 00 00 00 00	 call	 new_date_ex
  00214	48 8b f8	 mov	 rdi, rax

; 5220 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00217	48 85 c0	 test	 rax, rax
  0021a	0f 84 5b 07 00
	00		 je	 $LN38@PyInit__da
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00227	4c 8b c0	 mov	 r8, rax
  0022a	48 8b ce	 mov	 rcx, rsi
  0022d	e8 00 00 00 00	 call	 PyDict_SetItemString
  00232	85 c0		 test	 eax, eax
  00234	0f 88 41 07 00
	00		 js	 $LN38@PyInit__da

; 5221 :         return NULL;
; 5222 :     Py_DECREF(x);

  0023a	48 8b cf	 mov	 rcx, rdi
  0023d	e8 00 00 00 00	 call	 _Py_DecRef

; 5223 : 
; 5224 :     x = new_delta(1, 0, 0, 0);

  00242	33 d2		 xor	 edx, edx
  00244	45 33 c9	 xor	 r9d, r9d
  00247	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  0024a	45 33 c0	 xor	 r8d, r8d
  0024d	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00252	e8 00 00 00 00	 call	 new_delta_ex
  00257	48 8b f8	 mov	 rdi, rax

; 5225 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  0025a	48 85 c0	 test	 rax, rax
  0025d	0f 84 18 07 00
	00		 je	 $LN38@PyInit__da
  00263	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  0026a	4c 8b c0	 mov	 r8, rax
  0026d	48 8b ce	 mov	 rcx, rsi
  00270	e8 00 00 00 00	 call	 PyDict_SetItemString
  00275	85 c0		 test	 eax, eax
  00277	0f 88 fe 06 00
	00		 js	 $LN38@PyInit__da

; 5226 :         return NULL;
; 5227 :     Py_DECREF(x);

  0027d	48 8b cf	 mov	 rcx, rdi
  00280	48 89 ac 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbp
  00288	e8 00 00 00 00	 call	 _Py_DecRef

; 5228 : 
; 5229 :     /* time values */
; 5230 :     d = PyDateTime_TimeType.tp_dict;

  0028d	48 8b 35 60 01
	00 00		 mov	 rsi, QWORD PTR PyDateTime_TimeType+352

; 5231 : 
; 5232 :     x = new_time(0, 0, 0, 0, Py_None);

  00294	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NoneStruct
  0029b	45 33 c9	 xor	 r9d, r9d
  0029e	45 33 c0	 xor	 r8d, r8d
  002a1	33 d2		 xor	 edx, edx
  002a3	33 c9		 xor	 ecx, ecx
  002a5	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  002aa	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  002af	e8 00 00 00 00	 call	 new_time_ex
  002b4	48 8b f8	 mov	 rdi, rax

; 5233 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  002b7	48 85 c0	 test	 rax, rax
  002ba	0f 84 b7 06 00
	00		 je	 $LN26@PyInit__da
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  002c7	4c 8b c0	 mov	 r8, rax
  002ca	48 8b ce	 mov	 rcx, rsi
  002cd	e8 00 00 00 00	 call	 PyDict_SetItemString
  002d2	85 c0		 test	 eax, eax
  002d4	0f 88 9d 06 00
	00		 js	 $LN26@PyInit__da

; 5235 :     Py_DECREF(x);

  002da	48 8b cf	 mov	 rcx, rdi
  002dd	e8 00 00 00 00	 call	 _Py_DecRef

; 5236 : 
; 5237 :     x = new_time(23, 59, 59, 999999, Py_None);

  002e2	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  002e7	41 b9 3f 42 0f
	00		 mov	 r9d, 999999		; 000f423fH
  002ed	8d 4a dc	 lea	 ecx, QWORD PTR [rdx-36]
  002f0	44 8b c2	 mov	 r8d, edx
  002f3	4c 89 7c 24 28	 mov	 QWORD PTR [rsp+40], r15
  002f8	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  002fd	e8 00 00 00 00	 call	 new_time_ex
  00302	48 8b f8	 mov	 rdi, rax

; 5238 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00305	48 85 c0	 test	 rax, rax
  00308	0f 84 69 06 00
	00		 je	 $LN26@PyInit__da
  0030e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00315	4c 8b c0	 mov	 r8, rax
  00318	48 8b ce	 mov	 rcx, rsi
  0031b	e8 00 00 00 00	 call	 PyDict_SetItemString
  00320	85 c0		 test	 eax, eax
  00322	0f 88 4f 06 00
	00		 js	 $LN26@PyInit__da

; 5239 :         return NULL;
; 5240 :     Py_DECREF(x);

  00328	48 8b cf	 mov	 rcx, rdi
  0032b	e8 00 00 00 00	 call	 _Py_DecRef

; 5241 : 
; 5242 :     x = new_delta(0, 0, 1, 0);

  00330	45 33 c9	 xor	 r9d, r9d
  00333	33 d2		 xor	 edx, edx
  00335	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00339	33 c9		 xor	 ecx, ecx
  0033b	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00340	e8 00 00 00 00	 call	 new_delta_ex
  00345	48 8b f8	 mov	 rdi, rax

; 5243 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  00348	48 85 c0	 test	 rax, rax
  0034b	0f 84 26 06 00
	00		 je	 $LN26@PyInit__da
  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  00358	4c 8b c0	 mov	 r8, rax
  0035b	48 8b ce	 mov	 rcx, rsi
  0035e	e8 00 00 00 00	 call	 PyDict_SetItemString
  00363	85 c0		 test	 eax, eax
  00365	0f 88 0c 06 00
	00		 js	 $LN26@PyInit__da

; 5244 :         return NULL;
; 5245 :     Py_DECREF(x);

  0036b	48 8b cf	 mov	 rcx, rdi
  0036e	4c 89 6c 24 60	 mov	 QWORD PTR [rsp+96], r13
  00373	e8 00 00 00 00	 call	 _Py_DecRef

; 5246 : 
; 5247 :     /* datetime values */
; 5248 :     d = PyDateTime_DateTimeType.tp_dict;

  00378	48 8b 35 60 01
	00 00		 mov	 rsi, QWORD PTR PyDateTime_DateTimeType+352

; 5249 : 
; 5250 :     x = new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None);

  0037f	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  00384	45 33 ed	 xor	 r13d, r13d
  00387	ba 01 00 00 00	 mov	 edx, 1
  0038c	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00391	44 89 6c 24 30	 mov	 DWORD PTR [rsp+48], r13d
  00396	8b ca		 mov	 ecx, edx
  00398	44 8b c2	 mov	 r8d, edx
  0039b	45 33 c9	 xor	 r9d, r9d
  0039e	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  003a3	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  003a8	e8 00 00 00 00	 call	 new_datetime_ex
  003ad	48 8b f8	 mov	 rdi, rax

; 5251 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  003b0	48 85 c0	 test	 rax, rax
  003b3	0f 84 ba 05 00
	00		 je	 $LN20@PyInit__da
  003b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  003c0	4c 8b c0	 mov	 r8, rax
  003c3	48 8b ce	 mov	 rcx, rsi
  003c6	e8 00 00 00 00	 call	 PyDict_SetItemString
  003cb	85 c0		 test	 eax, eax
  003cd	0f 88 a0 05 00
	00		 js	 $LN20@PyInit__da

; 5253 :     Py_DECREF(x);

  003d3	48 8b cf	 mov	 rcx, rdi
  003d6	e8 00 00 00 00	 call	 _Py_DecRef

; 5254 : 
; 5255 :     x = new_datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, Py_None);

  003db	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  003e0	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  003e5	c7 44 24 30 3f
	42 0f 00	 mov	 DWORD PTR [rsp+48], 999999 ; 000f423fH
  003ed	41 8d 55 0c	 lea	 edx, QWORD PTR [r13+12]
  003f1	45 8d 4d 17	 lea	 r9d, QWORD PTR [r13+23]
  003f5	45 8d 45 1f	 lea	 r8d, QWORD PTR [r13+31]
  003f9	b9 0f 27 00 00	 mov	 ecx, 9999		; 0000270fH
  003fe	c7 44 24 28 3b
	00 00 00	 mov	 DWORD PTR [rsp+40], 59	; 0000003bH
  00406	c7 44 24 20 3b
	00 00 00	 mov	 DWORD PTR [rsp+32], 59	; 0000003bH
  0040e	e8 00 00 00 00	 call	 new_datetime_ex
  00413	48 8b f8	 mov	 rdi, rax

; 5256 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00416	48 85 c0	 test	 rax, rax
  00419	0f 84 54 05 00
	00		 je	 $LN20@PyInit__da
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00426	4c 8b c0	 mov	 r8, rax
  00429	48 8b ce	 mov	 rcx, rsi
  0042c	e8 00 00 00 00	 call	 PyDict_SetItemString
  00431	85 c0		 test	 eax, eax
  00433	0f 88 3a 05 00
	00		 js	 $LN20@PyInit__da

; 5257 :         return NULL;
; 5258 :     Py_DECREF(x);

  00439	48 8b cf	 mov	 rcx, rdi
  0043c	e8 00 00 00 00	 call	 _Py_DecRef

; 5259 : 
; 5260 :     x = new_delta(0, 0, 1, 0);

  00441	45 8d 45 01	 lea	 r8d, QWORD PTR [r13+1]
  00445	45 33 c9	 xor	 r9d, r9d
  00448	33 d2		 xor	 edx, edx
  0044a	33 c9		 xor	 ecx, ecx
  0044c	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00451	e8 00 00 00 00	 call	 new_delta_ex
  00456	48 8b f8	 mov	 rdi, rax

; 5261 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  00459	48 85 c0	 test	 rax, rax
  0045c	0f 84 11 05 00
	00		 je	 $LN20@PyInit__da
  00462	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  00469	4c 8b c0	 mov	 r8, rax
  0046c	48 8b ce	 mov	 rcx, rsi
  0046f	e8 00 00 00 00	 call	 PyDict_SetItemString
  00474	85 c0		 test	 eax, eax
  00476	0f 88 f7 04 00
	00		 js	 $LN20@PyInit__da

; 5262 :         return NULL;
; 5263 :     Py_DECREF(x);

  0047c	48 8b cf	 mov	 rcx, rdi
  0047f	e8 00 00 00 00	 call	 _Py_DecRef

; 5264 : 
; 5265 :     /* timezone values */
; 5266 :     d = PyDateTime_TimeZoneType.tp_dict;

  00484	48 8b 2d 60 01
	00 00		 mov	 rbp, QWORD PTR PyDateTime_TimeZoneType+352

; 5267 : 
; 5268 :     delta = new_delta(0, 0, 0, 0);

  0048b	45 33 c9	 xor	 r9d, r9d
  0048e	45 33 c0	 xor	 r8d, r8d
  00491	33 d2		 xor	 edx, edx
  00493	33 c9		 xor	 ecx, ecx
  00495	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0049a	e8 00 00 00 00	 call	 new_delta_ex
  0049f	48 8b f0	 mov	 rsi, rax

; 5269 :     if (delta == NULL)

  004a2	48 85 c0	 test	 rax, rax

; 5270 :         return NULL;

  004a5	0f 84 c8 04 00
	00		 je	 $LN20@PyInit__da

; 5271 :     x = create_timezone(delta, NULL);

  004ab	33 d2		 xor	 edx, edx
  004ad	48 8b c8	 mov	 rcx, rax
  004b0	e8 00 00 00 00	 call	 create_timezone

; 5272 :     Py_DECREF(delta);

  004b5	48 8b ce	 mov	 rcx, rsi
  004b8	48 8b f8	 mov	 rdi, rax
  004bb	e8 00 00 00 00	 call	 _Py_DecRef

; 5273 :     if (x == NULL || PyDict_SetItemString(d, "utc", x) < 0)

  004c0	48 85 ff	 test	 rdi, rdi
  004c3	0f 84 aa 04 00
	00		 je	 $LN20@PyInit__da
  004c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JPHCIIKF@utc?$AA@
  004d0	4c 8b c7	 mov	 r8, rdi
  004d3	48 8b cd	 mov	 rcx, rbp
  004d6	e8 00 00 00 00	 call	 PyDict_SetItemString
  004db	85 c0		 test	 eax, eax
  004dd	0f 88 90 04 00
	00		 js	 $LN20@PyInit__da

; 5274 :         return NULL;
; 5275 :     PyDateTime_TimeZone_UTC = x;
; 5276 : 
; 5277 :     delta = new_delta(-1, 60, 0, 1); /* -23:59 */

  004e3	45 8d 4d 01	 lea	 r9d, QWORD PTR [r13+1]
  004e7	41 8d 55 3c	 lea	 edx, QWORD PTR [r13+60]
  004eb	45 33 c0	 xor	 r8d, r8d
  004ee	83 c9 ff	 or	 ecx, -1
  004f1	48 89 3d 00 00
	00 00		 mov	 QWORD PTR PyDateTime_TimeZone_UTC, rdi
  004f8	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  004fd	e8 00 00 00 00	 call	 new_delta_ex
  00502	48 8b f0	 mov	 rsi, rax

; 5278 :     if (delta == NULL)

  00505	48 85 c0	 test	 rax, rax

; 5279 :         return NULL;

  00508	0f 84 65 04 00
	00		 je	 $LN20@PyInit__da

; 5280 :     x = create_timezone(delta, NULL);

  0050e	33 d2		 xor	 edx, edx
  00510	48 8b c8	 mov	 rcx, rax
  00513	e8 00 00 00 00	 call	 create_timezone

; 5281 :     Py_DECREF(delta);

  00518	48 8b ce	 mov	 rcx, rsi
  0051b	48 8b f8	 mov	 rdi, rax
  0051e	e8 00 00 00 00	 call	 _Py_DecRef

; 5282 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00523	48 85 ff	 test	 rdi, rdi
  00526	0f 84 47 04 00
	00		 je	 $LN20@PyInit__da
  0052c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  00533	4c 8b c7	 mov	 r8, rdi
  00536	48 8b cd	 mov	 rcx, rbp
  00539	e8 00 00 00 00	 call	 PyDict_SetItemString
  0053e	85 c0		 test	 eax, eax
  00540	0f 88 2d 04 00
	00		 js	 $LN20@PyInit__da

; 5283 :         return NULL;
; 5284 :     Py_DECREF(x);

  00546	48 8b cf	 mov	 rcx, rdi
  00549	e8 00 00 00 00	 call	 _Py_DecRef

; 5285 : 
; 5286 :     delta = new_delta(0, (23 * 60 + 59) * 60, 0, 0); /* +23:59 */

  0054e	45 33 c9	 xor	 r9d, r9d
  00551	45 33 c0	 xor	 r8d, r8d
  00554	ba 44 51 01 00	 mov	 edx, 86340		; 00015144H
  00559	33 c9		 xor	 ecx, ecx
  0055b	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00560	e8 00 00 00 00	 call	 new_delta_ex
  00565	48 8b f0	 mov	 rsi, rax

; 5287 :     if (delta == NULL)

  00568	48 85 c0	 test	 rax, rax

; 5288 :         return NULL;

  0056b	0f 84 02 04 00
	00		 je	 $LN20@PyInit__da

; 5289 :     x = create_timezone(delta, NULL);

  00571	33 d2		 xor	 edx, edx
  00573	48 8b c8	 mov	 rcx, rax
  00576	e8 00 00 00 00	 call	 create_timezone

; 5290 :     Py_DECREF(delta);

  0057b	48 8b ce	 mov	 rcx, rsi
  0057e	48 8b f8	 mov	 rdi, rax
  00581	e8 00 00 00 00	 call	 _Py_DecRef

; 5291 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00586	48 85 ff	 test	 rdi, rdi
  00589	0f 84 e4 03 00
	00		 je	 $LN20@PyInit__da
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00596	4c 8b c7	 mov	 r8, rdi
  00599	48 8b cd	 mov	 rcx, rbp
  0059c	e8 00 00 00 00	 call	 PyDict_SetItemString
  005a1	85 c0		 test	 eax, eax
  005a3	0f 88 ca 03 00
	00		 js	 $LN20@PyInit__da

; 5292 :         return NULL;
; 5293 :     Py_DECREF(x);

  005a9	48 8b cf	 mov	 rcx, rdi
  005ac	e8 00 00 00 00	 call	 _Py_DecRef

; 5294 : 
; 5295 :     /* Epoch */
; 5296 :     PyDateTime_Epoch = new_datetime(1970, 1, 1, 0, 0, 0, 0,
; 5297 :                                     PyDateTime_TimeZone_UTC);

  005b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZone_UTC
  005b8	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  005bd	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  005c2	ba 01 00 00 00	 mov	 edx, 1
  005c7	44 89 6c 24 30	 mov	 DWORD PTR [rsp+48], r13d
  005cc	45 33 c9	 xor	 r9d, r9d
  005cf	b9 b2 07 00 00	 mov	 ecx, 1970		; 000007b2H
  005d4	44 8b c2	 mov	 r8d, edx
  005d7	44 89 6c 24 28	 mov	 DWORD PTR [rsp+40], r13d
  005dc	44 89 6c 24 20	 mov	 DWORD PTR [rsp+32], r13d
  005e1	e8 00 00 00 00	 call	 new_datetime_ex
  005e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR PyDateTime_Epoch, rax

; 5298 :     if (PyDateTime_Epoch == NULL)

  005ed	48 85 c0	 test	 rax, rax

; 5299 :       return NULL;

  005f0	0f 84 7d 03 00
	00		 je	 $LN20@PyInit__da

; 5300 : 
; 5301 :     /* module initialization */
; 5302 :     PyModule_AddIntConstant(m, "MINYEAR", MINYEAR);

  005f6	45 8d 45 01	 lea	 r8d, QWORD PTR [r13+1]
  005fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KMJIHBII@MINYEAR?$AA@
  00601	48 8b cb	 mov	 rcx, rbx
  00604	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 5303 :     PyModule_AddIntConstant(m, "MAXYEAR", MAXYEAR);

  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EKPINOGJ@MAXYEAR?$AA@
  00610	41 b8 0f 27 00
	00		 mov	 r8d, 9999		; 0000270fH
  00616	48 8b cb	 mov	 rcx, rbx
  00619	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 5304 : 
; 5305 :     Py_INCREF(&PyDateTime_DateType);

  0061e	e8 00 00 00 00	 call	 _Py_PXCTX
  00623	85 c0		 test	 eax, eax
  00625	75 3c		 jne	 SHORT $LN50@PyInit__da
  00627	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  0062e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00635	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  0063c	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00642	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0064a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0064f	85 c0		 test	 eax, eax
  00651	75 09		 jne	 SHORT $LN49@PyInit__da
  00653	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_DateType+32, 32 ; 00000020H
  0065a	74 07		 je	 SHORT $LN50@PyInit__da
$LN49@PyInit__da:
  0065c	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_DateType+80
$LN50@PyInit__da:

; 5306 :     PyModule_AddObject(m, "date", (PyObject *) &PyDateTime_DateType);

  00663	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DateType
  0066a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JNIHBGGH@date?$AA@
  00671	48 8b cb	 mov	 rcx, rbx
  00674	e8 00 00 00 00	 call	 PyModule_AddObject

; 5307 : 
; 5308 :     Py_INCREF(&PyDateTime_DateTimeType);

  00679	e8 00 00 00 00	 call	 _Py_PXCTX
  0067e	85 c0		 test	 eax, eax
  00680	75 38		 jne	 SHORT $LN54@PyInit__da
  00682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00689	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00690	4d 8b ce	 mov	 r9, r14
  00693	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00699	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  006a1	e8 00 00 00 00	 call	 _PyParallel_Guard
  006a6	85 c0		 test	 eax, eax
  006a8	75 09		 jne	 SHORT $LN53@PyInit__da
  006aa	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_DateTimeType+32, 32 ; 00000020H
  006b1	74 07		 je	 SHORT $LN54@PyInit__da
$LN53@PyInit__da:
  006b3	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_DateTimeType+80
$LN54@PyInit__da:

; 5309 :     PyModule_AddObject(m, "datetime",
; 5310 :                        (PyObject *)&PyDateTime_DateTimeType);

  006ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08FGNPMIBK@datetime?$AA@
  006c1	4d 8b c6	 mov	 r8, r14
  006c4	48 8b cb	 mov	 rcx, rbx
  006c7	e8 00 00 00 00	 call	 PyModule_AddObject

; 5311 : 
; 5312 :     Py_INCREF(&PyDateTime_TimeType);

  006cc	e8 00 00 00 00	 call	 _Py_PXCTX
  006d1	85 c0		 test	 eax, eax
  006d3	75 38		 jne	 SHORT $LN58@PyInit__da
  006d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  006e3	4d 8b cf	 mov	 r9, r15
  006e6	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  006ec	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  006f4	e8 00 00 00 00	 call	 _PyParallel_Guard
  006f9	85 c0		 test	 eax, eax
  006fb	75 09		 jne	 SHORT $LN57@PyInit__da
  006fd	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_TimeType+32, 32 ; 00000020H
  00704	74 07		 je	 SHORT $LN58@PyInit__da
$LN57@PyInit__da:
  00706	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_TimeType+80
$LN58@PyInit__da:

; 5313 :     PyModule_AddObject(m, "time", (PyObject *) &PyDateTime_TimeType);

  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  00714	4d 8b c7	 mov	 r8, r15
  00717	48 8b cb	 mov	 rcx, rbx
  0071a	e8 00 00 00 00	 call	 PyModule_AddObject

; 5314 : 
; 5315 :     Py_INCREF(&PyDateTime_DeltaType);

  0071f	e8 00 00 00 00	 call	 _Py_PXCTX
  00724	85 c0		 test	 eax, eax
  00726	75 38		 jne	 SHORT $LN62@PyInit__da
  00728	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0072f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00736	4d 8b cc	 mov	 r9, r12
  00739	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  0073f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00747	e8 00 00 00 00	 call	 _PyParallel_Guard
  0074c	85 c0		 test	 eax, eax
  0074e	75 09		 jne	 SHORT $LN61@PyInit__da
  00750	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_DeltaType+32, 32 ; 00000020H
  00757	74 07		 je	 SHORT $LN62@PyInit__da
$LN61@PyInit__da:
  00759	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_DeltaType+80
$LN62@PyInit__da:

; 5316 :     PyModule_AddObject(m, "timedelta", (PyObject *) &PyDateTime_DeltaType);

  00760	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BNCODEBM@timedelta?$AA@
  00767	4d 8b c4	 mov	 r8, r12
  0076a	48 8b cb	 mov	 rcx, rbx
  0076d	e8 00 00 00 00	 call	 PyModule_AddObject

; 5317 : 
; 5318 :     Py_INCREF(&PyDateTime_TZInfoType);

  00772	e8 00 00 00 00	 call	 _Py_PXCTX
  00777	85 c0		 test	 eax, eax
  00779	75 3c		 jne	 SHORT $LN66@PyInit__da
  0077b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_TZInfoType
  00782	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00790	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00796	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0079e	e8 00 00 00 00	 call	 _PyParallel_Guard
  007a3	85 c0		 test	 eax, eax
  007a5	75 09		 jne	 SHORT $LN65@PyInit__da
  007a7	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_TZInfoType+32, 32 ; 00000020H
  007ae	74 07		 je	 SHORT $LN66@PyInit__da
$LN65@PyInit__da:
  007b0	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_TZInfoType+80
$LN66@PyInit__da:

; 5319 :     PyModule_AddObject(m, "tzinfo", (PyObject *) &PyDateTime_TZInfoType);

  007b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_TZInfoType
  007be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
  007c5	48 8b cb	 mov	 rcx, rbx
  007c8	e8 00 00 00 00	 call	 PyModule_AddObject

; 5320 : 
; 5321 :     Py_INCREF(&PyDateTime_TimeZoneType);

  007cd	e8 00 00 00 00	 call	 _Py_PXCTX
  007d2	85 c0		 test	 eax, eax
  007d4	75 3c		 jne	 SHORT $LN70@PyInit__da
  007d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_TimeZoneType
  007dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  007e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  007eb	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  007f1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  007f9	e8 00 00 00 00	 call	 _PyParallel_Guard
  007fe	85 c0		 test	 eax, eax
  00800	75 09		 jne	 SHORT $LN69@PyInit__da
  00802	f6 05 20 00 00
	00 20		 test	 BYTE PTR PyDateTime_TimeZoneType+32, 32 ; 00000020H
  00809	74 07		 je	 SHORT $LN70@PyInit__da
$LN69@PyInit__da:
  0080b	48 ff 05 50 00
	00 00		 inc	 QWORD PTR PyDateTime_TimeZoneType+80
$LN70@PyInit__da:

; 5322 :     PyModule_AddObject(m, "timezone", (PyObject *) &PyDateTime_TimeZoneType);

  00812	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_TimeZoneType
  00819	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EDKBBHCH@timezone?$AA@
  00820	48 8b cb	 mov	 rcx, rbx
  00823	e8 00 00 00 00	 call	 PyModule_AddObject

; 5323 : 
; 5324 :     x = PyCapsule_New(&CAPI, PyDateTime_CAPSULE_NAME, NULL);

  00828	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@
  0082f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CAPI
  00836	45 33 c0	 xor	 r8d, r8d
  00839	e8 00 00 00 00	 call	 PyCapsule_New

; 5325 :     if (x == NULL)

  0083e	48 85 c0	 test	 rax, rax

; 5326 :         return NULL;

  00841	0f 84 2c 01 00
	00		 je	 $LN20@PyInit__da

; 5327 :     PyModule_AddObject(m, "datetime_CAPI", x);

  00847	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@
  0084e	4c 8b c0	 mov	 r8, rax
  00851	48 8b cb	 mov	 rcx, rbx
  00854	e8 00 00 00 00	 call	 PyModule_AddObject

; 5328 : 
; 5329 :     /* A 4-year cycle has an extra leap day over what we'd get from
; 5330 :      * pasting together 4 single years.
; 5331 :      */
; 5332 :     assert(DI4Y == 4 * 365 + 1);
; 5333 :     assert(DI4Y == days_before_year(4+1));
; 5334 : 
; 5335 :     /* Similarly, a 400-year cycle has an extra leap day over what we'd
; 5336 :      * get from pasting together 4 100-year cycles.
; 5337 :      */
; 5338 :     assert(DI400Y == 4 * DI100Y + 1);
; 5339 :     assert(DI400Y == days_before_year(400+1));
; 5340 : 
; 5341 :     /* OTOH, a 100-year cycle has one fewer leap day than we'd get from
; 5342 :      * pasting together 25 4-year cycles.
; 5343 :      */
; 5344 :     assert(DI100Y == 25 * DI4Y - 1);
; 5345 :     assert(DI100Y == days_before_year(100+1));
; 5346 : 
; 5347 :     us_per_us = PyLong_FromLong(1);

  00859	b9 01 00 00 00	 mov	 ecx, 1
  0085e	e8 00 00 00 00	 call	 PyLong_FromLong

; 5348 :     us_per_ms = PyLong_FromLong(1000);

  00863	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00868	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_us, rax
  0086f	e8 00 00 00 00	 call	 PyLong_FromLong

; 5349 :     us_per_second = PyLong_FromLong(1000000);

  00874	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00879	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_ms, rax
  00880	e8 00 00 00 00	 call	 PyLong_FromLong

; 5350 :     us_per_minute = PyLong_FromLong(60000000);

  00885	b9 00 87 93 03	 mov	 ecx, 60000000		; 03938700H
  0088a	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_second, rax
  00891	e8 00 00 00 00	 call	 PyLong_FromLong

; 5351 :     seconds_per_day = PyLong_FromLong(24 * 3600);

  00896	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  0089b	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_minute, rax
  008a2	e8 00 00 00 00	 call	 PyLong_FromLong

; 5352 :     if (us_per_us == NULL || us_per_ms == NULL || us_per_second == NULL ||
; 5353 :         us_per_minute == NULL || seconds_per_day == NULL)

  008a7	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_us, r13
  008ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR seconds_per_day, rax
  008b5	0f 84 b8 00 00
	00		 je	 $LN20@PyInit__da
  008bb	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_ms, r13
  008c2	0f 84 ab 00 00
	00		 je	 $LN20@PyInit__da
  008c8	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_second, r13
  008cf	0f 84 9e 00 00
	00		 je	 $LN20@PyInit__da
  008d5	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_minute, r13
  008dc	0f 84 91 00 00
	00		 je	 $LN20@PyInit__da
  008e2	48 85 c0	 test	 rax, rax
  008e5	0f 84 88 00 00
	00		 je	 $LN20@PyInit__da

; 5354 :         return NULL;
; 5355 : 
; 5356 :     /* The rest are too big for 32-bit ints, but even
; 5357 :      * us_per_week fits in 40 bits, so doubles should be exact.
; 5358 :      */
; 5359 :     us_per_hour = PyLong_FromDouble(3600000000.0);

  008eb	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41ead27480000000
  008f3	e8 00 00 00 00	 call	 PyLong_FromDouble

; 5360 :     us_per_day = PyLong_FromDouble(86400000000.0);

  008f8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@42341dd760000000
  00900	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_hour, rax
  00907	e8 00 00 00 00	 call	 PyLong_FromDouble

; 5361 :     us_per_week = PyLong_FromDouble(604800000000.0);

  0090c	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@42619a1c74000000
  00914	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_day, rax
  0091b	e8 00 00 00 00	 call	 PyLong_FromDouble

; 5362 :     if (us_per_hour == NULL || us_per_day == NULL || us_per_week == NULL)

  00920	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_hour, r13
  00927	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_week, rax
  0092e	74 43		 je	 SHORT $LN20@PyInit__da
  00930	4c 39 2d 00 00
	00 00		 cmp	 QWORD PTR us_per_day, r13
  00937	74 3a		 je	 SHORT $LN20@PyInit__da
  00939	48 85 c0	 test	 rax, rax
  0093c	74 35		 je	 SHORT $LN20@PyInit__da

; 5363 :         return NULL;
; 5364 :     return m;

  0093e	48 8b c3	 mov	 rax, rbx
$LN79@PyInit__da:
  00941	4c 8b 6c 24 60	 mov	 r13, QWORD PTR [rsp+96]
$LN78@PyInit__da:
  00946	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
$LN77@PyInit__da:
  0094e	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR [rsp+136]
  00956	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR [rsp+144]
$LN75@PyInit__da:
  0095e	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]
  00963	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  00968	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]

; 5365 : }

  0096d	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00971	5b		 pop	 rbx
  00972	c3		 ret	 0
$LN20@PyInit__da:

; 5252 :         return NULL;

  00973	33 c0		 xor	 eax, eax
  00975	eb ca		 jmp	 SHORT $LN79@PyInit__da
$LN26@PyInit__da:

; 5234 :         return NULL;

  00977	33 c0		 xor	 eax, eax
  00979	eb cb		 jmp	 SHORT $LN78@PyInit__da
$LN38@PyInit__da:

; 5198 :         return NULL;

  0097b	33 c0		 xor	 eax, eax
  0097d	eb cf		 jmp	 SHORT $LN77@PyInit__da
PyInit__datetime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@ ; `string'
PUBLIC	??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$new_timezone DD imagerel new_timezone
	DD	imagerel new_timezone+21
	DD	imagerel $unwind$new_timezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$new_timezone DD imagerel new_timezone+21
	DD	imagerel new_timezone+109
	DD	imagerel $chain$0$new_timezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$new_timezone DD imagerel new_timezone+109
	DD	imagerel new_timezone+220
	DD	imagerel $chain$1$new_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$new_timezone DD 021H
	DD	imagerel new_timezone
	DD	imagerel new_timezone+21
	DD	imagerel $unwind$new_timezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$new_timezone DD 020521H
	DD	063405H
	DD	imagerel new_timezone
	DD	imagerel new_timezone+21
	DD	imagerel $unwind$new_timezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_timezone DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@
CONST	SEGMENT
??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@ DB 'offset must'
	DB	' be a timedelta representing a whole number of minutes, not %'
	DB	'R.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@
CONST	SEGMENT
??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@ DB 'offset must'
	DB	' be a timedelta strictly between -timedelta(hours=24) and tim'
	DB	'edelta(hours=24), not %R.', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT new_timezone
_TEXT	SEGMENT
offset$ = 64
name$ = 72
new_timezone PROC					; COMDAT

; 801  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b c2	 mov	 r8, rdx

; 802  :     assert(offset != NULL);
; 803  :     assert(PyDelta_Check(offset));
; 804  :     assert(name == NULL || PyUnicode_Check(name));
; 805  : 
; 806  :     if (name == NULL && delta_bool((PyDateTime_Delta *)offset) == 0) {

  00007	48 85 d2	 test	 rdx, rdx
  0000a	75 61		 jne	 SHORT $LN6@new_timezo
  0000c	e8 00 00 00 00	 call	 delta_bool
  00011	85 c0		 test	 eax, eax
  00013	75 58		 jne	 SHORT $LN6@new_timezo

; 807  :         Py_INCREF(PyDateTime_TimeZone_UTC);

  00015	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0001a	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR PyDateTime_TimeZone_UTC
  00021	e8 00 00 00 00	 call	 _Py_PXCTX
  00026	85 c0		 test	 eax, eax
  00028	75 32		 jne	 SHORT $LN10@new_timezo
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00038	4c 8b cb	 mov	 r9, rbx
  0003b	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00041	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00049	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004e	85 c0		 test	 eax, eax
  00050	75 06		 jne	 SHORT $LN9@new_timezo
  00052	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  00056	74 04		 je	 SHORT $LN10@new_timezo
$LN9@new_timezo:
  00058	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN10@new_timezo:

; 808  :         return PyDateTime_TimeZone_UTC;

  0005c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZone_UTC
  00063	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 826  : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
$LN6@new_timezo:

; 809  :     }
; 810  :     if (GET_TD_MICROSECONDS(offset) != 0 || GET_TD_SECONDS(offset) % 60 != 0) {

  0006d	83 79 70 00	 cmp	 DWORD PTR [rcx+112], 0
  00071	75 4c		 jne	 SHORT $LN4@new_timezo
  00073	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  00077	b8 89 88 88 88	 mov	 eax, -2004318071	; ffffffff88888889H
  0007c	41 f7 e9	 imul	 r9d
  0007f	41 03 d1	 add	 edx, r9d
  00082	c1 fa 05	 sar	 edx, 5
  00085	8b c2		 mov	 eax, edx
  00087	c1 e8 1f	 shr	 eax, 31
  0008a	03 d0		 add	 edx, eax
  0008c	6b d2 3c	 imul	 edx, 60			; 0000003cH
  0008f	44 3b ca	 cmp	 r9d, edx
  00092	75 2b		 jne	 SHORT $LN4@new_timezo

; 815  :     }
; 816  :     if ((GET_TD_DAYS(offset) == -1 && GET_TD_SECONDS(offset) == 0) ||
; 817  :         GET_TD_DAYS(offset) < -1 || GET_TD_DAYS(offset) >= 1) {

  00094	8b 41 68	 mov	 eax, DWORD PTR [rcx+104]
  00097	83 f8 ff	 cmp	 eax, -1
  0009a	75 07		 jne	 SHORT $LN13@new_timezo
  0009c	45 85 c9	 test	 r9d, r9d
  0009f	74 15		 je	 SHORT $LN2@new_timezo
  000a1	3b c0		 cmp	 eax, eax
$LN13@new_timezo:
  000a3	7c 11		 jl	 SHORT $LN2@new_timezo
  000a5	83 f8 01	 cmp	 eax, 1
  000a8	7d 0c		 jge	 SHORT $LN2@new_timezo

; 823  :     }
; 824  : 
; 825  :     return create_timezone(offset, name);

  000aa	49 8b d0	 mov	 rdx, r8

; 826  : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	e9 00 00 00 00	 jmp	 create_timezone
$LN2@new_timezo:

; 818  :         PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 819  :                      " strictly between -timedelta(hours=24) and"
; 820  :                      " timedelta(hours=24),"
; 821  :                      " not %R.", offset);

  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@

; 822  :         return NULL;

  000bd	eb 07		 jmp	 SHORT $LN14@new_timezo
$LN4@new_timezo:

; 811  :         PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 812  :                      " representing a whole number of minutes,"
; 813  :                      " not %R.", offset);

  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@
$LN14@new_timezo:
  000c6	4c 8b c1	 mov	 r8, rcx
  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d0	e8 00 00 00 00	 call	 PyErr_Format

; 814  :         return NULL;

  000d5	33 c0		 xor	 eax, eax

; 826  : }

  000d7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000db	c3		 ret	 0
new_timezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@	; `string'
EXTRN	PyOS_snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_utcoffset DD imagerel format_utcoffset
	DD	imagerel format_utcoffset+288
	DD	imagerel $unwind$format_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_utcoffset DD 0a7e01H
	DD	0f647eH
	DD	0e3479H
	DD	010540eH
	DD	0d00a920eH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@ DB '%c%02d%s%02d', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT format_utcoffset
_TEXT	SEGMENT
minutes$ = 64
seconds$ = 64
buf$ = 112
buflen$ = 120
sep$ = 128
tzinfo$ = 136
tzinfoarg$ = 144
format_utcoffset PROC					; COMDAT

; 1039 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000e	4c 8b ea	 mov	 r13, rdx

; 1040 :     PyObject *offset;
; 1041 :     int hours, minutes, seconds;
; 1042 :     char sign;
; 1043 : 
; 1044 :     assert(buflen >= 1);
; 1045 : 
; 1046 :     offset = call_utcoffset(tzinfo, tzinfoarg);

  00011	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tzinfoarg$[rsp]
  00019	48 8b e9	 mov	 rbp, rcx
  0001c	49 8b c9	 mov	 rcx, r9
  0001f	4d 8b e0	 mov	 r12, r8
  00022	e8 00 00 00 00	 call	 call_utcoffset
  00027	48 8b f8	 mov	 rdi, rax

; 1047 :     if (offset == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	75 15		 jne	 SHORT $LN5@format_utc

; 1048 :         return -1;

  0002f	83 c8 ff	 or	 eax, -1

; 1076 : }

  00032	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  0003a	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0003e	41 5d		 pop	 r13
  00040	41 5c		 pop	 r12
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN5@format_utc:

; 1049 :     if (offset == Py_None) {

  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0004b	48 3b f8	 cmp	 rdi, rax
  0004e	75 20		 jne	 SHORT $LN4@format_utc

; 1050 :         Py_DECREF(offset);

  00050	48 8b cf	 mov	 rcx, rdi
  00053	e8 00 00 00 00	 call	 _Py_DecRef

; 1051 :         *buf = '\0';

  00058	c6 45 00 00	 mov	 BYTE PTR [rbp], 0

; 1052 :         return 0;

  0005c	33 c0		 xor	 eax, eax

; 1076 : }

  0005e	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00066	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0006a	41 5d		 pop	 r13
  0006c	41 5c		 pop	 r12
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
$LN4@format_utc:

; 1053 :     }
; 1054 :     /* Offset is normalized, so it is negative if days < 0 */
; 1055 :     if (GET_TD_DAYS(offset) < 0) {

  00070	83 7f 68 00	 cmp	 DWORD PTR [rdi+104], 0
  00074	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00079	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  0007e	7d 23		 jge	 SHORT $LN3@format_utc

; 1056 :         PyObject *temp = offset;
; 1057 :         sign = '-';
; 1058 :         offset = delta_negative((PyDateTime_Delta *)offset);

  00080	48 8b cf	 mov	 rcx, rdi
  00083	48 8b df	 mov	 rbx, rdi
  00086	40 b6 2d	 mov	 sil, 45			; 0000002dH
  00089	e8 00 00 00 00	 call	 delta_negative

; 1059 :         Py_DECREF(temp);

  0008e	48 8b cb	 mov	 rcx, rbx
  00091	48 8b f8	 mov	 rdi, rax
  00094	e8 00 00 00 00	 call	 _Py_DecRef

; 1060 :         if (offset == NULL)

  00099	48 85 ff	 test	 rdi, rdi
  0009c	75 08		 jne	 SHORT $LN1@format_utc

; 1061 :             return -1;

  0009e	83 c8 ff	 or	 eax, -1
  000a1	eb 61		 jmp	 SHORT $LN9@format_utc
$LN3@format_utc:

; 1062 :     }
; 1063 :     else {
; 1064 :         sign = '+';

  000a3	40 b6 2b	 mov	 sil, 43			; 0000002bH
$LN1@format_utc:

; 1065 :     }
; 1066 :     /* Offset is not negative here. */
; 1067 :     seconds = GET_TD_SECONDS(offset);

  000a6	8b 5f 6c	 mov	 ebx, DWORD PTR [rdi+108]

; 1068 :     Py_DECREF(offset);

  000a9	48 8b cf	 mov	 rcx, rdi
  000ac	89 5c 24 40	 mov	 DWORD PTR seconds$[rsp], ebx
  000b0	e8 00 00 00 00	 call	 _Py_DecRef

; 1069 :     minutes = divmod(seconds, 60, &seconds);

  000b5	4c 8d 44 24 40	 lea	 r8, QWORD PTR seconds$[rsp]
  000ba	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000bf	8b cb		 mov	 ecx, ebx
  000c1	e8 00 00 00 00	 call	 divmod

; 1070 :     hours = divmod(minutes, 60, &minutes);

  000c6	4c 8d 44 24 40	 lea	 r8, QWORD PTR minutes$[rsp]
  000cb	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000d0	8b c8		 mov	 ecx, eax
  000d2	89 44 24 40	 mov	 DWORD PTR minutes$[rsp], eax
  000d6	e8 00 00 00 00	 call	 divmod

; 1071 :     assert(seconds == 0);
; 1072 :     /* XXX ignore sub-minute data, curently not allowed. */
; 1073 :     PyOS_snprintf(buf, buflen, "%c%02d%s%02d", sign, hours, sep, minutes);

  000db	8b 4c 24 40	 mov	 ecx, DWORD PTR minutes$[rsp]
  000df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@
  000e6	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000ea	44 0f be ce	 movsx	 r9d, sil
  000ee	49 8b d5	 mov	 rdx, r13
  000f1	48 8b cd	 mov	 rcx, rbp
  000f4	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  000f9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fd	e8 00 00 00 00	 call	 PyOS_snprintf

; 1074 : 
; 1075 :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN9@format_utc:

; 1076 : }

  00104	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  00109	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  0010e	48 8b ac 24 80
	00 00 00	 mov	 rbp, QWORD PTR [rsp+128]
  00116	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0011a	41 5d		 pop	 r13
  0011c	41 5c		 pop	 r12
  0011e	5f		 pop	 rdi
  0011f	c3		 ret	 0
format_utcoffset ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MJJLPNK@OO?$AA@				; `string'
PUBLIC	??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@ ; `string'
EXTRN	PyUnicode_FromString:PROC
EXTRN	_PyBytes_Resize:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$wrap_strftime DD imagerel wrap_strftime
	DD	imagerel wrap_strftime+161
	DD	imagerel $unwind$wrap_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$wrap_strftime DD imagerel wrap_strftime+161
	DD	imagerel wrap_strftime+982
	DD	imagerel $chain$1$wrap_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$wrap_strftime DD imagerel wrap_strftime+982
	DD	imagerel wrap_strftime+1337
	DD	imagerel $chain$2$wrap_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$wrap_strftime DD 021H
	DD	imagerel wrap_strftime
	DD	imagerel wrap_strftime+161
	DD	imagerel $unwind$wrap_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$wrap_strftime DD 020821H
	DD	0186408H
	DD	imagerel wrap_strftime
	DD	imagerel wrap_strftime+161
	DD	imagerel $unwind$wrap_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_strftime DD 0a6b01H
	DD	021346bH
	DD	0190120H
	DD	0e017f019H
	DD	0c013d015H
	DD	050107011H
xdata	ENDS
;	COMDAT ??_C@_02MJJLPNK@OO?$AA@
CONST	SEGMENT
??_C@_02MJJLPNK@OO?$AA@ DB 'OO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@
CONST	SEGMENT
??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@ DB 'strft'
	DB	'ime format ends with raw %', 00H		; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT wrap_strftime
_TEXT	SEGMENT
result$1$ = 48
ntoappend$ = 56
newfmt$ = 64
flen$ = 72
buf$21145 = 80
object$ = 256
format$ = 264
timetuple$ = 272
tzinfoarg$ = 280
wrap_strftime PROC					; COMDAT

; 1146 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1147 :     PyObject *result = NULL;            /* guilty until proved innocent */

  00020	45 33 ff	 xor	 r15d, r15d
  00023	48 8b c2	 mov	 rax, rdx
  00026	48 8b f9	 mov	 rdi, rcx

; 1148 : 
; 1149 :     PyObject *zreplacement = NULL;      /* py string, replacement for %z */
; 1150 :     PyObject *Zreplacement = NULL;      /* py string, replacement for %Z */
; 1151 :     PyObject *freplacement = NULL;      /* py string, replacement for %f */
; 1152 : 
; 1153 :     const char *pin;            /* pointer to next char in input format */
; 1154 :     Py_ssize_t flen;            /* length of input format */
; 1155 :     char ch;                    /* next char in input format */
; 1156 : 
; 1157 :     PyObject *newfmt = NULL;            /* py string, the output format */
; 1158 :     char *pnew;         /* pointer to available byte in output format */
; 1159 :     size_t totalnew;            /* number bytes total in output format buffer,
; 1160 :                                exclusive of trailing \0 */
; 1161 :     size_t usednew;     /* number bytes used so far in output format buffer */
; 1162 : 
; 1163 :     const char *ptoappend;      /* ptr to string to append to output buffer */
; 1164 :     Py_ssize_t ntoappend;       /* # of bytes to append to output buffer */
; 1165 : 
; 1166 :     assert(object && format && timetuple);
; 1167 :     assert(PyUnicode_Check(format));
; 1168 :     /* Convert the input format to a C string and size */
; 1169 :     pin = _PyUnicode_AsStringAndSize(format, &flen);

  00029	48 8d 54 24 48	 lea	 rdx, QWORD PTR flen$[rsp]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	4c 89 7c 24 30	 mov	 QWORD PTR result$1$[rsp], r15
  00036	45 8b e7	 mov	 r12d, r15d
  00039	45 8b f7	 mov	 r14d, r15d
  0003c	41 8b ef	 mov	 ebp, r15d
  0003f	4c 89 7c 24 40	 mov	 QWORD PTR newfmt$[rsp], r15
  00044	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00049	4c 8b e8	 mov	 r13, rax

; 1170 :     if (!pin)

  0004c	48 85 c0	 test	 rax, rax
  0004f	75 12		 jne	 SHORT $LN49@wrap_strft

; 1307 : }

  00051	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00058	41 5f		 pop	 r15
  0005a	41 5e		 pop	 r14
  0005c	41 5d		 pop	 r13
  0005e	41 5c		 pop	 r12
  00060	5f		 pop	 rdi
  00061	5d		 pop	 rbp
  00062	c3		 ret	 0
$LN49@wrap_strft:
  00063	48 89 9c 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rbx

; 1171 :         return NULL;
; 1172 : 
; 1173 :     /* Scan the input format, looking for %z/%Z/%f escapes, building
; 1174 :      * a new format.  Since computing the replacements for those codes
; 1175 :      * is expensive, don't unless they're actually used.
; 1176 :      */
; 1177 :     if (flen > INT_MAX - 1) {

  0006b	48 8b 5c 24 48	 mov	 rbx, QWORD PTR flen$[rsp]
  00070	48 81 fb fe ff
	ff 7f		 cmp	 rbx, 2147483646		; 7ffffffeH
  00077	7e 0a		 jle	 SHORT $LN48@wrap_strft

; 1178 :         PyErr_NoMemory();

  00079	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1179 :         goto Done;

  0007e	e9 2a 04 00 00	 jmp	 $LN7@wrap_strft
$LN48@wrap_strft:

; 1180 :     }
; 1181 : 
; 1182 :     totalnew = flen + 1;        /* realistic if no %z/%Z */

  00083	48 ff c3	 inc	 rbx

; 1183 :     newfmt = PyBytes_FromStringAndSize(NULL, totalnew);

  00086	33 c9		 xor	 ecx, ecx
  00088	48 8b d3	 mov	 rdx, rbx
  0008b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00090	48 89 44 24 40	 mov	 QWORD PTR newfmt$[rsp], rax

; 1184 :     if (newfmt == NULL) goto Done;

  00095	48 85 c0	 test	 rax, rax
  00098	0f 84 7e 04 00
	00		 je	 $LN3@wrap_strft

; 1185 :     pnew = PyBytes_AsString(newfmt);

  0009e	48 8b c8	 mov	 rcx, rax
  000a1	48 89 b4 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rsi
  000a9	e8 00 00 00 00	 call	 PyBytes_AsString
  000ae	48 8b f0	 mov	 rsi, rax

; 1186 :     usednew = 0;
; 1187 : 
; 1188 :     while ((ch = *pin++) != '\0') {

  000b1	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
  000b6	84 c0		 test	 al, al
  000b8	0f 84 13 02 00
	00		 je	 $LN109@wrap_strft
$LN119@wrap_strft:
  000be	49 ff c5	 inc	 r13
  000c1	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH

; 1189 :         if (ch != '%') {

  000cb	3c 25		 cmp	 al, 37			; 00000025H
  000cd	74 0f		 je	 SHORT $LN44@wrap_strft

; 1190 :             ptoappend = pin - 1;
; 1191 :             ntoappend = 1;

  000cf	49 8d 7d ff	 lea	 rdi, QWORD PTR [r13-1]
  000d3	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d9	e9 51 01 00 00	 jmp	 $LN117@wrap_strft
$LN44@wrap_strft:

; 1192 :         }
; 1193 :         else if ((ch = *pin++) == '\0') {

  000de	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
  000e3	49 ff c5	 inc	 r13
  000e6	84 c0		 test	 al, al
  000e8	0f 84 cb 01 00
	00		 je	 $LN101@wrap_strft

; 1198 :         }
; 1199 :         /* A % has been seen and ch is the character after it. */
; 1200 :         else if (ch == 'z') {

  000ee	3c 7a		 cmp	 al, 122			; 0000007aH
  000f0	0f 85 ab 00 00
	00		 jne	 $LN40@wrap_strft

; 1201 :             if (zreplacement == NULL) {

  000f6	4d 85 e4	 test	 r12, r12
  000f9	0f 85 96 00 00
	00		 jne	 $LN35@wrap_strft

; 1202 :                 /* format utcoffset */
; 1203 :                 char buf[100];
; 1204 :                 PyObject *tzinfo = get_tzinfo_member(object);

  000ff	48 8b cf	 mov	 rcx, rdi
  00102	e8 00 00 00 00	 call	 get_tzinfo_member

; 1205 :                 zreplacement = PyBytes_FromStringAndSize("", 0);

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0010e	33 d2		 xor	 edx, edx
  00110	48 8b f8	 mov	 rdi, rax
  00113	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00118	4c 8b e0	 mov	 r12, rax

; 1206 :                 if (zreplacement == NULL) goto Done;

  0011b	48 85 c0	 test	 rax, rax
  0011e	0f 84 3b 02 00
	00		 je	 $Done$21130

; 1207 :                 if (tzinfo != Py_None && tzinfo != NULL) {

  00124	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0012b	48 3b f8	 cmp	 rdi, rax
  0012e	74 65		 je	 SHORT $LN35@wrap_strft
  00130	48 85 ff	 test	 rdi, rdi
  00133	74 60		 je	 SHORT $LN35@wrap_strft

; 1208 :                     assert(tzinfoarg != NULL);
; 1209 :                     if (format_utcoffset(buf,
; 1210 :                                          sizeof(buf),
; 1211 :                                          "",
; 1212 :                                          tzinfo,
; 1213 :                                          tzinfoarg) < 0)

  00135	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tzinfoarg$[rsp]
  0013d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00144	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$21145[rsp]
  00149	4c 8b cf	 mov	 r9, rdi
  0014c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00151	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00156	e8 00 00 00 00	 call	 format_utcoffset
  0015b	85 c0		 test	 eax, eax
  0015d	0f 88 fc 01 00
	00		 js	 $Done$21130

; 1214 :                         goto Done;
; 1215 :                     Py_DECREF(zreplacement);

  00163	49 8b cc	 mov	 rcx, r12
  00166	e8 00 00 00 00	 call	 _Py_DecRef

; 1216 :                     zreplacement =
; 1217 :                       PyBytes_FromStringAndSize(buf,
; 1218 :                                                strlen(buf));

  0016b	48 83 c9 ff	 or	 rcx, -1
  0016f	33 c0		 xor	 eax, eax
  00171	48 8d 7c 24 50	 lea	 rdi, QWORD PTR buf$21145[rsp]
  00176	f2 ae		 repne scasb
  00178	48 f7 d1	 not	 rcx
  0017b	48 8d 51 ff	 lea	 rdx, QWORD PTR [rcx-1]
  0017f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$21145[rsp]
  00184	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00189	4c 8b e0	 mov	 r12, rax

; 1219 :                     if (zreplacement == NULL)

  0018c	48 85 c0	 test	 rax, rax
  0018f	0f 84 ca 01 00
	00		 je	 $Done$21130
$LN35@wrap_strft:

; 1220 :                         goto Done;
; 1221 :                 }
; 1222 :             }
; 1223 :             assert(zreplacement != NULL);
; 1224 :             ptoappend = PyBytes_AS_STRING(zreplacement);
; 1225 :             ntoappend = PyBytes_GET_SIZE(zreplacement);

  00195	4d 8b 44 24 60	 mov	 r8, QWORD PTR [r12+96]
  0019a	49 8d 7c 24 78	 lea	 rdi, QWORD PTR [r12+120]
  0019f	eb 6a		 jmp	 SHORT $LN118@wrap_strft
$LN40@wrap_strft:

; 1226 :         }
; 1227 :         else if (ch == 'Z') {

  001a1	3c 5a		 cmp	 al, 90			; 0000005aH
  001a3	75 41		 jne	 SHORT $LN33@wrap_strft

; 1228 :             /* format tzname */
; 1229 :             if (Zreplacement == NULL) {

  001a5	4d 85 f6	 test	 r14, r14
  001a8	75 1c		 jne	 SHORT $LN31@wrap_strft

; 1230 :                 Zreplacement = make_Zreplacement(object,
; 1231 :                                                  tzinfoarg);

  001aa	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR tzinfoarg$[rsp]
  001b2	48 8b cf	 mov	 rcx, rdi
  001b5	e8 00 00 00 00	 call	 make_Zreplacement
  001ba	4c 8b f0	 mov	 r14, rax

; 1232 :                 if (Zreplacement == NULL)

  001bd	48 85 c0	 test	 rax, rax
  001c0	0f 84 99 01 00
	00		 je	 $Done$21130
$LN31@wrap_strft:

; 1233 :                     goto Done;
; 1234 :             }
; 1235 :             assert(Zreplacement != NULL);
; 1236 :             assert(PyUnicode_Check(Zreplacement));
; 1237 :             ptoappend = _PyUnicode_AsStringAndSize(Zreplacement,
; 1238 :                                                   &ntoappend);

  001c6	48 8d 54 24 38	 lea	 rdx, QWORD PTR ntoappend$[rsp]
  001cb	49 8b ce	 mov	 rcx, r14
  001ce	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  001d3	48 8b f8	 mov	 rdi, rax

; 1239 :             if (ptoappend == NULL)

  001d6	48 85 c0	 test	 rax, rax
  001d9	0f 84 80 01 00
	00		 je	 $Done$21130

; 1240 :                 goto Done;
; 1241 :         }
; 1242 :         else if (ch == 'f') {

  001df	4c 8b 44 24 38	 mov	 r8, QWORD PTR ntoappend$[rsp]
  001e4	eb 2a		 jmp	 SHORT $LN25@wrap_strft
$LN33@wrap_strft:
  001e6	3c 66		 cmp	 al, 102			; 00000066H
  001e8	75 3b		 jne	 SHORT $LN28@wrap_strft

; 1243 :             /* format microseconds */
; 1244 :             if (freplacement == NULL) {

  001ea	48 85 ed	 test	 rbp, rbp
  001ed	75 14		 jne	 SHORT $LN26@wrap_strft

; 1245 :                 freplacement = make_freplacement(object);

  001ef	48 8b cf	 mov	 rcx, rdi
  001f2	e8 00 00 00 00	 call	 make_freplacement
  001f7	48 8b e8	 mov	 rbp, rax

; 1246 :                 if (freplacement == NULL)

  001fa	48 85 c0	 test	 rax, rax
  001fd	0f 84 c6 01 00
	00		 je	 $LN15@wrap_strft
$LN26@wrap_strft:

; 1247 :                     goto Done;
; 1248 :             }
; 1249 :             assert(freplacement != NULL);
; 1250 :             assert(PyBytes_Check(freplacement));
; 1251 :             ptoappend = PyBytes_AS_STRING(freplacement);
; 1252 :             ntoappend = PyBytes_GET_SIZE(freplacement);

  00203	4c 8b 45 60	 mov	 r8, QWORD PTR [rbp+96]
  00207	48 8d 7d 78	 lea	 rdi, QWORD PTR [rbp+120]
$LN118@wrap_strft:
  0020b	4c 89 44 24 38	 mov	 QWORD PTR ntoappend$[rsp], r8
$LN25@wrap_strft:

; 1258 :         }
; 1259 : 
; 1260 :         /* Append the ntoappend chars starting at ptoappend to
; 1261 :          * the new format.
; 1262 :          */
; 1263 :         if (ntoappend == 0)

  00210	4d 85 c0	 test	 r8, r8
  00213	0f 84 80 00 00
	00		 je	 $LN110@wrap_strft
  00219	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH
  00223	eb 0f		 jmp	 SHORT $LN111@wrap_strft
$LN28@wrap_strft:

; 1186 :     usednew = 0;
; 1187 : 
; 1188 :     while ((ch = *pin++) != '\0') {

  00225	49 8d 7d fe	 lea	 rdi, QWORD PTR [r13-2]

; 1253 :         }
; 1254 :         else {
; 1255 :             /* percent followed by neither z nor Z */
; 1256 :             ptoappend = pin - 2;
; 1257 :             ntoappend = 2;

  00229	41 b8 02 00 00
	00		 mov	 r8d, 2
$LN117@wrap_strft:
  0022f	4c 89 44 24 38	 mov	 QWORD PTR ntoappend$[rsp], r8
$LN111@wrap_strft:

; 1264 :             continue;
; 1265 :         assert(ptoappend != NULL);
; 1266 :         assert(ntoappend > 0);
; 1267 :         while (usednew + ntoappend > totalnew) {

  00234	4b 8d 04 38	 lea	 rax, QWORD PTR [r8+r15]
  00238	48 3b c3	 cmp	 rax, rbx
  0023b	76 46		 jbe	 SHORT $LN22@wrap_strft
  0023d	0f 1f 00	 npad	 3
$LL23@wrap_strft:

; 1268 :             if (totalnew > (PY_SSIZE_T_MAX >> 1)) { /* overflow */

  00240	48 3b d9	 cmp	 rbx, rcx
  00243	77 6a		 ja	 SHORT $LN99@wrap_strft

; 1271 :             }
; 1272 :             totalnew <<= 1;

  00245	48 03 db	 add	 rbx, rbx

; 1273 :             if (_PyBytes_Resize(&newfmt, totalnew) < 0)

  00248	48 8d 4c 24 40	 lea	 rcx, QWORD PTR newfmt$[rsp]
  0024d	48 8b d3	 mov	 rdx, rbx
  00250	e8 00 00 00 00	 call	 _PyBytes_Resize
  00255	85 c0		 test	 eax, eax
  00257	0f 88 02 01 00
	00		 js	 $Done$21130

; 1274 :                 goto Done;
; 1275 :             pnew = PyBytes_AsString(newfmt) + usednew;

  0025d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newfmt$[rsp]
  00262	e8 00 00 00 00	 call	 PyBytes_AsString
  00267	4c 8b 44 24 38	 mov	 r8, QWORD PTR ntoappend$[rsp]
  0026c	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH
  00276	49 8d 34 07	 lea	 rsi, QWORD PTR [r15+rax]
  0027a	4b 8d 04 38	 lea	 rax, QWORD PTR [r8+r15]
  0027e	48 3b c3	 cmp	 rax, rbx
  00281	77 bd		 ja	 SHORT $LL23@wrap_strft
$LN22@wrap_strft:

; 1276 :         }
; 1277 :         memcpy(pnew, ptoappend, ntoappend);

  00283	48 8b d7	 mov	 rdx, rdi
  00286	48 8b ce	 mov	 rcx, rsi
  00289	e8 00 00 00 00	 call	 memcpy

; 1278 :         pnew += ntoappend;

  0028e	48 8b 54 24 38	 mov	 rdx, QWORD PTR ntoappend$[rsp]
  00293	48 03 f2	 add	 rsi, rdx

; 1279 :         usednew += ntoappend;

  00296	4c 03 fa	 add	 r15, rdx
$LN110@wrap_strft:

; 1186 :     usednew = 0;
; 1187 : 
; 1188 :     while ((ch = *pin++) != '\0') {

  00299	41 0f b6 45 00	 movzx	 eax, BYTE PTR [r13]
  0029e	84 c0		 test	 al, al
  002a0	74 2f		 je	 SHORT $LN109@wrap_strft
  002a2	48 8b bc 24 00
	01 00 00	 mov	 rdi, QWORD PTR object$[rsp]
  002aa	e9 0f fe ff ff	 jmp	 $LN119@wrap_strft
$LN99@wrap_strft:

; 1269 :                 PyErr_NoMemory();

  002af	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1270 :                 goto Done;

  002b4	e9 a6 00 00 00	 jmp	 $Done$21130
$LN101@wrap_strft:

; 1194 :             /* There's a lone trailing %; doesn't make sense. */
; 1195 :             PyErr_SetString(PyExc_ValueError, "strftime format "
; 1196 :                             "ends with raw %");

  002b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@
  002c7	e8 00 00 00 00	 call	 PyErr_SetString

; 1197 :             goto Done;

  002cc	e9 8e 00 00 00	 jmp	 $Done$21130
$LN109@wrap_strft:

; 1280 :         assert(usednew <= totalnew);
; 1281 :     }  /* end while() */
; 1282 : 
; 1283 :     if (_PyBytes_Resize(&newfmt, usednew) < 0)

  002d1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR newfmt$[rsp]
  002d6	49 8b d7	 mov	 rdx, r15
  002d9	e8 00 00 00 00	 call	 _PyBytes_Resize
  002de	85 c0		 test	 eax, eax
  002e0	78 7d		 js	 SHORT $Done$21130

; 1284 :         goto Done;
; 1285 :     {
; 1286 :         PyObject *format;
; 1287 :         PyObject *time = PyImport_ImportModuleNoBlock("time");

  002e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  002e9	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  002ee	48 8b f8	 mov	 rdi, rax

; 1288 : 
; 1289 :         if (time == NULL)

  002f1	48 85 c0	 test	 rax, rax
  002f4	74 69		 je	 SHORT $Done$21130

; 1290 :             goto Done;
; 1291 :         format = PyUnicode_FromString(PyBytes_AS_STRING(newfmt));

  002f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newfmt$[rsp]
  002fb	48 83 c1 78	 add	 rcx, 120		; 00000078H
  002ff	e8 00 00 00 00	 call	 PyUnicode_FromString
  00304	48 8b d8	 mov	 rbx, rax

; 1292 :         if (format != NULL) {

  00307	48 85 c0	 test	 rax, rax
  0030a	74 4b		 je	 SHORT $LN17@wrap_strft

; 1293 :             _Py_IDENTIFIER(strftime);
; 1294 : 
; 1295 :             result = _PyObject_CallMethodId(time, &PyId_strftime, "OO",
; 1296 :                                             format, timetuple, NULL);

  0030c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00312	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0031b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_strftime@?BC@??wrap_strftime@@9@9
  00320	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00324	33 c0		 xor	 eax, eax
  00326	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MJJLPNK@OO?$AA@
  0032d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00332	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR timetuple$[rsp]
  0033a	4c 8b cb	 mov	 r9, rbx
  0033d	48 8b cf	 mov	 rcx, rdi
  00340	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00345	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 1297 :             Py_DECREF(format);

  0034a	48 8b cb	 mov	 rcx, rbx
  0034d	48 89 44 24 30	 mov	 QWORD PTR result$1$[rsp], rax
  00352	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@wrap_strft:

; 1298 :         }
; 1299 :         Py_DECREF(time);

  00357	48 8b cf	 mov	 rcx, rdi
  0035a	e8 00 00 00 00	 call	 _Py_DecRef
$Done$21130:

; 1300 :     }
; 1301 :  Done:
; 1302 :     Py_XDECREF(freplacement);

  0035f	48 85 ed	 test	 rbp, rbp
  00362	74 65		 je	 SHORT $LN15@wrap_strft
  00364	e8 00 00 00 00	 call	 _Py_PXCTX
  00369	85 c0		 test	 eax, eax
  0036b	75 5c		 jne	 SHORT $LN15@wrap_strft
  0036d	48 8b 45 20	 mov	 rax, QWORD PTR [rbp+32]
  00371	a8 20		 test	 al, 32			; 00000020H
  00373	75 4c		 jne	 SHORT $LN56@wrap_strft
  00375	84 c0		 test	 al, al
  00377	78 48		 js	 SHORT $LN56@wrap_strft
  00379	a8 02		 test	 al, 2
  0037b	75 4c		 jne	 SHORT $LN15@wrap_strft
  0037d	48 ff 4d 50	 dec	 QWORD PTR [rbp+80]
  00381	75 46		 jne	 SHORT $LN15@wrap_strft
  00383	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00391	4c 8b cd	 mov	 r9, rbp
  00394	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0039a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  003a2	e8 00 00 00 00	 call	 _PyParallel_Guard
  003a7	48 8b cd	 mov	 rcx, rbp
  003aa	85 c0		 test	 eax, eax
  003ac	74 07		 je	 SHORT $LN61@wrap_strft
  003ae	e8 00 00 00 00	 call	 _Px_Dealloc
  003b3	eb 14		 jmp	 SHORT $LN15@wrap_strft
$LN61@wrap_strft:
  003b5	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  003b9	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  003bf	eb 08		 jmp	 SHORT $LN15@wrap_strft
$LN56@wrap_strft:
  003c1	48 8b cd	 mov	 rcx, rbp
  003c4	e8 00 00 00 00	 call	 Px_DecRef
$LN15@wrap_strft:

; 1303 :     Py_XDECREF(zreplacement);

  003c9	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR [rsp+192]
  003d1	4d 85 e4	 test	 r12, r12
  003d4	74 68		 je	 SHORT $LN11@wrap_strft
  003d6	e8 00 00 00 00	 call	 _Py_PXCTX
  003db	85 c0		 test	 eax, eax
  003dd	75 5f		 jne	 SHORT $LN11@wrap_strft
  003df	49 8b 44 24 20	 mov	 rax, QWORD PTR [r12+32]
  003e4	a8 20		 test	 al, 32			; 00000020H
  003e6	75 4e		 jne	 SHORT $LN67@wrap_strft
  003e8	84 c0		 test	 al, al
  003ea	78 4a		 js	 SHORT $LN67@wrap_strft
  003ec	a8 02		 test	 al, 2
  003ee	75 4e		 jne	 SHORT $LN11@wrap_strft
  003f0	49 ff 4c 24 50	 dec	 QWORD PTR [r12+80]
  003f5	75 47		 jne	 SHORT $LN11@wrap_strft
  003f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  003fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00405	4d 8b cc	 mov	 r9, r12
  00408	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0040e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00416	e8 00 00 00 00	 call	 _PyParallel_Guard
  0041b	49 8b cc	 mov	 rcx, r12
  0041e	85 c0		 test	 eax, eax
  00420	74 07		 je	 SHORT $LN72@wrap_strft
  00422	e8 00 00 00 00	 call	 _Px_Dealloc
  00427	eb 15		 jmp	 SHORT $LN11@wrap_strft
$LN72@wrap_strft:
  00429	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0042e	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00434	eb 08		 jmp	 SHORT $LN11@wrap_strft
$LN67@wrap_strft:
  00436	49 8b cc	 mov	 rcx, r12
  00439	e8 00 00 00 00	 call	 Px_DecRef
$LN11@wrap_strft:

; 1304 :     Py_XDECREF(Zreplacement);

  0043e	4d 85 f6	 test	 r14, r14
  00441	74 65		 je	 SHORT $LN116@wrap_strft
  00443	e8 00 00 00 00	 call	 _Py_PXCTX
  00448	85 c0		 test	 eax, eax
  0044a	75 5c		 jne	 SHORT $LN116@wrap_strft
  0044c	49 8b 46 20	 mov	 rax, QWORD PTR [r14+32]
  00450	a8 20		 test	 al, 32			; 00000020H
  00452	75 4c		 jne	 SHORT $LN78@wrap_strft
  00454	84 c0		 test	 al, al
  00456	78 48		 js	 SHORT $LN78@wrap_strft
  00458	a8 02		 test	 al, 2
  0045a	75 4c		 jne	 SHORT $LN116@wrap_strft
  0045c	49 ff 4e 50	 dec	 QWORD PTR [r14+80]
  00460	75 46		 jne	 SHORT $LN116@wrap_strft
  00462	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00470	4d 8b ce	 mov	 r9, r14
  00473	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00479	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00481	e8 00 00 00 00	 call	 _PyParallel_Guard
  00486	49 8b ce	 mov	 rcx, r14
  00489	85 c0		 test	 eax, eax
  0048b	74 07		 je	 SHORT $LN83@wrap_strft
  0048d	e8 00 00 00 00	 call	 _Px_Dealloc
  00492	eb 14		 jmp	 SHORT $LN116@wrap_strft
$LN83@wrap_strft:
  00494	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00498	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0049e	eb 08		 jmp	 SHORT $LN116@wrap_strft
$LN78@wrap_strft:
  004a0	49 8b ce	 mov	 rcx, r14
  004a3	e8 00 00 00 00	 call	 Px_DecRef
$LN116@wrap_strft:
  004a8	4c 8b 7c 24 30	 mov	 r15, QWORD PTR result$1$[rsp]
$LN7@wrap_strft:

; 1305 :     Py_XDECREF(newfmt);

  004ad	48 8b 7c 24 40	 mov	 rdi, QWORD PTR newfmt$[rsp]
  004b2	48 85 ff	 test	 rdi, rdi
  004b5	74 65		 je	 SHORT $LN3@wrap_strft
  004b7	e8 00 00 00 00	 call	 _Py_PXCTX
  004bc	85 c0		 test	 eax, eax
  004be	75 5c		 jne	 SHORT $LN3@wrap_strft
  004c0	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  004c4	a8 20		 test	 al, 32			; 00000020H
  004c6	75 4c		 jne	 SHORT $LN89@wrap_strft
  004c8	84 c0		 test	 al, al
  004ca	78 48		 js	 SHORT $LN89@wrap_strft
  004cc	a8 02		 test	 al, 2
  004ce	75 4c		 jne	 SHORT $LN3@wrap_strft
  004d0	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  004d4	75 46		 jne	 SHORT $LN3@wrap_strft
  004d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  004e4	4c 8b cf	 mov	 r9, rdi
  004e7	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  004ed	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004f5	e8 00 00 00 00	 call	 _PyParallel_Guard
  004fa	48 8b cf	 mov	 rcx, rdi
  004fd	85 c0		 test	 eax, eax
  004ff	74 07		 je	 SHORT $LN94@wrap_strft
  00501	e8 00 00 00 00	 call	 _Px_Dealloc
  00506	eb 14		 jmp	 SHORT $LN3@wrap_strft
$LN94@wrap_strft:
  00508	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  0050c	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  00512	eb 08		 jmp	 SHORT $LN3@wrap_strft
$LN89@wrap_strft:
  00514	48 8b cf	 mov	 rcx, rdi
  00517	e8 00 00 00 00	 call	 Px_DecRef
$LN3@wrap_strft:

; 1306 :     return result;

  0051c	49 8b c7	 mov	 rax, r15
  0051f	48 8b 9c 24 08
	01 00 00	 mov	 rbx, QWORD PTR [rsp+264]

; 1307 : }

  00527	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0052e	41 5f		 pop	 r15
  00530	41 5e		 pop	 r14
  00532	41 5d		 pop	 r13
  00534	41 5c		 pop	 r12
  00536	5f		 pop	 rdi
  00537	5d		 pop	 rbp
  00538	c3		 ret	 0
wrap_strftime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_hash DD imagerel delta_hash
	DD	imagerel delta_hash+16
	DD	imagerel $unwind$delta_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$delta_hash DD imagerel delta_hash+16
	DD	imagerel delta_hash+69
	DD	imagerel $chain$0$delta_hash
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$delta_hash DD imagerel delta_hash+69
	DD	imagerel delta_hash+79
	DD	imagerel $chain$1$delta_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$delta_hash DD 021H
	DD	imagerel delta_hash
	DD	imagerel delta_hash+16
	DD	imagerel $unwind$delta_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$delta_hash DD 020521H
	DD	067405H
	DD	imagerel delta_hash
	DD	imagerel delta_hash+16
	DD	imagerel $unwind$delta_hash
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_hash DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT delta_hash
_TEXT	SEGMENT
self$ = 48
delta_hash PROC						; COMDAT

; 1835 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1836 :     if (self->hashcode == -1) {

  00006	48 83 79 60 ff	 cmp	 QWORD PTR [rcx+96], -1
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	75 35		 jne	 SHORT $LN6@delta_hash

; 1837 :         PyObject *temp = delta_getstate(self);

  00010	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00015	e8 00 00 00 00	 call	 delta_getstate
  0001a	48 8b f8	 mov	 rdi, rax

; 1838 :         if (temp != NULL) {

  0001d	48 85 c0	 test	 rax, rax
  00020	74 14		 je	 SHORT $LN5@delta_hash

; 1839 :             self->hashcode = PyObject_Hash(temp);

  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 PyObject_Hash

; 1840 :             Py_DECREF(temp);

  0002a	48 8b cf	 mov	 rcx, rdi
  0002d	48 89 43 60	 mov	 QWORD PTR [rbx+96], rax
  00031	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@delta_hash:

; 1841 :         }
; 1842 :     }
; 1843 :     return self->hashcode;

  00036	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  0003a	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 1844 : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
$LN6@delta_hash:

; 1841 :         }
; 1842 :     }
; 1843 :     return self->hashcode;

  00045	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]

; 1844 : }

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
delta_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LENHFJKM@U?3strftime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_strftime DD imagerel date_strftime
	DD	imagerel date_strftime+96
	DD	imagerel $unwind$date_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$date_strftime DD imagerel date_strftime+96
	DD	imagerel date_strftime+125
	DD	imagerel $chain$0$date_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$date_strftime DD imagerel date_strftime+125
	DD	imagerel date_strftime+169
	DD	imagerel $chain$2$date_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$date_strftime DD 020021H
	DD	087400H
	DD	imagerel date_strftime
	DD	imagerel date_strftime+96
	DD	imagerel $unwind$date_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$date_strftime DD 020521H
	DD	087405H
	DD	imagerel date_strftime
	DD	imagerel date_strftime+96
	DD	imagerel $unwind$date_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_strftime DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@LENHFJKM@U?3strftime?$AA@
CONST	SEGMENT
??_C@_0L@LENHFJKM@U?3strftime?$AA@ DB 'U:strftime', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT date_strftime
_TEXT	SEGMENT
self$ = 64
args$ = 72
kw$ = 80
format$ = 88
date_strftime PROC					; COMDAT

; 2647 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 2648 :     /* This method can be inherited, and needs to call the
; 2649 :      * timetuple() method appropriate to self's class.
; 2650 :      */
; 2651 :     PyObject *result;
; 2652 :     PyObject *tuple;
; 2653 :     PyObject *format;
; 2654 :     _Py_IDENTIFIER(timetuple);
; 2655 :     static char *keywords[] = {"format", NULL};
; 2656 : 
; 2657 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "U:strftime", keywords,
; 2658 :                                       &format))

  0000f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR format$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??date_strftime@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LENHFJKM@U?3strftime?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	49 8b ca	 mov	 rcx, r10
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN2@date_strft

; 2659 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 2668 : }

  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN2@date_strft:

; 2660 : 
; 2661 :     tuple = _PyObject_CallMethodId((PyObject *)self, &PyId_timetuple, "()");

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00044	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0004d	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_timetuple@?1??date_strftime@@9@9
  00052	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  00056	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0005d	48 8b cb	 mov	 rcx, rbx
  00060	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  00065	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0006a	48 8b f8	 mov	 rdi, rax

; 2662 :     if (tuple == NULL)

  0006d	48 85 c0	 test	 rax, rax
  00070	75 0b		 jne	 SHORT $LN1@date_strft
  00072	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2668 : }

  00077	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
$LN1@date_strft:

; 2663 :         return NULL;
; 2664 :     result = wrap_strftime((PyObject *)self, format, tuple,
; 2665 :                            (PyObject *)self);

  0007d	48 8b 54 24 58	 mov	 rdx, QWORD PTR format$[rsp]
  00082	4c 8b cb	 mov	 r9, rbx
  00085	4c 8b c0	 mov	 r8, rax
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 wrap_strftime

; 2666 :     Py_DECREF(tuple);

  00090	48 8b cf	 mov	 rcx, rdi
  00093	48 8b d8	 mov	 rbx, rax
  00096	e8 00 00 00 00	 call	 _Py_DecRef
  0009b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2667 :     return result;

  000a0	48 8b c3	 mov	 rax, rbx

; 2668 : }

  000a3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
date_strftime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@ ; `string'
PUBLIC	??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@ ; `string'
PUBLIC	??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@ ; `string'
PUBLIC	??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@ ; `string'
PUBLIC	??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_fromutc DD imagerel tzinfo_fromutc
	DD	imagerel tzinfo_fromutc+81
	DD	imagerel $unwind$tzinfo_fromutc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$tzinfo_fromutc DD imagerel tzinfo_fromutc+81
	DD	imagerel tzinfo_fromutc+230
	DD	imagerel $chain$0$tzinfo_fromutc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$tzinfo_fromutc DD imagerel tzinfo_fromutc+230
	DD	imagerel tzinfo_fromutc+249
	DD	imagerel $chain$1$tzinfo_fromutc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$tzinfo_fromutc DD imagerel tzinfo_fromutc+249
	DD	imagerel tzinfo_fromutc+473
	DD	imagerel $chain$2$tzinfo_fromutc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$tzinfo_fromutc DD 020021H
	DD	08d400H
	DD	imagerel tzinfo_fromutc
	DD	imagerel tzinfo_fromutc+81
	DD	imagerel $unwind$tzinfo_fromutc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$tzinfo_fromutc DD 021H
	DD	imagerel tzinfo_fromutc
	DD	imagerel tzinfo_fromutc+81
	DD	imagerel $unwind$tzinfo_fromutc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$tzinfo_fromutc DD 020521H
	DD	08d405H
	DD	imagerel tzinfo_fromutc
	DD	imagerel tzinfo_fromutc+81
	DD	imagerel $unwind$tzinfo_fromutc
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_fromutc DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0c00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@
CONST	SEGMENT
??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@ DB 'fromut'
	DB	'c: tz.dst() gaveinconsistent results; cannot convert', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@
CONST	SEGMENT
??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@ DB 'fromu'
	DB	'tc: non-None dst() result required', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@
CONST	SEGMENT
??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@ DB 'fromu'
	DB	'tc: non-None utcoffset() result required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
CONST	SEGMENT
??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@ DB 'fromutc:'
	DB	' dt.tzinfo is not self', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@
CONST	SEGMENT
??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@ DB 'fromutc: a'
	DB	'rgument must be a datetime', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT tzinfo_fromutc
_TEXT	SEGMENT
self$ = 64
dt$ = 72
tzinfo_fromutc PROC					; COMDAT

; 2987 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2988 :     PyObject *result = NULL;

  00012	33 f6		 xor	 esi, esi
  00014	4c 8b e1	 mov	 r12, rcx

; 2989 :     PyObject *off = NULL, *dst = NULL;
; 2990 :     PyDateTime_Delta *delta = NULL;
; 2991 : 
; 2992 :     if (!PyDateTime_Check(dt)) {

  00017	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00025	8b fe		 mov	 edi, esi
  00027	8b ee		 mov	 ebp, esi
  00029	48 3b ca	 cmp	 rcx, rdx
  0002c	74 23		 je	 SHORT $LN28@tzinfo_fro
  0002e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00033	85 c0		 test	 eax, eax
  00035	75 1a		 jne	 SHORT $LN28@tzinfo_fro

; 2993 :         PyErr_SetString(PyExc_TypeError,
; 2994 :                         "fromutc: argument must be a datetime");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 2995 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 95 00 00 00	 jmp	 $LN29@tzinfo_fro
$LN28@tzinfo_fro:
  00051	4c 89 6c 24 40	 mov	 QWORD PTR [rsp+64], r13

; 2996 :     }
; 2997 :     if (GET_DT_TZINFO(dt) != (PyObject *)self) {

  00056	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:_Py_NoneStruct
  0005d	40 38 73 68	 cmp	 BYTE PTR [rbx+104], sil
  00061	74 06		 je	 SHORT $LN31@tzinfo_fro
  00063	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00067	eb 03		 jmp	 SHORT $LN32@tzinfo_fro
$LN31@tzinfo_fro:
  00069	49 8b c5	 mov	 rax, r13
$LN32@tzinfo_fro:
  0006c	49 3b c4	 cmp	 rax, r12
  0006f	74 15		 je	 SHORT $LN27@tzinfo_fro

; 2998 :         PyErr_SetString(PyExc_ValueError, "fromutc: dt.tzinfo "
; 2999 :                         "is not self");

  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 3000 :         return NULL;

  00084	eb 59		 jmp	 SHORT $LN3@tzinfo_fro
$LN27@tzinfo_fro:

; 3001 :     }
; 3002 : 
; 3003 :     off = datetime_utcoffset(dt, NULL);

  00086	33 d2		 xor	 edx, edx
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 datetime_utcoffset
  00090	4c 8b e0	 mov	 r12, rax

; 3004 :     if (off == NULL)

  00093	48 85 c0	 test	 rax, rax

; 3005 :         return NULL;

  00096	74 47		 je	 SHORT $LN3@tzinfo_fro

; 3006 :     if (off == Py_None) {

  00098	49 3b c5	 cmp	 rax, r13
  0009b	75 5c		 jne	 SHORT $LN25@tzinfo_fro

; 3007 :         PyErr_SetString(PyExc_ValueError, "fromutc: non-None "
; 3008 :                         "utcoffset() result required");

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@
$LN36@tzinfo_fro:

; 3016 :         PyErr_SetString(PyExc_ValueError, "fromutc: non-None "
; 3017 :                         "dst() result required");

  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ab	e8 00 00 00 00	 call	 PyErr_SetString
$Fail$22683:

; 3050 : 
; 3051 :     /* fall thru to failure */
; 3052 : Fail:
; 3053 :     Py_XDECREF(off);

  000b0	49 8b cc	 mov	 rcx, r12
  000b3	e8 00 00 00 00	 call	 _Py_DecRef

; 3054 :     Py_XDECREF(dst);

  000b8	48 85 ff	 test	 rdi, rdi
  000bb	74 08		 je	 SHORT $LN11@tzinfo_fro
  000bd	48 8b cf	 mov	 rcx, rdi
  000c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@tzinfo_fro:

; 3055 :     Py_XDECREF(delta);

  000c5	48 85 ed	 test	 rbp, rbp
  000c8	74 08		 je	 SHORT $LN7@tzinfo_fro
  000ca	48 8b cd	 mov	 rcx, rbp
  000cd	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@tzinfo_fro:

; 3056 :     Py_XDECREF(result);

  000d2	48 85 f6	 test	 rsi, rsi
  000d5	74 08		 je	 SHORT $LN3@tzinfo_fro
  000d7	48 8b ce	 mov	 rcx, rsi
  000da	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@tzinfo_fro:

; 3057 :     return NULL;

  000df	33 c0		 xor	 eax, eax
$LN35@tzinfo_fro:
  000e1	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
$LN29@tzinfo_fro:

; 3058 : }

  000e6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000eb	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	41 5c		 pop	 r12
  000f6	5f		 pop	 rdi
  000f7	5e		 pop	 rsi
  000f8	c3		 ret	 0
$LN25@tzinfo_fro:

; 3009 :         goto Fail;
; 3010 :     }
; 3011 : 
; 3012 :     dst = datetime_dst(dt, NULL);

  000f9	33 d2		 xor	 edx, edx
  000fb	48 8b cb	 mov	 rcx, rbx
  000fe	e8 00 00 00 00	 call	 datetime_dst
  00103	48 8b f8	 mov	 rdi, rax

; 3013 :     if (dst == NULL)

  00106	48 85 c0	 test	 rax, rax
  00109	74 a5		 je	 SHORT $Fail$22683

; 3014 :         goto Fail;
; 3015 :     if (dst == Py_None) {

  0010b	49 3b c5	 cmp	 rax, r13
  0010e	75 09		 jne	 SHORT $LN23@tzinfo_fro

; 3016 :         PyErr_SetString(PyExc_ValueError, "fromutc: non-None "
; 3017 :                         "dst() result required");

  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@

; 3018 :         goto Fail;

  00117	eb 8b		 jmp	 SHORT $LN36@tzinfo_fro
$LN23@tzinfo_fro:

; 3019 :     }
; 3020 : 
; 3021 :     delta = (PyDateTime_Delta *)delta_subtract(off, dst);

  00119	48 8b d0	 mov	 rdx, rax
  0011c	49 8b cc	 mov	 rcx, r12
  0011f	e8 00 00 00 00	 call	 delta_subtract
  00124	48 8b e8	 mov	 rbp, rax

; 3022 :     if (delta == NULL)

  00127	48 85 c0	 test	 rax, rax
  0012a	74 84		 je	 SHORT $Fail$22683

; 3023 :         goto Fail;
; 3024 :     result = add_datetime_timedelta((PyDateTime_DateTime *)dt, delta, 1);

  0012c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00132	48 8b d0	 mov	 rdx, rax
  00135	48 8b cb	 mov	 rcx, rbx
  00138	e8 00 00 00 00	 call	 add_datetime_timedelta
  0013d	48 8b f0	 mov	 rsi, rax

; 3025 :     if (result == NULL)

  00140	48 85 c0	 test	 rax, rax
  00143	0f 84 67 ff ff
	ff		 je	 $Fail$22683

; 3026 :         goto Fail;
; 3027 : 
; 3028 :     Py_DECREF(dst);

  00149	48 8b cf	 mov	 rcx, rdi
  0014c	e8 00 00 00 00	 call	 _Py_DecRef

; 3029 :     dst = call_dst(GET_DT_TZINFO(dt), result);

  00151	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00155	74 06		 je	 SHORT $LN33@tzinfo_fro
  00157	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0015b	eb 03		 jmp	 SHORT $LN34@tzinfo_fro
$LN33@tzinfo_fro:
  0015d	49 8b cd	 mov	 rcx, r13
$LN34@tzinfo_fro:
  00160	48 8b d6	 mov	 rdx, rsi
  00163	e8 00 00 00 00	 call	 call_dst
  00168	48 8b f8	 mov	 rdi, rax

; 3030 :     if (dst == NULL)

  0016b	48 85 c0	 test	 rax, rax
  0016e	0f 84 3c ff ff
	ff		 je	 $Fail$22683

; 3031 :         goto Fail;
; 3032 :     if (dst == Py_None)

  00174	49 3b c5	 cmp	 rax, r13
  00177	75 0c		 jne	 SHORT $LN19@tzinfo_fro
$Inconsistent$22701:

; 3046 : 
; 3047 : Inconsistent:
; 3048 :     PyErr_SetString(PyExc_ValueError, "fromutc: tz.dst() gave"
; 3049 :                     "inconsistent results; cannot convert");

  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@
  00180	e9 1f ff ff ff	 jmp	 $LN36@tzinfo_fro
$LN19@tzinfo_fro:

; 3033 :         goto Inconsistent;
; 3034 :     if (delta_bool(delta) != 0) {

  00185	48 8b cd	 mov	 rcx, rbp
  00188	e8 00 00 00 00	 call	 delta_bool
  0018d	85 c0		 test	 eax, eax
  0018f	74 28		 je	 SHORT $LN17@tzinfo_fro

; 3035 :         PyObject *temp = result;
; 3036 :         result = add_datetime_timedelta((PyDateTime_DateTime *)result,
; 3037 :                                         (PyDateTime_Delta *)dst, 1);

  00191	41 b8 01 00 00
	00		 mov	 r8d, 1
  00197	48 8b d7	 mov	 rdx, rdi
  0019a	48 8b ce	 mov	 rcx, rsi
  0019d	48 8b de	 mov	 rbx, rsi
  001a0	e8 00 00 00 00	 call	 add_datetime_timedelta

; 3038 :         Py_DECREF(temp);

  001a5	48 8b cb	 mov	 rcx, rbx
  001a8	48 8b f0	 mov	 rsi, rax
  001ab	e8 00 00 00 00	 call	 _Py_DecRef

; 3039 :         if (result == NULL)

  001b0	48 85 f6	 test	 rsi, rsi
  001b3	0f 84 f7 fe ff
	ff		 je	 $Fail$22683
$LN17@tzinfo_fro:

; 3040 :             goto Fail;
; 3041 :     }
; 3042 :     Py_DECREF(delta);

  001b9	48 8b cd	 mov	 rcx, rbp
  001bc	e8 00 00 00 00	 call	 _Py_DecRef

; 3043 :     Py_DECREF(dst);

  001c1	48 8b cf	 mov	 rcx, rdi
  001c4	e8 00 00 00 00	 call	 _Py_DecRef

; 3044 :     Py_DECREF(off);

  001c9	49 8b cc	 mov	 rcx, r12
  001cc	e8 00 00 00 00	 call	 _Py_DecRef

; 3045 :     return result;

  001d1	48 8b c6	 mov	 rax, rsi
  001d4	e9 08 ff ff ff	 jmp	 $LN35@tzinfo_fro
tzinfo_fromutc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@	; `string'
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_new DD imagerel timezone_new
	DD	imagerel timezone_new+115
	DD	imagerel $unwind$timezone_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_new DD 010701H
	DD	0a207H
xdata	ENDS
;	COMDAT ??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@
CONST	SEGMENT
??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@ DB 'O!|O!:timezone', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT timezone_new
_TEXT	SEGMENT
offset$ = 64
type$ = 96
args$ = 104
kw$ = 112
name$ = 120
timezone_new PROC					; COMDAT

; 3192 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3193 :     PyObject *offset;
; 3194 :     PyObject *name = NULL;
; 3195 :     if (PyArg_ParseTupleAndKeywords(args, kw, "O!|O!:timezone", timezone_kws,
; 3196 :                                     &PyDateTime_DeltaType, &offset,
; 3197 :                                     &PyUnicode_Type, &name))

  00007	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000b	49 8b c0	 mov	 rax, r8
  0000e	4c 8b d2	 mov	 r10, rdx
  00011	49 89 4b e0	 mov	 QWORD PTR [r11-32], rcx
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyUnicode_Type
  0001c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:timezone_kws
  00023	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00027	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0002b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@
  00032	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DeltaType
  0003d	48 8b d0	 mov	 rdx, rax
  00040	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00044	49 8b ca	 mov	 rcx, r10
  00047	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  0004f	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00054	85 c0		 test	 eax, eax
  00056	74 14		 je	 SHORT $LN1@timezone_n

; 3198 :         return new_timezone(offset, name);

  00058	48 8b 54 24 78	 mov	 rdx, QWORD PTR name$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  00062	e8 00 00 00 00	 call	 new_timezone

; 3201 : }

  00067	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006b	c3		 ret	 0
$LN1@timezone_n:

; 3199 : 
; 3200 :     return NULL;

  0006c	33 c0		 xor	 eax, eax

; 3201 : }

  0006e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00072	c3		 ret	 0
timezone_new ENDP
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT timezone_hash
_TEXT	SEGMENT
self$ = 8
timezone_hash PROC					; COMDAT

; 3229 :     return delta_hash((PyDateTime_Delta *)self->offset);

  00000	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]

; 3230 : }

  00004	e9 00 00 00 00	 jmp	 delta_hash
timezone_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_fromutc DD imagerel timezone_fromutc
	DD	imagerel timezone_fromutc+145
	DD	imagerel $unwind$timezone_fromutc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_fromutc DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT timezone_fromutc
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_fromutc PROC					; COMDAT

; 3327 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx

; 3328 :     if (!PyDateTime_Check(dt)) {

  0000d	48 8b 4a 58	 mov	 rcx, QWORD PTR [rdx+88]
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	74 29		 je	 SHORT $LN3@timezone_f
  00020	e8 00 00 00 00	 call	 PyType_IsSubtype
  00025	85 c0		 test	 eax, eax
  00027	75 20		 jne	 SHORT $LN3@timezone_f

; 3329 :         PyErr_SetString(PyExc_TypeError,
; 3330 :                         "fromutc: argument must be a datetime");

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@

; 3334 :         PyErr_SetString(PyExc_ValueError, "fromutc: dt.tzinfo "
; 3335 :                         "is not self");

  00037	e8 00 00 00 00	 call	 PyErr_SetString

; 3336 :         return NULL;

  0003c	33 c0		 xor	 eax, eax

; 3340 : }

  0003e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN3@timezone_f:

; 3331 :         return NULL;
; 3332 :     }
; 3333 :     if (!HASTZINFO(dt) || dt->tzinfo != (PyObject *)self) {

  00049	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  0004d	74 22		 je	 SHORT $LN1@timezone_f
  0004f	48 39 7b 78	 cmp	 QWORD PTR [rbx+120], rdi
  00053	75 1c		 jne	 SHORT $LN1@timezone_f

; 3337 :     }
; 3338 : 
; 3339 :     return add_datetime_timedelta(dt, (PyDateTime_Delta *)self->offset, 1);

  00055	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  00059	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005f	48 8b cb	 mov	 rcx, rbx

; 3340 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	e9 00 00 00 00	 jmp	 add_datetime_timedelta
$LN1@timezone_f:

; 3334 :         PyErr_SetString(PyExc_ValueError, "fromutc: dt.tzinfo "
; 3335 :                         "is not self");

  00071	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 3340 : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	33 c0		 xor	 eax, eax
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
timezone_fromutc ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
EXTRN	PyUnicode_AppendAndDel:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_isoformat DD imagerel time_isoformat
	DD	imagerel time_isoformat+213
	DD	imagerel $unwind$time_isoformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_isoformat DD 030901H
	DD	0140109H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%02d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%02d:%02d:'
	DB	'%02d.%06d', 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_isoformat
_TEXT	SEGMENT
buf$ = 48
result$ = 176
self$ = 176
unused$ = 184
time_isoformat PROC					; COMDAT

; 3598 : {

  00000	40 53		 push	 rbx
  00002	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00009	48 8b d9	 mov	 rbx, rcx

; 3599 :     char buf[100];
; 3600 :     PyObject *result;
; 3601 :     int us = TIME_GET_MICROSECOND(self);

  0000c	0f b6 49 6c	 movzx	 ecx, BYTE PTR [rcx+108]
  00010	0f b6 43 6d	 movzx	 eax, BYTE PTR [rbx+109]

; 3602 : 
; 3603 :     if (us)
; 3604 :         result = PyUnicode_FromFormat("%02d:%02d:%02d.%06d",
; 3605 :                                       TIME_GET_HOUR(self),
; 3606 :                                       TIME_GET_MINUTE(self),
; 3607 :                                       TIME_GET_SECOND(self),
; 3608 :                                       us);

  00014	44 0f b6 4b 6b	 movzx	 r9d, BYTE PTR [rbx+107]
  00019	44 0f b6 43 6a	 movzx	 r8d, BYTE PTR [rbx+106]
  0001e	0f b6 53 69	 movzx	 edx, BYTE PTR [rbx+105]
  00022	c1 e1 08	 shl	 ecx, 8
  00025	0b c8		 or	 ecx, eax
  00027	0f b6 43 6e	 movzx	 eax, BYTE PTR [rbx+110]
  0002b	c1 e1 08	 shl	 ecx, 8
  0002e	0b c8		 or	 ecx, eax
  00030	74 12		 je	 SHORT $LN5@time_isofo
  00032	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  0003d	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 3609 :     else

  00042	eb 0c		 jmp	 SHORT $LN8@time_isofo
$LN5@time_isofo:

; 3610 :         result = PyUnicode_FromFormat("%02d:%02d:%02d",
; 3611 :                                       TIME_GET_HOUR(self),
; 3612 :                                       TIME_GET_MINUTE(self),
; 3613 :                                       TIME_GET_SECOND(self));

  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
  0004b	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN8@time_isofo:
  00050	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 3614 : 
; 3615 :     if (result == NULL || !HASTZINFO(self) || self->tzinfo == Py_None)

  00058	48 85 c0	 test	 rax, rax
  0005b	74 6f		 je	 SHORT $LN2@time_isofo
  0005d	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00061	74 69		 je	 SHORT $LN2@time_isofo
  00063	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0006e	4c 3b c9	 cmp	 r9, rcx
  00071	74 59		 je	 SHORT $LN2@time_isofo

; 3616 :         return result;
; 3617 : 
; 3618 :     /* We need to append the UTC offset. */
; 3619 :     if (format_utcoffset(buf, sizeof(buf), ":", self->tzinfo,
; 3620 :                          Py_None) < 0) {

  00073	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00078	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  0007f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  00084	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00089	e8 00 00 00 00	 call	 format_utcoffset
  0008e	85 c0		 test	 eax, eax
  00090	79 18		 jns	 SHORT $LN1@time_isofo

; 3621 :         Py_DECREF(result);

  00092	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0009a	e8 00 00 00 00	 call	 _Py_DecRef

; 3622 :         return NULL;

  0009f	33 c0		 xor	 eax, eax

; 3626 : }

  000a1	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  000a8	5b		 pop	 rbx
  000a9	c3		 ret	 0
$LN1@time_isofo:

; 3623 :     }
; 3624 :     PyUnicode_AppendAndDel(&result, PyUnicode_FromString(buf));

  000aa	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000af	e8 00 00 00 00	 call	 PyUnicode_FromString
  000b4	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  000bc	48 8b d0	 mov	 rdx, rax
  000bf	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 3625 :     return result;

  000c4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN2@time_isofo:

; 3626 : }

  000cc	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  000d3	5b		 pop	 rbx
  000d4	c3		 ret	 0
time_isoformat ENDP
_TEXT	ENDS
PUBLIC	??_C@_09BOADOOAM@iiiiiiiii?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_strftime DD imagerel time_strftime
	DD	imagerel time_strftime+132
	DD	imagerel $unwind$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$time_strftime DD imagerel time_strftime+132
	DD	imagerel time_strftime+161
	DD	imagerel $chain$0$time_strftime
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$time_strftime DD imagerel time_strftime+161
	DD	imagerel time_strftime+209
	DD	imagerel $chain$2$time_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$time_strftime DD 020021H
	DD	0c7400H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+132
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$time_strftime DD 020521H
	DD	0c7405H
	DD	imagerel time_strftime
	DD	imagerel time_strftime+132
	DD	imagerel $unwind$time_strftime
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_strftime DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT ??_C@_09BOADOOAM@iiiiiiiii?$AA@
CONST	SEGMENT
??_C@_09BOADOOAM@iiiiiiiii?$AA@ DB 'iiiiiiiii', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT time_strftime
_TEXT	SEGMENT
self$ = 96
args$ = 104
kw$ = 112
format$ = 120
time_strftime PROC					; COMDAT

; 3630 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 3631 :     PyObject *result;
; 3632 :     PyObject *tuple;
; 3633 :     PyObject *format;
; 3634 :     static char *keywords[] = {"format", NULL};
; 3635 : 
; 3636 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "U:strftime", keywords,
; 3637 :                                       &format))

  0000f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR format$[rsp]
  00014	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??time_strftime@@9@9
  0001b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LENHFJKM@U?3strftime?$AA@
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	49 8b ca	 mov	 rcx, r10
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN2@time_strft

; 3638 :         return NULL;

  00036	33 c0		 xor	 eax, eax

; 3657 : }

  00038	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$LN2@time_strft:

; 3639 : 
; 3640 :     /* Python's strftime does insane things with the year part of the
; 3641 :      * timetuple.  The year is forced to (the otherwise nonsensical)
; 3642 :      * 1900 to work around that.
; 3643 :      */
; 3644 :     tuple = Py_BuildValue("iiiiiiiii",
; 3645 :                           1900, 1, 1, /* year, month, day */
; 3646 :                   TIME_GET_HOUR(self),
; 3647 :                   TIME_GET_MINUTE(self),
; 3648 :                   TIME_GET_SECOND(self),
; 3649 :                   0, 1, -1); /* weekday, daynum, dst */

  0003e	0f b6 4b 6a	 movzx	 ecx, BYTE PTR [rbx+106]
  00042	0f b6 53 69	 movzx	 edx, BYTE PTR [rbx+105]
  00046	0f b6 43 6b	 movzx	 eax, BYTE PTR [rbx+107]
  0004a	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR [rsp+72], -1
  00052	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR [rsp+64], 1
  0005a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00063	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00067	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0006b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00071	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09BOADOOAM@iiiiiiiii?$AA@
  0007c	ba 6c 07 00 00	 mov	 edx, 1900		; 0000076cH
  00081	45 8b c1	 mov	 r8d, r9d
  00084	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00089	e8 00 00 00 00	 call	 Py_BuildValue
  0008e	48 8b f8	 mov	 rdi, rax

; 3650 :     if (tuple == NULL)

  00091	48 85 c0	 test	 rax, rax
  00094	75 0b		 jne	 SHORT $LN1@time_strft
  00096	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 3657 : }

  0009b	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
$LN1@time_strft:

; 3651 :         return NULL;
; 3652 :     assert(PyTuple_Size(tuple) == 9);
; 3653 :     result = wrap_strftime((PyObject *)self, format, tuple,
; 3654 :                            Py_None);

  000a1	48 8b 54 24 78	 mov	 rdx, QWORD PTR format$[rsp]
  000a6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000ad	4c 8b c0	 mov	 r8, rax
  000b0	48 8b cb	 mov	 rcx, rbx
  000b3	e8 00 00 00 00	 call	 wrap_strftime

; 3655 :     Py_DECREF(tuple);

  000b8	48 8b cf	 mov	 rcx, rdi
  000bb	48 8b d8	 mov	 rbx, rax
  000be	e8 00 00 00 00	 call	 _Py_DecRef
  000c3	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 3656 :     return result;

  000c8	48 8b c3	 mov	 rax, rbx

; 3657 : }

  000cb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000cf	5b		 pop	 rbx
  000d0	c3		 ret	 0
time_strftime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ ; `string'
PUBLIC	??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_isoformat DD imagerel datetime_isoformat
	DD	imagerel datetime_isoformat+352
	DD	imagerel $unwind$datetime_isoformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_isoformat DD 050d01H
	DD	01b340dH
	DD	018010dH
	DD	07006H
xdata	ENDS
;	COMDAT ??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%'
	DB	'04d-%02d-%02d%c%02d:%02d:%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
CONST	SEGMENT
??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ DB '%'
	DB	'04d-%02d-%02d%c%02d:%02d:%02d.%06d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@
CONST	SEGMENT
??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@ DB '|C:isoformat', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_isoformat
_TEXT	SEGMENT
buffer$ = 80
sep$ = 208
self$ = 208
args$ = 216
kw$ = 224
result$ = 232
datetime_isoformat PROC					; COMDAT

; 4492 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 4493 :     int sep = 'T';
; 4494 :     static char *keywords[] = {"sep", NULL};
; 4495 :     char buffer[100];
; 4496 :     PyObject *result;
; 4497 :     int us = DATE_GET_MICROSECOND(self);

  0000d	0f b6 41 71	 movzx	 eax, BYTE PTR [rcx+113]
  00011	0f b6 79 70	 movzx	 edi, BYTE PTR [rcx+112]
  00015	4d 8b d0	 mov	 r10, r8
  00018	c1 e7 08	 shl	 edi, 8
  0001b	4c 8b da	 mov	 r11, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	0b f8		 or	 edi, eax
  00023	0f b6 41 72	 movzx	 eax, BYTE PTR [rcx+114]

; 4498 : 
; 4499 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|C:isoformat", keywords, &sep))

  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_isoformat@@9@9
  0002e	c1 e7 08	 shl	 edi, 8
  00031	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@
  00038	49 8b d2	 mov	 rdx, r10
  0003b	0b f8		 or	 edi, eax
  0003d	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR sep$[rsp]
  00045	49 8b cb	 mov	 rcx, r11
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	c7 84 24 d0 00
	00 00 54 00 00
	00		 mov	 DWORD PTR sep$[rsp], 84	; 00000054H
  00058	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0005d	85 c0		 test	 eax, eax

; 4500 :         return NULL;

  0005f	0f 84 b5 00 00
	00		 je	 $LN10@datetime_i

; 4501 :     if (us)
; 4502 :         result = PyUnicode_FromFormat("%04d-%02d-%02d%c%02d:%02d:%02d.%06d",
; 4503 :                                       GET_YEAR(self), GET_MONTH(self),
; 4504 :                                       GET_DAY(self), (int)sep,
; 4505 :                                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4506 :                                       DATE_GET_SECOND(self), us);

  00065	0f b6 43 6a	 movzx	 eax, BYTE PTR [rbx+106]
  00069	0f b6 53 69	 movzx	 edx, BYTE PTR [rbx+105]
  0006d	0f b6 4b 6f	 movzx	 ecx, BYTE PTR [rbx+111]
  00071	44 0f b6 53 6e	 movzx	 r10d, BYTE PTR [rbx+110]
  00076	44 0f b6 5b 6d	 movzx	 r11d, BYTE PTR [rbx+109]
  0007b	44 0f b6 4b 6c	 movzx	 r9d, BYTE PTR [rbx+108]
  00080	44 0f b6 43 6b	 movzx	 r8d, BYTE PTR [rbx+107]
  00085	c1 e2 08	 shl	 edx, 8
  00088	0b d0		 or	 edx, eax
  0008a	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR sep$[rsp]
  00091	85 ff		 test	 edi, edi
  00093	74 24		 je	 SHORT $LN5@datetime_i
  00095	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00099	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0009d	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  000a2	44 89 5c 24 28	 mov	 DWORD PTR [rsp+40], r11d
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
  000ae	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b2	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 4507 :     else

  000b7	eb 1e		 jmp	 SHORT $LN9@datetime_i
$LN5@datetime_i:

; 4508 :         result = PyUnicode_FromFormat("%04d-%02d-%02d%c%02d:%02d:%02d",
; 4509 :                                       GET_YEAR(self), GET_MONTH(self),
; 4510 :                                       GET_DAY(self), (int)sep,
; 4511 :                                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4512 :                                       DATE_GET_SECOND(self));

  000b9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000bd	44 89 54 24 30	 mov	 DWORD PTR [rsp+48], r10d
  000c2	44 89 5c 24 28	 mov	 DWORD PTR [rsp+40], r11d
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@
  000ce	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d2	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN9@datetime_i:
  000d7	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 4513 : 
; 4514 :     if (!result || !HASTZINFO(self))

  000df	48 85 c0	 test	 rax, rax
  000e2	74 6b		 je	 SHORT $LN2@datetime_i
  000e4	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  000e8	74 65		 je	 SHORT $LN2@datetime_i

; 4515 :         return result;
; 4516 : 
; 4517 :     /* We need to append the UTC offset. */
; 4518 :     if (format_utcoffset(buffer, sizeof(buffer), ":", self->tzinfo,
; 4519 :                          (PyObject *)self) < 0) {

  000ea	4c 8b 4b 78	 mov	 r9, QWORD PTR [rbx+120]
  000ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  000f5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buffer$[rsp]
  000fa	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000ff	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00104	e8 00 00 00 00	 call	 format_utcoffset
  00109	85 c0		 test	 eax, eax
  0010b	79 20		 jns	 SHORT $LN1@datetime_i

; 4520 :         Py_DECREF(result);

  0010d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00115	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@datetime_i:

; 4521 :         return NULL;

  0011a	33 c0		 xor	 eax, eax

; 4525 : }

  0011c	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+216]
  00124	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
$LN1@datetime_i:

; 4522 :     }
; 4523 :     PyUnicode_AppendAndDel(&result, PyUnicode_FromString(buffer));

  0012d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buffer$[rsp]
  00132	e8 00 00 00 00	 call	 PyUnicode_FromString
  00137	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  0013f	48 8b d0	 mov	 rdx, rax
  00142	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 4524 :     return result;

  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN2@datetime_i:

; 4525 : }

  0014f	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+216]
  00157	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0015e	5f		 pop	 rdi
  0015f	c3		 ret	 0
datetime_isoformat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_tzname:BYTE
EXTRN	__imp_daylight:DWORD
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$local_timezone DD imagerel local_timezone
	DD	imagerel local_timezone+496
	DD	imagerel $unwind$local_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_timezone DD 0a5d01H
	DD	010645dH
	DD	0e5455H
	DD	011340eH
	DD	0d00a920eH
	DD	07006c008H
xdata	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\modules\_datetimemodule.c
CONST	ENDS
;	COMDAT local_timezone
_TEXT	SEGMENT
utc_time$ = 112
timestamp$ = 120
local_timezone PROC					; COMDAT

; 4697 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	41 54		 push	 r12
  00008	41 55		 push	 r13
  0000a	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4698 :     PyObject *result = NULL;
; 4699 :     struct tm *timep;
; 4700 :     time_t timestamp;
; 4701 :     PyObject *delta;
; 4702 :     PyObject *one_second;
; 4703 :     PyObject *seconds;
; 4704 :     PyObject *nameo = NULL;
; 4705 :     const char *zone = NULL;
; 4706 : 
; 4707 :     delta = datetime_subtract((PyObject *)utc_time, PyDateTime_Epoch);

  0000e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyDateTime_Epoch
  00015	45 33 e4	 xor	 r12d, r12d
  00018	4c 8b e9	 mov	 r13, rcx
  0001b	41 8b fc	 mov	 edi, r12d
  0001e	e8 00 00 00 00	 call	 datetime_subtract
  00023	48 8b d8	 mov	 rbx, rax

; 4708 :     if (delta == NULL)

  00026	48 85 c0	 test	 rax, rax
  00029	75 12		 jne	 SHORT $LN9@local_time

; 4756 : }

  0002b	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00033	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00037	41 5d		 pop	 r13
  00039	41 5c		 pop	 r12
  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
$LN9@local_time:

; 4709 :         return NULL;
; 4710 :     one_second = new_delta(0, 1, 0, 0);

  0003d	45 33 c9	 xor	 r9d, r9d
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0004e	33 c9		 xor	 ecx, ecx
  00050	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00055	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rsi
  0005d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00062	e8 00 00 00 00	 call	 new_delta_ex
  00067	48 8b f0	 mov	 rsi, rax

; 4711 :     if (one_second == NULL)

  0006a	48 85 c0	 test	 rax, rax
  0006d	0f 84 53 01 00
	00		 je	 $error$24206

; 4712 :         goto error;
; 4713 :     seconds = divide_timedelta_timedelta((PyDateTime_Delta *)delta,
; 4714 :                                          (PyDateTime_Delta *)one_second);

  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 divide_timedelta_timedelta

; 4715 :     Py_DECREF(one_second);

  0007e	48 8b ce	 mov	 rcx, rsi
  00081	48 8b e8	 mov	 rbp, rax
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 4716 :     if (seconds == NULL)

  00089	48 85 ed	 test	 rbp, rbp
  0008c	0f 84 34 01 00
	00		 je	 $error$24206

; 4717 :         goto error;
; 4718 :     Py_DECREF(delta);

  00092	48 8b cb	 mov	 rcx, rbx
  00095	e8 00 00 00 00	 call	 _Py_DecRef

; 4719 :     timestamp = PyLong_AsLong(seconds);

  0009a	48 8b cd	 mov	 rcx, rbp
  0009d	e8 00 00 00 00	 call	 PyLong_AsLong
  000a2	48 63 c8	 movsxd	 rcx, eax
  000a5	48 89 4c 24 78	 mov	 QWORD PTR timestamp$[rsp], rcx

; 4720 :     Py_DECREF(seconds);

  000aa	48 8b cd	 mov	 rcx, rbp
  000ad	e8 00 00 00 00	 call	 _Py_DecRef

; 4721 :     if (timestamp == -1 && PyErr_Occurred())

  000b2	48 83 7c 24 78
	ff		 cmp	 QWORD PTR timestamp$[rsp], -1
  000b8	75 11		 jne	 SHORT $LN6@local_time
  000ba	e8 00 00 00 00	 call	 PyErr_Occurred
  000bf	48 85 c0	 test	 rax, rax
  000c2	74 07		 je	 SHORT $LN6@local_time

; 4722 :         return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 06 01 00 00	 jmp	 $LN16@local_time
$LN6@local_time:

; 4723 :     timep = localtime(&timestamp);

  000cb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR timestamp$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 4724 : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 4725 :     zone = timep->tm_zone;
; 4726 :     delta = new_delta(0, timep->tm_gmtoff, 0, 1);
; 4727 : #else /* HAVE_STRUCT_TM_TM_ZONE */
; 4728 :     {
; 4729 :         PyObject *local_time;
; 4730 :         local_time = new_datetime(timep->tm_year + 1900, timep->tm_mon + 1,
; 4731 :                                   timep->tm_mday, timep->tm_hour, timep->tm_min,
; 4732 :                                   timep->tm_sec, DATE_GET_MICROSECOND(utc_time),
; 4733 :                                   utc_time->tzinfo);

  000d6	45 0f b6 45 70	 movzx	 r8d, BYTE PTR [r13+112]
  000db	48 8b f0	 mov	 rsi, rax
  000de	41 0f b6 45 71	 movzx	 eax, BYTE PTR [r13+113]
  000e3	41 c1 e0 08	 shl	 r8d, 8
  000e7	8b 56 10	 mov	 edx, DWORD PTR [rsi+16]
  000ea	8b 4e 14	 mov	 ecx, DWORD PTR [rsi+20]
  000ed	44 8b 4e 08	 mov	 r9d, DWORD PTR [rsi+8]
  000f1	44 0b c0	 or	 r8d, eax
  000f4	41 0f b6 45 72	 movzx	 eax, BYTE PTR [r13+114]
  000f9	ff c2		 inc	 edx
  000fb	41 c1 e0 08	 shl	 r8d, 8
  000ff	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  00105	44 0b c0	 or	 r8d, eax
  00108	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  0010f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00114	49 8b 45 78	 mov	 rax, QWORD PTR [r13+120]
  00118	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0011d	8b 06		 mov	 eax, DWORD PTR [rsi]
  0011f	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d
  00124	44 8b 46 0c	 mov	 r8d, DWORD PTR [rsi+12]
  00128	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012c	8b 46 04	 mov	 eax, DWORD PTR [rsi+4]
  0012f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00133	e8 00 00 00 00	 call	 new_datetime_ex
  00138	48 8b e8	 mov	 rbp, rax

; 4734 :         if (local_time == NULL)

  0013b	48 85 c0	 test	 rax, rax
  0013e	0f 84 82 00 00
	00		 je	 $error$24206

; 4735 :             goto error;
; 4736 :         delta = datetime_subtract(local_time, (PyObject*)utc_time);

  00144	49 8b d5	 mov	 rdx, r13
  00147	48 8b c8	 mov	 rcx, rax
  0014a	e8 00 00 00 00	 call	 datetime_subtract
  0014f	48 8b d8	 mov	 rbx, rax

; 4737 :         /* XXX: before relying on tzname, we should compare delta
; 4738 :            to the offset implied by timezone/altzone */
; 4739 :         if (daylight && timep->tm_isdst >= 0)

  00152	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_daylight
  00159	39 38		 cmp	 DWORD PTR [rax], edi
  0015b	74 25		 je	 SHORT $LN4@local_time
  0015d	8b 46 20	 mov	 eax, DWORD PTR [rsi+32]
  00160	85 c0		 test	 eax, eax
  00162	78 1e		 js	 SHORT $LN4@local_time

; 4740 :             zone = tzname[timep->tm_isdst % 2];

  00164	25 01 00 00 80	 and	 eax, -2147483647	; ffffffff80000001H
  00169	7d 07		 jge	 SHORT $LN14@local_time
  0016b	ff c8		 dec	 eax
  0016d	83 c8 fe	 or	 eax, -2
  00170	ff c0		 inc	 eax
$LN14@local_time:
  00172	48 63 c8	 movsxd	 rcx, eax
  00175	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_tzname
  0017c	48 8b 34 c8	 mov	 rsi, QWORD PTR [rax+rcx*8]

; 4741 :         else

  00180	eb 0a		 jmp	 SHORT $LN3@local_time
$LN4@local_time:

; 4742 :             zone = tzname[0];

  00182	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_tzname
  00189	48 8b 30	 mov	 rsi, QWORD PTR [rax]
$LN3@local_time:

; 4743 :         Py_DECREF(local_time);

  0018c	48 8b cd	 mov	 rcx, rbp
  0018f	e8 00 00 00 00	 call	 _Py_DecRef

; 4744 :     }
; 4745 : #endif /* HAVE_STRUCT_TM_TM_ZONE */
; 4746 :     if (zone != NULL) {

  00194	48 85 f6	 test	 rsi, rsi
  00197	74 17		 je	 SHORT $LN1@local_time

; 4747 :         nameo = PyUnicode_DecodeLocale(zone, "surrogateescape");

  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  001a0	48 8b ce	 mov	 rcx, rsi
  001a3	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale
  001a8	48 8b f8	 mov	 rdi, rax

; 4748 :         if (nameo == NULL)

  001ab	48 85 c0	 test	 rax, rax
  001ae	74 16		 je	 SHORT $error$24206
$LN1@local_time:

; 4749 :             goto error;
; 4750 :     }
; 4751 :     result = new_timezone(delta, nameo);

  001b0	48 8b d7	 mov	 rdx, rdi
  001b3	48 8b cb	 mov	 rcx, rbx
  001b6	e8 00 00 00 00	 call	 new_timezone

; 4752 :     Py_DECREF(nameo);

  001bb	48 8b cf	 mov	 rcx, rdi
  001be	4c 8b e0	 mov	 r12, rax
  001c1	e8 00 00 00 00	 call	 _Py_DecRef
$error$24206:

; 4753 :   error:
; 4754 :     Py_DECREF(delta);

  001c6	48 8b cb	 mov	 rcx, rbx
  001c9	e8 00 00 00 00	 call	 _Py_DecRef

; 4755 :     return result;

  001ce	49 8b c4	 mov	 rax, r12
$LN16@local_time:

; 4756 : }

  001d1	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  001d6	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001de	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  001e6	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ea	41 5d		 pop	 r13
  001ec	41 5c		 pop	 r12
  001ee	5f		 pop	 rdi
  001ef	c3		 ret	 0
local_timezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@ ; `string'
PUBLIC	??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_astimezone DD imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+102
	DD	imagerel $unwind$datetime_astimezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$datetime_astimezone DD imagerel datetime_astimezone+102
	DD	imagerel datetime_astimezone+152
	DD	imagerel $chain$0$datetime_astimezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$datetime_astimezone DD imagerel datetime_astimezone+152
	DD	imagerel datetime_astimezone+217
	DD	imagerel $chain$2$datetime_astimezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$datetime_astimezone DD imagerel datetime_astimezone+217
	DD	imagerel datetime_astimezone+316
	DD	imagerel $chain$5$datetime_astimezone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$datetime_astimezone DD imagerel datetime_astimezone+316
	DD	imagerel datetime_astimezone+399
	DD	imagerel $chain$7$datetime_astimezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$datetime_astimezone DD 040021H
	DD	097400H
	DD	086400H
	DD	imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+102
	DD	imagerel $unwind$datetime_astimezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$datetime_astimezone DD 040f21H
	DD	08640fH
	DD	097400H
	DD	imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+102
	DD	imagerel $unwind$datetime_astimezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$datetime_astimezone DD 020021H
	DD	097400H
	DD	imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+102
	DD	imagerel $unwind$datetime_astimezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$datetime_astimezone DD 020521H
	DD	097405H
	DD	imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+102
	DD	imagerel $unwind$datetime_astimezone
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_astimezone DD 040a01H
	DD	0a340aH
	DD	05006520aH
xdata	ENDS
;	COMDAT ??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@
CONST	SEGMENT
??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@ DB 'astime'
	DB	'zone() cannot be applied to a naive datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@
CONST	SEGMENT
??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@ DB '|O:astimezone', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT datetime_astimezone
_TEXT	SEGMENT
self$ = 64
args$ = 72
kw$ = 80
tzinfo$ = 88
datetime_astimezone PROC				; COMDAT

; 4760 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	49 8b c0	 mov	 rax, r8
  00010	4c 8b d2	 mov	 r10, rdx

; 4761 :     PyDateTime_DateTime *result;
; 4762 :     PyObject *offset;
; 4763 :     PyObject *temp;
; 4764 :     PyObject *tzinfo = Py_None;
; 4765 :     _Py_IDENTIFIER(fromutc);
; 4766 :     static char *keywords[] = {"tz", NULL};
; 4767 : 
; 4768 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|O:astimezone", keywords,
; 4769 : 				      &tzinfo))

  00013	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tzinfo$[rsp]
  00018	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:_Py_NoneStruct
  0001f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_astimezone@@9@9
  00026	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@
  00032	48 8b d0	 mov	 rdx, rax
  00035	49 8b ca	 mov	 rcx, r10
  00038	48 89 6c 24 58	 mov	 QWORD PTR tzinfo$[rsp], rbp
  0003d	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00042	85 c0		 test	 eax, eax
  00044	75 0d		 jne	 SHORT $LN11@datetime_a@3
$LN18@datetime_a@3:

; 4770 :         return NULL;

  00046	33 c0		 xor	 eax, eax

; 4823 : }

  00048	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5d		 pop	 rbp
  00052	c3		 ret	 0
$LN11@datetime_a@3:

; 4771 : 
; 4772 :     if (check_tzinfo_subclass(tzinfo) == -1)

  00053	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00058	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0005d	83 f8 ff	 cmp	 eax, -1

; 4773 :         return NULL;

  00060	74 e4		 je	 SHORT $LN18@datetime_a@3

; 4774 : 
; 4775 :     if (!HASTZINFO(self) || self->tzinfo == Py_None)

  00062	80 7b 68 00	 cmp	 BYTE PTR [rbx+104], 0
  00066	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0006b	74 47		 je	 SHORT $NeedAware$24258
  0006d	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]
  00071	48 3b c5	 cmp	 rax, rbp
  00074	74 3e		 je	 SHORT $NeedAware$24258

; 4776 :         goto NeedAware;
; 4777 : 
; 4778 :     /* Conversion to self's own time zone is a NOP. */
; 4779 :     if (self->tzinfo == tzinfo) {
; 4780 :         Py_INCREF(self);

  00076	48 8b cb	 mov	 rcx, rbx
  00079	48 3b 44 24 58	 cmp	 rax, QWORD PTR tzinfo$[rsp]
  0007e	75 18		 jne	 SHORT $LN7@datetime_a@3
  00080	e8 00 00 00 00	 call	 _Py_IncRef
  00085	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 4781 :         return self;

  0008a	48 8b c3	 mov	 rax, rbx

; 4823 : }

  0008d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00092	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00096	5d		 pop	 rbp
  00097	c3		 ret	 0
$LN7@datetime_a@3:

; 4782 :     }
; 4783 : 
; 4784 :     /* Convert self to UTC. */
; 4785 :     offset = datetime_utcoffset((PyObject *)self, NULL);

  00098	33 d2		 xor	 edx, edx
  0009a	e8 00 00 00 00	 call	 datetime_utcoffset
  0009f	48 8b f8	 mov	 rdi, rax

; 4786 :     if (offset == NULL)

  000a2	48 85 c0	 test	 rax, rax

; 4787 :         return NULL;

  000a5	74 20		 je	 SHORT $LN17@datetime_a@3

; 4788 :     if (offset == Py_None) {

  000a7	48 3b c5	 cmp	 rax, rbp
  000aa	75 2d		 jne	 SHORT $LN5@datetime_a@3

; 4789 :         Py_DECREF(offset);

  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 _Py_DecRef
$NeedAware$24258:

; 4790 :       NeedAware:
; 4791 :         PyErr_SetString(PyExc_ValueError, "astimezone() cannot be applied to "
; 4792 :                         "a naive datetime");

  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@
  000c2	e8 00 00 00 00	 call	 PyErr_SetString
$LN17@datetime_a@3:

; 4793 :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 4823 : }

  000ce	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d3	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d7	5d		 pop	 rbp
  000d8	c3		 ret	 0
$LN5@datetime_a@3:

; 4794 :     }
; 4795 : 
; 4796 :     /* result = self - offset */
; 4797 :     result = (PyDateTime_DateTime *)add_datetime_timedelta(self,
; 4798 :                                        (PyDateTime_Delta *)offset, -1);

  000d9	41 83 c8 ff	 or	 r8d, -1
  000dd	48 8b d0	 mov	 rdx, rax
  000e0	48 8b cb	 mov	 rcx, rbx
  000e3	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  000e8	e8 00 00 00 00	 call	 add_datetime_timedelta

; 4799 :     Py_DECREF(offset);

  000ed	48 8b cf	 mov	 rcx, rdi
  000f0	48 8b f0	 mov	 rsi, rax
  000f3	e8 00 00 00 00	 call	 _Py_DecRef

; 4800 :     if (result == NULL)

  000f8	48 85 f6	 test	 rsi, rsi

; 4801 :         return NULL;

  000fb	74 28		 je	 SHORT $LN16@datetime_a@3

; 4802 : 
; 4803 :     /* Attach new tzinfo and let fromutc() do the rest. */
; 4804 :     temp = result->tzinfo;
; 4805 :     if (tzinfo == Py_None) {

  000fd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00102	48 8b 5e 78	 mov	 rbx, QWORD PTR [rsi+120]
  00106	48 3b cd	 cmp	 rcx, rbp
  00109	75 31		 jne	 SHORT $LN3@datetime_a@3

; 4806 :         tzinfo = local_timezone(result);

  0010b	48 8b ce	 mov	 rcx, rsi
  0010e	e8 00 00 00 00	 call	 local_timezone
  00113	48 89 44 24 58	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4807 :         if (tzinfo == NULL) {

  00118	48 85 c0	 test	 rax, rax
  0011b	75 29		 jne	 SHORT $LN1@datetime_a@3

; 4808 :             Py_DECREF(result);

  0011d	48 8b ce	 mov	 rcx, rsi
  00120	e8 00 00 00 00	 call	 _Py_DecRef
$LN16@datetime_a@3:

; 4809 :             return NULL;

  00125	33 c0		 xor	 eax, eax
$LN15@datetime_a@3:
  00127	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 4823 : }

  00131	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00136	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0013a	5d		 pop	 rbp
  0013b	c3		 ret	 0
$LN3@datetime_a@3:

; 4810 :         }
; 4811 :     }
; 4812 :     else
; 4813 :       Py_INCREF(tzinfo);

  0013c	e8 00 00 00 00	 call	 _Py_IncRef
  00141	48 8b 44 24 58	 mov	 rax, QWORD PTR tzinfo$[rsp]
$LN1@datetime_a@3:

; 4814 :     result->tzinfo = tzinfo;
; 4815 :     Py_DECREF(temp);

  00146	48 8b cb	 mov	 rcx, rbx
  00149	48 89 46 78	 mov	 QWORD PTR [rsi+120], rax
  0014d	e8 00 00 00 00	 call	 _Py_DecRef

; 4816 : 
; 4817 :     temp = (PyObject *)result;
; 4818 :     result = (PyDateTime_DateTime *)
; 4819 :         _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", temp);

  00152	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00159	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00162	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00167	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_fromutc@?1??datetime_astimezone@@9@9
  0016c	4c 8b ce	 mov	 r9, rsi
  0016f	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  00173	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0017a	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 4820 :     Py_DECREF(temp);

  0017f	48 8b ce	 mov	 rcx, rsi
  00182	48 8b d8	 mov	 rbx, rax
  00185	e8 00 00 00 00	 call	 _Py_DecRef

; 4821 : 
; 4822 :     return result;

  0018a	48 8b c3	 mov	 rax, rbx
  0018d	eb 98		 jmp	 SHORT $LN15@datetime_a@3
datetime_astimezone ENDP
_TEXT	ENDS
END
