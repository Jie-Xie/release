; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
module_search_path DQ 01H DUP (?)
python3_checked DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?keyPrefix@?1??getpythonregpath@@9@9 DB 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, '\', 00H, 'P', 00H, 'y'
	DB	00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '\', 00H, 'P', 00H
	DB	'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, 'C', 00H, 'o'
	DB	00H, 'r', 00H, 'e', 00H, '\', 00H, 00H, 00H	; `getpythonregpath'::`2'::keyPrefix
?keySuffix@?1??getpythonregpath@@9@9 DB '\', 00H, 'P', 00H, 'y', 00H, 't', 00H
	DB	'h', 00H, 'o', 00H, 'n', 00H, 'P', 00H, 'a', 00H, 't', 00H, 'h'
	DB	00H, 00H, 00H				; `getpythonregpath'::`2'::keySuffix
CONST	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	Px_DecRef:PROC
EXTRN	_Px_Dealloc:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN12
	DD	imagerel $LN12+123
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 63		 jne	 SHORT $LN11@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00012	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00016	a8 20		 test	 al, 32			; 00000020H
  00018	75 53		 jne	 SHORT $LN5@Py_DecRef
  0001a	84 c0		 test	 al, al
  0001c	78 4f		 js	 SHORT $LN5@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  0001e	a8 02		 test	 al, 2
  00020	75 53		 jne	 SHORT $LN11@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;
; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00022	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  00026	75 4d		 jne	 SHORT $LN11@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  00036	4c 8b cb	 mov	 r9, rbx
  00039	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  0003f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00047	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN10@Py_DecRef

; 933  :         }
; 934  :     }
; 935  : }

  00053	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00057	5b		 pop	 rbx
  00058	e9 00 00 00 00	 jmp	 _Px_Dealloc
$LN10@Py_DecRef:

; 930  :                 _Py_CHECK_REFCNT(op);
; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  0005d	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]

; 933  :         }
; 934  :     }
; 935  : }

  00061	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00065	5b		 pop	 rbx
  00066	48 ff a0 88 00
	00 00		 rex_jmp QWORD PTR [rax+136]
$LN5@Py_DecRef:

; 926  :             Px_DECREF(op);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 Px_DecRef
$LN11@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\getpathp.c
_TEXT	ENDS
;	COMDAT is_sep
_TEXT	SEGMENT
ch$ = 8
is_sep	PROC						; COMDAT

; 103  : #ifdef ALTSEP
; 104  :     return ch == SEP || ch == ALTSEP;

  00000	66 83 f9 5c	 cmp	 cx, 92			; 0000005cH
  00004	74 09		 je	 SHORT $LN3@is_sep
  00006	66 83 f9 2f	 cmp	 cx, 47			; 0000002fH
  0000a	74 03		 je	 SHORT $LN3@is_sep
  0000c	33 c0		 xor	 eax, eax

; 105  : #else
; 106  :     return ch == SEP;
; 107  : #endif
; 108  : }

  0000e	c3		 ret	 0
$LN3@is_sep:

; 103  : #ifdef ALTSEP
; 104  :     return ch == SEP || ch == ALTSEP;

  0000f	b8 01 00 00 00	 mov	 eax, 1

; 105  : #else
; 106  :     return ch == SEP;
; 107  : #endif
; 108  : }

  00014	c3		 ret	 0
is_sep	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reduce DD imagerel reduce
	DD	imagerel reduce+75
	DD	imagerel $unwind$reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reduce DD 020601H
	DD	070023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT reduce
_TEXT	SEGMENT
dir$ = 48
reduce	PROC						; COMDAT

; 115  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4c 8b c1	 mov	 r8, rcx

; 116  :     size_t i = wcslen(dir);

  00009	48 83 c9 ff	 or	 rcx, -1
  0000d	33 c0		 xor	 eax, eax
  0000f	49 8b f8	 mov	 rdi, r8
  00012	66 f2 af	 repne scasw
  00015	48 f7 d1	 not	 rcx
  00018	48 ff c9	 dec	 rcx
  0001b	48 8b d1	 mov	 rdx, rcx

; 117  :     while (i > 0 && !is_sep(dir[i]))

  0001e	74 20		 je	 SHORT $LN7@reduce
$LL2@reduce:
  00020	41 0f b7 0c 50	 movzx	 ecx, WORD PTR [r8+rdx*2]
  00025	e8 00 00 00 00	 call	 is_sep
  0002a	85 c0		 test	 eax, eax
  0002c	75 05		 jne	 SHORT $LN8@reduce

; 118  :         --i;

  0002e	48 ff ca	 dec	 rdx

; 117  :     while (i > 0 && !is_sep(dir[i]))

  00031	75 ed		 jne	 SHORT $LL2@reduce
$LN8@reduce:

; 119  :     dir[i] = '\0';

  00033	33 c0		 xor	 eax, eax
  00035	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax

; 120  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
$LN7@reduce:

; 119  :     dir[i] = '\0';

  00040	66 41 89 04 48	 mov	 WORD PTR [r8+rcx*2], ax

; 120  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
reduce	ENDP
_TEXT	ENDS
EXTRN	__imp_GetFileAttributesW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$exists DD imagerel exists
	DD	imagerel exists+25
	DD	imagerel $unwind$exists
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exists DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT exists
_TEXT	SEGMENT
filename$ = 48
exists	PROC						; COMDAT

; 125  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 126  :     return GetFileAttributesW(filename) != 0xFFFFFFFF;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW
  0000a	33 c9		 xor	 ecx, ecx
  0000c	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  0000f	0f 95 c1	 setne	 cl
  00012	8b c1		 mov	 eax, ecx

; 127  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
exists	ENDP
_TEXT	ENDS
PUBLIC	??_C@_13PHCIHIAO@?$AAc?$AA?$AA@			; `string'
PUBLIC	??_C@_13LNPOMHLG@?$AAo?$AA?$AA@			; `string'
EXTRN	Py_OptimizeFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ismodule DD imagerel ismodule
	DD	imagerel ismodule+33
	DD	imagerel $unwind$ismodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$ismodule DD imagerel ismodule+33
	DD	imagerel ismodule+158
	DD	imagerel $chain$0$ismodule
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$ismodule DD imagerel ismodule+158
	DD	imagerel ismodule+171
	DD	imagerel $chain$2$ismodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$ismodule DD 020021H
	DD	067400H
	DD	imagerel ismodule
	DD	imagerel ismodule+33
	DD	imagerel $unwind$ismodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$ismodule DD 020521H
	DD	067405H
	DD	imagerel ismodule
	DD	imagerel ismodule+33
	DD	imagerel $unwind$ismodule
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ismodule DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_13PHCIHIAO@?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_13PHCIHIAO@?$AAc?$AA?$AA@ DB 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13LNPOMHLG@?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_13LNPOMHLG@?$AAo?$AA?$AA@ DB 'o', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ismodule
_TEXT	SEGMENT
filename$ = 48
ismodule PROC						; COMDAT

; 134  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 135  :     if (exists(filename))

  00009	e8 00 00 00 00	 call	 exists
  0000e	85 c0		 test	 eax, eax
  00010	74 0b		 je	 SHORT $LN3@ismodule

; 136  :         return 1;

  00012	b8 01 00 00 00	 mov	 eax, 1

; 145  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN3@ismodule:

; 137  : 
; 138  :     /* Check for the compiled version of prefix. */
; 139  :     if (wcslen(filename) < MAXPATHLEN) {

  0001d	48 83 c9 ff	 or	 rcx, -1
  00021	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00026	33 c0		 xor	 eax, eax
  00028	48 8b fb	 mov	 rdi, rbx
  0002b	66 f2 af	 repne scasw
  0002e	48 f7 d1	 not	 rcx
  00031	48 ff c9	 dec	 rcx
  00034	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  0003b	73 61		 jae	 SHORT $LN1@ismodule

; 140  :         wcscat(filename, Py_OptimizeFlag ? L"o" : L"c");

  0003d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_OptimizeFlag, 0
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13LNPOMHLG@?$AAo?$AA?$AA@
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13PHCIHIAO@?$AAc?$AA?$AA@
  00052	48 0f 45 d0	 cmovne	 rdx, rax
  00056	33 c0		 xor	 eax, eax
  00058	48 83 c9 ff	 or	 rcx, -1
  0005c	48 8b fb	 mov	 rdi, rbx
  0005f	66 f2 af	 repne scasw
  00062	33 c9		 xor	 ecx, ecx
  00064	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL6@ismodule:
  00070	0f b7 04 0a	 movzx	 eax, WORD PTR [rdx+rcx]
  00074	48 83 c1 02	 add	 rcx, 2
  00078	66 89 44 0f fc	 mov	 WORD PTR [rdi+rcx-4], ax
  0007d	66 85 c0	 test	 ax, ax
  00080	75 ee		 jne	 SHORT $LL6@ismodule

; 141  :         if (exists(filename))

  00082	48 8b cb	 mov	 rcx, rbx
  00085	e8 00 00 00 00	 call	 exists
  0008a	85 c0		 test	 eax, eax
  0008c	74 10		 je	 SHORT $LN1@ismodule

; 142  :             return 1;

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 145  : }

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5b		 pop	 rbx
  0009d	c3		 ret	 0
$LN1@ismodule:

; 143  :     }
; 144  :     return 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 145  : }

  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5b		 pop	 rbx
  000aa	c3		 ret	 0
ismodule ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@ ; `string'
EXTRN	__imp_wcsncpy:PROC
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$join DD	imagerel join
	DD	imagerel join+224
	DD	imagerel $unwind$join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join DD	0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@
CONST	SEGMENT
??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@ DB 'buffer ove'
	DB	'rflow in getpathp.c''s joinpath()', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT join
_TEXT	SEGMENT
buffer$ = 48
stuff$ = 56
join	PROC						; COMDAT

; 158  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b f1	 mov	 rsi, rcx

; 159  :     size_t n, k;
; 160  :     if (is_sep(stuff[0]))

  0001d	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00020	48 8b ea	 mov	 rbp, rdx
  00023	e8 00 00 00 00	 call	 is_sep
  00028	45 33 e4	 xor	 r12d, r12d
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN5@join

; 161  :         n = 0;

  0002f	41 8b dc	 mov	 ebx, r12d

; 162  :     else {

  00032	eb 50		 jmp	 SHORT $LN2@join
$LN5@join:

; 163  :         n = wcslen(buffer);

  00034	48 83 c9 ff	 or	 rcx, -1
  00038	33 c0		 xor	 eax, eax
  0003a	48 8b fe	 mov	 rdi, rsi
  0003d	66 f2 af	 repne scasw
  00040	48 f7 d1	 not	 rcx
  00043	48 ff c9	 dec	 rcx
  00046	48 8b d9	 mov	 rbx, rcx

; 164  :         if (n > 0 && !is_sep(buffer[n-1]) && n < MAXPATHLEN)

  00049	74 24		 je	 SHORT $LN3@join
  0004b	0f b7 4c 4e fe	 movzx	 ecx, WORD PTR [rsi+rcx*2-2]
  00050	e8 00 00 00 00	 call	 is_sep
  00055	85 c0		 test	 eax, eax
  00057	75 16		 jne	 SHORT $LN3@join
  00059	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
  00060	73 14		 jae	 SHORT $LN8@join

; 165  :             buffer[n++] = SEP;

  00062	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  00067	48 ff c3	 inc	 rbx
  0006a	66 89 44 5e fe	 mov	 WORD PTR [rsi+rbx*2-2], ax
$LN3@join:

; 166  :     }
; 167  :     if (n > MAXPATHLEN)

  0006f	48 81 fb 00 01
	00 00		 cmp	 rbx, 256		; 00000100H
$LN8@join:
  00076	76 0c		 jbe	 SHORT $LN2@join

; 168  :         Py_FatalError("buffer overflow in getpathp.c's joinpath()");

  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@
  0007f	e8 00 00 00 00	 call	 Py_FatalError
$LN2@join:

; 169  :     k = wcslen(stuff);

  00084	33 c0		 xor	 eax, eax
  00086	48 83 c9 ff	 or	 rcx, -1
  0008a	48 8b fd	 mov	 rdi, rbp
  0008d	66 f2 af	 repne scasw
  00090	48 f7 d1	 not	 rcx

; 170  :     if (n + k > MAXPATHLEN)

  00093	48 8d 44 19 ff	 lea	 rax, QWORD PTR [rcx+rbx-1]
  00098	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
  0009c	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000a2	76 08		 jbe	 SHORT $LN1@join

; 171  :         k = MAXPATHLEN - n;

  000a4	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
  000a9	48 2b fb	 sub	 rdi, rbx
$LN1@join:

; 172  :     wcsncpy(buffer+n, stuff, k);

  000ac	48 8d 0c 5e	 lea	 rcx, QWORD PTR [rsi+rbx*2]
  000b0	4c 8b c7	 mov	 r8, rdi
  000b3	48 8b d5	 mov	 rdx, rbp
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 173  :     buffer[n+k] = '\0';
; 174  : }

  000bc	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000c1	48 8d 14 1f	 lea	 rdx, QWORD PTR [rdi+rbx]
  000c5	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ca	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000cf	66 44 89 24 56	 mov	 WORD PTR [rsi+rdx*2], r12w
  000d4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dd	41 5c		 pop	 r12
  000df	c3		 ret	 0
join	ENDP
_TEXT	ENDS
_BSS	SEGMENT
prefix	DW	0101H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gotlandmark DD imagerel gotlandmark
	DD	imagerel gotlandmark+72
	DD	imagerel $unwind$gotlandmark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gotlandmark DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT gotlandmark
_TEXT	SEGMENT
landmark$ = 48
gotlandmark PROC					; COMDAT

; 182  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d1	 mov	 rdx, rcx

; 183  :     int ok;
; 184  :     Py_ssize_t n;
; 185  : 
; 186  :     n = wcslen(prefix);

  0000d	48 83 c9 ff	 or	 rcx, -1
  00011	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:prefix
  00018	33 c0		 xor	 eax, eax
  0001a	48 8b fb	 mov	 rdi, rbx
  0001d	66 f2 af	 repne scasw
  00020	48 f7 d1	 not	 rcx
  00023	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]

; 187  :     join(prefix, landmark);

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	e8 00 00 00 00	 call	 join

; 188  :     ok = ismodule(prefix);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 ismodule

; 189  :     prefix[n] = '\0';

  00037	33 c9		 xor	 ecx, ecx
  00039	66 89 0c 7b	 mov	 WORD PTR [rbx+rdi*2], cx

; 190  :     return ok;
; 191  : }

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
gotlandmark ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search_for_prefix DD imagerel search_for_prefix
	DD	imagerel search_for_prefix+103
	DD	imagerel $unwind$search_for_prefix
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search_for_prefix DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT search_for_prefix
_TEXT	SEGMENT
argv0_path$ = 48
landmark$ = 56
search_for_prefix PROC					; COMDAT

; 197  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 198  :     /* Search from argv0_path, until landmark is found */
; 199  :     wcscpy(prefix, argv0_path);

  00006	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:prefix
  0000d	48 8b da	 mov	 rbx, rdx
  00010	4c 2b c1	 sub	 r8, rcx
  00013	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@search_for:
  00020	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00023	48 83 c1 02	 add	 rcx, 2
  00027	66 41 89 44 08
	fe		 mov	 WORD PTR [r8+rcx-2], ax
  0002d	66 85 c0	 test	 ax, ax
  00030	75 ee		 jne	 SHORT $LL7@search_for
$LL4@search_for:

; 200  :     do {
; 201  :         if (gotlandmark(landmark))

  00032	48 8b cb	 mov	 rcx, rbx
  00035	e8 00 00 00 00	 call	 gotlandmark
  0003a	85 c0		 test	 eax, eax
  0003c	75 1e		 jne	 SHORT $LN11@search_for

; 203  :         reduce(prefix);

  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00045	e8 00 00 00 00	 call	 reduce

; 204  :     } while (prefix[0]);

  0004a	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR prefix, 0
  00052	75 de		 jne	 SHORT $LL4@search_for

; 205  :     return 0;

  00054	33 c0		 xor	 eax, eax

; 206  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN11@search_for:

; 202  :             return 1;

  0005c	b8 01 00 00 00	 mov	 eax, 1

; 206  : }

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
search_for_prefix ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
EXTRN	__imp_RegCloseKey:PROC
EXTRN	__imp_RegQueryValueExW:PROC
EXTRN	__imp_RegEnumKeyExW:PROC
EXTRN	__imp_RegQueryInfoKeyA:PROC
EXTRN	__imp_RegOpenKeyExW:PROC
EXTRN	__imp_mbstowcs:PROC
EXTRN	__imp_malloc:PROC
EXTRN	PyWin_DLLVersionString:QWORD
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$getpythonregpath DD imagerel getpythonregpath
	DD	imagerel getpythonregpath+1060
	DD	imagerel $unwind$getpythonregpath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getpythonregpath DD 0b2301H
	DD	05a3423H
	DD	0520123H
	DD	0e012f014H
	DD	0c00ed010H
	DD	0600b700cH
	DD	0500aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT getpythonregpath
_TEXT	SEGMENT
reqdSize$120407 = 96
newKey$ = 104
subKey$120406 = 112
keyBuf$1$ = 120
keyBuf$120405 = 128
keyBase$ = 720
skipcore$ = 728
dataSize$ = 736
numKeys$ = 744
getpythonregpath PROC					; COMDAT

; 230  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	55		 push	 rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 55		 push	 r13
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 8d ac 24 70
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-400]
  0001c	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H

; 231  :     HKEY newKey = 0;
; 232  :     DWORD dataSize = 0;
; 233  :     DWORD numKeys = 0;
; 234  :     LONG rc;
; 235  :     wchar_t *retval = NULL;
; 236  :     WCHAR *dataBuf = NULL;
; 237  :     static const WCHAR keyPrefix[] = L"Software\\Python\\PythonCore\\";
; 238  :     static const WCHAR keySuffix[] = L"\\PythonPath";
; 239  :     size_t versionLen;
; 240  :     DWORD index;
; 241  :     WCHAR *keyBuf = NULL;
; 242  :     WCHAR *keyBufPtr;
; 243  :     WCHAR **ppPaths = NULL;
; 244  : 
; 245  :     /* Tried to use sysget("winver") but here is too early :-( */
; 246  :     versionLen = strlen(PyWin_DLLVersionString);

  00023	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR PyWin_DLLVersionString
  0002a	4c 8b e1	 mov	 r12, rcx
  0002d	33 db		 xor	 ebx, ebx
  0002f	48 83 c9 ff	 or	 rcx, -1
  00033	33 c0		 xor	 eax, eax
  00035	48 89 5c 24 68	 mov	 QWORD PTR newKey$[rsp], rbx
  0003a	89 9d e0 01 00
	00		 mov	 DWORD PTR dataSize$[rbp-256], ebx
  00040	89 9d e8 01 00
	00		 mov	 DWORD PTR numKeys$[rbp-256], ebx
  00046	f2 ae		 repne scasb
  00048	48 f7 d1	 not	 rcx
  0004b	44 8b f2	 mov	 r14d, edx
  0004e	44 8b eb	 mov	 r13d, ebx
  00051	48 8d 71 ff	 lea	 rsi, QWORD PTR [rcx-1]

; 247  :     /* Space for all the chars, plus one \0 */
; 248  :     keyBuf = keyBufPtr = malloc(sizeof(keyPrefix) +
; 249  :                                 sizeof(WCHAR)*(versionLen-1) +
; 250  :                                 sizeof(keySuffix));

  00055	48 8d 4c 09 4c	 lea	 rcx, QWORD PTR [rcx+rcx+76]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00060	48 8b f8	 mov	 rdi, rax
  00063	4c 8b f8	 mov	 r15, rax
  00066	48 89 44 24 78	 mov	 QWORD PTR keyBuf$1$[rsp], rax

; 251  :     if (keyBuf==NULL) goto done;

  0006b	48 85 c0	 test	 rax, rax
  0006e	0f 84 92 03 00
	00		 je	 $LN40@getpythonr

; 252  : 
; 253  :     memcpy(keyBufPtr, keyPrefix, sizeof(keyPrefix)-sizeof(WCHAR));

  00074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9

; 254  :     keyBufPtr += Py_ARRAY_LENGTH(keyPrefix) - 1;
; 255  :     mbstowcs(keyBufPtr, PyWin_DLLVersionString, versionLen);

  0007b	49 8d 4f 36	 lea	 rcx, QWORD PTR [r15+54]
  0007f	4c 8b c6	 mov	 r8, rsi
  00082	49 89 07	 mov	 QWORD PTR [r15], rax
  00085	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+8
  0008c	49 89 47 08	 mov	 QWORD PTR [r15+8], rax
  00090	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+16
  00097	49 89 47 10	 mov	 QWORD PTR [r15+16], rax
  0009b	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+24
  000a2	49 89 47 18	 mov	 QWORD PTR [r15+24], rax
  000a6	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+32
  000ad	49 89 47 20	 mov	 QWORD PTR [r15+32], rax
  000b1	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+40
  000b8	49 89 47 28	 mov	 QWORD PTR [r15+40], rax
  000bc	8b 05 30 00 00
	00		 mov	 eax, DWORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+48
  000c2	41 89 47 30	 mov	 DWORD PTR [r15+48], eax
  000c6	0f b7 05 34 00
	00 00		 movzx	 eax, WORD PTR ?keyPrefix@?1??getpythonregpath@@9@9+52
  000cd	66 41 89 47 34	 mov	 WORD PTR [r15+52], ax
  000d2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyWin_DLLVersionString
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs

; 256  :     keyBufPtr += versionLen;
; 257  :     /* NULL comes with this one! */
; 258  :     memcpy(keyBufPtr, keySuffix, sizeof(keySuffix));

  000df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?keySuffix@?1??getpythonregpath@@9@9

; 259  :     /* Open the root Python key */
; 260  :     rc=RegOpenKeyExW(keyBase,
; 261  :                     keyBuf, /* subkey */
; 262  :             0, /* reserved */
; 263  :             KEY_READ,
; 264  :             &newKey);

  000e6	41 b9 19 00 02
	00		 mov	 r9d, 131097		; 00020019H
  000ec	49 89 44 77 36	 mov	 QWORD PTR [r15+rsi*2+54], rax
  000f1	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ?keySuffix@?1??getpythonregpath@@9@9+8
  000f8	45 33 c0	 xor	 r8d, r8d
  000fb	49 89 44 77 3e	 mov	 QWORD PTR [r15+rsi*2+62], rax
  00100	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?keySuffix@?1??getpythonregpath@@9@9+16
  00107	49 8b d7	 mov	 rdx, r15
  0010a	49 89 44 77 46	 mov	 QWORD PTR [r15+rsi*2+70], rax
  0010f	48 8d 44 24 68	 lea	 rax, QWORD PTR newKey$[rsp]
  00114	49 8b cc	 mov	 rcx, r12
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExW

; 265  :     if (rc!=ERROR_SUCCESS) goto done;

  00122	85 c0		 test	 eax, eax
  00124	0f 85 c3 02 00
	00		 jne	 $LN7@getpythonr

; 266  :     /* Find out how big our core buffer is, and how many subkeys we have */
; 267  :     rc = RegQueryInfoKey(newKey, NULL, NULL, NULL, &numKeys, NULL, NULL,
; 268  :                     NULL, NULL, &dataSize, NULL, NULL);

  0012a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newKey$[rsp]
  0012f	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  00134	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00139	48 8d 85 e0 01
	00 00		 lea	 rax, QWORD PTR dataSize$[rbp-256]
  00140	45 33 c9	 xor	 r9d, r9d
  00143	45 33 c0	 xor	 r8d, r8d
  00146	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0014b	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00150	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00155	48 8d 85 e8 01
	00 00		 lea	 rax, QWORD PTR numKeys$[rbp-256]
  0015c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00161	33 d2		 xor	 edx, edx
  00163	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00168	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryInfoKeyA

; 269  :     if (rc!=ERROR_SUCCESS) goto done;

  00173	85 c0		 test	 eax, eax
  00175	0f 85 72 02 00
	00		 jne	 $LN7@getpythonr

; 270  :     if (skipcore) dataSize = 0; /* Only count core ones if we want them! */

  0017b	44 8b a5 e0 01
	00 00		 mov	 r12d, DWORD PTR dataSize$[rbp-256]

; 271  :     /* Allocate a temp array of char buffers, so we only need to loop
; 272  :        reading the registry once
; 273  :     */
; 274  :     ppPaths = malloc( sizeof(WCHAR *) * numKeys );

  00182	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  00188	45 85 f6	 test	 r14d, r14d
  0018b	44 0f 45 e3	 cmovne	 r12d, ebx
  0018f	8b f7		 mov	 esi, edi
  00191	48 c1 e6 03	 shl	 rsi, 3
  00195	44 89 a5 e0 01
	00 00		 mov	 DWORD PTR dataSize$[rbp-256], r12d
  0019c	48 8b ce	 mov	 rcx, rsi
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001a5	4c 8b f0	 mov	 r14, rax

; 275  :     if (ppPaths==NULL) goto done;

  001a8	48 85 c0	 test	 rax, rax
  001ab	0f 84 3c 02 00
	00		 je	 $LN7@getpythonr

; 276  :     memset(ppPaths, 0, sizeof(WCHAR *) * numKeys);

  001b1	4c 8b c6	 mov	 r8, rsi
  001b4	33 d2		 xor	 edx, edx
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	e8 00 00 00 00	 call	 memset

; 277  :     /* Loop over all subkeys, allocating a temp sub-buffer. */
; 278  :     for(index=0;index<numKeys;index++) {

  001be	8b f3		 mov	 esi, ebx
  001c0	85 ff		 test	 edi, edi
  001c2	0f 84 08 01 00
	00		 je	 $LN22@getpythonr

; 276  :     memset(ppPaths, 0, sizeof(WCHAR *) * numKeys);

  001c8	4d 8b e6	 mov	 r12, r14
  001cb	0f 1f 44 00 00	 npad	 5
$LL24@getpythonr:

; 279  :         WCHAR keyBuf[MAX_PATH+1];
; 280  :         HKEY subKey = 0;
; 281  :         DWORD reqdSize = MAX_PATH+1;
; 282  :         /* Get the sub-key name */
; 283  :         DWORD rc = RegEnumKeyExW(newKey, index, keyBuf, &reqdSize,
; 284  :                                  NULL, NULL, NULL, NULL );

  001d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newKey$[rsp]
  001d5	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  001da	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  001df	4c 8d 4c 24 60	 lea	 r9, QWORD PTR reqdSize$120407[rsp]
  001e4	4c 8d 45 80	 lea	 r8, QWORD PTR keyBuf$120405[rbp-256]
  001e8	8b d6		 mov	 edx, esi
  001ea	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  001ef	48 89 5c 24 70	 mov	 QWORD PTR subKey$120406[rsp], rbx
  001f4	c7 44 24 60 05
	01 00 00	 mov	 DWORD PTR reqdSize$120407[rsp], 261 ; 00000105H
  001fc	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExW

; 285  :         if (rc!=ERROR_SUCCESS) goto done;

  00207	85 c0		 test	 eax, eax
  00209	0f 85 65 01 00
	00		 jne	 $LN41@getpythonr

; 286  :         /* Open the sub-key */
; 287  :         rc=RegOpenKeyExW(newKey,
; 288  :                                         keyBuf, /* subkey */
; 289  :                         0, /* reserved */
; 290  :                         KEY_READ,
; 291  :                         &subKey);

  0020f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newKey$[rsp]
  00214	48 8d 44 24 70	 lea	 rax, QWORD PTR subKey$120406[rsp]
  00219	48 8d 55 80	 lea	 rdx, QWORD PTR keyBuf$120405[rbp-256]
  0021d	41 b9 19 00 02
	00		 mov	 r9d, 131097		; 00020019H
  00223	45 33 c0	 xor	 r8d, r8d
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExW

; 292  :         if (rc!=ERROR_SUCCESS) goto done;

  00231	85 c0		 test	 eax, eax
  00233	0f 85 3b 01 00
	00		 jne	 $LN41@getpythonr

; 293  :         /* Find the value of the buffer size, malloc, then read it */
; 294  :         RegQueryValueExW(subKey, NULL, 0, NULL, NULL, &reqdSize);

  00239	48 8b 4c 24 70	 mov	 rcx, QWORD PTR subKey$120406[rsp]
  0023e	48 8d 44 24 60	 lea	 rax, QWORD PTR reqdSize$120407[rsp]
  00243	45 33 c9	 xor	 r9d, r9d
  00246	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0024b	45 33 c0	 xor	 r8d, r8d
  0024e	33 d2		 xor	 edx, edx
  00250	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW

; 295  :         if (reqdSize) {

  0025b	8b 54 24 60	 mov	 edx, DWORD PTR reqdSize$120407[rsp]
  0025f	85 d2		 test	 edx, edx
  00261	74 47		 je	 SHORT $LN18@getpythonr

; 296  :             ppPaths[index] = malloc(reqdSize);

  00263	8b ca		 mov	 ecx, edx
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0026b	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 297  :             if (ppPaths[index]) {

  0026f	48 85 c0	 test	 rax, rax
  00272	74 36		 je	 SHORT $LN18@getpythonr

; 298  :                 RegQueryValueExW(subKey, NULL, 0, NULL,
; 299  :                                 (LPBYTE)ppPaths[index],
; 300  :                                 &reqdSize);

  00274	48 8d 4c 24 60	 lea	 rcx, QWORD PTR reqdSize$120407[rsp]
  00279	45 33 c9	 xor	 r9d, r9d
  0027c	45 33 c0	 xor	 r8d, r8d
  0027f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00284	48 8b 4c 24 70	 mov	 rcx, QWORD PTR subKey$120406[rsp]
  00289	33 d2		 xor	 edx, edx
  0028b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW

; 301  :                 dataSize += reqdSize + 1; /* 1 for the ";" */

  00296	8b 95 e0 01 00
	00		 mov	 edx, DWORD PTR dataSize$[rbp-256]
  0029c	8b 44 24 60	 mov	 eax, DWORD PTR reqdSize$120407[rsp]
  002a0	8d 4c 02 01	 lea	 ecx, DWORD PTR [rdx+rax+1]
  002a4	89 8d e0 01 00
	00		 mov	 DWORD PTR dataSize$[rbp-256], ecx
$LN18@getpythonr:

; 302  :             }
; 303  :         }
; 304  :         RegCloseKey(subKey);

  002aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR subKey$120406[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
  002b5	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  002bb	ff c6		 inc	 esi
  002bd	49 83 c4 08	 add	 r12, 8
  002c1	3b f7		 cmp	 esi, edi
  002c3	0f 82 07 ff ff
	ff		 jb	 $LL24@getpythonr

; 277  :     /* Loop over all subkeys, allocating a temp sub-buffer. */
; 278  :     for(index=0;index<numKeys;index++) {

  002c9	44 8b a5 e0 01
	00 00		 mov	 r12d, DWORD PTR dataSize$[rbp-256]
$LN22@getpythonr:

; 305  :     }
; 306  : 
; 307  :     /* return null if no path to return */
; 308  :     if (dataSize == 0) goto done;

  002d0	45 85 e4	 test	 r12d, r12d
  002d3	0f 84 e6 00 00
	00		 je	 $done$120384

; 309  : 
; 310  :     /* original datasize from RegQueryInfo doesn't include the \0 */
; 311  :     dataBuf = malloc((dataSize+1) * sizeof(WCHAR));

  002d9	41 8d 4c 24 01	 lea	 ecx, DWORD PTR [r12+1]
  002de	48 03 c9	 add	 rcx, rcx
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002e7	4c 8b f8	 mov	 r15, rax

; 312  :     if (dataBuf) {

  002ea	48 85 c0	 test	 rax, rax
  002ed	0f 84 c7 00 00
	00		 je	 $LN42@getpythonr

; 313  :         WCHAR *szCur = dataBuf;

  002f3	48 8b f0	 mov	 rsi, rax

; 314  :         DWORD reqdSize = dataSize;
; 315  :         /* Copy our collected strings */
; 316  :         for (index=0;index<numKeys;index++) {

  002f6	44 8b e3	 mov	 r12d, ebx
  002f9	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  002fe	85 ff		 test	 edi, edi
  00300	74 65		 je	 SHORT $LN13@getpythonr

; 313  :         WCHAR *szCur = dataBuf;

  00302	4d 8b ee	 mov	 r13, r14
$LL15@getpythonr:

; 317  :             if (index > 0) {

  00305	45 85 e4	 test	 r12d, r12d
  00308	74 13		 je	 SHORT $LN12@getpythonr

; 318  :                 *(szCur++) = L';';

  0030a	66 89 06	 mov	 WORD PTR [rsi], ax

; 319  :                 dataSize--;

  0030d	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  00313	48 83 c6 02	 add	 rsi, 2
  00317	ff 8d e0 01 00
	00		 dec	 DWORD PTR dataSize$[rbp-256]
$LN12@getpythonr:

; 320  :             }
; 321  :             if (ppPaths[index]) {

  0031d	49 8b 55 00	 mov	 rdx, QWORD PTR [r13]
  00321	48 85 d2	 test	 rdx, rdx
  00324	74 35		 je	 SHORT $LN14@getpythonr

; 322  :                 Py_ssize_t len = wcslen(ppPaths[index]);

  00326	48 83 c9 ff	 or	 rcx, -1
  0032a	33 c0		 xor	 eax, eax
  0032c	48 8b fa	 mov	 rdi, rdx
  0032f	66 f2 af	 repne scasw
  00332	48 f7 d1	 not	 rcx

; 323  :                 wcsncpy(szCur, ppPaths[index], len);

  00335	4c 8d 41 ff	 lea	 r8, QWORD PTR [rcx-1]
  00339	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]
  0033d	48 8b ce	 mov	 rcx, rsi
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 324  :                 szCur += len;
; 325  :                 assert(dataSize > (DWORD)len);
; 326  :                 dataSize -= (DWORD)len;

  00346	29 bd e0 01 00
	00		 sub	 DWORD PTR dataSize$[rbp-256], edi
  0034c	48 8d 34 7e	 lea	 rsi, QWORD PTR [rsi+rdi*2]
  00350	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  00356	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
$LN14@getpythonr:

; 314  :         DWORD reqdSize = dataSize;
; 315  :         /* Copy our collected strings */
; 316  :         for (index=0;index<numKeys;index++) {

  0035b	41 ff c4	 inc	 r12d
  0035e	49 83 c5 08	 add	 r13, 8
  00362	44 3b e7	 cmp	 r12d, edi
  00365	72 9e		 jb	 SHORT $LL15@getpythonr
$LN13@getpythonr:

; 327  :             }
; 328  :         }
; 329  :         if (skipcore)

  00367	39 9d d8 01 00
	00		 cmp	 DWORD PTR skipcore$[rbp-256], ebx
  0036d	74 0d		 je	 SHORT $LN10@getpythonr

; 330  :             *szCur = '\0';

  0036f	66 89 1e	 mov	 WORD PTR [rsi], bx

; 331  :         else {

  00372	eb 3d		 jmp	 SHORT $LN9@getpythonr
$LN41@getpythonr:

; 342  :         }
; 343  :         /* And set the result - caller must free */
; 344  :         retval = dataBuf;

  00374	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  0037a	eb 43		 jmp	 SHORT $done$120384
$LN10@getpythonr:

; 332  :             /* If we have no values, we dont need a ';' */
; 333  :             if (numKeys) {

  0037c	85 ff		 test	 edi, edi
  0037e	74 0d		 je	 SHORT $LN8@getpythonr

; 334  :                 *(szCur++) = L';';

  00380	66 89 06	 mov	 WORD PTR [rsi], ax
  00383	48 83 c6 02	 add	 rsi, 2

; 335  :                 dataSize--;

  00387	ff 8d e0 01 00
	00		 dec	 DWORD PTR dataSize$[rbp-256]
$LN8@getpythonr:

; 336  :             }
; 337  :             /* Now append the core path entries -
; 338  :                this will include the NULL
; 339  :             */
; 340  :             rc = RegQueryValueExW(newKey, NULL, 0, NULL,
; 341  :                                   (LPBYTE)szCur, &dataSize);

  0038d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newKey$[rsp]
  00392	48 8d 85 e0 01
	00 00		 lea	 rax, QWORD PTR dataSize$[rbp-256]
  00399	45 33 c9	 xor	 r9d, r9d
  0039c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003a1	45 33 c0	 xor	 r8d, r8d
  003a4	33 d2		 xor	 edx, edx
  003a6	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  003ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW
$LN9@getpythonr:

; 342  :         }
; 343  :         /* And set the result - caller must free */
; 344  :         retval = dataBuf;

  003b1	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
  003b7	4d 8b ef	 mov	 r13, r15
$LN42@getpythonr:

; 247  :     /* Space for all the chars, plus one \0 */
; 248  :     keyBuf = keyBufPtr = malloc(sizeof(keyPrefix) +
; 249  :                                 sizeof(WCHAR)*(versionLen-1) +
; 250  :                                 sizeof(keySuffix));

  003ba	4c 8b 7c 24 78	 mov	 r15, QWORD PTR keyBuf$1$[rsp]
$done$120384:

; 345  :     }
; 346  : done:
; 347  :     /* Loop freeing my temp buffers */
; 348  :     if (ppPaths) {
; 349  :         for(index=0;index<numKeys;index++)

  003bf	85 ff		 test	 edi, edi
  003c1	74 21		 je	 SHORT $LN4@getpythonr
  003c3	49 8b f6	 mov	 rsi, r14
$LL6@getpythonr:

; 350  :             if (ppPaths[index]) free(ppPaths[index]);

  003c6	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  003c9	48 85 c9	 test	 rcx, rcx
  003cc	74 0c		 je	 SHORT $LN5@getpythonr
  003ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  003d4	8b bd e8 01 00
	00		 mov	 edi, DWORD PTR numKeys$[rbp-256]
$LN5@getpythonr:

; 345  :     }
; 346  : done:
; 347  :     /* Loop freeing my temp buffers */
; 348  :     if (ppPaths) {
; 349  :         for(index=0;index<numKeys;index++)

  003da	ff c3		 inc	 ebx
  003dc	48 83 c6 08	 add	 rsi, 8
  003e0	3b df		 cmp	 ebx, edi
  003e2	72 e2		 jb	 SHORT $LL6@getpythonr
$LN4@getpythonr:

; 351  :         free(ppPaths);

  003e4	49 8b ce	 mov	 rcx, r14
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@getpythonr:

; 352  :     }
; 353  :     if (newKey)

  003ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newKey$[rsp]
  003f2	48 85 c9	 test	 rcx, rcx
  003f5	74 06		 je	 SHORT $LN2@getpythonr

; 354  :         RegCloseKey(newKey);

  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
$LN2@getpythonr:

; 355  :     if (keyBuf)
; 356  :         free(keyBuf);

  003fd	49 8b cf	 mov	 rcx, r15
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN40@getpythonr:

; 357  :     return retval;

  00406	49 8b c5	 mov	 rax, r13

; 358  : }

  00409	48 8b 9c 24 d0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+720]
  00411	48 81 c4 90 02
	00 00		 add	 rsp, 656		; 00000290H
  00418	41 5f		 pop	 r15
  0041a	41 5e		 pop	 r14
  0041c	41 5d		 pop	 r13
  0041e	41 5c		 pop	 r12
  00420	5f		 pop	 rdi
  00421	5e		 pop	 rsi
  00422	5d		 pop	 rbp
  00423	c3		 ret	 0
getpythonregpath ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@	; `string'
EXTRN	__imp_wcschr:PROC
EXTRN	__imp_GetModuleFileNameW:PROC
EXTRN	PyWin_DLLhModule:QWORD
EXTRN	Py_GetProgramName:PROC
EXTRN	__imp__wgetenv:PROC
_BSS	SEGMENT
	ALIGN	4

progpath DW	0101H DUP (?)
	ALIGN	4

dllpath	DW	0101H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_progpath DD imagerel get_progpath
	DD	imagerel get_progpath+194
	DD	imagerel $unwind$get_progpath
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$get_progpath DD imagerel get_progpath+194
	DD	imagerel get_progpath+329
	DD	imagerel $chain$1$get_progpath
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$get_progpath DD imagerel get_progpath+329
	DD	imagerel get_progpath+377
	DD	imagerel $chain$2$get_progpath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$get_progpath DD 021H
	DD	imagerel get_progpath
	DD	imagerel get_progpath+194
	DD	imagerel $unwind$get_progpath
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$get_progpath DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel get_progpath
	DD	imagerel get_progpath+194
	DD	imagerel $unwind$get_progpath
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_progpath DD 081401H
	DD	0b6414H
	DD	0a5414H
	DD	0e0103214H
	DD	0c00cd00eH
xdata	ENDS
;	COMDAT ??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@ DB 'p', 00H, 'y'
	DB	00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ DB 'P', 00H, 'A', 00H, 'T', 00H
	DB	'H', 00H, 00H, 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT get_progpath
_TEXT	SEGMENT
get_progpath PROC					; COMDAT

; 364  : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 365  :     extern wchar_t *Py_GetProgramName(void);
; 366  :     wchar_t *path = _wgetenv(L"PATH");

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  00021	48 8b f0	 mov	 rsi, rax

; 367  :     wchar_t *prog = Py_GetProgramName();

  00024	e8 00 00 00 00	 call	 Py_GetProgramName

; 368  : 
; 369  : #ifdef MS_WINDOWS
; 370  : #ifdef Py_ENABLE_SHARED
; 371  :     extern HANDLE PyWin_DLLhModule;
; 372  :     /* static init of progpath ensures final char remains \0 */
; 373  :     if (PyWin_DLLhModule)

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyWin_DLLhModule
  00030	45 33 f6	 xor	 r14d, r14d
  00033	41 bd 00 01 00
	00		 mov	 r13d, 256		; 00000100H
  00039	48 8b e8	 mov	 rbp, rax
  0003c	48 85 c9	 test	 rcx, rcx
  0003f	74 1c		 je	 SHORT $LN15@get_progpa

; 374  :         if (!GetModuleFileNameW(PyWin_DLLhModule, dllpath, MAXPATHLEN))

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  00048	45 8b c5	 mov	 r8d, r13d
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameW
  00051	85 c0		 test	 eax, eax
  00053	75 08		 jne	 SHORT $LN15@get_progpa

; 375  :             dllpath[0] = 0;

  00055	66 44 89 35 00
	00 00 00	 mov	 WORD PTR dllpath, r14w
$LN15@get_progpa:

; 376  : #else
; 377  :     dllpath[0] = 0;
; 378  : #endif
; 379  :     if (GetModuleFileNameW(NULL, progpath, MAXPATHLEN))

  0005d	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:progpath
  00064	45 8b c5	 mov	 r8d, r13d
  00067	33 c9		 xor	 ecx, ecx
  00069	49 8b d4	 mov	 rdx, r12
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameW
  00072	85 c0		 test	 eax, eax
  00074	0f 85 cf 00 00
	00		 jne	 $LN1@get_progpa

; 380  :         return;
; 381  : #endif
; 382  :     if (prog == NULL || *prog == '\0')

  0007a	48 85 ed	 test	 rbp, rbp
  0007d	74 07		 je	 SHORT $LN12@get_progpa
  0007f	66 44 39 75 00	 cmp	 WORD PTR [rbp], r14w
  00084	75 07		 jne	 SHORT $LN13@get_progpa
$LN12@get_progpa:

; 383  :         prog = L"python";

  00086	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@
$LN13@get_progpa:

; 384  : 
; 385  :     /* If there is no slash in the argv0 path, then we have to
; 386  :      * assume python is on the user's $PATH, since there's no
; 387  :      * other way to find a directory to start the search from.  If
; 388  :      * $PATH isn't exported, you lose.
; 389  :      */
; 390  : #ifdef ALTSEP
; 391  :     if (wcschr(prog, SEP) || wcschr(prog, ALTSEP))

  0008d	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00092	48 8b cd	 mov	 rcx, rbp
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0009b	48 85 c0	 test	 rax, rax
  0009e	0f 85 c4 00 00
	00		 jne	 $LN10@get_progpa
  000a4	8d 50 2f	 lea	 edx, QWORD PTR [rax+47]
  000a7	48 8b cd	 mov	 rcx, rbp
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  000b0	48 85 c0	 test	 rax, rax
  000b3	0f 85 af 00 00
	00		 jne	 $LN10@get_progpa

; 396  :     else if (path) {

  000b9	48 85 f6	 test	 rsi, rsi
  000bc	0f 84 9c 00 00
	00		 je	 $LN8@get_progpa
  000c2	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  000c7	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  000cc	0f 1f 40 00	 npad	 4
$LL7@get_progpa:

; 397  :         while (1) {
; 398  :             wchar_t *delim = wcschr(path, DELIM);

  000d0	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  000d5	48 8b ce	 mov	 rcx, rsi
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 404  :                 wcsncpy(progpath, path, len);

  000de	48 8b d6	 mov	 rdx, rsi
  000e1	49 8b cc	 mov	 rcx, r12
  000e4	48 8b f8	 mov	 rdi, rax
  000e7	48 85 c0	 test	 rax, rax
  000ea	74 20		 je	 SHORT $LN5@get_progpa

; 399  : 
; 400  :             if (delim) {
; 401  :                 size_t len = delim - path;

  000ec	48 8b d8	 mov	 rbx, rax
  000ef	48 2b de	 sub	 rbx, rsi
  000f2	48 d1 fb	 sar	 rbx, 1

; 402  :                 /* ensure we can't overwrite buffer */
; 403  :                 len = min(MAXPATHLEN,len);

  000f5	49 3b dd	 cmp	 rbx, r13
  000f8	49 0f 47 dd	 cmova	 rbx, r13

; 404  :                 wcsncpy(progpath, path, len);

  000fc	4c 8b c3	 mov	 r8, rbx
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 405  :                 *(progpath + len) = '\0';

  00105	66 45 89 34 5c	 mov	 WORD PTR [r12+rbx*2], r14w

; 406  :             }
; 407  :             else

  0010a	eb 09		 jmp	 SHORT $LN4@get_progpa
$LN5@get_progpa:

; 408  :                 wcsncpy(progpath, path, MAXPATHLEN);

  0010c	4d 8b c5	 mov	 r8, r13
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
$LN4@get_progpa:

; 409  : 
; 410  :             /* join() is safe for MAXPATHLEN+1 size buffer */
; 411  :             join(progpath, prog);

  00115	48 8b d5	 mov	 rdx, rbp
  00118	49 8b cc	 mov	 rcx, r12
  0011b	e8 00 00 00 00	 call	 join

; 412  :             if (exists(progpath))

  00120	49 8b cc	 mov	 rcx, r12
  00123	e8 00 00 00 00	 call	 exists
  00128	85 c0		 test	 eax, eax
  0012a	75 13		 jne	 SHORT $LN23@get_progpa

; 413  :                 break;
; 414  : 
; 415  :             if (!delim) {

  0012c	48 85 ff	 test	 rdi, rdi
  0012f	74 06		 je	 SHORT $LN21@get_progpa

; 417  :                 break;
; 418  :             }
; 419  :             path = delim + 1;

  00131	48 8d 77 02	 lea	 rsi, QWORD PTR [rdi+2]

; 420  :         }

  00135	eb 99		 jmp	 SHORT $LL7@get_progpa
$LN21@get_progpa:

; 416  :                 progpath[0] = '\0';

  00137	66 44 89 35 00
	00 00 00	 mov	 WORD PTR progpath, r14w
$LN23@get_progpa:
  0013f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00144	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
$LN1@get_progpa:

; 424  : }

  00149	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0014e	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00153	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00157	41 5e		 pop	 r14
  00159	41 5d		 pop	 r13
  0015b	41 5c		 pop	 r12
  0015d	c3		 ret	 0
$LN8@get_progpa:

; 421  :     }
; 422  :     else
; 423  :         progpath[0] = '\0';

  0015e	66 44 89 35 00
	00 00 00	 mov	 WORD PTR progpath, r14w
  00166	eb e1		 jmp	 SHORT $LN1@get_progpa
$LN10@get_progpa:

; 392  : #else
; 393  :     if (wcschr(prog, SEP))
; 394  : #endif
; 395  :         wcsncpy(progpath, prog, MAXPATHLEN);

  00168	4d 8b c5	 mov	 r8, r13
  0016b	48 8b d5	 mov	 rdx, rbp
  0016e	49 8b cc	 mov	 rcx, r12
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
  00177	eb d0		 jmp	 SHORT $LN1@get_progpa
get_progpath ENDP
_TEXT	ENDS
PUBLIC	??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@		; `string'
PUBLIC	??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@		; `string'
PUBLIC	??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
EXTRN	__imp_wcstok:PROC
EXTRN	PyUnicode_AsWideChar:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fseek:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$find_env_config_value DD imagerel find_env_config_value
	DD	imagerel find_env_config_value+56
	DD	imagerel $unwind$find_env_config_value
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$find_env_config_value DD imagerel find_env_config_value+56
	DD	imagerel find_env_config_value+470
	DD	imagerel $chain$1$find_env_config_value
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$find_env_config_value DD imagerel find_env_config_value+470
	DD	imagerel find_env_config_value+492
	DD	imagerel $chain$2$find_env_config_value
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$find_env_config_value DD imagerel find_env_config_value+492
	DD	imagerel find_env_config_value+517
	DD	imagerel $chain$3$find_env_config_value
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$find_env_config_value DD imagerel find_env_config_value+517
	DD	imagerel find_env_config_value+521
	DD	imagerel $chain$4$find_env_config_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$find_env_config_value DD 021H
	DD	imagerel find_env_config_value
	DD	imagerel find_env_config_value+56
	DD	imagerel $unwind$find_env_config_value
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$find_env_config_value DD 040021H
	DD	0cd7400H
	DD	0cc6400H
	DD	imagerel find_env_config_value
	DD	imagerel find_env_config_value+56
	DD	imagerel $unwind$find_env_config_value
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$find_env_config_value DD 021H
	DD	imagerel find_env_config_value
	DD	imagerel find_env_config_value+56
	DD	imagerel $unwind$find_env_config_value
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$find_env_config_value DD 041021H
	DD	0cd7410H
	DD	0cc6408H
	DD	imagerel find_env_config_value
	DD	imagerel find_env_config_value+56
	DD	imagerel $unwind$find_env_config_value
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_env_config_value DD 071301H
	DD	0cf5413H
	DD	0ce3413H
	DD	0ca0113H
	DD	0c00cH
xdata	ENDS
;	COMDAT ??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@ DB 0dH, 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@
CONST	SEGMENT
??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@ DB '=', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@
CONST	SEGMENT
??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@ DB ' ', 00H, 09H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@ DB ' ', 00H, 09H, 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\src\pyparallel\pc\getpathp.c
CONST	ENDS
;	COMDAT find_env_config_value
_TEXT	SEGMENT
buffer$ = 48
tmpbuffer$120494 = 576
env_file$ = 1632
key$ = 1640
value$ = 1648
find_env_config_value PROC				; COMDAT

; 428  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 54		 push	 r12
  0000c	48 81 ec 50 06
	00 00		 sub	 rsp, 1616		; 00000650H
  00013	4d 8b e0	 mov	 r12, r8
  00016	48 8b ea	 mov	 rbp, rdx

; 429  :     int result = 0; /* meaning not found */
; 430  :     char buffer[MAXPATHLEN*2+1];  /* allow extra for key, '=', etc. */
; 431  : 
; 432  :     fseek(env_file, 0, SEEK_SET);

  00019	45 33 c0	 xor	 r8d, r8d
  0001c	33 d2		 xor	 edx, edx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek

; 433  :     while (!feof(env_file)) {

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00030	85 c0		 test	 eax, eax
  00032	0f 85 cd 01 00
	00		 jne	 $LN31@find_env_c
  00038	48 89 b4 24 60
	06 00 00	 mov	 QWORD PTR [rsp+1632], rsi
  00040	48 89 bc 24 68
	06 00 00	 mov	 QWORD PTR [rsp+1640], rdi
  00048	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@find_env_c:

; 434  :         char * p = fgets(buffer, MAXPATHLEN*2, env_file);

  00050	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00055	4c 8b c3	 mov	 r8, rbx
  00058	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00063	48 8b d0	 mov	 rdx, rax

; 435  :         wchar_t tmpbuffer[MAXPATHLEN*2+1];
; 436  :         PyObject * decoded;
; 437  :         int n;
; 438  : 
; 439  :         if (p == NULL)

  00066	48 85 c0	 test	 rax, rax
  00069	0f 84 55 01 00
	00		 je	 $LN34@find_env_c

; 440  :             break;
; 441  :         n = strlen(p);

  0006f	33 c0		 xor	 eax, eax
  00071	48 83 c9 ff	 or	 rcx, -1
  00075	48 8b fa	 mov	 rdi, rdx
  00078	f2 ae		 repne scasb
  0007a	48 f7 d1	 not	 rcx
  0007d	48 8d 41 ff	 lea	 rax, QWORD PTR [rcx-1]

; 442  :         if (p[n - 1] != '\n') {

  00081	48 98		 cdqe
  00083	80 7c 10 ff 0a	 cmp	 BYTE PTR [rax+rdx-1], 10
  00088	0f 85 36 01 00
	00		 jne	 $LN34@find_env_c

; 443  :             /* line has overflowed - bail */
; 444  :             break;
; 445  :         }
; 446  :         if (p[0] == '#')    /* Comment - skip */

  0008e	80 3a 23	 cmp	 BYTE PTR [rdx], 35	; 00000023H
  00091	0f 84 1c 01 00
	00		 je	 $LN1@find_env_c

; 447  :             continue;
; 448  :         decoded = PyUnicode_DecodeUTF8(buffer, n, "surrogateescape");

  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  0009e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  000ab	48 8b f8	 mov	 rdi, rax

; 449  :         if (decoded != NULL) {

  000ae	48 85 c0	 test	 rax, rax
  000b1	0f 84 fc 00 00
	00		 je	 $LN1@find_env_c

; 450  :             Py_ssize_t k;
; 451  :             k = PyUnicode_AsWideChar(decoded,
; 452  :                                      tmpbuffer, MAXPATHLEN * 2);

  000b7	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR tmpbuffer$120494[rsp]
  000bf	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  000c5	48 8b c8	 mov	 rcx, rax
  000c8	e8 00 00 00 00	 call	 PyUnicode_AsWideChar
  000cd	48 8b f0	 mov	 rsi, rax

; 453  :             Py_DECREF(decoded);

  000d0	e8 00 00 00 00	 call	 _Py_PXCTX
  000d5	85 c0		 test	 eax, eax
  000d7	75 5e		 jne	 SHORT $LN23@find_env_c
  000d9	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  000dd	f6 c1 20	 test	 cl, 32			; 00000020H
  000e0	75 4d		 jne	 SHORT $LN17@find_env_c
  000e2	84 c9		 test	 cl, cl
  000e4	78 49		 js	 SHORT $LN17@find_env_c
  000e6	f6 c1 02	 test	 cl, 2
  000e9	75 4c		 jne	 SHORT $LN23@find_env_c
  000eb	48 ff 4f 50	 dec	 QWORD PTR [rdi+80]
  000ef	75 46		 jne	 SHORT $LN23@find_env_c
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000ff	4c 8b cf	 mov	 r9, rdi
  00102	41 b8 a4 03 00
	00		 mov	 r8d, 932		; 000003a4H
  00108	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00110	e8 00 00 00 00	 call	 _PyParallel_Guard
  00115	48 8b cf	 mov	 rcx, rdi
  00118	85 c0		 test	 eax, eax
  0011a	74 07		 je	 SHORT $LN22@find_env_c
  0011c	e8 00 00 00 00	 call	 _Px_Dealloc
  00121	eb 14		 jmp	 SHORT $LN23@find_env_c
$LN22@find_env_c:
  00123	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00127	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]
  0012d	eb 08		 jmp	 SHORT $LN23@find_env_c
$LN17@find_env_c:
  0012f	48 8b cf	 mov	 rcx, rdi
  00132	e8 00 00 00 00	 call	 Px_DecRef
$LN23@find_env_c:

; 454  :             if (k >= 0) {

  00137	48 85 f6	 test	 rsi, rsi
  0013a	78 77		 js	 SHORT $LN1@find_env_c

; 455  :                 wchar_t * tok = wcstok(tmpbuffer, L" \t\r\n");

  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@
  00143	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120494[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok

; 456  :                 if ((tok != NULL) && !wcscmp(tok, key)) {

  00151	48 85 c0	 test	 rax, rax
  00154	74 5d		 je	 SHORT $LN1@find_env_c
  00156	48 8b fd	 mov	 rdi, rbp
  00159	48 2b f8	 sub	 rdi, rax
  0015c	0f 1f 40 00	 npad	 4
$LL29@find_env_c:
  00160	0f b7 10	 movzx	 edx, WORD PTR [rax]
  00163	0f b7 0c 38	 movzx	 ecx, WORD PTR [rax+rdi]
  00167	2b d1		 sub	 edx, ecx
  00169	75 08		 jne	 SHORT $LN30@find_env_c
  0016b	48 83 c0 02	 add	 rax, 2
  0016f	85 c9		 test	 ecx, ecx
  00171	75 ed		 jne	 SHORT $LL29@find_env_c
$LN30@find_env_c:
  00173	85 d2		 test	 edx, edx
  00175	75 3c		 jne	 SHORT $LN1@find_env_c

; 457  :                     tok = wcstok(NULL, L" \t");

  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@
  0017e	33 c9		 xor	 ecx, ecx
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok

; 458  :                     if ((tok != NULL) && !wcscmp(tok, L"=")) {

  00186	48 85 c0	 test	 rax, rax
  00189	74 28		 je	 SHORT $LN1@find_env_c
  0018b	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@
  00192	48 8b f0	 mov	 rsi, rax
  00195	b9 02 00 00 00	 mov	 ecx, 2
  0019a	66 f3 a7	 repe cmpsw
  0019d	75 14		 jne	 SHORT $LN1@find_env_c

; 459  :                         tok = wcstok(NULL, L"\r\n");

  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@
  001a6	33 c9		 xor	 ecx, ecx
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok

; 460  :                         if (tok != NULL) {

  001ae	48 85 c0	 test	 rax, rax
  001b1	75 39		 jne	 SHORT $LN28@find_env_c
$LN1@find_env_c:

; 433  :     while (!feof(env_file)) {

  001b3	48 8b cb	 mov	 rcx, rbx
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  001bc	85 c0		 test	 eax, eax
  001be	0f 84 8c fe ff
	ff		 je	 $LL10@find_env_c
$LN34@find_env_c:

; 462  :                             result = 1;
; 463  :                             break;
; 464  :                         }
; 465  :                     }
; 466  :                 }
; 467  :             }
; 468  :         }
; 469  :     }
; 470  :     return result;

  001c4	33 c0		 xor	 eax, eax
$LN36@find_env_c:
  001c6	48 8b b4 24 60
	06 00 00	 mov	 rsi, QWORD PTR [rsp+1632]
  001ce	48 8b bc 24 68
	06 00 00	 mov	 rdi, QWORD PTR [rsp+1640]
$LN9@find_env_c:

; 471  : }

  001d6	4c 8d 9c 24 50
	06 00 00	 lea	 r11, QWORD PTR [rsp+1616]
  001de	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  001e2	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  001e6	49 8b e3	 mov	 rsp, r11
  001e9	41 5c		 pop	 r12
  001eb	c3		 ret	 0
$LN28@find_env_c:

; 461  :                             wcsncpy(value, tok, MAXPATHLEN);

  001ec	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001f2	48 8b d0	 mov	 rdx, rax
  001f5	49 8b cc	 mov	 rcx, r12
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 462  :                             result = 1;
; 463  :                             break;
; 464  :                         }
; 465  :                     }
; 466  :                 }
; 467  :             }
; 468  :         }
; 469  :     }
; 470  :     return result;

  001fe	b8 01 00 00 00	 mov	 eax, 1
  00203	eb c1		 jmp	 SHORT $LN36@find_env_c
$LN31@find_env_c:
  00205	33 c0		 xor	 eax, eax
  00207	eb cd		 jmp	 SHORT $LN9@find_env_c
find_env_config_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@ ; `string'
PUBLIC	??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_13BPINEIPE@?$AAr?$AA?$AA@			; `string'
PUBLIC	??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ ; `string'
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp__errno:PROC
EXTRN	_Py_wfopen:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
EXTRN	Py_GetPythonHome:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$calculate_path DD imagerel calculate_path
	DD	imagerel calculate_path+1704
	DD	imagerel $unwind$calculate_path
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calculate_path DD 0d2701H
	DD	0d37427H
	DD	0d26427H
	DD	0d13427H
	DD	0ca0127H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@ DB 'Using defaul'
	DB	't static path.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@ DB 'Using env'
	DB	'ironment $PYTHONPATH.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@
CONST	SEGMENT
??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@ DB 'Can''t mall'
	DB	'oc dynamic PYTHONPATH.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@ DB '.'
	DB	00H, '\', 00H, 'D', 00H, 'L', 00H, 'L', 00H, 's', 00H, ';', 00H
	DB	'.', 00H, '\', 00H, 'l', 00H, 'i', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 'b', 00H, '\', 00H, 'o', 00H, 's', 00H, '.', 00H
	DB	'p', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@ DB 'h', 00H, 'o', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13BPINEIPE@?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_13BPINEIPE@?$AAr?$AA?$AA@ DB 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@ DB 'p'
	DB	00H, 'y', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 'v', 00H, '.', 00H
	DB	'c', 00H, 'f', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ DB 'P'
	DB	00H, 'Y', 00H, 'T', 00H, 'H', 00H, 'O', 00H, 'N', 00H, 'P', 00H
	DB	'A', 00H, 'T', 00H, 'H', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT calculate_path
_TEXT	SEGMENT
lookBuf$120624 = 32
argv0_path$ = 32
zip_path$ = 560
tmpbuffer$120539 = 1088
pythonhome$1$ = 1664
calculate_path PROC					; COMDAT

; 475  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d ac 24 b0
	fa ff ff	 lea	 rbp, QWORD PTR [rsp-1360]
  00020	48 81 ec 50 06
	00 00		 sub	 rsp, 1616		; 00000650H

; 476  :     wchar_t argv0_path[MAXPATHLEN+1];
; 477  :     wchar_t *buf;
; 478  :     size_t bufsz;
; 479  :     wchar_t *pythonhome = Py_GetPythonHome();

  00027	e8 00 00 00 00	 call	 Py_GetPythonHome

; 480  :     wchar_t *envpath = NULL;

  0002c	45 33 ff	 xor	 r15d, r15d
  0002f	45 8b e7	 mov	 r12d, r15d
  00032	48 8b f0	 mov	 rsi, rax
  00035	48 89 85 80 05
	00 00		 mov	 QWORD PTR pythonhome$1$[rbp-256], rax

; 481  : 
; 482  : #ifdef MS_WINDOWS
; 483  :     int skiphome, skipdefault;
; 484  :     wchar_t *machinepath = NULL;
; 485  :     wchar_t *userpath = NULL;
; 486  :     wchar_t zip_path[MAXPATHLEN+1];
; 487  :     size_t len;
; 488  : 
; 489  :     if (!Py_IgnoreEnvironmentFlag) {

  0003c	44 39 25 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, r12d
  00043	75 10		 jne	 SHORT $LN50@calculate_

; 490  :         envpath = _wgetenv(L"PYTHONPATH");

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  00052	4c 8b e0	 mov	 r12, rax
$LN50@calculate_:

; 491  :     }
; 492  : #else
; 493  :     char *_envpath = Py_GETENV("PYTHONPATH");
; 494  :     wchar_t wenvpath[MAXPATHLEN+1];
; 495  :     if (_envpath) {
; 496  :         size_t r = mbstowcs(wenvpath, _envpath, MAXPATHLEN+1);
; 497  :         envpath = wenvpath;
; 498  :         if (r == (size_t)-1 || r >= MAXPATHLEN)
; 499  :             envpath = NULL;
; 500  :     }
; 501  : #endif
; 502  : 
; 503  :     get_progpath();

  00055	e8 00 00 00 00	 call	 get_progpath

; 504  :     /* progpath guaranteed \0 terminated in MAXPATH+1 bytes. */
; 505  :     wcscpy(argv0_path, progpath);

  0005a	49 8b d7	 mov	 rdx, r15
  0005d	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:progpath
  00064	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL53@calculate_:
  00070	0f b7 0c 1a	 movzx	 ecx, WORD PTR [rdx+rbx]
  00074	48 83 c2 02	 add	 rdx, 2
  00078	66 89 4c 14 1e	 mov	 WORD PTR argv0_path$[rsp+rdx-2], cx
  0007d	66 85 c9	 test	 cx, cx
  00080	75 ee		 jne	 SHORT $LL53@calculate_

; 506  :     reduce(argv0_path);

  00082	48 8d 4c 24 20	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  00087	e8 00 00 00 00	 call	 reduce

; 507  : 
; 508  :     /* Search for an environment configuration file, first in the
; 509  :        executable's directory and then in the parent directory.
; 510  :        If found, open it for use when searching for prefixes.
; 511  :     */
; 512  : 
; 513  :     {
; 514  :         wchar_t tmpbuffer[MAXPATHLEN+1];
; 515  :         wchar_t *env_cfg = L"pyvenv.cfg";
; 516  :         FILE * env_file = NULL;
; 517  : 
; 518  :         wcscpy(tmpbuffer, argv0_path);

  0008c	49 8b d7	 mov	 rdx, r15
  0008f	90		 npad	 1
$LL54@calculate_:
  00090	0f b7 44 14 20	 movzx	 eax, WORD PTR argv0_path$[rsp+rdx]
  00095	48 83 c2 02	 add	 rdx, 2
  00099	66 89 84 15 3e
	03 00 00	 mov	 WORD PTR tmpbuffer$120539[rbp+rdx-258], ax
  000a1	66 85 c0	 test	 ax, ax
  000a4	75 ea		 jne	 SHORT $LL54@calculate_

; 519  :         join(tmpbuffer, env_cfg);

  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@
  000ad	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  000b4	e8 00 00 00 00	 call	 join

; 520  :         env_file = _Py_wfopen(tmpbuffer, L"r");

  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  000c0	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  000c7	e8 00 00 00 00	 call	 _Py_wfopen
  000cc	48 8b f8	 mov	 rdi, rax

; 521  :         if (env_file == NULL) {

  000cf	48 85 c0	 test	 rax, rax
  000d2	75 5a		 jne	 SHORT $LN85@calculate_

; 522  :             errno = 0;

  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 523  :             reduce(tmpbuffer);

  000da	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  000e1	44 89 38	 mov	 DWORD PTR [rax], r15d
  000e4	e8 00 00 00 00	 call	 reduce

; 524  :             reduce(tmpbuffer);

  000e9	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  000f0	e8 00 00 00 00	 call	 reduce

; 525  :             join(tmpbuffer, env_cfg);

  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@
  000fc	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  00103	e8 00 00 00 00	 call	 join

; 526  :             env_file = _Py_wfopen(tmpbuffer, L"r");

  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  0010f	48 8d 8d 40 03
	00 00		 lea	 rcx, QWORD PTR tmpbuffer$120539[rbp-256]
  00116	e8 00 00 00 00	 call	 _Py_wfopen
  0011b	48 8b f8	 mov	 rdi, rax

; 527  :             if (env_file == NULL) {

  0011e	48 85 c0	 test	 rax, rax
  00121	75 0b		 jne	 SHORT $LN85@calculate_

; 528  :                 errno = 0;

  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00129	44 89 38	 mov	 DWORD PTR [rax], r15d

; 529  :             }
; 530  :         }
; 531  :         if (env_file != NULL) {

  0012c	eb 41		 jmp	 SHORT $LN47@calculate_
$LN85@calculate_:

; 532  :             /* Look for a 'home' variable and set argv0_path to it, if found */
; 533  :             if (find_env_config_value(env_file, L"home", tmpbuffer)) {

  0012e	4c 8d 85 40 03
	00 00		 lea	 r8, QWORD PTR tmpbuffer$120539[rbp-256]
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@
  0013c	48 8b cf	 mov	 rcx, rdi
  0013f	e8 00 00 00 00	 call	 find_env_config_value
  00144	85 c0		 test	 eax, eax
  00146	74 1e		 je	 SHORT $LN46@calculate_

; 534  :                 wcscpy(argv0_path, tmpbuffer);

  00148	49 8b cf	 mov	 rcx, r15
  0014b	0f 1f 44 00 00	 npad	 5
$LL55@calculate_:
  00150	0f b7 84 0d 40
	03 00 00	 movzx	 eax, WORD PTR tmpbuffer$120539[rbp+rcx-256]
  00158	48 83 c1 02	 add	 rcx, 2
  0015c	66 89 44 0c 1e	 mov	 WORD PTR argv0_path$[rsp+rcx-2], ax
  00161	66 85 c0	 test	 ax, ax
  00164	75 ea		 jne	 SHORT $LL55@calculate_
$LN46@calculate_:

; 535  :             }
; 536  :             fclose(env_file);

  00166	48 8b cf	 mov	 rcx, rdi
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
$LN47@calculate_:

; 537  :             env_file = NULL;
; 538  :         }
; 539  :     }
; 540  : 
; 541  :     if (pythonhome == NULL || *pythonhome == '\0') {

  0016f	48 85 f6	 test	 rsi, rsi
  00172	74 1e		 je	 SHORT $LN44@calculate_
  00174	66 44 39 3e	 cmp	 WORD PTR [rsi], r15w
  00178	74 18		 je	 SHORT $LN44@calculate_

; 543  :             pythonhome = prefix;
; 544  :         else
; 545  :             pythonhome = NULL;
; 546  :     }
; 547  :     else
; 548  :         wcsncpy(prefix, pythonhome, MAXPATHLEN);

  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00181	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00187	48 8b d6	 mov	 rdx, rsi
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
  00190	eb 25		 jmp	 SHORT $LN43@calculate_
$LN44@calculate_:

; 542  :         if (search_for_prefix(argv0_path, LANDMARK))

  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
  00199	48 8d 4c 24 20	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  0019e	e8 00 00 00 00	 call	 search_for_prefix
  001a3	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:prefix
  001aa	85 c0		 test	 eax, eax
  001ac	49 0f 44 f7	 cmove	 rsi, r15
  001b0	48 89 b5 80 05
	00 00		 mov	 QWORD PTR pythonhome$1$[rbp-256], rsi
$LN43@calculate_:

; 549  : 
; 550  :     if (envpath && *envpath == '\0')

  001b7	4d 85 e4	 test	 r12, r12
  001ba	74 09		 je	 SHORT $LN40@calculate_
  001bc	66 45 39 3c 24	 cmp	 WORD PTR [r12], r15w
  001c1	4d 0f 44 e7	 cmove	 r12, r15
$LN40@calculate_:

; 551  :         envpath = NULL;
; 552  : 
; 553  : 
; 554  : #ifdef MS_WINDOWS
; 555  :     /* Calculate zip archive path */
; 556  :     if (dllpath[0])             /* use name of python DLL */

  001c5	66 44 39 3d 00
	00 00 00	 cmp	 WORD PTR dllpath, r15w

; 557  :         wcsncpy(zip_path, dllpath, MAXPATHLEN);

  001cd	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001d3	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR zip_path$[rbp-256]
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  001e1	75 03		 jne	 SHORT $LN94@calculate_

; 558  :     else                        /* use name of executable program */
; 559  :         wcsncpy(zip_path, progpath, MAXPATHLEN);

  001e3	48 8b d3	 mov	 rdx, rbx
$LN94@calculate_:
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 560  :     zip_path[MAXPATHLEN] = '\0';
; 561  :     len = wcslen(zip_path);

  001ec	48 83 c9 ff	 or	 rcx, -1
  001f0	33 c0		 xor	 eax, eax
  001f2	48 8d bd 30 01
	00 00		 lea	 rdi, QWORD PTR zip_path$[rbp-256]
  001f9	66 44 89 bd 30
	03 00 00	 mov	 WORD PTR zip_path$[rbp+256], r15w
  00201	66 f2 af	 repne scasw
  00204	48 f7 d1	 not	 rcx
  00207	48 ff c9	 dec	 rcx

; 562  :     if (len > 4) {

  0020a	48 83 f9 04	 cmp	 rcx, 4
  0020e	76 29		 jbe	 SHORT $LN37@calculate_

; 563  :         zip_path[len-3] = 'z';          /* change ending to "zip" */

  00210	b8 7a 00 00 00	 mov	 eax, 122		; 0000007aH
  00215	66 89 84 4d 2a
	01 00 00	 mov	 WORD PTR zip_path$[rbp+rcx*2-262], ax

; 564  :         zip_path[len-2] = 'i';

  0021d	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  00222	66 89 84 4d 2c
	01 00 00	 mov	 WORD PTR zip_path$[rbp+rcx*2-260], ax

; 565  :         zip_path[len-1] = 'p';

  0022a	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  0022f	66 89 84 4d 2e
	01 00 00	 mov	 WORD PTR zip_path$[rbp+rcx*2-258], ax

; 566  :     }
; 567  :     else {

  00237	eb 08		 jmp	 SHORT $LN36@calculate_
$LN37@calculate_:

; 568  :         zip_path[0] = 0;

  00239	66 44 89 bd 30
	01 00 00	 mov	 WORD PTR zip_path$[rbp-256], r15w
$LN36@calculate_:

; 569  :     }
; 570  : 
; 571  :     skiphome = pythonhome==NULL ? 0 : 1;

  00241	41 8b ff	 mov	 edi, r15d
  00244	48 85 f6	 test	 rsi, rsi

; 572  : #ifdef Py_ENABLE_SHARED
; 573  :     machinepath = getpythonregpath(HKEY_LOCAL_MACHINE, skiphome);

  00247	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  0024e	40 0f 95 c7	 setne	 dil
  00252	8b d7		 mov	 edx, edi
  00254	e8 00 00 00 00	 call	 getpythonregpath

; 574  :     userpath = getpythonregpath(HKEY_CURRENT_USER, skiphome);

  00259	8b d7		 mov	 edx, edi
  0025b	48 c7 c1 01 00
	00 80		 mov	 rcx, -2147483647	; ffffffff80000001H
  00262	4c 8b f0	 mov	 r14, rax
  00265	e8 00 00 00 00	 call	 getpythonregpath

; 575  : #endif
; 576  :     /* We only use the default relative PYTHONPATH if we havent
; 577  :        anything better to use! */
; 578  :     skipdefault = envpath!=NULL || pythonhome!=NULL || \
; 579  :                   machinepath!=NULL || userpath!=NULL;

  0026a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  00271	4c 8b e8	 mov	 r13, rax
  00274	4d 85 e4	 test	 r12, r12
  00277	75 0f		 jne	 SHORT $LN56@calculate_
  00279	48 85 f6	 test	 rsi, rsi
  0027c	75 0a		 jne	 SHORT $LN56@calculate_
  0027e	4d 85 f6	 test	 r14, r14
  00281	75 05		 jne	 SHORT $LN56@calculate_
  00283	48 85 c0	 test	 rax, rax
  00286	74 46		 je	 SHORT $LN35@calculate_
$LN56@calculate_:
  00288	41 bf 01 00 00
	00		 mov	 r15d, 1

; 580  : #endif
; 581  : 
; 582  :     /* We need to construct a path from the following parts.
; 583  :        (1) the PYTHONPATH environment variable, if set;
; 584  :        (2) for Win32, the zip archive file path;
; 585  :        (3) for Win32, the machinepath and userpath, if set;
; 586  :        (4) the PYTHONPATH config macro, with the leading "."
; 587  :            of each component replaced with pythonhome, if set;
; 588  :        (5) the directory containing the executable (argv0_path).
; 589  :        The length calculation calculates #4 first.
; 590  :        Extra rules:
; 591  :        - If PYTHONHOME is set (in any way) item (3) is ignored.
; 592  :        - If registry values are used, (4) and (5) are ignored.
; 593  :     */
; 594  : 
; 595  :     /* Calculate size of return buffer */
; 596  :     if (pythonhome != NULL) {

  0028e	48 85 f6	 test	 rsi, rsi
  00291	74 3b		 je	 SHORT $LN35@calculate_

; 597  :         wchar_t *p;
; 598  :         bufsz = 1;

  00293	41 8b d7	 mov	 edx, r15d

; 599  :         for (p = PYTHONPATH; *p; p++) {

  00296	48 8b cb	 mov	 rcx, rbx
  00299	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  0029e	66 90		 npad	 2
$LL34@calculate_:

; 600  :             if (*p == DELIM)

  002a0	66 83 f8 3b	 cmp	 ax, 59			; 0000003bH
  002a4	75 03		 jne	 SHORT $LN33@calculate_

; 601  :                 bufsz++; /* number of DELIM plus one */

  002a6	48 ff c2	 inc	 rdx
$LN33@calculate_:

; 599  :         for (p = PYTHONPATH; *p; p++) {

  002a9	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]
  002ad	48 83 c1 02	 add	 rcx, 2
  002b1	66 85 c0	 test	 ax, ax
  002b4	75 ea		 jne	 SHORT $LL34@calculate_

; 602  :         }
; 603  :         bufsz *= wcslen(pythonhome);

  002b6	48 83 c9 ff	 or	 rcx, -1
  002ba	33 c0		 xor	 eax, eax
  002bc	48 8b fe	 mov	 rdi, rsi
  002bf	66 f2 af	 repne scasw
  002c2	48 f7 d1	 not	 rcx
  002c5	48 ff c9	 dec	 rcx
  002c8	48 0f af d1	 imul	 rdx, rcx

; 604  :     }
; 605  :     else

  002cc	eb 02		 jmp	 SHORT $LN30@calculate_
$LN35@calculate_:

; 606  :         bufsz = 0;

  002ce	33 d2		 xor	 edx, edx
$LN30@calculate_:

; 607  :     bufsz += wcslen(PYTHONPATH) + 1;
; 608  :     bufsz += wcslen(argv0_path) + 1;

  002d0	48 83 c9 ff	 or	 rcx, -1
  002d4	33 c0		 xor	 eax, eax
  002d6	48 8d 7c 24 20	 lea	 rdi, QWORD PTR argv0_path$[rsp]
  002db	66 f2 af	 repne scasw
  002de	48 f7 d1	 not	 rcx
  002e1	4c 8d 44 0a 0d	 lea	 r8, QWORD PTR [rdx+rcx+13]

; 609  : #ifdef MS_WINDOWS
; 610  :     if (userpath)

  002e6	4d 85 ed	 test	 r13, r13
  002e9	74 10		 je	 SHORT $LN29@calculate_

; 611  :         bufsz += wcslen(userpath) + 1;

  002eb	48 83 c9 ff	 or	 rcx, -1
  002ef	49 8b fd	 mov	 rdi, r13
  002f2	66 f2 af	 repne scasw
  002f5	48 f7 d1	 not	 rcx
  002f8	4c 03 c1	 add	 r8, rcx
$LN29@calculate_:

; 612  :     if (machinepath)

  002fb	4d 85 f6	 test	 r14, r14
  002fe	74 12		 je	 SHORT $LN28@calculate_

; 613  :         bufsz += wcslen(machinepath) + 1;

  00300	48 83 c9 ff	 or	 rcx, -1
  00304	33 c0		 xor	 eax, eax
  00306	49 8b fe	 mov	 rdi, r14
  00309	66 f2 af	 repne scasw
  0030c	48 f7 d1	 not	 rcx
  0030f	4c 03 c1	 add	 r8, rcx
$LN28@calculate_:

; 614  :     bufsz += wcslen(zip_path) + 1;

  00312	48 83 c9 ff	 or	 rcx, -1
  00316	33 c0		 xor	 eax, eax
  00318	48 8d bd 30 01
	00 00		 lea	 rdi, QWORD PTR zip_path$[rbp-256]
  0031f	66 f2 af	 repne scasw
  00322	48 f7 d1	 not	 rcx
  00325	49 8d 14 08	 lea	 rdx, QWORD PTR [r8+rcx]

; 615  : #endif
; 616  :     if (envpath != NULL)

  00329	4d 85 e4	 test	 r12, r12
  0032c	74 10		 je	 SHORT $LN27@calculate_

; 617  :         bufsz += wcslen(envpath) + 1;

  0032e	48 83 c9 ff	 or	 rcx, -1
  00332	49 8b fc	 mov	 rdi, r12
  00335	66 f2 af	 repne scasw
  00338	48 f7 d1	 not	 rcx
  0033b	48 03 d1	 add	 rdx, rcx
$LN27@calculate_:

; 618  : 
; 619  :     module_search_path = buf = malloc(bufsz*sizeof(wchar_t));

  0033e	48 8d 0c 12	 lea	 rcx, QWORD PTR [rdx+rdx]
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00348	48 8b f0	 mov	 rsi, rax
  0034b	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax

; 620  :     if (buf == NULL) {

  00352	48 85 c0	 test	 rax, rax
  00355	0f 85 8d 00 00
	00		 jne	 $LN26@calculate_

; 621  :         /* We can't exit, so print a warning and limp along */
; 622  :         fprintf(stderr, "Can't malloc dynamic PYTHONPATH.\n");

  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00361	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@
  00368	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 623  :         if (envpath) {
; 624  :             fprintf(stderr, "Using environment $PYTHONPATH.\n");

  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00378	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  0037c	4d 85 e4	 test	 r12, r12
  0037f	74 16		 je	 SHORT $LN25@calculate_
  00381	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 625  :             module_search_path = envpath;

  0038e	4c 89 25 00 00
	00 00		 mov	 QWORD PTR module_search_path, r12

; 626  :         }
; 627  :         else {

  00395	eb 14		 jmp	 SHORT $LN24@calculate_
$LN25@calculate_:

; 628  :             fprintf(stderr, "Using default static path.\n");

  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 629  :             module_search_path = PYTHONPATH;

  003a4	48 89 1d 00 00
	00 00		 mov	 QWORD PTR module_search_path, rbx
$LN24@calculate_:

; 630  :         }
; 631  : #ifdef MS_WINDOWS
; 632  :         if (machinepath)

  003ab	4d 85 f6	 test	 r14, r14
  003ae	74 09		 je	 SHORT $LN23@calculate_

; 633  :             free(machinepath);

  003b0	49 8b ce	 mov	 rcx, r14
  003b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@calculate_:

; 634  :         if (userpath)

  003b9	4d 85 ed	 test	 r13, r13
  003bc	74 09		 je	 SHORT $LN88@calculate_

; 635  :             free(userpath);

  003be	49 8b cd	 mov	 rcx, r13
  003c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN88@calculate_:

; 738  :     }
; 739  : }

  003c7	4c 8d 9c 24 50
	06 00 00	 lea	 r11, QWORD PTR [rsp+1616]
  003cf	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  003d3	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  003d7	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  003db	49 8b e3	 mov	 rsp, r11
  003de	41 5f		 pop	 r15
  003e0	41 5e		 pop	 r14
  003e2	41 5d		 pop	 r13
  003e4	41 5c		 pop	 r12
  003e6	5d		 pop	 rbp
  003e7	c3		 ret	 0
$LN26@calculate_:

; 636  : #endif /* MS_WINDOWS */
; 637  :         return;
; 638  :     }
; 639  : 
; 640  :     if (envpath) {

  003e8	bf 3b 00 00 00	 mov	 edi, 59			; 0000003bH
  003ed	4d 85 e4	 test	 r12, r12
  003f0	74 34		 je	 SHORT $LN21@calculate_

; 641  :         wcscpy(buf, envpath);

  003f2	48 8b c8	 mov	 rcx, rax
  003f5	49 2b cc	 sub	 rcx, r12
  003f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL58@calculate_:
  00400	41 0f b7 04 24	 movzx	 eax, WORD PTR [r12]
  00405	49 83 c4 02	 add	 r12, 2
  00409	66 42 89 44 21
	fe		 mov	 WORD PTR [rcx+r12-2], ax
  0040f	66 85 c0	 test	 ax, ax
  00412	75 ec		 jne	 SHORT $LL58@calculate_

; 642  :         buf = wcschr(buf, L'\0');

  00414	33 d2		 xor	 edx, edx
  00416	48 8b ce	 mov	 rcx, rsi
  00419	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 643  :         *buf++ = DELIM;

  0041f	66 89 38	 mov	 WORD PTR [rax], di
  00422	48 8d 70 02	 lea	 rsi, QWORD PTR [rax+2]
$LN21@calculate_:

; 644  :     }
; 645  : #ifdef MS_WINDOWS
; 646  :     if (zip_path[0]) {

  00426	66 83 bd 30 01
	00 00 00	 cmp	 WORD PTR zip_path$[rbp-256], 0
  0042e	74 43		 je	 SHORT $LN20@calculate_

; 647  :         wcscpy(buf, zip_path);

  00430	48 8d 85 30 01
	00 00		 lea	 rax, QWORD PTR zip_path$[rbp-256]
  00437	48 8b d6	 mov	 rdx, rsi
  0043a	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR zip_path$[rbp-256]
  00441	48 2b d0	 sub	 rdx, rax
  00444	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL59@calculate_:
  00450	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00453	48 83 c1 02	 add	 rcx, 2
  00457	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  0045c	66 85 c0	 test	 ax, ax
  0045f	75 ef		 jne	 SHORT $LL59@calculate_

; 648  :         buf = wcschr(buf, L'\0');

  00461	33 d2		 xor	 edx, edx
  00463	48 8b ce	 mov	 rcx, rsi
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 649  :         *buf++ = DELIM;

  0046c	66 89 38	 mov	 WORD PTR [rax], di
  0046f	48 8d 70 02	 lea	 rsi, QWORD PTR [rax+2]
$LN20@calculate_:

; 650  :     }
; 651  :     if (userpath) {

  00473	4d 85 ed	 test	 r13, r13
  00476	74 35		 je	 SHORT $LN19@calculate_

; 652  :         wcscpy(buf, userpath);

  00478	48 8b d6	 mov	 rdx, rsi
  0047b	49 8b cd	 mov	 rcx, r13
  0047e	49 2b d5	 sub	 rdx, r13
$LL60@calculate_:
  00481	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00484	48 83 c1 02	 add	 rcx, 2
  00488	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  0048d	66 85 c0	 test	 ax, ax
  00490	75 ef		 jne	 SHORT $LL60@calculate_

; 653  :         buf = wcschr(buf, L'\0');

  00492	33 d2		 xor	 edx, edx
  00494	48 8b ce	 mov	 rcx, rsi
  00497	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 654  :         *buf++ = DELIM;
; 655  :         free(userpath);

  0049d	49 8b cd	 mov	 rcx, r13
  004a0	66 89 38	 mov	 WORD PTR [rax], di
  004a3	48 8d 70 02	 lea	 rsi, QWORD PTR [rax+2]
  004a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@calculate_:

; 656  :     }
; 657  :     if (machinepath) {

  004ad	4d 85 f6	 test	 r14, r14
  004b0	74 3a		 je	 SHORT $LN18@calculate_

; 658  :         wcscpy(buf, machinepath);

  004b2	48 8b d6	 mov	 rdx, rsi
  004b5	49 8b ce	 mov	 rcx, r14
  004b8	49 2b d6	 sub	 rdx, r14
  004bb	0f 1f 44 00 00	 npad	 5
$LL61@calculate_:
  004c0	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  004c3	48 83 c1 02	 add	 rcx, 2
  004c7	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  004cc	66 85 c0	 test	 ax, ax
  004cf	75 ef		 jne	 SHORT $LL61@calculate_

; 659  :         buf = wcschr(buf, L'\0');

  004d1	33 d2		 xor	 edx, edx
  004d3	48 8b ce	 mov	 rcx, rsi
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 660  :         *buf++ = DELIM;
; 661  :         free(machinepath);

  004dc	49 8b ce	 mov	 rcx, r14
  004df	66 89 38	 mov	 WORD PTR [rax], di
  004e2	48 8d 70 02	 lea	 rsi, QWORD PTR [rax+2]
  004e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN18@calculate_:

; 662  :     }
; 663  :     if (pythonhome == NULL) {

  004ec	4c 8b b5 80 05
	00 00		 mov	 r14, QWORD PTR pythonhome$1$[rbp-256]
  004f3	4d 85 f6	 test	 r14, r14
  004f6	0f 85 04 01 00
	00		 jne	 $LL14@calculate_

; 664  :         if (!skipdefault) {

  004fc	45 85 ff	 test	 r15d, r15d
  004ff	75 2e		 jne	 SHORT $LN80@calculate_

; 665  :             wcscpy(buf, PYTHONPATH);

  00501	48 8b ce	 mov	 rcx, rsi
  00504	48 2b cb	 sub	 rcx, rbx
  00507	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL62@calculate_:
  00510	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00513	48 83 c3 02	 add	 rbx, 2
  00517	66 89 44 19 fe	 mov	 WORD PTR [rcx+rbx-2], ax
  0051c	66 85 c0	 test	 ax, ax
  0051f	75 ef		 jne	 SHORT $LL62@calculate_

; 666  :             buf = wcschr(buf, L'\0');

  00521	33 d2		 xor	 edx, edx
  00523	48 8b ce	 mov	 rcx, rsi
  00526	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0052c	48 8b f0	 mov	 rsi, rax
$LN80@calculate_:

; 698  :     }
; 699  :     if (argv0_path) {
; 700  :         *buf++ = DELIM;
; 701  :         wcscpy(buf, argv0_path);

  0052f	48 8d 44 24 20	 lea	 rax, QWORD PTR argv0_path$[rsp]
  00534	48 8d 56 02	 lea	 rdx, QWORD PTR [rsi+2]
  00538	66 89 3e	 mov	 WORD PTR [rsi], di
  0053b	48 2b d0	 sub	 rdx, rax
  0053e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  00543	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL64@calculate_:
  00550	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00553	48 83 c1 02	 add	 rcx, 2
  00557	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  0055c	66 85 c0	 test	 ax, ax
  0055f	75 ef		 jne	 SHORT $LL64@calculate_

; 702  :         buf = wcschr(buf, L'\0');

  00561	48 8d 4e 02	 lea	 rcx, QWORD PTR [rsi+2]
  00565	33 d2		 xor	 edx, edx
  00567	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 703  :     }
; 704  :     *buf = L'\0';

  0056d	33 f6		 xor	 esi, esi
  0056f	66 89 30	 mov	 WORD PTR [rax], si

; 705  :     /* Now to pull one last hack/trick.  If sys.prefix is
; 706  :        empty, then try and find it somewhere on the paths
; 707  :        we calculated.  We scan backwards, as our general policy
; 708  :        is that Python core directories are at the *end* of
; 709  :        sys.path.  We assume that our "lib" directory is
; 710  :        on the path, and that our 'prefix' directory is
; 711  :        the parent of that.
; 712  :     */
; 713  :     if (*prefix==L'\0') {

  00572	66 39 35 00 00
	00 00		 cmp	 WORD PTR prefix, si
  00579	0f 85 48 fe ff
	ff		 jne	 $LN88@calculate_

; 714  :         wchar_t lookBuf[MAXPATHLEN+1];
; 715  :         wchar_t *look = buf - 1; /* 'buf' is at the end of the buffer */

  0057f	48 8d 78 fe	 lea	 rdi, QWORD PTR [rax-2]
  00583	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
  0058a	66 0f 1f 44 00
	00		 npad	 6
$LL6@calculate_:

; 716  :         while (1) {
; 717  :             Py_ssize_t nchars;
; 718  :             wchar_t *lookEnd = look;

  00590	48 8b df	 mov	 rbx, rdi

; 719  :             /* 'look' will end up one character before the
; 720  :                start of the path in question - even if this
; 721  :                is one character before the start of the buffer
; 722  :             */
; 723  :             while (look >= module_search_path && *look != DELIM)

  00593	48 3b f8	 cmp	 rdi, rax
  00596	72 0f		 jb	 SHORT $LN87@calculate_
$LL4@calculate_:
  00598	66 83 3f 3b	 cmp	 WORD PTR [rdi], 59	; 0000003bH
  0059c	74 09		 je	 SHORT $LN87@calculate_

; 724  :                 look--;

  0059e	48 83 ef 02	 sub	 rdi, 2
  005a2	48 3b f8	 cmp	 rdi, rax
  005a5	73 f1		 jae	 SHORT $LL4@calculate_
$LN87@calculate_:

; 725  :             nchars = lookEnd-look;

  005a7	48 2b df	 sub	 rbx, rdi

; 726  :             wcsncpy(lookBuf, look+1, nchars);

  005aa	48 8d 57 02	 lea	 rdx, QWORD PTR [rdi+2]
  005ae	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lookBuf$120624[rsp]
  005b3	48 d1 fb	 sar	 rbx, 1
  005b6	4c 8b c3	 mov	 r8, rbx
  005b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 727  :             lookBuf[nchars] = L'\0';
; 728  :             /* Up one level to the parent */
; 729  :             reduce(lookBuf);

  005bf	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lookBuf$120624[rsp]
  005c4	66 89 74 5c 20	 mov	 WORD PTR lookBuf$120624[rsp+rbx*2], si
  005c9	e8 00 00 00 00	 call	 reduce

; 730  :             if (search_for_prefix(lookBuf, LANDMARK)) {

  005ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
  005d5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR lookBuf$120624[rsp]
  005da	e8 00 00 00 00	 call	 search_for_prefix
  005df	85 c0		 test	 eax, eax
  005e1	0f 85 e0 fd ff
	ff		 jne	 $LN88@calculate_

; 731  :                 break;
; 732  :             }
; 733  :             /* If we are out of paths to search - give up */
; 734  :             if (look < module_search_path)

  005e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
  005ee	48 3b f8	 cmp	 rdi, rax
  005f1	0f 82 d0 fd ff
	ff		 jb	 $LN88@calculate_

; 735  :                 break;
; 736  :             look--;

  005f7	48 83 ef 02	 sub	 rdi, 2

; 737  :         }

  005fb	eb 93		 jmp	 SHORT $LL6@calculate_
  005fd	0f 1f 00	 npad	 3
$LL14@calculate_:

; 667  :         }
; 668  :     }
; 669  : #else
; 670  :     if (pythonhome == NULL) {
; 671  :         wcscpy(buf, PYTHONPATH);
; 672  :         buf = wcschr(buf, L'\0');
; 673  :     }
; 674  : #endif /* MS_WINDOWS */
; 675  :     else {
; 676  :         wchar_t *p = PYTHONPATH;
; 677  :         wchar_t *q;
; 678  :         size_t n;
; 679  :         for (;;) {
; 680  :             q = wcschr(p, DELIM);

  00600	8b d7		 mov	 edx, edi
  00602	48 8b cb	 mov	 rcx, rbx
  00605	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0060b	4c 8b e0	 mov	 r12, rax

; 681  :             if (q == NULL)

  0060e	48 85 c0	 test	 rax, rax
  00611	75 13		 jne	 SHORT $LN12@calculate_

; 682  :                 n = wcslen(p);

  00613	48 83 c9 ff	 or	 rcx, -1
  00617	48 8b fb	 mov	 rdi, rbx
  0061a	66 f2 af	 repne scasw
  0061d	48 f7 d1	 not	 rcx
  00620	48 8d 79 ff	 lea	 rdi, QWORD PTR [rcx-1]

; 683  :             else

  00624	eb 09		 jmp	 SHORT $LN11@calculate_
$LN12@calculate_:

; 684  :                 n = q-p;

  00626	48 8b f8	 mov	 rdi, rax
  00629	48 2b fb	 sub	 rdi, rbx
  0062c	48 d1 ff	 sar	 rdi, 1
$LN11@calculate_:

; 685  :             if (p[0] == '.' && is_sep(p[1])) {

  0062f	66 83 3b 2e	 cmp	 WORD PTR [rbx], 46	; 0000002eH
  00633	75 41		 jne	 SHORT $LN10@calculate_
  00635	0f b7 4b 02	 movzx	 ecx, WORD PTR [rbx+2]
  00639	e8 00 00 00 00	 call	 is_sep
  0063e	85 c0		 test	 eax, eax
  00640	74 34		 je	 SHORT $LN10@calculate_

; 686  :                 wcscpy(buf, pythonhome);

  00642	48 8b d6	 mov	 rdx, rsi
  00645	49 8b ce	 mov	 rcx, r14
  00648	49 2b d6	 sub	 rdx, r14
  0064b	0f 1f 44 00 00	 npad	 5
$LL63@calculate_:
  00650	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00653	48 83 c1 02	 add	 rcx, 2
  00657	66 89 44 0a fe	 mov	 WORD PTR [rdx+rcx-2], ax
  0065c	66 85 c0	 test	 ax, ax
  0065f	75 ef		 jne	 SHORT $LL63@calculate_

; 687  :                 buf = wcschr(buf, L'\0');

  00661	33 d2		 xor	 edx, edx
  00663	48 8b ce	 mov	 rcx, rsi
  00666	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr

; 688  :                 p++;

  0066c	48 83 c3 02	 add	 rbx, 2

; 689  :                 n--;

  00670	48 ff cf	 dec	 rdi
  00673	48 8b f0	 mov	 rsi, rax
$LN10@calculate_:

; 690  :             }
; 691  :             wcsncpy(buf, p, n);

  00676	4c 8b c7	 mov	 r8, rdi
  00679	48 8b d3	 mov	 rdx, rbx
  0067c	48 8b ce	 mov	 rcx, rsi
  0067f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 692  :             buf += n;

  00685	48 8d 34 7e	 lea	 rsi, QWORD PTR [rsi+rdi*2]

; 693  :             if (q == NULL)
; 694  :                 break;
; 695  :             *buf++ = DELIM;

  00689	bf 3b 00 00 00	 mov	 edi, 59			; 0000003bH
  0068e	4d 85 e4	 test	 r12, r12
  00691	0f 84 98 fe ff
	ff		 je	 $LN80@calculate_
  00697	66 89 3e	 mov	 WORD PTR [rsi], di
  0069a	48 83 c6 02	 add	 rsi, 2

; 696  :             p = q+1;

  0069e	49 8d 5c 24 02	 lea	 rbx, QWORD PTR [r12+2]

; 697  :         }

  006a3	e9 58 ff ff ff	 jmp	 $LL14@calculate_
calculate_path ENDP
_TEXT	ENDS
PUBLIC	Py_SetPath
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_SetPath DD imagerel $LN8
	DD	imagerel $LN8+156
	DD	imagerel $unwind$Py_SetPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_SetPath DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_SetPath
_TEXT	SEGMENT
path$ = 48
Py_SetPath PROC						; COMDAT

; 746  : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 747  :     if (module_search_path != NULL) {

  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR module_search_path
  00014	33 ff		 xor	 edi, edi
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 0d		 je	 SHORT $LN3@Py_SetPath

; 748  :         free(module_search_path);

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 749  :         module_search_path = NULL;

  00021	48 89 3d 00 00
	00 00		 mov	 QWORD PTR module_search_path, rdi
$LN3@Py_SetPath:

; 750  :     }
; 751  :     if (path != NULL) {

  00028	48 85 db	 test	 rbx, rbx
  0002b	74 64		 je	 SHORT $LN1@Py_SetPath

; 752  :         extern wchar_t *Py_GetProgramName(void);
; 753  :         wchar_t *prog = Py_GetProgramName();

  0002d	e8 00 00 00 00	 call	 Py_GetProgramName

; 754  :         wcsncpy(progpath, prog, MAXPATHLEN);

  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  00039	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0003f	48 8b d0	 mov	 rdx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 755  :         prefix[0] = L'\0';
; 756  :         module_search_path = malloc((wcslen(path) + 1) * sizeof(wchar_t));

  00048	48 83 c9 ff	 or	 rcx, -1
  0004c	66 89 3d 00 00
	00 00		 mov	 WORD PTR prefix, di
  00053	33 c0		 xor	 eax, eax
  00055	48 8b fb	 mov	 rdi, rbx
  00058	66 f2 af	 repne scasw
  0005b	48 f7 d1	 not	 rcx
  0005e	48 03 c9	 add	 rcx, rcx
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00067	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax

; 757  :         if (module_search_path != NULL)

  0006e	48 85 c0	 test	 rax, rax
  00071	74 1e		 je	 SHORT $LN1@Py_SetPath

; 758  :             wcscpy(module_search_path, path);

  00073	48 2b c3	 sub	 rax, rbx
  00076	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL6@Py_SetPath:
  00080	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00083	48 83 c3 02	 add	 rbx, 2
  00087	66 89 4c 18 fe	 mov	 WORD PTR [rax+rbx-2], cx
  0008c	66 85 c9	 test	 cx, cx
  0008f	75 ef		 jne	 SHORT $LL6@Py_SetPath
$LN1@Py_SetPath:

; 759  : 	}
; 760  : }

  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
Py_SetPath ENDP
_TEXT	ENDS
PUBLIC	Py_GetPath
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetPath DD imagerel $LN5
	DD	imagerel $LN5+33
	DD	imagerel $unwind$Py_GetPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetPath DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_GetPath
_TEXT	SEGMENT
Py_GetPath PROC						; COMDAT

; 764  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 765  :     if (!module_search_path)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
  0000b	48 85 c0	 test	 rax, rax
  0000e	75 0c		 jne	 SHORT $LN4@Py_GetPath

; 766  :         calculate_path();

  00010	e8 00 00 00 00	 call	 calculate_path

; 767  :     return module_search_path;

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
$LN4@Py_GetPath:

; 768  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
Py_GetPath ENDP
_TEXT	ENDS
PUBLIC	Py_GetPrefix
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetPrefix DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$Py_GetPrefix
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetPrefix DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_GetPrefix
_TEXT	SEGMENT
Py_GetPrefix PROC					; COMDAT

; 772  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 773  :     if (!module_search_path)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  0000c	75 05		 jne	 SHORT $LN4@Py_GetPref

; 774  :         calculate_path();

  0000e	e8 00 00 00 00	 call	 calculate_path
$LN4@Py_GetPref:

; 775  :     return prefix;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prefix

; 776  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
Py_GetPrefix ENDP
_TEXT	ENDS
PUBLIC	Py_GetExecPrefix
; Function compile flags: /Ogtpy
;	COMDAT Py_GetExecPrefix
_TEXT	SEGMENT
Py_GetExecPrefix PROC					; COMDAT

; 781  :     return Py_GetPrefix();
; 782  : }

  00000	e9 00 00 00 00	 jmp	 Py_GetPrefix
Py_GetExecPrefix ENDP
_TEXT	ENDS
PUBLIC	Py_GetProgramFullPath
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetProgramFullPath DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$Py_GetProgramFullPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetProgramFullPath DD 010401H
	DD	04204H
; Function compile flags: /Ogtpy
xdata	ENDS
;	COMDAT Py_GetProgramFullPath
_TEXT	SEGMENT
Py_GetProgramFullPath PROC				; COMDAT

; 786  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 787  :     if (!module_search_path)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  0000c	75 05		 jne	 SHORT $LN4@Py_GetProg

; 788  :         calculate_path();

  0000e	e8 00 00 00 00	 call	 calculate_path
$LN4@Py_GetProg:

; 789  :     return progpath;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:progpath

; 790  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
Py_GetProgramFullPath ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	_Py_CheckPython3
EXTRN	__imp_LoadLibraryExW:PROC
EXTRN	__imp_wcsrchr:PROC
_BSS	SEGMENT
	ALIGN	8

hPython3 DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_CheckPython3 DD imagerel $LN13
	DD	imagerel $LN13+40
	DD	imagerel $unwind$_Py_CheckPython3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$_Py_CheckPython3 DD imagerel $LN13+40
	DD	imagerel $LN13+212
	DD	imagerel $chain$0$_Py_CheckPython3
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$_Py_CheckPython3 DD imagerel $LN13+212
	DD	imagerel $LN13+358
	DD	imagerel $chain$2$_Py_CheckPython3
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$_Py_CheckPython3 DD 020021H
	DD	0487400H
	DD	imagerel $LN13
	DD	imagerel $LN13+40
	DD	imagerel $unwind$_Py_CheckPython3
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$_Py_CheckPython3 DD 020821H
	DD	0487408H
	DD	imagerel $LN13
	DD	imagerel $LN13+40
	DD	imagerel $unwind$_Py_CheckPython3
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_CheckPython3 DD 030901H
	DD	0460109H
	DD	03002H
xdata	ENDS
;	COMDAT ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'L', 00H, 'L', 00H, 's', 00H, '\', 00H, 'p', 00H
	DB	'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '3', 00H, '.'
	DB	00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'p', 00H, 'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H
	DB	'3', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT _Py_CheckPython3
_TEXT	SEGMENT
py3path$ = 32
_Py_CheckPython3 PROC					; COMDAT

; 802  : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H

; 803  :     wchar_t py3path[MAXPATHLEN+1];
; 804  :     wchar_t *s;
; 805  :     if (python3_checked)
; 806  :         return hPython3 != NULL;

  00009	33 db		 xor	 ebx, ebx
  0000b	39 1d 00 00 00
	00		 cmp	 DWORD PTR python3_checked, ebx
  00011	74 15		 je	 SHORT $LN3@Py_CheckPy
  00013	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR hPython3, rbx
  0001a	0f 95 c3	 setne	 bl
  0001d	8b c3		 mov	 eax, ebx

; 825  : }

  0001f	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
$LN3@Py_CheckPy:
  00028	48 89 bc 24 40
	02 00 00	 mov	 QWORD PTR [rsp+576], rdi

; 807  :     python3_checked = 1;

  00030	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR python3_checked, 1

; 808  : 
; 809  :     /* If there is a python3.dll next to the python3y.dll,
; 810  :        assume this is a build tree; use that DLL */
; 811  :     wcscpy(py3path, dllpath);

  0003a	48 8b cb	 mov	 rcx, rbx
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  00044	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL6@Py_CheckPy:
  00050	0f b7 04 11	 movzx	 eax, WORD PTR [rcx+rdx]
  00054	48 83 c1 02	 add	 rcx, 2
  00058	66 89 44 0c 1e	 mov	 WORD PTR py3path$[rsp+rcx-2], ax
  0005d	66 85 c0	 test	 ax, ax
  00060	75 ee		 jne	 SHORT $LL6@Py_CheckPy

; 812  :     s = wcsrchr(py3path, L'\\');

  00062	48 8d 4c 24 20	 lea	 rcx, QWORD PTR py3path$[rsp]
  00067	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsrchr

; 813  :     if (!s)

  00072	48 8d 7c 24 20	 lea	 rdi, QWORD PTR py3path$[rsp]

; 814  :         s = py3path;
; 815  :     wcscpy(s, L"\\python3.dll");

  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  0007e	48 85 c0	 test	 rax, rax
  00081	48 0f 45 f8	 cmovne	 rdi, rax
  00085	48 2b fa	 sub	 rdi, rdx
  00088	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@Py_CheckPy:
  00090	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00093	48 83 c2 02	 add	 rdx, 2
  00097	66 89 4c 17 fe	 mov	 WORD PTR [rdi+rdx-2], cx
  0009c	66 85 c9	 test	 cx, cx
  0009f	75 ef		 jne	 SHORT $LL7@Py_CheckPy

; 816  :     hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

  000a1	33 d2		 xor	 edx, edx
  000a3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR py3path$[rsp]
  000a8	44 8d 42 08	 lea	 r8d, QWORD PTR [rdx+8]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW
  000b2	48 89 05 00 00
	00 00		 mov	 QWORD PTR hPython3, rax

; 817  :     if (hPython3 != NULL)

  000b9	48 85 c0	 test	 rax, rax
  000bc	74 16		 je	 SHORT $LN1@Py_CheckPy

; 818  :         return 1;

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 825  : }

  000cb	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
$LN1@Py_CheckPy:

; 819  : 
; 820  :     /* Check sys.prefix\DLLs\python3.dll */
; 821  :     wcscpy(py3path, Py_GetPrefix());

  000d4	e8 00 00 00 00	 call	 Py_GetPrefix
  000d9	48 8d 54 24 20	 lea	 rdx, QWORD PTR py3path$[rsp]
  000de	48 2b d0	 sub	 rdx, rax
$LL8@Py_CheckPy:
  000e1	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  000e4	48 83 c0 02	 add	 rax, 2
  000e8	66 89 4c 02 fe	 mov	 WORD PTR [rdx+rax-2], cx
  000ed	66 85 c9	 test	 cx, cx
  000f0	75 ef		 jne	 SHORT $LL8@Py_CheckPy

; 822  :     wcscat(py3path, L"\\DLLs\\python3.dll");

  000f2	33 c0		 xor	 eax, eax
  000f4	48 83 c9 ff	 or	 rcx, -1
  000f8	48 8d 7c 24 20	 lea	 rdi, QWORD PTR py3path$[rsp]
  000fd	66 f2 af	 repne scasw
  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@

; 823  :     hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

  00107	33 d2		 xor	 edx, edx
  00109	48 89 47 fe	 mov	 QWORD PTR [rdi-2], rax
  0010d	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@+8
  00114	44 8d 42 08	 lea	 r8d, QWORD PTR [rdx+8]
  00118	48 89 47 06	 mov	 QWORD PTR [rdi+6], rax
  0011c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@+16
  00123	48 8d 4c 24 20	 lea	 rcx, QWORD PTR py3path$[rsp]
  00128	48 89 47 0e	 mov	 QWORD PTR [rdi+14], rax
  0012c	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@+24
  00133	48 89 47 16	 mov	 QWORD PTR [rdi+22], rax
  00137	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@+32
  0013d	89 47 1e	 mov	 DWORD PTR [rdi+30], eax
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW
  00146	48 8b bc 24 40
	02 00 00	 mov	 rdi, QWORD PTR [rsp+576]

; 824  :     return hPython3 != NULL;

  0014e	48 85 c0	 test	 rax, rax
  00151	48 89 05 00 00
	00 00		 mov	 QWORD PTR hPython3, rax
  00158	0f 95 c3	 setne	 bl
  0015b	8b c3		 mov	 eax, ebx

; 825  : }

  0015d	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  00164	5b		 pop	 rbx
  00165	c3		 ret	 0
_Py_CheckPython3 ENDP
_TEXT	ENDS
END
